<html><head></head><body>
		<div><h1 id="_idParaDest-18" class="chapter-number"><a id="_idTextAnchor017"/>1</h1>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Foundational Design Principles</h1>
			<p>Design principles form the foundation of any well-architected software. They serve as the guiding light that helps developers navigate the path of creating maintainable, scalable, and robust applications while avoiding the pitfalls of bad design.</p>
			<p>In this chapter, we will explore the core design principles that all developers should know and apply in their projects. We will explore four foundational principles. The first one, <em class="italic">Encapsulate What Varies</em>, teaches you how to isolate the parts of your code that are subject to change, making it easier to modify and extend your applications. Next, <em class="italic">Favor Composition</em>, makes you understand why it’s often better to assemble complex objects from simple ones rather than inheriting functionalities. The third one, <em class="italic">Program to Interfaces</em>, shows the power of coding to an interface rather than to a concrete class, enhancing flexibility and maintainability. Finally, with the <em class="italic">Loose Coupling</em> principle, you will grasp the importance of reducing dependencies between components, making your code easier to refactor and test.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Following the “Encapsulate What Varies” principle</li>
				<li>Following the “Favor Composition Over Inheritance” principle</li>
				<li>Following the “Program to Interfaces, Not Implementations” principle</li>
				<li>Following the “Loose Coupling” principle</li>
			</ul>
			<p>By the end of this chapter, you’ll have a solid understanding of these principles and how to implement them in Python, setting the foundation for the rest of the book.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Technical requirements</h1>
			<p>For the chapters in this book, you will need a running Python 3.12 environment, or for some exceptional cases in some chapters, 3.11.</p>
			<p>In addition, install the Mypy static type checker (<a href="https://www.mypy-lang.org">https://www.mypy-lang.org</a>) by running the following:</p>
			<pre class="console">
python3.12 –m pip install -–user mypy</pre>			<p>The examples are available in the GitHub repository here: <a href="https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition">https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition</a></p>
			<p class="callout-heading">About the Python executable</p>
			<p class="callout">Throughout the book, we will reference the Python executable for executing code examples as <code>python3.12</code> or <code>python</code>. Adapt that to your specific environment, practice and/or workflow. </p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Following the Encapsulate What Varies principle</h1>
			<p>One of <a id="_idIndexMarker000"/>the most common challenges in software development is dealing with change. Requirements evolve, technologies advance, and user needs also change. Therefore, it is crucial to write code that can adapt without causing a ripple effect of modifications throughout your program or application. This is where the principle of <em class="italic">Encapsulate What Varies</em> comes into play.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>What does it mean?</h2>
			<p>The idea behind this principle is straightforward: isolate the parts of your code that are most likely to change and encapsulate them. By doing so, you create a protective barrier that shields the rest of your code from these elements that are subject to change. This encapsulation allows you to make changes to one part of your system without affecting others.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Benefits</h2>
			<p>Encapsulating what varies <a id="_idIndexMarker001"/>provides several benefits, mainly the following:</p>
			<ul>
				<li><strong class="bold">Ease of maintenance</strong>: When changes are needed, you must only modify the encapsulated parts, reducing the risk of introducing bugs elsewhere</li>
				<li><strong class="bold">Enhanced flexibility</strong>: Encapsulated components can be easily swapped or extended, providing a more adaptable architecture</li>
				<li><strong class="bold">Improved readability</strong>: By isolating varying elements, your code becomes more organized and easier to understand</li>
			</ul>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Techniques for achieving encapsulation</h2>
			<p>As we <a id="_idIndexMarker002"/>introduced, encapsulation<a id="_idIndexMarker003"/> helps in data hiding and exposing only the necessary functionalities. Here, we will present key techniques that enhance encapsulation in Python: polymorphism and the <em class="italic">getters</em> and <em class="italic">setters</em> techniques.</p>
			<h3>Polymorphism</h3>
			<p>In programming, polymorphism <a id="_idIndexMarker004"/>allows objects of different classes to be treated as objects of a common superclass. It is one of the core concepts in <strong class="bold">object-oriented programming</strong> <strong class="bold">OOP</strong> that<a id="_idIndexMarker005"/> enables a single interface to represent different types. Polymorphism allows for implementing elegant software design patterns, such as the strategy pattern, and it’s a way to implement clean, maintainable code in Python.</p>
			<h3>Getters and Setters</h3>
			<p>These are <a id="_idIndexMarker006"/>special methods in a class that enable controlled access to attribute values. <em class="italic">getters</em> allow reading the values of attributes and <em class="italic">setters</em> enable modifying them. By using these methods, you can add validation logic or side effects such as logging, thus adhering to the principles of encapsulation. They provide a way to control and protect the state of an object and are particularly useful when you want to encapsulate complex attributes that are derived from other instance variables.</p>
			<p>And there is more. To <a id="_idIndexMarker007"/>complement the <em class="italic">getters</em> and <em class="italic">setters</em> technique, Python offers a more elegant approach known as the <em class="italic">property</em> technique. This is a built-in feature of Python that allows you to convert attribute access into method calls seamlessly. With properties, you can ensure that an object retains its internal state against incorrect or harmful manipulation without having to explicitly define <em class="italic">getter</em> and <em class="italic">setter</em> methods.</p>
			<p>The <code>@property</code> decorator<a id="_idIndexMarker008"/> allows you to define a method that is automatically invoked when an attribute is accessed, effectively serving as a <em class="italic">getter</em>. Similarly, the <code>@a<a id="_idTextAnchor024"/>ttribute_name.setter</code> decorator allows you to define a method that acts as a <em class="italic">setter</em>, invoked when you attempt to change the value of an attribute. This way, you can embed validation or other actions directly within these methods, making <a id="_idTextAnchor025"/>the code more clean.</p>
			<p>By using the <em class="italic">property</em> technique, you can achieve the same level of data encapsulation and validation as with <a id="_idIndexMarker009"/>traditional <em class="italic">Getters</em> and <em class="italic">Setters</em> but in a way that is more aligned with Python’s design philosophy. It allows you to write code that is not just functional but also <a id="_idIndexMarker010"/>clean and easy to read, enhancing both encapsulation and the overall quality of your Python programs.</p>
			<p>Next, we will better understand these techniques through examples.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>An example – encapsulating using polymorphism</h2>
			<p>Polymorphism<a id="_idIndexMarker011"/> is a powerful way to achieve encapsulation of varying behavior. Let’s see that with an example of a payment processing system where the payment method option can vary. In such a case, you might encapsulate each method of payment in its own class:</p>
			<ol>
				<li>You would first define the base class for payment methods, providing a <code>process_payment()</code> method that each specific payment method will implement. This is where we encapsulate what varies—the payment processing logic. That part of the code will be as follows:<pre class="source-code">
class PaymentBase:
    def __init__(self, amount: int):
        self.amount: int = amount
    def process_payment(self):
        pass</pre></li>				<li>Next, we introduce the <code>CreditCard</code> and <code>PayPal</code> classes, inheriting from <code>PaymentBase</code>, each providing their own implementation of <code>process_payment</code>. This is a classic way of polymorphism, as you can treat <code>CreditCard</code> and <code>PayPal</code> objects as instances of their common superclass. The code is as follows:<pre class="source-code">
class CreditCard(PaymentBase):
    def process_payment(self):
        msg = f"Credit card payment: {self.amount}"
        print(msg)
class PayPal(PaymentBase):
    def process_payment(self):
        msg = f"PayPal payment: {self.amount}"
        print(msg)</pre></li>				<li>To make it possible to test the classes we just created, let’s add some code, calling <code>process_payment()</code> for each object. The beauty of polymorphism is evident when you use these classes, as follows:<pre class="source-code">
if __name__ == "__main__":
    payments = [CreditCard(100), PayPal(200)]
    for payment in payments:
        payment.process_payment()</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker012"/>code for this example (<code>ch01/encapsulate.py</code>) is as follows:</p>
			<pre class="source-code">
class PaymentBase:
    def __init__(self, amount: int):
        self.amount: int = amount
    def process_payment(self):
        pass
class CreditCard(PaymentBase):
    def process_payment(self):
        msg = f"Credit card payment: {self.amount}"
        print(msg)
class PayPal(PaymentBase):
    def process_payment(self):
        msg = f"PayPal payment: {self.amount}"
        print(msg)
if __name__ == "__main__":
    payments = [CreditCard(100), PayPal(200)]
    for payment in payments:
        payment.process_payment()</pre>			<p>To test <a id="_idIndexMarker013"/>the code, run the following command:</p>
			<pre class="console">
python3.12 ch01/encapsulate.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Credit card payment: 100
PayPal payment: 200</pre>			<p>As you <a id="_idIndexMarker014"/>can see, when the payment method changes, the program adapts to produce the expected outcome.</p>
			<p>By encapsulating what varies—here, the<em class="italic"> payment method</em>—you can easily add new options or modify existing ones without affecting the core payment processing logic.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>An example – encapsulating using a property</h2>
			<p>Let’s<a id="_idIndexMarker015"/> define a <code>Circle</code> class and show how to use Python’s <code>@property</code> technique to create a <em class="italic">getter</em> and a <em class="italic">setter</em> for its <code>radius</code> attribute.</p>
			<p>Note that the underlying attribute would actually be called <code>_radius</code>, but it is hidden/protected behind the <em class="italic">property</em> called <code>radius</code>.</p>
			<p>Let’s write the code step by step:</p>
			<ol>
				<li>We start by defining the <code>Circle</code> class with its initialization method, where we initialize the <code>_radius</code> attribute as follows:<pre class="source-code">
class Circle:
    def __init__(self, radius: int):
        self._radius: int = radius</pre></li>				<li>We add the radius property: a <code>radius()</code> method where we return the value from the underlying attribute, decorated using the <code>@property</code> decorator, as follows:<pre class="source-code">
    @property
    def radius(self):
        return self._radius</pre></li>				<li>We add the radius setter part: another <code>radius()</code> method where we do the actual job of modifying the underlying attribute, after a validation check, since we do not want to allow a negative value for the radius; this method is decorated by the special <code>@radius.setter</code> decorator. This part of the code is as follows:<pre class="source-code">
    @radius.setter
    def radius(self, value: int):
        if value &lt; 0:
            raise ValueError("Radius cannot be negative!")
        self._radius = value</pre></li>				<li>Finally, we add some lines that will help us test the class, as follows:<pre class="source-code">
if __name__ == "__main__":
    circle = Circle(10)
    print(f"Initial radius: {circle.radius}")
    circle.radius = 15
    print(f"New radius: {circle.radius}")</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker016"/>code for this example (<code>ch01/encapsulate_bis.py</code>) is as follows:</p>
			<pre class="source-code">
class Circle:
    def __init__(self, radius: int):
        self._radius: int = radius
    @property
    def radius(self):
        return self._radius
    @radius.setter
    def radius(self, value: int):
        if value &lt; 0:
            raise ValueError("Radius cannot be negative!")
        self._radius = value
if __name__ == "__main__":
    circle = Circle(10)
    print(f"Initial radius: {circle.radius}")
    circle.radius = 15
    print(f"New radius: {circle.radius}")</pre>			<p>To test the<a id="_idIndexMarker017"/> example, run the following command:</p>
			<pre class="console">
python3.12 ch01/encapsulate_bis.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Initial radius: 10
New radius: 15</pre>			<p>In this second example, we saw how we can encapsulate the circle’s radius component so that we can change the technical aspects if needed, without breaking the class. For example, the validation code for the <em class="italic">setter</em> can evolve. We can even change the underlying attribute, <code>_radius</code>, and the behavior for the user of our code will remain unchanged.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/>Following the Favor Composition Over Inheritance principle</h1>
			<p>In OOP, it’s <a id="_idIndexMarker018"/>tempting to create complex hierarchies of classes through inheritance. While inheritance has its merits, it can lead to tightly coupled code that is hard to maintain and extend. This is where the principle of <em class="italic">Favor Composition Over Inheritance</em> comes into the picture.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>What does it mean?</h2>
			<p>This principle advises that you should prefer composing objects from simpler parts to inheriting functionalities from a base class. In other words, build complex objects by combining simpler ones.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>Benefits</h2>
			<p>Choosing <a id="_idIndexMarker019"/>composition over inheritance offers several advantages:</p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: Composition allows you to change objects’ behavior at runtime, making your code more adaptable</li>
				<li><strong class="bold">Reusability</strong>: Smaller, simpler objects can be reused across different parts of your application, promoting code reusability</li>
				<li><strong class="bold">Ease of maintenance</strong>: With composition, you can easily swap out or update individual components without affecting the overall system, avoiding border effects</li>
			</ul>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Techniques for composition</h2>
			<p>In Python, composition<a id="_idIndexMarker020"/> is often achieved through OOP by including instances of other classes within a class. This is sometimes referred to as a “has-a” relationship between the class that is being composed and the classes that are being included. Python makes it particularly easy to use composition by not requiring explicit type declarations. You can include other objects by simply instantiating them in the class’s <code>__init__</code> method or by passing them as parameters.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>An example – compose a car using the engine</h2>
			<p>In Python, you<a id="_idIndexMarker021"/> can use composition by including instances of other classes within your class. For example, consider a <code>Car</code> class that includes an instance of an <code>Engine</code> class:</p>
			<ol>
				<li>Let’s first define the <code>Engine</code> class as follows, with its <code>start</code> method:<pre class="source-code">
class Engine:
    def start(self):
        print("Engine started")</pre></li>				<li>Then, let’s define the <code>Car</code> class as follows:<pre class="source-code">
class Car:
    def __init__(self):
        self.engine = Engine()
    def start(self):
        self.engine.start()
        print("Car started")</pre></li>				<li>Finally, add the following lines of code to create an instance of the <code>Car</code> class and call the <code>start</code> method on that instance, when this program is executed:<pre class="source-code">
if __name__ == "__main__":
    my_car = Car()
    my_car.start()</pre></li>			</ol>
			<p>The complete code for this example (<code>ch01/composition.py</code>) is as follows:</p>
			<pre class="source-code">
class Engine:
    def start(self):
        print("Engine started")
class Car:
    def __init__(self):
        self.engine = Engine()
    def start(self):
        self.engine.start()
        print("Car started")
if __name__ == "__main__":
    my_car = Car()
    my_car.start()</pre>			<p>To<a id="_idIndexMarker022"/> test the code, run the following command:</p>
			<pre class="console">
python3.12 ch01/composition.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Engine started
Car started</pre>			<p>As you can see in this example, the <code>Car</code> class is composed of an <code>Engine</code> object, thanks to the <code>self.engine = Engine()</code> line, allowing you to easily swap out the engine for another type without altering the <code>Car</code> class itself.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Following the Program to Interfaces, Not Implementations principle</h1>
			<p>In software design, it’s easy <a id="_idIndexMarker023"/>to get caught up in the specifics of how a feature is implemented. However, focusing too much on implementation details can lead to code that is tightly coupled and difficult to modify. The principle of <em class="italic">Program to Interfaces, Not Implementations</em> offers a solution to this problem.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>What does it mean?</h2>
			<p>An interface defines a <strong class="bold">contract</strong> for classes, specifying a set of methods that must be implemented.</p>
			<p>This principle encourages you to code against an interface rather than a concrete class. By doing so, you untie your code from the specific classes that provide the required behavior, making it easier to swap or extend implementations without affecting the rest of the system.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Benefits</h2>
			<p>Programming to<a id="_idIndexMarker024"/> interfaces offers several benefits:</p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: You can easily switch between different implementations without altering the code that uses them</li>
				<li><strong class="bold">Maintainability</strong>: Losing your code from specific implementations makes it easier to update or replace components</li>
				<li><strong class="bold">Testability</strong>: Interfaces make it simpler to write unit tests, as you can easily mock the interface during testing</li>
			</ul>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Techniques for interfaces</h2>
			<p>In Python, <em class="italic">interfaces</em> can be <a id="_idIndexMarker025"/>implemented using two primary techniques: <strong class="bold">abstract base classes</strong> (<strong class="bold">ABCs</strong>) and protocols.</p>
			<h3>Abstract base classes</h3>
			<p><em class="italic">ABCs</em>, provided<a id="_idIndexMarker026"/> by the <code>abc</code> module, allow<a id="_idIndexMarker027"/> you to define <em class="italic">abstract methods</em> that must be implemented by any concrete (i.e., non-abstract) subclass.</p>
			<p>Let’s understand this concept with an example, where we will define an abstract class (for an interface) and then use it:</p>
			<ol>
				<li>First, we need to import the <code>ABC</code> class and the <code>abstractmethod</code> decorator function as follows:<pre class="source-code">
from abc import ABC, abstractmethod</pre></li>				<li>Then, we define the interface class as follows:<pre class="source-code">
class MyInterface(ABC):
    @abstractmethod
    def do_something(self, param: str):
        pass</pre></li>				<li>Now, define a concrete class for that interface; it inherits from the interface class and provides an implementation for the <code>do_something</code> method as follows:<pre class="source-code">
class MyClass(MyInterface):
    def do_something(self, param: str):
        print(f"Doing something with: '{param}'")</pre></li>				<li>Add the following lines for testing purposes:<pre class="source-code">
if __name__ == "__main__":
    MyClass().do_something("some param")</pre></li>			</ol>
			<p>The complete code (<code>ch01/abstractclass.py</code>) is as follows:</p>
			<pre class="source-code">
from abc import ABC, abstractmethod
class MyInterface(ABC):
    @abstractmethod
    def do_something(self, param: str):
        pass
class MyClass(MyInterface):
    def do_something(self, param: str):
        print(f"Doing something with: '{param}'")
if __name__ == "__main__":
    MyClass().do_something("some param")</pre>			<p>To<a id="_idIndexMarker028"/> test <a id="_idIndexMarker029"/>the code, run the following command:</p>
			<pre class="console">
python3.12 ch01/abstractclass.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Doing something with: 'some param'</pre>			<p>Now you know how to define an interface and a concrete class implementing that interface in Python.</p>
			<h3>Protocols</h3>
			<p>Introduced in <a id="_idIndexMarker030"/>Python 3.8 via the <code>typing</code> module, <em class="italic">Protocols</em> offer a more flexible approach than ABCs, known as <em class="italic">structural duck typing</em>, where an object is considered valid if it has certain attributes or methods, regardless of its actual inheritance.</p>
			<p>Unlike traditional duck typing, where type compatibility is determined at runtime, structural duck typing allows for type checking at compile time. This means that you can catch type errors before your code even runs (while in your IDE, for example), making your programs more robust and easier to debug.</p>
			<p>The key advantage<a id="_idIndexMarker031"/> of using <em class="italic">Protocols</em> is that they focus on what an object can do, rather than what it is. In other words, <em class="italic">if an object walks like a duck and quacks like a duck, it’s a duck</em>, regardless of its actual inheritance hierarchy. This is particularly useful in a dynamically typed language such as Python, where an object’s behavior is more important than its actual type.</p>
			<p>For example, you can define a <code>Drawable</code> protocol that requires a <code>draw()</code> method. Any class that implements this method would implicitly satisfy the protocol without having to explicitly inherit from it.</p>
			<p>Here’s a quick example to illustrate the concept. Let’s say you need a Protocol named <code>Flyer</code> that requires a <code>fly()</code> method. You can define it as follows:</p>
			<pre class="source-code">
from typing import Protocol
class Flyer(Protocol):
    def fly(self) -&gt; None:
        ...</pre>			<p>And that’s it! Now, any class that has a <code>fly()</code> method would be considered <code>Flyer</code>, whether it explicitly inherits from the <code>Flyer</code> class or not. This is a powerful feature that allows you to write more generic and reusable code and adheres to the principle of composition over inheritance, a principle that we previously discussed in the <em class="italic">Following the “Favor Composition Over Inheritance” </em><em class="italic">principle</em> section.</p>
			<p>In a later example, we will see a practical use of Protocols.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>An example – different types of logger</h2>
			<p>Using ABCs, let’s<a id="_idIndexMarker032"/> create a logging interface that allows for different types of logging mechanisms. Here’s how you could implement that:</p>
			<ol>
				<li>Import what is needed from <code>abc</code>:<pre class="source-code">
from abc import ABC, abstractmethod</pre></li>				<li>Define the <code>Logger</code> interface with a <code>log</code> method:<pre class="source-code">
class Logger(ABC):
    @abstractmethod
    def log(self, message: str):
        pass</pre></li>				<li>Then, define<a id="_idIndexMarker033"/> two concrete classes that implement the <code>Logger</code> interface for two different types of <code>Logger</code>:<pre class="source-code">
class ConsoleLogger(Logger):
    def log(self, message: str):
        print(f"Console: {message}")
class FileLogger(Logger):
    def log(self, message: str):
        with open("log.txt", "a") as f:
            f.write(f"File: {message}\n")</pre></li>				<li>Next, to use each type of logger, define a function as follows:<pre class="source-code">
def log_message(logger: Logger, message: str):
    logger.log(message)</pre><p class="list-inset">Notice that the function takes as its first argument an object of type <code>Logger</code>, meaning an instance of a concrete class that implements the <code>Logger</code> interface (i.e., <code>ConsoleLogger</code> or <code>FileLogger</code>).</p></li>				<li>Finally, add the lines needed to test the code, calling the <code>log_message</code> function as follows:<pre class="source-code">
if __name__ == "__main__":
    log_message(ConsoleLogger(), "A console log.")
    log_message(FileLogger(), "A file log.")</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker034"/>code for this example (<code>ch01/interfaces.py</code>) is as follows:</p>
			<pre class="source-code">
from abc import ABC, abstractmethod
class Logger(ABC):
    @abstractmethod
    def log(self, message: str):
        pass
class ConsoleLogger(Logger):
    def log(self, message: str):
        print(f"Console: {message}")
class FileLogger(Logger):
    def log(self, message: str):
        with open("log.txt", "a") as f:
            f.write(f"File: {message}\n")
def log_message(logger: Logger, message: str):
    logger.log(message)
if __name__ == "__main__":
    log_message(ConsoleLogger(), "A console log.")
    log_message(FileLogger(), "A file log.")</pre>			<p>To test the <a id="_idIndexMarker035"/>code, run the following command:</p>
			<pre class="console">
python3.12 ch01/interfaces.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Console: A console log.</pre>			<p>In addition to that output, looking in the folder from which you run the command, you will find that a file called <code>log.txt</code> has been created, containing the following line:</p>
			<pre class="source-code">
File: A file log.</pre>			<p>As you just saw with the <code>log_message</code> function, you can easily switch between different logging mechanisms without changing the function itse<a id="_idTextAnchor038"/>lf.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>An example – different types of logger, now using Protocols</h2>
			<p>Let’s revisit the <a id="_idIndexMarker036"/>previous example with the <em class="italic">Protocols </em>way of defining interfaces:</p>
			<ol>
				<li>First, we need to import the <code>Protocol</code> class as follows:<pre class="source-code">
from typing import Protocol</pre></li>				<li>Then, defining the <code>Logger</code> interface is done by inheriting from the <code>Protocol</code> class as follows:<pre class="source-code">
class Logger(Protocol):
    def log(self, message: str):
        ...</pre><p class="list-inset">And the rest of the code stays unchanged.</p></li>			</ol>
			<p>So, the <a id="_idIndexMarker037"/>complete code (<code>ch01/interfaces_bis.py</code>) is as follows:</p>
			<pre class="source-code">
from typing import Protocol
class Logger(Protocol):
    def log(self, message: str):
        ...
class ConsoleLogger:
    def log(self, message: str):
        print(f"Console: {message}")
class FileLogger:
    def log(self, message: str):
        with open("log.txt", "a") as f:
            f.write(f"File: {message}\n")
def log_message(logger: Logger, message: str):
    logger.log(message)
if __name__ == "__main__":
    log_message(ConsoleLogger(), "A console log.")
    log_message(FileLogger(), "A file log.")</pre>			<p>To<a id="_idIndexMarker038"/> check the static typing of the code based on the protocol we defined, run the following command:</p>
			<pre class="console">
mypy ch01/interfaces_bis.py</pre>			<p>You should get the following output:</p>
			<pre class="console">
Success: no issues found in 1 source file</pre>			<p>To test the code, run the following command:</p>
			<pre class="console">
python3.12 ch01/interfaces_bis.py</pre>			<p>You should get the same result as when running the previous version—in other words, the <code>log.txt</code> file created and the following output in the shell:</p>
			<pre class="console">
Console: A console log.</pre>			<p>This is normal since the only thing we changed is the way we define the interface. And, the effect of the interface (the protocol) is not enforced at runtime, meaning it does not change the actual result of the code execution.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor040"/>Following the Loose Coupling principle</h1>
			<p>As software <a id="_idIndexMarker039"/>grows in complexity, the relationships between its components can become tangled, leading to a system that is hard to understand, maintain, and extend. The principle of <em class="italic">Loose Coupling</em> aims to mitigate this issue.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor041"/>What does it mean?</h2>
			<p><em class="italic">Loose coupling</em> refers<a id="_idIndexMarker040"/> to minimizing the dependencies between different parts of a program. In a loosely coupled system, components are independent and interact through well-defined interfaces, making it easier to make changes to one part without affecting others.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/>Benefits</h2>
			<p>Loose coupling offers<a id="_idIndexMarker041"/> several advantages:</p>
			<ul>
				<li><strong class="bold">Maintainability</strong>: With fewer dependencies, it’s easier to update or replace individual components</li>
				<li><strong class="bold">Extensibility</strong>: A loosely coupled system can be more easily extended with new features or components</li>
				<li><strong class="bold">Testability</strong>: Independent components are easier to test in isolation, improving the overall quality of your software</li>
			</ul>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>Techniques for loose coupling</h2>
			<p>Two primary<a id="_idIndexMarker042"/> techniques for achieving <em class="italic">loose coupling</em> are <strong class="bold">dependency injection</strong> and the <strong class="bold">observer pattern</strong>. <em class="italic">Dependency injection</em> allows<a id="_idIndexMarker043"/> a component to receive its dependencies from an external source rather than creating them, making it easier to swap or mock these<a id="_idIndexMarker044"/> dependencies. The <em class="italic">observer pattern</em>, on the other hand, allows an object to publish changes to its state so that other objects can react accordingly, without being tightly bound to each other.</p>
			<p>Both techniques aim to reduce the interdependencies between components, making the system you are building more modular and easier to manage.</p>
			<p>We will discuss the <em class="italic">observer pattern</em> in detail in <a href="B21896_05.xhtml#_idTextAnchor121"><em class="italic">Chapter 5</em></a>, <em class="italic">Behavioral Design Patterns</em>. For now, let’s study an example to understand how to use the <em class="italic">dependency </em><em class="italic">injection</em> technique.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>An example – a message service</h2>
			<p>In Python, you<a id="_idIndexMarker045"/> can achieve loose coupling by using <em class="italic">dependency injection</em>. Let’s see a simple example involving a <code>MessageService</code> class:</p>
			<ol>
				<li>First, we define the <code>MessageService</code> class as follows:<pre class="source-code">
class MessageService:
    def __init__(self, sender):
        self.sender = sender
    def send_message(self, message):
        self.sender.send(message)</pre><p class="list-inset">As you can see, the class will be initialized by passing a sender object to it; that object has a <code>send</code> method to allow sending messages.</p></li>				<li>Second, let’s define an <code>EmailSender</code> class:<pre class="source-code">
class EmailSender:
    def send(self, message):
        print(f"Sending email: {message}")</pre></li>				<li>Third, let’s define an <code>SMSSender</code> class:<pre class="source-code">
class SMSSender:
    def send(self, message):
        print(f"Sending SMS: {message}")</pre></li>				<li>Now we can instantiate <code>MessageService</code> using an <code>EmailSender</code> object and use it to send a message. We can also instantiate <code>MessageService</code> using an <code>SMSSender</code> object instead. We add code to test both actions as follows:<pre class="source-code">
if __name__ == "__main__":
    email_service = MessageService(EmailSender())
    email_service.send_message("Hello via Email")
    sms_service = MessageService(SMSSender())
    sms_service.send_message("Hello via SMS")</pre></li>			</ol>
			<p>The complete<a id="_idIndexMarker046"/> code for this example, saved in the <code>ch01/loose_coupling.py</code> file, is as follows:</p>
			<pre class="source-code">
class MessageService:
    def __init__(self, sender):
        self.sender = sender
    def send_message(self, message: str):
        self.sender.send(message)
class EmailSender:
    def send(self, message: str):
        print(f"Sending email: {message}")
class SMSSender:
    def send(self, message: str):
        print(f"Sending SMS: {message}")
if __name__ == "__main__":
    email_service = MessageService(EmailSender())
    email_service.send_message("Hello via Email")
    sms_service = MessageService(SMSSender())
    sms_service.send_message("Hello via SMS")</pre>			<p>To test the code, run the following command:</p>
			<pre class="console">
python3.12 ch01/loose_coupling.py</pre>			<p>You should <a id="_idIndexMarker047"/>get the following output:</p>
			<pre class="console">
Sending email: Hello via Email
Sending SMS: Hello via SMS</pre>			<p>In this example, <code>MessageService</code> is loosely coupled with <code>EmailSender</code> and <code>SMSSender</code> through dependency injection. This allows you to easily switch between different sending mechanisms without modifying the <code>MessageService</code> class.</p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor045"/>Summary</h1>
			<p>We began the book with the foundational design principles that developers should follow for writing maintainable, flexible, and robust software. From encapsulating what varies to favoring composition, programming to interfaces, and aiming for loose coupling, these principles provide a strong foundation for any Python developer.</p>
			<p>As you’ve seen, these principles are not just theoretical constructs but practical guidelines that can significantly improve the quality of your code. They set the stage for what comes next: diving deeper into more specialized sets of principles that guide object-oriented design.</p>
			<p>In the next chapter, we will delve into the SOLID principles, a set of five design principles aimed at making software designs more understandable, flexible, and maintainable.</p>
		</div>
	</body></html>