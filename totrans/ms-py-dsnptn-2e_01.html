<html><head></head><body>
		<div id="_idContainer007">
			<h1 id="_idParaDest-18" class="chapter-number"><a id="_idTextAnchor017"/>1</h1>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Foundational Design Principles</h1>
			<p>Design principles form the foundation of any well-architected software. They serve as the guiding light that helps developers navigate the path of creating maintainable, scalable, and robust applications while avoiding the pitfalls of <span class="No-Break">bad design.</span></p>
			<p>In this chapter, we will explore the core design principles that all developers should know and apply in their projects. We will explore four foundational principles. The first one, <em class="italic">Encapsulate What Varies</em>, teaches you how to isolate the parts of your code that are subject to change, making it easier to modify and extend your applications. Next, <em class="italic">Favor Composition</em>, makes you understand why it’s often better to assemble complex objects from simple ones rather than inheriting functionalities. The third one, <em class="italic">Program to Interfaces</em>, shows the power of coding to an interface rather than to a concrete class, enhancing flexibility and maintainability. Finally, with the <em class="italic">Loose Coupling</em> principle, you will grasp the importance of reducing dependencies between components, making your code easier to refactor <span class="No-Break">and test.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Following the “Encapsulate What <span class="No-Break">Varies” principle</span></li>
				<li>Following the “Favor Composition Over <span class="No-Break">Inheritance” principle</span></li>
				<li>Following the “Program to Interfaces, Not <span class="No-Break">Implementations” principle</span></li>
				<li>Following the “Loose <span class="No-Break">Coupling” principle</span></li>
			</ul>
			<p>By the end of this chapter, you’ll have a solid understanding of these principles and how to implement them in Python, setting the foundation for the rest of <span class="No-Break">the book.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Technical requirements</h1>
			<p>For the chapters in this book, you will need a running Python 3.12 environment, or for some exceptional cases in some <span class="No-Break">chapters, 3.11.</span></p>
			<p>In addition, install the Mypy static type checker (<a href="https://www.mypy-lang.org">https://www.mypy-lang.org</a>) by running <span class="No-Break">the following:</span></p>
			<pre class="console">
python3.12 –m pip install -–user mypy</pre>			<p>The examples are available in the GitHub repository <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition"><span class="No-Break">https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition</span></a></p>
			<p class="callout-heading">About the Python executable</p>
			<p class="callout">Throughout the book, we will reference the Python executable for executing code examples as <strong class="source-inline">python3.12</strong> or <strong class="source-inline">python</strong>. Adapt that to your specific environment, practice and/or workflow. </p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Following the Encapsulate What Varies principle</h1>
			<p>One of <a id="_idIndexMarker000"/>the most common challenges in software development is dealing with change. Requirements evolve, technologies advance, and user needs also change. Therefore, it is crucial to write code that can adapt without causing a ripple effect of modifications throughout your program or application. This is where the principle of <em class="italic">Encapsulate What Varies</em> comes <span class="No-Break">into play.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>What does it mean?</h2>
			<p>The idea behind this principle is straightforward: isolate the parts of your code that are most likely to change and encapsulate them. By doing so, you create a protective barrier that shields the rest of your code from these elements that are subject to change. This encapsulation allows you to make changes to one part of your system without <span class="No-Break">affecting others.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Benefits</h2>
			<p>Encapsulating what varies <a id="_idIndexMarker001"/>provides several benefits, mainly <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Ease of maintenance</strong>: When changes are needed, you must only modify the encapsulated parts, reducing the risk of introducing <span class="No-Break">bugs elsewhere</span></li>
				<li><strong class="bold">Enhanced flexibility</strong>: Encapsulated components can be easily swapped or extended, providing a more <span class="No-Break">adaptable architecture</span></li>
				<li><strong class="bold">Improved readability</strong>: By isolating varying elements, your code becomes more organized and easier <span class="No-Break">to understand</span></li>
			</ul>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Techniques for achieving encapsulation</h2>
			<p>As we <a id="_idIndexMarker002"/>introduced, encapsulation<a id="_idIndexMarker003"/> helps in data hiding and exposing only the necessary functionalities. Here, we will present key techniques that enhance encapsulation in Python: polymorphism and the <em class="italic">getters</em> and <span class="No-Break"><em class="italic">setters</em></span><span class="No-Break"> techniques.</span></p>
			<h3>Polymorphism</h3>
			<p>In programming, polymorphism <a id="_idIndexMarker004"/>allows objects of different classes to be treated as objects of a common superclass. It is one of the core concepts in <strong class="bold">object-oriented programming</strong> <strong class="bold">OOP</strong> that<a id="_idIndexMarker005"/> enables a single interface to represent different types. Polymorphism allows for implementing elegant software design patterns, such as the strategy pattern, and it’s a way to implement clean, maintainable code <span class="No-Break">in Python.</span></p>
			<h3>Getters and Setters</h3>
			<p>These are <a id="_idIndexMarker006"/>special methods in a class that enable controlled access to attribute values. <em class="italic">getters</em> allow reading the values of attributes and <em class="italic">setters</em> enable modifying them. By using these methods, you can add validation logic or side effects such as logging, thus adhering to the principles of encapsulation. They provide a way to control and protect the state of an object and are particularly useful when you want to encapsulate complex attributes that are derived from other <span class="No-Break">instance variables.</span></p>
			<p>And there is more. To <a id="_idIndexMarker007"/>complement the <em class="italic">getters</em> and <em class="italic">setters</em> technique, Python offers a more elegant approach known as the <em class="italic">property</em> technique. This is a built-in feature of Python that allows you to convert attribute access into method calls seamlessly. With properties, you can ensure that an object retains its internal state against incorrect or harmful manipulation without having to explicitly define <em class="italic">getter</em> and <span class="No-Break"><em class="italic">setter</em></span><span class="No-Break"> methods.</span></p>
			<p>The <strong class="source-inline">@property</strong> decorator<a id="_idIndexMarker008"/> allows you to define a method that is automatically invoked when an attribute is accessed, effectively serving as a <em class="italic">getter</em>. Similarly, the <strong class="source-inline">@a<a id="_idTextAnchor024"/>ttribute_name.setter</strong> decorator allows you to define a method that acts as a <em class="italic">setter</em>, invoked when you attempt to change the value of an attribute. This way, you can embed validation or other actions directly within these methods, making <a id="_idTextAnchor025"/>the code <span class="No-Break">more clean.</span></p>
			<p>By using the <em class="italic">property</em> technique, you can achieve the same level of data encapsulation and validation as with <a id="_idIndexMarker009"/>traditional <em class="italic">Getters</em> and <em class="italic">Setters</em> but in a way that is more aligned with Python’s design philosophy. It allows you to write code that is not just functional but also <a id="_idIndexMarker010"/>clean and easy to read, enhancing both encapsulation and the overall quality of your <span class="No-Break">Python programs.</span></p>
			<p>Next, we will better understand these techniques <span class="No-Break">through examples.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>An example – encapsulating using polymorphism</h2>
			<p>Polymorphism<a id="_idIndexMarker011"/> is a powerful way to achieve encapsulation of varying behavior. Let’s see that with an example of a payment processing system where the payment method option can vary. In such a case, you might encapsulate each method of payment in its <span class="No-Break">own class:</span></p>
			<ol>
				<li>You would first define the base class for payment methods, providing a <strong class="source-inline">process_payment()</strong> method that each specific payment method will implement. This is where we encapsulate what varies—the payment processing logic. That part of the code will be <span class="No-Break">as follows:</span><pre class="source-code">
class PaymentBase:
    def __init__(self, amount: int):
        self.amount: int = amount
    def process_payment(self):
        pass</pre></li>				<li>Next, we introduce the <strong class="source-inline">CreditCard</strong> and <strong class="source-inline">PayPal</strong> classes, inheriting from <strong class="source-inline">PaymentBase</strong>, each providing their own implementation of <strong class="source-inline">process_payment</strong>. This is a classic way of polymorphism, as you can treat <strong class="source-inline">CreditCard</strong> and <strong class="source-inline">PayPal</strong> objects as instances of their common superclass. The code is <span class="No-Break">as follows:</span><pre class="source-code">
class CreditCard(PaymentBase):
    def process_payment(self):
        msg = f"Credit card payment: {self.amount}"
        print(msg)
class PayPal(PaymentBase):
    def process_payment(self):
        msg = f"PayPal payment: {self.amount}"
        print(msg)</pre></li>				<li>To make it possible to test the classes we just created, let’s add some code, calling <strong class="source-inline">process_payment()</strong> for each object. The beauty of polymorphism is evident when you use these classes, <span class="No-Break">as follows:</span><pre class="source-code">
if __name__ == "__main__":
    payments = [CreditCard(100), PayPal(200)]
    for payment in payments:
        payment.process_payment()</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker012"/>code for this example (<strong class="source-inline">ch01/encapsulate.py</strong>) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class PaymentBase:
    def __init__(self, amount: int):
        self.amount: int = amount
    def process_payment(self):
        pass
class CreditCard(PaymentBase):
    def process_payment(self):
        msg = f"Credit card payment: {self.amount}"
        print(msg)
class PayPal(PaymentBase):
    def process_payment(self):
        msg = f"PayPal payment: {self.amount}"
        print(msg)
if __name__ == "__main__":
    payments = [CreditCard(100), PayPal(200)]
    for payment in payments:
        payment.process_payment()</pre>			<p>To test <a id="_idIndexMarker013"/>the code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/encapsulate.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Credit card payment: 100
PayPal payment: 200</pre>			<p>As you <a id="_idIndexMarker014"/>can see, when the payment method changes, the program adapts to produce the <span class="No-Break">expected outcome.</span></p>
			<p>By encapsulating what varies—here, the<em class="italic"> payment method</em>—you can easily add new options or modify existing ones without affecting the core payment <span class="No-Break">processing logic.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>An example – encapsulating using a property</h2>
			<p>Let’s<a id="_idIndexMarker015"/> define a <strong class="source-inline">Circle</strong> class and show how to use Python’s <strong class="source-inline">@property</strong> technique to create a <em class="italic">getter</em> and a <em class="italic">setter</em> for its <span class="No-Break"><strong class="source-inline">radius</strong></span><span class="No-Break"> attribute.</span></p>
			<p>Note that the underlying attribute would actually be called <strong class="source-inline">_radius</strong>, but it is hidden/protected behind the <em class="italic">property</em> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">radius</strong></span><span class="No-Break">.</span></p>
			<p>Let’s write the code step <span class="No-Break">by step:</span></p>
			<ol>
				<li>We start by defining the <strong class="source-inline">Circle</strong> class with its initialization method, where we initialize the <strong class="source-inline">_radius</strong> attribute <span class="No-Break">as follows:</span><pre class="source-code">
class Circle:
    def __init__(self, radius: int):
        self._radius: int = radius</pre></li>				<li>We add the radius property: a <strong class="source-inline">radius()</strong> method where we return the value from the underlying attribute, decorated using the <strong class="source-inline">@property</strong> decorator, <span class="No-Break">as follows:</span><pre class="source-code">
    @property
    def radius(self):
        return self._radius</pre></li>				<li>We add the radius setter part: another <strong class="source-inline">radius()</strong> method where we do the actual job of modifying the underlying attribute, after a validation check, since we do not want to allow a negative value for the radius; this method is decorated by the special <strong class="source-inline">@radius.setter</strong> decorator. This part of the code is <span class="No-Break">as follows:</span><pre class="source-code">
    @radius.setter
    def radius(self, value: int):
        if value &lt; 0:
            raise ValueError("Radius cannot be negative!")
        self._radius = value</pre></li>				<li>Finally, we add some lines that will help us test the class, <span class="No-Break">as follows:</span><pre class="source-code">
if __name__ == "__main__":
    circle = Circle(10)
    print(f"Initial radius: {circle.radius}")
    circle.radius = 15
    print(f"New radius: {circle.radius}")</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker016"/>code for this example (<strong class="source-inline">ch01/encapsulate_bis.py</strong>) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Circle:
    def __init__(self, radius: int):
        self._radius: int = radius
    @property
    def radius(self):
        return self._radius
    @radius.setter
    def radius(self, value: int):
        if value &lt; 0:
            raise ValueError("Radius cannot be negative!")
        self._radius = value
if __name__ == "__main__":
    circle = Circle(10)
    print(f"Initial radius: {circle.radius}")
    circle.radius = 15
    print(f"New radius: {circle.radius}")</pre>			<p>To test the<a id="_idIndexMarker017"/> example, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/encapsulate_bis.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Initial radius: 10
New radius: 15</pre>			<p>In this second example, we saw how we can encapsulate the circle’s radius component so that we can change the technical aspects if needed, without breaking the class. For example, the validation code for the <em class="italic">setter</em> can evolve. We can even change the underlying attribute, <strong class="source-inline">_radius</strong>, and the behavior for the user of our code will <span class="No-Break">remain unchanged.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/>Following the Favor Composition Over Inheritance principle</h1>
			<p>In OOP, it’s <a id="_idIndexMarker018"/>tempting to create complex hierarchies of classes through inheritance. While inheritance has its merits, it can lead to tightly coupled code that is hard to maintain and extend. This is where the principle of <em class="italic">Favor Composition Over Inheritance</em> comes into <span class="No-Break">the picture.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>What does it mean?</h2>
			<p>This principle advises that you should prefer composing objects from simpler parts to inheriting functionalities from a base class. In other words, build complex objects by combining <span class="No-Break">simpler ones.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>Benefits</h2>
			<p>Choosing <a id="_idIndexMarker019"/>composition over inheritance offers <span class="No-Break">several advantages:</span></p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: Composition allows you to change objects’ behavior at runtime, making your code <span class="No-Break">more adaptable</span></li>
				<li><strong class="bold">Reusability</strong>: Smaller, simpler objects can be reused across different parts of your application, promoting <span class="No-Break">code reusability</span></li>
				<li><strong class="bold">Ease of maintenance</strong>: With composition, you can easily swap out or update individual components without affecting the overall system, avoiding <span class="No-Break">border effects</span></li>
			</ul>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Techniques for composition</h2>
			<p>In Python, composition<a id="_idIndexMarker020"/> is often achieved through OOP by including instances of other classes within a class. This is sometimes referred to as a “has-a” relationship between the class that is being composed and the classes that are being included. Python makes it particularly easy to use composition by not requiring explicit type declarations. You can include other objects by simply instantiating them in the class’s <strong class="source-inline">__init__</strong> method or by passing them <span class="No-Break">as parameters.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>An example – compose a car using the engine</h2>
			<p>In Python, you<a id="_idIndexMarker021"/> can use composition by including instances of other classes within your class. For example, consider a <strong class="source-inline">Car</strong> class that includes an instance of an <span class="No-Break"><strong class="source-inline">Engine</strong></span><span class="No-Break"> class:</span></p>
			<ol>
				<li>Let’s first define the <strong class="source-inline">Engine</strong> class as follows, with its <span class="No-Break"><strong class="source-inline">start</strong></span><span class="No-Break"> method:</span><pre class="source-code">
class Engine:
    def start(self):
        print("Engine started")</pre></li>				<li>Then, let’s define the <strong class="source-inline">Car</strong> class <span class="No-Break">as follows:</span><pre class="source-code">
class Car:
    def __init__(self):
        self.engine = Engine()
    def start(self):
        self.engine.start()
        print("Car started")</pre></li>				<li>Finally, add the following lines of code to create an instance of the <strong class="source-inline">Car</strong> class and call the <strong class="source-inline">start</strong> method on that instance, when this program <span class="No-Break">is executed:</span><pre class="source-code">
if __name__ == "__main__":
    my_car = Car()
    my_car.start()</pre></li>			</ol>
			<p>The complete code for this example (<strong class="source-inline">ch01/composition.py</strong>) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Engine:
    def start(self):
        print("Engine started")
class Car:
    def __init__(self):
        self.engine = Engine()
    def start(self):
        self.engine.start()
        print("Car started")
if __name__ == "__main__":
    my_car = Car()
    my_car.start()</pre>			<p>To<a id="_idIndexMarker022"/> test the code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/composition.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Engine started
Car started</pre>			<p>As you can see in this example, the <strong class="source-inline">Car</strong> class is composed of an <strong class="source-inline">Engine</strong> object, thanks to the <strong class="source-inline">self.engine = Engine()</strong> line, allowing you to easily swap out the engine for another type without altering the <strong class="source-inline">Car</strong> <span class="No-Break">class itself.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Following the Program to Interfaces, Not Implementations principle</h1>
			<p>In software design, it’s easy <a id="_idIndexMarker023"/>to get caught up in the specifics of how a feature is implemented. However, focusing too much on implementation details can lead to code that is tightly coupled and difficult to modify. The principle of <em class="italic">Program to Interfaces, Not Implementations</em> offers a solution to <span class="No-Break">this problem.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>What does it mean?</h2>
			<p>An interface defines a <strong class="bold">contract</strong> for classes, specifying a set of methods that must <span class="No-Break">be implemented.</span></p>
			<p>This principle encourages you to code against an interface rather than a concrete class. By doing so, you untie your code from the specific classes that provide the required behavior, making it easier to swap or extend implementations without affecting the rest of <span class="No-Break">the system.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Benefits</h2>
			<p>Programming to<a id="_idIndexMarker024"/> interfaces offers <span class="No-Break">several benefits:</span></p>
			<ul>
				<li><strong class="bold">Flexibility</strong>: You can easily switch between different implementations without altering the code that <span class="No-Break">uses them</span></li>
				<li><strong class="bold">Maintainability</strong>: Losing your code from specific implementations makes it easier to update or <span class="No-Break">replace components</span></li>
				<li><strong class="bold">Testability</strong>: Interfaces make it simpler to write unit tests, as you can easily mock the interface <span class="No-Break">during testing</span></li>
			</ul>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Techniques for interfaces</h2>
			<p>In Python, <em class="italic">interfaces</em> can be <a id="_idIndexMarker025"/>implemented using two primary techniques: <strong class="bold">abstract base classes</strong> (<strong class="bold">ABCs</strong>) <span class="No-Break">and protocols.</span></p>
			<h3>Abstract base classes</h3>
			<p><em class="italic">ABCs</em>, provided<a id="_idIndexMarker026"/> by the <strong class="source-inline">abc</strong> module, allow<a id="_idIndexMarker027"/> you to define <em class="italic">abstract methods</em> that must be implemented by any concrete (i.e., <span class="No-Break">non-abstract) subclass.</span></p>
			<p>Let’s understand this concept with an example, where we will define an abstract class (for an interface) and then <span class="No-Break">use it:</span></p>
			<ol>
				<li>First, we need to import the <strong class="source-inline">ABC</strong> class and the <strong class="source-inline">abstractmethod</strong> decorator function <span class="No-Break">as follows:</span><pre class="source-code">
from abc import ABC, abstractmethod</pre></li>				<li>Then, we define the interface class <span class="No-Break">as follows:</span><pre class="source-code">
class MyInterface(ABC):
    @abstractmethod
    def do_something(self, param: str):
        pass</pre></li>				<li>Now, define a concrete class for that interface; it inherits from the interface class and provides an implementation for the <strong class="source-inline">do_something</strong> method <span class="No-Break">as follows:</span><pre class="source-code">
class MyClass(MyInterface):
    def do_something(self, param: str):
        print(f"Doing something with: '{param}'")</pre></li>				<li>Add the following lines for <span class="No-Break">testing purposes:</span><pre class="source-code">
if __name__ == "__main__":
    MyClass().do_something("some param")</pre></li>			</ol>
			<p>The complete code (<strong class="source-inline">ch01/abstractclass.py</strong>) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from abc import ABC, abstractmethod
class MyInterface(ABC):
    @abstractmethod
    def do_something(self, param: str):
        pass
class MyClass(MyInterface):
    def do_something(self, param: str):
        print(f"Doing something with: '{param}'")
if __name__ == "__main__":
    MyClass().do_something("some param")</pre>			<p>To<a id="_idIndexMarker028"/> test <a id="_idIndexMarker029"/>the code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/abstractclass.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Doing something with: 'some param'</pre>			<p>Now you know how to define an interface and a concrete class implementing that interface <span class="No-Break">in Python.</span></p>
			<h3>Protocols</h3>
			<p>Introduced in <a id="_idIndexMarker030"/>Python 3.8 via the <strong class="source-inline">typing</strong> module, <em class="italic">Protocols</em> offer a more flexible approach than ABCs, known as <em class="italic">structural duck typing</em>, where an object is considered valid if it has certain attributes or methods, regardless of its <span class="No-Break">actual inheritance.</span></p>
			<p>Unlike traditional duck typing, where type compatibility is determined at runtime, structural duck typing allows for type checking at compile time. This means that you can catch type errors before your code even runs (while in your IDE, for example), making your programs more robust and easier <span class="No-Break">to debug.</span></p>
			<p>The key advantage<a id="_idIndexMarker031"/> of using <em class="italic">Protocols</em> is that they focus on what an object can do, rather than what it is. In other words, <em class="italic">if an object walks like a duck and quacks like a duck, it’s a duck</em>, regardless of its actual inheritance hierarchy. This is particularly useful in a dynamically typed language such as Python, where an object’s behavior is more important than its <span class="No-Break">actual type.</span></p>
			<p>For example, you can define a <strong class="source-inline">Drawable</strong> protocol that requires a <strong class="source-inline">draw()</strong> method. Any class that implements this method would implicitly satisfy the protocol without having to explicitly inherit <span class="No-Break">from it.</span></p>
			<p>Here’s a quick example to illustrate the concept. Let’s say you need a Protocol named <strong class="source-inline">Flyer</strong> that requires a <strong class="source-inline">fly()</strong> method. You can define it <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from typing import Protocol
class Flyer(Protocol):
    def fly(self) -&gt; None:
        ...</pre>			<p>And that’s it! Now, any class that has a <strong class="source-inline">fly()</strong> method would be considered <strong class="source-inline">Flyer</strong>, whether it explicitly inherits from the <strong class="source-inline">Flyer</strong> class or not. This is a powerful feature that allows you to write more generic and reusable code and adheres to the principle of composition over inheritance, a principle that we previously discussed in the <em class="italic">Following the “Favor Composition Over Inheritance” </em><span class="No-Break"><em class="italic">principle</em></span><span class="No-Break"> section.</span></p>
			<p>In a later example, we will see a practical use <span class="No-Break">of Protocols.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>An example – different types of logger</h2>
			<p>Using ABCs, let’s<a id="_idIndexMarker032"/> create a logging interface that allows for different types of logging mechanisms. Here’s how you could <span class="No-Break">implement that:</span></p>
			<ol>
				<li>Import what is needed <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">abc</strong></span><span class="No-Break">:</span><pre class="source-code">
from abc import ABC, abstractmethod</pre></li>				<li>Define the <strong class="source-inline">Logger</strong> interface with a <span class="No-Break"><strong class="source-inline">log</strong></span><span class="No-Break"> method:</span><pre class="source-code">
class Logger(ABC):
    @abstractmethod
    def log(self, message: str):
        pass</pre></li>				<li>Then, define<a id="_idIndexMarker033"/> two concrete classes that implement the <strong class="source-inline">Logger</strong> interface for two different types <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Logger</strong></span><span class="No-Break">:</span><pre class="source-code">
class ConsoleLogger(Logger):
    def log(self, message: str):
        print(f"Console: {message}")
class FileLogger(Logger):
    def log(self, message: str):
        with open("log.txt", "a") as f:
            f.write(f"File: {message}\n")</pre></li>				<li>Next, to use each type of logger, define a function <span class="No-Break">as follows:</span><pre class="source-code">
def log_message(logger: Logger, message: str):
    logger.log(message)</pre><p class="list-inset">Notice that the function takes as its first argument an object of type <strong class="source-inline">Logger</strong>, meaning an instance of a concrete class that implements the <strong class="source-inline">Logger</strong> interface (i.e., <strong class="source-inline">ConsoleLogger</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">FileLogger</strong></span><span class="No-Break">).</span></p></li>				<li>Finally, add the lines needed to test the code, calling the <strong class="source-inline">log_message</strong> function <span class="No-Break">as follows:</span><pre class="source-code">
if __name__ == "__main__":
    log_message(ConsoleLogger(), "A console log.")
    log_message(FileLogger(), "A file log.")</pre></li>			</ol>
			<p>The complete <a id="_idIndexMarker034"/>code for this example (<strong class="source-inline">ch01/interfaces.py</strong>) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from abc import ABC, abstractmethod
class Logger(ABC):
    @abstractmethod
    def log(self, message: str):
        pass
class ConsoleLogger(Logger):
    def log(self, message: str):
        print(f"Console: {message}")
class FileLogger(Logger):
    def log(self, message: str):
        with open("log.txt", "a") as f:
            f.write(f"File: {message}\n")
def log_message(logger: Logger, message: str):
    logger.log(message)
if __name__ == "__main__":
    log_message(ConsoleLogger(), "A console log.")
    log_message(FileLogger(), "A file log.")</pre>			<p>To test the <a id="_idIndexMarker035"/>code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/interfaces.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Console: A console log.</pre>			<p>In addition to that output, looking in the folder from which you run the command, you will find that a file called <strong class="source-inline">log.txt</strong> has been created, containing the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
File: A file log.</pre>			<p>As you just saw with the <strong class="source-inline">log_message</strong> function, you can easily switch between different logging mechanisms without changing the <span class="No-Break">function itse<a id="_idTextAnchor038"/>lf.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>An example – different types of logger, now using Protocols</h2>
			<p>Let’s revisit the <a id="_idIndexMarker036"/>previous example with the <em class="italic">Protocols </em>way of <span class="No-Break">defining interfaces:</span></p>
			<ol>
				<li>First, we need to import the <strong class="source-inline">Protocol</strong> class <span class="No-Break">as follows:</span><pre class="source-code">
from typing import Protocol</pre></li>				<li>Then, defining the <strong class="source-inline">Logger</strong> interface is done by inheriting from the <strong class="source-inline">Protocol</strong> class <span class="No-Break">as follows:</span><pre class="source-code">
class Logger(Protocol):
    def log(self, message: str):
        ...</pre><p class="list-inset">And the rest of the code <span class="No-Break">stays unchanged.</span></p></li>			</ol>
			<p>So, the <a id="_idIndexMarker037"/>complete code (<strong class="source-inline">ch01/interfaces_bis.py</strong>) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from typing import Protocol
class Logger(Protocol):
    def log(self, message: str):
        ...
class ConsoleLogger:
    def log(self, message: str):
        print(f"Console: {message}")
class FileLogger:
    def log(self, message: str):
        with open("log.txt", "a") as f:
            f.write(f"File: {message}\n")
def log_message(logger: Logger, message: str):
    logger.log(message)
if __name__ == "__main__":
    log_message(ConsoleLogger(), "A console log.")
    log_message(FileLogger(), "A file log.")</pre>			<p>To<a id="_idIndexMarker038"/> check the static typing of the code based on the protocol we defined, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
mypy ch01/interfaces_bis.py</pre>			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Success: no issues found in 1 source file</pre>			<p>To test the code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/interfaces_bis.py</pre>			<p>You should get the same result as when running the previous version—in other words, the <strong class="source-inline">log.txt</strong> file created and the following output in <span class="No-Break">the shell:</span></p>
			<pre class="console">
Console: A console log.</pre>			<p>This is normal since the only thing we changed is the way we define the interface. And, the effect of the interface (the protocol) is not enforced at runtime, meaning it does not change the actual result of the <span class="No-Break">code execution.</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor040"/>Following the Loose Coupling principle</h1>
			<p>As software <a id="_idIndexMarker039"/>grows in complexity, the relationships between its components can become tangled, leading to a system that is hard to understand, maintain, and extend. The principle of <em class="italic">Loose Coupling</em> aims to mitigate <span class="No-Break">this issue.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor041"/>What does it mean?</h2>
			<p><em class="italic">Loose coupling</em> refers<a id="_idIndexMarker040"/> to minimizing the dependencies between different parts of a program. In a loosely coupled system, components are independent and interact through well-defined interfaces, making it easier to make changes to one part without <span class="No-Break">affecting others.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/>Benefits</h2>
			<p>Loose coupling offers<a id="_idIndexMarker041"/> <span class="No-Break">several advantages:</span></p>
			<ul>
				<li><strong class="bold">Maintainability</strong>: With fewer dependencies, it’s easier to update or replace <span class="No-Break">individual components</span></li>
				<li><strong class="bold">Extensibility</strong>: A loosely coupled system can be more easily extended with new features <span class="No-Break">or components</span></li>
				<li><strong class="bold">Testability</strong>: Independent components are easier to test in isolation, improving the overall quality of <span class="No-Break">your software</span></li>
			</ul>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>Techniques for loose coupling</h2>
			<p>Two primary<a id="_idIndexMarker042"/> techniques for achieving <em class="italic">loose coupling</em> are <strong class="bold">dependency injection</strong> and the <strong class="bold">observer pattern</strong>. <em class="italic">Dependency injection</em> allows<a id="_idIndexMarker043"/> a component to receive its dependencies from an external source rather than creating them, making it easier to swap or mock these<a id="_idIndexMarker044"/> dependencies. The <em class="italic">observer pattern</em>, on the other hand, allows an object to publish changes to its state so that other objects can react accordingly, without being tightly bound to <span class="No-Break">each other.</span></p>
			<p>Both techniques aim to reduce the interdependencies between components, making the system you are building more modular and easier <span class="No-Break">to manage.</span></p>
			<p>We will discuss the <em class="italic">observer pattern</em> in detail in <a href="B21896_05.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Behavioral Design Patterns</em>. For now, let’s study an example to understand how to use the <em class="italic">dependency </em><span class="No-Break"><em class="italic">injection</em></span><span class="No-Break"> technique.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>An example – a message service</h2>
			<p>In Python, you<a id="_idIndexMarker045"/> can achieve loose coupling by using <em class="italic">dependency injection</em>. Let’s see a simple example involving a <span class="No-Break"><strong class="source-inline">MessageService</strong></span><span class="No-Break"> class:</span></p>
			<ol>
				<li>First, we define the <strong class="source-inline">MessageService</strong> class <span class="No-Break">as follows:</span><pre class="source-code">
class MessageService:
    def __init__(self, sender):
        self.sender = sender
    def send_message(self, message):
        self.sender.send(message)</pre><p class="list-inset">As you can see, the class will be initialized by passing a sender object to it; that object has a <strong class="source-inline">send</strong> method to allow <span class="No-Break">sending messages.</span></p></li>				<li>Second, let’s define an <span class="No-Break"><strong class="source-inline">EmailSender</strong></span><span class="No-Break"> class:</span><pre class="source-code">
class EmailSender:
    def send(self, message):
        print(f"Sending email: {message}")</pre></li>				<li>Third, let’s define an <span class="No-Break"><strong class="source-inline">SMSSender</strong></span><span class="No-Break"> class:</span><pre class="source-code">
class SMSSender:
    def send(self, message):
        print(f"Sending SMS: {message}")</pre></li>				<li>Now we can instantiate <strong class="source-inline">MessageService</strong> using an <strong class="source-inline">EmailSender</strong> object and use it to send a message. We can also instantiate <strong class="source-inline">MessageService</strong> using an <strong class="source-inline">SMSSender</strong> object instead. We add code to test both actions <span class="No-Break">as follows:</span><pre class="source-code">
if __name__ == "__main__":
    email_service = MessageService(EmailSender())
    email_service.send_message("Hello via Email")
    sms_service = MessageService(SMSSender())
    sms_service.send_message("Hello via SMS")</pre></li>			</ol>
			<p>The complete<a id="_idIndexMarker046"/> code for this example, saved in the <strong class="source-inline">ch01/loose_coupling.py</strong> file, is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class MessageService:
    def __init__(self, sender):
        self.sender = sender
    def send_message(self, message: str):
        self.sender.send(message)
class EmailSender:
    def send(self, message: str):
        print(f"Sending email: {message}")
class SMSSender:
    def send(self, message: str):
        print(f"Sending SMS: {message}")
if __name__ == "__main__":
    email_service = MessageService(EmailSender())
    email_service.send_message("Hello via Email")
    sms_service = MessageService(SMSSender())
    sms_service.send_message("Hello via SMS")</pre>			<p>To test the code, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
python3.12 ch01/loose_coupling.py</pre>			<p>You should <a id="_idIndexMarker047"/>get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Sending email: Hello via Email
Sending SMS: Hello via SMS</pre>			<p>In this example, <strong class="source-inline">MessageService</strong> is loosely coupled with <strong class="source-inline">EmailSender</strong> and <strong class="source-inline">SMSSender</strong> through dependency injection. This allows you to easily switch between different sending mechanisms without modifying the <span class="No-Break"><strong class="source-inline">MessageService</strong></span><span class="No-Break"> class.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor045"/>Summary</h1>
			<p>We began the book with the foundational design principles that developers should follow for writing maintainable, flexible, and robust software. From encapsulating what varies to favoring composition, programming to interfaces, and aiming for loose coupling, these principles provide a strong foundation for any <span class="No-Break">Python developer.</span></p>
			<p>As you’ve seen, these principles are not just theoretical constructs but practical guidelines that can significantly improve the quality of your code. They set the stage for what comes next: diving deeper into more specialized sets of principles that guide <span class="No-Break">object-oriented design.</span></p>
			<p>In the next chapter, we will delve into the SOLID principles, a set of five design principles aimed at making software designs more understandable, flexible, <span class="No-Break">and maintainable.</span></p>
		</div>
	</body></html>