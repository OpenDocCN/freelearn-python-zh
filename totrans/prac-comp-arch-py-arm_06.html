<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-75" class="chapter-number" lang="en-GB"><a id="_idTextAnchor075"/>5</h1>&#13;
			<h1 id="_idParaDest-76" lang="en-GB"><a id="_idTextAnchor076"/>A Little More Python</h1>&#13;
			<p lang="en-GB">We’ve introduced Python and we’ve been using it. In this chapter we increase our knowledge of Python and extend some of the concepts we have encountered, and also introduce new features. In particular, we examine data structures, starting with the way in which lists of elements or strings of characters can be processed. This chapter paves the way for <a href="B19624_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a><em class="italic">,</em> where we complete the design of a computer simulator. But, before that, we provide a note on the terminology we use when discussing features of Python.</p>&#13;
			<p lang="en-GB">We will discuss the following topics:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Statements and expressions</li>&#13;
				<li lang="en-GB">More string features</li>&#13;
				<li lang="en-GB">List comprehensions</li>&#13;
				<li lang="en-GB">String processing</li>&#13;
				<li lang="en-GB">Repetition and looping</li>&#13;
				<li lang="en-GB">The dictionary</li>&#13;
				<li lang="en-GB">Functions</li>&#13;
				<li lang="en-GB">Lists of lists</li>&#13;
				<li lang="en-GB">Imports</li>&#13;
				<li lang="en-GB">Indenting in Python</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-77" lang="en-GB"><a id="_idTextAnchor077"/>Technical requirements</h1>&#13;
			<p lang="en-GB">You can find the programs used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05</a>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This chapter requires no new resources in addition to previous chapters. All that is required is a computer with a Python IDE. The same is true of all chapters until we reach <a href="B19624_09.xhtml#_idTextAnchor159"><em class="italic">Chapter 9</em></a>, which deals with Raspberry Pi.</p>&#13;
			<p class="callout-heading" lang="en-GB">Statements and Expressions</p>&#13;
			<p class="callout" lang="en-GB">An <em class="italic">expression</em> is a <a id="_idIndexMarker287"/>combination of values and operators that can be evaluated to provide a result; for example <code>(p+q)*7 - r</code>. A Boolean expression is a combination of values and logical operators that yields the value <code>True</code> or <code>False</code>; for example, <code>p &gt; </code><code>q</code>.</p>&#13;
			<p class="callout" lang="en-GB">A <em class="italic">statement</em> is a <a id="_idIndexMarker288"/>Python operation that must be evaluated by an interpreter; that is, it’s an action. Typical Python statements involve <code>if</code>… <code>for</code>… actions. These two terms are often used in formal definitions; for example, the definition of an <code>if</code> statement is as follows:</p>&#13;
			<p class="callout" lang="en-GB"><code>if &lt;expr&gt;:</code></p>&#13;
			<p class="callout" lang="en-GB">   <code>&lt;</code><code>statement&gt;</code></p>&#13;
			<p class="callout" lang="en-GB">Angle brackets are used in descriptions of the language to indicate <em class="italic">something that will be replaced by its actual value</em>; for example, a valid <code>if</code> statement is as follows:</p>&#13;
			<p class="callout" lang="en-GB"><code>if x &gt; </code><code>y:</code></p>&#13;
			<p class="callout" lang="en-GB">    <code>p = p + q</code></p>&#13;
			<p class="callout" lang="en-GB">In this case the <em class="italic">expression</em> is <code>x &gt; y</code> and the <em class="italic">statement</em> is <code>p = p + </code><code>q</code>.</p>&#13;
			<h1 id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor078"/>More string features</h1>&#13;
			<p lang="en-GB">Now we’re going to<a id="_idIndexMarker289"/> extend our ability to manipulate strings. The string is one of Python’s most important data structures and is at the heart of all the programs we write in this book. Python’s string-handling facilities make it one of the most powerful and easy-to-use text-processing languages. A string is indicated by quotes, which may be either single or double; for example, <code>x = "Two"</code> and <code>y = 'One'</code> are Python strings. Python’s ability to use two string terminators means that we can create strings like “Alan’s book” (i.e., use the apostrophe as a normal grammar element).</p>&#13;
			<p lang="en-GB">During the execution of a Python program, you can read a string from the keyboard and also provide a prompt in the following way.</p>&#13;
			<p lang="en-GB"><code>x = input(' Please type </code><code>something ')</code></p>&#13;
			<p lang="en-GB">Executing this command displays '<code>Please type something</code>' on the screen, waits for your input, and then assigns the string you typed to variable <code>x</code>. This mechanism is very useful when <a id="_idIndexMarker290"/>simulating a program, because you can provide input as the program runs. Note that the input string must be terminated by hitting the <em class="italic">Enter</em> key.</p>&#13;
			<h1 id="_idParaDest-79" lang="en-GB"><a id="_idTextAnchor079"/>String processing</h1>&#13;
			<p lang="en-GB">You can change (substitute) characters in a<a id="_idIndexMarker291"/> string by using the method <code>replace</code>. For example, suppose we wish to replace all occurrences of <code>'$'</code> in the string <code>price</code> with <code>'£'</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
price =  'eggs $2, cheese $4'</pre>&#13;
			<pre class="source-code">price = price.<strong class="bold">replace</strong>('$', '£')      # Replace $ by £ in the string price</pre>&#13;
			<p lang="en-GB">If we print <code>price</code>, we now get<code> 'eggs £2, </code><code>cheese £4'</code>.</p>&#13;
			<p lang="en-GB">Other string methods are <code>upper()</code> (convert text to upper case), <code>lstrip()</code> (remove leading characters), and <code>rstrip()</code> (remove trailing characters). Let <code>x ='###this Is A test???'</code>. Consider the following sequence:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = x.lstrip('#')      # Remove left-hand leading '#' characters to get x = 'this Is A test???'&#13;
x = x.rstrip('?')      # Remove right-hand trailing '?' characters to get x = 'this Is A test'&#13;
x = x.lower()          # Convert to lower-case to get x = 'this is a test'</pre>&#13;
			<p lang="en-GB">This sequence produces <code>x </code>= '<code>this is is </code><code>a test'</code>.</p>&#13;
			<p lang="en-GB">Strings are <em class="italic">immutable</em>. You cannot change them once they are defined. In the preceding code, it looks as if we have modified x by removing leading and trailing characters and converting upper case to lower case. No! In each case we have created a <em class="italic">new</em> string with the same name as the old string (i.e., x).</p>&#13;
			<p lang="en-GB">If you were to enter <code>y =</code> '<code>Allen</code>' and try to edit it to read '<code>Allan</code>' by changing the '<code>e</code>' to '<code>a</code>' using the expression <code>y[3] = </code>'<code>a</code>', you would get an error, because you would have tried to change an immutable string. However, you could legally write <code>y = y[0:3] + 'a' + y[4]</code> to create a new string <code>y</code> with the value <code>'Allan'</code>.</p>&#13;
			<p lang="en-GB">The addition symbol, +, performs addition in <em class="italic">arithmetic</em> and <em class="italic">concatenation</em> in string processing; for example, <code>x = 4 + 5</code> gives <code>9</code>, whereas <code>x = '4' + '5'</code> gives <code>'45'</code>. This action is called <em class="italic">operator overloading</em> and indicates the extension of a function, when, for example, the function is applied to different objects.</p>&#13;
			<p lang="en-GB">The TC1 assembler uses<a id="_idIndexMarker292"/> the following string methods to remove spaces before an instruction, enable users to employ upper- or lower-case, and allow the use of a space or comma as a separator. For example, this code fragment lets you write either <code>r0,[r1]</code> or <code>R0,R1</code> with the same meaning. The code below shows how TC1 takes a line of the input (i.e., an assembly instruction) and simplifies it for later conversion to binary:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    line = line.replace(',',' ')     # Allow use of a space or comma to separate operands&#13;
    line = line.replace('[','')      # Allow LDRI r0,[r2] or LDRI r0,r2 First remove '['&#13;
    line = line.replace(']','')      # Replace ']' by null string.&#13;
    line = line.upper()              # Let's force lower- to upper-case&#13;
    line = line.lstrip(' ')          # Remove leading spaces&#13;
    line = line.rstrip('\n')         # Remove end of line chars. End-of-line is \n</pre>&#13;
			<p lang="en-GB">Suppose an instruction is entered in string form as '<code>   ADD r0,R1,r3</code>'. This has leading spaces, upper- and lower-case text and commas, and is converted to <code>'ADD R0 R1 R3'</code> by the above <a id="_idIndexMarker293"/>sequence of operations. The next step is to convert the string into individual <em class="italic">tokens</em> for analysis by the assembler. We can do this with the <code>split()</code> method. which converts a string into a list of strings separated by the character in the parentheses. Note that the default parameter is a space. If <code>s = 'ADD R0 R1 R2'</code>, then <code>s.split()</code> or <code>s.split(' ')</code> results in this:</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>s = ['ADD', 'R1', 'R2', 'R3']</code>      # A list of four tokens, each of which is a string</p>&#13;
			<p lang="en-GB">We now have a list consisting of four separate strings; that is, a command followed by three parameters. We can access each of these strings using index notation:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
T1 = s[0]                       # This is the mnemonic 'ADD'&#13;
T2 = s[1]                       # This is the destination register 'R1'&#13;
T3 = s[2]                       # This is the first source register 'R2'&#13;
T4 = s[3]                       # This is the second source register 'R3'</pre>&#13;
			<p lang="en-GB">We can now perform operations on the tokens:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if T1 == 'STOP': then run = 0   # If the instruction is stop then halt processing&#13;
firstReg = int(T2[1:])          # Get the register number as an integer</pre>&#13;
			<p lang="en-GB">The second statement uses <code>T2[1:]</code> to convert string <code>'R2'</code> into a new string <code>'2'</code> by removing the first character. The slice notation <code>[1:]</code> is interpreted as "All characters following the first." This lets us deal with one- or two-digit values like R2 or R23. Since there are only 8 registers, we could have written <code>[1:2]</code>. Using <code>[1:]</code> allows the extension 16 registers in a future version of TC1 without changing the code.</p>&#13;
			<p lang="en-GB">We have to use<a id="_idIndexMarker294"/> the <em class="italic">integer </em>function <code>int</code> to convert the register number from a string into its value as an integer. When learning Python, a common mistake is to forget to convert a string to an integer:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
regNum = input('Please enter register number &gt;&gt;&gt;')&#13;
contents = reg[regNum]</pre>&#13;
			<p lang="en-GB">This code would generate an error. Because <code>regNum</code> is created as a string, holding the value you typed. However, in the second line, the program is expecting an integer as a list index. You have to write <code>reg[int(regNum)]</code> to convert the numeric string into an integer value.</p>&#13;
			<h2 id="_idParaDest-80" lang="en-GB"><a id="_idTextAnchor080"/>Example – text Input</h2>&#13;
			<p lang="en-GB">Here’s a simple example of text input<a id="_idIndexMarker295"/> with Python using a simple <code>.txt</code> file. The source file is this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
@ This is text&#13;
NOP&#13;
 NOP&#13;
NOP&#13;
NOP</pre>&#13;
			<pre class="source-code">END</pre>&#13;
			<p lang="en-GB">This file was processed by Python as follows. I use the address it had on my computer. This is read into a variable <code>sFile</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
myFile = 'E:\\ArchitectureWithPython\\testText.txt'&#13;
with open(myFile,'r') as sFile:&#13;
    sFile = sFile.readlines()           # Open the source program&#13;
print (sFile)</pre>&#13;
			<p lang="en-GB">The output from this code fragment is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
['@ This is text\n', 'NOP\n', ' NOP\n', ' \n', 'NOP\n', '\n', 'NOP\n', 'END']</pre>&#13;
			<p lang="en-GB">We now have a Python list of strings, each corresponding to one line of the source text. Note that each line <a id="_idIndexMarker296"/>ends with an end-of-line (i.e., \n) and any spaces in the text are included. For example, there’s a totally empty line and an empty line with a space. We have to take account of these when dealing with the input.</p>&#13;
			<p lang="en-GB">Having increased our ability to manipulate text strings, in the next section we look at one of Python’s most interesting features: the facility to perform a sequence of operations on a string or a list in just one line of code with list comprehension.</p>&#13;
			<h1 id="_idParaDest-81" lang="en-GB"><a id="_idTextAnchor081"/>List comprehensions</h1>&#13;
			<p lang="en-GB">We now <a id="_idIndexMarker297"/>introduce a very powerful feature of Python, the <em class="italic">list comprehension</em>. It’s not powerful because of what it can do, but because of how succinct it is. A list comprehension lets you take a list and process it in a single line. We take a look at list comprehensions, because they are so useful in processing text; for example, you can use a list comprehension to take a line of text and replace all double-spaces with single spaces, or convert all lower-case characters to upper-case characters.</p>&#13;
			<p lang="en-GB">List comprehensions can be applied to any iterable. An iterable is a structure that you can step through, such <a id="_idIndexMarker298"/>as a list, a string, or a tuple. The simplest form of list comprehension is this:</p>&#13;
			<p lang="en-GB"><code>x = </code>[<code>i </code>for<code> i </code>in<code> y</code>]</p>&#13;
			<p lang="en-GB">Here, <code>x</code> and <code>y</code> are strings (or lists). The text in bold represents Python reserved words and punctuation. The variable <code>i</code> is a user-chosen variable used to step through the list. We could have used any name instead of <em class="italic">i</em>; it simply doesn’t matter. Consider the following example:</p>&#13;
			<p lang="en-GB"><code>lettersList = [i for i </code><code>in 'Tuesday']</code></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The iterable being processed is the string <code>'Tuesday'</code> and it is copied a character at a time to <code>lettersList</code>. This returns <code>lettersList</code> as the list of characters <code>[</code>'<code>T','u','e','s','d','a','y']</code>. We have turned a string into a list of characters.</p>&#13;
			<p lang="en-GB">We can create a more sophisticated version of the list comprehension as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = [expression for i in y if condition]</pre>&#13;
			<p lang="en-GB">where <code>expression</code> is a Python expression, and <code>condition</code> is a Boolean condition. We step through the iterable, <code>y</code>, looking at each element and selecting it subject to a condition, processing it <a id="_idIndexMarker299"/>according to the expression, and then putting it in a new list. That’s an awful lot of work in a single line. Consider this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
y = 'this$is$a$test'&#13;
x = [i for i in y if i != '$']</pre>&#13;
			<p lang="en-GB">The <a id="_idIndexMarker300"/>condition is <em class="italic">if item i from y is not equal to ‘$’ </em>. This list comprehension says, "Copy the characters in string y to string x, one-by-one, as long as the character isn’t a <code>'$'</code> character." The result is this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x =['t', 'h', 'i', 's', 'i', 's', 'a', 't', 'e', 's', 't'].</pre>&#13;
			<p lang="en-GB">The original string has been replaced by a list of single-character strings, but with every <code>'$'</code> removed.</p>&#13;
			<p lang="en-GB">Let’s look at three examples of list comprehensions:</p>&#13;
			<ol>&#13;
				<li lang="en-GB">The first example <a id="_idIndexMarker301"/>demonstrates how empty lines (i.e., '') can be removed from the input. We can copy all lines apart from those equal to the null or empty string " "with:<pre class="source-code">sFile = [i for i in sFile if i != '']   # Remove blank lines</pre></li>&#13;
			</ol>&#13;
			<p lang="en-GB">We’ve renamed the new list the same as the old one. There’s no reason why we can’t do this and it saves having to invent a new name for each of the list comprehensions.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="2">The second example is this:<pre class="source-code">sFile = [i.upper() for i in sFile]      # Convert to upper-case</pre></li>&#13;
			</ol>&#13;
			<p lang="en-GB">We apply the function <code>.upper()</code> to each element <code>i</code>. This expression converts a lower-case character into its upper-case equivalent; that is, it converts all strings to upper-case. The last list comprehension is this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile = [i.split() for i in sFile if i != '']</pre>&#13;
			<p lang="en-GB">The expression <code>i.split()</code> divides the source string into individual tokens (strings) at each space. This means we can then then process the line as a sequence of tokens. The condition <code>if i != ''</code> is used to remove empty strings by not copying them.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="3">The third example removes empty lines.</li>&#13;
			</ol>&#13;
			<p lang="en-GB">We’ve created a list of three instructions that has empty lines in it, denoted by ' '. When we execute this list comprehension, we convert each string into a sublist and we<a id="_idIndexMarker302"/> remove the empty lines:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile = ['ADD R1 R2 R3', 'BEQ LOOP', '', 'LDRL R2 4','']&#13;
sFile = [i.split() for i in sFile if i != '']</pre>&#13;
			<pre class="source-code">print(sFile)</pre>&#13;
			<p lang="en-GB">The output from this code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
[['ADD', 'R1', 'R2', 'R3'], ['BEQ', 'LOOP'], ['LDRL', 'R2', '4']]</pre>&#13;
			<h2 id="_idParaDest-82" lang="en-GB"><a id="_idTextAnchor082"/>The tuple</h2>&#13;
			<p lang="en-GB">We now introduce the tuple for the<a id="_idIndexMarker303"/> sake of completeness, although we make little use of it in this text. A list<a id="_idIndexMarker304"/> is a sequence of elements enclosed by square brackets; for example, <code>P = [1,4,8,9]</code>. A tuple is a sequence of elements separated by round brackets; for example, <code>Q = (</code><code>1,4,8,9)</code>.</p>&#13;
			<p lang="en-GB">There is little difference between a tuple and a list; they are both data structures that hold a sequence of elements. However, a <em class="italic">tuple is immutable</em> and cannot be modified, unlike a list. A tuple is a read-only list and is used when you wish to store data that does not change. Although not relevant here, tuples do have implementation and performance advantages over lists; that is, if you have a list that is fixed, it is better to use a tuple.</p>&#13;
			<p lang="en-GB">Later, we will use tuples in dictionary structures, as here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
opCodes = {'add':<strong class="bold">(2,34)</strong>, 'inc':<strong class="bold">(4,37)</strong>}</pre>&#13;
			<p lang="en-GB">In this case, the values <a id="_idIndexMarker305"/>in bold are each two-component tuples. We could have used a list, but the tuple indicates a fixed structure that cannot change. If you were to use a list instead of a tuple, you would write this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
opCodes = {'add':[<strong class="bold">2,34]</strong>, 'inc':[<strong class="bold">4,37]</strong>}</pre>&#13;
			<h2 id="_idParaDest-83" lang="en-GB"><a id="_idTextAnchor083"/>Repetition and looping</h2>&#13;
			<p lang="en-GB">We now expand our knowledge of Python’s repetition mechanism, a feature <a id="_idIndexMarker306"/>common to all high-level procedural languages. In this section we learn how to do the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Repeat an action multiple times</li>&#13;
				<li lang="en-GB">Use different data and parameters each time you carry out the action</li>&#13;
				<li lang="en-GB">Iterate over elements in a list</li>&#13;
				<li lang="en-GB">Use the <code>enumerate</code> function</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Suppose we want to test whether a list includes a particular item. We can create a <code>for</code> loop to do this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
fruit1 = ['apples', 'oranges', 'grapes', 'bananas', 'peaches']&#13;
size = len(fruit1)               # Get length of the list&#13;
inList = False                   # inList is False until we find item&#13;
for i in range (0,size):         # Repeat for each item in list&#13;
    if fruit1[i] == 'grapes':</pre>&#13;
			<pre class="source-code">        inList = True            # Set flag to True if we find the item</pre>&#13;
			<p lang="en-GB">This code first sets <code>inList</code> to <code>False</code> to indicate that the element <code>'grapes'</code> has not been found. The <code>for</code> loop steps though all elements in the list, testing each one for the item we’re looking for. If it is found, <code>inList</code> is set to <code>True</code>. This code works, but it is not good. If there are a million elements in the list and grapes the first one, the code still steps through the remaining 999,999 elements. This is horribly inefficient.</p>&#13;
			<p lang="en-GB">In the following example, we compare successive elements with a value, and stop if we find it. On each cycle, if the item is not found, we continue. If we find what we want, we jump out of the loop rather than continuing to the bitter end by testing every single item. When we do the comparison, if the current item is <em class="italic">not</em> equal to '<code>grapes'</code>, we set <code>inList</code> to <code>False</code> and the loop continues with the next element.</p>&#13;
			<p lang="en-GB">If we find <code>'grapes'</code>, the <code>else</code> part of the <code>if</code> statement sets <code>inList</code> to <code>True</code> and then uses a <code>break</code> statement to exit the loop and avoid further pointless cycles round the loop. A <code>break</code> in a <code>for</code> or <code>while</code> loop tells Python to exit the loop now and continue <a id="_idIndexMarker307"/>with the next instruction <em class="italic">after</em> the loop:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
listSize = len(fruit1)&#13;
for i in range (0,listSize):&#13;
    if fruit1[i] != 'grapes': inList = False   # Is the item here?"&#13;
    else:                                      # If it is, drop out of the loop&#13;
        inList = True                          # Set flag on finding it&#13;
        break                                  # Jump out of the loop</pre>&#13;
			<p lang="en-GB">The variable <code>inList</code> is just a flag that we can use later in the program; for example, we could write this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if inList == False: print('Yes, we have no grapes')&#13;
if inList == True:  print('Grapes --- we got lots')</pre>&#13;
			<p lang="en-GB">Another approach is to use the list operator <code>in</code>. If we have a list, we can check whether an item is a member of that list by using the following construct:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if    'grapes' in fruit1:&#13;
      inList = True&#13;
else: inList = False</pre>&#13;
			<p lang="en-GB">The first line returns <code>True</code> if <code>'grapes'</code> is in the list <code>fruit1</code>, and <code>False</code> otherwise. The <code>in</code> construct is very useful in testing whether an item belongs to a group of other items arranged as a list; for example, if all employees are in the list <code>staff</code>, then</p>&#13;
			<p lang="en-GB">sets <code>worksHere</code> to <code>True</code> if <code>Smith</code> is a valid employee name, and <code>False</code> otherwise.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if 'Smith' in staff:  worksHere = True&#13;
else:                 worksHere = False</pre>&#13;
			<p lang="en-GB">Later we will use the <code>in</code> <a id="_idIndexMarker308"/>operator in to test whether an instruction is a member of a set, as here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
arithOps = ['ADD','SUB','MUL','DIV']       # Define list of arithmetic operations&#13;
.&#13;
.&#13;
if 'mnemonic' <strong class="bold">in</strong> arithOps:                 # Test whether instruction is arithmetic&#13;
    .&#13;
    .&#13;
else:</pre>&#13;
			<h2 id="_idParaDest-84" lang="en-GB"><a id="_idTextAnchor084"/>Repetition and Iterables</h2>&#13;
			<p lang="en-GB">Another version of the <code>for</code> loop iterates <a id="_idIndexMarker309"/>over the elements of a list as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">for</strong> i <strong class="bold">in</strong> anyList:                          # Operate on each element of the list one-by-one&#13;
    &lt;body of loop&gt;</pre>&#13;
			<p lang="en-GB">The words in bold are the reserved Python words; the other words are user-defined variables. Here, the <code>i</code> is not a sequence-counting integer as it was in the previous example using <code>range()</code>. It is the value of each element (or iterable) in the list taken in turn. Consider the following example using a list of colors:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
car = ['red', 'white', 'green' ,'silver', 'teal']&#13;
for color in car: print(color)             # Color is a loop variable; we could have used i.</pre>&#13;
			<p lang="en-GB">This code steps through each element of the list <code>car</code> and prints out its value, as follows.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
red&#13;
white&#13;
green&#13;
silver&#13;
teal</pre>&#13;
			<p lang="en-GB">Consider an example using a list of computer operations. In this case we’ve taken a list of tuples, one for <a id="_idIndexMarker310"/>each of four op-codes. The tuple consists of an op-code string, an instruction type, and the number of operands required. This is just a demonstration. We could have used a list but chose a tuple to emphasize that the tuple values do not change:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
opCodes = [('NOP','misc',0),('BEQ','flow',1),('LDR','move',2), \&#13;
          ('ADD', 'arith',3)]&#13;
for instruction in opCodes:                # Step through the op-codes&#13;
    print(instruction)                     # Print the current op-code&#13;
    op     = instruction[0]                # Extract the three tuple members&#13;
    group  = instruction[1]&#13;
    params = instruction[2]&#13;
    print(op, group, params)               # Print the three tuple values</pre>&#13;
			<pre class="source-code">    if op == 'BEQ': print('beq found')     # Demo! Print BEQ when we find it</pre>&#13;
			<p lang="en-GB">The output of this code fragment is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
('NOP', 'misc', 0)&#13;
NOP misc 0&#13;
('BEQ', 'flow', 1)&#13;
BEQ flow 1&#13;
beq found&#13;
('LDR', 'move', 2)&#13;
LDR move 2&#13;
('ADD', 'arith', 3)&#13;
ADD arith 3</pre>&#13;
			<p lang="en-GB">We have now <a id="_idIndexMarker311"/>demonstrated that you can iterate through a list of any type in Python.</p>&#13;
			<p lang="en-GB">A particularly interesting feature of Python is looping with a<em class="italic"> double index</em>. You can step through a list by numeric index, or by object name. This is useful when you want to step through by object name but would also like to know where it is in the list. The Python function <code>enumerate</code> permits this form of looping. It is easier to demonstrate the action of <code>enumerate</code> than to explain it. Consider the previous example of the list <code>car</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
car = [ 'red', 'white', 'green', 'silver', 'teal']&#13;
for color in enumerate(car):&#13;
    print (color)</pre>&#13;
			<p lang="en-GB">The output from this code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(0, 'red')&#13;
(1, 'white')&#13;
(2, 'green')&#13;
(3, 'silver')&#13;
(4, 'teal')</pre>&#13;
			<p lang="en-GB">The iterator, <code>color</code>, has become a sequence of tuples with the element index and the corresponding value from the list. Remember that a tuple is like a list except that its elements are immutable and can’t be changed. Here’s a case where I would use an iterator name like <em class="italic">color</em>, rather than <code>i</code>, because it is more explicit/descriptive, and it is less easy to confuse with an integer.</p>&#13;
			<p lang="en-GB">An alternative form of<a id="_idIndexMarker312"/> enumeration uses two indices, one an explicit integer count and one an element count. In the following example, <code>count</code> is the explicit integer index and <code>color</code> is the enumeration index. Thus, <code>count</code> steps <code>0</code>, <code>1</code>, <code>2</code> etc., and <code>color</code> steps <code>red</code>, <code>white</code>, <code>green</code> …:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">for</strong> count, color <strong class="bold">in enumerate</strong>(car):</pre>&#13;
			<pre class="source-code">    print ('count = ', count, 'Color =', color)</pre>&#13;
			<p lang="en-GB">This produces the following output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
count =  0 Color = red&#13;
count =  1 Color = white&#13;
count =  2 Color = green&#13;
count =  3 Color = silver&#13;
count =  4 Color = teal</pre>&#13;
			<h2 id="_idParaDest-85" lang="en-GB"><a id="_idTextAnchor085"/>Lists of lists</h2>&#13;
			<p lang="en-GB">Here we extend<a id="_idIndexMarker313"/> the use of Python’s most important data structure, the list. First, we demonstrate that a list can, itself, contain lists. Python lets you construct lists with any type of item; for example, <code>x = [1,2,'test',v,True]</code> defines a list with two integers, a string, a variable, and a Boolean constant. Since you can use any legal element in a list, you can create a <em class="italic">list of lists</em>. Consider this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
fruit = [['apple',2.35,150], ['orange',4.10,200], ['banana',3.65,70]]</pre>&#13;
			<p lang="en-GB"> This is a list of three items and each item is a list itself (shaded); for example, the first item in this list is the list ['apple',2.35,150]. Each sub-list consists of a string naming the fruit, the price of the fruit, and the current stock level.</p>&#13;
			<p lang="en-GB">Suppose we want to know the price of oranges; we could write something like this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for i in range (0,len(fruit)):     # Step through the list of fruit.  len(fruit) is 3&#13;
    if fruit<strong class="bold">[i]</strong>[0] == 'orange':    # If the first element in the current item is 'orange',&#13;
        price = fruit<strong class="bold">[i]</strong>[1]        # then get the second element in that item&#13;
        break                      # If we do find 'orange' we can break out of the loop</pre>&#13;
			<p lang="en-GB">We use a <code>for</code> loop to step through the list of fruits. Then, when we’ve located the item we want (which is a list), we read the second item of that list. As you can see, we use two subscripts, first [i] and then [1].</p>&#13;
			<p lang="en-GB">Consider the following<a id="_idIndexMarker314"/> example of lists of lists:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
testList = [[4,9,[1,6]],[8,7,[0,9]]]</pre>&#13;
			<p lang="en-GB">This is not easy on the eye! Let’s use bold font and shading to emphasize the components of the string:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
testList = [<strong class="bold">[4,9,</strong>[1,6]<strong class="bold">],</strong> [<strong class="bold">8,7,</strong>[0,9]<strong class="bold">]</strong>]  # Each element in the list is itself a list</pre>&#13;
			<p lang="en-GB">It’s a list consisting of two items: [4,9,[1,6]] and [8,7<code>4</code>, <code>9</code> and the list [1,6].</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If I were to write <code>x = testList[1][2][1]</code>, what would the value of <code>x</code> be?</p>&#13;
			<p lang="en-GB">It would be <code>9</code>, because <code>testList</code>[1] is <code>[8,7,[0,9]]</code> and<code> testList[1]</code>[2]<em class="italic"> </em>is [0,9] and <code>testList[1][2]</code>[1]is 9. Think of this as a tree with branches! The first branch is element <code>[1]</code> of <code>testList</code>. The second branch is element <code>[2]</code> of that branch, and the third (final) branch is element <code>[1]</code> on that second branch. <em class="italic">Figure 5</em><em class="italic">.1</em> illustrates the concept of embedded lists graphically.</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_5.01_B19624.jpg" alt="Figure 5.1 - Illustration of embedded lists" width="1101" height="369"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 - Illustration of embedded lists</p>&#13;
			<p lang="en-GB">Consider a second example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = ['this', 'that', 'then']</pre>&#13;
			<p lang="en-GB">What is <code>x[2][3]</code>? This <a id="_idIndexMarker315"/>expression yields <code>'n'</code>, because <code>x[2]</code> is <code>'then'</code> , and element 3 of that is <code>'n'</code>.</p>&#13;
			<h2 id="_idParaDest-86" lang="en-GB"><a id="_idTextAnchor086"/>Indenting in python</h2>&#13;
			<p lang="en-GB">We have been indenting<a id="_idIndexMarker316"/> code since we introduced Python. Now we re-emphasize the use of the indent in Python because it is so vital to correct programming. Most computer languages allow you to group statements together, as a block, for a particular purpose. Typically, the instructions in a group are executed as a batch, one by one. Such groups are often associated with conditional statements and loops.</p>&#13;
			<p lang="en-GB">Some languages indicate a block of instructions by enclosing them in curly brackets <code>{ }</code>. Consider the following. It’s not real code; it’s just plain text designed to illustrate the layout of a program:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
{some operations}&#13;
{main loop&#13;
<strong class="bold">{</strong>some other operations<strong class="bold">}</strong>&#13;
if x == 1 {Do this batch of operations}&#13;
repeat&#13;
{do these operations}&#13;
}</pre>&#13;
			<p lang="en-GB">Here, you have several blocks of operations, which include nested blocks (i.e., a block within another block). Blocks are executed as if they were a single operation; that is, they are the computer equivalent of <em class="italic">subcontracting</em>. Although it is not a programming requirement, it is normal to use indentation as a reading aid to make the code more understandable to people, as here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">{</strong>some operations<strong class="bold">}</strong>&#13;
<strong class="bold">{</strong>main loop&#13;
     <strong class="bold">{</strong>some operations<strong class="bold">}</strong>&#13;
     if x == 1&#13;
        <strong class="bold">{</strong>do this batch of operations<strong class="bold">}</strong>&#13;
     repeat&#13;
        <strong class="bold">{</strong>do these operations<strong class="bold">}</strong>&#13;
<strong class="bold">}</strong></pre>&#13;
			<p lang="en-GB">Python doesn’t use <a id="_idIndexMarker317"/>brackets to indicate a block of consecutive operations. It requires that a block of code be indented (and the same indentation used for each member of the block). Failure to get the indentation right will either result in a failure to compile the program, or a program that doesn’t do what you think it will do. Errors of indentation are one of the first things that the novice programmer encounters. An indentation error is very easy to miss. For example, if you accidentally create an indent or remove an indent while editing a program, you can easily get an error that takes a long time to locate.</p>&#13;
			<p lang="en-GB">A simple example of the use of blocks and indentation in Python is given below. Although any amount of indent is legal, by convention, an indent is normally four spaces. Each level of indentation is shaded. Note that the <code>else</code> in the last line belongs to the first <code>if</code>. If we had indented it further, it would belong to the second <code>if</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 1&#13;
y = 2&#13;
if z == 4:&#13;
    s = 1&#13;
    b = 2&#13;
    if b == 3:&#13;
        g = 1&#13;
<strong class="bold">else: p = 7</strong></pre>&#13;
			<h2 id="_idParaDest-87" lang="en-GB"><a id="_idTextAnchor087"/>The dictionary</h2>&#13;
			<p lang="en-GB">In this section we introduce Python’s <a id="_idIndexMarker318"/>dictionary mechanism, which makes writing simulators so easy. Here, you will learn how to create a dictionary that translates one thing into another, for example, translating the name of an instruction into its binary code. Here we learn about the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">The nature of a dictionary</li>&#13;
				<li lang="en-GB">The advantages of a dictionary over the list</li>&#13;
				<li lang="en-GB">The difference between a dictionary key and a dictionary value</li>&#13;
				<li lang="en-GB">Inserting items in a dictionary</li>&#13;
				<li lang="en-GB">Extracting items from a dictionary</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Using a dictionary to solve a problem</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The dictionary is one of Python’s most useful features, a feature that makes it so much easier to design simulators. The Python dictionary is an impressive data structure that is accessed by means of a <em class="italic">key</em>, rather than a location within the data structure. Instead of providing a location like <code>myList[5]</code>, you look up an item in a dictionary in exactly the same way you use a dictionary in everyday life. You provide the dictionary with a name (which we call a <em class="italic">key</em>) and up pops <a id="_idIndexMarker319"/>the information <em class="italic">associated</em> with that name. Keys are unique; the same key can’t appear more than once in a dictionary (just as social security numbers are unique).</p>&#13;
			<p lang="en-GB">A Python dictionary has the form <code>{key1:value1, key2:value2, key3:value3}</code>; for example, <code>{'UK':44, 'USA':1, 'Germany':49, 'France':33}</code> might be used to look up a country’s international telephone prefix. The dictionary is enclosed in curly braces, and <code>key:value</code> pairs have a colon between the key and its value. The order of pairs in a dictionary does not matter, because an item is accessed by its <em class="italic">key</em> and not by its location in the dictionary.</p>&#13;
			<p lang="en-GB">The key is often a string, but that is not a requirement. In our computer simulator, the keys are usually the <a id="_idIndexMarker320"/>mnemonic codes of a computer language. The value associated with a key can be any legal Python data structure. In some of the simulators we create, we often specify the value as a tuple, which is an ordered list. For example, the dictionary entry <code>'INC':(8,16)</code>has the key <code>'INC'</code> and the value <code>(8,16)</code>. Searching the dictionary using the key <code>'INC'</code>, returns the tuple <code>(8,16)</code>. In this case, the value is the format of the instruction (i.e., 8), and its op-code (i.e., 16).</p>&#13;
			<p lang="en-GB">You could use a list as a value instead of a tuple, that is, <code>'INC':[8,16]</code>. The only significant difference is that you can’t change a tuple once it is defined.</p>&#13;
			<p lang="en-GB">You can check whether an item is in the dictionary by writing <code>if key in dictionary</code>, as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if 'INC' in opCodes:       # This returns True if 'INC' is in opCodes</pre>&#13;
			<p lang="en-GB">To obtain the information about a particular mnemonic, we can use the <code>get</code> method to read the value associated with the key. For example, <code>opData = </code><code>opCodes</code>.get<code>('INC')</code> returns<code>(8,16)</code>.</p>&#13;
			<p lang="en-GB">We can then access the two fields of the tuple associated with <code>'INC'</code> as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binaryCode  = opData[0]&#13;
formatStyle = opData[1]</pre>&#13;
			<p lang="en-GB">If the requested key is<a id="_idIndexMarker321"/> not in the dictionary, the <code>get</code> method returns <code>None</code>. <code>None</code> is a Python reserved word and indicates a null value. Note that <code>None</code> is not zero or an empty string, it has its own type <code>None</code>. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if opCodes.get(thisInstruction) == None: # Ensure that the instruction is valid</pre>&#13;
			<pre class="source-code">   print("Error. Illegal operation")</pre>&#13;
			<p lang="en-GB">The following code uses the telephone prefix directory we described above to demonstrate how to use <code>None</code> to deal with errors. Note that this uses an infinite loop and terminates on an error. When <code>None</code> is detected, the <code>break</code> forces an exit from the infinite loop:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
prefixes = {'UK':44, 'USA':1, 'Germany':49, 'France':33}&#13;
while True:                              # Infinite loop&#13;
    x = input('Country? ')               # Ask for the country&#13;
    y = prefixes.get(x)                  # Look up the prefix&#13;
    if y == None:                        # If None print error message&#13;
        print('Prefix not found')&#13;
        break                            # And exit the loop&#13;
    else: print('Prefix = ',y)&#13;
print('Program terminated')</pre>&#13;
			<p lang="en-GB">Python’s dictionaries <a id="_idIndexMarker322"/>make it incredibly easy to implement symbolic names for labels and variables. Just create a dictionary with <em class="italic">name: value</em> pairs, and use the name to get the value associated with the label; for example, you might want to associate Hastings with the value 1066. Typical assemblers use <em class="italic">directives</em> to express this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Hastings EQU 1066      @ Equate the Name "Hastings" to the value 1066</pre>&#13;
			<p lang="en-GB">Later in your program, you might write <code>LDRL </code>r0<code>,Hastings</code> in order to load <code>r0</code> with <code>1066</code>. Suppose you have a table of names and values, <code>namSub</code>, that’s set up as a dictionary:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
namSub = {'Hastings':1066, 'Agincourt':1415, 'Trafalgar':1805}</pre>&#13;
			<p lang="en-GB">If we wish to get the<a id="_idIndexMarker323"/> value associated with Hastings, we can write this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = namSub.get('Hastings')</pre>&#13;
			<p lang="en-GB">The name will be translated into its value.</p>&#13;
			<p lang="en-GB">In what follows, we’ve written several fragments of Python code in order to demonstrate how the dictionary can be used. These examples demonstrate the setting up of a dictionary, adding information to it, and accessing it. When an assembly language program is run, some dictionaries are set up before it is executed, for example, the list of legal instructions. Some directories, such as the symbol table of names appearing in the assembly language program, will be constructed as the program runs.</p>&#13;
			<p lang="en-GB">The first<a id="_idIndexMarker324"/> directory in the example converts a register name into its register number; for example, a register name <code>x</code> can be converted to its register number <code>y</code> by <code>y = regs.get(x)</code>. Of course, you don’t need to use a dictionary. We could simply write <code>y = int(x[1:])</code> to convert the string <code>'r6'</code> into the integer 6 by using string processing. However, the dictionary method is more elegant and easier to follow. Moreover, it’s more flexible:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
regs = {'r0':0, 'r1':1, 'r2':2, 'r3':3, 'r4':4}   # Register name-to-number translation&#13;
symTab = {'start':0,'time':24,'stackP':'sp','next':0xF2} &#13;
                                            # Symbol table converts symbolic name to value&#13;
x0 = 'add r1,r2,r4'                # An example of an instruction in text form&#13;
x1 = x0.split(' ')                 # Split instruction into op-code and predicate&#13;
x2 = x1[1].split(',')              # Split the predicate into tokens&#13;
x3 = x2[0]                         # Get the first token of x2&#13;
if x3 in regs:                     # Is this a valid register?&#13;
    x4 = regs.get(x3)              # Use get() to read its value&#13;
print ('x0 = ',x0, '\nx1 = ',x1, '\nx2 = ',x2, '\nx3 = ',x3, '\nx4 = ',x4)&#13;
y0 = 'beq next'                    # Another example: instruction with a label&#13;
y1 = y0.split(' ')                 # Split into op-code and predicate on the space&#13;
y2 = y1[1]                         # Read the predicate (i.e.,'next')&#13;
y3 = symTab.get(y2)                # Get its value from the symbol table (i.e., 0xF2)&#13;
print('beq ',y3)                   # Print the instruction with the actual address&#13;
z = symTab.get('beq next'.split(' ')[1])  # We've done it all in one line. Not so easy to follow.&#13;
print('beq ',z)&#13;
print('Symbol table ', symTab)            # Print the symbol table using a print&#13;
symTab['nextOne'] = 1234                  # This is how we add a new key and value&#13;
print('Symbol table ', symTab)            # Here's the augmented symbol table&#13;
opCode = {'add':('Arith',0b0001,3),'ldr':('Move',0b1100,2), \&#13;
       'nop':('Miscellaneous',1111,0)}    # New directory. Each key has three values in a tuple&#13;
thisInst = 'ldr'                          # Let's look up an instruction&#13;
if thisInst in opCode:                    # First test if it's valid and in the dictionary&#13;
    if thisInst == 'ldr':                 # If it is:&#13;
        instClass = opCode.get('ldr')[0]  # Get first element of the instruction&#13;
        binaryVal = opCode.get('ldr')[1]  # Get the second element&#13;
        operands  = opCode.get('ldr')[2]  # Get the third element&#13;
print('\nFor opCode: ',thisInst, '\nClass = ', instClass, \&#13;
      '\nBinary code = ', bin(binaryVal), '\nNumber of operands = ',operands)&#13;
print('\nThis is how to print a directory')&#13;
                                   # Now print a formatted dictionary (key and value on each line)&#13;
for <strong class="bold">key,value</strong> in opCode.items():&#13;
    print(key, ':', value)&#13;
print()&#13;
for <strong class="bold">i,j</strong> in opCode.items():         # Note that key and value can be any two variables&#13;
    print(i, ':', j)&#13;
theKeys = opCode.keys()            # The function .keys() returns the keys in a dictionary&#13;
print('The keys are: ',theKeys)&#13;
test = {'a':0,'b':0,'c':0,'d':0}   # A new directory. The values are just integers&#13;
test['a'] = test['a'] + 1          # You can change a value! Use the key to locate it&#13;
test['d'] = test['d'] + 7&#13;
test1 = {'e':0, 'f':0}             # Here's a second dictionary.&#13;
test.update(test1)                 # Append it to test using .update()&#13;
print('Updated dictionary test is: ',test)   # Not convinced? Here it is then.</pre>&#13;
			<p lang="en-GB">The following is the <a id="_idIndexMarker325"/>output after executing the above fragment of code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x0 =  add r1,r2,r4&#13;
x1 =  ['add', 'r1,r2,r4']&#13;
x2 =  ['r1', 'r2', 'r3']&#13;
x3 =  r1&#13;
x4 =  1&#13;
beq  242&#13;
beq  242&#13;
Symbol table  {'start': 0, 'time': 24, 'stackPointer': 'sp', 'next': 242}&#13;
Symbol table  {'start': 0, 'time': 24, 'stackPointer': 'sp', 'next': 242,&#13;
               'nextOne': 1234}&#13;
For opCode:  ldr&#13;
Class =  Move&#13;
Binary code =  0b1100&#13;
Number of operands =  2&#13;
This is how to print a directory&#13;
add : ('Arith', 1, 3)&#13;
ldr : ('Move', 12, 2)&#13;
nop : ('Miscellaneous', 1111, 0)&#13;
add : ('Arith', 1, 3)&#13;
ldr : ('Move', 12, 2)&#13;
nop : ('Miscellaneous', 1111, 0)&#13;
The keys are:  dict_keys(['add', 'ldr', 'nop'])&#13;
Updated dictionary test is:  {'a': 1, 'b': 0, 'c': 0, 'd': 7, 'e': 0, 'f': 0}</pre>&#13;
			<p lang="en-GB">Let’s look at <a id="_idIndexMarker326"/>dictionaries in more detail with another example. The use of Python’s dictionaries makes it easy to implement symbolic names for labels and variables. All we have to do is to create a dictionary with <code>name: value</code> pairs and use a name to get its associated value. Suppose we’ve read an instruction, say, <code>'ADD r4,r2,r3'</code>, and tokenized it into this:</p>&#13;
			<pre class="source-code">predicate = ['r4','r2','r3']  # The list of parameters for the op-code</pre>&#13;
			<p lang="en-GB">We can get the integer value of a register the hard way by using slicing:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
rD = int([predicate[0]][1:])</pre>&#13;
			<p lang="en-GB">Let’s simplify the expression to make the explanation easier. Suppose we write this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
rD = predicate[0]</pre>&#13;
			<p lang="en-GB">The value of <code>rD</code> is the string <code>'r4'</code>. What we need to do is to isolate the <code>'4'</code> from <code>'r4'</code> and then convert the character <code>'4'</code> to the integer <code>4</code>.</p>&#13;
			<p lang="en-GB">We can write <code>rD = rD[1:]</code> to return all characters in the string except the initial <code>'r'</code>. The final step is to convert to an integer, which we can do with <code>rD = </code><code>int(rD)</code>.</p>&#13;
			<p lang="en-GB">The <code>[1:]</code> means all the characters after the first character, <code>r</code>, which returns <code>'4'</code> if the register was <code>'r4'</code>. We could have written <code>[1:2]</code> rather than <code>[1:]</code>. However, by using <code>[1:]</code>, we can later increase the number of registers beyond 9 without changing the program. Putting all three steps together, we get this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
rD = int([predicate[0]][1:])</pre>&#13;
			<p lang="en-GB">Let’s use a dictionary to carry out the same action. Assume also that we’ve set up a directory for the registers: </p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
regs = {'r0':0, 'r1':1, 'r2':2, 'r3':3, 'r4':4}   # Register names and values</pre>&#13;
			<p lang="en-GB">Before processing a register name, we can test for a valid register symbolic name with this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if predicate[0] in regs:&#13;
      &lt;deal with valid name&gt;&#13;
else: &lt;deal with error&gt;</pre>&#13;
			<p lang="en-GB">Extracting the actual integer number of the register is easy:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
rD = regs.get(predicate[0])</pre>&#13;
			<p lang="en-GB">Finally, note that you can<a id="_idIndexMarker327"/> access a dictionary in two ways. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
regs = {'r0':0, 'r1':1, 'r2':2, 'r3':3, 'r4':4}&#13;
<strong class="bold">aaa  = regs.get('r3')</strong>&#13;
<strong class="bold">bbb  = regs['r3']</strong>&#13;
print('Test aaa = ',aaa, 'bbb =',bbb)</pre>&#13;
			<p lang="en-GB">This gives us this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Test aaa =  3 bbb = 3</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The advantage of <code>get</code> is that it returns <code>None</code> if the key is not found, whereas the other method creates a runtime error, called <code>KeyError</code>.</p>&#13;
			<h2 id="_idParaDest-88" lang="en-GB"><a id="_idTextAnchor088"/>Functions revisited</h2>&#13;
			<p lang="en-GB">This section looks at<a id="_idIndexMarker328"/> functions in a little more detail and demonstrates the use of the <code>global</code> statement to make parameters accessible outside a function.</p>&#13;
			<p lang="en-GB">Parameters can be passed to functions in parentheses in the function call, and results retrieved by a <code>return()</code> statement. Recall that variables created in a function are local to the function unless they are declared as global; that is, if you write <code>x = 5</code> in a function, you have created a local variable <code>x</code> with the value <code>5</code>. If there is an <code>x</code> outside the function, it is a different <code>x</code>. A value declared outside a function can be accessed inside the function provided it hasn’t been declared as a local variable within the function.</p>&#13;
			<p lang="en-GB">The body of a function is indented from the initial <code>def</code> statement. A function does not need an explicit termination, because<em class="italic"> indentation</em> takes care of that. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def adder(P,Q):                    # Adder function&#13;
   R = P + Q&#13;
   return (R)                      # Return the sum R&#13;
def subtractor(P,Q):               # Subtractor function&#13;
   global R                        # Make R global&#13;
   R = P – Q                       # No need to return a value&#13;
A, B = 7, 2                        # Note Python's multiple assignment&#13;
C = adder(A,B)                     # Do addition&#13;
subtractor(A,B)                    # Do subtraction (just call the function)&#13;
print('Sum =', C, 'Diff = ',R)</pre>&#13;
			<p lang="en-GB">If we run this program we get the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Sum = 9 Diff =  5</pre>&#13;
			<p lang="en-GB">As you can see, we can return a value as an argument in the return statement, or we can make it global. When <a id="_idIndexMarker329"/>we do use the global variables, we don’t need to pass the parameters to or from the function.</p>&#13;
			<h2 id="_idParaDest-89" lang="en-GB"><a id="_idTextAnchor089"/>Imports</h2>&#13;
			<p lang="en-GB">This section shows how you can <a id="_idIndexMarker330"/>access operations that are not part of the Python language itself. These functions are not vital to writing a simulator, but they do provide some very useful facilities. We’ve included this short section to demonstrate how these facilities are accessed.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">A strength of Python is that it includes several libraries of functions that you can access to facilitate the design of programs, for example, graphics. We don’t need many external functions for our work. Here, we will demonstrate two: <code>random</code> and <code>sys</code>.</p>&#13;
			<p lang="en-GB">When simulating a computer, you often need data for testing. Typing it in is time-consuming. Fortunately, Python has a library of functions that generate random numbers. In order to use a library, you first have to import it. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
import random                   # Get the library (usually at the start of the program)&#13;
.&#13;
.&#13;
X = random.randint(0,256)       # Generate a random integer in the range 0 to 255</pre>&#13;
			<p lang="en-GB">Function calls are usually of the form <code>library.action</code>. In this case, the library is <code>random</code> and the action is <code>randomint(a,b)</code>. The parameters <code>a</code> and <code>b</code> give the range of random integer values.</p>&#13;
			<p lang="en-GB">Another useful library is <code>sys</code>, which<a id="_idIndexMarker331"/> provides operating system functions such as <code>exit()</code>, which terminates a Python program and returns to its calling level. See this, for example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
import sys                      # Get the system library&#13;
.&#13;
.&#13;
if run == 0: sys.exit()         # If run is 0 then go home (exit the Python program)</pre>&#13;
			<p lang="en-GB">We have now covered <a id="_idIndexMarker332"/>enough Python topics to begin to design a real computer simulator in the next chapter.</p>&#13;
			<h1 id="_idParaDest-90" lang="en-GB"><a id="_idTextAnchor090"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we’ve extended our knowledge of Python and introduced or expanded some of the features that demonstrate its power and versatility. For example, we’ve looked at the list and the string, the two data structures that are of most importance to us. We’ve also expanded on the use of loops and other repetitive structures.</p>&#13;
			<p lang="en-GB">We’ve introduced the dictionary, a delightfully elegant data structure that enables us to locate information by a key that describes it, rather than its location in the directory. For example, if we want to convert instruction names into binary op-code, we can create a dictionary and just look up the appropriate code for any mnemonic. This feature really does simplify the design of interpreters and assemblers.</p>&#13;
			<p lang="en-GB">We’ve also looked at one of Python’s more unusual features: list comprehensions. These take a little getting used to, but they can make it much easier to process the text of assembly language instructions by cleaning up the input (for example, by removing spaces, or modifying punctuation and syntax).</p>&#13;
			<p lang="en-GB">In <a href="B19624_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a> we put together the things we’ve learned about the operation of a computer and design an assembler and a simulator for a hypothetical computer called TC1.</p>&#13;
		</div>&#13;
	</div></body></html>