<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer041" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-75" class="chapter-number" lang="en-GB"><a id="_idTextAnchor075"/>5</h1>&#13;
			<h1 id="_idParaDest-76" lang="en-GB"><a id="_idTextAnchor076"/>A Little More Python</h1>&#13;
			<p lang="en-GB">We’ve introduced Python and we’ve been using it. In this chapter we increase our knowledge of Python and extend some of the concepts we have encountered, and also introduce new features. In particular, we examine data structures, starting with the way in which lists of elements or strings of characters can be processed. This chapter paves the way for <a href="B19624_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">,</em> where we complete the design of a computer simulator. But, before that, we provide a note on the terminology we use when discussing features <span class="No-Break">of Python.</span></p>&#13;
			<p lang="en-GB">We will discuss the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Statements <span class="No-Break">and expressions</span></li>&#13;
				<li lang="en-GB">More <span class="No-Break">string features</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">List comprehensions</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">String processing</span></li>&#13;
				<li lang="en-GB">Repetition <span class="No-Break">and looping</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">The dictionary</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Functions</span></li>&#13;
				<li lang="en-GB">Lists <span class="No-Break">of lists</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Imports</span></li>&#13;
				<li lang="en-GB">Indenting <span class="No-Break">in Python</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-77" lang="en-GB"><a id="_idTextAnchor077"/>Technical requirements</h1>&#13;
			<p lang="en-GB">You can find the programs used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter05</span></a><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This chapter requires no new resources in addition to previous chapters. All that is required is a computer with a Python IDE. The same is true of all chapters until we reach <a href="B19624_09.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, which deals with <span class="No-Break">Raspberry Pi.</span></p>&#13;
			<p class="callout-heading" lang="en-GB">Statements and Expressions</p>&#13;
			<p class="callout" lang="en-GB">An <em class="italic">expression</em> is a <a id="_idIndexMarker287"/>combination of values and operators that can be evaluated to provide a result; for example <strong class="source-inline">(p+q)*7 - r</strong>. A Boolean expression is a combination of values and logical operators that yields the value <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong>; for example, <strong class="source-inline">p &gt; </strong><span class="No-Break"><strong class="source-inline">q</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="callout" lang="en-GB">A <em class="italic">statement</em> is a <a id="_idIndexMarker288"/>Python operation that must be evaluated by an interpreter; that is, it’s an action. Typical Python statements involve <strong class="source-inline">if</strong>… <strong class="source-inline">for</strong>… actions. These two terms are often used in formal definitions; for example, the definition of an <strong class="source-inline">if</strong> statement is <span class="No-Break">as follows:</span></p>&#13;
			<p class="callout" lang="en-GB"><span class="No-Break"><strong class="source-inline">if &lt;expr&gt;:</strong></span></p>&#13;
			<p class="callout" lang="en-GB"><span class="CharOverride-1">   </span><strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">statement&gt;</strong></span></p>&#13;
			<p class="callout" lang="en-GB">Angle brackets are used in descriptions of the language to indicate <em class="italic">something that will be replaced by its actual value</em>; for example, a valid <strong class="source-inline">if</strong> statement is <span class="No-Break">as follows:</span></p>&#13;
			<p class="callout" lang="en-GB"><strong class="source-inline">if x &gt; </strong><span class="No-Break"><strong class="source-inline">y:</strong></span></p>&#13;
			<p class="callout" lang="en-GB"><span class="CharOverride-1">    </span><strong class="source-inline">p = p + q</strong></p>&#13;
			<p class="callout" lang="en-GB">In this case the <em class="italic">expression</em> is <strong class="source-inline">x &gt; y</strong> and the <em class="italic">statement</em> is <strong class="source-inline">p = p + </strong><span class="No-Break"><strong class="source-inline">q</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-78" lang="en-GB"><a id="_idTextAnchor078"/>More string features</h1>&#13;
			<p lang="en-GB">Now we’re going to<a id="_idIndexMarker289"/> extend our ability to manipulate strings. The string is one of Python’s most important data structures and is at the heart of all the programs we write in this book. Python’s string-handling facilities make it one of the most powerful and easy-to-use text-processing languages. A string is indicated by quotes, which may be either single or double; for example, <strong class="source-inline">x = "Two"</strong> and <strong class="source-inline">y = 'One'</strong> are Python strings. Python’s ability to use two string terminators means that we can create strings like “Alan’s book” (i.e., use the apostrophe as a normal <span class="No-Break">grammar element).</span></p>&#13;
			<p lang="en-GB">During the execution of a Python program, you can read a string from the keyboard and also provide a prompt in the <span class="No-Break">following way.</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">x = input(' Please type </strong><span class="No-Break"><strong class="source-inline">something ')</strong></span></p>&#13;
			<p lang="en-GB">Executing this command displays '<strong class="source-inline">Please type something</strong>' on the screen, waits for your input, and then assigns the string you typed to variable <strong class="source-inline">x</strong>. This mechanism is very useful when <a id="_idIndexMarker290"/>simulating a program, because you can provide input as the program runs. Note that the input string must be terminated by hitting the <span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break"> key.</span></p>&#13;
			<h1 id="_idParaDest-79" lang="en-GB"><a id="_idTextAnchor079"/>String processing</h1>&#13;
			<p lang="en-GB">You can change (substitute) characters in a<a id="_idIndexMarker291"/> string by using the method <strong class="source-inline">replace</strong>. For example, suppose we wish to replace all occurrences of <strong class="source-inline">'$'</strong> in the string <strong class="source-inline">price</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">'£'</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>price =  'eggs $2, cheese $4'</span></pre>&#13;
			<pre class="source-code">price = price.<strong class="bold">replace</strong>('$', '£')      <span class="sc-comment"># Replace $ by £ in the string price</span></pre>&#13;
			<p lang="en-GB">If we print <strong class="source-inline">price</strong>, we now get<strong class="source-inline"> 'eggs £2, </strong><span class="No-Break"><strong class="source-inline">cheese £4'</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Other string methods are <strong class="source-inline">upper()</strong> (convert text to upper case), <strong class="source-inline">lstrip()</strong> (remove leading characters), and <strong class="source-inline">rstrip()</strong> (remove trailing characters). Let <strong class="source-inline">x ='###this Is A test???'</strong>. Consider the <span class="No-Break">following sequence:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = x.lstrip('#')      <span class="sc-comment"># Remove left-hand leading '#' characters to get x = 'this Is A test???'</span></span>&#13;
<span>x = x.rstrip('?')      <span class="sc-comment"># Remove right-hand trailing '?' characters to get x = 'this Is A test'</span></span>&#13;
<span>x = x.lower()          <span class="sc-comment"># Convert to lower-case to get x = 'this is a test'</span></span></pre>&#13;
			<p lang="en-GB">This sequence produces <strong class="source-inline">x </strong>= '<strong class="source-inline">this is is </strong><span class="No-Break"><strong class="source-inline">a test'</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Strings are <em class="italic">immutable</em>. You cannot change them once they are defined. In the preceding code, it looks as if we have modified x by removing leading and trailing characters and converting upper case to lower case. No! In each case we have created a <em class="italic">new</em> string with the same name as the old string (<span class="No-Break">i.e., x).</span></p>&#13;
			<p lang="en-GB">If you were to enter <strong class="source-inline">y =</strong> '<strong class="source-inline">Allen</strong>' and try to edit it to read '<strong class="source-inline">Allan</strong>' by changing the '<strong class="source-inline">e</strong>' to '<strong class="source-inline">a</strong>' using the expression <strong class="source-inline">y[3] = </strong>'<strong class="source-inline">a</strong>', you would get an error, because you would have tried to change an immutable string. However, you could legally write <strong class="source-inline">y = y[0:3] + 'a' + y[4]</strong> to create a new string <strong class="source-inline">y</strong> with the <span class="No-Break">value </span><span class="No-Break"><strong class="source-inline">'Allan'</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The addition symbol, +, performs addition in <em class="italic">arithmetic</em> and <em class="italic">concatenation</em> in string processing; for example, <strong class="source-inline">x = 4 + 5</strong> gives <strong class="source-inline">9</strong>, whereas <strong class="source-inline">x = '4' + '5'</strong> gives <strong class="source-inline">'45'</strong>. This action is called <em class="italic">operator overloading</em> and indicates the extension of a function, when, for example, the function is applied to <span class="No-Break">different objects.</span></p>&#13;
			<p lang="en-GB">The TC1 assembler uses<a id="_idIndexMarker292"/> the following string methods to remove spaces before an instruction, enable users to employ upper- or lower-case, and allow the use of a space or comma as a separator. For example, this code fragment lets you write either <strong class="source-inline">r0,[r1]</strong> or <strong class="source-inline">R0,R1</strong> with the same meaning. The code below shows how TC1 takes a line of the input (i.e., an assembly instruction) and simplifies it for later conversion <span class="No-Break">to binary:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    line = line.replace(',',' ')     <span class="sc-comment"># Allow use of a space or comma to separate operands</span></span>&#13;
<span>    line = line.replace('[','')      <span class="sc-comment"># Allow LDRI r0,[r2] or LDRI r0,r2 First remove '['</span></span>&#13;
<span>    line = line.replace(']','')      <span class="sc-comment"># Replace ']' by null string.</span></span>&#13;
<span>    line = line.upper()              <span class="sc-comment"># Let's force lower- to upper-case</span></span>&#13;
<span>    line = line.lstrip(' ')          <span class="sc-comment"># Remove leading spaces</span></span>&#13;
<span>    line = line.rstrip('\n')         <span class="sc-comment"># Remove end of line chars. End-of-line is \n</span></span></pre>&#13;
			<p lang="en-GB">Suppose an instruction is entered in string form as '<strong class="source-inline">   ADD r0,R1,r3</strong>'. This has leading spaces, upper- and lower-case text and commas, and is converted to <strong class="source-inline">'ADD R0 R1 R3'</strong> by the above <a id="_idIndexMarker293"/>sequence of operations. The next step is to convert the string into individual <em class="italic">tokens</em> for analysis by the assembler. We can do this with the <strong class="source-inline">split()</strong> method. which converts a string into a list of strings separated by the character in the parentheses. Note that the default parameter is a space. If <strong class="source-inline">s = 'ADD R0 R1 R2'</strong>, then <strong class="source-inline">s.split()</strong> or <strong class="source-inline">s.split(' ')</strong> results <span class="No-Break">in this:</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><strong class="source-inline">s = ['ADD', 'R1', 'R2', 'R3']</strong><span class="CharOverride-1">      </span><span class="sc-comment"># A list of four tokens, each of which is </span><span class="No-Break"><span class="sc-comment">a string</span></span></p>&#13;
			<p lang="en-GB">We now have a list consisting of four separate strings; that is, a command followed by three parameters. We can access each of these strings using <span class="No-Break">index notation:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>T1 = s[0]                       <span class="sc-comment"># This is the mnemonic 'ADD'</span></span>&#13;
<span>T2 = s[1]                       <span class="sc-comment"># This is the destination register 'R1'</span></span>&#13;
<span>T3 = s[2]                       <span class="sc-comment"># This is the first source register 'R2'</span></span>&#13;
<span>T4 = s[3]                       <span class="sc-comment"># This is the second source register 'R3'</span></span></pre>&#13;
			<p lang="en-GB">We can now perform operations on <span class="No-Break">the tokens:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if T1 == 'STOP': then run = 0   <span class="sc-comment"># If the instruction is stop then halt processing</span></span>&#13;
<span>firstReg = int(T2[1:])          <span class="sc-comment"># Get the register number as an integer</span></span></pre>&#13;
			<p lang="en-GB">The second statement uses <strong class="source-inline">T2[1:]</strong> to convert string <strong class="source-inline">'R2'</strong> into a new string <strong class="source-inline">'2'</strong> by removing the first character. The slice notation <strong class="source-inline">[1:]</strong> is interpreted as "All characters following the first." This lets us deal with one- or two-digit values like R2 or R23. Since there are only 8 registers, we could have written <strong class="source-inline">[1:2]</strong>. Using <strong class="source-inline">[1:]</strong> allows the extension 16 registers in a future version of TC1 without changing <span class="No-Break">the code.</span></p>&#13;
			<p lang="en-GB">We have to use<a id="_idIndexMarker294"/> the <em class="italic">integer </em>function <strong class="source-inline">int</strong> to convert the register number from a string into its value as an integer. When learning Python, a common mistake is to forget to convert a string to <span class="No-Break">an integer:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>regNum = input('Please enter register number &gt;&gt;&gt;')</span>&#13;
<span>contents = reg[regNum]</span></pre>&#13;
			<p lang="en-GB">This code would generate an error. Because <strong class="source-inline">regNum</strong> is created as a string, holding the value you typed. However, in the second line, the program is expecting an integer as a list index. You have to write <strong class="source-inline">reg[int(regNum)]</strong> to convert the numeric string into an <span class="No-Break">integer value.</span></p>&#13;
			<h2 id="_idParaDest-80" lang="en-GB"><a id="_idTextAnchor080"/>Example – text Input</h2>&#13;
			<p lang="en-GB">Here’s a simple example of text input<a id="_idIndexMarker295"/> with Python using a simple <strong class="source-inline">.txt</strong> file. The source file <span class="No-Break">is this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment">@ This is text</span></span>&#13;
<span>NOP</span>&#13;
<span> NOP</span>&#13;
<span>NOP</span>&#13;
<span>NOP</span></pre>&#13;
			<pre class="source-code">END</pre>&#13;
			<p lang="en-GB">This file was processed by Python as follows. I use the address it had on my computer. This is read into a <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">sFile</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>myFile = 'E:\\ArchitectureWithPython\\testText.txt'</span>&#13;
<span>with open(myFile,'r') as sFile:</span>&#13;
<span>    sFile = sFile.readlines()           <span class="sc-comment"># Open the source program</span></span>&#13;
<span>print (sFile)</span></pre>&#13;
			<p lang="en-GB">The output from this code fragment is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>['@ This is text\n', 'NOP\n', ' NOP\n', ' \n', 'NOP\n', '\n', 'NOP\n', 'END']</span></pre>&#13;
			<p lang="en-GB">We now have a Python list of strings, each corresponding to one line of the source text. Note that each line <a id="_idIndexMarker296"/>ends with an end-of-line (i.e., \n) and any spaces in the text are included. For example, there’s a totally empty line and an empty line with a space. We have to take account of these when dealing with <span class="No-Break">the input.</span></p>&#13;
			<p lang="en-GB">Having increased our ability to manipulate text strings, in the next section we look at one of Python’s most interesting features: the facility to perform a sequence of operations on a string or a list in just one line of code with <span class="No-Break">list comprehension.</span></p>&#13;
			<h1 id="_idParaDest-81" lang="en-GB"><a id="_idTextAnchor081"/>List comprehensions</h1>&#13;
			<p lang="en-GB">We now <a id="_idIndexMarker297"/>introduce a very powerful feature of Python, the <em class="italic">list comprehension</em>. It’s not powerful because of what it can do, but because of how succinct it is. A list comprehension lets you take a list and process it in a single line. We take a look at list comprehensions, because they are so useful in processing text; for example, you can use a list comprehension to take a line of text and replace all double-spaces with single spaces, or convert all lower-case characters to <span class="No-Break">upper-case characters.</span></p>&#13;
			<p lang="en-GB">List comprehensions can be applied to any iterable. An iterable is a structure that you can step through, such <a id="_idIndexMarker298"/>as a list, a string, or a tuple. The simplest form of list comprehension <span class="No-Break">is this:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">x = </strong><span class="pcode-bold">[</span><strong class="source-inline">i </strong><span class="pcode-bold">for</span><strong class="source-inline"> i </strong><span class="No-Break"><span class="pcode-bold">in</span></span><span class="No-Break"><strong class="source-inline"> y</strong></span><span class="No-Break"><span class="pcode-bold">]</span></span></p>&#13;
			<p lang="en-GB">Here, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> are strings (or lists). The text in bold represents Python reserved words and punctuation. The variable <strong class="source-inline">i</strong> is a user-chosen variable used to step through the list. We could have used any name instead of <em class="italic">i</em>; it simply doesn’t matter. Consider the <span class="No-Break">following example:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">lettersList = [i for i </strong><span class="No-Break"><strong class="source-inline">in 'Tuesday']</strong></span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The iterable being processed is the string <strong class="source-inline">'Tuesday'</strong> and it is copied a character at a time to <strong class="source-inline">lettersList</strong>. This returns <strong class="source-inline">lettersList</strong> as the list of characters <strong class="source-inline">[</strong>'<strong class="source-inline">T','u','e','s','d','a','y']</strong>. We have turned a string into a list <span class="No-Break">of characters.</span></p>&#13;
			<p lang="en-GB">We can create a more sophisticated version of the list comprehension <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = [expression for i in y if condition]</span></pre>&#13;
			<p lang="en-GB">where <strong class="source-inline">expression</strong> is a Python expression, and <strong class="source-inline">condition</strong> is a Boolean condition. We step through the iterable, <strong class="source-inline">y</strong>, looking at each element and selecting it subject to a condition, processing it <a id="_idIndexMarker299"/>according to the expression, and then putting it in a new list. That’s an awful lot of work in a single line. <span class="No-Break">Consider this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>y = 'this$is$a$test'</span>&#13;
<span>x = [i for i in y if i != '$']</span></pre>&#13;
			<p lang="en-GB">The <a id="_idIndexMarker300"/>condition is <em class="italic">if item i from y is not equal to ‘$’ </em>. This list comprehension says, "Copy the characters in string y to string x, one-by-one, as long as the character isn’t a <strong class="source-inline">'$'</strong> character." The result <span class="No-Break">is this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x =['t', 'h', 'i', 's', 'i', 's', 'a', 't', 'e', 's', 't'].</span></pre>&#13;
			<p lang="en-GB">The original string has been replaced by a list of single-character strings, but with every <strong class="source-inline">'$'</strong> <span class="No-Break">removed.</span></p>&#13;
			<p lang="en-GB">Let’s look at three examples of <span class="No-Break">list comprehensions:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB">The first example <a id="_idIndexMarker301"/>demonstrates how empty lines (i.e., '') can be removed from the input. We can copy all lines apart from those equal to the null or empty string " "<span class="No-Break">with:</span><pre class="source-code">sFile = [i for i in sFile if i != '']   <span class="sc-comment"># Remove blank lines</span></pre></li>&#13;
			</ol>&#13;
			<p lang="en-GB">We’ve renamed the new list the same as the old one. There’s no reason why we can’t do this and it saves having to invent a new name for each of the list comprehensions.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="2">The second example <span class="No-Break">is this:</span><pre class="source-code">sFile = [i.upper() for i in sFile]      <span class="sc-comment"># Convert to upper-case</span></pre></li>&#13;
			</ol>&#13;
			<p lang="en-GB">We apply the function <strong class="source-inline">.upper()</strong> to each element <strong class="source-inline">i</strong>. This expression converts a lower-case character into its upper-case equivalent; that is, it converts all strings to upper-case. The last list comprehension is this:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile = [i.split() for i in sFile if i != '']</span></pre>&#13;
			<p lang="en-GB">The expression <strong class="source-inline">i.split()</strong> divides the source string into individual tokens (strings) at each space. This means we can then then process the line as a sequence of tokens. The condition <strong class="source-inline">if i != ''</strong> is used to remove empty strings by not copying them.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="3">The third example removes <span class="No-Break">empty lines.</span></li>&#13;
			</ol>&#13;
			<p lang="en-GB">We’ve created a list of three instructions that has empty lines in it, denoted by ' '. When we execute this list comprehension, we convert each string into a sublist and we<a id="_idIndexMarker302"/> remove the empty lines:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile = ['ADD R1 R2 R3', 'BEQ LOOP', '', 'LDRL R2 4','']</span>&#13;
<span>sFile = [i.split() for i in sFile if i != '']</span></pre>&#13;
			<pre class="source-code">print(sFile)</pre>&#13;
			<p lang="en-GB">The output from this code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>[['ADD', 'R1', 'R2', 'R3'], ['BEQ', 'LOOP'], ['LDRL', 'R2', '4']]</span></pre>&#13;
			<h2 id="_idParaDest-82" lang="en-GB"><a id="_idTextAnchor082"/>The tuple</h2>&#13;
			<p lang="en-GB">We now introduce the tuple for the<a id="_idIndexMarker303"/> sake of completeness, although we make little use of it in this text. A list<a id="_idIndexMarker304"/> is a sequence of elements enclosed by square brackets; for example, <strong class="source-inline">P = [1,4,8,9]</strong>. A tuple is a sequence of elements separated by round brackets; for example, <strong class="source-inline">Q = (</strong><span class="No-Break"><strong class="source-inline">1,4,8,9)</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">There is little difference between a tuple and a list; they are both data structures that hold a sequence of elements. However, a <em class="italic">tuple is immutable</em> and cannot be modified, unlike a list. A tuple is a read-only list and is used when you wish to store data that does not change. Although not relevant here, tuples do have implementation and performance advantages over lists; that is, if you have a list that is fixed, it is better to use <span class="No-Break">a tuple.</span></p>&#13;
			<p lang="en-GB">Later, we will use tuples in dictionary structures, <span class="No-Break">as here:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>opCodes = {'add':<strong class="bold">(2,34)</strong>, 'inc':<strong class="bold">(4,37)</strong>}</span></pre>&#13;
			<p lang="en-GB">In this case, the values <a id="_idIndexMarker305"/>in bold are each two-component tuples. We could have used a list, but the tuple indicates a fixed structure that cannot change. If you were to use a list instead of a tuple, you would <span class="No-Break">write this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>opCodes = {'add':[<strong class="bold">2,34]</strong>, 'inc':[<strong class="bold">4,37]</strong>}</span></pre>&#13;
			<h2 id="_idParaDest-83" lang="en-GB"><a id="_idTextAnchor083"/>Repetition and looping</h2>&#13;
			<p lang="en-GB">We now expand our knowledge of Python’s repetition mechanism, a feature <a id="_idIndexMarker306"/>common to all high-level procedural languages. In this section we learn how to do <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Repeat an action <span class="No-Break">multiple times</span></li>&#13;
				<li lang="en-GB">Use different data and parameters each time you carry out <span class="No-Break">the action</span></li>&#13;
				<li lang="en-GB">Iterate over elements in <span class="No-Break">a list</span></li>&#13;
				<li lang="en-GB">Use the <span class="No-Break"><strong class="source-inline">enumerate</strong></span><span class="No-Break"> function</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Suppose we want to test whether a list includes a particular item. We can create a <strong class="source-inline">for</strong> loop to <span class="No-Break">do this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>fruit1 = ['apples', 'oranges', 'grapes', 'bananas', 'peaches']</span>&#13;
<span>size = len(fruit1)               <span class="sc-comment"># Get length of the list</span></span>&#13;
<span>inList = False                   <span class="sc-comment"># inList is False until we find item</span></span>&#13;
<span>for i in range (0,size):         <span class="sc-comment"># Repeat for each item in list</span></span>&#13;
<span>    if fruit1[i] == 'grapes':</span></pre>&#13;
			<pre class="source-code">        inList = True            <span class="sc-comment"># Set flag to True if we find the item</span></pre>&#13;
			<p lang="en-GB">This code first sets <strong class="source-inline">inList</strong> to <strong class="source-inline">False</strong> to indicate that the element <strong class="source-inline">'grapes'</strong> has not been found. The <strong class="source-inline">for</strong> loop steps though all elements in the list, testing each one for the item we’re looking for. If it is found, <strong class="source-inline">inList</strong> is set to <strong class="source-inline">True</strong>. This code works, but it is not good. If there are a million elements in the list and grapes the first one, the code still steps through the remaining 999,999 elements. This is <span class="No-Break">horribly inefficient.</span></p>&#13;
			<p lang="en-GB">In the following example, we compare successive elements with a value, and stop if we find it. On each cycle, if the item is not found, we continue. If we find what we want, we jump out of the loop rather than continuing to the bitter end by testing every single item. When we do the comparison, if the current item is <em class="italic">not</em> equal to '<strong class="source-inline">grapes'</strong>, we set <strong class="source-inline">inList</strong> to <strong class="source-inline">False</strong> and the loop continues with the <span class="No-Break">next element.</span></p>&#13;
			<p lang="en-GB">If we find <strong class="source-inline">'grapes'</strong>, the <strong class="source-inline">else</strong> part of the <strong class="source-inline">if</strong> statement sets <strong class="source-inline">inList</strong> to <strong class="source-inline">True</strong> and then uses a <strong class="source-inline">break</strong> statement to exit the loop and avoid further pointless cycles round the loop. A <strong class="source-inline">break</strong> in a <strong class="source-inline">for</strong> or <strong class="source-inline">while</strong> loop tells Python to exit the loop now and continue <a id="_idIndexMarker307"/>with the next instruction <em class="italic">after</em> <span class="No-Break">the loop:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>listSize = len(fruit1)</span>&#13;
<span>for i in range (0,listSize):</span>&#13;
<span>    if fruit1[i] != 'grapes': inList = False   <span class="sc-comment"># Is the item here?"</span></span>&#13;
<span>    else:                                      <span class="sc-comment"># If it is, drop out of the loop</span></span>&#13;
<span>        inList = True                          <span class="sc-comment"># Set flag on finding it</span></span>&#13;
<span>        break                                  <span class="sc-comment"># Jump out of the loop</span></span></pre>&#13;
			<p lang="en-GB">The variable <strong class="source-inline">inList</strong> is just a flag that we can use later in the program; for example, we could <span class="No-Break">write this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if inList == False: print('Yes, we have no grapes')</span>&#13;
<span>if inList == True:  print('Grapes --- we got lots')</span></pre>&#13;
			<p lang="en-GB">Another approach is to use the list operator <strong class="source-inline">in</strong>. If we have a list, we can check whether an item is a member of that list by using the <span class="No-Break">following construct:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if    'grapes' in fruit1:</span>&#13;
<span>      inList = True</span>&#13;
<span>else: inList = False</span></pre>&#13;
			<p lang="en-GB">The first line returns <strong class="source-inline">True</strong> if <strong class="source-inline">'grapes'</strong> is in the list <strong class="source-inline">fruit1</strong>, and <strong class="source-inline">False</strong> otherwise. The <strong class="source-inline">in</strong> construct is very useful in testing whether an item belongs to a group of other items arranged as a list; for example, if all employees are in the list <span class="No-Break"><strong class="source-inline">staff</strong></span><span class="No-Break">, then</span></p>&#13;
			<p lang="en-GB">sets <strong class="source-inline">worksHere</strong> to <strong class="source-inline">True</strong> if <strong class="source-inline">Smith</strong> is a valid employee name, and <span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break"> otherwise.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if 'Smith' in staff:  worksHere = True</span>&#13;
<span>else:                 worksHere = False</span></pre>&#13;
			<p lang="en-GB">Later we will use the <strong class="source-inline">in</strong> <a id="_idIndexMarker308"/>operator in to test whether an instruction is a member of a set, <span class="No-Break">as here:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>arithOps = ['ADD','SUB','MUL','DIV']       <span class="sc-comment"># Define list of arithmetic operations</span></span>&#13;
<span>.</span>&#13;
<span>.</span>&#13;
<span>if 'mnemonic' <strong class="bold">in</strong> arithOps:                 <span class="sc-comment"># Test whether instruction is arithmetic</span></span>&#13;
<span>    .</span>&#13;
<span>    .</span>&#13;
<span>else:</span></pre>&#13;
			<h2 id="_idParaDest-84" lang="en-GB"><a id="_idTextAnchor084"/>Repetition and Iterables</h2>&#13;
			<p lang="en-GB">Another version of the <strong class="source-inline">for</strong> loop iterates <a id="_idIndexMarker309"/>over the elements of a list <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">for</strong> i <strong class="bold">in</strong> anyList:                          <span class="sc-comment"># Operate on each element of the list one-by-one</span></span>&#13;
<span>    &lt;body of loop&gt;</span></pre>&#13;
			<p lang="en-GB">The words in bold are the reserved Python words; the other words are user-defined variables. Here, the <strong class="source-inline">i</strong> is not a sequence-counting integer as it was in the previous example using <strong class="source-inline">range()</strong>. It is the value of each element (or iterable) in the list taken in turn. Consider the following example using a list <span class="No-Break">of colors:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>car = ['red', 'white', 'green' ,'silver', 'teal']</span>&#13;
<span>for color in car: print(color)             <span class="sc-comment"># Color is a loop variable; we could have used i.</span></span></pre>&#13;
			<p lang="en-GB">This code steps through each element of the list <strong class="source-inline">car</strong> and prints out its value, <span class="No-Break">as follows.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>red</span>&#13;
<span>white</span>&#13;
<span>green</span>&#13;
<span>silver</span>&#13;
<span>teal</span></pre>&#13;
			<p lang="en-GB">Consider an example using a list of computer operations. In this case we’ve taken a list of tuples, one for <a id="_idIndexMarker310"/>each of four op-codes. The tuple consists of an op-code string, an instruction type, and the number of operands required. This is just a demonstration. We could have used a list but chose a tuple to emphasize that the tuple values do <span class="No-Break">not change:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>opCodes = [('NOP','misc',0),('BEQ','flow',1),('LDR','move',2), \</span>&#13;
<span>          ('ADD', 'arith',3)]</span>&#13;
<span>for instruction in opCodes:                <span class="sc-comment"># Step through the op-codes</span></span>&#13;
<span>    print(instruction)                     <span class="sc-comment"># Print the current op-code</span></span>&#13;
<span>    op     = instruction[0]                <span class="sc-comment"># Extract the three tuple members</span></span>&#13;
<span>    group  = instruction[1]</span>&#13;
<span>    params = instruction[2]</span>&#13;
<span>    print(op, group, params)               <span class="sc-comment"># Print the three tuple values</span></span></pre>&#13;
			<pre class="source-code">    if op == 'BEQ': print('beq found')     <span class="sc-comment"># Demo! Print BEQ when we find it</span></pre>&#13;
			<p lang="en-GB">The output of this code fragment is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>('NOP', 'misc', 0)</span>&#13;
<span>NOP misc 0</span>&#13;
<span>('BEQ', 'flow', 1)</span>&#13;
<span>BEQ flow 1</span>&#13;
<span>beq found</span>&#13;
<span>('LDR', 'move', 2)</span>&#13;
<span>LDR move 2</span>&#13;
<span>('ADD', 'arith', 3)</span>&#13;
<span>ADD arith 3</span></pre>&#13;
			<p lang="en-GB">We have now <a id="_idIndexMarker311"/>demonstrated that you can iterate through a list of any type <span class="No-Break">in Python.</span></p>&#13;
			<p lang="en-GB">A particularly interesting feature of Python is looping with a<em class="italic"> double index</em>. You can step through a list by numeric index, or by object name. This is useful when you want to step through by object name but would also like to know where it is in the list. The Python function <strong class="source-inline">enumerate</strong> permits this form of looping. It is easier to demonstrate the action of <strong class="source-inline">enumerate</strong> than to explain it. Consider the previous example of the <span class="No-Break">list </span><span class="No-Break"><strong class="source-inline">car</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>car = [ 'red', 'white', 'green', 'silver', 'teal']</span>&#13;
<span>for color in enumerate(car):</span>&#13;
<span>    print (color)</span></pre>&#13;
			<p lang="en-GB">The output from this code is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(0, 'red')</span>&#13;
<span>(1, 'white')</span>&#13;
<span>(2, 'green')</span>&#13;
<span>(3, 'silver')</span>&#13;
<span>(4, 'teal')</span></pre>&#13;
			<p lang="en-GB">The iterator, <strong class="source-inline">color</strong>, has become a sequence of tuples with the element index and the corresponding value from the list. Remember that a tuple is like a list except that its elements are immutable and can’t be changed. Here’s a case where I would use an iterator name like <em class="italic">color</em>, rather than <strong class="source-inline">i</strong>, because it is more explicit/descriptive, and it is less easy to confuse with <span class="No-Break">an integer.</span></p>&#13;
			<p lang="en-GB">An alternative form of<a id="_idIndexMarker312"/> enumeration uses two indices, one an explicit integer count and one an element count. In the following example, <strong class="source-inline">count</strong> is the explicit integer index and <strong class="source-inline">color</strong> is the enumeration index. Thus, <strong class="source-inline">count</strong> steps <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong> etc., and <strong class="source-inline">color</strong> steps <strong class="source-inline">red</strong>, <strong class="source-inline">white</strong>, <span class="No-Break"><strong class="source-inline">green</strong></span><span class="No-Break"> …:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">for</strong> count, color <strong class="bold">in enumerate</strong>(car):</span></pre>&#13;
			<pre class="source-code">    print ('count = ', count, 'Color =', color)</pre>&#13;
			<p lang="en-GB">This produces the <span class="No-Break">following output:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>count =  0 Color = red</span>&#13;
<span>count =  1 Color = white</span>&#13;
<span>count =  2 Color = green</span>&#13;
<span>count =  3 Color = silver</span>&#13;
<span>count =  4 Color = teal</span></pre>&#13;
			<h2 id="_idParaDest-85" lang="en-GB"><a id="_idTextAnchor085"/>Lists of lists</h2>&#13;
			<p lang="en-GB">Here we extend<a id="_idIndexMarker313"/> the use of Python’s most important data structure, the list. First, we demonstrate that a list can, itself, contain lists. Python lets you construct lists with any type of item; for example, <strong class="source-inline">x = [1,2,'test',v,True]</strong> defines a list with two integers, a string, a variable, and a Boolean constant. Since you can use any legal element in a list, you can create a <em class="italic">list of lists</em>. <span class="No-Break">Consider this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>fruit = [<span class="sc-source-bg">['apple',2.35,150]</span>, [<span class="sc-source-bg">'orange',4.10,200]</span>, <span class="sc-source-bg">['banana',3.65,70]</span>]</span></pre>&#13;
			<p lang="en-GB"> This is a list of three items and each item is a list itself (shaded); for example, the first item in this list is the list <span class="pcode-bg">['apple',2.35,150]</span>. Each sub-list consists of a string naming the fruit, the price of the fruit, and the current <span class="No-Break">stock level.</span></p>&#13;
			<p lang="en-GB">Suppose we want to know the price of oranges; we could write something <span class="No-Break">like this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for i in range (0,len(fruit)):     <span class="sc-comment"># Step through the list of fruit.  len(fruit) is 3</span></span>&#13;
<span>    if fruit<strong class="bold">[i]</strong><span class="sc-source-bold-bg">[0]</span> == 'orange':    <span class="sc-comment"># If the first element in the current item is 'orange',</span></span>&#13;
<span>        price = fruit<strong class="bold">[i]</strong><span class="sc-source-bold-bg">[1]</span>        <span class="sc-comment"># then get the second element in that item</span></span>&#13;
<span>        break                      <span class="sc-comment"># If we do find 'orange' we can break out of the loop</span></span></pre>&#13;
			<p lang="en-GB">We use a <strong class="source-inline">for</strong> loop to step through the list of fruits. Then, when we’ve located the item we want (which is a list), we read the second item of that list. As you can see, we use two subscripts, first <span class="pcode-bold">[i]</span> and <span class="No-Break">then </span><span class="No-Break"><span class="pcode-bold-bg">[1]</span></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Consider the following<a id="_idIndexMarker314"/> example of lists <span class="No-Break">of lists:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>testList = [[4,9,[1,6]],[8,7,[0,9]]]</span></pre>&#13;
			<p lang="en-GB">This is not easy on the eye! Let’s use bold font and shading to emphasize the components of <span class="No-Break">the string:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>testList = [<strong class="bold">[4,9,</strong><span class="sc-source-bg">[1,6]</span><strong class="bold">],</strong> [<strong class="bold">8,7,</strong><span class="sc-source-bg">[0,9]</span><strong class="bold">]</strong>]  <span class="sc-comment"># Each element in the list is itself a list</span></span></pre>&#13;
			<p lang="en-GB">It’s a list consisting of two items: <span class="pcode-bold">[4,9,</span><span class="pcode-bg">[1,6]</span><span class="pcode-bold">]</span> and <span class="pcode-bold">[8,7</span><strong class="bold">,</strong><span class="pcode-bg">[0,9]</span><span class="pcode-bold">]</span>. Each of these items is itself a list consisting of three items: two integers and a list; for example, the elements of the first item are <strong class="source-inline">4</strong>, <strong class="source-inline">9</strong> and the <span class="No-Break">list </span><span class="No-Break"><span class="pcode-bg">[1,6]</span></span><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If I were to write <strong class="source-inline">x = testList[1][2][1]</strong>, what would the value of <span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break"> be?</span></p>&#13;
			<p lang="en-GB">It would be <strong class="source-inline">9</strong>, because <strong class="source-inline">testList</strong><span class="pcode-bold">[1]</span> is <strong class="source-inline">[8,7,[0,9]]</strong> and<strong class="source-inline"> testList[1]</strong><span class="pcode-bold">[2]</span><em class="italic"> </em>is <span class="pcode-bg">[0,9]</span> and <strong class="source-inline">testList[1][2]</strong><span class="pcode-bold">[1]</span>is 9. Think of this as a tree with branches! The first branch is element <strong class="source-inline">[1]</strong> of <strong class="source-inline">testList</strong>. The second branch is element <strong class="source-inline">[2]</strong> of that branch, and the third (final) branch is element <strong class="source-inline">[1]</strong> on that second branch. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em> illustrates the concept of embedded <span class="No-Break">lists graphically.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer040" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_5.01_B19624.jpg" alt="Figure 5.1 - Illustration of embedded lists" width="1101" height="369"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 - Illustration of embedded lists</p>&#13;
			<p lang="en-GB">Consider a <span class="No-Break">second example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = ['this', 'that', 'then']</span></pre>&#13;
			<p lang="en-GB">What is <strong class="source-inline">x[2][3]</strong>? This <a id="_idIndexMarker315"/>expression yields <strong class="source-inline">'n'</strong>, because <strong class="source-inline">x[2]</strong> is <strong class="source-inline">'then'</strong> , and element 3 of that <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'n'</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-86" lang="en-GB"><a id="_idTextAnchor086"/>Indenting in python</h2>&#13;
			<p lang="en-GB">We have been indenting<a id="_idIndexMarker316"/> code since we introduced Python. Now we re-emphasize the use of the indent in Python because it is so vital to correct programming. Most computer languages allow you to group statements together, as a block, for a particular purpose. Typically, the instructions in a group are executed as a batch, one by one. Such groups are often associated with conditional statements <span class="No-Break">and loops.</span></p>&#13;
			<p lang="en-GB">Some languages indicate a block of instructions by enclosing them in curly brackets <strong class="source-inline">{ }</strong>. Consider the following. It’s not real code; it’s just plain text designed to illustrate the layout of <span class="No-Break">a program:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>{some operations}</span>&#13;
<span>{main loop</span>&#13;
<span><strong class="bold">{</strong>some other operations<strong class="bold">}</strong></span>&#13;
<span>if x == 1 {Do this batch of operations}</span>&#13;
<span>repeat</span>&#13;
<span>{do these operations}</span>&#13;
<span>}</span></pre>&#13;
			<p lang="en-GB">Here, you have several blocks of operations, which include nested blocks (i.e., a block within another block). Blocks are executed as if they were a single operation; that is, they are the computer equivalent of <em class="italic">subcontracting</em>. Although it is not a programming requirement, it is normal to use indentation as a reading aid to make the code more understandable to people, <span class="No-Break">as here:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">{</strong>some operations<strong class="bold">}</strong></span>&#13;
<span><strong class="bold">{</strong>main loop</span>&#13;
<span>     <strong class="bold">{</strong>some operations<strong class="bold">}</strong></span>&#13;
<span>     if x == 1</span>&#13;
<span>        <strong class="bold">{</strong>do this batch of operations<strong class="bold">}</strong></span>&#13;
<span>     repeat</span>&#13;
<span>        <strong class="bold">{</strong>do these operations<strong class="bold">}</strong></span>&#13;
<span><strong class="bold">}</strong></span></pre>&#13;
			<p lang="en-GB">Python doesn’t use <a id="_idIndexMarker317"/>brackets to indicate a block of consecutive operations. It requires that a block of code be indented (and the same indentation used for each member of the block). Failure to get the indentation right will either result in a failure to compile the program, or a program that doesn’t do what you think it will do. Errors of indentation are one of the first things that the novice programmer encounters. An indentation error is very easy to miss. For example, if you accidentally create an indent or remove an indent while editing a program, you can easily get an error that takes a long time <span class="No-Break">to locate.</span></p>&#13;
			<p lang="en-GB">A simple example of the use of blocks and indentation in Python is given below. Although any amount of indent is legal, by convention, an indent is normally four spaces. Each level of indentation is shaded. Note that the <strong class="source-inline">else</strong> in the last line belongs to the first <strong class="source-inline">if</strong>. If we had indented it further, it would belong to the <span class="No-Break">second </span><span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = 1</span>&#13;
<span>y = 2</span>&#13;
<span>if z == 4:</span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">    s = 1</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">    b = 2</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">    if b == 3:</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">        g = 1</span></span>&#13;
<span class="sc-bottom" lang="en-GB"><strong class="bold">else: p = 7</strong></span></pre>&#13;
			<h2 id="_idParaDest-87" lang="en-GB"><a id="_idTextAnchor087"/>The dictionary</h2>&#13;
			<p lang="en-GB">In this section we introduce Python’s <a id="_idIndexMarker318"/>dictionary mechanism, which makes writing simulators so easy. Here, you will learn how to create a dictionary that translates one thing into another, for example, translating the name of an instruction into its binary code. Here we learn about <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">The nature of <span class="No-Break">a dictionary</span></li>&#13;
				<li lang="en-GB">The advantages of a dictionary over <span class="No-Break">the list</span></li>&#13;
				<li lang="en-GB">The difference between a dictionary key and a <span class="No-Break">dictionary value</span></li>&#13;
				<li lang="en-GB">Inserting items in <span class="No-Break">a dictionary</span></li>&#13;
				<li lang="en-GB">Extracting items from <span class="No-Break">a dictionary</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Using a dictionary to solve <span class="No-Break">a problem</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The dictionary is one of Python’s most useful features, a feature that makes it so much easier to design simulators. The Python dictionary is an impressive data structure that is accessed by means of a <em class="italic">key</em>, rather than a location within the data structure. Instead of providing a location like <strong class="source-inline">myList[5]</strong>, you look up an item in a dictionary in exactly the same way you use a dictionary in everyday life. You provide the dictionary with a name (which we call a <em class="italic">key</em>) and up pops <a id="_idIndexMarker319"/>the information <em class="italic">associated</em> with that name. Keys are unique; the same key can’t appear more than once in a dictionary (just as social security numbers <span class="No-Break">are unique).</span></p>&#13;
			<p lang="en-GB">A Python dictionary has the form <strong class="source-inline">{key1:value1, key2:value2, key3:value3}</strong>; for example, <strong class="source-inline">{'UK':44, 'USA':1, 'Germany':49, 'France':33}</strong> might be used to look up a country’s international telephone prefix. The dictionary is enclosed in curly braces, and <strong class="source-inline">key:value</strong> pairs have a colon between the key and its value. The order of pairs in a dictionary does not matter, because an item is accessed by its <em class="italic">key</em> and not by its location in <span class="No-Break">the dictionary.</span></p>&#13;
			<p lang="en-GB">The key is often a string, but that is not a requirement. In our computer simulator, the keys are usually the <a id="_idIndexMarker320"/>mnemonic codes of a computer language. The value associated with a key can be any legal Python data structure. In some of the simulators we create, we often specify the value as a tuple, which is an ordered list. For example, the dictionary entry <strong class="source-inline">'INC':(8,16)</strong>has the key <strong class="source-inline">'INC'</strong> and the value <strong class="source-inline">(8,16)</strong>. Searching the dictionary using the key <strong class="source-inline">'INC'</strong>, returns the tuple <strong class="source-inline">(8,16)</strong>. In this case, the value is the format of the instruction (i.e., 8), and its op-code (<span class="No-Break">i.e., 16).</span></p>&#13;
			<p lang="en-GB">You could use a list as a value instead of a tuple, that is, <strong class="source-inline">'INC':[8,16]</strong>. The only significant difference is that you can’t change a tuple once it <span class="No-Break">is defined.</span></p>&#13;
			<p lang="en-GB">You can check whether an item is in the dictionary by writing <strong class="source-inline">if key in dictionary</strong>, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if 'INC' in opCodes:       <span class="sc-comment"># This returns True if 'INC' is in opCodes</span></span></pre>&#13;
			<p lang="en-GB">To obtain the information about a particular mnemonic, we can use the <strong class="source-inline">get</strong> method to read the value associated with the key. For example, <strong class="source-inline">opData = </strong><span class="No-Break"><strong class="source-inline">opCodes</strong></span><span class="No-Break"><span class="pcode-bold">.get</span></span><span class="No-Break"><strong class="source-inline">('INC')</strong></span><span class="No-Break"> returns</span><span class="No-Break"><strong class="source-inline">(8,16)</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We can then access the two fields of the tuple associated with <strong class="source-inline">'INC'</strong> <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>binaryCode  = opData[0]</span>&#13;
<span>formatStyle = opData[1]</span></pre>&#13;
			<p lang="en-GB">If the requested key is<a id="_idIndexMarker321"/> not in the dictionary, the <strong class="source-inline">get</strong> method returns <strong class="source-inline">None</strong>. <strong class="source-inline">None</strong> is a Python reserved word and indicates a null value. Note that <strong class="source-inline">None</strong> is not zero or an empty string, it has its own type <strong class="source-inline">None</strong>. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if opCodes.get(thisInstruction) == <span class="sc-comment">None:</span> <span class="sc-comment"># Ensure that the instruction is valid</span></span></pre>&#13;
			<pre class="source-code">   print("Error. Illegal operation")</pre>&#13;
			<p lang="en-GB">The following code uses the telephone prefix directory we described above to demonstrate how to use <strong class="source-inline">None</strong> to deal with errors. Note that this uses an infinite loop and terminates on an error. When <strong class="source-inline">None</strong> is detected, the <strong class="source-inline">break</strong> forces an exit from the <span class="No-Break">infinite loop:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>prefixes = {'UK':44, 'USA':1, 'Germany':49, 'France':33}</span>&#13;
<span>while True:                              <span class="sc-comment"># Infinite loop</span></span>&#13;
<span>    x = input('Country? ')               <span class="sc-comment"># Ask for the country</span></span>&#13;
<span>    y = prefixes.get(x)                  <span class="sc-comment"># Look up the prefix</span></span>&#13;
<span>    if y == None:                        <span class="sc-comment"># If None print error message</span></span>&#13;
<span>        print('Prefix not found')</span>&#13;
<span>        break                            <span class="sc-comment"># And exit the loop</span></span>&#13;
<span>    else: print('Prefix = ',y)</span>&#13;
<span>print('Program terminated')</span></pre>&#13;
			<p lang="en-GB">Python’s dictionaries <a id="_idIndexMarker322"/>make it incredibly easy to implement symbolic names for labels and variables. Just create a dictionary with <em class="italic">name: value</em> pairs, and use the name to get the value associated with the label; for example, you might want to associate Hastings with the value 1066. Typical assemblers use <em class="italic">directives</em> to <span class="No-Break">express this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Hastings EQU 1066      <span class="sc-comment">@ Equate the Name "Hastings" to the value 1066</span></span></pre>&#13;
			<p lang="en-GB">Later in your program, you might write <strong class="source-inline">LDRL </strong><span class="pcode-bold">r0</span><strong class="source-inline">,Hastings</strong> in order to load <strong class="source-inline">r0</strong> with <strong class="source-inline">1066</strong>. Suppose you have a table of names and values, <strong class="source-inline">namSub</strong>, that’s set up as <span class="No-Break">a dictionary:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>namSub = {'Hastings':1066, 'Agincourt':1415, 'Trafalgar':1805}</span></pre>&#13;
			<p lang="en-GB">If we wish to get the<a id="_idIndexMarker323"/> value associated with Hastings, we can <span class="No-Break">write this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = namSub.get('Hastings')</span></pre>&#13;
			<p lang="en-GB">The name will be translated into <span class="No-Break">its value.</span></p>&#13;
			<p lang="en-GB">In what follows, we’ve written several fragments of Python code in order to demonstrate how the dictionary can be used. These examples demonstrate the setting up of a dictionary, adding information to it, and accessing it. When an assembly language program is run, some dictionaries are set up before it is executed, for example, the list of legal instructions. Some directories, such as the symbol table of names appearing in the assembly language program, will be constructed as the <span class="No-Break">program runs.</span></p>&#13;
			<p lang="en-GB">The first<a id="_idIndexMarker324"/> directory in the example converts a register name into its register number; for example, a register name <strong class="source-inline">x</strong> can be converted to its register number <strong class="source-inline">y</strong> by <strong class="source-inline">y = regs.get(x)</strong>. Of course, you don’t need to use a dictionary. We could simply write <strong class="source-inline">y = int(x[1:])</strong> to convert the string <strong class="source-inline">'r6'</strong> into the integer 6 by using string processing. However, the dictionary method is more elegant and easier to follow. Moreover, it’s <span class="No-Break">more flexible:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>regs = {'r0':0, 'r1':1, 'r2':2, 'r3':3, 'r4':4}   <span class="sc-comment"># Register name-to-number translation</span></span>&#13;
<span>symTab = {'start':0,'time':24,'stackP':'sp','next':0xF2} </span>&#13;
<span>                                            <span class="sc-comment"># Symbol table converts symbolic name to value</span></span>&#13;
<span>x0 = 'add r1,r2,r4'                <span class="sc-comment"># An example of an instruction in text form</span></span>&#13;
<span>x1 = x0.split(' ')                 <span class="sc-comment"># Split instruction into op-code and predicate</span></span>&#13;
<span>x2 = x1[1].split(',')              <span class="sc-comment"># Split the predicate into tokens</span></span>&#13;
<span>x3 = x2[0]                         <span class="sc-comment"># Get the first token of x2</span></span>&#13;
<span>if x3 in regs:                     <span class="sc-comment"># Is this a valid register?</span></span>&#13;
<span>    x4 = regs.get(x3)              <span class="sc-comment"># Use get() to read its value</span></span>&#13;
<span>print ('x0 = ',x0, '\nx1 = ',x1, '\nx2 = ',x2, '\nx3 = ',x3, '\nx4 = ',x4)</span>&#13;
<span>y0 = 'beq next'                    <span class="sc-comment"># Another example: instruction with a label</span></span>&#13;
<span>y1 = y0.split(' ')                 <span class="sc-comment"># Split into op-code and predicate on the space</span></span>&#13;
<span>y2 = y1[1]                         <span class="sc-comment"># Read the predicate (i.e.,'next')</span></span>&#13;
<span>y3 = symTab.get(y2)                <span class="sc-comment"># Get its value from the symbol table (i.e., 0xF2)</span></span>&#13;
<span>print('beq ',y3)                   <span class="sc-comment"># Print the instruction with the actual address</span></span>&#13;
<span>z = symTab.get('beq next'.split(' ')[1])  <span class="sc-comment"># We've done it all in one line. Not so easy to follow.</span></span>&#13;
<span>print('beq ',z)</span>&#13;
<span>print('Symbol table ', symTab)            <span class="sc-comment"># Print the symbol table using a print</span></span>&#13;
<span>symTab['nextOne'] = 1234                  <span class="sc-comment"># This is how we add a new key and value</span></span>&#13;
<span>print('Symbol table ', symTab)            <span class="sc-comment"># Here's the augmented symbol table</span></span>&#13;
<span>opCode = {'add':('Arith',0b0001,3),'ldr':('Move',0b1100,2), \</span>&#13;
<span>       'nop':('Miscellaneous',1111,0)}    <span class="sc-comment"># New directory. Each key has three values in a tuple</span></span>&#13;
<span>thisInst = 'ldr'                          <span class="sc-comment"># Let's look up an instruction</span></span>&#13;
<span>if thisInst in opCode:                    <span class="sc-comment"># First test if it's valid and in the dictionary</span></span>&#13;
<span>    if thisInst == 'ldr':                 <span class="sc-comment"># If it is:</span></span>&#13;
<span>        instClass = opCode.get('ldr')[0]  <span class="sc-comment"># Get first element of the instruction</span></span>&#13;
<span>        binaryVal = opCode.get('ldr')[1]  <span class="sc-comment"># Get the second element</span></span>&#13;
<span>        operands  = opCode.get('ldr')[2]  <span class="sc-comment"># Get the third element</span></span>&#13;
<span>print('\nFor opCode: ',thisInst, '\nClass = ', instClass, \</span>&#13;
<span>      '\nBinary code = ', bin(binaryVal), '\nNumber of operands = ',operands)</span>&#13;
<span>print('\nThis is how to print a directory')</span>&#13;
<span>                                   <span class="sc-comment"># Now print a formatted dictionary (key and value on each line)</span></span>&#13;
<span>for <strong class="bold">key,value</strong> in opCode.items():</span>&#13;
<span>    print(key, ':', value)</span>&#13;
<span>print()</span>&#13;
<span>for <strong class="bold">i,j</strong> in opCode.items():         <span class="sc-comment"># Note that key and value can be any two variables</span></span>&#13;
<span>    print(i, ':', j)</span>&#13;
<span>theKeys = opCode.keys()            <span class="sc-comment"># The function .keys() returns the keys in a dictionary</span></span>&#13;
<span>print('The keys are: ',theKeys)</span>&#13;
<span>test = {'a':0,'b':0,'c':0,'d':0}   <span class="sc-comment"># A new directory. The values are just integers</span></span>&#13;
<span>test['a'] = test['a'] + 1          <span class="sc-comment"># You can change a value! Use the key to locate it</span></span>&#13;
<span>test['d'] = test['d'] + 7</span>&#13;
<span>test1 = {'e':0, 'f':0}             <span class="sc-comment"># Here's a second dictionary.</span></span>&#13;
<span>test.update(test1)                 <span class="sc-comment"># Append it to test using .update()</span></span>&#13;
<span>print('Updated dictionary test is: ',test)   <span class="sc-comment"># Not convinced? Here it is then.</span></span></pre>&#13;
			<p lang="en-GB">The following is the <a id="_idIndexMarker325"/>output after executing the above fragment <span class="No-Break">of code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x0 =  add r1,r2,r4</span>&#13;
<span>x1 =  ['add', 'r1,r2,r4']</span>&#13;
<span>x2 =  ['r1', 'r2', 'r3']</span>&#13;
<span>x3 =  r1</span>&#13;
<span>x4 =  1</span>&#13;
<span>beq  242</span>&#13;
<span>beq  242</span>&#13;
<span>Symbol table  {'start': 0, 'time': 24, 'stackPointer': 'sp', 'next': 242}</span>&#13;
<span>Symbol table  {'start': 0, 'time': 24, 'stackPointer': 'sp', 'next': 242,</span>&#13;
<span>               'nextOne': 1234}</span>&#13;
<span>For opCode:  ldr</span>&#13;
<span>Class =  Move</span>&#13;
<span>Binary code =  0b1100</span>&#13;
<span>Number of operands =  2</span>&#13;
<span>This is how to print a directory</span>&#13;
<span>add : ('Arith', 1, 3)</span>&#13;
<span>ldr : ('Move', 12, 2)</span>&#13;
<span>nop : ('Miscellaneous', 1111, 0)</span>&#13;
<span>add : ('Arith', 1, 3)</span>&#13;
<span>ldr : ('Move', 12, 2)</span>&#13;
<span>nop : ('Miscellaneous', 1111, 0)</span>&#13;
<span>The keys are:  dict_keys(['add', 'ldr', 'nop'])</span>&#13;
<span>Updated dictionary test is:  {'a': 1, 'b': 0, 'c': 0, 'd': 7, 'e': 0, 'f': 0}</span></pre>&#13;
			<p lang="en-GB">Let’s look at <a id="_idIndexMarker326"/>dictionaries in more detail with another example. The use of Python’s dictionaries makes it easy to implement symbolic names for labels and variables. All we have to do is to create a dictionary with <strong class="source-inline">name: value</strong> pairs and use a name to get its associated value. Suppose we’ve read an instruction, say, <strong class="source-inline">'ADD r4,r2,r3'</strong>, and tokenized it <span class="No-Break">into this:</span></p>&#13;
			<pre class="source-code">predicate = ['r4','r2','r3']  <span class="sc-comment"># The list of parameters for the op-code</span></pre>&#13;
			<p lang="en-GB">We can get the integer value of a register the hard way by <span class="No-Break">using slicing:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>rD = int([predicate[0]][1:])</span></pre>&#13;
			<p lang="en-GB">Let’s simplify the expression to make the explanation easier. Suppose we <span class="No-Break">write this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>rD = predicate[0]</span></pre>&#13;
			<p lang="en-GB">The value of <strong class="source-inline">rD</strong> is the string <strong class="source-inline">'r4'</strong>. What we need to do is to isolate the <strong class="source-inline">'4'</strong> from <strong class="source-inline">'r4'</strong> and then convert the character <strong class="source-inline">'4'</strong> to the <span class="No-Break">integer </span><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We can write <strong class="source-inline">rD = rD[1:]</strong> to return all characters in the string except the initial <strong class="source-inline">'r'</strong>. The final step is to convert to an integer, which we can do with <strong class="source-inline">rD = </strong><span class="No-Break"><strong class="source-inline">int(rD)</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">[1:]</strong> means all the characters after the first character, <strong class="source-inline">r</strong>, which returns <strong class="source-inline">'4'</strong> if the register was <strong class="source-inline">'r4'</strong>. We could have written <strong class="source-inline">[1:2]</strong> rather than <strong class="source-inline">[1:]</strong>. However, by using <strong class="source-inline">[1:]</strong>, we can later increase the number of registers beyond 9 without changing the program. Putting all three steps together, we <span class="No-Break">get this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>rD = int([predicate[0]][1:])</span></pre>&#13;
			<p lang="en-GB">Let’s use a dictionary to carry out the same action. Assume also that we’ve set up a directory for the registers: </p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>regs = {'r0':0, 'r1':1, 'r2':2, 'r3':3, 'r4':4}   <span class="sc-comment"># Register names and values</span></span></pre>&#13;
			<p lang="en-GB">Before processing a register name, we can test for a valid register symbolic name <span class="No-Break">with this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if predicate[0] in regs:</span>&#13;
<span>      &lt;deal with valid name&gt;</span>&#13;
<span>else: &lt;deal with error&gt;</span></pre>&#13;
			<p lang="en-GB">Extracting the actual integer number of the register <span class="No-Break">is easy:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>rD = regs.get(predicate[0])</span></pre>&#13;
			<p lang="en-GB">Finally, note that you can<a id="_idIndexMarker327"/> access a dictionary in two ways. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>regs = {'r0':0, 'r1':1, 'r2':2, 'r3':3, 'r4':4}</span>&#13;
<span><strong class="bold">aaa  = regs.get('r3')</strong></span>&#13;
<span><strong class="bold">bbb  = regs['r3']</strong></span>&#13;
<span>print('Test aaa = ',aaa, 'bbb =',bbb)</span></pre>&#13;
			<p lang="en-GB">This gives <span class="No-Break">us this:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Test aaa =  3 bbb = 3</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The advantage of <strong class="source-inline">get</strong> is that it returns <strong class="source-inline">None</strong> if the key is not found, whereas the other method creates a runtime error, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">KeyError</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-88" lang="en-GB"><a id="_idTextAnchor088"/>Functions revisited</h2>&#13;
			<p lang="en-GB">This section looks at<a id="_idIndexMarker328"/> functions in a little more detail and demonstrates the use of the <strong class="source-inline">global</strong> statement to make parameters accessible outside <span class="No-Break">a function.</span></p>&#13;
			<p lang="en-GB">Parameters can be passed to functions in parentheses in the function call, and results retrieved by a <strong class="source-inline">return()</strong> statement. Recall that variables created in a function are local to the function unless they are declared as global; that is, if you write <strong class="source-inline">x = 5</strong> in a function, you have created a local variable <strong class="source-inline">x</strong> with the value <strong class="source-inline">5</strong>. If there is an <strong class="source-inline">x</strong> outside the function, it is a different <strong class="source-inline">x</strong>. A value declared outside a function can be accessed inside the function provided it hasn’t been declared as a local variable within <span class="No-Break">the function.</span></p>&#13;
			<p lang="en-GB">The body of a function is indented from the initial <strong class="source-inline">def</strong> statement. A function does not need an explicit termination, because<em class="italic"> indentation</em> takes care of that. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def adder(P,Q):                    <span class="sc-comment"># Adder function</span></span>&#13;
<span>   R = P + Q</span>&#13;
<span>   return (R)                      <span class="sc-comment"># Return the sum R</span></span>&#13;
<span>def subtractor(P,Q):               <span class="sc-comment"># Subtractor function</span></span>&#13;
<span>   global R                        <span class="sc-comment"># Make R global</span></span>&#13;
<span>   R = P – Q                       <span class="sc-comment"># No need to return a value</span></span>&#13;
<span>A, B = 7, 2                        <span class="sc-comment"># Note Python's multiple assignment</span></span>&#13;
<span>C = adder(A,B)                     <span class="sc-comment"># Do addition</span></span>&#13;
<span>subtractor(A,B)                    <span class="sc-comment"># Do subtraction (just call the function)</span></span>&#13;
<span>print('Sum =', C, 'Diff = ',R)</span></pre>&#13;
			<p lang="en-GB">If we run this program we get <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Sum = 9 Diff =  5</span></pre>&#13;
			<p lang="en-GB">As you can see, we can return a value as an argument in the return statement, or we can make it global. When <a id="_idIndexMarker329"/>we do use the global variables, we don’t need to pass the parameters to or from <span class="No-Break">the function.</span></p>&#13;
			<h2 id="_idParaDest-89" lang="en-GB"><a id="_idTextAnchor089"/>Imports</h2>&#13;
			<p lang="en-GB">This section shows how you can <a id="_idIndexMarker330"/>access operations that are not part of the Python language itself. These functions are not vital to writing a simulator, but they do provide some very useful facilities. We’ve included this short section to demonstrate how these facilities <span class="No-Break">are accessed.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">A strength of Python is that it includes several libraries of functions that you can access to facilitate the design of programs, for example, graphics. We don’t need many external functions for our work. Here, we will demonstrate two: <strong class="source-inline">random</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">sys</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">When simulating a computer, you often need data for testing. Typing it in is time-consuming. Fortunately, Python has a library of functions that generate random numbers. In order to use a library, you first have to import it. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>import random                   <span class="sc-comment"># Get the library (usually at the start of the program)</span></span>&#13;
<span>.</span>&#13;
<span>.</span>&#13;
<span>X = random.randint(0,256)       <span class="sc-comment"># Generate a random integer in the range 0 to 255</span></span></pre>&#13;
			<p lang="en-GB">Function calls are usually of the form <strong class="source-inline">library.action</strong>. In this case, the library is <strong class="source-inline">random</strong> and the action is <strong class="source-inline">randomint(a,b)</strong>. The parameters <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> give the range of random <span class="No-Break">integer values.</span></p>&#13;
			<p lang="en-GB">Another useful library is <strong class="source-inline">sys</strong>, which<a id="_idIndexMarker331"/> provides operating system functions such as <strong class="source-inline">exit()</strong>, which terminates a Python program and returns to its calling level. See this, <span class="No-Break">for example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>import sys                      <span class="sc-comment"># Get the system library</span></span>&#13;
<span>.</span>&#13;
<span>.</span>&#13;
<span>if run == 0: sys.exit()         <span class="sc-comment"># If run is 0 then go home (exit the Python program)</span></span></pre>&#13;
			<p lang="en-GB">We have now covered <a id="_idIndexMarker332"/>enough Python topics to begin to design a real computer simulator in the <span class="No-Break">next chapter.</span></p>&#13;
			<h1 id="_idParaDest-90" lang="en-GB"><a id="_idTextAnchor090"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we’ve extended our knowledge of Python and introduced or expanded some of the features that demonstrate its power and versatility. For example, we’ve looked at the list and the string, the two data structures that are of most importance to us. We’ve also expanded on the use of loops and other <span class="No-Break">repetitive structures.</span></p>&#13;
			<p lang="en-GB">We’ve introduced the dictionary, a delightfully elegant data structure that enables us to locate information by a key that describes it, rather than its location in the directory. For example, if we want to convert instruction names into binary op-code, we can create a dictionary and just look up the appropriate code for any mnemonic. This feature really does simplify the design of interpreters <span class="No-Break">and assemblers.</span></p>&#13;
			<p lang="en-GB">We’ve also looked at one of Python’s more unusual features: list comprehensions. These take a little getting used to, but they can make it much easier to process the text of assembly language instructions by cleaning up the input (for example, by removing spaces, or modifying punctuation <span class="No-Break">and syntax).</span></p>&#13;
			<p lang="en-GB">In <a href="B19624_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> we put together the things we’ve learned about the operation of a computer and design an assembler and a simulator for a hypothetical computer <span class="No-Break">called TC1.</span></p>&#13;
		</div>&#13;
	</div></body></html>