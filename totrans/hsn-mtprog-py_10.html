<html><head></head><body>
<div><div><h1 id="_idParaDest-105"><em class="italic"><a id="_idTextAnchor107"/>Chapter 8</em>: Defining Templates for Algorithms</h1>
<p>In this chapter, we will look at what templates are and how to implement template programming in Python.</p>
<p>What are templates and where are they useful? The main usage of applying the concepts of metaprogramming during the process of developing an application is to design a reusable framework that can be manipulated externally through the programming of metadata of Python objects rather than modifying the object itself. Templates, as the name suggests, can act as a template, a format, or a model on how a sequence of operations can be performed on a Python object. These templates can be used to define the common functionalities of methods within a class and to reuse them through the application of the object-oriented programming concept of <strong class="bold">inheritance</strong>.</p>
<p>Throughout this chapter, we will look at understanding how templates can be defined and used in Python and how a sequence of common operations can be designed into a template that fits into a framework. Speaking of designs, template programming is one of the main concepts within the design patterns of Python. Design patterns will be covered in detail in <a href="B13426_12_Final_PG_epub.xhtml#_idTextAnchor154"><em class="italic">Chapter 12</em></a> on design patterns.</p>
<p>In this chapter, we will be taking a look at the following main topics:</p>
<ul>
<li>Explaining a sequence of operations</li>
<li>Defining the sequence of methods</li>
<li>Identifying the common functionalities</li>
<li>Designing templates</li>
</ul>
<p>By the end of this chapter, you should be able to apply generics and type checking on Python variables. You should also be able to create your own domain-specific data types.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor108"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08</a>.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor109"/>Explaining a sequence of operations</h1>
<p>Developing<a id="_idIndexMarker396"/> algorithms is always interesting, especially<a id="_idIndexMarker397"/> in a language like Python where less code needs to be written to complete an action compared to any other programming language. An <strong class="bold">algorithm</strong> is a simple sequence of steps that need to be performed to accomplish a task. While developing any algorithm, the most important aspect is to ensure that we are following the steps to perform the action in the right sequence. This section covers examples of a sequence of operations and how they can be defined in a Python program.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor110"/>Back to our core example</h2>
<p>In this chapter, we will <a id="_idIndexMarker398"/>continue using our core example of <em class="italic">ABC Megamart</em>, and we will specifically look at the billing counter where we can perform a sequence of operations. The reason we are focusing on a sequence of operations here is to especially understand <a id="_idIndexMarker399"/>how <strong class="bold">templates</strong> can be utilized to perform a set of tasks, and also how they can be reused to perform similar kinds of other tasks too. So, let’s begin.</p>
<p>At <em class="italic">ABC Megamart</em>, we have four different checkout counters to check out the shopping items from the cart. The details of the counters are as follows:</p>
<ul>
<li>The first one is to check out items that contain vegetables and dairy.</li>
<li>The second one is to check out items that contain less than 10 assorted items, excluding electronics, vegetables, and dairy.</li>
<li>The third one is to check out items that contain more than 10 assorted items, excluding electronics, vegetables, and dairy. </li>
<li>The fourth one is to check out electronic goods.</li>
</ul>
<p>Each of these counters is performing a sequence of operations and at this point in time, they might look like they are an independent set of operations. The goal of this chapter is to create templates and look at a common way of connecting these independent operations. To connect them and create a template, we need to understand the sequence of operations in each of these counters.</p>
<p>Let’s now look at what each of the counters will work on.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor111"/>The vegetables and dairy counter</h2>
<p>The<a id="_idIndexMarker400"/> journey of a customer to the billing counter starts from the vegetable section, where vegetables are added to the shopping cart, the customer then stands in a queue at the respective billing counter, vegetables and fruit are weighed and packed, a price tag with a bar code is added on the packet, the bar code is scanned and the bill is added to the invoice for each item, a tax component is added for each item, and the bill is totaled, printed, and handed over to the customer, who then pays the bill.</p>
<p>The graphical representation of the steps is as follows:</p>
<div><div><img alt="Figure 8.1 – Vegetables counter " height="890" src="img/Figure_8.1_B13426.jpg" width="1342"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Vegetables counter</p>
<p>The following functions will be defined to perform each of these operations:</p>
<pre class="source-code">return_cart()</pre>
<pre class="source-code">goto_vege_counter()</pre>
<pre class="source-code">weigh_items()</pre>
<pre class="source-code">add_price_tag()</pre>
<pre class="source-code">scan_bar_code()</pre>
<pre class="source-code">add_billing()</pre>
<pre class="source-code">add_tax()</pre>
<pre class="source-code">calc_bill()</pre>
<pre class="source-code">print_invoice()</pre>
<pre class="source-code">receive_payment()</pre>
<p>Let’s <a id="_idIndexMarker401"/>further look at the next counter, which handles less than 10 items.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor112"/>Less than 10 items counter</h2>
<p>When a<a id="_idIndexMarker402"/> customer adds less than 10 items to the cart and the items do not contain vegetables, fruit, dairy, or electronics, then the customer goes to the less than 10 items counter where the bar code on each item is scanned and the bill is added to the invoice for each item, a tax component is added for each item, and the bill is totaled, printed, and handed over to the customer, who then pays the bill.</p>
<p>The graphical representation of the steps is as follows:</p>
<div><div><img alt="Figure 8.2 – Less than 10 items counter " height="889" src="img/Figure_8.2_B13426.jpg" width="1342"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Less than 10 items counter</p>
<p>The following functions will be defined to perform each of these operations:</p>
<pre class="source-code">return_cart()</pre>
<pre class="source-code">goto_less_t10_counter()</pre>
<pre class="source-code">review_items()</pre>
<pre class="source-code">count_items()</pre>
<pre class="source-code">scan_bar_code()</pre>
<pre class="source-code">add_billing()</pre>
<pre class="source-code">add_tax()</pre>
<pre class="source-code">calc_bill()</pre>
<pre class="source-code">print_invoice()</pre>
<pre class="source-code">receive_payment()</pre>
<p>Let’s further<a id="_idIndexMarker403"/> look at the next counter, which handles more than 10 items.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor113"/>The greater than 10 items counter</h2>
<p>When a <a id="_idIndexMarker404"/>customer adds more than 10 items to the cart and the items do not contain vegetables, fruit, dairy, or electronics, then the customer goes to the greater than 10 items counter where the bar code on each item is scanned and the bill is added to the invoice for each item, coupons are applied, a tax component is added for each item, and the bill is totaled, printed, and handed over to the customer, who then pays the bill.</p>
<p>The graphical representation of the steps is as follows:</p>
<div><div><img alt="Figure 8.3 – Greater than 10 items counter " height="603" src="img/Figure_8.3_B13426.jpg" width="860"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Greater than 10 items counter</p>
<p>The<a id="_idIndexMarker405"/> following functions will be defined to perform each of these operations:</p>
<pre class="source-code">return_cart()</pre>
<pre class="source-code">gotoGreatT10Counter()</pre>
<pre class="source-code">review_items()</pre>
<pre class="source-code">count_items()</pre>
<pre class="source-code">scan_bar_code()</pre>
<pre class="source-code">add_billing()</pre>
<pre class="source-code">apply_coupon()</pre>
<pre class="source-code">add_tax()</pre>
<pre class="source-code">calc_bill()</pre>
<pre class="source-code">print_invoice()</pre>
<pre class="source-code">receive_payment()</pre>
<p>Let’s further look at the next counter, which handles electronic items.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor114"/>Electronics counter</h2>
<p>The <a id="_idIndexMarker406"/>last counter is the electronics counter, where a customer goes to the counter, gets the electronic items tested, the item is scanned, and the bill is added to the invoice for each item. A tax component is added for each item and the bill is totaled, printed, and handed over to the customer, who then pays the bill.</p>
<p>The graphical representation of the steps is as follows:</p>
<div><div><img alt="Figure 8.4 – Electronics counter " height="941" src="img/Figure_8.4_B13426.jpg" width="1342"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Electronics counter</p>
<p>The following functions will be defined to perform each of these operations:</p>
<pre class="source-code">return_cart()</pre>
<pre class="source-code">goto_electronics_counter()</pre>
<pre class="source-code">review_items()</pre>
<pre class="source-code">test_electronics()</pre>
<pre class="source-code">scan_bar_code()</pre>
<pre class="source-code">add_billing()</pre>
<pre class="source-code">apply_coupon()</pre>
<pre class="source-code">add_tax()</pre>
<pre class="source-code">calc_bill()</pre>
<pre class="source-code">print_invoice()</pre>
<pre class="source-code">receive_payment()</pre>
<p>In each of the<a id="_idIndexMarker407"/> preceding billing counters, we looked at the sequence of operations that happens for a sale to complete. </p>
<p>With this understanding, let’s look at defining each of the operations into methods in the following section.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor115"/>Defining the sequence of methods</h1>
<p>Defining the<a id="_idIndexMarker408"/> methods helps us in understanding each of the operations performed at each counter in detail. Let’s define the classes and methods required to fulfill the actions to be performed in each operation. We will be covering the following counters in this section:</p>
<ul>
<li>The vegetable counter</li>
<li>Less than 10 items counter</li>
<li>Greater than 10 items counter</li>
<li>The electronics counter</li>
</ul>
<p>Let’s begin with the vegetable counter. </p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor116"/>The vegetable counter</h2>
<p>The <a id="_idIndexMarker409"/>following are the steps for the operation of this counter:</p>
<ol>
<li>We will first create the <code>VegCounter</code> class as follows:<pre>class VegCounter():</pre></li>
<li>In the following code, we will be defining the <code>return_cart</code> method that returns the list of items added to the shopping cart:<pre>    def return_cart(self,*items):
        cart_items = list(items)
        return cart_items</pre></li>
<li>Let’s now<a id="_idIndexMarker410"/> return the name of the counter to be included in the bill. For this example, the counter name is <code>Vegetables &amp; Dairy</code>:<pre>    def goto_vege_counter(self):
        return 'Vegetables &amp; Dairy'</pre></li>
<li>In the following code, let’s define the method to weigh the items in the cart and return a dictionary of items and their corresponding weights:<pre>    def weigh_items(self,*weights,cart_items = None):
        weight = list(weights)
        item_weight = dict(zip(cart_items, weight))
        return item_weight</pre></li>
<li>Next, let’s define a method to take the unit price and weights as input and calculate the price of each item by multiplying the weights and unit price:<pre>    def add_price_tag(self,*units,weights = None):
        pricetag = []
        for item,price in zip(weights.items(),list(units)):
            pricetag.append(item[1]*price)
        return pricetag        </pre></li>
<li>In the following method, let’s input bar codes to each of the items in the cart and return the bar codes as a list:<pre>    def scan_bar_code(self,*scan):
        codes = list(scan)
        return codes</pre></li>
<li>Next, let’s add a method to add price tags to the bar codes by creating a dictionary object and adding the codes and their corresponding price tags as key-value pairs:<pre>    def add_billing(self,codes=None,pricetag=None):
        self.codes = codes
        self.pricetag = pricetag
        bill = dict(zip(self.codes, self.pricetag))
        return bill</pre></li>
<li>Then, let’s add tax percentages for each of the items and return the tax values as a list:<pre>    def add_tax(self,*tax):
        taxed = list(tax)
        return taxed</pre></li>
<li>Let’s further <a id="_idIndexMarker411"/>use the price tags and the tax values and calculate the bill for each of the items in the cart, and create a dictionary to add the items and their corresponding billing amount:<pre>    def calc_bill(self,bill,taxes,cart_items):
        items = []
        calc_bill = []
        for item,tax in zip(bill.items(),taxes):
            items.append(item[1])
            calc_bill.append(item[1] + item[1]*tax)
        finalbill = dict(zip(cart_items, calc_bill))
        return finalbill</pre></li>
<li>In the following method, let’s print the invoice with the counter name, items in the cart, price, and the total bill amount: <pre>    def print_invoice(self,finalbill):
        final_total = sum(finalbill.values())
        print('**************ABC Megamart*****************')
        print('***********------------------**************')
        print('Counter Name: ', self.goto_vege_counter())
        for item,price in finalbill.items():
            print(item,": ", price)
        print('Total:',final_total)
        print('***********------------------**************')</pre></li>
<li>Then, let’s <a id="_idIndexMarker412"/>print the invoice with a statement stating that the invoice is paid:<pre>    def receive_payment(self,finalbill):
        final_total = sum(finalbill.values())
        print('**************ABC Megamart*****************')
        print('***********------------------**************')
        print('Counter Name: ', self.goto_vege_counter())
        for item,price in finalbill.items():
            print(item,": ", price)
        print('Total:',final_total)
        print('***********------------------**************')
        print('***************PAID************************')</pre></li>
<li>Executing the preceding code results in the following. The methods are called in a sequence so <a id="_idIndexMarker413"/>that the results from one method are provided as input to the next step:<pre>veg = VegCounter()
cart = veg.return_cart('onions','tomatoes','carrots','lettuce')
item_weight = veg.weigh_items(1,2,1.5,2.5,cart_items = cart)
pricetag = veg.add_price_tag(7,2,3,5,weights = item_weight)
codes = veg.scan_bar_code(113323,3434332,2131243,2332783)
bill = veg.add_billing(codes,pricetag)
taxes = veg.add_tax(0.04,0.03,0.035,0.025)
finalbill = veg.calc_bill(bill,taxes,cart)
veg.print_invoice(finalbill)</pre></li>
</ol>
<p>The output of the printed invoice looks as follows:</p>
<pre><strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  Vegetables &amp; Dairy</strong>
<strong class="bold">onions :  7.28</strong>
<strong class="bold">tomatoes :  4.12</strong>
<strong class="bold">carrots :  4.6575</strong>
<strong class="bold">lettuce :  12.8125</strong>
<strong class="bold">Total: 28.87</strong>
<strong class="bold">***********------------------**************</strong></pre>
<ol>
<li value="13">Next, let’s print the invoice that has been paid by the customer, <code>veg.receive_payment(finalbill)</code>.</li>
</ol>
<p>The<a id="_idIndexMarker414"/> output of the paid invoice looks as follows:</p>
<pre><strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  Vegetables &amp; Dairy</strong>
<strong class="bold">onions :  7.28</strong>
<strong class="bold">tomatoes :  4.12</strong>
<strong class="bold">carrots :  4.6575</strong>
<strong class="bold">lettuce :  12.8125</strong>
<strong class="bold">Total: 28.87</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<h2 id="_idParaDest-115"><a id="_idTextAnchor117"/>Less than 10 items counter</h2>
<p>Similar to <a id="_idIndexMarker415"/>the class defined for the vegetable counter, we can also define the methods for the remaining three counters. The detailed code for the remaining counters is available at <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter08</a>. </p>
<p>For the code for this counter, let’s create the <code>LessThan10Counter</code> class and add all of its methods, which includes <code>return_cart</code>, <code>goto_less_t10_counter</code>, <code>review_items</code>, <code>count_items</code>, <code>scan_bar_code</code>, <code>add_billing</code>, <code>add_tax</code>, <code>calc_bill</code>, <code>print_invoice</code>, and <code>receive_payment</code>. For simplicity, let’s look at the additional methods that we have in each counter instead of repeating all of the methods:</p>
<ol>
<li value="1">Let’s start by creating the <code>LessThan10Counter</code> class:<pre>class LessThan10Counter():
…    </pre></li>
<li>In this <a id="_idIndexMarker416"/>class, we have a <code>goto_less_t10_counter</code> method, which returns the name of the counter:<pre>    def goto_less_t10_counter(self):
          return 'Less than 10 counter'</pre></li>
<li>We also have the following method to review the items in the cart to make sure that they are not electronic, vegetable, fruit, or dairy products:<pre>     def review_items(self,item_type = None):
        veg_cart = ['Vegetables', 'Dairy', 'Fruits']
        if (item_type == 'Electronics'):
            print("Move to Electronics Counter")
        elif (item_type in veg_cart):        
            print("Move to Vege Counter")</pre></li>
<li>In the following method, let’s count the items to make sure that the total number of items in the cart is less than <code>10</code>:<pre>    def count_items(self,cart_items = None):
        if len(cart_items)&lt;=10:
            print("Move to Less than 10 items counter")
        else:
            print("Move to Greater than 10 items counter")
    …</pre></li>
<li>Executing all of the methods for this class in a sequence results in the following:<pre>less10 = LessThan10Counter()
cart = less10.return_cart('paperclips','blue pens','stapler','pencils')
less10.review_items(item_type = ['stationary'])
less10.count_items(cart)
codes = less10.scan_bar_code(113323,3434332,2131243,2332783)
bill = less10.add_billing(10,15,12,14,codes = codes)
taxes = less10.add_tax(0.04,0.03,0.035,0.025)
finalbill = less10.calc_bill(bill,taxes,cart)
less10.print_invoice(finalbill)
less10.receive_payment(finalbill)</pre></li>
</ol>
<p>The<a id="_idIndexMarker417"/> output for the paid invoice looks as follows:</p>
<pre><strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  Less than 10 counter</strong>
<strong class="bold">paperclips :  10.4</strong>
<strong class="bold">blue pens :  15.45</strong>
<strong class="bold">stapler :  12.42</strong>
<strong class="bold">pencils :  14.35</strong>
<strong class="bold">Total: 52.620000000000005</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<h2 id="_idParaDest-116"><a id="_idTextAnchor118"/>Greater than 10 items counter</h2>
<p>In this section, let’s <a id="_idIndexMarker418"/>define the class and methods for the counter for greater than 10 items. </p>
<p>For the code here, let’s create the <code>GreaterThan10Counter</code> class and add all of its methods, which includes <code>return_cart</code>, <code>goto_greater_t10_counter</code>, <code>review_items</code>, <code>count_items</code>, <code>scan_bar_code</code>, <code>add_billing</code>, <code>add_tax</code>, <code>apply_coupon</code>, <code>calc_bill</code>, <code>print_invoice</code>, and <code>receive_payment</code>. For simplicity, let’s look at the additional methods that we have in each counter instead of repeating all of the methods:</p>
<ol>
<li value="1">We will first create the <code>GreaterThan10Counter</code> class:<pre>class GreaterThan10Counter():
…</pre></li>
<li>In this class, we have a <code>goto_greater_t10_counter</code> method counter that returns the name of the counter:<pre>    def goto_greater_t10_counter(self):
        return 'Greater than 10 counter'
 …   </pre></li>
<li>Next, let’s add a method to apply a discount coupon to the items purchased:<pre>    def apply_coupon(self):
        coupon_discount = 0.1
        return coupon_discount        
   …     </pre></li>
<li>Executing all of the methods for this class in a sequence results in the following:<pre>greater = GreaterThan10Counter()
cart = greater.return_cart('paper clips','blue pens','stapler','pencils','a4paper','a3paper','chart',
                          'sketch pens','canvas','water color','acrylic colors')
greater.review_items(item_type = ['stationary'])
greater.count_items(cart)
codes = greater.scan_bar_code(113323,3434332,2131243,2332783)
bill = greater.add_billing(10,15,12,14,codes = codes)
taxes = greater.add_tax(0.04,0.03,0.035,0.025)
greater.apply_coupon()
finalbill = greater.calc_bill(bill,taxes,cart)
greater.print_invoice(finalbill)
greater.receive_payment(finalbill)</pre></li>
</ol>
<p>The output for the paid invoice looks as follows:</p>
<pre><strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  Greater than 10 counter</strong>
<strong class="bold">paper clips :  10.4</strong>
<strong class="bold">blue pens :  15.45</strong>
<strong class="bold">stapler :  12.42</strong>
<strong class="bold">pencils :  14.35</strong>
<strong class="bold">Total: 47.358000000000004</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<p>In this class, we <a id="_idIndexMarker419"/>had a different method definition for <code>goto_greater_t10_counter</code> and a new <code>apply_coupon</code> method.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor119"/>The electronics counter</h2>
<p>In this <a id="_idIndexMarker420"/>section, let’s define the class and methods for the electronic items counter. In the following code, let’s create the <code>ElectronicsCounter</code> class and add all of its methods, which includes <code>return_cart</code>, <code>goto_electronics_counter</code>, <code>review_items</code>, <code>test_electronics</code>, <code>scan_bar_code</code>, <code>add_billing</code>, <code>add_tax</code>, <code>apply_coupon</code>, <code>calc_bill</code>, <code>print_invoice</code>, and <code>receive_payment</code>. For simplicity, let’s look at the additional methods that we have in each counter instead of repeating all of the methods:</p>
<ol>
<li value="1">We will first create the class for the electronics counter:<pre>class ElectronicsCounter():
…</pre></li>
<li>In this class, we have a method to go to the electronics counter that returns the name of the counter:<pre>    def goto_electronics_counter(self):
        return 'Electronics counter'</pre></li>
<li>Next, let’s define a method that provides the status of the electronic goods and checks whether they are working:<pre>      def test_electronics(self,*status):
        teststatus = list(status)
        return teststatus            </pre></li>
<li>Executing all of the methods for this class in a sequence results in the following:<pre>electronics = ElectronicsCounter()
cart = electronics.return_cart('television','keyboard','mouse')
electronics.review_items(item_type = ['Electronics'])
electronics.test_electronics('pass','pass','pass')
codes = electronics.scan_bar_code(113323,3434332,2131243)
bill = electronics.add_billing(100,16,14,codes = codes)
taxes = electronics.add_tax(0.04,0.03,0.035)
electronics.apply_coupon()
finalbill = electronics.calc_bill(bill,taxes,cart)
electronics.print_invoice(finalbill)
electronics.receive_payment(finalbill)</pre></li>
</ol>
<p>The<a id="_idIndexMarker421"/> output for the paid invoice looks as follows:</p>
<pre><strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  Greater than 10 counter</strong>
<strong class="bold">television :  104.0</strong>
<strong class="bold">keyboard :  16.48</strong>
<strong class="bold">mouse :  14.49</strong>
<strong class="bold">Total: 134.97</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<p>In this class, we had different method definitions for <code>goto_electronics_counter</code> and a new <code>test_electronics</code> method.</p>
<p>Having defined the sequences, let’s proceed further to look at the common functionalities of each of these counters.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor120"/>Identifying the common functionalities</h1>
<p>In this <a id="_idIndexMarker422"/>section, let’s look at a graphical representation that shows the list of functions to be performed at each counter and the common functionalities between all four of them as follows. The common functionalities are highlighted in bold font in the following figure:</p>
<div><div><img alt="Figure 8.5 – Common operations performed across each counter " height="1102" src="img/Figure_8.5_B13426.jpg" width="958"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Common operations performed across each counter</p>
<p>From <em class="italic">Figure 8.5</em>, all the functions highlighted in the bold font are common across all four counters. The <code>review_items</code> function is common across the less than 10 items counter, greater than 10 items counter, and electronics counter. The <code>count_items</code> function is common across the less than 10 items counter and greater than 10 items counter. The <code>apply_coupon</code> function is common across the greater than 10 items counter <a id="_idIndexMarker423"/>and the electronics counter. Since there are common functions or operations performed across all of the counters, we can look at creating a common way of designing them, too. This is where we can introduce the concept of templates.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor121"/>Designing templates</h1>
<p>As the name suggests, <strong class="bold">templates</strong> define <a id="_idIndexMarker424"/>a common template or format in which we can design an algorithmic flow of operations and reuse them when similar<a id="_idIndexMarker425"/> kinds of activities are performed. A template is one of the methods of design patterns in Python and can be used effectively while developing frameworks or libraries. Templates emphasize the concept of reusability in programming. </p>
<p>In this section, we will look at creating a class that handles all the common functions of all four counters discussed throughout this chapter, and create a method that handles the template that sequences or pipelines the steps to be executed in all the counters:</p>
<ol>
<li value="1">To begin with, let’s create an abstract class named <code>CommonCounter</code>, and initialize the class with all the variables that will be used across all four counters. Refer to the following code:<pre>from abc import ABC, abstractmethod 
class CommonCounter(ABC):
    def __init__(self,items,name,scan,units,tax,item_type = None, weights = None, status = None):
        self.items = items
        self.name = name
        self.scan = scan
        self.units = units
        self.tax = tax
        self.item_type = item_type
        self.weights = weights
        self.status = status</pre></li>
<li>Next, we<a id="_idIndexMarker426"/> will be defining the <code>return_cart</code>, <code>goto_counter</code>, and <code>scan_bar_code</code> methods to take the input variables that are initialized in the class:<pre>    def return_cart(self):
        cart_items = []
        for i in self.items:
            cart_items.append(i)
        return cart_items
    def goto_counter(self):
        countername = self.name
        return countername
    def scan_bar_code(self):
        codes = []
        for i in self.scan:
            codes.append(i)
        return codes</pre></li>
<li>Then, we will be defining the <code>add_billing</code>, <code>add_tax</code>, and <code>calc_bill</code> methods to take the input variables that are initialized in the class:<pre>def add_billing(self):
        self.codes = self.scan_bar_code()
        pricetag = []
        for i in self.units:
            pricetag.append(i)
        bill = dict(zip(self.codes, pricetag))
        return bill
     def add_tax(self):
        taxed = []
        for i in self.tax:
            taxed.append(i)
        return taxed
     def calc_bill(self):
        bill = self.add_billing()
        items = []
        cart_items = self.return_cart()
        calc_bill = []
        taxes = self.add_tax()
        for item,tax in zip(bill.items(),taxes):
            items.append(item[1])
            calc_bill.append(item[1] + item[1]*tax)
        finalbill = dict(zip(cart_items, calc_bill))
        return finalbill</pre></li>
<li>For <a id="_idIndexMarker427"/>simplicity, we will not be defining the print invoice method, and instead, will define the <code>receive_payment</code> method, which contains the definition of the print invoice method as well within the following code:<pre>def receive_payment(self):
        finalbill = self.calc_bill()
        final_total = sum(finalbill.values())
        print('**************ABC Megamart*****************')
        print('***********------------------**************')
        print('Counter Name: ', self.goto_counter())
        for item,price in finalbill.items():
            print(item,": ", price)
        print('Total:',final_total)
        print('***********------------------**************')
        print('***************PAID************************')</pre></li>
<li>Next, we <a id="_idIndexMarker428"/>will be defining the <code>apply_coupon</code> method, which returns a <code>0</code> value. This method can be redefined in the child classes if required:<pre>def apply_coupon(self):
        return 0</pre></li>
<li>In the preceding code snippets, we defined all the methods that are common across all four counters, whereas in the following code, we will be defining methods without statements so that they can be redefined within the child classes as and when required:<pre>def weigh_items(self):
        pass
def add_price_tag(self):
        pass
def count_items(self):
        pass
def test_electronics(self):
        pass</pre></li>
<li>Then, let’s create review items as an abstract method that needs to have a definition within the child classes:<pre>@abstractmethod
    def review_items(self):
        pass</pre></li>
</ol>
<p>Now, the most <a id="_idIndexMarker429"/>important concept of templates is defined in the next code. </p>
<ol>
<li value="1">Let’s define a method that handles the sequence of operations of a billing counter, and let’s use this method as a template for all the child classes that will be created for each billing counter:<pre>def pipeline_template(self):
        self.return_cart()
        self.goto_counter()
        self.review_items()
        self.count_items()
        self.test_electronics()
        self.weigh_items()
        self.add_price_tag()
        self.scan_bar_code()
        self.add_billing()
        self.add_tax()
        self.apply_coupon()
        self.calc_bill()
        self.receive_payment()</pre></li>
<li>We have defined the common class for all counters along with its template method, which can be reused for each individual billing counter. </li>
<li>In the following code, we<a id="_idIndexMarker430"/> will create a child class for <code>VegeCounter</code>, with <code>CommonCounter</code> as a parent class:<pre>class VegeCounter(CommonCounter):
    def review_items(self):
        if ('Vegetables' in self.item_type):
            print("Move to Vege Counter")
        if ('Dairy' in self.item_type):
            print("Move to Vege Counter")
        if ('Fruits' in self.item_type):
            print("Move to Vege Counter")
    def weigh_items(self):
        item_weight = dict(zip(self.items, self.weights))
        return item_weight
    def add_price_tag(self):
        pricetag = []
        item_weight = self.weigh_items()
        for item,price in zip(item_weight.items(),self.units):
            pricetag.append(item[1]*price)
        return pricetag        </pre></li>
<li>In the preceding code, we have defined the <code>review_items</code> abstract method and we have also added statements in the definition of the <code>weight_items</code> and <code>add_price_tag</code> methods.</li>
<li>Similarly, in the following code, let’s create a child class for <code>ElectronicsCounter</code> and define <code>review_items</code> (which is an abstract method), followed by redefining <code>test_electronics</code> (which did not have a definition <a id="_idIndexMarker431"/>in the <code>CommonCounter</code> base class):<pre>class ElectronicsCounter(CommonCounter):
    def review_items(self):
        if ('Electronics' in self.item_type):
            print("Move to Electronics Counter")
      def test_electronics(self):
        teststatus = []
        for i in self.status:
            teststatus.append(i)
        return teststatus</pre></li>
<li>Let’s now create a function to run the <code>pipeline_template</code> method for each of its child classes:<pre>def run_pipeline(counter = CommonCounter):
    counter.pipeline_template()</pre></li>
<li>Executing the <code>run_pipeline</code> method for each of the child classes results in the sequence of steps executed according to each billing counter. Let’s execute the <code>pipeline</code> method for the vegetable counter:<pre>run_pipeline(VegeCounter(items = ['onions', 'lettuce', 'apples', 'oranges'],
                         name = ['Vegetable Counter'],
                         scan = [113323,3434332,2131243,2332783],
                         units = [10,15,12,14],
                         tax = [0.04,0.03,0.035,0.025],
                         item_type = ['Vegetables'],
                         weights = [1,2,1.5,2.5]))</pre></li>
</ol>
<p>The output<a id="_idIndexMarker432"/> after running the pipeline for <code>VegeCounter</code> is as follows:</p>
<pre><strong class="bold">Move to Vege Counter</strong>
<strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  ['Vegetable Counter']</strong>
<strong class="bold">paperclips :  10.4</strong>
<strong class="bold">blue pens :  15.45</strong>
<strong class="bold">stapler :  12.42</strong>
<strong class="bold">pencils :  14.35</strong>
<strong class="bold">Total: 52.620000000000005</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<ol>
<li value="8">Let’s now execute the <code>pipeline</code> method for <code>ElectronicsCounter</code>:<pre>run_pipeline(ElectronicsCounter(items = ['television','keyboard','mouse'],
                                name = ['Electronics Counter'],
                                scan = [113323,3434332,2131243],
                                units = [100,16,14],
                                tax = [0.04,0.03,0.035],
                                item_type = ['Electronics'],
                                status = ['pass','pass','pass']))</pre></li>
</ol>
<p>The output after<a id="_idIndexMarker433"/> running the pipeline for <code>ElectronicsCounter</code> is as follows:</p>
<pre><strong class="bold">Move to Electronics Counter</strong>
<strong class="bold">**************ABC Megamart*****************</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">Counter Name:  ['Electronics Counter']</strong>
<strong class="bold">television :  104.0</strong>
<strong class="bold">keyboard :  16.48</strong>
<strong class="bold">mouse :  14.49</strong>
<strong class="bold">Total: 134.97</strong>
<strong class="bold">***********------------------**************</strong>
<strong class="bold">***************PAID************************</strong></pre>
<p>In this section, we have created a template, but we have not repeated the same methods in multiple class definitions. The same <code>CommonCounter</code> abstract class can be reused for the definitions of the less than 10 items counter and the greater than 10 items counter as well. We learned how to create a template and implement template programming that emphasizes reusability in Python application development. We created a template that covers all the common functionalities across multiple sets of operations and reused the template multiple times.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor122"/>Summary</h1>
<p>In this chapter, we have learned the concepts of defining methods for a sequence of operations that follows an algorithm. We also defined classes that follow a sequence of operations from our core example. We created an abstract class that defines all the common functionalities of our core example, and we applied the templates design pattern to understand the concept of templates using the sequences from our core example.</p>
<p>Similar to other chapters covered in this book, this chapter also covered templates, which is a design pattern applied in metaprogramming to change the behavior of Python objects externally.</p>
<p>In the next chapter, we will be looking at the concept of abstract syntax trees with some interesting examples.</p>
</div>
</div></body></html>