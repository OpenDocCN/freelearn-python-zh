<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer203">
<h1 class="chapter-number" id="_idParaDest-252"><a id="_idTextAnchor265"/>11</h1>
<h1 id="_idParaDest-253"><a id="_idTextAnchor266"/>Object Modifiers</h1>
<p>A major part of creating 3D content consists of editing geometries by adding and removing the vertices, edges, and faces of a model, or displacing the <span class="No-Break">existing ones.</span></p>
<p><strong class="bold">Object modifiers</strong> can perform these actions via non-destructive edits that affect the appearance of <a id="_idIndexMarker696"/>an object but not its internal data. They can be used for generative modeling, and without them, animation would be impossible, because deforming an object would require changing the geometric data at <span class="No-Break">every frame.</span></p>
<p>Object modifiers are like the F-Modifiers treated in <a href="B18375_08.xhtml#_idTextAnchor206"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, but they present a greater variety in purpose <span class="No-Break">and attributes.</span></p>
<p>In this chapter, we will cover <span class="No-Break">the following:</span></p>
<ul>
<li>Understanding and using <span class="No-Break">object modifiers</span></li>
<li>Script <span class="No-Break">deformation modifiers</span></li>
<li>Generating armatures <span class="No-Break">and meshes</span></li>
</ul>
<h1 id="_idParaDest-254"><a id="_idTextAnchor267"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found at the following <span class="No-Break">URL: </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11</span></a><span class="No-Break">.</span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11%0D"/></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor268"/>Understanding object modifiers</h1>
<p>Object modifiers change the displayed status of an object without altering its geometric data. We met <a id="_idIndexMarker697"/>something similar in <a href="B18375_08.xhtml#_idTextAnchor206"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, when we applied effects to animation F-Curves without changing <span class="No-Break">their keyframes.</span></p>
<p>Like F-Modifiers, they can be stacked on each other and accessed in Python as a <span class="No-Break">collection property.</span></p>
<p>Modifiers can be added <a id="_idIndexMarker698"/>manually, but their creation and setup can be scripted as well. Before we delve into the API, let’s take a look at how to create them in the <span class="No-Break"><strong class="bold">Modifiers</strong></span><span class="No-Break"> properties.</span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor269"/>Adding modifiers</h2>
<p>Object modifiers are <a id="_idIndexMarker699"/>created in the <strong class="bold">Modifiers</strong> tab of <strong class="bold">Properties</strong> using the <strong class="bold">Add Modifier</strong> drop-down button. The tab is marked with the icon of <span class="No-Break">a wrench.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 11.1: Adding modifiers in Blender" height="928" src="image/Figure_11.01_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: Adding modifiers in Blender</p>
<p>Clicking <strong class="bold">Add Modifier</strong> displays the available options. They change according to the object type: curves don’t have as many modifiers as meshes, while nongeometric types such as empty or cameras can’t have any modifiers <span class="No-Break">at all.</span></p>
<p>Though their number has grown with time, all modifiers are grouped into <span class="No-Break">four categories:</span></p>
<ul>
<li><strong class="bold">Modify</strong> – Affects data that won’t be displayed directly, such as <span class="No-Break">vertex groups</span></li>
<li><strong class="bold">Generate</strong> – Adds or removes geometry to or from <span class="No-Break">an object</span></li>
<li><strong class="bold">Deform</strong> – Changes the shape of an object without adding or removing vertices, edges, <span class="No-Break">or faces</span></li>
<li><strong class="bold">Physics</strong> – Brings the result of physics simulations to <span class="No-Break">the object</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 11.2: Clicking Add Modifier displays the available types" height="788" src="image/Figure_11.02_B18375.jpg" width="1323"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Clicking Add Modifier displays the available types</p>
<p>The interface displays one column per category, with several modifier types for each of the four. Even modifier <a id="_idIndexMarker700"/>types from the same category differ a lot from each other and present different sets <span class="No-Break">of attributes.</span></p>
<p>To better understand how modifiers work, we can create one in the interface and see how that affects an object’s geometry. For example, adding a <strong class="bold">Subdivision Surface</strong> modifier to an object makes it smoother by creating <span class="No-Break">additional polygons.</span></p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor270"/>Subdividing an object</h2>
<p>Mesh objects are polygonal; that is, they consist of flat faces and sharp edges. That works well for <a id="_idIndexMarker701"/>simple solids like a cube, but not for smooth surfaces such as a sphere, or most <span class="No-Break">real-life objects.</span></p>
<p>To give an illusion of smoothness, we subdivide the polygons of a mesh until they approximate a <span class="No-Break">continuous surface.</span></p>
<p>The downside is that geometries that are too dense are problematic; they require more disk space and are not easy to model or edit. For that reason, rather than storing additional mesh data, we generate smooth geometry using the <strong class="bold">Subdivision </strong><span class="No-Break"><strong class="bold">Surface</strong></span><span class="No-Break"> modifier.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface" height="416" src="image/Figure_11.03_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface</p>
<p>This modifier splits every edge into two, generating new polygons from those divisions. By default, an algorithm named <strong class="bold">Catmull-Clark</strong> smoothens the result while preserving the <span class="No-Break">overall shape.</span></p>
<p>We can add a <a id="_idIndexMarker702"/>subdivision to a model with the <span class="No-Break">following steps:</span></p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File | New | </strong><span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break">.</span></li>
<li>Select the default <strong class="bold">Cube</strong> shape and make <span class="No-Break">it active.</span></li>
<li>In the <strong class="bold">Modifiers</strong> tab, click <strong class="bold">Add Modifier</strong> and select <strong class="bold">Subdivision Surface</strong> at the bottom of the <span class="No-Break"><strong class="bold">Generate</strong></span><span class="No-Break"> column.</span></li>
<li>A new entry appears in the <strong class="bold">Modifiers</strong> properties. We can see the parameters of the <span class="No-Break"><strong class="bold">Subdivision</strong></span><span class="No-Break"> modifier.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 11.4: Subdivision Surface properties" height="390" src="image/Figure_11.04_B18375.jpg" width="477"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: Subdivision Surface properties</p>
<ol>
<li value="5">Increasing the number in <strong class="bold">Levels Viewport</strong> adds subdivision to the object. Applying a <strong class="bold">Catmull-Clark</strong> division of <strong class="source-inline">3</strong> makes our <strong class="bold">Cube</strong> look much like <span class="No-Break">a ball.</span></li>
<li>Clicking the <strong class="bold">Simple</strong> button disables the smoothing: the object is still subdivided, but its shape <span class="No-Break">doesn’t change.</span></li>
</ol>
<p>Even if enabling <strong class="bold">Simple</strong> doesn’t alter its shape, our object is still subdivided. That can be useful to other <a id="_idIndexMarker703"/>modifiers that can be added after <strong class="bold">Subdivision</strong>, as they will have more geometry <span class="No-Break">to deform.</span></p>
<p>Now that our <strong class="bold">Cube</strong> has been subdivided, we will be able to alter its shape using a second <span class="No-Break">modifier: </span><span class="No-Break"><strong class="bold">Cast</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor271"/>Changing the object’s shape using Cast</h2>
<p>With our <strong class="bold">Subdivision</strong> modifier <a id="_idIndexMarker704"/>still in place, we can <a id="_idIndexMarker705"/>add a new modifier to alter the <span class="No-Break">object’s shape:</span></p>
<ol>
<li>In the <strong class="bold">Modifiers</strong> tab, click <strong class="bold">Add Modifier</strong> and select <strong class="bold">Cast</strong> at the top of the <strong class="bold">Deform</strong> column. Another modifier shows up <span class="No-Break">under </span><span class="No-Break"><strong class="bold">Subdivision</strong></span><span class="No-Break">.</span></li>
<li>Change the <strong class="bold">Shape</strong> property to <strong class="source-inline">Cylinder</strong> and the <strong class="bold">Factor</strong> to <strong class="source-inline">1.0</strong>. Our geometry is now <span class="No-Break">a cylinder.</span></li>
</ol>
<p>The two modifiers are displayed one on top of the other. Starting from the top, each modifier acts as the <a id="_idIndexMarker706"/>input of the next one. For this reason, the modifiers column is also called the <span class="No-Break"><strong class="bold">modifiers stack</strong></span><span class="No-Break">.</span></p>
<p>Using modifiers, we have made our original object look like a cylinder, but that change can be reversed, or even animated. Moving the <strong class="bold">Factor</strong> slider between <strong class="source-inline">0.0</strong> and <strong class="source-inline">1.0</strong>, our object transitions from its original shape to the one set <span class="No-Break">in </span><span class="No-Break"><strong class="bold">Cast</strong></span><span class="No-Break">.</span></p>
<p>We can replicate the preceding steps in Python scripts using <span class="No-Break">Blender’s API.</span></p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor272"/>Adding modifiers in Python</h1>
<p>The Python class <a id="_idIndexMarker707"/>of Blender objects contains a <strong class="source-inline">modifiers</strong> attribute. Like <a id="_idIndexMarker708"/>all coll<a id="_idTextAnchor273"/>ections, <strong class="source-inline">modifiers</strong> provides the <strong class="source-inline">new</strong> method, which creates and returns new items. By using <strong class="source-inline">new</strong>, we can automate the setup of modifiers <span class="No-Break">using Python.</span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor274"/>Finding collection-type items</h2>
<p><strong class="source-inline">Object.modifiers.new</strong> takes two arguments: <strong class="source-inline">name</strong> and <strong class="source-inline">type</strong>. The first will be displayed in the <a id="_idIndexMarker709"/>modifier properties in the interface, while <strong class="source-inline">type</strong> specifies which kind of modifier we want to create. The <strong class="source-inline">type</strong> argument must belong to the list of available types, or it will cause an error. Available types are listed in the <span class="No-Break">API documentation:</span></p>
<p><a href="https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml"><span class="No-Break">https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml</span></a></p>
<p>But we can also get them from Blender itself. These commands will list the modifier keywords in Blender’s <span class="No-Break">Python console:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; mod_rna = bpy.types.ObjectModifiers.bl_rna
&gt;&gt;&gt; mod_params = mod_rna.functions["new"].parameters
&gt;&gt;&gt; mod_params["type"].enum_items.keys()
['DATA_TRANSFER', 'MESH_CACHE', 'MESH_SEQUENCE_CACHE', 'NORMAL_EDIT', 'WEIGHTED_NORMAL', 'UV_PROJECT', 'UV_WARP',
...</pre>
<p>There’s another way to get a <span class="No-Break">modifier keyword:</span></p>
<ol>
<li>Use the <strong class="bold">Add Modifier</strong> button in <span class="No-Break">the interface.</span></li>
<li>Look for the argument of the <strong class="source-inline">modifier_add</strong> operator in the <strong class="bold">Info</strong> log. It’s part of the <strong class="bold">Scripting</strong> workspace, as we know from <a href="B18375_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 11.5: Blender info log after adding Subdivision Surface" height="159" src="image/Figure_11.05_B18375.jpg" width="888"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: Blender info log after adding Subdivision Surface</p>
<p>For instance, the <a id="_idIndexMarker710"/>keyword for the <strong class="bold">Subdivision Surface</strong> modifiers <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">'SUBSURF'</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor275"/>Using modifiers.new</h2>
<p>Since <strong class="source-inline">modifiers.new</strong> returns <a id="_idIndexMarker711"/>the created modifier, we can store the return value and replicate all the steps from the previous <em class="italic">Understanding object </em><span class="No-Break"><em class="italic">modifiers</em></span><span class="No-Break"> section.</span></p>
<p>We’ll see how to add a <strong class="bold">Subdivision Surface</strong> instance and a <strong class="bold">Cast</strong> modifier on the active object and how to reshape it into a cylinder using Python. First, our script needs to import <strong class="source-inline">bpy</strong> and add a subdivision to increase the <span class="No-Break">available geometry:</span></p>
<pre class="source-code">
import bpy
ob = bpy.context.object
subdiv = ob.modifiers.new('Subdivision', 'SUBSURF')</pre>
<p>The <strong class="source-inline">subdiv</strong> variable contains the new <strong class="bold">Subdivision Surface</strong> modifier, so we can change the modifier’s parameters by setting <span class="No-Break"><strong class="source-inline">subdiv</strong></span><span class="No-Break">’s attributes.</span></p>
<p>If we are looking for the Python counterpart of an attribute we can see in the interface, we can resort to <strong class="bold">Python Tooltips</strong> and <strong class="bold">Developer Extra</strong>, the two options in <strong class="bold">Edit</strong> &gt; <strong class="bold">Preferences</strong> from the top-bar menu. We learned about them in the <em class="italic">Useful features for Python</em> section in <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
<p>If tooltips are enabled, hovering the mouse on the <strong class="bold">Levels Viewport</strong> slider shows that its Python attribute <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">levels</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 11.6: Subdivision attributes path displayed in tooltips" height="240" src="image/Figure_11.06_B18375.jpg" width="560"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: Subdivision attributes path displayed in tooltips</p>
<p>To increase the object’s poly count without altering its shape, we set <strong class="source-inline">subdiv.levels</strong> to <strong class="source-inline">3</strong> and <strong class="source-inline">subdivision_type</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">'SIMPLE'</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
subdiv.levels = 3
subdiv.subdivision_type = 'SIMPLE'</pre>
<p>Now we have <a id="_idIndexMarker712"/>enough polygons to deform our object. We add a <strong class="source-inline">'CAST'</strong> modifier and reshape it to <span class="No-Break">a cylinder:</span></p>
<pre class="source-code">
cast = ob.modifiers.new('Cast', 'CAST')
cast.cast_type = <strong class="source-inline">'CYLINDER'</strong>
cast.factor = <strong class="source-inline">1.0</strong></pre>
<p><strong class="bold">Subdivision Surface</strong> and <strong class="bold">Cast</strong> are self-sufficient, as they don’t require other objects besides the one they are affecting. Other modifiers rely on data from <span class="No-Break">ancillary objects.</span></p>
<p>In the next section, we will set up a modifier that depends on a <span class="No-Break">deformer object.</span></p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor276"/>Deformation objects</h1>
<p>Many deformers translate <a id="_idIndexMarker713"/>a change from one object to another. That allows us to deform a complex object by manipulating a simpler one. Here are a few <span class="No-Break">notable examples:</span></p>
<ul>
<li><strong class="bold">Curve</strong> – Deforms a mesh along a <span class="No-Break">curve object</span></li>
<li><strong class="bold">Lattice</strong> – Transfers the changes from a regular grid to <span class="No-Break">a mesh</span></li>
<li><strong class="bold">Armature</strong> – Transfers the pose of an articulated structure to <span class="No-Break">a mesh</span></li>
<li><strong class="bold">Surface Deform</strong> – Transfers the deformation from one mesh <span class="No-Break">to another</span></li>
</ul>
<p>The object used by a <a id="_idIndexMarker714"/>modifier can be set using the <span class="No-Break"><strong class="source-inline">modifier.object</strong></span><span class="No-Break"> attribute.</span></p>
<p>The <strong class="bold">Armature</strong> modifier reproduces the limb movements using a structure of <strong class="bold">bones</strong>, so it requires <a id="_idIndexMarker715"/>a special type of object that can <span class="No-Break">be posed.</span></p>
<p>A <strong class="bold">Lattice</strong> modifier, on the other <a id="_idIndexMarker716"/>hand, relies on the internal coordinates of a grid, which are specific to <strong class="bold">Lattice</strong> <span class="No-Break">object types.</span></p>
<p>As an example, we will see how to add lattice deformation to <span class="No-Break">an object.</span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor277"/>Using the Lattice modifier</h2>
<p>To use lattice deformation, we <a id="_idIndexMarker717"/>need geometry to deform and an object <a id="_idIndexMarker718"/>of type lattice. We can use Blender’s mascot, the <span class="No-Break">monkey </span><span class="No-Break"><strong class="bold">Suzanne</strong></span><span class="No-Break">:</span></p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File </strong>| <strong class="bold">New </strong>| <span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break">.</span></li>
<li>Delete the default <strong class="bold">Cube</strong> shape by pressing <strong class="bold">Canc</strong> or <strong class="bold">X</strong> | <span class="No-Break"><strong class="bold">Delete</strong></span><span class="No-Break">.</span></li>
<li>Add a monkey head to the scene using <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <span class="No-Break"><strong class="bold">Monkey</strong></span><span class="No-Break">.</span></li>
<li>Add a lattice to the scene by using <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">Lattice</strong></span><span class="No-Break">.</span></li>
</ol>
<p>A lattice was added to the scene. By default, it is smaller than Suzanne, so we need to scale <span class="No-Break">it up:</span></p>
<ol>
<li>With the lattice still selected, press <strong class="source-inline">S</strong> to scale. Drag the mouse or press <strong class="source-inline">2</strong> to double <span class="No-Break">its size.</span></li>
<li>Select Suzanne to add a modifier. In the <strong class="bold">Modifiers</strong> tab, Use <strong class="bold">Add Modifier</strong> | <span class="No-Break"><strong class="bold">Lattice</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">Lattice</strong> modifier, click the <strong class="bold">Object</strong> property and select the <strong class="bold">Lattice</strong> object from <span class="No-Break">the options.</span></li>
</ol>
<p>Editing the Lattice object changes <span class="No-Break">Suzanne’s shape:</span></p>
<ol>
<li>Select <strong class="bold">Lattice</strong> in <span class="No-Break"><strong class="bold">3D Viewport</strong></span><span class="No-Break">.</span></li>
<li>Press the <em class="italic">Tab</em> key to switch to <span class="No-Break"><strong class="bold">Edit Mode</strong></span><span class="No-Break">.</span></li>
<li>Select one or more <span class="No-Break">lattice vertices.</span></li>
<li>Press <em class="italic">G</em> and drag the <a id="_idIndexMarker719"/>mouse to move the selection: a lattice <a id="_idIndexMarker720"/>deformation is applied <span class="No-Break">to Suzanne.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 11.7: Mesh deformed by a lattice cage" height="680" src="image/Figure_11.07_B18375.jpg" width="1024"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: Mesh deformed by a lattice cage</p>
<p>Automating these steps with Python can make the process much easier. In the next section, we will write an operator that sets up a lattice deformation in <span class="No-Break">one click.</span></p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor278"/>Writing the Latte Express add-on</h1>
<p>The <strong class="bold">Latte Express</strong> add-on <a id="_idIndexMarker721"/>creates a new lattice around the active object and sets up <span class="No-Break">the modifier.</span></p>
<p>It’s useful for creating basic rigs for cartoon deformation, or stylized objects. The add-on consists of an operator class and a <span class="No-Break">menu entry.</span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor279"/>Setting the environment</h2>
<p>We create <a id="_idIndexMarker722"/>a Python script for <span class="No-Break">our add-on:</span></p>
<ol>
<li>Create a <strong class="source-inline">PythonScriptingBlender/ch11/addons</strong> folder. We can use the file manager or the file tab of our programmer editor, for example, <span class="No-Break"><strong class="bold">VS Code</strong></span><span class="No-Break">.</span></li>
<li>Create a new file in that folder and name it <strong class="source-inline">lattice_express.py</strong>. We can do that using the file manager or the <strong class="bold">New File</strong> button in <span class="No-Break">an IDE.</span></li>
<li>Open the file in <a id="_idIndexMarker723"/>your editor <span class="No-Break">of choice.</span></li>
<li>Set the <strong class="bold">Scripts</strong> path to <strong class="source-inline">PythonScriptingBlender/ch11</strong> in the Blender <strong class="bold">File Paths</strong> preferences and <span class="No-Break">restart Blender.</span></li>
</ol>
<p>Now we can write the add-on and load it <span class="No-Break">in Blender.</span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor280"/>Writing the Latte Express information</h2>
<p>Like other <a id="_idIndexMarker724"/>add-ons, Latte Express starts with a blank line, followed by the <span class="No-Break"><strong class="source-inline">bl_info</strong></span><span class="No-Break"> dictionary:</span></p>
<pre class="source-code">
bl_info = {
    "name": "Latte Express",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Create a Lattice on the active object",
    "category": "Learning",
}</pre>
<p>Then we proceed with the add-on classes and interface, in this case, a <span class="No-Break">simple operator.</span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor281"/>Writing the Latte Express operator</h2>
<p>We need to <a id="_idIndexMarker725"/>import the <strong class="source-inline">bpy</strong> module, so that we can create a <span class="No-Break">new operator:</span></p>
<pre class="source-code">
import bpy
class LatteExpress(bpy.types.Operator):
    """Set up Lattice Deformation"""
    bl_idname = "object.latte_expresso"
    bl_label = "Create Lattice on active object"</pre>
<p>The operator requires an active object, so the condition in <strong class="source-inline">poll</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.active_object</pre>
<p>Creating a lattice object requires lattice data first, so inside <strong class="source-inline">execute</strong>, we call <strong class="source-inline">bpy.data.lattices.new</strong> and use its return value in <strong class="source-inline">bpy.data.objects.new</strong>. We name the new <a id="_idIndexMarker726"/>object and data after the active object, even if that’s not required. Finally, we add the lattice to the scene by linking it to the <span class="No-Break">current collection:</span></p>
<pre class="source-code">
    def execute(self, context):
        ob = context.object
        <strong class="source-inline">latt_data</strong> = bpy.data.lattices.new(f"LAT-{ob.name}")
        latt_obj = <strong class="source-inline">bpy.data.objects.new</strong>(
                                     name=latt_data.name,
                                     object_data=<strong class="source-inline">latt_data</strong>
                                    )
        context.collection.objects.link(latt_obj)</pre>
<p>Let’s scale the lattice so that it fits our object. We can get its size from the <span class="No-Break"><strong class="source-inline">dimensions</strong></span><span class="No-Break"> attribute:</span></p>
<pre class="source-code">
        latt_obj.scale = ob.dimensions</pre>
<p>We match the lattice position with the center of the active geometry. We can get the object location from the world matrix as we learned in <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">:</span></p>
<pre class="source-code">
        ob_translation = ob.matrix_world.to_translation()</pre>
<p>That alone would <a id="_idIndexMarker727"/>not work on objects that have their transform pivot away from their geometry center, so we must find the actual midpoint of <span class="No-Break">our object.</span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor282"/>Finding the center of a model</h2>
<p>To create a lattice that matches the location and size of an object, we must find the median <a id="_idIndexMarker728"/>point of its vertices, but we don’t have to look at all the components. We can find the center of the object’s <span class="No-Break"><strong class="bold">bounding box</strong></span><span class="No-Break">.</span></p>
<p>A bounding box is an imaginary <a id="_idIndexMarker729"/>parallelepiped that contains all the object geometry. We can display it by activating <strong class="bold">Bound</strong> in the <span class="No-Break"><strong class="bold">Object</strong></span><span class="No-Break"> properties.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer194">
<img alt="Figure 11.8: An object’s bounding box with coordinate indices added on top" height="762" src="image/Figure_11.8_B18375.jpg" width="1629"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8: An object’s bounding box with coordinate indices added on top</p>
<p>The bounding box is found in Python via the <strong class="source-inline">bound_box</strong> attribute. It’s a list of eight coordinates, and we can find the center by interpolating two <span class="No-Break">opposite corners.</span></p>
<p>The center of a box is found in the middle of its diagonals, so we want to mediate between the lower-left-back corner and the top-right-forward corner. We know the indices of those points from <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.8</em>. They are <strong class="source-inline">0</strong> and <span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">, respectively.</span></p>
<p>A better way to find those two corners is by using the <strong class="source-inline">min</strong> and <span class="No-Break"><strong class="source-inline">max</strong></span><span class="No-Break"> functions.</span></p>
<p>One of the two extremes has the lowest <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">z</strong> values, and the other one has the highest. In other words, the components of the lower corner have the lowest sum, and those of the higher corner have <span class="No-Break">the highest.</span></p>
<p>In Python, <strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> return the lower and higher value in a list, but we can supply a different criterion, in this case, <strong class="source-inline">sum</strong>, using the <span class="No-Break"><strong class="source-inline">key</strong></span><span class="No-Break"> argument:</span></p>
<pre class="source-code">
        btm_left = min((c for c in ob.bound_box), key=<strong class="source-inline">sum</strong>)
        top_right = max((c for c in ob.bound_box), key=<strong class="source-inline">sum</strong>)</pre>
<p>To find the midpoint between two vectors, we can use the linear interpolation method (<strong class="source-inline">lerp</strong>) from the <strong class="source-inline">Vector</strong> class. In the <strong class="source-inline">import</strong> section, we need to add <span class="No-Break">this line:</span></p>
<pre class="source-code">
from mathutils import Vector</pre>
<p>Then, in <strong class="source-inline">execute</strong>, we interpolate the two coordinates. The first argument of <strong class="source-inline">lerp</strong> can be any triplet, so we convert only one <a id="_idTextAnchor283"/>of the two corners to the <strong class="source-inline">Vector</strong> type. Since we are looking for the point sitting halfway between the two corners, we provide a factor of <strong class="source-inline">0.5</strong> as the <span class="No-Break">second argument:</span></p>
<pre class="source-code">
        btm_left = Vector(btm_left)
        ob_center = btm_left.<strong class="source-inline">lerp</strong>(top_right, <strong class="source-inline">0.5</strong>)</pre>
<p>We add <strong class="source-inline">ob_center</strong> to <strong class="source-inline">ob_translation</strong> to center the lattice to <span class="No-Break">the geometry:</span></p>
<pre class="source-code">
        Ob_translation += ob_center
        latt_obj.location = ob_translation</pre>
<p>Our lattice, centered <a id="_idIndexMarker730"/>and scaled, can now be used to deform the object. We can use it inside a new modifier and return <strong class="source-inline">{'FINISHED'}</strong> to exit <span class="No-Break">the operator:</span></p>
<pre class="source-code">
        mod = ob.modifiers.new("Lattice", 'LATTICE')
        mod.object = latt_obj
        return {'FINISHED'}</pre>
<p>Now that the operator is finished, we can add a menu entry for <span class="No-Break">using it.</span></p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor284"/>Adding a Create Lattice menu item</h2>
<p>We define <a id="_idIndexMarker731"/>a function to add <strong class="source-inline">LatteExpress</strong> to a menu. Using the <strong class="bold">Icon Viewer</strong> addon as in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we can find lattice-related icons such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">MOD_LATTICE</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.operator(LatteExpress.bl_idname,
                         icon=<strong class="source-inline">"MOD_LATTICE"</strong>)</pre>
<p>Of course, we need to register the new Blender class <span class="No-Break">and function:</span></p>
<pre class="source-code">
def register():
    bpy.utils.register_class(LatteExpress)
    ob_menu = bpy.types.VIEW3D_MT_object_context_menu
    ob_menu.append(menu_func)
def unregister():
    ob_menu = bpy.types.VIEW3D_MT_object_context_menu
    ob_menu.remove(menu_func)
    bpy.utils.unregister_class(LatteExpress)</pre>
<p>We can refresh the add-on preferences and enable <span class="No-Break"><strong class="bold">Latte Express</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor285"/>Using the Latte Express add-on</h2>
<p>Once we have <a id="_idIndexMarker732"/>set the <strong class="bold">Scripts</strong> path to the <strong class="source-inline">ch11</strong> folder, we will be able to activate <strong class="bold">Latte Express</strong> in the <span class="No-Break"><strong class="bold">Add-ons</strong></span><span class="No-Break"> preferences.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 11.9: Enabling the Latte Express add-on" height="333" src="image/Figure_11.09_B18375.jpg" width="991"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9: Enabling the Latte Express add-on</p>
<p>Our add-on makes the task of setting up a lattice deformation easier. Let’s see how the workflow from the previous section, <em class="italic">Deformation objects</em>, <span class="No-Break">has improved:</span></p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File </strong>| <strong class="bold">New </strong>| <span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break">.</span></li>
<li>Delete the default <strong class="bold">Cube</strong> shape by pressing <strong class="bold">Canc</strong> or <strong class="bold">X</strong> | <span class="No-Break"><strong class="bold">Delete</strong></span><span class="No-Break">.</span></li>
<li>Add a monkey head to the scene using <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <span class="No-Break"><strong class="bold">Monkey</strong></span><span class="No-Break">.</span></li>
<li>Use the mouse right-click to open the object menu in the <span class="No-Break"><strong class="bold">3D Viewport</strong></span><span class="No-Break">.</span></li>
<li>Select <strong class="bold">Create Lattice on </strong><span class="No-Break"><strong class="bold">Active Object</strong></span><span class="No-Break">.</span></li>
</ol>
<p>A lattice is <a id="_idIndexMarker733"/>created, centered, and scaled on the active object, while a modifier is set up. Besides automating the task, using this add-on gives better accuracy, as the lattice is scaled according to the object’s <span class="No-Break">exact dimensions.</span></p>
<p>In the next section, we will add more control over the geometry and <span class="No-Break">lattice subdivision.</span></p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor286"/>Improving Latte Express options</h1>
<p>Some objects <a id="_idIndexMarker734"/>might not have enough polygons for the lattice deformation to work properly. We encountered a similar condition at the beginning of this chapter, in the <em class="italic">Understanding object modifiers</em> section, where we applied a <strong class="bold">Subdivision Surface</strong> modifier to our <strong class="bold">Cube</strong> shape before we could reshape it into a cylinder using a <span class="No-Break"><strong class="bold">Cast</strong></span><span class="No-Break"> modifier.</span></p>
<p>The resolution of lattice objects can also be increased to get more control over <span class="No-Break">the deformation.</span></p>
<p>For those reasons, we <a id="_idIndexMarker735"/>will add object subdivision and lattice resolution options to <span class="No-Break">our operator.</span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor287"/>Adding object subdivisions</h2>
<p>We add a subdivide <a id="_idIndexMarker736"/>option to <strong class="bold">Latte Express</strong> using <strong class="source-inline">BoolProperty</strong>. Since we will also set a <strong class="source-inline">SUBSURF</strong> modifier, we add <strong class="source-inline">IntProperty</strong> for the <span class="No-Break">subdivision levels.</span></p>
<p>We add <strong class="source-inline">bl_options = {'REGISTER', 'UNDO'}</strong> to display the operator panel. The declaration of <strong class="bold">LatteExpress</strong> becomes <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LatteExpress(bpy.types.Operator):
    """Set up Lattice Deformation"""
    bl_idname = "object.latte_expresso"
    bl_label = "Create Lattice on active object"
    bl_options = <strong class="source-inline">{'REGISTER', 'UNDO'}</strong>
    <strong class="source-inline">add_subsurf</strong>: bpy.props.BoolProperty(default=True)
    <strong class="source-inline">subd_levels</strong>: bpy.props.IntProperty(default=2)</pre>
<p>The <strong class="source-inline">execute</strong> method takes these options into account, creating a <strong class="source-inline">SUBSURF</strong> modifier if <strong class="source-inline">add_subsurf</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    def execute(self, context):
        ob = context.object
        if self.add_subsurf:
            subdiv = ob.modifiers.new("Subdivision",
                                      "SUBSURF")
            subdiv.<strong class="source-inline">levels</strong> = self.subd_levels
            subdiv.<strong class="source-inline">render_levels</strong> = self.subd_levels
            subdiv.subdivision_type = "SIMPLE"</pre>
<p><strong class="bold">Subdivision Surface</strong> has an additional attribute for rendering subdivision levels. We have set both <a id="_idIndexMarker737"/>to the same value to make sure that the Viewport and the rendered images look <span class="No-Break">the same.</span></p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor288"/>Changing lattice resolution</h2>
<p>Lattices don’t have <a id="_idIndexMarker738"/>polygons or subdivision modifiers, but they have resolution parameters to add more divisions along the <span class="No-Break">three axes.</span></p>
<p>The <strong class="source-inline">points_u</strong>, <strong class="source-inline">points_v</strong>, and <strong class="source-inline">points_w</strong> attributes set the number of divisions across its <em class="italic">x</em>, <em class="italic">y</em>, and <span class="No-Break"><em class="italic">z</em></span><span class="No-Break"> axes.</span></p>
<p>We add a property to influence the grid resolution. We use <strong class="source-inline">IntVectorProperty</strong> for those three attributes and set its subtype to <strong class="source-inline">'XYZ'</strong> so that they are displayed like coordinates. The minimum value for resolution coordinates is <strong class="source-inline">1</strong>, while we use <strong class="source-inline">3</strong> <span class="No-Break">as default:</span></p>
<pre class="source-code">
    grid_levels: bpy.props.IntVectorProperty(
                                         default=(3, 3, 3),
                                         min=<strong class="source-inline">1</strong>,
                                         <strong class="source-inline">subtype='XYZ'</strong>
                                        )</pre>
<p>Because of the way the lattice is implemented, changing the resolution before creating the lattice object changes the starting dimensions of a lattice. To avoid that, we only set <strong class="source-inline">points_u</strong>, <strong class="source-inline">points_v</strong>, and <strong class="source-inline">points_w</strong> after <strong class="source-inline">latt_obj</strong> <span class="No-Break">is created.</span></p>
<p>So, the lattice section becomes <span class="No-Break">as follows:</span></p>
<pre class="source-code">
        latt_data = bpy.data.lattices.new(f"LAT-{ob.name}")
        latt_obj = bpy.data.objects.new(
                                      name=latt_data.name,
                                      object_data=latt_data
                                     )
        latt_data.<strong class="source-inline">points_u</strong> = self.grid_levels[<strong class="source-inline">0</strong>]
        latt_data.<strong class="source-inline">points_v</strong> = self.grid_levels[<strong class="source-inline">1</strong>]
        latt_data.<strong class="source-inline">points_w</strong> = self.grid_levels[<strong class="source-inline">2</strong>]</pre>
<p>Now that we are adding subdivisions, the lattice grid will present internal vertices, that is, control points <a id="_idIndexMarker739"/>that end up being inside the lattice. We don’t want that because we are using the lattice as an <span class="No-Break">external cage.</span></p>
<p>So, we set <strong class="source-inline">use_outside</strong> of the lattice data <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
        latt_data.use_outside = False</pre>
<p>After that, the <strong class="source-inline">execute</strong> method continues as before, linking <strong class="source-inline">latt_obj</strong> to <strong class="source-inline">context.collection.objects</strong>, setting its location and scale, and creating the object modifiers before it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">{'FINISHED'}</strong></span><span class="No-Break">.</span></p>
<p>If we save the script and use <em class="italic">F3</em> -&gt; <strong class="bold">Reload Scripts</strong> and launch <strong class="bold">Create Lattice on Active Object</strong>, we’ll see the options for the <span class="No-Break">lattice resolution.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 11.10: A 5x3x3 lattice created with Latte Express" height="768" src="image/Figure_11.10_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10: A 5x3x3 lattice created with Latte Express</p>
<p>Lattice grids add quick deformations without requiring additional data in the deformed object. Deformers such as <strong class="bold">Armature</strong>, the modifier used for articulated characters, require the assignment of <strong class="bold">vertex groups</strong> to <span class="No-Break">work properly.</span></p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor289"/>Using armature deformers</h1>
<p>Armatures are deformation objects like lattices, but instead of using a grid, they rely on the translation, rotation, <a id="_idIndexMarker740"/>and scale of sub-objects called <strong class="bold">bones</strong>, in analogy with the <a id="_idIndexMarker741"/><span class="No-Break">human skeleton.</span></p>
<p>By default, bones are represented as octahedral sticks. Armatures can switch to <strong class="bold">Pose Mode</strong>, a special Blender mode in <a id="_idIndexMarker742"/>which bones can be animated individually using the techniques learned in <a href="B18375_07.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
<p>The setup of an <strong class="bold">Armature</strong> modifier might take some extra steps but is similar to the one used <span class="No-Break">for lattices.</span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor290"/>Adding armature objects to the scene</h2>
<p>To acquire familiarity <a id="_idIndexMarker743"/>with the bones, we will create a simple armature for <span class="No-Break"><strong class="bold">Suzanne</strong></span><span class="No-Break">’s geometry:</span></p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File</strong> | <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break">.</span></li>
<li>Delete the default <strong class="bold">Cube</strong> shape by pressing <strong class="bold">Canc</strong> or <strong class="bold">X</strong> | <span class="No-Break"><strong class="bold">Delete</strong></span><span class="No-Break">.</span></li>
<li>Add a monkey head to the scene using <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <span class="No-Break"><strong class="bold">Monkey</strong></span><span class="No-Break">.</span></li>
<li>Add an armature to the scene using <strong class="bold">Add</strong> | <strong class="bold">Armature</strong> | <span class="No-Break"><strong class="bold">Single Bone</strong></span><span class="No-Break">.</span></li>
</ol>
<p>At this point, we should see the tip of an octahedral bone on top of <strong class="bold">Suzanne</strong>’s head. Since most of the bone is hidden inside the model, we can press the <em class="italic">Z</em> key and switch to the <span class="No-Break">wireframe display.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 11.11: An armature bone inside a geometry, with a wireframe display" height="768" src="image/Figure_11.11_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11: An armature bone inside a geometry, with a wireframe display</p>
<p>We could set <a id="_idIndexMarker744"/>up an <strong class="bold">Armature</strong> modifier right away, but armatures usually have more than one bone. For instance, we can add bones to <span class="No-Break">the ears.</span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor291"/>Adding armature bones</h2>
<p>To have a better view while we <a id="_idIndexMarker745"/>create new bones, we can press the <em class="italic">1</em> key or use <strong class="bold">View</strong> | <strong class="bold">Viewpoint</strong> | <strong class="bold">Front</strong> from the top-bar menu, then we can press the <em class="italic">.</em> key, or <strong class="bold">View</strong> | <strong class="bold">Frame Selected</strong>, to center <span class="No-Break">the view.</span></p>
<p>With the armature as the active object, we switch to <strong class="bold">Edit Mode</strong> by pressing <em class="italic">Tab</em> or using the drop-down box on the top left. Then, always in front view, we can add bone to the ears using the <span class="No-Break">following steps:</span></p>
<ol>
<li>Add a new bone using the <em class="italic">Shift</em> + <em class="italic">A</em> combination or <strong class="bold">Add</strong> | <strong class="bold">Single Bone</strong> from the top-bar menu. The new bone is added on top of the <span class="No-Break">existing one.</span></li>
<li>Click on the bones to select one <span class="No-Break">of them.</span></li>
<li>Press <em class="italic">R</em>, then type <strong class="source-inline">50</strong>, and press <em class="italic">Enter</em> to rotate the bone toward the right-hand side of <span class="No-Break">the screen.</span></li>
<li>Press <em class="italic">G</em>, then <em class="italic">X</em> to move it horizontally, and type <strong class="source-inline">1</strong>. Then, press <em class="italic">Enter</em> to move the bone toward Suzanne’s <span class="No-Break">left ear.</span></li>
<li>Press <em class="italic">G</em>, then <em class="italic">Z</em> to move the bone vertically and type <strong class="source-inline">0.2</strong>. Then, press <em class="italic">Enter</em> to move the bone <span class="No-Break">slightly downward.</span></li>
<li>Blender has a naming convention for left and right bones. To add the <strong class="source-inline">.L</strong> suffix to the left ear bone, we select <strong class="bold">Armature</strong> | <strong class="bold">Names</strong> | <strong class="bold">Auto-Name Left/Right</strong> from the <span class="No-Break">top-bar menu.</span></li>
<li>To create a bone for the other ear, we select <strong class="bold">Armature</strong> | <strong class="bold">Symmetrize</strong> from the <span class="No-Break">top-bar menu.</span></li>
</ol>
<p>The resulting armature <a id="_idIndexMarker746"/>should resemble a trident. The exact position of the bones is not important for the sake of <span class="No-Break">this example.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 11.12: Ear bones for Blender’s Suzanne" height="612" src="image/Figure_11.12_B18375.jpg" width="972"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12: Ear bones for Blender’s Suzanne</p>
<p>With three bones in place, we can go back to <strong class="bold">Object Mode</strong> by pressing <em class="italic">Tab</em> and go back to the <strong class="bold">Solid</strong> view by pressing <em class="italic">Z</em>. Now, we can bind our geometry to <span class="No-Break">the armature.</span></p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor292"/>Binding objects to armatures</h2>
<p>As mentioned earlier, <strong class="bold">Armature</strong> deformers require additional information: each vertex should be <a id="_idIndexMarker747"/>assigned to one or more bones with a process called <strong class="bold">weight painting</strong>. It’s a <a id="_idIndexMarker748"/>manual task for riggers, but <a id="_idIndexMarker749"/>we can use Blender automatic weights for a <span class="No-Break">quick result:</span></p>
<ol>
<li>In <strong class="bold">Object Mode</strong>, select the Suzanne object in <strong class="bold">3D Viewport</strong>, then keep the <em class="italic">Shift</em> key pressed and select the <span class="No-Break">armature too.</span></li>
<li>Press <em class="italic">Ctrl</em> + <em class="italic">P</em> to open the <strong class="bold">Set Parent</strong> menu and pick <strong class="bold">With Automatic Weights</strong>. Or select <strong class="bold">Object</strong> | <strong class="bold">Parent</strong> | <strong class="bold">With Automatic Weights</strong> from the <span class="No-Break">top-bar menu.</span></li>
</ol>
<p class="callout-heading">Beware the outliner</p>
<p class="callout">If you use <strong class="bold">Outliner</strong> for selecting objects, keep in mind that its policy <span class="No-Break">is different:</span></p>
<ul>
<li class="callout">In <strong class="bold">Viewport</strong>, the last selected of multiple objects is the <span class="No-Break">active object</span></li>
<li class="callout">In <strong class="bold">Outliner</strong>, the first selected of multiple objects is the <span class="No-Break">active object</span></li>
</ul>
<p class="callout">To parent an object to an armature, we either select the object and then the armature in <strong class="bold">Viewport</strong>, or first the armature and then the object <span class="No-Break">in </span><span class="No-Break"><strong class="bold">Outliner</strong></span><span class="No-Break">.</span></p>
<p>Now we can deform our <a id="_idIndexMarker750"/>mesh by posing the <span class="No-Break">armature </span><span class="No-Break"><a id="_idIndexMarker751"/></span><span class="No-Break">bones:</span></p>
<ol>
<li>Select <strong class="bold">Armature</strong> and press <em class="italic">Ctrl</em> + <em class="italic">Tab</em>, or use the drop-down box on the top left of the screen and switch to <span class="No-Break"><strong class="bold">Pose Mode</strong></span><span class="No-Break">.</span></li>
<li>Select any bone, then move, rotate, or scale it by using the <em class="italic">G</em>, <em class="italic">R</em>, and <span class="No-Break"><em class="italic">S</em></span><span class="No-Break"> keys.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 11.13: Armature deformation in Blender" height="768" src="image/Figure_11.13_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13: Armature deformation in Blender</p>
<p>Bones are a soft, controllable <a id="_idIndexMarker752"/>way to deform a model. Lattice grids can be <a id="_idIndexMarker753"/>deformed with armatures too, so we can create and set up an armature in <span class="No-Break"><strong class="bold">Latte Express</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor293"/>Scripting a lattice armature</h1>
<p>Armatures are the recommended <a id="_idIndexMarker754"/>way for animating in Blender as they support linking across different <strong class="source-inline">.blend</strong> files and other advanced <span class="No-Break">animation features.</span></p>
<p>Binding a lattice to an armature allows you to animate deformations without switching to <strong class="bold">Edit Mode</strong> to edit <span class="No-Break">grid vertices.</span></p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor294"/>Adding an armature condition</h2>
<p>We want armatures <a id="_idIndexMarker755"/>to be an optional feature, so we can add another property for that. We set its default value to <strong class="source-inline">True</strong>, so an armature is created unless it’s <span class="No-Break">set otherwise:</span></p>
<pre class="source-code">
    add_armature: bpy.props.BoolProperty(default=True)</pre>
<p>Inside the <strong class="source-inline">execute</strong> method, we check for this value and <span class="No-Break">proceed accordingly.</span></p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor295"/>Adding an armature to the scene</h2>
<p>Armatures are <a id="_idIndexMarker756"/>created in the same way as lattices and <span class="No-Break">other objects:</span></p>
<ol>
<li>Create <span class="No-Break">new data.</span></li>
<li>Create a new object using the <span class="No-Break">data created.</span></li>
</ol>
<p>Even if it is not strictly required, we set the new armature as the parent of the lattice to ensure consistency between <span class="No-Break">their transforms.</span></p>
<p>If <strong class="source-inline">add_armature</strong> is <strong class="source-inline">False</strong>, we set the lattice location right away. Otherwise, we create a new armature. The underlying code takes over soon after we’ve got the object <span class="No-Break">median point:</span></p>
<pre class="source-code">
        # …
        ob_translation = ob.matrix_world.to_translation()
        ob_translation += ob_center
        if <strong class="source-inline">not self.add_armature</strong>:
            <strong class="source-inline">latt_obj.location = ob_translation</strong>
        <strong class="source-inline">else</strong>:
            <strong class="source-inline">arm_data</strong> = bpy.data.<strong class="source-inline">armatures.new</strong>(
                                           f"ARM-{ob.name}"
                                          )
            arm_obj = bpy.data.objects.new(
                                       name=arm_data.name,
                                       <strong class="source-inline">object_data=arm_data</strong>
                                      )
            context.collection.objects.link(arm_obj)</pre>
<p>Once the armature is part of the scene, we can parent the lattice to it and move it to where the <span class="No-Break">object is:</span></p>
<pre class="source-code">
            latt_obj.parent = arm_obj
            arm_obj.location = ob_translation</pre>
<p>It’s common to have the armature’s transform pivot under the affected geometry, so when an armature <a id="_idIndexMarker757"/>is at its resting position, the deformed character will be above ground level. Therefore, we move the armature to half the object height below the center, using the third coordinate <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">dimensions</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
            half_height = ob.<strong class="source-inline">dimensions[2]/2</strong>
            arm_obj.location[2] <strong class="source-inline">-= half_height</strong></pre>
<p>The lattice, on the other hand, should be centered on the geometry, so we bring it up by the <span class="No-Break">same amount:</span></p>
<pre class="source-code">
            latt_obj.location[2] += half_height</pre>
<p>Now that the armature <a id="_idIndexMarker758"/>and lattice are placed, we need to create <span class="No-Break">some bones.</span></p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor296"/>Creating edit bones</h2>
<p>To create the <a id="_idIndexMarker759"/>bones manually, we select the armature and switch to <strong class="bold">Edit Mode</strong>. In Python, the same steps are performed with <span class="No-Break">the following:</span></p>
<pre class="source-code">
            context.view_layer.objects.<strong class="source-inline">active</strong> = <strong class="source-inline">arm_obj</strong>
            bpy.ops.object.<strong class="source-inline">mode_set</strong>(mode=<strong class="source-inline">'EDIT'</strong>,
                                    toggle=False)</pre>
<p>We pass <strong class="source-inline">False</strong> to the <strong class="source-inline">toggle</strong> argument of <strong class="source-inline">mode_set</strong>, because we are not switching back and forth <span class="No-Break">between modes.</span></p>
<p>We will add as many bones as the lattice vertical sections. For instance, a lattice with a vertical resolution of <strong class="source-inline">3</strong> can be rigged with <span class="No-Break">three bones.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 11.14: Rigging a lattice with armature bones" height="768" src="image/Figure_11.14_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14: Rigging a lattice with armature bones</p>
<p>We get the number of levels from the <strong class="source-inline">grid_levels</strong> property. Each bone starts from the lower section and stops at the next. The last bone pops outside <span class="No-Break">the lattice.</span></p>
<p>To get the optimal length, we divide the object height by the number of internal bones, i.e., one bone less <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">grid_levels</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
            grid_levels = self.grid_levels[2]
            height = ob.dimensions[2]
            bone_length = height / (grid_levels – 1)</pre>
<p>We use a <strong class="source-inline">for</strong> loop to add an <strong class="bold">edit bone</strong> at each section. In Python, index-based loops use the <strong class="source-inline">range</strong> function. We add a two-digit suffix to each <span class="No-Break">bone name:</span></p>
<pre class="source-code">
            for i in <strong class="source-inline">range</strong>(grid_levels):
                eb = arm_data.edit_bones.new(f"LAT_<strong class="source-inline">{i:02}</strong>")</pre>
<p>Each bone has a start point (<strong class="source-inline">head</strong>) and an endpoint (<strong class="source-inline">tail</strong>). Since the armature’s origin matches the first section of the lattice, the first bone has the coordinates <strong class="source-inline">0, </strong><span class="No-Break"><strong class="source-inline">0, 0</strong></span><span class="No-Break">.</span></p>
<p>The second bone <a id="_idIndexMarker760"/>should have a higher position to make room for the previous bone length, and so on, so the expression for each bone head is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
                eb.<strong class="source-inline">head</strong> = (0, 0, <strong class="source-inline">i * bone_length</strong>)</pre>
<p>The <strong class="source-inline">tail</strong> part of the bone adds one <strong class="source-inline">bone_length</strong> to the <span class="No-Break"><strong class="source-inline">head[2]</strong></span><span class="No-Break"> coordinate:</span></p>
<pre class="source-code">
                eb.<strong class="source-inline">tail</strong> = (0, 0, <strong class="source-inline">eb.head[2] + bone_length</strong>)</pre>
<p>To assign the lattice vertices to the bones, we must collect which vertices belong to the current level based on their <span class="No-Break"><strong class="source-inline">Z</strong></span><span class="No-Break"> coordinate.</span></p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor297"/>Assigning vertices to bones</h2>
<p>For each lattice <a id="_idIndexMarker761"/>point, we compare the third coordinate (<strong class="source-inline">co[2]</strong>) with <a id="_idIndexMarker762"/>the relative height of the current section. <em class="italic">Relative</em> means that the first section is at a height of <strong class="source-inline">0.0</strong>, the last is at <strong class="source-inline">1.0</strong>, the one in the middle is at <strong class="source-inline">0.5</strong>, and <span class="No-Break">so on.</span></p>
<p>Python indices start from <strong class="source-inline">0</strong>, so the index of the last section is the number of sections minus <strong class="source-inline">1</strong>. Keeping that in mind, here’s how we can get the relative height of <span class="No-Break">each level:</span></p>
<pre class="source-code">
                rel_height = i / (grid_levels–- 1)</pre>
<p>Lattice points are relative to the center, and the size of one side of the lattice is <strong class="source-inline">1.0</strong>, so the vertical coordinate of the lowest point is <strong class="source-inline">-0.5</strong>. For that reason, we lower <strong class="source-inline">rel_height</strong> by <span class="No-Break"><strong class="source-inline">0.5</strong></span><span class="No-Break"> units:</span></p>
<pre class="source-code">
                rel_height -= 0.5</pre>
<p>To assign vertices, we need a list of their indices, which we store in the <span class="No-Break"><strong class="source-inline">vert_ids</strong></span><span class="No-Break"> list:</span></p>
<pre class="source-code">
                vert_ids = []</pre>
<p>In this list, we need to store the identifier number of the lattice points, not <span class="No-Break">their coordinates.</span></p>
<p>The lattice data points are an ordered collection, so their identifier is their ordinal index; that is, the first point is identified by index <strong class="source-inline">1</strong>, the second point has index <strong class="source-inline">2</strong>, and <span class="No-Break">so on.</span></p>
<p>In Python, we can get the ordinal of the iterated items <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">enumerate</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
                for <strong class="source-inline">id</strong>, <strong class="source-inline">v</strong> in <strong class="source-inline">enumerate</strong>(latt_data.<strong class="source-inline">points</strong>):
                    if <strong class="source-inline">v.co[2] == rel_height</strong>:
                        vert_ids.append(id)</pre>
<p>We can create a <a id="_idIndexMarker763"/>vertex group named after each bone and <a id="_idIndexMarker764"/>assign vertices using the <strong class="source-inline">add</strong> method. We also supply a weight of <strong class="source-inline">1.0</strong>, because we are not blending the assignment between two groups, and set <strong class="source-inline">'REPLACE'</strong> as a condition, because we are not adding nor subtracting from a <span class="No-Break">previous assignment:</span></p>
<pre class="source-code">
                vg = latt_obj.vertex_groups.<strong class="source-inline">new</strong>(
                                               name=<strong class="source-inline">eb.name</strong>
                                              )
                vg.add(<strong class="source-inline">vert_ids</strong>, <strong class="source-inline">1.0</strong>,'REPLACE')</pre>
<p>Creating the bones and assigning their influence is the hard part of the process. Now we can create <span class="No-Break">the modifiers.</span></p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor298"/>Creating the Armature modifier</h2>
<p>We add <a id="_idIndexMarker765"/>a new Armature modifier to <strong class="source-inline">latt_obj</strong> via the <strong class="source-inline">modifiers.new</strong> method, and we use <strong class="source-inline">arm_obj</strong> as its <span class="No-Break">deformer object:</span></p>
<pre class="source-code">
            arm_mod = <strong class="source-inline">latt_obj</strong>.modifiers.new("Armature",
                                            <strong class="source-inline">"ARMATURE"</strong>)
            arm_mod.object = arm_obj</pre>
<p>Finally, we leave <strong class="bold">Edit Mode</strong> and switch to <strong class="source-inline">'POSE'</strong>, so that the user <span class="No-Break">can animate:</span></p>
<pre class="source-code">
            bpy.ops.object.mode_set(mode='POSE',
                                    toggle=False)</pre>
<p>At this point, <strong class="source-inline">LattExpress</strong> creates a lattice deformer and animation bones in one click. As an optional <a id="_idIndexMarker766"/>step, we can create custom shapes for displaying <span class="No-Break">the bones.</span></p>
<h1 id="_idParaDest-284"><a id="_idTextAnchor299"/>Adding custom bone shapes</h1>
<p>Armature bones are effective deformers, but we have experienced a major drawback for ourselves <a id="_idIndexMarker767"/>in the <em class="italic">Using armature deformers</em> section: bones tend to be hidden by the <span class="No-Break">deformed geometry.</span></p>
<p>There are a few workarounds, such as activating the <strong class="bold">In Front</strong> attribute in the <strong class="bold">Armature</strong> properties and using <strong class="bold">X-Ray</strong> or <span class="No-Break"><strong class="bold">Wireframe</strong></span><span class="No-Break"> views.</span></p>
<p>Another gimmick consists in displaying special widgets by assigning mesh objects to the bone’s <strong class="bold">Custom </strong><span class="No-Break"><strong class="bold">Shape</strong></span><span class="No-Break"> attribute.</span></p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor300"/>Creating mesh objects in Python</h2>
<p>First, we <a id="_idIndexMarker768"/>must create a new mesh. A mesh <a id="_idIndexMarker769"/>consists of vertex coordinates, plus <a id="_idIndexMarker770"/>edges or faces that <span class="No-Break">connect vertices.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 11.15: Vertex coordinates of a 2D square" height="449" src="image/Figure_11.15_B18375.jpg" width="449"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15: Vertex coordinates of a 2D square</p>
<p>In this example, we create a wireframe square and use it as a bone widget. Blender bones expand upon their <strong class="source-inline">Y</strong> axis, so the horizontal coordinates of our bones that are placed vertically are <strong class="source-inline">X</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Z</strong></span><span class="No-Break">.</span></p>
<p>We build our <a id="_idIndexMarker771"/>list of vertices. We <a id="_idIndexMarker772"/>aim for a side length of <strong class="source-inline">1.0</strong>, a measure easy to <a id="_idIndexMarker773"/>scale. For that reason, each side will go from a <strong class="source-inline">-0.5</strong> to a <strong class="source-inline">0.5</strong> coordinate, or the other way around. If <strong class="source-inline">X</strong> and <strong class="source-inline">Z</strong> are the first and last coordinates, this is our <span class="No-Break">vertex list:</span></p>
<pre class="source-code">
            v_cos = [
                [-0.5, 0.0, -0.5],
                [-0.5, 0.0, 0.5],
                [0.5, 0.0, 0.5],
                [0.5, 0.0, -0.5]
            ]</pre>
<p>Next, we need a list of edges. An edge is a pair of vertex indices, each representing the two vertices that are going to connect. The four edges of a square connect vertex <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>, <strong class="source-inline">1</strong> to <strong class="source-inline">2</strong>, vertex <strong class="source-inline">2</strong> to <strong class="source-inline">3</strong>, and <strong class="source-inline">3</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0]
            ]</pre>
<p>We can create new mesh data from Python lists using the <strong class="source-inline">from_pydata</strong> method. Since we don’t need faces in a control widget, the third argument is an <span class="No-Break">empty list:</span></p>
<pre class="source-code">
            mesh = bpy.data.meshes.new("WDG-square")
            <strong class="source-inline">mesh.from_pydata(coords, edges, [])</strong></pre>
<p>We add the mesh to <span class="No-Break">the scene:</span></p>
<pre class="source-code">
            wdg_obj = bpy.data.objects.new(mesh.name, mesh)
            context.collection.objects.link(wdg_obj)</pre>
<p>Now, we can assign the widget shape to the <strong class="bold">pose bones</strong> of <span class="No-Break">our armature:</span></p>
<pre class="source-code">
            for pb in arm_obj.<strong class="source-inline">pose.bones</strong>:
                pb.<strong class="source-inline">custom_shape = wdg_obj</strong></pre>
<p>With a side <a id="_idIndexMarker774"/>length of <strong class="source-inline">1.0</strong>, our widget could <a id="_idIndexMarker775"/>be hidden as well, so we scale it to match <a id="_idIndexMarker776"/>the <span class="No-Break"><strong class="source-inline">dimensions</strong></span><span class="No-Break"> object.</span></p>
<p>Keeping in mind that a bone’s up direction is the <strong class="source-inline">Y</strong> axis, but Blender’s up direction is <strong class="source-inline">Z</strong>, we set the <strong class="source-inline">Z</strong> custom shape scale to the <span class="No-Break"><strong class="source-inline">Y</strong></span><span class="No-Break"> dimension:</span></p>
<pre class="source-code">
                pb_scale = pb.<strong class="source-inline">custom_shape_scale_xyz</strong>
                pb_scale[0] = ob.dimensions[0]
                pb_scale[<strong class="source-inline">2</strong>] = ob.dimensions[<strong class="source-inline">1</strong>]</pre>
<p>Blender scales the displayed custom shape by the length of the bone, so we divide the scale by the <span class="No-Break">bone length:</span></p>
<pre class="source-code">
                pb_scale[0] /= bone_length
                pb_scale[2] /= bone_length</pre>
<p>The armature created in our script is ready. We will tidy the scene and exit <span class="No-Break">the operator.</span></p>
<p class="callout-heading">Storing bones is bad for your variables!</p>
<p class="callout">Armature bones are represented by different Python entities depending on the current mode. When the armature is in <strong class="bold">Edit Mode</strong>, <strong class="source-inline">EditBone</strong> from the armature data <strong class="source-inline">edit_bones</strong> collection is used. When the armature is in <strong class="bold">Pose Mode</strong>, <strong class="source-inline">PoseBone</strong> from the <strong class="source-inline">pose.bones</strong> object <span class="No-Break"><strong class="source-inline">is</strong></span><span class="No-Break"> used.</span></p>
<p class="callout">These collections are rebuilt every time the armature is updated, storing them in variables while they are changed can <span class="No-Break">cause crashes.</span></p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor301"/>Finalizing the setup</h2>
<p>If an armature <a id="_idIndexMarker777"/>is created, we hide the widget mesh and <span class="No-Break">the lattice:</span></p>
<pre class="source-code">
            wdg.hide_set(True)
            latt_obj.hide_set(True)</pre>
<p>The last steps of <strong class="source-inline">execute</strong> are the same as before: we create a lattice modifier for the deformed object, unselect the geometry, <span class="No-Break">and finish:</span></p>
<pre class="source-code">
        mod = ob.modifiers.new("Lattice", "LATTICE")
        mod.object = latt_obj
        ob.select_set(False)
        return {'FINISHED'}</pre>
<p>Reloading the scripts and launching <strong class="bold">Create Lattice on Active Object</strong> will create a full animation setup complete with armature and <span class="No-Break">bone shapes.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 11.16: Suzanne deformed via animation controls" height="640" src="image/Figure_11.16_B18375.jpg" width="640"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16: Suzanne deformed via animation controls</p>
<p>This add-on can still be <a id="_idIndexMarker778"/>improved. For instance, we could build oval shapes for our animation controls or tidy the <strong class="source-inline">execute</strong> method by moving some of the code to specific functions, but since it satisfies its initial purpose, we can consider <span class="No-Break">it finished.</span></p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor302"/>Summary</h1>
<p>We have learned how to alter objects using modifiers and how to bind modifiers to animate objects. We have also gained a deeper understanding of how object data works and how objects of different types are created, linked to the scene, <span class="No-Break">and integrated.</span></p>
<p>Using this knowledge, we have coded a production tool that can be used to deform <span class="No-Break">any object.</span></p>
<p>In the next and final chapter of this book, <a href="B18375_12.xhtml#_idTextAnchor304"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, we will explore the last step of a <span class="No-Break">3D pipeline.</span></p>
<h1 id="_idParaDest-288"><a id="_idTextAnchor303"/>Questions</h1>
<ol>
<li>Do modifiers alter the <span class="No-Break">object’s data?</span></li>
<li>How do we add modifiers to <span class="No-Break">an object?</span></li>
<li>Do modifiers rely on other objects besides the ones <span class="No-Break">they deform?</span></li>
<li>True or false: We can change the resolution of lattice data before or after we create its lattice object with <span class="No-Break">no consequences.</span></li>
<li>How do we add bones to an armature <span class="No-Break">in Python?</span></li>
<li>True or false: There is only one bone <span class="No-Break">collection property.</span></li>
<li>True or false: Only objects of type mesh can be deformed <span class="No-Break">by armatures.</span></li>
<li>Blender has modes. Does the current mode have consequences on whether we can add or remove data in <span class="No-Break">our script?</span></li>
<li>How do we create a mesh <span class="No-Break">using Python?</span></li>
</ol>
</div>
</div></body></html>