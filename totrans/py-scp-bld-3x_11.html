<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-252"><a id="_idTextAnchor265"/>11</h1>
<h1 id="_idParaDest-253"><a id="_idTextAnchor266"/>Object Modifiers</h1>
<p>A major part of creating 3D content consists of editing geometries by adding and removing the vertices, edges, and faces of a model, or displacing the existing ones.</p>
<p><strong class="bold">Object modifiers</strong> can perform these actions via non-destructive edits that affect the appearance of <a id="_idIndexMarker696"/>an object but not its internal data. They can be used for generative modeling, and without them, animation would be impossible, because deforming an object would require changing the geometric data at every frame.</p>
<p>Object modifiers are like the F-Modifiers treated in <a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>, but they present a greater variety in purpose and attributes.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Understanding and using object modifiers</li>
<li>Script deformation modifiers</li>
<li>Generating armatures and meshes</li>
</ul>
<h1 id="_idParaDest-254"><a id="_idTextAnchor267"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found at the following URL: <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11</a>.<a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11%0D"/></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor268"/>Understanding object modifiers</h1>
<p>Object modifiers change the displayed status of an object without altering its geometric data. We met <a id="_idIndexMarker697"/>something similar in <a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>, when we applied effects to animation F-Curves without changing their keyframes.</p>
<p>Like F-Modifiers, they can be stacked on each other and accessed in Python as a collection property.</p>
<p>Modifiers can be added <a id="_idIndexMarker698"/>manually, but their creation and setup can be scripted as well. Before we delve into the API, let’s take a look at how to create them in the <strong class="bold">Modifiers</strong> properties.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor269"/>Adding modifiers</h2>
<p>Object modifiers are <a id="_idIndexMarker699"/>created in the <strong class="bold">Modifiers</strong> tab of <strong class="bold">Properties</strong> using the <strong class="bold">Add Modifier</strong> drop-down button. The tab is marked with the icon of a wrench.</p>
<div><div><img alt="Figure 11.1: Adding modifiers in Blender" height="928" src="img/Figure_11.01_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: Adding modifiers in Blender</p>
<p>Clicking <strong class="bold">Add Modifier</strong> displays the available options. They change according to the object type: curves don’t have as many modifiers as meshes, while nongeometric types such as empty or cameras can’t have any modifiers at all.</p>
<p>Though their number has grown with time, all modifiers are grouped into four categories:</p>
<ul>
<li><strong class="bold">Modify</strong> – Affects data that won’t be displayed directly, such as vertex groups</li>
<li><strong class="bold">Generate</strong> – Adds or removes geometry to or from an object</li>
<li><strong class="bold">Deform</strong> – Changes the shape of an object without adding or removing vertices, edges, or faces</li>
<li><strong class="bold">Physics</strong> – Brings the result of physics simulations to the object</li>
</ul>
<div><div><img alt="Figure 11.2: Clicking Add Modifier displays the available types" height="788" src="img/Figure_11.02_B18375.jpg" width="1323"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Clicking Add Modifier displays the available types</p>
<p>The interface displays one column per category, with several modifier types for each of the four. Even modifier <a id="_idIndexMarker700"/>types from the same category differ a lot from each other and present different sets of attributes.</p>
<p>To better understand how modifiers work, we can create one in the interface and see how that affects an object’s geometry. For example, adding a <strong class="bold">Subdivision Surface</strong> modifier to an object makes it smoother by creating additional polygons.</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor270"/>Subdividing an object</h2>
<p>Mesh objects are polygonal; that is, they consist of flat faces and sharp edges. That works well for <a id="_idIndexMarker701"/>simple solids like a cube, but not for smooth surfaces such as a sphere, or most real-life objects.</p>
<p>To give an illusion of smoothness, we subdivide the polygons of a mesh until they approximate a continuous surface.</p>
<p>The downside is that geometries that are too dense are problematic; they require more disk space and are not easy to model or edit. For that reason, rather than storing additional mesh data, we generate smooth geometry using the <strong class="bold">Subdivision </strong><strong class="bold">Surface</strong> modifier.</p>
<div><div><img alt="Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface" height="416" src="img/Figure_11.03_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface</p>
<p>This modifier splits every edge into two, generating new polygons from those divisions. By default, an algorithm named <strong class="bold">Catmull-Clark</strong> smoothens the result while preserving the overall shape.</p>
<p>We can add a <a id="_idIndexMarker702"/>subdivision to a model with the following steps:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File | New | </strong><strong class="bold">General</strong>.</li>
<li>Select the default <strong class="bold">Cube</strong> shape and make it active.</li>
<li>In the <strong class="bold">Modifiers</strong> tab, click <strong class="bold">Add Modifier</strong> and select <strong class="bold">Subdivision Surface</strong> at the bottom of the <strong class="bold">Generate</strong> column.</li>
<li>A new entry appears in the <strong class="bold">Modifiers</strong> properties. We can see the parameters of the <strong class="bold">Subdivision</strong> modifier.</li>
</ol>
<div><div><img alt="Figure 11.4: Subdivision Surface properties" height="390" src="img/Figure_11.04_B18375.jpg" width="477"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: Subdivision Surface properties</p>
<ol>
<li value="5">Increasing the number in <code>3</code> makes our <strong class="bold">Cube</strong> look much like a ball.</li>
<li>Clicking the <strong class="bold">Simple</strong> button disables the smoothing: the object is still subdivided, but its shape doesn’t change.</li>
</ol>
<p>Even if enabling <strong class="bold">Simple</strong> doesn’t alter its shape, our object is still subdivided. That can be useful to other <a id="_idIndexMarker703"/>modifiers that can be added after <strong class="bold">Subdivision</strong>, as they will have more geometry to deform.</p>
<p>Now that our <strong class="bold">Cube</strong> has been subdivided, we will be able to alter its shape using a second modifier: <strong class="bold">Cast</strong>.</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor271"/>Changing the object’s shape using Cast</h2>
<p>With our <strong class="bold">Subdivision</strong> modifier <a id="_idIndexMarker704"/>still in place, we can <a id="_idIndexMarker705"/>add a new modifier to alter the object’s shape:</p>
<ol>
<li>In the <strong class="bold">Modifiers</strong> tab, click <strong class="bold">Add Modifier</strong> and select <strong class="bold">Cast</strong> at the top of the <strong class="bold">Deform</strong> column. Another modifier shows up under <strong class="bold">Subdivision</strong>.</li>
<li>Change the <code>Cylinder</code> and the <code>1.0</code>. Our geometry is now a cylinder.</li>
</ol>
<p>The two modifiers are displayed one on top of the other. Starting from the top, each modifier acts as the <a id="_idIndexMarker706"/>input of the next one. For this reason, the modifiers column is also called the <strong class="bold">modifiers stack</strong>.</p>
<p>Using modifiers, we have made our original object look like a cylinder, but that change can be reversed, or even animated. Moving the <code>0.0</code> and <code>1.0</code>, our object transitions from its original shape to the one set in <strong class="bold">Cast</strong>.</p>
<p>We can replicate the preceding steps in Python scripts using Blender’s API.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor272"/>Adding modifiers in Python</h1>
<p>The Python class <a id="_idIndexMarker707"/>of Blender objects contains a <code>modifiers</code> attribute. Like <a id="_idIndexMarker708"/>all coll<a id="_idTextAnchor273"/>ections, <code>modifiers</code> provides the <code>new</code> method, which creates and returns new items. By using <code>new</code>, we can automate the setup of modifiers using Python.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor274"/>Finding collection-type items</h2>
<p><code>Object.modifiers.new</code> takes two arguments: <code>name</code> and <code>type</code>. The first will be displayed in the <a id="_idIndexMarker709"/>modifier properties in the interface, while <code>type</code> specifies which kind of modifier we want to create. The <code>type</code> argument must belong to the list of available types, or it will cause an error. Available types are listed in the API documentation:</p>
<p><a href="https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml">https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml</a></p>
<p>But we can also get them from Blender itself. These commands will list the modifier keywords in Blender’s Python console:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; mod_rna = bpy.types.ObjectModifiers.bl_rna
&gt;&gt;&gt; mod_params = mod_rna.functions["new"].parameters
&gt;&gt;&gt; mod_params["type"].enum_items.keys()
['DATA_TRANSFER', 'MESH_CACHE', 'MESH_SEQUENCE_CACHE', 'NORMAL_EDIT', 'WEIGHTED_NORMAL', 'UV_PROJECT', 'UV_WARP',
...</pre>
<p>There’s another way to get a modifier keyword:</p>
<ol>
<li>Use the <strong class="bold">Add Modifier</strong> button in the interface.</li>
<li>Look for the argument of the <code>modifier_add</code> operator in the <strong class="bold">Info</strong> log. It’s part of the <strong class="bold">Scripting</strong> workspace, as we know from <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</li>
</ol>
<div><div><img alt="Figure 11.5: Blender info log after adding Subdivision Surface" height="159" src="img/Figure_11.05_B18375.jpg" width="888"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: Blender info log after adding Subdivision Surface</p>
<p>For instance, the <a id="_idIndexMarker710"/>keyword for the <code>'SUBSURF'</code>.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor275"/>Using modifiers.new</h2>
<p>Since <code>modifiers.new</code> returns <a id="_idIndexMarker711"/>the created modifier, we can store the return value and replicate all the steps from the previous <em class="italic">Understanding object </em><em class="italic">modifiers</em> section.</p>
<p>We’ll see how to add a <code>bpy</code> and add a subdivision to increase the available geometry:</p>
<pre class="source-code">
import bpy
ob = bpy.context.object
subdiv = ob.modifiers.new('Subdivision', 'SUBSURF')</pre>
<p>The <code>subdiv</code> variable contains the new <code>subdiv</code>’s attributes.</p>
<p>If we are looking for the Python counterpart of an attribute we can see in the interface, we can resort to <strong class="bold">Python Tooltips</strong> and <strong class="bold">Developer Extra</strong>, the two options in <strong class="bold">Edit</strong> &gt; <strong class="bold">Preferences</strong> from the top-bar menu. We learned about them in the <em class="italic">Useful features for Python</em> section in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>.</p>
<p>If tooltips are enabled, hovering the mouse on the <code>levels</code>.</p>
<div><div><img alt="Figure 11.6: Subdivision attributes path displayed in tooltips" height="240" src="img/Figure_11.06_B18375.jpg" width="560"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: Subdivision attributes path displayed in tooltips</p>
<p>To increase the object’s poly count without altering its shape, we set <code>subdiv.levels</code> to <code>3</code> and <code>subdivision_type</code> to <code>'SIMPLE'</code>:</p>
<pre class="source-code">
subdiv.levels = 3
subdiv.subdivision_type = 'SIMPLE'</pre>
<p>Now we have <a id="_idIndexMarker712"/>enough polygons to deform our object. We add a <code>'CAST'</code> modifier and reshape it to a cylinder:</p>
<pre class="source-code">
cast = ob.modifiers.new('Cast', 'CAST')
cast.cast_type = <code>'CYLINDER'</code>
cast.factor = <code>1.0</code></pre>
<p><strong class="bold">Subdivision Surface</strong> and <strong class="bold">Cast</strong> are self-sufficient, as they don’t require other objects besides the one they are affecting. Other modifiers rely on data from ancillary objects.</p>
<p>In the next section, we will set up a modifier that depends on a deformer object.</p>
<h1 id="_idParaDest-262"><a id="_idTextAnchor276"/>Deformation objects</h1>
<p>Many deformers translate <a id="_idIndexMarker713"/>a change from one object to another. That allows us to deform a complex object by manipulating a simpler one. Here are a few notable examples:</p>
<ul>
<li><strong class="bold">Curve</strong> – Deforms a mesh along a curve object</li>
<li><strong class="bold">Lattice</strong> – Transfers the changes from a regular grid to a mesh</li>
<li><strong class="bold">Armature</strong> – Transfers the pose of an articulated structure to a mesh</li>
<li><strong class="bold">Surface Deform</strong> – Transfers the deformation from one mesh to another</li>
</ul>
<p>The object used by a <a id="_idIndexMarker714"/>modifier can be set using the <code>modifier.object</code> attribute.</p>
<p>The <strong class="bold">Armature</strong> modifier reproduces the limb movements using a structure of <strong class="bold">bones</strong>, so it requires <a id="_idIndexMarker715"/>a special type of object that can be posed.</p>
<p>A <strong class="bold">Lattice</strong> modifier, on the other <a id="_idIndexMarker716"/>hand, relies on the internal coordinates of a grid, which are specific to <strong class="bold">Lattice</strong> object types.</p>
<p>As an example, we will see how to add lattice deformation to an object.</p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor277"/>Using the Lattice modifier</h2>
<p>To use lattice deformation, we <a id="_idIndexMarker717"/>need geometry to deform and an object <a id="_idIndexMarker718"/>of type lattice. We can use Blender’s mascot, the monkey <strong class="bold">Suzanne</strong>:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File </strong>| <strong class="bold">New </strong>| <strong class="bold">General</strong>.</li>
<li>Delete the default <strong class="bold">Cube</strong> shape by pressing <strong class="bold">Canc</strong> or <strong class="bold">X</strong> | <strong class="bold">Delete</strong>.</li>
<li>Add a monkey head to the scene using <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Monkey</strong>.</li>
<li>Add a lattice to the scene by using <strong class="bold">Add</strong> | <strong class="bold">Lattice</strong>.</li>
</ol>
<p>A lattice was added to the scene. By default, it is smaller than Suzanne, so we need to scale it up:</p>
<ol>
<li>With the lattice still selected, press <code>S</code> to scale. Drag the mouse or press <code>2</code> to double its size.</li>
<li>Select Suzanne to add a modifier. In the <strong class="bold">Modifiers</strong> tab, Use <strong class="bold">Add Modifier</strong> | <strong class="bold">Lattice</strong>.</li>
<li>In the <strong class="bold">Lattice</strong> modifier, click the <strong class="bold">Object</strong> property and select the <strong class="bold">Lattice</strong> object from the options.</li>
</ol>
<p>Editing the Lattice object changes Suzanne’s shape:</p>
<ol>
<li>Select <strong class="bold">Lattice</strong> in <strong class="bold">3D Viewport</strong>.</li>
<li>Press the <em class="italic">Tab</em> key to switch to <strong class="bold">Edit Mode</strong>.</li>
<li>Select one or more lattice vertices.</li>
<li>Press <em class="italic">G</em> and drag the <a id="_idIndexMarker719"/>mouse to move the selection: a lattice <a id="_idIndexMarker720"/>deformation is applied to Suzanne.</li>
</ol>
<div><div><img alt="Figure 11.7: Mesh deformed by a lattice cage" height="680" src="img/Figure_11.07_B18375.jpg" width="1024"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: Mesh deformed by a lattice cage</p>
<p>Automating these steps with Python can make the process much easier. In the next section, we will write an operator that sets up a lattice deformation in one click.</p>
<h1 id="_idParaDest-264"><a id="_idTextAnchor278"/>Writing the Latte Express add-on</h1>
<p>The <strong class="bold">Latte Express</strong> add-on <a id="_idIndexMarker721"/>creates a new lattice around the active object and sets up the modifier.</p>
<p>It’s useful for creating basic rigs for cartoon deformation, or stylized objects. The add-on consists of an operator class and a menu entry.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor279"/>Setting the environment</h2>
<p>We create <a id="_idIndexMarker722"/>a Python script for our add-on:</p>
<ol>
<li>Create a <code>PythonScriptingBlender/ch11/addons</code> folder. We can use the file manager or the file tab of our programmer editor, for example, <strong class="bold">VS Code</strong>.</li>
<li>Create a new file in that folder and name it <code>lattice_express.py</code>. We can do that using the file manager or the <strong class="bold">New File</strong> button in an IDE.</li>
<li>Open the file in <a id="_idIndexMarker723"/>your editor of choice.</li>
<li>Set the <code>PythonScriptingBlender/ch11</code> in the Blender <strong class="bold">File Paths</strong> preferences and restart Blender.</li>
</ol>
<p>Now we can write the add-on and load it in Blender.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor280"/>Writing the Latte Express information</h2>
<p>Like other <a id="_idIndexMarker724"/>add-ons, Latte Express starts with a blank line, followed by the <code>bl_info</code> dictionary:</p>
<pre class="source-code">
bl_info = {
    "name": "Latte Express",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Create a Lattice on the active object",
    "category": "Learning",
}</pre>
<p>Then we proceed with the add-on classes and interface, in this case, a simple operator.</p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor281"/>Writing the Latte Express operator</h2>
<p>We need to <a id="_idIndexMarker725"/>import the <code>bpy</code> module, so that we can create a new operator:</p>
<pre class="source-code">
import bpy
class LatteExpress(bpy.types.Operator):
    """Set up Lattice Deformation"""
    bl_idname = "object.latte_expresso"
    bl_label = "Create Lattice on active object"</pre>
<p>The operator requires an active object, so the condition in <code>poll</code> is as follows:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return context.active_object</pre>
<p>Creating a lattice object requires lattice data first, so inside <code>execute</code>, we call <code>bpy.data.lattices.new</code> and use its return value in <code>bpy.data.objects.new</code>. We name the new <a id="_idIndexMarker726"/>object and data after the active object, even if that’s not required. Finally, we add the lattice to the scene by linking it to the current collection:</p>
<pre class="source-code">
    def execute(self, context):
        ob = context.object
        <code>latt_data</code> = bpy.data.lattices.new(f"LAT-{ob.name}")
        latt_obj = <code>bpy.data.objects.new</code>(
                                     name=latt_data.name,
                                     object_data=<code>latt_data</code>
                                    )
        context.collection.objects.link(latt_obj)</pre>
<p>Let’s scale the lattice so that it fits our object. We can get its size from the <code>dimensions</code> attribute:</p>
<pre class="source-code">
        latt_obj.scale = ob.dimensions</pre>
<p>We match the lattice position with the center of the active geometry. We can get the object location from the world matrix as we learned in <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>:</p>
<pre class="source-code">
        ob_translation = ob.matrix_world.to_translation()</pre>
<p>That alone would <a id="_idIndexMarker727"/>not work on objects that have their transform pivot away from their geometry center, so we must find the actual midpoint of our object.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor282"/>Finding the center of a model</h2>
<p>To create a lattice that matches the location and size of an object, we must find the median <a id="_idIndexMarker728"/>point of its vertices, but we don’t have to look at all the components. We can find the center of the object’s <strong class="bold">bounding box</strong>.</p>
<p>A bounding box is an imaginary <a id="_idIndexMarker729"/>parallelepiped that contains all the object geometry. We can display it by activating <strong class="bold">Bound</strong> in the <strong class="bold">Object</strong> properties.</p>
<div><div><img alt="Figure 11.8: An object’s bounding box with coordinate indices added on top" height="762" src="img/Figure_11.8_B18375.jpg" width="1629"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8: An object’s bounding box with coordinate indices added on top</p>
<p>The bounding box is found in Python via the <code>bound_box</code> attribute. It’s a list of eight coordinates, and we can find the center by interpolating two opposite corners.</p>
<p>The center of a box is found in the middle of its diagonals, so we want to mediate between the lower-left-back corner and the top-right-forward corner. We know the indices of those points from <em class="italic">Figure 11</em><em class="italic">.8</em>. They are <code>0</code> and <code>6</code>, respectively.</p>
<p>A better way to find those two corners is by using the <code>min</code> and <code>max</code> functions.</p>
<p>One of the two extremes has the lowest <code>x</code>, <code>y</code>, <code>z</code> values, and the other one has the highest. In other words, the components of the lower corner have the lowest sum, and those of the higher corner have the highest.</p>
<p>In Python, <code>min</code> and <code>max</code> return the lower and higher value in a list, but we can supply a different criterion, in this case, <code>sum</code>, using the <code>key</code> argument:</p>
<pre class="source-code">
        btm_left = min((c for c in ob.bound_box), key=<code>sum</code>)
        top_right = max((c for c in ob.bound_box), key=<code>sum</code>)</pre>
<p>To find the midpoint between two vectors, we can use the linear interpolation method (<code>lerp</code>) from the <code>Vector</code> class. In the <code>import</code> section, we need to add this line:</p>
<pre class="source-code">
from mathutils import Vector</pre>
<p>Then, in <code>execute</code>, we interpolate the two coordinates. The first argument of <code>lerp</code> can be any triplet, so we convert only one <a id="_idTextAnchor283"/>of the two corners to the <code>Vector</code> type. Since we are looking for the point sitting halfway between the two corners, we provide a factor of <code>0.5</code> as the second argument:</p>
<pre class="source-code">
        btm_left = Vector(btm_left)
        ob_center = btm_left.<code>lerp</code>(top_right, <code>0.5</code>)</pre>
<p>We add <code>ob_center</code> to <code>ob_translation</code> to center the lattice to the geometry:</p>
<pre class="source-code">
        Ob_translation += ob_center
        latt_obj.location = ob_translation</pre>
<p>Our lattice, centered <a id="_idIndexMarker730"/>and scaled, can now be used to deform the object. We can use it inside a new modifier and return <code>{'FINISHED'}</code> to exit the operator:</p>
<pre class="source-code">
        mod = ob.modifiers.new("Lattice", 'LATTICE')
        mod.object = latt_obj
        return {'FINISHED'}</pre>
<p>Now that the operator is finished, we can add a menu entry for using it.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor284"/>Adding a Create Lattice menu item</h2>
<p>We define <a id="_idIndexMarker731"/>a function to add <code>LatteExpress</code> to a menu. Using the <code>MOD_LATTICE</code>:</p>
<pre class="source-code">
def menu_func(self, context):
    self.layout.operator(LatteExpress.bl_idname,
                         icon=<code>"MOD_LATTICE"</code>)</pre>
<p>Of course, we need to register the new Blender class and function:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(LatteExpress)
    ob_menu = bpy.types.VIEW3D_MT_object_context_menu
    ob_menu.append(menu_func)
def unregister():
    ob_menu = bpy.types.VIEW3D_MT_object_context_menu
    ob_menu.remove(menu_func)
    bpy.utils.unregister_class(LatteExpress)</pre>
<p>We can refresh the add-on preferences and enable <strong class="bold">Latte Express</strong>.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor285"/>Using the Latte Express add-on</h2>
<p>Once we have <a id="_idIndexMarker732"/>set the <code>ch11</code> folder, we will be able to activate <strong class="bold">Latte Express</strong> in the <strong class="bold">Add-ons</strong> preferences.</p>
<div><div><img alt="Figure 11.9: Enabling the Latte Express add-on" height="333" src="img/Figure_11.09_B18375.jpg" width="991"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9: Enabling the Latte Express add-on</p>
<p>Our add-on makes the task of setting up a lattice deformation easier. Let’s see how the workflow from the previous section, <em class="italic">Deformation objects</em>, has improved:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File </strong>| <strong class="bold">New </strong>| <strong class="bold">General</strong>.</li>
<li>Delete the default <strong class="bold">Cube</strong> shape by pressing <strong class="bold">Canc</strong> or <strong class="bold">X</strong> | <strong class="bold">Delete</strong>.</li>
<li>Add a monkey head to the scene using <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Monkey</strong>.</li>
<li>Use the mouse right-click to open the object menu in the <strong class="bold">3D Viewport</strong>.</li>
<li>Select <strong class="bold">Create Lattice on </strong><strong class="bold">Active Object</strong>.</li>
</ol>
<p>A lattice is <a id="_idIndexMarker733"/>created, centered, and scaled on the active object, while a modifier is set up. Besides automating the task, using this add-on gives better accuracy, as the lattice is scaled according to the object’s exact dimensions.</p>
<p>In the next section, we will add more control over the geometry and lattice subdivision.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor286"/>Improving Latte Express options</h1>
<p>Some objects <a id="_idIndexMarker734"/>might not have enough polygons for the lattice deformation to work properly. We encountered a similar condition at the beginning of this chapter, in the <em class="italic">Understanding object modifiers</em> section, where we applied a <strong class="bold">Subdivision Surface</strong> modifier to our <strong class="bold">Cube</strong> shape before we could reshape it into a cylinder using a <strong class="bold">Cast</strong> modifier.</p>
<p>The resolution of lattice objects can also be increased to get more control over the deformation.</p>
<p>For those reasons, we <a id="_idIndexMarker735"/>will add object subdivision and lattice resolution options to our operator.</p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor287"/>Adding object subdivisions</h2>
<p>We add a subdivide <a id="_idIndexMarker736"/>option to <code>BoolProperty</code>. Since we will also set a <code>SUBSURF</code> modifier, we add <code>IntProperty</code> for the subdivision levels.</p>
<p>We add <code>bl_options = {'REGISTER', 'UNDO'}</code> to display the operator panel. The declaration of <strong class="bold">LatteExpress</strong> becomes as follows:</p>
<pre class="source-code">
class LatteExpress(bpy.types.Operator):
    """Set up Lattice Deformation"""
    bl_idname = "object.latte_expresso"
    bl_label = "Create Lattice on active object"
    bl_options = <code>{'REGISTER', 'UNDO'}</code>
    <code>add_subsurf</code>: bpy.props.BoolProperty(default=True)
    <code>subd_levels</code>: bpy.props.IntProperty(default=2)</pre>
<p>The <code>execute</code> method takes these options into account, creating a <code>SUBSURF</code> modifier if <code>add_subsurf</code> is <code>True</code>:</p>
<pre class="source-code">
    def execute(self, context):
        ob = context.object
        if self.add_subsurf:
            subdiv = ob.modifiers.new("Subdivision",
                                      "SUBSURF")
            subdiv.<code>levels</code> = self.subd_levels
            subdiv.<code>render_levels</code> = self.subd_levels
            subdiv.subdivision_type = "SIMPLE"</pre>
<p><strong class="bold">Subdivision Surface</strong> has an additional attribute for rendering subdivision levels. We have set both <a id="_idIndexMarker737"/>to the same value to make sure that the Viewport and the rendered images look the same.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor288"/>Changing lattice resolution</h2>
<p>Lattices don’t have <a id="_idIndexMarker738"/>polygons or subdivision modifiers, but they have resolution parameters to add more divisions along the three axes.</p>
<p>The <code>points_u</code>, <code>points_v</code>, and <code>points_w</code> attributes set the number of divisions across its <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes.</p>
<p>We add a property to influence the grid resolution. We use <code>IntVectorProperty</code> for those three attributes and set its subtype to <code>'XYZ'</code> so that they are displayed like coordinates. The minimum value for resolution coordinates is <code>1</code>, while we use <code>3</code> as default:</p>
<pre class="source-code">
    grid_levels: bpy.props.IntVectorProperty(
                                         default=(3, 3, 3),
                                         min=<code>1</code>,
                                         <code>subtype='XYZ'</code>
                                        )</pre>
<p>Because of the way the lattice is implemented, changing the resolution before creating the lattice object changes the starting dimensions of a lattice. To avoid that, we only set <code>points_u</code>, <code>points_v</code>, and <code>points_w</code> after <code>latt_obj</code> is created.</p>
<p>So, the lattice section becomes as follows:</p>
<pre class="source-code">
        latt_data = bpy.data.lattices.new(f"LAT-{ob.name}")
        latt_obj = bpy.data.objects.new(
                                      name=latt_data.name,
                                      object_data=latt_data
                                     )
        latt_data.<code>points_u</code> = self.grid_levels[<code>0</code>]
        latt_data.<code>points_v</code> = self.grid_levels[<code>1</code>]
        latt_data.<code>points_w</code> = self.grid_levels[<code>2</code>]</pre>
<p>Now that we are adding subdivisions, the lattice grid will present internal vertices, that is, control points <a id="_idIndexMarker739"/>that end up being inside the lattice. We don’t want that because we are using the lattice as an external cage.</p>
<p>So, we set <code>use_outside</code> of the lattice data to <code>True</code>:</p>
<pre class="source-code">
        latt_data.use_outside = False</pre>
<p>After that, the <code>execute</code> method continues as before, linking <code>latt_obj</code> to <code>context.collection.objects</code>, setting its location and scale, and creating the object modifiers before it returns <code>{'FINISHED'}</code>.</p>
<p>If we save the script and use <em class="italic">F3</em> -&gt; <strong class="bold">Reload Scripts</strong> and launch <strong class="bold">Create Lattice on Active Object</strong>, we’ll see the options for the lattice resolution.</p>
<div><div><img alt="Figure 11.10: A 5x3x3 lattice created with Latte Express" height="768" src="img/Figure_11.10_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10: A 5x3x3 lattice created with Latte Express</p>
<p>Lattice grids add quick deformations without requiring additional data in the deformed object. Deformers such as <strong class="bold">Armature</strong>, the modifier used for articulated characters, require the assignment of <strong class="bold">vertex groups</strong> to work properly.</p>
<h1 id="_idParaDest-274"><a id="_idTextAnchor289"/>Using armature deformers</h1>
<p>Armatures are deformation objects like lattices, but instead of using a grid, they rely on the translation, rotation, <a id="_idIndexMarker740"/>and scale of sub-objects called <strong class="bold">bones</strong>, in analogy with the <a id="_idIndexMarker741"/>human skeleton.</p>
<p>By default, bones are represented as octahedral sticks. Armatures can switch to <strong class="bold">Pose Mode</strong>, a special Blender mode in <a id="_idIndexMarker742"/>which bones can be animated individually using the techniques learned in <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>.</p>
<p>The setup of an <strong class="bold">Armature</strong> modifier might take some extra steps but is similar to the one used for lattices.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor290"/>Adding armature objects to the scene</h2>
<p>To acquire familiarity <a id="_idIndexMarker743"/>with the bones, we will create a simple armature for <strong class="bold">Suzanne</strong>’s geometry:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">General</strong>.</li>
<li>Delete the default <strong class="bold">Cube</strong> shape by pressing <strong class="bold">Canc</strong> or <strong class="bold">X</strong> | <strong class="bold">Delete</strong>.</li>
<li>Add a monkey head to the scene using <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Monkey</strong>.</li>
<li>Add an armature to the scene using <strong class="bold">Add</strong> | <strong class="bold">Armature</strong> | <strong class="bold">Single Bone</strong>.</li>
</ol>
<p>At this point, we should see the tip of an octahedral bone on top of <strong class="bold">Suzanne</strong>’s head. Since most of the bone is hidden inside the model, we can press the <em class="italic">Z</em> key and switch to the wireframe display.</p>
<div><div><img alt="Figure 11.11: An armature bone inside a geometry, with a wireframe display" height="768" src="img/Figure_11.11_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11: An armature bone inside a geometry, with a wireframe display</p>
<p>We could set <a id="_idIndexMarker744"/>up an <strong class="bold">Armature</strong> modifier right away, but armatures usually have more than one bone. For instance, we can add bones to the ears.</p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor291"/>Adding armature bones</h2>
<p>To have a better view while we <a id="_idIndexMarker745"/>create new bones, we can press the <em class="italic">1</em> key or use <strong class="bold">View</strong> | <strong class="bold">Viewpoint</strong> | <strong class="bold">Front</strong> from the top-bar menu, then we can press the <em class="italic">.</em> key, or <strong class="bold">View</strong> | <strong class="bold">Frame Selected</strong>, to center the view.</p>
<p>With the armature as the active object, we switch to <strong class="bold">Edit Mode</strong> by pressing <em class="italic">Tab</em> or using the drop-down box on the top left. Then, always in front view, we can add bone to the ears using the following steps:</p>
<ol>
<li>Add a new bone using the <em class="italic">Shift</em> + <em class="italic">A</em> combination or <strong class="bold">Add</strong> | <strong class="bold">Single Bone</strong> from the top-bar menu. The new bone is added on top of the existing one.</li>
<li>Click on the bones to select one of them.</li>
<li>Press <em class="italic">R</em>, then type <code>50</code>, and press <em class="italic">Enter</em> to rotate the bone toward the right-hand side of the screen.</li>
<li>Press <em class="italic">G</em>, then <em class="italic">X</em> to move it horizontally, and type <code>1</code>. Then, press <em class="italic">Enter</em> to move the bone toward Suzanne’s left ear.</li>
<li>Press <em class="italic">G</em>, then <em class="italic">Z</em> to move the bone vertically and type <code>0.2</code>. Then, press <em class="italic">Enter</em> to move the bone slightly downward.</li>
<li>Blender has a naming convention for left and right bones. To add the <code>.L</code> suffix to the left ear bone, we select <strong class="bold">Armature</strong> | <strong class="bold">Names</strong> | <strong class="bold">Auto-Name Left/Right</strong> from the top-bar menu.</li>
<li>To create a bone for the other ear, we select <strong class="bold">Armature</strong> | <strong class="bold">Symmetrize</strong> from the top-bar menu.</li>
</ol>
<p>The resulting armature <a id="_idIndexMarker746"/>should resemble a trident. The exact position of the bones is not important for the sake of this example.</p>
<div><div><img alt="Figure 11.12: Ear bones for Blender’s Suzanne" height="612" src="img/Figure_11.12_B18375.jpg" width="972"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12: Ear bones for Blender’s Suzanne</p>
<p>With three bones in place, we can go back to <strong class="bold">Object Mode</strong> by pressing <em class="italic">Tab</em> and go back to the <strong class="bold">Solid</strong> view by pressing <em class="italic">Z</em>. Now, we can bind our geometry to the armature.</p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor292"/>Binding objects to armatures</h2>
<p>As mentioned earlier, <strong class="bold">Armature</strong> deformers require additional information: each vertex should be <a id="_idIndexMarker747"/>assigned to one or more bones with a process called <strong class="bold">weight painting</strong>. It’s a <a id="_idIndexMarker748"/>manual task for riggers, but <a id="_idIndexMarker749"/>we can use Blender automatic weights for a quick result:</p>
<ol>
<li>In <strong class="bold">Object Mode</strong>, select the Suzanne object in <strong class="bold">3D Viewport</strong>, then keep the <em class="italic">Shift</em> key pressed and select the armature too.</li>
<li>Press <em class="italic">Ctrl</em> + <em class="italic">P</em> to open the <strong class="bold">Set Parent</strong> menu and pick <strong class="bold">With Automatic Weights</strong>. Or select <strong class="bold">Object</strong> | <strong class="bold">Parent</strong> | <strong class="bold">With Automatic Weights</strong> from the top-bar menu.</li>
</ol>
<p class="callout-heading">Beware the outliner</p>
<p class="callout">If you use <strong class="bold">Outliner</strong> for selecting objects, keep in mind that its policy is different:</p>
<ul>
<li class="callout">In <strong class="bold">Viewport</strong>, the last selected of multiple objects is the active object</li>
<li class="callout">In <strong class="bold">Outliner</strong>, the first selected of multiple objects is the active object</li>
</ul>
<p class="callout">To parent an object to an armature, we either select the object and then the armature in <strong class="bold">Viewport</strong>, or first the armature and then the object in <strong class="bold">Outliner</strong>.</p>
<p>Now we can deform our <a id="_idIndexMarker750"/>mesh by posing the armature <a id="_idIndexMarker751"/>bones:</p>
<ol>
<li>Select <strong class="bold">Armature</strong> and press <em class="italic">Ctrl</em> + <em class="italic">Tab</em>, or use the drop-down box on the top left of the screen and switch to <strong class="bold">Pose Mode</strong>.</li>
<li>Select any bone, then move, rotate, or scale it by using the <em class="italic">G</em>, <em class="italic">R</em>, and <em class="italic">S</em> keys.</li>
</ol>
<div><div><img alt="Figure 11.13: Armature deformation in Blender" height="768" src="img/Figure_11.13_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13: Armature deformation in Blender</p>
<p>Bones are a soft, controllable <a id="_idIndexMarker752"/>way to deform a model. Lattice grids can be <a id="_idIndexMarker753"/>deformed with armatures too, so we can create and set up an armature in <strong class="bold">Latte Express</strong>.</p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor293"/>Scripting a lattice armature</h1>
<p>Armatures are the recommended <a id="_idIndexMarker754"/>way for animating in Blender as they support linking across different <code>.blend</code> files and other advanced animation features.</p>
<p>Binding a lattice to an armature allows you to animate deformations without switching to <strong class="bold">Edit Mode</strong> to edit grid vertices.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor294"/>Adding an armature condition</h2>
<p>We want armatures <a id="_idIndexMarker755"/>to be an optional feature, so we can add another property for that. We set its default value to <code>True</code>, so an armature is created unless it’s set otherwise:</p>
<pre class="source-code">
    add_armature: bpy.props.BoolProperty(default=True)</pre>
<p>Inside the <code>execute</code> method, we check for this value and proceed accordingly.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor295"/>Adding an armature to the scene</h2>
<p>Armatures are <a id="_idIndexMarker756"/>created in the same way as lattices and other objects:</p>
<ol>
<li>Create new data.</li>
<li>Create a new object using the data created.</li>
</ol>
<p>Even if it is not strictly required, we set the new armature as the parent of the lattice to ensure consistency between their transforms.</p>
<p>If <code>add_armature</code> is <code>False</code>, we set the lattice location right away. Otherwise, we create a new armature. The underlying code takes over soon after we’ve got the object median point:</p>
<pre class="source-code">
        # …
        ob_translation = ob.matrix_world.to_translation()
        ob_translation += ob_center
        if <code>not self.add_armature</code>:
            <code>latt_obj.location = ob_translation</code>
        <code>else</code>:
            <code>arm_data</code> = bpy.data.<code>armatures.new</code>(
                                           f"ARM-{ob.name}"
                                          )
            arm_obj = bpy.data.objects.new(
                                       name=arm_data.name,
                                       <code>object_data=arm_data</code>
                                      )
            context.collection.objects.link(arm_obj)</pre>
<p>Once the armature is part of the scene, we can parent the lattice to it and move it to where the object is:</p>
<pre class="source-code">
            latt_obj.parent = arm_obj
            arm_obj.location = ob_translation</pre>
<p>It’s common to have the armature’s transform pivot under the affected geometry, so when an armature <a id="_idIndexMarker757"/>is at its resting position, the deformed character will be above ground level. Therefore, we move the armature to half the object height below the center, using the third coordinate of <code>dimensions</code>:</p>
<pre class="source-code">
            half_height = ob.<code>dimensions[2]/2</code>
            arm_obj.location[2] <code>-= half_height</code></pre>
<p>The lattice, on the other hand, should be centered on the geometry, so we bring it up by the same amount:</p>
<pre class="source-code">
            latt_obj.location[2] += half_height</pre>
<p>Now that the armature <a id="_idIndexMarker758"/>and lattice are placed, we need to create some bones.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor296"/>Creating edit bones</h2>
<p>To create the <a id="_idIndexMarker759"/>bones manually, we select the armature and switch to <strong class="bold">Edit Mode</strong>. In Python, the same steps are performed with the following:</p>
<pre class="source-code">
            context.view_layer.objects.<code>active</code> = <code>arm_obj</code>
            bpy.ops.object.<code>mode_set</code>(mode=<code>'EDIT'</code>,
                                    toggle=False)</pre>
<p>We pass <code>False</code> to the <code>toggle</code> argument of <code>mode_set</code>, because we are not switching back and forth between modes.</p>
<p>We will add as many bones as the lattice vertical sections. For instance, a lattice with a vertical resolution of <code>3</code> can be rigged with three bones.</p>
<div><div><img alt="Figure 11.14: Rigging a lattice with armature bones" height="768" src="img/Figure_11.14_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14: Rigging a lattice with armature bones</p>
<p>We get the number of levels from the <code>grid_levels</code> property. Each bone starts from the lower section and stops at the next. The last bone pops outside the lattice.</p>
<p>To get the optimal length, we divide the object height by the number of internal bones, i.e., one bone less than <code>grid_levels</code>:</p>
<pre class="source-code">
            grid_levels = self.grid_levels[2]
            height = ob.dimensions[2]
            bone_length = height / (grid_levels – 1)</pre>
<p>We use a <code>for</code> loop to add an <code>range</code> function. We add a two-digit suffix to each bone name:</p>
<pre class="source-code">
            for i in <code>range</code>(grid_levels):
                eb = arm_data.edit_bones.new(f"LAT_<code>{i:02}</code>")</pre>
<p>Each bone has a start point (<code>head</code>) and an endpoint (<code>tail</code>). Since the armature’s origin matches the first section of the lattice, the first bone has the coordinates <code>0, </code><code>0, 0</code>.</p>
<p>The second bone <a id="_idIndexMarker760"/>should have a higher position to make room for the previous bone length, and so on, so the expression for each bone head is as follows:</p>
<pre class="source-code">
                eb.<code>head</code> = (0, 0, <code>i * bone_length</code>)</pre>
<p>The <code>tail</code> part of the bone adds one <code>bone_length</code> to the <code>head[2]</code> coordinate:</p>
<pre class="source-code">
                eb.<code>tail</code> = (0, 0, <code>eb.head[2] + bone_length</code>)</pre>
<p>To assign the lattice vertices to the bones, we must collect which vertices belong to the current level based on their <code>Z</code> coordinate.</p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor297"/>Assigning vertices to bones</h2>
<p>For each lattice <a id="_idIndexMarker761"/>point, we compare the third coordinate (<code>co[2]</code>) with <a id="_idIndexMarker762"/>the relative height of the current section. <em class="italic">Relative</em> means that the first section is at a height of <code>0.0</code>, the last is at <code>1.0</code>, the one in the middle is at <code>0.5</code>, and so on.</p>
<p>Python indices start from <code>0</code>, so the index of the last section is the number of sections minus <code>1</code>. Keeping that in mind, here’s how we can get the relative height of each level:</p>
<pre class="source-code">
                rel_height = i / (grid_levels–- 1)</pre>
<p>Lattice points are relative to the center, and the size of one side of the lattice is <code>1.0</code>, so the vertical coordinate of the lowest point is <code>-0.5</code>. For that reason, we lower <code>rel_height</code> by <code>0.5</code> units:</p>
<pre class="source-code">
                rel_height -= 0.5</pre>
<p>To assign vertices, we need a list of their indices, which we store in the <code>vert_ids</code> list:</p>
<pre class="source-code">
                vert_ids = []</pre>
<p>In this list, we need to store the identifier number of the lattice points, not their coordinates.</p>
<p>The lattice data points are an ordered collection, so their identifier is their ordinal index; that is, the first point is identified by index <code>1</code>, the second point has index <code>2</code>, and so on.</p>
<p>In Python, we can get the ordinal of the iterated items using <code>enumerate</code>:</p>
<pre class="source-code">
                for <code>id</code>, <code>v</code> in <code>enumerate</code>(latt_data.<code>points</code>):
                    if <code>v.co[2] == rel_height</code>:
                        vert_ids.append(id)</pre>
<p>We can create a <a id="_idIndexMarker763"/>vertex group named after each bone and <a id="_idIndexMarker764"/>assign vertices using the <code>add</code> method. We also supply a weight of <code>1.0</code>, because we are not blending the assignment between two groups, and set <code>'REPLACE'</code> as a condition, because we are not adding nor subtracting from a previous assignment:</p>
<pre class="source-code">
                vg = latt_obj.vertex_groups.<code>new</code>(
                                               name=<code>eb.name</code>
                                              )
                vg.add(<code>vert_ids</code>, <code>1.0</code>,'REPLACE')</pre>
<p>Creating the bones and assigning their influence is the hard part of the process. Now we can create the modifiers.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor298"/>Creating the Armature modifier</h2>
<p>We add <a id="_idIndexMarker765"/>a new Armature modifier to <code>latt_obj</code> via the <code>modifiers.new</code> method, and we use <code>arm_obj</code> as its deformer object:</p>
<pre class="source-code">
            arm_mod = <code>latt_obj</code>.modifiers.new("Armature",
                                            <code>"ARMATURE"</code>)
            arm_mod.object = arm_obj</pre>
<p>Finally, we leave <code>'POSE'</code>, so that the user can animate:</p>
<pre class="source-code">
            bpy.ops.object.mode_set(mode='POSE',
                                    toggle=False)</pre>
<p>At this point, <code>LattExpress</code> creates a lattice deformer and animation bones in one click. As an optional <a id="_idIndexMarker766"/>step, we can create custom shapes for displaying the bones.</p>
<h1 id="_idParaDest-284"><a id="_idTextAnchor299"/>Adding custom bone shapes</h1>
<p>Armature bones are effective deformers, but we have experienced a major drawback for ourselves <a id="_idIndexMarker767"/>in the <em class="italic">Using armature deformers</em> section: bones tend to be hidden by the deformed geometry.</p>
<p>There are a few workarounds, such as activating the <strong class="bold">In Front</strong> attribute in the <strong class="bold">Armature</strong> properties and using <strong class="bold">X-Ray</strong> or <strong class="bold">Wireframe</strong> views.</p>
<p>Another gimmick consists in displaying special widgets by assigning mesh objects to the bone’s <strong class="bold">Custom </strong><strong class="bold">Shape</strong> attribute.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor300"/>Creating mesh objects in Python</h2>
<p>First, we <a id="_idIndexMarker768"/>must create a new mesh. A mesh <a id="_idIndexMarker769"/>consists of vertex coordinates, plus <a id="_idIndexMarker770"/>edges or faces that connect vertices.</p>
<div><div><img alt="Figure 11.15: Vertex coordinates of a 2D square" height="449" src="img/Figure_11.15_B18375.jpg" width="449"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15: Vertex coordinates of a 2D square</p>
<p>In this example, we create a wireframe square and use it as a bone widget. Blender bones expand upon their <code>Y</code> axis, so the horizontal coordinates of our bones that are placed vertically are <code>X</code> and <code>Z</code>.</p>
<p>We build our <a id="_idIndexMarker771"/>list of vertices. We <a id="_idIndexMarker772"/>aim for a side length of <code>1.0</code>, a measure easy to <a id="_idIndexMarker773"/>scale. For that reason, each side will go from a <code>-0.5</code> to a <code>0.5</code> coordinate, or the other way around. If <code>X</code> and <code>Z</code> are the first and last coordinates, this is our vertex list:</p>
<pre class="source-code">
            v_cos = [
                [-0.5, 0.0, -0.5],
                [-0.5, 0.0, 0.5],
                [0.5, 0.0, 0.5],
                [0.5, 0.0, -0.5]
            ]</pre>
<p>Next, we need a list of edges. An edge is a pair of vertex indices, each representing the two vertices that are going to connect. The four edges of a square connect vertex <code>0</code> to <code>1</code>, <code>1</code> to <code>2</code>, vertex <code>2</code> to <code>3</code>, and <code>3</code> to <code>0</code>:</p>
<pre class="source-code">
            edges = [
                [0, 1], [1, 2], [2, 3], [3, 0]
            ]</pre>
<p>We can create new mesh data from Python lists using the <code>from_pydata</code> method. Since we don’t need faces in a control widget, the third argument is an empty list:</p>
<pre class="source-code">
            mesh = bpy.data.meshes.new("WDG-square")
            <code>mesh.from_pydata(coords, edges, [])</code></pre>
<p>We add the mesh to the scene:</p>
<pre class="source-code">
            wdg_obj = bpy.data.objects.new(mesh.name, mesh)
            context.collection.objects.link(wdg_obj)</pre>
<p>Now, we can assign the widget shape to the <strong class="bold">pose bones</strong> of our armature:</p>
<pre class="source-code">
            for pb in arm_obj.<code>pose.bones</code>:
                pb.<code>custom_shape = wdg_obj</code></pre>
<p>With a side <a id="_idIndexMarker774"/>length of <code>1.0</code>, our widget could <a id="_idIndexMarker775"/>be hidden as well, so we scale it to match <a id="_idIndexMarker776"/>the <code>dimensions</code> object.</p>
<p>Keeping in mind that a bone’s up direction is the <code>Y</code> axis, but Blender’s up direction is <code>Z</code>, we set the <code>Z</code> custom shape scale to the <code>Y</code> dimension:</p>
<pre class="source-code">
                pb_scale = pb.<code>custom_shape_scale_xyz</code>
                pb_scale[0] = ob.dimensions[0]
                pb_scale[<code>2</code>] = ob.dimensions[<code>1</code>]</pre>
<p>Blender scales the displayed custom shape by the length of the bone, so we divide the scale by the bone length:</p>
<pre class="source-code">
                pb_scale[0] /= bone_length
                pb_scale[2] /= bone_length</pre>
<p>The armature created in our script is ready. We will tidy the scene and exit the operator.</p>
<p class="callout-heading">Storing bones is bad for your variables!</p>
<p class="callout">Armature bones are represented by different Python entities depending on the current mode. When the armature is in <code>EditBone</code> from the armature data <code>edit_bones</code> collection is used. When the armature is in <code>PoseBone</code> from the <code>pose.bones</code> object <code>is</code> used.</p>
<p class="callout">These collections are rebuilt every time the armature is updated, storing them in variables while they are changed can cause crashes.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor301"/>Finalizing the setup</h2>
<p>If an armature <a id="_idIndexMarker777"/>is created, we hide the widget mesh and the lattice:</p>
<pre class="source-code">
            wdg.hide_set(True)
            latt_obj.hide_set(True)</pre>
<p>The last steps of <code>execute</code> are the same as before: we create a lattice modifier for the deformed object, unselect the geometry, and finish:</p>
<pre class="source-code">
        mod = ob.modifiers.new("Lattice", "LATTICE")
        mod.object = latt_obj
        ob.select_set(False)
        return {'FINISHED'}</pre>
<p>Reloading the scripts and launching <strong class="bold">Create Lattice on Active Object</strong> will create a full animation setup complete with armature and bone shapes.</p>
<div><div><img alt="Figure 11.16: Suzanne deformed via animation controls" height="640" src="img/Figure_11.16_B18375.jpg" width="640"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16: Suzanne deformed via animation controls</p>
<p>This add-on can still be <a id="_idIndexMarker778"/>improved. For instance, we could build oval shapes for our animation controls or tidy the <code>execute</code> method by moving some of the code to specific functions, but since it satisfies its initial purpose, we can consider it finished.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor302"/>Summary</h1>
<p>We have learned how to alter objects using modifiers and how to bind modifiers to animate objects. We have also gained a deeper understanding of how object data works and how objects of different types are created, linked to the scene, and integrated.</p>
<p>Using this knowledge, we have coded a production tool that can be used to deform any object.</p>
<p>In the next and final chapter of this book, <a href="B18375_12.xhtml#_idTextAnchor304"><em class="italic">Chapter 12</em></a>, we will explore the last step of a 3D pipeline.</p>
<h1 id="_idParaDest-288"><a id="_idTextAnchor303"/>Questions</h1>
<ol>
<li>Do modifiers alter the object’s data?</li>
<li>How do we add modifiers to an object?</li>
<li>Do modifiers rely on other objects besides the ones they deform?</li>
<li>True or false: We can change the resolution of lattice data before or after we create its lattice object with no consequences.</li>
<li>How do we add bones to an armature in Python?</li>
<li>True or false: There is only one bone collection property.</li>
<li>True or false: Only objects of type mesh can be deformed by armatures.</li>
<li>Blender has modes. Does the current mode have consequences on whether we can add or remove data in our script?</li>
<li>How do we create a mesh using Python?</li>
</ol>
</div>
</div></body></html>