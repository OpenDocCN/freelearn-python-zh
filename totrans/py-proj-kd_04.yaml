- en: Chapter 4. Making Decisions – Python Control Flows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。做出决定 – Python控制流
- en: Congratulations! In [Chapter 3](ch03.html "Chapter 3. Calculate This!"), *Calculate
    This!*, you wrote a calculator program. If you followed the instructions and corrected
    your errors, then you have a program that runs all of the mathematical functions
    with two numbers. While this is great for a first program, that sort of a limited
    calculator doesn't give a user much choice. When the user runs the calculator,
    the program will not end until all five functions have run or until the program
    ends due to an error.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在[第3章](ch03.html "第3章。计算这个！")“计算这个！”中，你编写了一个计算器程序。如果你遵循了指示并纠正了错误，那么你就有了一个可以运行两个数字的所有数学函数的程序。虽然这对第一个程序来说很棒，但这样的有限计算器不会给用户太多选择。当用户运行计算器时，程序将不会结束，直到所有五个函数都运行完毕，或者由于错误而结束程序。
- en: What if, instead of doing the entire math, we could program our calculator to
    perform certain operations based on the way the users answer our questions? As
    programmers, we can use Python to interpret user data and change the way the program
    operates. In this chapter, you will learn how to use *control flows* so that our
    calculator program can make choices and only run the code that the user chooses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够编程我们的计算器根据用户回答我们的问题的方式执行某些操作，而不是执行整个数学运算，那会怎么样？作为程序员，我们可以使用Python来解释用户数据并改变程序的操作方式。在本章中，你将学习如何使用*控制流*，以便我们的计算器程序可以做出选择，并且只运行用户选择的代码。
- en: At the end of this chapter, you will have a calculator program that can choose
    which mathematical operations to perform based on what the user wants to do. You
    will be able to customize this program on the basis of how you use the control
    flows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将有一个可以根据用户想要做什么来选择执行哪种数学运算的计算器程序。你将能够根据你如何使用控制流来定制这个程序。
- en: Is it equal, not equal, or something else?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是等于、不等于，还是其他什么？
- en: 'Before you learn about conditional statements, you need to realize that computers
    make decisions based on **comparison operators**. These help us compare two things
    so that the computer can make a decision about what to do next. Here is a list
    of operators:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习条件语句之前，你需要意识到计算机是根据**比较运算符**做出决定的。这些帮助我们比较两件事，以便计算机可以决定接下来做什么。以下是一个运算符列表：
- en: '| Comparison Operators |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 比较运算符 |'
- en: '| --- |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Less than | < |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 小于 | < |'
- en: '| Less than or equal to | <= |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 小于或等于 | <= |'
- en: '| Greater than | > |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 大于 | > |'
- en: '| Greater than or equal to | >= |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 大于或等于 | >= |'
- en: '| Equal to | == |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 等于 | == |'
- en: '| Not equal to | != |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 不等于 | != |'
- en: Each of these operators allows us to compare two values. The most confusing
    operator is the equal to operator because it uses two equals signs. The reason
    for this is that when we set a variable, we use one equal sign. We do not want
    the computer to get confused when we are comparing two values, so we use two equals
    signs. When we use the comparison operators with `if`, `elif`, and `else`, our
    program can be written to make better decisions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符中的每一个都允许我们比较两个值。最令人困惑的运算符是等于运算符，因为它使用了两个等号。之所以这样，是因为当我们设置变量时，我们使用一个等号。我们不希望计算机在我们比较两个值时感到困惑，所以我们使用两个等号。当我们使用比较运算符与`if`、`elif`和`else`一起使用时，我们的程序可以编写得更好，以便做出更好的决策。
- en: 'To take a look at how these operators work in real life, open up your Python
    shell and type the following lines of code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这些运算符在实际生活中的工作方式，打开你的Python壳并输入以下代码行：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After each line of code, the words `True` or `False` will print. Take a look
    at the following screenshot for answers to how the statements evaluate using the
    number `1`. Experiment with other numbers to take a look at what happens and to
    learn about the operators and what they do:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行代码之后，将打印出“True”或“False”。请查看以下截图，了解如何使用数字`1`评估这些语句。尝试使用其他数字，看看会发生什么，并了解运算符及其功能：
- en: '![Is it equal, not equal, or something else?](img/B04681_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![它是等于、不等于，还是其他什么？](img/B04681_04_01.jpg)'
- en: Conditional statements – if, elif, else
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句 – if，elif，else
- en: 'There are three language constructs that are used frequently in Python to control
    the outcome of a program. These constructs are `if`, `elif`, and `else`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有三种语言结构经常用于控制程序的结果。这些结构是`if`、`elif`和`else`：
- en: The `if` statement tells the program that *if the user does this, then execute
    this part of the program*.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句告诉程序“如果用户这样做，则执行程序的这个部分”。'
- en: 'The `else` statement is used to catch anything that the user does and is not
    in the program. For example, you can use `if` and `else` together: *if the user
    chooses* `add`*, do addition, else do another action.*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 语句用于捕获用户所做的任何不在程序中的操作。例如，你可以将 `if` 和 `else` 结合使用：*如果用户选择* `add`*，则执行加法，否则执行其他操作*。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `elif` stands for *else if*, which means that *if the first thing does not
    happen, then do the next thing in the list of possibilities until the user choice
    matches the possibility*.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`elif` 代表 *else if*，这意味着 *如果第一个条件不成立，那么就在可能性的列表中执行下一个操作，直到用户的选项与可能性匹配*。'
- en: '`elif` is used when you want to give the program more than two choices. You
    can use `elif` as many times as you like.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elif` 用于当你想给程序提供超过两个选择时。你可以根据需要多次使用 `elif`。'
- en: '`else` is a signal of the end of the possible choices to your computer program.
    The `else` means that *if none of the other things have taken place in your program,
    OR if the user has done something unexpected, then end this block of code*. `else`
    statements are always at the end of a block of code that begins with `if`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else` 是向你的计算机程序发出结束可能选择信号的标志。`else` 的意思是 *如果程序中没有发生其他事情，或者如果用户做了意外的事情，那么结束这段代码块*。`else`
    语句始终位于以 `if` 开头的代码块末尾。'
- en: In the next section, you can take a look at how `if`, `elif`, and `else` are
    used. Then, you will experiment with your calculator code, and add some of these
    statements to make your calculator more flexible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你可以查看 `if`、`elif` 和 `else` 的使用方法。然后，你可以通过实验你的计算器代码，并添加一些这些语句来使你的计算器更加灵活。
- en: Getting better input
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取更好的输入
- en: In order for `if`, `elif`, and `else` to work, we will need to get better user
    input. For this to happen, we need to ask better questions! You will see in each
    example of `if`, `elif`, and `else` that we will be adding more `raw_input()`
    statements to get further information from the user. Then, we will put that information
    to work using the `if`, `elif`, and `else` statements so that our calculator program
    is more responsive to the user's needs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `if`、`elif` 和 `else` 能够工作，我们需要获取更好的用户输入。为了实现这一点，我们需要提出更好的问题！你将在每个 `if`、`elif`
    和 `else` 的示例中看到，我们将添加更多的 `raw_input()` 语句来获取用户更多的信息。然后，我们将使用 `if`、`elif` 和 `else`
    语句来使用这些信息，使我们的计算器程序更能满足用户的需求。
- en: 'To practice asking better questions, let''s open our Python shell and practice
    writing the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习提出更好的问题，让我们打开我们的 Python 壳，并练习编写以下代码：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, we are now asking the user to choose what operation they want to execute
    by typing the name of the operation as the answer to the question. When our program
    runs, it will ask the user this question. How will our program know what to do
    with the answer?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在要求用户通过将操作名称作为问题的答案来选择他们想要执行的操作。当我们的程序运行时，它会询问用户这个问题。我们的程序将如何知道如何处理这个答案？
- en: if
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if
- en: 'The `if` statement tells the program to do something special if the user makes
    a choice. To better understand this, let''s use this sample question and ask the
    user what operation they would like the calculator to do:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句告诉程序，如果用户做出选择，则执行一些特殊操作。为了更好地理解这一点，让我们使用这个示例问题并询问用户他们希望计算器执行什么操作：'
- en: '![if](img/B04681_04_10_replace.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![if](img/B04681_04_10_replace.jpg)'
- en: For the purposes of practicing, let's imagine that our user types *addition*
    as their answer. Right now, our program does not know or care that the user wants
    to do addition. Our program has no way to do anything with that answer! We need
    to use the `if` statement to tell our program what to do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习的目的，让我们假设用户输入 *addition* 作为他们的答案。目前，我们的程序不知道或关心用户想要做加法。我们的程序无法对那个答案做出任何反应！我们需要使用
    `if` 语句来告诉我们的程序该做什么。
- en: So, we will now create a special function, and we will tell the computer what
    to do with this new information from the user. To do this, we will use our text
    editor to add new code and our command prompt to run the code once we have saved
    the code. As a reminder, the working directory of your command prompt should be
    set to your project's folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将创建一个特殊函数，并将我们告诉计算机如何处理用户的新信息。为此，我们将使用我们的文本编辑器添加新代码，并在保存代码后使用命令提示符来运行代码。提醒一下，你的命令提示符的工作目录应该设置为你的项目文件夹。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to [Chapter 1](ch01.html "Chapter 1. Welcome! Let's Get Started"),
    *Welcome! Let's Get Started*, in case you've forgotten how to find your working
    directory.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了如何找到你的工作目录，可以参考[第1章](ch01.html "第1章。欢迎！让我们开始吧")，*欢迎！让我们开始吧*。
- en: 'Once you have opened your calculator program in your text editor, add this
    function to the program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在文本编辑器中打开了你的计算器程序，将此函数添加到程序中：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, call your new `calc_run()` function by adding this line to the end of
    your program file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过在程序文件末尾添加这一行来调用你的新 `calc_run()` 函数：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you will erase the calls you made to your addition, subtraction, multiplication,
    and division functions throughout the program because we do not need them all
    the time. We want them to happen only when the user makes the choice.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将擦除你在整个程序中对加法、减法、乘法和除法函数的调用，因为我们并不总是需要它们。我们希望它们只在用户做出选择时发生。
- en: In the `calc_run()` function that we are creating now, we tell the calculator
    to ask a question. Once the user answers the question, the computer will check
    whether the answer is equal to addition. If it is, then the computer will run
    the addition function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现在创建的 `calc_run()` 函数中，我们告诉计算器提出一个问题。一旦用户回答了问题，计算机将检查答案是否等于加法。如果是，那么计算机将运行加法函数。
- en: elif
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: elif
- en: The `elif` statement lets us give the user many choices, which is much more
    logical for a user who might want to choose from the addition, subtraction, multiplication,
    and division functions. Using `elif` allows us to give the user the choice between
    many operations. There is no limit to how many times you can write the `elif`
    statement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif` 语句让我们可以为用户提供许多选择，这对于可能想要从加法、减法、乘法和除法函数中选择用户来说更加合理。使用 `elif` 允许我们给用户提供在多个操作之间的选择。你可以写多少次
    `elif` 语句没有限制。'
- en: 'If you wanted to create a response to 100 different kinds of information, you
    could write 100 `elif` statements. However, this is really tedious, so we won''t
    do it. You can take a look at some of the changes made in the following code,
    which will show how you can use `elif` to give the user choices for each mathematical
    operation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为100种不同的信息创建响应，你可以写100个 `elif` 语句。然而，这真的很繁琐，所以我们不会这样做。你可以看看以下代码中的一些更改，这将展示你如何使用
    `elif` 为每个数学运算提供用户选择：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will notice that we used four `elif` statements. Each `elif` matched the
    response that we wanted. Now, we will test our program. Hopefully, you have saved
    your work in your text editor. Always remember to save as often as you can!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们使用了四个 `elif` 语句。每个 `elif` 都匹配我们想要的响应。现在，我们将测试我们的程序。希望你在文本编辑器中保存了你的工作。始终记得尽可能经常保存！
- en: '![elif](img/B04681_04_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![elif](img/B04681_04_03.jpg)'
- en: 'Try running your program by following these steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试运行你的程序：
- en: Open your command prompt or terminal.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的命令提示符或终端。
- en: Navigate to your project folder.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的项目文件夹。
- en: Type `python` `first_calc.py`.![elif](img/B04681_04_04.jpg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `python first_calc.py`。![elif](img/B04681_04_04.jpg)
- en: else
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: else
- en: '`else` is a way to manage all the other things that a user might do that we
    cannot predict. When the user enters something to trigger `else`, we can return
    a message to them, or we can even end the program. Your program does not *NEED*
    to use an `else` statement; however, it is nice to make the choices that you want
    for your users, and make them as clear as possible. In the following example,
    we will print a message to the user if they do *NOT* choose add, subtract, multiply,
    divide, or modulo:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 是一种管理用户可能执行的所有其他我们无法预测的行为的方式。当用户输入某些内容以触发 `else` 时，我们可以向他们返回一条消息，甚至可以结束程序。你的程序**不需要**使用
    `else` 语句；然而，为你的用户提供你想要的选项，并尽可能使它们清晰是很不错的。在下面的示例中，如果用户没有选择加、减、乘、除或取模，我们将向用户打印一条消息：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![else](img/B04681_04_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![else](img/B04681_04_05.jpg)'
- en: Now, when you run the code, if you type an answer that is not addition, subtraction,
    multiplication, or division, your program should print `Thank you. Goodbye`. Test
    your program to check whether your `else` statement works!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行代码时，如果你输入的答案不是加法、减法、乘法或除法，你的程序应该打印 `Thank you. Goodbye`。测试你的程序以检查你的 `else`
    语句是否工作！
- en: '![else](img/B04681_04_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![else](img/B04681_04_06.jpg)'
- en: Loops
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: '**Loops** are a kind of control flow, but they rerun the same block of code
    over and over again until something else tells the loop to stop repeating itself.
    This is a bit different from conditional statements since these only run the block
    of code once. The two kinds of loop are `while` and `for`. Both types of loop
    are really useful.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**是一种控制流，但它们会反复运行相同的代码块，直到有其他东西告诉循环停止重复。这与条件语句有点不同，因为它们只会运行一次代码块。两种循环类型是
    `while` 和 `for`。这两种类型的循环都非常有用。'
- en: while
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while
- en: '**while** is one kind of loop. When we make a `while` loop, the program repeats
    itself until a given block of code happens. When programming a `while` loop, we
    need to create some rules, or our program will run forever.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**while** 是一种循环。当我们创建一个 `while` 循环时，程序会重复执行，直到发生一个给定的代码块。在编程 `while` 循环时，我们需要创建一些规则，否则我们的程序将永远运行。'
- en: 'For example, we can make this rule: when the calculator is on, perform the
    following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以制定以下规则：当计算器开启时，执行以下步骤：
- en: Run the calculator.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行计算器。
- en: Prompt the user to keep calculating.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户继续计算。
- en: When the user hits the `else` statement, turn the calculator off.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户遇到 `else` 语句时，关闭计算器。
- en: Let's go through each of the code changes step by step; you will need these
    changes in order to make the `while` loop work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地通过每个代码更改；您需要这些更改才能使 `while` 循环工作。
- en: Global variables and the quit() function
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量和 `quit()` 函数
- en: We will create a global variable to use in our `quit()` function. Using the
    variable in this way will allow us to let the `quit ()` function act like an `off`
    switch, thus stopping our `calc_run()` function from running. In the next section,
    we will write our global variable, and then we will create our `quit()` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个全局变量，用于我们的 `quit()` 函数。以这种方式使用变量将允许我们让 `quit()` 函数像一个“关闭”开关一样工作，从而停止
    `calc_run()` 函数的运行。在下一节中，我们将编写我们的全局变量，然后创建我们的 `quit()` 函数。
- en: 'First, we will make a global variable called `calc_on`. This is one way for
    us to make an `on` button for our computer calculator. This global variable should
    be typed at the top of the code file with the *NO* indentation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个全局变量，名为 `calc_on`。这是我们为计算机计算器创建一个“开启”按钮的方法之一。这个全局变量应该在代码文件顶部编写，不要缩进，写为
    *NO*：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Global variables can be used in any function we want throughout the program.
    If you want to use a global variable in a function, you can type `global` next
    to the name of the variable inside of the function. You will be shown an example
    of this later on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量可以在程序中的任何函数中使用。如果您想在函数中使用全局变量，可以在函数内部变量的名称旁边输入 `global`。稍后您将看到一个示例。
- en: 'Now that we have an *on button* global variable that can be used anywhere in
    our code, we will create the pieces needed for our `while` loop. We need to add
    a way for our program to keep repeating itself so that the user can keep doing
    calculations without restarting the program for each calculation. Also, we need
    to add a way for the user to quit the program. We are going to work backward and
    make the `quit()` function first:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个可以在代码的任何地方使用的 *开启按钮* 全局变量，我们将创建 `while` 循环所需的组件。我们需要添加一种让程序不断重复的方法，这样用户就可以在每次计算时无需重新启动程序。此外，我们还需要添加一种让用户退出程序的方法。我们将从后往前工作，首先创建
    `quit()` 函数：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We just wrote the code for our `quit()` function. The first line uses our `calc_on`
    global variable. The second line changes the value of `calc_on` to `0`. By changing
    the value from `1` to `0`, we are telling the program to turn the calculator off
    and stop running the code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了 `quit()` 函数的代码。第一行使用了我们的 `calc_on` 全局变量。第二行将 `calc_on` 的值更改为 `0`。通过将值从
    `1` 更改为 `0`，我们告诉程序关闭计算器并停止运行代码。
- en: Using the quit() function
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `quit()` 函数
- en: 'In our code, we are going to change our `else` statement so that it runs the
    `quit()` function instead of printing a message. Take a look at this code sample
    to understand the changes we make to else:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将更改 `else` 语句，使其运行 `quit()` 函数而不是打印一条消息。请看以下代码示例，以了解我们对 `else` 的更改：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have made the `on` button, `calc_on`, the `off` button, and `quit()`,
    we can add the `quit` choice to our program. In the line of code where we get
    information from the user, we will add the word `quit` as a choice:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了“开启”按钮 `calc_on`、“关闭”按钮和 `quit()`，我们可以将“退出”选项添加到我们的程序中。在获取用户信息的代码行中，我们将添加单词
    `quit` 作为选项：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using the while loop to control the program
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `while` 循环控制程序
- en: 'Quitting is one choice that the user can make by simply typing `quit`. However,
    we want to allow the user to keep the program running if they wish to. To do this,
    we will use a `while` loop. At the bottom of the code, we will simply write this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 退出是用户可以通过简单地输入 `quit` 来做出的一个选择。然而，我们希望允许用户在需要时保持程序运行。为此，我们将使用一个 `while` 循环。在代码底部，我们将简单地写下：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `while` loop is says that *while the on button is on, run the* `calc_run()`
    *function. If someone does something to change* `calc_on` *to a value that is
    not* `1`*, then stop running the* `calc_run()` *program.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环表示*只要开关键处于开启状态，就运行* `calc_run()` *函数。如果有人做了改变，将* `calc_on` *的值改为不是*
    `1` *的值，那么停止运行* `calc_run()` *程序。'
- en: 'Hopefully, you noticed that our `quit()` function changes the value of `calc_on`
    to `0`, which means that our program stops running. `while` loops are very useful
    for running run parts of a program, and they can use simple variables to start
    or stop the loops, which is similar to what we did with this calculator:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能注意到我们的 `quit()` 函数将 `calc_on` 的值改为 `0`，这意味着我们的程序停止运行。`while` 循环对于运行程序的一部分非常有用，并且可以使用简单的变量来开始或停止循环，这与我们在计算器中做的类似：
- en: '![Using the while loop to control the program](img/B04681_04_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![使用 while 循环控制程序](img/B04681_04_07.jpg)'
- en: for
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for
- en: The `for` loop is another kind of loop. We will use the `for` loop to make a
    bonus function for our calculator. The biggest difference between `for` and `while`
    is that the `for` loop is used when a programmer knows exactly how many times
    they need the loop to repeat. In the `while` loop, we do not know when the user
    will be done with the calculator. The user might want to make one calculation
    or they might want to make 10, and a `while` loop is flexible. A `for` loop is
    more rigid.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是另一种循环。我们将使用 `for` 循环为我们的计算器创建一个奖励函数。`for` 和 `while` 之间最大的区别是，当程序员确切知道需要循环重复多少次时，才会使用
    `for` 循环。在 `while` 循环中，我们不知道用户何时会完成计算器。用户可能只想进行一次计算，或者可能想进行 10 次计算，而 `while` 循环是灵活的。`for`
    循环更加严格。'
- en: 'Why not just use `while` all the time, then? Well, there are times when we
    know just what it will take to get a job done, and we do not want the program
    to keep going any more after the job is done. The `for` loop is perfect for saying
    how many times to repeat a loop. For example, let''s say that you have a list
    of numbers, and you want to print all the numbers in the list. Let''s say that
    you want to print the numbers `1` through `10`. If you had to write them out individually,
    it would look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不总是使用 `while` 呢？嗯，有些时候我们知道完成工作需要什么，我们不想在任务完成后让程序继续运行。`for` 循环非常适合说明重复循环的次数。例如，假设你有一个数字列表，你想要打印列表中的所有数字。假设你想要打印数字
    `1` 到 `10`。如果你必须单独写出它们，看起来会是这样：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a lot of lines of code, and they are all doing the same thing! What
    a waste of space, and what a waste of time to type this all out. Instead of typing
    the preceding code, type the code in the following `for` loop:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段很多行的代码，它们都在做同样的事情！多么浪费空间，而且输入这些代码是多么浪费时间。与其输入前面的代码，不如在下面的 `for` 循环中输入代码：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![for](img/B04681_04_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![for](img/B04681_04_08.jpg)'
- en: First, you see that we typed `n` in `range(1, 11)`. This means *every number
    between* `1` *and* `11`*, not including* `11`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你注意到我们在 `range(1, 11)` 中输入了 `n`。这意味着*介于* `1` 和 `11` 之间的*每一个数字*，不包括 `11`。
- en: You will also notice that we called a function named `range()`, which is a built-in
    Python function that allows us to specify a range of numbers instead of writing
    them all out. The `range()` function does *NOT* include the last number, so you
    can see that the second number is `11`, instead of `10`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到我们调用了一个名为 `range()` 的函数，这是一个内置的 Python 函数，允许我们指定一系列数字而不是全部写出来。`range()`
    函数*不包括*最后一个数字，所以你可以看到第二个数字是 `11`，而不是 `10`。
- en: You can experiment with these numbers in the range by expanding it to `range(1,
    1000)`. What happens now? This is a basic `for` loop, but we will find that using
    this `for` loop is very helpful when we want to repeat code for lists of numbers,
    letters, words, or objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将范围扩展到 `range(1, 1000)` 来在这些数字范围内进行实验。现在会发生什么？这是一个基本的 `for` 循环，但我们会发现，当我们想要对数字、字母、单词或对象列表重复代码时，使用这个
    `for` 循环非常有帮助。
- en: Bonus – count_to_ten() function
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奖励 - `count_to_ten()` 函数
- en: 'To make our calculator a little more interesting, let''s create a `count` function
    that will print the numbers from `1` to `10`. We can then add this function to
    our list of choices. First, think about how we used the preceding `for` loop.
    Then, copy the `count_to_ten()` function between the `modulo()` function and the
    `quit()` function into your `first_calc.py` program:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的计算器更有趣，让我们创建一个 `count` 函数，该函数将打印从 `1` 到 `10` 的数字。然后我们可以将此函数添加到我们的选择列表中。首先，考虑我们是如何使用前面的
    `for` 循环的。然后，将 `count_to_ten()` 函数复制到 `modulo()` 函数和 `quit()` 函数之间，并将其放入你的 `first_calc.py`
    程序中：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the choice `ten` to your `op` variable, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将选择`ten`添加到你的`op`变量中，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add `elif` for `ten` to your control flow of `if`/`elif`/`else`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`elif`添加到你的`if`/`elif`/`else`控制流程中，用于`ten`：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will print out the choice for your users, and then, when they type `ten`,
    the calculator will print out all of the numbers from 1 to 10\. This screenshot
    shows how the code works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出用户的选择，然后，当用户输入`ten`时，计算机会打印出从1到10的所有数字。这个截图显示了代码的工作原理：
- en: '![Bonus – count_to_ten() function](img/B04681_04_09.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![奖励 – count_to_ten() 函数](img/B04681_04_09.jpg)'
- en: A quick task for you
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个快速的任务
- en: 'In this chapter, you learned a lot about how to write programs that can make
    decisions. Here are some questions to answer:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多关于如何编写能够做出决策的程序的知识。以下是一些需要回答的问题：
- en: Q1\. How many times can the `elif` statement appear in the `if`/`elif`/`else`
    flow?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. `elif`语句在`if`/`elif`/`else`流程中可以出现多少次？
- en: Only once
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只一次
- en: Twice
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两次
- en: As many times as it is needed
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要多少次就运行多少次
- en: Ten
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十
- en: Q2\. Which statement starts a conditional block of code that is used to make
    decisions?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 哪个语句开始了一个用于做出决策的条件代码块？
- en: else
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: else
- en: if
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if
- en: elif
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: elif
- en: while
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: while
- en: Q3\. Which statement is only used at the end of a conditional block of code?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 哪个语句仅在条件代码块的末尾使用？
- en: else
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: else
- en: if
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if
- en: elif
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: elif
- en: while
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: while
- en: Q4\. What is a global variable?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 什么是全局变量？
- en: A variable that is only used in one function
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在一个函数中使用的变量
- en: A variable that can be shared with many functions
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以与许多函数共享的变量
- en: A variable that uses global before its name if it is inside a function
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果变量在函数内部，其名称前使用全局变量
- en: Both 2 and 3
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2 和 3 都可以
- en: Q5\. What is a `while` loop?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Q5. 什么是`while`循环？
- en: A loop that runs code only once
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只运行一次代码的循环
- en: A loop that runs code a set number of times
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行固定次数代码的循环
- en: A loop that repeats code until something different happens, and then it stops
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行代码直到发生不同的事情，然后停止的循环
- en: A loop that does nothing
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个什么也不做的循环
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned many new concepts. You learned about comparison
    operators, the symbols that allow us to compare two items. You also learned about
    `if`, `elif`, and `else`, which are three conditional words that let us tell our
    program how to make different decisions based on the information that a user enters.
    You learned about the `for` and `while` loops; both are very important in making
    programs that give feedback. You also learned a bit about how to use global variables,
    which can be shared with all the functions in a code file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了许多新概念。你学习了比较运算符，这些符号允许我们比较两个项目。你还学习了`if`、`elif`和`else`，这三个条件词让我们能够告诉程序如何根据用户输入的信息做出不同的决策。你学习了`for`和`while`循环；这两个循环在制作提供反馈的程序中都非常重要。你还了解了一些如何使用全局变量的知识，这些变量可以与代码文件中的所有函数共享。
- en: Hopefully, you are keeping up with everything we've talked about so far! It
    may feel a little overwhelming, but we will continue to review the concepts we
    learned in this chapter by building some new projects in the next chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能跟上我们到目前为止所讨论的所有内容！这可能感觉有点令人不知所措，但我们将通过在下一章中构建一些新的项目来继续复习本章学到的概念。
