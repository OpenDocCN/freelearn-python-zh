<html><head></head><body><div><div><h1 id="_idParaDest-268"><em class="italic"><a id="_idTextAnchor272"/></em><a href="B16119_09_Final_PD_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a>: External API – Integrating with Other Systems</h1>
			<p>The Odoo server provides an external API that's used by its web client and is also available for other client applications. In this chapter, we'll learn how to use the Odoo external API to implement external applications that interact with an Odoo server by using it as a backend.</p>
			<p>This can be used to write scripts to load or modify Odoo data, or to integrate with an Odoo existing business application, which is complementary and can't be replaced by an Odoo app.</p>
			<p>We'll describe how to use OdooRPC calls, and then use that knowledge to build a simple command-line application for the <em class="italic">Library</em> Odoo app using Python.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Introducing the learning project – a client app to catalog books</li>
				<li>Setting up Python on the client machine</li>
				<li>Exploring the Odoo external API</li>
				<li>Implementing the client app's XML-RPC interface</li>
				<li>Implementing the client app's user interface</li>
				<li>Using the OdooRPC library</li>
			</ul>
			<p>By the end of this chapter, you should have created a simple Python application that can use Odoo as a backend to query and store data.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor273"/>Technical requirements</h1>
			<p>The code in this chapter requires the <code>library_app</code> Odoo module that we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>. The corresponding code can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>.</p>
			<p>The path to the Git clone repository should be in the Odoo add-ons path and the <code>library_app</code> module should be installed. The code examples will assume that the Odoo database you're working with is <code>library</code>, to be consistent with the installation instructions provided in <a href="B16119_02_Final_PD_ePub.xhtml#_idTextAnchor049"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing the Development Environment</em>.</p>
			<p>The code in this chapter can be found in the same repository, in the <code>ch09/client_app/</code> directory.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor274"/>Introducing the learning project – a client app to catalog books</h1>
			<p>In this chapter, we will work <a id="_idIndexMarker738"/>on a simple client application to manage the library book catalog. It is a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) application that uses Odoo as its backend. The features that we will implement will be basic to keep the focus on the technology that's used to interact with the Odoo server.</p>
			<p>This simple CLI application <a id="_idIndexMarker739"/>should be able to do the following:</p>
			<ul>
				<li>Search for and list books by title.</li>
				<li>Add new books to the catalog.</li>
				<li>Edit a book title.</li>
			</ul>
			<p>The goal is to focus on how to use the Odoo external API, so we want to avoid introducing additional programming languages that you might not be familiar with. By introducing this constraint, the most sensible choice is to use Python to implement the client app. Still, once we understand the XML-RPC library for a particular language, the techniques to handle the RPC calls will also apply.</p>
			<p>The application will be a Python script that expects specific commands to perform. Here is an example:</p>
			<pre>$ python3 library.py add "Moby-Dick"
$ python3 library.py list "moby"
3 Moby-Dick
$ python3 library.py set-title 3 "Moby Dick"</pre>
			<p>This example session <a id="_idIndexMarker740"/>demonstrates the client app being used to add, list, and modify book titles.</p>
			<p>This client app will run using Python. Before we start looking at the code for the client app, we must make sure that Python is installed in the client machine.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor275"/>Setting up Python on the client machine</h1>
			<p>The Odoo API can <a id="_idIndexMarker741"/>be accessed externally using two different <a id="_idIndexMarker742"/>protocols: XML-RPC and JSON-RPC. Any external program capable of implementing a client for one of these protocols will be able to interact with an Odoo server. To avoid introducing additional programming languages, we will use Python to explore the external API.</p>
			<p>Until now, Python code was only being used on the server side. For the client app, Python code will run on the client, so the workstation may require additional setup.</p>
			<p>To follow the examples in this chapter, the system you're using needs to be able to run Python 3 code. If you've followed the same development environment that's been used for the other chapters in this book, this might already be the case. However, if it isn't, we should make sure that Python is installed.</p>
			<p>To make sure that Python 3 is installed in the development workstation, run the <code>python3 --version</code> command in a terminal window. If it is not installed, please refer to the official page to find the installation package for your system, at <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</p>
			<p>With Ubuntu, there's a good chance it is preinstalled on your system. If not, it can be installed with the following command:</p>
			<pre>$ sudo apt-get install python3 python3-pip</pre>
			<p>For Windows 10, it can be installed from the Microsoft Store.</p>
			<p>Running <code>python3</code> in PowerShell will direct you to the corresponding download page.</p>
			<p>If you are a Windows user and have installed Odoo with the all-in-one installer, you may be wondering <a id="_idIndexMarker743"/>why the Python interpreter is not already <a id="_idIndexMarker744"/>available for you. In this case, you'll need an additional installation. The short answer is that the Odoo all-in-one installer has an embedded Python interpreter that is not directly made available to the general system.</p>
			<p>Now that Python has been installed and is available, it can be used to explore the Odoo external API.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor276"/>Exploring the Odoo external API</h1>
			<p>Some familiarity with <a id="_idIndexMarker745"/>the Odoo external API should be gained before we implement the client app. The following sections explore the XML-RPC API using a <em class="italic">Python interpreter</em>.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor277"/>Using XML-RPC to connect to the Odoo external API</h2>
			<p>The simplest <a id="_idIndexMarker746"/>way to access the Odoo server is <a id="_idIndexMarker747"/>by using XML-RPC. The <code>xmlrpc</code> library, from Python standard library, can be used for this.</p>
			<p>Remember that the application being developed is a client that connects to a server. So, a running Odoo server instance is needed for the client to connect to. The code examples will assume that an Odoo server instance is running on the same machine, <code>http://localhost:8069</code>, but any reachable URL can be used if the server you wish to use is running on a different machine.</p>
			<p>The Odoo <code>xmlrpc/2/common</code> endpoint exposes public methods, and these can be accessed without a login. These can be used to inspect the server version and check login credentials. Let's use the <code>xmlrpc</code> library to explore the <code>common</code> publicly available Odoo API.</p>
			<p>First, start a Python 3 console and type the following:</p>
			<pre>&gt;&gt;&gt; from xmlrpc import client
&gt;&gt;&gt; srv = "http://localhost:8069"
&gt;&gt;&gt; common = client.ServerProxy("%s/xmlrpc/2/common" % srv)
&gt;&gt;&gt; common.version()
{'server_version': '15.0', 'server_version_info': [15, 0, 0, 'final', 0, ''], 'server_serie': '15.0', 'protocol_version': 1}</pre>
			<p>The preceding code imports the <code>xmlrpc</code> library and sets up a variable with the server address and listening port. This can be adapted to the specific URL of the Odoo server to connect to.</p>
			<p>Next, an XML-RPC client object is created to access the server public services that are exposed at the <code>/xmlrpc/2/common</code> endpoint. You do not need to log in. One of the methods <a id="_idIndexMarker748"/>available there is <code>version()</code>, which is <a id="_idIndexMarker749"/>used to inspect the Odoo server version. It is a simple way to confirm that communication with the server is working.</p>
			<p>Another useful public method is <code>authenticate()</code>. This method confirms that the username and password are accepted and returns the user ID that should be used in requests. Here is an example:</p>
			<pre>&gt;&gt;&gt; db, user, password = "library", "admin", "admin"
&gt;&gt;&gt; uid = common.authenticate(db, user, password, {})
&gt;&gt;&gt; print(uid)
2</pre>
			<p>The <code>authenticate()</code> method expects four parameters: the database name, the username, the password, and the user agent. The previous code used variables to store these and then passed those variables as parameters.</p>
			<p class="callout-heading">Changes in Odoo 14</p>
			<p class="callout">Odoo 14 supports API keys, and this may be required for Odoo API external access. API keys can be set on the user's <strong class="bold">Preferences</strong> form, in the <strong class="bold">Account Security</strong> tab. The XML-RPC usage is the same, except that the API key should be used as the password. More details are provided in the official documentation at <a href="https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html#api-keys">https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html#api-keys</a>.</p>
			<p>The user agent <a id="_idIndexMarker750"/>environment should be used to <a id="_idIndexMarker751"/>provide some metadata about the client. It's mandatory, and should at least be an empty dictionary, <code>{}</code>.</p>
			<p>If the authentication fails, a <code>False</code> value will be returned.</p>
			<p>The <code>common</code> public endpoint is quite limited, so to gain access to the ORM API or another endpoint, the required authentication needs to be used.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor278"/>Using XML-RPC to run server methods</h2>
			<p>To access the <a id="_idIndexMarker752"/>Odoo models and their methods, the <code>xmlrpc/2/object</code> endpoint needs to be used. The requests to this endpoint require login details.</p>
			<p>This endpoint exposes a generic <code>execute_kw</code> method and receives the model's name, the method to call, and a list containing the parameters to pass to that method.</p>
			<p>Here is an example of how <code>execute_kw</code> works. It calls the <code>search_count</code> method, which returns the number of records that match a domain filter:</p>
			<pre>&gt;&gt;&gt; api = xmlrpc.client.ServerProxy('%s/xmlrpc/2/object' % srv)
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search_count", [[]])
3</pre>
			<p>This code uses the <code>xmlrpc/2/endpoint</code> object to access the server API. The <code>execute_kw()</code> method is called using the following arguments:</p>
			<ul>
				<li>The name of the database to connect to</li>
				<li>The connection user ID</li>
				<li>The user password (or API key)</li>
				<li>The target model identifier</li>
				<li>The method to call</li>
				<li>A list of positional arguments</li>
				<li>An optional dictionary with keyword arguments (not used in this example)</li>
			</ul>
			<p>All the model methods can be called, except for the ones prefixed with an underscore (<code>_</code>), which are <a id="_idIndexMarker753"/>considered private. Some methods might not work with the XML-RPC protocol if they return values that can't be sent through the XML-RPC protocol. This is the case for <code>browse()</code>, which returns a recordset object. Trying to use <code>browse()</code> through XML-RPC returns a <code>TypeError: cannot marshal objects</code> error. Instead of <code>browse()</code>, XML-RPC calls should use <code>read</code> or <code>search_read</code>, which return data in a format the XML-RPC protocol can send to the client.</p>
			<p>Now, let's see how <code>search</code> and <code>read</code> can be used to query Odoo data.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor279"/>Using the search and read API methods</h2>
			<p>The Odoo server-side <a id="_idIndexMarker754"/>code uses <code>browse</code> to query <a id="_idIndexMarker755"/>records. This can't be used by RPC clients because the recordset objects can't be transported through the RPC protocol. Instead, the <code>read</code> method should be used.</p>
			<p><code>read([&lt;ids&gt;, [&lt;fields&gt;])</code> is similar to the <code>browse</code> method, but instead of a recordset, it returns a list of records. Each record is a dictionary that contains the fields that have been requested and their data.</p>
			<p>Let's see how <code>read()</code> can be used to retrieve data from Odoo:</p>
			<pre>&gt;&gt;&gt; api = xmlrpc.client.ServerProxy("%s/xmlrpc/2/object" % srv)
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "read", [2, ["login", "name", "company_id"]])
[{'id': 2, 'login': 'admin', 'name': 'Mitchell Admin', 'company_id': [1, 'YourCompany']}]</pre>
			<p>The preceding example calls the <code>read</code> method of the <code>res.users</code> model with two positional arguments – the record ID <code>2</code> (a list of IDs could have been used instead) and the list of fields to retrieve, <code>["login", "name", "company_id"]</code>, and no keyword arguments.</p>
			<p>The result is a list of dictionaries, where each dictionary is a record. The values of to-many fields <a id="_idIndexMarker756"/>follow a particular representation. They <a id="_idIndexMarker757"/>are a pair of values with the record ID and the record display name. For example, the <code>company_id</code> value that was returned previously was <code>[1, 'YourCompany']</code>.</p>
			<p>The record IDs may not be known, and in that case, a search call is needed to find the record IDs that match a domain filter.</p>
			<p>For example, if we wish to find the admin user, we can use <code>[("login", "=", "admin")]</code>. This RPC call is shown here:</p>
			<pre>&gt;&gt;&gt; domain = [("login", "=", "admin")]
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search", [domain])
[2]</pre>
			<p>The result is a list with only one element, <code>2</code>, which is the ID of the <code>admin</code> user.</p>
			<p>A frequent action would be to use combinations of the <code>search</code> and <code>read</code> methods to find the ID for the records meeting a domain filter and then retrieve the data for them. For a client app, this means two round trips to the server. To simplify this, the <code>search_read</code> method is available, which can perform both operations in a single step.</p>
			<p>Here is an example of <code>search_read</code> being used to find the admin user and return its name:</p>
			<pre>&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search_read", [domain, ["login", "name"]])
[{'id': 2, 'login': 'admin', 'name': 'Mitchell Admin'}]</pre>
			<p>The <code>search_read</code> method is using two positional arguments: a list containing the domain filter, and a second list containing the fields to retrieve.</p>
			<p>The arguments for <code>search_read</code> are as follows:</p>
			<ul>
				<li><code>domain</code>: A list with a domain filter expression</li>
				<li><code>fields</code>: A list with the names of the fields to retrieve</li>
				<li><code>offset</code>: The number of records to skip or use for record pagination</li>
				<li><code>limit</code>: The maximum number of records to return</li>
				<li><code>order</code>: A string to be used by the database's <code>ORDER BY</code> clause</li>
			</ul>
			<p>The <code>fields</code> argument is optional, both for <code>read</code> and <code>search_read</code>. If it's not provided, all the <a id="_idIndexMarker758"/>model fields will be retrieved. But <a id="_idIndexMarker759"/>this may cause expensive function field computation and a large amount of data being retrieved that is probably not needed. So, the recommendation is to provide an explicit list of fields.</p>
			<p>The <code>execute_kw</code> call can use both positional and keyword arguments. Here is what the same call looks like when you're using keyword arguments instead of positional ones:</p>
			<pre>&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search_read", <strong class="bold">[], {"domain": domain, "fields": ["login", "name"]</strong>})</pre>
			<p><code>search_read</code> is the most used method to retrieve data, but there are more methods available to write data or trigger other business logic.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor280"/>Calling other API methods</h2>
			<p>All the other model <a id="_idIndexMarker760"/>methods are exposed through RPC, except for the ones prefixed with an underscore, which are considered private. This means that <code>create</code>, <code>write</code>, and <code>unlink</code> can be called to modify data on the server.</p>
			<p>Let's look at an example. The following code creates a new partner record, modifies it, reads it to confirm the modification was written, and finally deletes it:</p>
			<pre>&gt;&gt;&gt; x = api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"create"</strong>, 
[{'name': 'Packt Pub'}])
&gt;&gt;&gt; print(x)
49
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"write"</strong>, 
[[x], {'name': 'Packt Publishing'}]) 
True
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"read"</strong>, 
[[x], ["name"]])
[{'id': 49, 'name': 'Packt Publishing'}]
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"unlink"</strong>, [[x]])
True
&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"read"</strong>, [[x]])
[]</pre>
			<p>One limitation of the XML-RPC protocol is that it doesn't support <code>None</code> values. There's an XML-RPC extension <a id="_idIndexMarker761"/>that supports <code>None</code> values, but whether this is available will depend on the particular XML-RPC library being used by the client app. Methods that don't return anything may not be usable through XML-RPC, since they are implicitly returning <code>None</code>. This is why it is good practice for methods to always return something, at a <code>True</code> value. Another alternative is to use JSON-RPC instead. The <code>OdooRPC</code> library supports this protocol, and it will be used later in this chapter, in the <em class="italic">Using the OdooRPC library</em> section.</p>
			<p>The <code>Model</code> methods that are prefixed with an underscore are considered private and aren't exposed through XML-RPC.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Often, client apps want to replicate manual user entry on an Odoo form. Calling the <code>create()</code> method might not be enough for this, because forms can automate some fields using <code>onchange</code> methods, which are triggered by the form's interaction, but not by <code>create()</code>. The solution is to create a custom method on the Odoo server, that uses <code>create()</code> and then runs the needed <code>onchange</code> methods.</p>
			<p>It is worth repeating <a id="_idIndexMarker762"/>that the Odoo external API can be used by most programming languages. The official documentation provides examples for Ruby, PHP, and Java. This is available at <a href="https://www.odoo.com/documentation/15.0/webservices/odoo.html">https://www.odoo.com/documentation/15.0/webservices/odoo.html</a>.</p>
			<p>So far, we've seen how to call Odoo methods using the XML-RPC protocol. Now, we can use this to build the book catalog client application.</p>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor281"/>Implementing the client app XML-RPC interface</h1>
			<p>Let's start by implementing the Library book catalog client application.</p>
			<p>This can be <a id="_idIndexMarker763"/>split into two files: one for the Odoo backend interface containing the server backend, <code>library_xmlrpc.py</code>, and another for the user interface, <code>library.py</code>. This will allow us to use alternative implementations for the backend interface.</p>
			<p>Starting with the Odoo backend component, a <code>LibraryAPI</code> class will be used to set up the connection with the Odoo server that supports methods that are needed to interact with Odoo. The methods to implement are as follows:</p>
			<ul>
				<li><code>search_read(&lt;title&gt;)</code> to search for book data by title</li>
				<li><code>create(&lt;title&gt;)</code> to create a book with a specific title</li>
				<li><code>write(&lt;id&gt;, &lt;title&gt;)</code> to update a book title using the book ID</li>
				<li><code>unlink(&lt;id&gt;)</code> to delete a book using its ID</li>
			</ul>
			<p>Choose a directory to host the application files in and create the <code>library_xmlrpc.py</code> file. Start by adding the class constructor, as follows:</p>
			<pre>import xmlrpc.client
class LibraryAPI(): 
    def __init__(self, host, port, db, user, pwd):
        common = xmlrpc.client.ServerProxy(
            "http://%s:%d/xmlrpc/2/common" % (host, port))
        self.api = xmlrpc.client.ServerProxy(
            "http://%s:%d/xmlrpc/2/object" % (host, port))
        self.uid = common.authenticate(db, user, pwd, {})
        self.pwd = pwd
        self.db = db
        self.model = "library.book"</pre>
			<p>This class <a id="_idIndexMarker764"/>stores all of the information needed to execute calls on the target model: the API XML-RPC reference, <code>uid</code>, the password, the database name, and the model name.</p>
			<p>The RPC calls to Odoo will all use the same <code>execute_kw</code> RPC method. A thin wrapper around it is added next, in the <code>_execute()</code> private method. This takes advantage of the object stored data to provide a smaller function signature, as shown in the following code block:</p>
			<pre>    def _execute(self, method, arg_list, kwarg_dict=None): 
        return self.api.execute_kw( 
            self.db, self.uid, self.pwd, self.model,
            method, arg_list, kwarg_dict or {})</pre>
			<p>This <code>_execute()</code> private method can now be used for less verbose implementations of the higher-level methods.</p>
			<p>The first public method is the <code>search_read()</code> method. It will accept an optional string that's used to search book titles. If no title is given, all the records will be returned. This is the corresponding implementation:</p>
			<pre>    def search_read(self, title=None):
        domain = [("name", "ilike", title)] if title else 
                   [] 
        fields = ["id", "name"]
        return self._execute("search_read", [domain, 
          fields])</pre>
			<p>The <code>create()</code> method will create <a id="_idIndexMarker765"/>a new book with the given title and return the ID of the created record:</p>
			<pre>    def create(self, title):
        vals = {"name": title}
        return self._execute("create", [vals])</pre>
			<p>The <code>write()</code> method will <a id="_idIndexMarker766"/>have the new title and book ID as arguments and will perform a write operation on that book:</p>
			<pre>    def write(self, id, title): 
        vals = {"name": title} 
        return self._execute("write", [[id], vals])</pre>
			<p>Finally, the <code>unlink()</code> method is <a id="_idIndexMarker767"/>used to delete a book, given the corresponding ID:</p>
			<pre>    def unlink(self, id): 
        return self._execute("unlink", [[id]])</pre>
			<p>We end the <a id="_idIndexMarker768"/>file with a small piece of test code that will be executed if we run the Python file, which can help test the methods that have been implemented, as shown here:</p>
			<pre>if __name__ == "__main__": 
    # Sample test configurations 
    host, port, db = "localhost", 8069, "library" 
    user, pwd = "admin", "admin"
    api = LibraryAPI(host, port, db, user, pwd) 
    from pprint import pprint 
    pprint(api.search_read())</pre>
			<p>If we run this Python script, we should see the content of our library books printed out:</p>
			<pre>$ python3 library_xmlrpc.py
[{'id': 1, 'name': 'Odoo Development Essentials 11'},
 {'id': 2, 'name': 'Odoo 11 Development Cookbook'},
 {'id': 3, 'name': 'Brave New World'}]</pre>
			<p>Now that we have a <a id="_idIndexMarker769"/>simple wrapper around our Odoo backend, let's deal with the command-line user interface.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor282"/>Implementing the client app user interface</h1>
			<p>Our goal here was <a id="_idIndexMarker770"/>to learn how to write the interface between an external application and the Odoo server, and we did this in the previous section. But let's go the extra mile and build the user interface for this minimalistic client application.</p>
			<p>To keep this as simple as possible, we will use a simple command-line user interface and additional dependencies will be avoided. This leaves us with Python's built-in features to implement command-line applications and the <code>ArgumentParser</code> library.</p>
			<p>Now, alongside the <code>library_xmlrpc.py</code> file, create a new <code>library.py</code> file. This will import Python's command-line argument parser and then the <code>LibraryAPI</code> class, as shown in the following code:</p>
			<pre>from argparse import ArgumentParser
from library_xmlrpc import LibraryAPI</pre>
			<p>Next, we must describe the commands that the argument parser will expect. There are four commands:</p>
			<ul>
				<li><code>list</code> to search for and list books</li>
				<li><code>add</code> to add a book</li>
				<li><code>set</code> to update a book title</li>
				<li><code>del</code> to delete a book</li>
			</ul>
			<p>The command-line parser code for implementing the preceding commands is shown here:</p>
			<pre>parser = ArgumentParser()
parser.add_argument(
    "command",
    choices=["list", "add", "set", "del"])
parser.add_argument("params", nargs="*")  # optional args
args = parser.parse_args()</pre>
			<p>The <code>args</code> object <a id="_idIndexMarker771"/>represents the command-line options given by the user. <code>args.command</code> is the command being used, while <code>args.params</code> holds the additional parameters to use for the command, if they've been given any.</p>
			<p>If no or incorrect commands are given, the argument parser will handle that and will show the user what input is expected. A complete reference to <code>argparse</code> can be found in <a id="_idIndexMarker772"/>the official documentation at <a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a>.</p>
			<p>The next step is to perform the action that corresponds to the <code>user</code> command. We will start by creating a <code>LibraryAPI</code> instance. This requires Odoo connection details that, in this simple implementation, will be hardcoded, as shown here:</p>
			<pre>host, port, db = "localhost", 8069, "library"
user, pwd = "admin", "admin"
api = LibraryAPI(host, port, db, user, pwd)</pre>
			<p>The first line sets some fixed parameters for the server instance and database to connect to. In this case, the connection is to a local Odoo server, listening on the <code>8069</code> default port, to a <code>library</code> database. To connect to a different server and database, these parameters should be adapted accordingly.</p>
			<p>New specific code to handle each command must be added. We will start with the <code>list</code> command, which returns a list of books:</p>
			<pre>if args.command == "list":
    title = args.params[:1]
    books = api.search_read(title)
    for book in books:
        print("%(id)d %(name)s" % book)</pre>
			<p>The <code>LibraryAPI.search_read()</code> method is being used in the preceding code to retrieve the list of book records. The returned list is then iterated to print out each element.</p>
			<p>Next is the <code>add</code> command:</p>
			<pre>if args.command == "add":
    title = args.params[0]
    book_id = api.create(title)
    print("Book added with ID %d for title %s." % (
      book_id, title))</pre>
			<p>Since the hard <a id="_idIndexMarker773"/>work was already done in the <code>LibraryAPI</code> object, the implementation just needs to call the <code>create()</code> method and show the result to the end user.</p>
			<p>The <code>set</code> command allows us to change the title of an existing book. It should have two parameters – the ID of the book and the new title:</p>
			<pre>if args.command == "set":
    if len(args.params) != 2:
        print("set command requires a Title and ID.")
    else:
        book_id, title = int(args.params[0]), 
          args.params[1]
        api.write(book_id, title)
        print("Title of Book ID %d set to %s." % (book_id, 
          title))</pre>
			<p>Finally, there is the implementation for the <code>del</code> command, to delete a book record. This is not very different from the previous commands:</p>
			<pre>if args.command == "del":
    book_id = int(args.params[0])
    api.unlink(book_id)
    print("Book with ID %s was deleted." % book_id)</pre>
			<p>The client <a id="_idIndexMarker774"/>application is done, and you can try it out using the commands of your choice. In particular, we should be able to run the example commands shown at the beginning of this chapter.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">On a Linux system, <code>library.py</code> can be made executable by running the <code>chmod +x library.py</code> command and adding <code>#!/usr/bin/env python3</code> to the first line of the file. After this, running <code>./library.py</code> in the command line should work.</p>
			<p>This is quite a basic application, and it is easy to think of a few ways to improve it. The point here was to build a minimum viable application using the Odoo RPC API.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor283"/>Using the OdooRPC library</h1>
			<p>Another relevant client library to be considered is <code>OdooRPC</code>. It is a complete client library that <a id="_idIndexMarker775"/>uses the JSON-RPC protocol instead of XML-RPC. The Odoo official web client uses JSON-RPC as well, although XML-RPC is still also supported.</p>
			<p>The <code>OdooRPC</code> library is now maintained under the Odoo Community Association umbrella. The source code repository can be found at <a href="https://github.com/OCA/odoorpc">https://github.com/OCA/odoorpc</a>.</p>
			<p>The <code>OdooRPC</code> library can be installed from PyPI using the following command:</p>
			<pre>$ pip3 install odoorpc</pre>
			<p>The <code>OdooRPC</code> library sets up a server connection when a new <code>odoorpc.ODOO</code> object is created. At this point, we should use the <code>ODOO.login()</code> method to create a user session. Just like on the server side, the session has an <code>env</code> attribute containing the session's environment, including the user ID, <code>uid</code>, and <code>context</code>.</p>
			<p>The <code>OdooRPC</code> library can be used to provide an alternate implementation for the <code>library_xmlrpc.py</code> interface with the server. It should provide the same features but be implemented using JSON-RPC instead of XML-RPC.</p>
			<p>To achieve this, a <code>library_odoorpc.py</code> Python module will be created that provides a <a id="_idIndexMarker776"/>drop-in replacement for the <code>library_xmlrpc.py</code> module. To do this, create a new <code>library_odoorpc.py</code> file alongside it that contains the following code:</p>
			<pre>import odoorpc
class LibraryAPI():
    def __init__(self, host, port, db, user, pwd):
        self.api = odoorpc.ODOO(host, port=port)
        self.api.login(db, user, pwd)
        self.uid = self.api.env.uid
        self.model = "library.book"
        self.Model = self.api.env[self.model]
    def _execute(self, method, arg_list, kwarg_dict=None):
        return self.api.execute(
            self.model,
            method, *arg_list, **kwarg_dict)</pre>
			<p>The <code>OdooRPC</code> library implements the <code>Model</code> and <code>Recordset</code> objects, which mimic the behavior of their server-side counterparts. The goal is for the code that's using this library to be similar to the code that's used on the Odoo server side. The methods that are used by the client make use of this and store a reference to the <code>library.book</code> model object in the <code>self.Model</code> attribute, which is provided by the OdooRPC <code>env["library.book"]</code> call.</p>
			<p>The <code>_execute()</code> method is implemented here as well; it allows us to compare it to the plain XML-RPC version. The OdooRPC library has the <code>execute()</code> method to run arbitrary Odoo model methods.</p>
			<p>Next is the implementation for the <code>search_read()</code>, <code>create()</code>, <code>write()</code>, and <code>unlink()</code> client methods. In the same file, add these methods inside the <code>LibraryAPI()</code> class:</p>
			<pre>    def search_read(self, title=None):
        domain = [("name", "ilike", title)] if title else 
                  []
        fields = ["id", "name"]
        return self.Model.search_read(domain, fields)
    def create(self, title):
        vals = {"name": title}
        return self.Model.create(vals)
    def write(self, id, title):
        vals = {"name": title}
        self.Model.write(id, vals)
    def unlink(self, id):
        return self.Model.unlink(id)</pre>
			<p>Notice how this client code is similar to the Odoo server-side code.</p>
			<p>This <code>LibraryAPI</code> object can be used as a drop-in replacement for <code>library_xmlrpc.py</code>. It can <a id="_idIndexMarker777"/>be used as the RPC connection layer by editing the <code>library.py</code> file and changing the <code>from library_xmlrpc import LibraryAPI</code> line to <code>from library_odoorpc import LibraryAPI</code>. Now, test drive the <code>library.py</code> client application; it should perform just like before!</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor284"/>Summary</h1>
			<p>The goal of this chapter was to learn how the external API works and what it is capable of. We started by exploring it with simple scripts using the Python XML-RPC client, though the external API can be used from any programming language. The official documentation provides code examples for Java, PHP, and Ruby.</p>
			<p>Then, we learned how to use XML-RPC calls to search for and read data, and then how to call any other method. We can, for example, create, update, and delete records.</p>
			<p>Next, we introduced the OdooRPC library. It provides a layer on top of the RPC base library (XML-RPC or JSON-RPC) to provide a local API that's similar to the API that can be found on the server side. This lowers the learning curve, reduces programming mistakes, and makes it easier to copy code between server and client code.</p>
			<p>With this, we have finished the chapters dedicated to the programming API and business logic. Now, it's time to look at views and the user interface. In the next chapter, we will look at backend views in more detail and the user experience that can be provided out of the box by the web client.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor285"/>Further reading</h1>
			<p>The following additional reference material may complement the topics described in this chapter:</p>
			<ul>
				<li>The official documentation on Odoo web services, including code examples for programming languages other than Python: <a href="https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html">https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html</a></li>
				<li>The OdooRPC documentation: <a href="https://pythonhosted.org/OdooRPC">https://pythonhosted.org/OdooRPC</a></li>
			</ul>
		</div>
	</div></body></html>