<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer065">
			<h1 id="_idParaDest-268"><em class="italic"><a id="_idTextAnchor272"/></em><a href="B16119_09_Final_PD_ePub.xhtml#_idTextAnchor272"><em class="italic">Chapter 9</em></a>: External API – Integrating with Other Systems</h1>
			<p>The Odoo server provides an external API that's used by its web client and is also available for other client applications. In this chapter, we'll learn how to use the Odoo external API to implement external applications that interact with an Odoo server by using it as a backend.</p>
			<p>This can be used to write scripts to load or modify Odoo data, or to integrate with an Odoo existing business application, which is complementary and can't be replaced by an Odoo app.</p>
			<p>We'll describe how to use OdooRPC calls, and then use that knowledge to build a simple command-line application for the <em class="italic">Library</em> Odoo app using Python.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Introducing the learning project – a client app to catalog books</li>
				<li>Setting up Python on the client machine</li>
				<li>Exploring the Odoo external API</li>
				<li>Implementing the client app's XML-RPC interface</li>
				<li>Implementing the client app's user interface</li>
				<li>Using the OdooRPC library</li>
			</ul>
			<p>By the end of this chapter, you should have created a simple Python application that can use Odoo as a backend to query and store data.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor273"/>Technical requirements</h1>
			<p>The code in this chapter requires the <strong class="source-inline">library_app</strong> Odoo module that we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>. The corresponding code can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>.</p>
			<p>The path to the Git clone repository should be in the Odoo add-ons path and the <strong class="source-inline">library_app</strong> module should be installed. The code examples will assume that the Odoo database you're working with is <strong class="source-inline">library</strong>, to be consistent with the installation instructions provided in <a href="B16119_02_Final_PD_ePub.xhtml#_idTextAnchor049"><em class="italic">Chapter 2</em></a>, <em class="italic">Preparing the Development Environment</em>.</p>
			<p>The code in this chapter can be found in the same repository, in the <strong class="source-inline">ch09/client_app/</strong> directory.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor274"/>Introducing the learning project – a client app to catalog books</h1>
			<p>In this chapter, we will work <a id="_idIndexMarker738"/>on a simple client application to manage the library book catalog. It is a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) application that uses Odoo as its backend. The features that we will implement will be basic to keep the focus on the technology that's used to interact with the Odoo server.</p>
			<p>This simple CLI application <a id="_idIndexMarker739"/>should be able to do the following:</p>
			<ul>
				<li>Search for and list books by title.</li>
				<li>Add new books to the catalog.</li>
				<li>Edit a book title.</li>
			</ul>
			<p>The goal is to focus on how to use the Odoo external API, so we want to avoid introducing additional programming languages that you might not be familiar with. By introducing this constraint, the most sensible choice is to use Python to implement the client app. Still, once we understand the XML-RPC library for a particular language, the techniques to handle the RPC calls will also apply.</p>
			<p>The application will be a Python script that expects specific commands to perform. Here is an example:</p>
			<p class="source-code">$ python3 library.py add "Moby-Dick"</p>
			<p class="source-code">$ python3 library.py list "moby"</p>
			<p class="source-code">3 Moby-Dick</p>
			<p class="source-code">$ python3 library.py set-title 3 "Moby Dick"</p>
			<p>This example session <a id="_idIndexMarker740"/>demonstrates the client app being used to add, list, and modify book titles.</p>
			<p>This client app will run using Python. Before we start looking at the code for the client app, we must make sure that Python is installed in the client machine.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor275"/>Setting up Python on the client machine</h1>
			<p>The Odoo API can <a id="_idIndexMarker741"/>be accessed externally using two different <a id="_idIndexMarker742"/>protocols: XML-RPC and JSON-RPC. Any external program capable of implementing a client for one of these protocols will be able to interact with an Odoo server. To avoid introducing additional programming languages, we will use Python to explore the external API.</p>
			<p>Until now, Python code was only being used on the server side. For the client app, Python code will run on the client, so the workstation may require additional setup.</p>
			<p>To follow the examples in this chapter, the system you're using needs to be able to run Python 3 code. If you've followed the same development environment that's been used for the other chapters in this book, this might already be the case. However, if it isn't, we should make sure that Python is installed.</p>
			<p>To make sure that Python 3 is installed in the development workstation, run the <strong class="source-inline">python3 --version</strong> command in a terminal window. If it is not installed, please refer to the official page to find the installation package for your system, at <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</p>
			<p>With Ubuntu, there's a good chance it is preinstalled on your system. If not, it can be installed with the following command:</p>
			<p class="source-code">$ sudo apt-get install python3 python3-pip</p>
			<p>For Windows 10, it can be installed from the Microsoft Store.</p>
			<p>Running <strong class="source-inline">python3</strong> in PowerShell will direct you to the corresponding download page.</p>
			<p>If you are a Windows user and have installed Odoo with the all-in-one installer, you may be wondering <a id="_idIndexMarker743"/>why the Python interpreter is not already <a id="_idIndexMarker744"/>available for you. In this case, you'll need an additional installation. The short answer is that the Odoo all-in-one installer has an embedded Python interpreter that is not directly made available to the general system.</p>
			<p>Now that Python has been installed and is available, it can be used to explore the Odoo external API.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor276"/>Exploring the Odoo external API</h1>
			<p>Some familiarity with <a id="_idIndexMarker745"/>the Odoo external API should be gained before we implement the client app. The following sections explore the XML-RPC API using a <em class="italic">Python interpreter</em>.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor277"/>Using XML-RPC to connect to the Odoo external API</h2>
			<p>The simplest <a id="_idIndexMarker746"/>way to access the Odoo server is <a id="_idIndexMarker747"/>by using XML-RPC. The <strong class="source-inline">xmlrpc</strong> library, from Python standard library, can be used for this.</p>
			<p>Remember that the application being developed is a client that connects to a server. So, a running Odoo server instance is needed for the client to connect to. The code examples will assume that an Odoo server instance is running on the same machine, <strong class="source-inline">http://localhost:8069</strong>, but any reachable URL can be used if the server you wish to use is running on a different machine.</p>
			<p>The Odoo <strong class="source-inline">xmlrpc/2/common</strong> endpoint exposes public methods, and these can be accessed without a login. These can be used to inspect the server version and check login credentials. Let's use the <strong class="source-inline">xmlrpc</strong> library to explore the <strong class="source-inline">common</strong> publicly available Odoo API.</p>
			<p>First, start a Python 3 console and type the following:</p>
			<p class="source-code">&gt;&gt;&gt; from xmlrpc import client</p>
			<p class="source-code">&gt;&gt;&gt; srv = "http://localhost:8069"</p>
			<p class="source-code">&gt;&gt;&gt; common = client.ServerProxy("%s/xmlrpc/2/common" % srv)</p>
			<p class="source-code">&gt;&gt;&gt; common.version()</p>
			<p class="source-code">{'server_version': '15.0', 'server_version_info': [15, 0, 0, 'final', 0, ''], 'server_serie': '15.0', 'protocol_version': 1}</p>
			<p>The preceding code imports the <strong class="source-inline">xmlrpc</strong> library and sets up a variable with the server address and listening port. This can be adapted to the specific URL of the Odoo server to connect to.</p>
			<p>Next, an XML-RPC client object is created to access the server public services that are exposed at the <strong class="source-inline">/xmlrpc/2/common</strong> endpoint. You do not need to log in. One of the methods <a id="_idIndexMarker748"/>available there is <strong class="source-inline">version()</strong>, which is <a id="_idIndexMarker749"/>used to inspect the Odoo server version. It is a simple way to confirm that communication with the server is working.</p>
			<p>Another useful public method is <strong class="source-inline">authenticate()</strong>. This method confirms that the username and password are accepted and returns the user ID that should be used in requests. Here is an example:</p>
			<p class="source-code">&gt;&gt;&gt; db, user, password = "library", "admin", "admin"</p>
			<p class="source-code">&gt;&gt;&gt; uid = common.authenticate(db, user, password, {})</p>
			<p class="source-code">&gt;&gt;&gt; print(uid)</p>
			<p class="source-code">2</p>
			<p>The <strong class="source-inline">authenticate()</strong> method expects four parameters: the database name, the username, the password, and the user agent. The previous code used variables to store these and then passed those variables as parameters.</p>
			<p class="callout-heading">Changes in Odoo 14</p>
			<p class="callout">Odoo 14 supports API keys, and this may be required for Odoo API external access. API keys can be set on the user's <strong class="bold">Preferences</strong> form, in the <strong class="bold">Account Security</strong> tab. The XML-RPC usage is the same, except that the API key should be used as the password. More details are provided in the official documentation at <a href="https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html#api-keys">https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html#api-keys</a>.</p>
			<p>The user agent <a id="_idIndexMarker750"/>environment should be used to <a id="_idIndexMarker751"/>provide some metadata about the client. It's mandatory, and should at least be an empty dictionary, <strong class="source-inline">{}</strong>.</p>
			<p>If the authentication fails, a <strong class="source-inline">False</strong> value will be returned.</p>
			<p>The <strong class="source-inline">common</strong> public endpoint is quite limited, so to gain access to the ORM API or another endpoint, the required authentication needs to be used.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor278"/>Using XML-RPC to run server methods</h2>
			<p>To access the <a id="_idIndexMarker752"/>Odoo models and their methods, the <strong class="source-inline">xmlrpc/2/object</strong> endpoint needs to be used. The requests to this endpoint require login details.</p>
			<p>This endpoint exposes a generic <strong class="source-inline">execute_kw</strong> method and receives the model's name, the method to call, and a list containing the parameters to pass to that method.</p>
			<p>Here is an example of how <strong class="source-inline">execute_kw</strong> works. It calls the <strong class="source-inline">search_count</strong> method, which returns the number of records that match a domain filter:</p>
			<p class="source-code">&gt;&gt;&gt; api = xmlrpc.client.ServerProxy('%s/xmlrpc/2/object' % srv)</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search_count", [[]])</p>
			<p class="source-code">3</p>
			<p>This code uses the <strong class="source-inline">xmlrpc/2/endpoint</strong> object to access the server API. The <strong class="source-inline">execute_kw()</strong> method is called using the following arguments:</p>
			<ul>
				<li>The name of the database to connect to</li>
				<li>The connection user ID</li>
				<li>The user password (or API key)</li>
				<li>The target model identifier</li>
				<li>The method to call</li>
				<li>A list of positional arguments</li>
				<li>An optional dictionary with keyword arguments (not used in this example)</li>
			</ul>
			<p>All the model methods can be called, except for the ones prefixed with an underscore (<strong class="source-inline">_</strong>), which are <a id="_idIndexMarker753"/>considered private. Some methods might not work with the XML-RPC protocol if they return values that can't be sent through the XML-RPC protocol. This is the case for <strong class="source-inline">browse()</strong>, which returns a recordset object. Trying to use <strong class="source-inline">browse()</strong> through XML-RPC returns a <strong class="source-inline">TypeError: cannot marshal objects</strong> error. Instead of <strong class="source-inline">browse()</strong>, XML-RPC calls should use <strong class="source-inline">read</strong> or <strong class="source-inline">search_read</strong>, which return data in a format the XML-RPC protocol can send to the client.</p>
			<p>Now, let's see how <strong class="source-inline">search</strong> and <strong class="source-inline">read</strong> can be used to query Odoo data.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor279"/>Using the search and read API methods</h2>
			<p>The Odoo server-side <a id="_idIndexMarker754"/>code uses <strong class="source-inline">browse</strong> to query <a id="_idIndexMarker755"/>records. This can't be used by RPC clients because the recordset objects can't be transported through the RPC protocol. Instead, the <strong class="source-inline">read</strong> method should be used.</p>
			<p><strong class="source-inline">read([&lt;ids&gt;, [&lt;fields&gt;])</strong> is similar to the <strong class="source-inline">browse</strong> method, but instead of a recordset, it returns a list of records. Each record is a dictionary that contains the fields that have been requested and their data.</p>
			<p>Let's see how <strong class="source-inline">read()</strong> can be used to retrieve data from Odoo:</p>
			<p class="source-code">&gt;&gt;&gt; api = xmlrpc.client.ServerProxy("%s/xmlrpc/2/object" % srv)</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "read", [2, ["login", "name", "company_id"]])</p>
			<p class="source-code">[{'id': 2, 'login': 'admin', 'name': 'Mitchell Admin', 'company_id': [1, 'YourCompany']}]</p>
			<p>The preceding example calls the <strong class="source-inline">read</strong> method of the <strong class="source-inline">res.users</strong> model with two positional arguments – the record ID <strong class="source-inline">2</strong> (a list of IDs could have been used instead) and the list of fields to retrieve, <strong class="source-inline">["login", "name", "company_id"]</strong>, and no keyword arguments.</p>
			<p>The result is a list of dictionaries, where each dictionary is a record. The values of to-many fields <a id="_idIndexMarker756"/>follow a particular representation. They <a id="_idIndexMarker757"/>are a pair of values with the record ID and the record display name. For example, the <strong class="source-inline">company_id</strong> value that was returned previously was <strong class="source-inline">[1, 'YourCompany']</strong>.</p>
			<p>The record IDs may not be known, and in that case, a search call is needed to find the record IDs that match a domain filter.</p>
			<p>For example, if we wish to find the admin user, we can use <strong class="source-inline">[("login", "=", "admin")]</strong>. This RPC call is shown here:</p>
			<p class="source-code">&gt;&gt;&gt; domain = [("login", "=", "admin")]</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search", [domain])</p>
			<p class="source-code">[2]</p>
			<p>The result is a list with only one element, <strong class="source-inline">2</strong>, which is the ID of the <strong class="source-inline">admin</strong> user.</p>
			<p>A frequent action would be to use combinations of the <strong class="source-inline">search</strong> and <strong class="source-inline">read</strong> methods to find the ID for the records meeting a domain filter and then retrieve the data for them. For a client app, this means two round trips to the server. To simplify this, the <strong class="source-inline">search_read</strong> method is available, which can perform both operations in a single step.</p>
			<p>Here is an example of <strong class="source-inline">search_read</strong> being used to find the admin user and return its name:</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search_read", [domain, ["login", "name"]])</p>
			<p class="source-code">[{'id': 2, 'login': 'admin', 'name': 'Mitchell Admin'}]</p>
			<p>The <strong class="source-inline">search_read</strong> method is using two positional arguments: a list containing the domain filter, and a second list containing the fields to retrieve.</p>
			<p>The arguments for <strong class="source-inline">search_read</strong> are as follows:</p>
			<ul>
				<li><strong class="source-inline">domain</strong>: A list with a domain filter expression</li>
				<li><strong class="source-inline">fields</strong>: A list with the names of the fields to retrieve</li>
				<li><strong class="source-inline">offset</strong>: The number of records to skip or use for record pagination</li>
				<li><strong class="source-inline">limit</strong>: The maximum number of records to return</li>
				<li><strong class="source-inline">order</strong>: A string to be used by the database's <strong class="source-inline">ORDER BY</strong> clause</li>
			</ul>
			<p>The <strong class="source-inline">fields</strong> argument is optional, both for <strong class="source-inline">read</strong> and <strong class="source-inline">search_read</strong>. If it's not provided, all the <a id="_idIndexMarker758"/>model fields will be retrieved. But <a id="_idIndexMarker759"/>this may cause expensive function field computation and a large amount of data being retrieved that is probably not needed. So, the recommendation is to provide an explicit list of fields.</p>
			<p>The <strong class="source-inline">execute_kw</strong> call can use both positional and keyword arguments. Here is what the same call looks like when you're using keyword arguments instead of positional ones:</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.users", "search_read", <strong class="bold">[], {"domain": domain, "fields": ["login", "name"]</strong>})</p>
			<p><strong class="source-inline">search_read</strong> is the most used method to retrieve data, but there are more methods available to write data or trigger other business logic.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor280"/>Calling other API methods</h2>
			<p>All the other model <a id="_idIndexMarker760"/>methods are exposed through RPC, except for the ones prefixed with an underscore, which are considered private. This means that <strong class="source-inline">create</strong>, <strong class="source-inline">write</strong>, and <strong class="source-inline">unlink</strong> can be called to modify data on the server.</p>
			<p>Let's look at an example. The following code creates a new partner record, modifies it, reads it to confirm the modification was written, and finally deletes it:</p>
			<p class="source-code">&gt;&gt;&gt; x = api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"create"</strong>, </p>
			<p class="source-code">[{'name': 'Packt Pub'}])</p>
			<p class="source-code">&gt;&gt;&gt; print(x)</p>
			<p class="source-code">49</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"write"</strong>, </p>
			<p class="source-code">[[x], {'name': 'Packt Publishing'}]) </p>
			<p class="source-code">True</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"read"</strong>, </p>
			<p class="source-code">[[x], ["name"]])</p>
			<p class="source-code">[{'id': 49, 'name': 'Packt Publishing'}]</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"unlink"</strong>, [[x]])</p>
			<p class="source-code">True</p>
			<p class="source-code">&gt;&gt;&gt; api.execute_kw(db, uid, password, "res.partner", <strong class="bold">"read"</strong>, [[x]])</p>
			<p class="source-code">[]</p>
			<p>One limitation of the XML-RPC protocol is that it doesn't support <strong class="source-inline">None</strong> values. There's an XML-RPC extension <a id="_idIndexMarker761"/>that supports <strong class="source-inline">None</strong> values, but whether this is available will depend on the particular XML-RPC library being used by the client app. Methods that don't return anything may not be usable through XML-RPC, since they are implicitly returning <strong class="source-inline">None</strong>. This is why it is good practice for methods to always return something, at a <strong class="source-inline">True</strong> value. Another alternative is to use JSON-RPC instead. The <strong class="source-inline">OdooRPC</strong> library supports this protocol, and it will be used later in this chapter, in the <em class="italic">Using the OdooRPC library</em> section.</p>
			<p>The <strong class="source-inline">Model</strong> methods that are prefixed with an underscore are considered private and aren't exposed through XML-RPC.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Often, client apps want to replicate manual user entry on an Odoo form. Calling the <strong class="source-inline">create()</strong> method might not be enough for this, because forms can automate some fields using <strong class="source-inline">onchange</strong> methods, which are triggered by the form's interaction, but not by <strong class="source-inline">create()</strong>. The solution is to create a custom method on the Odoo server, that uses <strong class="source-inline">create()</strong> and then runs the needed <strong class="source-inline">onchange</strong> methods.</p>
			<p>It is worth repeating <a id="_idIndexMarker762"/>that the Odoo external API can be used by most programming languages. The official documentation provides examples for Ruby, PHP, and Java. This is available at <a href="https://www.odoo.com/documentation/15.0/webservices/odoo.html">https://www.odoo.com/documentation/15.0/webservices/odoo.html</a>.</p>
			<p>So far, we've seen how to call Odoo methods using the XML-RPC protocol. Now, we can use this to build the book catalog client application.</p>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor281"/>Implementing the client app XML-RPC interface</h1>
			<p>Let's start by implementing the Library book catalog client application.</p>
			<p>This can be <a id="_idIndexMarker763"/>split into two files: one for the Odoo backend interface containing the server backend, <strong class="source-inline">library_xmlrpc.py</strong>, and another for the user interface, <strong class="source-inline">library.py</strong>. This will allow us to use alternative implementations for the backend interface.</p>
			<p>Starting with the Odoo backend component, a <strong class="source-inline">LibraryAPI</strong> class will be used to set up the connection with the Odoo server that supports methods that are needed to interact with Odoo. The methods to implement are as follows:</p>
			<ul>
				<li><strong class="source-inline">search_read(&lt;title&gt;)</strong> to search for book data by title</li>
				<li><strong class="source-inline">create(&lt;title&gt;)</strong> to create a book with a specific title</li>
				<li><strong class="source-inline">write(&lt;id&gt;, &lt;title&gt;)</strong> to update a book title using the book ID</li>
				<li><strong class="source-inline">unlink(&lt;id&gt;)</strong> to delete a book using its ID</li>
			</ul>
			<p>Choose a directory to host the application files in and create the <strong class="source-inline">library_xmlrpc.py</strong> file. Start by adding the class constructor, as follows:</p>
			<p class="source-code">import xmlrpc.client</p>
			<p class="source-code">class LibraryAPI(): </p>
			<p class="source-code">    def __init__(self, host, port, db, user, pwd):</p>
			<p class="source-code">        common = xmlrpc.client.ServerProxy(</p>
			<p class="source-code">            "http://%s:%d/xmlrpc/2/common" % (host, port))</p>
			<p class="source-code">        self.api = xmlrpc.client.ServerProxy(</p>
			<p class="source-code">            "http://%s:%d/xmlrpc/2/object" % (host, port))</p>
			<p class="source-code">        self.uid = common.authenticate(db, user, pwd, {})</p>
			<p class="source-code">        self.pwd = pwd</p>
			<p class="source-code">        self.db = db</p>
			<p class="source-code">        self.model = "library.book"</p>
			<p>This class <a id="_idIndexMarker764"/>stores all of the information needed to execute calls on the target model: the API XML-RPC reference, <strong class="source-inline">uid</strong>, the password, the database name, and the model name.</p>
			<p>The RPC calls to Odoo will all use the same <strong class="source-inline">execute_kw</strong> RPC method. A thin wrapper around it is added next, in the <strong class="source-inline">_execute()</strong> private method. This takes advantage of the object stored data to provide a smaller function signature, as shown in the following code block:</p>
			<p class="source-code">    def _execute(self, method, arg_list, kwarg_dict=None): </p>
			<p class="source-code">        return self.api.execute_kw( </p>
			<p class="source-code">            self.db, self.uid, self.pwd, self.model,</p>
			<p class="source-code">            method, arg_list, kwarg_dict or {})</p>
			<p>This <strong class="source-inline">_execute()</strong> private method can now be used for less verbose implementations of the higher-level methods.</p>
			<p>The first public method is the <strong class="source-inline">search_read()</strong> method. It will accept an optional string that's used to search book titles. If no title is given, all the records will be returned. This is the corresponding implementation:</p>
			<p class="source-code">    def search_read(self, title=None):</p>
			<p class="source-code">        domain = [("name", "ilike", title)] if title else </p>
			<p class="source-code">                   [] </p>
			<p class="source-code">        fields = ["id", "name"]</p>
			<p class="source-code">        return self._execute("search_read", [domain, </p>
			<p class="source-code">          fields])</p>
			<p>The <strong class="source-inline">create()</strong> method will create <a id="_idIndexMarker765"/>a new book with the given title and return the ID of the created record:</p>
			<p class="source-code">    def create(self, title):</p>
			<p class="source-code">        vals = {"name": title}</p>
			<p class="source-code">        return self._execute("create", [vals])</p>
			<p>The <strong class="source-inline">write()</strong> method will <a id="_idIndexMarker766"/>have the new title and book ID as arguments and will perform a write operation on that book:</p>
			<p class="source-code">    def write(self, id, title): </p>
			<p class="source-code">        vals = {"name": title} </p>
			<p class="source-code">        return self._execute("write", [[id], vals])</p>
			<p>Finally, the <strong class="source-inline">unlink()</strong> method is <a id="_idIndexMarker767"/>used to delete a book, given the corresponding ID:</p>
			<p class="source-code">    def unlink(self, id): </p>
			<p class="source-code">        return self._execute("unlink", [[id]])</p>
			<p>We end the <a id="_idIndexMarker768"/>file with a small piece of test code that will be executed if we run the Python file, which can help test the methods that have been implemented, as shown here:</p>
			<p class="source-code">if __name__ == "__main__": </p>
			<p class="source-code">    # Sample test configurations </p>
			<p class="source-code">    host, port, db = "localhost", 8069, "library" </p>
			<p class="source-code">    user, pwd = "admin", "admin"</p>
			<p class="source-code">    api = LibraryAPI(host, port, db, user, pwd) </p>
			<p class="source-code">    from pprint import pprint </p>
			<p class="source-code">    pprint(api.search_read())</p>
			<p>If we run this Python script, we should see the content of our library books printed out:</p>
			<p class="source-code">$ python3 library_xmlrpc.py</p>
			<p class="source-code">[{'id': 1, 'name': 'Odoo Development Essentials 11'},</p>
			<p class="source-code"> {'id': 2, 'name': 'Odoo 11 Development Cookbook'},</p>
			<p class="source-code"> {'id': 3, 'name': 'Brave New World'}]</p>
			<p>Now that we have a <a id="_idIndexMarker769"/>simple wrapper around our Odoo backend, let's deal with the command-line user interface.</p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor282"/>Implementing the client app user interface</h1>
			<p>Our goal here was <a id="_idIndexMarker770"/>to learn how to write the interface between an external application and the Odoo server, and we did this in the previous section. But let's go the extra mile and build the user interface for this minimalistic client application.</p>
			<p>To keep this as simple as possible, we will use a simple command-line user interface and additional dependencies will be avoided. This leaves us with Python's built-in features to implement command-line applications and the <strong class="source-inline">ArgumentParser</strong> library.</p>
			<p>Now, alongside the <strong class="source-inline">library_xmlrpc.py</strong> file, create a new <strong class="source-inline">library.py</strong> file. This will import Python's command-line argument parser and then the <strong class="source-inline">LibraryAPI</strong> class, as shown in the following code:</p>
			<p class="source-code">from argparse import ArgumentParser</p>
			<p class="source-code">from library_xmlrpc import LibraryAPI</p>
			<p>Next, we must describe the commands that the argument parser will expect. There are four commands:</p>
			<ul>
				<li><strong class="source-inline">list</strong> to search for and list books</li>
				<li><strong class="source-inline">add</strong> to add a book</li>
				<li><strong class="source-inline">set</strong> to update a book title</li>
				<li><strong class="source-inline">del</strong> to delete a book</li>
			</ul>
			<p>The command-line parser code for implementing the preceding commands is shown here:</p>
			<p class="source-code">parser = ArgumentParser()</p>
			<p class="source-code">parser.add_argument(</p>
			<p class="source-code">    "command",</p>
			<p class="source-code">    choices=["list", "add", "set", "del"])</p>
			<p class="source-code">parser.add_argument("params", nargs="*")  # optional args</p>
			<p class="source-code">args = parser.parse_args()</p>
			<p>The <strong class="source-inline">args</strong> object <a id="_idIndexMarker771"/>represents the command-line options given by the user. <strong class="source-inline">args.command</strong> is the command being used, while <strong class="source-inline">args.params</strong> holds the additional parameters to use for the command, if they've been given any.</p>
			<p>If no or incorrect commands are given, the argument parser will handle that and will show the user what input is expected. A complete reference to <strong class="source-inline">argparse</strong> can be found in <a id="_idIndexMarker772"/>the official documentation at <a href="https://docs.python.org/3/library/argparse.html">https://docs.python.org/3/library/argparse.html</a>.</p>
			<p>The next step is to perform the action that corresponds to the <strong class="source-inline">user</strong> command. We will start by creating a <strong class="source-inline">LibraryAPI</strong> instance. This requires Odoo connection details that, in this simple implementation, will be hardcoded, as shown here:</p>
			<p class="source-code">host, port, db = "localhost", 8069, "library"</p>
			<p class="source-code">user, pwd = "admin", "admin"</p>
			<p class="source-code">api = LibraryAPI(host, port, db, user, pwd)</p>
			<p>The first line sets some fixed parameters for the server instance and database to connect to. In this case, the connection is to a local Odoo server, listening on the <strong class="source-inline">8069</strong> default port, to a <strong class="source-inline">library</strong> database. To connect to a different server and database, these parameters should be adapted accordingly.</p>
			<p>New specific code to handle each command must be added. We will start with the <strong class="source-inline">list</strong> command, which returns a list of books:</p>
			<p class="source-code">if args.command == "list":</p>
			<p class="source-code">    title = args.params[:1]</p>
			<p class="source-code">    books = api.search_read(title)</p>
			<p class="source-code">    for book in books:</p>
			<p class="source-code">        print("%(id)d %(name)s" % book)</p>
			<p>The <strong class="source-inline">LibraryAPI.search_read()</strong> method is being used in the preceding code to retrieve the list of book records. The returned list is then iterated to print out each element.</p>
			<p>Next is the <strong class="source-inline">add</strong> command:</p>
			<p class="source-code">if args.command == "add":</p>
			<p class="source-code">    title = args.params[0]</p>
			<p class="source-code">    book_id = api.create(title)</p>
			<p class="source-code">    print("Book added with ID %d for title %s." % (</p>
			<p class="source-code">      book_id, title))</p>
			<p>Since the hard <a id="_idIndexMarker773"/>work was already done in the <strong class="source-inline">LibraryAPI</strong> object, the implementation just needs to call the <strong class="source-inline">create()</strong> method and show the result to the end user.</p>
			<p>The <strong class="source-inline">set</strong> command allows us to change the title of an existing book. It should have two parameters – the ID of the book and the new title:</p>
			<p class="source-code">if args.command == "set":</p>
			<p class="source-code">    if len(args.params) != 2:</p>
			<p class="source-code">        print("set command requires a Title and ID.")</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        book_id, title = int(args.params[0]), </p>
			<p class="source-code">          args.params[1]</p>
			<p class="source-code">        api.write(book_id, title)</p>
			<p class="source-code">        print("Title of Book ID %d set to %s." % (book_id, </p>
			<p class="source-code">          title))</p>
			<p>Finally, there is the implementation for the <strong class="source-inline">del</strong> command, to delete a book record. This is not very different from the previous commands:</p>
			<p class="source-code">if args.command == "del":</p>
			<p class="source-code">    book_id = int(args.params[0])</p>
			<p class="source-code">    api.unlink(book_id)</p>
			<p class="source-code">    print("Book with ID %s was deleted." % book_id)</p>
			<p>The client <a id="_idIndexMarker774"/>application is done, and you can try it out using the commands of your choice. In particular, we should be able to run the example commands shown at the beginning of this chapter.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">On a Linux system, <strong class="source-inline">library.py</strong> can be made executable by running the <strong class="source-inline">chmod +x library.py</strong> command and adding <strong class="source-inline">#!/usr/bin/env python3</strong> to the first line of the file. After this, running <strong class="source-inline">./library.py</strong> in the command line should work.</p>
			<p>This is quite a basic application, and it is easy to think of a few ways to improve it. The point here was to build a minimum viable application using the Odoo RPC API.</p>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor283"/>Using the OdooRPC library</h1>
			<p>Another relevant client library to be considered is <strong class="source-inline">OdooRPC</strong>. It is a complete client library that <a id="_idIndexMarker775"/>uses the JSON-RPC protocol instead of XML-RPC. The Odoo official web client uses JSON-RPC as well, although XML-RPC is still also supported.</p>
			<p>The <strong class="source-inline">OdooRPC</strong> library is now maintained under the Odoo Community Association umbrella. The source code repository can be found at <a href="https://github.com/OCA/odoorpc">https://github.com/OCA/odoorpc</a>.</p>
			<p>The <strong class="source-inline">OdooRPC</strong> library can be installed from PyPI using the following command:</p>
			<p class="source-code">$ pip3 install odoorpc</p>
			<p>The <strong class="source-inline">OdooRPC</strong> library sets up a server connection when a new <strong class="source-inline">odoorpc.ODOO</strong> object is created. At this point, we should use the <strong class="source-inline">ODOO.login()</strong> method to create a user session. Just like on the server side, the session has an <strong class="source-inline">env</strong> attribute containing the session's environment, including the user ID, <strong class="source-inline">uid</strong>, and <strong class="source-inline">context</strong>.</p>
			<p>The <strong class="source-inline">OdooRPC</strong> library can be used to provide an alternate implementation for the <strong class="source-inline">library_xmlrpc.py</strong> interface with the server. It should provide the same features but be implemented using JSON-RPC instead of XML-RPC.</p>
			<p>To achieve this, a <strong class="source-inline">library_odoorpc.py</strong> Python module will be created that provides a <a id="_idIndexMarker776"/>drop-in replacement for the <strong class="source-inline">library_xmlrpc.py</strong> module. To do this, create a new <strong class="source-inline">library_odoorpc.py</strong> file alongside it that contains the following code:</p>
			<p class="source-code">import odoorpc</p>
			<p class="source-code">class LibraryAPI():</p>
			<p class="source-code">    def __init__(self, host, port, db, user, pwd):</p>
			<p class="source-code">        self.api = odoorpc.ODOO(host, port=port)</p>
			<p class="source-code">        self.api.login(db, user, pwd)</p>
			<p class="source-code">        self.uid = self.api.env.uid</p>
			<p class="source-code">        self.model = "library.book"</p>
			<p class="source-code">        self.Model = self.api.env[self.model]</p>
			<p class="source-code">    def _execute(self, method, arg_list, kwarg_dict=None):</p>
			<p class="source-code">        return self.api.execute(</p>
			<p class="source-code">            self.model,</p>
			<p class="source-code">            method, *arg_list, **kwarg_dict)</p>
			<p>The <strong class="source-inline">OdooRPC</strong> library implements the <strong class="source-inline">Model</strong> and <strong class="source-inline">Recordset</strong> objects, which mimic the behavior of their server-side counterparts. The goal is for the code that's using this library to be similar to the code that's used on the Odoo server side. The methods that are used by the client make use of this and store a reference to the <strong class="source-inline">library.book</strong> model object in the <strong class="source-inline">self.Model</strong> attribute, which is provided by the OdooRPC <strong class="source-inline">env["library.book"]</strong> call.</p>
			<p>The <strong class="source-inline">_execute()</strong> method is implemented here as well; it allows us to compare it to the plain XML-RPC version. The OdooRPC library has the <strong class="source-inline">execute()</strong> method to run arbitrary Odoo model methods.</p>
			<p>Next is the implementation for the <strong class="source-inline">search_read()</strong>, <strong class="source-inline">create()</strong>, <strong class="source-inline">write()</strong>, and <strong class="source-inline">unlink()</strong> client methods. In the same file, add these methods inside the <strong class="source-inline">LibraryAPI()</strong> class:</p>
			<p class="source-code">    def search_read(self, title=None):</p>
			<p class="source-code">        domain = [("name", "ilike", title)] if title else </p>
			<p class="source-code">                  []</p>
			<p class="source-code">        fields = ["id", "name"]</p>
			<p class="source-code">        return self.Model.search_read(domain, fields)</p>
			<p class="source-code">    def create(self, title):</p>
			<p class="source-code">        vals = {"name": title}</p>
			<p class="source-code">        return self.Model.create(vals)</p>
			<p class="source-code">    def write(self, id, title):</p>
			<p class="source-code">        vals = {"name": title}</p>
			<p class="source-code">        self.Model.write(id, vals)</p>
			<p class="source-code">    def unlink(self, id):</p>
			<p class="source-code">        return self.Model.unlink(id)</p>
			<p>Notice how this client code is similar to the Odoo server-side code.</p>
			<p>This <strong class="source-inline">LibraryAPI</strong> object can be used as a drop-in replacement for <strong class="source-inline">library_xmlrpc.py</strong>. It can <a id="_idIndexMarker777"/>be used as the RPC connection layer by editing the <strong class="source-inline">library.py</strong> file and changing the <strong class="source-inline">from library_xmlrpc import LibraryAPI</strong> line to <strong class="source-inline">from library_odoorpc import LibraryAPI</strong>. Now, test drive the <strong class="source-inline">library.py</strong> client application; it should perform just like before!</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor284"/>Summary</h1>
			<p>The goal of this chapter was to learn how the external API works and what it is capable of. We started by exploring it with simple scripts using the Python XML-RPC client, though the external API can be used from any programming language. The official documentation provides code examples for Java, PHP, and Ruby.</p>
			<p>Then, we learned how to use XML-RPC calls to search for and read data, and then how to call any other method. We can, for example, create, update, and delete records.</p>
			<p>Next, we introduced the OdooRPC library. It provides a layer on top of the RPC base library (XML-RPC or JSON-RPC) to provide a local API that's similar to the API that can be found on the server side. This lowers the learning curve, reduces programming mistakes, and makes it easier to copy code between server and client code.</p>
			<p>With this, we have finished the chapters dedicated to the programming API and business logic. Now, it's time to look at views and the user interface. In the next chapter, we will look at backend views in more detail and the user experience that can be provided out of the box by the web client.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor285"/>Further reading</h1>
			<p>The following additional reference material may complement the topics described in this chapter:</p>
			<ul>
				<li>The official documentation on Odoo web services, including code examples for programming languages other than Python: <a href="https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html">https://www.odoo.com/documentation/15.0/developer/misc/api/odoo.html</a></li>
				<li>The OdooRPC documentation: <a href="https://pythonhosted.org/OdooRPC">https://pythonhosted.org/OdooRPC</a></li>
			</ul>
		</div>
	</div></body></html>