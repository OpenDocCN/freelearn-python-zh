<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Encoding Secret Messages with Steganography</h1></div></div></div><p>We're going to acquire intelligence data from a variety of sources. In the previous chapter, we searched the WWW. We might use our own cameras or recording devices. We'll look at image processing and encoding in this chapter.</p><p>To work with images in Python, we'll need to install<a id="id296" class="indexterm"/> Pillow. This library gives us software tools to process image files. Pillow is a fork of the older PIL project; Pillow is a bit nicer to use than PIL.</p><p>Along the way, we'll visit some additional Python programming techniques, including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We'll review how Python works with OS files and also look at some common physical formats, including ZIP files, JSON, and CSV.</li><li class="listitem" style="list-style-type: disc">We'll introduce JPEG files and learn to process them with Pillow. We'll have to install Pillow before we can make this work.</li><li class="listitem" style="list-style-type: disc">We'll look at several image transformations, such as getting the EXIF data, creating thumbnails, cropping, enhancing, and filtering.</li><li class="listitem" style="list-style-type: disc">We'll look at how we can fiddle with the individual bits that make up an integer value.</li><li class="listitem" style="list-style-type: disc">We'll also see how we work with Unicode characters and how characters are encoded into bytes.</li><li class="listitem" style="list-style-type: disc">Learning to work with Unicode characters will allow us to encode data in the pixels of an image file. We'll look at the two common steganography algorithms.</li><li class="listitem" style="list-style-type: disc">We'll also take a quick side trip to look at secure hashes. This will show us how to make messages that can't be altered in transmission.</li></ul></div><p>Python is a very powerful programming language. In this chapter, we'll see a lot of sophistication available. We'll also lay a foundation to look at web services and geocoding in the next chapter.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Background briefing – handling file formats</h1></div></div></div><p>As we've observed so far, our data comes in a wide variety of physical formats. In <a class="link" href="ch01.html" title="Chapter 1. Our Espionage Toolkit">Chapter 1</a>, <em>Our Espionage Toolkit</em>, we looked at ZIP files, which are archives that contain other files. In <a class="link" href="ch02.html" title="Chapter 2. Acquiring Intelligence Data">Chapter 2</a>, <em>Acquiring Intelligence Data</em>, we looked at JSON files, which serialize many kinds of Python objects.</p><p>In this chapter, we're going <a id="id297" class="indexterm"/>to review some previous technology and then look at working specifically with CSV files. The important part is to look at the various kinds of image files that we might need to work with.</p><p>In all cases, Python encourages looking at a file as a kind of context. This means that we should strive to open files using the <code class="literal">with</code> statement so that we can be sure the file is properly closed when we're done with the processing. This doesn't always work out perfectly, so there are some exceptions.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Working with the OS filesystem</h2></div></div></div><p>There are many<a id="id298" class="indexterm"/> modules for working with files. We'll focus on two: <code class="literal">glob</code> and <code class="literal">os</code>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec15"/>glob</h3></div></div></div><p>The <code class="literal">glob</code> module implements filesystem <em>globbing</em> rules. When we use <code class="literal">*.jpg</code> in a command at the <a id="id299" class="indexterm"/>terminal prompt, a standard OS shell tool will <em>glob</em> or expand the<a id="id300" class="indexterm"/> wildcard name into a matching list of actual file names, as shown in the following snippet:</p><div><pre class="programlisting">MacBookPro-SLott:code slott$ ls *.jpg
1drachmi_1973.jpg      IPhone_Internals.jpg
Common_face_of_one_euro_coin.jpg  LHD_warship.jpg</pre></div><p>The POSIX standard is for <code class="literal">*.jpg</code> to be expanded by the shell, prior to the <code class="literal">ls</code> program being run. In Windows, this is not always the case.</p><p>The Python <code class="literal">glob</code> module contains the <code class="literal">glob()</code> function that does this job from within a Python program. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; import glob
&gt;&gt;&gt; glob.glob("*.jpg")
['1drachmi_1973.jpg', 'Common_face_of_one_euro_coin.jpg', 'IPhone_Internals.jpg', 'LHD_warship.jpg']</pre></div><p>When we evaluated <code class="literal">glob.glob("*.jpg")</code>, the return value was a list of strings with the names of<a id="id301" class="indexterm"/> matching files.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec16"/>os</h3></div></div></div><p>Many files have a <code class="literal">path/name.extension</code> format. For Windows, a device prefix and the backslash is used (<code class="literal">c:path\name.ext</code>). The Python<a id="id302" class="indexterm"/> <code class="literal">os</code> package provides a <code class="literal">path</code> module with a number of functions for working with file names and paths irrespective of any vagaries of<a id="id303" class="indexterm"/> punctuation. As the <code class="literal">path</code> module is in the <code class="literal">os</code> package, the components will have two levels of namespace containers: <code class="literal">os.path</code>.</p><p>We must always use functions from the <code class="literal">os.path</code> module for working with filenames. There are numerous functions to split paths, join paths, and create absolute paths from relative paths. For example, we should use <code class="literal">os.path.splitext()</code> to separate a filename from the extension. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.path.splitext( "1drachmi_1973.jpg" )
('1drachmi_1973', '.jpg')</pre></div><p>We've separated the filename from the extension without writing any of our own code. There's no reason to write our own parsers when the standard library already has them written.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Processing simple text files</h2></div></div></div><p>In some cases, our files<a id="id304" class="indexterm"/> contain ordinary text. In this case, we can <a id="id305" class="indexterm"/>open the file and process the lines as follows:</p><div><pre class="programlisting">with open("some_file") as data:
    for line in data:
       ... process the line ...</pre></div><p>This is the most common way to work with text files. Each line processed by the <code class="literal">for</code> loop will include a trailing <code class="literal">\n</code> character.</p><p>We can use a simple generator expression to strip the trailing spaces from each line:</p><div><pre class="programlisting">with open("some_file") as data:
    for line in (raw.rstrip() for raw in data):
       ... process the line ...</pre></div><p>We've inserted a generator expression into the <code class="literal">for</code> statement. The generator expression has three parts: a subexpression (<code class="literal">raw.rstrip()</code>), a target variable (<code class="literal">raw</code>), and a source iterable collection (<code class="literal">data</code>). Each line in the source iterable, <code class="literal">data</code>, is assigned to the target, <code class="literal">raw</code>, and the subexpression is evaluated. Each result from the generator expression is made available to the outer <code class="literal">for</code> loop.</p><p>We can visually separate the generator expression into a separate line of code:</p><div><pre class="programlisting">with open("some_file") as data:
    clean_lines = (raw.rstrip() for raw in data)
    for line in clean_lines:
        ... process the line ...</pre></div><p>We wrote the generator expression outside the <code class="literal">for</code> statement. We assigned the generator—not the resulting collection—to the <code class="literal">clean_lines</code> variable to clarify its purpose. A generator <a id="id306" class="indexterm"/>doesn't generate any output until the individual lines are required by another iterator, in this case, the <code class="literal">for</code> loop. There's no real overhead: the processing is simply separated visually.</p><p>This technique allows us to separate different design considerations. We can separate the text cleanup from the important processing inside the <code class="literal">for</code> statement.</p><p>We can expand on the cleanup by writing additional generators:</p><div><pre class="programlisting">with open("some_file") as data:
    clean_lines = (raw.rstrip() for raw in data)
    non_blank_lines = (line for line in clean_lines if len(line) != 0)
    for line in non_blank_lines:
        ... process the line ...</pre></div><p>We've broken down two preprocessing steps into two separate generator expressions. The first expression removes the <code class="literal">\n</code> character from the end of each line. The second generator expression uses the optional <code class="literal">if</code> clause—it will get lines from the first generator expression and only pass lines if the length is not 0. This is a filter that rejects blank lines. The final <code class="literal">for</code> statement only gets nonblank lines that have had the <code class="literal">\n</code> character removed.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Working with ZIP files</h2></div></div></div><p>A ZIP archive <a id="id307" class="indexterm"/>contains one or more files. To use <code class="literal">with</code> with ZIP archives, we need to import the <code class="literal">zipfile</code> module:</p><div><pre class="programlisting">import zipfile</pre></div><p>Generally, we can<a id="id308" class="indexterm"/> open an archive using something like the following:</p><div><pre class="programlisting">with zipfile.ZipFile("demo.zip", "r") as archive:</pre></div><p>This creates a context so that we can work with the file and be sure that it's properly closed at the end of the indented context.</p><p>When we want to create an archive, we can provide an additional parameter:</p><div><pre class="programlisting">with ZipFile("test.zip", "w", compression=zipfile.zipfile.ZIP_DEFLATED) as archive:</pre></div><p>This will create a ZIP file that uses a simple compression algorithm to save space. If we're reading members of a ZIP archive, we can use a nested context to open this member file, as shown in the following snippet:</p><div><pre class="programlisting">    with archive.open("some_file") as member:
        ...process member... </pre></div><p>As we showed in <a class="link" href="ch01.html" title="Chapter 1. Our Espionage Toolkit">Chapter 1</a>, <em>Our Espionage Toolkit</em>, once we've opened a member for reading, it's similar to an<a id="id309" class="indexterm"/> ordinary OS file. The nested<a id="id310" class="indexterm"/> context allows us to use ordinary file processing operations on the member. We used the following example earlier:</p><div><pre class="programlisting">import zipfile
with zipfile.ZipFile( "demo.zip", "r" ) as archive:
    archive.printdir()
    first = archive.infolist()[0]
    with archive.open(first) as member:
        text= member.read()
        print( text )</pre></div><p>We used a context to open the archive. We used a nested context to open a member of the archive. Not all files can be read this way. Members that are images, for example, can't be read directly by Pillow; they must be extracted to a temporary file. We'd do something like this:</p><div><pre class="programlisting">import zipfile
with zipfile.ZipFile( "photos.zip", "r" ) as archive:
    archive.extract("warship.png")</pre></div><p>This will extract a member named <code class="literal">warship.png</code> from the archive and create a local file. Pillow can then work with the extracted file.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Working with JSON files</h2></div></div></div><p>A JSON file contains<a id="id311" class="indexterm"/> a Python object that's been serialized in JSON notation. To work with JSON files, we need to import the <code class="literal">json</code> module:</p><div><pre class="programlisting">import json</pre></div><p>The file processing<a id="id312" class="indexterm"/> context doesn't really apply well to JSON files. We don't generally have the file open for any extended time when processing it. Often, the <code class="literal">with</code> statement context is just one line of code. We might create a file like this:</p><div><pre class="programlisting">...create an_object...
with open("some_file.json", "w") as output:
    json.save(an_object, output)</pre></div><p>This is all that's required to create a JSON-encoded file. Often, we'll contrive to make the object we're serializing<a id="id313" class="indexterm"/> a list or a dict so that we can save multiple objects in a single file. To retrieve the object, we generally do something that's similarly simple, as shown in the following code:</p><div><pre class="programlisting">with open("some_file.json") as input:
    an_object= json.load(input)
...process an_object...</pre></div><p>This will decode<a id="id314" class="indexterm"/> the object and save it in the given variable. If the file contains a list, we can iterate through the object to process each item in the list. If the file contains a dictionary, we might work with specific key values of this dictionary.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The processing applied to the resulting object, <code class="literal">an_object</code>, is outside the context of the <code class="literal">with</code> statement.</p></div></div><p>Once the Python object has been created, we no longer need the file context. The resources associated with the file can be released, and we can focus our processing steps on the resulting object.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Working with CSV files</h2></div></div></div><p>
<strong>CSV</strong> stands for <strong>comma-separated values</strong>. While one of the most <a id="id315" class="indexterm"/>common CSV formats uses the quote character and commas, the CSV idea is readily applicable to any file that has a<a id="id316" class="indexterm"/> column-separator character. We might have a file with each data item separated by tab characters, written as <code class="literal">\t</code> in Python. This is also a kind of CSV file that uses the tab <a id="id317" class="indexterm"/>character to fill the role of a comma.</p><p>We'll use the <code class="literal">csv</code> module to process these files:</p><div><pre class="programlisting">import csv</pre></div><p>When we open a CSV file, we must create a <em>reader</em> or <em>writer</em> that parses the various rows of data in the file. Let's say we downloaded the historical record of bitcoin prices. You can download this data from <a class="ulink" href="https://coinbase.com/api/doc/1.0/prices/historical.html">https://coinbase.com/api/doc/1.0/prices/historical.html</a>. See <a class="link" href="ch02.html" title="Chapter 2. Acquiring Intelligence Data">Chapter 2</a>, <em>Acquiring Intelligence Data</em>, for more information.</p><p>The data is in the CSV notation. Once we've read the string, we need to create a CSV reader around the data. As the data was just read into a big string variable, we don't need to use the filesystem. We can use in-memory processing to create a file-like object, as shown in the following code:</p><div><pre class="programlisting">import io
with urllib.request.urlopen( query_history ) as document:
    history_data= document.read().decode("utf-8") 
reader= csv.reader( io.StringIO(history_data) )</pre></div><p>We've used the <code class="literal">urllib.request.urlopen()</code> function to make a <code class="literal">GET</code> request to the given URL. The response will be in bytes. We decoded the characters from these bytes and saved them in a variable named <code class="literal">history_data</code>.</p><p>In order to make<a id="id318" class="indexterm"/> this amenable to the <code class="literal">csv.Reader</code> class, we used the <code class="literal">io.StringIO</code> class to wrap the data. This creates a file-like object without <a id="id319" class="indexterm"/>actually wasting time to create a file on the disk somewhere.</p><p>We can now read individual rows from the <code class="literal">reader</code> object, as shown in the following code:</p><div><pre class="programlisting">for row in reader:
    print( row )</pre></div><p>This <code class="literal">for</code> loop will step through each row of the CSV file. The various columns of data will be separated; each row will be a tuple of individual column values.</p><p>If we have <em>tab-separated</em> data, we'd modify the reader by providing additional details about the file format. We might, for example, use <code class="literal">rdr= csv.reader(some_file, delimiter='\t')</code> to specify that there are tab-separated values instead of comma-separated ones.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>JPEG and PNG graphics – pixels and metadata</h2></div></div></div><p>An image is composed of picture elements called pixels. Each<a id="id320" class="indexterm"/> pixel is a dot. For computer<a id="id321" class="indexterm"/> displays, the individual dots are<a id="id322" class="indexterm"/> encoded using <strong>red-green-blue</strong> (<strong>RGB</strong>) colors. Each displayed pixel is a sum of the levels of red, green, and blue light. For printing, the colors might be switched to <a id="id323" class="indexterm"/>
<strong>cyan-magenta-yellow-key</strong> (<strong>CMYK</strong>) colors.</p><p>An image file<a id="id324" class="indexterm"/> contains an encoding of the various pixels of the image. The image file may also contain metadata about the image. The<a id="id325" class="indexterm"/> metadata information is sometimes called <strong>tags</strong> and even <a id="id326" class="indexterm"/>
<strong>Exif tags</strong>.</p><p>An image file can use a variety of encodings for<a id="id327" class="indexterm"/> each pixel. A pure black and white image only needs 1 bit for each pixel. High-quality photographs may use one byte for each color, leading to 24 bits per pixel. In some cases, we might add a transparency mask or look for even higher-resolution color. This leads to four bytes per pixel.</p><p>The issue rapidly turns into a question of the amount of storage required. A picture that fills an iPhone display has 326 pixels per inch. The display has 1136 by 640 pixels. If each pixel uses 4 bytes of color information, then the image involves 3 MB of memory.</p><p>Consider a scanned image that's of 8 1/2" by 11" at 326 pixels per inch The image is 2762 x 3586 pixels, a total of 39 MB. Some scanners are capable of producing images at 1200 pixels per inch: that file would be of 673 MB.</p><p>Different image files reflect different strategies to compress this immense amount of data without losing the quality of the image.</p><p>A naive compression algorithm can make the files somewhat smaller. TIFF files, for example, use a fairly simple<a id="id328" class="indexterm"/> compression. The algorithms used by JPEG, however, are quite sophisticated and lead to relatively small file sizes while retaining much—but <a id="id329" class="indexterm"/>not all—of the original image. While JPEG is very good at compressing, the compressed image is not perfect—details are lost to achieve good compression. This makes JPEG weak for steganography where we'll be tweaking the bits to conceal a message in an image.</p><p>We can call JPEG compression lossy because some bits can be lost. We can call TIFF compression lossless because all the original bits can be recovered. Once bits are lost, they can't be recovered. As our message will only be tweaking a few bits, JPEG compression can corrupt our hidden message.</p><p>When we work with images in Pillow, it will be similar to working with a JSON file. We'll open and load the image. We can then process the object in our program. When we're done, we'll save the modified image.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Using the Pillow library</h1></div></div></div><p>We're going to add some cool Python<a id="id330" class="indexterm"/> software to process images. The Pillow package is a sophisticated image-processing library. This library provides extensive file format support, an efficient internal representation, and fairly powerful image processing capabilities. For more information, visit <a class="ulink" href="https://pypi.python.org/pypi/Pillow/2.1.0">https://pypi.python.org/pypi/Pillow/2.1.0</a>. The Pillow<a id="id331" class="indexterm"/> documentation will provide important background in what needs to be done. The installation guide on the PyPi web page is essential reading, you will get some additional details here. The core <a id="id332" class="indexterm"/>Pillow documentation is at <a class="ulink" href="http://pillow.readthedocs.org/en/latest/">http://pillow.readthedocs.org/en/latest/</a>.</p><p>Note that Pillow will install a package named <code class="literal">PIL</code>. This assures that Pillow (the project) creates a module that's compatible<a id="id333" class="indexterm"/> with the <strong>Python Imaging Library</strong> (<strong>PIL</strong>). We'll be importing modules from the <code class="literal">PIL</code> package, even though we'll be installing software created by the Pillow project.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Adding the required supporting libraries</h2></div></div></div><p>If you're a Windows agent, then <a id="id334" class="indexterm"/>you can skip this section. The folks who build Pillow have you firmly in mind. For everyone else, your OS may not be Pillow ready.</p><p>Before installing Pillow, some supporting software infrastructure must be in place. Once all the supporting software is ready, then Pillow can be installed.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec17"/>GNU/Linux secrets</h3></div></div></div><p>We need to have the following libraries in our GNU/Linux configuration. Odds are good that these files are already present in a given distribution. If these files aren't present, it's time to perform some upgrades<a id="id335" class="indexterm"/> or installations. Install the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>libjpeg</strong>: This library provides access to JPEG images; versions 6b, 8, and 9 have been tested</li><li class="listitem" style="list-style-type: disc"><strong>zlib</strong>: This library provides access to compressed PNG images</li><li class="listitem" style="list-style-type: disc"><strong>libtiff</strong>: This library provides access to TIFF images; versions 3.x and 4.0 have been tested</li><li class="listitem" style="list-style-type: disc"><strong>libfreetype</strong>: This library provides type-related services</li><li class="listitem" style="list-style-type: disc"><strong>littlecms</strong>: This library provides color management</li><li class="listitem" style="list-style-type: disc"><strong>libwebp</strong>: This library provides access to the WebP format</li></ul></div><p>Each Linux distribution has a unique approach to installing and configuring the libraries. We can't cover them all.</p><p>Once the supporting libraries are in place, we can use the <code class="literal">easy_install-3.3 pillow</code> command. We'll review this in the <em>Installing and confirming Pillow</em> section.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec18"/>Mac OS X secrets</h3></div></div></div><p>To install Pillow on a Mac, we require three preliminary steps to be performed. We'll need Xcode and homebrew, then we'll use homebrew.</p><p>To get Xcode for<a id="id336" class="indexterm"/> Mac OS X, visit <a class="ulink" href="https://developer.apple.com/xcode/downloads/">https://developer.apple.com/xcode/downloads/</a>. Every<a id="id337" class="indexterm"/> Mac OS X agent should have Xcode, even if they're not going to write native Mac OS X or iOS apps.</p><p>When installing Xcode, we must<a id="id338" class="indexterm"/> be sure that we also install the command-line developer tools. This is another big download above and beyond the basic XCode download.</p><p>Once we have Xcode command-line tools, the second preliminary step is to install Homebrew<a id="id339" class="indexterm"/> from <a class="ulink" href="http://brew.sh">http://brew.sh</a>. This application builds and installs GNU/Linux binaries for Mac OS X. Homebrew is not directly related to Python; this is a popular Mac OS X developer tool.</p><p>The Homebrew installation is a single line entered in the terminal window:</p><div><pre class="programlisting">
<strong>ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"</strong>
</pre></div><p>This will use the<a id="id340" class="indexterm"/> curl program to download the Homebrew installation kit from GitHub. It will use Ruby to run this installation<a id="id341" class="indexterm"/> program, building the various Homebrew tools and scripts. The Homebrew installation suggests using <code class="literal">brew doctor</code> to check the development environment. There may be some cleanup to do before proceeding.</p><p>The third step is to use the <code class="literal">brew</code> program to install the required additional libraries for Pillow. This command line will handle that:</p><div><pre class="programlisting">
<strong>brew install libtiff libjpeg webp littlecms</strong>
</pre></div><p>Periodically, we may need to upgrade the libraries Homebrew knows about. The command is simply <code class="literal">brew update</code>. We may also need to upgrade the various packages we installed. This is done using <code class="literal">brew upgrade libtiff libjpeg webp littlecms</code>.</p><p>When we've finished the three preliminary steps, we can use the <code class="literal">easy_install-3.3 pillow</code> command. We'll review this in the <em>Installing and confirming pillow</em> section.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec19"/>Windows secrets</h3></div></div></div><p>The Pillow distribution for <a id="id342" class="indexterm"/>Windows contains all the <a id="id343" class="indexterm"/>various libraries prebuilt. The kit will have the following already installed:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>libjpeg</strong></li><li class="listitem" style="list-style-type: disc"><strong>zlib</strong></li><li class="listitem" style="list-style-type: disc"><strong>libtiff</strong></li><li class="listitem" style="list-style-type: disc"><strong>libfreetype</strong></li><li class="listitem" style="list-style-type: disc"><strong>littlecms</strong></li><li class="listitem" style="list-style-type: disc"><strong>libwebp</strong></li></ul></div><p>After the installation is complete, these modules will all be present and used by Pillow.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Installing and confirming Pillow</h2></div></div></div><p>Once all the<a id="id344" class="indexterm"/> required supporting<a id="id345" class="indexterm"/> tools are in place (or you're a Windows agent), the next step is to install Pillow.</p><p>This should amount to the following command:</p><div><pre class="programlisting">
<strong>sudo easy_install-3.3 pillow</strong>
</pre></div><p>Windows agents must omit the <code class="literal">sudo</code> command that prefixes the <code class="literal">easy_install</code> command.</p><p>Part of the output will look something like this (details will vary):</p><div><pre class="programlisting">
<strong>--------------------------------------------------------------------</strong>
<strong>PIL SETUP SUMMARY</strong>
<strong>--------------------------------------------------------------------</strong>
<strong>version      Pillow 2.4.0</strong>
<strong>platform     darwin 3.3.4 (v3.3.4:7ff62415e426, Feb  9 2014, 00:29:34)</strong>
<strong>             [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)]</strong>
<strong>--------------------------------------------------------------------</strong>
<strong>--- TKINTER support available</strong>
<strong>--- JPEG support available</strong>
<strong>*** OPENJPEG (JPEG2000) support not available</strong>
<strong>--- ZLIB (PNG/ZIP) support available</strong>
<strong>--- LIBTIFF support available</strong>
<strong>*** FREETYPE2 support not available</strong>
<strong>*** LITTLECMS2 support not available</strong>
<strong>--- WEBP support available</strong>
<strong>--- WEBPMUX support available</strong>
<strong>--------------------------------------------------------------------</strong>
<strong>To add a missing option, make sure you have the required</strong>
<strong>library, and set the corresponding ROOT variable in the</strong>
<strong>setup.py script.</strong>

<strong>To check the build, run the selftest.py script.</strong>
</pre></div><p>This tells <a id="id346" class="indexterm"/>us that some libraries were not available, and we can't do every kind of processing. If we don't intend to work with JPEG2000 files or do complex color management, this is <a id="id347" class="indexterm"/>acceptable. On the other hand, if we think we're going to do more complex processing, we may need to track down additional modules and redo our Pillow installation.</p><p>The Pillow installation creates PIL. The top-level package will be named <code class="literal">PIL</code>.</p><p>We can test Pillow using it's own internal test script, <code class="literal">PIL.selftest</code>. Otherwise, we can use it like this:</p><div><pre class="programlisting">&gt;&gt;&gt; from PIL import Image</pre></div><p>If this works, then the PIL package is installed. We can then open an image file to see whether things are working properly. The following code shows us that PIL happily opened an image file for us:</p><div><pre class="programlisting">&gt;&gt;&gt; pix= Image.open("1drachmi_1973.jpg")
&gt;&gt;&gt; pix
&lt;PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=198x194 at 0x10183BA90&gt;</pre></div><p>This shows<a id="id348" class="indexterm"/> us that PIL was able<a id="id349" class="indexterm"/> to save the file in a different format:</p><div><pre class="programlisting">&gt;&gt;&gt; pix.save("test.tiff")</pre></div><p>This simple-looking step requires Pillow do a tremendous amount of computation to convert from one format to another.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Decoding and encoding image data</h2></div></div></div><p>Image files are encoded in a form that makes them handy for reading and writing, but not so useful for detailed <a id="id350" class="indexterm"/>processing. We'll need to decode an image from the file format to a useful internal representation. Pillow greatly simplifies the<a id="id351" class="indexterm"/> processes of<a id="id352" class="indexterm"/> decoding and encoding image files. Our general strategy for working with an image file is to start <a id="id353" class="indexterm"/>with the following recipe:</p><div><pre class="programlisting">from PIL import Image
pix= Image.open("LHD_warship.jpg")</pre></div><p>Pillow extracts a number of interesting attributes from the image metadata. There's a complex hierarchy of additional information that comes along with the image. We'll review some of this metadata in detail.</p><p>At the top level, there are some pieces of information that describe some details of the encoding. These are available in a dictionary that is the <code class="literal">info</code> attribute of the <code class="literal">pix</code> object we created. We can use the <code class="literal">keys()</code> method of a dictionary to see what's present in the metadata, as shown in the following snippet:</p><div><pre class="programlisting">&gt;&gt;&gt; pix.info.keys()
dict_keys(['jfif_density', 'icc_profile', 'jfif_version', 'jfif', 'exif', 'jfif_unit', 'dpi'])</pre></div><p>Of these keys, the value mapped to the <code class="literal">exif</code> key is often the most interesting. This is the exchangeable image file format data that provides additional details about the image. The other items are technical details about the image encoding.</p><p>The Exif data isn't automatically decoded by Pillow. We need to use the <code class="literal">_getexif()</code> method to see what's in the <code class="literal">exif</code> key for the image. Note the leading <code class="literal">_</code> sign to this name. This is atypical. This method will give us a dictionary of tags and values. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; exif= pix._getexif()
&gt;&gt;&gt; exif.keys()
dict_keys([36864, 37121, 37378, 36867, 36868, 41989, 40960, 37383, 37385, 37386, 40962, 271, 272, 37521, 37522, 40963, 37396, 41495, 41988, 282, 283, 33434, 37500, 34850, 40961, 34853, 41986, 34855, 296, 34665, 41987, 41990, 42034, 33437, 305, 306, 42035, 42036, 41729])</pre></div><p>This doesn't look too useful. The good news is that the numeric codes are defined in a separate module. We can use a <a id="id354" class="indexterm"/>dictionary lookup to translate<a id="id355" class="indexterm"/> numeric codes to words. Here's an example:</p><div><pre class="programlisting">&gt;&gt;&gt; import PIL.ExifTags
&gt;&gt;&gt; for k, v in pix._getexif().items():
...     print( PIL.ExifTags.TAGS[k], v ) </pre></div><p>This will iterate through the Exif tags and values, translating the tag values to words. Now we<a id="id356" class="indexterm"/> can find the <a id="id357" class="indexterm"/>useful identifying information about the image. The output shows us details like these:</p><div><pre class="programlisting">  Software 7.1.1
  DateTime 2014:05:10 09:59:22
  LensMake Apple
  LensModel iPhone 4 back camera 3.85mm f/2.8</pre></div><p>Of these Exif tags, the number <code class="literal">34853</code>, the <code class="literal">GPSInfo</code> tag form a subdictionary with yet more cryptic numeric keys. This secondary set of numeric codes are defined by the <code class="literal">PIL.ExifTags.GPSTAGS</code> mapping.</p><p>This leads us to something like the following to dump the information for an image:</p><div><pre class="programlisting">    img= Image.open(name)
    print( name, img.format, img.mode, img.size )
    for key in img.info:
        if key == 'exif':
            for k,v in img._getexif().items():
                if k == 34853: # GPSInfo
                    print( " ", PIL.ExifTags.TAGS[k], v )
                    for gk, gv in v.items():
                        print( "  ", PIL.ExifTags.GPSTAGS[gk], gv )
                else:
                    print( " ", PIL.ExifTags.TAGS[k], v )
        elif key == 'icc_profile':
            print( key ) # Skip these details
        else:
            print( key, img.info[key] )</pre></div><p>This will iterate through the top-level <code class="literal">.info</code> dictionary associated with the image. Within this top-level <code class="literal">.info</code> dictionary, if the key is <code class="literal">exif</code>, we'll iterate through the <code class="literal">Exif</code> dictionary items. Within the <code class="literal">Exif</code> dictionary, we'll translate the numeric keys to meaningful strings. If <a id="id358" class="indexterm"/>we find the key, <code class="literal">34853</code> (<code class="literal">GPSInfo</code>), we know that we have another dictionary that is more deeply nested. We'll use another <a id="id359" class="indexterm"/>nested <code class="literal">for</code> loop to iterate through the items of the <code class="literal">GPSInfo</code> dictionary, translating those keys to useful strings.</p><p>We might see this kind of output.</p><div><pre class="programlisting">Common_face_of_one_euro_coin.jpg JPEG RGB (320, 312)
  ExifOffset 26
  ExifImageWidth 320
  ExifImageHeight 312
jfif_version (1, 1)
jfif_unit 0
jfif_density (1, 1)
jfif 257</pre></div><p>In this output, the<a id="id360" class="indexterm"/> Exif data isn't too interesting. The other details don't seem useful either.</p><p>When we<a id="id361" class="indexterm"/> look at a picture that's richly detailed with metadata, there might be over 30 individual pieces of Exif data. For example, here's a section of some Exif data found in one image:</p><div><pre class="programlisting">  DateTimeOriginal 2009:03:18 04:24:24
  DateTimeDigitized 2009:03:18 04:24:24
  SceneCaptureType 0
  MeteringMode 3
  Flash 16
  FocalLength (20, 1)
  ApertureValue (35, 8)
  FocalPlaneXResolution (257877, 53)
  Make Canon
  Model Canon EOS DIGITAL REBEL XSi </pre></div><p>This can tell someone a lot about how the picture was taken.</p><p>When we have pictures taken with modern cameras (such as phone cameras) with GPS data, some additional information is packed into the Exif. For some cameras, we'll find this kind of information as follows:</p><div><pre class="programlisting">   GPSLatitudeRef N
   GPSLatitude ((36, 1), (50, 1), (4012, 100))
   GPSLongitudeRef W
   GPSLongitude ((76, 1), (17, 1), (3521, 100))</pre></div><p>The GPS coordinates from the camera are a little odd looking. We can turn each of these tuple-of-tuples structures into numbers such as 36°50′40.12″N and 76°17′35.21″W. Once we have the location, we can figure out where the picture was taken.</p><p>A quick check on<a id="id362" class="indexterm"/> the nautical chart 12253 shows that the picture was taken from a dock in Norfolk, Virginia. <em>Every secret agent has a set of nautical charts, right? If not, visit</em> <a class="ulink" href="http://www.nauticalcharts.noaa.gov/mcd/Raster/">http://www.nauticalcharts.noaa.gov/mcd/Raster/</a>.</p><p>The ICC profile<a id="id363" class="indexterm"/> shows the details of color and rendering<a id="id364" class="indexterm"/> for the image. For details on the data encoded here, see the applicable specifications from <a class="ulink" href="http://www.color.org/specification/ICC1v43_2010-12.pdf">http://www.color.org/specification/ICC1v43_2010-12.pdf</a>. It's not clear that this information is very helpful for what we're doing.</p><p>What's more<a id="id365" class="indexterm"/> helpful is looking at the picture. LHD 3 painted on the hull seems to be important.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Manipulating images – resizing and thumbnails</h2></div></div></div><p>The Pillow software allows us to perform a number of manipulations on the image. We can, without too much<a id="id366" class="indexterm"/> additional work, resize, crop, rotate, or apply any number of filters to an image.</p><p>The most important <a id="id367" class="indexterm"/>reason for using PIL is that we have a reproducible, automated process. We can find many kinds of manual image manipulation software. The problem with these desktop tools is that a manual sequence of steps is irreproducible. The benefit of using Pillow for this manipulation is we know precisely what we did.</p><p>One common resizing is to create a<a id="id368" class="indexterm"/> thumbnail image from a larger image. Here's how we can create useful thumbnail versions of a collection of images:</p><div><pre class="programlisting">from PIL import Image
import glob
import os

for filename in glob.glob("*.jpg"):
    name, ext = os.path.splitext( filename )
    if name.endswith("_thumb"):
        continue
    img = Image.open( filename )
    thumb= img.copy()
    w, h = img.size
    largest = max(w,h)
    w_n, h_n = w*128//largest, h*128//largest
    print( "Resize", filename, "from", w,h, "to", w_n,h_n )
    thumb.thumbnail( (w_n, h_n), PIL.Image.ANTIALIAS )
    thumb.save( name+"_thumb"+ext )</pre></div><p>We've imported the modules we need: <code class="literal">PIL.Image</code>, <code class="literal">glob</code> and <code class="literal">os</code>. We used <code class="literal">glob.glob("*.jpg")</code> to locate all of the JPEG files in the current working directory. We used <code class="literal">os.path.splitext()</code> to tease apart the base filename and extension. If the filename already ends in <code class="literal">_thumb</code>, we'll continue the <code class="literal">for</code> loop. No more processing will happen for this filename; the <code class="literal">for</code> statement will advance to the next item in the glob sequence.</p><p>We opened the image file and immediately created a copy. This allows us to work with the original image, if we need to, as well as work with the copy.</p><p>We've extracted <a id="id369" class="indexterm"/>the size of the original image and assigned each item of the tuples to two separate variables, <code class="literal">w</code> and <code class="literal">h</code>. We picked the largest of the two dimensions using the <code class="literal">max()</code> function. If the picture was in the landscape mode, the width will be largest; if the picture was in the portrait mode, the height will be largest.</p><p>We've computed<a id="id370" class="indexterm"/>  the size of the thumbnail image, <code class="literal">w_t</code> and <code class="literal">h_t</code>. The pair of calculations will assure that the largest dimension is limited to 128 pixels and the smaller dimension will be scaled proportionally.</p><p>We used the <code class="literal">thumbnail()</code> method of the <code class="literal">thumb</code> object, which is a copy of the original image. We provided a two-tuple with the new dimensions. It's essential that we include <code class="literal">()</code> around <code class="literal">(w_n, h_n)</code> to create a tuple for the first argument value to the <code class="literal">thumbnail()</code> method. We also provided the resample function to use; in this case, we used the <code class="literal">PIL.Image.ANTIALIAS</code> function, as this produces good (but slow) results.</p><p>Here's the thumbnail of our LHD warship:</p><div><img src="img/0420OS_03_01.jpg" alt="Manipulating images – resizing and thumbnails"/></div><p>The image is pretty small. This makes it good for attaching it to an e-mail. However, for more serious intelligence work, we'll need to blow it up, crop it, and enhance it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Manipulating images – cropping</h2></div></div></div><p>When we look at our LHD warship image, we notice that the ship number is almost visible on the bow. We'd like to crop that portion of the image and perhaps, blow it up. Cropping without a visua<a id="id371" class="indexterm"/>l editor involves a certain amount of hit-or-miss processing.</p><p>Even from the command line, we can crop an image interactively by using the <code class="literal">show()</code> method of an image, as shown in the following code:</p><div><pre class="programlisting">&gt;&gt;&gt; from PIL import Image
&gt;&gt;&gt; ship= Image.open( "LHD_warship.jpg" )
&gt;&gt;&gt; ship.size
(2592, 1936)</pre></div><p>We can try different bounding <a id="id372" class="indexterm"/>boxes until we locate the logo. One way to start is to break the image into thirds in each direction; this leads to nine sections, computed via relatively simple rules as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; w, h = ship.size
&gt;&gt;&gt; ship.crop( box=(w//3,0,2*w//3,h//3) ).show()
&gt;&gt;&gt; ship.crop( box=(w//3,h//3,2*w//3,2*h//3) ).show()</pre></div><p>The bounding box for a crop operation requires a four-tuple with the left, top, right, and bottom sides, in that order. The values must be integers and the <code class="literal">()</code> brackets are required to create four-tuple, instead of four separate argument values. The horizontal dividing lines are at <code class="literal">0</code>, <code class="literal">w//3</code>, <code class="literal">2*w//3</code>, and <code class="literal">w</code>. The vertical dividing lines are at <code class="literal">0</code>, <code class="literal">h//3</code>, <code class="literal">2*h//3</code>, and <code class="literal">h</code>. We can use various combinations to locate the various sections of the image and show each section.</p><p>Entering formulae like this is error prone. It's much nicer to work with a bounding box defined by a top-left coordinate pair. We can fiddle in a width and compute the height to maintain the picture's proportions. If we use something like the following, we only have to tweak the <em>x</em> and <em>y</em> coordinates:</p><div><pre class="programlisting">&gt;&gt;&gt; p=h/w
&gt;&gt;&gt; x,y=3*w//12, 3*h//12
&gt;&gt;&gt; ship.crop( box=(x,y,x+600,int(y+600*p)) ).show()
&gt;&gt;&gt; x,y=3*w//12, 5*h//12
&gt;&gt;&gt; ship.crop( box=(x,y,x+600,int(y+600*p)) ).show()</pre></div><p>We can fiddle with the <code class="literal">x</code> and <code class="literal">y</code> values. Then we can use the up arrow key to fetch the <code class="literal">ship.crop().show()</code> line back again. This allows us to step through the image manually, just changing <code class="literal">x</code> and <code class="literal">y</code>.</p><p>We can do a little better at generalizing the bounding boxes of image sections. Consider this list of fractions:</p><div><pre class="programlisting">&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; slices = 6
&gt;&gt;&gt; box = [ Fraction(i,slices) for i in range(slices+1) ]
&gt;&gt;&gt; box
[Fraction(0, 1), Fraction(1, 6), Fraction(1, 3), Fraction(1, 2), Fraction(2, 3), Fraction(5, 6), Fraction(1, 1)]</pre></div><p>We have defined the<a id="id373" class="indexterm"/> number of slices we want to make. In this case, we'll divide the image into 1/6, giving us 36 individual boxes. We then computed the <code class="literal">slice+1</code> lines at positions between <img src="img/0420OS_03_13.jpg" alt="Manipulating images – cropping"/> and <img src="img/0420OS_03_14.jpg" alt="Manipulating images – cropping"/>. Here is an illustration that<a id="id374" class="indexterm"/> shows the slicing of the image into a 6 x 6 grid. Each cell has a boundary defined by the <code class="literal">box</code> sequence:</p><div><img src="img/0420OS_03_06.jpg" alt="Manipulating images – cropping"/></div><p>This uses the following pair of nested <code class="literal">for</code> loops with the <code class="literal">box</code> fractions to generate the individual boundaries for various pieces of the image:</p><div><pre class="programlisting">for i in range(slices):
    for j in range(slices):
       bounds = int(w*box[i]), int(h*box[j]), int(w*box[i+1]), int(h*box[j+1])</pre></div><p>Each boundary box has the left, top, right, and bottom side as a four-tuple. We've picked values of two variables to enumerate all 36 combinations from (0,0) to (5,5). We've picked two adjacent values from our list of fractions, <code class="literal">lines</code>. This will give us all 36 bounding boxes from top-left to bottom-right.</p><p>We can then crop our original image using each of these definitions of box and show all 36 slices, looking for the one that's closest to the subject matter we're looking for. Also, we might want to resize each image and make it twice as big.</p><p>We can use the following to show each box:</p><div><pre class="programlisting">print( bounds )
ship.crop( bounds ).show() </pre></div><p>This will display<a id="id375" class="indexterm"/> the original image cropped to each of the slices. The <code class="literal">bounds</code> object is a four-tuple with the boundary information.</p><p>We can slightly<a id="id376" class="indexterm"/> optimize the expression that computes the bounds using the <code class="literal">map()</code> function:</p><div><pre class="programlisting">bounds = map( int, (w*box[i], h*box[j], w*box[i+1], h*box[j+1]) )</pre></div><p>The <code class="literal">map()</code> function will apply a function to each element of the associated collection. In this example, we apply the <code class="literal">int()</code> function to each value of the bounding box. It turns out that this is the image we want:</p><div><pre class="programlisting">slices = 12
box = [ Fraction(i,slices) for i in range(slices+1) ]
bounds = map( int, (w*box[3], h*box[6], w*box[5], h*box[7]) )
logo= ship.crop( bounds )
logo.show()
logo.save( "LHD_number.jpg" )</pre></div><p>We've cropped the image using two adjacent boxes. The boxes at (3,6) and (4,6) incorporate the ship's identification number nicely. We created a single four-tuple with the combined bounding box and cropped the original image to pick up just the logo. We used the <code class="literal">show()</code> method of the <code class="literal">logo</code> object, which will pop up an image viewer. We also saved it so that we'd have a file we could work with later.</p><p>We might want to resize the cropped image. We can use code like this to blow up the image:</p><div><pre class="programlisting">w,h= logo.size
logo.resize( (w*3,h*3) )</pre></div><p>This will use the original size as a basis so that the expanded image retains the original proportions. As with other operations, the size is given as a tuple and the inner <code class="literal">()</code> brackets are required to define a tuple. Without the inner <code class="literal">()</code> brackets, these would be two separate argument values.</p><p>Here's the cropped image:</p><div><img src="img/0420OS_03_02.jpg" alt="Manipulating images – cropping"/></div><p>That's kind of <a id="id377" class="indexterm"/>murky and hard to work with. We'll need to enhance it.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Manipulating images – enhancing</h2></div></div></div><p>The original picture is pretty grainy. We'd like to enhance the details of the slice we found. Pillow has a number of filters than can help modify an image. Unlike popular TV shows and movies, there's no <a id="id378" class="indexterm"/>enhance feature that magically makes a poor image spectacular.</p><p>We can modify<a id="id379" class="indexterm"/> an image, and sometimes, it's more usable. We can also modify an image and leave it no better than we found it. The third choice—not often available to secret agents—is that we might make the results more artistic than the original image.</p><p>We have three modules in the Pillow package that contain filter-like processing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ImageEnhance</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageFilter</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ImageOps</code></li></ul></div><p>The <code class="literal">ImageEnhance</code> module<a id="id380" class="indexterm"/> contains <code class="literal">enhance</code> class definitions. We create an enhancer object by binding an enhancer and an image. We then use that bound <a id="id381" class="indexterm"/>object to create enhanced versions of a given image. An enhancer allows us to make many incremental changes to an image. We can think of these as simple knobs, which might be turned to tweak the image.</p><p>The <code class="literal">ImageFilter</code> module <a id="id382" class="indexterm"/>contains filters functions that will revise the image, creating a new image object that we might save. These various kinds of filter<a id="id383" class="indexterm"/> objects are plugged into the image's <code class="literal">filter()</code> method. A filter can be imagined as a way to reduce the volume of information in the image; the image is usually simpler after being filtered.</p><p>The <code class="literal">ImageOps</code> module contains functions that transform one image to create a new image. These<a id="id384" class="indexterm"/> are different from filtering and enhancing. They're not<a id="id385" class="indexterm"/> necessarily reducing the data nor are they simple knobs to tweak an image. The <code class="literal">ImageOps</code> module tends to perform more complex transformations.</p><p>We'll start out with some <a id="id386" class="indexterm"/>simple enhancers in the <code class="literal">PIL.ImageEnhance</code> module, specifically, the <code class="literal">Contrast</code> class. We won't present each individual class; the more systematic<a id="id387" class="indexterm"/> exploration is for field agents.</p><p>We'll start with one of the four enhancers: the <code class="literal">Contrast</code> class. Here's how we can use it:</p><div><pre class="programlisting">&gt;&gt;&gt; from PIL import ImageEnhance
&gt;&gt;&gt; e= ImageEnhance.Contrast(logo)
&gt;&gt;&gt; e.enhance(2.0).show()
&gt;&gt;&gt; e.enhance(4.0).show()
&gt;&gt;&gt; e.enhance(8.0).show()</pre></div><p>This builds an enhancer, based on the specific algorithm and the image we're working with. We've assigned this enhancer to the <code class="literal">e</code> variable. We then performed an <code class="literal">enhance</code> operation with a specific parameter value and showed the resulting image.</p><p>The last image is pretty nice. We can save a copy of this image with <code class="literal">e.enhance(8.0).save( "LHD_Number_1.jpg" )</code>.</p><p>Here's how the logo looks with the <code class="literal">Contrast</code> enhancement set to <code class="literal">8</code>:</p><div><img src="img/0420OS_03_03.jpg" alt="Manipulating images – enhancing"/></div><p>Someone might be able to work with this image. As a field agent, you'll need to experiment with the other three enhancement filters: color, brightness, and sharpness. You might be able to extract even more detail from the image.</p><p>This is the first step in defining a reproducible, automated process. Using Python from the command line means that we have a record of precisely what we did. We can reduce the process to an automated script.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Manipulating images – filtering</h2></div></div></div><p>We've<a id="id388" class="indexterm"/> looked at the <code class="literal">ImageEnhance</code> module to improve an image. We can also filter via the image's <code class="literal">filter()</code> method. The <code class="literal">ImageFilter</code> module defines 18 different<a id="id389" class="indexterm"/> filters. When we use a filter, we'll provide the filter <a id="id390" class="indexterm"/>object to the <code class="literal">Image.filter()</code> method.</p><p>We'll pick just one of these filters. The <code class="literal">ImageFilter.EDGE_ENHANCE</code> module seems to be helpful for<a id="id391" class="indexterm"/> distinguishing between the light-colored letter and the dark-colored background. Emphasizing on the transition in color might make the letters more visible.</p><p>Here's an example of using the <code class="literal">ImageFilter.EDGE_ENHANCE</code> filter in the <code class="literal">filter()</code> method of an image:</p><div><pre class="programlisting">&gt;&gt;&gt; from PIL import ImageFilter
&gt;&gt;&gt; logo.filter( ImageFilter.EDGE_ENHANCE ).show()</pre></div><p>We've used the <code class="literal">filter</code> method to create and show a new image.</p><p>While this is good, it seems like our enhancement attempts might work better with the <code class="literal">ImageEnhance.Contrast</code> class we used earlier. Here's how we can apply a sequence of transformations.</p><p>The following code applies the specific filter to the image and creates a new image:</p><div><pre class="programlisting">&gt;&gt;&gt; e.enhance(8.0).filter( ImageFilter.EDGE_ENHANCE ).save( "LHD_Number_2.jpg" )</pre></div><p>We've created an enhanced image and then applied a filter to it. This creates something even more crisp and possibly more usable than the original image.</p><p>This is our filtered and enhanced image:</p><div><img src="img/0420OS_03_04.jpg" alt="Manipulating images – filtering"/></div><p>The filter has made some minor changes to the previously saved image. The edge on the lower loop of <code class="literal">3</code> might be a bit more crisp. We'll need to change some more things.</p><p>Some filters (such as the <code class="literal">EDGE_ENHANCE</code> object) have no parameters or options. Other filters have parameters<a id="id392" class="indexterm"/> that can be applied to change the way they work. For example, the <code class="literal">ModeFilter()</code> will reduce a given section of the image to the most common color value within that section; we<a id="id393" class="indexterm"/> provide a parameter for the number of pixels to consider when computing the mode.</p><p>Here's an example of combining several operations to create a new image:</p><div><pre class="programlisting">&gt;&gt;&gt; p1= e.enhance(8.0).filter( ImageFilter.ModeFilter(8) )
&gt;&gt;&gt; p1.filter( ImageFilter.EDGE_ENHANCE ).show()</pre></div><p>This seems to be<a id="id394" class="indexterm"/> tending towards art and away from proper intelligence gathering. However, a good field agent will work with some additional filters and filter parameters to look for better enhancement techniques.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Manipulating images – ImageOps</h2></div></div></div><p>We've looked at the <code class="literal">ImageEnhance</code> module to improve an image. We've also looked at a few other filters in the <code class="literal">ImageFilter</code> module. The <code class="literal">ImageOps</code> module provides 13 additional<a id="id395" class="indexterm"/> transformations that we can use to improve our image.</p><p>We'll look at the <code class="literal">ImageOps.autocontrast()</code> function, as shown in the following snippet. This will adjust the various pixels so that the brightness levels fill the entire 8-bit space from 0 to 255. An<a id="id396" class="indexterm"/> image that's dark or washed out lacks contrast, and the pixels are all piled up at the dark end or the bright end of the spectrum.</p><div><pre class="programlisting">&gt;&gt;&gt; from PIL import ImageOps
&gt;&gt;&gt; ImageOps.autocontrast( logo ).show()
&gt;&gt;&gt; logo.show()</pre></div><p>This shows an image with <code class="literal">autocontrast</code> applied and the original image. This shows the striking difference between the original clipping and an image that uses the full range from dark to light. That seems to be just what HQ would want.</p><p>Let's tweak the contrast a little further to really make the numbers stand out:</p><div><pre class="programlisting">&gt;&gt;&gt; ac= ImageEnhance.Contrast( ImageOps.autocontrast( logo ) )
&gt;&gt;&gt; ac.enhance( 2.5 ).save( "LHD_Number_3.jpg" )</pre></div><p>This seems to be the most startling enhancement we can do:</p><div><img src="img/0420OS_03_05.jpg" alt="Manipulating images – ImageOps"/></div><p>This might be good enough. A competent field agent should play with the rest of the <code class="literal">ImageOps</code> transformations to see whether more improvement is possible.</p><p>At this point, we have<a id="id397" class="indexterm"/> the outline for a reproducible, automated process. We know<a id="id398" class="indexterm"/> precisely what we did to enhance the image. We can use our series of experiments to create an automated script for image enhancement.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Some approaches to steganography</h1></div></div></div><p>There are many more things we can do with image files. One thing we can do is use steganography to<a id="id399" class="indexterm"/> conceal messages inside image files. As image files are large, complex, and relatively noisy, adding a few extra bits of data won't make much of a visible change to the image or the file.</p><p>Sometimes this is summarized as adding a<a id="id400" class="indexterm"/> <strong>digital watermark</strong> to an image. We're going to subtly alter the image in a way that we can recognize and recover it later.</p><p>Adding a message can be seen as a lossy modification to the image. Some of the original pixels will be unrecoverable. As the JPEG compression, in general, already involves minor losses, tweaking the image as part of steganography will be a similar level of image corruption.</p><p>Speaking of losses, the JPEG format can, and will, tweak some of the bits in our image. Consequently, it's difficult to perform steganography with JPEG. Rather than wrestle with JPEG details, we'll use the TIFF format for our concealed messages.</p><p>There are two common approaches to concealing a message in an image:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Using a color channel</strong>: If we <a id="id401" class="indexterm"/>overwrite some bytes in just<a id="id402" class="indexterm"/> one color channel, we'll be shifting a part of the color of a few pixels in the area we overwrote. It will only be a few of millions of pixels, and it will only be one of the three (or four) colors. If we confine the tweaking to the edge, it's not too noticeable.</li><li class="listitem" style="list-style-type: disc"><strong>Using the least significant bits (LSBs) of each byte</strong>: If we overwrite the least significant bit in a series of bytes, we'll make an extremely minor shift in the image. We have<a id="id403" class="indexterm"/> to limit the size of our message because we can only encode one byte per pixel. A small picture that's <em>432 * 161 = 69,552</em> pixels can encode 8,694 bytes of data. If we<a id="id404" class="indexterm"/> use the UTF-8 encoding for our characters, we should be able to cram an 8 K message into that image. If we use UTF-16, we'd only get a 4 K message. This technique works even for grayscale images where there's only one channel.</li></ul></div><p>In addition to the JPEG compression problem, there are some color encoding schemes that don't work out well with either of these steganography approaches. The modes, known as <strong>P</strong>, <strong>I</strong>, and <strong>F</strong>, present a bit of a problem. These color modes involve mapping a color code to a palette. In these cases, the byte is not the level of gray or the level of a color; when using a palette, the bytes are a reference to a color. Making a 1-bit change might lead to a profound change in the color selected from the underlying palette. The color <code class="literal">5</code> might be a pleasant sea-foam green, the color <code class="literal">4</code> might be an awful magenta. A 1-bit change between <code class="literal">5</code> and <code class="literal">4</code> may be a noticeable out-of-place dot.</p><p>For our purposes, we can switch the source image to RGB (or CMYK) before applying our steganography encoding. The basic change to the color mode might be visible to someone who had access to the original image. However, the hidden message will remain obscured unless they also know our steganography algorithm.</p><p>Our strategy works like this:</p><div><ol class="orderedlist arabic"><li class="listitem">Get the bytes from the pixels of the image.</li><li class="listitem">Transform our secret message from a Unicode string into a sequence of bits.</li><li class="listitem">For each bit of our secret message, adulterate 1 byte of the original image. As we're tweaking the least significant bit, one of two things will happen.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We'll make an image pixel value into an even number to encode a 0 bit from our secret message</li><li class="listitem" style="list-style-type: disc">We'll make an image pixel value into an odd number to encode a 1 bit from our secret message</li></ul></div></li></ol></div><p>We'll work with two parallel sequences of values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The bytes from the image (ideally enough to encode our entire message)</li><li class="listitem" style="list-style-type: disc">The bits from our secret message</li></ul></div><p>The idea is to step through each byte of the image and incorporate 1 bit of the secret message into that image byte. The cool feature of this is that some pixel values might not need to actually change. If we're encoding a byte in a pixel that's already odd, we won't change the image at all.</p><p>This means that we need to perform the following important steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get the bytes in the red channel of the image</li><li class="listitem" style="list-style-type: disc">Get the bytes from a Unicode message</li><li class="listitem" style="list-style-type: disc">Get the bits from the message bytes</li><li class="listitem" style="list-style-type: disc">Tweak the image pixel byte using a message bit, and update the image</li></ul></div><p>We'll tackle these one at a time, then we'll weld it all together at the end.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Getting the red-channel data</h2></div></div></div><p>Let's look at encoding<a id="id405" class="indexterm"/> our message in an image using the red channel LSB encoding. Why red? Why not? Men may have some degree of red-green color blindness; if they're less likely to see a shift in this channel, then<a id="id406" class="indexterm"/> we've further concealed our image from a few prying eyes.</p><p>The first question is this: how do we tinker with the bytes of the original image?</p><p>The PIL <code class="literal">Image</code> object has the <code class="literal">getpixel()</code> and <code class="literal">putpixel()</code> methods that allow us to get the various color band values.</p><p>We can peel out individual pixels from the image like this:</p><div><pre class="programlisting">&gt;&gt;&gt; y = 0
&gt;&gt;&gt; for x in range(64):
...     print(ship.getpixel( (x,y) ))
... 
(234, 244, 243)
(234, 244, 243)
(233, 243, 242)
(233, 243, 242)
etc.</pre></div><p>We've provided an <code class="literal">(x,y)</code> two-tuple to the <code class="literal">getpixel()</code> method. This shows us that each pixel in the image is a three-tuple. It's not obvious what the three numbers are. We can use <code class="literal">ship.getbands()</code> to get this information, as shown in the following snippet:</p><div><pre class="programlisting">&gt;&gt;&gt; ship.getbands() 
('R', 'G', 'B')</pre></div><p>There was little doubt in our minds that the three pixel values were red level, green level, and blue level. We've used the <code class="literal">getband()</code> method to get confirmation from Pillow that our assumption about the image encoding band was correct.</p><p>We now have access to the individual bytes of the image. The next steps are to get the bits from our secret message and then adulterate the image bytes with our secret message bits.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Extracting bytes from Unicode characters</h2></div></div></div><p>In order to encode our secret message into the bytes of an image, we'll need to transform our Unicode message into bytes. Once we have some bytes, we can then make one more transformation to<a id="id407" class="indexterm"/> get a sequence of bits.</p><p>The second question, is how do we get the individual bits of the message text? Another form of this question<a id="id408" class="indexterm"/> is, how do we turn a string of Unicode characters into a string of individual bits?</p><p>Here's a Unicode string we can work with: <a class="ulink" href="http://www.kearsarge.navy.mil">http://www.kearsarge.navy.mil</a>. We'll break the<a id="id409" class="indexterm"/> transformation into two steps: first to bytes and then to bits. There are a number of ways to encode strings as bytes. We'll use the UTF-8 encoding as that's very popular:</p><div><pre class="programlisting">&gt;&gt;&gt; message="http://www.kearsarge.navy.mil"
&gt;&gt;&gt; message.encode("UTF-8")
b'http://www.kearsarge.navy.mil'</pre></div><p>It doesn't look like too much happened there. This is because the UTF-8 encoding happens to match the ASCII encoding that Python byte literals use. This means that the bytes version of a string, which happens to use only US-ASCII characters, will look very much like the original Python string. The presence of special <code class="literal">b' '</code> quotes is the hint that the string is only bytes, not full Unicode characters.</p><p>If we had some non-ASCII Unicode characters in our string, then the UTF-8 encoding would become quite a bit more complex.</p><p>Just for reference, here's the UTF-16 encoding of our message:</p><div><pre class="programlisting">&gt;&gt;&gt; message.encode("UTF-16")
b'\xff\xfeh\x00t\x00t\x00p\x00:\x00/\x00/\x00w\x00w\x00w\x00.\x00k\x00e\x00a\x00r
\x00s\x00a\x00r\x00g\x00e\x00.\x00n\x00a\x00v\x00y\x00.\x00m\x00i\x00l\x00'</pre></div><p>The previous encoded message looks to be a proper mess. As expected, it's close to twice as big as UTF-8.</p><p>Here's another view of the individual bytes in the message:</p><div><pre class="programlisting">&gt;&gt;&gt; [ hex(c) for c in message.encode("UTF-8") ]
['0x68', '0x74', '0x74', '0x70', '0x3a', '0x2f', '0x2f', '0x77', '0x77', '0x77', '0x2e', '0x6b', '0x65', '0x61', '0x72', '0x73', '0x61', '0x72', '0x67', '0x65', '0x2e', '0x6e', '0x61', '0x76', '0x79', '0x2e', '0x6d', '0x69', '0x6c']</pre></div><p>We've used a generator expression to apply the <code class="literal">hex()</code> function to each byte. This gives us a hint as to how <a id="id410" class="indexterm"/>we're going to<a id="id411" class="indexterm"/> proceed. Our message was<a id="id412" class="indexterm"/> transformed into 29 bytes, which is 232 bits; we want to put these bits into the first 232 pixels of our image.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>Manipulating bits and bytes</h2></div></div></div><p>As we'll be fiddling with individual bits, we need to know how to transform a Python byte into a tuple of 8 bits. The inverse<a id="id413" class="indexterm"/> is a technique to transform an 8-bit tuple back into a single byte. If we expand each byte into<a id="id414" class="indexterm"/> an eight-tuple, we can easily adjust the bits and confirm that we're doing the right thing.</p><p>We'll need some<a id="id415" class="indexterm"/> functions to expand a list of byte into bits and contract the bits back to the original list of bytes. Then, we can<a id="id416" class="indexterm"/> apply these functions to our sequence of bytes to create the sequence of individual bits.</p><p>The essential computer science is explained next:</p><p>A number, <img src="img/0420OS_03_07.jpg" alt="Manipulating bits and bytes"/>, is a polynomial in some particular base. Here's the polynomial for the value of 234 with base 10:</p><div><img src="img/0420OS_03_08.jpg" alt="Manipulating bits and bytes"/></div><p>In base 16, we have <img src="img/0420OS_03_09.jpg" alt="Manipulating bits and bytes"/>. When writing hex, we use letters for the 14 and 10 digits: <code class="literal">0xea</code>.</p><p>This kind of polynomial representation is true in base 2. A number, <img src="img/0420OS_03_07.jpg" alt="Manipulating bits and bytes"/>, is a polynomial in base 2. Here's the polynomial for the value of 234:</p><div><img src="img/0420OS_03_10.jpg" alt="Manipulating bits and bytes"/></div><p>Here's a way to extract the lower 8 bits from a numeric value:</p><div><pre class="programlisting">def to_bits( v ):
    b= []
    for i in range(8):
        b.append( v &amp; 1 )
        v &gt;&gt;= 1
    return tuple(reversed(b))</pre></div><p>The <code class="literal">v&amp;1</code> expression applies a bitwise operation to extract the rightmost bit of a number. We'll append the calculated bit value to the <code class="literal">b</code> variable. The <code class="literal">v &gt;&gt;= 1</code> statement is the same as <code class="literal">v = v&gt;&gt;1</code>; the <code class="literal">v&gt;&gt;1</code> expression will shift the value, <code class="literal">v</code>, one bit to the right. After doing this eight times, we've extracted the lowest bits of the <code class="literal">v</code> value. We've assembled this sequence <a id="id417" class="indexterm"/>of bits in a list object, <code class="literal">b</code>.</p><p>The results are<a id="id418" class="indexterm"/> accumulated in the <em>wrong</em> order, so we reverse them and create a tidy little eight-tuple object. We can compare this with the built-in <code class="literal">bin()</code> function:</p><div><pre class="programlisting">&gt;&gt;&gt; to_bits(234)
(1, 1, 1, 0, 1, 0, 1, 0)
&gt;&gt;&gt; bin(234)
'0b11101010'</pre></div><p>For a value<a id="id419" class="indexterm"/> over 127, both the <code class="literal">bin()</code> and <code class="literal">to_bits()</code> functions produce 8-bit results. For smaller values, we'll see that the <code class="literal">bin()</code> function doesn't produce 8 bits; it produces just enough bits.</p><p>The opposite transformation<a id="id420" class="indexterm"/> evaluates the polynomial. We can do a little algebra to optimize the number of multiplications:</p><div><img src="img/0420OS_03_11.jpg" alt="Manipulating bits and bytes"/></div><p>Because of the grouping, the leftmost 1 winds up multiplied by <img src="img/0420OS_03_12.jpg" alt="Manipulating bits and bytes"/>. As shifting bits to the left is the same as multiplying by 2, we can reconstruct the a byte value from a tuple of bits as follows:</p><div><pre class="programlisting">def to_byte( b ):
    v= 0
    for bit in b:
        v = (v&lt;&lt;1)|bit
    return v</pre></div><p>The <code class="literal">(v&lt;&lt;1)|bit</code> expression will shift <code class="literal">v</code> to the left 1 bit, effectively performing a <code class="literal">*2</code> operation. An <code class="literal">OR</code> operation will fold the next bit into the value being accumulated.</p><p>We can test these two functions with a loop like this:</p><div><pre class="programlisting">for test in range(256):
    b = to_bits(test)
    v = to_byte(b)
    assert v == test</pre></div><p>If all 256 byte values are converted to bits and back to bytes, we are absolutely sure that we can convert bytes to bits. We can use this to see the expansion of our message:</p><div><pre class="programlisting">message_bytes = message.encode("UTF-8")
print( list(to_bits(c) for c in message_bytes) )</pre></div><p>This will show us a big list of 8-tuples:</p><div><pre class="programlisting">[(1, 1, 1, 1, 1, 1, 1, 1), (1, 1, 1, 1, 1, 1, 1, 0), 
(0, 1, 1, 0, 1, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0),
  ...
(0, 1, 1, 0, 1, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0)]</pre></div><p>Each<a id="id421" class="indexterm"/> byte of the <a id="id422" class="indexterm"/>secret message has become<a id="id423" class="indexterm"/> an eight-tuple<a id="id424" class="indexterm"/> of individual bits.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>Assembling the bits</h2></div></div></div><p>At this point, we've got two <a id="id425" class="indexterm"/>parallel sequences of values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The bytes<a id="id426" class="indexterm"/> from the image (ideally enough to encode our entire message)</li><li class="listitem" style="list-style-type: disc">The bits from our secret message (in the example, we've got just 29 bytes, which is 232 bits)</li></ul></div><p>The idea is to step through each byte of the image and incorporate one bit of the secret message into that byte.</p><p>Before we can fully tweak the various image bytes with our message bits, we need to assemble a long sequence of individual bits. We have two choices to do this. We can create a <code class="literal">list</code> object with all of the bit values. This wastes a bit of memory, and we can do better.</p><p>We can also create a generator function that will appear to be a <code class="literal">sequence</code> object with all of the bits.</p><p>Here's a generator function that we can use to emit the entire sequence of bits from the message:</p><div><pre class="programlisting">def bit_sequence( list_of_tuples ):
    for t8 in list_of_tuples:
        for b in t8:
            yield b</pre></div><p>We've stepped through each individual eight-tuple in the list-of-tuples values that can be created by our <code class="literal">to_bits()</code> function. For each bit in the 8-tuple, we've used the <code class="literal">yield</code> statement to provide the individual bit values. Any expression or statement that expects an iterable sequence will be able to use this function.</p><p>Here's how we can use this to accumulate a sequence of all 232 bits from a message:</p><div><pre class="programlisting">print( list( bit_sequence(
    (to_bits(c) for c in message_bytes)
) ) )</pre></div><p>This will apply the <code class="literal">to_bits()</code> function to each byte of the message, creating a sequence of 8-tuples. Then it will apply the <code class="literal">bit_sequence()</code> generator to that sequence of eight-tuples. The output<a id="id427" class="indexterm"/> is a sequence of individual bits, which we collected into a <code class="literal">list</code> object. The resulting list looks like this:</p><div><pre class="programlisting">[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 
0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
... 
0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</pre></div><p>We can see the list of 232 individual bits built from our original message.</p><p>Here's the<a id="id428" class="indexterm"/> inverse to the <code class="literal">bit_sequence()</code> function. This will group a sequence of bits into eight-tuples:</p><div><pre class="programlisting">def byte_sequence( bits ):
    byte= []
    for n, b in enumerate(bits):
        if n%8 == 0 and n != 0:
            yield to_byte(byte)
            byte= []
        byte.append( b )
    yield to_byte(byte)</pre></div><p>We've used the built-in <code class="literal">enumerate()</code> generator <a id="id429" class="indexterm"/>function to provide a number for each individual bit in the original sequence. The output from the <code class="literal">enumerate(bits)</code> expression is a sequence of two-tuples; each two-tuple has the enumerated bit number (from <code class="literal">0</code> to <code class="literal">231</code>) and the bit value itself (<code class="literal">0</code> or <code class="literal">1</code>).</p><p>When the bit number is a multiple of <code class="literal">8</code> (<code class="literal">n%8 == 0</code>), we've seen a complete batch of eight bits. We can convert these eight bits to a byte with <code class="literal">to_byte()</code>, yield the byte value, and reset our temporary accumulator, <code class="literal">byte</code>, to be empty.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>We've made a special exception for the very first byte.</p></div></div><p>The <code class="literal">enumerate()</code> function will assign the very first byte number <code class="literal">0</code>; since <code class="literal">0%8 == 0</code>, it looks like we've just accumulated eight bits to make a byte. We've avoided this complication by assuring that <code class="literal">n</code> is not 0; it's not the first bit value. We could also have used the <code class="literal">len(byte) != 0</code> expression to avoid the first-time complication.</p><p>The final <code class="literal">yield</code> statement is critical for success. The final batch of bits will have <code class="literal">n%8</code> values of <code class="literal">0</code> to <code class="literal">7</code>. The <code class="literal">n%8</code> test won't be used when the collection of bits is exhausted, but we'll still have eight bits accumulated in the <code class="literal">byte</code> variable. We yield this final batch of eight bits as an extra step.</p><p>Here's what it looks like:</p><div><pre class="programlisting">&gt;&gt;&gt; list(byte_sequence(bits))
[255, 254, 104, 0, 116, 0, 116, 0, 112, 0, 58, 0, 47, 0, 47, 0, 119, 0, 119, 0, 119, 0, 46, 0, 107, 0, 101, 0, 97, 0, 114, 0, 115, 0, 97, 0, 114, 0, 103, 0, 101, 0, 46, 0, 110, 0, 97, 0, 118, 0, 121, 0, 46, 0, 109, 0, 105, 0, 108, 0]</pre></div><p>We've taken the<a id="id430" class="indexterm"/> sequence of individual bits and collected each batch of eight bits into bytes.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Encoding the message</h2></div></div></div><p>Now that we can<a id="id431" class="indexterm"/> transform any Unicode string into bits, we can encode a message into an image. The final nuance is how to delimit the message. We don't want to accidentally decode each byte in the<a id="id432" class="indexterm"/> entire image. If we did this, our message will be padded with random characters. We need to know when to stop decoding.</p><p>One common technique is to include a terminator character. Another common technique is to provide a length in front of the string. We're going to include a length in front of the string so that we aren't constrained by the contents of the string or the encoded bytes that are produced from that string.</p><p>We'll use a 2-byte length in front of the string; we can encode it into bytes and bits like this:</p><div><pre class="programlisting">len_H, len_L = divmod( len(message), 256 )
size = [to_bits(len_H), to_bits(len_L)]</pre></div><p>We've used the Python <code class="literal">divmod()</code> function to compute the quotient and remainder after division. The results of the <code class="literal">divmod( len(message), 256 )</code> expression will be <code class="literal">len(message)//256</code> and <code class="literal">len(message)%256</code>. We can recover the original value from the <code class="literal">len_H*256+len_L</code> expression.</p><p>The <code class="literal">size</code> variable is set to a short sequence composed of two eight-tuples built from the <code class="literal">len_H</code> and <code class="literal">len_L</code> values.</p><p>The complete sequence of bytes, including the length, looks like this:</p><div><pre class="programlisting">message_bytes= message.encode("UTF-8")
bits_list = list(to_bits(c) for c in message_bytes )
len_h, len_l = divmod( len(message_bytes), 256 )
size_list = [to_bits(len_h), to_bits(len_l)]
bit_sequence( size_list+bits_list ) </pre></div><p>First, we encoded the message into bytes. Depending on the Unicode characters involved and the encoding used, this may be longer than the original message. The <code class="literal">bits_list</code> variable is a sequence of eight-tuples built from the various bytes of the encoded message.</p><p>Then, we created two more<a id="id433" class="indexterm"/> bytes with the length information and converted them to bits. The <code class="literal">size_list</code> variable is a sequence of eight-tuples built from the bytes of the encoded size.</p><p>The <code class="literal">size_list+bits_list</code> expression shows how to concatenate the two sequences to create a long sequence of individual bits that we can embed into our image.</p><p>Here's how we use<a id="id434" class="indexterm"/> the <code class="literal">putpixel()</code> and <code class="literal">getpixel()</code> methods to update the image:</p><div><pre class="programlisting">w, h = ship.size
for p,m in enumerate( bit_sequence(size_list+bits_list) ):
    y, x = divmod( p, w )
    r, g, b = ship.getpixel( (x,y) )
    <strong>r_new = (r &amp; 0xfe) | m</strong>
    print( (r, g, b), m, (r_new, g, b) )
    ship.putpixel( (x,y), (r_new, g, b)  )</pre></div><p>We've extracted the size of the original image; this tells us how long the <em>x</em> axis is so that we can use multiple rows of the image if necessary. If our image only has 128 pixels on a row, we'll need more than one row for a 292-bit message.</p><p>We've applied the <code class="literal">enumerate()</code> function to the <code class="literal">bit_sequence(size_list+bits_list)</code> value. This will provide both a sequence number and an individual bit from the original message. The sequence number can be converted to a row and column using the <code class="literal">divmod()</code> function. We'll set <code class="literal">y</code> to <code class="literal">sequence // width</code>; we'll set <code class="literal">x</code> to <code class="literal">sequence % width</code>.</p><p>If we use the thumbnail image, which is 128-pixels wide, the first 128 bits go to row <code class="literal">0</code>. The next 128 bits go to row <code class="literal">1</code>. The balance of the 292 bits will wind up on row <code class="literal">3</code>.</p><p>We got the RGB values from the pixel using <code class="literal">ship.getpixel( (x,y) )</code>.</p><p>We've highlighted the bit-fiddling part: <code class="literal">r_new = (r &amp; 0xfe) | m</code>. This uses a <a id="id435" class="indexterm"/>
<strong>mask</strong> value of <code class="literal">0xfe</code>, which is <code class="literal">0b11111110</code>. This works because the <code class="literal">&amp;</code> operator has a handy feature. When we use <code class="literal">b&amp;1</code>, the value of <code class="literal">b</code> is preserved. When we use <code class="literal">b&amp;0</code>, the result is <code class="literal">0</code>.</p><p>Try it, as shown in the following code:</p><div><pre class="programlisting">&gt;&gt;&gt; 1 &amp; 1
1
&gt;&gt;&gt; 0 &amp; 1
0</pre></div><p>The value of <code class="literal">b</code> (either <code class="literal">1</code> or <code class="literal">0</code>) was preserved. Similarly, <code class="literal">1 &amp; 0</code> and <code class="literal">0 &amp; 0</code> are both <code class="literal">0</code>.</p><p>Using a mask value in <code class="literal">(r &amp; 0xfe)</code> means that the leftmost seven bits of <code class="literal">r</code> will be preserved; the<a id="id436" class="indexterm"/> rightmost bit will be set to <code class="literal">0</code>. When we use <code class="literal">(r &amp; 0xfe) | m</code>, we'll be folding the value of <code class="literal">m</code> into the rightmost position. We've printed out the old and new pixel values to provide some details on how this works. Here are two rows from the output:</p><div><pre class="programlisting">(245, 247, 246) 0 (244, 247, 246)
(246, 248, 247) 1 (247, 248, 247)</pre></div><p>We can see that the old value of the red channel was <code class="literal">245</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; 245 &amp; 0xfe
244
&gt;&gt;&gt; (245 &amp; 0xfe) | 0
244</pre></div><p>The value <code class="literal">244</code> shows how the rightmost bit was removed from <code class="literal">245</code>. When we fold in a new bit value <code class="literal">0</code>, the result<a id="id437" class="indexterm"/> remains <code class="literal">244</code>. An even value encodes a 0 bit from our secret message.</p><p>In this case, the old value of the red channel was <code class="literal">246</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; 246 &amp; 0xfe
246
&gt;&gt;&gt; (246 &amp; 0xfe) | 1
247</pre></div><p>The value remains <code class="literal">246</code> when we remove the rightmost bit. When we fold in a new bit value of <code class="literal">1</code>, the result becomes <code class="literal">247</code>. An odd value encodes a one bit from our secret message.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Using <code class="literal">ship.show()</code> before and after the image reveals no perceivable change to the image.</p></div></div><p>After all, we've only tweaked the level of the red in the image by plus or minus <code class="literal">1</code> on a scale of <code class="literal">256</code>, less than half percent change.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Decoding a message</h2></div></div></div><p>We will decode a message concealed with steganography in two steps. The first step will decode just the first two<a id="id438" class="indexterm"/> bytes of length information, so we<a id="id439" class="indexterm"/> can recover our embedded message. Once we know how many bytes we're looking for, we can decode the right number of bits, recovering just our embedded characters, and nothing more.</p><p>As we'll be dipping into the message twice, it will help to write a bit extractor. Here's the function that will strip bits from the red channel of an image:</p><div><pre class="programlisting">def get_bits( image, offset= 0, size= 16 ):
    w, h = image.size
    for p in range(offset, offset+size):
        y, x = divmod( p, w )
        r, g, b = image.getpixel( (x,y) )
        yield r &amp; 0x01</pre></div><p>We've defined a function with three parameters: an image, an offset into the image, and a number of bits to extract. The length information is an offset zero and has a length of 16 bits. We set those as default values.</p><p>We used the a common <code class="literal">divmod()</code> calculation to transform a position into <em>y</em> and <em>x</em> coordinates based on the overall width<a id="id440" class="indexterm"/> of the image. The <code class="literal">y</code> value is <code class="literal">position//width</code>; the <code class="literal">x</code> value is <code class="literal">position%width</code>. This <a id="id441" class="indexterm"/>matches the calculation carried out when embedding bits into the message.</p><p>We used the image's <code class="literal">getpixel()</code> method to<a id="id442" class="indexterm"/> extract the three channels of color information. We used <code class="literal">r &amp; 0x01</code> to calculate just the rightmost bit of the red channel.</p><p>As the value was returned with a <code class="literal">yield</code> statement, this is a generator function: it provides a sequence of values. As our <code class="literal">byte_sequence()</code> function expects a sequence of values, we can combine the two to extract the size, as shown in the following code:</p><div><pre class="programlisting">size_H, size_L = byte_sequence( get_bits( ship, 0, 16 ) )
size= size_H*256+size_L</pre></div><p>We grabbed 16 bits from the image using the <code class="literal">get_bits()</code> function. This sequence of bits was provided to the <code class="literal">byte_sequence()</code> function. The bits were grouped into eight-tuples and the eight-tuples transformed into single values. We can then multiply and add these values to recover the original message size.</p><p>Now that we know how many bytes to get, we also know how many bits to extract. The extraction looks like this:</p><div><pre class="programlisting">message= byte_sequence(get_bits(ship, 16, size*8))</pre></div><p>We've used the <a id="id443" class="indexterm"/>
<code class="literal">get_bits()</code> function to extract bits starting from position 16 and extending until we've found a total of <code class="literal">size*8</code> individual bits. We grouped the bits into eight-tuples and converted the eight-tuples to individual values.</p><p>Given a sequence of bytes, we can create a <code class="literal">bytes</code> object and use Python's decoder to recover the original string. It looks like this:</p><div><pre class="programlisting">print( bytes(message).decode("UTF-8") )</pre></div><p>This will properly decode bytes into characters using the UTF-8 encoding.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Detecting and preventing tampering</h1></div></div></div><p>We can use steganography to assure that our message isn't tampered with. If we can't find our digital watermark properly encoded, we know that our picture was touched. This is one way to detect tampering. A more robust<a id="id444" class="indexterm"/> technique to detect tampering is to use hash totals. There are a number of hash algorithms used to produce a summary or signature of a sequence of bytes. We send both the message and the hash code separately. If the<a id="id445" class="indexterm"/> received message doesn't match the hash code, we know something went wrong. One common use case for hashes is to confirm a proper download of a file. After downloading a file, we should compare the hash of the file we got with a separately published hash value; if the hash values don't match, something's wrong with the file. We can delete it before opening it.</p><p>While it seems like encryption would prevent tampering, it requires careful management of the encryption keys. Encryption is no panacea. It's possible to employ a good encryption algorithm but lose control of the keys, rendering the encryption useless. Someone with unauthorized access to the key can rewrite the file and no one would know.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>Using hash totals to validate a file</h2></div></div></div><p>Python has a number<a id="id446" class="indexterm"/> of hash algorithms available in the <code class="literal">hashlib</code> module. Software<a id="id447" class="indexterm"/> downloads are often provided with MD5 hashes of the software package. We can compute an MD5 digest of a file using <code class="literal">hashlib</code>, as shown in the following code:</p><div><pre class="programlisting">import hashlib
md5 = hashlib.new("md5")
with open( "LHD_warship.jpg", "rb" ) as some_file:
    md5.update( some_file.read() )
print( md5.hexdigest() )</pre></div><p>We've created an MD5 digest object using the <code class="literal">hashlib.new()</code> function; we named the algorithm to be used. We opened the file in <em>bytes</em> mode. We provided the entire file to the digest object's <code class="literal">update()</code> method. For really large files, we might want to read the file in blocks rather than read the entire file into memory in one swoop. Finally, we printed the hex version of the digest.</p><p>This will provide a hexadecimal string version of the MD5 digest, as follows:</p><div><pre class="programlisting">0032e5b0d9dd6e3a878a611b49807d24</pre></div><p>Having this secure hash allows us to confirm that the file has not been tampered with in its journey through the Internet from sender to receiver.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Using a key with a digest</h2></div></div></div><p>We can provide considerably more security by adding<a id="id448" class="indexterm"/> a key to a message digest. This doesn't encrypt the message; it encrypts the digest to be sure that the digest is not <a id="id449" class="indexterm"/>touched during transmission.</p><p>The <code class="literal">hmac</code> module in the Python standard library handles this for us, as shown in the following code:</p><div><pre class="programlisting">import hmac
with open( "LHD_warship.jpg", "rb" ) as some_file:
    keyed= hmac.new( b"Agent Garbo", some_file.read() )
print( keyed.hexdigest() )</pre></div><p>In this example, we've created an HMAC digest object and also passed the message content to that digest object. The <code class="literal">hmac.new()</code> function can accept both the key (as a string of bytes) and the body of a message.</p><p>The hex digest from this HMAC digest object includes both the original message and a key we provided. Here's the output:</p><div><pre class="programlisting">42212d077cc5232f3f2da007d35a726c</pre></div><p>As HQ knows our key, they can confirm that a message comes from us.</p><p>Similarly, HQ must use our key when sending us a message. We can then use our key when we read the message to confirm that it was sent to us by HQ.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Solving problems – encrypting a message</h1></div></div></div><p>For proper encryption, the PyCrypto package can be used, which <a id="id450" class="indexterm"/>can be downloaded from <a class="ulink" href="https://www.dlitz.net/software/pycrypto/">https://www.dlitz.net/software/pycrypto/</a>. As with Pillow, this is a hefty download.</p><p>As we saw in <a class="link" href="ch01.html" title="Chapter 1. Our Espionage Toolkit">Chapter 1</a>, <em>Our Espionage Toolkit</em>, a poor choice of key will render any encryption scheme essentially worthless. If we encrypt a file using a single-word key that's available in a readily<a id="id451" class="indexterm"/> available corpus of words, we haven't really made our data very secure at all. A brute-force attack will break the encryption.</p><p>We can combine steganography with the creation of a <code class="literal">ZipFile</code> archive to embed a message in an image in a ZIP file. As a ZIP file can have a comment string, we can include an HMAC signature as the comment for the ZIP archive.</p><p>Ideally, we'd use the ZIP encryption. However, the Python <code class="literal">ZipFile</code> library doesn't create encrypted ZIP files. It only reads encrypted files.</p><p>We're going to define a function that looks like this:</p><div><pre class="programlisting">def package( text, image_source, key_hmac, filename ):</pre></div><p>We'll provide the text of our message, the image source, the key we'll use to create our HMAC signature, and<a id="id452" class="indexterm"/> an output filename. The output from this will be a ZIP file that contains the image and the signature.</p><p>The outline of our <code class="literal">package()</code> function looks like this:</p><div><pre class="programlisting">    image= Image.open( image_source )
    steg_embed( image, text )
    image.save( "/tmp/package.tiff", format="TIFF" )
    with open("/tmp/package.tiff","rb") as saved:
        digest= hmac.new( key_hmac.encode("ASCII"), saved.read() )
    with ZipFile( filename, "w" ) as archive:
        archive.write( "/tmp/package.tiff", "image.tiff" )
        archive.comment= digest.hexdigest().encode("ASCII")
    os.remove( "/tmp/package.tiff" )</pre></div><p>We've opened the source image and used an <a id="id453" class="indexterm"/>
<code class="literal">steg_embed()</code> function to put our secret message into the image. We've saved the updated image to a temporary file.</p><p>We computed the HMAC digest of our image file before doing anything else with it. We saved the digest in the <code class="literal">digest</code> variable.</p><p>Now that everything is prepared, we can create a new archive file. We can write the image into one member of the archive. When we are setting the <code class="literal">comment</code> attribute of the archive, this will make sure that the comment text is written when the archive is closed.</p><p>Note that we had to convert the key to ASCII bytes to create a digest. The HMAC algorithm is defined for bytes, not Unicode characters. Similarly, the resulting <code class="literal">hexdigest()</code> string had to be converted to ASCII bytes before it could be placed in the archive. ZIP archives only work in bytes and can't directly support Unicode characters.</p><p>Finally, we removed the temporary file that had the tweaked image in it. There's no reason to leave potentially incriminating files laying around.</p><p>For this to work, we need to complete the function, <code class="literal">steg_embed()</code>, that implements our steganographic encoding. See the <em>Some approaches to steganography</em> section for details on how this needs to work.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Unpacking a message</h2></div></div></div><p>We'll also<a id="id454" class="indexterm"/> need the inverse function that can decode a message in a ZIP archive. This function would have a definition like this:</p><div><pre class="programlisting">def unpackage( filename, key_hmac ):</pre></div><p>It requires a ZIP filename and a key to validate the signature. This can return two things: the embedded message and the image into which the message was encoded.</p><p>The outline of our <code class="literal">unpackage()</code> function looks like this:</p><div><pre class="programlisting">    try:
        os.remove( "/tmp/image.tiff" )
    except FileNotFoundError:
        pass
    with ZipFile( filename, "r" ) as archive:
        with archive.open( "image.tiff", "r" ) as member:
            keyed= hmac.new( key_hmac.encode("ASCII"), member.read() )
        assert archive.comment == keyed.hexdigest().encode("ASCII"), "Invalid HMAC"
        archive.extract( "image.tiff", "/tmp" )
    image= Image.open( "/tmp/image.tiff" )
    text= steg_extract( image )
    os.remove( "/tmp/image.tiff" )
    return text, image</pre></div><p>We're going to remove any temporary file that might exist. If the file doesn't exist already, that's a good thing, but it will raise a <code class="literal">FileNotFoundError</code> exception. We need to trap and silence that exception.</p><p>Our first step is to<a id="id455" class="indexterm"/> open the ZIP file and then open the <code class="literal">image.tiff</code> member within the ZIP file. We compute the HMAC digest of this member. Then, we assert that the archive comment matches the hex digest of the selected member. If the condition in the <code class="literal">assert</code> statement is false and the HMAC keys don't match, then this will raise an exception and the script will stop running. This will also mean that our message was compromised. If the condition in the <code class="literal">assert</code> statement is true, it executes silently.</p><p>If the assertion is true, we can extract the image file to a spot in the <code class="literal">/tmp</code> directory. From here, we can open the file and use the <a id="id456" class="indexterm"/>
<code class="literal">steg_extract()</code> function to recover the message hidden in the image. Windows agents can use the <code class="literal">os</code> module to locate a temporary directory. The value of <code class="literal">os.environ['TEMP']</code> will name a suitable temporary directory.</p><p>Once we've got the message, we can remove the temporary file.</p><p>For this to work, we need to complete the function, <code class="literal">steg_extract()</code>, that implements our steganographic decoding. See the <em>Some approaches to steganography</em> section for details on how this needs to work.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we learned how to work on a computer's filesystem and common file formats. We looked in depth at image files. We also saw how Pillow allows us to apply operations such as cropping, filtering, and enhancing to an image.</p><p>We covered Python bit-fiddling operators such as <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">&lt;&lt;</code>, and <code class="literal">&gt;&gt;</code>. These operators work on the individual bits of an integer value. Something like <code class="literal">bin(0b0100 &amp; 0b1100)</code> will show how the answer is based on doing an <code class="literal">AND</code> operation on each individual bit of the number.</p><p>We also looked at how we can apply steganographic techniques to conceal a message in an image file. This involved both byte and bit manipulation in Python.</p><p>In the next chapter, we'll look at incorporating geolocation information with our other information gathering. We know that pictures can be tied to locations, so geocoding and reverse geocoding are essential. We'll also look at ways to read more complex online datasets and combine multiple web services into a composite application.</p></div></body></html>