["```py\nclass Testable:\n    def method1(self, number):\n        number += 4\n        number **= 0.5\n        number *= 7\n        return number\n\n    def method2(self, number):\n        return ((number * 2) ** 1.27) * 0.3\n\n    def method3(self, number):\n        return self.method1(number) + self.method2(number)\n\n    def method4(self):\n        return 1.713 * self.method3(id(self))\n```", "```py\nclass ClassOne:\n    def __init__(self, arg1, arg2):\n        self.arg1 = int(arg1)\n        self.arg2 = arg2\n\n    def method1(self, x):\n        return x * self.arg1\n\n    def method2(self, x):\n        return self.method1(self.arg2) * x\n```", "```py\n>>> import pid\n\n>>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)\n\n>>> controller.gains\n(0.5, 0.5, 0.5)\n>>> controller.setpoint\n[0.0]\n>>> controller.previous_time is None\nTrue\n>>> controller.previous_error\n0.0\n>>> controller.integrated_error\n0.0\n```", "```py\nReplace time.time with a predictable fake\n>>> import time\n>>> real_time = time.time\n>>> time.time = (float(x) for x in range(1, 1000)).__next__\n\nMake sure we're not inheriting old state from the constructor tests\n>>> import imp\n>>> pid = imp.reload(pid)\n\nActual tests. These test values are nearly arbitrary, having been chosen for no reason other than that they should produce easily recognized values.\n>>> controller = pid.PID(P=0.5, I=0.5, D=0.5, setpoint=0)\n>>> controller.calculate_response(12)\n-6.0\n>>> controller.calculate_response(6)\n-3.0\n>>> controller.calculate_response(3)\n-4.5\n>>> controller.calculate_response(-1.5)\n-0.75\n>>> controller.calculate_response(-2.25)\n-1.125\n\nUndo the fake\n>>> time.time = real_time\n```", "```py\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0)\n\n>>> controller.push_setpoint(7)\n>>> controller.setpoint\n[0.0, 7.0]\n\n>>> controller.push_setpoint(8.5)\n>>> controller.setpoint\n[0.0, 7.0, 8.5]\n\n>>> controller.pop_setpoint()\n8.5\n>>> controller.setpoint\n[0.0, 7.0]\n\n>>> controller.pop_setpoint()\n7.0\n>>> controller.setpoint\n[0.0]\n\n>>> controller.pop_setpoint()\nTraceback (most recent call last):\nValueError: PID controller must have a setpoint\n```", "```py\npython3 -m doctest PID.txt\n```", "```py\nfrom time import time\n\nclass PID:\n    def __init__(self, P, I, D, setpoint):\n        self.gains = (float(P), float(I), float(D))\n        self.setpoint = [float(setpoint)]\n        self.previous_time = None\n        self.previous_error = 0.0\n        self.integrated_error = 0.0\n\n    def push_setpoint(self, target):\n        self.setpoint.append(float(target))\n\n    def pop_setpoint(self):\n        if len(self.setpoint) > 1:\n            return self.setpoint.pop()\n        raise ValueError('PID controller must have a setpoint')\n\n    def calculate_response(self, value):\n        now = time()\n        P, I, D = self.gains\n\n        err = value - self.setpoint[-1]\n\n        result = P * err\n        if self.previous_time is not None:\n            delta = now - self.previous_time\n            self.integrated_error += err * delta\n            result += I * self.integrated_error\n            result += D * (err - self.previous_error) / delta\n\n        self.previous_error = err\n        self.previous_time = now\n\n        return result\n```", "```py\npython3 -m doctest PIDflawed.txt\n```", "```py\nerr = self.setpoint[-1] - value\n```", "```py\n>>> import time\n>>> real_time = time.time\n>>> time.time = (float(x) for x in range(1, 1000)).__next__\n>>> import pid\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)\n>>> controller.gains\n(0.5, 0.5, 0.5)\n>>> controller.setpoint\n[0.0]\n>>> controller.previous_time\n1.0\n>>> controller.previous_error\n-12.0\n>>> controller.integrated_error\n0.0\n>>> time.time = real_time\n```", "```py\n>>> import imp\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 1,\n...                      initial = 12, when = 43)\n>>> controller.gains\n(0.5, 0.5, 0.5)\n>>> controller.setpoint\n[1.0]\n>>> controller.previous_time\n43.0\n>>> controller.previous_error\n-11.0\n>>> controller.integrated_error\n0.0\n```", "```py\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)\n```", "```py\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,\n...                      initial = 12, when = 1)\n>>> controller.calculate_response(6, 2)\n-3.0\n>>> controller.calculate_response(3, 3)\n-4.5\n>>> controller.calculate_response(-1.5, 4)\n-0.75\n>>> controller.calculate_response(-2.25, 5)\n-1.125\n```", "```py\nWe want a class that implements a PID controller for a single\nvariable. The measurement, setpoint, and output should all be real\nnumbers. The constructor should accept an initial measurement value in\naddition to the gains and setpoint.\n\n>>> import time\n>>> real_time = time.time\n>>> time.time = (float(x) for x in range(1, 1000)).__next__\n>>> import pid\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)\n>>> controller.gains\n(0.5, 0.5, 0.5)\n>>> controller.setpoint\n[0.0]\n>>> controller.previous_time\n1.0\n>>> controller.previous_error\n-12.0\n>>> controller.integrated_error\n0.0\n>>> time.time = real_time\n\nThe constructor should also optionally accept a parameter specifying\nwhen the initial measurement was taken.\n\n>>> import imp\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 1,\n...                      initial = 12, when = 43)\n>>> controller.gains\n(0.5, 0.5, 0.5)\n>>> controller.setpoint\n[1.0]\n>>> controller.previous_time\n43.0\n>>> controller.previous_error\n-11.0\n>>> controller.integrated_error\n0.0\n\nThe calculate response method receives the measured value as input,\nand returns the control signal.\n\n>>> import time\n>>> real_time = time.time\n>>> time.time = (float(x) for x in range(1, 1000)).__next__\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)\n>>> controller.calculate_response(6)\n-3.0\n>>> controller.calculate_response(3)\n-4.5\n>>> controller.calculate_response(-1.5)\n-0.75\n>>> controller.calculate_response(-2.25)\n-1.125\n>>> time.time = real_time\n\nThe calculate_response method should be willing to accept a parameter\nspecifying at what time the call is happening.\n\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,\n...                      initial = 12, when = 1)\n>>> controller.calculate_response(6, 2)\n-3.0\n>>> controller.calculate_response(3, 3)\n-4.5\n>>> controller.calculate_response(-1.5, 4)\n-0.75\n>>> controller.calculate_response(-2.25, 5)\n-1.125\n\nWe need to be able to adjust the setpoint at runtime, but we want it to have a memory, so that we can easily return to the previous\nsetpoint.\n\n>>> pid = imp.reload(pid)\n>>> controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,...                      initial = 12)\n>>> controller.push_setpoint(7)\n>>> controller.setpoint\n[0.0, 7.0]\n>>> controller.push_setpoint(8.5)\n>>> controller.setpoint\n[0.0, 7.0, 8.5]\n>>> controller.pop_setpoint()\n8.5\n>>> controller.setpoint\n[0.0, 7.0]\n>>> controller.pop_setpoint()\n7.0\n>>> controller.setpoint\n[0.0]\n>>> controller.pop_setpoint()\nTraceback (most recent call last):\nValueError: PID controller must have a setpoint\n```", "```py\nPython3 -m doctest PID.txt\n```", "```py\nfrom time import time\n\nclass PID:\n    def __init__(self, P, I, D, setpoint, initial, when = None):\n        self.gains = (float(P), float(I), float(D))\n\n        if P < 0 or I < 0 or D < 0:\n            raise ValueError('PID controller gains must be non-negative')\n\n        if not isinstance(setpoint, complex):\n            setpoint = float(setpoint)\n\n        if not isinstance(initial, complex):\n            initial = float(initial)\n\n        self.setpoint = [setpoint]\n\n        if when is None:\n            self.previous_time = time()\n        else:\n            self.previous_time = float(when)\n\n        self.previous_error = self.setpoint[-1] - initial\n        self.integrated_error = 0.0\n\n    def push_setpoint(self, target):\n        self.setpoint.append(float(target))\n\n    def pop_setpoint(self):\n        if len(self.setpoint) > 1:\n            return self.setpoint.pop()\n        raise ValueError('PID controller must have a setpoint')\n\n    def calculate_response(self, value, now = None):\n        if now is None:\n            now = time()\n        else:\n            now = float(now)\n\n        P, I, D = self.gains\n\n        err = self.setpoint[-1] - value\n\n        result = P * err\n        delta = now - self.previous_time\n        self.integrated_error += err * delta\n        result += I * self.integrated_error\n        result += D * (err - self.previous_error) / delta\n\n        self.previous_error = err\n        self.previous_time = now\n\n        return result\n```"]