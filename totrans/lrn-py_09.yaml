- en: Chapter 9. Data Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 数据科学
- en: '|   | *"If we have data, let''s look at data. If all we have are opinions,
    let''s go with mine."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"如果我们有数据，让我们看看数据。如果我们只有意见，那就听我的。" |   |'
- en: '|   | --*Jim Barksdale, former Netscape CEO* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*吉姆·巴克斯代尔，前网景CEO* |'
- en: '**Data science** is a very broad term, and can assume several different meanings
    according to context, understanding, tools, and so on. There are countless books
    about this subject, which is not suitable for the faint-hearted.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据科学**是一个非常广泛的概念，根据上下文、理解、工具等因素，它可以有多种不同的含义。关于这个主题有无数本书籍，这对胆小的人来说并不适合。'
- en: In order to do proper data science, you need to know mathematics and statistics
    at the very least. Then, you may want to dig into other subjects such as pattern
    recognition and machine learning and, of course, there is a plethora of languages
    and tools you can choose from.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行适当的数据科学，你至少需要了解数学和统计学。然后，你可能想深入研究其他主题，如模式识别和机器学习，当然，你有很多语言和工具可以选择。
- en: Unless I transform into *The Amazing Fabrizio* in the next few minutes, I won't
    be able to talk about everything; I won't even get close to it. Therefore, in
    order to render this chapter meaningful, we're going to work on a cool project
    together.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我在接下来的几分钟内变成**神奇的法布里齐奥**，否则我无法谈论所有的事情；我甚至无法接近它。因此，为了使这一章节有意义，我们将一起进行一个有趣的项目。
- en: About 3 years ago, I was working for a top-tier social media company in London.
    I stayed there for 2 years, and I was privileged to work with several people whose
    brilliance I can only start to describe. We were the first in the world to have
    access to the Twitter Ads API, and we were partners with Facebook as well. That
    means a lot of data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大约3年前，我在伦敦的一家顶级社交媒体公司工作。我在那里待了2年，我有幸与几位我只能说初窥其才华的人一起工作。我们是世界上第一个能够访问Twitter
    Ads API的人，我们也是Facebook的合作伙伴。这意味着有很多数据。
- en: Our analysts were dealing with a huge number of campaigns and they were struggling
    with the amount of work they had to do, so the development team I was a part of
    tried to help by introducing them to Python and to the tools Python gives you
    to deal with data. It was a very interesting journey that led me to mentor several
    people in the company and eventually to Manila where, for 2 weeks, I gave intensive
    training in Python and data science to our analysts there.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分析师正在处理大量的活动，他们正在努力应对他们必须完成的工作量，所以我所在的开发团队试图通过向他们介绍Python和Python提供的数据处理工具来帮助他们。这是一段非常有趣的旅程，它引导我成为公司中几个人的导师，并最终到了马尼拉，在那里，我花了2个星期的时间对那里的分析师进行了密集的Python和数据科学培训。
- en: The project we're going to do together in this chapter is a lightweight version
    of the final example I presented to my Manila students. I have rewritten it to
    a size that will fit this chapter, and made a few adjustments here and there for
    teaching purposes, but all the main concepts are there, so it should be fun and
    instructional for you to code along.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将一起做的项目是我在马尼拉学生面前展示的最终示例的轻量级版本。我将其重写到一个适合这一章的大小，并对教学目的进行了一些调整，但所有主要概念都在那里，所以你应该会享受编码并从中学习。
- en: On our journey, we're going to meet a few of the tools you can find in the Python
    ecosystem when it comes to dealing with data, so let's start by talking about
    Roman gods.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅途中，我们将遇到一些你可以在Python生态系统中发现的数据处理工具，所以让我们先从罗马神祇开始谈。
- en: IPython and Jupyter notebook
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPython和Jupyter笔记本
- en: In 2001, Fernando Perez was a graduate student in physics at CU Boulder, and
    was trying to improve the Python shell so that he could have some niceties like
    those he was used to when he was working with tools such as Mathematica and Maple.
    The result of that effort took the name **IPython**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 2001年，费尔南多·佩雷斯是科罗拉多大学博尔德分校的物理学研究生，他试图改进Python shell，以便他能够拥有一些他习惯于在像Mathematica和Maple这样的工具工作时的一些便利性。这项努力的成果被命名为**IPython**。
- en: In a nutshell, that small script began as an enhanced version of the Python
    shell and, through the effort of other coders and eventually proper funding from
    several different companies, it became the wonderful and successful project it
    is today. Some 10 years after its birth, a notebook environment was created, powered
    by technologies like WebSockets, the Tornado web server, jQuery, CodeMirror, and
    MathJax. The ZeroMQ library was also used to handle the messages between the notebook
    interface and the Python core that lies behind it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，那个小脚本最初是Python shell的一个增强版本，通过其他编码者的努力，以及几家不同公司的适当资助，它最终成为了今天这个美妙且成功的项目。在其诞生后的大约10年后，一个笔记本环境被创建，它由WebSocket、Tornado网络服务器、jQuery、CodeMirror和MathJax等技术驱动。ZeroMQ库也被用来处理笔记本界面和背后的Python核心之间的消息。
- en: The IPython notebook has become so popular and widely used that eventually,
    all sorts of goodies have been added to it. It can handle widgets, parallel computing,
    all sorts of media formats, and much, much more. Moreover, at some point, it became
    possible to code in languages other than Python from within the notebook.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IPython笔记本变得如此受欢迎和广泛使用，以至于最终，各种功能都被添加到了它上面。它可以处理小部件、并行计算、各种媒体格式等等。此外，在某个时刻，从笔记本内部使用除Python以外的语言进行编码成为可能。
- en: 'This has led to a huge project that only recently has been split into two:
    IPython has been stripped down to focus more on the kernel part and the shell,
    while the notebook has become a brand new project called **Jupyter**. Jupyter
    allows interactive scientific computations to be done in more than 40 languages.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了这样一个巨大的项目，最近才被拆分为两个部分：IPython被精简以更多地关注内核和shell部分，而笔记本则成为了一个全新的项目，名为**Jupyter**。Jupyter允许在40多种语言中进行交互式科学计算。
- en: This chapter's project will all be coded and run in a Jupyter notebook, so let
    me explain in a few words what a notebook is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目都将使用Jupyter笔记本进行编码和运行，所以让我用几句话来解释一下什么是笔记本。
- en: A notebook environment is a web page that exposes a simple menu and the cells
    in which you can run Python code. Even though the cells are separate entities
    that you can run individually, they all share the same Python kernel. This means
    that all the names that you define in a cell (the variables, functions, and so
    on) will be available in any other cell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本环境是一个网页，它暴露了一个简单的菜单和你可以运行Python代码的单元格。尽管单元格是独立的实体，你可以单独运行它们，但它们都共享同一个Python内核。这意味着你在单元格中定义的所有名称（变量、函数等）都将可在任何其他单元格中使用。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Simply put, a Python kernel is a process in which Python is running. The notebook
    web page is therefore an interface exposed to the user for driving this kernel.
    The web page communicates to it using a very fast messaging system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Python内核就是一个Python正在运行的进程。因此，笔记本网页就是提供给用户的一个界面，用于驱动这个内核。网页通过一个非常快速的消息系统与之通信。
- en: Apart from all the graphical advantages, the beauty to have such an environment
    consists in the ability of running a Python script in chunks, and this can be
    a tremendous advantage. Take a script that is connecting to a database to fetch
    data and then manipulate that data. If you do it in the conventional way, with
    a Python script, you have to fetch the data every time you want to experiment
    with it. Within a notebook environment, you can fetch the data in a cell and then
    manipulate and experiment with it in other cells, so fetching it every time is
    not necessary.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有图形优势之外，拥有这样一个环境的美妙之处在于能够分块运行Python脚本，这可以是一个巨大的优势。以一个连接数据库以获取数据并处理这些数据的脚本为例。如果你用传统的Python脚本方式来做，每次你想对其进行实验时都必须重新获取数据。在笔记本环境中，你可以在一个单元格中获取数据，然后在其他单元格中对其进行处理和实验，因此不需要每次都获取数据。
- en: The notebook environment is also extremely helpful for data science because
    it allows for step-by-step introspection. You do one chunk of work and then verify
    it. You then do another chunk and verify again, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本环境对于数据科学也非常有帮助，因为它允许逐步进行内省。你完成一块工作后验证它。然后你做另一块工作并再次验证，依此类推。
- en: It's also invaluable for prototyping because the results are there, right in
    front of your eyes, immediately available.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它对于原型设计也非常有价值，因为结果就在你眼前，立即可用。
- en: If you want to know more about these tools, please check out [http://ipython.org/](http://ipython.org/)
    and [http://jupyter.org/](http://jupyter.org/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于这些工具的信息，请查看[http://ipython.org/](http://ipython.org/)和[http://jupyter.org/](http://jupyter.org/)。
- en: 'I have created a very simple example notebook with a `fibonacci` function that
    gives you the list of all Fibonacci numbers smaller than a given `N`. In my browser,
    it looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个非常简单的示例笔记本，其中包含一个`fibonacci`函数，该函数可以给出小于给定`N`的所有斐波那契数的列表。在我的浏览器中，它看起来像这样：
- en: '![IPython and Jupyter notebook](img/4715_09_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![IPython和Jupyter笔记本](img/4715_09_01.jpg)'
- en: Every cell has an **In []** label. If there's nothing between the braces, it
    means that cell has never been executed. If there is a number, it means that the
    cell has been executed, and the number represents the order in which the cell
    was executed. Finally, a ***** means that the cell is currently being executed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格都有一个**In []**标签。如果花括号内没有内容，这意味着该单元格从未被执行过。如果有数字，这意味着该单元格已被执行，数字代表单元格被执行的顺序。最后，一个*****表示该单元格目前正在被执行。
- en: You can see in the picture that in the first cell I have defined the `fibonacci`
    function, and I have executed it. This has the effect of placing the `fibonacci`
    name in the global frame associated with the notebook, therefore the `fibonacci`
    function is now available to the other cells as well. In fact, in the second cell,
    I can run `fibonacci(100)` and see the results in **Out [2]**. In the third cell,
    I have shown you one of the several magic functions you can find in a notebook
    in the second cell. **%timeit** runs the code several times and provides you with
    a nice benchmark for it. All the measurements for the list comprehensions and
    generators I did in [Chapter 5](ch05.html "Chapter 5. Saving Time and Memory"),
    *Saving Time and Memory* were carried out with this nice feature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从图片中看到，在第一个单元格中，我定义了`fibonacci`函数，并且已经执行了它。这会将`fibonacci`名称放入与笔记本关联的全局框架中，因此`fibonacci`函数现在对其他单元格也是可用的。实际上，在第二个单元格中，我可以运行`fibonacci(100)`并在**Out
    [2]**中看到结果。在第三个单元格中，我向你展示了笔记本中可以找到的几个魔法函数之一。**%timeit**会多次运行代码，并为你提供一个很好的基准。我在[第5章](ch05.html
    "第5章。节省时间和内存")“节省时间和内存”中进行的所有列表推导和生成器的测量都是使用这个很好的功能完成的。
- en: You can execute a cell as many times as you want, and change the order in which
    you run them. Cells are very malleable, you can also put in markdown text or render
    them as headers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以多次执行一个单元格，并改变它们的执行顺序。单元格非常灵活，你还可以在其中放入Markdown文本或将其渲染为标题。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Markdown** is a lightweight markup language with plain text formatting syntax
    designed so that it can be converted to HTML and many other formats.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Markdown**是一种轻量级标记语言，具有纯文本格式化语法，旨在能够将其转换为HTML和其他格式。'
- en: Also, whatever you place in the last row of a cell will be automatically printed
    for you. This is very handy because you're not forced to write `print(...)` explicitly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论你在单元格的最后一行放置什么内容，它都会自动为你打印出来。这非常方便，因为你不必明确地写`print(...)`。
- en: Feel free to explore the notebook environment; once you're friends with it,
    it's a long-lasting relationship, I promise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随意探索笔记本环境；一旦你成为它的朋友，这将是一段持久的友谊，我保证。
- en: 'In order to run the notebook, you have to install a handful of libraries, each
    of which collaborates with the others to make the whole thing work. Alternatively,
    you can just install Jupyter and it will take care of everything for you. For
    this chapter, there are a few other dependencies that we need to install, so please
    run the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行笔记本，你必须安装一些库，每个库都与其他库协作以使整个系统工作。或者，你只需安装Jupyter，它将为你处理一切。对于本章，我们还需要安装一些其他依赖项，所以请运行以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Don''t worry, I''ll introduce you to each of these gradually. Now, when you''re
    done installing these libraries (it may take a few minutes), you can start the
    notebook:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我会逐渐向你介绍这些内容。现在，当你安装完这些库（可能需要几分钟）后，你就可以开始使用笔记本了：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will open a page in your browser at this address: `http://localhost:8888/`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的浏览器中打开一个页面，地址为：`http://localhost:8888/`。
- en: Go to that page and create a new notebook using the menu. When you have it and
    you're comfortable with it, we're ready to go.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前往该页面并使用菜单创建一个新的笔记本。当你熟悉它时，我们就准备好了。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you experience any issues setting up the notebook environment, please don't
    get discouraged. If you get an error, it's usually just a matter of searching
    a little bit on the web and you'll end up on a page where someone else has had
    the same issue, and they have explained how to fix it. Try your best to have the
    notebook environment up and running before continuing with the chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置笔记本环境时遇到任何问题，请不要气馁。如果你遇到错误，通常只是在网上搜索一下，你最终会找到其他人遇到相同问题并解释如何修复它的页面。在你继续本章之前，尽力让笔记本环境运行起来。
- en: Our project will take place in a notebook, therefore I will tag each code snippet
    with the cell number it belongs to, so that you can easily reproduce the code
    and follow along.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的项目将在笔记本中进行，因此我将为每个代码片段标记所属的单元格编号，这样你就可以轻松地重现代码并跟随。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you familiarize yourself with the keyboard shortcuts (look in the notebook's
    help section), you will be able to move between cells and handle their content
    without having to reach for the mouse. This will make you more proficient and
    way faster when you work in a notebook.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉键盘快捷键（在笔记本的帮助部分查看），你将能够在单元格之间移动并处理它们的内容，而无需伸手去拿鼠标。这将使你在笔记本中工作时更加熟练，速度也会更快。
- en: Dealing with data
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: 'Typically, when you deal with data, this is the path you go through: you fetch
    it, you clean and manipulate it, then you inspect it and present results as values,
    spreadsheets, graphs, and so on. I want you to be in charge of all three steps
    of the process without having any external dependency on a data provider, so we''re
    going to do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你处理数据时，这是你经过的路径：你获取它，清理和操作它，然后检查它，并以值、电子表格、图表等形式展示结果。我希望你负责整个过程的三个步骤，而不依赖于任何外部数据提供者，所以我们将做以下事情：
- en: We're going to create the data, simulating the fact that it comes in a format
    which is not perfect or ready to be worked on.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建数据，模拟它以不完美或未准备好工作的格式出现。
- en: 'We''re going to clean it and feed it to the main tool we''ll use in the project:
    **DataFrame** of `pandas`.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将清理它，并将其提供给我们在项目中使用的核心工具：`pandas` 的 **DataFrame**。
- en: We're going to manipulate the data in the DataFrame.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将操作 DataFrame 中的数据。
- en: We're going to save the DataFrame to a file in different formats.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把 DataFrame 保存到不同格式的文件中。
- en: Finally, we're going to inspect the data and get some results out of it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将检查数据并从中获取一些结果。
- en: Setting up the notebook
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置笔记本
- en: First things first, we need to set up the notebook. This means imports and a
    bit of configuration.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置笔记本。这意味着导入和一些配置。
- en: '`#1`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`#1`'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Cell `#1` takes care of the imports. There are quite a few new things here:
    the `calendar`, `random` and `datetime` modules are part of the standard library.
    Their names are self-explanatory, so let''s look at `faker`. The `fake-factory`
    library gives you this module, which you can use to prepare fake data. It''s very
    useful in tests, when you prepare your fixtures, to get all sorts of things such
    as names, e-mail addresses, phone numbers, credit card details, and much more.
    It is all fake, of course.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格 `#1` 负责导入。这里有很多新事物：`calendar`、`random` 和 `datetime` 模块是标准库的一部分。它们的名字具有自解释性，所以让我们看看
    `faker`。`fake-factory` 库提供了这个模块，你可以使用它来准备假数据。在测试中，当你准备你的固定数据时，它非常有用，可以获取各种东西，如姓名、电子邮件地址、电话号码、信用卡详情等等。当然，这些都是假的。
- en: '`numpy` is the NumPy library, the fundamental package for scientific computing
    with Python. I''ll spend a few words on it later on in the chapter.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy` 是 NumPy 库，是 Python 科学计算的基础包。我将在本章后面简要介绍它。'
- en: '`pandas` is the very core upon which the whole project is based. It stands
    for **Python Data Analysis Library**. Among many others, it provides the **DataFrame**,
    a matrix-like data structure with advanced processing capabilities. It''s customary
    to import the `DataFrame` separately and then do `import pandas as pd`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 是整个项目的基础核心。它代表 **Python 数据分析库**。在许多其他功能中，它提供了 **DataFrame**，这是一种具有高级处理能力的类似矩阵的数据结构。通常，我们会单独导入
    `DataFrame`，然后执行 `import pandas as pd`。'
- en: '`delorean` is a nice third-party library that speeds up dealing with dates
    dramatically. Technically, we could do it with the standard library, but I see
    no reason not to expand a bit the range of the example and show you something
    different.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`delorean` 是一个很好的第三方库，可以显著加快处理日期的速度。技术上，我们可以使用标准库来完成，但我看不出为什么要限制示例的范围，所以我会展示一些不同的事情。'
- en: Finally, we have an instruction on the last line that will make our graphs at
    the end a little bit nicer, which doesn't hurt.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在最后一行有一个指令，这将使我们的最终图表看起来更美观，这不会有什么坏处。
- en: Preparing the data
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'We want to achieve the following data structure: we''re going to have a list
    of user objects. Each user object will be linked to a number of campaign objects.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望达到以下数据结构：我们将有一个用户对象的列表。每个用户对象都将链接到一定数量的活动对象。
- en: In Python, everything is an object, so I'm using this term in a generic way.
    The user object may be a string, a dict, or something else.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，一切都是对象，所以我以通用方式使用这个术语。用户对象可能是一个字符串、一个字典，或者其他东西。
- en: A **campaign** in the social media world is a promotional campaign that a media
    agency runs on social media networks on behalf of a client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在社交媒体世界中，**活动**是指媒体代理代表客户在社交媒体网络上运行的推广活动。
- en: Remember that we're going to prepare this data so that it's not in perfect shape
    (but it won't be so bad either...).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将准备这些数据，使其不完全处于完美状态（但也不会太糟糕...）。
- en: '`#2`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`#2`'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, we instantiate the `Faker` that we'll use to create the data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化 `Faker`，我们将用它来创建数据。
- en: '`#3`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`#3`'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then we need usernames. I want 1,000 unique usernames, so I loop over the length
    of the `usernames` set until it has 1,000 elements. A set doesn't allow duplicated
    elements, therefore uniqueness is guaranteed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要用户名。我想要 1,000 个唯一的用户名，所以我遍历 `usernames` 集合的长度，直到它有 1,000 个元素。集合不允许重复元素，因此保证了唯一性。
- en: '`#4`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`#4`'
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we create a list of users. Each `username` has now been augmented to a
    full-blown `user` dict, with other details such as name, gender, e-mail, and so
    on. Each `user` dict is then dumped to JSON and added to the list. This data structure
    is not optimal, of course, but we're simulating a scenario where users come to
    us like that.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个用户列表。每个 `username` 现在已经被扩展为一个完整的 `user` 字典，包括其他细节，如姓名、性别、电子邮件等。然后，每个
    `user` 字典被转换为 JSON 并添加到列表中。这种数据结构当然不是最优的，但我们正在模拟用户以这种方式来到我们这里的场景。
- en: Note the skewed use of `random.random()` to make 60% of users female. The rest
    of the logic should be very easy for you to understand.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `random.random()` 的倾斜使用，以使 60% 的用户为女性。其余的逻辑应该很容易理解。
- en: 'Note also the last line. Each cell automatically prints what''s on the last
    line; therefore, the output of this is a list with the first three users:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一行。每个单元格会自动打印最后一行上的内容；因此，这个输出是一个包含前三个用户的列表：
- en: '`Out #4`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out #4`'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I hope you're following along with your own notebook. If you do, please note
    that all data is generated using random functions and values; therefore, you will
    see different results. They will change every time you execute the notebook.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你在自己的笔记本上也能跟着做。如果你做了，请注意，所有数据都是使用随机函数和值生成的；因此，你会看到不同的结果。每次执行笔记本时，它们都会改变。
- en: '`#5`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`#5`'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `#5`, we define the logic to generate a campaign name. Analysts use spreadsheets
    all the time and they come up with all sorts of coding techniques to compress
    as much information as possible into the campaign names. The format I chose is
    a simple example of that technique: there is a code that tells the campaign type,
    then start and end dates, then the target age and gender, and finally the currency.
    All values are separated by an underscore.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `#5` 中，我们定义了生成活动名称的逻辑。分析师经常使用电子表格，他们会想出各种编码技术，尽可能将尽可能多的信息压缩到活动名称中。我选择的是这种技术的简单示例：有一个代码表示活动类型，然后是开始和结束日期，然后是目标年龄和性别，最后是货币。所有值都由下划线分隔。
- en: In the `get_type` function, I use `random.choice()` to get one value randomly
    out of a collection. Probably more interesting is `get_start_end_dates`. First,
    I get the duration for the campaign, which goes from 1 day to 2 years (randomly),
    then I get a random offset in time which I subtract from today's date in order
    to get the start date. Given that the offset is a random number between -365 and
    365, would anything be different if I added it to today's date instead of subtracting
    it?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get_type` 函数中，我使用 `random.choice()` 从一个集合中随机获取一个值。可能更有趣的是 `get_start_end_dates`。首先，我获取活动的持续时间，从
    1 天到 2 年（随机），然后我获取一个随机的时间偏移量，我从今天的日期中减去它以获取开始日期。考虑到偏移量是一个介于 -365 和 365 之间的随机数，如果我将它加到今天的日期上而不是减去，会有什么不同吗？
- en: When I have both the start and end dates, I return a stringified version of
    them, joined by an underscore.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我有了开始和结束日期，我会返回它们的字符串化版本，并用下划线连接。
- en: Then, we have a bit of modular trickery going on with the age calculation. I
    hope you remember the modulo operator (`%`) from [Chapter 2](ch02.html "Chapter 2. Built-in
    Data Types"), *Built-in Data Types*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在年龄计算中做了一些模运算技巧。我希望您还记得第二章[内置数据类型](ch02.html "第二章。内置数据类型")中提到的模运算符（`%`）。
- en: What happens here is that I want a date range that has multiples of 5 as extremes.
    So, there are many ways to do it, but what I do is to get a random number between
    20 and 45 for the left extreme, and remove the remainder of the division by 5\.
    So, if, for example, I get 28, I will remove *28 % 5 = 3* to it, getting 25\.
    I could have just used `random.randrange()`, but it's hard to resist modular division.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是我想要一个具有5的倍数为端点的日期范围。所以有很多方法可以做到这一点，但我所做的是获取一个介于20和45之间的随机数作为左端点，并去除除以5的余数。例如，如果得到28，我会从28中去除*28
    % 5 = 3*，得到25。我本可以使用`random.randrange()`，但很难抗拒模除运算。
- en: The rest of the functions are just some other applications of `random.choice()`
    and the last one, `get_campaign_name`, is nothing more than a collector for all
    these puzzle pieces that returns the final campaign name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的函数只是`random.choice()`的一些其他应用，最后一个函数`get_campaign_name`不过是一个收集所有这些拼图碎片并返回最终活动名称的收集器。
- en: '`#6`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`#6`'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `#6`, we write a function that creates a complete campaign object. I used
    a few different functions from the `random` module. `random.randint()` gives you
    an integer between two extremes. The problem with it is that it follows a uniform
    probability distribution, which means that any number in the interval has the
    same probability of coming up.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`#6`中，我们编写了一个函数来创建一个完整的活动对象。我使用了`random`模块中的几个不同函数。`random.randint()`给你两个极端之间的整数。它的缺点是它遵循均匀概率分布，这意味着区间内的任何数字出现的概率都是相同的。
- en: Therefore, when dealing with a lot of data, if you distribute your fixtures
    using a uniform distribution, the results you will get will all look similar.
    For this reason, I chose to use `triangular` and `gauss`, for `clicks` and `impressions`.
    They use different probability distributions so that we'll have something more
    interesting to see in the end.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当处理大量数据时，如果您使用均匀分布来分配您的固定值，您将得到的结果都将看起来很相似。出于这个原因，我选择使用`triangular`和`gauss`分布来模拟`clicks`和`impressions`。它们使用不同的概率分布，这样我们最终会看到更有趣的结果。
- en: 'Just to make sure we''re on the same page with the terminology: `clicks` represents
    the number of clicks on a campaign advertisement, `budget` is the total amount
    of money allocated for the campaign, `spent` is how much of that money has already
    been spent, and `impressions` is the number of times the campaign has been fetched,
    as a resource, from its source, regardless of the amount of clicks that were performed
    on the campaign. Normally, the amount of impressions is greater than the amount
    of clicks.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们对术语的理解一致：`clicks`代表活动广告的点击次数，`budget`是分配给活动的总金额，`spent`是已经花费的金额，`impressions`是活动从其源获取作为资源的次数，无论在活动中执行了多少点击。通常，展示次数要多于点击次数。
- en: 'Now that we have the data, it''s time to put it all together:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，是时候将它们全部组合在一起了：
- en: '`#7`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`#7`'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, each item in `data` is a dict with a user and a list of campaigns
    that are associated with that user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`data`中的每个项目都是一个包含用户和与该用户关联的活动列表的字典。
- en: Cleaning the data
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理数据
- en: 'Let''s start cleaning the data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始清理数据：
- en: '`#8`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`#8`'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We simulate fetching the data from a source and then inspect it. The notebook
    is the perfect tool to inspect your steps. You can vary the granularity to your
    needs. The first item in `rough_data` looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟从源数据中获取数据并对其进行检查。笔记本是检查您步骤的完美工具。您可以根据需要调整粒度。`rough_data`中的第一个项目看起来是这样的：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, we now start working with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在开始处理它。
- en: '`#9`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`#9`'
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we need to do in order to be able to feed a DataFrame with
    this data is to denormalize it. This means transforming the data into a list whose
    items are campaign dicts, augmented with their relative user dict. Users will
    be duplicated in each campaign they belong to. The first item in `data` looks
    like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将此数据输入到 DataFrame 中，我们首先需要对其进行反规范化。这意味着将数据转换成一个列表，其项目是包含其相对用户字典的活动字典。用户将在他们所属的每个活动中重复。`data`中的第一个项目看起来是这样的：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see that the user object has been brought into the campaign dict which
    was repeated for each campaign.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到用户对象已经被引入到活动字典中，并且为每个活动重复。
- en: Creating the DataFrame
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 DataFrame
- en: 'Now it''s time to create the `DataFrame`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建`DataFrame`了：
- en: '`#10`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`#10`'
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we will create the `DataFrame` and inspect the first five rows using
    the `head` method. You should see something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`DataFrame`并使用`head`方法检查前五行。你应该会看到类似以下的内容：
- en: '![Creating the DataFrame](img/4715_09_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建DataFrame](img/4715_09_02.jpg)'
- en: Jupyter renders the output of the `df.head()` call as HTML automatically. In
    order to have a text-based output, simply wrap `df.head()` in a `print` call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter会自动将`df.head()`调用的输出渲染为HTML。为了得到基于文本的输出，只需将`df.head()`包裹在一个`print`调用中即可。
- en: The `DataFrame` structure is very powerful. It allows us to do a great deal
    of manipulation on its contents. You can filter by rows, columns, aggregate on
    data, and many other operations. You can operate with rows or columns without
    suffering the time penalty you would have to pay if you were working on data with
    pure Python. This happens because, under the covers, `pandas` is harnessing the
    power of the NumPy library, which itself draws its incredible speed from the low-level
    implementation of its core. NumPy stands for **Numeric Python**, and it is one
    of the most widely used libraries in the data science environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`结构非常强大。它允许我们对内容进行大量操作。你可以按行或列进行过滤，对数据进行聚合，以及许多其他操作。你可以操作行或列，而无需支付如果你使用纯Python处理数据时必须支付的时间惩罚。这是因为，在幕后，`pandas`正在利用NumPy库的力量，而NumPy本身则从其核心的低级实现中获得了惊人的速度。NumPy代表**Numeric
    Python**，它是数据科学环境中使用最广泛的库之一。'
- en: Using a DataFrame allows us to couple the power of NumPy with spreadsheet-like
    capabilities so that we'll be able to work on our data in a fashion that is similar
    to what an analyst could do. Only, we do it with code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DataFrame`允许我们将NumPy的力量与类似电子表格的功能相结合，这样我们就可以以类似于分析师可以做到的方式处理我们的数据。只是，我们用代码来做。
- en: 'But let''s go back to our project. Let''s see two ways to quickly get a bird''s
    eye view of the data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到我们的项目。让我们看看两种快速获取数据概览的方法：
- en: '`#11`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`#11`'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`count` yields a count of all the non-empty cells in each column. This is good
    to help you understand how sparse your data can be. In our case, we have no missing
    values, so the output is:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`返回每列中所有非空单元格的计数。这有助于你了解你的数据可以有多稀疏。在我们的例子中，我们没有缺失值，所以输出如下：'
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Nice! We have 4,974 rows, and the data type is integers (`dtype: int64` means
    long integers because they take 64 bits each). Given that we have 1,000 users
    and the amount of campaigns per user is a random number between 2 and 8, we''re
    exactly in line with what I was expecting.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '好棒！我们有4,974行数据，数据类型是整数（`dtype: int64`表示长整数，因为它们每个占用64位）。考虑到我们有1,000个用户，每个用户的营销活动数量是一个介于2到8之间的随机数，我们正好符合我预期的结果。'
- en: '`#12`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`#12`'
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`describe` is a nice and quick way to introspect a bit further:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`是一个快速且方便的方法来进一步检查：'
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, it gives us several measures such as `count`, `mean`, `std`
    (standard deviation), `min`, `max`, and shows how data is distributed in the various
    quadrants. Thanks to this method, we could already have a rough idea of how our
    data is structured.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它给出了几个度量，如`count`（计数）、`mean`（平均值）、`std`（标准差）、`min`（最小值）、`max`（最大值），并显示了数据在各个象限中的分布情况。多亏了这个方法，我们已经有了一个关于数据结构的大致了解。
- en: 'Let''s see which are the three campaigns with the highest and lowest budgets:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看预算最高和最低的三个营销活动：
- en: '`#13`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`#13`'
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives the following output (truncated):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出（已截断）：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And (`#14`) a call to `.tail(3)`, shows us the ones with the lowest budget.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以及（`#14`）调用`.tail(3)`，显示了预算最低的几个。
- en: Unpacking the campaign name
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解包营销活动名称
- en: Now it's time to increase the complexity up a bit. First of all, we want to
    get rid of that horrible campaign name (`cmp_name`). We need to explode it into
    parts and put each part in one dedicated column. In order to do this, we'll use
    the `apply` method of the **Series** object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候稍微增加一点复杂性了。首先，我们想要摆脱那个糟糕的营销活动名称（`cmp_name`）。我们需要将其分解成部分，并将每个部分放入一个专门的列中。为了做到这一点，我们将使用**Series**对象的`apply`方法。
- en: The `pandas.core.series.Series` class is basically a powerful wrapper around
    an array (think of it as a list with augmented capabilities). We can extrapolate
    a `Series` object from a `DataFrame` by accessing it in the same way we do with
    a key in a dict, and we can call `apply` on that `Series` object, which will run
    a function feeding each item in the `Series` to it. We compose the result into
    a new `DataFrame`, and then join that `DataFrame` with our beloved `df`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas.core.series.Series`类基本上是一个围绕数组的强大包装器（将其视为具有增强功能的列表）。我们可以通过以字典中键的方式访问它来从`DataFrame`中提取一个`Series`对象，并且可以在该`Series`对象上调用`apply`，这将运行一个函数，将`Series`中的每个项目作为参数传递给它。我们将结果组合成一个新的`DataFrame`，然后将其与我们的`df`合并。'
- en: '`#15`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`#15`'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Within `unpack_campaign_name`, we split the campaign `name` in parts. We use
    `delorean.parse()` to get a proper date object out of those strings (`delorean`
    makes it really easy to do it, doesn''t it?), and then we return the objects.
    A quick peek at the last line reveals:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`unpack_campaign_name`函数中，我们将活动`name`分割成几个部分。我们使用`delorean.parse()`从这些字符串中获取适当的日期对象（`delorean`使这个过程变得非常简单，不是吗？），然后返回这些对象。快速查看最后一行可以发现：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Nice! One important thing: even if the dates appear as strings, they are just
    the representation of the real `date` objects that are hosted in the `DataFrame`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！有一点很重要：即使日期以字符串的形式出现，它们也只是`DataFrame`中托管的真实`date`对象的表示。
- en: 'Another very important thing: when joining two DataFrame instances, it''s imperative
    that they have the same index, otherwise `pandas` won''t be able to know which
    rows go with which. Therefore, when we create `campaign_df`, we set its index
    to the one from `df`. This enables us to join them. When creating this DataFrame,
    we also pass the columns names.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的事情是：在连接两个`DataFrame`实例时，它们必须具有相同的索引，否则`pandas`将无法知道哪些行与哪些行对应。因此，当我们创建`campaign_df`时，我们将它的索引设置为`df`中的索引。这使得我们可以将它们连接起来。在创建此DataFrame时，我们还传递了列名。
- en: '`#16`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`#16`'
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And after the join, we take a peek, hoping to see matching data (output truncated):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接之后，我们进行快速查看，希望看到匹配的数据（输出被截断）：
- en: '`#17`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`#17`'
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Gives:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 得到：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the join was successful; the campaign name and the separate
    columns expose the same data. Did you see what we did there? We're accessing the
    `DataFrame` using the square brackets syntax, and we pass a list of column names.
    This will produce a brand new `DataFrame`, with those columns (in the same order),
    on which we then call `head()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，连接操作成功；活动名称和单独的列显示了相同的数据。您是否看到了我们在这里做了什么？我们正在使用方括号语法访问`DataFrame`，并传递一个列名列表。这将生成一个新的`DataFrame`，包含那些列（按相同顺序），然后我们调用`head()`。
- en: Unpacking the user data
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解包用户数据
- en: We now do the exact same thing for each piece of `user` JSON data. We call `apply`
    on the `user` Series, running the `unpack_user_json` function, which takes a JSON
    `user` object and transforms it into a list of its fields, which we can then inject
    into a brand new DataFrame `user_df`. After that, we'll join `user_df` back with
    `df`, like we did with `campaign_df`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对每个`user` JSON数据片段执行完全相同的事情。我们对`user` `Series`调用`apply`，运行`unpack_user_json`函数，该函数接受一个JSON
    `user`对象并将其转换为字段列表，然后我们可以将其注入到一个全新的DataFrame `user_df`中。之后，我们将`user_df`与`df`合并，就像我们之前对`campaign_df`所做的那样。
- en: '`#18`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`#18`'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Very similar to the previous operation, isn''t it? We should also note here
    that, when creating `user_df`, we need to instruct `DataFrame` about the column
    names and, very important, the index. Let''s join (`#19`) and take a quick peek
    (`#20`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的操作非常相似，不是吗？我们还应该注意，在创建`user_df`时，我们需要指导`DataFrame`关于列名和，非常重要，索引。让我们进行连接（`#19`）并快速查看（`#20`）：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output shows us that everything went well. We're good, but we're not done
    yet.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示一切顺利。我们做得很好，但还没有完成。
- en: 'If you call `df.columns` in a cell, you''ll see that we still have ugly names
    for our columns. Let''s change that:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在单元格中调用`df.columns`，您会看到我们列的名称仍然很丑陋。让我们来改变一下：
- en: '`#21`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`#21`'
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Good! Now, with the exception of `'cmp_name'` and `'user'`, we only have nice
    names.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！现在，除了`'cmp_name'`和`'user'`之外，我们只剩下了一些好听的名称。
- en: 'Completing the `datasetNext` step will be to add some extra columns. For each
    campaign, we have the amount of clicks and impressions, and we have the spent.
    This allows us to introduce three measurement ratios: **CTR**, **CPC**, and **CPI**.
    They stand for **Click Through Rate**, **Cost Per Click**, and **Cost Per Impression**,
    respectively.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤`datasetNext`将是通过添加一些额外的列。对于每个活动，我们有点击次数和展示次数，还有花费。这使我们能够引入三个测量比率：**CTR**、**CPC**和**CPI**。它们分别代表**点击通过率**、**每点击成本**和**每展示成本**。
- en: 'The last two are easy to understand, but CTR is not. Suffice it to say that
    it is the ratio between clicks and impressions. It gives you a measure of how
    many clicks were performed on a campaign advertisement per impression: the higher
    this number, the more successful the advertisement is in attracting users to click
    on it.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个很容易理解，但CTR不是。简单来说，它是点击和展示的比率。它衡量了每次展示中点击活动广告的次数：这个数字越高，广告在吸引用户点击方面就越成功。
- en: '`#22`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`#22`'
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: I wrote this as a function, but I could have just written the code in the cell.
    It's not important. What I want you to notice here is that we're adding those
    three columns with one line of code each, but the `DataFrame` applies the operation
    automatically (the division, in this case) to each pair of cells from the appropriate
    columns. So, even if they are masked as three divisions, these are actually *4974
    * 3* divisions, because they are performed for each row. Pandas does a lot of
    work for us, and also does a very good job in hiding the complexity of it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它写成函数，但我也可以直接在单元格中写代码。这并不重要。我想让你注意的在这里是，我们用一行代码添加了这三个列，但`DataFrame`会自动（在这种情况下是除法）对适当列的每一对单元格执行操作。所以，即使它们被标记为三个除法，实际上也是*4974
    * 3*次除法，因为它们是针对每一行执行的。Pandas为我们做了很多工作，同时也很好地隐藏了它的复杂性。
- en: The function, `calculate_extra_columns,` takes a `DataFrame`, and works directly
    on it. This mode of operation is called **in-place**. Do you remember how `list.sort()`
    was sorting the list? It is the same deal.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`calculate_extra_columns`接受一个`DataFrame`，并直接在其上工作。这种操作模式被称为**原地**。你还记得`list.sort()`是如何排序列表的吗？情况是一样的。
- en: We can take a look at the results by filtering on the relevant columns and calling
    `head`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过筛选相关列并调用`head`来查看结果。
- en: '`#23`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`#23`'
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This shows us that the calculations were performed correctly on each row:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明每个行的计算都是正确的：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, I want to verify the accuracy of the results manually for the first row:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想手动验证第一行的结果准确性：
- en: '`#24`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`#24`'
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It yields the following output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生了以下输出：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is exactly what we saw in the previous output. Of course, I wouldn't normally
    need to do this, but I wanted to show you how can you perform calculations this
    way. You can access a Series (a column) by passing its name to the `DataFrame`,
    in square brackets, and then you access each row by its position, exactly as you
    would with a regular list or tuple.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在之前的输出中看到的内容。当然，我通常不需要这样做，但我想展示你可以这样进行计算。你可以通过将名称传递给`DataFrame`（在方括号中），然后通过其位置访问每个行，就像你使用常规列表或元组一样，来访问一个序列（一个列）。
- en: We're almost done with our `DataFrame`. All we are missing now is a column that
    tells us the duration of the campaign and a column that tells us which day of
    the week corresponds to the start date of each campaign. This allows me to expand
    on how to play with date objects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们的`DataFrame`。我们现在缺少的是告诉我们活动持续时间的列和告诉我们每个活动开始日期对应星期几的列。这让我可以进一步讲解如何操作日期对象。
- en: '`#25`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`#25`'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We used two different techniques here but first, the code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两种不同的技术，但首先，是代码。
- en: '`get_day_of_the_week` takes a date object. If you cannot understand what it
    does, please take a few moments to try and understand for yourself before reading
    the explanation. Use the inside-out technique like we''ve done a few times before.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_day_of_the_week`接受一个日期对象。如果你不能理解它是做什么的，请在阅读解释之前花几分钟时间尝试自己理解。使用我们之前几次使用过的内外技术。'
- en: So, as I'm sure you know by now, if you put `calendar.day_name` in a `list`
    call, you get `['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',
    'Sunday']`. This means that, if we enumerate `calendar.day_name` starting from
    1, we get pairs such as `(1, 'Monday')`, `(2, 'Tuesday')`, and so on. If we feed
    these pairs to a dict, we get a mapping between the days of the week as numbers
    (1, 2, 3, ...) and their names. When the mapping is created, in order to get the
    name of a day, we just need to know its number. To get it, we call `date.isoweekday()`,
    which tells us which day of the week that date is (as a number). You feed that
    into the mapping and, boom! You have the name of the day.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你现在可能已经知道的，如果你在`list`调用中放入`calendar.day_name`，你会得到`['Monday', 'Tuesday',
    'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']`。这意味着，如果我们从1开始枚举`calendar.day_name`，我们会得到如`(1,
    'Monday')`、`(2, 'Tuesday')`等对。如果我们将这些对输入到一个字典中，我们就会得到一周中天数（1、2、3、...）和它们名称之间的映射。当映射创建后，为了得到一个天的名称，我们只需要知道它的数字。为了得到它，我们调用`date.isoweekday()`，它告诉我们这个日期是星期几（作为一个数字）。你将这个数字输入到映射中，然后，砰！你就得到了这个天的名称。
- en: '`get_duration` is interesting as well. First, notice it takes an entire row,
    not just a single value. What happens in its body is that we perform a subtraction
    between a campaign end and start dates. When you subtract date objects the result
    is a `timedelta` object, which represents a given amount of time. We take the
    value of its `.days` property. It is as simple as that.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_duration`同样有趣。首先，注意它接受整个行，而不仅仅是单个值。在其主体中发生的事情是我们执行活动结束日期和开始日期之间的减法。当你从日期对象中减去时，结果是`timedelta`对象，它表示给定的时间量。我们取其`.days`属性的值。就这么简单。'
- en: Now, we can introduce the fun part, the application of those two functions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以介绍有趣的部分，即这两个函数的应用。
- en: The first application is performed on a `Series` object, like we did before
    for `'user'` and `'cmp_name'`, there is nothing new here.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个应用是在一个`Series`对象上执行的，就像我们之前对`'user'`和`'cmp_name'`所做的那样，这里没有什么新的。
- en: The second one is applied to the whole DataFrame and, in order to instruct Pandas
    to perform that operation on the rows, we pass `axis=1`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作应用于整个DataFrame，为了指示Pandas在行上执行该操作，我们传递`axis=1`。
- en: 'We can verify the results very easily, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地验证结果，如下所示：
- en: '`#26`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`#26`'
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Yields:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'Yields:'
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, we now know that between the 26th of August 2015 and the 5th of March 2017
    there are 557 days, and that the 26th of August 2015 was a Wednesday.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道，从2015年8月26日到2017年3月5日之间有557天，而且2015年8月26日是一个星期三。
- en: If you're wondering what the purpose of this is, I'll provide an example. Imagine
    that you have a campaign that is tied to a sports event that usually takes place
    on a Sunday. You may want to inspect your data according to the days so that you
    can correlate them to the various measurements you have. We're not going to do
    it in this project, but it was useful to see, if only for the different way of
    calling `apply()` on a DataFrame.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道这个的目的，我会提供一个例子。想象一下，你有一个与通常在星期日举行的一项体育赛事相关的活动。你可能想根据天数检查你的数据，以便你可以将它们与你的各种测量数据相关联。我们不会在这个项目中这样做，但看到不同的方式调用DataFrame上的`apply()`是有用的。
- en: Cleaning everything up
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理一切
- en: 'Now that we have everything we want, it''s time to do the final cleaning: remember
    we still have the `''cmp_name''` and `''user''` columns. Those are useless now,
    so they have to go. Also, I want to reorder the columns in the DataFrame so that
    it is more relevant to the data it now contains. In order to do this, we just
    need to filter `df` on the column list we want. We''ll get back a brand new DataFrame
    that we can reassign to `df` itself.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了我们想要的一切，是时候进行最后的清理了：记住我们仍然有`'cmp_name'`和`'user'`列。这些现在都是无用的，所以它们必须被移除。此外，我想重新排列DataFrame中的列，使其与现在包含的数据更加相关。为了做到这一点，我们只需要根据我们想要的列列表过滤`df`。我们将得到一个新的DataFrame，我们可以将其重新分配给`df`本身。
- en: '`#27`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`#27`'
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I have grouped the campaign information at the beginning, then the measurements,
    and finally the user data at the end. Now our DataFrame is clean and ready for
    us to inspect.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我在开始时将活动信息分组，然后是测量数据，最后是用户数据。现在我们的DataFrame已经清理干净，准备好供我们检查。
- en: Before we start going crazy with graphs, what about taking a snapshot of our
    DataFrame so that we can easily reconstruct it from a file, rather than having
    to redo all the steps we did to get here. Some analysts may want to have it in
    spreadsheet form, to do a different kind of analysis than the one we want to do,
    so let's see how to save a DataFrame to a file. It's easier done than said.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始疯狂绘制图表之前，为什么不先对我们的 DataFrame 拍个快照，这样我们就可以轻松地从文件中重建它，而不是不得不重新执行我们为了到达这里所做的一切步骤。一些分析师可能希望将其以电子表格的形式保存，以便进行与我们想要进行的分析不同的分析，所以让我们看看如何将
    DataFrame 保存到文件。这比说起来容易。
- en: Saving the DataFrame to a file
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DataFrame 保存到文件
- en: We can save a DataFrame in many different ways. You can type `df.to_` and then
    press *Tab* to make auto-completion pop up, to see all the possible options.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用许多不同的方式保存 DataFrame。你可以输入 `df.to_` 然后按 *Tab* 键来弹出自动完成，查看所有可能的选项。
- en: 'We''re going to save our DataFrame in three different formats, just for fun:
    **comma-separated values** (**CSV**), JSON, and Excel spreadsheet.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保存我们的 DataFrame 在三种不同的格式中，只是为了好玩：**逗号分隔值**（**CSV**）、JSON 和 Excel 电子表格。
- en: '`#28`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`#28`'
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`#29`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`#29`'
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`#30`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`#30`'
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The CSV file looks like this (output truncated):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件看起来像这样（输出已截断）：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the JSON one like this (again, output truncated):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 而像这样的 JSON 格式（再次，输出已截断）：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, it''s extremely easy to save a DataFrame in many different formats, and
    the good news is that the opposite is also true: it''s very easy to load a spreadsheet
    into a DataFrame. The programmers behind Pandas went a long way to ease our tasks,
    something to be grateful for.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将 DataFrame 保存为多种格式非常简单，好消息是相反的情况也是真的：将电子表格加载到 DataFrame 中也非常容易。Pandas 背后的程序员走得很远，简化了我们的任务，这是我们应该感激的。
- en: Visualizing the results
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化结果
- en: Finally, the juicy bits. In this section, we're going to visualize some results.
    From a data science perspective, I'm not very interested in going deep into analysis,
    especially because the data is completely random, but nonetheless, this code will
    get you started with graphs and other features.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是精华部分。在本节中，我们将可视化一些结果。从数据科学的角度来看，我对深入分析并不感兴趣，特别是因为数据是完全随机的，但无论如何，这段代码将帮助你开始使用图表和其他功能。
- en: Something I learned in my life—and this may come as a surprise to you—is that
    *looks also counts* so it's very important that when you present your results,
    you do your best to *make them pretty*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我在生活中学到的一件事——这可能会让你感到惊讶——是外表也很重要，所以当你展示你的结果时，你尽最大努力使它们看起来很漂亮。
- en: 'I won''t try to prove to you how truthful that last statement is, but I really
    do believe in it. If you recall the last line of cell `#1`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会试图向你证明最后一个陈述的真实性，但我确实相信它。如果你还记得单元格 `#1` 的最后一行：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Its purpose is to make the graphs we will look at in this section a little bit
    prettier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它的目的是让我们在本节中查看的图表看起来更漂亮一些。
- en: 'Okay, so, first of all we have to instruct the notebook that we want to use
    `matplotlib` `inline`. This means that when we ask Pandas to plot something, we
    will have the result rendered in the cell output frame. In order to do this, we
    just need one simple instruction:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，首先，我们必须指示笔记本我们想要使用 `matplotlib` `inline`。这意味着当我们要求 Pandas 绘制某些内容时，结果将在单元格输出框架中渲染。为了做到这一点，我们只需要一个简单的指令：
- en: '`#31`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`#31`'
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can also instruct the notebook to do this when you start it from the console
    by passing a parameter, but I wanted to show you this way too, since it can be
    annoying to have to restart the notebook just because you want to plot something.
    In this way, you can do it on the fly and then keep working.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传递一个参数来指示笔记本在从控制台启动时执行此操作，但我还想展示这种方法，因为仅仅因为你想绘制一些东西而不得不重新启动笔记本可能会很烦人。这样，你就可以即时操作，然后继续工作。
- en: Next, we're going to set some parameters on `pylab`. This is for plotting purposes
    and it will remove a warning that a font hasn't been found. I suggest that you
    do not execute this line and keep going. If you get a warning that a font is missing,
    come back to this cell and run it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对 `pylab` 设置一些参数。这是为了绘图目的，它将消除一个字体未找到的警告。我建议你不要执行这一行，继续前进。如果你收到一个字体缺失的警告，请回到这个单元格并运行它。
- en: '`#32`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`#32`'
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This basically tells Pylab to use the first available serif font. It is simple
    but effective, and you can experiment with other fonts too.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是告诉 Pylab 使用第一个可用的衬线字体。它简单但有效，你还可以尝试其他字体。
- en: 'Now that the DataFrame is complete, let''s run `df.describe()` (`#33`) again.
    The results should look something like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在DataFrame已经完整，让我们再次运行 `df.describe()` (`#33`)。结果应该看起来像这样：
- en: '![Visualizing the results](img/4715_09_03.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![可视化结果](img/4715_09_03.jpg)'
- en: This kind of quick result is perfect to satisfy those managers who have 20 seconds
    to dedicate to you and just want rough numbers.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这种快速的结果非常适合那些只有20秒时间给你并且只想得到粗略数字的经理。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, please keep in mind that our campaigns have different currencies,
    so these numbers are actually meaningless. The point here is to demonstrate the
    DataFrame capabilities, not to get to a correct or detailed analysis of real data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，请注意，我们的活动有不同的货币，所以这些数字实际上是没有意义的。这里的目的是展示DataFrame的能力，而不是对真实数据进行正确或详细的分析。
- en: 'Alternatively, a graph is usually much better than a table with numbers because
    it''s much easier to read it and it gives you immediate feedback. So, let''s graph
    out the four pieces of information we have on each campaign: budget, spent, clicks,
    and impressions.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，图表通常比数字表格要好得多，因为它更容易阅读，并且能立即给出反馈。所以，让我们绘制出我们每个活动拥有的四条信息：预算、花费、点击和印象。
- en: '`#34`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`#34`'
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We extrapolate those four columns (this will give us another DataFrame made
    with only those columns) and call the histogram `hist()` method on it. We give
    some measurements on the bins and figure sizes, but basically everything is done
    automatically.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们外推这四列（这将给我们另一个只包含这些列的DataFrame）并对其调用`hist()`方法。我们对桶和图形大小给出一些测量，但基本上一切都是自动完成的。
- en: 'One important thing: since this instruction is the only one in this cell (which
    also means, it''s the last one), the notebook will print its result before drawing
    the graph. To suppress this behavior and have only the graph drawn with no printing,
    just add a semicolon at the end (you thought I was reminiscing about Java, didn''t
    you?). Here are the graphs:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一件重要的事情：由于这个指令是这个单元格中唯一的（这也意味着，它是最后一个），笔记本会在绘制图表之前打印出其结果。为了抑制这种行为，只绘制图表而不打印，只需在末尾添加一个分号（你以为我在回忆Java，不是吗？）。以下是图表：
- en: '![Visualizing the results](img/4715_09_04.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![可视化结果](img/4715_09_04.jpg)'
- en: They are beautiful, aren't they? Did you notice the serif font? How about the
    meaning of those figures? If you go back to `#6` and take a look at the way we
    generate the data, you will see that all these graphs make perfect sense.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 它们很漂亮，不是吗？你注意到衬线字体了吗？那些数字的意义是什么？如果你回到`#6`并看看我们生成数据的方式，你会发现所有这些图表都很有意义。
- en: '**Budget** is simply a random integer in an interval, therefore we were expecting
    a *uniform distribution*, and there we have it; it''s practically a constant line.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**预算**是一个区间内的随机整数，因此我们预期的是一个**均匀分布**，看那里；它几乎是一条恒定的线。'
- en: '**Spent** is a *uniform distribution* as well, but the high end of its interval
    is the budget, which is moving, this means we should expect something like a quadratic
    hyperbole that decreases to the right. And there it is as well.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**花费**也是一个**均匀分布**，但它的区间高端是预算，这是在变化的，这意味着我们应该预期一个向右递减的二次抛物线。看那里，它也是这样的。'
- en: '**Clicks** was generated with a *triangular distribution* with mean roughly
    20% of the interval size, and you can see that the peak is right there, at about
    20% to the left.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击**是通过一个平均大约为区间大小20%的**三角分布**生成的，你可以看到峰值就在那里，大约在左侧20%的位置。'
- en: Finally, **Impressions** was a *Gaussian distribution*, which is the one that
    assumes the famous bell shape. The mean was exactly in the middle and we had standard
    deviation of 2\. You can see that the graph matches those parameters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**印象**是一个高斯分布，这是假设著名的钟形曲线的那个分布。平均值正好在中间，我们的标准差是2。你可以看到图表与这些参数相匹配。
- en: 'Good! Let''s plot out the measures we calculated:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！让我们绘制出我们计算出的度量值：
- en: '`#35`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`#35`'
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Visualizing the results](img/4715_09_05.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![可视化结果](img/4715_09_05.jpg)'
- en: We can see that the cost per click is highly skewed to the left, meaning that
    most of the CPC values are very low. The cost per impression has a similar shape,
    but less extreme.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每点击成本高度偏左，这意味着大多数的CPC值都非常低。每印象成本也有类似的形状，但不太极端。
- en: Now, all this is nice, but if you wanted to analyze only a particular segment
    of the data, how would you do it? We can apply a mask to a DataFrame, so that
    we get another one with only the rows that satisfy the mask condition. It's like
    applying a global row-wise `if` clause.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有这些都很好，但如果你只想分析数据的一个特定部分，你会怎么做？我们可以对一个DataFrame应用一个掩码，这样我们就会得到另一个只包含满足掩码条件的行的DataFrame。这就像应用一个全局的行`if`子句。
- en: '`#36`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`#36`'
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, I prepared a mask to filter out all the rows for which the spent
    is less than or equal to 75% of the budget. In other words, we'll include only
    those campaigns for which we have spent at least three quarters of the budget.
    Notice that in the mask I am showing you an alternative way of asking for a DataFrame
    column, by using direct property access (`object.property_name`), instead of dict-like
    access (`object['property_name']`). If `property_name` is a valid Python name,
    you can use both ways interchangeably (JavaScript works like this as well).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我准备了一个面具来过滤掉所有花费小于或等于预算75%的行。换句话说，我们只包括那些至少花费了预算四分之三的活动。注意，在我向你展示的面具中，我展示了请求DataFrame列的另一种方式，即使用直接属性访问（`object.property_name`），而不是类似字典的访问（`object['property_name']`）。如果`property_name`是一个有效的Python名称，你可以互换使用这两种方式（JavaScript也是这样工作的）。
- en: 'The mask is applied in the same way that we access a dict with a key. When
    you apply a mask to a DataFrame, you get back another one and we select only the
    relevant columns on this, and call `hist()` again. This time, just for fun, we
    want the results to be painted green:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 面具的运用方式与我们使用键访问字典的方式相同。当你对一个DataFrame应用一个面具时，你会得到另一个DataFrame，我们只选择这个DataFrame上的相关列，并再次调用`hist()`。这次，为了好玩，我们希望结果被涂成绿色：
- en: '![Visualizing the results](img/4715_09_06.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![可视化结果](img/4715_09_06.jpg)'
- en: Note that the shapes of the graphs haven't changed much, apart from the spent,
    which is quite different. The reason for this is that we've asked only for the
    rows where spent is at least 75% of the budget. This means that we're including
    only the rows where spent is close to the budget. The budget numbers come from
    a uniform distribution. Therefore, it is quite obvious that the spent is now assuming
    that kind of shape. If you make the boundary even tighter, and ask for 85% or
    more, you'll see spent become more and more like budget.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到图形的形状变化不大，除了花费，它相当不同。这是因为我们只请求了花费至少为预算75%的行。这意味着我们只包括花费接近预算的行。预算数字来自均匀分布。因此，现在花费呈现出这种形状是很明显的。如果你将边界设置得更紧，要求85%或更多，你会看到花费越来越接近预算。
- en: Let's now ask for something different. How about the measure of spent, click,
    and impressions grouped by day of the week?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来请求一些不同的事情。关于按星期分组的花费、点击和展示量怎么样？
- en: '`#37`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`#37`'
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first line creates a new `DataFrame`, `df_weekday`, by asking for a grouping
    by `'Day of Week'` on `df`. The function used to aggregate the data is addition.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行通过在`df`上按`'Day of Week'`进行分组来创建一个新的`DataFrame`，名为`df_weekday`。用于聚合数据的功能是加法。
- en: 'The second line gets a slice of `df_weekday` using a list of column names,
    something we''re accustomed to by now. On the result we call `plot()`, which is
    a bit different to `hist()`. The option `subplots=True` makes `plot` draw three
    independent graphs:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行使用列名列表从`df_weekday`中获取一个切片，这是我们现在已经习惯的做法。在结果上我们调用`plot()`，这与`hist()`有点不同。选项`subplots=True`使得`plot`绘制三个独立的图表：
- en: '![Visualizing the results](img/4715_09_07.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![可视化结果](img/4715_09_07.jpg)'
- en: Interestingly enough, we can see that most of the action happens on Thursdays.
    If this were meaningful data, this would potentially be important information
    to give to our clients, and this is the reason I'm showing you this example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们可以看到大部分活动都发生在星期四。如果这是有意义的资料，这可能会成为提供给客户的重要信息，这也是我向你展示这个例子的原因。
- en: Note that the days are sorted alphabetically, which scrambles them up a bit.
    Can you think of a quick solution that would fix the issue? I'll leave it to you
    as an exercise to come up with something.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到天是按字母顺序排序的，这有点打乱了它们的顺序。你能想到一个快速解决问题的方案吗？我会把它留给你作为一个练习，来想出一种方法。
- en: Let's finish this presentation section with a couple more things. First, a simple
    aggregation. We want to aggregate on `'Target Gender'` and `'Target Age'`, and
    show `'Impressions'` and `'Spent'`. For both, we want to see the mean and the
    standard deviation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用几件事情来结束这个演示部分。首先是一个简单的聚合。我们想要对`'Target Gender'`和`'Target Age'`进行聚合，并显示`'Impressions'`和`'Spent'`。对于两者，我们想要看到平均值和标准差。
- en: '`#38`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`#38`'
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It's very easy to do it. We will prepare a dictionary that we'll use as a configuration.
    I'm showing you two options to do it. We use a nicer format for `'Impressions'`,
    where we pass a nested dict with description/function as key/value pairs. On the
    other hand, for `'Spent'`, we just use a simpler list with just the function names.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事非常简单。我们将准备一个字典，我们将用它作为配置。我向你展示了两种做这件事的方法。对于`'Impressions'`，我们使用更漂亮的格式，其中我们传递一个嵌套字典，以描述/函数作为键/值对。另一方面，对于`'Spent'`，我们只使用一个简单的列表，只包含函数名。
- en: 'Then, we perform a grouping on the `''Target Gender''` and `''Target Age''`
    columns, and we pass our configuration dict to the `agg()` method. The result
    is truncated and rearranged a little bit to make it fit, and shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`'Target Gender'`和`'Target Age'`列上执行分组，并将我们的配置字典传递给`agg()`方法。结果被截断并稍微重新排列，以适应显示，如下所示：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is the textual representation, of course, but you can also have the HTML
    one. You can see that `Spent` has the `mean` and `std` columns whose labels are
    simply the function names, while `Impressions` features the nice titles we added
    to the configuration dict.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一种文本表示，但你也可以有HTML版本。你可以看到`Spent`有`mean`和`std`列，其标签仅仅是函数名，而`Impressions`则展示了我们添加到配置字典中的美好标题。
- en: Let's do one more thing before we wrap this chapter up. I want to show you something
    called a **pivot table**. It's kind of a buzzword in the data environment, so
    an example such as this one, albeit very simple, is a must.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，让我们再做一些事情。我想向你展示一个叫做**交叉表**的东西。在数据环境中，这有点像是一个热门词汇，所以像这样一个虽然非常简单但却是必须的例子。
- en: '`#39`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`#39`'
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We create a pivot table that shows us the correlation between the target age
    and impressions, clicks, and spent. These last three will be subdivided according
    to the target gender. The aggregation function used to calculate the results is
    the `numpy.sum` function (`numpy.mean` would be the default, had I not specified
    anything).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个交叉表，展示了目标年龄与展示次数、点击次数和花费之间的相关性。后三者将根据目标性别进行细分。用于计算结果的聚合函数是`numpy.sum`函数（如果没有指定，默认将是`numpy.mean`）。
- en: 'After creating the pivot table, we simply print it with the last line in the
    cell, and here''s a crop of the result:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建交叉表后，我们只需在单元格的最后一行打印它，这里是结果的截图：
- en: '![Visualizing the results](img/4715_09_08.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![可视化结果](img/4715_09_08.jpg)'
- en: It's pretty clear and provides very useful information when the data is meaningful.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据有意义时，它非常清晰，并提供了非常有用的信息。
- en: That's it! I'll leave you to discover more about the wonderful world of IPython,
    Jupyter, and data science. I strongly encourage you to get comfortable with the
    notebook environment. It's much better than a console, it's extremely practical
    and fun to use, and you can even do slides and documents with it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我将让你去发现更多关于IPython、Jupyter和数据科学的奇妙世界。我强烈建议你熟悉笔记本环境。它比控制台好得多，它极其实用且使用起来很有趣，你甚至可以用它来做幻灯片和文档。
- en: Where do we go from here?
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们接下来该去哪里？
- en: 'Data science is indeed a fascinating subject. As I said in the introduction,
    those who want to delve into its meanders need to be well trained in mathematics
    and statistics. Working with data that has been interpolated incorrectly renders
    any result about it useless. The same goes for data that has been extrapolated
    incorrectly or sampled with the wrong frequency. To give you an example, imagine
    a population of individuals that are aligned in a queue. If, for some reason,
    the gender of that population alternated between male and female, the queue would
    be something like this: F-M-F-M-F-M-F-M-F...'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学确实是一个迷人的主题。正如我在引言中所说，那些想要深入其迷宫的人需要在数学和统计学方面接受良好的训练。处理被错误插值的数据会使任何关于它的结果都变得无用。同样，对于被错误外推或以错误频率采样的数据也是如此。为了给你一个例子，想象一个个体排列在队列中的人群。如果出于某种原因，这个群体的性别在男性和女性之间交替，队列将类似于这样：F-M-F-M-F-M-F-M-F...
- en: If you sampled it taking only the even elements, you would draw the conclusion
    that the population was made up only of males, while sampling the odd ones would
    tell you exactly the opposite.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只采样偶数元素，你会得出结论说这个群体只由男性组成，而采样奇数元素则会告诉你正好相反。
- en: Of course, this was just a silly example, I know, but believe me it's very easy
    to make mistakes in this field, especially when dealing with big data where sampling
    is mandatory and therefore, the quality of the introspection you make depends,
    first and foremost, on the quality of the sampling itself.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个愚蠢的例子，我知道，但请相信我，在这个领域很容易出错，尤其是在处理大数据时，采样是强制性的，因此，您进行的内省的质量首先取决于采样的质量。
- en: 'When it comes to data science and Python, these are the main tools you want
    to look at:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到数据科学和Python时，这些是您想要查看的主要工具：
- en: '**NumPy** ([http://www.numpy.org/](http://www.numpy.org/)): This is the fundamental
    package for scientific computing with Python. It contains a powerful N-dimensional
    array object, sophisticated (broadcasting) functions, tools for integrating C/C++
    and Fortran code, useful linear algebra, Fourier transform, random number capabilities,
    and much more.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy** ([http://www.numpy.org/](http://www.numpy.org/)): 这是Python科学计算的基础包。它包含一个强大的N维数组对象，复杂的（广播）函数，用于集成C/C++和Fortran代码的工具，有用的线性代数、傅里叶变换、随机数能力以及更多。'
- en: '**Scikit-Learn** ([http://scikit-learn.org/stable/](http://scikit-learn.org/stable/)):
    This is probably the most popular machine learning library in Python. It has simple
    and efficient tools for data mining and data analysis, accessible to everybody,
    and reusable in various contexts. It''s built on NumPy, SciPy, and Matplotlib.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scikit-Learn** ([http://scikit-learn.org/stable/](http://scikit-learn.org/stable/)):
    这可能是Python中最受欢迎的机器学习库。它提供了简单高效的数据挖掘和分析工具，对每个人都是可访问的，并且可以在各种环境中重复使用。它是基于NumPy、SciPy和Matplotlib构建的。'
- en: '**Pandas** ([http://pandas.pydata.org/](http://pandas.pydata.org/)): This is
    an open source, BSD-licensed library providing high-performance, easy-to-use data
    structures, and data analysis tools. We''ve used it throughout this whole chapter.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pandas** ([http://pandas.pydata.org/](http://pandas.pydata.org/)): 这是一个开源的、BSD许可的库，提供高性能、易于使用的数据结构和数据分析工具。我们在这整个章节中都用到了它。'
- en: '**IPython** ([http://ipython.org/](http://ipython.org/)) / Jupyter ([http://jupyter.org/](http://jupyter.org/)):
    These provide a rich architecture for interactive computing.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPython** ([http://ipython.org/](http://ipython.org/)) / Jupyter ([http://jupyter.org/](http://jupyter.org/)):
    这些提供了丰富的交互式计算架构。'
- en: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/)): This is
    a Python 2D plotting library that produces publication-quality figures in a variety
    of hard copy formats and interactive environments across platforms. Matplotlib
    can be used in Python scripts, the Python and IPython shell and notebook, web
    application servers, and six graphical user interface toolkits.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/)): 这是一个Python
    2D绘图库，可以在各种硬拷贝格式和跨平台的交互式环境中生成高质量的出版物。Matplotlib可用于Python脚本、Python和IPython shell和notebook、Web应用程序服务器以及六个图形用户界面工具包。'
- en: '**Numba** ([http://numba.pydata.org/](http://numba.pydata.org/)): This gives
    you the power to speed up your applications with high performance functions written
    directly in Python. With a few annotations, array-oriented and math-heavy Python
    code can be just-in-time compiled to native machine instructions, similar in performance
    to C, C++, and Fortran, without having to switch languages or Python interpreters.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Numba** ([http://numba.pydata.org/](http://numba.pydata.org/)): 这为您提供了使用直接在Python中编写的性能函数来加速应用程序的能力。通过一些注解，面向数组和数学密集型的Python代码可以被即时编译成本地机器指令，其性能与C、C++和Fortran相似，而无需切换语言或Python解释器。'
- en: '**Bokeh** ([http://bokeh.pydata.org/en/latest/](http://bokeh.pydata.org/en/latest/)):
    It''s a Python-interactive visualization library that targets modern web browsers
    for presentation. Its goal is to provide elegant, concise construction of novel
    graphics in the style of D3.js, but also deliver this capability with high-performance
    interactivity over very large or streaming datasets.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bokeh** ([http://bokeh.pydata.org/en/latest/](http://bokeh.pydata.org/en/latest/)):
    这是一个针对现代Web浏览器的Python交互式可视化库，用于展示。其目标是提供类似于D3.js风格的优雅、简洁的图形构建，同时也能在非常大的或流式数据集上提供高性能的交互性。'
- en: Other than these single libraries, you can also find ecosystems such as **SciPy**
    ([http://scipy.org/](http://scipy.org/)) and **Anaconda** ([https://www.continuum.io/](https://www.continuum.io/)),
    which bundle several different packages in order to give you something that just
    works in an "out-of-the-box" fashion.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些单个库之外，您还可以找到如**SciPy** ([http://scipy.org/](http://scipy.org/))和**Anaconda**
    ([https://www.continuum.io/](https://www.continuum.io/))这样的生态系统，它们捆绑了多个不同的包，以便为您提供“开箱即用”的解决方案。
- en: Installing all these tools and their several dependencies is hard on some systems,
    so I suggest that you try out ecosystems as well and see if you are comfortable
    with them. It may be worth it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上安装所有这些工具及其依赖项很困难，所以我建议你也尝试一下生态系统，看看你是否对他们感到舒适。这可能值得尝试。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about data science. Rather than attempting to explain
    anything about this extremely wide subject, we delved into a project. We familiarized
    ourselves with the Jupyter notebook, and with different libraries such as Pandas,
    Matplotlib, NumPy.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了数据科学。而不是试图解释这个极其广泛的主题的任何内容，我们深入了一个项目。我们熟悉了Jupyter笔记本，以及Pandas、Matplotlib、NumPy等不同的库。
- en: Of course, having to compress all this information into one single chapter means
    I could only touch briefly on the subjects I presented. I hope the project we've
    gone through together has been comprehensive enough to give you a good idea about
    what could potentially be the workflow you might follow when working in this field.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，必须将这些信息压缩到一章中意味着我只能简要地触及我提出的主题。我希望我们共同完成的项目足够全面，能够给你一个关于你在这个领域工作时可能遵循的工作流程的好主意。
- en: The next chapter is dedicated to web development. So, make sure you have a browser
    ready and let's go!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于Web开发。所以，请确保你已经准备好了浏览器，我们开始吧！
