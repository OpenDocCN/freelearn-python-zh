<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor092" class="pcalibre calibre4 pcalibre1"/>3</h1>
			<h1 id="_idParaDest-52" class="calibre6"><a id="_idTextAnchor093" class="pcalibre calibre4 pcalibre1"/>Uncovering ROS 2 Core Concepts</h1>
			<p class="calibre3">You will now start your first ROS 2 programs. As <a id="_idIndexMarker099" class="pcalibre calibre4 pcalibre1"/>you will see, a ROS 2 program is called a <strong class="bold">node</strong>.</p>
			<p class="calibre3">What’s inside a node, what does it do, and how do nodes communicate with each other? How do you configure nodes and start several of them at the same time?</p>
			<p class="calibre3">That’s what we will focus on in this chapter. We won’t write any code yet but instead focus on discovering the concepts through hands-on experimentation, using existing demos that were installed along with ROS 2.</p>
			<p class="calibre3">By the end of this chapter, you will have a global understanding of the main ROS 2 core concepts. You will also be familiar with the most important ROS 2 tools that you will use later in all your projects.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In this chapter, I won’t explain everything. We are going to embark on a discovery phase, where we use the different core concepts and guess how they work. Not everything has to make sense right now and don’t worry too much if some concepts are still a bit blurry for you. Just try to get through the chapter by running all the commands yourself.</p>
			<p class="calibre3">The goal here is not to get a complete understanding or to remember all the commands, but rather to get an <em class="italic">intuition</em> of how things work. This will help you tremendously for <em class="italic">Part 2</em> when we go through each concept with much more detail—and develop with them.</p>
			<p class="calibre3">In this chapter, we will cover the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">Running your first node</li>
				<li class="calibre10">Topics</li>
				<li class="calibre10">Services</li>
				<li class="calibre10">Actions</li>
				<li class="calibre10">Parameters</li>
				<li class="calibre10">Launch files<a id="_idTextAnchor094" class="pcalibre calibre4 pcalibre1"/></li>
			</ul>
			<h1 id="_idParaDest-53" class="calibre6"><a id="_idTextAnchor095" class="pcalibre calibre4 pcalibre1"/>Running your first node</h1>
			<p class="calibre3">To understand what a<a id="_idIndexMarker100" class="pcalibre calibre4 pcalibre1"/> node is, we will simply run one and make some observations using some of the most useful ROS 2 tools.</p>
			<p class="calibre3">For this chapter, I recommend having a few<a id="_idIndexMarker101" class="pcalibre calibre4 pcalibre1"/> open terminals. You can start a few terminal windows and arrange them on your screen or run Terminator (see <em class="italic">Extra tools for ROS development</em> in <a href="B22403_02.xhtml#_idTextAnchor048" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 2</em></a>) with at least three tabs. To clear any confusion when running a command, I will also tell you in which terminal to run the command (Terminal 1, Terminal 2, etc.<a id="_idTextAnchor096" class="pcalibre calibre4 pcalibre1"/>).</p>
			<h2 id="_idParaDest-54" class="calibre6"><a id="_idTextAnchor097" class="pcalibre calibre4 pcalibre1"/>Starting a node from the terminal with ros2 run</h2>
			<p class="calibre3">Let’s discover your first ROS 2 tool, and probably the most important one: the <strong class="source-inline1">ros2</strong> command-line tool. You will use this tool all the time in your future projects.</p>
			<p class="calibre3"><strong class="source-inline1">ros2</strong> comes with a lot of functions. We<a id="_idIndexMarker102" class="pcalibre calibre4 pcalibre1"/> will explore some of them in this chapter, and more in the following ones. There is no need to remember all the<a id="_idIndexMarker103" class="pcalibre calibre4 pcalibre1"/> commands: just use them to build an understanding now, and later you will easily be able to retrieve them from the terminal.</p>
			<p class="calibre3">To start a node, you have to follow this template: <strong class="source-inline1">ros2 run &lt;</strong><strong class="source-inline1">package&gt; &lt;executable&gt;</strong>.</p>
			<p class="calibre3">As we will see later, nodes are organized inside packages. That’s why you first need to specify the package name where the node is and the executable name for that node. As we installed ROS Desktop, a lot of demo packages are already included, for example, <strong class="source-inline1">demo_nodes_cpp</strong>.</p>
			<p class="calibre3">In Terminal 1, start the talker node from the <strong class="source-inline1">demo_nodes_cpp</strong> package:</p>
			<pre class="console">
$ ros2 run demo_nodes_cpp talker
[INFO] [1710223859.331462978] [talker]: Publishing: 'Hello World: 1'
[INFO] [1710223860.332262491] [talker]: Publishing: 'Hello World: 2'
[INFO] [1710223861.333233619] [talker]: Publishing: 'Hello World: 3'
^C[INFO] [1710223862.456938986] [rclcpp]: signal_handler(signum=2)</pre>			<p class="calibre3">After you run this command, the node starts. To stop it, simply press <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal where the node is<a id="_idIndexMarker104" class="pcalibre calibre4 pcalibre1"/> running.</p>
			<p class="calibre3">So, what happened here? From what we can observe, this node is simply a program that will print a log in the terminal every second.</p>
			<p class="calibre3">Now, keep the node alive, or start it again if you stopped it. In another terminal (Terminal 2), let’s start a different node, which is the listener node from the same package:</p>
			<pre class="console">
$ ros2 run demo_nodes_cpp listener
[INFO] [1710224252.496221751] [listener]: I heard: [Hello World: 9]
[INFO] [1710224253.497121609] [listener]: I heard: [Hello World: 10]
[INFO] [1710224254.495878769] [listener]: I heard: [Hello World: 11]</pre>			<p class="calibre3">This node is also a simple program that will print some logs in the terminal. However, as you can see, when the two nodes are running (talker and listener), whatever is printed on the talker seems to also be received on the listener, which then prints it.</p>
			<p class="calibre3">In this example, we have two nodes running, and we can clearly see that they communicate with each other. If you stop the talker node, you will see that the listener node stops printing logs as well. When you restart the talker, the listener starts printing what the talker is “sending.”</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Here are a few tips for when you use the <code>ros2</code> command-line tool:</p>
			<p class="callout">Use auto-completion as much as you can. It will make you type commands faster, but more importantly, you will be sure that you type<a id="_idIndexMarker105" class="pcalibre calibre4 pcalibre1"/> the right command, package name, node name, and so on.</p>
			<p class="callout">If you have any doubts about a command or sub-command, you can get help from the terminal by adding <code>-h</code> to the command. For example, use <code>ros2 -h</code> for the global help, or <code>ros2 run -h</code> for help specifically for the run sub-command. There’s no need to remember all the commands if you know where to find the inform<a id="_idTextAnchor098" class="pcalibre calibre4 pcalibre1"/>ation.</p>
			<h2 id="_idParaDest-55" class="calibre6"><a id="_idTextAnchor099" class="pcalibre calibre4 pcalibre1"/>Introspecting the nodes with rqt_graph</h2>
			<p class="calibre3">There is another very useful tool we will discover<a id="_idIndexMarker106" class="pcalibre calibre4 pcalibre1"/> here, which is a good complement to the command line: <strong class="source-inline1">rqt_graph</strong>. This tool will show you all running<a id="_idIndexMarker107" class="pcalibre calibre4 pcalibre1"/> nodes with a nice visual.</p>
			<p class="calibre3">Keep the 2 nodes alive (Terminals 1 and 2) and start <strong class="source-inline1">rqt_graph</strong> in Terminal 3. The command is identical to the tool name:</p>
			<pre class="console">
$ rqt_graph</pre>			<p class="calibre3">This will open a new graphical window, where you should see the two nodes. If you don’t see anything, make sure both nodes are running, and refresh the view by clicking on the button with a refresh icon, in the top-left corner. You can also select <strong class="bold">Nodes/Topics (all)</strong> from the top left drop-down menu. Then, you should get something like this:</p>
			<div><div><img alt="Figure 3.1 – rqt_graph with two nodes" src="img/B22403_03_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1 – rqt_graph with two nodes</p>
			<p class="calibre3">Here, we can see that both nodes are up and running (nothing new for now), but we also see an arrow going from the talker node to a box, and another one from that box to the listener node. This is<a id="_idIndexMarker108" class="pcalibre calibre4 pcalibre1"/> the ROS 2 communication that allows the talker node to send some data—here, some text—to the listener node. We will talk about this communication in the <a id="_idIndexMarker109" class="pcalibre calibre4 pcalibre1"/>next section of this chapter.</p>
			<p class="calibre3">What we can conclude for now is that we started two different ROS programs (nodes) in two different terminals, using the <strong class="source-inline1">ros2 run</strong> command. It seems that those two programs are communicating with each other, and we can confirm that with <strong class="source-inline1">rqt_graph</strong>.</p>
			<p class="calibre3">Before we go further and look at what kind of ROS communication it is, let’s run another set <a id="_idTextAnchor100" class="pcalibre calibre4 pcalibre1"/>of nodes.</p>
			<h2 id="_idParaDest-56" class="calibre6"><a id="_idTextAnchor101" class="pcalibre calibre4 pcalibre1"/>Running a 2D robot simulation</h2>
			<p class="calibre3">The first two nodes we ran <a id="_idIndexMarker110" class="pcalibre calibre4 pcalibre1"/>are very simple programs that print logs on the terminal and send some text between each other.</p>
			<p class="calibre3">Now, stop all existing <a id="_idIndexMarker111" class="pcalibre calibre4 pcalibre1"/>nodes (press <em class="italic">Ctrl</em> + <em class="italic">C</em> in each terminal), and let’s start again with some other nodes. In Terminal 1, run the following command:</p>
			<pre class="console">
$ ros2 run turtlesim turtlesim_node
Warning: Ignoring XDG_SESSION_TYPE=wayland on Gnome. Use QT_QPA_PLATFORM=wayland to run on Wayland anyway.
[INFO] [1710229365.273668657] [turtlesim]: Starting turtlesim with node name /turtlesim
[INFO] [1710229365.288027379] [turtlesim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</pre>			<p class="calibre3">You’ll see a few logs, but more importantly, you will get a new window with a blue background and a turtle <a id="_idIndexMarker112" class="pcalibre calibre4 pcalibre1"/>in the middle. This turtle represents a (very simplified) simulated robot that moves in 2D space.</p>
			<p class="calibre3">In Terminal 2, start <a id="_idIndexMarker113" class="pcalibre calibre4 pcalibre1"/>this second node:</p>
			<pre class="console">
$ ros2 run turtlesim turtle_teleop_key
Reading from keyboard
---------------------------
Use arrow keys to move the turtle.
Use G|B|V|C|D|E|R|T keys to rotate to absolute orientations. 'F' to cancel a rotation.
'Q' to quit.</pre>			<p class="calibre3">After you see this, make sure Terminal 2 is selected, and use the arrow keys (up, down, left, right). When doing this, you should see the turtle robot moving.</p>
			<div><div><img alt="Figure 3.2 – Moving the simulated turtle robot (TurtleSim)" src="img/B22403_03_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Moving the simulated turtle robot (TurtleSim)</p>
			<p class="calibre3">We can already guess that the second node we started (with <strong class="source-inline1">turtle_teleop_key</strong>) is reading the keys you<a id="_idIndexMarker114" class="pcalibre calibre4 pcalibre1"/> press on the keyboard and sending some kind of information/command to the <strong class="source-inline1">turtlesim</strong> node, which then makes the <a id="_idIndexMarker115" class="pcalibre calibre4 pcalibre1"/>turtle robot move. To confirm that, start <strong class="source-inline1">rqt_graph</strong> again on Terminal 3:</p>
			<pre class="console">
$ rqt_graph</pre>			<p class="calibre3">If needed, refresh the view a few times. Select <strong class="bold">Nodes/Topics (all)</strong>, and you’ll see something like this:</p>
			<div><div><img alt="Figure 3.3 – rqt_graph with the turtlesim and teleop_turtle nodes" src="img/B22403_03_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3 – rqt_graph with the turtlesim and teleop_turtle nodes</p>
			<p class="calibre3">We can find a node named <strong class="source-inline1">turtlesim</strong> and another one named <strong class="source-inline1">teleop_turtle</strong>, and we can clearly see that the<a id="_idIndexMarker116" class="pcalibre calibre4 pcalibre1"/> two nodes are communicating with <a id="_idIndexMarker117" class="pcalibre calibre4 pcalibre1"/>each other.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As you can see, the executable name (<code>turtle_teleop_key</code>) we used to start the node is not necessarily the same as the node name (<code>teleop_turtle</code>). We’ll come back to this late<a id="_idTextAnchor102" class="pcalibre calibre4 pcalibre1"/>r in this book.</p>
			<h2 id="_idParaDest-57" class="calibre6"><a id="_idTextAnchor103" class="pcalibre calibre4 pcalibre1"/>Recap – nodes</h2>
			<p class="calibre3">What can we get from those <a id="_idIndexMarker118" class="pcalibre calibre4 pcalibre1"/>two experiments? As you can see, a ROS 2 node can be any kind of computer program that contains:</p>
			<ul class="calibre9">
				<li class="calibre10">Instructions to print logs in the terminal</li>
				<li class="calibre10">Graphical windows (2D, can also be 3D)</li>
				<li class="calibre10">Hardware drivers and more</li>
			</ul>
			<p class="calibre3">A node, on top of being a computer program, also benefits from the ROS 2 functionalities: logs, communication with other nodes, and other features we will discover throughout this book.</p>
			<p class="calibre3">Now that you’ve seen<a id="_idIndexMarker119" class="pcalibre calibre4 pcalibre1"/> how to start a node and use the <strong class="source-inline1">ros2</strong> command-line tool, let’s focus on how they communicate<a id="_idTextAnchor104" class="pcalibre calibre4 pcalibre1"/> with each other.</p>
			<h1 id="_idParaDest-58" class="calibre6"><a id="_idTextAnchor105" class="pcalibre calibre4 pcalibre1"/>Topics</h1>
			<p class="calibre3">Nodes communicate with each other using ROS 2 communication features. There are three types of communication: topics, services, and actions. We will discover all three of them, starting with <strong class="bold">topics</strong>.</p>
			<p class="calibre3">Here, we will make <a id="_idIndexMarker120" class="pcalibre calibre4 pcalibre1"/>some basic discoveries to get an idea of what a ROS 2 topic is, and you’ll learn much more about them, including how to write code for top<a id="_idTextAnchor106" class="pcalibre calibre4 pcalibre1"/>ics, in <a href="B22403_05.xhtml#_idTextAnchor211" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 5</em></a>.</p>
			<h2 id="_idParaDest-59" class="calibre6"><a id="_idTextAnchor107" class="pcalibre calibre4 pcalibre1"/>Running a topic publisher and subscriber</h2>
			<p class="calibre3">Stop all running nodes (<em class="italic">Ctrl</em> + <em class="italic">C</em>), and let’s come back to our first example.</p>
			<p class="calibre3">In Terminal 1, input <a id="_idIndexMarker121" class="pcalibre calibre4 pcalibre1"/>the following:</p>
			<pre class="console">
$ ros2 run demo_nodes_cpp talker</pre>			<p class="calibre3">In Terminal 2, input the following:</p>
			<pre class="console">
$ ros2 run demo_nodes_cpp listener</pre>			<p class="calibre3">In Terminal 3, input the following:</p>
			<pre class="console">
$ rqt_graph</pre>			<p class="calibre3">If needed, refresh the view a few times, select <strong class="bold">Nodes/Topics (all)</strong>, and you should get the same visual as in <em class="italic">Figure 3</em><em class="italic">.1</em>.</p>
			<p class="calibre3">In the middle, you <a id="_idIndexMarker122" class="pcalibre calibre4 pcalibre1"/>will see a <strong class="source-inline1">/chatter</strong> box. This box represents a ROS 2 topic. What you can also see is that the talker node is sending something to the <strong class="source-inline1">/chatter</strong> topic, which will then be received by the listener node.</p>
			<p class="calibre3">We say that the <a id="_idIndexMarker123" class="pcalibre calibre4 pcalibre1"/>talker is a <strong class="bold">publisher</strong>, and the listener is a <strong class="bold">subscriber</strong>.</p>
			<p class="calibre3">An important detail is that the<a id="_idIndexMarker124" class="pcalibre calibre4 pcalibre1"/> talker is not actually sending data directly to the listener. The talker is publishing on the <strong class="source-inline1">/chatter</strong> topic, and the listener is subscribing to the <strong class="source-inline1">/chatter</strong> topic. Because of this, the data flows from the t<a id="_idTextAnchor108" class="pcalibre calibre4 pcalibre1"/>alker to the listener.</p>
			<h2 id="_idParaDest-60" class="calibre6"><a id="_idTextAnchor109" class="pcalibre calibre4 pcalibre1"/>A name and an interface (data type)</h2>
			<p class="calibre3">From <strong class="source-inline1">rqt_graph</strong>, we can already see that one node can send data to another node through a topic. An important point is that the topic is defined by a name. Both publishers and subscribers use the same name to make communication successful.</p>
			<p class="calibre3">There is more to it than just a <a id="_idIndexMarker125" class="pcalibre calibre4 pcalibre1"/>name. Let’s come back to the terminal and use the <strong class="source-inline1">ros2</strong> command-line tool to discover more information.</p>
			<p class="calibre3">You previously used <strong class="source-inline1">ros2 run</strong> to start a node. We also have <strong class="source-inline1">ros2 topic</strong> to interact with topics. You can get more help with all available topic commands with <strong class="source-inline1">ros2 topic -h</strong>. The <strong class="source-inline1">ros2 topic list</strong> command will list all available topics, which means all topic communications between running<a id="_idIndexMarker126" class="pcalibre calibre4 pcalibre1"/> nodes.</p>
			<p class="calibre3">In Terminal 3 (if you stopped <strong class="source-inline1">rqt_graph</strong>), or in Terminal 4, run the following:</p>
			<pre class="console">
$ ros2 topic list
/chatter
/parameter_events
/rosout</pre>			<p class="calibre3">For any node you create, you will always see <strong class="source-inline1">/rosout</strong> and <strong class="source-inline1">/parameter_events</strong>. Those are not important for now and you can just ignore them. What’s important is the <strong class="source-inline1">/chatter</strong> topic. We already know it’s used between the talker and listener node, but now the question is this: What kind of data is being sent?</p>
			<p class="calibre3">To get this information, we can use <strong class="source-inline1">ros2 topic </strong><strong class="source-inline1">info &lt;topic_name&gt;</strong>:</p>
			<pre class="console">
$ ros2 topic info /chatter
Type: std_msgs/msg/String
Publisher count: 1
Subscription count: 1</pre>			<p class="calibre3">Here, we see how many nodes are publishing and subscribing to this topic. We have one publisher (talker node) and one subscriber (listener node). We <a id="_idIndexMarker127" class="pcalibre calibre4 pcalibre1"/>can also see what kind of message is being sent: <strong class="source-inline1">std_msgs/msg/String</strong>. In ROS 2, this message is<a id="_idIndexMarker128" class="pcalibre calibre4 pcalibre1"/> called an <strong class="bold">interface</strong>.</p>
			<p class="calibre3">To see what’s inside an interface, run <strong class="source-inline1">ros2 interface </strong><strong class="source-inline1">show &lt;interface_name&gt;</strong>:</p>
			<pre class="console">
$ ros2 interface show std_msgs/msg/String
# Some comments
string data</pre>			<p class="calibre3">There can be a bunch of comments (starting with <strong class="source-inline1">#</strong>) that you can ignore. The important thing is this: <strong class="source-inline1">string data</strong>. This tells us what’s being sent on that topic. Here, it’s a string (chain of characters) with the name <strong class="source-inline1">data</strong>.</p>
			<p class="calibre3">So, when the talker node wants to send a message to the <strong class="source-inline1">/chatter</strong> topic, it needs to send a <strong class="source-inline1">data</strong> field of type string. The listener, to get that information, will need to subscribe to <strong class="source-inline1">/chatter</strong>, and expect to receive the same data type.</p>
			<p class="calibre3">That is how a topic is defined: a name and an interface (data type). Both publishers and subscribers should use the same name and interface to communicate.</p>
			<p class="calibre3">This makes sense: as an analogy, imagine you and I are talking through an online chat. If we are not in the same chat room (same topic name), we won’t be able to find each other. Also, if I’m talking to you in a language you don’t speak, this would not make sense to you. To communicate, we both need to agree on what languag<a id="_idTextAnchor110" class="pcalibre calibre4 pcalibre1"/>e we use (same interface).</p>
			<h2 id="_idParaDest-61" class="calibre6"><a id="_idTextAnchor111" class="pcalibre calibre4 pcalibre1"/>More experimentation with topics</h2>
			<p class="calibre3">Let’s practice a bit more with a <a id="_idIndexMarker129" class="pcalibre calibre4 pcalibre1"/>challenge. This time, I won’t just show you what commands to run directly but give you a challenge so you can practice on your own.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I will sometimes give you some challenges/activities in this book with various levels of difficulty —this first challenge being quite small. I will then give you the solution (or a part of it). Of course, I encourage you to stop reading after the instructions and only use the previous pages to solve the challenge. Then, read the solution and co<a id="_idTextAnchor112" class="pcalibre calibre4 pcalibre1"/>mpare it with what you did.</p>
			<h3 class="calibre8">Challenge</h3>
			<p class="calibre3">Run the second example we did <a id="_idIndexMarker130" class="pcalibre calibre4 pcalibre1"/>with the 2D <strong class="source-inline1">turtlesim</strong> robot (two nodes).</p>
			<p class="calibre3">What I challenge you to do right now is to find the topic name and interface used by the <strong class="source-inline1">turtle_teleop</strong> node to send a velocity command to the <strong class="source-inline1">turtlesim</strong> node. Use the previous commands from this chapter to <a id="_idTextAnchor113" class="pcalibre calibre4 pcalibre1"/>try to get that information.</p>
			<h3 class="calibre8">Solution</h3>
			<p class="calibre3">Start the two nodes and <strong class="source-inline1">rqt_graph</strong>.</p>
			<p class="calibre3">In Terminal 1, input the<a id="_idIndexMarker131" class="pcalibre calibre4 pcalibre1"/> following:</p>
			<pre class="console">
$ ros2 run turtlesim turtlesim_node</pre>			<p class="calibre3">In Terminal 2, input the following:</p>
			<pre class="console">
$ ros2 run turtlesim turtle_teleop_key</pre>			<p class="calibre3">In Terminal 3, input the following:</p>
			<pre class="console">
$ rqt_graph</pre>			<p class="calibre3">Make sure you refresh the view on <strong class="source-inline1">rqt_graph</strong> and select <strong class="bold">Nodes/Topics (all)</strong>. You will get the same as previously, as in <em class="italic">Figure 3</em><em class="italic">.3</em>.</p>
			<p class="calibre3">There are some more things on this screen, but we just need one piece of information. As you can see, there is a <strong class="source-inline1">/turtle1/cmd_vel</strong> box, here representing a topic. The <strong class="source-inline1">teleop_turtle</strong> node is a publisher, and the <strong class="source-inline1">turtlesim</strong> node is a subscriber to that topic.</p>
			<p class="calibre3">This is quite logical: the <strong class="source-inline1">teleop_turtle</strong> node will read the keys that you press, and then publish on the topic. On its end, the <strong class="source-inline1">turtlesim</strong> node will subscribe to that topic to get the latest velocity command for the robot.</p>
			<p class="calibre3">We can get roughly the same information from the terminal:</p>
			<pre class="console">
$ ros2 topic list
/parameter_events
/rosout
/turtle1/cmd_vel
/turtle1/color_sensor
/turtle1/pose</pre>			<p class="calibre3">From the list of all running topics, we can spot the <strong class="source-inline1">/</strong><strong class="source-inline1">turtle1/cmd_vel</strong> topic.</p>
			<p class="calibre3">Now, to retrieve the<a id="_idIndexMarker132" class="pcalibre calibre4 pcalibre1"/> interface (data type) for that topic, run the following command:</p>
			<pre class="console">
$ ros2 topic info /turtle1/cmd_vel
Type: geometry_msgs/msg/Twist
Publisher count: 1
Subscription count: 1</pre>			<p class="calibre3">For the details of what’s inside the interface, run the following command:</p>
			<pre class="console">
$ ros2 interface show geometry_msgs/msg/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
      float64 x
      float64 y
      float64 z
Vector3  angular
      float64 x
      float64 y
      float64 z</pre>			<p class="calibre3">This interface is a bit more complex than the one we had before. There’s no need to make sense of all of that for now, as we will dive into interfaces later in this book. The goal here is just to find a topic name and interface.</p>
			<p class="calibre3">From this information, let’s<a id="_idIndexMarker133" class="pcalibre calibre4 pcalibre1"/> say we want to make the robot move forward. We can guess that we would need to set a value for the <strong class="source-inline1">x</strong> field, inside the <strong class="source-inline1">linear</strong> field (as<a id="_idTextAnchor114" class="pcalibre calibre4 pcalibre1"/> <strong class="source-inline1">x</strong> is pointing forward in ROS).</p>
			<h2 id="_idParaDest-62" class="calibre6"><a id="_idTextAnchor115" class="pcalibre calibre4 pcalibre1"/>Recap – topics</h2>
			<p class="calibre3">With those two experiments, you can see that nodes communicate with each other using topics. One node can publish or <a id="_idIndexMarker134" class="pcalibre calibre4 pcalibre1"/>subscribe to a topic. When publishing, the node sends some data. When subscribing, it receives the data.</p>
			<p class="calibre3">A topic is defined by a name and a data type. That’s all you need to remember for now. Let’s switch to the seco<a id="_idTextAnchor116" class="pcalibre calibre4 pcalibre1"/>nd communication type: services.</p>
			<h1 id="_idParaDest-63" class="calibre6"><a id="_idTextAnchor117" class="pcalibre calibre4 pcalibre1"/>Services</h1>
			<p class="calibre3">Topics are very useful to <a id="_idIndexMarker135" class="pcalibre calibre4 pcalibre1"/>send a stream of data/commands from one node to another node. However, this is not the only way to communicate. You can also find client/server communications in ROS 2. In this case, <strong class="bold">services</strong> will be used.</p>
			<p class="calibre3">As we did for topics, we will run two nodes communicating with each other, this time with services, and we will try to analyze, using the ROS 2 tools, what’s happening and how the communication is working.</p>
			<p class="calibre3">In <a href="B22403_06.xhtml#_idTextAnchor282" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 6</em></a>, you will get a much more detailed explanation about services, when to use them versus topics, and how to include them in your code. For now, let’s just c<a id="_idTextAnchor118" class="pcalibre calibre4 pcalibre1"/>ontinue with our discovery phase.</p>
			<h2 id="_idParaDest-64" class="calibre6"><a id="_idTextAnchor119" class="pcalibre calibre4 pcalibre1"/>Running a service server and client</h2>
			<p class="calibre3">Stop all running nodes. This time, we will start another node from <strong class="source-inline1">demo_nodes_cpp</strong>, which contains a<a id="_idIndexMarker136" class="pcalibre calibre4 pcalibre1"/> simple service server to add two integer numbers. We will also start a <strong class="bold">client</strong> node, which<a id="_idIndexMarker137" class="pcalibre calibre4 pcalibre1"/> will send a<a id="_idIndexMarker138" class="pcalibre calibre4 pcalibre1"/> request to the <strong class="bold">server</strong> node.</p>
			<p class="calibre3">In Terminal 1, input the following:</p>
			<pre class="console">
$ ros2 run demo_nodes_cpp add_two_ints_server</pre>			<p class="calibre3">In Terminal 2, input the following:</p>
			<pre class="console">
$ ros2 run demo_nodes_cpp add_two_ints_client</pre>			<p class="calibre3">As soon as you run the client node, you can see this log in Terminal 1 (server):</p>
			<pre class="console">
[INFO] [1710301834.789596504] [add_two_ints_server]: Incoming request
a: 2 b: 3</pre>			<p class="calibre3">You can also see this log in Terminal 2 (client):</p>
			<pre class="console">
[INFO] [1710301834.790073100] [add_two_ints_client]: Result of add_two_ints: 5</pre>			<p class="calibre3">From what we observe here, it<a id="_idIndexMarker139" class="pcalibre calibre4 pcalibre1"/> seems that the server node is hanging and waiting. The client node will send a request to the server, with two integer numbers, in this example: <strong class="source-inline1">2</strong> and <strong class="source-inline1">3</strong>. The server node receives the request, adds the number, and returns the result: <strong class="source-inline1">5</strong>. Then, the client gets the response and prints the result.</p>
			<p class="calibre3">This is basically how a service works in ROS 2. You run one node that contains a server, then any other node (client) can send a request to that server. The server processes the request and r<a id="_idTextAnchor120" class="pcalibre calibre4 pcalibre1"/>eturns a response to the client node.</p>
			<h2 id="_idParaDest-65" class="calibre6"><a id="_idTextAnchor121" class="pcalibre calibre4 pcalibre1"/>A name and an interface (data type)</h2>
			<p class="calibre3">As for topics, services are defined by<a id="_idIndexMarker140" class="pcalibre calibre4 pcalibre1"/> two things: a name, and an interface (data type). The <a id="_idIndexMarker141" class="pcalibre calibre4 pcalibre1"/>only difference is that the interface will contain two<a id="_idIndexMarker142" class="pcalibre calibre4 pcalibre1"/> parts: a <strong class="bold">request</strong> and a <strong class="bold">response</strong>.</p>
			<p class="calibre3">Unfortunately, <strong class="source-inline1">rqt_graph</strong> does not support <a id="_idIndexMarker143" class="pcalibre calibre4 pcalibre1"/>service introspection—although there are some plans to implement this in future ROS 2 distributions.</p>
			<p class="calibre3">To find the name of the service, we can use the <strong class="source-inline1">ros2</strong> command-line tool again, this time with the <strong class="source-inline1">service</strong> command, followed by <strong class="source-inline1">list</strong>. As you can see, if you understand the way to list all topics, then it’s exactly the same for services.</p>
			<p class="calibre3">At this point, you still have the service node running on Terminal 1, and nothing running on Terminal 2 (as the client stopped after receiving the response). In Terminal 2 or 3, run the following:</p>
			<pre class="console">
$ ros2 service list
/add_two_ints
/add_two_ints_server/describe_parameters
/add_two_ints_server/get_parameter_types
/add_two_ints_server/get_parameters
/add_two_ints_server/list_parameters
/add_two_ints_server/set_parameters
/add_two_ints_server/set_parameters_atomically</pre>			<p class="calibre3">That’s a lot of services. Most of them <a id="_idIndexMarker144" class="pcalibre calibre4 pcalibre1"/>can be discarded. For each node, you automatically get six additional <a id="_idIndexMarker145" class="pcalibre calibre4 pcalibre1"/>services, all of them containing the name <strong class="source-inline1">parameter</strong>. If we ignore them, we can see the <strong class="source-inline1">/add_two_ints</strong> service, which is the service server running on the <strong class="source-inline1">add_two_ints_server</strong> node.</p>
			<p class="calibre3">Great, we found the name. Now, to get the data type, we can use <strong class="source-inline1">ros2 service type &lt;service_name&gt;</strong>, and then <strong class="source-inline1">ros2 interface </strong><strong class="source-inline1">show &lt;interface_name&gt;</strong>:</p>
			<pre class="console">
$ ros2 service type /add_two_ints
example_interfaces/srv/AddTwoInts
$ ros2 interface show example_interfaces/srv/AddTwoInts
int64 a
int64 b
---
int64 sum</pre>			<p class="calibre3">You can see that the interface contains a line with three dashes (<strong class="source-inline1">---</strong>). This is the separation between the<a id="_idIndexMarker146" class="pcalibre calibre4 pcalibre1"/> request and the response. With this, you know that to send a request to the server (as a client), you need to send one integer number named <strong class="source-inline1">a</strong>, and another integer<a id="_idIndexMarker147" class="pcalibre calibre4 pcalibre1"/> number named <strong class="source-inline1">b</strong>. Then, you will receive a resp<a id="_idTextAnchor122" class="pcalibre calibre4 pcalibre1"/>onse containing one integer number named <strong class="source-inline1">sum</strong>.</p>
			<h2 id="_idParaDest-66" class="calibre6"><a id="_idTextAnchor123" class="pcalibre calibre4 pcalibre1"/>Sending a request from the terminal</h2>
			<p class="calibre3">Instead of running the <strong class="source-inline1">add_two_ints_client</strong> node, we can also send a request directly from the terminal. I’m <a id="_idIndexMarker148" class="pcalibre calibre4 pcalibre1"/>adding this here because it’s a very useful way to test a service without requiring an existing client node.</p>
			<p class="calibre3">The syntax is <strong class="source-inline1">ros2 service call &lt;service_name&gt; &lt;interface_name&gt; "&lt;request_in_json&gt;"</strong>. As you can see, we need to provide both the service name and interface.</p>
			<p class="calibre3">Here is an example of how to do that (make sure the server node is still running):</p>
			<pre class="console">
$ ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 4, b: 7}"
waiting for service to become available...
requester: making request: example_interfaces.srv.AddTwoInts_Request(a=4, b=7)
response:
example_interfaces.srv.AddTwoInts_Response(sum=11)</pre>			<p class="calibre3">With this command, we send a request with <strong class="source-inline1">4</strong> and <strong class="source-inline1">7</strong>. The server node will print those logs:</p>
			<pre class="console">
[INFO] [1710302858.634838573] [add_two_ints_server]: Incoming request
a: 4 b: 7</pre>			<p class="calibre3">In the end, on the client si<a id="_idTextAnchor124" class="pcalibre calibre4 pcalibre1"/>de, we get the response that contains <strong class="source-inline1">sum=11</strong>.</p>
			<h2 id="_idParaDest-67" class="calibre6"><a id="_idTextAnchor125" class="pcalibre calibre4 pcalibre1"/>More experimentation with services</h2>
			<p class="calibre3">Here’s another<a id="_idTextAnchor126" class="pcalibre calibre4 pcalibre1"/> challenge for you <a id="_idIndexMarker149" class="pcalibre calibre4 pcalibre1"/>to practice with services.</p>
			<h3 class="calibre8">Challenge</h3>
			<p class="calibre3">Start the <strong class="source-inline1">turtlesim</strong> node, list the existing services, and find how to spawn a new turtle robot in the 2D screen, using the terminal.</p>
			<p class="calibre3">Once again, I recommend<a id="_idIndexMarker150" class="pcalibre calibre4 pcalibre1"/> you take a bit of time to try to do this on your own. Feel free to review all the previous commands from this chapter. No need to remember all of them as you can easily find them in the book, using the <em class="italic">Tab</em> key for <a id="_idTextAnchor127" class="pcalibre calibre4 pcalibre1"/>auto-completion, or by adding <strong class="source-inline1">-h</strong> to any command.</p>
			<h3 class="calibre8">Solution</h3>
			<p class="calibre3">Stop all running<a id="_idIndexMarker151" class="pcalibre calibre4 pcalibre1"/> nodes.</p>
			<p class="calibre3">In Terminal 1, input the following:</p>
			<pre class="console">
$ ros2 run turtlesim turtlesim_node</pre>			<p class="calibre3">In Terminal 2, input the following:</p>
			<pre class="console">
$ ros2 service list
/clear
/kill
/reset
/spawn
/turtle1/set_pen
/turtle1/teleport_absolute
/turtle1/teleport_relative
# There are more services containing "parameter" that we can ignore</pre>			<p class="calibre3">Those are all the services we can use for the <strong class="source-inline1">turtlesim</strong> node. As you can see, we already have quite a lot. In this challenge, you have to spawn a turtle. Great, we can find a <strong class="source-inline1">/</strong><strong class="source-inline1">spawn</strong> service.</p>
			<p class="calibre3">We already have the <a id="_idIndexMarker152" class="pcalibre calibre4 pcalibre1"/>name; now, let’s find the interface (request, response):</p>
			<pre class="console">
$ ros2 service type /spawn
turtlesim/srv/Spawn
$ ros2 interface show turtlesim/srv/Spawn
float32 x
float32 y
float32 theta
string name # Optional.  A unique name will be created and returned if this is empty
---
string name</pre>			<p class="calibre3">Now, we have all the information we need. To send a request to the server, we have to use the <strong class="source-inline1">/spawn</strong> service and the <strong class="source-inline1">turtlesim/srv/Spawn</strong> interface. We can send a request that contains (<strong class="source-inline1">x</strong>, <strong class="source-inline1">y</strong>, <strong class="source-inline1">theta</strong>) coordinates, plus an optional name. Actually, note that all fields in the request are optional. If you don’t provide a value for a field, the default will be <strong class="source-inline1">0</strong> for numbers, and <strong class="source-inline1">""</strong> for strings.</p>
			<p class="calibre3">Let’s now send our request from the terminal:</p>
			<pre class="console">
$ ros2 service call /spawn turtlesim/srv/Spawn "{x: 3.0, y: 4.0}"
waiting for service to become available...
requester: making request: turtlesim.srv.Spawn_Request(x=3.0, y=4.0, theta=0.0, name='')
response:
turtlesim.srv.Spawn_Response(name='turtle2')</pre>			<p class="calibre3">If you look at the 2D window, you will see a new turtle.</p>
			<div><div><img alt="Figure 3.4 – The TurtleSim window after spawning a new turtle" src="img/B22403_03_4.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4 – The TurtleSim window after spawning a new turtle</p>
			<p class="calibre3">This turtle has been <a id="_idIndexMarker153" class="pcalibre calibre4 pcalibre1"/>spawned at the (<strong class="source-inline1">x</strong>, <strong class="source-inline1">y</strong>, <strong class="source-inline1">theta</strong>) coordinates provided in the request. You can try to run the <strong class="source-inline1">ros2 service call</strong> command again a few times with different coordin<a id="_idTextAnchor128" class="pcalibre calibre4 pcalibre1"/>ates, so you can spawn more turtles on the screen.</p>
			<h2 id="_idParaDest-68" class="calibre6"><a id="_idTextAnchor129" class="pcalibre calibre4 pcalibre1"/>Recap – services</h2>
			<p class="calibre3">You have successfully run a client/server communication between two nodes. Once again, a service is defined by a <a id="_idIndexMarker154" class="pcalibre calibre4 pcalibre1"/>name and an interface (request, response).</p>
			<p class="calibre3">For more details about the question of when to use topics versus services, read on, as this is something we will see later in this book when you understand more about each concept. For now, you have just seen two kinds of communication between nodes. Each of them has a name and an interface, and we can already play with them in the terminal.</p>
			<p class="calibre3">There is now<a id="_idTextAnchor130" class="pcalibre calibre4 pcalibre1"/> one more ROS 2 communication to discover: actions.</p>
			<h1 id="_idParaDest-69" class="calibre6"><a id="_idTextAnchor131" class="pcalibre calibre4 pcalibre1"/>Actions</h1>
			<p class="calibre3">A ROS 2 <strong class="bold">action</strong> is basically the same thing as a service (client/server communication), but designed for longer tasks, and when you might want to also get some feedback during the execution, be able to cancel the execution, and so on.</p>
			<p class="calibre3">In robotics, we are making robots <a id="_idIndexMarker155" class="pcalibre calibre4 pcalibre1"/>move. Making a robot move is not something that happens instantly. It could take a fraction of a second, but sometimes a task could take a few seconds/minutes or more. ROS 2 services have been designed for quick execution, for example: a computation, or an immediate action, such as spawning a turtle on a screen. Actions are used whenever a client/server communication might take more time and we want more control over it.</p>
			<p class="calibre3">We will dive into actions with more details in <a href="B22403_07.xhtml#_idTextAnchor338" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 7</em></a>. Actions are what I consider to be an intermediate-level concept, not a beginner one, so I won’t start to go too deep right now. Let’s just continue the discovery phase with a very <a id="_idTextAnchor132" class="pcalibre calibre4 pcalibre1"/>simple example, just to get an idea of how it works.</p>
			<h2 id="_idParaDest-70" class="calibre6"><a id="_idTextAnchor133" class="pcalibre calibre4 pcalibre1"/>Running an action server</h2>
			<p class="calibre3">Stop all running nodes, and <a id="_idIndexMarker156" class="pcalibre calibre4 pcalibre1"/>start the <strong class="source-inline1">turtlesim</strong> node again in Terminal 1:</p>
			<pre class="console">
$ ros2 run turtlesim turtlesim_node</pre>			<p class="calibre3">As you’ve already practiced with topics and services, the following <strong class="source-inline1">ros2</strong> commands will start to look familiar to you. List all existing actions in Terminal 2:</p>
			<pre class="console">
$ ros2 action list
/turtle1/rotate_absolute</pre>			<p class="calibre3">From what we observe, it seems that the <strong class="source-inline1">turtlesim</strong> node contains an action server named <strong class="source-inline1">/turtle1/rotate_absolute</strong>. There is no existing client node for this action, so we will try to interact with it from the terminal. Of course,<a id="_idTextAnchor134" class="pcalibre calibre4 pcalibre1"/> we will need two things: the name and the interface.</p>
			<h2 id="_idParaDest-71" class="calibre6"><a id="_idTextAnchor135" class="pcalibre calibre4 pcalibre1"/>A name and an interface (data type)</h2>
			<p class="calibre3">As for topics and <a id="_idIndexMarker157" class="pcalibre calibre4 pcalibre1"/>services, an action will be defined by a name and an interface. This time, the interface<a id="_idIndexMarker158" class="pcalibre calibre4 pcalibre1"/> contains three parts: <strong class="bold">goal</strong>, <strong class="bold">result</strong>, and <strong class="bold">feedback</strong>.</p>
			<p class="calibre3">The goal and result <a id="_idIndexMarker159" class="pcalibre calibre4 pcalibre1"/>are similar to the<a id="_idIndexMarker160" class="pcalibre calibre4 pcalibre1"/> request and<a id="_idIndexMarker161" class="pcalibre calibre4 pcalibre1"/> response for a service. The feedback is additional data that can be sent by the server to give some feedback during the goal execution.</p>
			<p class="calibre3">To get the action interface, you can run the <strong class="source-inline1">ros2 action info &lt;action_name&gt; -t</strong> command. Don’t forget to add <strong class="source-inline1">-t</strong> (for type), otherwise, you’ll see some details, but no interface:</p>
			<pre class="console">
$ ros2 action info /turtle1/rotate_absolute -t
Action: /turtle1/rotate_absolute
Action clients: 0
Action servers: 1
    /turtlesim [turtlesim/action/RotateAbsolute]</pre>			<p class="calibre3">We can see that the action is running within one server (the <strong class="source-inline1">turtlesim</strong> node), and we also found the interface: <strong class="source-inline1">turtlesim/action/RotateAbsolute</strong>.</p>
			<p class="calibre3">Let’s see what’s inside this interface:</p>
			<pre class="console">
$ ros2 interface show turtlesim/action/RotateAbsolute
# The desired heading in radians
float32 theta
---
# The angular displacement in radians to the starting position
float32 delta
---
# The remaining rotation in radians
float32 remaining</pre>			<p class="calibre3">You can see two separations with three dashes (<strong class="source-inline1">---</strong>). The first part is the goal, the second part is the result, and the third part is the feedback. This action is quite simple; we only have one float number for each part of the interface.</p>
			<p class="calibre3">As a client, we send <a id="_idIndexMarker162" class="pcalibre calibre4 pcalibre1"/>the desired angle for rotation. The server node will receive the goal and process it while optionally sending some feedback. When the goal <a id="_idTextAnchor136" class="pcalibre calibre4 pcalibre1"/>is finished, the server will send the result to the client.</p>
			<h2 id="_idParaDest-72" class="calibre6"><a id="_idTextAnchor137" class="pcalibre calibre4 pcalibre1"/>Sending a goal from the terminal</h2>
			<p class="calibre3">As an action client, we <a id="_idIndexMarker163" class="pcalibre calibre4 pcalibre1"/>are firstly interested in the goal part of the interface. Here, we need to send a float number, which corresponds to the angle (in radians) we want to rotate the turtle to.</p>
			<p class="calibre3">The syntax to send a goal from the terminal is <strong class="source-inline1">ros2 action send_goal &lt;action_name&gt; &lt;action_interface&gt; "&lt;goal_in_json&gt;"</strong>. Once again, you need to provide both the name and interface.</p>
			<p class="calibre3">Make sure the <strong class="source-inline1">turtlesim</strong> node is alive, then send a goal from Terminal 2:</p>
			<pre class="console">
$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.0}"
Waiting for an action server to become available...
Sending goal:
     theta: 1.0
Goal accepted with ID: 3ba92096282a4053b552a161292afc8e
Result:
    delta: -0.9919999837875366
Goal finished with status: SUCCEEDED</pre>			<p class="calibre3">After you run the command, you should see the turtle robot rotate on the 2D window. Once the desired angle is <a id="_idTextAnchor138" class="pcalibre calibre4 pcalibre1"/>reached, the action will finish, and you will receive the result.</p>
			<h2 id="_idParaDest-73" class="calibre6"><a id="_idTextAnchor139" class="pcalibre calibre4 pcalibre1"/>Recap – actions</h2>
			<p class="calibre3">You have run your first action communication in ROS 2. An <strong class="bold">action</strong> is defined by two things: a name and an interface (goal, result, feedback). Actions are used when you need a client/server kind <a id="_idIndexMarker164" class="pcalibre calibre4 pcalibre1"/>of communication, and when the duration of the action might take some time—versus being executed immediately.</p>
			<p class="calibre3">With this, you have seen all three types of communications in ROS 2: topics, services, and actions. Each one will get its own chapter in <em class="italic">Part 2</em> so you can see in detail how they work, how to use them in <a id="_idTextAnchor140" class="pcalibre calibre4 pcalibre1"/>your code, and how to fully introspect them with ROS 2 tools.</p>
			<h1 id="_idParaDest-74" class="calibre6"><a id="_idTextAnchor141" class="pcalibre calibre4 pcalibre1"/>Parameters</h1>
			<p class="calibre3">We are now going to come back to the node itself and talk about another important ROS 2 concept: <strong class="bold">parameters</strong>.</p>
			<p class="calibre3">This time, it’s not about <a id="_idIndexMarker165" class="pcalibre calibre4 pcalibre1"/>communication, but about how to give different settings to a node when you start it.</p>
			<p class="calibre3">Let’s quickly discover how parameters work, and you’ll get a compl<a id="_idTextAnchor142" class="pcalibre calibre4 pcalibre1"/>ete explanation with more examples and use cases in <a href="B22403_08.xhtml#_idTextAnchor394" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 8</em></a>.</p>
			<h2 id="_idParaDest-75" class="calibre6"><a id="_idTextAnchor143" class="pcalibre calibre4 pcalibre1"/>Getting the parameters for a node</h2>
			<p class="calibre3">Stop all running nodes, and<a id="_idIndexMarker166" class="pcalibre calibre4 pcalibre1"/> start the <strong class="source-inline1">turtlesim</strong> node in Terminal 1:</p>
			<pre class="console">
$ ros2 run turtlesim turtlesim_node</pre>			<p class="calibre3">Then, to list all parameters, it’s quite easy, and you can probably guess the command. If we have <strong class="source-inline1">ros2 topic list</strong> for topics, <strong class="source-inline1">ros2 service list</strong> for services, and <strong class="source-inline1">ros2 action list</strong> for actions, then, for parameters, we have <strong class="source-inline1">ros2 param list</strong>. The only particularity is that we use the word <strong class="source-inline1">param</strong> instead of <strong class="source-inline1">parameter</strong>. Run this command in Terminal 2:</p>
			<pre class="console">
$ ros2 param list
/turtlesim:
  background_b
  background_g
  background_r
  holonomic
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  start_type_description_service
  use_sim_time</pre>			<p class="callout-heading">Note</p>
			<p class="callout">Sometimes, the <code>ros2</code> <code>param</code> <code>list</code> command doesn’t work properly and you won’t see any parameters or not all of them. This can also happen with a few other <code>ros2</code> commands. In this case, just run the command again, a few times if needed, and this should work. It’s probably some kind of bug in the <code>ros2</code> command-line tool itself, but nothing to worry about: the application is running correctly.</p>
			<p class="calibre3">We first see the <strong class="source-inline1">turtlesim</strong> node (actually written <strong class="source-inline1">/turtlesim</strong>, with a leading slash), then a list of names under this node, with an indentation. Those names are the parameters, and they belong<a id="_idIndexMarker167" class="pcalibre calibre4 pcalibre1"/> to the node. That’s the first thing about parameters in ROS 2: they exist within a node. If you stop this <strong class="source-inline1">turtlesim</strong> node, then the parameters would also be destroyed.</p>
			<p class="calibre3">There are a bunch of parameters you can ignore: <strong class="source-inline1">use_sim_time</strong>, <strong class="source-inline1">start_type_description_service</strong>, and all the parameters containing <strong class="source-inline1">qos_overrides</strong>. Those will be present for any node you start. If we get rid of them, we are left with a few parameters, including <strong class="source-inline1">background_b</strong>, <strong class="source-inline1">background_g</strong>, <strong class="source-inline1">backgound_r</strong>.</p>
			<p class="calibre3">From this observation, it seems that we would be able to change the background color of the 2D window when we start the <strong class="source-inline1">turtlesim</strong> node.</p>
			<p class="calibre3">Now, what’s inside those parameters? What kind of value? Is it a round number, a float, or a string? Let’s find out, with <strong class="source-inline1">ros2 param get &lt;node_name&gt; &lt;param_name&gt;</strong>. In Terminal 2, run<a id="_idIndexMarker168" class="pcalibre calibre4 pcalibre1"/> the following commands:</p>
			<pre class="console">
$ ros2 param get /turtlesim background_b
Integer value is: 255
$ ros2 param get /turtlesim background_g
Integer value is: 86
$ ros2 param get /turtlesim background_r
Integer value is: 69</pre>			<p class="calibre3">From this, we can guess that the <strong class="bold">red, green, blue</strong> (<strong class="bold">RGB</strong>) value for the background is (<strong class="source-inline1">69</strong>, <strong class="source-inline1">86</strong>, <strong class="source-inline1">255</strong>). It als<a id="_idTextAnchor144" class="pcalibre calibre4 pcalibre1"/>o seems that the <a id="_idIndexMarker169" class="pcalibre calibre4 pcalibre1"/>parameter value is a round number from <strong class="source-inline1">0</strong> to <strong class="source-inline1">255</strong>.</p>
			<h2 id="_idParaDest-76" class="calibre6"><a id="_idTextAnchor145" class="pcalibre calibre4 pcalibre1"/>Setting up a parameter value for a node</h2>
			<p class="calibre3">Now that we have found the<a id="_idIndexMarker170" class="pcalibre calibre4 pcalibre1"/> name of each parameter, and what kind of value we should use, let’s modify the value ourselves when we start the node.</p>
			<p class="calibre3">For this, we will need to restart the node, using the same syntax as before: <strong class="source-inline1">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</strong>. We will then add <strong class="source-inline1">--ros-args</strong> (only once), and <strong class="source-inline1">-p &lt;param_name&gt;:=value</strong> for each parameter we want to modify.</p>
			<p class="calibre3">Stop the <strong class="source-inline1">turtlesim</strong> node on Terminal 1, and start it again, with a different value for some of the parameters:</p>
			<pre class="console">
$ ros2 run turtlesim turtlesim_node --ros-args -p background_b:=0 -p background_r:=0</pre>			<p class="calibre3">Here, we decided that both the blue and red colors would be <strong class="source-inline1">0</strong>. We don’t specify any value for <strong class="source-inline1">background_g</strong>, which means that the default value will be used (as seen previously: <strong class="source-inline1">86</strong>).</p>
			<p class="calibre3">After you run this command, you should see<a id="_idTextAnchor146" class="pcalibre calibre4 pcalibre1"/> the 2D screen appear, but this time, the background is dark green.</p>
			<h2 id="_idParaDest-77" class="calibre6"><a id="_idTextAnchor147" class="pcalibre calibre4 pcalibre1"/>Recap – parameters</h2>
			<p class="calibre3">Parameters are settings that can be provided at runtime (which means when we run the node). They allow us to easily <a id="_idIndexMarker171" class="pcalibre calibre4 pcalibre1"/>configure the different nodes that we start, and thus, they make ROS 2 applications more dynamic.</p>
			<p class="calibre3">A parameter exists within a node. You can find all parameters for a node and get the value for each one. When starting the node<a id="_idTextAnchor148" class="pcalibre calibre4 pcalibre1"/>, you can give a custom value for the parameters you want to modify.</p>
			<h1 id="_idParaDest-78" class="calibre6"><a id="_idTextAnchor149" class="pcalibre calibre4 pcalibre1"/>Launch files</h1>
			<p class="calibre3">Let’s finish this list of ROS 2 concepts with launch files.</p>
			<p class="calibre3">A <strong class="bold">launch file</strong> will allow<a id="_idIndexMarker172" class="pcalibre calibre4 pcalibre1"/> you to start several nodes and parameters from just one file, which means that you can start your entire application with just one command line.</p>
			<p class="calibre3">In <a href="B22403_09.xhtml#_idTextAnchor443" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 9</em></a>, you will learn how to write your own <a id="_idTextAnchor150" class="pcalibre calibre4 pcalibre1"/>launch file, but for now, let’s just start a few to see what they do.</p>
			<h2 id="_idParaDest-79" class="calibre6"><a id="_idTextAnchor151" class="pcalibre calibre4 pcalibre1"/>Starting a launch file</h2>
			<p class="calibre3">To start a single<a id="_idIndexMarker173" class="pcalibre calibre4 pcalibre1"/> node in the terminal, you have seen the <strong class="source-inline1">ros2 run</strong> command. For launch files, we will use <strong class="source-inline1">ros2 launch &lt;</strong><strong class="source-inline1">package_name&gt; &lt;launch_file&gt;</strong>.</p>
			<p class="calibre3">Stop all running nodes, and let’s start the <strong class="source-inline1">talker_listener</strong> launch file from the <strong class="source-inline1">demo_nodes_cpp</strong> package. In Terminal 1, run the following command:</p>
			<pre class="console">
$ ros2 launch demo_nodes_cpp talker_listener_launch.py
[INFO] [launch]: All log files can be found below /home/ed/.ros/log/2024-03-14-16-09-27-384050-ed-vm-2867
[INFO] [launch]: Default logging verbosity is set to INFO
[INFO] [talker-1]: process started with pid [2868]
[INFO] [listener-2]: process started with pid [2871]
[talker-1] [INFO] [1710403768.481156318] [talker]: Publishing: 'Hello World: 1'
[listener-2] [INFO] [1710403768.482142732] [listener]: I heard: [Hello World: 1]</pre>			<p class="calibre3">As you can see, it seems that both the talker and listener nodes have been started. You can easily verify that in Terminal 2:</p>
			<pre class="console">
$ ros2 node list
/listener
/talker</pre>			<p class="calibre3">With <strong class="source-inline1">rqt_graph</strong>, you could also check that the nodes communicate with each other. We have proof of that with the logs: on the same screen, we get both logs from the talker and listener nodes, and it seems that the listener node is receiving messages (using the <strong class="source-inline1">/chatter</strong> topic as we saw previously).</p>
			<p class="calibre3">In the end, it’s the same<a id="_idIndexMarker174" class="pcalibre calibre4 pcalibre1"/> thing as if we had started both nodes on two terminals. The launch file will simply start the two nodes in one terminal.</p>
			<p class="calibre3">If we read the logs more carefully, we can see that each node will be started in a different process. To stop the launch file, press <em class="italic">Ctrl</em> + <em class="italic">C</em>. This will stop all processes (nodes), and your application will end.</p>
			<p class="calibre3">Let’s now try another launch file from the <strong class="source-inline1">turtlesim</strong> package. Stop the launch file in Terminal 1, and start the <strong class="source-inline1">multisim</strong> launch file from the <strong class="source-inline1">turtlesim</strong> package:</p>
			<pre class="console">
$ ros2 launch turtlesim multisim.launch.py
[INFO] [launch]: All log files can be found below /home/ed/.ros/log/2024-03-14-16-14-41-043618-ed-vm-2962
[INFO] [launch]: Default logging verbosity is set to INFO
[INFO] [turtlesim_node-1]: process started with pid [2963]
[INFO] [turtlesim_node-2]: process started with pid [2965]</pre>			<p class="calibre3">With this, you will see not one, but two 2D windows, containing each a turtle robot. As you can see from the logs, we are starting two <strong class="source-inline1">turtlesim</strong> nodes (two identical nodes with a different name each).</p>
			<p class="calibre3">We can also check that from the terminal:</p>
			<pre class="console">
$ ros2 node list
/turtlesim1/turtlesim
/turtlesim2/turtlesim</pre>			<p class="calibre3">The nodes have been renamed. Instead of just <strong class="source-inline1">/turtlesim</strong>, we get <strong class="source-inline1">/turtlesim1/turtlesim</strong> and <strong class="source-inline1">/tur<a id="_idTextAnchor152" class="pcalibre calibre4 pcalibre1"/>tlesim2/turtlesim</strong>. Those names have been chosen inside the launch file.</p>
			<h2 id="_idParaDest-80" class="calibre6"><a id="_idTextAnchor153" class="pcalibre calibre4 pcalibre1"/>Recap – launch files</h2>
			<p class="calibre3">Launch files are quite useful for starting several nodes (and the parameters for those nodes) from one file. With <a id="_idIndexMarker175" class="pcalibre calibre4 pcalibre1"/>just one command line (<strong class="source-inline1">ros2 launch</strong>), you can start an entire ROS 2 application.</p>
			<p class="calibre3">There is not much more to say about launch files for now, as this concept is quite simple (the real challenge is when writing a launch file, not star<a id="_idTextAnchor154" class="pcalibre calibre4 pcalibre1"/>ting it). We have now finished discovering the main ROS 2 concepts.</p>
			<h1 id="_idParaDest-81" class="calibre6"><a id="_idTextAnchor155" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">With this chapter, you have discovered the most important ROS 2 concepts: nodes, topics, services, actions, parameters, and launch files.</p>
			<p class="calibre3">ROS 2 programs are called nodes. Simply put, they are regular software programs that can also benefit from ROS 2 functionalities: logs, communications, parameters, and so on.</p>
			<p class="calibre3">There are three types of communication: topics, services, and actions. Topics are used to send a stream of data/commands from one or several nodes to another or several other nodes. Services are used when we need client/server communication. Actions are basically the same things as services, but for goal executions that could take some time.</p>
			<p class="calibre3">On top of communication features, nodes can also use parameters to specify settings at runtime. Parameters allow nodes to be easily configured when started.</p>
			<p class="calibre3">Finally, we can start all nodes and parameters from just one command line, using a launch file.</p>
			<p class="calibre3">That’s it for the core concepts (for now). You have also discovered the <strong class="source-inline1">ros2</strong> command-line tool and <strong class="source-inline1">rqt_graph</strong>. Those tools are invaluable, and you will use them all the time. The experiments we did with those tools here are very similar to what you will do in the future for your own ROS 2 projects.</p>
			<p class="calibre3">This chapter was a bit special, in a way that it doesn’t fully explain one concept from A to Z. As stated in the introduction, it was more of a concept walkthrough, where you discover the main concepts through hands-on discovery. What you get is not a complete understanding, but an intuition of how things work, a bit of experience with the tools, and an idea of the big picture.</p>
			<p class="calibre3">Feel free to come back to this chapter and run the experiments again as you make progress with the book. Everything will make much more sense.</p>
			<p class="calibre3">You are now ready to continue with <em class="italic">Part 2</em>, where you will create a complete ROS 2 application from scratch, using Python and C++ code. Each concept you’ve seen so far will get its own dedicated chapter. The intuition you’ve developed here will be extremely useful.</p>
		</div>
	</body></html>