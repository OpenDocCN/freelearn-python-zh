<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. GUI-based Media Players Using QT Phonon</h1></div></div></div><div><blockquote class="blockquote"><p>The earlier chapters had focused on developing audio and video processing tools. The involvement of<strong> Graphical User Interface</strong> (GUI) was intentionally kept aside so that we could learn 'pure' multimedia-processing techniques using the GStreamer framework. However, to just 'play' an audio or a video, we would always prefer a media player with a user interface that provides an easy way to control the playback, adjust the volume, and so on.</p></blockquote></div><p>In this chapter, we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Develop a GUI for audio and video players using QT</li><li class="listitem" style="list-style-type: disc">Learn fundamental components of the Phonon framework, such as<code class="literal"> MediaObject, MediaSource, AudioOutput</code>, and so on to build a media graph</li><li class="listitem" style="list-style-type: disc">Learn how to use QT Phonon framework to create media players with graphical user interface</li></ul></div><p>So let's get on with it.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Installation prerequisites</h1></div></div></div><p>We will cover the prerequisites for the installation of QT Python in this section.<a id="id354" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec01"/>PyQt4</h2></div></div></div><p>This package provides Python bindings for QT libraries. We will use PyQt4 to generate GUI for the image processing application to be developed later in this chapter. The GPL version is available at:<a id="id355" class="indexterm"/>
</p><p>
<a class="ulink" href="http://www.riverbankcomputing.co.uk/software/pyqt/download">http://www.riverbankcomputing.co.uk/software/pyqt/download</a>
</p><p>Note that you should install PyQt4 binary for Python version 2.6. The PyQt4 for Python version 2.5 or earlier may not support the Phonon module. Check the PyQt4 documentation to know more. The installation instructions for PyQt4 were already discussed in<a class="link" href="ch02.html" title="Chapter 2. Working with Images"> Chapter 2</a>,<em> Working with Images</em>. Refer to that chapter for further details. The following table summarizes the installation prerequisites.<a id="id356" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec02"/>Summary of installation prerequisites</h2></div></div></div><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Package</p>
</th><th style="text-align: left" valign="bottom">
<p>Download location</p>
</th><th style="text-align: left" valign="bottom">
<p>Version</p>
</th><th style="text-align: left" valign="bottom">
<p>Windows platform</p>
</th><th style="text-align: left" valign="bottom">
<p>Linux/Unix/OS X platforms</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Python</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://python.org/download/releases/">http://python.org/download/releases/</a>
</p>
</td><td style="text-align: left" valign="top">
<p>2.6.4 (or any 2.6.x)</p>
</td><td style="text-align: left" valign="top">
<p>Install using binary distribution</p>
</td><td style="text-align: left" valign="top">
<p>Install from binary. Also install additional developer packages (for example, with python-devel in the package name for rpm-based linux distributions).</p>
<p>Build and install from the source tarball.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PyQt4</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.riverbankcomputing.co.uk/software/pyqt/download">http://www.riverbankcomputing.co.uk/software/pyqt/download</a>
</p>
</td><td style="text-align: left" valign="top">
<p>4.6.2 or later</p>
</td><td style="text-align: left" valign="top">
<p>Install using binary pertaining to Python2.6</p>
</td><td style="text-align: left" valign="top">
<p>First install SIP 4.9 or later.</p>
<p>Then install PyQt4.</p>
</td></tr></tbody></table></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Introduction to QT Phonon</h1></div></div></div><p>In earlier chapters on audio and video processing, we extensively used GStreamer multimedia framework.<strong> Phonon</strong> is a multimedia framework used by QT to provide audio/video playback. With the GStreamer API knowledge under our belt, it should be very easy to grasp the fundamental concepts behind the Phonon multimedia framework.<a id="id357" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec03"/>Main components</h2></div></div></div><p>Let's briefly discuss some of the fundamental components and concepts behind the Phonon architecture.<a id="id358" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec01"/>Media graph</h3></div></div></div><p>This is analogous to a GStreamer<code class="literal"> pipeline</code>. The media graph specifies various<em> nodes</em> (analogous to GStreamer elements) for processing the media stream. For example, the<em> sink</em> node gives the media data as output. To begin streaming the media data within the<code class="literal"> Graph</code>, we call the<code class="literal"> play()method</code> of the<code class="literal"> MediaObject</code> module.<a id="id359" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec02"/>Media object</h3></div></div></div><p>This object is used for the media playback. It is analogous to the portion of a GStreamer pipeline that handles the input media data. The instance of<code class="literal"> MediaObject</code> class is used for this purpose. It provides methods to control the playback, such as playing, pausing, and stopping the streaming media.<a id="id360" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec03"/>Sink</h3></div></div></div><p>Just like in GStreamer, Phonon has a media<code class="literal"> Sink</code>. For example, an audio sink is used to output the audio through an audio output device.<a id="id361" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec04"/>Path</h3></div></div></div><p>The<code class="literal"> Path</code> object is used to connect nodes within a media graph in Phonon. For example, a<code class="literal"> MediaObject</code> node is linked to an<code class="literal"> AudioOutput</code> node to stream an audio.<a id="id362" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec05"/>Effects</h3></div></div></div><p>To manipulate the streaming media, we need to insert<code class="literal"> Effects</code> nodes within the<code class="literal"> Graph</code>, between the source (MediaObject) and the<code class="literal"> Sink</code> nodes. These nodes are also called processors. The<code class="literal"> Effect</code> class of the Phonon framework facilitates adding various effects to the streaming media.<a id="id363" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec04"/>Backends</h2></div></div></div><p>It is a<code class="literal"> backend</code> that does the heavy lifting, which is, processing a media stream in Phonon. On Windows platform the backend framework is<em> DirectShow</em>. If you are using Linux, the backend framework for Phonon is GStreamer and, it is<em> QuickTime</em> in case you use Mac OS X. The supported functionality (for example, the media formats supported) may vary depending on the platform.<a id="id364" class="indexterm"/>
</p><p>The namespace,<code class="literal"> Phonon.BackendCapabilities</code>, includes functions that provide information about what the Phonon backend is capable of doing. For example, the function<code class="literal"> BackendCapabilities.availableMimeTypes()</code> returns a list of all the mime types that the backend is capable of decoding. Additionally, it provides information about the available audio output devices and available effects.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec05"/>Modules</h2></div></div></div><p>Qt Phonon includes several modules that help to quickly develop applications for audio and video playback. We will briefly discuss a few of the important modules.<a id="id365" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec06"/>MediaNode</h3></div></div></div><p>This is the superclass for all the nodes within a Phonon media graph. Therefore, it is inherited by modules such as<code class="literal"> MediaObject, Effect</code>, and<code class="literal"> AudioOutput</code>, which will be discussed next.<a id="id366" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec07"/>MediaSource</h3></div></div></div><p>As the name indicates, this is used to the input the media source. The<code class="literal"> MediaObject</code> uses the media data it provides. The following line of code shows how this is accomplished.<a id="id367" class="indexterm"/>
</p><div><pre class="programlisting">self.mediaObj.setCurrentSource(self.mediaSource)
</pre></div><p>The API method,<code class="literal"> setCurrentSouce</code> of class<code class="literal"> MediaObject</code>, is used to specify the<code class="literal"> MediaSource</code> object from which to obtain the media data.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec08"/>MediaObject</h3></div></div></div><p>As mentioned earlier, the<code class="literal"> MediaObject</code> module defines an API to manage the playback. The methods such as<code class="literal"> play(), pause()</code>, and<code class="literal"> stop()</code> provide playback controls.<a id="id368" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec09"/>Path</h3></div></div></div><p>The<code class="literal"> Path</code> class links the nodes within a graph. It can be created using an API method,<code class="literal"> Phonon.createPath</code>. The following code snippet shows an example usage:<a id="id369" class="indexterm"/>
</p><div><pre class="programlisting">self.audioPath = Phonon.createPath(self.mediaObj, self.audioSink)
</pre></div><p>Here,<code class="literal"> self.audioPath</code> is an instance of<code class="literal"> Path</code> class. It links the instance of class<code class="literal"> MediaObject</code> with<code class="literal"> self.audioSink</code>, which is an instance of class<code class="literal"> AudioOutPut</code>. More nodes can be added to the graph by using<code class="literal"> Path.insertEffect</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec10"/>AudioOutput</h3></div></div></div><p>The instance of this class provides an audio output node in the Phonon media graph. The output device is typically the sound card.<code class="literal"> AudioOutput</code> is connected to the<code class="literal"> MediaObject</code> (and<code class="literal"> Effect</code> instances) using the<code class="literal"> Path</code> object we just discussed. The property<code class="literal"> AudioOutput.outputDevice()</code> contains information about the output device.<a id="id370" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec11"/>Effect</h3></div></div></div><p>The instance of class<code class="literal"> Effect</code> can be inserted as a node into the media graph. The<code class="literal"> Path.insertEffect</code> can bring about this effect whereas<code class="literal"> Path.removeEffect</code> facilitates removal of that node from the graph. This object modifies the streaming media data. For example, an echo effect will add an echo to the audio. Use<code class="literal"> BackendCapabilities.availableAudioEffects</code> to find out which effects are supported by the Phonon backend.<a id="id371" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec12"/>VideoPlayer</h3></div></div></div><p>This class provides an important functionality. It has several built-in features that eliminate the need of explicitly creating nodes such as<code class="literal"> MediaObject</code>. We will discuss this in detail while developing the video player application.<a id="id372" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec13"/>SeekSlider</h3></div></div></div><p>
<code class="literal">SeekSlider</code> is a GUI widget. This class provides a slider to seek a specific position in the streaming media. It handles all the necessary updates and signal connections internally. All it needs is the media object instance.<a id="id373" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec14"/>volumeSlider</h3></div></div></div><p>This class provides a widget for controlling the volume. It makes a programmer's job easy by internally connecting signals. The following line of code sets the audio output device for a volume slider.<a id="id374" class="indexterm"/>
</p><div><pre class="programlisting">volumeSlider.setAudioOutput(self.audioSink)
</pre></div><p>Here, the<code class="literal"> volumeSlider</code> will control the volume for the audio output device of<code class="literal"> self.audioSink</code>.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Project: GUI-based music player</h1></div></div></div><p>Let's get straight to the business. We will develop a simple GUI-based music player using QT Phonon. The goal of this project is to learn how to put together important components of the Phonon framework discussed earlier. It will help us get familiar with the overall Phonon framework. In the second project, we will learn an even simpler way to accomplish the same task.<a id="id375" class="indexterm"/>
</p><p>The application to be developed here will play an opened audio file. It will have GUI widgets to control the playback and add various effects to the streaming audio. The screenshot of the music player application is shown in the following illustration of its graphical user interface:<a id="id376" class="indexterm"/>
</p><div><img src="img/0165_8_1.jpg" alt="Project: GUI-based music player"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec06"/>GUI elements in the music player</h2></div></div></div><p>The illustrated music player application uses the following QT widgets.<a id="id377" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">QMainWindow:</code> This class provides the main application window. In this window, other elements such as buttons and menus are added in a layout.<a id="id378" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">QToolButton:</code> The play, pause, and stop buttons are created using the<code class="literal"> QToolButton</code> class. The appearance of these<code class="literal"> QToolButtons</code> can be tweaked using a number of properties; for example, calling<code class="literal"> QToolButtoon.setAutoRaise(True):</code> Removes the raised button effect. On mouse hover, the button will be highlighted and appear raised above the surface.<a id="id379" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">VolumeSlider:</code> As discussed earlier, the volume slider widget is used for controlling the volume of the output audio device.<a id="id380" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">SeekSlider:</code> Used to seek a position within the streaming media. While the music is being played, its position is automatically updated. You can drag the slider using mouse to jump to a different position on the track.<a id="id381" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">QLineEdit:</code> This widget is used to display the full path of the media file currently being played.<a id="id382" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">QMenubar:</code> This is the menu bar above the<code class="literal"> QLineEdit</code>. Here, we add different menus such as<strong> File</strong> and<strong> Effects</strong>.<a id="id383" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">QAction:</code> Various audio effect options are added to the<strong> Effects</strong> menu as<code class="literal"> QAction</code> instances.<a id="id384" class="indexterm"/></li></ul></div><p>Some of these QT elements just discussed are pointed out in the following illustration of a music player application displaying various QT widgets used:<a id="id385" class="indexterm"/>
</p><div><img src="img/0165_8_2.jpg" alt="GUI elements in the music player"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec07"/>Generating the UI code</h2></div></div></div><p>The required GUI is built using the QT Designer application. This should be included in the binary installer of PyQT4. QT Designer provides a quick way to design and develop the user interface code. It supports a number of commonly used QT widgets. One can interactively add these widgets to a layout. This tool is also very useful to enhance the aesthetic appeal of the application. For example, the widget colors and other properties can easily be changed using various features available in QT Designer.<a id="id386" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Time for action -  generating the UI code</h1></div></div></div><p>The UI file necessary for this application is already created for you. The purpose of this section is not to show you how to generate the UI from scratch. It will just illustrate some of the important aspects of developing GUI using QT Designer for this application. You can then experiment with it further to add new widgets to the music player application. We used QT Designer while developing the 'Thumbnail Maker' application in<a class="link" href="ch02.html" title="Chapter 2. Working with Images"> Chapter 2</a>,<em> Working with Images</em>. We will cover some of those things here as well.</p><div><ol class="orderedlist arabic"><li class="listitem">Download the file<code class="literal"> Ui_AudioPlayerDialog.ui</code> from the Packt website.</li><li class="listitem">Start the QT Designer application that comes with the PyQt4 installation.</li><li class="listitem">Open this file in QT Designer. Click on each widget element within this audio player dialog. The QT class associated with the selected widget will be displayed in the<strong> Property Editor</strong> panel of the QT Designer.</li><li class="listitem">Notice the red-colored borders around various UI widgets within the dialog. These borders indicate a 'layout' in which the widgets are arranged. The layouts are created using the<code class="literal"> QLayout</code> class and its various subclasses. It is a critical component of the user interface design using QT. Without a layout in place, the UI elements may appear distorted when you run the application and, for instance, resize the dialog.<a id="id387" class="indexterm"/><p>The following illustration shows how the dialog appears when opened in QT Designer the music player dialog (.ui file) in QT Designer.
</p><div><img src="img/0165_8_3.jpg" alt="Time for action - generating the UI code"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Closely observe the borders around the widgets that indicate the presence of a layout. You will notice that there are multiple borders. This implies that we have placed the widgets in multiple layouts. For example, the buttons Play, Pause, and Stop are arranged in a horizontal layout, QHBoxLayout. These are further arranged in another horizontal layout with the volumeSlider element. Refer to QT4 and QT Designer documentation to know how to arrange widgets in a layout.</li></ul></div></li><li class="listitem">If you click on the<strong> Type Here</strong> placeholder in the menu bar, it becomes editable. With this, you can add a new menu to the menu bar. Similarly, you can add menu items to the<strong> File</strong> and<strong> Effects</strong> menus by opening those menus and clicking on<strong> Type Here</strong> menu item. The<strong> File</strong> menu has two menu items:<strong> Open</strong> and<strong> Exit</strong>. Note that the<strong> Effects</strong> menu is empty. We will add menu items to this menu later. In the following few steps, we will make minor changes to this dialog just to get a feel of QT Designer.<a id="id388" class="indexterm"/></li><li class="listitem">We will now add a widget that can display digits. This widget can be used to update the playtime information of the streaming media. The left panel shows a bunch of widgets that can be mouse dragged and dropped inside the Audio Player dialog window. This is illustrated by the following screenshot:<div><img src="img/0165_8_4.jpg" alt="Time for action - generating the UI code"/></div><div><img src="img/0165_8_5.jpg" alt="Time for action - generating the UI code"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">You can see the Display widget panel of QT Designer and the LCD number widget inserted into the dialog.<p>The inserted LCD number widget is shown selected in the screenshot on the right-hand side. It is inserted in a layout that arranges QToolButtons and the volumeSlider widgets in a horizontal fashion. Also, notice that the inserted LCD number widget has a default size. This size needs to be adjusted so that other widgets get their share of the space. Various parameters can be adjusted using the property editor panel within QT Designer for this widget. Here, we adjust the maximum size values as illustrated in the following screenshot.
<a id="id389" class="indexterm"/>
</p></li></ul></div><div><img src="img/0165_8_6.jpg" alt="Time for action - generating the UI code"/></div><div><img src="img/0165_8_7.jpg" alt="Time for action - generating the UI code"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The Property Editor for LCD number widget the screenshot on the right-hand side shows the edited size parameters.<p>Once the maximum width and height parameters are adjusted, the LCD number widget fits in nicely within the horizontal layout. The resultant dialog is shown in the next illustration.
<a id="id390" class="indexterm"/>
</p></li></ul></div><div><img src="img/0165_8_8.jpg" alt="Time for action - generating the UI code"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">That's it! You can keep this LCD number widget in the dialog for now. After completion of this project, you can use it to add a feature that displays the time information for the streaming media. Note that LCD Number widget is not the only option to display the play time. You can even use a QTextLabel and update the label string with the time.</li></ul></div></li><li class="listitem">As mentioned in the chapter,<a class="link" href="ch02.html" title="Chapter 2. Working with Images"> Chapter 2</a>,<em> Working with Images</em>, the QT Designer saves the user interface file with an extension<code class="literal"> .ui</code>. To convert this into Python source code, PyQt4 provides a conversion utility called<code class="literal"> pyuic4</code>. On Windows XP, for standard Python installation, the path for this utility is<code class="literal"> C:\Python26\Lib\site-packages\PyQt4\pyuic4.bat</code>. Add the path to the environment variable. Alternatively, specify the whole path each time you want to convert<code class="literal"> .ui</code> file to Python source file. The conversion utility can be run from the command prompt as:<a id="id391" class="indexterm"/><div><pre class="programlisting">pyuic4 UI_AudioPlayerDialog.ui -o Ui_AudioPlayerDialog.py
</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">This script will create a Python source file, Ui_AudioPlayerDialog.py from the input .ui file. You can further review this file to understand how the UI code is set up. We will use this file 'as-is' for the further discussion.</li></ul></div><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>It is<em> not</em> a good idea to modify the autogenerated Python source file,<code class="literal"> Ui_AudioPlayerDialog.py</code>; if you make any changes to the corresponding<code class="literal"> .ui</code> file of the QT Designer and run the<code class="literal"> pyuic4</code> script again, it will<em> overwrite</em> the previous Python source file,<code class="literal"> Ui_AudioPlayerDialog.py</code>, provided we use the same filename. Instead, you can use the autogenerated file as a base class and create a subclass to add custom UI elements programmatically.</p></div></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec08"/>What just happened?</h2></div></div></div><p>This section gave us a working knowledge of tweaking a user interface using QT Designer. Just to get the feel of user interface editing, we added a LCD number widget to the Audio Player dialog. We learned how to autogenerate the Python source code from a<code class="literal"> .ui</code> file created with the help of QT Designer.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec09"/>Connecting the widgets</h2></div></div></div><p>The command-line utility<code class="literal"> pyuic4</code> (pyuic4.bat for Windows users) enabled conversion of the user interface created by the QT-Designer into a Python source file. However, various widgets in this UI need to respond to the user actions. For example, when the<strong> Play</strong> button is clicked, it must start streaming the media file. Thus, we need to add necessary code that will instruct these widgets what they should do when a certain event occurs. This is accomplished using the slots and signals. A<code class="literal"> signal</code> is emitted when a particular GUI<code class="literal"> event</code> occurs. For example, when a user clicks on the<strong> Pause</strong> button, a<code class="literal"> "clicked()" signal</code> is emitted. A<code class="literal"> slot</code> is a method that is called for this<code class="literal"> signal</code>. This is very similar to the how we connected<code class="literal"> pad-added</code> signal by a<code class="literal"> decodebin</code> element to a method<code class="literal"> decodebin_pad_added</code> in earlier chapter. Refer to the PyQt4/ QT4 documentation that has a comprehensive list of available<code class="literal"> signals</code> for various widgets.<a id="id392" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Time for action -  connecting the widgets</h1></div></div></div><p>Let's learn how to make widgets respond to a particular user action, such as a button click.</p><div><ol class="orderedlist arabic"><li class="listitem">Download the file<code class="literal"> AudioPlayerDialog.py</code> from the Packt website. It defines the class<code class="literal"> AudioPlayerDialog</code>.</li><li class="listitem">We will now review the method that connects class methods to the emitted signals. These signals are generated whenever a particular 'event' occurs.<div><pre class="programlisting">1 def _connect(self):
2 """
3 Connect slots with signals.
4 """
5 self.connect(self._dialog.fileOpenAction,
6 SIGNAL("triggered()"),
7 self._openFileDialog)
8
9 self.connect(self._dialog.fileExitAction,
10 SIGNAL("triggered()"),
11 self.close)
12
13 self.connect(self._dialog.menuAudioEffects,
14 SIGNAL("triggered(QAction*)"),
15 self._changeAudioEffects)
16
17 self.connect(self._dialog.playToolButton,
18 SIGNAL("clicked()"),
19 self._playMedia)
20
21 self.connect(self._dialog.stopToolButton,
22 SIGNAL("clicked()"),
23 self._stopMedia)
24
25 self.connect(self._dialog.pauseToolButton,
26 SIGNAL("clicked()"),
27 self._pauseMedia)
</pre></div></li><li class="listitem">Here, the self._dialog is an instance of class Ui_AudioPlayerDialog. Note that, the self.connect is an inherited method of the QT class QMainWindow. It takes the following arguments (QObject, SIGNAL, callable). The QObject is any widget type; SIGNAL is generated when a specific event occurs. The callable is a method that handles this event. The AudioPlayer._connect method connects all the necessary signals with class methods.<a id="id393" class="indexterm"/></li><li class="listitem">The File menu in the Audio Player dialog contains two<code class="literal"> QActions</code>, namely,<code class="literal"> fileOpenAction</code> and<code class="literal"> fileExitAction</code>. When File-&gt;Open is selected, a signal "triggered" is generated for the<code class="literal"> QAction</code>. We need to watch out for this signal and then call a method that will do the job of opening a file. This signal is connected by the code between lines 5-7. Thus, when "triggered()" signal is emitted, for<code class="literal"> fileopenAction</code>, a method<code class="literal"> AudioPlayer._openFileDialog</code> is called that has necessary code to open an audio file.</li><li class="listitem">Let's review the code on line 9-12. This code connects all the<code class="literal"> QActions</code> within a<code class="literal"> QMenu</code> to a method of class<code class="literal"> AudioPlayer</code>. The first argument,<code class="literal"> self._dialog.menuAudioEffects</code>, is the Effects menu in the menu bar. This is a<code class="literal"> QMenu</code>. The second argument<code class="literal"> SIGNAL("triggered(QAction*)")</code> tells QT that we want to capture the triggered signal for any of the<code class="literal"> QActions</code> within the<strong> Effects</strong> menu. This is best explained with an example. Imagine that the audio<strong> Effects</strong> menu has menu items (QActions) such as Echo and Distortion. When a user selects<strong> Effects</strong> |<strong> Echo</strong> or<strong> Effects</strong> |<strong> Distortion</strong>, the<code class="literal"> triggered(QAction*)</code> signal is emitted. The argument<code class="literal"> QAction*</code> is just a pointer to that<code class="literal"> QAction</code>. The third argument is the receiver method,<code class="literal"> self._changeAudioEffects</code> that is called when this signal is emitted.<div><img src="img/0165_8_9.jpg" alt="Time for action - connecting the widgets"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The clicked() signal emitted when a QToolButton, such as, Play, Pause, or Stop is clicked. This signal is connected to appropriate methods of class AudioPlayer by the code block 13-23.<a id="id394" class="indexterm"/></li></ul></div></li><li class="listitem">Notice that we didn't connect the<code class="literal"> SeekSlider</code> and<code class="literal"> VolumeSlider</code>. The signals for these widgets are connected internally. All you need to do is set<code class="literal"> MediaObject</code> and<code class="literal"> AudioOutput</code> for these widgets respectively. We will learn how that's done in the next section.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec10"/>What just happened?</h2></div></div></div><p>We reviewed<code class="literal"> AudioPlayerDialog._connect()</code> method to learn how various widgets within the Audio Player dialog are connected to internal methods. This helped us learn some preliminary concepts of GUI programming using QT.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec11"/>Developing the audio player code</h2></div></div></div><p>The discussion so far has been focused on the graphical user interface. We learned how to use QT Designer to create user interface and then generate a Python source file representing this UI. We also reviewed the code that connects the frontend of our application with the backend (the class methods). Now, it is time to review the workhorse audio processing code responsible for playing the audio, controlling the playback, and operations like adding audio effects.<a id="id395" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Time for action -  developing the audio player code</h1></div></div></div><p>The source file,<code class="literal"> AudioPlayerDialog.py</code>, used in the earlier section will be used here as well. The class<code class="literal"> AudioPlayerDialog</code> inherits<code class="literal"> QMainWindow</code>.<a id="id396" class="indexterm"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">If you have not done so already, download the Python source file<code class="literal"> AudioPlayerDialog.py</code>.</li><li class="listitem">Let's start with the constructor of the class,<code class="literal"> AudioPlayerDialog</code>.<div><pre class="programlisting">1 def __init__(self):
2 QMainWindow.__init__(self)
3 self.mediaSource = None
4 self.audioPath = ''
5 self.addedEffects = {}
6 self.effectsDict = {}
7
8 # Initialize some other variables.
9 self._filePath = ''
10 self._dirPath = ''
11 self._dialog = None
12 # Create media object , audio sink and path
13 self.mediaObj = phonon.Phonon.MediaObject(self)
14 self.audioSink = Phonon.AudioOutput(
15 Phonon.MusicCategory,
16 self)
17 self.audioPath = Phonon.createPath(self.mediaObj,
18 self.audioSink)
19
20 # Create self._dialog instance and call
21 # necessary methods to create a user interface
22 self._createUI()
23
24 # Connect slots with signals.
25 self._connect()
26
27 # Show the Audio player.
28 self.show()
</pre></div></li><li class="listitem">The code block from lines 2 to 6 initializes some instance variables to be used later. The dictionary object self.effectsDict will be used to store information about the available audio effects. Whereas, self.addedEffects is used to check if an audio effect is already added to the streaming media.<p>On line 13, the instance of Phonon.MediaObject is created. It will be used for controlling the playback of a MediaSource.
</p><p>An audio output node in the Phonon media graph is created by the code on lines 14-16. We will call it as self.audioSink, the terminology used in earlier chapter. The first argument for AudioOutput is used to specify the category. It is an object of class Phonon.Category. Since this is a music player application, we define the category as Phonon.MusicCategory. Review QT documentation to know more about the categories. The second argument is used as a parent for this audio sink.
</p><p>The Phonon.Path class links the nodes within a media graph. This object is created using an API method, Phonon.createPath. On line 17, the Path self.audioPath links the media object self.mediaObject with the audio output self.audioSink.
<a id="id397" class="indexterm"/>
</p><p>The call to the _createUI method handles the defining of the user interface. We already learned how the frontend communicates with the backend using the connections set up in the _connect method.
</p><p>Finally, on line 28, the API method QMainWindow.show()displays the audio player.
</p></li><li class="listitem">The method<code class="literal"> _createUI</code> delegates most of the GUI creation to the class<code class="literal"> UI_AudioPlayerDialog</code>. The method also has the code that further modifies the GUI.<div><pre class="programlisting">1 def _createUI(self):
2 # Define the instance to access the the UI elements
3 defined in class Ui_AudioPlayerDialog.
4 self._dialog = Ui_AudioPlayerDialog()
5 self._dialog.setupUi(self)
6 self._dialog.retranslateUi(self)
7 playIcon= QIcon("play.png")
8 pauseIcon= QIcon("pause.png")
9 stopIcon= QIcon("stop.png")
10 musicIcon= QIcon("music.png")
11
12 self._dialog.playToolButton.setIcon(playIcon)
13 self._dialog.pauseToolButton.setIcon(pauseIcon)
14 self._dialog.stopToolButton.setIcon(stopIcon)
15 self.setWindowIcon(musicIcon)
16 self._setupEffectsMenu()
17 self._dialog.seekSlider.setMediaObject(self.mediaObj)
18 self._dialog.volumeSlider.setAudioOutput(
19 self.audioSink)
</pre></div></li><li class="listitem">The instance of class UI_AudioPlayerDialog is created on line 4. setupUI and retranslateUI are the automatically generated methods. These are generated when the QT Designer file with the UI is converted into a Python source file. The AudioPlayerDialog instance is passed as an argument to these two methods.<p>The code block 7 to 14 sets up the icons for the three QToolButton instances. The setIcon API method takes QIcon instance as an argument. The music player icon in the caption (on top-left corner of the dialog) is created by the code on line 15. As mentioned earlier, the Phonon.SeekSlider signals are internally connected. We only need to tell which MediaObject it will handle. This is done on line 17. Similarly, on line 18, the setAudioOutput method of volumeSlider sets up the self.audiosink as the audio output for this volumeSlider. While setting up the UI design, we did not add any menu items to the Effects menu. This is done now, by calling the _setupEffectsMenu method on line 16.
</p></li><li class="listitem">Let's review the method<code class="literal"> _setupEffectsMenu</code>. It adds various available audio effects in the Phonon framework as menu items to the<strong> Effects</strong> menu.<a id="id398" class="indexterm"/><div><pre class="programlisting">1 def _setupEffectsMenu(self):
2 availableEffects = (
3 Phonon.BackendCapabilities.availableAudioEffects())
4 for e in availableEffects:
5 effectName = e.name()
6 self.effectsDict[effectName] = e
7 action = QAction(effectName,
8 self._dialog.menuAudioEffects)
9 action.setCheckable(True)
10 self._dialog.menuAudioEffects.addAction(action)
</pre></div></li><li class="listitem">The namespace, Phonon.BackendCapabilities includes functions that provide information about the capability of the Phonon backend. BackendCapabilities.availableAudioeffects() returns a list of all audio effects supported by Phonon on a given platform. The list, availableEffects, contains objects of the class Phonon.EffectDescription. self.effectsDict stores the name of the effect and the EffectDescription object as key-value pairs. This dictionary will be used later. The Effects menu, menuAudioEffects, is populated with the QAction instances corresponding to each of the available audio effects. QAction is created on line 6. The setCheckable property of QAction toggles the checked state of the action on mouse click. The following screenshot shows the Effects menu items on Windows XP.<div><img src="img/0165_8_10.jpg" alt="Time for action - developing the audio player code"/></div></li><li class="listitem">The method<code class="literal"> _openFileDialog</code> is called when<strong> File</strong> |<strong> Open</strong> is clicked from the music player.<a id="id399" class="indexterm"/><div><pre class="programlisting">1 def _openFileDialog(self):
2
3 self._filePath = ''
4
5 self._filePath = (
6 str(QFileDialog.getOpenFileName(
7 self,
8 "Open Audio File",
9 "",
10 "MP3 file (*.mp3);;wav(*.wav);;All Files
11 (*.*);;")) )
12 if self._filePath:
13 self._filePath = os.path.normpath(self._filePath)
14 self._dialog.fileLineEdit.setText(self._filePath)
15 self._loadNewMedia()
</pre></div></li><li class="listitem">This pops up a QFileDialog with the file type filters as specified on line 10. To know about the supported media formats, you can use the Phonon.BackEndCapabilities as illustrated by the following line of code.<div><pre class="programlisting">types = Phonon.BackendCapabilities.availableMimeTypes()
</pre></div></li><li class="listitem">Where, types is a list of available mime types.<p>The path of the file specified by the user is then stored in the variable self._filePath. This path is displayed in the fileLineEdit field of the dialog. On line 15, the method _loadNewMedia is called. We will review that next.
</p></li><li class="listitem">The method<code class="literal"> _loadNewMedia</code> sets up the media source for the<code class="literal"> MediaObject</code>.<div><pre class="programlisting">1 def _loadNewMedia(self):
2 # This is required so that the player can play another
3 # file, if loaded while first one is still playing.
4 if self.mediaSource:
5 self._stopMedia()
6 del self.mediaSource
7 self.mediaSource = phonon.Phonon.MediaSource(
8 self._filePath)
9 self.mediaObj.setCurrentSource(self.mediaSource)
</pre></div></li><li class="listitem">The if block on line 4 ensures that the current streaming audio (if any) is stopped by the media object before setting the new media source to a playing state. Although it is not necessary, the memory occupied by the MediaSource object is cleared up by the code on line 6. Line 8 creates a new instance of class MediaSource. The API method, setCurrentSouce of the class MediaObject is used to specify the MediaSource that provides the media data. With this, our media player is all set to stream the audio file.<a id="id400" class="indexterm"/></li><li class="listitem">When you click on the<strong> Play</strong> button in the music player, the<code class="literal"> AudioPlayerDialog._playMedia</code> method is called.<div><pre class="programlisting">1 def _playMedia(self):
2 if not self._okToPlayPauseStop():
3 return
4
5 if self.mediaObj is None:
6 print "Error playing Audio"
7 return
8
9 self.mediaObj.play()
</pre></div></li><li class="listitem">First the program carries out some primary checks to ensure that the media is playable and then calls the play() method of Phonon.MediaObject, which begins streaming the audio. The methods _pauseMedia and _stopMedia of class AudioPlayerDialog contain similar code.<p>We just learned how to set up the media graph, stream the media, and control its playback. Now let's see how to add audio effects to this streaming media. If any of the items in the Effects menu are clicked, the AudioPlayerDialog._changeAudioEffects method is called:
</p><div><pre class="programlisting">1 def _changeAudioEffects(self, action):
2 effectName = action.text()
3
4 if action.isChecked():
5 effectDescription = self.effectsDict[effectName]
6 effect = Phonon.Effect(effectDescription)
7 self.addedEffects[effectName] = effect
8 self.audioPath.insertEffect(effect)
9 else:
10 effect = self.addedEffects[effectName]
11 self.audioPath.removeEffect(effect)
12 del self.addedEffects[effectName]
</pre></div></li><li class="listitem">The if and else blocks in the preceding code snippet add and remove effects nodes from the media graph respectively. The if block is executed when an action in the Effects menu is checked. When an already checked action is toggled, the program executes the else block. In the if block, an instance of Phonon.Effect is created on line 6. This takes an EffectDescription object as an argument. As seen in the _setupEffectsMenu method, self.effectsDict stores the EffectDescription objects as the dictionary values. On line 8, this effect is inserted as a node in the media graph. The self.audioPath links all the nodes within the media graph.<a id="id401" class="indexterm"/><p>The dictionary, self.addedEffects keeps track of all the audio effects inserted within the media graph. The else block removes an already added effect.
</p><p>On line 11, an added effect is removed by calling the removeEffect API method of Phonon.Path. The corresponding key-value pair of self.addedEffects is also deleted on line 12. This also ensures that there is no memory leak.
</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>QT Phonon allows adding the same audio effect multiple times. For example, you can create multiple 'Chorus' effect nodes within the media graph using<code class="literal"> Path.insertEffect</code>. Each of the added effects will have its own contribution. However, in our application, we support adding an effect only once. You can extend this to support adding the same effect multiple times. For this, you will need to tweak the<strong> Effects</strong> menu UI and make some other changes in the code to keep track of the added effects.</p></div></div></li><li class="listitem">The application will not terminate properly if you close the GUI window while an audio file is being played. To safely terminate the application without any memory leaks,<code class="literal"> AudioPlayerDialog</code> overrides the<code class="literal"> QMainWindow.closeEvent</code>. Before closing the window, we do the necessary cleanup to avoid memory leaks. The code is illustrated below.<div><pre class="programlisting">1 def closeEvent(self, evt):
2 print "\n in close event"
3 if self.mediaObj:
4 self.mediaObj.stop()
5
6 self.mediaObj = None
7 self._clearEffectsObjects()
8 QMainWindow.closeEvent(self, evt)
</pre></div></li><li class="listitem">The streaming media, if any, is first stopped. The call to _clearEffectsObject deletes all the Phonon.Effect and Phonon.EffectDescription objects (if present). The method _clearEffectsObject is self-explanatory.</li><li class="listitem">The following code creates an instance of<code class="literal"> QApplication</code> and executes this program.<a id="id402" class="indexterm"/><div><pre class="programlisting">1 app = QApplication(sys.argv)
2 musicPlayer = AudioPlayerDialog()
3 app.exec_()
</pre></div></li><li class="listitem">Review the rest of the code from the file<code class="literal"> AudioPlayerDialog.py</code> and then run the music player as:<div><pre class="programlisting">$python AudioPlayerDialog.py
</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">This should display the music player GUI window. Use File | Open to specify a music file and then click on the Play button to enjoy the music!</li></ul></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec12"/>What just happened?</h2></div></div></div><p>We just created our own music player! We developed a frontend for this music player using QT Phonon multimedia framework. Use of various modules in QT Phonon was thoroughly discussed. We learned how to set up audio controls and effects in a media graph by using modules such as<code class="literal"> MediaObject, AudioOutput, Path</code>, and so on. We also gained some higher-level understanding of GUI programming aspects using QT.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec13"/>Have a go hero add more features to the audio player</h2></div></div></div><p>In the<em> Generating the UI code</em> section, we added a widget to the music player GUI window. This is an LCD number widget that can display the frame numbers. Connect this widget to the Audio Player backend, so that it can display the current media time. The next illustration shows this LCD number widget in action for a streaming audio file.<a id="id403" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extend this music player application so that it can play all the songs from a directory or CD one after the other. There are a number of ways to create a user interface to display the files. For example, you can try using widgets such as<code class="literal"> QDirectoryView</code> ,<code class="literal"> QTreeView</code>, or<code class="literal"> QTableWidget</code>.<p>Music player displaying the frame number (time) in the LCD number widget:
</p></li></ul></div><div><img src="img/0165_8_11.jpg" alt="Have a go hero add more features to the audio player"/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec07"/>Project: GUI-based video player</h1></div></div></div><p>In the first project, we learned the fundamentals of the QT Phonon framework. In this project, we will extend that knowledge further by developing a video player. The Audio player was developed by building a media graph. Various nodes such as<code class="literal"> MediaObject, AudioOutput</code>, and<code class="literal"> Effects</code> were linked together by creating a<code class="literal"> Phonon.Path</code>. If the goal is just to develop a simple audio or video player, the job is even simpler. Phonon has a module<code class="literal"> VideoPlayer</code> that provides an abstract way to play an audio or a video without the need to explicitly create<code class="literal"> MediaObject, AudioOutput</code>, and some other objects. All it needs is a<code class="literal"> MediaSource</code>. It is also possible to create a custom media graph by adding various audio-effect nodes. We will see how to do it later. For now, let's write a simple video player application using QT Phonon. The following illustration shows the video player in action.<a id="id404" class="indexterm"/>
</p><div><img src="img/0165_8_12.jpg" alt="Project: GUI-based video player"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec14"/>Generating the UI code</h2></div></div></div><p>QT Designer is an excellent resource for generating user interface interactively. As we have seen, most of the user interface for this project is built using QT Designer. In addition, some important points about the user interface design using QT were covered. This section will just walk you through the user interface generation for this application using QT Designer and<code class="literal"> pyuic4</code>.<a id="id405" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec08"/>Time for action -  generating the UI code</h1></div></div></div><p>The<code class="literal"> .ui</code> file is already created. In the following discussion, we will simply use this file and go through some of the GUI elements needed for this application.<a id="id406" class="indexterm"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Download the file<code class="literal"> Ui_VideoPlayerDialog.ui</code> from the Packt website.</li><li class="listitem">Open this file in QT Designer. Click on each widget element. The QT class associated with the selected widget will be displayed in the<strong> Property Editor</strong> panel on the right-hand side. Most of the widgets used here are same as the ones used in the earlier project. The only widget that is different is the<code class="literal"> Phonon.VideoPlayer</code>. The following illustration shows how the dialog appears when opened in QT Designer. It also points out various Phonon widgets used in the dialog.<div><img src="img/0165_8_13.jpg" alt="Time for action - generating the UI code"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The video player widget in QT Designer appears as shown in the preceding screenshot.</li></ul></div></li><li class="listitem">Click on the<code class="literal"> VideoPlayer</code> widget shown in the preceding illustration. The<strong> Property Editor</strong> will display its properties. Pay attention to how the size of this widget is defined. This Video Player will support an option to view the video in 'Full Screen' mode. Therefore, the maximum size parameters for the<code class="literal"> VideoPlayer</code> widget are set to high values as shown in the next screenshot. In fact, we are using the QT default values for the maximum size property. The only property modified is the minimum size of the widget. This minimum size will be the default size of the video player widget.<a id="id407" class="indexterm"/><p>The Property editor for Video Player widget:
</p><div><img src="img/0165_8_14.jpg" alt="Time for action - generating the UI code"/></div></li><li class="listitem">The rest of the widgets are the same as the one used in an earlier project. You can add the LCD<strong> Number</strong> widget or a simple text label that displays the current time for the streaming media. Refer to the last project for instructions on adding such widgets.<a id="id408" class="indexterm"/></li><li class="listitem">Next, convert the<code class="literal"> .ui</code> file into<code class="literal"> .py</code> using the<code class="literal"> pyuic4</code> conversion utility. The conversion utility can be run from the command prompt as:<div><pre class="programlisting">pyuic4 UI_VideoPlayerDialog.ui -o Ui_VideoPlayerDialog.py
</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">This script will create a Python source file, Ui_VideoPlayerDialog.py, from the input .ui file. We will use this file 'as-is' for the further discussion.</li></ul></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec15"/>What just happened?</h2></div></div></div><p>The previous discussion served as a refresher on use of QT Designer to generate most of the user interface elements needed for this project. The<code class="literal"> pyuic4</code> conversion utility was used to convert the<code class="literal"> .ui</code> file to a Python source file.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec16"/>Connecting the widgets</h2></div></div></div><p>Most of the widgets used in the previous project are re-used here. Therefore, this is going to be a short discussion. In this project, we have not included an<strong> Effects</strong> menu. Thus, the<code class="literal"> VideoPlayerDialog._connect</code> method has minor changes. This method is illustrated as follows:<a id="id409" class="indexterm"/>
</p><div><pre class="programlisting">def _connect(self):
self.connect(self._dialog.fileOpenAction,
SIGNAL("triggered()"),
self._openFileDialog)
self.connect(self._dialog.fileExitAction,
SIGNAL("triggered()"),
self.close)
self.connect(self._dialog.fullScreenAction,
SIGNAL("toggled(bool)"),
self._toggleFullScreen)
self.connect(self._dialog.playToolButton,
SIGNAL("clicked()"),
self._playMedia)
self.connect(self._dialog.stopToolButton,
SIGNAL("clicked()"),
self._stopMedia)
self.connect(self._dialog.pauseToolButton,
SIGNAL("clicked()"),
self._pauseMedia)
</pre></div><p>The highlighted lines of code are a new widget connection. The rest of the connections are the same as the ones discussed in the previous project. When<strong> View</strong> |<strong> Full Screen</strong> is selected, the<code class="literal"> toggled(bool)</code> signal of<code class="literal"> fullScreenAction</code> is emitted. When this happens the<code class="literal"> slot</code> method<code class="literal"> self._toggleFullScreen</code> is called. The next section will have more details about this method.<a id="id410" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec17"/>Developing the video player code</h2></div></div></div><p>The generated frontend is connected to the backend for processing the media. In this section, we will review the video player backend that actually streams the media and controls the playback and volume. Our job is easier here. Most of the good work we did in the earlier project will be re-used here. There will be some minor modifications because we will be using<code class="literal"> Phonon.VideoPlayer</code> for video processing instead of explicitly creating the objects such as<code class="literal"> MediaObject</code>.<a id="id411" class="indexterm"/>
</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec09"/>Time for action -  developing the video player code</h1></div></div></div><p>Let's develop the rest of the video player backend. We will re-use several methods from the<code class="literal"> AudioPlayerDialog</code> class with a few minor changes. Only the important methods will be covered in this section.</p><div><ol class="orderedlist arabic"><li class="listitem">Download the file<code class="literal"> VideoPlayerDialog.py</code> from the Packt website.</li><li class="listitem">The constructor of the class is shown below.<div><pre class="programlisting">1 def __init__(self):
2 QMainWindow.__init__(self)
3 self.mediaSource = None
4 self.audioPath = ''
5
6 # Initialize some other variables.
7 self._filePath = ''
8 self._dialog = None
9
10 # Create self._dialog instance and call
11 # necessary methods to create a user interface
12 self._createUI()
13
14 self.mediaObj = self._dialog.videoPlayer.mediaObject()
15 self.audioSink = self._dialog.videoPlayer.audioOutput()
16
17 self._dialog.seekSlider.setMediaObject(self.mediaObj)
18 self._dialog.volumeSlider.setAudioOutput(
19 self.audioSink)
20
21 # Connect slots with signals.
22 self._connect()
23
24 # Show the Audio player.
25 self.show()
</pre></div></li><li class="listitem">The self._dialog creates an instance of class Phonon.VideoPlayer. Once a media source is specified, self._dialog.videoPlayer is able to stream the media. Thus, for the media streaming itself, we don't need to create the nodes MediaObject and AudioOutput explicitly; the Phonon.VideoPlayer internally builds the media graph. However, MediaObject and AudioOutput are required for seekSlider and volumeControl widgets respectively. On lines 14 and 15, these objects are obtained from self._dialog.videoPlayer.</li><li class="listitem">The<code class="literal"> _createUI</code> method is almost identical to the corresponding method in<code class="literal"> AudioPlayerDialog</code>, except that it doesn't have the<strong> Effects</strong> menu-related code.<a id="id412" class="indexterm"/></li><li class="listitem">Following that, the method to review is<code class="literal"> _playMedia:</code><div><pre class="programlisting">1 def _playMedia(self):
2 if not self._okToPlayPauseStop():
3 return
4 self._dialog.videoPlayer.play(self.mediaSource)
</pre></div></li><li class="listitem">The code is self-explanatory. The self.mediaSource is set in VideoPlayerDialog._loadNewMedia. This MediaSource instance is passed as an argument to the API method VideoPlayer.play. The videoPlayer then builds the media graph internally and plays the given media file.</li><li class="listitem">This simple video player supports an option to view the streaming video in full screen mode.<code class="literal"> QMainWindow</code> class provides an easy way to change the view between full screen and normal viewing mode. This is done by the method<code class="literal"> _toggleFullScreen</code>.<div><pre class="programlisting">def _toggleFullScreen(self, val):
"""
Change between normal and full screen mode.
"""
# Note: The program starts in Normal viewing mode
# by default.
if val:
self.showFullScreen()
else:
</pre></div><div><pre class="programlisting">self.showNormal()
</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The method, self.showFullScreen() is inherited from class QMainWindow. If the QAction in the View menu (View | Full Screen) is checked, the video player window is set to full screen. QMainWindow.showNormal() changes the video player back to the normal viewing mode. The following screenshot shows the video player in the full screen mode. Notice that the window caption bar is hidden in the full screen mode.<a id="id413" class="indexterm"/><p>Video player in full screen mode is illustrated as shown in the next image:
</p></li></ul></div><div><img src="img/0165_8_15.jpg" alt="Time for action - developing the video player code"/></div></li><li class="listitem">Review the rest of the code from file<code class="literal"> VideoPlayerDialog.py</code>. Keep this file in the same directory as<code class="literal"> Ui_VideoPlayerDialog.py</code> and then run the program from the command line as:</li><li class="listitem">The video player GUI window will appear. Open any supported audio or video file and click on the<strong> Play</strong> button to begin the playback.<a id="id414" class="indexterm"/><div><pre class="programlisting">$python VideoPlayerDialog.py
</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec18"/>What just happened?</h2></div></div></div><p>We wrote our own video player. This video player is capable of playing video as well as audio files of supported formats. The module<code class="literal"> Phonon.VideoPlayer</code> that enables media playback and control was used here. We also learned how to toggle view between full screen and normal viewing mode using the API methods of class<code class="literal"> QMainWindow</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec19"/>Have a go hero do more with the video player</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Here is a simple enhancement. The full screen mode shows widgets such as playback control buttons, seek, and volume sliders. Hide these widgets when the<strong> View</strong> |<strong> Full Screen</strong> action is checked. Also, add a keyboard shortcut to toggle between normal and full screen view mode.<a id="id415" class="indexterm"/></li><li class="listitem">Add audio effects to the video player GUI. We already learned how to add audio effects to the media graph in the first project. You can re-use that code here. However, you will need an appropriate<code class="literal"> Phonon.Path</code> object to which the<code class="literal"> effects</code> node needs to be added. In the last project, we used<code class="literal"> Phonon.createPath</code> we can't create a new path as it is created internally by the VideoPlayer. Instead, the path can be obtained using API method<code class="literal"> MediaObject.outputPaths()</code>. This method returns a list containing output (audio and video) paths. The line of code is shown as an example.<div><pre class="programlisting">self.audioPath = self.mediaObj.outputPaths()[0]
</pre></div></li><li class="listitem">However, be careful with the memory leaks. If you add audio effects, and then exit the application, the program may freeze. This could be because the effect nodes are not deleted from the original audio path. Alternatively, you can build the video player from basic principles. That is, don't use Phonon.VideoPlayer. Instead, build a custom media graph just like how we did for the audio player project. In this case, you will need to use modules such as Phonon.VideoWidget.</li></ol></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec10"/>Summary</h1></div></div></div><p>This chapter taught us several things about GUI multimedia application development using QT. We worked on two exciting projects where audio and video players using QT Phonon framework were developed. To accomplish these tasks, we:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Used QT Designer to generate the UI source code</li><li class="listitem" style="list-style-type: disc">Handled the QT generated events by connecting slots (class methods) with signals</li><li class="listitem" style="list-style-type: disc">Used Phonon framework to set up media graphs for streaming of audio and video</li></ul></div></div></div>
</body></html>