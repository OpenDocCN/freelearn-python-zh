<html><head></head><body>
<div><div><div><h1 id="_idParaDest-329"><em class="italic"><a id="_idTextAnchor310"/>Chapter 19</em>: The Adapter Pattern</h1>
			<p>In previous chapters, we covered creational patterns, which are <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) patterns that help us with object creation procedures. The next category of patterns we want to present is <strong class="bold">structural design patterns</strong>.</p>
			<p>A structural design pattern proposes a way of composing objects to create new functionality. The first of these patterns we will cover is the <strong class="bold">adapter</strong> pattern.</p>
			<p>In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>Understanding the adapter pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<p>By the end of the chapter, you will know how to use this design pattern to create interfaces that could help application layers that otherwise could not communicate.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor311"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter19</a>.</p>
			<h1 id="_idParaDest-331"><a id="_idTextAnchor312"/>Understanding the adapter pattern</h1>
			<p>The adapter pattern is a structural design pattern that helps us make two incompatible interfaces compatible. <em class="italic">What does that really mean?</em> If we have an old component and we want to use it in a new <a id="_idIndexMarker1229"/>system, or a new component that we want to use in an old system, the two can rarely communicate without requiring code changes. But changing the code is not always possible, either because we don't have access to it or because it is impractical. In such cases, we can write an extra layer that makes all the required <a id="_idIndexMarker1230"/>modifications for enabling communication <a id="_idIndexMarker1231"/>between the two interfaces. This layer is called an <em class="italic">adapter</em>.</p>
			<p>To further understand this design pattern, let's consider some real-life examples.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor313"/>Real-world examples</h1>
			<p>When you are traveling from most European countries to the UK or US, or the other way around, you need to <a id="_idIndexMarker1232"/>use a plug adapter for charging your laptop. Another kind of adapter is needed for connecting some devices to your computer: a USB adapter.</p>
			<p>In the software category, the Zope <a id="_idIndexMarker1233"/>application server (<a href="http://www.zope.org">http://www.zope.org</a>) is known for its <strong class="bold">Zope Component Architecture</strong> (<strong class="bold">ZCA</strong>), which contributed to the <a id="_idIndexMarker1234"/>implementation of interfaces and adapters used by several big Python web projects. <em class="italic">Pyramid</em>, built by former Zope developers, is a Python web framework that took good ideas from Zope to provide a more modular approach for developing web apps. Pyramid uses adapters to make it possible for existing objects to conform to specific APIs without the need to modify them. Another project from the Zope ecosystem, <em class="italic">Plone CMS</em>, uses adapters under the hood.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor314"/>Use cases</h1>
			<p>Usually, one of the two incompatible interfaces is either foreign or old/legacy. If the interface is foreign, it means <a id="_idIndexMarker1235"/>that we have no access to the source code. If it is old, it is usually impractical to refactor it.</p>
			<p>Using an adapter to make things work after they have been implemented is a good approach because it does not require access to the source code of the foreign interface. It is also often a pragmatic solution if we have to reuse some legacy code.</p>
			<p>With that, let's start implementing a hands-on application in Python.</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor315"/>Implementation</h1>
			<p>Let's look at a relatively simple application to illustrate the concept of adaptation. Consider an example <a id="_idIndexMarker1236"/>of a club's activities. It mainly needs to organize performances and events for the entertainment of its clients, by hiring talented artists.</p>
			<p>At the core, we have a <code>Club</code> class that represents the club where hired artists perform some evenings. The <code>organize_performance()</code> method is the main action that the club can perform. The code is as follows:</p>
			<pre>class Club: 
    def __init__(self, name): 
        self.name = name 
 
    def __str__(self): 
        return f'the club {self.name}' 
 
    def organize_event(self): 
        return 'hires an artist to perform for the people' </pre>
			<p>Most of the time, our club hires a DJ to perform, but our application addresses the need to organize a diverse range of performances by a musician or music band, a dancer, a one-man or one-woman show, and so on.</p>
			<p>Through our research to try and reuse existing code, we find an open source contributed library that brings us two interesting classes: <code>Musician</code> and <code>Dancer</code>. In the <code>Musician</code> class, the main action is performed by the <code>play()</code> method. In the <code>Dancer</code> class, it is performed by the <code>dance()</code> method.</p>
			<p>In our example, to indicate that these two classes are external, we place them in a separate module. The code for the <code>Musician</code> class is as follows:</p>
			<pre>class Musician:
 def __init__(self, name):
 self.name = name
 
 def __str__(self):
 return f'the musician {self.name}'
 
  def play(self):
 return 'plays music'</pre>
			<p>Then, the <code>Dancer</code> class is defined as follows:</p>
			<pre>class Dancer:
     def __init__(self, name):
         self.name = name
  
     def __str__(self):
         return f'the dancer {self.name}'
  
     def dance(self):
         return 'does a dance performance'</pre>
			<p>The client code, using <a id="_idIndexMarker1237"/>these classes, only knows how to call the <code>organize_performance()</code> method (on the <code>Club</code> class); it has no idea about <code>play()</code> or <code>dance()</code> (on the respective classes from the external library).</p>
			<p><em class="italic">How can we make the code work without changing the</em> <code>Musician</code> <em class="italic">and</em> <code>Dancer</code> <em class="italic">classes?</em></p>
			<p>Adapters to the rescue! We create a generic <code>Adapter</code> class that allows us to adapt several objects with different interfaces into one unified interface. The <code>obj</code> argument of the <code>__init__()</code> method is the object that we want to adapt, and <code>adapted_methods</code> is a dictionary containing key/value pairs matching the method the client calls and the method that should be called.</p>
			<p>The code for the <code>Adapter</code> class is as follows:</p>
			<pre>class Adapter:
     def __init__(self, obj, adapted_methods):
         self.obj = obj
         self.__dict__.update(adapted_methods)
  
     def __str__(self):
         return str(self.obj)</pre>
			<p>When dealing with <a id="_idIndexMarker1238"/>different instances of the classes, we have two cases:</p>
			<ul>
				<li>The compatible object that belongs to the <code>Club</code> class needs no adaptation. We can treat it as it is.</li>
				<li>The incompatible objects need to be adapted first, using the <code>Adapter</code> class.</li>
			</ul>
			<p>The result is that the client code can continue using the known <code>organize_performance()</code> method on all objects without the need to be aware of any interface differences between the used classes. Consider the following code:</p>
			<pre>def main():
    objects = [Club('Jazz Cafe'), Musician('Roy Ayers'), \
      Dancer('Shane Sparks')]
    
    for obj in objects:
        if hasattr(obj, 'play') or hasattr(obj, 'dance'):
            if hasattr(obj, 'play'):
                adapted_methods = \
                  dict(organize_event=obj.play)
            elif hasattr(obj, 'dance'):            
                adapted_methods = \
                  dict(organize_event=obj.dance)
                
            # referencing the adapted object here
            obj = Adapter(obj, adapted_methods)
           
        print(f'{obj} {obj.organize_event()}') </pre>
			<p>Let's recapitulate the complete code of our adapter pattern implementation:</p>
			<ol>
				<li>We define the <code>Musician</code> and <code>Dancer</code> classes (in <code>external.py</code>).</li>
				<li>Then, we need to import those classes from the external module (in <code>adapter.py</code>):<pre>from external import Musician, Dance</pre></li>
				<li>We then define the <code>Adapter</code> class (in <code>adapter.py</code>).</li>
				<li>We add the <code>main()</code> function, as shown earlier, and the usual trick to call it (in <code>adapter.py</code>).</li>
			</ol>
			<p>Here is the output when <a id="_idIndexMarker1239"/>executing the <code>python adapter.py</code> command, as usual:</p>
			<pre>the club Jazz Cafe hires an artist to perform for the 
people
the musician Roy Ayers plays music
the dancer Shane Sparks does a dance performance</pre>
			<p>As you can see, we managed to make the <code>Musician</code> and <code>Dancer</code> classes compatible with the interface expected by the client, without changing their source code.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor316"/>Summary</h1>
			<p>This chapter covered the adapter design pattern. The adapter makes things work after they have been implemented. The Pyramid web framework, the Plone CMS, and other Zope-based or related frameworks use the adapter pattern to achieve interface compatibility. In the <em class="italic">Implementation</em> section, we saw how to achieve interface conformance using the adapter pattern without modifying the source code of the incompatible model. This is achieved through a generic <code>Adapter</code> class that does the work for us.</p>
			<p>Overall, we could use the adapter pattern to make two (or more) incompatible interfaces compatible, which has a lot of usage in software engineering.</p>
			<p>In the next chapter, we will cover the decorator pattern.</p>
		</div>
	</div>
</div>
</body></html>