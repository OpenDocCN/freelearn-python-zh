- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More Advanced Class Design
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), we looked at some recipes
    that covered the basics of class design. In this chapter, we’ll dive more deeply
    into Python classes and class design.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    and [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipes in Chapter [7](ch011_split_000.xhtml#x1-3760007), we identified a design
    choice that’s central to object-oriented programming, the ”wrap versus extend”
    decision. One way to add features is to create a new subclass via an extension.
    The other technique for adding features is to wrap an existing class, making it
    part of a new class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to direct inheritance, there are some other class extension techniques
    available in Python. A Python class can inherit features from more than one superclass.
    We call this design pattern a mixin.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [4](ch008_split_000.xhtml#x1-2240004) and Chapter [5](ch009.xhtml#x1-2890005),
    we looked at the core built-in data structures. We can combine and extend these
    collection definition features to create more complex data structures or data
    structures with additional features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Choosing between inheritance and composition – the ”is-a” question](ch012.xhtml#x1-4530001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Leveraging Python’s duck typing](ch012.xhtml#x1-4670003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Managing global and singleton objects](ch012.xhtml#x1-4730004)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using more complex structures – maps of lists](ch012.xhtml#x1-4810005)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Creating a class that has orderable objects](ch012.xhtml#x1-4870006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deleting from a list of complicated objects](ch012.xhtml#x1-4930007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a great many techniques of object-oriented class design available
    in Python. We’ll start with a foundational design concept: making the design choice
    between using inheritance from a base class and wrapping a class to extend it.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Choosing between inheritance and composition – the ”is-a” question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006)
    recipe in Chapter [6](ch010.xhtml#x1-3300006), and the [Extending a built-in collection
    – a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007),
    we looked at extending a class. In both cases, the class implemented in the recipe
    was a subclass of one of Python’s built-in classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea of extension via inheritance is sometimes called the generalization-specialization
    relationship. It can also be called an is-a relationship. There’s an important
    semantic issue:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we mean that instances of the subclass are also instances of the superclass?
    This is an is-a relationship, an example of inheritance, where we extend a class,
    changing the implementation details of features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or do we mean something else? Perhaps there’s a composition or association,
    sometimes called a has-a relationship. In this case, we may wrap another class,
    adding or removing features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the SOLID design principles, the Liskov Substitution Principle, requires
    any subclass to be a proper replacement for the superclass. We’ll look at both
    the inheritance and composition techniques for creating new features for existing
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we’ll use models for a deck of playing cards as concrete examples.
    We’ll look at several ways to design a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core ingredient for both implementations is the underlying Card object.
    We can define this using NamedTuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use this Card class in the rest of this recipe. What’s important is the
    various kinds of collection representing a deck or hand; all have considerable
    overlaps in the kinds of features they support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have several common pattern for collections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aggregation: Some objects are bound into collections, but the objects have
    a properly independent existence. While Card objects can be aggregated into a
    Hand collection, when the Hand object is deleted, the Card objects continue to
    exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Composition: Some objects in collections do not have an independent existence.
    A Hand of cards cannot exist without a Player. When a Player instance leaves a
    game, the Hand object must also be removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inheritance (also called an is-a relationship): This is the idea that a Deck
    is a Hand with some extra features. We can extend a built-in class like list to
    implement this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distinction between aggregation and composition is very important when designing
    a database, where persistence of objects is the focus. In Python, the distinction
    is a minor nuance. The ordinary Python memory management will preserve the objects
    still referenced by collections or variables. We’ll consider both to be examples
    of composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the relationships are understood, there are two distinct paths: [Composition
    or aggregation](ch012.xhtml#x1-4560002) or [Inheritance and extension](ch012.xhtml#x1-4570002).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe has two separate mini-recipes: aggregation and inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Composition or aggregation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Wrapping a collection object inside another class’s instance variables has
    two common variants, sometimes called composition and aggregation. The nuanced
    difference doesn’t matter in Python. Here’s how we design a collection using composition:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the collection class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To distinguish similar examples in this book, the name has a _W suffix to show
    it is a wrapper. This is not a generally recommended practice; it’s only used
    here to emphasize the distinctions between class definitions in this recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s the definition of the class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the __init__() method of this class as one way to provide the underlying
    collection object. This will also initialize any stateful variables. We might
    create an iterator for dealing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This uses a type hint, list[Card], to show the source collection that will be
    wrapped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Provide the methods appropriate to the aggregate object. The shuffle() method
    randomizes the internal list object. It also creates an iterator used to step
    through the list by the deal() method. We’ve provided a type hint on deal() to
    clarify that it returns Card instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how we can use the Deck_W class. We’ll be working with a list of Card
    objects. In this case, the domain variable was created from a list comprehension
    that generated all 52 combinations of 13 ranks and four suits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the items in this collection, domain, to create a second aggregate
    object that shares the same underlying Card objects. We’ll build the Deck_W object
    from a list of Card objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance and extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s an approach to defining a class that extends one of the built-in collections
    of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining the extension class as a subclass of a built-in collection.
    To distinguish similar examples in this book, the name has an _X suffix. The subclass
    relationship is a formal statement—a Deck_X instance is also a kind of list. Here’s
    the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No additional code is needed to initialize the instance, as we’ll use the __init__()
    method inherited from the list class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No additional code is needed to update the deck, as we’ll use other methods
    of the list class for adding, changing, or removing items from the Deck_X instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the appropriate new features to the extended object. The shuffle()
    method randomizes the object as a whole. The collection here is self, because
    this method is an extension of the list class. The deal() object relies on an
    iterator created by the shuffle() method to step through the list, returning Card
    instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how we can use the Deck_X class. First, we’ll build a deck of cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using only the deck-specific features for the Deck_X implementation looks exactly
    like the other implementation, Deck_W:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we’ll see below in There’s more..., because Deck_X is a list, it has all
    of the methods of a list object. When designing a framework for others to use,
    this may be a bad idea. When designing an application, it’s easy to avoid using
    the extra features.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python implements the idea of inheritance via a clever search algorithm for
    finding methods (and attributes) of an object’s class. The search works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the object’s class for the method or attribute name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the name is not defined in the immediate class, then search in all of the
    parent classes for the method or attribute. The Method Resolution Order (MRO)
    defines the order in which these classes are searched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Searching through the parent classes ensures two things:'
  prefs: []
  type: TYPE_NORMAL
- en: All methods defined in any superclass are available to subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any subclass can override a method to replace the superclass method. The super()
    function searches parent classes for the definition being overridden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of this, a subclass of the list class inherits all the features of the
    parent class. It is a specialized extension of the built-in list class.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that all methods have the potential to be overridden by a subclass.
    Some languages have ways to lock a method against extension. Because Python doesn’t
    have this, a subclass can override any method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The super() function allows a subclass to add features by wrapping the superclass
    version of a method. One way to use it is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the some_method() method of a class will do something extra and
    then use the superclass version of the method. This allows us a handy way to extend
    selected methods of a class. We can preserve the superclass features while adding
    features unique to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some huge differences between the two definitions, Deck_W and Deck_X.
    When wrapping, we get precisely the methods we defined and no others. When using
    inheritance, we receive a wealth of method definitions from the superclass. This
    leads to some additional behaviors in the Deck_X class that may not be desirable:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a variety of collections as a source to create Deck_X instances.
    This works because the list class has a number of features for converting Python
    collections to lists. The Deck_W class will only work for sequences offering the
    methods implicitly required by the shuffle() method. Further, the type hint of
    list[Card] will cause programs like mypy to raise errors for the use of other
    source collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Deck_X instance can be sliced and indexed outside the core sequential iteration
    supported by the deal() method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the Deck_X class is a list, it also works directly with the iter() function;
    it can be used as an iterable source of Card objects without the deal() method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These differences are also important parts of deciding which technique to use.
    If the additional features are desirable, that suggests inheritance. If the additional
    features create problems, then composition might be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve looked at built-in collections in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    Also, in Chapter [7](ch011_split_000.xhtml#x1-3760007), we looked at how to define
    simple collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we looked at wrapping a class with a separate class that handles the processing
    details. We can contrast this with the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe of Chapter [7](ch011_split_000.xhtml#x1-3760007), where we put the complicated
    computations into the class as properties; this design relies on extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2 Separating concerns via multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the [Choosing between inheritance and composition – the ”is-a” question](ch012.xhtml#x1-4530001)
    recipe earlier in the chapter, we looked at the idea of defining a Deck class
    that was a composition of playing card objects. For the purposes of that example,
    we treated each Card object as simply having rank and suit attributes. This created
    two small problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The display for the card always showed a numeric rank. We didn’t see J, Q, or
    K. Instead we saw 11, 12, and 13\. Similarly, an ace was shown as 1 instead of
    A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many games like Cribbage assign a point value to each rank. Generally, the face
    cards have 10 points. The remaining cards have points that match their rank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s multiple inheritance lets us handle variations in card game rules while
    keeping a single, essential Card class. Using multiple inheritance lets us separate
    rules for specific games from generic properties of playing cards. We can combine
    a base class definition with a mixin class that provides needed features.
  prefs: []
  type: TYPE_NORMAL
- en: Python multiple inheritance relies on a clever algorithm called C3 to resolve
    various parent classes into a single list, in a useful order. When we combine
    multiple classes, they will have common parent classes, which now have multiple
    references. The C3 algorithm creates a linear list that respects all of the parent-child
    relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A practical extension to the Card class needs to be a mixture of two feature
    sets. Python lets us define a class that includes features from multiple parents.
    The are two parts to this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Essential features: This are the rank and suit. This also includes a method
    to show the Card object’s value nicely as a string using “J”, “Q”, and “K” for
    court cards, and “A” for aces.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mixin features: These are all of the less essential, game-specific features,
    such as the number of points allotted to each particular card.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The working application relies on a combination of features built from the essentials
    and the mixins.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will create two hierarchies of classes, one for the essential Card
    and one for game-specific features including Cribbage point values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the essential class. This is a generic Card class, suitable for ranks
    2 to 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the subclasses to implement specializations. We need two subclasses
    of the Card class—the AceCard class and the FaceCard class, as defined in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of this overrides the built-in __str__() method to provide distinct behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the core features required by the mixin classes. Use the typing.Protocol
    superclass to be sure the various implementations all provide the required features.
    The rank attribute is required by the protocol, and will be defined in the essential
    class. A points() method will be defined in the mixin classes. Here’s how it looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When writing type hint classes, the body can be ... because this will be ignored
    by tools like mypy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a mixin subclasses for additional features that will be added. For the
    game of Cribbage, the points for some cards are equal to the rank of the card,
    and face cards are 10 points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the final concrete class definitions to combine an essential base class
    and all of the required mixin classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the CribbagePoints mixin is used for both Card and AceCard classes,
    allowing us to reuse code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a function (or class) to create the appropriate objects based on the
    input parameters. This is often called a factory function or factory class. The
    objects being created will all be considered as subclasses of the Card class because
    it’s first in the list of base classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the make_cribbage_card() function to create a shuffled deck of cards,
    as shown in this example interactive session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can evaluate the points() method of each Card object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The hand has two face cards, plus 3, 6, and ace, so the total points are 30\.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python’s mechanism for finding a method (or attribute) of an object works like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the instance for the attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search in the class for the method or attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the name is not defined in the immediate class, then search all of the parent
    classes for the method or attribute. The parent classes are searched in a sequence
    called, appropriately, the Method Resolution Order (MRO).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can display the MRO using the mro() method of a class. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The mro() method of the CribbageCard class shows us the order that’s used to
    resolve names. Because the class object uses an internal dict to store method
    definitions, the search is an extremely fast hash-based lookup of the attribute
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several kinds of design concerns we can separate in the form of mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Persistence and representation of state: A mixin class could add methods to
    manage conversion to a consistent external representation like CSV or JSON notation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security: A mixin class could add methods performs a consistent authorization
    check that applies to a number of base classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Logging: A mixin class could introduce a logger with a definition consistent
    across a variety of classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Event signaling and change notification: A mixin might report object state
    changes so one or more GUI widgets can refresh the display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, we’ll create a mixin to introduce logging to cards. We’ll define
    this class in a way that must be provided first in the list of superclasses. Since
    it’s early in the MRO list, it uses the super() function to use methods defined
    by subsequent classes in the MRO list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class will add the logger attribute to each object that has the PointedCard
    protocol defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’ve used super().__init__() to perform the __init__() method of
    any other classes defined. The order for these initializations comes from the
    class MRO. The simplest approach to have one class that defines the essential
    features of an object, and all other mixins add features in the form of additional
    methods to the essential object.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve provided an overriding definition for points(). This will search other
    classes in the MRO list for an implementation of the points() method. Then it
    will log the results computed by the method from another mixin class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The # type: ignore [safe-super] comment is a note to tools like mypy that do
    strict type-checking. When we look at the definitions of the PointedCard protocol,
    there’s no definition for this method. From the tool’s examination of the class
    hierarchy, it’s possible that calling super().points() is unsafe. We’re sure this
    won’t happen in practice, because a mixin will always be present to define the
    points() method. We’ve flagged the unsafe use of super() as an error to be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some classes that include the Logged mixin features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each of these classes are built from three separate class definitions. Since
    the Logged class is provided first, we’re assured that all classes have consistent
    logging. We’re also assured that any method in Logged can use super() to locate
    an implementation in the class list that follows it in the sequence of classes
    in the definition.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of these classes, we’d need to define a make_logged_card() function
    to use these new classes.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The method resolution order is computed when the class is created. The algorithm
    used is called C3\. The process was originally developed for the Dylan language
    and is now also used by Python. The C3 algorithm ensures that each parent class
    is searched exactly once. It also ensures the relative ordering of superclasses
    is preserved; subclasses will be searched before any of their parent classes are
    examined. More information is available at [https://dl.acm.org/doi/10.1145/236337.236343](https://dl.acm.org/doi/10.1145/236337.236343).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When considering multiple inheritance, it’s always essential to also consider
    whether or not a wrapper is a better design than a subclass. See the [Choosing
    between inheritance and composition – the ”is-a” question](ch012.xhtml#x1-4530001)
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3 Leveraging Python’s duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a design involves inheritance, there is often a clear relationship from
    a superclass to one or more subclasses. In the [Choosing between inheritance and
    composition – the ”is-a” question](ch012.xhtml#x1-4530001) recipe of this chapter,
    as well as the [Extending a built-in collection – a list that does statistics](ch011_split_001.xhtml#x1-4250009)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ve looked at extensions
    that involve a proper subclass-superclass relationship.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have classes that can be used in place of one another (”polymorphic”
    classes), some languages require a common superclass. In many cases, the common
    class doesn’t have concrete implementations for all of the methods; it’s called
    an abstract superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn’t require common superclasses. The standard library offers the
    abc module to support creating abstract classes in cases where it can help to
    clarify the relationships among classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of defining polymorphic classes with common superclasses, Python relies
    on duck typing to establish equivalence. This name comes from the quote:'
  prefs: []
  type: TYPE_NORMAL
- en: When I see a bird that walks like a duck and swims like a duck and quacks like
    a duck, I call that bird a duck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (James Whitcomb Riley)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the case of Python class relationships, if two objects have the same methods
    and the same attributes, these similarities have the same effect as having a common
    superclass. No formal definition of a common class is required.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to exploit the concept of duck typing to create polymorphic
    classes. Instances of these classes can be used in place of each other, giving
    us more flexible designs.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases, it can be awkward to define a superclass for a number of loosely
    related implementation choices. For example, if an application is spread across
    several modules, it might be challenging to factor out a common superclass and
    put this by itself in a separate module where it can be imported into other modules.
    Instead of factoring out a common abstraction, it’s sometimes easier to create
    classes that will pass the ”duck test”: the various classes have the same methods
    and attributes; therefore, they are effectively interchangeable, polymorphic classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll define a pair of classes to show how this works. These classes will both
    simulate rolling a pair of dice. We’ll create two distinct implementations that
    have enough common features that they are interchangeable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a class, Dice1, with the required methods and attributes. In this
    example, we’ll have one attribute, dice, that retains the result of the last roll,
    and one method, roll(), that changes the state of the dice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define another class, Dice2, with the same methods and attributes. Here’s a
    somewhat more complex definition that creates a class that has the same signature
    as the Dice1 class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, the two classes, Dice1 and Dice2, can be interchanged freely.
    Here’s a function that accepts either class as an argument, creates an instance,
    and yields several rolls of the dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can use this function providing either the Dice1 class or Dice2 class for
    the dice argument value. The type[Dice1 | Dice2] type hint specifies a union of
    multiple equivalent classes. This function creates an instance of the given class
    in the dice parameter, and can even provide the seed value. Using a known seed
    creates reproducible results, often required for unit testing, and also used for
    reproducing statistical studies that involve randomized selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following interactive session shows the roller() function being applied
    to both classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The objects built from Dice1 and Dice2 have enough similarities that they’re
    indistinguishable.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve created two classes with identical collections of attributes and methods.
    This is the essence of duck typing. Because of the way Python searches through
    a sequence of dictionaries for matching names, classes do not need to have a common
    superclass to be interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: It can be helpful to define a union of related classes. An alternative is to
    define a common Protocol that the classes adhere to. It’s not necessary for each
    class to explicitly inherit from the Protocol definition, but it can make it more
    clear to your readers to do this. Tools like mypy can discern whether or not a
    class fits a Protocol, which is how duck typing works.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the definition of the roller() function, we used the following type hint:
    dice: type[Dice1 | Dice2].'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s often helpful to make this explicit with code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This can be easily extended as new alternative definitions are added. Client
    classes can then use type[Dice] to refer to the union of alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative is to define a protocol. A protocol defines a generic type with
    only the common features the various implementations will share:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It helps to create type hints later in the development process. After creating
    alternative implementations, it’s easy to define a type that’s a union of the
    various choices. If more implementations arise, they can be added to the union.
  prefs: []
  type: TYPE_NORMAL
- en: A protocol permits easier expansion of the alternatives. The protocol defines
    only the relevant features of the implementations. This is often done by refactoring
    the signatures of client methods and attributes to refer to the protocol class.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The duck type question is implicit in the [Choosing between inheritance and
    composition – the ”is-a” question](ch012.xhtml#x1-4530001) recipe; if we leverage
    duck typing, we’re also making a claim that two classes are not the same thing.
    When we bypass inheritance, we are implicitly claiming that the is-a relationship
    doesn’t hold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking at the [Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)
    recipe, we’re also able to leverage duck typing to create composite classes that
    may not have a simple inheritance hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4 Managing global and singleton objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python environment contains a number of implicit global objects. These objects
    provide a convenient way to work with a collection of other objects. Because the
    collection is implicit, we’re saved from the annoyance of explicit initialization
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this is an implicit random number generating object in the random
    module. When we evaluate random.random(), we’re actually making use of an instance
    of the random.Random class.
  prefs: []
  type: TYPE_NORMAL
- en: Because a module is only imported once, a module implements the Singleton design
    pattern. We can rely on this technique to implement these global singletons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other examples of this include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The collection of data encoders and decoders (codecs) available. The codecs
    module has a registry for encoders and decoders. We can add encodings and decodings
    to this registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The webbrowser module has a registry of known browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numbers module has a registry of numeric data types. This allows a module
    to define a new implementation of a numeric type and add it to the mix of known
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logging module maintains a collection of named loggers. The getLogger()
    function tries to find an existing logger; it creates a new logger if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The re module has a cache of compiled regular expressions. This saves the time
    to recompile a regular expression that’s defined inside a method or function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe will show how to work with an implicit global object like the registries
    used for codecs, browsers, and number classes.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A collection of functions can all work with an implicit global object, created
    by a module. The benefit is to allow other modules to share a common object without
    having to write any code that explicitly coordinates sharing.
  prefs: []
  type: TYPE_NORMAL
- en: This is potentially confusing to people reading your code.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of shared global state can become a design nightmare. The further step
    of making a shared object implicit may compound the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the examples from the Python standard library, there are two important
    patterns. First, there’s a narrow focus. Second, the updates to the registry are
    limited to adding new instances.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we’ll define a module with a global singleton object. We’ll look
    more at modules in Chapter [13](ch017.xhtml#x1-71500013).
  prefs: []
  type: TYPE_NORMAL
- en: Our global object will be a counter that we can use to accumulate centralized
    data from several independent modules or objects. We’ll use this global to count
    events in the application. The counts provide a summary of the work completed,
    and a check to confirm that all the work was completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to be able to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The some_processing() function might use something like count(’reject’) to count
    rejected input rows. This function may call other functions that also use the
    count() function to record evidence of the processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two independent functions both refer to a shared global counter:'
  prefs: []
  type: TYPE_NORMAL
- en: count(key) increments a global Counter and returns the current value for the
    given key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: counts() provides all of the Counter values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two common ways to handle global state information:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a module global variable because modules are singleton objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a class-level variable (called static in some programming languages). In
    Python, a class definition is also a singleton object that can be shared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover these as separate mini-recipes, starting with module globals.
  prefs: []
  type: TYPE_NORMAL
- en: Module global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can do the following to create a variable that is global to a module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a module file. This will be a .py file with the definitions in it. We’ll
    call it counter.py.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If necessary, define a class for the global singleton. In our case, we can
    use this definition to create a collections.Counter object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the one and only instance of the global singleton object. We’ve used
    a leading _ in the name to make it slightly less visible. It’s not — technically
    — private. It is, however, gracefully ignored by many Python tools and utilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A common idiom for marking global variables is to use an ALL_CAPS name. This
    seems more important for global variables that are to be considered as constants.
    In this case, this variable will be updated, and an ALL_CAPS name seems misleading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the two functions to use the global object, _global_counter. These functions
    encapsulate the detail of how the counter is implemented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can write applications that use the count() function in a variety of
    places. The counted events, however, are fully centralized in a single object,
    defined as part of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We’ve imported the count() and counts() functions from the counter module. We’ve
    also imported the Dice1 class as a handy object that creates a sequence of events.
    When we create an instance of Dice1, we provide an initialization to force a particular
    random seed. This gives repeatable results.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this technique is that several modules can all share the global
    object within the counter module. All that’s required is an import statement.
    No further coordination or overheads are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Class-level ”static” variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can do the following to create a variable that is global to all instances
    of a class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a class with a variable outside the __init__() method. This variable
    is part of the class, not part of an instance. To make it clear that the attribute
    is shared by all instances of the class, the ClassVar type hint is helpful. In
    this example, we’ve decided to use a leading _ so the class-level variable is
    not seen as part of the public interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add methods to update and extract data from the class-level _class_counter
    attribute. These will use the @classmethod decorators to show they are used directly
    by the class, not by an instance. The self variable is not used; instead, a cls
    variable is used as a reminder that the method applies to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It’s very important to note that the _class_counter attribute is part of the
    class, and is referred to as cls._class_counter. We don’t use a self instance
    variable because we aren’t referring to an instance of the class; we’re referring
    to a variable that’s part of the overall class definition, provided as the first
    parameter to a method decorated with @classmethod.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how we can use this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since all these operations update the EventCounter class, each increments the
    shared variable.
  prefs: []
  type: TYPE_NORMAL
- en: Shared global state must be used carefully.
  prefs: []
  type: TYPE_NORMAL
- en: They may be tangential to the real work of the class. The focus must be narrow
    and limited to very state changes.
  prefs: []
  type: TYPE_NORMAL
- en: When in doubt, explicitly shared objects will be a better design strategy, but
    will involve a bit more code.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python import mechanism uses sys.modules to track which modules are loaded.
    Once a module is in this mapping, it is not loaded again. This means that any
    variable defined within a module will be a singleton: there will only be one instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Within a module, a class definition can only be created once. This means the
    internal state changes of a class also follow the Singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How can we choose between these two mechanisms? The choice is based on the degree
    of confusion created by having multiple classes sharing a global state. As shown
    in the previous example in [Class-level ”static” variables](ch012.xhtml#x1-4770002),
    we could have multiple variables sharing a common Counter object. If the presence
    of an implicitly shared global state seems confusing, then a module-level global
    is a better choice. In the cases where a module-level global is confusing, share
    state explicitly with ordinary visible variables.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A shared global state can be called the opposite of object-oriented programming.
    One ideal of object-oriented programming is to encapsulate state changes in individual
    objects. Used too broadly, global variables break the idea of encapsulation of
    state within a single object.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, a module is a kind of class-like structure. A module is a namespace
    with module-level variables to define state and module functions that are like
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: One example of a need for a common global state often arises when trying to
    define configuration parameters for an application. It can help to have a single,
    uniform configuration that’s shared widely throughout multiple modules. When these
    objects are used for pervasive features such as configuration, audits, logging,
    and security, globals can be helpful for segregating a single, focused cross-cutting
    concern into a generic class separate from application-specific classes.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to create a configuration object explicitly. This configuration
    object can then be provided as a parameter to other objects throughout an application.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chapter [14](ch018.xhtml#x1-75800014) covers additional topics in module and
    application design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5 Using more complex structures – maps of lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter [4](ch008_split_000.xhtml#x1-2240004), we looked at the basic data
    structures available in Python. Those recipes generally looked at the various
    structures in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at a common combination structure—the mapping from a single key to
    a list of related values. This can be used to accumulate detailed information
    about database or log records identified by a given key. This recipe will partition
    a flat list of details into lists organized by shared key values.
  prefs: []
  type: TYPE_NORMAL
- en: This blurs into class design because we can often leverage Python’s built-in
    classes for this kind of work. This can reduces the volume of unique, new code
    we have to write.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll look at a mapping from a string to a list of instances of a class we’ll
    design. We’re going to start with some raw log entries from an application, decompose
    each line into individual fields, and then create individual Event objects from
    the fields of data. Once we have these objects, we can then reorganize and regroup
    them into lists associated with common attribute values like module name, or message
    severity.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter [5](ch009.xhtml#x1-2890005), we looked at log data in the [Creating
    dictionaries – inserting and updating](ch009.xhtml#x1-2900001) recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The first step will be to transform the log lines into a more useful comma-separated
    value (CSV) format. A regular expression can pick out the various syntactic groups.
    See the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001) for information on how
    the parsing works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw data looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Each row can be parsed into the component fields with a regular expression.
    We’ll define a NamedTuple subclass that has a static method, from_line(), to create
    instances of the class using these four fields. Making sure the attribute names
    match the regular expression group names, we can build instances of the class
    using the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our objective is to group the log messages by the module name attribute. We
    want to see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 8.5.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can write a summarize() function to restructure the log data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required modules and some type hints for various kinds of collections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The defaultdict type is a concrete class that extends the MutableMapping abstract
    base class. This is in a separate module from the Iterable type hint, which is
    an abstract base class definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The source data type, the Event class, was shown in the Getting ready section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an overall type hint for the summary dictionary we’ll be working with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the definition of a function to summarize an iterable source of the Event
    instances, and produce a Summary object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the list function as the default value for defaultdict. It’s also helpful
    to create a type hint for this collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list function is provided as a name only. A common mistake using list()
    will evaluate the function and create a list object that is not a function. An
    error message like TypeError: first argument must be callable or None is a reminder
    that the argument must be the name of a function only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Iterate through the data, appending to the list associated with each key. The
    defaultdict object will use the supplied list() function to build an empty list
    as the value corresponding to each new key the first time each key is encountered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the summarize() function is a dictionary that maps from a module
    name string to a list of all log rows for that module name. The data will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The key for this mapping is the module name and the value in the mapping is
    the list of rows for that module name. We can now focus the analysis on a specific
    module. This seems to be a close match with the initial expectations for the summarized
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two choices for how a mapping behaves when a key is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in dict class raises an exception when a key is missing. This makes
    it difficult to accumulate values associated with keys that aren’t known in advance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defaultdict class evaluates a function that creates a default value when
    a key is missing. In many cases, the function is int or float to create a default
    numeric value of 0 or 0.0\. In this case, the function is list to create an empty
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can imagine using the set function instead of list to create an empty set
    object for a missing key. This would be suitable for a mapping from a key to a
    set of immutable objects that share that key.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also build a version of this as an extension to the built-in dict class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We’ve provided an implementation for the special __missing__() method. The default
    behavior is to raise a KeyError exception. This will create a new empty list in
    the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to use code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The use case is identical to the defaultdict, but the definition of the collection
    class is slightly more complicated. This permits further extension to add features
    to the ModuleEvents class.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), we looked at the basics
    of using a mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), we looked at other places
    where default values are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [Using more sophisticated collections](ch011_split_001.xhtml#x1-4190008)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007), we looked at other examples
    of using the defaultdict class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.6 Creating a class that has orderable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need objects that can be sorted into order. Log records, to give one
    example, are often ordered by date and time. Most of our class definitions have
    not included the features necessary for sorting objects into order. Many of the
    recipes have kept objects in mappings or sets based on the internal hash value
    computed by the __hash__() method, and an equality test defined by the __eq__()
    method.
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep items in a sorted collection, we’ll need the comparison methods
    that implement <, >, <=, and >=. These comparisons are all based on the attribute
    values of each object.
  prefs: []
  type: TYPE_NORMAL
- en: When we extend the NamedTuple class, the comparison methods that apply to the
    tuple class are available. If we defined class using the @dataclass decorator,
    the comparison methods are not provided by default. We can use @dataclass(order=True)
    to have the ordering methods included. For this recipe, we’ll look at a class
    that is not based on either of these helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)
    recipe, we defined playing cards using two class definitions. The Card class hierarchy
    defined essential features of each card. A second set of mixin classes provided
    game-specific features for each card.
  prefs: []
  type: TYPE_NORMAL
- en: The core definition, Card, was a frozen dataclass. It did not have the order=True
    parameter, and does not properly put cards into order. We’ll need to add features
    to this Card definition to create objects that can be ordered properly.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume one more class definition, PinochlePoints to follow the rules for
    assigning points to cards for the game of Pinochle. The details don’t matter;
    all that matters is that the class implements the points() method.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a sortable collection of cards, we need to add yet another
    feature to the family of Card class definitions. We’ll need to define four special
    methods used for the comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an orderable class definition, we’ll create a comparison protocol,
    and then define a class that implements the protocol, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re defining a new protocol that tools like mypy can use when comparing objects.
    This will describe what kinds of objects the mixin will apply to. We’ve called
    it CardLike because it applies to any class with at least the two attributes of
    rank and suit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This use of something-Like as a protocol name is part of the overall Pythonic
    approach of duck typing. Rather than insist on a type hierarchy, we define the
    fewest features required as a new Protocol.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extending the protocol, we can create the SortableCard subclass for the comparison
    features. This subclass can be mixed into any class that fits the protocol definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the four order comparison methods to the SortableCard subclass. In this
    case, we’re using the relevant attributes of any class that fits the CardLike
    protocol into a tuple, then using Python’s built-in tuple comparison to handle
    the details of comparing the items in the tuple. Here are the methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the composite class definitions, built from an essential Card class and
    two mixin classes to provide the Pinochle and comparison features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There’s no simple superclass for this collection of classes. We’ll add a type
    hint to create a common definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create a function that will create individual PinochleCard objects
    from the classes defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The dauntingly complex point rules for Pinochle are encapsulated in the PinochlePoints
    class. We’ve omitted them because the points don’t parallel the six card ranks
    at all. Building composite classes as a base subclass of Card plus PinochlePoints
    leads to an accurate model of the cards without too much overt complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now make cards that respond to comparison operators, using the following
    sequence of interactive commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The equality comparisons to implement == and != are defined in the base class,
    Card. This is a frozen data class. By default, data classes contain equality test
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a function that builds the special 48-card deck. It creates two copies
    of each of the 24 different rank and suit combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The value of the SUITS variable is the four Unicode characters for the suits.
    The generator expression inside the make_deck() function builds two copies of
    each card using the 6 ranks that are part of the Pinochle game.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses special methods for a vast number of things. Almost every operator
    in the language is implemented by a special method. (The few exceptions are the
    is operator and and, or, and not.) In this recipe, we’ve leveraged the four ordering
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: The expression c1 <= c2 is evaluated as if we’d written c1.__le__(c2). This
    kind of transformation happens for almost all Python operators.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Language Reference organizes the special methods into several distinct
    groups. In this recipe, we’ve looked at methods used for basic customization of
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it looks when we work with instances of this class hierarchy. The
    first example will create a 48-card Pinochle deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The important part of the above example is the use of the sorted() function.
    Because we’ve defined proper comparison operators, we can sort the PinochleCard
    instances, and they are presented in the expected order from low rank to high
    rank.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A little formal logic suggests that we really only need to implement two of
    the comparisons in detail. From an equality method and one ordering method, all
    the remaining methods can be built. For example, if we build the operations for
    less than (__lt__()) and equal to (__eq__()), we could compute the other three
    comparisons following these equivalence rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![a ≤ b ≡ a < b∨ a = b ](img/file55.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![a ≥ b ≡ b < a∨ a = b ](img/file56.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![a ⁄= b ≡ ¬(a = b) ](img/file57.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: Python emphatically does not do any of this kind of advanced algebra for us.
    We need to do the algebra carefully and implement the necessary comparison methods.
  prefs: []
  type: TYPE_NORMAL
- en: The functools library includes a decorator, @total_ordering, that can generate
    these missing comparison methods.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the [Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)
    recipe for the essential definitions of cards and card game rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Chapter [7](ch011_split_000.xhtml#x1-3760007) for more information on dataclasses
    and named tuple classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.7 Deleting from a list of complicated objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing items from a list has an interesting consequence. Specifically, when
    an item is removed, all the subsequent items move forward. The rule is this:'
  prefs: []
  type: TYPE_NORMAL
- en: On deleting item y, items list[y+1:] take the place of items list[y:].
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a side-effect that happens in addition to removing the selected item.
    Because things can move around in a list, it makes deleting more than one item
    at a time potentially challenging.
  prefs: []
  type: TYPE_NORMAL
- en: When the list contains items that have a definition for the __eq__() special
    method, then the list remove() method can remove each item. When the list items
    don’t have a simple __eq__() test, then the remove() method doesn’t work, making
    it more challenging to remove multiple items from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1 Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we’ll work with a list of dictionaries, where a naïve approach
    to removing items doesn’t work out. It’s helpful to see what can go wrong with
    trying repeatedly to search a list for an item to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’ve got some data that includes a song name, the writers, and
    a duration. The dictionary objects are rather long. The data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The type hint for each row of this complex structure can be defined with as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A better design would use a datetime.timedelta for the song’s time. We’ve omitted
    this complication from the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The list of songs as a whole can be described as list[SongType].
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a naïve approach that emphatically does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Because items are moved, the computed index values will skip over the item
    just after one that is deleted. Further, because the list gets shorter, the range
    is wrong after a deletion. This fails with an index error, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Another failing approach looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This suffers from the problem that each remove() operation must search the list
    from the beginning. This approach will be slow for a very large list.
  prefs: []
  type: TYPE_NORMAL
- en: We need to combine search and remove operations in a way that avoids multiple
    passes through the list.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.2 How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To efficiently delete multiple items from a list, we’ll need to implement our
    own list index processing function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function to update a list object by removing selected items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize an index value, i, to zero to begin with the first item in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While the value for the i variable is not equal to the length of the list,
    we want to make a state change to either increment the i value or shrink the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the data[i] value is the searched-for target, we can remove it, shrinking
    the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Otherwise, increment the index value, i, one step closer to the length of the
    list:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This leads to the expected behavior of removing the items from the list without
    suffering from index errors, making multiple passes through the list items, or
    failing to delete matching items.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.3 How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal is to examine each item exactly once and either remove it or step
    over it, leaving it in place. The while statement design stems from looking at
    statements that advance toward the goal: increment the index, and delete an item.
    Each of these works in a limited set of conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing the index only works if the item should not be removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an item only works if the item is a match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s important is that the conditions are exclusive. When we use a for statement,
    the increment processing always happens, an undesirable feature. The while statement
    permits us to increment only when the item should be left in place.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.4 There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative to the overhead of removal is to create a new list with some
    items rejected. Making a shallow copy of items is much faster than removing items
    from a list, but uses more storage. This is a common example of the time versus
    memory trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a list comprehension like the following one to create a new list
    of only the desired items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This will create a shallow copy of selected items from the list. The items we
    don’t want to keep will be ignored. For more information on the idea of a shallow
    copy, see the Making shallow and deep copies of objects recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a higher-order function, filter(), as part of the copy operation.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter() function has two arguments: a lambda object and the original set
    of data. In this case, the lambda expression is used to decide which items to
    pass. Items for which the lambda returns False are rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: The filter() function is a generator. This means that we need to collect all
    of the items to create a final list object. The list() function is one way to
    consume all items from a generator, stashing them in the collection object they
    create and return.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.5 See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve leveraged two other recipes: [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    and [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) in Chapter [4](ch008_split_000.xhtml#x1-2240004).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll look closely at filters and generator expressions in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community Discord space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  prefs: []
  type: TYPE_IMG
