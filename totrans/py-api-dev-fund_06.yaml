- en: 6\. Email Confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Send out plaintext and HTML format emails using the Mailgun API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a token for account activation using the itsdangerous package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the entire workflow for user registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop applications using the benefits of environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers how to use an email package to develop an email activation
    feature on the food recipe sharing platform for user registration as well as email
    verification.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we worked on validating APIs using marshmallow. In
    this chapter, we will add functionality to our application that allows us to send
    emails to users.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone has their own email address. Some people may even have multiple mailboxes
    for different needs. In order to ensure the correctness of the email addresses
    entered by users when creating an account in our application, we need to verify
    their email address during registration. It is important to get their email address
    correct, as we may need to send emails to users in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement a function to verify a mailbox, learn how
    to send a message through the third-party Mailgun API, and create a unique token
    to ensure that it is verified by the user. This can be achieved with the `itsdangerous`
    package. At the end of the chapter, we will make our confidential information
    (for example, Mailgun API Secret Key) more secure by sorting it into environmental
    variables. So, when we upload our project to GitHub or other platforms down the
    road, this confidential information will not be shared in the project. The following
    is how the new user registration flow works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: New user registration flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: New user registration flow'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In our first section, we will introduce you to the `Mailgun` platform. Without
    further ado, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Mailgun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mailgun is a third-party **SMTP** (**Simple Mail Transfer Protocol**) and API
    sending email provider. Through Mailgun, not only can a large number of emails
    be sent, but the log for every email can also be traced. You have 10,000 free
    quotas per month. That means, in the free plan, we can only send, at most, 10,000
    emails. This will be enough for our learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Mailgun also provides an open RESTful API, which is easy to understand and use.
    In the following exercise, we will register a Mailgun account, and send an email
    through the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 40: Get Started with Using Mailgun'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start with, we need to register an account in Mailgun. As we explained before,
    Mailgun is a third-party platform. We will register a Mailgun account in this
    exercise. Then, we will obtain the necessary setup information to use their email
    sending service API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Mailgun website at [https://www.mailgun.com/](https://www.mailgun.com/).
    Click **Sign Up** to register an account. The home page will look like the following
    screenshot:![Figure 6.2: Mailgun home page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_06_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.2: Mailgun home page'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Once registration is done, Mailgun will send out a verification email with an
    account activation link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the link in the verification email to activate the account, which
    is shown in the following screenshot:![Figure 6.3: Mailgun account activation
    email'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.3: Mailgun account activation email'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, we will follow the Mailgun verification process. Enter your phone number
    to get a verification code. Use the code to activate your account. The screen
    will look like this:![Figure 6.4: Verifying the account'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_06_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.4: Verifying the account'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After your account is activated, log in to your account, then go to the **Overview**
    screen under **Sending**. There, you can find the domain name, API key, and base
    URL. This information is required for our subsequent programming work. Mailgun
    also provides sample code for a quick start:![Figure 6.5: Mailgun dashboard'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_06_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.5: Mailgun dashboard'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we have opened an account in Mailgun that will allow us to use their service
    to send emails to our users. The API URL and key are for our Smilecook application
    to connect to the Mailgun API. We will show you how to do that very soon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Currently, we are using the sandbox domain for testing. You can only send an
    email to your own email address (that is, the email address registered with Mailgun).
    If you want to send emails to other email addresses, you can add Authorized Recipients
    on the right-hand side, and it will send an email to that recipient. The recipient
    needs to accept you sending them email.
  prefs: []
  type: TYPE_NORMAL
- en: We will go through the process of how to send the first email in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 41: Using the Mailgun API to Send Out Emails'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, we have already registered an account with Mailgun. With that Mailgun account,
    we will be able to use the Mailgun API to send out emails to our users. In this
    exercise, we''ll use Mailgun to send out our first test email, programmatically,
    in our Smilecook project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import requests and create the `MailgunApi` class in `mailgun.py`, under the
    `Smilecook` project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `MailgunApi` class, set the `API_URL` to `https://api.mailgun.net/v3/{}/messages`;
    this is the `API_URL` provided by Mailgun:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `MailgunApi` class, define the `__init__` constructor method for
    instantiating the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same `MailgunApi` class, define the `send_email` method for sending
    out emails using the Mailgun API. This method takes in `to`, `subject`, `text`,
    and `html` as the input parameters and composes the email:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `MailgunApi` to send the first email. Open the `MailgunApi` from `mailgun`,
    then create a `mailgun` object by passing the domain name and API key provided
    by Mailgun in the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, use the `send_mail()` method in `MailgunApi` to send our first email.
    We can pass in the `email`, `subject`, and `body` as parameters. We will get an
    HTTP status code `smilecook.api@gmail.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the mailbox of the registered email address. You should receive an email.
    If you can''t find it, it could be in your spam folder:![Figure 6.6: Sending an
    email via Mailgun'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_06_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.6: Sending an email via Mailgun'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, we have just sent out our first email using the third-party `Mailgun` API.
    Now we know how to add email capability to our application without setting up
    our own mail server. Later on, we will incorporate this email capability into
    our Smilecook application. We are going to use it in our user account activation
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: User Account Activation Workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We would like to add an account activation step to our recipe sharing platform
    so that when a user registers an account in our system, the account will not be
    activated by default. At this time, a user cannot log in to their account dashboard.
    It''s only after they activate their account by clicking on the link in our activation
    email that they can then log in to their account dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: User account activation workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: User account activation workflow'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To build this workflow, we will use the `is_active` attribute in the user model
    to indicate whether the account is activated (whether the link of the activation
    email has been clicked), then create a method for sending the verification email
    when the user registers and the endpoint can be used to open the account. In order
    to create a unique link, we'll use the `itsdangerous` package, which will help
    us to create a unique token that will be used in the link for account activation.
    This package ensures that the email we generated is not modified by anyone so
    that we can verify the user's identity before we activate their account.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are interested in understanding more about the `itsdangerous` package,
    please visit [https://pythonhosted.org/itsdangerous/](https://pythonhosted.org/itsdangerous/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will generate the account activation token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 42: Generating the Account Activation Token'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As explained previously, we would like to implement a user account activation
    flow in our Smilecook application. This is to make sure the email address provided
    during registration is valid and is owned by the user. In this exercise, we will
    create a function to generate the activation token, as well as another function
    to verify the token. They will then be used later in the account activation flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the `itsdangerous` package using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following result returned after the packages are successfully
    installed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure the secret key is added in `config.py`; it will be useful when we
    use the `itsdangerous` package later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `utils.py`, import the `URLSafeTimedSerializer` module from `itsdangerous`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `utils.py` again, define the `generate_token` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `generate_token` method, we used the `URLSafeTimedSerializer` class to
    create a token via email and the `current_app.config.get('SECRET_KEY')` secret
    key, which is the secret key we set in the `config.py` settings. This same secret
    key will be used to verify this token in the future. Also, note that the timestamp
    will be in this token, after which we can verify the time this message was created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `utils.py` again, define the `verify_token` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `verify_token` function will try to extract the email address from the token,
    which will confirm whether the valid period in the token is within 30 minutes
    (*30 * 60* seconds) through the `max_age` attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: You can see in *steps 5* and *step 6*, that `salt` is used here to distinguish
    between different tokens. When tokens are created by email, for example, in the
    scenarios of opening an account, resetting the password, and upgrading the account,
    a verification email will be sent. You can use `salt='activate-salt'`, `salt='reset-salt'`,
    and `salt='upgrade-salt'` to distinguish between these scenarios.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we have these two handy functions to generate and verify the activation
    token, in the next exercise, we will use them in the user account activation flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 43: Sending Out the User Account Activation Email'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we have the activation token ready from our previous exercise, and we
    have also learned how to use the Mailgun API to send out an email. We are going
    to combine the two in this exercise, placing the activation token in the activation
    email to complete the whole account activation workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `url_for`, the `MailgunAPI` class, and the `generate_token` and `verify_token`
    functions into `resources/user.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `MailgunApi` object by passing in the `Mailgun` domain name and the
    API key that we got in the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `UserListResource` class, right after `user.save()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We first generate a token using `generate_token(user.email, salt='activate')`.
    Here, `salt='activate'` means that the token is mainly used to activate the account.
    The subject of the email is set to `Please confirm your registration`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an activation link and define the email text in the same `UserListResource`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create the activation link using the `url_for` function. It will require
    `UserActivateResource` (we will create that in our next step). This endpoint will
    need a token as well. The `_external=True` parameter is used to convert the default
    relative URL, `/users/activate/<string:token>`, to an absolute URL, `http://localhost:5000/users/activate/<string:token>`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we use the `mailgun.send_email` method to send the email in the same
    `UserListResource` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `UserActivateResource` class under `resources/user.py` and define
    the `get` method in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, this method verifies the token using `verify_token(token, salt='activate')`.
    The token has a default expiration time of 30 minutes. If the token is valid and
    not expired, we will get the user email and can proceed with the account activation.
    Otherwise, the email will be set to `False` and we can return an error message,
    `Invalid token or token expired`, with an **HTTP status code 400 Bad Request**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continue to work on the `UserActivateResource.get` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we have the user's email, we can look up the `user` object and modify its
    `is_active` attribute. If the user account is already activated, we will simply
    return `The user is already activated`. Otherwise, we activate the account and
    save that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we will return HTTP status code `204 No Content` to indicate that
    the request was handled successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Usually, in a real-world scenario, the activation link in the email will point
    to the frontend layer of the system. The frontend layer will, in turn, communicate
    with the backend through the API. Therefore, when the frontend receives the HTTP
    status code **204 No Content**, it means the account is activated. It can then
    forward the user to the account dashboard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, add the new `UserActivateResource` class to `app.py` by using the following
    code. First, import the `UserActivateResource` class from `resources.user`, then
    add the route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we would like to make sure the user cannot log in to the application
    before their account is activated. We will change the `POST` method in `resources/token.py`.
    Add the following lines of code right after checking the password to return the
    HTTP status code **403 Forbidden** if the user account is not activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on it to run the application. And we are ready to test the entire
    user registration workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have completed the development of the entire user registration
    workflow. Our Smilecook application will be able to send out an email with an
    activation link. Users can then click on the activation link to activate their
    user account.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, we would like you to go through the whole flow and test
    whether it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9: Testing the Complete User Registration and Activation Workflow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will test the complete user registration and activation
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Register a new user through Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in through the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the link sent to the mailbox to activate the account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in again after the account is activated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 314.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Setting Up Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to use environment variables to ensure that our sensitive information,
    such as the secret key, is safe. This ensures that we are not leaking this sensitive
    and confidential information when we share code with others. Environment variables
    are only saved in the local environment and they won't appear in code. That is
    a usual best practice to segregate code from confidential information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 44: Setting Up Environment Variables in PyCharm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The environment variable is a key-value pair stored in the local system, which
    can be accessed by our application. In this exercise, we will set the environment
    variables through `PyCharm`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `PyCharm` interface, select **Run** and then click **Edit
    Configurations**:![Figure 6.8: Select Run and click Edit Configurations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_06_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.8: Select Run and click Edit Configurations'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Click `MAILGUN_DOMAIN` and `MAILGUN_API_KEY` environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your screen will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_06_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: For the Python console, to read the environment variables, we can set it under
    *Pycharm >> Preferences >> Build, Execution, Deployment >> Console >> Python Console*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then import the `os` package in `resources/user.py` and get the value
    in the environment variables using `os.environ[''MAILGUN_DOMAIN'']` and `os.environ[''MAILGUN_API_KEY'']`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, this is how you can move the secret `API_KEY` and other related information
    out from the code. This secret data is now stored in the environment variable
    and is isolated from the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we get the environment variable using `os.environ[''KEY'']`. It will raise
    a `''KeyError''` if the environment variable is not defined. We can get the value
    using `os.environ.get(''KEY'')` or `os.getenv(''Key'')`. This will give us None
    if the variable is not defined. If we want to set a default value if the environment
    variable is not defined, we can use this syntax: `os.getenv(''KEY'', default_value)`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: HTML Format Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add a bit of color to our email by using an HTML format email instead
    of plaintext email. HTML format email is everywhere. I am sure you have seen images
    in emails, or emails with a fancy layout. Those are HTML format emails. Theoretically,
    to send out HTML format email using the `Mailgun` API, it could be as simple as
    passing in the HTML code as a parameter to the `mailgun.send_email` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following sample code to send out an HTML format email
    using Mailgun. We can see that we are just adding the new `html` parameter here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, this way of coupling the HTML code with the Python code is cumbersome.
    If we have a fancy layout, the HTML can be pretty long and that's too much to
    be included in the actual Python code. To address this, we can leverage the `render_template()`
    function in Flask. This is a function that makes use of the Jinja2 template engine.
    With it, we can just place the HTML code in a separate HTML file under a `/templates`
    folder in the application project. We can then pass in the HTML file, also called
    a template file, to this `render_template` function to generate the HTML text.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the following sample code, we can see that, with the `render_template`
    function, we can simplify the code a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then render the HTML with the subject set to `Test email` using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The sample code here will look for the `templates/sample.html` file under the
    application project folder and render the HTML code for us.
  prefs: []
  type: TYPE_NORMAL
- en: The function is named `render_template` instead of `render_html` for a reason.
    The `render_template` function does more than just directly outputting the HTML
    code from the file. In fact, we can insert variable in the HTML template file
    and have the `render_template` function render it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can modify `sample.html` like this (the `{{content}}` here
    is a placeholder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then render the HTML with the subject set to `test email` using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the next activity, we would like you to send out the activation email in
    HTML format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10: Creating the HTML Format User Account Activation Email'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have previously sent out plaintext format emails. In this activity, we will
    create an HTML format email so that it looks more appealing to our users:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the user's email address into the `Mailgun` authorized recipient list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy an HTML template from the `Mailgun` website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add in the activation token in the HTML template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `render_template` function to render the HTML code and send out the
    activation email using the `Mailgun` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register a new account in Postman and get the account activation email in HTML
    format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 317.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You have now learned how to send out an email in HTML format. You can design
    your own HTML templates from now on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use the third-party `Mailgun` API to send
    a user account activation email. Later, we can send different emails, such as
    a notification email, using the `MailgunAPI` class. Mailgun not only provides
    the API for sending mail but also provides a backend dashboard for us to track
    the status of the emails we've sent out. It is a very handy service. User account
    activation is an important step to ensure we are onboarding a validated user.
    Though not every platform performs this kind of validation, it reduces the impact
    of spam and bots onboarding our platform. In this chapter, we used the `itsdangerous`
    package to create a unique token to confirm the ownership of the user's email
    address. This package contains timestamps so that we can verify whether the token
    has expired or not.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to add more features to our Smilecook
    application. We will work with images in our next chapter. I am sure you will
    learn a lot of practical skills there. Let's continue our journey.
  prefs: []
  type: TYPE_NORMAL
