- en: 6\. Email Confirmation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 电子邮件确认
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够：
- en: Send out plaintext and HTML format emails using the Mailgun API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mailgun API 发送纯文本和 HTML 格式的电子邮件
- en: Create a token for account activation using the itsdangerous package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 itsdangerous 包创建用于账户激活的令牌
- en: Utilize the entire workflow for user registration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用整个用户注册工作流程
- en: Develop applications using the benefits of environment variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用环境变量的优势开发应用程序
- en: This chapter covers how to use an email package to develop an email activation
    feature on the food recipe sharing platform for user registration as well as email
    verification.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何使用电子邮件包在食品食谱分享平台上开发电子邮件激活功能，以及用户注册和电子邮件验证。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we worked on validating APIs using marshmallow. In
    this chapter, we will add functionality to our application that allows us to send
    emails to users.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用 marshmallow 验证了 API。在本章中，我们将向我们的应用程序添加功能，使我们能够向用户发送电子邮件。
- en: Everyone has their own email address. Some people may even have multiple mailboxes
    for different needs. In order to ensure the correctness of the email addresses
    entered by users when creating an account in our application, we need to verify
    their email address during registration. It is important to get their email address
    correct, as we may need to send emails to users in the future.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都有自己的电子邮件地址。有些人甚至可能为了不同的需求拥有多个邮箱。为了确保用户在创建我们应用程序的账户时输入的电子邮件地址的正确性，我们需要在注册时验证他们的电子邮件地址。获取他们的电子邮件地址是重要的，因为我们可能需要将来向用户发送电子邮件。
- en: 'In this chapter, we will implement a function to verify a mailbox, learn how
    to send a message through the third-party Mailgun API, and create a unique token
    to ensure that it is verified by the user. This can be achieved with the `itsdangerous`
    package. At the end of the chapter, we will make our confidential information
    (for example, Mailgun API Secret Key) more secure by sorting it into environmental
    variables. So, when we upload our project to GitHub or other platforms down the
    road, this confidential information will not be shared in the project. The following
    is how the new user registration flow works:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个验证邮箱的功能，学习如何通过第三方 Mailgun API 发送消息，并创建一个唯一的令牌以确保它被用户验证。这可以通过 `itsdangerous`
    包实现。在本章结束时，我们将通过将其分类到环境变量中，使我们的机密信息（例如，Mailgun API 密钥）更加安全。这样，当我们将来将项目上传到 GitHub
    或其他平台时，这些机密信息将不会在项目中共享。以下是新用户注册流程的步骤：
- en: '![Figure 6.1: New user registration flow'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1：新用户注册流程](img/C15309_06_01.jpg)'
- en: '](img/C15309_06_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1：新用户注册流程](img/C15309_06_01.jpg)'
- en: 'Figure 6.1: New user registration flow'
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.1：新用户注册流程
- en: In our first section, we will introduce you to the `Mailgun` platform. Without
    further ado, let's get started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一部分，我们将向您介绍 `Mailgun` 平台。无需多言，让我们开始吧。
- en: Mailgun
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mailgun
- en: Mailgun is a third-party **SMTP** (**Simple Mail Transfer Protocol**) and API
    sending email provider. Through Mailgun, not only can a large number of emails
    be sent, but the log for every email can also be traced. You have 10,000 free
    quotas per month. That means, in the free plan, we can only send, at most, 10,000
    emails. This will be enough for our learning purposes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Mailgun 是一家第三方 **SMTP** （**简单邮件传输协议**）和 API 发送电子邮件的服务提供商。通过 Mailgun，不仅可以发送大量电子邮件，还可以追踪每封邮件的日志。您每月有
    10,000 个免费配额。这意味着，在免费计划中，我们最多只能发送 10,000 封电子邮件。这对于我们的学习目的来说已经足够了。
- en: Mailgun also provides an open RESTful API, which is easy to understand and use.
    In the following exercise, we will register a Mailgun account, and send an email
    through the API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Mailgun 还提供了一个易于理解和使用的开放 RESTful API。在接下来的练习中，我们将注册一个 Mailgun 账户，并通过 API 发送电子邮件。
- en: 'Exercise 40: Get Started with Using Mailgun'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 40：开始使用 Mailgun
- en: 'To start with, we need to register an account in Mailgun. As we explained before,
    Mailgun is a third-party platform. We will register a Mailgun account in this
    exercise. Then, we will obtain the necessary setup information to use their email
    sending service API:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 Mailgun 中注册一个账户。正如我们之前所解释的，Mailgun 是一个第三方平台。在这个练习中，我们将注册一个 Mailgun
    账户，然后获取使用他们电子邮件发送服务 API 所需的必要设置信息：
- en: 'Visit the Mailgun website at [https://www.mailgun.com/](https://www.mailgun.com/).
    Click **Sign Up** to register an account. The home page will look like the following
    screenshot:![Figure 6.2: Mailgun home page'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Mailgun 网站 [https://www.mailgun.com/](https://www.mailgun.com/)。点击 **注册**
    来注册一个账户。主页将看起来像以下截图：![图 6.2：Mailgun 主页](img/C15309_06_02.jpg)
- en: '](img/C15309_06_02.jpg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_02.jpg)'
- en: 'Figure 6.2: Mailgun home page'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：Mailgun主页
- en: Once registration is done, Mailgun will send out a verification email with an
    account activation link.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦完成注册，Mailgun将发送包含账户激活链接的验证邮件。
- en: 'Click on the link in the verification email to activate the account, which
    is shown in the following screenshot:![Figure 6.3: Mailgun account activation
    email'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击验证邮件中的链接以激活账户，如下截图所示：![图6.3：Mailgun账户激活邮件
- en: '](img/C15309_06_03.jpg)'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_03.jpg)'
- en: 'Figure 6.3: Mailgun account activation email'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：Mailgun账户激活邮件
- en: 'Then, we will follow the Mailgun verification process. Enter your phone number
    to get a verification code. Use the code to activate your account. The screen
    will look like this:![Figure 6.4: Verifying the account'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将遵循Mailgun的验证流程。输入您的电话号码以获取验证码。使用该代码激活您的账户。屏幕将看起来像这样：![图6.4：验证账户
- en: '](img/C15309_06_04.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_04.jpg)'
- en: 'Figure 6.4: Verifying the account'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：验证账户
- en: 'After your account is activated, log in to your account, then go to the **Overview**
    screen under **Sending**. There, you can find the domain name, API key, and base
    URL. This information is required for our subsequent programming work. Mailgun
    also provides sample code for a quick start:![Figure 6.5: Mailgun dashboard'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户激活后，登录您的账户，然后转到**发送**下的**概览**屏幕。在那里，您可以找到域名、API密钥和基本URL。这些信息是我们后续编程工作所需的信息。Mailgun还提供了快速入门的示例代码：![图6.5：Mailgun仪表板
- en: '](img/C15309_06_05.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_05.jpg)'
- en: 'Figure 6.5: Mailgun dashboard'
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：Mailgun仪表板
- en: Now we have opened an account in Mailgun that will allow us to use their service
    to send emails to our users. The API URL and key are for our Smilecook application
    to connect to the Mailgun API. We will show you how to do that very soon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Mailgun中开设了一个账户，这将允许我们使用他们的服务向我们的用户发送邮件。API URL和密钥是用于我们的Smilecook应用程序连接到Mailgun
    API的。我们很快就会向您展示如何做到这一点。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, we are using the sandbox domain for testing. You can only send an
    email to your own email address (that is, the email address registered with Mailgun).
    If you want to send emails to other email addresses, you can add Authorized Recipients
    on the right-hand side, and it will send an email to that recipient. The recipient
    needs to accept you sending them email.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用沙盒域进行测试。您只能向自己的电子邮件地址发送邮件（即与Mailgun注册的电子邮件地址）。如果您想向其他电子邮件地址发送邮件，您可以在右侧添加授权收件人，并将邮件发送给该收件人。收件人需要接受您发送的邮件。
- en: We will go through the process of how to send the first email in the next exercise.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中讲解如何发送第一封邮件。
- en: 'Exercise 41: Using the Mailgun API to Send Out Emails'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习41：使用Mailgun API发送邮件
- en: 'So, we have already registered an account with Mailgun. With that Mailgun account,
    we will be able to use the Mailgun API to send out emails to our users. In this
    exercise, we''ll use Mailgun to send out our first test email, programmatically,
    in our Smilecook project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经在Mailgun上注册了一个账户。有了这个Mailgun账户，我们将能够使用Mailgun API向我们的用户发送邮件。在这个练习中，我们将使用Mailgun在我们的Smilecook项目中以编程方式发送第一封测试邮件：
- en: 'Import requests and create the `MailgunApi` class in `mailgun.py`, under the
    `Smilecook` project:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mailgun.py`文件下，`Smilecook`项目中导入requests并创建`MailgunApi`类：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the same `MailgunApi` class, set the `API_URL` to `https://api.mailgun.net/v3/{}/messages`;
    this is the `API_URL` provided by Mailgun:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`MailgunApi`类中，将`API_URL`设置为`https://api.mailgun.net/v3/{}/messages`；这是Mailgun提供的`API_URL`：
- en: '[PRE1]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the same `MailgunApi` class, define the `__init__` constructor method for
    instantiating the object:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`MailgunApi`类中，定义用于实例化对象的`__init__`构造方法：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the same `MailgunApi` class, define the `send_email` method for sending
    out emails using the Mailgun API. This method takes in `to`, `subject`, `text`,
    and `html` as the input parameters and composes the email:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的`MailgunApi`类中，定义用于通过Mailgun API发送邮件的`send_email`方法。此方法接受`to`、`subject`、`text`和`html`作为输入参数并组成邮件：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use `MailgunApi` to send the first email. Open the `MailgunApi` from `mailgun`,
    then create a `mailgun` object by passing the domain name and API key provided
    by Mailgun in the previous exercise:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`MailgunApi`发送第一封邮件。从`mailgun`中打开`MailgunApi`，然后通过传递之前练习中提供的域名和API密钥创建一个`mailgun`对象：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then, use the `send_mail()` method in `MailgunApi` to send our first email.
    We can pass in the `email`, `subject`, and `body` as parameters. We will get an
    HTTP status code `smilecook.api@gmail.com`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`MailgunApi`中的`send_mail()`方法发送我们的第一封电子邮件。我们可以将`email`、`subject`和`body`作为参数传递。我们将得到HTTP状态码`smilecook.api@gmail.com`。
- en: 'Check the mailbox of the registered email address. You should receive an email.
    If you can''t find it, it could be in your spam folder:![Figure 6.6: Sending an
    email via Mailgun'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查注册电子邮件地址的邮箱。你应该会收到一封电子邮件。如果你找不到它，它可能在你垃圾邮件文件夹中：![图6.6：通过Mailgun发送电子邮件
- en: '](img/C15309_06_06.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C15309_06_06.jpg](img/C15309_06_06.jpg)'
- en: 'Figure 6.6: Sending an email via Mailgun'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：通过Mailgun发送电子邮件
- en: So, we have just sent out our first email using the third-party `Mailgun` API.
    Now we know how to add email capability to our application without setting up
    our own mail server. Later on, we will incorporate this email capability into
    our Smilecook application. We are going to use it in our user account activation
    workflow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们刚刚使用第三方`Mailgun` API发送了第一封电子邮件。现在我们知道了如何在不设置自己的邮件服务器的情况下，将电子邮件功能添加到我们的应用程序中。稍后，我们将把这个电子邮件功能整合到我们的Smilecook应用程序中。我们打算在用户账户激活工作流程中使用它。
- en: User Account Activation Workflow
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户账户激活工作流程
- en: 'We would like to add an account activation step to our recipe sharing platform
    so that when a user registers an account in our system, the account will not be
    activated by default. At this time, a user cannot log in to their account dashboard.
    It''s only after they activate their account by clicking on the link in our activation
    email that they can then log in to their account dashboard:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在我们的食谱分享平台上添加一个账户激活步骤，这样当用户在我们的系统中注册账户时，账户将不会默认激活。此时，用户无法登录到他们的账户仪表板。只有当他们通过点击我们的激活电子邮件中的链接激活账户后，他们才能登录到他们的账户仪表板：
- en: '![Figure 6.7: User account activation workflow'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：用户账户激活工作流程'
- en: '](img/C15309_06_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C15309_06_07.jpg](img/C15309_06_07.jpg)'
- en: 'Figure 6.7: User account activation workflow'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：用户账户激活工作流程
- en: To build this workflow, we will use the `is_active` attribute in the user model
    to indicate whether the account is activated (whether the link of the activation
    email has been clicked), then create a method for sending the verification email
    when the user registers and the endpoint can be used to open the account. In order
    to create a unique link, we'll use the `itsdangerous` package, which will help
    us to create a unique token that will be used in the link for account activation.
    This package ensures that the email we generated is not modified by anyone so
    that we can verify the user's identity before we activate their account.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个工作流程，我们将使用用户模型中的`is_active`属性来指示账户是否已激活（激活电子邮件的链接是否已被点击），然后创建一个在用户注册时发送验证电子邮件的方法，以及一个端点可以用来激活账户。为了创建一个唯一的链接，我们将使用`itsdangerous`包，这将帮助我们创建一个用于账户激活链接的唯一令牌。这个包确保我们生成的电子邮件不会被任何人修改，这样我们就可以在激活用户的账户之前验证用户的身份。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in understanding more about the `itsdangerous` package,
    please visit [https://pythonhosted.org/itsdangerous/](https://pythonhosted.org/itsdangerous/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`itsdangerous`包的信息，请访问[https://pythonhosted.org/itsdangerous/](https://pythonhosted.org/itsdangerous/)。
- en: In the next exercise, we will generate the account activation token.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将生成账户激活令牌。
- en: 'Exercise 42: Generating the Account Activation Token'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习42：生成账户激活令牌
- en: 'As explained previously, we would like to implement a user account activation
    flow in our Smilecook application. This is to make sure the email address provided
    during registration is valid and is owned by the user. In this exercise, we will
    create a function to generate the activation token, as well as another function
    to verify the token. They will then be used later in the account activation flow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望在Smilecook应用程序中实现一个用户账户激活流程。这是为了确保在注册过程中提供的电子邮件地址是有效的，并且属于用户本人。在这个练习中，我们将创建一个生成激活令牌的函数，以及另一个验证令牌的函数。然后，它们将在账户激活流程中稍后使用：
- en: 'Add the following line of code to `requirements.txt`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`requirements.txt`文件中：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install the `itsdangerous` package using the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`itsdangerous`包：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should see the following result returned after the packages are successfully
    installed:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在成功安装包之后，你应该会看到以下结果返回：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make sure the secret key is added in `config.py`; it will be useful when we
    use the `itsdangerous` package later:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`config.py`中添加了密钥；当我们稍后使用`itsdangerous`包时，它会很有用：
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In `utils.py`, import the `URLSafeTimedSerializer` module from `itsdangerous`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`utils.py`中，从`itsdangerous`导入`URLSafeTimedSerializer`模块：
- en: '[PRE9]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `utils.py` again, define the `generate_token` function:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在`utils.py`中定义`generate_token`函数：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `generate_token` method, we used the `URLSafeTimedSerializer` class to
    create a token via email and the `current_app.config.get('SECRET_KEY')` secret
    key, which is the secret key we set in the `config.py` settings. This same secret
    key will be used to verify this token in the future. Also, note that the timestamp
    will be in this token, after which we can verify the time this message was created.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`generate_token`方法中，我们使用`URLSafeTimedSerializer`类通过电子邮件和`current_app.config.get('SECRET_KEY')`密钥创建令牌，这是我们在`config.py`设置中设置的密钥。这个相同的密钥将在未来验证这个令牌时使用。此外，请注意，时间戳将包含在这个令牌中，之后我们可以验证消息创建的时间。
- en: 'In `utils.py` again, define the `verify_token` function:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在`utils.py`中定义`verify_token`函数：
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `verify_token` function will try to extract the email address from the token,
    which will confirm whether the valid period in the token is within 30 minutes
    (*30 * 60* seconds) through the `max_age` attribute.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`verify_token`函数将尝试从令牌中提取电子邮件地址，这将确认令牌中的有效期限是否在30分钟内（*30 * 60* 秒）通过`max_age`属性。'
- en: Note
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You can see in *steps 5* and *step 6*, that `salt` is used here to distinguish
    between different tokens. When tokens are created by email, for example, in the
    scenarios of opening an account, resetting the password, and upgrading the account,
    a verification email will be sent. You can use `salt='activate-salt'`, `salt='reset-salt'`,
    and `salt='upgrade-salt'` to distinguish between these scenarios.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在*步骤5*和*步骤6*中看到，这里使用`salt`来区分不同的令牌。例如，当通过电子邮件创建令牌时，在开户、重置密码和升级账户的场景中，会发送一封验证邮件。你可以使用`salt='activate-salt'`、`salt='reset-salt'`和`salt='upgrade-salt'`来区分这些场景。
- en: Now we have these two handy functions to generate and verify the activation
    token, in the next exercise, we will use them in the user account activation flow.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个方便的函数来生成和验证激活令牌，在下一个练习中，我们将它们用于用户账户激活流程中。
- en: 'Exercise 43: Sending Out the User Account Activation Email'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习43：发送用户账户激活电子邮件
- en: 'Now, we have the activation token ready from our previous exercise, and we
    have also learned how to use the Mailgun API to send out an email. We are going
    to combine the two in this exercise, placing the activation token in the activation
    email to complete the whole account activation workflow:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从上一个练习中准备好了激活令牌，并且我们也学习了如何使用Mailgun API发送电子邮件。在这个练习中，我们将结合这两者，将激活令牌放入激活电子邮件中，以完成整个账户激活工作流程：
- en: 'Import `url_for`, the `MailgunAPI` class, and the `generate_token` and `verify_token`
    functions into `resources/user.py`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`url_for`、`MailgunAPI`类以及`generate_token`和`verify_token`函数导入到`resources/user.py`中：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `MailgunApi` object by passing in the `Mailgun` domain name and the
    API key that we got in the previous exercise:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递我们在上一个练习中获得的`Mailgun`域名和API密钥来创建一个`MailgunApi`对象：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code in the `UserListResource` class, right after `user.save()`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserListResource`类中，在`user.save()`之后添加以下代码：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We first generate a token using `generate_token(user.email, salt='activate')`.
    Here, `salt='activate'` means that the token is mainly used to activate the account.
    The subject of the email is set to `Please confirm your registration`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先使用`generate_token(user.email, salt='activate')`生成一个令牌。这里，`salt='activate'`表示令牌主要用于激活账户。电子邮件的主题设置为`请确认您的注册`。
- en: 'Create an activation link and define the email text in the same `UserListResource`
    class:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`UserListResource`类中创建一个激活链接并定义电子邮件文本：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We create the activation link using the `url_for` function. It will require
    `UserActivateResource` (we will create that in our next step). This endpoint will
    need a token as well. The `_external=True` parameter is used to convert the default
    relative URL, `/users/activate/<string:token>`, to an absolute URL, `http://localhost:5000/users/activate/<string:token>`:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`url_for`函数创建激活链接。它将需要`UserActivateResource`（我们将在下一步创建）。这个端点也需要一个令牌。`_external=True`参数用于将默认的相对URL
    `/users/activate/<string:token>` 转换为绝对URL `http://localhost:5000/users/activate/<string:token>`：
- en: 'Finally, we use the `mailgun.send_email` method to send the email in the same
    `UserListResource` class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`mailgun.send_email`方法在同一个`UserListResource`类中发送电子邮件：
- en: '[PRE16]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a new `UserActivateResource` class under `resources/user.py` and define
    the `get` method in it:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/user.py`下创建一个新的`UserActivateResource`类，并在其中定义`get`方法：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, this method verifies the token using `verify_token(token, salt='activate')`.
    The token has a default expiration time of 30 minutes. If the token is valid and
    not expired, we will get the user email and can proceed with the account activation.
    Otherwise, the email will be set to `False` and we can return an error message,
    `Invalid token or token expired`, with an **HTTP status code 400 Bad Request**.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，此方法使用`verify_token(token, salt='activate')`验证令牌。令牌有默认的30分钟过期时间。如果令牌有效且未过期，我们将获取用户电子邮件并可以继续账户激活。否则，电子邮件将被设置为`False`，我们可以返回错误消息`Invalid
    token or token expired`，并带有**HTTP状态码400 Bad Request**。
- en: 'Continue to work on the `UserActivateResource.get` method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在`UserActivateResource.get`方法上工作：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If we have the user's email, we can look up the `user` object and modify its
    `is_active` attribute. If the user account is already activated, we will simply
    return `The user is already activated`. Otherwise, we activate the account and
    save that.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们有用户的电子邮件，我们可以查找`user`对象并修改其`is_active`属性。如果用户账户已经激活，我们将简单地返回`用户已激活`。否则，我们将激活账户并保存。
- en: 'Finally, we will return HTTP status code `204 No Content` to indicate that
    the request was handled successfully:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将返回HTTP状态码`204 No Content`以指示请求已成功处理：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, in a real-world scenario, the activation link in the email will point
    to the frontend layer of the system. The frontend layer will, in turn, communicate
    with the backend through the API. Therefore, when the frontend receives the HTTP
    status code **204 No Content**, it means the account is activated. It can then
    forward the user to the account dashboard.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，在现实世界的场景中，电子邮件中的激活链接将指向系统的前端层。前端层会通过API与后端通信。因此，当前端接收到HTTP状态码**204 No Content**时，意味着账户已激活。然后它可以转发用户到账户仪表板。
- en: 'Then, add the new `UserActivateResource` class to `app.py` by using the following
    code. First, import the `UserActivateResource` class from `resources.user`, then
    add the route:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过以下代码将新的`UserActivateResource`类添加到`app.py`中。首先从`resources.user`导入`UserActivateResource`类，然后添加路由：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we would like to make sure the user cannot log in to the application
    before their account is activated. We will change the `POST` method in `resources/token.py`.
    Add the following lines of code right after checking the password to return the
    HTTP status code **403 Forbidden** if the user account is not activated:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们想确保用户在账户激活之前不能登录到应用程序。我们将更改`resources/token.py`中的`POST`方法。在检查密码后立即返回HTTP状态码**403
    Forbidden**，如果用户账户未激活：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Right-click on it to run the application. And we are ready to test the entire
    user registration workflow.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击以运行应用程序。然后我们准备测试整个用户注册工作流程。
- en: Congratulations! You have completed the development of the entire user registration
    workflow. Our Smilecook application will be able to send out an email with an
    activation link. Users can then click on the activation link to activate their
    user account.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已完成了整个用户注册工作流程的开发。我们的Smilecook应用程序将能够发送带有激活链接的电子邮件。用户可以点击激活链接来激活他们的用户账户。
- en: In the next activity, we would like you to go through the whole flow and test
    whether it works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们希望您走完整个流程并测试它是否工作。
- en: 'Activity 9: Testing the Complete User Registration and Activation Workflow'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动九：测试完整的用户注册和激活工作流程
- en: 'In this activity, we will test the complete user registration and activation
    workflow:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将测试完整的用户注册和激活工作流程：
- en: Register a new user through Postman.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过Postman注册新用户。
- en: Log in through the API.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过API登录。
- en: Use the link sent to the mailbox to activate the account.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用发送到邮箱的链接来激活账户。
- en: Log in again after the account is activated.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户激活后重新登录。
- en: Note
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 314.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第314页找到。
- en: Setting Up Environment Variables
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置环境变量
- en: We are going to use environment variables to ensure that our sensitive information,
    such as the secret key, is safe. This ensures that we are not leaking this sensitive
    and confidential information when we share code with others. Environment variables
    are only saved in the local environment and they won't appear in code. That is
    a usual best practice to segregate code from confidential information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用环境变量来确保我们的敏感信息，例如密钥，是安全的。这确保了当我们与他人共享代码时不会泄露这些敏感和机密信息。环境变量仅保存在本地环境中，它们不会出现在代码中。这是将代码与机密信息分离的常用最佳实践。
- en: 'Exercise 44: Setting Up Environment Variables in PyCharm'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 44：在 PyCharm 中设置环境变量
- en: 'The environment variable is a key-value pair stored in the local system, which
    can be accessed by our application. In this exercise, we will set the environment
    variables through `PyCharm`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是在本地系统中存储的键值对，可以被我们的应用程序访问。在这个练习中，我们将通过 `PyCharm` 设置环境变量：
- en: 'At the top of the `PyCharm` interface, select **Run** and then click **Edit
    Configurations**:![Figure 6.8: Select Run and click Edit Configurations'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PyCharm` 界面的顶部，选择 **运行** 然后点击 **编辑配置**：![图 6.8：选择运行并点击编辑配置
- en: '](img/C15309_06_08.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_08.jpg)'
- en: 'Figure 6.8: Select Run and click Edit Configurations'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.8：选择运行并点击编辑配置
- en: Click `MAILGUN_DOMAIN` and `MAILGUN_API_KEY` environment variables.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `MAILGUN_DOMAIN` 和 `MAILGUN_API_KEY` 环境变量。
- en: 'Your screen will look as follows:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的屏幕将如下所示：
- en: '![Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.9：添加 MAILGUN_DOMAIN 和 MAILGUN_API_KEY 环境变量'
- en: '](img/C15309_06_09.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_06_09.jpg)'
- en: 'Figure 6.9: Adding the MAILGUN_DOMAIN and MAILGUN_API_KEY environment variables'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.9：添加 MAILGUN_DOMAIN 和 MAILGUN_API_KEY 环境变量
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For the Python console, to read the environment variables, we can set it under
    *Pycharm >> Preferences >> Build, Execution, Deployment >> Console >> Python Console*.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Python 控制台，要读取环境变量，我们可以在 *Pycharm >> 首选项 >> 构建、执行、部署 >> 控制台 >> Python 控制台*
    下设置。
- en: 'We will then import the `os` package in `resources/user.py` and get the value
    in the environment variables using `os.environ[''MAILGUN_DOMAIN'']` and `os.environ[''MAILGUN_API_KEY'']`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 `resources/user.py` 中导入 `os` 包，并使用 `os.environ['MAILGUN_DOMAIN']` 和 `os.environ['MAILGUN_API_KEY']`
    获取环境变量中的值：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, this is how you can move the secret `API_KEY` and other related information
    out from the code. This secret data is now stored in the environment variable
    and is isolated from the code.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，这就是如何将秘密的 `API_KEY` 和其他相关信息从代码中移除。这些秘密数据现在存储在环境变量中，并且与代码隔离。
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we get the environment variable using `os.environ[''KEY'']`. It will raise
    a `''KeyError''` if the environment variable is not defined. We can get the value
    using `os.environ.get(''KEY'')` or `os.getenv(''Key'')`. This will give us None
    if the variable is not defined. If we want to set a default value if the environment
    variable is not defined, we can use this syntax: `os.getenv(''KEY'', default_value)`.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们使用 `os.environ['KEY']` 获取环境变量，如果环境变量未定义，则会引发 `'KeyError'`。我们可以使用 `os.environ.get('KEY')`
    或 `os.getenv('Key')` 获取值。如果变量未定义，这将返回 None。如果我们想在环境变量未定义时设置一个默认值，我们可以使用这个语法：`os.getenv('KEY',
    default_value)`。
- en: HTML Format Email
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 格式电子邮件
- en: We can add a bit of color to our email by using an HTML format email instead
    of plaintext email. HTML format email is everywhere. I am sure you have seen images
    in emails, or emails with a fancy layout. Those are HTML format emails. Theoretically,
    to send out HTML format email using the `Mailgun` API, it could be as simple as
    passing in the HTML code as a parameter to the `mailgun.send_email` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 HTML 格式的电子邮件而不是纯文本电子邮件来给我们的电子邮件添加一些颜色。HTML 格式的电子邮件无处不在。我相信你一定在电子邮件中看到过图片，或者有复杂布局的电子邮件。这些都是
    HTML 格式的电子邮件。理论上，要使用 `Mailgun` API 发送 HTML 格式的电子邮件，可能只需将 HTML 代码作为参数传递给 `mailgun.send_email`
    方法即可。
- en: 'Please refer to the following sample code to send out an HTML format email
    using Mailgun. We can see that we are just adding the new `html` parameter here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下示例代码，了解如何使用 Mailgun 发送 HTML 格式的电子邮件。我们可以看到，我们只是在这里添加了新的 `html` 参数：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, this way of coupling the HTML code with the Python code is cumbersome.
    If we have a fancy layout, the HTML can be pretty long and that's too much to
    be included in the actual Python code. To address this, we can leverage the `render_template()`
    function in Flask. This is a function that makes use of the Jinja2 template engine.
    With it, we can just place the HTML code in a separate HTML file under a `/templates`
    folder in the application project. We can then pass in the HTML file, also called
    a template file, to this `render_template` function to generate the HTML text.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 HTML 代码与 Python 代码耦合的这种方式比较繁琐。如果我们有一个复杂的布局，HTML 代码可能会相当长，这会使得将其包含在实际的 Python
    代码中变得过于复杂。为了解决这个问题，我们可以利用 Flask 中的 `render_template()` 函数。这是一个利用 Jinja2 模板引擎的函数。通过它，我们只需将
    HTML 代码放置在应用程序项目下的 `/templates` 文件夹中的单独的 HTML 文件中。然后，我们可以将这个 HTML 文件（也称为模板文件）传递给这个
    `render_template` 函数以生成 HTML 文本。
- en: 'From the following sample code, we can see that, with the `render_template`
    function, we can simplify the code a lot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下示例代码中，我们可以看到，使用 `render_template` 函数，我们可以大大简化代码：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then render the HTML with the subject set to `Test email` using the
    following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码将主题设置为`Test email`来渲染HTML：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The sample code here will look for the `templates/sample.html` file under the
    application project folder and render the HTML code for us.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的示例代码将在应用程序项目文件夹下查找`templates/sample.html`文件，并为我们渲染HTML代码。
- en: The function is named `render_template` instead of `render_html` for a reason.
    The `render_template` function does more than just directly outputting the HTML
    code from the file. In fact, we can insert variable in the HTML template file
    and have the `render_template` function render it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被命名为`render_template`而不是`render_html`是有原因的。`render_template`函数不仅仅是从文件中直接输出HTML代码。实际上，我们可以在HTML模板文件中插入变量，并由`render_template`函数渲染它。
- en: 'For example, we can modify `sample.html` like this (the `{{content}}` here
    is a placeholder):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样修改`sample.html`（这里的`{{content}}`是一个占位符）：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then render the HTML with the subject set to `test email` using the
    following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码将主题设置为`test email`来渲染HTML：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next activity, we would like you to send out the activation email in
    HTML format.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们希望你能发送HTML格式的激活邮件。
- en: 'Activity 10: Creating the HTML Format User Account Activation Email'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十：创建HTML格式的用户账户激活邮件
- en: 'We have previously sent out plaintext format emails. In this activity, we will
    create an HTML format email so that it looks more appealing to our users:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经发送过纯文本格式的邮件。在这个活动中，我们将创建一个HTML格式的邮件，使其对我们的用户更具吸引力：
- en: Put the user's email address into the `Mailgun` authorized recipient list.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户的电子邮件地址放入`Mailgun`授权收件人列表中。
- en: Copy an HTML template from the `Mailgun` website.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Mailgun`网站上复制一个HTML模板。
- en: Add in the activation token in the HTML template.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML模板中添加激活令牌。
- en: Use the `render_template` function to render the HTML code and send out the
    activation email using the `Mailgun` API.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`render_template`函数渲染HTML代码，并通过`Mailgun` API发送激活邮件。
- en: Register a new account in Postman and get the account activation email in HTML
    format.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Postman中注册一个新账户，并获取HTML格式的账户激活邮件。
- en: Note
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 317.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第317页找到。
- en: You have now learned how to send out an email in HTML format. You can design
    your own HTML templates from now on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何以HTML格式发送电子邮件。从现在起，你可以设计自己的HTML模板。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the third-party `Mailgun` API to send
    a user account activation email. Later, we can send different emails, such as
    a notification email, using the `MailgunAPI` class. Mailgun not only provides
    the API for sending mail but also provides a backend dashboard for us to track
    the status of the emails we've sent out. It is a very handy service. User account
    activation is an important step to ensure we are onboarding a validated user.
    Though not every platform performs this kind of validation, it reduces the impact
    of spam and bots onboarding our platform. In this chapter, we used the `itsdangerous`
    package to create a unique token to confirm the ownership of the user's email
    address. This package contains timestamps so that we can verify whether the token
    has expired or not.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用第三方`Mailgun` API发送用户账户激活邮件。稍后，我们可以使用`MailgunAPI`类发送不同的邮件，例如通知邮件。Mailgun不仅提供了发送邮件的API，还为我们提供了一个后端仪表板，以便我们跟踪已发送邮件的状态。这是一个非常方便的服务。用户账户激活是确保我们正在欢迎经过验证的用户的重要步骤。尽管不是每个平台都执行这种验证，但它减少了垃圾邮件和机器人对我们平台的负面影响。在本章中，我们使用了`itsdangerous`包来创建一个唯一的令牌，以确认用户电子邮件地址的所有权。这个包包含时间戳，这样我们就可以验证令牌是否已过期。
- en: In the next chapter, we will continue to add more features to our Smilecook
    application. We will work with images in our next chapter. I am sure you will
    learn a lot of practical skills there. Let's continue our journey.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续为我们的Smilecook应用程序添加更多功能。我们将在下一章中处理图片。我相信你将在那里学到很多实用的技能。让我们继续我们的旅程。
