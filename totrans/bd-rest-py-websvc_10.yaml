- en: Chapter 10.  Working with Asynchronous Code, Testing, and Deploying an API with
    Tornado
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用Tornado处理异步代码、测试和部署API
- en: 'In this chapter, we will take advantage of the non-blocking features combined
    with asynchronous operations in Tornado in a new version for the API we built
    in the previous chapter. We will configure, write, and execute unit tests and
    learn a few things related to deployment. We will cover  the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用Tornado的非阻塞特性以及异步操作，为我们在上一章中构建的API创建一个新版本。我们将配置、编写和执行单元测试，并学习一些与部署相关的内容。我们将涵盖以下主题：
- en: Understanding synchronous and asynchronous execution
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解同步和异步执行
- en: Working with asynchronous code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步代码
- en: Refactoring code to take advantage of asynchronous decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新设计代码以利用异步装饰器
- en: Mapping URL patterns to asynchronous and non-blocking request handlers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将URL模式映射到异步和非阻塞请求处理器
- en: Making HTTP requests to the Tornado non-blocking API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Tornado非阻塞API发送HTTP请求
- en: Setting up unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: Writing a first round of unit tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: Running unit tests with `nose2` and checking testing coverage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nose2`运行单元测试并检查测试覆盖率
- en: Improving testing coverage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: Understanding synchronous and asynchronous execution
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解同步和异步执行
- en: In our current version of the API, each HTTP request is blocking, as happened
    with Django and Flask. Thus, whenever the Tornado HTTP server receives an HTTP
    request, it doesn't start working on any other HTTP request in the incoming queue
    until the server sends the response for the first HTTP request it received. The
    methods we coded in the request handlers are working with a synchronous execution
    and they don't take advantage of the non-blocking features included in Tornado
    when combined with asynchronous executions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的API版本中，每个HTTP请求都是阻塞的，就像Django和Flask一样。因此，每当Tornado HTTP服务器收到一个HTTP请求时，它不会开始处理队列中的任何其他HTTP请求，直到服务器为它收到的第一个HTTP请求发送响应。我们在请求处理器中编写的代码是以同步执行方式工作的，并且没有利用Tornado中包含的非阻塞特性与异步执行相结合的优势。
- en: In order to set the brightness level for both the blue and white LEDs, we have
    to make two HTTP PATCH requests. We will make them to understand how our current
    version of the API processes two incoming requests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置蓝色和白色LED的亮度，我们必须发出两个HTTP PATCH请求。我们将发出这些请求来了解我们当前版本的API如何处理两个传入的请求。
- en: 'Open two Cygwin terminals in Windows or two Terminals in macOS or Linux, and
    write the following command in the first one. We will compose and send an HTTP
    request to set the brightness level for the blue `LED` to `255`. Write the line
    in the first window, but don''t press *Enter* yet, as we will try to launch two
    commands at almost the same time in two windows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中打开两个Cygwin终端或在macOS或Linux中打开两个终端，并在第一个终端中输入以下命令。我们将编写并发送一个HTTP请求来设置蓝色`LED`的亮度为`255`。在第一个窗口中写下这一行，但不要按*Enter*键，因为我们将在两个窗口中几乎同时尝试启动两个命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, go to the second window and write the following command. We will compose
    and send an HTTP request to set the brightness level for the white LED to 255\.
    Write the line in the second window, but don''t press *Enter* yet, as we will
    try to launch two commands at almost the same time in two windows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到第二个窗口，并输入以下命令。我们将编写并发送一个HTTP请求来设置白色LED的亮度为255。在第二个窗口中写下这一行，但不要按*Enter*键，因为我们将在两个窗口中几乎同时尝试启动两个命令：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, go to the first window, press ***Enter*** . Then, go to the second window
    and quickly press *Enter*. You will see the following line in the window that
    is running the Tornado HTTP server:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到第一个窗口，按下***Enter***。然后，转到第二个窗口并迅速按下*Enter*。你将在运行Tornado HTTP服务器的窗口中看到以下行：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, you will see the following lines that show the results of executing the
    print statements that describe when the code finished and then started setting
    the brightness level for the LEDs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将看到以下行，它们显示了执行描述代码何时完成以及随后开始设置LED亮度级别的打印语句的结果：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It was necessary to wait for the request that changed the brightness level
    for the blue LED to finish before the server could process the HTTP that changes
    the brightness level for the white LED. The following screenshot shows three windows
    on Windows. The window on the left-hand side is running the Tornado HTTP server
    and displays the messages printed in the methods that process the HTTP requests.
    The window at the upper-right corner is running the `http` command to generate
    the HTTP request that changes the brightness level for the blue LED. The window
    at the lower-right corner is running the `http` command to generate the HTTP request
    that changes the brightness level for the white LED. It is a good idea to use
    a similar configuration to check the output while we compose and send the HTTP
    requests and how the synchronous execution is working on the current version of
    the API:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器能够处理改变白色 LED 亮度级别的 HTTP 请求之前，必须等待改变蓝色 LED 亮度级别的请求完成。以下截图显示了 Windows 上的三个窗口。左侧的窗口正在运行
    Tornado HTTP 服务器，并显示处理 HTTP 请求的方法中打印的消息。右上角的窗口正在运行 `http` 命令以生成改变蓝色 LED 亮度级别的
    HTTP 请求。右下角的窗口正在运行 `http` 命令以生成改变白色 LED 亮度级别的 HTTP 请求。在编写和发送 HTTP 请求以及检查当前 API
    版本的同步执行情况时，使用类似的配置是一个好主意：
- en: '![Understanding synchronous and asynchronous execution](img/image_10_001.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![理解同步和异步执行](img/image_10_001.jpg)'
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that the different methods we coded in the request handler classes
    end up calling `time.sleep` to simulate it takes some time for the operations
    to complete their execution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在请求处理类中编写的不同方法最终都会调用 `time.sleep` 来模拟操作执行所需的时间。
- en: As each operation takes some time and blocks the possibility to process other
    incoming HTTP requests, we will create a new version of this API that will use
    asynchronous execution, and we will understand the advantages of Tornado's non-blocking
    features. This way, it will be possible to change the brightness level for the
    white LED while the other request is to change the brightness level for the blue
    LED. Tornado will be able to start processing requests while the I/O operations
    with the drone take some time to complete.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个操作都需要一些时间并且会阻塞处理其他传入的 HTTP 请求，我们将创建这个 API 的新版本，它将使用异步执行，我们将了解 Tornado 非阻塞特性的优势。这样，在处理其他请求改变蓝色
    LED 亮度级别的同时，就可以改变白色 LED 的亮度级别。Tornado 将能够在 I/O 操作与无人机完成所需时间的同时开始处理请求。
- en: Refactoring code to take advantage of asynchronous decorators
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码重构以利用异步装饰器
- en: It is extremely difficult to read and understand code split into different methods,
    such as the asynchronous code that requires working with callbacks that are executed
    once the asynchronous execution finishes. Luckily, Tornado provides a generator-based
    interface that enables us to write asynchronous code in request handlers in a
    single generator. We can avoid splitting our methods into multiple methods with
    callbacks by using the `tornado.gen` generator-based interface that Tornado provides
    to make it easier to work in an asynchronous environment.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码拆分到不同的方法中，如需要处理异步执行完成后执行的回调的异步代码，是非常难以阅读和理解的。幸运的是，Tornado 提供了一个基于生成器的接口，使我们能够在请求处理程序中编写异步代码，并且使用单个生成器。我们可以通过使用
    Tornado 提供的 `tornado.gen` 基于生成器的接口来避免将方法拆分成多个带有回调的方法，从而使在异步环境中工作变得更加容易。
- en: The recommended way to write asynchronous code in Tornado is to use coroutines.
    Thus, we will refactor our existing code to use the `@tornado.gen.coroutine` decorator
    for asynchronous generators in the required methods that process the different
    HTTP requests in the subclasses of `tornado.web.RequestHandler`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tornado 中编写异步代码的推荐方法是使用协程。因此，我们将重构现有代码，在处理 `tornado.web.RequestHandler` 子类中不同
    HTTP 请求的必要方法中使用 `@tornado.gen.coroutine` 装饰器来处理异步生成器。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Instead of working with a chain of callbacks, coroutines use the Python `yield`
    keyword to suspend and resume execution. By using coroutines, our code is going
    to be as simple to understand and maintain as if we were writing synchronous code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用回调链工作不同，协程使用 Python 的 `yield` 关键字来暂停和恢复执行。通过使用协程，我们的代码将像编写同步代码一样简单易懂和维护。
- en: We will use an instance of the `concurrent.futures.ThreadPoolExecutor` class
    that provides us with a high-level interface for asynchronously executing callables.
    The asynchronous execution will be performed with threads. We will also use the
    `@tornado.concurrent.run_on_executor` decorator to run a synchronous method asynchronously
    on an executor. In this case, the methods provided by the different components
    of our drone to get and set data have a synchronous execution. We want them to
    run with an asynchronous execution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `concurrent.futures.ThreadPoolExecutor` 类的实例，它为我们提供了一个异步执行可调用对象的高级接口。异步执行将通过线程执行。我们还将使用
    `@tornado.concurrent.run_on_executor` 装饰器在执行器上异步运行同步方法。在这种情况下，我们无人机不同组件提供用于获取和设置数据的方法具有同步执行。我们希望它们以异步执行运行。
- en: 'Create a new `async_api.py` file. The following lines show all the necessary
    imports for the classes that we will create and the code that creates an instance
    of the `concurrent.futures.ThreadPoolExecutor` class named `thread_pool`. We will
    use this instance in the different methods that we will refactor to make asynchronous
    calls. The code file for the sample is included in the `restful_python_chapter_10_01`
    folder:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `async_api.py` 文件。以下行显示了我们将创建的类所需的全部必要导入以及创建名为 `thread_pool` 的 `concurrent.futures.ThreadPoolExecutor`
    类实例的代码。我们将使用此实例在将重构以进行异步调用的不同方法中。示例的代码文件包含在 `restful_python_chapter_10_01` 文件夹中：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will create an `AsyncHexacopterHandler` class that we will use to handle
    requests for the hexacopter resource with an asynchronous execution. The lines
    that are new or changed compared with the synchronous version of this handler
    named `HexacopterHandler` are highlighted. Open the previously created `async_pi.py`
    file and add the following lines. The code file for the sample is included in
    the `restful_python_chapter_10_01` folder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `AsyncHexacopterHandler` 类，我们将使用它以异步执行来处理对六旋翼机资源的请求。与名为 `HexacopterHandler`
    的同步版本相比，以下行是新的或已更改的。打开先前创建的 `async_pi.py` 文件，并添加以下行。示例的代码文件包含在 `restful_python_chapter_10_01`
    文件夹中：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `AsyncHexacopterHandler` class declares a `_thread_pool` class attribute
    that saves a reference to the previously created `concurrent.futures.ThreadPoolExecutor`
    instance. The class declares two methods with the `@run_on_executor(executor="_thread_pool")`
    decorator that makes the synchronous method run asynchronously with the `concurrent.futures.ThreadPoolExecutor`
    instance whose reference is saved in the `_thread_pool` class attribute. The following
    are the two methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncHexacopterHandler` 类声明了一个 `_thread_pool` 类属性，该属性保存了对先前创建的 `concurrent.futures.ThreadPoolExecutor`
    实例的引用。该类声明了两个带有 `@run_on_executor(executor="_thread_pool")` 装饰器的方法，这使得同步方法可以异步地使用保存在
    `_thread_pool` 类属性中的 `concurrent.futures.ThreadPoolExecutor` 实例运行。以下是有两个方法：'
- en: '`retrieve_hexacopter_status`: This method returns the results of calling the
    `drone.hexacopter.get_hexacopter_status` method.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retrieve_hexacopter_status`：此方法返回调用 `drone.hexacopter.get_hexacopter_status`
    方法的结果。'
- en: '`set_hexacopter_motor_speed`: This method receives the `motor_speed` argument
    and returns the results of calling the `drone.hexacopter.set_motor_speed` method
    with the received `motor_speed` as an argument.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_hexacopter_motor_speed`：此方法接收 `motor_speed` 参数，并返回调用 `drone.hexacopter.set_motor_speed`
    方法的结果，其中接收到的 `motor_speed` 作为参数。'
- en: We added the `@gen.coroutine` decorator to both the `get` and `patch` methods.
    We added a call to `self.finish` whenever we wanted to finish the HTTP request.
    It is our responsibility to call this method to finish the response and end the
    HTTP request when we use the `@gen.coroutine` decorator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `get` 和 `patch` 方法上都添加了 `@gen.coroutine` 装饰器。每当我们需要完成 HTTP 请求时，我们都添加了对 `self.finish`
    的调用。当我们使用 `@gen.coroutine` 装饰器时，我们有责任调用此方法来完成响应并结束 HTTP 请求。
- en: 'The `get` method uses the following line to retrieve the hexacopter status
    with a non-blocking and asynchronous execution:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法使用以下行以非阻塞和异步执行来检索六旋翼机的状态：'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code uses the `yield` keyword to retrieve `HexacopterStatus` from the `Future`
    returned by `self.retrieve_hexacopter_status` that runs with an asynchronous execution.
    A `Future` encapsulates the asynchronous execution of a callable. In this case,
    `Future` encapsulates the asynchronous execution of the `self.retrieve_hexacopter_status`
    method. The next lines didn't require changes, and we only had to add a call to
    `self.finish` as the last line after we write the response.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字从 `self.retrieve_hexacopter_status` 返回的 `Future` 中检索 `HexacopterStatus`，该
    `Future` 是以异步方式运行的。`Future` 封装了可调用的异步执行。在这种情况下，`Future` 封装了 `self.retrieve_hexacopter_status`
    方法的异步执行。接下来的几行不需要更改，我们只需在写入响应后作为最后一行添加对 `self.finish` 的调用。
- en: 'The `get` method uses the following line to retrieve the hexacopter status
    with a non-blocking and asynchronous execution:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法使用以下行以非阻塞和异步方式检索六旋翼机的状态：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code uses the `yield` keyword to retrieve the `HexacopterStatus` from the
    `Future` returned by the `self.retrieve_hexacopter_status` that runs with an asynchronous
    execution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字从 `self.retrieve_hexacopter_status` 返回的 `Future` 中检索 `HexacopterStatus`，该
    `Future` 是以异步方式运行的。
- en: 'The `patch` method uses the following line to set the hexacopter''s motor speed
    with a non-blocking and asynchronous execution:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch` 方法使用以下行以非阻塞和异步方式设置六旋翼机的电机速度：'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code uses the `yield` keyword to retrieve the `HexacopterStatus` from the
    `Future` returned by the `self.set_hexacopter_motor_speed` that runs with an asynchronous
    execution. The next lines didn't require changes, and we only had to add a call
    to `self.finish` as the last line after we write the response.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字从 `self.set_hexacopter_motor_speed` 返回的 `Future` 中检索 `HexacopterStatus`，该
    `Future` 是以异步方式运行的。接下来的几行不需要更改，我们只需在写入响应后作为最后一行添加对 `self.finish` 的调用。
- en: 'Now, we will create an `AsyncLedHandler` class that we will use to represent
    the LED resources and process requests with an asynchronous execution. The lines
    that are new or changed compared with the synchronous version of this handler
    named `LedHandler` are highlighted. Open the previously created `async_pi.py`
    file and add the following lines. The code file for the sample is included in
    the `restful_python_chapter_10_01` folder:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `AsyncLedHandler` 类，我们将使用它来表示 LED 资源并使用异步执行处理请求。与名为 `LedHandler`
    的此处理器的同步版本相比，以下行是新的或已更改的。打开之前创建的 `async_pi.py` 文件，并添加以下行。示例的代码文件包含在 `restful_python_chapter_10_01`
    文件夹中：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `AsyncLedHandler` class declares a `_thread_pool` class attribute that
    saves a reference to the previously created `concurrent.futures.ThreadPoolExecutor`
    instance. The class declares two methods with the `@run_on_executor(executor="_thread_pool")`
    decorator that makes the synchronous method run asynchronously with the `concurrent.futures.ThreadPoolExecutor`
    instance whose reference is saved in the `_thread_pool` class attribute. The following
    are the two methods:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncLedHandler` 类声明了一个 `_thread_pool` 类属性，该属性保存了对之前创建的 `concurrent.futures.ThreadPoolExecutor`
    实例的引用。该类声明了两个带有 `@run_on_executor(executor="_thread_pool")` 装饰器的方法，这使得同步方法可以与保存在
    `_thread_pool` 类属性中的 `concurrent.futures.ThreadPoolExecutor` 实例异步运行。以下是有两个方法的示例：'
- en: '`retrieve_led_brightness_level`: This method receives a `LightEmittingDiode`
    instance in the `led` argument and returns the results of calling the `led.get_brightness_level`
    method.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retrieve_led_brightness_level`: 此方法接收一个在 `led` 参数中的 `LightEmittingDiode` 实例，并返回调用
    `led.get_brightness_level` 方法的结果。'
- en: '`set_led_brightness_level`: This method receives a `LightEmittingDiode` instance
    in the `led` argument and the `brightness_level` argument. The code returns the
    results of calling the `led.set_brightness_level` method with the received `brightness_level`
    as an argument.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_led_brightness_level`: 此方法接收一个在 `led` 参数中的 `LightEmittingDiode` 实例和 `brightness_level`
    参数。代码使用接收到的 `brightness_level` 作为参数调用 `led.set_brightness_level` 方法并返回结果。'
- en: We added the `@gen.coroutine` decorator to both the `get` and `patch` methods.
    In addition, we added a call to `self.finish` whenever we wanted to finish the
    HTTP request.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `get` 和 `patch` 方法上都添加了 `@gen.coroutine` 装饰器。此外，每当我们想要完成 HTTP 请求时，我们都添加了对
    `self.finish` 的调用。
- en: 'The `get` method uses the following line to retrieve the LED''s brightness
    level with a non-blocking and asynchronous execution:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法使用以下行以非阻塞和异步方式检索 LED 的亮度级别：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The code uses the `yield` keyword to retrieve the `int` from `Future` returned
    by `self.retrieve_led_brightness_level` that runs with an asynchronous execution.
    The next lines didn't require changes, and we only had to add a call to `self.finish`
    as the last line after we write the response.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字从 `self.retrieve_led_brightness_level` 返回的 `Future` 中检索 `int`，该
    `Future` 以异步执行方式运行。接下来的行不需要更改，我们只需在写入响应后作为最后一行添加对 `self.finish` 的调用。
- en: 'The `patch` method uses the following line to retrieve the hexacopter status
    with a non-blocking and asynchronous execution:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch` 方法使用以下行以非阻塞和异步执行方式检索六旋翼机的状态：'
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code uses the `yield` keyword to retrieve `HexacopterStatus` from `Future`
    returned by `self.retrieve_hexacopter_status` that runs with an asynchronous execution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字从 `self.retrieve_hexacopter_status` 返回的 `Future` 中检索 `HexacopterStatus`，该
    `Future` 以异步执行方式运行。
- en: 'The `patch` method uses the following line to set the LED''s brightness level
    with a non-blocking and asynchronous execution:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch` 方法使用以下行以非阻塞和异步执行来设置 LED 的亮度级别：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code uses the `yield` keyword to call `self.set_led_brightness_level` with
    an asynchronous execution. The next lines didn't require changes, and we only
    had to add a call to `self.finish` as the last line after we write the response.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字以异步执行方式调用 `self.set_led_brightness_level`。接下来的行不需要更改，我们只需在写入响应后作为最后一行添加对
    `self.finish` 的调用。
- en: Now, we will create an `AsyncAltimeterHandler` class that we will use to represent
    the altimeter resource and process the `get` request with an asynchronous execution.
    The lines that are new or changed compared with the synchronous version of this
    handler named `AltimeterHandler`, are highlighted. Open the previously created
    `async_pi.py` file and add the following lines. The code file for the sample is
    included in the `restful_python_chapter_10_01` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `AsyncAltimeterHandler` 类，我们将使用该类来表示高度计资源，并以异步执行方式处理 `get` 请求。与名为
    `AltimeterHandler` 的同步版本相比，新或更改的行被突出显示。打开先前创建的 `async_pi.py` 文件，并添加以下行。示例的代码文件包含在
    `restful_python_chapter_10_01` 文件夹中。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `AsyncAltimeterHandler` class declares a `_thread_pool` class attribute
    that saves a reference to the previously created `concurrent.futures.ThreadPoolExecutor`
    instance. The class declares the `retrieve_altitude` method with the `@run_on_executor(executor="_thread_pool")`
    decorator that makes the synchronous method run asynchronously with the `concurrent.futures.ThreadPoolExecutor`
    instance whose reference is saved in the `_thread_pool` class attribute. The `retrieve_altitude`
    method returns the results of calling the `drone.altimeter.get_altitude` method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncAltimeterHandler` 类声明了一个 `_thread_pool` 类属性，该属性保存了对先前创建的 `concurrent.futures.ThreadPoolExecutor`
    实例的引用。该类使用 `@run_on_executor(executor="_thread_pool")` 装饰器声明了 `retrieve_altitude`
    方法，该装饰器使得同步方法可以异步运行，其引用保存在 `_thread_pool` 类属性中。`retrieve_altitude` 方法返回调用 `drone.altimeter.get_altitude`
    方法的结果。'
- en: We added the `@gen.coroutine` decorator to the `get` method. In addition, we
    added a call to `self.finish` whenever we wanted to finish the HTTP request.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `get` 方法中添加了 `@gen.coroutine` 装饰器。此外，每当我们要完成 HTTP 请求时，我们都添加了对 `self.finish`
    的调用。
- en: 'The `get` method uses the following line to retrieve the altimeter''s altitude
    value with a non-blocking and asynchronous execution:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法使用以下行以非阻塞和异步执行方式检索高度计的 altitude 值：'
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code uses the `yield` keyword to retrieve the `int` from `Future` returned
    by `self.retrieve_altitude` that runs with an asynchronous execution. The next
    lines didn't require changes, and we only had to add a call to `self.finish` as
    the last line after we write the response.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `yield` 关键字从 `self.retrieve_altitude` 返回的 `Future` 中检索 `int`，该 `Future`
    以异步执行方式运行。接下来的行不需要更改，我们只需在写入响应后作为最后一行添加对 `self.finish` 的调用。
- en: Mapping URL patterns to asynchronous request handlers
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 URL 模式映射到异步请求处理器
- en: 'We must map URL patterns to our previously coded subclasses of `tornado.web.RequestHandler`
    that provide us asynchronous methods for our request handlers. The following lines
    create the main entry point for the application, initialize it with the URL patterns
    for the API, and start listening for requests. Open the previously created `async_api.py`
    file and add the following lines. The code file for the sample is included in
    the `restful_python_chapter_10_01` folder:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将 URL 模式映射到我们之前编写的 `tornado.web.RequestHandler` 的子类，这些子类为我们提供了请求处理器的异步方法。以下行创建了应用程序的主入口点，用
    API 的 URL 模式初始化它，并开始监听请求。打开之前创建的 `async_api.py` 文件，并添加以下行。示例代码文件位于 `restful_python_chapter_10_01`
    文件夹中：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code creates an instance of `tornado.web.Application` named `application`
    with the collection of request handlers that make up the Web application. We just
    changed the name of the handlers with the new names that have the `Async` prefix.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为 `application` 的 `tornado.web.Application` 实例，其中包含构成 Web 应用的请求处理器集合。我们只是将处理器的名称更改为带有
    `Async` 前缀的新名称。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As with any other Web framework, you should never enable debugging in a production
    environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他 Web 框架一样，你永远不应该在生产环境中启用调试。
- en: Making HTTP requests to the Tornado non-blocking API
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Tornado 非阻塞 API 发送 HTTP 请求
- en: 'Now, we can run the `async_api.py` script that launches Tornados''s development
    server to compose and send HTTP requests to our new version of the Web API that
    uses the non-blocking features of Tornado combined with asynchronous execution.
    Execute the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `async_api.py` 脚本，启动 Tornado 的开发服务器，以编写和发送 HTTP 请求到我们新版本的 Web API，该
    API 结合了 Tornado 的非阻塞特性和异步执行。执行以下命令：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following lines show the output after we execute the previous command.
    The Tornado HTTP development server is listening at port `8888`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行上一条命令后的输出。Tornado HTTP 开发服务器正在 `8888` 端口上监听：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With the previous command, we will start the Tornado HTTP server and it will
    listen on every interface on port `8888`. Thus, if we want to make HTTP requests
    to our API from other computers or devices connected to our LAN, we don't need
    any additional configurations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的命令，我们将启动 Tornado HTTP 服务器，它将在 `8888` 端口上的每个接口上监听。因此，如果我们想从连接到我们局域网的其它计算机或设备向我们的
    API 发送 HTTP 请求，我们不需要任何额外的配置。
- en: In our new version of the API, each HTTP request is non-blocking. Thus, whenever
    the Tornado HTTP server receives an HTTP request and makes an asynchronous call,
    it is able to start working on any other HTTP request in the incoming queue before
    the server sends the response for the first HTTP request it received. The methods
    we coded in the request handlers are working with an asynchronous execution and
    they take advantage of the non-blocking features included in Tornado, combined
    with asynchronous executions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 API 的新版本中，每个 HTTP 请求都是非阻塞的。因此，每当 Tornado HTTP 服务器收到一个 HTTP 请求并执行异步调用时，它能够在服务器发送第一个接收到的
    HTTP 请求的响应之前，开始处理队列中的任何其他 HTTP 请求。我们在请求处理器中编写的这些方法正在使用异步执行，并利用了 Tornado 中包含的非阻塞特性，结合了异步执行。
- en: In order to set the brightness level for both the blue and white LEDs, we have
    to make two HTTP `PATCH` requests. We will make them to understand how our new
    version of the API processes two incoming requests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置蓝色和白色 LED 的亮度级别，我们必须发送两个 HTTP `PATCH` 请求。我们将通过发送这两个请求来了解我们 API 的新版本如何处理两个传入的请求。
- en: 'Open two Cygwin terminals in Windows, or two Terminals in macOS or Linux, and
    write the following command in the first one. We will compose and send an HTTP
    request to set the brightness level for the blue LED to `255`. Write the line
    in the first window but don''t press *Enter* yet, as we will try to launch two
    commands at almost the same time in two windows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中打开两个 Cygwin 终端，或在 macOS 或 Linux 中打开两个终端，并在第一个终端中写下以下命令。我们将编写并发送一个
    HTTP 请求来设置蓝色 LED 的亮度级别为 `255`。在第一个窗口中写下这一行，但不要按 *Enter*，因为我们将在两个窗口中几乎同时尝试启动两个命令：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, go to the second window and write the following command. We will compose
    and send an HTTP request to set the brightness level for the white LED to `255`.
    Write the line in the second window but don''t press *Enter* yet, as we will try
    to launch two commands at almost the same time in two windows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到第二个窗口，并写下以下命令。我们将编写并发送一个 HTTP 请求来设置白色 LED 的亮度级别为 `255`。在第二个窗口中写下这一行，但不要按
    *Enter*，因为我们将在两个窗口中几乎同时尝试启动两个命令：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, go to the first window, press ***Enter*** . Then, go to the second window
    and quickly press *Enter*. You will see the following lines in the window that
    is running the Tornado HTTP server:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到第一个窗口，按***Enter***。然后，转到第二个窗口并快速按*Enter*。您将在运行Tornado HTTP服务器的窗口中看到以下几行：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, you will see the following lines that show the results of executing the
    print statements that describe when the code finished setting the brightness level
    for the LEDs:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将看到以下几行，它们显示了执行描述代码完成设置LED亮度级别的print语句的结果：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The server could start processing the request that changes the brightness level
    for the white LED before the request that changes the brightness level of the
    blue LED finishes its execution. The following screenshot shows three windows
    on Windows. The window on the left-hand side is running the Tornado HTTP server
    and displays the messages printed in the methods that process the HTTP requests.
    The window on the upper-right corner is running the `http` command to generate
    the HTTP request that changes the brightness level for the blue LED. The window
    at the lower-right corner is running the `http` command to generate the HTTP request
    that changes the brightness level for the white LED. It is a good idea to use
    a similar configuration to check the output while we compose and send the HTTP
    requests and check how the asynchronous execution is working on the new version
    of the API:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以在更改白色LED亮度级别的请求完成其执行之前开始处理更改蓝色LED亮度级别的请求。以下截图显示了Windows上的三个窗口。左侧的窗口正在运行Tornado
    HTTP服务器并显示处理HTTP请求的方法中打印的消息。右上角的窗口正在运行`http`命令以生成更改蓝色LED亮度级别的HTTP请求。右下角的窗口正在运行`http`命令以生成更改白色LED亮度级别的HTTP请求。在我们编写和发送HTTP请求以及检查新版本的API上的异步执行如何工作时，使用类似的配置来检查输出是一个好主意：
- en: '![Making HTTP requests to the Tornado non-blocking API](img/image_10_002.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![向Tornado非阻塞API发送HTTP请求](img/image_10_002.jpg)'
- en: Each operation takes some time but doesn't block the possibility to process
    other incoming HTTP requests thanks to the changes we made to the API to take
    advantage of the asynchronous execution. This way, it is possible to change the
    brightness level for the white LED while the other request is to change the brightness
    level for the blue LED. Tornado is able to start processing requests while the
    I/O operations with the drone take some time to complete.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作都需要一些时间，但由于我们对API所做的更改以利用异步执行，因此不会阻塞处理其他传入的HTTP请求的可能性。这样，在处理其他请求更改蓝色LED亮度级别的同时，可以更改白色LED的亮度级别。Tornado能够在与无人机进行I/O操作需要一些时间来完成时开始处理请求。
- en: Setting up unit tests
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: We will use `nose2` to make it easier to discover and run unit tests. We will
    measure test coverage, and therefore, we will install the necessary package to
    allow us to run coverage with `nose2`. First, we will install the `nose2` and
    `cov-core` packages in our virtual environment. The `cov-core` package will allow
    us to measure test coverage with `nose2`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nose2`来简化单元测试的发现和运行。我们将测量测试覆盖率，因此我们将安装必要的包，以便我们可以使用`nose2`运行覆盖率。首先，我们将在我们的虚拟环境中安装`nose2`和`cov-core`包。`cov-core`包将允许我们使用`nose2`测量测试覆盖率。
- en: 'Make sure you quit the Tornado''s HTTP server. Remember that you just need
    to press ***Ctrl*** + ***C*** in the Terminal or command-prompt window in which
    it is running. We just need to run the following command to install the `nose2`
    package that will also install the `six` dependency:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出Tornado的HTTP服务器。请记住，您只需在运行它的终端或命令提示符窗口中按***Ctrl*** + ***C***即可。我们只需运行以下命令来安装`nose2`包，该包还将安装`six`依赖项：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last lines for the output will indicate that the `nose2` package has been
    successfully installed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`nose2`包已成功安装：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We just need to run the following command to install the `cov-core` package
    that will also install the `coverage` dependency:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需运行以下命令来安装`cov-core`包，该包还将安装`coverage`依赖项：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last lines for the output will indicate that the `django-nose` package
    has been successfully installed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`django-nose`包已成功安装：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Open the previously created `async_api.py` file and remove the lines that create
    the `web.Application` instance named application and the `__main__` method. After
    you remove these lines, add the next lines. The code file for the sample is included
    in the `restful_python_chapter_10_02` folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打开之前创建的 `async_api.py` 文件，删除创建名为 `application` 的 `web.Application` 实例和 `__main__`
    方法的行。删除这些行后，添加以下行。示例代码文件包含在 `restful_python_chapter_10_02` 文件夹中：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code declares an `Application` class, specifically, a subclass of `tornado.web.Application`
    that overrides the inherited constructor, that is, the `__init__` method. The
    constructor declares the `handlers` list that maps URL patterns to asynchronous
    request handlers and then calls the inherited constructor with the list as one
    of its arguments. We create the class to make it possible for the tests to use
    this class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了一个 `Application` 类，具体来说，是 `tornado.web.Application` 的子类，它重写了继承的构造函数，即 `__init__`
    方法。构造函数声明了 `handlers` 列表，该列表将 URL 模式映射到异步请求处理器，然后使用列表作为其参数之一调用继承的构造函数。我们创建这个类是为了使测试能够使用这个类。
- en: Then, the main method creates an instance of the Application class, registers
    a periodic callback that will be executed every `500` milliseconds by the `IOLoop`
    to make it possible to use ***Ctrl*** + ***C*** to stop the HTTP server, and finally
    calls the `start` method. The `async_api.py` script is going to continue working
    in the same way. The main difference is that we can reuse the `Application` class
    in our tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主方法创建 `Application` 类的一个实例，注册一个周期性回调，该回调将由 `IOLoop` 每 `500` 毫秒执行，以便可以使用 ***Ctrl***
    + ***C*** 停止 HTTP 服务器，并最终调用 `start` 方法。`async_api.py` 脚本将继续以相同的方式工作。主要区别在于我们可以在测试中重用
    `Application` 类。
- en: 'Finally, create a new text file named `.coveragerc` within the virtual environment''s
    root folder with the following content. The code file for the sample is included
    in the `restful_python_chapter_10_02` folder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在虚拟环境根文件夹中创建一个名为 `.coveragerc` 的新文本文件，内容如下。示例代码文件包含在 `restful_python_chapter_10_02`
    文件夹中：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This way, the `coverage` utility will only consider the code in the `async_api.py`
    and `drone.py` files when providing us with the test coverage report. We will
    have a more accurate test coverage report with this settings file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`coverage` 工具在提供测试覆盖率报告时，只会考虑 `async_api.py` 和 `drone.py` 文件中的代码。使用这个设置文件，我们将得到一个更准确的测试覆盖率报告。
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this case, we won't be using configuration files for each environment. However,
    in more complex applications, you will definitely want to use configuration files.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不会为每个环境使用配置文件。然而，在更复杂的应用程序中，你肯定会想使用配置文件。
- en: Writing a first round of unit tests
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: 'Now, we will write a first round of unit tests. Specifically, we will write
    unit tests related to the LED resources. Create a new `tests` subfolder within
    the virtual environment''s root folder. Then, create a new `test_hexacopter.py`
    file within the new `tests` subfolder. Add the following lines that declare many
    `import` statements and the `TextHexacopter` class. The code file for the sample
    is included in the `restful_python_chapter_10_02` folder:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写第一轮单元测试。具体来说，我们将编写与 LED 资源相关的单元测试。在虚拟环境根文件夹中创建一个新的 `tests` 子文件夹。然后，在新的
    `tests` 子文件夹中创建一个新的 `test_hexacopter.py` 文件。添加以下行，声明许多 `import` 语句和 `TextHexacopter`
    类。示例代码文件包含在 `restful_python_chapter_10_02` 文件夹中：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `TestHexacopter` class is a subclass of `tornado.testing.AsyncHTTPTestCase`,
    that is, a test case that starts up a Tornado HTTP Server. The class overrides
    the `get_app` method that returns the `tornado.web.Application` instance that
    we want to test. In this case, we return an instance of the `Application` class
    declared in the `async_api` module, with the `debug` argument set to `False`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestHexacopter` 类是 `tornado.testing.AsyncHTTPTestCase` 的子类，即一个启动 Tornado HTTP
    服务器的测试用例。该类重写了 `get_app` 方法，该方法返回我们想要测试的 `tornado.web.Application` 实例。在这种情况下，我们返回
    `async_api` 模块中声明的 `Application` 类的一个实例，将 `debug` 参数设置为 `False`。'
- en: The `test_set_and_get_led_brightness_level` method tests whether we can set
    and get the brightness levels for both the white and blue LED. The code composes
    and sends two HTTP `PATCH` methods to set new brightness level values for the
    LEDs whose IDs are equal to `1` and `2`. The code sets a different brightness
    level for each LED.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_set_and_get_led_brightness_level` 方法测试我们是否可以设置和获取白色和蓝色 LED 的亮度级别。代码组合并发送了两个
    HTTP `PATCH` 方法，为 ID 等于 `1` 和 `2` 的 LED 设置新的亮度级别值。代码为每个 LED 设置不同的亮度级别。'
- en: 'The code calls the self.fetch method to compose and send the HTTP `PATCH` request
    and calls `json.dumps` with the dictionary to be sent to the body as an argument.
    Then, the code uses `self.fetch` again to compose and send two HTTP `GET` methods
    to retrieve the brightness level values for the LEDs whose brightness values have
    been modified. The code uses `tornado.escape.json_decode` to convert the bytes
    in the response body to a Python dictionary. The method uses `assertEqual` and
    `assertTrue` to check for the following expected results:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用 self.fetch 方法来组合并发送 HTTP `PATCH` 请求，并将要发送到主体的字典作为参数调用 `json.dumps`。然后，代码再次使用
    `self.fetch` 来组合并发送两个 HTTP `GET` 方法，以检索亮度值已更改的 LED 的亮度级别值。代码使用 `tornado.escape.json_decode`
    将响应主体的字节转换为 Python 字典。该方法使用 `assertEqual` 和 `assertTrue` 来检查以下预期结果：
- en: The `status_code` for the two HTTP `PATCH` responses is HTTP 200 OK (`status.HTTP_200_OK`)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 HTTP `PATCH` 响应的 `status_code` 是 HTTP 200 OK (`status.HTTP_200_OK`)
- en: The `status_code` for the two HTTP `GET` responses is HTTP 200 OK (`status.HTTP_200_OK`)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 HTTP `GET` 响应的 `status_code` 是 HTTP 200 OK (`status.HTTP_200_OK`)
- en: The response body for the two HTTP `GET` responses include a key named `brigthness_level`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个 HTTP `GET` 响应的响应体包含一个名为 `brigthness_level` 的键
- en: The value for the `brightness_level` key in the HTTP `GET` responses are equal
    to the brightness level set to each LED
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP `GET` 响应中 `brightness_level` 键的值等于每个 LED 设置的亮度级别
- en: Running unit tests with nose2 and checking testing coverage
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nose2 运行单元测试并检查测试覆盖率
- en: Now, run the following command to create all the necessary tables in our test
    database and use the nose2 test running to execute all the tests we created. The
    test runner will execute all the methods for our `TestHexacopter` class that start
    with the `test_` prefix and will display the results. In this case, we just have
    one method that matches the criteria, but we will add more later.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以在我们的测试数据库中创建所有必要的表，并使用 nose2 测试运行器执行我们创建的所有测试。测试运行器将执行我们 `TestHexacopter`
    类中以 `test_` 前缀开头的方法，并将显示结果。在这种情况下，我们只有一个符合标准的方法，但稍后我们会添加更多。
- en: 'Run the following command within the same virtual environment we have been
    using. We will use the `-v` option to instruct nose2 to print test case names
    and statuses. The `--with-coverage` option turns on test coverage reporting generation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一直在使用的同一虚拟环境中运行以下命令。我们将使用 `-v` 选项指示 nose2 打印测试用例名称和状态。`--with-coverage` 选项打开测试覆盖率报告生成：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following lines show the sample output. Notice that the numbers shown in
    the report might have small differences if our code includes additional lines
    or comments:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出。请注意，如果我们的代码包含额外的行或注释，报告中显示的数字可能会有所不同：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: By default, `nose2` looks for modules whose names start with the `test` prefix.
    In this case, the only module that matches the criteria is the `test_hexacopter`
    module. In the modules that match the criteria, `nose2` loads tests from all the
    subclasses of `unittest.TestCase` and the functions whose names start with the
    `test` prefix. The `tornado.testing.AsyncHTTPTestCase` includes `unittest.TestCase`
    as one of its superclasses in the class hierarchy.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`nose2` 会查找以 `test` 前缀开头的模块。在这种情况下，唯一符合标准的模块是 `test_hexacopter` 模块。在符合标准的模块中，`nose2`
    会从 `unittest.TestCase` 的所有子类以及以 `test` 前缀开头的方法中加载测试。`tornado.testing.AsyncHTTPTestCase`
    在其类层次结构中将 `unittest.TestCase` 作为其超类之一。
- en: The output provided details indicating that the test runner discovered and executed
    one test and it passed. The output displays the method name and the class name
    for each method in the `TestHexacopter` class that started with the `test_` prefix
    and represented a test to be executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的输出详细说明了测试运行器发现并执行了一个测试，并且它通过了。输出显示了 `TestHexacopter` 类中以 `test_` 前缀开头的方法及其类名，这些方法代表要执行的测试。
- en: We definitely have a very low coverage for `async_api.py` and `drone.py` based
    on the measurements shown in the report. In fact, we just wrote one test related
    to LEDs, and therefore, it makes sense that the coverage has to be improved. We
    didn't create tests related to other hexacopter resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据报告中显示的测量结果，`async_api.py` 和 `drone.py` 的覆盖率确实非常低。实际上，我们只编写了一个与 LED 相关的测试，因此提高覆盖率是有意义的。我们没有创建与其他六旋翼机资源相关的测试。
- en: 'We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有 `-m` 命令行选项的 `coverage` 命令来显示新 `Missing` 列中缺失语句的行号：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The command will use the information from the last execution and will display
    the missing statements. The next lines show a sample output that corresponds to
    the previous execution of the unit tests. Notice that the numbers shown in the
    report might have small differences if our code includes additional lines or comments:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将使用上次执行的信息，并显示遗漏的语句。以下几行显示了与之前单元测试执行相对应的示例输出。请注意，如果我们的代码包含额外的行或注释，报告中显示的数字可能会有所不同：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以获取详细说明遗漏行的注释HTML列表：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    Web browser. The following screenshot shows an example report that coverage generated
    in HTML format:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的Web浏览器打开在`htmlcov`文件夹中生成的`index.html` HTML文件。以下截图显示了一个示例报告，该报告以HTML格式生成覆盖率：
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_10_003.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2运行单元测试并检查测试覆盖率](img/image_10_003.jpg)'
- en: Click or tap on `drony.py` and the Web browser will render a Web page that displays
    the statements that were run, the missing ones, and the excluded ones, with different
    colors. We can click or tap on the **run**, **missing**, and **excluded** buttons
    to show or hide the background color that represents the status for each line
    of code. By default, the missing lines of code will be displayed with a pink background.
    Thus, we must write unit tests that target these lines of code to improve our
    test coverage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触`drony.py`，Web浏览器将渲染一个显示已运行语句、遗漏语句和排除语句的Web页面，这些语句用不同的颜色表示。我们可以点击或轻触**运行**、**遗漏**和**排除**按钮来显示或隐藏代表每行代码状态的背景颜色。默认情况下，遗漏的代码行将以粉红色背景显示。因此，我们必须编写针对这些代码行的单元测试来提高我们的测试覆盖率。
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_10_004.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![使用nose2运行单元测试并检查测试覆盖率](img/image_10_004.jpg)'
- en: Improving testing coverage
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: 'Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to the hexacopter motor and the altimeter. Open
    the existing `test_hexacopter.py` file and insert the following lines after the
    last line. The code file for the sample is included in the `restful_python_chapter_10_03`
    folder:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写额外的单元测试来提高测试覆盖率。具体来说，我们将编写与六旋翼电机和高度计相关的单元测试。打开现有的`test_hexacopter.py`文件，在最后一行之后插入以下行。示例的代码文件包含在`restful_python_chapter_10_03`文件夹中：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The previous code added the following two methods to the `TestHexacopter` class
    whose names start with the `test_` prefix:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码向`TestHexacopter`类添加了以下两个以`test_`前缀开头的方法：
- en: '`test_set_and_get_hexacopter_motor_speed`: This tests whether we can set and
    get the hexacopter''s motor speed.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_and_get_hexacopter_motor_speed`：这个测试检查我们是否可以设置和获取六旋翼的电机速度。'
- en: '`test_get_altimeter_altitude`: This tests whether we can retrieve the altitude
    value from the altimeter.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_altimeter_altitude`：这个测试检查我们是否可以从高度计检索高度值。'
- en: We just coded a few tests related to the hexacopter and the altimeter in order
    to improve test coverage and notice the impact on the test coverage report.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是编写了一些与六旋翼和高度计相关的测试，以提高测试覆盖率并注意对测试覆盖率报告的影响。
- en: 'Now, run the following command within the same virtual environment we have
    been using:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个虚拟环境中运行以下命令：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following lines show the sample output. Notice that the numbers shown in
    the report might have small differences if our code includes additional lines
    or comments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了示例输出。请注意，如果我们的代码包含额外的行或注释，报告中显示的数字可能会有所不同：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The output provided details indicating that the test runner executed `3` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_api.py`
    module from `47%` in the previous run to `71%`. In addition, the percentage of
    the `drone.py` module increased from `68%` to `93%` because we wrote tests that
    worked with all the components for the drone. The new additional tests we wrote
    executed additional code in the two modules, and therefore, there is an impact
    in the coverage report.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，表明测试运行器执行了`3`个测试，并且所有测试都通过了。由`coverage`包提供的测试代码覆盖率测量报告将`async_api.py`模块的`Cover`百分比从上次运行的`47%`提高到`71%`。此外，`drone.py`模块的百分比从`68%`提高到`93%`，因为我们编写了与无人机所有组件一起工作的测试。我们编写的新附加测试在这两个模块中执行了额外的代码，因此覆盖率报告中有影响。
- en: 'If we take a look at the missing statements, we will notice that we aren''t
    testing scenarios where validations fail. Now, we will write additional unit tests
    to improve the testing coverage further. Specifically, we will write unit tests
    to make sure that we cannot set invalid brightness levels for the LEDs, we cannot
    set invalid motor speeds for the hexacopter, and we receive an HTTP 404 Not Found
    status code when we try to access a resource that doesn''t exist. Open the existing
    `test_hexacopter.py` file and insert the following lines after the last line.
    The code file for the sample is included in the `restful_python_chapter_10_04`
    folder:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看未执行的语句，我们会注意到我们没有测试验证失败的场景。现在，我们将编写额外的单元测试来进一步提高测试覆盖率。具体来说，我们将编写单元测试以确保我们无法为
    LED 设置无效的亮度级别，我们无法为六旋翼机设置无效的电机速度，并且当我们尝试访问不存在的资源时，我们会收到 HTTP 404 Not Found 状态码。打开现有的
    `test_hexacopter.py` 文件，在最后一行之后插入以下行。示例代码文件包含在 `restful_python_chapter_10_04`
    文件夹中：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The previous code added the following seven methods to the `TestHexacopter`
    class whose names start with the `test_` prefix:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码向 `TestHexacopter` 类添加了以下七个以 `test_` 前缀开头的方法：
- en: '`test_set_invalid_brightness_level`: This makes sure that we cannot set an
    invalid brightness level for an LED through an HTTP `PATCH` request.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_invalid_brightness_level`: 这确保了我们无法通过 HTTP `PATCH` 请求为 LED 设置无效的亮度级别。'
- en: '`test_set_brightness_level_invalid_led_id`: This makes sure that we cannot
    set the brightness level for an invalid LED ID through an HTTP `PATCH` request.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_brightness_level_invalid_led_id`: 这确保了我们无法通过 HTTP `PATCH` 请求为无效的
    LED ID 设置亮度级别。'
- en: '`test_get_brightness_level_invalid_led_id`: This makes sure that we cannot
    get the brightness level for an invalid LED ID.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_brightness_level_invalid_led_id`: 这确保了我们无法获取无效 LED ID 的亮度级别。'
- en: '`test_set_invalid_motor_speed`: This makes sure that we cannot set an invalid
    motor seed for the hexacopter through an HTTP `PATCH` request.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_invalid_motor_speed`: 这确保了我们无法通过 HTTP `PATCH` 请求为六旋翼机设置无效的电机速度。'
- en: '`test_set_motor_speed_invalid_hexacopter_id`: This makes sure that we cannot
    set the motor speed for an invalid hexacopter ID through an HTTP `PATCH` request.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_set_motor_speed_invalid_hexacopter_id`: 这确保了我们无法通过 HTTP `PATCH` 请求为无效的六旋翼机
    ID 设置电机速度。'
- en: '`test_get_motor_speed_invalid_hexacopter_id`: This makes sure that we cannot
    get the motor speed for an invalid hexacopter ID.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_motor_speed_invalid_hexacopter_id`: 这确保了我们无法获取无效六旋翼机 ID 的电机速度。'
- en: '`test_get_altimeter_altitude_invalid_altimeter_id`: This makes sure that we
    cannot get the altitude value for an invalid altimeter ID.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_get_altimeter_altitude_invalid_altimeter_id`: 这确保了我们无法获取无效高度计 ID 的高度值。'
- en: 'We coded many tests that will make sure that all the validations work as expected.
    Now, run the following command within the same virtual environment we have been
    using:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了许多测试，以确保所有验证都能按预期工作。现在，在同一个虚拟环境中运行以下命令：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following lines show the sample output. Notice that the numbers shown in
    the report might have small differences if our code includes additional lines
    or comments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出。请注意，如果我们的代码包含额外的行或注释，报告中显示的数字可能会有所不同：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The output provided details indicating that the test runner executed `10` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_api.py`
    module from `71%` in the previous run to `97%`. In addition, the percentage of
    the `drone.py` module increased from `93%` to `100%`. If we check the coverage
    report, we will notice that the only statements that aren't executed are the statements
    included in the main method for the async_api.py module because they aren't part
    of the tests. Thus, we can say that we have `100%` coverage.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，表明测试运行器执行了 `10` 个测试，并且所有测试都通过了。由 `coverage` 包提供的测试代码覆盖率测量报告将 `async_api.py`
    模块的 `Cover` 百分比从上一次运行的 `71%` 提高到了 `97%`。此外，`drone.py` 模块的百分比从 `93%` 提高到了 `100%`。如果我们检查覆盖率报告，我们会注意到未执行的唯一语句是
    `async_api.py` 模块主方法中包含的语句，因为它们不是测试的一部分。因此，我们可以说是 `100%` 的覆盖率。
- en: Now that we have a great test coverage, we can generate the `requirements.txt`
    file that lists the application dependencies together with their versions. This
    way, any platform in which we decide to deploy the RESTful API will be able to
    easily install all the necessary dependencies listed in the file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `pip freeze` to generate the `requirements.txt` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following lines show the content of a sample generated `requirements.txt`
    file. However, bear in mind that many packages increase their version number quickly
    and you might see different versions in your configuration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Other Python Web frameworks for building RESTful APIs
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built RESTful Web Services with Django, Flask, and Tornado. However, Python
    has many other Web frameworks that are also suitable for building RESTful APIs.
    Everything we learned throughout the book about designing, building, testing,
    and deploying a RESTful API is also applicable to any other Python Web framework
    we decide to use. The following list enumerates additional frameworks and their
    main Web page:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Pyramid**: [http://www.pylonsproject.org/](http://www.pylonsproject.org/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottle**: [http://bottlepy.org/](http://bottlepy.org/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Falcon**: [https://falconframework.org/](https://falconframework.org/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always happens with any Python Web framework, there are additional packages
    that might simplify our most common tasks. For example, it is possible to use
    Ramses in combination with Pyramid to create RESTful APIs by working with **RAML**
    (**RESTful API Modeling Language**), whose specification is available at [http://github.com/raml-org/raml-spec](http://github.com/raml-org/raml-spec).
    You can read more details about Ramses at [http://ramses.readthedocs.io/en/stable/getting_started.html](http://ramses.readthedocs.io/en/stable/getting_started.html).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `concurrent.futures.ThreadPoolExecutor` class provides us:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for synchronously executing callables.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for asynchronously executing callables.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for composing HTTP requests.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `@tornado.concurrent.run_on_executor` decorator allows us to:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an asynchronous method synchronously on an executor.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an asynchronous method on an executor without generating a Future.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a synchronous method asynchronously on an executor.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The recommended way to write asynchronous code in Tornado is to use:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coroutines.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chained callbacks.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Subroutines.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `tornado.Testing.AsyncHTTPTestCase` class represents:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A test case that starts up a Flask HTTP Server.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A test case that starts up a Tornado HTTP Server.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A test case that doesn't start up any HTTP Server.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to convert the bytes in a JSON response body to a Python dictionary,
    we can use the following function:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.json_decode`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.byte_decode`'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.response_body_decode`'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the difference between synchronous and asynchronous
    execution. We created a new version of the RESTful API that takes advantage of
    the non-blocking features in Tornado combined with asynchronous execution. We
    improved scalability for our existing API and we made it possible to start executing
    other requests while waiting for the slow I/O operations with sensors and actuators.
    We avoided splitting our methods into multiple methods with callbacks by using
    the `tornado.gen` generator-based interface that Tornado provides to make it easier
    to work in an asynchronous environment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们理解了同步执行和异步执行之间的区别。我们创建了一个新的 RESTful API 版本，它利用了 Tornado 中的非阻塞特性以及异步执行。我们提高了现有
    API 的可扩展性，并使其在等待传感器和执行器的慢速 I/O 操作时能够开始执行其他请求。我们通过使用 Tornado 提供的基于 `tornado.gen`
    生成器的接口来避免将方法拆分成多个带有回调的方法，这使得在异步环境中工作变得更加容易。
- en: Then, we set up a testing environment. We installed nose2 to make it easy to
    discover and execute unit tests. We wrote a first round of unit tests, measured
    test coverage, and then we wrote additional unit tests to improve test coverage.
    We created all the necessary tests to have a complete coverage of all the lines
    of code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置了测试环境。我们安装了 nose2 以便于发现和执行单元测试。我们编写了一轮单元测试，测量了测试覆盖率，然后编写了额外的单元测试以提高测试覆盖率。我们创建了所有必要的测试，以确保对所有代码行都有完整的覆盖。
- en: We built RESTful Web Services with Django, Flask, and Tornado. We have chosen
    the most appropriate framework for each case. We learned to design a RESTful API
    from scratch and to run all the necessary tests to make sure that our API works
    without issues as we release new versions. Now, we are ready to create RESTful
    APIs with any of the Web frameworks with whom we have been working throughout
    this book.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Django、Flask 和 Tornado 构建了 RESTful Web 服务。我们为每种情况选择了最合适的框架。我们学会了从头设计 RESTful
    API，并运行所有必要的测试以确保我们的 API 在发布新版本时没有问题。现在，我们准备好使用本书中一直使用的任何 Web 框架来创建 RESTful API。
