- en: Chapter 10.  Working with Asynchronous Code, Testing, and Deploying an API with
    Tornado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take advantage of the non-blocking features combined
    with asynchronous operations in Tornado in a new version for the API we built
    in the previous chapter. We will configure, write, and execute unit tests and
    learn a few things related to deployment. We will cover  the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding synchronous and asynchronous execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring code to take advantage of asynchronous decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping URL patterns to asynchronous and non-blocking request handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP requests to the Tornado non-blocking API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a first round of unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit tests with `nose2` and checking testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding synchronous and asynchronous execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our current version of the API, each HTTP request is blocking, as happened
    with Django and Flask. Thus, whenever the Tornado HTTP server receives an HTTP
    request, it doesn't start working on any other HTTP request in the incoming queue
    until the server sends the response for the first HTTP request it received. The
    methods we coded in the request handlers are working with a synchronous execution
    and they don't take advantage of the non-blocking features included in Tornado
    when combined with asynchronous executions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set the brightness level for both the blue and white LEDs, we have
    to make two HTTP PATCH requests. We will make them to understand how our current
    version of the API processes two incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open two Cygwin terminals in Windows or two Terminals in macOS or Linux, and
    write the following command in the first one. We will compose and send an HTTP
    request to set the brightness level for the blue `LED` to `255`. Write the line
    in the first window, but don''t press *Enter* yet, as we will try to launch two
    commands at almost the same time in two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the second window and write the following command. We will compose
    and send an HTTP request to set the brightness level for the white LED to 255\.
    Write the line in the second window, but don''t press *Enter* yet, as we will
    try to launch two commands at almost the same time in two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the first window, press ***Enter*** . Then, go to the second window
    and quickly press *Enter*. You will see the following line in the window that
    is running the Tornado HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will see the following lines that show the results of executing the
    print statements that describe when the code finished and then started setting
    the brightness level for the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It was necessary to wait for the request that changed the brightness level
    for the blue LED to finish before the server could process the HTTP that changes
    the brightness level for the white LED. The following screenshot shows three windows
    on Windows. The window on the left-hand side is running the Tornado HTTP server
    and displays the messages printed in the methods that process the HTTP requests.
    The window at the upper-right corner is running the `http` command to generate
    the HTTP request that changes the brightness level for the blue LED. The window
    at the lower-right corner is running the `http` command to generate the HTTP request
    that changes the brightness level for the white LED. It is a good idea to use
    a similar configuration to check the output while we compose and send the HTTP
    requests and how the synchronous execution is working on the current version of
    the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding synchronous and asynchronous execution](img/image_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the different methods we coded in the request handler classes
    end up calling `time.sleep` to simulate it takes some time for the operations
    to complete their execution.
  prefs: []
  type: TYPE_NORMAL
- en: As each operation takes some time and blocks the possibility to process other
    incoming HTTP requests, we will create a new version of this API that will use
    asynchronous execution, and we will understand the advantages of Tornado's non-blocking
    features. This way, it will be possible to change the brightness level for the
    white LED while the other request is to change the brightness level for the blue
    LED. Tornado will be able to start processing requests while the I/O operations
    with the drone take some time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code to take advantage of asynchronous decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is extremely difficult to read and understand code split into different methods,
    such as the asynchronous code that requires working with callbacks that are executed
    once the asynchronous execution finishes. Luckily, Tornado provides a generator-based
    interface that enables us to write asynchronous code in request handlers in a
    single generator. We can avoid splitting our methods into multiple methods with
    callbacks by using the `tornado.gen` generator-based interface that Tornado provides
    to make it easier to work in an asynchronous environment.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended way to write asynchronous code in Tornado is to use coroutines.
    Thus, we will refactor our existing code to use the `@tornado.gen.coroutine` decorator
    for asynchronous generators in the required methods that process the different
    HTTP requests in the subclasses of `tornado.web.RequestHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of working with a chain of callbacks, coroutines use the Python `yield`
    keyword to suspend and resume execution. By using coroutines, our code is going
    to be as simple to understand and maintain as if we were writing synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an instance of the `concurrent.futures.ThreadPoolExecutor` class
    that provides us with a high-level interface for asynchronously executing callables.
    The asynchronous execution will be performed with threads. We will also use the
    `@tornado.concurrent.run_on_executor` decorator to run a synchronous method asynchronously
    on an executor. In this case, the methods provided by the different components
    of our drone to get and set data have a synchronous execution. We want them to
    run with an asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `async_api.py` file. The following lines show all the necessary
    imports for the classes that we will create and the code that creates an instance
    of the `concurrent.futures.ThreadPoolExecutor` class named `thread_pool`. We will
    use this instance in the different methods that we will refactor to make asynchronous
    calls. The code file for the sample is included in the `restful_python_chapter_10_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create an `AsyncHexacopterHandler` class that we will use to handle
    requests for the hexacopter resource with an asynchronous execution. The lines
    that are new or changed compared with the synchronous version of this handler
    named `HexacopterHandler` are highlighted. Open the previously created `async_pi.py`
    file and add the following lines. The code file for the sample is included in
    the `restful_python_chapter_10_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AsyncHexacopterHandler` class declares a `_thread_pool` class attribute
    that saves a reference to the previously created `concurrent.futures.ThreadPoolExecutor`
    instance. The class declares two methods with the `@run_on_executor(executor="_thread_pool")`
    decorator that makes the synchronous method run asynchronously with the `concurrent.futures.ThreadPoolExecutor`
    instance whose reference is saved in the `_thread_pool` class attribute. The following
    are the two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`retrieve_hexacopter_status`: This method returns the results of calling the
    `drone.hexacopter.get_hexacopter_status` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_hexacopter_motor_speed`: This method receives the `motor_speed` argument
    and returns the results of calling the `drone.hexacopter.set_motor_speed` method
    with the received `motor_speed` as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `@gen.coroutine` decorator to both the `get` and `patch` methods.
    We added a call to `self.finish` whenever we wanted to finish the HTTP request.
    It is our responsibility to call this method to finish the response and end the
    HTTP request when we use the `@gen.coroutine` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` method uses the following line to retrieve the hexacopter status
    with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to retrieve `HexacopterStatus` from the `Future`
    returned by `self.retrieve_hexacopter_status` that runs with an asynchronous execution.
    A `Future` encapsulates the asynchronous execution of a callable. In this case,
    `Future` encapsulates the asynchronous execution of the `self.retrieve_hexacopter_status`
    method. The next lines didn't require changes, and we only had to add a call to
    `self.finish` as the last line after we write the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` method uses the following line to retrieve the hexacopter status
    with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to retrieve the `HexacopterStatus` from the
    `Future` returned by the `self.retrieve_hexacopter_status` that runs with an asynchronous
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patch` method uses the following line to set the hexacopter''s motor speed
    with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to retrieve the `HexacopterStatus` from the
    `Future` returned by the `self.set_hexacopter_motor_speed` that runs with an asynchronous
    execution. The next lines didn't require changes, and we only had to add a call
    to `self.finish` as the last line after we write the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create an `AsyncLedHandler` class that we will use to represent
    the LED resources and process requests with an asynchronous execution. The lines
    that are new or changed compared with the synchronous version of this handler
    named `LedHandler` are highlighted. Open the previously created `async_pi.py`
    file and add the following lines. The code file for the sample is included in
    the `restful_python_chapter_10_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AsyncLedHandler` class declares a `_thread_pool` class attribute that
    saves a reference to the previously created `concurrent.futures.ThreadPoolExecutor`
    instance. The class declares two methods with the `@run_on_executor(executor="_thread_pool")`
    decorator that makes the synchronous method run asynchronously with the `concurrent.futures.ThreadPoolExecutor`
    instance whose reference is saved in the `_thread_pool` class attribute. The following
    are the two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`retrieve_led_brightness_level`: This method receives a `LightEmittingDiode`
    instance in the `led` argument and returns the results of calling the `led.get_brightness_level`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_led_brightness_level`: This method receives a `LightEmittingDiode` instance
    in the `led` argument and the `brightness_level` argument. The code returns the
    results of calling the `led.set_brightness_level` method with the received `brightness_level`
    as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `@gen.coroutine` decorator to both the `get` and `patch` methods.
    In addition, we added a call to `self.finish` whenever we wanted to finish the
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` method uses the following line to retrieve the LED''s brightness
    level with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to retrieve the `int` from `Future` returned
    by `self.retrieve_led_brightness_level` that runs with an asynchronous execution.
    The next lines didn't require changes, and we only had to add a call to `self.finish`
    as the last line after we write the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patch` method uses the following line to retrieve the hexacopter status
    with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to retrieve `HexacopterStatus` from `Future`
    returned by `self.retrieve_hexacopter_status` that runs with an asynchronous execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patch` method uses the following line to set the LED''s brightness level
    with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to call `self.set_led_brightness_level` with
    an asynchronous execution. The next lines didn't require changes, and we only
    had to add a call to `self.finish` as the last line after we write the response.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create an `AsyncAltimeterHandler` class that we will use to represent
    the altimeter resource and process the `get` request with an asynchronous execution.
    The lines that are new or changed compared with the synchronous version of this
    handler named `AltimeterHandler`, are highlighted. Open the previously created
    `async_pi.py` file and add the following lines. The code file for the sample is
    included in the `restful_python_chapter_10_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `AsyncAltimeterHandler` class declares a `_thread_pool` class attribute
    that saves a reference to the previously created `concurrent.futures.ThreadPoolExecutor`
    instance. The class declares the `retrieve_altitude` method with the `@run_on_executor(executor="_thread_pool")`
    decorator that makes the synchronous method run asynchronously with the `concurrent.futures.ThreadPoolExecutor`
    instance whose reference is saved in the `_thread_pool` class attribute. The `retrieve_altitude`
    method returns the results of calling the `drone.altimeter.get_altitude` method.
  prefs: []
  type: TYPE_NORMAL
- en: We added the `@gen.coroutine` decorator to the `get` method. In addition, we
    added a call to `self.finish` whenever we wanted to finish the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get` method uses the following line to retrieve the altimeter''s altitude
    value with a non-blocking and asynchronous execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the `yield` keyword to retrieve the `int` from `Future` returned
    by `self.retrieve_altitude` that runs with an asynchronous execution. The next
    lines didn't require changes, and we only had to add a call to `self.finish` as
    the last line after we write the response.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping URL patterns to asynchronous request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must map URL patterns to our previously coded subclasses of `tornado.web.RequestHandler`
    that provide us asynchronous methods for our request handlers. The following lines
    create the main entry point for the application, initialize it with the URL patterns
    for the API, and start listening for requests. Open the previously created `async_api.py`
    file and add the following lines. The code file for the sample is included in
    the `restful_python_chapter_10_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code creates an instance of `tornado.web.Application` named `application`
    with the collection of request handlers that make up the Web application. We just
    changed the name of the handlers with the new names that have the `Async` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with any other Web framework, you should never enable debugging in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to the Tornado non-blocking API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can run the `async_api.py` script that launches Tornados''s development
    server to compose and send HTTP requests to our new version of the Web API that
    uses the non-blocking features of Tornado combined with asynchronous execution.
    Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we execute the previous command.
    The Tornado HTTP development server is listening at port `8888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the previous command, we will start the Tornado HTTP server and it will
    listen on every interface on port `8888`. Thus, if we want to make HTTP requests
    to our API from other computers or devices connected to our LAN, we don't need
    any additional configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In our new version of the API, each HTTP request is non-blocking. Thus, whenever
    the Tornado HTTP server receives an HTTP request and makes an asynchronous call,
    it is able to start working on any other HTTP request in the incoming queue before
    the server sends the response for the first HTTP request it received. The methods
    we coded in the request handlers are working with an asynchronous execution and
    they take advantage of the non-blocking features included in Tornado, combined
    with asynchronous executions.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set the brightness level for both the blue and white LEDs, we have
    to make two HTTP `PATCH` requests. We will make them to understand how our new
    version of the API processes two incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open two Cygwin terminals in Windows, or two Terminals in macOS or Linux, and
    write the following command in the first one. We will compose and send an HTTP
    request to set the brightness level for the blue LED to `255`. Write the line
    in the first window but don''t press *Enter* yet, as we will try to launch two
    commands at almost the same time in two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the second window and write the following command. We will compose
    and send an HTTP request to set the brightness level for the white LED to `255`.
    Write the line in the second window but don''t press *Enter* yet, as we will try
    to launch two commands at almost the same time in two windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the first window, press ***Enter*** . Then, go to the second window
    and quickly press *Enter*. You will see the following lines in the window that
    is running the Tornado HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will see the following lines that show the results of executing the
    print statements that describe when the code finished setting the brightness level
    for the LEDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The server could start processing the request that changes the brightness level
    for the white LED before the request that changes the brightness level of the
    blue LED finishes its execution. The following screenshot shows three windows
    on Windows. The window on the left-hand side is running the Tornado HTTP server
    and displays the messages printed in the methods that process the HTTP requests.
    The window on the upper-right corner is running the `http` command to generate
    the HTTP request that changes the brightness level for the blue LED. The window
    at the lower-right corner is running the `http` command to generate the HTTP request
    that changes the brightness level for the white LED. It is a good idea to use
    a similar configuration to check the output while we compose and send the HTTP
    requests and check how the asynchronous execution is working on the new version
    of the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making HTTP requests to the Tornado non-blocking API](img/image_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each operation takes some time but doesn't block the possibility to process
    other incoming HTTP requests thanks to the changes we made to the API to take
    advantage of the asynchronous execution. This way, it is possible to change the
    brightness level for the white LED while the other request is to change the brightness
    level for the blue LED. Tornado is able to start processing requests while the
    I/O operations with the drone take some time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use `nose2` to make it easier to discover and run unit tests. We will
    measure test coverage, and therefore, we will install the necessary package to
    allow us to run coverage with `nose2`. First, we will install the `nose2` and
    `cov-core` packages in our virtual environment. The `cov-core` package will allow
    us to measure test coverage with `nose2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you quit the Tornado''s HTTP server. Remember that you just need
    to press ***Ctrl*** + ***C*** in the Terminal or command-prompt window in which
    it is running. We just need to run the following command to install the `nose2`
    package that will also install the `six` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `nose2` package has been
    successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to run the following command to install the `cov-core` package
    that will also install the `coverage` dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `django-nose` package
    has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the previously created `async_api.py` file and remove the lines that create
    the `web.Application` instance named application and the `__main__` method. After
    you remove these lines, add the next lines. The code file for the sample is included
    in the `restful_python_chapter_10_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code declares an `Application` class, specifically, a subclass of `tornado.web.Application`
    that overrides the inherited constructor, that is, the `__init__` method. The
    constructor declares the `handlers` list that maps URL patterns to asynchronous
    request handlers and then calls the inherited constructor with the list as one
    of its arguments. We create the class to make it possible for the tests to use
    this class.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the main method creates an instance of the Application class, registers
    a periodic callback that will be executed every `500` milliseconds by the `IOLoop`
    to make it possible to use ***Ctrl*** + ***C*** to stop the HTTP server, and finally
    calls the `start` method. The `async_api.py` script is going to continue working
    in the same way. The main difference is that we can reuse the `Application` class
    in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create a new text file named `.coveragerc` within the virtual environment''s
    root folder with the following content. The code file for the sample is included
    in the `restful_python_chapter_10_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `coverage` utility will only consider the code in the `async_api.py`
    and `drone.py` files when providing us with the test coverage report. We will
    have a more accurate test coverage report with this settings file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case, we won't be using configuration files for each environment. However,
    in more complex applications, you will definitely want to use configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a first round of unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write a first round of unit tests. Specifically, we will write
    unit tests related to the LED resources. Create a new `tests` subfolder within
    the virtual environment''s root folder. Then, create a new `test_hexacopter.py`
    file within the new `tests` subfolder. Add the following lines that declare many
    `import` statements and the `TextHexacopter` class. The code file for the sample
    is included in the `restful_python_chapter_10_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `TestHexacopter` class is a subclass of `tornado.testing.AsyncHTTPTestCase`,
    that is, a test case that starts up a Tornado HTTP Server. The class overrides
    the `get_app` method that returns the `tornado.web.Application` instance that
    we want to test. In this case, we return an instance of the `Application` class
    declared in the `async_api` module, with the `debug` argument set to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The `test_set_and_get_led_brightness_level` method tests whether we can set
    and get the brightness levels for both the white and blue LED. The code composes
    and sends two HTTP `PATCH` methods to set new brightness level values for the
    LEDs whose IDs are equal to `1` and `2`. The code sets a different brightness
    level for each LED.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code calls the self.fetch method to compose and send the HTTP `PATCH` request
    and calls `json.dumps` with the dictionary to be sent to the body as an argument.
    Then, the code uses `self.fetch` again to compose and send two HTTP `GET` methods
    to retrieve the brightness level values for the LEDs whose brightness values have
    been modified. The code uses `tornado.escape.json_decode` to convert the bytes
    in the response body to a Python dictionary. The method uses `assertEqual` and
    `assertTrue` to check for the following expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` for the two HTTP `PATCH` responses is HTTP 200 OK (`status.HTTP_200_OK`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `status_code` for the two HTTP `GET` responses is HTTP 200 OK (`status.HTTP_200_OK`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response body for the two HTTP `GET` responses include a key named `brigthness_level`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value for the `brightness_level` key in the HTTP `GET` responses are equal
    to the brightness level set to each LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit tests with nose2 and checking testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, run the following command to create all the necessary tables in our test
    database and use the nose2 test running to execute all the tests we created. The
    test runner will execute all the methods for our `TestHexacopter` class that start
    with the `test_` prefix and will display the results. In this case, we just have
    one method that matches the criteria, but we will add more later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command within the same virtual environment we have been
    using. We will use the `-v` option to instruct nose2 to print test case names
    and statuses. The `--with-coverage` option turns on test coverage reporting generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output. Notice that the numbers shown in
    the report might have small differences if our code includes additional lines
    or comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: By default, `nose2` looks for modules whose names start with the `test` prefix.
    In this case, the only module that matches the criteria is the `test_hexacopter`
    module. In the modules that match the criteria, `nose2` loads tests from all the
    subclasses of `unittest.TestCase` and the functions whose names start with the
    `test` prefix. The `tornado.testing.AsyncHTTPTestCase` includes `unittest.TestCase`
    as one of its superclasses in the class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: The output provided details indicating that the test runner discovered and executed
    one test and it passed. The output displays the method name and the class name
    for each method in the `TestHexacopter` class that started with the `test_` prefix
    and represented a test to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: We definitely have a very low coverage for `async_api.py` and `drone.py` based
    on the measurements shown in the report. In fact, we just wrote one test related
    to LEDs, and therefore, it makes sense that the coverage has to be improved. We
    didn't create tests related to other hexacopter resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will use the information from the last execution and will display
    the missing statements. The next lines show a sample output that corresponds to
    the previous execution of the unit tests. Notice that the numbers shown in the
    report might have small differences if our code includes additional lines or comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `index.html` HTML file generated in the `htmlcov` folder with your
    Web browser. The following screenshot shows an example report that coverage generated
    in HTML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click or tap on `drony.py` and the Web browser will render a Web page that displays
    the statements that were run, the missing ones, and the excluded ones, with different
    colors. We can click or tap on the **run**, **missing**, and **excluded** buttons
    to show or hide the background color that represents the status for each line
    of code. By default, the missing lines of code will be displayed with a pink background.
    Thus, we must write unit tests that target these lines of code to improve our
    test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests with nose2 and checking testing coverage](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Improving testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to the hexacopter motor and the altimeter. Open
    the existing `test_hexacopter.py` file and insert the following lines after the
    last line. The code file for the sample is included in the `restful_python_chapter_10_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code added the following two methods to the `TestHexacopter` class
    whose names start with the `test_` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_set_and_get_hexacopter_motor_speed`: This tests whether we can set and
    get the hexacopter''s motor speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_altimeter_altitude`: This tests whether we can retrieve the altitude
    value from the altimeter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just coded a few tests related to the hexacopter and the altimeter in order
    to improve test coverage and notice the impact on the test coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command within the same virtual environment we have
    been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output. Notice that the numbers shown in
    the report might have small differences if our code includes additional lines
    or comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The output provided details indicating that the test runner executed `3` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_api.py`
    module from `47%` in the previous run to `71%`. In addition, the percentage of
    the `drone.py` module increased from `68%` to `93%` because we wrote tests that
    worked with all the components for the drone. The new additional tests we wrote
    executed additional code in the two modules, and therefore, there is an impact
    in the coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the missing statements, we will notice that we aren''t
    testing scenarios where validations fail. Now, we will write additional unit tests
    to improve the testing coverage further. Specifically, we will write unit tests
    to make sure that we cannot set invalid brightness levels for the LEDs, we cannot
    set invalid motor speeds for the hexacopter, and we receive an HTTP 404 Not Found
    status code when we try to access a resource that doesn''t exist. Open the existing
    `test_hexacopter.py` file and insert the following lines after the last line.
    The code file for the sample is included in the `restful_python_chapter_10_04`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code added the following seven methods to the `TestHexacopter`
    class whose names start with the `test_` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_set_invalid_brightness_level`: This makes sure that we cannot set an
    invalid brightness level for an LED through an HTTP `PATCH` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_set_brightness_level_invalid_led_id`: This makes sure that we cannot
    set the brightness level for an invalid LED ID through an HTTP `PATCH` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_brightness_level_invalid_led_id`: This makes sure that we cannot
    get the brightness level for an invalid LED ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_set_invalid_motor_speed`: This makes sure that we cannot set an invalid
    motor seed for the hexacopter through an HTTP `PATCH` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_set_motor_speed_invalid_hexacopter_id`: This makes sure that we cannot
    set the motor speed for an invalid hexacopter ID through an HTTP `PATCH` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_motor_speed_invalid_hexacopter_id`: This makes sure that we cannot
    get the motor speed for an invalid hexacopter ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_get_altimeter_altitude_invalid_altimeter_id`: This makes sure that we
    cannot get the altitude value for an invalid altimeter ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We coded many tests that will make sure that all the validations work as expected.
    Now, run the following command within the same virtual environment we have been
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output. Notice that the numbers shown in
    the report might have small differences if our code includes additional lines
    or comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The output provided details indicating that the test runner executed `10` tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage of the `async_api.py`
    module from `71%` in the previous run to `97%`. In addition, the percentage of
    the `drone.py` module increased from `93%` to `100%`. If we check the coverage
    report, we will notice that the only statements that aren't executed are the statements
    included in the main method for the async_api.py module because they aren't part
    of the tests. Thus, we can say that we have `100%` coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a great test coverage, we can generate the `requirements.txt`
    file that lists the application dependencies together with their versions. This
    way, any platform in which we decide to deploy the RESTful API will be able to
    easily install all the necessary dependencies listed in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `pip freeze` to generate the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the content of a sample generated `requirements.txt`
    file. However, bear in mind that many packages increase their version number quickly
    and you might see different versions in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Other Python Web frameworks for building RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built RESTful Web Services with Django, Flask, and Tornado. However, Python
    has many other Web frameworks that are also suitable for building RESTful APIs.
    Everything we learned throughout the book about designing, building, testing,
    and deploying a RESTful API is also applicable to any other Python Web framework
    we decide to use. The following list enumerates additional frameworks and their
    main Web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pyramid**: [http://www.pylonsproject.org/](http://www.pylonsproject.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottle**: [http://bottlepy.org/](http://bottlepy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Falcon**: [https://falconframework.org/](https://falconframework.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always happens with any Python Web framework, there are additional packages
    that might simplify our most common tasks. For example, it is possible to use
    Ramses in combination with Pyramid to create RESTful APIs by working with **RAML**
    (**RESTful API Modeling Language**), whose specification is available at [http://github.com/raml-org/raml-spec](http://github.com/raml-org/raml-spec).
    You can read more details about Ramses at [http://ramses.readthedocs.io/en/stable/getting_started.html](http://ramses.readthedocs.io/en/stable/getting_started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `concurrent.futures.ThreadPoolExecutor` class provides us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for synchronously executing callables.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for asynchronously executing callables.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A high-level interface for composing HTTP requests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `@tornado.concurrent.run_on_executor` decorator allows us to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an asynchronous method synchronously on an executor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run an asynchronous method on an executor without generating a Future.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a synchronous method asynchronously on an executor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The recommended way to write asynchronous code in Tornado is to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coroutines.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Chained callbacks.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Subroutines.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `tornado.Testing.AsyncHTTPTestCase` class represents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A test case that starts up a Flask HTTP Server.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A test case that starts up a Tornado HTTP Server.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A test case that doesn't start up any HTTP Server.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to convert the bytes in a JSON response body to a Python dictionary,
    we can use the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.json_decode`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.byte_decode`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.escape.response_body_decode`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood the difference between synchronous and asynchronous
    execution. We created a new version of the RESTful API that takes advantage of
    the non-blocking features in Tornado combined with asynchronous execution. We
    improved scalability for our existing API and we made it possible to start executing
    other requests while waiting for the slow I/O operations with sensors and actuators.
    We avoided splitting our methods into multiple methods with callbacks by using
    the `tornado.gen` generator-based interface that Tornado provides to make it easier
    to work in an asynchronous environment.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set up a testing environment. We installed nose2 to make it easy to
    discover and execute unit tests. We wrote a first round of unit tests, measured
    test coverage, and then we wrote additional unit tests to improve test coverage.
    We created all the necessary tests to have a complete coverage of all the lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: We built RESTful Web Services with Django, Flask, and Tornado. We have chosen
    the most appropriate framework for each case. We learned to design a RESTful API
    from scratch and to run all the necessary tests to make sure that our API works
    without issues as we release new versions. Now, we are ready to create RESTful
    APIs with any of the Web frameworks with whom we have been working throughout
    this book.
  prefs: []
  type: TYPE_NORMAL
