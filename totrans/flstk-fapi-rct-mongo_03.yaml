- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Type Hints and Pydantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before exploring FastAPI, it is useful to explore some Python concepts that
    will be heavily used throughout your journey with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Python type hinting is a very important and relatively new feature of the language
    that facilitates the work of developers, bringing greater robustness and maintainability
    to the development workflow. Types make your code more readable and understandable,
    and most importantly, they promote good practices.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is heavily based on Python type hints. So, before diving into the framework,
    it is useful to review the basic concepts of type hinting, what they are, how
    they are implemented, and what their purpose is. This foundational knowledge will
    help you create robust, maintainable, and scalable APIs with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deep understanding of the role of
    type annotations in Python with FastAPI and Pydantic. Pydantic is a modern Python
    library that enforces type hints at runtime, provides customizable and user-friendly
    errors when data is invalid, and allows definition of data structures using Python
    type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to model your data with precision, leveraging the advanced
    features of Pydantic to make you a better and more productive FastAPI developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python type hints and their usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general overview of Pydantic and its main functions, including parsing and
    validating data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data deserialization and serialization, including advanced and special cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation and data transformation, aliases, and field and model-level validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Pydantic usage such as nested models, fields, and model settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the sample application in this chapter, you should have Python version
    3.11.7(https://www.python.org/downloads/) or higher installed on your local computer,
    a virtual environment, and a couple of packages. As the examples in this chapter
    will not make use of FastAPI, if you wish, you can create a pristine virtual environment
    and install Pydantic with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, you will be working with Pydantic and some Pydantic-related
    packages, such as `pydantic_settings`.
  prefs: []
  type: TYPE_NORMAL
- en: Python types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The different types present in a programming language define the language itself—they
    define its boundaries and set some ground rules for what is possible and, more
    importantly, what the recommended way of achieving something is. Different types
    of variables have completely different sets of methods and properties available.
    For example, while capitalizing a string makes perfect sense, capitalizing a floating
    number or a list of integers doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have used Python for a while, even for the most mundane tasks, you already
    know that, like every programming language, it supports different types of data—strings
    and different numerical types such as integers and floats. It also features a
    rather rich data structure library: from dictionaries to lists, from sets to tuples,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Python is a **dynamically typed language**. This means that the type of a variable
    is not determined at compile time, but at runtime. This feature gives the language
    itself a lot of flexibility and enables you to declare a variable as a string,
    use it, and then later on reassign it to a list. However, the ease of changing
    the variable type can make larger and more complex codebases more prone to errors.
    Dynamic typing implies that the type of a variable is embedded with the variable
    itself and is easily modifiable.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other end of the spectrum lie the so-called statically typed languages:
    C, C++, Java, Rust, Go, and so on. In these languages, the type of the variable
    is known at compile time, and it cannot change over time. The type-checking is
    performed at compile time (so before runtime) and errors are caught before runtime,
    as the compiler will prevent the program from being compiled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming languages are divided into different categories along another,
    different axis: strongly typed languages and weakly typed languages. This characteristic
    tells us how much a language restricts its types to operations inherent to those
    specific types and how easy it is to coerce, or change, a variable from one to
    another type. Unlike JavaScript, for instance, Python is considered to be on the
    stronger side of the spectrum, and the interpreter sends strong messages when
    you try to perform an illegal operation, such as typing the following in a Python
    interpreter to add a `dict` type to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, while Python does complain when you attempt to perform unsupported operations,
    it only does so at runtime, not before executing the code. In fact, there is no
    indication to you—the developer—that you are writing code that violates the Python
    type system.
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen in the previous section, Python is a dynamically typed language,
    and types aren’t known until runtime. Since variable types are embedded in the
    value of the variable itself, as a developer, you cannot know the type of a variable
    that you encounter in a codebase just by looking at it or inspecting it with your
    IDE of choice. Fortunately, Python introduced a very sought-out feature starting
    from version 3.5—type annotations (https://peps.python.org/pep-0484/).
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations or hints in Python are an additional syntax that notifies you,
    the developer, of the expected type of a variable. They are not used by the Python
    language at runtime, and they do not modify or affect the behavior of your program
    in any way. You might be wondering what the use of these hints is if the Python
    interpreter cannot even see them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, several important benefits will make almost any codebase much
    more robust, more maintainable, and future-proof:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster code development**: Any developer reading your code will know exactly
    the type of any annotated variable—whether it is an integer or a floating point,
    a list or a set, allowing for faster development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Knowledge of methods and properties**: You will know exactly which methods
    or properties are available for any given variable. Inadvertently changing the
    type of a variable in a larger codebase will be picked up immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified code development**: Code editors and IDE (such as Visual Studio
    Code) will provide excellent support and auto-completion (IntelliSense), further
    simplifying development and reducing the cognitive load on the developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic code generation**: FastAPI provides automatic and interactive (as
    in a fully functional REST API) documentation that is entirely based on Python
    type hints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type checkers**: This is the most important benefit. These are programs that
    run in the background and perform static analysis of your code, spotting potential
    problems and informing you immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to read and smaller cognitive load**: Annotated code is much easier
    to read and puts much less cognitive load on you as a developer when you have
    to work on a piece of code and are trying to figure out what it is supposed to
    do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strongly typed and flexible**: Preserves the language’s strongly typed nature
    and dynamic typing flexibility, while allowing for imposing the necessary safety
    requirements and constraints. While recommended for larger codebases, Python type
    hints are ingrained into FastAPI and Pydantic, so even the smallest projects will
    require you to at least know your way around types and how to work with them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type hinting is at the very base of FastAPI. Coupled with MongoDB’s flexible
    document schema, it is the backbone of FARM stack development. Type hinting ensures
    that your application data flow maintains the right data types going in and out
    of the system at every moment. While this might seem trivial for simpler endpoints—quantities
    should be integers, names should be strings, and so on—when your data structure
    becomes more complex, debugging type errors can become very cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Type hints can also be defined as a formalism—a formal solution to statically
    (before runtime) indicate the type of a value to a type checker (**Mypy**, in
    your case), which will ensure that when the Python runtime encounters your program
    the types will not be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will detail the syntax of type hints, how to annotate functions,
    and how to check your code with Mypy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing type hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how you can implement type hinting. Create a directory named `Chapter3`
    and create a virtual environment inside it, as shown earlier. Inside, add a `requirements.txt`
    file with the following contents if you want to be able to recreate the examples
    in the chapter exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the packages with `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now you are ready to explore the world of Python type hints.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many Python type checkers—basically tools that perform static
    analysis of the source code without running it—we will use `mypy` as it is easily
    installable. Later, you will have tools such as Black or Ruff at your disposal.
    These perform different actions on your source code, including type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to showcase the Python type annotation syntax, a simple function,
    such as the following will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `chapter3_01.py` and define a simple function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous function accepts two parameters, `name` (a string) and `times`
    (an integer), and returns `None`, while the function prints the given name for
    a given number of times in the console. If you try to call the function in your
    code and start typing the arguments, Visual Studio Code (or any IDE with Python
    type-checking support) will immediately suggest a string as the first positional
    argument and an integer as the second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can try to input the wrong argument types, for instance, an integer first
    and then a string afterward, save the file, and run `mypy` on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Mypy will inform you that there are two errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This example was simple enough, but take a look again at what **Python Enhancement
    Proposal 8** (**PEP 8**)recommends when it comes to the type-hinting syntax with
    another example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a simple variable that has a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The colon is attached to the variable (no spaces), there is one space after
    the colon, and, in cases where you do provide a value, there are spaces around
    the equal sign.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When annotating the output of a function, the "arrow," which is made up of
    a dash and greater than sign (`->`), should be surrounded by one space, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So far, you have seen simple annotations that constrain a variable to some
    Python primitive types including integers and strings. Typing annotations can
    be more flexible: you might want to allow a variable to accept several variable
    types, such as an integer and a string.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can achieve this with the use of the `Union` package from the `typing`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previously defined `x` variable can take a string or an integer value.
    The more modern and concise way of achieving the same functionality is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These annotations mean that the variable `x` can be an integer or it can take
    a value of `string`, which is a different type from an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `typing` module contains several types of so-called generics, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`: For variables that should be of the list type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dict`: For dictionaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sequence`: For any type of sequence of values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callable`: For callables, such as functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterator`: Indicates that a function or variable accepts an iterator object
    (an object that implements the iterator protocol and can be used in a `for` loop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to explore the `typing` module but bear in mind that the
    types from the module are gradually being imported into Python’s code functionality.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the `List` type is very useful in working with FastAPI as it allows
    you to serialize a list of items or resources quickly and efficiently into a JSON
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a `List` type is the following, in a new file called `chapter3_02.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful type is `Literal` , which restricts the possible values of a
    variable to a few admissible states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines showcase the power of type hints. There is nothing inherently
    wrong with assigning the `account_type` variable to a string, but that string
    is not part of the admissible state set and thus Mypy complains and returns an
    `Incompatible types in` `assignment` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at an example that includes a `datetime` argument. Create a new file
    called `chapter3_03.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously defined function accepts one parameter—a datetime object—and
    outputs a string: a nicely formatted date and time, useful for displaying on websites.
    If you try to type *dt* and then a dot in your Visual Studio Code editor, you
    will be prompted by the autocompletion system, offering all the methods and properties
    related to the datetime object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a structure as a list of dictionaries (something very familiar to
    anyone working with a JSON-based API), you could use something like this, in a
    file named `chapter3_04.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After having covered the basic annotation types in Python, the next few sections
    will look at some more advanced types that are very useful when working with FastAPI
    and Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The annotations you have seen so far are very simple and convey basic information
    related only to the specific desired type of a variable, function, class argument,
    or output. Python’s typing system is capable of much more and it can be used to
    restrict the allowable variables' state further and prevent you, the developer,
    from creating impossible or illegal states in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most frequently used types are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Optional` type is used for handling optional values and `None` values in
    an explicit and developer-friendly way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Union` type allows you to define a union of possible types, such as integers
    and strings. Modern Python uses the pipe operator (`|`), as shown in the previous
    example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self` type is used to indicate that the value will be an instance of a
    certain class, useful in Pydantic model validators as we will see later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `New` type allows developers to define completely new types based on existing
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section detailed Python type hints, their purpose, and how they are implemented.
    The next section will take a deeper look at Pydantic, the workhorse of FastAPI
    data validation.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pydantic is a data validation library labeled on its website as the most widely
    used data validation library for Python. It allows you to model your data in a
    granular way and perform various types of validation while being firmly rooted
    in the Python type hinting system. The actual version, V2, has critical parts
    of the code rewritten in **Rust** for speed and allows for an excellent developer
    experience. The following list describes some of the benefits of using Pydantic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Based on type hints that are part of the standard library**: Instead of needing
    to learn contrived new systems or terminologies, you just need to learn pure Python
    types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excellent speed**: Everything about FastAPI and MongoDB revolves around speed—fast
    and responsive applications delivered in record time—so having a fast validation
    and parsing library is mandatory. The core of Pydantic is written in Rust, which
    ensures high-speed operations on data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Huge community support and wide adoption**: Learning your way around Pydantic
    will prove useful when working with popular packages such as Django Ninja, SQLModel,
    LangChain, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The possibility of emitting JSON schema**: It facilitates integration with
    other systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More flexibility**: Pydantic supports different modes (strict and lax when
    it comes to coercion) and nearly unlimited customization options and flexibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Popular among developers**: It has been downloaded more than 70 million times
    and over 8,000 packages on PyPI depend on Pydantic (as of July 2024).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can take a look at Pydantic in detail in its documentation: [https://docs.pydantic.dev/latest/](https://docs.pydantic.dev/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, Pydantic tackles many important problems in a modern web development
    workflow. It ensures that the data that is ingested into your application is properly
    formed and formatted, falls within the desired range, is of the appropriate type
    and dimensions, and reaches your document store safely and without errors.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic also ensures that your application outputs the data exactly as intended
    and according to the specification, omitting fields that should not be exposed
    (such as user passwords) and even more complex tasks, including interfacing with
    other incompatible systems.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is standing on the shoulders of two powerful Python libraries—Starlette
    and Pydantic. While Starlette takes care of the web-related aspects of the framework,
    often through thin wrappers and utility functions and classes provided by FastAPI,
    Pydantic is responsible for FastAPI’s phenomenal developer experience. Pydantic
    is fundamental to FastAPI, and leveraging its powerful capabilities opens up the
    playing field for all FARM stack developers.
  prefs: []
  type: TYPE_NORMAL
- en: While type checking is performed statically (without running the code), the
    role of Pydantic is apparent during runtime and performs the role of a guardian
    of inbound data. Your FastAPI application will receive data from users, from a
    flexible MongoDB database schema, and from other systems via APIs—and Pydantic
    will facilitate the parsing and data validation. Instead of crafting complex validation
    logic for every possible invalid case, you will simply create Pydantic models
    of desired complexity, matching your application’s needs as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will explore most of functionality of Pydantic
    through examples with increasing complexity and demands as we feel that it is
    the best and most effective way of familiarizing yourself with the library.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike some other libraries that provide similar functionality (such as `dataclasses`),
    Pydantic provides a base model (aptly named `BaseModel`) that enables the parsing
    and validation functionality through inheritance. Since you will be building a
    user model in the coming sections, you can start by jotting down the most basic
    data that needs to be associated with your user. At the minimum, you will need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An email address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An ID (keep it as an integer for now)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A date of birth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Pydantic, a user model that would be associated with this specification
    could look like the following, in a file called `chapter3_05.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `User` class already handled a lot of work for you—there is no need to perform
    validation checks as the instantiation of the class performs the validation and
    parsing immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of constructing the class is pretty straightforward: each field
    has a type declaration, and Pydantic is ready to inform you of any erroneous types
    it might encounter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try and create a user, you shouldn’t see any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Say however, you create a user with the wrong data, and conveniently import
    the Pydantic `ValidationError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Pydantic will inform you that the data cannot be validated when you run the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The error messages of Pydantic, derived from `ValidationError`, are deliberately
    informative and precise. The field with an error is called `id` and the type of
    error is described. The first useful aspect that comes to mind is that if there
    were several errors—for instance, you might provide an invalid `datetime`—Pydantic
    will not stop at the first error. It will continue parsing the entire instance
    and outputting the list of errors that can easily be output in JSON format. That
    is actually the desired behavior when working with APIs; you want to be able to
    list all the errors, for instance, to a user that has sent the wrong data to the
    backend. The exception contains a list of all the encountered errors.
  prefs: []
  type: TYPE_NORMAL
- en: The model guarantees that the instance, once validation is passed, will have
    the required fields and that they are of the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also provide defaults and nullable types, according to the type hinting
    conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous model has a default `id` value (which is not something that you
    would want to do in practice) and a list of favorite colors as strings, which
    can also be `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create and print a model (or more precisely, when you invoke its representation
    via the `print` function), you get a nice output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Pydantic by default operates in a lax mode, which means that it will try to
    coerce the provided types to the ones that are declared in the model. For instance,
    if you pass the user ID as a string `"2"` to the model, there will not be any
    errors, as Pydantic automatically converts the ID to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Although fields are available through the dot notation (`user.id`) and they
    can be easily modified, this is not recommended as the validation rules will not
    be applied. You could instantiate a user with an `id` value of `5`, access `user.id`,
    and set it to a string `"five"`, but that is probably not something you would
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides pure data validation, Pydantic provides other important functionalities
    to your application. Some of the most widely used operations with Pydantic models
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data deserialization**: Ingesting data into the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data serialization**: Outputting validated data from the model into Python
    data structures or JSON'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data modification**: Sanitizing or modifying data on the fly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few sections will look at each of these operations in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Deserialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deserialization refers to the process of providing data to the model, which
    is the input phase, as opposed to the process of serialization, which means outputting
    model data in a desired form. Deserialization is tightly coupled with validation
    as the processes of validation and parsing are performed when instantiating the
    model, although this can be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In Pydantic, the term `ValidationError` type of Pydantic that is raised when
    data cannot be successfully parsed into a model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you have already performed a couple of validations through instantiating
    the Pydantic-based user models, the data to be validated is often passed in the
    form of a dictionary. The following is an example of passing data as a dictionary,
    in a file named `chapter3_06.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another version of your user model and pass it a dictionary of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `.model_validate()` method is a helper that accepts a Python dictionary
    and performs the class instantiation and thus validation. This method creates
    your `user` instance and validates the data types in one step.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `model_validate_json()` accepts a JSON string (useful when working
    with APIs).
  prefs: []
  type: TYPE_NORMAL
- en: There is also a method for constructing a model instance without validation
    with `model_construct()` but this has very specific user cases and is not recommended
    in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to pass data to your simple Pydantic model. The next section
    will take a closer look at the model fields and their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Model fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pydantic fields are based on Python types and setting them to be required or
    nullable and providing default values is intuitive. For instance, to create a
    default value for a field, it is enough to provide it in the model as a value,
    while the nullable field follows the same conventions that you saw in the *Python
    types* sections—by using the older union syntax from the `typing` module, or the
    newer syntax with the pipe operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of another user model in a file named `chapter3_07.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert some default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previously defined `UserModel` class defines a couple of standard string-type
    fields: an account that can have exactly two values or be equal to `None` and
    a nickname that can be a string or `None`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You may use the `model_fields` property to inspect the model as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get a handy list of all the fields belonging to the model with information
    about them including their types and whether they are required:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next section will detail Pydantic-specific types that make working with
    the library easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Pydantic is based on standard Python types such as strings, integers,
    dictionaries, and sets, which makes it very intuitive and straightforward for
    starting, the library also provides a plethora of customizations and solutions
    for common cases. In this section, you will get to know the most useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict types such as `StrictBool`, `StrictInt`, `StrictStr`, and other Pydantic-specific
    types are types that will pass validation only if the validated value belongs
    to these types, without any coercion: a `StrictInt` must be of type `Integer`
    and not `"1"` or `1.0`, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Constrained types provide additional constraints for existing types. For instance,
    `condate()` is a date type with greater than, greater than or equal, less than,
    and less than or equal constraints. `conlist()` wraps the list type and adds length
    validation or can impose a rule that the items contained must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pydantic is not limited to the validation of primitive types such as strings
    and integers. Many additional validators cover the vast majority of uses that
    you might run into while modeling your business logic. For instance, the `email`
    validator validates email addresses and, since it is not part of the core Pydantic
    package, it needs to be installed separately by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Pydantic website (https://docs.pydantic.dev/latest/api/types/) provides
    a comprehensive list of additional validation types that extend the functionalities—lists
    can have a minimum and maximum length, uniqueness can be required, integers can
    be positive or negative, and many more, including CSS color codes, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the simple Python type annotations might suffice in many cases, the real
    power of Pydantic starts to show when you begin to use the `Field` class for the
    fields. The `Field` class is used to customize models and add metadata to the
    model fields.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how you can use the `Field` class for the `UserModel` explored in
    the previous section. Create a file and name it `chapter3_08.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, rewrite your previous `UserModel` with the help of the `Field` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This model is equivalent to the one previously defined without fields. The first
    syntactic difference can be seen in the way default values are provided—the `Field`
    class accepts a default value that is defined explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Fields also provide additional model flexibility, through the use of aliases,
    as you will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Field aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fields allow you to create and use aliases, which is very useful when dealing
    with different systems that need to be compatible with your Pydantic-based data
    definition. Create a file named `chapter3_09.py`. Assume that your application
    uses the `UserModelFields` model for users, but also needs to be able to ingest
    data from another system, maybe through a JSON-based API, and this other system
    sends the data in the following JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This format clearly doesn’t conform to your `UserModelFields` model and aliases
    provide an elegant way of dealing with this incompatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This updated model provides aliases for all the fields that have different
    names, so it is possible to validate your external data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you have used the simple `alias` parameter, but there are other
    options for aliases for serialization or for validation only.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `Field` class enables numeric values to be constrained in
    different ways, which is a feature heavily used in FastAPI. Create a file called
    `chapter3_10.py` and start populating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you need to model a chess event that has the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In this relatively simple class, Pydantic fields introduce some complex validation
    rules that would otherwise be very verbose and cumbersome to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dt`: The `datetime` object of the tournament uses a `default_factory` parameter,
    a function invoked at instantiation time that provides the default value. In this
    case, the value is equal to `datetime.now`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This field has some length constraints, such as the minimum and maximum
    length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of enlisted players is constrained**: It must be greater than
    or equal to 4, less than or equal to 16, and additionally, it must be an even
    number—a multiple of 2—to allow for all players to play in each round.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid` library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: This field is an integer, but this time you apply the `strict` flag,
    which means you override the default behavior of Pydantic and do not allow strings
    like `"3"` to pass validation, even though they could be cast to integers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful page in the Pydantic documentation is dedicated to Fields: https://docs.pydantic.dev/latest/concepts/fields/.
    There are numerous validation options available through the `Field` class, and
    you are encouraged to skim through them before you start your modeling process.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section will detail how to get the data out of the model through the
    process of deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: Serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important task of any parsing and validation library is data serialization
    (or data dumping). It is the process of converting and outputting a model instance
    to a Python dictionary or a JSON-encoded string. The method for generating a Python
    dictionary is `model_dump()`, as demonstrated by the following user model example,
    in a new file called `chapter3_11.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to use email validation in Pydantic, add the following line to the
    `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, re-run the user model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The user model that you are using is a fairly standard one, and, with your
    knowledge of Pydantic fields, you can already understand it. There are a couple
    of new validations, but they are intuitive: the `EmailStr` object imported from
    Pydantic is a string that validates email addresses, while the `password` field
    contains an additional regular expression to ensure that the field contains only
    alphanumeric characters and no spaces. Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of the model and serialize it to a Python dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is a simple Python dictionary:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to dump the model to a JSON representation and omit the password for security
    reasons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is a JSON string with the password omitted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Serialization uses the field names and not the aliases by default, but that
    is another setting that can be easily overridden by setting the `by_alias` flag
    to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an alias used when working with FastAPI and MongoDB is MongoDB’s
    `ObjectId` field, which is mostly serialized as a string. Another useful method
    is `model_json_schema()`, which generates the JSON schema for a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Models can be additionally configured through the `ConfigDict` object, and
    the special field called `model_config`—the name is reserved and mandatory. In
    the following file, called `chapter3_12.py`, you are using the `model_config`
    field to allow populating the model by name and prevent passing additional data
    to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `model_config` field allows for additional configuration of the model.
    For instance, the `extra` keyword refers to additional data fields that are passed
    to the deserialization process: the default behavior is just to ignore this data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we set `extra` to `forbid`, so any additional data passed and
    not declared in the model will throw a validation error. `populate_by_name` is
    another useful setting as it allows us to populate a model by using field names
    and not only aliases, practically mixing and matching. You will see that this
    feature is handy when crafting APIs that have to talk to different systems.
  prefs: []
  type: TYPE_NORMAL
- en: Custom serializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pydantic can provide you with virtually unlimited capabilities when it comes
    to serialization and also provides different serialization methods for Python
    and JSON outputs with the use of the `@``field_serializer` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Python decorators are a powerful and elegant feature that allow you to modify
    or extend the behavior of functions or methods without changing their actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are higher-order functions that take a function as input, add some
    functionality, and return a new, decorated function. This approach promotes the
    reusability, modularity, and separation of concerns in your Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you are going to create a very simple bank account
    model and use different serializers depending on the type of serialization. Your
    requirement is to round the balance to exactly two decimals and, only when serializing
    to JSON, to format the `updated` field according to the ISO format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `chapter3_13.py` and add a simple model for a bank
    account that contains only two fields, the balance and the time of the last account
    update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have added two custom serializers. The first is the balance serializer (as
    denoted by the string `"balance"`), which will always be used. This serializer
    simply rounds the balance to two decimals. The second serializer is used only
    for JSON serialization and returns the date as an ISO-formatted datetime string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you try to populate the model and inspect the serializations, you will see
    how the serializers modified the initial default output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get a similar output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Earlier in this chapter, you saw basic validation provided by Pydantic through
    the mere instantiation of the model class. The next section will discuss the various
    custom validation methods of Pydantic with the help of Pydantic decorators and
    how they can be leveraged to move beyond serialization and provide powerful custom
    validation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Custom data validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to custom field serializers, custom field validators are implemented
    as decorators, with the `@``field_validator` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Field validators are class methods, so they must receive the entire class as
    the first argument, not the instance, while the second value is the name of the
    field to be validated (or a list of fields, or the `*` symbol for all fields).
  prefs: []
  type: TYPE_NORMAL
- en: 'Field validators should return either the parsed value or a `ValueError` response
    (or `AssertionError`) in case the data passed to the validator doesn’t conform
    to the validation rules. As with other Pydantic features, it is much easier to
    start with an example. Create a new file called `chapter3_14.py` and insert the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The validator is run before the class instantiation and accepts the class and
    the name of the validated field as arguments. The `check_title` validator checks
    that the title contains the string `"FARM stack"` and if it doesn’t, it throws
    `ValueError`. Additionally, the validator returns the string in title case, so
    we can perform data transformation as well, at the field level.
  prefs: []
  type: TYPE_NORMAL
- en: While field validators provide great flexibility, they do not consider field
    interactions and the combinations of field values. That is where model validators
    come into play, as the next section will outline.
  prefs: []
  type: TYPE_NORMAL
- en: Model validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful feature when performing validation of web-related data is model
    validation—the possibility to write validation functions at the model level, allowing
    for complex interactions between various fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model validators can run before or after instantiating the model class.
    Again, we will take a look at a rather simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new file and name it `chapter3_15.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose you have a user model with the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The model is simple like the previous ones, and it contains two password fields
    that are required to match to enable the registration of a new user. Additionally,
    you want to impose another validation—the data that comes into the model via deserialization
    must not contain private data (such as a social security number or card number).
    Model validators allow you to perform flexible validations such as this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continuing the previous model, you can write the following model validators
    under the class definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try to validate of the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will be informed of just one error—the one related to the `before` mode,
    stating that private data should not be included.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you comment out or delete the line that sets the `private_data` field and
    re-run the example, the error becomes the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are a couple of new concepts involved in the previous example; you are
    using the `Self` Python type, introduced for denoting instances of the wrapping
    class, so you practically expect the output to be an instance of the `UserModelV`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Another new concept is present in the `check_private_data` function as it checks
    whether the data passed to the class is an instance of a dictionary, and then
    proceeds to verify whether the undesired `private_data` field is present in the
    dictionary—this is just Pydantic’s way of checking for the data passed as it is
    stored inside a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will detail how to compose nested models with Pydantic to validate
    models of increasing complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Nested models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The treatment of nested models in Pydantic through composition is very straightforward
    and intuitive if you are coming from a basic MongoDB background. To understand
    how to implement nested models, the easiest way is to start from an existing data
    structure that needs to be validated and run through Pydantic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the structure of a JSON document that returns car brands and makes
    (or models). Create a new file named `chapter3_16.py` and add the following lines
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can start from the inside of the data structure and begin identifying the
    smallest units or the most deeply nested structures—in this case, the smallest
    unit is the car model (a Ford Mustang from 1964).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This can be the first Pydantic model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this first abstraction is made, it is easy to create a model for the brand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The car brand model has distinct names and countries of origin and contains
    a list of models.
  prefs: []
  type: TYPE_NORMAL
- en: Model fields can be other models (or lists or sets or other sequences thereof)
    and this feature makes mapping Pydantic data structures to data, and especially
    MongoDB documents, a very pleasant and intuitive process.
  prefs: []
  type: TYPE_NORMAL
- en: While MongoDB can support up to 100 levels of nesting, you will probably not
    hit that limit in your data modeling process. However, it’s worth noting that
    Pydantic will support you as you delve deeper and deeper into your data structures.
    Embedding data also becomes much more manageable from the Python side, as you
    can rest assured that data coming into your collections is stored as intended.
  prefs: []
  type: TYPE_NORMAL
- en: The next and final section will detail another useful tool that Pydantic offers—a
    little help with managing environment variables and settings, a problem that you
    face in every web-related project.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pydantic Settings is an external package that needs to be installed separately.
    It provides Pydantic features for loading a settings or config class from environment
    variables or secret files.
  prefs: []
  type: TYPE_NORMAL
- en: That is basically the definition from the Pydantic website ([https://docs.pydantic.dev/latest/concepts/pydantic_settings/](https://docs.pydantic.dev/latest/concepts/pydantic_settings/)),
    and the whole concept revolves around the `BaseSettings` class.
  prefs: []
  type: TYPE_NORMAL
- en: A model that inherits from this class attempts to read the values of any fields
    passed as keyword arguments by scanning the environment.
  prefs: []
  type: TYPE_NORMAL
- en: This simple functionality allows you to define clear and straightforward configuration
    classes from environment variables. Pydantic settings can also automatically pick
    up environment modifications and, when needed, manually override settings for
    testing, development, or production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following exercise, you will create a simple `pydantic_settings` setup
    that will allow you to read environment variables and easily override them in
    case the necessity arises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Pydantic settings with `pip`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `.env` file at the same level as your project files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can set up a simple `Settings` configuration (the `chapter3_17.py`
    file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run this code, both the Python and the `.env` file are on the same path,
    so you will see that Pydantic was able to read the environment variables from
    the `.``env` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, if you set an environment variable, it will take precedence over the
    `.``env` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can test it by adding this line before the `Settings()` call and observing
    the output of the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pydantic Settings makes managing configurations such as your Atlas and MongoDB
    URLs, secrets for hashing passwords, and other configurations much more structured
    and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter detailed aspects of Python that are either new and still evolving,
    or often simply overlooked, such as type hinting, and the implications that their
    use can have on your projects.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is based on Pydantic and type hinting. Working with these solid principles
    and conventions will make your code more robust, maintainable, and future-proof
    even when working with other frameworks. You have a solid Python types foundation
    and have learned the basic functionalities provided by Pydantic—validation, serialization,
    and deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to deserialize, serialize, and validate data through Pydantic,
    and even add some transformations during the process, creating structures of increased
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has equipped you to learn more web-specific aspects of FastAPI
    and to blend data seamlessly between MongoDB, Python data structures, and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore FastAPI and its Pythonic foundations.
  prefs: []
  type: TYPE_NORMAL
