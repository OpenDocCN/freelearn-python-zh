- en: Improving Python Performance with PyPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover PyPy, a compiled version of Python that aims
    to increase the performance of Python programs. We will talk about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is PyPy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is RPython?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an interpreted language. Interpreted languages use middleware to read
    the source code and generate system-specific machine language. Compiled languages
    use a compiler to convert the source code directly into machine language; there
    is no middle step in the process.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of compiled languages is that, without the interpretation step,
    the code is executed directly by the system and yields the fastest processing
    time available. In addition, compilers have the ability to look at the source
    code as it is being converted and apply optimizations to make the machine code
    that much faster.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the compiler is analyzing the source code and sees that code
    spends a large amount of time in a particular loop, it can apply one of several
    optimization algorithms to the code to improve performance, such as breaking a
    single loop into multiple loops that each process a smaller part of the original
    loop's body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, interpreted languages make the life of a programmer easier, as
    the languages tend to be easier to code in and they generally have an interactive
    prompt, allowing a developer to test code before putting it into the final program.
    This leads to another point about interpreted languages: they don''t have a compilation
    step so seeing the results of a program is more or less immediate. If there is
    a bug in the code, the developer knows immediately rather than after the (potentially
    long) compilation. (While most bugs are identified by the compiler during compilation,
    there are some bugs that won''t be caught, such as those identified at [http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/](http://www.learncpp.com/cpp-programming/eight-c-programming-mistakes-the-compiler-wont-catch/).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as a quick example of the possible speed differences that can occur between
    interpreted and compiled languages, here are some times for C++ versus Python
    from [https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&amp;lang2=gpp](https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3&lang2=gpp):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Task** | **Python (secs)** | **C++ (secs)** |'
  prefs: []
  type: TYPE_TB
- en: '| Pi digits | 3.43 | 1.88 |'
  prefs: []
  type: TYPE_TB
- en: '| Reverse complement | 18.79 | 3.08 |'
  prefs: []
  type: TYPE_TB
- en: '| Regex redux | 15.22 | 1.61 |'
  prefs: []
  type: TYPE_TB
- en: '| Mandelbrot | 225.24 | 1.51 |'
  prefs: []
  type: TYPE_TB
- en: What is PyPy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PyPy is an alternative implementation of Python. While normal Python is built
    using the C language (hence the alternative term: CPython), PyPy is built on the
    **RPython** (**Restricted Python**) language . RPython constrains the Python language;
    these constraints mean that PyPy can look at the RPython code, translate it into
    C code, and then compile it to machine code.'
  prefs: []
  type: TYPE_NORMAL
- en: The main aspects of PyPy is the **just-in-time**** (JIT)** compiler. Specifically,
    it uses a tracing JIT, which monitors frequently executed loops and compiles them
    into native machine code. Since programs frequently spend much of their time in
    loops, compiling those loops to native code maximizes the speed at which they
    process data.
  prefs: []
  type: TYPE_NORMAL
- en: Using RPython, the JIT compiler receives known code, that is, the compiler doesn't
    have to spend time parsing the metadata of the code to determine what type an
    object is, how much memory space is taken up, and so on. Thus, it is able to effectively
    convert the CPython code into C code and then to native assembly language for
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'While object types are still inferred, like normal Python, and are not declared
    like statically typed languages, each variable can only have one type associated
    with it and cannot change later in the code. For example, a favorite thing to
    show about Python is that the following are both legitimate variable assignments
    in Python; `x` has no inherited knowledge about itself so it can be changed at
    any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But with RPython, this would not be allowed because, once a variable is declared,
    even if as something like an empty list, it can never change types, for example,
    converting from a list to a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Because it is different from CPython, there may be compatibility issues when
    using PyPy. While their designers strive to provide maximum compatibility between
    the two implementations, there are some known problems ([http://pypy.org/compat.html](http://pypy.org/compat.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main features of PyPy are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Speed: Currently, PyPy is an average of 7.6x faster than CPython ([http://speed.pypy.org](http://speed.pypy.org)).
    Depending on the module, speed improvements can be up to 98%. Note that there
    are two main cases where PyPy will not provide a speed increase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs that are too short for the JIT compiler to warm up. A program has to
    run for a few seconds, so a large number of simple scripts will not benefit from
    PyPy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, if the program isn't running Python code but is working with runtime
    libraries such as C functions (for example, Python is just a glue language between
    blocks of compiled code) you won't notice a performance difference with PyPy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory usage: PyPy programs tend to have better memory management than CPython,
    that is, hundreds of MBs in size. While it isn''t always the case, there may be
    some resource improvement through PyPy, though it depends on the details of the
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stackless support is integrated into PyPy, allowing improved concurrent processing
    support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other languages implement RPython: Prolog, Smalltalk, JavaScript, Io, Scheme,
    Gameboy, Ruby (called Topaz), and PHP (called HippyVM).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A prototype sandbox environment is available for testing. It is designed to
    replace calls to external libraries with a code stub that handles communications
    with an external process that handles the policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing PyPy can be easy or hard, depending on your system. Binaries are
    available ([http://pypy.org/download.html#default-with-a-jit-compiler](http://pypy.org/download.html#default-with-a-jit-compiler))
    for x86, ARM, PowerPC, and s390x CPUs for Windows, macOS, and Linux OSes. In addition,
    Python 2.7 and 3.5 versions are available.
  prefs: []
  type: TYPE_NORMAL
- en: If installing on Linux, binaries are only usable for the distributions they
    are compiled for. Unfortunately, this means that many more recent distribution
    versions are out of luck. For example, the latest Ubuntu version supported is
    16.04, while Windows doesn't have a 64-bit version available. If you don't use
    a binary that is expressly written for your version, you will most likely get
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: If you are running Linux and it isn't one of the distributions listed in the
    downloads site, you have the choice of hacking your distribution to make things
    work, or trying out the portable PyPy binary. Portable PyPy is an attempt to write
    a 64-bit x86-compatible binary for a variety of Linux distributions without requiring
    additional libraries or OS configuration changes. These portable binaries are
    created using Docker, so while they should work without issue, like any technology,
    your mileage may vary.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to PyPy, these portable binaries include `virtenv` to keep everything
    separate, as well as providing OpenSSL, SQLite3, libffi, expat, and Tcl/Tk.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run PyPy, simply go to the location where you placed the binary and call
    PyPy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57cd3fbb-f88f-412a-829e-6c4a19243655.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen, it looks like a standard Python interactive interpreter, so
    you can experiment with your code as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple test to demonstrate how quick PyPy compares with normal Python,
    we will make a couple of files, as well as a C file, to see how well PyPy''s JIT
    compiler compares:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We save the following as `add_funct.py`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following is `loop_funct.py`**:**
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`loop_funct.c` is the C code for comparison:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshots show the timings for each program type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Python:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0e650d5f-ee08-4a28-863c-257b9ca22547.png)'
  prefs: []
  type: TYPE_IMG
- en: 'PyPy:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/651cae91-dd2f-471e-8186-de33f0bc251b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'C:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/48b2e619-bc97-4f20-9372-9aeca4e4f20c.png)'
  prefs: []
  type: TYPE_IMG
- en: The speed increase using PyPy over Python was 99.5%. The speed difference between
    PyPy and C was 97.3%, but comparing C to Python resulted in a 99.9% increase.
    In programs that use human interaction, the difference between C and PyPy times
    is effectively nil, but in long-running, non-interactive programs, that time difference
    adds up. Is it enough to warrant rewriting Python code into C code? Probably not,
    but it might be worth rewriting just the the bottleneck code in C and then passing
    that data into Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`beer_loop.py` shows that PyPy is most effective if it can work on loops that
    execute functions. The following program, while having a long iteration, is essentially
    just a counter. The loop doesn''t call any functions or do much besides print
    strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we time both a normal Python call and PyPy, we''ll see that the times are
    roughly the same:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/39caa66b-8e55-487d-af3a-c2f0f6482892.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is the time for normal Python 3 to run through 1 million
    iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04762c1d-84ed-4c38-8a72-52e886ed5988.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is for PyPy. While there is about a 25% difference
    between the two, the speed improvement with PyPy is nowhere near what is was in
    the results shown in step 4 above (more than 99% speed increase). Even after running
    it a few additional times to see whether having a compiled file already available
    made a difference, this author was not able to improve the results. Hence, while
    PyPy can improve performance on a number of different Python programs, the improvement
    really occurs on functions that are hottest, that is, the functions that are executed
    most often. Thus, one way to maximize performance is to simply make your code
    utilize functions whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of course, there are ways to improve code, such as actually using a loop rather
    than an iterator, but this demonstrates a couple of points:'
  prefs: []
  type: TYPE_NORMAL
- en: Just because PyPy is being used doesn't mean that it will improve program performance.
    Not only do you have to ensure that the PyPy subset of Python commands is utilized,
    it also means that the code has to be written in a manner that utilizes the improvement
    capabilities of PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While maximum performance can be achieved using a compiled language, using PyPy
    means that you don't have to bother rewriting your code very often. Of course,
    if your code is taking a long time to process, but can't be optimized for PyPy,
    then compiling may be your best bet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, writing a C version of the Million Bottles code resulted in a compilation
    time of < 1 second. This is 99 percent faster than PyPy's time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This also points out that it is better to write your code first, then conduct
    performance modeling and identify bottlenecks. Those areas will be the key places
    to focus on, whether it's rewriting in a compiled language or looking into PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The PyPy documentation ([http://pypy.org/performance.html](http://pypy.org/performance.html))
    provides some hints on how to optimize your code prior to refactoring or rewriting
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: Use regression testing. Like any testing code, it requires significant time
    upfront to determine what tests are needed, as well as the actual code writing.
    But the payout comes when refactoring as it allows you to try different optimizations
    without worrying about adding a lot of hidden bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use profilers to actually measure the time of your code overall, as well as
    individual portions. This way, you know exactly where the time sinks are so you
    can focus on those areas, rather than guessing where the bottlenecks are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harking back to parallel processing, be aware of code that is I/O-bound versus
    CPU-bound. I/O-bound code is reliant upon data transfers and benefits most from
    multithreading, rather than significant code optimization; there is only so much
    you can do with your code before the data processing becomes reliant on the speed
    of the I/O connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU-bound code is where you get the most value in terms of refactoring and optimization.
    That's because the CPU has to process a lot of data, so any sort of optimization
    in the code, such as compiling it or parallelizing it, will have an impact on
    the performance speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While you can always rewrite your code in a compiled language, it defeats the
    purpose of using Python. A better technique is to tune your algorithms to maximize
    performance in terms how the data is processed. You will probably go through several
    iterations of tuning and algorithm optimizing as you discover new bottlenecks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller programs are intrinsically faster than larger ones. This is because
    the different levels of cache on CPUs are progressively smaller the closer to
    the core they are, but they are also faster as well. If you can create a program,
    or at least subroutines, that can fit inside a cache space, it will be as fast
    as the cache itself is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller programs imply simpler code, as simple code creates shorter machine
    language opcodes. The problem comes from algorithm tuneup; improving algorithm
    performance generally implies using time-saving but space-filling techniques such
    as pre-computations or reverse maps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is RPython?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPython is the language used to create PyPy. Technically, it is considered a
    translation and support framework for implementing dynamic programming languages,
    separating the language specs from the implementation aspects. This means that
    RPython can be used for other languages besides Python, though it is most commonly
    associated with Python. This also means that any dynamic language will benefit
    from the JIT compiler and allows for a mix-and-match style when making implementation
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: While certain environments have been created in the past to provide abstraction
    between source code and the target system, such as .NET and Java Virtual Machines,
    RPython uses a subset of CPython to create languages that act as simple interpreters,
    with little direct connectivity to low-level, system details. The subsequent toolchain
    creates a solid virtual machine for a designated platform by using the appropriate
    lower-level aspects as needed. This allows further customization of features and
    platform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing languages, developers have to contend with the languages themselves,
    the platforms that will run the languages, and the design decisions made during
    development. The overriding goal of PyPy and RPython development is to make it
    so that these development variables can be modified independently. Thus, the language
    used can be modified or replaced, the platform-specific code can be optimized
    to meet different model needs and desired trade-offs, and the translator backends
    can be written to target different physical and virtual platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, while a framework such as .NET tries to create a common environment for
    developers to target, PyPy strives to allow developers to essentially do whatever
    they want, however they want. JIT compilers are one way to do this, as they are
    made in a language-independent manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPython is not designed for writing programs, as such, but is designed for writing
    software interpreters. If you want to speed up your Python code, then just use
    PyPy. RPython's sole purpose is to allow development of dynamic language interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: In the light of the preceding tip, this section won't walk through the normal
    code examples. We will cover the differences between RPython and Python, just
    so you understand what is meant by RPython being a subset of Python, and possibly
    some of the considerations necessary if you are looking to write an interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Flow restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables should only contain values that are only one type at each control
    point. In other words, when combining paths of control, for example, `if...else`
    statements, using the same variable name for two different types of values, for
    example, a string and an integer, must be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All global values within a module are considered constants and can't change
    while the program is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All control structures are allowed but `for` loops are restricted to built-in
    types and generators are heavily restricted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `range` and `xrange` functions are treated equally, though `xrange` fields
    are not accessible to Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining classes or functions at runtime is prohibited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While generators are supported, their scope is limited and you cannot merge
    different generators at a single control point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions are fully supported. However, the generation of exceptions is slightly
    different compared to regular Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integers, floats, and booleans all work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most string methods are implemented but, of the ones that are implemented, not
    all arguments are accepted. String formatting is limited, as is Unicode support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples must be a fixed length and list-to-tuple conversion is not handled in
    a general way, as there is no way for RPython to determine, non-statically, what
    the length of the result would be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are implemented as allocated arrays. Negative and out-of-bounds indexing
    is only allowed in limited cases. Obviously, fixed-length lists will optimize
    better, but appending to lists is relatively quick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries must have unique keys but custom hash functions or custom equality
    will be ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets are not directly supported but can be simulated by creating a dictionary
    and providing the values for each key as `None`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List comprehensions can be used to create allocated, initialized arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions may be declared with default arguments and `*args`, but `**keywords`
    arguments aren't allowed. Generally speaking, functions operate normally but care
    must be taken when calling a function with a dynamic number of arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most built-in functions are available, but their support may be different from
    expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes are supported, as long as methods and attributes don't change after
    startup. Single inheritance is fully supported, but not multiple inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General object support is provided for, so creating custom objects shouldn't
    run into significant problems. However, only a limited set of special methods,
    for example, `__init__`, are available to custom objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because integers are implemented differently between Python 2 and Python 3,
    normal integers are used for signed arithmetic. This means that, prior to translation,
    *longs* are used in the case of overflow but, after translation, silent wraparound
    occurs. However, in cases where more control is necessary, the following functions
    and class are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ovfcheck()`: Should only be used when a single arithmetic operation is used
    as the argument. This function will perform its operation in overflow-checking
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intmask()`: Used for wraparound arithmetic and returns the lower bits of its
    argument, masking anything that isn''t part of a C signed-long-int. This allows
    Python to convert from a `long` from a previous operation to an `int`. Code generators
    ignore this function, as they conduct wraparound, signed arithmetic by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r_uint`: This class is a pure Python implementation of native machine-sized,
    unsigned integers that silently wrap around. This is provided to allow consistent
    typing by utilizing `r_uint` instances throughout the program; all operations
    with these instances will be assumed to be unsigned. Mixing signed integers and
    `r_uint` instances results in unsigned integers. To convert back to signed integers,
    the `intmask()` function should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just for clarification, RPython is not a compiler. It is a development framework,
    as well as a programming language, specifically a subset of regular Python. PyPy
    uses RPython as its programming language to implement a JIT compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Some real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are more examples of how PyPy can improve performance, as well as some
    practical uses of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code (`time.py`*)* uses the Pythagorean Theorem to calculate
    the hypotenuse for a number of triangles with increasing side lengths:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code (`time2.py`) does the same thing as `pythag_theorem.py`
    but puts the calculations within a function, rather than performing the calculation
    in line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the time-to-complete differences between regular
    Python and PyPy, for both `time.py` and `time2.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aea3ff84-b35c-4fda-b1a4-1842a14c9fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: The times for Python for both inline and function calls are within a second
    of each other. The difference for PyPy between the two calculations is the same,
    but there is a 96% speed improvement between PyPy and Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'This demonstrates two main things:'
  prefs: []
  type: TYPE_NORMAL
- en: Python takes a performance hit when calling functions, due to the overhead costs
    involved in looking up the function and calling the function
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: PyPy can have a significant effect when allowed to optimize code that is repeatedly
    called
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we modify the code so both `time.py` and `time2.py` are only run once, that
    is, `TIMES=1`, the following results occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d3d3ec3-65c2-45c5-957b-f1b064583c62.png)'
  prefs: []
  type: TYPE_IMG
- en: With one pass through the code, the time for Python is functionally equivalent
    for both inline and function calls. Also, the overhead required by PyPy to compile
    the code, then process it, leads to a longer time-to-process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to the other extreme, we change the count to 1 billion and run the programs
    again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is regular Python, running `time.py`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a13b72fc-acc8-472a-965f-1ff579d9764f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is regular Python, running `time2.py`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/ed5c52d0-8072-4121-8885-19151b46075e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is PyPy, running `time.py`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/30b32837-fa8d-413f-8a77-8882db5a6854.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is PyPy, running `time2.py`:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/a683124a-6d82-44cc-bcfc-b7da52965944.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first screenshot is the time for Python to complete `time.py`: nearly 14.5
    minutes. By having to deal with function calls, the second screenshot shows that
    Python''s time increases to nearly 17 minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: By comparison, PyPy didn't really seem to care too much. The third and fourth
    screenshots both show nearly the same time, less than 1 minute. Considering that
    we calculated 1 billion Pythagorean equations, that is an outstanding time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A real-world example is calculating the Great Circle distance, a common calculation
    for navigation to determine the shortest distance between two points on a sphere.
    `great_circle.py` was created using the formula from Wikipedia ([https://en.wikipedia.org/w/index.php?title=Great-circle_distance&amp;oldid=819870157](https://en.wikipedia.org/w/index.php?title=Great-circle_distance&oldid=819870157)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's worth pointing out that we are using some of the `math` module functions.
    In the interests of full disclosure, this author forgot to account for the use
    of radians initially, and the result was off by 1,300.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set up a loop to calculate the distance between the same two points,
    much like the previous example. In this case, we used 1 billion again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8da03b73-15f3-4592-8a07-6ac8a8fe4a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: The time differences here work out to a 97% improvement with PyPy.
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting comparison, we will rewrite the Great Circle code to use multiprocessing.
    This was done because there are no I/O operations occurring, so multithreading
    wouldn't do much good in a CPU-intensive operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is just a simple test, the code is not optimized in any fashion. It
    just creates a pool of eight workers and calls the `great_circle()` function in
    an asynchronous fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'So as to not drag out the time, only 1 million function calls were made for
    this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87445af2-c8e2-4095-945f-d58cdde971f8.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the multiprocessing call was performed first, with a time of
    nearly 45 seconds. The code was modified to remove the multiprocessing calls and
    ran with normal Python and PyPy, resulting in times of nearly 1.5 seconds and
    0.5 seconds, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The multiprocessing example demonstrates that, while multiprocessing is useful
    in some situations, considerable effort must be made to optimize the program to
    best utilize multiprocessing. In addition, multiprocessing can be slower than
    single thread operations because each process must be started anew, much like
    the function call overhead.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the problem of each process taking over a CPU core. While this
    helps with the parallelization of code processing, it means that the core is essentially
    locked until the processing is done.
  prefs: []
  type: TYPE_NORMAL
- en: For counts under than 1 million, multiprocessing performed well. At 100,000
    calls, the total time was just under 4 seconds. At 10,000 calls, the time was
    less than 0.5 seconds, which is comparable to PyPy's time.
  prefs: []
  type: TYPE_NORMAL
- en: However, when attempting to run this code with the original 1  billion calls,
    this author's computer (with eight cores) locked up hard. After attempting to
    kill the process, the computer finally released the lock after 1.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple reasons why the multiprocessing code caused this. The main
    part is that it isn't well optimized and simply tries to call the function as
    resources are available. Each process takes up both CPU cycles and memory space,
    so there eventually comes a point when new processes have to wait for resources
    to become available.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, serial processing, such as Python or PyPy, don't have this
    overhead problem and can simply plug and chug to process the code. Even on multiple
    calls, they are still able to process quickly. Of course, this is a more or less
    artificial test and real-world projects will vary considerably as to which method
    is best.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this gives a good demonstration of the capabilities of PyPy and
    how it compares to multiprocessing. Combining PyPy with multiprocessing may work
    but, based on readings, it looks like the PyPy community isn't interested in improving
    performance for parallel processing, so your results will vary.
  prefs: []
  type: TYPE_NORMAL
