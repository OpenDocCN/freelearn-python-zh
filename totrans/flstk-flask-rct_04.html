<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor086"/>4</h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor087"/>Fetching Data with React APIs</h1>
<p>Over the past few years, there has been an increase in the demand for database-driven web applications. This increase is a consequence of the abundance of data available at this present time. With widespread internet adoption, businesses leverage web applications to interact with customers, employees, and other stakeholders.</p>
<p>More than ever, web developers are constantly faced with tasks such as the organization and consumption of data. Both internal and external data require us to have smart and business-oriented database-driven web applications.</p>
<p>As a full stack software engineer, some of your frontend tasks will be to consume data, either from an internally developed API or a third-party API. Before we delve into approaches or tools you can use to fetch data in React projects, let’s briefly discuss what APIs are all about and why they are redefining ways of building user interfaces and web applications.</p>
<p><a id="_idTextAnchor088"/>An API simply allows communication among systems using a set of rules in a standard accepted format. In web development, HTTP protocols define the set of rules for web-based systems communication. HTTP is a data exchange protocol used to fetch resources across the internet.</p>
<p>There are two major formats for <a id="_idIndexMarker215"/>exchanging data: <strong class="bold">XML</strong> and <strong class="bold">JSON</strong>. JSON is winning the popularity contest between these two widely used formats for data exchange. JSON is<a id="_idIndexMarker216"/> specifically designed for data interchange, handles arrays seamlessly, and is used widely among developers.</p>
<p>In the React ecosystem, developers have access to a range of exposed interfaces designed to facilitate data fetching from various sources. These APIs are aimed at empowering React developers to create intuitive user interfaces and enhance the overall user experience when interacting with web applications.</p>
<p>In this chapter, we are going to learn about some of the methods and techniques used in React frontend development to fetch data from disparate sources. In this chapter, we will be covering the following topics:</p>
<ul>
<li>Fetching data using the Fetch API in React</li>
<li>Fetching data using <code>async/await</code> syntax</li>
<li>Fetching data using Axios</li>
<li>Fetching data using React Query</li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor089"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor090"/>Fetching data using the Fetch API in React</h1>
<p><strong class="bold">Fetch API</strong> is an<a id="_idIndexMarker217"/> inbuilt API in a web browser that provides the JavaScript interface for communication over the internet using HTTP. Every web browser has a JavaScript engine as a runtime to compile and run JavaScript code.</p>
<p>The<a id="_idIndexMarker218"/> React ecosystem relies inarguably on JavaScript. This is a fact and one of the reasons you are expected to understand modern JavaScript before delving into React application development.</p>
<p>As a React<a id="_idIndexMarker219"/> developer, you will need network resources to build web applications. The <code>fetch()</code> method provides you with the means to access and manipulate HTTP object requests and HTTP protocol responses. Let’s say that in our web application, we want to display the list of conference speakers and their associated data. This information is housed in another resource database server.</p>
<p>From a third-party public API, we are going to consume the user’s resource to fetch hypothetical data to be used in our React application as follows:</p>
<pre class="source-code">import React, { useEffect, useState } from 'react';const App = () =&gt; {
  const [data, setData] = useState([]);
  const getSpeakers = ()=&gt;{
    fetch("https://jsonplaceholder.typicode.com/users")
       .then((response) =&gt; response.json())
       .then((data) =&gt; {
         setData( data);
       })
    }
    useEffect(() =&gt; {
      getSpeakers()
    },[]);
    return (
      &lt;&gt;
        &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;
        &lt;ul&gt;
          {data.map(speaker =&gt; (
            &lt;li key={speaker.id}&gt;
              {speaker.name},  &lt;em&gt; {speaker.email} &lt;/em&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/&gt;
    );
};
export default App;</pre>
<p>Let’s discuss<a id="_idIndexMarker220"/> the preceding <code>fetch</code> data snippet in detail:</p>
<ul>
<li><code>import React, { useEffect, useState } from 'react'</code>: This line imports React’s core functions and some Hooks for use in our component.</li>
<li>Initializing the <code>useState</code>: We initialize our state by calling <code>useState</code> in our component as follows:<pre class="source-code">const [data, setData] = useState([]);//using a destructuring array to write concise code.</pre><p class="list-inset">The <code>useState</code> accepts<a id="_idIndexMarker221"/> an initial state of an empty array (<code>useState([])</code>) and returns two values, <code>data</code> and <code>setData</code>:</p><ul><li><code>data</code>: The current state</li>
<li><code>setData</code>: State updater function (this function is responsible for the new state of the initial state)</li>
</ul></li>
<li><code>useState([])</code> is <code>useState</code> with the initial value of empty array<code>[]</code></li>
<li>The<a id="_idIndexMarker222"/> following snippet has a global <code>fetch()</code> method that accepts the URL of the endpoint, <code>https://jsonplaceholder.typicode.com/users</code>, where we have the hypothetical resource for speakers:<pre class="source-code">const getSpeakers = ()=&gt;{  fetch("https://jsonplaceholder.typicode.com/users")    .then((response) =&gt; response.json())    .then((data) =&gt; {      setData( data);    })</pre><p class="list-inset">The URL in the preceding code is our resource endpoint. It returns JSON as data. <code>setData()</code> accepts the new state, which is the returned data in JSON.</p></li>
<li>The <code>useEffect</code> Hook is used to invoke the <code>getSpeaker</code> function:<pre class="source-code">useEffect(() =&gt; {getSpeakers()    },[]);</pre></li>
<li><code>map()</code> is invoked on the data array and used to iterate on the speakers’ data to display details on the screen:<pre class="source-code">{data.map(speaker =&gt; (        &lt;li key={speaker.id}&gt;          {speaker.name},  &lt;em&gt; {speaker.email} &lt;/em&gt;        &lt;/li&gt;      ))}</pre></li>
</ul>
<p>In<a id="_idIndexMarker223"/> sum, <code>fetch()</code> accepts the resource URL (<a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a>) as an argument, which is the path to the <a id="_idIndexMarker224"/>resource over the network we are interested in, and returns to a promise that moves to the status of fulfilled once the requested resource response is available.</p>
<p class="callout-heading">Note</p>
<p class="callout">In real-world applications, it’s crucial to manage network errors effectively, especially when data retrieval encounters issues or when the absence of data occurs. Additionally, implementing a loading state can significantly enhance the overall user experience.</p>
<p>Next, we are going to look at another technique for fetching data in React projects using <code>async/await</code> using the ECMAScript 2017 feature.</p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor091"/>Fetching data using async/await syntax</h1>
<p>There are <a id="_idIndexMarker225"/>three ways to write asynchronous codes in<a id="_idIndexMarker226"/> vanilla JavaScript: callbacks, promises, and <code>async/await</code>. In this section, we are going to focus on <code>async</code> <code>/await</code> and see how it can be used in React web applications. <code>async/await</code> is an improvement on promises.</p>
<p>The <a id="_idIndexMarker227"/>following snippet explains how <code>async/await</code> can <a id="_idIndexMarker228"/>be used to fetch data from an API using a promise-based approach:</p>
<pre class="source-code">import React, { useEffect, useState } from 'react';const App = () =&gt; {
    const [data, setData] = useState([]);
    const API_URL = "https://dummyjson.com/users";
    const fetchSpeakers = async () =&gt; {
        try {
            const response = await fetch(API_URL);
            const data = await response.json();
            setData(data.users);
        } catch (error) {
            console.log("error", error);
        }
    };
    useEffect(() =&gt; {
        fetchSpeakers();
    },[]);
    return (
      &lt;&gt; [Text Wrapping Break]
           &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;
[Text Wrapping Break]
           &lt;ul&gt;
               {data.map(item =&gt; (
                   &lt;li key={item.id}&gt;
                       {item.firstName} {item.lastName}
                   &lt;/li&gt;
               ))}
           &lt;/ul&gt;
      &lt;/&gt;
    );
};
export default App;</pre>
<p>Let’s discuss<a id="_idIndexMarker229"/> the preceding code snippet, which <a id="_idIndexMarker230"/>demonstrates how to use <code>async/await</code> to fetch data asynchronously:</p>
<ul>
<li><code>import React, { useEffect, useState } from 'react'</code>: This line imports React core functions and some Hooks for use in our component.</li>
<li>Initializing the <code>useState</code>: We initialize our state by calling <code>useState</code> in our component as follows:<pre class="source-code">const [data, setData] = useState([]);//using a destructuring array to write a concise code.</pre><p class="list-inset"><code>useState</code> accepts an initial state of empty array (<code>useState([])</code>) and returns two values, <code>data</code> and <code>setData</code>:</p><ul><li><code>data</code>: The current state</li>
<li><code>setData</code>: State updater function (this function is responsible for the new state of the initial state)</li>
</ul></li>
<li><code>useState([])</code> is <code>useState</code> with<a id="_idIndexMarker231"/> the initial value of empty array<code>[]</code>.<pre>const API_URL = "https://dummyjson.com/users";  const fetchSpeakers = async () =&gt; {      try {          const response = await fetch(API_URL);          const data = await response.json();          setData(data.users);      } catch (error) {          console.log("error", error);      }  };</pre><p class="list-inset">We have the hypothetical resource for speakers in the preceding endpoint. This is our resource endpoint. It returns JSON as data. <code>setData()</code> accepts the new state, which is the returned data in JSON.</pre></li>
<li>The <code>useEffect</code> Hook <a id="_idIndexMarker233"/>is used to invoke the <code>fetchSpeakers</code> function, which fetches <a id="_idIndexMarker234"/>data asynchronously from the endpoint <code>const API_URL = "</code><a href="https://dummyjson.com/users">https://dummyjson.com/users</a><code>"</code>:<pre class="source-code">  useEffect(() =&gt; {        fetchSpeakers();    },[data]);</pre><p class="list-inset">The array dependency is supplied with the data state. When the data state changes, maybe because of the addition or removal of speakers in the list, the component re-renders and shows the updated state.</p></li>
<li>Finally, <code>map()</code> is invoked on the data, and it is used to iterate on the speakers’ data to render details to the screen:<pre class="source-code">return (        &lt;&gt;        &lt;ul&gt;      {data.map(item =&gt; (        &lt;li key={item.id}&gt;          {item.firstName} {item.lastName}        &lt;/li&gt;      ))}    &lt;/ul&gt;</pre></li>
</ul>
<p>The <code>async/await</code> approach<a id="_idIndexMarker235"/> of fetching data gives your codes better organization and improves the responsiveness and performance of your React applications. The non-blocking <a id="_idIndexMarker236"/>mode of <code>async/await</code> means you can carry on with the rest of the code operations while you await responses from a large amount of data running tasks.</p>
<p>Next, we are going to look at another approach for fetching data from an API, using a third-party npm package called Axios.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor092"/>Fetching data using Axios</h1>
<p><strong class="bold">Axios</strong> is<a id="_idIndexMarker237"/> simply a lightweight JavaScript, promise-based HTTP client used to consume API services. It is <a id="_idIndexMarker238"/>mainly used in the browser and Node.js. To use Axios in our project, open the project terminal and type the following:</p>
<pre class="console">npm install axios</pre>
<p>Now, let’s see how<a id="_idIndexMarker239"/> to use Axios in the following code snippet:</p>
<pre class="source-code">import React, { useEffect, useState } from 'react';import axios from 'axios';
const App = () =&gt; {
    const [data, setData] = useState([]);
    const getSpeakers = ()=&gt;{
        axios.get(
            "https://jsonplaceholder.typicode.com/users")
            .then(response =&gt; {
                setData(response.data)
            })
    }
    useEffect(() =&gt; {
        getSpeakers()
    },[]);
    return (
        &lt;&gt;
           &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;
           &lt;ul&gt;
               {data.map(speaker =&gt; (
                   &lt;li key={speaker.id}&gt;
                       {speaker.name},  &lt;em&gt;
                           {speaker.email} &lt;/em&gt;
                   &lt;/li&gt;
               ))}
           &lt;/ul&gt;
        &lt;/&gt;
    );
};
export default App;</pre>
<p>Let’s examine <a id="_idIndexMarker240"/>the <a id="_idIndexMarker241"/>preceding code snippet to see how Axios can be used in data fetching:</p>
<ul>
<li><code>import React, { useEffect, useState } from 'react'</code>: This line imports React core functions and some Hooks for use in our component.</li>
<li><code>import axios from "axios"</code>: This line brings in the already installed Axios package for use in the project.</li>
<li>Initializing <code>useState</code>: We initialize our state by calling <code>useState</code> in our component<a id="_idIndexMarker242"/> as follows:<pre class="source-code">const [data, setData] = useState([]);//using a destructuring array to write a concise code.</pre></li>
<li><code>useState</code> accepts an initial state of an empty array (<code>useState([])</code>) and returns two values, <code>data</code> and <code>setData</code>:<ul><li><code>data</code>: The current state</li>
<li><code>setData</code>: State updater function (this function is responsible for the new state of the initial state)</li>
</ul></li>
<li><code>useState([])</code> is <code>useState</code> with the initial value of empty array<code>[]</code>.<pre>const getSpeakers = ()=&gt;{    axios.get(        "https://jsonplaceholder.typicode.com/users")        .then(response =&gt; {            setData(response.data)        })}</pre><p class="list-inset">This is our resource endpoint. It returns JSON as data. The <code>setData()</code> accepts the new state, which is the returned data in JSON.</pre><p class="list-inset">The <code>getSpeakers</code> function uses <code>axios.get()</code> to fetch external data from the endpoint and return <a id="_idIndexMarker244"/>a promise. The state value is updated, and we have a new state in <code>setData</code> from the response object:</p><pre class="source-code">useEffect(() =&gt; {getSpeakers()    },[]);</pre></li>
<li>The <code>useEffect</code> Hook is <a id="_idIndexMarker245"/>used to call <code>getSpeaker()</code> and renders the component:<pre class="source-code">&lt;ul&gt;    {data.map(speaker =&gt; (        &lt;li key={speaker.id}&gt;            {speaker.name},  &lt;em&gt; {speaker.email}                &lt;/em&gt;        &lt;/li&gt;    ))}&lt;/ul&gt;</pre><p class="list-inset">Finally, <code>map()</code> is used to iterate on the speakers’ data and display names and emails on the screen.</p></li>
</ul>
<p>Moving on to data fetching techniques in React, we are going to look at another approach to fetching data using React Query.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor093"/>Fetching data using the React Query in React</h1>
<p><strong class="bold">React Query</strong> is an<a id="_idIndexMarker246"/> npm package library created for data fetching purposes with a ton of functionalities loaded with it. In<a id="_idIndexMarker247"/> React Query, the state management, pre-fetching of data, request retries, and caching are handled out of the box. React Query is a critical component of the React ecosystem with over a million downloads weekly.</p>
<p>Let’s refactor <a id="_idIndexMarker248"/>the code snippet we used in the <em class="italic">Fetching data using Axios</em> section and experience the awesomeness of React Query:</p>
<ol>
<li>First, install <a id="_idIndexMarker249"/>React Query. In the root directory of the project, do the following:<pre class="source-code"><strong class="bold">npm install react-query</strong></pre></li>
<li>Inside <code>App.js</code>, add the following:<pre class="source-code">import {useQuery} from 'react-query'import axios from 'axios';function App() {  const{data, isLoading, error} = useQuery(    "speakers",    ()=&gt;{ axios(      "https://jsonplaceholder.typicode.com/users")  );  if(error) return &lt;h4&gt;Error: {error.message},    retry again&lt;/h4&gt;  if(isLoading) return &lt;h4&gt;...Loading data&lt;/h4&gt;  console.log(data);  return (      &lt;&gt;         &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;         &lt;ul&gt;             {data.data.map(speaker =&gt; (                 &lt;li key={speaker.id}&gt;                     {speaker.name},  &lt;em&gt;                         {speaker.email} &lt;/em&gt;                 &lt;/li&gt;             ))}         &lt;/ul&gt;      &lt;/&gt;  );}export default App;</pre></li>
</ol>
<p>Check the<a id="_idIndexMarker250"/> preceding <em class="italic">Fetching data using Axios</em> section<a id="_idIndexMarker251"/> to compare the code snippet. The React Query snippet is way shorter and more concise. The need for <code>useState</code> and <code>useEffect</code> Hooks have been handled out of the box by the <code>useQuery()</code> Hook.</p>
<p>Let’s dissect the preceding code:</p>
<ul>
<li><code>useQuery</code> accepts two arguments: the query key (<code>speakers</code>) and a callback function that uses <code>axios()</code> to fetch a hypothetical speaker from the resource endpoint.</li>
<li><code>useQuery</code> is destructured with variables – <code>{data, isLoading, error}</code>. We then check to see whether there is an error message coming from the error object.</li>
<li>Once we have data, then the <code>return()</code> function returns an array of speakers’ data.</li>
</ul>
<p>Inside <code>index.js</code>, add the following code. The existing <code>index.js</code> codes are presumed present:</p>
<pre class="source-code">import { QueryClient, QueryClientProvider } from    react-query";
const queryClient = new QueryClient();
root.render(
    &lt;QueryClientProvider client={queryClient}&gt;
        &lt;App /&gt; &lt;/QueryClientProvider&gt;
);</pre>
<p>Let’s <a id="_idIndexMarker252"/>have <a id="_idIndexMarker253"/>some explanation of the code snippet in <code>index.js</code>:</p>
<ul>
<li>Import the <code>{ QueryClient, QueryClientProvider }</code> from React Query: <code>QueryClient</code> allows us to leverage the global defaults for all queries and mutations in React Query. The <code>QueryClientProvider</code> connects and provides a <code>QueryClient</code> to the application.</li>
<li>Create a new <code>QueryClient</code> instance, <code>queryClient</code>: Wrap your component with <code>QueryClientProvider</code>—in this case, <code>&lt;App</code> <code>/&gt;</code> is the component—and pass the new instance as an attribute value.</li>
</ul>
<p>Now run <code>npm start</code> if <code>localhost:3000</code> is not running. The following should be displayed on the screen:</p>
<div><div><img alt="Figure 4.1 – Screenshot showing the usage of React Query in fetching data" src="img/Figure_4.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Screenshot showing the usage of React Query in fetching data</p>
<p>React Query is <a id="_idIndexMarker254"/>very effective at fetching data from API resources. It encapsulates functions that may be required by <code>useState</code> and <code>useEffect</code>. React Query radically redefines the way we fetch data in React applications by introducing a powerful caching mechanism with the <code>queryKey</code>.</p>
<p>Instead<a id="_idIndexMarker255"/> of manually managing data fetching and caching, React Query handles it transparently. React Query allows developers to easily fetch and cache data with just a few lines of code, reducing boilerplate and improving performance.</p>
<p>The library provides various Hooks and utilities that simplify data fetching, error handling, and data synchronization with the server, leading to a more efficient and seamless user experience. Exploring React Query further can open up a world of possibilities in handling complex data fetching scenarios and optimizing data management in React applications.</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor094"/>Summary</h1>
<p>Handling data is a critical component of any web application. React has proven to be very efficient and scalable in handling data at scale. In this chapter, we discussed various approaches you can utilize in your project to handle data fetching. We discussed fetching data using the Fetch API, <code>async/await</code>, Axios, and React Query.</p>
<p>In the next chapter, we are going to discuss JSX and how you can display lists in React.</p>
</div>
</body></html>