<html><head></head><body>
<div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-62"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-63"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.2.1">Fetching Data with React APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Over the past few years, there has been an increase in the demand for database-driven web applications. </span><span class="koboSpan" id="kobo.3.2">This increase is a consequence of the abundance of data available at this present time. </span><span class="koboSpan" id="kobo.3.3">With widespread internet adoption, businesses leverage web applications to interact with customers, employees, and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">other stakeholders.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">More than ever, web developers are constantly faced with tasks such as the organization and consumption of data. </span><span class="koboSpan" id="kobo.5.2">Both internal and external data require us to have smart and business-oriented database-driven </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">As a full stack software engineer, some of your frontend tasks will be to consume data, either from an internally developed API or a third-party API. </span><span class="koboSpan" id="kobo.7.2">Before we delve into approaches or tools you can use to fetch data in React projects, let’s briefly discuss what APIs are all about and why they are redefining ways of building user interfaces and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">web applications.</span></span></p>
<p><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.9.1">An API simply allows communication among systems using a set of rules in a standard accepted format. </span><span class="koboSpan" id="kobo.9.2">In web development, HTTP protocols define the set of rules for web-based systems communication. </span><span class="koboSpan" id="kobo.9.3">HTTP is a data exchange protocol used to fetch resources across </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">There are two major formats for </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.12.1">exchanging data: </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">XML</span></strong><span class="koboSpan" id="kobo.14.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">JSON</span></strong><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">JSON is winning the popularity contest between these two widely used formats for data exchange. </span><span class="koboSpan" id="kobo.16.3">JSON is</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.17.1"> specifically designed for data interchange, handles arrays seamlessly, and is used widely </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">among developers.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In the React ecosystem, developers have access to a range of exposed interfaces designed to facilitate data fetching from various sources. </span><span class="koboSpan" id="kobo.19.2">These APIs are aimed at empowering React developers to create intuitive user interfaces and enhance the overall user experience when interacting with </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we are going to learn about some of the methods and techniques used in React frontend development to fetch data from disparate sources. </span><span class="koboSpan" id="kobo.21.2">In this chapter, we will be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Fetching data using the Fetch API </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">in React</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Fetching data using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">async/await</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1"> syntax</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Fetching data </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">using Axios</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Fetching data using </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">React Query</span></span></li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.32.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.33.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04"><span class="No-Break"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter04</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.36.1">.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.37.1">Fetching data using the Fetch API in React</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.38.1">Fetch API</span></strong><span class="koboSpan" id="kobo.39.1"> is an</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.40.1"> inbuilt API in a web browser that provides the JavaScript interface for communication over the internet using HTTP. </span><span class="koboSpan" id="kobo.40.2">Every web browser has a JavaScript engine as a runtime to compile and run </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">JavaScript code.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">The</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.43.1"> React ecosystem relies inarguably on JavaScript. </span><span class="koboSpan" id="kobo.43.2">This is a fact and one of the reasons you are expected to understand modern JavaScript before delving into React </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">application development.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">As a React</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.46.1"> developer, you will need network resources to build web applications. </span><span class="koboSpan" id="kobo.46.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">fetch()</span></strong><span class="koboSpan" id="kobo.48.1"> method provides you with the means to access and manipulate HTTP object requests and HTTP protocol responses. </span><span class="koboSpan" id="kobo.48.2">Let’s say that in our web application, we want to display the list of conference speakers and their associated data. </span><span class="koboSpan" id="kobo.48.3">This information is housed in another resource </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">database server.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">From a third-party public API, we are going to consume the user’s resource to fetch hypothetical data to be used in our React application </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.52.1">import React, { useEffect, useState } from 'react';const App = () =&gt; {
  const [data, setData] = useState([]);
  const getSpeakers = ()=&gt;{
    fetch("https://jsonplaceholder.typicode.com/users")
       .then((response) =&gt; response.json())
       .then((data) =&gt; {
         setData( data);
       })
    }
    useEffect(() =&gt; {
      getSpeakers()
    },[]);
    return (
      &lt;&gt;
        &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;
        &lt;ul&gt;
          {data.map(speaker =&gt; (
            &lt;li key={speaker.id}&gt;
              {speaker.name},  &lt;em&gt; {speaker.email} &lt;/em&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      &lt;/&gt;
    );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.53.1">Let’s discuss</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.54.1"> the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">fetch</span></strong><span class="koboSpan" id="kobo.56.1"> data snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">in detail:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">import React, { useEffect, useState } from 'react'</span></strong><span class="koboSpan" id="kobo.59.1">: This line imports React’s core functions and some Hooks for use in </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">our component.</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Initializing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">useState</span></strong><span class="koboSpan" id="kobo.63.1">: We initialize our state by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">useState</span></strong><span class="koboSpan" id="kobo.65.1"> in our component </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.67.1">const [data, setData] = useState([]);//using a destructuring array to write concise code.</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.68.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">useState</span></strong><span class="koboSpan" id="kobo.70.1"> accepts</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.71.1"> an initial state of an empty array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">useState([])</span></strong><span class="koboSpan" id="kobo.73.1">) and returns two values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">data</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.75.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">setData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">data</span></strong><span class="koboSpan" id="kobo.79.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">current state</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">setData</span></strong><span class="koboSpan" id="kobo.82.1">: State updater function (this function is responsible for the new state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">initial state)</span></span></li>
</ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">useState([])</span></strong><span class="koboSpan" id="kobo.85.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">useState</span></strong><span class="koboSpan" id="kobo.87.1"> with the initial value of </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">empty array</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">[]</span></strong></span></li>
<li><span class="koboSpan" id="kobo.90.1">The</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.91.1"> following snippet has a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">fetch()</span></strong><span class="koboSpan" id="kobo.93.1"> method that accepts the URL of the endpoint, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">https://jsonplaceholder.typicode.com/users</span></strong><span class="koboSpan" id="kobo.95.1">, where we have the hypothetical resource </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">for speakers:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.97.1">const getSpeakers = ()=&gt;{  fetch("https://jsonplaceholder.typicode.com/users")    .then((response) =&gt; response.json())    .then((data) =&gt; {      setData( data);    })</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.98.1">The URL in the preceding code is our resource endpoint. </span><span class="koboSpan" id="kobo.98.2">It returns JSON as data. </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">setData()</span></strong><span class="koboSpan" id="kobo.100.1"> accepts the new state, which is the returned data </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">in JSON.</span></span></p></li>
<li><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">useEffect</span></strong><span class="koboSpan" id="kobo.104.1"> Hook is used to invoke the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">getSpeaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.107.1">useEffect(() =&gt; {getSpeakers()    },[]);</span></pre></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">map()</span></strong><span class="koboSpan" id="kobo.109.1"> is invoked on the data array and used to iterate on the speakers’ data to display details on </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">the screen:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.111.1">{data.map(speaker =&gt; (        &lt;li key={speaker.id}&gt;          {speaker.name},  &lt;em&gt; {speaker.email} &lt;/em&gt;        &lt;/li&gt;      ))}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.112.1">In</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.113.1"> sum, </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">fetch()</span></strong><span class="koboSpan" id="kobo.115.1"> accepts the resource URL (</span><a href="https://jsonplaceholder.typicode.com/users"><span class="koboSpan" id="kobo.116.1">https://jsonplaceholder.typicode.com/users</span></a><span class="koboSpan" id="kobo.117.1">) as an argument, which is the path to the </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.118.1">resource over the network we are interested in, and returns to a promise that moves to the status of fulfilled once the requested resource response </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">is available.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.120.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.121.1">In real-world applications, it’s crucial to manage network errors effectively, especially when data retrieval encounters issues or when the absence of data occurs. </span><span class="koboSpan" id="kobo.121.2">Additionally, implementing a loading state can significantly enhance the overall </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">Next, we are going to look at another technique for fetching data in React projects using </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">async/await</span></strong><span class="koboSpan" id="kobo.125.1"> using the ECMAScript </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">2017 feature.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.127.1">Fetching data using async/await syntax</span></h1>
<p><span class="koboSpan" id="kobo.128.1">There are </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.129.1">three ways to write asynchronous codes in</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.130.1"> vanilla JavaScript: callbacks, promises, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">async/await</span></strong><span class="koboSpan" id="kobo.132.1">. </span><span class="koboSpan" id="kobo.132.2">In this section, we are going to focus on </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">async</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.134.1">/await</span></strong><span class="koboSpan" id="kobo.135.1"> and see how it can be used in React web applications. </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">async/await</span></strong><span class="koboSpan" id="kobo.137.1"> is an improvement </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">on promises.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">The </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.140.1">following snippet explains how </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">async/await</span></strong><span class="koboSpan" id="kobo.142.1"> can </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.143.1">be used to fetch data from an API using a </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">promise-based approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">import React, { useEffect, useState } from 'react';const App = () =&gt; {
    const [data, setData] = useState([]);
    const API_URL = "https://dummyjson.com/users";
    const fetchSpeakers = async () =&gt; {
        try {
            const response = await fetch(API_URL);
            const data = await response.json();
            setData(data.users);
        } catch (error) {
            console.log("error", error);
        }
    };
    useEffect(() =&gt; {
        fetchSpeakers();
    },[]);
    return (
      &lt;&gt; [Text Wrapping Break]
           &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;
[Text Wrapping Break]
           &lt;ul&gt;
               {data.map(item =&gt; (
                   &lt;li key={item.id}&gt;
                       {item.firstName} {item.lastName}
                   &lt;/li&gt;
               ))}
           &lt;/ul&gt;
      &lt;/&gt;
    );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.146.1">Let’s discuss</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.147.1"> the preceding code snippet, which </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.148.1">demonstrates how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">async/await</span></strong><span class="koboSpan" id="kobo.150.1"> to fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">data asynchronously:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">import React, { useEffect, useState } from 'react'</span></strong><span class="koboSpan" id="kobo.153.1">: This line imports React core functions and some Hooks for use in </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">our component.</span></span></li>
<li><span class="koboSpan" id="kobo.155.1">Initializing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">useState</span></strong><span class="koboSpan" id="kobo.157.1">: We initialize our state by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">useState</span></strong><span class="koboSpan" id="kobo.159.1"> in our component </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.161.1">const [data, setData] = useState([]);//using a destructuring array to write a concise code.</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">useState</span></strong><span class="koboSpan" id="kobo.163.1"> accepts an initial state of empty array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">useState([])</span></strong><span class="koboSpan" id="kobo.165.1">) and returns two values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">data</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.167.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">setData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">data</span></strong><span class="koboSpan" id="kobo.171.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">current state</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">setData</span></strong><span class="koboSpan" id="kobo.174.1">: State updater function (this function is responsible for the new state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">initial state)</span></span></li>
</ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">useState([])</span></strong><span class="koboSpan" id="kobo.177.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">useState</span></strong><span class="koboSpan" id="kobo.179.1"> with</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.180.1"> the initial value of </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">empty array</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">[]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.184.1">The </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.185.1">following snippet has a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">fetch()</span></strong><span class="koboSpan" id="kobo.187.1"> method that accepts the URL of the endpoint (</span><a href="https://dummyjson.com/users"><span class="koboSpan" id="kobo.188.1">https://dummyjson.com/users</span></a><span class="koboSpan" id="kobo.189.1">) and asynchronously returns data once it </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">is available:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.191.1">const API_URL = "https://dummyjson.com/users";  const fetchSpeakers = async () =&gt; {      try {          const response = await fetch(API_URL);          const data = await response.json();          setData(data.users);      } catch (error) {          console.log("error", error);      }  };</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.192.1">We have the hypothetical resource for speakers in the preceding endpoint. </span><span class="koboSpan" id="kobo.192.2">This is our resource endpoint. </span><span class="koboSpan" id="kobo.192.3">It returns JSON as data. </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">setData()</span></strong><span class="koboSpan" id="kobo.194.1"> accepts the new state, which is the returned data </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">in JSON.</span></span></p></li>
<li><span class="koboSpan" id="kobo.196.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">useEffect</span></strong><span class="koboSpan" id="kobo.198.1"> Hook </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.199.1">is used to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">fetchSpeakers</span></strong><span class="koboSpan" id="kobo.201.1"> function, which fetches </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.202.1">data asynchronously from the endpoint </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">const API_URL = "</span></strong><a href="https://dummyjson.com/users"><span class="No-Break"><span class="koboSpan" id="kobo.204.1">https://dummyjson.com/users</span></span></a><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.207.1">  useEffect(() =&gt; {        fetchSpeakers();    },[data]);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.208.1">The array dependency is supplied with the data state. </span><span class="koboSpan" id="kobo.208.2">When the data state changes, maybe because of the addition or removal of speakers in the list, the component re-renders and shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">updated state.</span></span></p></li>
<li><span class="koboSpan" id="kobo.210.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">map()</span></strong><span class="koboSpan" id="kobo.212.1"> is invoked on the data, and it is used to iterate on the speakers’ data to render details to </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the screen:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.214.1">return (        &lt;&gt;        &lt;ul&gt;      {data.map(item =&gt; (        &lt;li key={item.id}&gt;          {item.firstName} {item.lastName}        &lt;/li&gt;      ))}    &lt;/ul&gt;</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.215.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">async/await</span></strong><span class="koboSpan" id="kobo.217.1"> approach</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.218.1"> of fetching data gives your codes better organization and improves the responsiveness and performance of your React applications. </span><span class="koboSpan" id="kobo.218.2">The non-blocking </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.219.1">mode of </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">async/await</span></strong><span class="koboSpan" id="kobo.221.1"> means you can carry on with the rest of the code operations while you await responses from a large amount of data </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">running tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Next, we are going to look at another approach for fetching data from an API, using a third-party npm package </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">called Axios.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.225.1">Fetching data using Axios</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.226.1">Axios</span></strong><span class="koboSpan" id="kobo.227.1"> is</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.228.1"> simply a lightweight JavaScript, promise-based HTTP client used to consume API services. </span><span class="koboSpan" id="kobo.228.2">It is </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.229.1">mainly used in the browser and Node.js. </span><span class="koboSpan" id="kobo.229.2">To use Axios in our project, open the project terminal and type </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.231.1">npm install axios</span></pre>
<p><span class="koboSpan" id="kobo.232.1">Now, let’s see how</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.233.1"> to use Axios in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">import React, { useEffect, useState } from 'react';import axios from 'axios';
const App = () =&gt; {
    const [data, setData] = useState([]);
    const getSpeakers = ()=&gt;{
        axios.get(
            "https://jsonplaceholder.typicode.com/users")
            .then(response =&gt; {
                setData(response.data)
            })
    }
    useEffect(() =&gt; {
        getSpeakers()
    },[]);
    return (
        &lt;&gt;
           &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;
           &lt;ul&gt;
               {data.map(speaker =&gt; (
                   &lt;li key={speaker.id}&gt;
                       {speaker.name},  &lt;em&gt;
                           {speaker.email} &lt;/em&gt;
                   &lt;/li&gt;
               ))}
           &lt;/ul&gt;
        &lt;/&gt;
    );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.236.1">Let’s examine </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.237.1">the </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.238.1">preceding code snippet to see how Axios can be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">data fetching:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">import React, { useEffect, useState } from 'react'</span></strong><span class="koboSpan" id="kobo.241.1">: This line imports React core functions and some Hooks for use in </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">our component.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">import axios from "axios"</span></strong><span class="koboSpan" id="kobo.244.1">: This line brings in the already installed Axios package for use in </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the project.</span></span></li>
<li><span class="koboSpan" id="kobo.246.1">Initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">useState</span></strong><span class="koboSpan" id="kobo.248.1">: We initialize our state by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">useState</span></strong><span class="koboSpan" id="kobo.250.1"> in our component</span><a id="_idIndexMarker242"/> <span class="No-Break"><span class="koboSpan" id="kobo.251.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.252.1">const [data, setData] = useState([]);//using a destructuring array to write a concise code.</span></pre></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">useState</span></strong><span class="koboSpan" id="kobo.254.1"> accepts an initial state of an empty array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">useState([])</span></strong><span class="koboSpan" id="kobo.256.1">) and returns two values, </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">data</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.258.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">setData</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">data</span></strong><span class="koboSpan" id="kobo.262.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">current state</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">setData</span></strong><span class="koboSpan" id="kobo.265.1">: State updater function (this function is responsible for the new state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">initial state)</span></span></li>
</ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">useState([])</span></strong><span class="koboSpan" id="kobo.268.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">useState</span></strong><span class="koboSpan" id="kobo.270.1"> with the initial value of </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">empty array</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">[]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.274.1">The following</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.275.1"> snippet has a global </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">fetch()</span></strong><span class="koboSpan" id="kobo.277.1"> method that accepts the URL of the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">endpoint </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">https://jsonplaceholder.typicode.com/users</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.281.1">const getSpeakers = ()=&gt;{    axios.get(        "https://jsonplaceholder.typicode.com/users")        .then(response =&gt; {            setData(response.data)        })}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.282.1">This is our resource endpoint. </span><span class="koboSpan" id="kobo.282.2">It returns JSON as data. </span><span class="koboSpan" id="kobo.282.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">setData()</span></strong><span class="koboSpan" id="kobo.284.1"> accepts the new state, which is the returned data </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">in JSON.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.286.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">getSpeakers</span></strong><span class="koboSpan" id="kobo.288.1"> function uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">axios.get()</span></strong><span class="koboSpan" id="kobo.290.1"> to fetch external data from the endpoint and return </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.291.1">a promise. </span><span class="koboSpan" id="kobo.291.2">The state value is updated, and we have a new state in </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">setData</span></strong><span class="koboSpan" id="kobo.293.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">response object:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.295.1">useEffect(() =&gt; {getSpeakers()    },[]);</span></pre></li>
<li><span class="koboSpan" id="kobo.296.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">useEffect</span></strong><span class="koboSpan" id="kobo.298.1"> Hook is </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.299.1">used to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">getSpeaker()</span></strong><span class="koboSpan" id="kobo.301.1"> and renders </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">the component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.303.1">&lt;ul&gt;    {data.map(speaker =&gt; (        &lt;li key={speaker.id}&gt;            {speaker.name},  &lt;em&gt; {speaker.email}                &lt;/em&gt;        &lt;/li&gt;    ))}&lt;/ul&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.304.1">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">map()</span></strong><span class="koboSpan" id="kobo.306.1"> is used to iterate on the speakers’ data and display names and emails on </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">the screen.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.308.1">Moving on to data fetching techniques in React, we are going to look at another approach to fetching data using </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">React Query.</span></span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.310.1">Fetching data using the React Query in React</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.311.1">React Query</span></strong><span class="koboSpan" id="kobo.312.1"> is an</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.313.1"> npm package library created for data fetching purposes with a ton of functionalities loaded with it. </span><span class="koboSpan" id="kobo.313.2">In</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.314.1"> React Query, the state management, pre-fetching of data, request retries, and caching are handled out of the box. </span><span class="koboSpan" id="kobo.314.2">React Query is a critical component of the React ecosystem with over a million </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">downloads weekly.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Let’s refactor </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.317.1">the code snippet we used in the </span><em class="italic"><span class="koboSpan" id="kobo.318.1">Fetching data using Axios</span></em><span class="koboSpan" id="kobo.319.1"> section and experience the awesomeness of </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">React Query:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.321.1">First, install </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.322.1">React Query. </span><span class="koboSpan" id="kobo.322.2">In the root directory of the project, do </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the following:</span></span><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.324.1">npm install react-query</span></strong></pre></li>
<li><span class="koboSpan" id="kobo.325.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">App.js</span></strong><span class="koboSpan" id="kobo.327.1">, add </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.329.1">import {useQuery} from 'react-query'import axios from 'axios';function App() {  const{data, isLoading, error} = useQuery(    "speakers",    ()=&gt;{ axios(      "https://jsonplaceholder.typicode.com/users")  );  if(error) return &lt;h4&gt;Error: {error.message},    retry again&lt;/h4&gt;  if(isLoading) return &lt;h4&gt;...Loading data&lt;/h4&gt;  console.log(data);  return (      &lt;&gt;         &lt;h1&gt;Displaying Speakers Information&lt;/h1&gt;         &lt;ul&gt;             {data.data.map(speaker =&gt; (                 &lt;li key={speaker.id}&gt;                     {speaker.name},  &lt;em&gt;                         {speaker.email} &lt;/em&gt;                 &lt;/li&gt;             ))}         &lt;/ul&gt;      &lt;/&gt;  );}export default App;</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.330.1">Check the</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.331.1"> preceding </span><em class="italic"><span class="koboSpan" id="kobo.332.1">Fetching data using Axios</span></em><span class="koboSpan" id="kobo.333.1"> section</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.334.1"> to compare the code snippet. </span><span class="koboSpan" id="kobo.334.2">The React Query snippet is way shorter and more concise. </span><span class="koboSpan" id="kobo.334.3">The need for </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">useState</span></strong><span class="koboSpan" id="kobo.336.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">useEffect</span></strong><span class="koboSpan" id="kobo.338.1"> Hooks have been handled out of the box by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">useQuery()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.340.1"> Hook.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Let’s dissect the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">preceding code:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">useQuery</span></strong><span class="koboSpan" id="kobo.344.1"> accepts two arguments: the query key (</span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">speakers</span></strong><span class="koboSpan" id="kobo.346.1">) and a callback function that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">axios()</span></strong><span class="koboSpan" id="kobo.348.1"> to fetch a hypothetical speaker from the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">resource endpoint.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">useQuery</span></strong><span class="koboSpan" id="kobo.351.1"> is destructured with variables – </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">{data, isLoading, error}</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">We then check to see whether there is an error message coming from the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">error object.</span></span></li>
<li><span class="koboSpan" id="kobo.355.1">Once we have data, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">return()</span></strong><span class="koboSpan" id="kobo.357.1"> function returns an array of </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">speakers’ data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.359.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">index.js</span></strong><span class="koboSpan" id="kobo.361.1">, add the following code. </span><span class="koboSpan" id="kobo.361.2">The existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">index.js</span></strong><span class="koboSpan" id="kobo.363.1"> codes are </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">presumed present:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.365.1">import { QueryClient, QueryClientProvider } from    react-query";
const queryClient = new QueryClient();
root.render(
    &lt;QueryClientProvider client={queryClient}&gt;
        &lt;App /&gt; &lt;/QueryClientProvider&gt;
);</span></pre>
<p><span class="koboSpan" id="kobo.366.1">Let’s </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.367.1">have </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.368.1">some explanation of the code snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">index.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.372.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">{ QueryClient, QueryClientProvider }</span></strong><span class="koboSpan" id="kobo.374.1"> from React Query: </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">QueryClient</span></strong><span class="koboSpan" id="kobo.376.1"> allows us to leverage the global defaults for all queries and mutations in React Query. </span><span class="koboSpan" id="kobo.376.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">QueryClientProvider</span></strong><span class="koboSpan" id="kobo.378.1"> connects and provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">QueryClient</span></strong><span class="koboSpan" id="kobo.380.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.382.1">Create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">QueryClient</span></strong><span class="koboSpan" id="kobo.384.1"> instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">queryClient</span></strong><span class="koboSpan" id="kobo.386.1">: Wrap your component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">QueryClientProvider</span></strong><span class="koboSpan" id="kobo.388.1">—in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">&lt;App</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.390.1">/&gt;</span></strong><span class="koboSpan" id="kobo.391.1"> is the component—and pass the new instance as an </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">attribute value.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.393.1">Now run </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">npm start</span></strong><span class="koboSpan" id="kobo.395.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">localhost:3000</span></strong><span class="koboSpan" id="kobo.397.1"> is not running. </span><span class="koboSpan" id="kobo.397.2">The following should be displayed on </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the screen:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.399.1"><img alt="Figure 4.1 – Screenshot showing the usage of React Query in fetching data" src="image/Figure_4.1_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.400.1">Figure 4.1 – Screenshot showing the usage of React Query in fetching data</span></p>
<p><span class="koboSpan" id="kobo.401.1">React Query is </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.402.1">very effective at fetching data from API resources. </span><span class="koboSpan" id="kobo.402.2">It encapsulates functions that may be required by </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">useState</span></strong><span class="koboSpan" id="kobo.404.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">useEffect</span></strong><span class="koboSpan" id="kobo.406.1">. </span><span class="koboSpan" id="kobo.406.2">React Query radically redefines the way we fetch data in React applications by introducing a powerful caching mechanism with </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">queryKey</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Instead</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.411.1"> of manually managing data fetching and caching, React Query handles it transparently. </span><span class="koboSpan" id="kobo.411.2">React Query allows developers to easily fetch and cache data with just a few lines of code, reducing boilerplate and </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">improving performance.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">The library provides various Hooks and utilities that simplify data fetching, error handling, and data synchronization with the server, leading to a more efficient and seamless user experience. </span><span class="koboSpan" id="kobo.413.2">Exploring React Query further can open up a world of possibilities in handling complex data fetching scenarios and optimizing data management in </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">React applications.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.415.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.416.1">Handling data is a critical component of any web application. </span><span class="koboSpan" id="kobo.416.2">React has proven to be very efficient and scalable in handling data at scale. </span><span class="koboSpan" id="kobo.416.3">In this chapter, we discussed various approaches you can utilize in your project to handle data fetching. </span><span class="koboSpan" id="kobo.416.4">We discussed fetching data using the Fetch API, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">async/await</span></strong><span class="koboSpan" id="kobo.418.1">, Axios, and </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">React Query.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">In the next chapter, we are going to discuss JSX and how you can display lists </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">in React.</span></span></p>
</div>
</body></html>