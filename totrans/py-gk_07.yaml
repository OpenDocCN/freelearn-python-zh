- en: '*Chapter 5*: Testing and Automation with Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：使用 Python 进行测试和自动化'
- en: Software testing is the process of validating an application or a program as
    per user requirements or desired specifications and evaluating the software for
    scalability and optimization goals. Validating software as a real user takes a
    long time and is not an efficient use of human resources. Moreover, testing is
    not performed only one or two times, but it is a continuous process as a part
    of software development. To rescue the situation, test automation is recommended
    for all sorts of testing. **Test automation** is a set of programs written to
    validate an application's behavior using different scenarios as input to these
    programs. For professional software development environments, it is a must that
    automation tests get executed every time the source code is updated (also called
    a **commit operation**) into a central repository.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是根据用户要求或期望的规范验证应用程序或程序的过程，并评估软件的可扩展性和优化目标。以真实用户验证软件需要很长时间，并且不是人力资源的有效利用。此外，测试不仅只进行一次或两次，而是一个作为软件开发一部分的持续过程。为了应对这种情况，建议对所有类型的测试进行自动化。**测试自动化**是一组程序，用于使用不同场景作为输入来验证应用程序的行为。对于专业的软件开发环境，每次将源代码更新（也称为**提交操作**）到中央存储库时，都必须执行自动化测试。
- en: In this chapter, we will study different approaches to automated testing, followed
    by looking at different types of testing frameworks and libraries that are available
    for Python applications. Then, we will focus on unit testing and will look into
    different ways of implementing unit testing in Python. Next, we will study the
    usefulness of **test-driven development** (**TDD**) and the right way to implement
    it. Finally, we will focus on automated **continuous integration** (**CI**) and
    will look into the challenges of implementing it robustly and efficiently. This
    chapter will help you understand the concepts of automated testing in Python at
    various levels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究自动化的不同方法，然后查看适用于 Python 应用程序的测试框架和库的不同类型。然后，我们将专注于单元测试，并探讨在 Python
    中实现单元测试的不同方法。接下来，我们将研究**测试驱动开发**（**TDD**）的有用性及其正确的实现方式。最后，我们将专注于自动化的**持续集成**（**CI**），并探讨其稳健和高效实施所面临的挑战。本章将帮助您理解
    Python 在各个级别自动化的概念。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding various levels of testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种测试级别
- en: Working with Python test frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 测试框架
- en: Executing TDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 TDD
- en: Introducing automated CI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍自动化 CI
- en: At the end of this chapter, you will not only understand different types of
    test automation but will also be able to write unit tests using one of the two
    popular test frameworks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您不仅将了解不同类型的测试自动化，还将能够使用两个流行的测试框架之一编写单元测试。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'These are the technical requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的技术要求：
- en: You need to have installed Python 3.7 or later on your computer.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在您的计算机上安装 Python 3.7 或更高版本。
- en: You need to register an account with Test PyPI and create an **application programming
    interface** (**API**) token under your account.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在 Test PyPI 上注册一个账户，并在您的账户下创建一个**应用程序编程接口**（**API**）令牌。
- en: The sample code for this chapter can be found at [https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter05](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter05](https://github.com/PacktPublishing/Python-for-Geeks/tree/master/Chapter05)找到。
- en: Understanding various levels of testing
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各种测试级别
- en: 'Testing is performed at various levels based on the application type, its complexity
    level, and the role of the team that is working on the application. The different
    levels of testing include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序类型、其复杂程度以及正在开发该应用程序的团队的角色，在各个级别执行测试。不同的测试级别包括以下内容：
- en: Unit testing
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: System testing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统测试
- en: Acceptance testing
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试
- en: 'These different levels of testing are applied in the order shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同的测试级别按照以下顺序应用：
- en: '![Figure 5.1 – Different levels of testing during software development'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 软件开发中的不同测试级别'
- en: '](img/B17189_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17189_05_01.jpg](img/B17189_05_01.jpg)'
- en: Figure 5.1 – Different levels of testing during software development
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 软件开发中的不同测试级别
- en: These testing levels are described in the next subsections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试级别将在下一小节中描述。
- en: Unit testing
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is a type of testing that is focused on the smallest possible unit
    level. A unit corresponds to a unit of code that can be a function in a module
    or a method in a class, or it can be a module in an application. A unit test executes
    a single unit of code in isolation and validates that the code is working as expected.
    Unit testing is a technique used by developers to identify bugs at the early stages
    of code development and fix them as part of the first iteration of the development
    process. In Python, unit testing mainly targets a particular class or module without
    involving dependencies.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种关注最小可能单元级别的测试类型。一个单元对应于代码中的一个单元，可以是模块中的一个函数或类中的一个方法，也可以是应用程序中的一个模块。单元测试在隔离的情况下执行单个单元的代码，并验证代码是否按预期工作。单元测试是开发者用于在代码开发的早期阶段识别错误，并在开发过程的第一轮迭代中修复它们的技巧。在Python中，单元测试主要针对特定的类或模块，而不涉及依赖项。
- en: Unit tests are developed by application developers and can be performed at any
    time. Unit testing is a kind of `pyunit` (`unittest`), `pytest`, `doctest`, `nose`,
    and a few others.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是由应用程序开发者开发的，可以在任何时间进行。单元测试是一种`pyunit`（`unittest`）、`pytest`、`doctest`、`nose`以及其他几种测试方式。
- en: Integration testing
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing is about testing individual units of a program collectively
    in the form of a group. The idea behind this type of testing is to test the combination
    of different functions or modules of an application together to validate the interfaces
    between the components and the data exchange between them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是关于以组的形式集体测试程序中的单个单元。这种测试背后的理念是将应用程序的不同功能或模块组合在一起进行测试，以验证组件之间的接口和数据交换。
- en: Integration testing is typically done by testers and not by developers. This
    type of testing starts after the unit testing process, and the focus of this testing
    is to identify the integration problem when different modules or functions are
    used together. In some cases, integration testing requires external resources
    or data that may not be possible to provide in a development environment. This
    limitation can be managed by using mock testing, which provides replacement mock
    objects for external or internal dependencies. The mock objects simulate the behavior
    of the real dependencies. Examples of mock testing can be sending an email or
    making a payment using a credit card.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常由测试人员而不是开发者执行。这种测试在单元测试过程之后开始，测试的重点是识别当不同的模块或功能一起使用时出现的集成问题。在某些情况下，集成测试可能需要外部资源或数据，这些资源或数据在开发环境中可能无法提供。这种限制可以通过使用模拟测试来管理，模拟测试提供外部或内部依赖的替代模拟对象。模拟对象模拟真实依赖的行为。模拟测试的例子可以是发送电子邮件或使用信用卡进行支付。
- en: Integration testing is a kind of **black-box testing**. The libraries and the
    tools used for integration testing are pretty much the same as for unit testing,
    with a difference that the boundaries of tests are pushed further out to include
    multiple units in a single test.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是一种**黑盒测试**。用于集成测试的库和工具与单元测试中使用的几乎相同，区别在于测试的边界被进一步扩展，以包括单个测试中的多个单元。
- en: System testing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试
- en: The boundaries of system testing are further pushed out to the system level,
    which may be a full-blown module or an application. This type of testing validates
    the application functionality from an **end-to-end** (**E2E**) perspective.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试的边界进一步扩展到系统级别，这可能是一个完整的模块或应用程序。这种测试从**端到端**（**E2E**）的角度验证应用程序的功能。
- en: System tests are also developed by testers but after completing the integration
    testing process. We can say that integration testing is a prerequisite for system
    testing; otherwise, a lot of effort will be repeated while performing system testing.
    System testing can identify potential problems but does not pinpoint the location
    of the problem. The exact root cause of the problem is typically identified by
    integration testing or even by adding more unit tests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试也是由测试人员开发的，但完成集成测试过程之后。我们可以这样说，集成测试是系统测试的先决条件；否则，在执行系统测试时，将会重复大量的工作。系统测试可以识别潜在的问题，但无法确定问题的具体位置。问题的确切根本原因通常由集成测试甚至通过添加更多的单元测试来确定。
- en: System testing is also a type of black-box testing and can leverage the same
    libraries that are available for integration testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试也是一种黑盒测试，可以利用与集成测试相同的库。
- en: Acceptance testing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受测试
- en: 'Acceptance testing is end-user testing before accepting the software for day-to-day
    use. Acceptance testing is not commonly a candidate for automation testing, but
    it is worth using automation for acceptance testing in situations where application
    users have to interact with the product using an API. This testing is also called
    **user acceptance testing** (**UAT**). This type of testing can be easily mixed
    up with system testing but it is different in that it ensures the usability of
    the application from a real user''s point of view. There are also further two
    types of acceptance testing: **factory acceptance testing** (**FAT**) and **operational
    acceptance testing** (**OAT**). The former is more popular from a hardware point
    of view, and the latter is performed by the operation teams, who are responsible
    for using the product in production environments.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试是在接受软件用于日常使用之前的最终用户测试。接受测试通常不是自动化测试的候选者，但在应用用户必须通过API与产品交互的情况下，使用自动化进行接受测试是值得的。这种测试也称为**用户接受测试**（**UAT**）。这种类型的测试很容易与系统测试混淆，但它不同之处在于它确保了从真实用户的角度来看应用程序的可使用性。还有另外两种接受测试：**工厂接受测试**（**FAT**）和**运营接受测试**（**OAT**）。前者从硬件角度来看更为流行，后者由负责在生产环境中使用产品的运营团队执行。
- en: Additionally, we also hear about **alpha** and **beta** testing. These are also
    user-level testing approaches and are not meant for test automation. Alpha testing
    is performed by developers and internal staff to emulate actual user behavior.
    Beta testing is performed by customers or actual users for early feedback before
    declaring **general availability** (**GA**) of the software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还听说过**alpha**和**beta**测试。这些也是用户级别的测试方法，并不适用于测试自动化。Alpha测试由开发人员和内部员工执行，以模拟实际用户的行为。Beta测试由客户或实际用户执行，以便在宣布软件的**通用可用性**（**GA**）之前提供早期反馈。
- en: We also use the term **regression testing** in software development. This is
    basically the execution of tests every time we make a change in the source code
    or any internal or external dependency changes. This practice ensures that our
    product is performing in the same way as it was before making a change. Since
    regression testing is repeated many times, automating the tests is a must for
    this type of testing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，我们也使用术语**回归测试**。这基本上是在我们更改源代码或任何内部或外部依赖项更改时执行测试。这种做法确保我们的产品在更改之前以相同的方式运行。由于回归测试会重复多次，因此自动化测试对于这种类型的测试是必须的。
- en: In the next section, we will investigate how to build test cases using the test
    frameworks in Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用Python中的测试框架构建测试用例。
- en: Working with Python test frameworks
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Python测试框架一起工作
- en: 'Python comes with standard as well as third-party libraries for test automation.
    The most popular frameworks are listed here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了用于测试自动化的标准库和第三方库。最流行的框架在此列出：
- en: '`pytest`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`'
- en: '`unittest`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`'
- en: '`doctest`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest`'
- en: '`nose`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nose`'
- en: 'These frameworks can be used for unit testing as well as for integration and
    system testing. In this section, we will evaluate two of these frameworks: `unittest`,
    which is part of the Python standard library, and `pytest`, which is available
    as an external library. The focus of this evaluation will be on building test
    cases (mainly unit tests) using these two frameworks, although the integration
    and system tests can also be built using the same libraries and design patterns.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架可以用于单元测试，以及集成和系统测试。在本节中，我们将评估这些框架中的两个：`unittest`，它是Python标准库的一部分，以及`pytest`，它作为一个外部库可用。评估的重点将在于使用这两个框架构建测试用例（主要是单元测试），尽管也可以使用相同的库和设计模式构建集成和系统测试。
- en: 'Before we start writing any test cases, it is important to understand what
    a test case is. In the context of this chapter and book, we can define a test
    case as a way of validating the outcomes of a particular behavior of a programming
    code as per the expected results. The development of a test case can be broken
    down into the following four stages:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写任何测试用例之前，了解什么是测试用例非常重要。在本章和本书的上下文中，我们可以将测试用例定义为根据预期结果验证编程代码特定行为结果的一种方式。测试用例的开发可以分为以下四个阶段：
- en: '**Arrange**: This is a stage where we prepare the environment for our test
    cases. This does not include any action or validation step. In the test automation
    community, this stage is more commonly known as preparing **test fixtures**.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**准备**：这是一个为我们的测试用例准备环境的阶段。这不包括任何动作或验证步骤。在测试自动化社区中，这个阶段更常见地被称为准备**测试工具**。'
- en: '**Act**: This is the action stage that triggers the system we want to test.
    This action stage results in a change in the system behavior, and the changed
    state of the system is something we want to evaluate for validation purposes.
    Note that we do not validate anything at this stage.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行**：这是触发我们想要测试的系统的动作阶段。这个动作阶段导致系统行为发生变化，而系统状态的变化是我们想要评估以进行验证目的的东西。请注意，在这个阶段我们不会验证任何东西。'
- en: '**Assert**: At this stage, we evaluate the results of the *act* stage and validate
    the results against the expected outcome. Based on this validation, the test automation
    tools mark the test case as failed or passed. In most of the tools, this validation
    is achieved using built-in *assert* functions or statements.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言**：在这个阶段，我们评估*执行*阶段的结果，并将结果与预期结果进行验证。基于这种验证，测试自动化工具将测试用例标记为失败或通过。在大多数工具中，这种验证是通过内置的*断言*函数或语句实现的。'
- en: '**Cleanup**: At this stage, the environment is cleaned up to make sure the
    other tests are not impacted by the status changes caused by the *act* stage.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**清理**：在这个阶段，环境被清理以确保其他测试不受*执行*阶段引起的状态变化的影响。'
- en: The core stages of a test case are *act* and *assert*. The *arrange* and *cleanup*
    stages are optional but highly recommended. These two stages mainly provide software
    test fixtures. A test fixture is a type of equipment or device or software that
    provides an environment to test a device or a machine or software consistently.
    The term *test fixture* is used in the same context for unit testing and integration
    testing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的核心阶段是*执行*和*断言*。*准备*和*清理*阶段是可选的，但强烈推荐。这两个阶段主要提供软件测试工具。测试工具是一种设备或装置或软件，它提供了一个环境，以一致的方式测试设备或机器或软件。术语*测试工具*在单元测试和集成测试的上下文中使用。
- en: 'The test frameworks or libraries provide helper methods or statements to facilitate
    the implementation of these stages conveniently. In the next sections, we will
    evaluate the `unittest` and the `pytest` frameworks for the following topics:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架或库提供了辅助方法或语句，以便方便地实现这些阶段。在下一节中，我们将评估`unittest`和`pytest`框架以下主题：
- en: How to build base-level test cases for act and assert stages
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建执行和断言阶段的基线测试用例
- en: How to build test cases with test fixtures
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用测试工具构建测试用例
- en: How to build test cases for exception and error validation
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建异常和错误验证的测试用例
- en: How to run test cases in bulk
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何批量运行测试用例
- en: How to include and exclude test cases in execution
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在执行中包含和排除测试用例
- en: These topics not only cover the development of a variety of test cases but also
    include different ways to execute them. We will start our evaluation with the
    `unittest` framework.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题不仅涵盖了各种测试用例的开发，还包括执行它们的不同方式。我们将从`unittest`框架开始评估。
- en: Working with the unittest framework
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与unittest框架一起工作
- en: 'Before starting to discuss practical examples with the `unittest` framework
    or library, it is important to introduce a few terms and traditional method names
    related to unit testing and, in particular, to the `unittest` library. This terminology
    is used more or less by all test frameworks and is outlined here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用`unittest`框架或库讨论实际示例之前，介绍一些与单元测试和，特别是与`unittest`库相关的术语和传统方法名称是很重要的。这些术语在所有测试框架中或多或少都会使用，下面概述如下：
- en: '**Test case**: A test or test case or test method is a set of code instructions
    that are based on a comparison of the current condition versus the post-execution
    conditions after executing a unit of application code.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例**：测试或测试用例或测试方法是一组基于执行应用代码单元后的当前条件与执行后的条件比较的代码指令。'
- en: '**Test suite**: A test suite is a collection of test cases that may have common
    pre-conditions, initialization steps, and perhaps the same cleanup steps. This
    foments reusability of test automation code and reduced execution time.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试套件**：测试套件是一组可能具有共同先决条件、初始化步骤，也许还有相同的清理步骤的测试用例。这促进了测试自动化代码的可重用性并减少了执行时间。'
- en: '**Test runner**: This is a Python application that executes the tests (unit
    tests), validates all the assertions defined in the code, and gives the results
    back to us as a success or a failure.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试运行器**: 这是一个Python应用程序，它执行测试（单元测试），验证代码中定义的所有断言，并将结果作为成功或失败返回给我们。'
- en: '**Setup**: This is a special method in a test suite that will be executed before
    each test case.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**: 这是测试套件中的一个特殊方法，将在每个测试用例之前执行。'
- en: '`setupClass`: This is a special method in a test suite that will be executed
    only once at the start of the execution of tests in a test suite.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setupClass`: 这是测试套件中的一个特殊方法，它将在测试套件中测试执行开始时仅执行一次。'
- en: '`teardown`: This is another special method in a test suite that is executed
    after completion of every test regardless of whether the test passes or fails.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teardown`: 这是测试套件中的另一个特殊方法，在每次测试完成后执行，无论测试是否通过。'
- en: '`teardownClass`: This is another special method in a test suite that is executed
    only once when all the tests in a suite are completed.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teardownClass`: 这是测试套件中的另一个特殊方法，当套件中的所有测试完成后，将仅执行一次。'
- en: 'To write test cases using the `unittest` library, we are required to implement
    the test cases as instance methods of a class that must be inherited from the
    `TestCase` base class. The `TestCase` class comes with several methods to facilitate
    writing as well as executing the test cases. These methods are grouped into three
    categories, which are discussed next:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`unittest`库编写测试用例，我们必须将测试用例实现为从`TestCase`基类继承的类的实例方法。`TestCase`类包含一些方法，可以方便地编写和执行测试用例。这些方法分为三类，将在下面讨论：
- en: '`setUp`, `tearDown`, `setupClass`, `teardownClass`, `run`, `skipTest`, `skipTestIf`,
    `subTest`, and `debug`. These tests are used by the test runner to execute a piece
    of code before or after a test case or running a set of test cases, running a
    test, skipping a test, or running any block of code as a sub-test. In our test
    case implementation class, we can override these methods. The exact details of
    these methods are available as part of the Python documentation at [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUp`, `tearDown`, `setupClass`, `teardownClass`, `run`, `skipTest`, `skipTestIf`,
    `subTest`, 和 `debug`。这些测试由测试运行器用于在测试用例之前或之后执行一段代码，运行一组测试用例，运行测试，跳过测试，或作为子测试运行任何代码块。在我们的测试用例实现类中，我们可以重写这些方法。这些方法的详细说明作为Python文档的一部分，可在[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)找到。'
- en: '**Validation methods** (assert methods): These methods are used to implement
    test cases to check for success or failure conditions and report success or failures
    for a test case automatically. These methods'' name typically starts with an *assert*
    prefix. The list of assert methods is very long. We provide commonly used assert
    methods here as examples:![Figure 5.2 – A few examples of assert methods of the
    TestCase class'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证方法**（断言方法）：这些方法用于实现测试用例以检查成功或失败条件，并自动报告测试用例的成功或失败。这些方法的名称通常以`assert`前缀开头。断言方法的列表非常长。我们在此提供一些常用断言方法的示例：![图5.2
    – TestCase类断言方法的几个示例'
- en: '](img/B17189_05_02.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B17189_05_02.jpg)'
- en: Figure 5.2 – A few examples of assert methods of the TestCase class
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – TestCase类断言方法的几个示例
- en: '`failureException`: This attribute provides an exception raised by a test method.
    This exception can be used as a superclass to define a custom failure exception
    with additional information.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failureException`: 此属性提供由测试方法引发的异常。此异常可以用作超类来定义具有附加信息的自定义失败异常。'
- en: 'b) `longMessage`: This attribute determines what to do with a custom message
    that is passed as an argument with an `assert` method. If the value of this attribute
    is set to `True`, the message is appended to the standard failure message. If
    this attribute is set to `false`, a custom message replaces the standard message.'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b) `longMessage`: 此属性确定如何处理使用`assert`方法传递的自定义消息。如果此属性的值设置为`True`，则消息将附加到标准失败消息。如果此属性设置为`false`，则自定义消息将替换标准消息。'
- en: 'c) `countTestCases()`: This method returns the number of tests attached to
    a test object.'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c) `countTestCases()`: 此方法返回附加到测试对象上的测试数量。'
- en: 'd) `shortDescription()`: This method returns a description of a test method
    if there is any description added, using a docstring.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd) `shortDescription()`: 此方法返回测试方法的描述，如果有任何描述添加，则使用文档字符串。'
- en: We have reviewed the main methods of the `TestCase` class in this section. In
    the next section, we will explore how to use `unittest` to build unit tests for
    a sample module or an application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中回顾了`TestCase`类的主要方法。在下一节中，我们将探讨如何使用`unittest`为示例模块或应用程序构建单元测试。
- en: Building test cases using the base TestCase class
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基类`TestCase`构建测试用例
- en: 'The `unittest` library is a standard Python testing framework that is highly
    inspired by the **JUnit** framework, a popular testing framework in the Java community.
    Unit tests are written in separate Python files and it is recommended to make
    the files part of the main project. As we discussed in [*Chapter 2*](B17189_02_Final_PG_ePub.xhtml#_idTextAnchor086),
    *Using Modularization to Handle Complex Projects*, in the *Building a package*
    section, the **Python Packaging Authority** (**PyPA**) guidelines recommend having
    a separate folder for tests when building packages for a project or a library.
    In our code examples for this section, we will follow a similar structure to the
    one shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`库是一个受JUnit框架（Java社区中流行的测试框架）高度启发的标准Python测试框架。单元测试以单独的Python文件编写，并建议将这些文件作为主项目的一部分。正如我们在[*第2章*](B17189_02_Final_PG_ePub.xhtml#_idTextAnchor086)，*使用模块化处理复杂项目*中的*构建包*部分所讨论的，**Python打包权威机构**（**PyPA**）的指南建议在为项目或库构建包时为测试保留一个单独的文件夹。在本节的代码示例中，我们将遵循与这里所示类似的结构：'
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our first code example, we will build a test suite for the `add` function
    in the `myadd.py` module, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个代码示例中，我们将为`myadd.py`模块中的`add`函数构建一个测试套件，如下所示：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is important to understand that there can be more than one test case for
    the same piece of code (an `add` function, in our case). For the `add` function,
    we implemented four test cases by varying the values of input parameters. Next
    is a code sample with four test cases for the `add` function, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，对于同一块代码（在我们的例子中是`add`函数）可以有多个测试用例。对于`add`函数，我们通过改变输入参数的值实现了四个测试用例。下面是一个包含四个`add`函数测试用例的代码示例，如下所示：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All the key points of the preceding test suite are discussed next, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将讨论前面测试套件的所有关键点，如下所示：
- en: To implement unit tests using the `unittest` framework, we need to import a
    standard library with the same name, `unittest`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用`unittest`框架实现单元测试，我们需要导入一个同名的标准库，即`unittest`。
- en: We need to import the module or modules we want to test in our test suite. In
    this case, we imported the `add` function from the `myadd.py` module using the
    relative import approach (see the *Importing modules* section of [*Chapter 2*](B17189_02_Final_PG_ePub.xhtml#_idTextAnchor086),
    *Using Modularization to Handle Complex Projects,* for details)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在测试套件中导入我们想要测试的模块或模块。在这种情况下，我们使用相对导入方法从`myadd.py`模块中导入了`add`函数（参见[*第2章*](B17189_02_Final_PG_ePub.xhtml#_idTextAnchor086)，*使用模块化处理复杂项目*中的*导入模块*部分，了解更多详情）。
- en: We will implement a test suite class that is inherited from the `unittest.Testcase`
    base class. The test cases are implemented in the subclass, which is the `MyAddTestSuite`
    class in this case. The `unittest.Testcase` class constructor can take a method
    name as an input that can be used to run the test cases. By default, there is
    a `runTest` method already implemented that is used by the test runner to execute
    the tests. In a majority of the cases, we do not need to provide our own method
    or re-implement the `runTest` method.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现一个继承自`unittest.Testcase`基类的测试套件类。测试用例在子类中实现，在这个例子中是`MyAddTestSuite`类。`unittest.Testcase`类的构造函数可以接受一个方法名作为输入，该输入可以用来运行测试用例。默认情况下，已经实现了一个`runTest`方法，该方法是测试运行器用来执行测试的。在大多数情况下，我们不需要提供自己的方法或重新实现`runTest`方法。
- en: To implement a test case, we need to write a method that starts with the `test`
    prefix and is followed by an underscore. This helps the test runner to look for
    the test cases to be executed. Using this naming convention, we added four methods
    to our test suite.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现一个测试用例，我们需要编写一个以`test`前缀开头并跟一个下划线的函数。这有助于测试运行器查找要执行的测试用例。使用这种命名约定，我们向我们的测试套件中添加了四个方法。
- en: In each test-case method, we used a special `assertEqual` method, which is available
    from the base class. This method represents the assert stage of a test case and
    is used to decide if our test will be declared as passed or failed. The first
    parameter of this method is the expected results of the unit test, the second
    parameter is the value that we get after executing the code under test, and the
    third parameter (optional) is the message to be provided in the report in case
    the test is failed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个测试用例方法中，我们使用了一个特殊的`assertEqual`方法，它来自基类。这个方法代表了测试用例的断言阶段，用于决定我们的测试将被宣布为通过或失败。这个方法的第一个参数是单元测试的预期结果，第二个参数是在执行测试代码后得到的值，第三个参数（可选）是在测试失败时报告中的消息。
- en: At the end of the test suite, we added the `unittest.main` method to trigger
    the test runner to run the `runTest` method, which makes it easy to execute the
    tests without using the commands at the console. This `main` method (a `TestProgram`
    class under the hood) will first discover all the tests to be executed and then
    execute the tests.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试套件结束时，我们添加了`unittest.main`方法来触发测试运行器运行`runTest`方法，这使得在不使用控制台命令的情况下执行测试变得容易。这个`main`方法（底层是一个`TestProgram`类）将首先发现所有要执行的测试，然后执行这些测试。
- en: Important note
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Unit tests can be run using a command such as `Python -m unittest <test suite
    or module>`, but the code examples we provide in this chapter will assume that
    we are running the test cases using the PyCharm **integrated development environment**
    (**IDE**).
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用如`Python -m unittest <测试套件或模块>`这样的命令来运行单元测试，但本章提供的代码示例将假设我们正在使用PyCharm **集成开发环境**（**IDE**）来运行测试用例。
- en: Next, we will build the next level of test cases using the test fixtures.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用测试固定装置构建下一级的测试用例。
- en: Building test cases with test fixtures
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用测试固定装置构建测试用例
- en: We have discussed `setUp` and `tearDown` methods that are run automatically
    by test runners before and after executing a test case. These methods (along with
    the `setUpClass` and `tearDownClass` methods) provide the test fixtures and are
    useful to implement the unit tests efficiently.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在执行测试用例前后由测试运行器自动运行的`setUp`和`tearDown`方法。这些方法（以及`setUpClass`和`tearDownClass`方法）提供了测试固定装置，并且对于有效地实现单元测试非常有用。
- en: 'First, we will revise the implementation of our `add` function. In the new
    implementation, we will make this unit of code a part of the `MyAdd` class. We
    are also handling the situation by throwing a `TypeError` exception in case the
    input arguments are invalid. Next is the complete code snippet with the new `add`
    method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将修改`add`函数的实现。在新实现中，我们将这段代码单元作为`MyAdd`类的一部分。我们还通过在输入参数无效的情况下抛出`TypeError`异常来处理这种情况。下面是包含新`add`方法的完整代码片段：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the previous section, we built test cases using only the act stage and the
    assert stage. In this section, we will revise the previous code example by adding
    `setUp` and `tearDown` methods. Next is the test suite for this `myAdd` class,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们仅使用行为阶段和断言阶段构建了测试用例。在本节中，我们将通过添加`setUp`和`tearDown`方法来修改之前的代码示例。下面是`myAdd`类的测试套件，如下所示：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this test suite, we added or changed the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试套件中，我们添加或更改了以下内容：
- en: We added a `setUp` method in which we created a new instance of the `MyAdd`
    class and saved its reference as an instance attribute. This means we will be
    creating a new instance of the `MyAdd` class *before* we execute any test case.
    This may not be ideal for this test suite, as a better approach could be to use
    the `setUpClass` method and create a single instance of the `MyAdd` class for
    the whole test suite, but we have implemented it this way for illustration purposes.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`setUp`方法中创建了一个新的`MyAdd`类实例，并将其引用保存为实例属性。这意味着在执行任何测试用例之前，我们将创建一个新的`MyAdd`类实例。这可能不是这个测试套件的理想做法，因为更好的方法可能是使用`setUpClass`方法，为整个测试套件创建一个`MyAdd`类的单个实例，但我们这样实现是为了说明目的。
- en: We also added a `tearDown` method. To demonstrate how to implement it, we simply
    called the destructor (using the `del` function) on the `MyAdd` instance that
    we created in the `setUp` method. As with the `setUp` method, the `tearDown` method
    is executed *after* each test case. If we intend to use the `setUpClass` method,
    there is an equivalent method for teardown, which is `tearDownClass`.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还添加了一个`tearDown`方法。为了演示如何实现它，我们简单地调用了在`setUp`方法中创建的`MyAdd`实例的析构函数（使用`del`函数）。与`setUp`方法一样，`tearDown`方法是在每个测试用例之后执行的。如果我们打算使用`setUpClass`方法，有一个等效的`tearDownClass`方法。
- en: In the next section, we will present code examples that will build test cases
    to handle a `TypeError` exception.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示构建测试用例以处理`TypeError`异常的代码示例。
- en: Building test cases with error handling
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有错误处理的测试用例构建
- en: In the previous code examples, we only compared the test-case results with the
    expected results. We did not consider any exception handling such as what would
    be the behavior of our program if the wrong types of arguments were passed as
    input to our `add` function. The unit tests have to cover these aspects of the
    programming as well.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码示例中，我们只比较了测试用例的结果与预期结果。我们没有考虑任何异常处理，例如如果将错误类型的参数传递给我们的`add`函数，我们的程序会有什么行为。单元测试也必须涵盖编程的这些方面。
- en: 'In the next code example, we will build test cases to handle errors or exceptions
    which are expected from a unit of code. For this example, we will use the same
    `add` function, which throws a `TypeError` exception if the argument is not a
    number. The test cases will be built by passing non-numeric arguments to the `add`
    function. The next code snippet shows the test cases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码示例中，我们将构建测试用例以处理来自代码单元的预期错误或异常。对于这个例子，我们将使用相同的`add`函数，如果参数不是数字，它将抛出`TypeError`异常。测试用例将通过向`add`函数传递非数字参数来构建。下一个代码片段显示了测试用例：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, we added two additional test cases to the `test_add3.py`
    module. These test cases use the `assertRaises` method to validate if a particular
    type of exception is thrown or not. In our test cases, we used a single letter
    (`a`) or two letters (`a` and `b`) as arguments for the two test cases. In both
    cases, we are expecting the intended exception (`TypeError`) to be thrown. It
    is important to note the arguments of the `assertRaises` method. This method expects
    only the method or function name as a second argument. The parameters of the method
    or function have to be passed separately as arguments of the `assertRaises` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`test_add3.py`模块中添加了两个额外的测试用例。这些测试用例使用`assertRaises`方法来验证是否抛出了特定类型的异常。在我们的测试用例中，我们使用单个字母（`a`）或两个字母（`a`和`b`）作为两个测试用例的参数。在两种情况下，我们都期望抛出预期的异常（`TypeError`）。注意`assertRaises`方法的参数。此方法只期望将方法或函数名称作为第二个参数。方法或函数的参数必须作为`assertRaises`函数的参数单独传递。
- en: So far, we have executed multiple test cases under a single test suite. In the
    next section, we will discuss how we can run multiple test suites simultaneously,
    using the command line and also programmatically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在单个测试套件下执行了多个测试用例。在下一节中，我们将讨论如何同时运行多个测试套件，使用命令行以及程序化方式。
- en: Executing multiple test suites
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行多个测试套件
- en: As we built test cases for each unit of code, the number of test cases (unit
    test cases) grows very quickly. The idea of using test suites is to bring modularity
    into the test-case development. Test suites also make it easier to maintain and
    extend the test cases as we add more functionality to an application. The next
    aspect that comes to our mind is how to execute multiple test suites through a
    master script or a workflow. CI tools such as Jenkins provides such functionality
    out of the box. Test frameworks such as `unittest`, `nose`, or `pytest` also provide
    similar features.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们为每个代码单元构建测试用例，测试用例的数量（单元测试用例）会迅速增长。使用测试套件的想法是将模块化引入测试用例的开发中。测试套件也使得在添加更多功能到应用程序时维护和扩展测试用例变得更加容易。接下来我们想到的是如何通过主脚本或工作流程来执行多个测试套件。像Jenkins这样的CI工具提供了这样的功能。像`unittest`、`nose`或`pytest`这样的测试框架也提供了类似的功能。
- en: 'In this section, we will build a simple calculator application (a `MyCalc`
    class) with `add`, `subtract`, `multiply`, and `divide` methods in it. Later,
    we will add one test suite for each method in this class. This way, we will add
    four test suites for this calculator application. A directory structure is important
    in implementing the test suites and test cases. For this application, we will
    use the following directory structure:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个简单的计算器应用程序（一个`MyCalc`类），其中包含`add`、`subtract`、`multiply`和`divide`方法。稍后，我们将为这个类中的每个方法添加一个测试套件。这样，我们将为这个计算器应用程序添加四个测试套件。目录结构在实现测试套件和测试用例时非常重要。对于这个应用程序，我们将使用以下目录结构：
- en: '![Figure 5.3 – Directory structure for the mycalc application and test suites
    associated with this application'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – mycalc应用程序及其相关测试套件的目录结构'
- en: '](img/B17189_05_03.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17189_05_03.jpg)'
- en: Figure 5.3 – Directory structure for the mycalc application and test suites
    associated with this application
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – mycalc应用程序及其相关测试套件的目录结构
- en: 'The Python code is written in the `mycalc.py` module and the test suite files
    (`test_mycalc*.py`) are shown next. Note that we show only one test case in each
    test suite in the code examples shown next. In reality, there will be multiple
    test cases in each test suite. We will start with the calculator functions in
    the `mycalc.py` file, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码编写在`mycalc.py`模块中，测试套件文件（`test_mycalc*.py`）将在下面展示。请注意，我们只展示了每个测试套件中的单个测试用例。实际上，每个测试套件中都会有多个测试用例。我们将从`mycalc.py`文件中的计算器函数开始，如下所示：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we have a test suite to test the `add` function in the `test_mycalc_add.py`
    file, as illustrated in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个测试套件用于测试`test_mycalc_add.py`文件中的`add`函数，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we have a test suite to test the `subtract` function in the `test_mycalc_subtract.py`
    file, as illustrated in the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个测试套件用于测试`test_mycalc_subtract.py`文件中的`subtract`函数，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we have a test suite to test the `multiply` function in the `test_mycalc_multiply.py`
    file, as illustrated in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个测试套件用于测试`test_mycalc_multiply.py`文件中的`multiply`函数，如下面的代码片段所示：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we have a test suite to test the `divide` function in the `test_mycalc_divide.py`
    file, as illustrated in the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个测试套件用于测试`test_mycalc_divide.py`文件中的`divide`函数，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have the sample application code and all four test suites'' code. The next
    aspect is how to execute all the test suites in one go. One easy way to do this
    is by using the `discover` keyword. In our example case, we will run the following
    command from the top of the project to discover and execute all test cases in
    all the four test suites that are available in the `tests_mycalc` directory:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了示例应用程序代码和所有四个测试套件的代码。下一个方面是如何一次性执行所有测试套件。一个简单的方法是使用`discover`关键字。在我们的示例案例中，我们将从项目的顶部运行以下命令来发现并执行`tests_mycalc`目录中所有四个测试套件中的所有测试用例：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will be executed recursively, which means it can discover the
    test cases in sub-directories as well. The other (optional) parameters can be
    used to select a set of test cases for execution, and these are described as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将以递归方式执行，这意味着它还可以发现子目录中的测试用例。其他（可选）参数可以用来选择要执行的测试用例集，具体描述如下：
- en: '`-v`: To make the output verbose.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`：使输出详细。'
- en: '`-s`: Start directory for the discovery of test cases.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：测试用例发现的起始目录。'
- en: '`-p`: Pattern to use for searching the test files. The default is `test*.py`,
    but it can be changed by this parameter.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：用于搜索测试文件的模式。默认为`test*.py`，但可以通过此参数更改。'
- en: '`-t`: This is a top-level directory of the project. If not specified, the start
    directory is the top-level directory'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`：这是项目的顶层目录。如果没有指定，起始目录是顶层目录'
- en: 'Although the command-line option of running multiple test suites is simple
    and powerful, we sometimes need to control the way we run selected tests from
    different test suites that may be in different locations. This is where loading
    and executing the test cases through the Python code is handy. The next code snippet
    is an example of how to load the test suites from a class name, find the test
    cases in each of the suites, and then run them using the `unittest` test runner:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管运行多个测试套件的命令行选项简单且强大，但我们有时需要控制从不同位置的不同测试套件中运行选定测试的方式。这就是通过Python代码加载和执行测试用例变得方便的地方。下面的代码片段是一个示例，展示了如何从类名中加载测试套件，在每个套件中查找测试用例，然后使用`unittest`测试运行器运行它们：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this section, we have covered building test cases using the `unittest` library.
    In the next section, we will work with the `pytest` library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用`unittest`库构建测试用例。在下一节中，我们将使用`pytest`库。
- en: Working with the pytest framework
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与pytest框架一起工作
- en: The test cases written using the `unittest` library are easier to read and manage,
    especially if you are coming from a background of using JUnit or other similar
    frameworks. But for large-scale Python applications, the `pytest` library stands
    out as one of the most popular frameworks, mainly because of its ease of use in
    implementation and its ability to extend for complex testing requirements. In
    the case of the `pytest` library, there is no requirement to extend the unit test
    class from any base class; in fact, we can write the test cases without even implementing
    any class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unittest`库编写的测试用例更容易阅读和管理，尤其是如果你来自使用JUnit或其他类似框架的背景。但对于大规模Python应用程序，`pytest`库因其易于实现和使用以及能够扩展以满足复杂测试需求而脱颖而出。在`pytest`库的情况下，没有要求从任何基类扩展单元测试类；实际上，我们可以编写测试用例而不实现任何类。
- en: '`pytest` is an open source framework. The `pytest` test framework can auto-discover
    tests, just as with the `unittest` framework, if the filename has a `test` prefix,
    and this discovery format is configurable. The `pytest` framework includes the
    same level of functionality as it is provided by the `unittest` framework for
    writing unit tests. In this section, we will focus on discussing the features
    that are different or additional in the `pytest` framework.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`是一个开源框架。与`unittest`框架一样，`pytest`测试框架可以自动发现测试，如果文件名有`test`前缀，并且这种发现格式是可以配置的。`pytest`框架提供的功能与`unittest`框架提供的单元测试功能相同。在本节中，我们将重点讨论`pytest`框架中不同或额外的功能。'
- en: Building test cases without a base class
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无基类构建测试用例
- en: 'To demonstrate how to write unit test cases using the `pytest` library, we
    will revise our `myadd2.py` module by implementing the `add` function without
    a class. This new `add` function will add two numbers and throw an exception if
    the *numbers* are not passed as arguments. The test-case code using the `pytest`
    framework is shown in the following snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`pytest`库编写单元测试用例，我们将通过实现没有类的`add`函数来修改我们的`myadd2.py`模块。这个新的`add`函数将添加两个数字，如果*数字*没有作为参数传递，则抛出异常。使用`pytest`框架的测试用例代码如下所示：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the test cases'' module is shown next, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将展示测试用例的模块，如下所示：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We only showed two test cases for the `test_myadd3.py` module as the other
    test cases will be similar to the first two test cases. These additional test
    cases are available with this chapter''s source code under the GitHub directory.
    A couple of key differences in the test case implementation are outlined here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只为`test_myadd3.py`模块展示了两个测试用例，因为其他测试用例将与前两个测试用例相似。这些额外的测试用例可以在本章的GitHub目录下的源代码中找到。以下是对测试用例实现中的一些关键差异进行了概述：
- en: There is no requirement to implement test cases under a class, and we can implement
    test cases as class methods without inheriting them from any base class. This
    is a key difference in comparison to the `unittest` library.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有要求在类下实现测试用例，我们可以实现测试用例作为类方法，而不需要从任何基类继承。这与`unittest`库相比是一个关键差异。
- en: The `assert` statements are available as a keyword for validation of any condition
    to declare whether a test passed or failed. Separating `assert` keywords from
    the conditional statement makes assertions in test cases very flexible and customizable.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert`语句可以作为关键字用于验证任何条件，以声明测试是否通过。将`assert`关键字从条件语句中分离出来，使得测试用例中的断言非常灵活和可定制。'
- en: 'It is also important to mention that the console output and the reporting is
    more powerful with the `pytest` framework. As an example, the console output of
    executing test cases using the `test_myadd3.py` module is shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，使用`pytest`框架，控制台输出和报告功能更加强大。例如，使用`test_myadd3.py`模块执行测试用例的控制台输出如下所示：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we will investigate how to validate expected errors using the `pytest`
    library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用`pytest`库验证预期的错误。
- en: Building test cases with error handling
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用错误处理构建测试用例
- en: 'Writing test cases to validate the throwing of an expected exception or error
    is different in the `pytest` framework as compared to writing such test cases
    in the `unittest` framework. The `pytest` framework utilizes the context manager
    for exception validation. In our `test_myadd3.py` test module, we already added
    two test cases for exception validation. An extract of the code in the `test_myadd3.py`
    module with the two test cases is shown next, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pytest`框架中编写用于验证预期抛出异常或错误的测试用例与在`unittest`框架中编写此类测试用例不同。`pytest`框架利用上下文管理器进行异常验证。在我们的`test_myadd3.py`测试模块中，我们已经添加了两个用于异常验证的测试用例。下面是`test_myadd3.py`模块中包含这两个测试用例的代码片段：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To validate the exception, we are using the `raises` function of the `pytest`
    library to indicate what sort of exception is expected by running a certain unit
    of code (`add('a', 5)` in our first test case). In the second test case, we used
    a `match` argument to validate the message that is set when an exception is thrown.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证异常，我们使用`pytest`库的`raises`函数来指示通过运行某个单元代码（我们第一个测试用例中的`add('a', 5)`）预期的异常类型。在第二个测试用例中，我们使用了`match`参数来验证抛出异常时设置的消息。
- en: Next, we will discuss how to use markers with the `pytest` framework.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用`pytest`框架中的标记。
- en: Building test cases with pytest markers
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pytest标记构建测试用例
- en: The `pytest` framework is equipped with markers that allow us to attach metadata
    or define different categories for our test cases. This metadata can be used for
    many purposes, such as including or excluding certain test cases. The markers
    are implemented using the `@pytest.mark` decorator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`框架配备了标记，允许我们为我们的测试用例附加元数据或定义不同的类别。这些元数据可用于许多目的，例如包括或排除某些测试用例。标记是通过使用`@pytest.mark`装饰器实现的。'
- en: 'The `pytest` framework provides a few built-in markers, with the most popular
    ones being described next:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`框架提供了一些内置标记，下面将描述其中最受欢迎的几个：'
- en: '`skip`: The test runner will skip a test case unconditionally when this marker
    is used.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip`：当使用此标记时，测试运行器将无条件地跳过测试用例。'
- en: '`skipif`: This marker is used to skip a test based on a conditional expression
    that is passed as an argument to this marker.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipif`：此标记用于根据传递给此标记的条件表达式跳过测试。'
- en: '`xfail`: This marker is used to ignore an expected failure in a test case.
    It is used with a certain condition.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xfail`：此标记用于忽略测试用例中预期的失败。它是在特定条件下使用的。'
- en: '`parametrize`: This marker is used to perform multiple calls to the test case
    with different values as arguments.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parametrize`：此标记用于使用不同的值作为参数对测试用例进行多次调用。'
- en: 'To demonstrate the use of the first three markers, we rewrite our `test_add3.py`
    module by adding markers with the test-case functions. The revised test-case module
    (`test_add4.py`) is shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示前三个标记的使用，我们通过为测试用例函数添加标记来重写我们的`test_add3.py`模块。修改后的测试用例模块（`test_add4.py`）如下所示：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We used the `skip` marker unconditionally for the first test case. This will
    ignore the test case. For the second test case, we used the `skipif` marker with
    a condition of a Python version greater than 3.6\. For the last test case, we
    deliberately raised an exception, and we used the `xfail` marker to ignore this
    type of exception if the system platform is Windows. This type of marker is helpful
    for ignoring errors in test cases if they are expected for a certain condition,
    such as the operating system in this case.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无条件地使用了`skip`标记来忽略第一个测试用例。这将忽略该测试用例。对于第二个测试用例，我们使用了带有条件（Python版本大于3.6）的`skipif`标记。对于最后一个测试用例，我们故意抛出一个异常，并使用`xfail`标记来忽略如果系统平台是Windows的此类异常。此类标记有助于在预期某些条件（如本例中的操作系统）下忽略测试用例中的错误。
- en: 'The console output from the execution of the test cases is shown here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的执行控制台输出如下所示：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we will discuss the use of the `parametrize` marker with the `pytest`
    library.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用`pytest`库中的`parametrize`标记。
- en: Building test cases with parametrization
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用参数化构建测试用例
- en: In all previous code examples, we built test-case functions or methods without
    passing any parameters to them. But for many test scenarios, we need to run the
    same test case by varying the input data. In a classical approach, we run multiple
    test cases that are different only in terms of the input data we used for them.
    Our previous example of `test_myadd3.py` shows how to implement test cases using
    this classical approach. A recommended approach for such type of testing is to
    use `pytest` will execute our test case as many times as the number of permutations
    is in the table or the dictionary. A real-world example of DDT is to validate
    the behavior of a login feature of an application by using a variety of users
    with valid and invalid credentials.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的代码示例中，我们构建了没有传递任何参数给它们的测试用例函数或方法。但对于许多测试场景，我们需要通过改变输入数据来运行相同的测试用例。在经典方法中，我们运行多个测试用例，这些测试用例在输入数据方面不同。我们之前的`test_myadd3.py`示例展示了如何使用这种方法实现测试用例。对于此类测试，一个推荐的方法是使用`pytest`，它将根据表或字典中的排列数量执行我们的测试用例。DDT的一个现实世界示例是使用各种具有有效和无效凭证的用户来验证应用程序登录功能的操作行为。
- en: In the `pytest` framework, DDT can be implemented using parametrization with
    the `pytest` marker. By using the `parametrize` marker, we can define which input
    argument we need to pass and also the test dataset we need to use. The `pytest`
    framework will automatically execute the test-case function multiple times as
    per the number of entries in the test data provided with the `parametrize` marker.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pytest`框架中，可以使用`pytest`标记进行参数化来实现DDT。通过使用`parametrize`标记，我们可以定义需要传递的输入参数以及需要使用的测试数据集。`pytest`框架将根据`parametrize`标记提供的测试数据条目数量自动多次执行测试用例函数。
- en: 'To illustrate how to use the `parametrize` marker for DDT, we will revise our
    `myadd4.py` module for the test cases of the `add` function. In the revised code,
    we will have only one test-case function but different test data to be used for
    the input parameters, as illustrated in the following snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用`parametrize`标记进行数据驱动测试（DDT），我们将修改我们的`myadd4.py`模块以适应`add`函数的测试用例。在修改后的代码中，我们将只有一个测试用例函数，但将使用不同的测试数据作为输入参数，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the `parametrize` marker, we used three parameters, which are described
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`parametrize`标记，我们使用了三个参数，具体描述如下：
- en: '**Test-case arguments**: We provide a list of arguments to be passed to our
    test function in the same order as defined with the test-case function definition.
    Also, the test data we need to provide in the next argument will follow the same
    order.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试用例参数**：我们提供了一个参数列表，这些参数将按照与测试用例函数定义相同的顺序传递给我们的测试函数。此外，我们将在下一个参数中提供的测试数据也将遵循相同的顺序。'
- en: '**Data**: The test data to be passed will be a list of different sets of input
    arguments. The number of entries in the test data will determine how many times
    the test case will be executed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：要传递的测试数据将是一系列不同的输入参数集合。测试数据中的条目数量将决定测试用例将执行多少次。'
- en: '`ids`: This is an optional parameter that is mainly attaching a friendly tag
    to different test datasets we provided in the previous argument. These **identifier**
    (**ID**) tags will be used in the output report to identify different executions
    of the same test case.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ids`：这是一个可选参数，主要用于为之前参数中提供的不同测试数据集附加一个友好的标签。这些**标识符**（**ID**）标签将在输出报告中用于识别同一测试用例的不同执行。'
- en: 'The console output for this test-case execution is shown next:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了此测试用例执行的控制台输出：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This console output shows us how many times the test case is executed and with
    which test data. The test cases built using the `pytest` markers are concise and
    easy to implement. This saves a lot of time and enables us to write more test
    cases (by varying data only) in a short time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制台输出显示了测试用例执行的次数以及使用了哪些测试数据。使用`pytest`标记构建的测试用例简洁且易于实现。这节省了大量时间，并使我们能够在短时间内编写更多的测试用例（仅通过改变数据）。
- en: 'Next, we will discuss another important feature of the `pytest` library: fixtures.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论`pytest`库的另一个重要特性：固定值（fixtures）。
- en: Building test cases with pytest fixtures
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用pytest固定值构建测试用例
- en: 'In the `pytest` framework, the test fixtures are implemented using Python decorators
    `(@pytest.fixture`). The implementation of test fixtures in the `pytest` framework
    is very powerful as compared to the other frameworks for the following key reasons:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pytest` 框架中，测试固定装置是通过 Python 装饰器 `(@pytest.fixture)` 实现的。与其它框架相比，`pytest`
    框架中测试固定装置的实现非常强大，以下是一些关键原因：
- en: Fixtures in the `pytest` framework provide high scalability. We can define a
    generic setup or fixtures (methods) that can be reused across functions, classes,
    modules, and packages.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 框架中的固定装置提供了高度的扩展性。我们可以定义通用的设置或固定装置（方法），这些可以在函数、类、模块和包之间重用。'
- en: Fixture implementation of the `pytest` framework is modular in nature. We can
    use one or more fixtures with a test case. A fixture can use one or many other
    fixtures as well, just as we use functions to call other functions.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 框架的固定装置实现是模块化的。我们可以为测试用例使用一个或多个固定装置。一个固定装置也可以使用一个或多个其他固定装置，就像我们使用函数调用其他函数一样。'
- en: Each test case in a test suite will have the flexibility to use the same or
    a different set of fixtures.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试套件中的每个测试用例都将具有使用相同或不同固定装置集的灵活性。
- en: 'We can create fixtures in the `pytest` framework with a scope set for them.
    The default scope is `function`, which means the fixture will be executed before
    every function (test case). Other scope options are `module`, `class`, `package`,
    or `session`. These are defined briefly next:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在 `pytest` 框架中创建固定装置，并为它们设置范围。默认范围是 `function`，这意味着固定装置将在每个函数（测试用例）执行之前执行。其他范围选项有
    `module`、`class`、`package` 或 `session`。以下简要定义：
- en: 'a) `Function`: The fixture is destroyed after executing a test case.'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a) `Function`：固定装置在执行测试用例后将被销毁。
- en: 'b) `Module`: The fixture is destroyed after executing the last test case in
    a module.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b) `Module`：固定装置在执行模块中的最后一个测试用例后将被销毁。
- en: 'c) `Class`: The fixture is destroyed after executing the last test case in
    a class.'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c) `Class`：固定装置在执行类中的最后一个测试用例后将被销毁。
- en: 'd) `Package`: The fixture is destroyed after executing the last test case in
    a package.'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d) `Package`：固定装置在执行包中的最后一个测试用例后将被销毁。
- en: 'e) `Session`: The fixture is destroyed after executing the last test case in
    a test session.'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: e) `Session`：固定装置在执行测试会话中的最后一个测试用例后将被销毁。
- en: The `pytest` framework has a few useful built-in fixtures that can be used out
    of the box, such as `capfd` to capture output to the file descriptors, `capsys`
    to capture output to `stdout` and `stderr`, `request` to provide information on
    the requesting test function, and `testdir` to provide a temporary test directory
    for test executions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 框架有一些有用的内置固定装置可以直接使用，例如 `capfd` 用于捕获输出到文件描述符，`capsys` 用于捕获输出到 `stdout`
    和 `stderr`，`request` 用于提供关于请求测试函数的信息，以及 `testdir` 用于提供测试执行的临时测试目录。'
- en: Fixtures in the `pytest` framework can be used to reset or tear down at the
    end of a test case as well. We will discuss this later on in this section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 框架中的固定装置可以在测试用例结束时用于重置或拆卸。我们将在本节稍后讨论这一点。'
- en: 'In the next code example, we will build test cases for our `MyCalc` class using
    custom fixtures. The sample code for `MyCalc` is already shared in the *Executing
    multiple test suites* section. The implementation of a test fixture and test cases
    is shown here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码示例中，我们将使用自定义固定装置为我们的 `MyCalc` 类构建测试用例。`MyCalc` 的示例代码已在 *执行多个测试套件* 部分中分享。固定装置和测试用例的实现如下所示：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this test-suite example, these are the key points of discussion:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试套件示例中，以下是我们讨论的关键点：
- en: 'We created two fixtures: `my_calc` and `test_data`. The `my_calc` fixture is
    set with a scope set to `module` because we want it to be executed only once to
    provide an instance of the `MyCalc` class. The `test_data` fixture is using the
    default scope (`function`), which means it will be executed before every method.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了两个固定装置：`my_calc` 和 `test_data`。`my_calc` 固定装置的设置范围设置为 `module`，因为我们希望它只执行一次，以提供一个
    `MyCalc` 类的实例。`test_data` 固定装置使用默认范围（`function`），这意味着它将在每个方法执行之前执行。
- en: For the test cases (`test_add` and `test_subtract`), we used the fixtures as
    input arguments. The name of the argument has to match the fixture function name.
    The `pytest` framework automatically looks for a fixture with the name used as
    an argument for a test case.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于测试用例（`test_add` 和 `test_subtract`），我们使用了固定装置作为输入参数。参数的名称必须与固定装置函数名称匹配。`pytest`
    框架会自动查找用于测试用例的参数名称对应的固定装置。
- en: 'The code example we discussed is using a fixture as the setup function. A question
    we may want to ask is: *How we can achieve teardown functionality with the pytest
    fixtures?* There are two approaches available for implementing the teardown functionality,
    and these are discussed next.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的代码示例是使用 fixture 作为设置函数。我们可能想要问的问题是：*我们如何通过 pytest fixtures 实现拆卸功能？* 实现拆卸功能有两种方法，接下来将进行讨论。
- en: Using yield instead of a return statement
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 yield 代替 return 语句
- en: With this approach, we write some code mainly for setup purposes, use a `yield`
    statement instead of `return`, and then write code for teardown purposes after
    the `yield` statement. If we have a test suite or module with many fixtures used
    in it, the `pytest` test runner will execute each fixture (as per the evaluated
    order of execution) till the `yield` statement is encountered. As soon as the
    test-case execution is completed, the `pytest` test runner triggers the execution
    of all fixtures that are yielded and executes the code that is written after the
    `yield` statement. The use of a yield-based approach is clean in the sense that
    the code is easy to follow and maintain. Therefore, it is a recommended approach.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们编写一些代码主要是为了设置目的，使用 `yield` 语句而不是 `return`，然后在 `yield` 语句之后编写拆卸目的的代码。如果我们有一个包含许多
    fixtures 的测试套件或模块，`pytest` 测试运行器将执行每个 fixture（按照评估的执行顺序），直到遇到 `yield` 语句。一旦测试用例执行完成，`pytest`
    测试运行器将触发所有已 `yield` 的 fixtures 的执行，并执行 `yield` 语句之后的代码。基于 yield 的方法在代码易于遵循和维护方面很干净。因此，这是一个推荐的方法。
- en: Adding a finalizer method using the request fixture
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用请求 fixture 添加最终化方法
- en: 'With this approach, we have to consider three steps to write a teardown method,
    outlined as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们必须考虑三个步骤来编写拆卸方法，概述如下：
- en: We have to use a `request` object in our fixtures. The `request` object can
    be provided using the built-in fixture with the same name.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须在 fixtures 中使用一个 `request` 对象。`request` 对象可以使用具有相同名称的内置 fixture 提供。
- en: We will define a `teardown` method, separately or as a part of the fixture implementation.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将定义一个 `teardown` 方法，单独或作为 fixture 实现的一部分。
- en: We will provide the `teardown` method as a callable method to the request object
    using the `addfinalizer` method.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `addfinalizer` 方法将 `teardown` 方法作为可调用方法提供给请求对象。
- en: 'To illustrate both approaches with code examples, we will modify our previous
    implementation of the fixtures. In the revised code, we will implement the `my_calc`
    fixture using a `yield` approach and the `data_set` fixture using an `addfinalizer`
    approach. Here is the revised code example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过代码示例说明这两种方法，我们将修改我们之前对 fixtures 的实现。在修改后的代码中，我们将使用 `yield` 方法实现 `my_calc`
    fixture，并使用 `addfinalizer` 方法实现 `data_set` fixture。以下是修改后的代码示例：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that there is no real need for teardown functionality for these example
    fixtures, but we added them for illustration purposes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于这些示例 fixtures，实际上没有必要进行拆卸功能，但我们添加它们是为了说明目的。
- en: Tip
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using `nose` and `doctest` for test automation is similar to using the `unittest`
    and `pytest` frameworks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `nose` 和 `doctest` 进行测试自动化类似于使用 `unittest` 和 `pytest` 框架。
- en: In the next section, we will discuss a TDD approach to software development.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论软件开发的 TDD 方法。
- en: Executing TDD
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行 TDD
- en: 'TDD is a well-known practice in software engineering. This is a software development
    approach in which test cases are written first before writing any code for a required
    feature in an application. Here are the three simple rules of TDD:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是软件工程中众所周知的一种实践。这是一种软件开发方法，其中在编写应用程序中所需功能的任何代码之前，首先编写测试用例。以下是 TDD 的三个简单规则：
- en: Do not write any functional code unless you write a unit test that is failing.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你编写一个失败的单元测试，否则不要编写任何功能代码。
- en: Do not write any additional code in the same test more than you need to make
    the test fail.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在同一个测试中编写任何超过使测试失败的代码。
- en: Do not write any functional code more than what is needed to pass a failing
    test.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写任何超过通过失败测试所需的函数代码。
- en: These TDD rules also drive us to follow a famous three-phase approach of software
    development called **Red, Green, Refactor**. The phases are repeated continuously
    for TDD. These three phases are shown in *Figure 5.4* and are described next.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 TDD 规则还驱使我们遵循一个著名的软件开发三阶段方法，称为 **红、绿、重构**。这些阶段在 TDD 中持续重复。这三个阶段在 *图 5.4*
    中显示，并将在下面进行描述。
- en: Red
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红色
- en: In this phase, the first step is to write a test without having any code to
    test. The test will obviously fail in this case. We will not try to write a complete
    test case but only write enough code to fail the test.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，第一步是编写一个没有测试代码的测试。在这种情况下，测试显然会失败。我们不会尝试编写一个完整的测试用例，而只是编写足够的代码来使测试失败。
- en: Green
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绿色
- en: In this phase, the first step is to write the code until an already written
    test passes. Again, we will only write enough code to pass the test. We will run
    all tests to make sure previously written tests also pass.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，第一步是编写代码，直到已经编写的测试通过。再次强调，我们只会编写足够的代码来通过测试。我们将运行所有测试以确保之前编写的测试也能通过。
- en: Refactor
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: In this phase, we should consider improving the quality of the code, which means
    making the code easy to read and use optimization—for example, any hardcoded values
    have to be removed. Running the tests after each refactoring cycle is also recommended.
    The outcome of the refactor phase is clean code. We can repeat the cycle by adding
    more test scenarios and adding code to make the new test pass, and this cycle
    must be repeated until a feature is developed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该考虑提高代码质量，这意味着使代码易于阅读和使用优化——例如，任何硬编码的值都必须移除。在重构周期后运行测试也是推荐的。重构阶段的成果是干净的代码。我们可以通过添加更多测试场景并添加代码来使新测试通过来重复这个周期，并且这个周期必须重复，直到开发出功能。
- en: It is important to understand that TDD is neither a testing nor a design approach.
    It is an approach to developing software according to specifications that are
    defined by writing test cases first.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 TDD 既不是一种测试方法，也不是一种设计方法。它是一种根据首先编写的测试用例来开发软件的方法。
- en: 'The following diagram shows the three phases of TDD:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 TDD 的三个阶段：
- en: '![Figure 5.4 – TDD, also known as Red, Green, Refactor'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – TDD，也称为红、绿、重构'
- en: '](img/B17189_05_04.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17189_05_04.jpg)'
- en: Figure 5.4 – TDD, also known as Red, Green, Refactor
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – TDD，也称为红、绿、重构
- en: In the next section, we will introduce the role of test automation in the CI
    process.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍测试自动化在 CI 流程中的作用。
- en: Introducing automated CI
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入自动化 CI
- en: 'CI is a process that combines the benefits of both automated testing and version
    control systems to achieve a fully automated integration environment. With a CI
    development approach, we integrate our code into a shared repository frequently.
    Every time we add our code to a repository, the following two processes are expected
    to kick in:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一个结合了自动化测试和版本控制系统优势的过程，以实现完全自动化的集成环境。采用 CI 开发方法，我们频繁地将代码集成到共享仓库中。每次我们将代码添加到仓库中，都期望以下两个过程启动：
- en: An automated build process starts to validate that the newly added code is not
    breaking anything from a compilation or syntax point of view.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动构建过程开始验证新添加的代码在编译或语法方面没有破坏任何东西。
- en: An automated test execution starts to verify that the existing, as well as new
    functionality is as per the test cases defined.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试执行开始验证现有功能以及新功能是否符合定义的测试用例。
- en: 'The different steps and phases of the CI process are depicted in the following
    diagram. Although we have shown the build phase in this flowchart, it is not a
    required phase for Python-based projects as we can execute integration tests without
    compiled code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 CI 流程的不同步骤和阶段。虽然我们在流程图中展示了构建阶段，但对于基于 Python 的项目来说，这不是一个必需的阶段，因为我们可以在没有编译代码的情况下执行集成测试：
- en: '![Figure 5.5 – Phases of CI testing'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – CI 测试阶段'
- en: '](img/B17189_05_05.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17189_05_05.jpg)'
- en: Figure 5.5 – Phases of CI testing
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – CI 测试阶段
- en: To build a CI system, we need to have a stable distributed version control and
    a tool that can be used to implement workflow for testing the whole application
    through a series of test suites. There are several commercial and open source
    software tools available that provide CI and **continuous delivery** (**CD**)
    functionality. These tools are designed for easy integration with a source control
    system and with a test automation framework. A few popular tools available for
    CI are *Jenkins*, *Bamboo*, *Buildbot*, *GitLab CI*, *CircleCI,* and *Buddy*.
    Details of these tools appear in the *Further reading* section, for those of you
    who are interested to learn more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个持续集成（CI）系统，我们需要一个稳定的分布式版本控制系统，以及一个可以用来通过一系列测试套件测试整个应用程序工作流程的工具。市面上有几种商业和开源软件工具提供持续集成和**持续交付（CD**）功能。这些工具旨在易于与源控制系统和测试自动化框架集成。一些流行的CI工具包括
    *Jenkins*、*Bamboo*、*Buildbot*、*GitLab CI*、*CircleCI* 和 *Buddy*。这些工具的详细信息可以在 *进一步阅读*
    部分找到，供那些有兴趣了解更多的人参考。
- en: The obvious benefits of this automated CI are to detect errors quickly and fix
    them more conveniently right at the beginning. It is important to understand that
    CI is not about bug fixing, but it definitely helps to identify bugs easily and
    get them fixed promptly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化的CI的明显好处是能够快速检测错误，并在一开始就方便地修复它们。重要的是要理解，CI不仅仅是关于错误修复，但它确实有助于轻松识别错误并及时修复。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced different levels of testing for software applications.
    We also evaluated two test frameworks (`unittest` and `pytest`) that are available
    for Python test automation. We learned how to build basic- and advanced-level
    test cases using these two frameworks. Later in the chapter, we introduced the
    TDD approach and its clear benefits for software development. Finally, we touched
    base on the topic of CI, which is a key step in delivering software using **agile**
    and **development-operations** (**devops**) models.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了软件应用的不同测试级别。我们还评估了两个可用于Python测试自动化的测试框架（`unittest` 和 `pytest`）。我们学习了如何使用这两个框架构建基本和高级测试用例。在章节的后面部分，我们介绍了TDD方法及其对软件开发明显的益处。最后，我们简要介绍了CI，这是使用**敏捷**和**开发运维（devops**）模型交付软件的关键步骤。
- en: This chapter is useful for anyone who wants to start writing unit tests for
    their Python application. The code examples provided provide a good starting point
    for us to write test cases using any test framework.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这章对任何想要开始为他们的Python应用程序编写单元测试的人来说都很有用。提供的代码示例为我们使用任何测试框架编写测试用例提供了一个良好的起点。
- en: In the next chapter, we will explore different tricks and tips for developing
    applications in Python.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在Python中开发应用程序的不同技巧和提示。
- en: Questions
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is unit testing a form of white-box or black-box testing?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试是白盒测试还是黑盒测试的一种形式？
- en: When should we use mock objects?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么时候使用模拟对象？
- en: Which methods are used to implement test fixtures with the `unittest` framework?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `unittest` 框架实现测试固定有哪些方法？
- en: How is TDD different from CI?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD与CI有何不同？
- en: When should we use DDT?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么时候使用DDT？
- en: Further reading
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Python Testing*, by *Daniel Arbuckle*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python测试学习》，作者：*Daniel Arbuckle*
- en: '*Test-Driven Development with Python*, by *Harry J.W. Percival*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Python测试驱动开发》，作者：*Harry J.W. Percival*
- en: '*Expert Python Programming*, by *Michał Jaworski and Tarek Ziadé*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《专家Python编程》，作者：*Michał Jaworski 和 Tarek Ziadé*
- en: '*unittest* framework details are available with the Python documentation at
    [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*unittest* 框架的详细信息可以在Python文档的[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)找到。'
- en: Answers
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: White-box testing
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 白盒测试
- en: Mock objects help simulate the behavior of external or internal dependencies.
    By using mock objects, we can focus on writing tests for validating functional
    behavior.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟对象有助于模拟外部或内部依赖的行为。通过使用模拟对象，我们可以专注于编写测试来验证功能行为。
- en: '`setUp`, `tearDown`, `setUpClass`, `tearDownClass`'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setUp`、`tearDown`、`setUpClass`、`tearDownClass`'
- en: TDD is an approach to developing software by writing the test cases first. CI
    is a process in which all the tests are executed every time we build a new release.
    There is no direct relationship between TDD and CI.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD是一种先编写测试用例再开发软件的方法。CI是在我们构建新版本时执行所有测试的过程。TDD和CI之间没有直接关系。
- en: DDT is used when we have to do functional testing with several permutations
    of input parameters. For example, if we are required to test an API endpoint with
    a different combination of arguments, we can leverage DDT.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们需要对输入参数的多种排列进行功能测试时，会使用DDT。例如，如果我们需要用不同组合的参数测试一个API端点，我们可以利用DDT。
