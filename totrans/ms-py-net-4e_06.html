<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer084">
    <h1 class="chapterNumber">6</h1>
    <h1 class="chapterTitle" id="_idParaDest-152">Network Security with Python</h1>
    <p class="normal">In my opinion, network security is a tricky topic to write about. The reason is not a technical one but rather has to do with setting up the correct scope. The boundaries of network security are so wide that they touch all seven layers of the OSI model. From layer 1 of wiretapping to layer 4 of the transport protocol vulnerability, to layer 7 of man-in-the-middle spoofing, network security is everywhere. The issue is exacerbated by all the newly discovered vulnerabilities, which sometimes seem to be a daily occurrence. This does not even include the human social engineering aspect of network security.</p>
    <p class="normal">As such, in this chapter, I would like to set the scope for what we will discuss. As we have been doing up to this point, we will primarily focus on using Python for network device security at OSI layers 3 and 4. We will look at Python tools that we can use to manage individual network devices for security purposes, as well as using Python as a glue to connect different components. Hopefully, we can treat network security holistically using Python in different OSI layers.</p>
    <p class="normal">In this chapter, we will take a look at the following topics:</p>
    <ul>
      <li class="bulletList">The lab setup</li>
      <li class="bulletList">Python Scapy for security testing</li>
      <li class="bulletList">Access lists</li>
      <li class="bulletList">Forensic analysis with Syslog and <strong class="keyWord">Uncomplicated Firewall</strong> (<strong class="keyWord">UFW</strong>) using Python</li>
      <li class="bulletList">Other tools, such as a MAC address filter list, private VLAN, and Python IP table binding</li>
    </ul>
    <p class="normal">Let’s begin by looking at our lab setup for this chapter. </p>
    <h1 class="heading-1" id="_idParaDest-153">The Lab Setup</h1>
    <p class="normal">The devices being used in this chapter are a bit different from the previous chapters. In the previous chapters, we isolated a particular set of devices. For this chapter, we will use a few more Linux <a id="_idIndexMarker442"/>hosts in our lab to illustrate the function of the tools we will use. The connectivity and operating system information are important as they have ramifications regarding the security tools we will show later in this chapter. For example, if we want to apply an access list to protect the server, we need to know what the topology looks like and in which direction the client is making their connections. The Ubuntu host connections are a bit different than what we have seen so far, so please refer to this lab section when you see the example later if needed.</p>
    <p class="normal">We will use the same Cisco CML tool with the NYC nodes with two additional Ubuntu hosts. The lab topology is provided with the course files. </p>
    <p class="normal">The way to add a Linux host in CML is the same as adding network nodes, simply click on <strong class="screenText">add nodes</strong> and pick Ubuntu as the selection. We will name the outside host connecting to <code class="inlineCode">nyc-cor-r1</code> as the client, and the host behind <code class="inlineCode">nyc-cor-edg-r1</code> as the server: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_06_01.png"/></figure>
    <p class="packt_figref">Figure 6.1: Adding Ubuntu Hosts</p>
    <p class="normal">This is a good point to review and learn about Ubuntu Linux networking. We will spend some time listing out the Ubuntu Linux networking options of the setup. Here is an overview of the lab topology:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_06_02.png"/></figure>
    <p class="packt_figref">Figure 6.2: Lab Topology</p>
    <div class="note">
      <p class="normal">The IP addresses listed will probably be different in your lab. They are listed here to easily reference in the remainder of the chapter code examples.</p>
    </div>
    <p class="normal">We will add two dual-home<a id="_idIndexMarker443"/> links to the hosts, one for the default gateway going to the unmanaged switch for management and internet. The other link is used to route the internet traffic. As illustrated, we will rename the host on the top as the client, and the bottom host as the server using the <code class="inlineCode">hostname &lt;name&gt;</code> command. This is analogous to an internet client trying to access a corporate server within our network. The version of Ubuntu Linux in the CML software is 18.04 LTS: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@client:~$ lsb_release -a
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 18.04.3 LTS
Release:	18.04
Codename:	bionic
</code></pre>
    <p class="normal">To list and turn up the links, we can use the <code class="inlineCode">ip link</code> and <code class="inlineCode">ifconfig</code> commands: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@client:~$ ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:1e:bc:51 brd ff:ff:ff:ff:ff:ff
3: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:19:54:b5 brd ff:ff:ff:ff:ff:ff
ubuntu@ubuntu:~$ sudo ifconfig ens3 up
</code></pre>
    <p class="normal">For the hosts, when <a id="_idIndexMarker444"/>we first turn it up, it will have an initial network configuration under <code class="inlineCode">/etc/netplan/50-cloud-init.yaml</code>. We will back it up and create our own: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@ubuntu:/etc/netplan$ cd /etc/netplan/
ubuntu@ubuntu:/etc/netplan$ cp 50-cloud-init.yaml 50-cloud-init.yaml.bak 
ubuntu@ubuntu:/etc/netplan$ sudo rm 50-cloud-init.yaml
ubuntu@ubuntu:/etc/netplan$ sudo touch 50-cloud-init.yaml
</code></pre>
    <p class="normal">For the two network links, we will use the following configuration to configure the default gateway for <code class="inlineCode">ens3</code> (management and internet) as well as the internal link: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@client:~$ cat /etc/netplan/50-cloud-init.yaml
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">network:
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">renderer:</span> <span class="hljs-string">networkd</span>
  <span class="hljs-attr">ethernets:</span>
    <span class="hljs-attr">ens3:</span>
      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168.2.152</span><span class="hljs-string">/24</span>]
      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168.2.1</span>
      <span class="hljs-attr">nameservers:</span>
        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168.2.1</span>,<span class="hljs-number">8.8.8.8</span>]
    <span class="hljs-attr">ens2:</span>
      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">10.0.0.5</span><span class="hljs-string">/30</span>]
</code></pre>
    <p class="normal">To allow the network change to take effect, we can use the <code class="inlineCode">netplan apply</code> command: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@ubuntu:/etc/netplan$ sudo netplan apply
</code></pre>
    <p class="normal">Here is a quick output <a id="_idIndexMarker445"/>for the server side: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@server:~$ ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:12:9c:5f brd ff:ff:ff:ff:ff:ff
3: ens3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:0e:f7:ab brd ff:ff:ff:ff:ff:ff
ubuntu@server:~$ cat /etc/netplan/50-cloud-init.yaml
</code></pre>
    <pre class="programlisting code"><code class="hljs-code">network:
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">renderer:</span> <span class="hljs-string">networkd</span>
  <span class="hljs-attr">ethernets:</span>
    <span class="hljs-attr">ens3:</span>
      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168.2.153</span><span class="hljs-string">/24</span>]
      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168.2.1</span>
      <span class="hljs-attr">nameservers:</span>
        <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168.2.1</span>,<span class="hljs-number">8.8.8.8</span>]
    <span class="hljs-attr">ens2:</span>
      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">dhcp6:</span> <span class="hljs-literal">no</span>
      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">10.0.0.9</span><span class="hljs-string">/30</span>]
</code></pre>
    <p class="normal">We will put the connected network into the existing OSPF network. Here is the configuration of <code class="inlineCode">nyc-cor-r1</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">nyc-cor-r1# </span>config t
Enter configuration commands, one per line.  End with CNTL/Z.
<span class="hljs-con-meta">nyc-cor-r1(config)# </span>int ethernet 2/4
<span class="hljs-con-meta">nyc-cor-r1(config-if)# </span>ip add 10.0.0.6/24
<span class="hljs-con-meta">nyc-cor-r1(config-if)# </span>ip router ospf 200 area 0.0.0.200
<span class="hljs-con-meta">nyc-cor-r1(config-if)# </span>no shut
<span class="hljs-con-meta">nyc-cor-r1(config-if)# </span>end
<span class="hljs-con-meta">nyc-cor-r1# </span>ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
36 bytes from 10.0.0.6: Destination Host Unreachable
Request 0 timed out
64 bytes from 10.0.0.5: icmp_seq=1 ttl=63 time=4.888 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=63 time=2.11 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=63 time=2.078 ms
64 bytes from 10.0.0.5: icmp_seq=4 ttl=63 time=0.965 ms
^C
--- 10.0.0.5 ping statistics ---
5 packets transmitted, 4 packets received, 20.00% packet loss
round-trip min/avg/max = 0.965/2.51/4.888 ms
<span class="hljs-con-meta">nyc-cor-r1# </span>
</code></pre>
    <p class="normal">The configuration <a id="_idIndexMarker446"/>of <code class="inlineCode">nyc-cor-edg-r1</code> is as follows: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">nyc-edg-r1#</span>confi t
Enter configuration commands, one per line.  End with CNTL/Z.
<span class="hljs-con-meta">nyc-edg-r1(config)#</span>int gig 0/2
<span class="hljs-con-meta">nyc-edg-r1(config-if)#</span>ip add 10.0.0.10 255.255.255.252
<span class="hljs-con-meta">nyc-edg-r1(config-if)#</span>no shut
<span class="hljs-con-meta">nyc-edg-r1(config-if)#</span>end
<span class="hljs-con-meta">nyc-edg-r1#</span>ping 10.0.0.9
Type escape sequence to abort.
Sending 5, 100-byte ICMP Echos to 10.0.0.9, timeout is 2 seconds:
.!!!!
Success rate is 80 percent (4/5), round-trip min/avg/max = 1/3/7 ms
<span class="hljs-con-meta">nyc-edg-r1#</span>
<span class="hljs-con-meta">nyc-edg-r1#</span>confi t
Enter configuration commands, one per line.  End with CNTL/Z.
<span class="hljs-con-meta">nyc-edg-r1(config)#</span>router ospf 200
<span class="hljs-con-meta">nyc-edg-r1(config-router)#</span>net
<span class="hljs-con-meta">nyc-edg-r1(config-router)#</span>network 10.0.0.8 0.0.0.3 area 200
<span class="hljs-con-meta">nyc-edg-r1(config-router)#</span>end
<span class="hljs-con-meta">nyc-edg-r1#</span>
</code></pre>
    <p class="normal">Here comes the part that might be a bit tricky for engineers who might be new to host-based networking. By default, the host has a routing preference as well. The default gateway we added for <code class="inlineCode">ens3</code> will allow us to use the lab gateway for the “destination of last resort.” We can<a id="_idIndexMarker447"/> see the routing table on the host via the <code class="inlineCode">route</code> command: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@client:~$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.2.1     0.0.0.0         UG    0      0        0 ens3
10.0.0.4        0.0.0.0         255.255.255.252 U     0      0        0 ens2
192.168.2.0     0.0.0.0         255.255.255.0   U     0      0        0 ens3
</code></pre>
    <p class="normal">We will use the following command to route traffic from the client to the server via the <code class="inlineCode">route</code> command: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@client:~$ sudo route add -net 10.0.0.8/30 gw 10.0.0.6
ubuntu@client:~$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.2.1     0.0.0.0         UG    0      0        0 ens3
10.0.0.4        0.0.0.0         255.255.255.252 U     0      0        0 ens2
10.0.0.8        10.0.0.6        255.255.255.252 UG    0      0        0 ens2
192.168.2.0     0.0.0.0         255.255.255.0   U     0      0        0 ens3
</code></pre>
    <p class="normal">We will do the same on the server side: </p>
    <pre class="programlisting con"><code class="hljs-con">ubuntu@server:~$ sudo route add -net 10.0.0.4/30 gw 10.0.0.10
ubuntu@server:~$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         192.168.2.1     0.0.0.0         UG    0      0        0 ens3
10.0.0.4        10.0.0.10       255.255.255.252 UG    0      0        0 ens2
10.0.0.8        0.0.0.0         255.255.255.252 U     0      0        0 ens2
192.168.2.0     0.0.0.0         255.255.255.0   U     0      0        0 ens3
</code></pre>
    <p class="normal">To verify the client-to-server path, let’s ping and trace the route to make sure that traffic between our hosts is going through the network devices instead of the default route:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>Install on both client and server
ubuntu@ubuntu:~$ sudo apt install traceroute
<span class="hljs-con-meta"># </span>From Server to Client
ubuntu@server:~$ ping -c 1 10.0.0.5
PING 10.0.0.5 (10.0.0.5) 56(84) bytes of data.
64 bytes from 10.0.0.5: icmp_seq=1 ttl=62 time=3.38 ms
--- 10.0.0.5 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 3.388/3.388/3.388/0.000 ms
ubuntu@server:~$ traceroute 10.0.0.5
traceroute to 10.0.0.5 (10.0.0.5), 30 hops max, 60 byte packets
 1  10.0.0.10 (10.0.0.10)  2.829 ms  5.832 ms  7.396 ms
 2  * * *
 3  10.0.0.5 (10.0.0.5)  11.458 ms  11.459 ms  11.744 ms
<span class="hljs-con-meta"># </span>From Client to Server
ubuntu@client:~$ ping -c 1 10.0.0.9
PING 10.0.0.9 (10.0.0.9) 56(84) bytes of data.
64 bytes from 10.0.0.9: icmp_seq=1 ttl=62 time=3.32 ms
--- 10.0.0.9 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 3.329/3.329/3.329/0.000 ms
ubuntu@client:~$ traceroute 10.0.0.9
traceroute to 10.0.0.9 (10.0.0.9), 30 hops max, 60 byte packets
 1  10.0.0.6 (10.0.0.6)  3.187 ms  3.318 ms  3.804 ms
 2  * * *
 3  10.0.0.9 (10.0.0.9)  11.845 ms  12.030 ms  12.035 ms
</code></pre>
    <p class="normal">The final task is to <a id="_idIndexMarker448"/>prepare the host for the remainder of the chapter with updated repositories: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo apt update &amp;&amp; sudo apt upgrade -y 
<span class="hljs-con-meta">$ </span>sudo apt install software-properties-common -y
<span class="hljs-con-meta">$ </span>sudo add-apt-repository ppa:deadsnakes/ppa
<span class="hljs-con-meta">$ </span>sudo apt install -y python3.10 python3.10-venv
<span class="hljs-con-meta">$ </span>python3.10 -m venv venv
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">source</span> venv/bin/activate
</code></pre>
    <p class="normal">Great! We have our<a id="_idIndexMarker449"/> lab; we are now ready to look at some security tools and measures using Python.</p>
    <h1 class="heading-1" id="_idParaDest-154">Python Scapy</h1>
    <p class="normal">Scapy (<a href="https://scapy.net"><span class="url">https://scapy.net</span></a>) is a powerful Python-based interactive packet crafting program. Outside of some expensive <a id="_idIndexMarker450"/>commercial programs, very few tools can do what Scapy can do, to my knowledge. It is one of my favorite tools in Python.</p>
    <p class="normal">The main advantage of Scapy is that it <a id="_idIndexMarker451"/>allows us to craft our packet from a very basic level. In the words of Scapy’s creator:</p>
    <blockquote class="packt_quote">
      <p class="quote">”Scapy is a powerful interactive packet manipulation program. It is able to forge or decode packets of a wide number of protocols, send them on the wire, capture them, match requests and replies, and much more…… with most other tools, you won’t build something the author did not imagine. These tools have been built for a specific goal and can’t deviate much from it.”</p>
    </blockquote>
    <p class="normal">Let’s now take a look at the tool.</p>
    <h2 class="heading-2" id="_idParaDest-155">Installing Scapy</h2>
    <p class="normal">Scapy has had an interesting path<a id="_idIndexMarker452"/> when it comes to Python 3 support. Back in 2015, there was an independent fork of Scapy from version 2.2.0 that aimed to support Python 3, named <code class="inlineCode">Scapy3k</code>. In this book, we are using the main code base from the original Scapy project. If you have read the previous edition of the book and used a Scapy version that was only compatible with Python 2, please take a look at the Python 3 support per Scapy release:</p>
    <figure class="mediaobject"><img alt="Table  Description automatically generated with medium confidence" src="../Images/B18403_06_03.1.png"/><img alt="A picture containing chart  Description automatically generated" src="../Images/B18403_06_03.png"/></figure>
    <p class="packt_figref">Figure 6.3: Python version support (source: https://scapy.net/download/)</p>
    <p class="normal">We will install the<a id="_idIndexMarker453"/> official release from the source: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) ubuntu@[server|client]:~$ git clone https://github.com/secdev/scapy.git
(venv) ubuntu@[server|client]:~$ cd scapy/
(venv) ubuntu@[server|client]:~/scapy$ sudo python3 setup.py install
(venv) ubuntu@[server|client]:~/scapy$ pip install scapy
</code></pre>
    <p class="normal">Following installation, we can launch the Scapy interactive shell by typing in <strong class="keyWord">scapy</strong> in the Command Prompt:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) ubuntu@client:~$ sudo scapy
…
                     aSPY//YASa
             apyyyyCY//////////YCa       |
            sY//////YSpcs  scpCY//Pp     | Welcome to Scapy
 ayp ayyyyyyySCP//Pp           syY//C    | Version 2.5.0rc1.dev16
 AYAsAYYYYYYYY///Ps              cY//S   |
         pCCCCY//p          cSSps y//Y   | https://github.com/secdev/scapy
         SPPPP///a          pP///AC//Y   |
              A//A            cyP////C   | Have fun!
              p///Ac            sC///a   |
              P////YCpc           A//A   | What is dead may never die!
       scccccp///pSP///p          p//Y   |                     -- Python 2
      sY/////////y  caa           S//P   |
       cayCyayP//Ya              pY/Ya
        sY/PsY////YCc          aC//Yp
         sc  sccaCY//PCypaapyCP//YSs
                  spCPY//////YPSps
                       ccaacs
</code></pre>
    <p class="normal">Here is a quick test to make sure we can access the <code class="inlineCode">Scapy</code> library from Python 3:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) ubuntu@client:~$ python3.10
Python 3.10.7 (main, Sep  7 2022, 15:23:21) [GCC 7.5.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> scapy.<span class="hljs-con-built_in">all</span> <span class="hljs-con-keyword">import</span> *
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exit()
</code></pre>
    <p class="normal">Awesome! Scapy is now <a id="_idIndexMarker454"/>installed and can be executed from our Python interpreter. Let’s take a look at its usage via the interactive shell in the next section.</p>
    <h2 class="heading-2" id="_idParaDest-156">Interactive examples</h2>
    <p class="normal">In our first <a id="_idIndexMarker455"/>example, we will craft an <strong class="keyWord">Internet Control Message Protocol</strong> (<strong class="keyWord">ICMP</strong>) packet on the client and send it<a id="_idIndexMarker456"/> to the server. On the server side, we will use <code class="inlineCode">tcpdump</code> with a host filter to see the packet coming in:</p>
    <pre class="programlisting con"><code class="hljs-con">## Client Side
ubuntu@client:~/scapy$ sudo scapy
<span class="hljs-con-meta">&gt;&gt;&gt;</span> send(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/ICMP())
.
Sent 1 packets.
# Server side
ubuntu@server:~/scapy$ sudo tcpdump -i ens2
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on ens2, link-type EN10MB (Ethernet), capture size 262144 bytes
02:02:24.402707 Loopback, skipCount 0, Reply, receipt number 0, data (40 octets)
02:02:24.658511 IP 10.0.0.5 &gt; server: ICMP echo request, id 0, seq 0, length 8
02:02:24.658532 IP server &gt; 10.0.0.5: ICMP echo reply, id 0, seq 0, length 8
</code></pre>
    <p class="normal">As you can see, it is very simple to craft a packet from Scapy. Scapy allows you to build the packet layer by layer using the slash (<code class="inlineCode">/</code>) as the separator. The <code class="inlineCode">send</code> function operates at the layer 3 level, which <a id="_idIndexMarker457"/>takes care of routing and layer 2 for you. There is also a <code class="inlineCode">sendp()</code> alternative that operates at layer 2, which means you will need to specify the interface and link layer protocol.</p>
    <p class="normal">Let’s look at capturing the returned packet by using the <code class="inlineCode">send-request</code> (<code class="inlineCode">sr</code>) function. We are using a special variation of <code class="inlineCode">sr</code>, called <code class="inlineCode">sr1</code>, which only returns one packet that answers from the packet sent:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> p = sr1(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/ICMP())
Begin emission:
.Finished sending 1 packets.
*
Received 2 packets, got 1 answers, remaining 0 packets
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p
&lt;IP  version=4 ihl=5 tos=0x0 len=28 id=5717 flags= frag=0 ttl=62 proto=icmp chksum=0x527f src=10.0.0.9 dst=10.0.0.5 |&lt;ICMP  type=echo-reply code=0 chksum=0xffff id=0x0 seq=0x0 |&lt;Padding  load='\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' |&gt;&gt;&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">One thing to note is that the <code class="inlineCode">sr()</code> function returns a tuple containing answered and unanswered lists:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> p = sr(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/ICMP())
.Begin emission:
.....Finished sending 1 packets.
*
Received 7 packets, got 1 answers, remaining 0 packets
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(p)
&lt;class 'tuple'&gt;
</code></pre>
    <p class="normal">Now, let’s take a look at what is contained inside the tuple:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ans, unans = sr(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/ICMP())
.Begin emission:
...Finished sending 1 packets.
..*
Received 7 packets, got 1 answers, remaining 0 packets
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(ans)
&lt;class 'scapy.plist.SndRcvList'&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(unans)
&lt;class 'scapy.plist.PacketList'&gt;
</code></pre>
    <p class="normal">If we were to only take<a id="_idIndexMarker458"/> a look at the answered packet list, we could see that it is a <code class="inlineCode">NamedTuple</code> containing the packet that we have sent as well as the returned packet:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> ans:
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">print</span>(<span class="hljs-con-built_in">type</span>(i))
<span class="hljs-con-meta">...</span>
&lt;class 'scapy.compat.NamedTuple.&lt;locals&gt;._NT'&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> ans:
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">print</span>(i)
<span class="hljs-con-meta">...</span>
QueryAnswer(query=&lt;IP  frag=0 proto=icmp dst=10.0.0.9 |&lt;ICMP  |&gt;&gt;, answer=&lt;IP  version=4 ihl=5 tos=0x0 len=28 id=10871 flags= frag=0 ttl=62 proto=icmp chksum=0x3e5d src=10.0.0.9 dst=10.0.0.5 |&lt;ICMP  type=echo-reply code=0 chksum=0xffff id=0x0 seq=0x0 |&lt;Padding  load='\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00' |&gt;&gt;&gt;)
</code></pre>
    <p class="normal">Scapy also provides a layer 7 construct, such as a DNS query. In the following example, we are querying an open DNS server for the resolution of <a href="http://www.google.com"><span class="url">www.google.com</span></a>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> p = sr1(IP(dst=<span class="hljs-con-string">"8.8.8.8"</span>)/UDP()/DNS(rd=<span class="hljs-con-number">1</span>,qd=DNSQR(qname=<span class="hljs-con-string">"www.google.com"</span>)))
Begin emission:
Finished sending 1 packets.
......*
Received 7 packets, got 1 answers, remaining 0 packets
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p
&lt;IP  version=4 ihl=5 tos=0x20 len=76 id=20467 flags= frag=0 ttl=58 proto=udp chksum=0x5d3e src=8.8.8.8 dst=192.168.2.152 |&lt;UDP  sport=domain dport=domain len=56 chksum=0xf934 |&lt;DNS  id=0 qr=1 opcode=QUERY aa=0 tc=0 rd=1 ra=1 z=0 ad=0 cd=0 rcode=ok qdcount=1 ancount=1 nscount=0 arcount=0 qd=&lt;DNSQR  qname='www.google.com.' qtype=A qclass=IN |&gt; an=&lt;DNSRR  rrname='www.google.com.' type=A rclass=IN ttl=115 rdlen=4 rdata=142.251.211.228 |&gt; ns=None ar=None |&gt;&gt;&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">Let’s take a look at some<a id="_idIndexMarker459"/> other Scapy features. We’ll begin by using Scapy for packet captures.</p>
    <h2 class="heading-2" id="_idParaDest-157">Packet captures with Scapy</h2>
    <p class="normal">As network engineers, we <a id="_idIndexMarker460"/>constantly have to capture packets on the wire during troubleshooting. We typically use Wireshark or similar tools, but Scapy can also be used to easily capture packets on the wire:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> a = sniff(<span class="hljs-con-built_in">filter</span>=<span class="hljs-con-string">"icmp"</span>, count=<span class="hljs-con-number">5</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> a.show()
0000 Ether / IP / ICMP 192.168.2.152 &gt; 8.8.8.8 echo-request 0 / Raw
0001 Ether / IP / ICMP 8.8.8.8 &gt; 192.168.2.152 echo-reply 0 / Raw
0002 Ether / IP / ICMP 192.168.2.152 &gt; 8.8.8.8 echo-request 0 / Raw
0003 Ether / IP / ICMP 8.8.8.8 &gt; 192.168.2.152 echo-reply 0 / Raw
0004 Ether / IP / ICMP 192.168.2.152 &gt; 8.8.8.8 echo-request 0 / Raw
</code></pre>
    <p class="normal">We can look at the packets in some more detail, including the raw format:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> packet <span class="hljs-con-keyword">in</span> a:
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">print</span>(packet.show())
<span class="hljs-con-meta">...</span>
###[ Ethernet ]###
  dst       = 08:b4:b1:18:01:39
  src       = 52:54:00:19:54:b5
  type      = IPv4
###[ IP ]###
     version   = 4
     ihl       = 5
     tos       = 0x0
     len       = 84
     id        = 38166
     flags     = DF
     frag      = 0
     ttl       = 64
     proto     = icmp
     chksum    = 0xd242
     src       = 192.168.2.152
     dst       = 8.8.8.8
     \options   \
###[ ICMP ]###
        type      = echo-request
        code      = 0
        chksum    = 0x6596
        id        = 0x502f
        seq       = 0x1
        unused    = ''
###[ Raw ]###
           load      = '\\xaa7%c\x00\x00\x00\x00\\xb2\\xcb\x01\x00\x00\x00\x00\x00\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !"#$%&amp;\'()*+,-./01234567'
&lt;skip&gt;
</code></pre>
    <p class="normal">We have seen the basic workings of Scapy. Let’s now move on and see how we can use Scapy for certain aspects <a id="_idIndexMarker461"/>of common security testing.</p>
    <h2 class="heading-2" id="_idParaDest-158">The TCP port scan</h2>
    <p class="normal">The first step for any potential hackers<a id="_idIndexMarker462"/> is almost always trying to learn which service is open on the network to focus their efforts on the attack. Of course, we need to open certain ports to service our customers; that is part of the risk we must accept. However, we should close any other open port that needlessly exposes a larger attack surface. We can use Scapy to do a simple TCP open port scan to scan our own host.</p>
    <p class="normal">We can send a <code class="inlineCode">SYN</code> packet and see whether the server will return with <code class="inlineCode">SYN-ACK</code> for various ports. Let’s start with Telnet, TCP port <code class="inlineCode">23</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> p = sr1(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/TCP(sport=<span class="hljs-con-number">666</span>,dport=<span class="hljs-con-number">23</span>,flags=<span class="hljs-con-string">"S"</span>))
Begin emission:
Finished sending 1 packets.
.*
Received 2 packets, got 1 answers, remaining 0 packets
<span class="hljs-con-meta">&gt;&gt;&gt;</span> p.show()
###[ IP ]###
  version= 4
  ihl= 5
  tos= 0x0
  len= 40
  id= 14089
  flags= DF
  frag= 0
  ttl= 62
  proto= tcp
  chksum= 0xf1b9
  src= 10.0.0.9
  dst= 10.0.0.5
  \options\
###[ TCP ]###
     sport= telnet
     dport= 666
     seq= 0
     ack= 1
     dataofs= 5
     reserved= 0
     flags= RA
     window= 0
     chksum= 0x9911
     urgptr= 0
     options= []
</code></pre>
    <p class="normal">Note that, in the output<a id="_idIndexMarker463"/> here, the server is responding with a <code class="inlineCode">RESET+ACK</code> for TCP port <code class="inlineCode">23</code>. However, TCP port <code class="inlineCode">22</code> (SSH) is open; therefore, a <code class="inlineCode">SYN-ACK</code> is returned:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> p = sr1(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/TCP(sport=<span class="hljs-con-number">666</span>,dport=<span class="hljs-con-number">22</span>,flags=<span class="hljs-con-string">"S"</span>)).show()
###[ IP ]###
  version= 4
&lt;skip&gt;
  proto= tcp
  chksum= 0x28bf
  src= 10.0.0.9
  dst= 10.0.0.5
  \options\
###[ TCP ]###
     sport= ssh
     dport= 666
     seq= 1671401418
     ack= 1
     dataofs= 6
     reserved= 0
     flags= SA
&lt;skip&gt;
</code></pre>
    <p class="normal">We can also scan a range of destination ports from <code class="inlineCode">20</code> to <code class="inlineCode">22</code>; note that we are using <code class="inlineCode">sr()</code> for send-receive instead of <a id="_idIndexMarker464"/>the <code class="inlineCode">sr1()</code> send-receive-one-packet variant:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ans,unans = sr(IP(dst=<span class="hljs-con-string">"10.0.0.9"</span>)/TCP(sport=<span class="hljs-con-number">666</span>,dport=(<span class="hljs-con-number">20</span>,<span class="hljs-con-number">22</span>),flags=<span class="hljs-con-string">"S"</span>))
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> ans:
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">print</span>(i)
<span class="hljs-con-meta">...</span>
QueryAnswer(query=&lt;IP  frag=0 proto=tcp dst=10.0.0.9 |&lt;TCP  sport=666 dport=ftp_data flags=S |&gt;&gt;, answer=&lt;IP  version=4 ihl=5 tos=0x0 len=40 id=0 flags=DF frag=0 ttl=62 proto=tcp chksum=0x28c3 src=10.0.0.9 dst=10.0.0.5 |&lt;TCP  sport=ftp_data dport=666 seq=0 ack=1 dataofs=5 reserved=0 flags=RA window=0 chksum=0x9914 urgptr=0 |&lt;Padding  load='\x00\x00\x00\x00\x00\x00' |&gt;&gt;&gt;)
QueryAnswer(query=&lt;IP  frag=0 proto=tcp dst=10.0.0.9 |&lt;TCP  sport=666 dport=ftp flags=S |&gt;&gt;, answer=&lt;IP  version=4 ihl=5 tos=0x0 len=40 id=0 flags=DF frag=0 ttl=62 proto=tcp chksum=0x28c3 src=10.0.0.9 dst=10.0.0.5 |&lt;TCP  sport=ftp dport=666 seq=0 ack=1 dataofs=5 reserved=0 flags=RA window=0 chksum=0x9913 urgptr=0 |&lt;Padding  load='\x00\x00\x00\x00\x00\x00' |&gt;&gt;&gt;)
QueryAnswer(query=&lt;IP  frag=0 proto=tcp dst=10.0.0.9 |&lt;TCP  sport=666 dport=ssh flags=S |&gt;&gt;, answer=&lt;IP  version=4 ihl=5 tos=0x0 len=44 id=0 flags=DF frag=0 ttl=62 proto=tcp chksum=0x28bf src=10.0.0.9 dst=10.0.0.5 |&lt;TCP  sport=ssh dport=666 seq=4214084277 ack=1 dataofs=6 reserved=0 flags=SA window=29200 chksum=0x4164 urgptr=0 options=[('MSS', 1460)] |&lt;Padding  load='\x00\x00' |&gt;&gt;&gt;)
</code></pre>
    <p class="normal">We can also specify a destination network instead of a single host. As you can see from the <code class="inlineCode">10.0.0.8/29</code> block, hosts <code class="inlineCode">10.0.0.9</code>, <code class="inlineCode">10.0.0.10</code>, and <code class="inlineCode">10.0.0.14</code> returned with <code class="inlineCode">SA</code>, which corresponds to the two network devices and the host:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ans,unans = sr(IP(dst=<span class="hljs-con-string">"10.0.0.8/29"</span>)/TCP(sport=<span class="hljs-con-number">666</span>,dport=(<span class="hljs-con-number">22</span>),flags=<span class="hljs-con-string">"S"</span>))
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span> i <span class="hljs-con-keyword">in</span> ans:
<span class="hljs-con-meta">...</span>     <span class="hljs-con-built_in">print</span>(i)
<span class="hljs-con-meta">...</span>
(&lt;IP  frag=0 proto=tcp dst=10.0.0.14 |&lt;TCP  sport=666 dport=ssh flags=S |&gt;&gt;, &lt;IP  version=4 ihl=5 tos=0x0 len=44 id=7289 flags= frag=0 ttl=64 proto=tcp chksum=0x4a41 src=10.0.0.14 dst=10.0.0.5 |&lt;TCP  sport=ssh dport=666 seq=1652640556 ack=1 dataofs=6 reserved=0 flags=SA window=17292 chksum=0x9029 urgptr=0 options=[('MSS', 1444)] |&gt;&gt;)
(&lt;IP  frag=0 proto=tcp dst=10.0.0.9 |&lt;TCP  sport=666 dport=ssh flags=S |&gt;&gt;, &lt;IP  version=4 ihl=5 tos=0x0 len=44 id=0 flags=DF frag=0 ttl=62 proto=tcp chksum=0x28bf src=10.0.0.9 dst=10.0.0.5 |&lt;TCP  sport=ssh dport=666 seq=898054835 ack=1 dataofs=6 reserved=0 flags=SA window=29200 chksum=0x9f0d urgptr=0 options=[('MSS', 1460)] |&gt;&gt;)
(&lt;IP  frag=0 proto=tcp dst=10.0.0.10 |&lt;TCP  sport=666 dport=ssh flags=S |&gt;&gt;, &lt;IP  version=4 ihl=5 tos=0x0 len=44 id=38021 flags= frag=0 ttl=254 proto=tcp chksum=0x1438 src=10.0.0.10 dst=10.0.0.5 |&lt;TCP  sport=ssh dport=666 seq=371720489 ack=1 dataofs=6 reserved=0 flags=SA window=4128 chksum=0x5d82 urgptr=0 options=[('MSS', 536)] |&gt;&gt;)
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
</code></pre>
    <p class="normal">Based on what we <a id="_idIndexMarker465"/>have learned so far, we can make a simple script for reusability, <code class="inlineCode">scapy_tcp_scan_1.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">def</span> <span class="hljs-title">tcp_scan</span>(<span class="hljs-params">destination, dport</span>):
    ans, unans = sr(IP(dst=destination)/TCP(sport=<span class="hljs-number">666</span>,dport=dport,flags=<span class="hljs-string">"S"</span>))
    <span class="hljs-keyword">for</span> sending, returned <span class="hljs-keyword">in</span> ans:
        <span class="hljs-keyword">if</span> <span class="hljs-string">'SA'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(returned[TCP].flags):
            <span class="hljs-keyword">return</span> destination + <span class="hljs-string">" port "</span> + <span class="hljs-built_in">str</span>(sending[TCP].dport) + <span class="hljs-string">" is open."</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> destination + <span class="hljs-string">" port "</span> + <span class="hljs-built_in">str</span>(sending[TCP].dport) + <span class="hljs-string">" is not open."</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():
    destination = sys.argv[<span class="hljs-number">1</span>]
    port = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>])
    scan_result = tcp_scan(destination, port)
    <span class="hljs-built_in">print</span>(scan_result)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
    <p class="normal">In the script, we start with the suggested importing of <code class="inlineCode">scapy</code> and the <code class="inlineCode">sys</code> module for taking in arguments. The <code class="inlineCode">tcp_scan()</code> function is similar to what we have seen up to this point, the only difference being that we functionalized it so that we can acquire inputs from arguments and<a id="_idIndexMarker466"/> then call the <code class="inlineCode">tcp_scan()</code> function in the <code class="inlineCode">main()</code> function.</p>
    <p class="normal">Remember that access to the low-level network requires root access; therefore, our script needs to be executed as <code class="inlineCode">sudo</code>. Let’s try the script on port <code class="inlineCode">22</code> (SSH) and port <code class="inlineCode">80</code> (HTTP):</p>
    <pre class="programlisting con"><code class="hljs-con">ubunbu@client:~$ sudo python3 scapy_tcp_scan_1.py "10.0.0.14" 22
Begin emission:
......Finished sending 1 packets.
*
Received 7 packets, got 1 answers, remaining 0 packets
10.0.0.14 port 22 is open.
ubuntu@client:~$ sudo python3 scapy_tcp_scan_1.py "10.0.0.14" 80
Begin emission:
...Finished sending 1 packets.
*
Received 4 packets, got 1 answers, remaining 0 packets
10.0.0.14 port 80 is not open.
</code></pre>
    <p class="normal">This was a relatively lengthy example of the TCP scan script, which demonstrated the power of crafting your packet with Scapy. We tested the steps in the interactive shell and finalized the usage with a simple script. Now, let’s look at some more examples of Scapy’s usage for security testing.</p>
    <h2 class="heading-2" id="_idParaDest-159">The ping collection</h2>
    <p class="normal">Let’s say our network contains a <a id="_idIndexMarker467"/>mix of Windows, Unix, and Linux machines, with network users adding their machines from the <strong class="keyWord">Bring Your Own Device</strong> (<strong class="keyWord">BYOD</strong>) policy; they may or may <a id="_idIndexMarker468"/>not support an ICMP ping. We can now construct a file with three types of common pings for our network – the ICMP, TCP, and UDP pings – in <code class="inlineCode">scapy_ping_collection.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-keyword">from</span> scapy.<span class="hljs-built_in">all</span> <span class="hljs-keyword">import</span> *
<span class="hljs-keyword">def</span> <span class="hljs-title">icmp_ping</span>(<span class="hljs-params">destination</span>):
    <span class="hljs-comment"># regular ICMP ping</span>
    ans, unans = sr(IP(dst=destination)/ICMP())
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">def</span> <span class="hljs-title">tcp_ping</span>(<span class="hljs-params">destination, dport</span>):
    ans, unans = sr(IP(dst=destination)/TCP(dport=dport,flags=<span class="hljs-string">"S"</span>))
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">def</span> <span class="hljs-title">udp_ping</span>(<span class="hljs-params">destination</span>):
    ans, unans = sr(IP(dst=destination)/UDP(dport=<span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span> ans
<span class="hljs-keyword">def</span> <span class="hljs-title">answer_summary</span>(<span class="hljs-params">ans</span>):
    <span class="hljs-keyword">for</span> send, recv <span class="hljs-keyword">in</span> ans:
        <span class="hljs-built_in">print</span>(recv.sprintf(<span class="hljs-string">"%IP.src% is alive"</span>))
</code></pre>
    <p class="normal">We can then execute all three types of pings on the network in one script:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"** ICMP Ping **"</span>)
    ans = icmp_ping(<span class="hljs-string">"10.0.0.13-14"</span>)
    answer_summary(ans)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"** TCP Ping ***"</span>)
    ans = tcp_ping(<span class="hljs-string">"</span><span class="hljs-string">10.0.0.13"</span>, <span class="hljs-number">22</span>)
    answer_summary(ans)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"** UDP Ping ***"</span>)
    ans = udp_ping(<span class="hljs-string">"10.0.0.13-14"</span>)
    answer_summary(ans)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    main()
</code></pre>
    <p class="normal">At this point, hopefully, you will agree with me that by having the ability to construct your custom packet, you can<a id="_idIndexMarker469"/> be in charge of the type of operations and tests that you would like to run. Along the same thought of constructing our custom packets using Scapy, we can construct our packets to perform security tests on our network.</p>
    <h2 class="heading-2" id="_idParaDest-160">Common attacks</h2>
    <p class="normal">In this example, let’s look at how we <a id="_idIndexMarker470"/>can construct our packet to conduct some <a id="_idIndexMarker471"/>classic attacks, such as <em class="italic">Ping of Death</em> (<a href="https://en.wikipedia.org/wiki/Ping_of_death"><span class="url">https://en.wikipedia.org/wiki/Ping_of_death</span></a>) and <em class="italic">Land Attack</em> (<a href="https://en.wikipedia.org/wiki/Denial-of-service_attack"><span class="url">https://en.wikipedia.org/wiki/Denial-of-service_attack</span></a>). These are network penetration tests that you previously had to pay for with similar commercial software. With Scapy, you can conduct the test while maintaining full control and adding more tests in the future.</p>
    <p class="normal">The first attack sends the destination host with a bogus IP header, such as an IP header length of two and an IP version of three:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">malformed_packet_attack</span>(<span class="hljs-params">host</span>): 
       send(IP(dst=host, ihl=<span class="hljs-number">2</span>, version=<span class="hljs-number">3</span>)/ICMP())
</code></pre>
    <p class="normal">The <code class="inlineCode">ping_of_death_attack</code> consists of the regular ICMP packet with a payload bigger than 65,535 bytes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">ping_of_death_attack</span>(<span class="hljs-params">host</span>):
    <span class="hljs-comment"># https://en.wikipedia.org/wiki/Ping_of_death</span>
    send(fragment(IP(dst=host)/ICMP()/(<span class="hljs-string">"X"</span>*<span class="hljs-number">60000</span>)))
</code></pre>
    <p class="normal">The <code class="inlineCode">land_attack</code> wants to<a id="_idIndexMarker472"/> redirect the client response back to the client and exhausts the host’s resources:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">land_attack</span>(<span class="hljs-params">host</span>):
    <span class="hljs-comment"># https://en.wikipedia.org/wiki/Denial-of-service_attack </span>
    send(IP(src=host, dst=host)/TCP(sport=<span class="hljs-number">135</span>,dport=<span class="hljs-number">135</span>))
</code></pre>
    <p class="normal">These are pretty old vulnerabilities or classic attacks that a modern operating system is no longer susceptible to. For our Ubuntu 20.04 host, none of the preceding attacks will bring it down. However, as more security issues are being discovered, Scapy is a great tool for initiating tests against our network and host without waiting for the impacted vendor to give you a validation tool. This is especially true for the zero-day (published without prior notification) attacks that seem more and more common on the internet. Scapy is a tool that can do a lot more than what we can cover in this chapter, but luckily, there are lots of open source resources on Scapy that we can reference.</p>
    <h2 class="heading-2" id="_idParaDest-161">Scapy resources</h2>
    <p class="normal">We have spent much effort working <a id="_idIndexMarker473"/>with Scapy in this chapter. This is partially due to the high regard in which I hold the tool. I hope you agree that Scapy is a great tool to keep in our toolset as network engineers. The best part about Scapy is that it is constantly being developed with an engaged community of users.</p>
    <p class="normal">I would highly recommend at least going through the Scapy tutorial at <a href="http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial"><span class="url">http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial</span></a>, as well as any of the documentation that is of interest to you.</p>
    <p class="normal">Of course, network<a id="_idIndexMarker474"/> security is more than just crafting packets and testing vulnerabilities. In the next section, we’ll take a look at automating the access list that is commonly used to protect sensitive internal resources.</p>
    <h1 class="heading-1" id="_idParaDest-162">Access lists</h1>
    <p class="normal">The network access lists are usually the first line of defense against outside intrusions and attacks. Generally speaking, routers and switches process packets at a much faster rate than servers by utilizing high-speed <a id="_idIndexMarker475"/>memory hardware such as <strong class="keyWord">ternary content-addressable memory</strong> (<strong class="keyWord">TCAM</strong>). They do not need to see the application layer information. Instead, they just examine the layer 3 and layer 4 headers and decide whether the packets can be forwarded. Therefore, we generally utilize <a id="_idIndexMarker476"/>network device access lists as a first step in safeguarding our network resources.</p>
    <p class="normal">As a rule of thumb, we want to place access lists as close to the source (client) as possible. Inherently, we also trust the inside host and distrust clients beyond our network boundary. The access list is, therefore, usually placed in the inbound direction on the external-facing network interface(s). In our lab scenario, this means we will place an inbound access list at Ethernet2/2 on <code class="inlineCode">nyc-cor-r1</code>, which is directly connected to the client host.</p>
    <p class="normal">If you are unsure of the direction and placement of the access list, a few points might help here:</p>
    <ul>
      <li class="bulletList">Think of the access list from the perspective of the network device.</li>
      <li class="bulletList">Simplify the packets in terms of just source and destination IPs and use one host as an example.</li>
      <li class="bulletList">In our lab, traffic from our server to the client will have a source IP of <code class="inlineCode">10.0.0.9</code>, with a destination IP of <code class="inlineCode">10.0.0.5</code>.</li>
      <li class="bulletList">The traffic from the client to the server will have a source IP of <code class="inlineCode">10.0.0.5</code>, and a destination IP of <code class="inlineCode">10.0.0.9</code>.</li>
    </ul>
    <p class="normal">Obviously, every network is different, and how the access list should be constructed depends on the services provided by your server. But, as an inbound border access list, you should do the <a id="_idIndexMarker477"/>following:</p>
    <ul>
      <li class="bulletList">Deny RFC 3030 special-use address sources, such as <code class="inlineCode">127.0.0.0/8</code>.</li>
      <li class="bulletList">Deny RFC 1918 space, such as <code class="inlineCode">10.0.0.0/8</code>.</li>
      <li class="bulletList">Deny our own space as the source IP; in this case, <code class="inlineCode">10.0.0.4/30</code>.</li>
      <li class="bulletList">Permit inbound TCP ports <code class="inlineCode">22</code> (SSH) and <code class="inlineCode">80</code> (HTTP) to host <code class="inlineCode">10.0.0.9</code>.</li>
      <li class="bulletList">Deny everything else.</li>
    </ul>
    <p class="normal">Here is a good list of bogon networks to block: <a href="https://ipinfo.io/bogon"><span class="url">https://ipinfo.io/bogon</span></a>.</p>
    <p class="normal">Knowing what to add is only half of the step. In the next section, let’s take a look at how to implement the intended access list with Ansible.</p>
    <h2 class="heading-2" id="_idParaDest-163">Implementing access lists with Ansible</h2>
    <p class="normal">The easiest way to<a id="_idIndexMarker478"/> implement this access list would be to use Ansible. We have already looked at Ansible in previous chapters, but it is worth repeating the<a id="_idIndexMarker479"/> advantages of using Ansible in this scenario:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Easier management</strong>: For<a id="_idIndexMarker480"/> a long access list, we can utilize the <code class="inlineCode">include</code> statement to break the access list into more manageable pieces. The smaller pieces can then be managed by other teams or service owners.</li>
      <li class="bulletList"><strong class="keyWord">Idempotency</strong>: We can schedule the playbook at regular intervals and only the necessary changes will be made.</li>
      <li class="bulletList"><strong class="keyWord">Each task is explicit</strong>: We can separate the construct of the entries as well as apply the access list to the proper interface.</li>
      <li class="bulletList"><strong class="keyWord">Reusability</strong>: In the future, if we add additional external-facing interfaces, we just need to add the device to the list of devices for the access list.</li>
      <li class="bulletList"><strong class="keyWord">Extensible</strong>: You will notice that we can use the same playbook for constructing the access list and apply it to the right interface. We can start small and expand to separate playbooks in the future as needed.</li>
    </ul>
    <p class="normal">The <code class="inlineCode">host</code> file is pretty standard. We will also follow our standards of putting the variables in the <code class="inlineCode">host_vars</code> folder:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">[nxosv-devices]</span>
nyc-cor-r1 
<span class="hljs-string">[iosv-devices]</span>
nyc-edg-r1
</code></pre>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> host_vars/nyc-cor-r1 
---
ansible_host: 192.168.2.60
ansible_user: cisco
ansible_ssh_pass: cisco
ansible_connection: network_cli
ansible_network_os: nxos
ansbile_become: yes
ansible_become_method: enable
ansible_become_pass: cisco
</code></pre>
    <p class="normal">We will declare the variables in the playbook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">Access</span> <span class="hljs-string">List</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">"nxosv-devices"</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">connection:</span> <span class="hljs-string">local</span>
  <span class="hljs-attr">vars:</span>
    <span class="hljs-attr">cli:</span>
      <span class="hljs-attr">host:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ ansible_host }}</span><span class="hljs-string">"</span>
      <span class="hljs-attr">username:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ ansible_username }}</span><span class="hljs-string">"</span>
      <span class="hljs-attr">password:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ ansible_password }}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">To save space, we will only<a id="_idIndexMarker481"/> illustrate denying the RFC 1918 space. Implementing<a id="_idIndexMarker482"/> the denial of RFC 3030 and our own space will be identical to the steps used for the RFC 1918 space. Note that we did not deny <code class="inlineCode">10.0.0.0/8</code> in our playbook because our configuration currently uses the <code class="inlineCode">10.0.0.0</code> network for addressing. Of course, we could perform the single host permit first and deny <code class="inlineCode">10.0.0.0/8</code> in a later entry, but in this example, we just chose to omit it:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">nxos_acl:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">border_inbound</span>
        <span class="hljs-attr">seq:</span> <span class="hljs-number">20</span>
        <span class="hljs-attr">action:</span> <span class="hljs-string">deny</span>
        <span class="hljs-attr">proto:</span> <span class="hljs-string">tcp</span>
        <span class="hljs-attr">src:</span> <span class="hljs-number">172.16.0.0</span><span class="hljs-string">/12</span>
        <span class="hljs-attr">dest:</span> <span class="hljs-string">any</span>
        <span class="hljs-attr">log:</span> <span class="hljs-string">enable</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">present</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">nxos_acl:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">border_inbound</span>
        <span class="hljs-attr">seq:</span> <span class="hljs-number">30</span>
        <span class="hljs-attr">action:</span> <span class="hljs-string">deny</span>
        <span class="hljs-attr">proto:</span> <span class="hljs-string">tcp</span>
        <span class="hljs-attr">src:</span> <span class="hljs-number">192.168.0.0</span><span class="hljs-string">/16</span>
        <span class="hljs-attr">dest:</span> <span class="hljs-string">any</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">present</span>
        <span class="hljs-attr">log:</span> <span class="hljs-string">enable</span>
<span class="hljs-string">&lt;skip&gt;</span>
</code></pre>
    <p class="normal">Note that we are allowing the established connection sourcing from the server inside to be allowed back in. We use<a id="_idIndexMarker483"/> the final explicit <code class="inlineCode">deny</code> <code class="inlineCode">ip</code> <code class="inlineCode">any</code> statement <a id="_idIndexMarker484"/>as a high-sequence number (<code class="inlineCode">1000</code>) so that we can insert any new entries later on.</p>
    <p class="normal">We can then apply the access list to the correct interface:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">apply</span> <span class="hljs-string">ingress</span> <span class="hljs-string">acl</span> <span class="hljs-string">to</span> <span class="hljs-string">Ethernet</span> <span class="hljs-number">2</span><span class="hljs-string">/4</span>
      <span class="hljs-attr">nxos_acl_interface:</span> 
        <span class="hljs-attr">name:</span> <span class="hljs-string">border_inbound</span>
        <span class="hljs-attr">interface:</span> <span class="hljs-string">Ethernet2/4</span>
        <span class="hljs-attr">direction:</span> <span class="hljs-string">ingress</span>
        <span class="hljs-attr">state:</span> <span class="hljs-string">present</span>
</code></pre>
    <p class="normal">This may seem like a lot of work for a single access list. For an experienced engineer, using Ansible to do this task will take longer than just logging in to the device and configuring the access list. However, remember that this playbook can be reused many times in the future, so it will save you time in the long run.</p>
    <p class="normal">It is my experience that often, for a long access list, a few entries will be for one service, a few entries will be for another, and so on. The access lists tend to grow organically over time, and it becomes very hard to keep track of the origin and purpose of each entry. The fact that we can break them apart makes the management of a long access list much simpler.</p>
    <p class="normal">Now, let’s execute the playbook and <code class="inlineCode">verify</code> on <code class="inlineCode">nx-osv-1</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>ansible-playbook -i hosts access_list_nxosv.yml 
PLAY [Configure Access List] ******************************************************************************
TASK [nxos_acl] *******************************************************************************************
ok: [nyc-cor-r1]
&lt;skip&gt;
TASK [nxos_acl] *******************************************************************************************
ok: [nyc-cor-r1]
TASK [apply ingress acl to Ethernet 2/4] ******************************************************************
changed: [nyc-cor-r1]
PLAY RECAP ************************************************************************************************
nyc-cor-r1                 : ok=7    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
&lt;skip&gt;
</code></pre>
    <p class="normal">We should log in to <code class="inlineCode">nyc-cor-r1</code> to <a id="_idIndexMarker485"/>verify the changes:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">nyc-cor-r1# </span>sh ip access-lists border_inbound
IP access list border_inbound
        20 deny tcp 172.16.0.0/12 any log
        30 deny tcp 192.168.0.0/16 any log
        40 permit tcp any 10.0.0.9/32 eq 22 log
        50 permit tcp any 10.0.0.9/32 eq www log
        60 permit tcp any any established log
        1000 deny ip any any log
<span class="hljs-con-meta">nx-osv-1# </span>sh run int eth 2/4
!
interface Ethernet2/1
  description to Client
  no switchport
  mac-address fa16.3e00.0001
  ip access-group border_inbound in
  ip address 10.0.0.6/30
  ip router ospf 1 area 0.0.0.0
  no shutdown
</code></pre>
    <p class="normal">We have seen the implementation of IP access lists that check layer 3 information on the network. In the next <a id="_idIndexMarker486"/>section, let’s look at how to restrict device access in a layer 2 environment.</p>
    <h2 class="heading-2" id="_idParaDest-164">MAC access lists</h2>
    <p class="normal">In the case where you have a layer 2 environment, or where you are using non-IP protocols on Ethernet interfaces, you<a id="_idIndexMarker487"/> can still use a MAC address access list to allow or deny hosts based on MAC addresses. The steps are similar to the IP access list, but the match will be based on MAC addresses. Recall that for MAC addresses, or physical addresses, the first six hexadecimal symbols belong to an <strong class="keyWord">organizationally unique identifier</strong> (<strong class="keyWord">OUI</strong>). So, we can <a id="_idIndexMarker488"/>use the same access list matching pattern to deny a certain group of hosts.</p>
    <p class="normal">We are testing this on IOSv with the <code class="inlineCode">ios_config</code> module. For older Ansible versions, the change will be pushed out every single time the playbook is executed. For newer Ansible versions, the control node will check for changes first and only make changes when needed.</p>
    <p class="normal">The <code class="inlineCode">host</code> file and the top portion of the playbook are similar to the IP access list; the <code class="inlineCode">tasks</code> portion is where the different modules and arguments are used:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">&lt;skip&gt;</span>
 <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deny</span> <span class="hljs-string">Hosts</span> <span class="hljs-string">with</span> <span class="hljs-string">vendor</span> <span class="hljs-string">id</span> <span class="hljs-string">fa16.3e00.0000</span>  
      <span class="hljs-attr">ios_config:</span> 
        <span class="hljs-attr">lines:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">access-list</span> <span class="hljs-number">700</span> <span class="hljs-string">deny</span> <span class="hljs-string">fa16.3e00.0000</span> <span class="hljs-number">0000.</span><span class="hljs-string">00FF.FFFF</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">access-list</span> <span class="hljs-number">700</span> <span class="hljs-string">permit</span> <span class="hljs-number">0000.0000.0000</span> <span class="hljs-string">FFFF.FFFF.FFFF</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Apply</span> <span class="hljs-string">filter</span> <span class="hljs-string">on</span> <span class="hljs-string">bridge</span> <span class="hljs-string">group</span> <span class="hljs-number">1</span>
      <span class="hljs-attr">ios_config:</span>
        <span class="hljs-attr">lines:</span> 
          <span class="hljs-bullet">-</span> <span class="hljs-string">bridge-group</span> <span class="hljs-number">1</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">bridge-group</span> <span class="hljs-number">1</span> <span class="hljs-string">input-address-list</span> <span class="hljs-number">700</span>
        <span class="hljs-string">parents</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">interface</span> <span class="hljs-string">GigabitEthernet0/1</span>
</code></pre>
    <p class="normal">We can execute the playbook and verify its application on <code class="inlineCode">iosv-1</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>ansible-playbook -i hosts access_list_mac_iosv.yml
TASK [Deny Hosts with vendor id fa16.3e00.0000] ****************************************************************************
changed: [nyc-edg-r1]
TASK [Apply filter on bridge group 1] ***************************************************************************************
changed: [nyc-edg-r1]
</code></pre>
    <p class="normal">As we have done before, let’s log in to <a id="_idIndexMarker489"/>the device to verify our change:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">nyc-edg-r1#</span>sh run int gig 0/1
!
interface GigabitEthernet0/1
 description to nyc-cor-r1
 &lt;skip&gt;
 bridge-group 1
 bridge-group 1 input-address-list 700
end
</code></pre>
    <p class="normal">As more virtual networks become popular, layer 3 information sometimes becomes transparent to the underlying virtual links. In these scenarios, the MAC access list becomes a good option if you need to restrict access to those links. In this section, we have used Ansible to automate the implementation of both layer 2 and layer 3 access lists. Now, let’s change gears a bit but stay within the security context and look at how to pick up necessary security information from <code class="inlineCode">syslogs</code> using Python.</p>
    <h1 class="heading-1" id="_idParaDest-165">The Syslog search</h1>
    <p class="normal">There are plenty of documented <a id="_idIndexMarker490"/>network security breaches that took place over an extended period. In these slow breaches, we quite often saw signs and traces in logs indicating that there were suspicious activities. These can be found in both server and network device logs. The activities were not detected, not because there was a lack of information, but rather because there was <strong class="keyWord">too much</strong> information. The critical information we were looking for is usually buried deep in a mountain of information that is hard to sort out.</p>
    <p class="normal">Besides Syslog, UFW is another great source of log information for servers. It is a frontend to IP tables, which is a server firewall. UFW makes managing firewall rules very simple and logs a good amount of information. Refer to the <em class="italic">Other Tools</em> section for more information on UFW.</p>
    <p class="normal">In this section, we will try <a id="_idIndexMarker491"/>to use Python to search through the Syslog text in order to detect the activities that we were looking for. Of course, the exact terms that we will search for depend on the device we are using. For example, Cisco provides a list of messages to look for in Syslog for any access-list violation logging. It is available at <a href="http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html"><span class="url">http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html</span></a>.</p>
    <p class="normal">For more understanding of access control list logging, go to <a href="http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html"><span class="url">http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html</span></a>.</p>
    <p class="normal">For our exercise, we will use a Nexus switch anonymized Syslog file containing about 65,000 lines of log messages. This file is included for you in the book’s GitHub repository:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">wc</span> -l sample_log_anonymized.log
65102 sample_log_anonymized.log
</code></pre>
    <p class="normal">We have inserted some Syslog messages from the Cisco documentation (<a href="https://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html"><span class="url">http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html</span></a>) as the log message that we should be looking for:</p>
    <pre class="programlisting con"><code class="hljs-con">2014 Jun 29 19:20:57 Nexus-7000 %VSHD-5-VSHD_SYSLOG_CONFIG_I: Configured
from vty by admin on console0
2014 Jun 29 19:21:18 Nexus-7000 %ACLLOG-5-ACLLOG_FLOW_INTERVAL: Src IP:
10.1 0.10.1,
Dst IP: 172.16.10.10, Src Port: 0, Dst Port: 0, Src Intf: Ethernet4/1, Pro tocol: "ICMP"(1), Hit-count = 2589
2014 Jun 29 19:26:18 Nexus-7000 %ACLLOG-5-ACLLOG_FLOW_INTERVAL: Src IP:
10.1 0.10.1, Dst IP: 172.16.10.10, Src Port: 0, Dst Port: 0, Src Intf: Ethernet4/1, Pro tocol: "ICMP"(1), Hit-count = 4561
</code></pre>
    <p class="normal">We will be using simple <a id="_idIndexMarker492"/>examples with regular expressions. If you are already familiar with the regular expression module in Python, feel free to skip the rest of the section.</p>
    <h2 class="heading-2" id="_idParaDest-166">Searching with the regular expression module</h2>
    <p class="normal">For our first search, we will <a id="_idIndexMarker493"/>simply use the regular expression module to search for the terms we are looking for. We will use a simple loop to do the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-keyword">import</span> re, datetime
startTime = datetime.datetime.now()
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'sample_log_anonymized.log'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():
        <span class="hljs-keyword">if</span> re.search(<span class="hljs-string">'ACLLOG-5-ACLLOG_FLOW_INTERVAL'</span>, line):
            <span class="hljs-built_in">print</span>(line)
endTime = datetime.datetime.now()
elapsedTime = endTime - startTime
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Time Elapsed: "</span> + <span class="hljs-built_in">str</span>(elapsedTime))
</code></pre>
    <p class="normal">It took about four-hundredths of a second to search through the log file:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 python_re_search_1.py
2014 Jun 29 19:21:18 Nexus-7000 %ACLLOG-5-ACLLOG_FLOW_INTERVAL: Src IP: 10.1 0.10.1,
2014 Jun 29 19:26:18 Nexus-7000 %ACLLOG-5-ACLLOG_FLOW_INTERVAL: Src IP: 10.1 0.10.1,
Time Elapsed: 0:00:00.047249
</code></pre>
    <p class="normal">It is recommended to compile the search term for a more efficient search. It will not impact us much since the script is already pretty fast. Python’s interpretative nature might make it slower. However, it will make a difference when we search through a larger text body, so let’s make the change:</p>
    <pre class="programlisting code"><code class="hljs-code">searchTerm = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">'ACLLOG-5-ACLLOG_FLOW_INTERVAL'</span>) 
<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">'sample_log_anonymized.log'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():
<span class="hljs-keyword">if</span> re.search(searchTerm, line): 
    <span class="hljs-built_in">print</span>(line)
</code></pre>
    <p class="normal">The timing result is actually slower:</p>
    <pre class="programlisting code"><code class="hljs-code">Time Elapsed: <span class="hljs-number">0</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00.081541</span>
</code></pre>
    <p class="normal">Let’s expand the example a bit. Assuming <a id="_idIndexMarker494"/>we have several files and multiple terms to search through, we will copy the original file to a new file:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cp</span> sample_log_anonymized.log sample_log_anonymized_1.log
</code></pre>
    <p class="normal">We will also include searching for the <code class="inlineCode">PAM: Authentication failure</code> term. We will add another loop to search both files:</p>
    <pre class="programlisting code"><code class="hljs-code">term1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">'ACLLOG-5-ACLLOG_FLOW_INTERVAL'</span>)
term2 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">'PAM: Authentication failure'</span>)
fileList = [<span class="hljs-string">'sample_log_anonymized.log'</span>, <span class="hljs-string">'sample_log_anonymized_1.log'</span>]
<span class="hljs-keyword">for</span> log <span class="hljs-keyword">in</span> fileList:
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(log, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():
            <span class="hljs-keyword">if</span> re.search(term1, line) <span class="hljs-keyword">or</span> re.search(term2, line):
                <span class="hljs-built_in">print</span>(line)
</code></pre>
    <p class="normal">We can now see the difference in performance by expanding our search terms and the number of messages:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 python_re_search_2.py
2016 Jun 5 16:49:33 NEXUS-A %DAEMON-3-SYSTEM_MSG: error: PAM:
Authentication failure for illegal user AAA from 172.16.20.170 - sshd[4425]
2016 Sep 14 22:52:26.210 NEXUS-A %DAEMON-3-SYSTEM_MSG: error: PAM:
Authentication failure for illegal user AAA from 172.16.20.170 - sshd[2811]
&lt;skip&gt;
2014 Jun 29 19:21:18 Nexus-7000 %ACLLOG-5-ACLLOG_FLOW_INTERVAL: Src IP:
10.1 0.10.1,
2014 Jun 29 19:26:18 Nexus-7000 %ACLLOG-5-ACLLOG_FLOW_INTERVAL: Src IP:
10.1 0.10.1,
&lt;skip&gt;
Time Elapsed: 0:00:00.330697
</code></pre>
    <p class="normal">Of course, when it comes to performance tuning, it is a never-ending, impossible race to zero, and the performance sometimes depends on the hardware you are using. But the important point is to<a id="_idIndexMarker495"/> regularly perform audits of your log files using Python so that you can catch the early signals of any potential breach.</p>
    <p class="normal">We have looked at<a id="_idIndexMarker496"/> some of the key ways in which we can enhance our network security in Python, but there are several other powerful tools that can make this process easier and more effective. In the final section of this chapter, we will explore some of these tools.</p>
    <h1 class="heading-1" id="_idParaDest-167">Other tools</h1>
    <p class="normal">There are other network security tools that we can use and automate with Python. Let’s take a look at two of the most commonly used ones.</p>
    <h2 class="heading-2" id="_idParaDest-168">Private VLANs</h2>
    <p class="normal"><strong class="keyWord">Virtual local area networks</strong> (<strong class="keyWord">VLANs</strong>) have been around for a long time. They are essentially broadcast domains where all <a id="_idIndexMarker497"/>hosts can be connected to a single switch but are partitioned out to different domains, so we can<a id="_idIndexMarker498"/> separate the hosts according to which hosts can see others via broadcasts. Let’s consider a map based on IP subnets. For example, in an enterprise building, I would likely see one IP subnet per physical floor: <code class="inlineCode">192.168.1.0/24</code> for the first floor, <code class="inlineCode">192.168.2.0/24</code> for the second floor, and so on. In this pattern, we use a <code class="inlineCode">/24</code> block for each floor. This gives a clear delineation of my physical network as well as my logical network. A host wanting to communicate beyond its subnet will need to traverse through its layer 3 gateway, where I can use an access list to enforce security.</p>
    <p class="normal">What happens when different departments reside on the same floor? Perhaps the finance and sales teams are on the second floor, and I would not want the sales team’s hosts in the same broadcast domain as the finance team. I can break the subnet down further, but that might become tedious and break the standard subnet scheme previously set up. This is where a private VLAN can help.</p>
    <p class="normal">The private VLAN essentially breaks up the existing VLAN into sub-VLANs. There are three categories within a private VLAN:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">The Promiscuous (P) port</strong>: This port is allowed to send and receive layer 2 frames from any other port <a id="_idIndexMarker499"/>on the VLAN; this usually belongs to the port connecting to the layer 3 routers.</li>
      <li class="bulletList"><strong class="keyWord">The Isolated (I) port</strong>: This port is only<a id="_idIndexMarker500"/> allowed to communicate with P ports, and it is typically connected to hosts when you do not want it to communicate with other hosts in the same VLAN.</li>
      <li class="bulletList"><strong class="keyWord">The Community (C) port</strong>: This port is<a id="_idIndexMarker501"/> allowed to communicate with other C ports in the same community and with P ports.</li>
    </ul>
    <p class="normal">We can again use Ansible <a id="_idIndexMarker502"/>or any other Python scripts introduced so far to accomplish this task. By now, we should have enough practice and confidence to implement this feature via automation, so I will not repeat the steps here. Being aware of the private VLAN feature will come in handy when you need to isolate ports even further in a layer 2 VLAN.</p>
    <h2 class="heading-2" id="_idParaDest-169">UFW with Python</h2>
    <p class="normal">We briefly<a id="_idIndexMarker503"/> mentioned UFW as the front end for IP tables on<a id="_idIndexMarker504"/> Ubuntu hosts. Here is a quick overview:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo apt-get install ufw
<span class="hljs-con-meta">$ </span>sudo ufw status
<span class="hljs-con-meta">$ </span>sudo ufw default outgoing
<span class="hljs-con-meta">$ </span>sudo ufw allow 22/tcp
<span class="hljs-con-meta">$ </span>sudo ufw allow www
<span class="hljs-con-meta">$ </span>sudo ufw default deny incoming
We can see the status of UFW:
<span class="hljs-con-meta">$ </span>sudo ufw status verbose Status: active
Logging: on (low)
Default: deny (incoming), allow (outgoing), disabled (routed) New profiles: skip
To Action From
-- ------ ----
22/tcp ALLOW IN Anywhere
80/tcp ALLOW IN Anywhere
22/tcp (v6) ALLOW IN Anywhere (v6)
80/tcp (v6) ALLOW IN Anywhere (v6)
</code></pre>
    <p class="normal">As you can see, the advantage of UFW is that it provides a simple interface to construct otherwise complicated IP table rules. There are several Python-related tools we can use with UFW to make<a id="_idIndexMarker505"/> things even simpler:</p>
    <ul>
      <li class="bulletList">We can use <a id="_idIndexMarker506"/>the Ansible UFW module to streamline our operations. More information is available at <a href="https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html"><span class="url">https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html</span></a>. </li>
      <li class="bulletList">There are Python wrapper modules around UFW as an API (visit <a href="https://gitlab.com/dhj/easyufw"><span class="url">https://gitlab.com/dhj/easyufw</span></a>). This can make integration easier if you need to dynamically modify UFW rules based on certain events.</li>
      <li class="bulletList">UFW itself is written in Python. Therefore, you can use existing Python knowledge if we need to extend the current command sets. More information is available at <a href="https://launchpad.net/ufw"><span class="url">https://launchpad.net/ufw</span></a>.</li>
    </ul>
    <p class="normal">UFW proves to be a good tool to safeguard your network server.</p>
    <h1 class="heading-1" id="_idParaDest-170">Further reading</h1>
    <p class="normal">Python is a very common language used in many security-related fields. A few of the books I would recommend are listed as follows:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Violent Python</strong>: A cookbook for hackers, forensic analysts, penetration testers, and security engineers, by T.J. O’Connor (ISBN-10: 1597499579)</li>
      <li class="bulletList"><strong class="keyWord">Black Hat Python</strong>: Python programming for hackers and pen-testers, by Justin Seitz (ISBN-10: 1593275900)</li>
    </ul>
    <p class="normal">I have personally used Python extensively in my research work on <strong class="keyWord">Distributed Denial of Service</strong> (<strong class="keyWord">DDoS</strong>) at A10 Networks. If you are interested in learning more, the guide can be downloaded for free at <a href="https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/"><span class="url">https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/</span></a>. </p>
    <h1 class="heading-1" id="_idParaDest-171">Summary</h1>
    <p class="normal">In this chapter, we looked at network security with Python. We used the Cisco CML tool to set up our lab with hosts and network devices, consisting of NX-OSv and IOSv types. We took a tour around Scapy, which allows us to construct packets from the ground up.</p>
    <p class="normal">Scapy can be used in interactive mode for quick testing. Once testing is completed in interactive mode, we can put the steps into a file for more scalable testing. It can be used to perform various network penetration testing for known vulnerabilities.</p>
    <p class="normal">We also looked at how we can use both an IP access list and a MAC access list to protect our network. They are usually the first line of defense in our network protection. Using Ansible, we can deploy access lists consistently and quickly to multiple devices.</p>
    <p class="normal">Syslog and other log files contain useful information that we should regularly comb through to detect any early signs of a breach. Using Python regular expressions, we can systematically search for known log entries that can point us to security events that require our attention. Besides the tools we have discussed, private VLAN and UFW are among some other useful tools that we can use for more security protection.</p>
    <p class="normal">In <em class="chapterRef">Chapter 7</em>, <em class="italic">Network Monitoring with Python – Part 1</em>, we will look at how to use Python for network monitoring. Monitoring allows us to know what is happening in our network, as well as the state of the network.</p>
    <h1 class="heading-1">Join our book community</h1>
    <p class="normal">To join our community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/networkautomationcommunity"><span class="url">https://packt.link/networkautomationcommunity</span></a></p>
    <p class="normal"><img alt="" src="../Images/QR_Code2903617220506617062.png"/></p>
  </div>
</body></html>