- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Testing and Debugging FastAPI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和调试 FastAPI 应用程序
- en: 'In this chapter of our journey through mastering FastAPI, we pivot towards
    a crucial aspect of software development that ensures the reliability, robustness,
    and quality of your applications: testing and debugging. As we delve into this
    chapter, you’ll be equipped with the knowledge and tools necessary to create an
    effective testing environment, write and execute comprehensive tests, and debug
    your FastAPI applications with efficiency and precision.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握 FastAPI 的旅程中，本章我们将转向软件开发的一个关键方面，确保您应用程序的可靠性、健壮性和质量：测试和调试。随着我们深入本章，您将具备创建有效测试环境、编写和执行全面测试以及高效精确地调试
    FastAPI 应用程序所需的知识和工具。
- en: Understanding how to properly test and debug is not just about finding errors;
    it’s about ensuring your application can withstand real-world use, manage high
    traffic without faltering, and provide a seamless user experience. By mastering
    these skills, you’ll be able to confidently enhance your applications, knowing
    that each line of code has been scrutinized and each potential bottleneck has
    been addressed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何正确地进行测试和调试，不仅仅是找到错误；它关乎确保您的应用程序能够承受实际使用，在高流量下不会崩溃，并提供无缝的用户体验。通过掌握这些技能，您将能够自信地增强您的应用程序，知道每一行代码都经过仔细审查，每个潜在的瓶颈都已解决。
- en: We are going to create a proto application with a minimal setup to test the
    recipes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有最小设置的 proto 应用程序来测试食谱。
- en: By the end of this chapter, you will not only have a deep understanding of the
    testing frameworks and debugging strategies suitable for FastAPI but also practical
    experience in implementing these techniques to build more resilient applications.
    This knowledge is invaluable, as it directly impacts the quality of your software,
    its maintenance, and its scalability.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您不仅将深入理解适合 FastAPI 的测试框架和调试策略，还将具备将这些技术应用于构建更健壮应用程序的实际经验。这种知识是无价的，因为它直接影响到软件的质量、维护和可扩展性。
- en: 'In this chapter we’re going to cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Setting up testing environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: Writing and running unit tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行单元测试
- en: Testing API endpoints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 API 端点
- en: Handling logging messages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理日志消息
- en: Debugging techniques
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试技术
- en: Performance testing for high traffic application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高流量应用程序的性能测试
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To dive into the chapter and follow along with the recipes, ensure your setup
    includes the following essentials:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了深入本章内容并跟随食谱进行操作，请确保您的设置包括以下基本要素：
- en: '**Python**: Make sure to have a Python version 3.7 or higher installed on your
    computer.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：请确保您的计算机上已安装 Python 3.7 或更高版本。'
- en: '`fastapi` package in your working environment.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的工作环境中安装`fastapi`包。
- en: '`pytest` framework, which is a testing framework largely used to test Python
    code.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 框架，这是一个广泛用于测试 Python 代码的测试框架。'
- en: 'The code used in the chapter is hosted on GitHub at the address: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码托管在 GitHub 上，地址为：[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05)。
- en: 'You can setup a virtual environment for the project within the project root
    folder is also recommended to manage dependencies efficiently and maintain project
    isolation. Within your virtual environment, you can install all the dependencies
    at once by using the `requirements.txt` provided on the GitHub repository in the
    project folder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在项目根目录内为项目设置一个虚拟环境，以高效管理依赖项并保持项目隔离。在您的虚拟环境中，您可以使用项目文件夹中 GitHub 仓库提供的`requirements.txt`一次性安装所有依赖项：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A basic knowledge of HTTP protocol, although not required, can be beneficial.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但具备基本的 HTTP 协议知识可能会有所帮助。
- en: Setting up testing environments
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: This recipe will show you how to setup an efficient and effective testing environment
    tailored for FastAPI applications. By the end of the recipe, you will have a solid
    foundation for writing, running, and managing tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何设置一个针对 FastAPI 应用程序高效且有效的测试环境。到食谱结束时，您将拥有编写、运行和管理测试的坚实基础。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have an application running. If not you can start by creating
    a project folder `proto_app`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个正在运行的应用程序。如果没有，您可以从创建一个名为 `proto_app` 的项目文件夹开始。
- en: 'If you haven’t installed the packages with the requirements.txt file provided
    on the GitHub repository, then install the testing libraries `pytest` and `httpx`
    in your environment with:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用 GitHub 仓库上提供的 requirements.txt 文件安装包，那么请在你的环境中使用以下命令安装测试库 `pytest`
    和 `httpx`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the project root folder create a new folder `proto_app` with a `main.py`
    module containing the `app` object instance:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个新的文件夹 `proto_app`，其中包含一个 `main.py` 模块，该模块包含 `app` 对象实例：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With a minimal app setup, we can proceed by scaffolding our project to accommodate
    the tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小化应用程序设置，我们可以通过构建项目来容纳测试。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, let’s start by structuring our project folder tree to accommodate tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开始构建我们的项目文件夹树以容纳测试。
- en: 'In the root directory let’s create a `pytest.ini` file and a `tests` folder
    containing the test module `test_main.py`. The project structure should look like
    this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下，让我们创建一个 `pytest.ini` 文件和一个包含测试模块 `test_main.py` 的 `tests` 文件夹。项目结构应该如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[pytest]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[pytest]'
- en: pythonpath = . protoapp
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pythonpath = . protoapp
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in the `test_main.py` module, let’s write a test for the `/home` endpoint
    we created earlier:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `test_main.py` 模块中，让我们为之前创建的 `/home` 端点编写一个测试：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get an output like:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到如下输出：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `pytest` plugins used
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用的 `pytest` 插件
- en: The directory tests, the module `test_main.py and` the test `test_read_main`
    which is a coroutine
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目录 tests，模块 `test_main.py` 和测试 `test_read_main`，它是一个协程
- en: 'Now, from the command line terminal at the project root folder level, run the
    `pytest` command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在项目根目录的命令行终端中，运行 `pytest` 命令：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ve just setup the environment to test our proto application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经设置了测试我们的原型应用程序的环境。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The recipe has shown how to configure `pytest` within a **FastAPI** project
    with some of the good practices. Feel free to dig deeper into the **Pytest** official
    documentation at the links:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱展示了如何在 **FastAPI** 项目中配置 `pytest` 并使用一些良好实践。请随意深入了解 **Pytest** 的官方文档，链接如下：
- en: '*Pytest* *configuration*: [https://docs.pytest.org/en/stable/reference/customize.xhtml](https://docs.pytest.org/en/stable/reference/customize.xhtml)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pytest 配置*：[https://docs.pytest.org/en/stable/reference/customize.xhtml](https://docs.pytest.org/en/stable/reference/customize.xhtml)'
- en: '*Setup PYTHONPATH in* *Pytest*: [https://docs.pytest.org/en/7.1.x/explanation/pythonpath.xhtml](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.xhtml)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Pytest 中设置 PYTHONPATH*：[https://docs.pytest.org/en/7.1.x/explanation/pythonpath.xhtml](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.xhtml)'
- en: '*Pytest good* *practices*: [https://docs.pytest.org/en/7.1.x/explanation/goodpractices.xhtml](https://docs.pytest.org/en/7.1.x/explanation/goodpractices.xhtml)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pytest 良好实践*：[https://docs.pytest.org/en/7.1.x/explanation/goodpractices.xhtml](https://docs.pytest.org/en/7.1.x/explanation/goodpractices.xhtml)'
- en: Writing and running unit tests
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和运行单元测试
- en: Once we setup our testing environment, we can focus on the process of writing
    and executing tests for FastAPI applications. Unit tests are essential for validating
    the behaviour of individual parts of your application in isolation, ensuring they
    perform as expected. In this recipe, you will learn to test the endpoints of your
    application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了测试环境，我们就可以专注于编写和执行 FastAPI 应用程序的测试过程。单元测试对于验证应用程序各个部分在隔离状态下的行为至关重要，确保它们按预期执行。在本食谱中，你将学习如何测试应用程序的端点。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use `pytest` to test the FastAPI client in unit tests. Since the recipe
    will utilize common testing *fixtures*, used in most **Python** standard code,
    make sure to be familiar with the test fixtures before diving into the recipe.
    If this is not the case, you can always refer to the dedicated documentation page
    at the link: [https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml](https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `pytest` 来测试 FastAPI 客户端在单元测试中的表现。由于食谱将利用大多数 **Python** 标准代码中使用的公共测试 *固定装置*，在深入食谱之前，请确保熟悉测试固定装置。如果不是这样，你始终可以参考链接中的专用文档页面：[https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml](https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml)。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will start by creating a unit test for the same `GET /home` endpoint, but
    differently from the previous recipe. We will use the `TestClient` class provided
    by FastAPI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为相同的 `GET /home` 端点创建一个单元测试，但与之前的食谱不同。我们将使用 FastAPI 提供的 `TestClient` 类。
- en: Let’s create a fixture for that. Since it could be used by multiple tests let’s
    do it in a new `conftest.py` module under the `tests` folder. The `conftest.py`
    is a default file used by `pytest` to store common elements shared amongst test
    modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为它创建一个测试夹具。由于它可能被多个测试使用，让我们在`tests`文件夹下创建一个新的`conftest.py`模块。`conftest.py`是`pytest`用来存储在测试模块间共享的公共元素的默认文件。
- en: 'In the `conftest.py` let’s write:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`conftest.py`中，让我们编写：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are now ready to leverage the `test_client` fixture to create a proper unit
    test for our endpoint.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以利用`test_client`测试夹具为我们的端点创建一个适当的单元测试。
- en: 'We will write our test in the `test_main.py` module:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`test_main.py`模块中编写我们的测试：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And that’s it. Compared to the previous test, this one is more compact and faster
    to write, thanks to the `TestClient` class provided by FastAPI package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。与之前的测试相比，这个测试更紧凑，编写起来更快，归功于FastAPI包提供的`TestClient`类。
- en: 'Now run `pytest`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`pytest`：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will see a message on the terminal showing that two tests have been collected
    and run successfully.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在终端上看到一条消息，显示已成功收集并运行了两个测试。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can check more on the test client for FastAPI in the official documentation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中了解更多关于FastAPI测试客户端的信息：
- en: '*FastAPI Test* *Client*: [https://fastapi.tiangolo.com/reference/testclient/](https://fastapi.tiangolo.com/reference/testclient/)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI 测试* *客户端*: [https://fastapi.tiangolo.com/reference/testclient/](https://fastapi.tiangolo.com/reference/testclient/)'
- en: Testing API Endpoints
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试API端点
- en: Integration tests verify that different parts of your application work together
    as expected. They are crucial for ensuring that your system’s components interact
    correctly, especially when dealing with external services, databases, or other
    APIs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试验证你的应用程序的不同部分是否按预期协同工作。它们对于确保你的系统组件正确交互至关重要，尤其是在处理外部服务、数据库或其他API时。
- en: In this recipe, we will test two endpoints that interact with an SQL database.
    One will add an item to the database, the other will read an item based on the
    ID.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将测试两个与SQL数据库交互的端点。一个将项目添加到数据库，另一个将根据ID读取项目。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To apply the recipe you need your testing environment already setup for `pytest`.
    If this is not the case check the recipe *Setting up* *testing environments* of
    the same chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个配方，你需要你的测试环境已经为`pytest`设置好了。如果不是这种情况，请检查同一章节的配方*设置* *测试环境*。
- en: Also, the recipe will show you how to make integration tests with existing endpoints
    of the application. You can use it for your application or you can build the endpoints
    for our `protoapp` as follows.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个配方将向你展示如何使用现有端点进行集成测试。你可以用它来测试你的应用程序，或者你可以按照以下方式为我们的`protoapp`构建端点。
- en: If you are using the recipe to test your endpoint you can directly jump on the
    *How to it…* section and apply the rules to tour endpoints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用这个配方来测试你的端点，你可以直接跳到*如何进行…*部分，并将规则应用到你的端点上。
- en: 'Otherwise, If you haven’t installed the packages from the `requirements.txt`,
    install `sqlalchemy` package in your environment:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果你还没有从`requirements.txt`中安装包，请在你的环境中安装`sqlalchemy`包：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now let’s setup the database connection through the following steps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过以下步骤设置数据库连接。
- en: 'Under the `protoapp` folder, at the same level as the `main.py` module, let’s
    create a module `database.py` containing the setup of the database. Let’s start
    by creating the `Base` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`protoapp`文件夹下，与`main.py`模块处于同一级别，让我们创建一个包含数据库设置的`database.py`模块。让我们先创建`Base`类：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will use the `Base` class to define the `Item` mapping class.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`Base`类来定义`Item`映射类。
- en: 'Then the database `Item` mapping class will be like:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，数据库`Item`映射类将如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we define the database engine that will handle the session:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义将处理会话的数据库引擎：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The engine object will be used to handle the session.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引擎对象将用于处理会话。
- en: 'Then, let’s bind the engine to the Base mapping class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们将引擎绑定到`Base`映射类：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now the engine can map the database table to our Python classes.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，引擎可以将数据库表映射到我们的Python类。
- en: 'Last in the `database.py` module let’s create a `SessionLocal` class that will
    generate the session as:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`database.py`模块中，让我们创建一个`SessionLocal`类，它将生成会话，如下所示：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `SessionLocal` is a class that will initialize the database session object.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SessionLocal`是一个类，它将初始化数据库会话对象。'
- en: Finally, before creating the endpoints, let’s create a database session.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在创建端点之前，让我们创建一个数据库会话。
- en: 'Since the app is relatively small, we can do it the same `main.py`:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于应用程序相对较小，我们可以在同一个`main.py`中完成它：
- en: '[PRE17]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will use the session to interact with the database.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用会话与数据库进行交互。
- en: Now that we have setup the database connection, in the `main.py` module, we
    can create the endpoints one to add an item to the database and one to read it.
    Let's do it as follows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了数据库连接，在`main.py`模块中，我们可以创建一个端点来添加项目到数据库，以及一个端点来读取它。让我们这样做。
- en: 'Let''s start by creating the request body for the endpoints as::'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们首先为端点创建请求体:: '
- en: '[PRE18]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The endpoint used to add an item will then be:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于添加项目的端点将是：
- en: '[PRE19]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The endpoint will return the item ID affected when the item is stored in the
    database.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当项目存储在数据库中时，端点将返回受影响的项ID。
- en: 'Now that we have the endpoint to add the item, we can proceed by creating the
    endpoint to retrieve the item based on its ID:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了添加项目的端点，我们可以通过创建基于ID检索项目的端点来继续：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the ID does not correspond to any item in the database the endpoint will
    return a 404 status code.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果ID不对应于数据库中的任何项目，端点将返回404状态码。
- en: We have just created the endpoints that will allow us to create an integration
    test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了允许我们创建集成测试的端点。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Once we have the endpoints, in the `tests` folder we should adapt our `test_client`
    fixture to use a different session than the one used in production.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了端点，在`tests`文件夹中，我们应该适配我们的`test_client`固定装置以使用与生产中不同的会话。
- en: 'We will break the process into two main actions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把整个过程分解为两个主要动作：
- en: Adapt the test client to accommodate the testing database session
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试客户端适配以适应测试数据库会话
- en: Create the test to simulate the interaction of the endpoints
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建测试以模拟端点之间的交互
- en: Let's do it by following these steps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤进行。
- en: 'First, In the `conftest.py` file we created earlier in the recipe *Writing
    and running unit tests*, let’s define a new engine that will use an in-memory
    SQLite database and bind it to the mapping `Base` class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在之前在配方“编写和运行单元测试”中创建的`conftest.py`文件中，让我们定义一个新的引擎，该引擎将使用内存中的SQLite数据库并将其绑定到`Base`类映射：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s create a dedicated session maker for the testing session as:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为测试会话创建一个专门的会话创建器，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly to the function `get_db_session` in the `main.py` module, we can
    create a fixture to retrieve the test session in the conftest.py module:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似于`main.py`模块中的`get_db_session`函数，我们可以在`conftest.py`模块中创建一个固定装置来检索测试会话：
- en: '[PRE23]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we should modify the `test_client` to use this session instead of the
    production one. We can do it by overwriting the dependency that returns the session
    with the one we just created. FastAPI allows you to do it easily by calling the
    test client’s method `dependency_overrides` as:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们应该修改`test_client`以使用这个会话而不是生产会话。我们可以通过覆盖返回会话的依赖项来实现，FastAPI允许你通过调用测试客户端的方法`dependency_overrides`来轻松实现，如下所示：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each time the test client needs to call the session, the fixture will replace
    it with the test session that uses the in-memory database.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次测试客户端需要调用会话时，固定装置将用使用内存数据库的测试会话替换它。
- en: 'Then, to verify the interaction of our application with the database, we create
    a test that:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了验证我们的应用程序与数据库的交互，我们创建了一个测试：
- en: Create the item into the database through the `POST /``item` endpoint
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`POST /item`端点将项目创建到数据库中
- en: Verify that the item is correctly created into the test database by using the
    test session
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用测试会话验证项目是否正确创建在测试数据库中
- en: Retrieve the item through the `GET /``item` endpoint
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`GET /item`端点检索项目
- en: 'You can put the test into the `test_main.py` and here is how it would look
    like:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将测试放入`test_main.py`，以下是它的样子：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You’ve just created an integration test for our proto application, feel free
    to enrich your application and create more tests accordingly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚为我们的原型应用创建了一个集成测试，请随意丰富你的应用并相应地创建更多测试。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: We have setup an in-memory SQLite database for our tests. Since each session
    is bonded to a thread, the engine needs to be configured accordingly to not flush
    data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为测试设置了一个内存中的SQLite数据库。由于每个会话都与线程绑定，因此需要相应地配置引擎以避免刷新数据。
- en: 'The configuration strategy has been found on the following documentation page:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 配置策略已在以下文档页面找到：
- en: '*SQLite In-Memory Database* *Configuration*: [https://docs.sqlalchemy.org/en/14/dialects/sqlite.xhtml#using-a-memory-database-in-multiple-threads](https://docs.sqlalchemy.org/en/14/dialects/sqlite.xhtml#using-a-memory-database-in-multiple-threads)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SQLite内存数据库* *配置*：[https://docs.sqlalchemy.org/en/14/dialects/sqlite.xhtml#using-a-memory-database-in-multiple-threads](https://docs.sqlalchemy.org/en/14/dialects/sqlite.xhtml#using-a-memory-database-in-multiple-threads)'
- en: Running tests techniques
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试技术
- en: By systematically covering all endpoints and scenarios, you ensure that your
    API behaves correctly under various conditions, providing confidence in your application’s
    functionality. Thoroughly testing API endpoints is essential for building reliable
    and robust applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过系统地覆盖所有端点和场景，你确保了你的API在各种条件下表现正确，从而为你的应用程序的功能提供信心。彻底测试API端点是构建可靠和健壮应用程序的基本要求。
- en: The recipe will explain to you how to run tests individually or by group and
    how to check the test coverage of our code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将解释如何单独或按组运行测试以及如何检查代码的测试覆盖率。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To run the recipe, make sure you already have some tests in place, or you already
    followed all the previous recipes of the chapter. Also, make sure you have your
    PYTHONPATH for tests defined in your `pytest.ini`. Have a look at the recipe *Setting
    up* *testing environments* on how to do it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个配方，确保你已经放置了一些测试，或者你已经遵循了本章的所有前一个配方。此外，确保你在`pytest.ini`中定义了测试的PYTHONPATH。查看配方*设置*
    *测试环境*了解如何操作。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will start by looking at how to run tests by default grouping (individually
    or by module), and then we will cover a technique for customizing test grouping
    based on marks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看如何通过默认分组（单独或按模块）运行测试，然后我们将介绍一种基于标记自定义测试分组的技术。
- en: 'As you already know, all unit tests can be run from the terminal with the command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，所有单元测试都可以通过终端使用以下命令运行：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'However, a test can be run individually according to the test call syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以根据测试调用语法单独运行测试：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, if we want to run the test function `test_read_main_client`, run:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想运行测试函数`test_read_main_client`，运行：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sometimes test names become too complicated to remember or we have a specific
    need to run only a targeted set of tests. Here is where test marks come to the
    aid.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有时测试名称变得过于复杂难以记住，或者我们有特定的需求只想运行一组特定的测试。这就是测试标记发挥作用的地方。
- en: Let’s imagine we want to run only integration tests. In our app, the only integration
    test is represented by the function `tests_client_can_add_read_the_item_from_database`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们只想运行集成测试。在我们的应用程序中，唯一的集成测试由函数`tests_client_can_add_read_the_item_from_database`表示。
- en: 'We can apply a mark by adding the specific decorator to the function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加特定的装饰器到函数中来应用标记：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, in the `pytest.ini` configuration add the `integration` marker in the
    dedicated sections to register the mark:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`pytest.ini`配置文件中，在专用部分添加`integration`标记以注册标记：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now you can run the targeted tests by running:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过以下方式运行目标测试：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the output message, you will see that only the marked test has been selected
    and run. You can use markers to group your application’s tests based on logical
    criteria, for example by functional meaning one group for **create, read, update
    and delete** (**CRUD**) operations, one group for security operations, and so
    on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出信息中，你会看到只有标记的测试被选中并运行。你可以使用标记根据逻辑标准对应用程序的测试进行分组，例如，一个组用于**创建、读取、更新和删除**（**CRUD**）操作，一个组用于安全操作，等等。
- en: Check test coverage
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查测试覆盖率
- en: To make sure that your endpoints are covered by testing as well as the text
    lines of your code, it can become useful to have an idea of the test coverage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的端点以及代码的文本行都经过了测试，了解测试覆盖率可能很有用。
- en: Test coverage is a metric used in software testing to measure the extent to
    which the source code of a program is executed when a particular test suite runs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率是软件测试中用来衡量在特定测试套件运行时程序源代码执行程度的指标。
- en: 'To use it with `pytest`, if you didn’t install the packages with the `requirements.txt`,
    you need to install `pytest-cov` package:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要与`pytest`一起使用，如果你没有使用`requirements.txt`安装包，你需要安装`pytest-cov`包：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The way it works is quite straightforward. You need to pass the source code
    root, in our case the `protoapp` directory, to the parameter `–cov` of `pytest`
    and tests root folder, in our case tests as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式非常直接。你需要将源代码根目录（在我们的例子中是`protoapp`目录）传递给`pytest`的`--cov`参数和测试根目录（在我们的例子中是测试），如下所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You will see a table in the output listing the coverage percentage for each
    module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在输出中看到一个表格，列出每个模块的覆盖率百分比：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In addition, a file named `.coverage` has been created. This is a binary file
    containing data on the test coverage and that can be used with additional tools
    to generate reports out of it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还创建了一个名为`.coverage`的文件。这是一个包含测试覆盖率数据的二进制文件，可以使用其他工具从中生成报告。
- en: 'For example, if you run:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你运行：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It will create a folder `htmlcov` with an `index.xhtml` page containing the
    coverage page and you can visualize it by opening it with a browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建一个名为`htmlcov`的文件夹，其中包含一个`index.xhtml`页面，包含覆盖率页面，您可以通过用浏览器打开它来可视化它。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can check more on various options to invoke unit tests with Pytest and how
    to evaluate test coverage at the official documentation links
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档链接中了解更多有关使用Pytest调用单元测试的选项以及如何评估测试覆盖率。
- en: '*Invoke Unit test with* *Pytest*: [https://docs.pytest.org/en/7.1.x/how-to/usage.xhtml](https://docs.pytest.org/en/7.1.x/how-to/usage.xhtml)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Pytest调用单元测试*：[https://docs.pytest.org/en/7.1.x/how-to/usage.xhtml](https://docs.pytest.org/en/7.1.x/how-to/usage.xhtml)'
- en: '*Pytest* *Coverage*: [https://pytest-cov.readthedocs.io/en/latest/](https://pytest-cov.readthedocs.io/en/latest/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pytest* *覆盖率*：[https://pytest-cov.readthedocs.io/en/latest/](https://pytest-cov.readthedocs.io/en/latest/)'
- en: Handling logging messages
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日志消息
- en: Effectively managing logs in application development not only aids in identifying
    errors promptly but also provides valuable insights into user interactions, system
    performance, and potential security threats. It serves as a crucial tool for auditing,
    compliance, and optimizing resource utilization, ultimately enhancing the reliability
    and scalability of the software.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发中有效地管理日志不仅有助于及时识别错误，还能提供有关用户交互、系统性能和潜在安全威胁的宝贵见解。它作为审计、合规和优化资源利用的关键工具，最终增强了软件的可靠性和可扩展性。
- en: This recipe will show how to efficiently implement a logging system into our
    FastAPI application to monitor the calls to the API.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何高效地将日志记录系统集成到我们的FastAPI应用程序中，以监控API的调用。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to use some basic features of the Python logging ecosystem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python日志生态系统的一些基本功能。
- en: 'Although the example is basic, you can refer to the official documentation
    to get familiar with related terms such as **logger**, **handler** , **formatter**,
    and **log level**. Follow this link:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子很简单，但您可以参考官方文档，了解相关术语，如**日志记录器**、**处理程序**、**格式化器**和**日志级别**。请点击以下链接：
- en: '[https://docs.python.org/3/howto/logging-cookbook.xhtml](https://docs.python.org/3/howto/logging-cookbook.xhtml).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/howto/logging-cookbook.xhtml](https://docs.python.org/3/howto/logging-cookbook.xhtml)。'
- en: To implement logging into FastAPI, make sure you have a running application
    or use the `protoapp` we developed all along the chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要将日志记录集成到FastAPI中，请确保您有一个运行中的应用程序或使用本章中一直开发的`protoapp`。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We want to create a logger that prints the client’s calls information to the
    terminal and logs them into a file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建一个日志记录器，将客户端的调用信息打印到终端并记录到文件中。
- en: Let’s create the logger into a dedicated `logging.py` module under the folder
    `protoapp`, through the following steps.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`protoapp`文件夹下的`logging.py`模块中创建日志记录器，按照以下步骤进行。
- en: 'Let’s start by defining the logger with a level value to `INFO`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先定义一个具有`INFO`级别值的日志记录器：
- en: '[PRE36]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since we want to stream the message to the console and store it in a file, we
    will need to define two separate handlers.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们希望将消息流式传输到控制台并存储到文件中，我们需要定义两个单独的处理程序。
- en: 'Now let’s define the handler to print log messages to the console. We will
    use a `StreamHandler` object from the `logging` built-in package:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个处理程序，将日志消息打印到控制台。我们将使用`logging`内置包中的`StreamHandler`对象：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will stream the message to the console.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会将消息流式传输到控制台。
- en: 'Let’s create a colorized formatter and add it to the handler we just created:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个彩色格式化器并将其添加到我们刚刚创建的处理程序中：
- en: '[PRE38]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The formatter will format log messages in the same of the default logger uvicorn
    logger used by FastAPI.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 格式化器将以FastAPI使用的默认日志记录器uvicorn日志记录器的格式格式化日志消息。
- en: 'Then let’s add the handler to the logger:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后让我们将处理程序添加到日志记录器中：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have just set up the logger to print message to the console.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚设置了日志记录器，以便将消息打印到控制台。
- en: 'Let’s repeat the previous *steps from 1 to 4* to create a handler that stores
    messages into a file and adds it to our `client_logger`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重复之前的*步骤1到4*来创建一个将消息存储到文件并添加到我们的`client_logger`的处理程序：
- en: '[PRE40]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we have our logger setup. Each message will be streamed to the console and
    stored in a `app.log` file.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经设置了日志记录器。每条消息都将被输出到控制台并存储在`app.log`文件中。
- en: Once we have built our `client_logger`, we need to use it in the code to get
    information about clients calls.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们构建了我们的`client_logger`，我们就在代码中使用它来获取客户端调用的信息。
- en: 'You can reach this by adding the logger and a dedicated middleware in the `main.py`
    module:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过在`main.py`模块中添加日志记录器和专用中间件来实现这一点：
- en: '[PRE41]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now spin up the server:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动服务器：
- en: '[PRE42]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Try to call any of the endpoints we defined, you will see on the terminal the
    logs we just defined for the request and response. Also, you will find only the
    messages from our `logger_client` in a newly created `app.log` file automatically
    created by the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调用我们定义的任何端点，你将在终端上看到我们为请求和响应定义的日志。此外，你将在由应用程序自动创建的新`app.log`文件中找到来自我们的`logger_client`的消息。
- en: There’s more
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: 'Defining a proper logging strategy would require a separate cookbook and it
    is out of the scope of the book. However, when building a logger into an application
    it is important to follow some guidelines:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 定义合适的日志策略需要单独的食谱，但这超出了本书的范围。然而，当将日志记录器集成到应用程序中时，遵循一些指南是很重要的：
- en: '**Use standard Logging Levels Appropriately**. A classical leveling system
    is made up of 4 levels: **INFO**, **WARNING**, **ERROR**, **CRITICAL**. You may
    need to have more or even less than four depending on the application. Anyway,
    place each message at the appropriate level.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适当使用标准日志级别**。一个经典的级别系统由4个级别组成：**INFO**、**WARNING**、**ERROR**、**CRITICAL**。根据应用程序的需要，你可能需要更多或更少的级别。无论如何，将每条消息放置在适当的级别。'
- en: '**Consist Log Format**. Maintain a consistent log format across your application.
    This includes consistent datetime formats, including the severity level, and describing
    the event clearly. A consistent format helps in parsing logs and automating log
    analysis.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持日志格式一致**。在整个应用程序中保持一致的日志格式。这包括一致的日期时间格式、严重级别，以及清楚地描述事件。一致的格式有助于解析日志和自动化日志分析。'
- en: '**Include Contextual Information**. Include relevant contextual information
    in your logs (e.g., user ID, transaction ID) to help trace and debug issues across
    your application’s workflow.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含上下文信息**。在你的日志中包含相关的上下文信息（例如，用户ID，事务ID），以帮助追踪和调试应用程序工作流程中的问题。'
- en: '**Avoid Sensitive Information**. Never log sensitive information such as passwords,
    API keys, or **personal identifiable information** (**PII**). If necessary, mask
    or hash these details.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免敏感信息**。永远不要记录敏感信息，如密码、API密钥或**个人可识别信息**（**PII**）。如果必要，可以对这些细节进行掩码或哈希处理。'
- en: '**Make Efficient Logging**. Be mindful of the performance impact of logging.
    Logging excessively can slow down your application and lead to log noise, making
    it hard to find useful information. Balance the need for information against the
    performance impact.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效日志记录**。注意日志记录对性能的影响。过度记录可能会减慢应用程序的速度，并导致日志噪声，使得找到有用的信息变得困难。在信息需求与性能影响之间取得平衡。'
- en: And of course, this is not a comprehensive list.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一个详尽的列表。
- en: See also
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'Python distribution comes with a powerful built-in package for logging, feel
    to have a look at the official documentation:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Python发行版自带一个强大的内置日志记录包，您可以查看官方文档：
- en: '*Python* *logging*: [https://docs.python.org/3/library/logging.xhtml](https://docs.python.org/3/library/logging.xhtml)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python* *日志记录*: [https://docs.python.org/3/library/logging.xhtml](https://docs.python.org/3/library/logging.xhtml)'
- en: 'Furthermore, discover more on logging best practices and guidelines at the
    **Sentry** blog:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在**Sentry**博客上了解更多关于日志记录最佳实践和指南：
- en: '*Logging* *Guidelines*: [https://blog.sentry.io/logging-in-python-a-developers-guide/](https://blog.sentry.io/logging-in-python-a-developers-guide/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*日志记录* *指南*: [https://blog.sentry.io/logging-in-python-a-developers-guide/](https://blog.sentry.io/logging-in-python-a-developers-guide/)'
- en: '**Sentry** is a tool to monitor Python code.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sentry**是一个用于监控Python代码的工具。'
- en: Debugging techniques
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试技术
- en: Mastering debugging application development is crucial for identifying and fixing
    issues efficiently. This recipe delves into the practical use of the debugger,
    leveraging tools and strategies to pinpoint problems in your FastAPI code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握调试应用程序开发对于高效识别和修复问题至关重要。这个食谱深入探讨了调试器的实际应用，利用工具和策略来定位FastAPI代码中的问题。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need to do to apply the recipe is to have a running application. We
    can keep on working with our `protoapp`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用这个食谱，你只需要有一个正在运行的应用程序。我们可以继续使用我们的`protoapp`进行工作。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The Python distribution already comes with a default debugger called `pdb`.
    If you use an **integrated development environment** (**IDE**), it usually comes
    with an editor distribution debugger. Whatever you are using to debug your code,
    you must be familiar with the concept of breakpoints.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python发行版已经自带了一个默认的调试器，称为`pdb`。如果你使用的是**集成开发环境**（**IDE**），它通常包含一个编辑器分布调试器。无论你使用什么来调试你的代码，你必须熟悉断点的概念。
- en: A **breakpoint** is a point within the code that pauses the execution and shows
    you the state of the code variables and calls. It can be attached with a condition
    that, if satisfied, activate it or skips otherwise.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**断点**是代码中的一个点，它暂停执行并显示代码变量的状态和调用。它可以附加一个条件，如果满足条件，则激活它，否则跳过。'
- en: Whether you are using the Python distribution debugger `pdb` or the one provided
    by your IDE, it can be useful to define a starting script to spin up the server.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用的是Python发行版调试器`pdb`还是你的IDE提供的调试器，定义一个启动脚本来启动服务器可能很有用。
- en: 'Create on the project root folder a file called `run_server.py` containing
    the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个名为`run_server.py`的文件，包含以下代码：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The script imports the `uvicorn` package and our application `app` and runs
    the application into the `uvicorn` server. It is equivalent to the launching command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本导入`uvicorn`包和我们的应用`app`，并在`uvicorn`服务器上运行应用。这相当于启动命令：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Having a script gives us more flexibility to run the server and include it into
    a broader python routine if required.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个脚本可以让我们有更大的灵活性来运行服务器，并在需要时将其包含到一个更广泛的Python程序中。
- en: 'To check that it is correctly setup run the script as you would run a normal
    python script:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否正确设置，像运行正常的Python脚本一样运行脚本：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With your favourite browser go to `localhost:8000/docs` and check that the documentation
    has been correctly generated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的浏览器访问`localhost:8000/docs`并检查文档是否已正确生成。
- en: Debugging with PDB
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PDB进行调试
- en: The PDB debugger comes by default with any Python distribution. From Python
    versions higher than 3.7, you can define a breakpoint by simply adding the function
    call `breakpoint()` at the line of the code you want to pause, and then run the
    code as you would it normally.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: PDB调试器默认包含在任何Python发行版中。从Python 3.7以上的版本开始，你可以通过在想要暂停的代码行添加函数调用`breakpoint()`来定义一个断点，然后像平常一样运行代码。
- en: 'If you then run the code, when it reaches the breakpoint line, the execution
    will automatically shift to debug mode, and you can run debugging commands from
    the terminal. You can find the list of the commands you can run by typing help:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行代码，当它到达断点行时，执行将自动切换到调试模式，你可以从终端运行调试命令。你可以通过输入help来找到你可以运行的命令列表：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can run commands to list variables, show the stack trace to check to recent
    frame, or define new breakpoints with conditions and more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行列出变量、显示堆栈跟踪以检查最近的帧或定义带有条件的新断点等命令。
- en: 'Here you can find the list of all the command available: [https://docs.python.org/3/library/pdb.xhtml#debugger-commands](https://docs.python.org/3/library/pdb.xhtml#debugger-commands).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以找到所有可用命令的列表：[https://docs.python.org/3/library/pdb.xhtml#debugger-commands](https://docs.python.org/3/library/pdb.xhtml#debugger-commands)。
- en: 'You can also invoke `pdb` as a module. In this case `pdb` will automatically
    enter **post-mortem** debugging if the program exists abnormally:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`pdb`作为模块调用。在这种情况下，如果程序异常退出，`pdb`将自动进入**事后**调试：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That means that `pdb` will restart the program automatically by preserving `pdb`
    module's execution state including breakpoints.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`pdb`将自动重启程序，同时保留`pdb`模块的执行状态，包括断点。
- en: 'The same can be done when debugging tests by calling `pytest` as a module,
    for example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过调用`pytest`作为模块进行测试调试时，也可以这样做：
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Another debugging strategy consists of leveraging the reload functionality
    of the `uvicorn` server. To do that, you need to modify the `run_server.py` file
    as:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调试策略是利用`uvicorn`服务器的重新加载功能。为此，你需要修改`run_server.py`文件，如下所示：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, run the server without the `pdb` module:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，不使用`pdb`模块运行服务器：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this way, you can always use the breakpoints at ease with the reloading server
    functionality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '这样，你就可以在重新加载服务器功能下轻松地使用断点。 '
- en: At the time of writing, `unvicorn`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`unvicorn`。
- en: Debugging with VS Code
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VS Code进行调试
- en: 'VS Code Python extension comes with its distribution debugger called *debugpy*.
    Configurations for the running environment can be managed in the `.vscode/launch.json`
    file. An example of the configuration file to debug our server is:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code Python 扩展自带其分布式的调试器，称为 *debugpy*。运行环境的配置可以在 `.vscode/launch.json` 文件中管理。调试我们服务器的配置文件示例如下：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The configuration specifies the type of debugger to use (`debugpy`), the program
    to run (our launching script `run_server.py`), and it can be found in the GUI
    options.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 配置指定了要使用的调试器类型（`debugpy`）、要运行的程序（我们的启动脚本 `run_server.py`），并且可以在 GUI 选项中找到。
- en: The `request` field specifies the mode to run the debugger, it can be *launch*,
    intended to run the program, or *attach*, intended to be attached to an already
    running instance, particularly useful to debug programs running on remote instances.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 字段指定了运行调试器的模式，可以是 *launch*（用于运行程序），或 *attach*（用于连接到已运行的实例），这对于调试运行在远程实例上的程序特别有用。'
- en: 'Debugging remote instance is out of the scope of the recipe, but you can find
    detailed instructions at on the official documentation: [https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection](https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 调试远程实例超出了本食谱的范围，但您可以在官方文档中找到详细说明：[https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection](https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection)
- en: 'Debugging configuration can be setup to run unit tests as well by leveraging
    the *Test Explorer* extension. The extension will look for a configuration in
    the `launch.json` containing `"type": "python"` and `"purpose": ["debug-test"]`
    (or `"request": "test"`). An example of configuration to debug tests would be:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '可以通过利用 *Test Explorer* 扩展来设置调试配置以运行单元测试。该扩展将在 `launch.json` 中查找包含 `"type":
    "python"` 和 `"purpose": ["debug-test"]`（或 `"request": "test"`）的配置。调试测试的配置示例如下：'
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can find an extensive explication on the extension page from the VS Code
    marketplace at: [https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.vscode-python-test-adapter](https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.vscode-python-test-adapter).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 VS Code 市场扩展页面找到详细的解释：[https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.vscode-python-test-adapter](https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.vscode-python-test-adapter)。
- en: Debugging with PyCharm
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PyCharm 进行调试
- en: PyCharm manages code execution through run/debug configurations, which are sets
    of named startup properties detailing execution parameters and environments. These
    configurations allow running scripts with different settings, such as using various
    Python interpreters, environment variables, and input sources.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 通过运行/调试配置管理代码执行，这些配置是一组命名的启动属性集，详细说明了执行参数和环境。这些配置允许使用不同的设置运行脚本，例如使用不同的
    Python 解释器、环境变量和输入源。
- en: 'Run/debug configurations are of two kinds:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 运行/调试配置有两种类型：
- en: 'Temporary: Automatically generated for each run or debug session.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时：自动为每次运行或调试会话生成。
- en: 'Permanent: Manually created from a template or by converting a temporary one,
    and saved within your project indefinitely until deleted.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永久：手动从模板创建或由临时配置转换而来，并保存在您的项目中，直到删除。
- en: PyCharm by default uses an existing permanent configuration or creates a temporary
    one for each session. Temporary configurations are capped at five, with the oldest
    deleted for new ones. This limit can be adjusted in the settings (**Settings**
    | **Advanced Settings** | **Run/Debug** | **Temporary configurations limit**).
    Icons distinguish between permanent (opaque) and temporary (semi-transparent)
    configurations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 默认使用现有的永久配置或为每个会话创建一个临时配置。临时配置限制为五个，最旧的配置将被删除以为新配置腾出空间。此限制可以在设置中调整（**设置**
    | **高级设置** | **运行/调试** | **临时配置限制**）。图标区分永久（不透明）和临时（半透明）配置。
- en: Each configuration can be stored in a single xml file that is automatically
    detected by the GUI.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个配置都可以存储在一个单独的 xml 文件中，该文件由 GUI 自动检测。
- en: 'An example of configuration for our FastAPI `protoapp` is the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 FastAPI `protoapp` 的配置示例如下：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can find a detailed guide on how to setup it at the dedicated Pycharm documentation
    page at: [https://www.jetbrains.com/help/pycharm/run-debug-configuration.xhtml](https://www.jetbrains.com/help/pycharm/run-debug-configuration.xhtml).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在专门的 PyCharm 文档页面找到如何设置的详细指南：[https://www.jetbrains.com/help/pycharm/run-debug-configuration.xhtml](https://www.jetbrains.com/help/pycharm/run-debug-configuration.xhtml)。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Feel free to dig into each of the debugging solutions and concepts we just
    explained at the links:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地深入研究我们刚刚在链接中解释的每个调试解决方案和概念：
- en: '*Python distribution* *debugger*: [https://docs.python.org/3/library/pdb.xhtml](https://docs.python.org/3/library/pdb.xhtml)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python发行版调试器*：[https://docs.python.org/3/library/pdb.xhtml](https://docs.python.org/3/library/pdb.xhtml)'
- en: '*Breakpoints*: [https://docs.python.org/3/library/functions.xhtml#breakpoint](https://docs.python.org/3/library/functions.xhtml#breakpoint)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*断点*：[https://docs.python.org/3/library/functions.xhtml#breakpoint](https://docs.python.org/3/library/functions.xhtml#breakpoint)'
- en: '*Uvicorn* *Settings*: [https://www.uvicorn.org/settings/](https://www.uvicorn.org/settings/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Uvicorn设置*：[https://www.uvicorn.org/settings/](https://www.uvicorn.org/settings/)'
- en: '*Debugging with VS* *Code*: [https://code.visualstudio.com/docs/python/debugging](https://code.visualstudio.com/docs/python/debugging)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用VS Code进行调试*：[https://code.visualstudio.com/docs/python/debugging](https://code.visualstudio.com/docs/python/debugging)'
- en: '*Debugy* *Debugger*: [https://github.com/microsoft/debugpy/](https://github.com/microsoft/debugpy/)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Debugy调试器*：[https://github.com/microsoft/debugpy/](https://github.com/microsoft/debugpy/)'
- en: '*Debugging with* *PyCharm*: [https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.xhtml](https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.xhtml)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用PyCharm进行调试*：[https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.xhtml](https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.xhtml)'
- en: Performance testing for high traffic applications
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高流量应用程序的性能测试
- en: Performance testing is crucial for ensuring your application can handle real-world
    usage scenarios, especially under high load. By systematically implementing and
    running performance tests, analyzing results, and optimizing based on findings,
    you can significantly improve your application’s responsiveness, stability, and
    scalability.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试对于确保你的应用程序能够处理现实世界的使用场景至关重要，尤其是在高负载下。通过系统地实施和运行性能测试，分析结果，并根据发现进行优化，你可以显著提高应用程序的响应性、稳定性和可扩展性。
- en: The recipe will show the basics of how to benchmark your application with **Locust**
    framework.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱将展示如何使用**Locust**框架基准测试你的应用程序的基础知识。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To run performance testing you need a working application, we will use our `protoapp`,
    and a testing framework. We will use **Locust** framework for the purpose, which
    a testing framework based on Python syntax.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行性能测试，你需要一个运行中的应用程序，我们将使用我们的`protoapp`和一个测试框架。我们将使用基于Python语法的**Locust**框架，它是一个测试框架。
- en: 'You can find a detailed explication on the official documentation at: [https://docs.locust.io/en/stable/](https://docs.locust.io/en/stable/).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到详细的解释：[https://docs.locust.io/en/stable/](https://docs.locust.io/en/stable/)。
- en: 'Before starting, make sure you installed it in your virtual environment by
    running:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保你已经通过运行以下命令在你的虚拟环境中安装了它：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now we are ready to setup our configuration file and run the locust instance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好设置配置文件并运行locust实例。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: With the application running and the `locust` package installed, we will proceed
    by specifying our configuration to run the performance test.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序正在运行且已安装`locust`包时，我们将通过指定我们的配置来运行性能测试。
- en: Create a `locustfile.py` in your project root. This file will define the behavior
    of users interacting with your application under test.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录中创建一个`locustfile.py`文件。此文件将定义与测试中的应用程序交互的用户的行为。
- en: 'A minimal example of `locustfile.py` can be:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`locustfile.py`的最小示例可以是：'
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The configuration defines a client class with the service address and the endpoint
    we want to test.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 配置定义了一个客户端类，其中包含服务地址和我们要测试的端点。
- en: 'Start your FastAPI server with:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动你的FastAPI服务器：
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then in another terminal window run locust:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在另一个终端窗口中运行locust：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Open your browser and navigate to `http://localhost:8089` to access the web
    interface of the application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器并导航到`http://localhost:8089`以访问应用程序的Web界面。
- en: 'The web interface is intuitively designed, making it straightforward to:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Web界面设计直观，使得以下操作变得简单：
- en: '**Set Concurrent Users**: Specify the maximum number of users accessing the
    service simultaneously during peak usage.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置并发用户**：指定在高峰使用期间同时访问服务的最大用户数。'
- en: '**Configure Ramp-Up Rate**: Determine the rate of new users added per second
    to simulate increasing traffic.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置爬坡速率**：确定每秒添加的新用户数量以模拟增加的流量。'
- en: After configuring these parameters, click the `/home` endpoint defined in the
    `locustfile.py`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好这些参数后，点击`locustfile.py`中定义的`/home`端点。
- en: 'Alternatively, you can simulate traffic using the command line. Here’s how:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用命令行模拟流量。以下是方法：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This command runs Locust in a headless mode to simulate:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以无头模式运行 Locust 以模拟：
- en: 10 users accessing your application concurrently.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10 个用户同时访问您的应用程序。
- en: A spawn rate of 1 user per second.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒产生 1 个用户。
- en: You push your test experience further by including it in a **Continuous Integration
    /Continuous Delivery** (**CI/CD**) pipeline before deploying, or even into a larger
    testing routine.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署之前，您可以通过将其包含在 **持续集成/持续交付**（**CI/CD**）管道中，或者甚至将其纳入更大的测试流程中，来进一步扩展您的测试体验。
- en: Dig into the documentation to test every aspect of the traffic for your application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 深入文档以测试您应用程序流量的各个方面。
- en: You have all the tools to debug and fully test your application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您拥有所有调试和全面测试您应用程序的工具。
- en: In the next chapter, we are going to build a comprehensive RESTful application
    interacting with an SQL database.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个与 SQL 数据库交互的综合 RESTful 应用程序。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can find more on Locust on the official documentation pages:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档页面上找到更多关于 Locust 的信息：
- en: '*Locust* *QuickStart*: [https://docs.locust.io/en/stable/quickstart.xhtml](https://docs.locust.io/en/stable/quickstart.xhtml)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Locust 快速入门*：[https://docs.locust.io/en/stable/quickstart.xhtml](https://docs.locust.io/en/stable/quickstart.xhtml)'
- en: '*Writing a Locust* *file*: [https://docs.locust.io/en/stable/writing-a-locustfile.xhtml](https://docs.locust.io/en/stable/writing-a-locustfile.xhtml)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写 Locust 文件*：[https://docs.locust.io/en/stable/writing-a-locustfile.xhtml](https://docs.locust.io/en/stable/writing-a-locustfile.xhtml)'
- en: '*Running Locust from the Command* *Line*: [https://docs.locust.io/en/stable/running-without-web-ui.xhtml](https://docs.locust.io/en/stable/running-without-web-ui.xhtml)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从命令行运行 Locust*：[https://docs.locust.io/en/stable/running-without-web-ui.xhtml](https://docs.locust.io/en/stable/running-without-web-ui.xhtml)'
