- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and Debugging FastAPI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter of our journey through mastering FastAPI, we pivot towards
    a crucial aspect of software development that ensures the reliability, robustness,
    and quality of your applications: testing and debugging. As we delve into this
    chapter, you’ll be equipped with the knowledge and tools necessary to create an
    effective testing environment, write and execute comprehensive tests, and debug
    your FastAPI applications with efficiency and precision.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to properly test and debug is not just about finding errors;
    it’s about ensuring your application can withstand real-world use, manage high
    traffic without faltering, and provide a seamless user experience. By mastering
    these skills, you’ll be able to confidently enhance your applications, knowing
    that each line of code has been scrutinized and each potential bottleneck has
    been addressed.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a proto application with a minimal setup to test the
    recipes.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will not only have a deep understanding of the
    testing frameworks and debugging strategies suitable for FastAPI but also practical
    experience in implementing these techniques to build more resilient applications.
    This knowledge is invaluable, as it directly impacts the quality of your software,
    its maintenance, and its scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up testing environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and running unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing API endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling logging messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing for high traffic application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To dive into the chapter and follow along with the recipes, ensure your setup
    includes the following essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: Make sure to have a Python version 3.7 or higher installed on your
    computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastapi` package in your working environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest` framework, which is a testing framework largely used to test Python
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code used in the chapter is hosted on GitHub at the address: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can setup a virtual environment for the project within the project root
    folder is also recommended to manage dependencies efficiently and maintain project
    isolation. Within your virtual environment, you can install all the dependencies
    at once by using the `requirements.txt` provided on the GitHub repository in the
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A basic knowledge of HTTP protocol, although not required, can be beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up testing environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to setup an efficient and effective testing environment
    tailored for FastAPI applications. By the end of the recipe, you will have a solid
    foundation for writing, running, and managing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have an application running. If not you can start by creating
    a project folder `proto_app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed the packages with the requirements.txt file provided
    on the GitHub repository, then install the testing libraries `pytest` and `httpx`
    in your environment with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the project root folder create a new folder `proto_app` with a `main.py`
    module containing the `app` object instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With a minimal app setup, we can proceed by scaffolding our project to accommodate
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s start by structuring our project folder tree to accommodate tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root directory let’s create a `pytest.ini` file and a `tests` folder
    containing the test module `test_main.py`. The project structure should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[pytest]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pythonpath = . protoapp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `test_main.py` module, let’s write a test for the `/home` endpoint
    we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get an output like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `pytest` plugins used
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The directory tests, the module `test_main.py and` the test `test_read_main`
    which is a coroutine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, from the command line terminal at the project root folder level, run the
    `pytest` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve just setup the environment to test our proto application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The recipe has shown how to configure `pytest` within a **FastAPI** project
    with some of the good practices. Feel free to dig deeper into the **Pytest** official
    documentation at the links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pytest* *configuration*: [https://docs.pytest.org/en/stable/reference/customize.xhtml](https://docs.pytest.org/en/stable/reference/customize.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setup PYTHONPATH in* *Pytest*: [https://docs.pytest.org/en/7.1.x/explanation/pythonpath.xhtml](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pytest good* *practices*: [https://docs.pytest.org/en/7.1.x/explanation/goodpractices.xhtml](https://docs.pytest.org/en/7.1.x/explanation/goodpractices.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and running unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we setup our testing environment, we can focus on the process of writing
    and executing tests for FastAPI applications. Unit tests are essential for validating
    the behaviour of individual parts of your application in isolation, ensuring they
    perform as expected. In this recipe, you will learn to test the endpoints of your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use `pytest` to test the FastAPI client in unit tests. Since the recipe
    will utilize common testing *fixtures*, used in most **Python** standard code,
    make sure to be familiar with the test fixtures before diving into the recipe.
    If this is not the case, you can always refer to the dedicated documentation page
    at the link: [https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml](https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by creating a unit test for the same `GET /home` endpoint, but
    differently from the previous recipe. We will use the `TestClient` class provided
    by FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a fixture for that. Since it could be used by multiple tests let’s
    do it in a new `conftest.py` module under the `tests` folder. The `conftest.py`
    is a default file used by `pytest` to store common elements shared amongst test
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `conftest.py` let’s write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to leverage the `test_client` fixture to create a proper unit
    test for our endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write our test in the `test_main.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it. Compared to the previous test, this one is more compact and faster
    to write, thanks to the `TestClient` class provided by FastAPI package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run `pytest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You will see a message on the terminal showing that two tests have been collected
    and run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can check more on the test client for FastAPI in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI Test* *Client*: [https://fastapi.tiangolo.com/reference/testclient/](https://fastapi.tiangolo.com/reference/testclient/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing API Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests verify that different parts of your application work together
    as expected. They are crucial for ensuring that your system’s components interact
    correctly, especially when dealing with external services, databases, or other
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will test two endpoints that interact with an SQL database.
    One will add an item to the database, the other will read an item based on the
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To apply the recipe you need your testing environment already setup for `pytest`.
    If this is not the case check the recipe *Setting up* *testing environments* of
    the same chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the recipe will show you how to make integration tests with existing endpoints
    of the application. You can use it for your application or you can build the endpoints
    for our `protoapp` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the recipe to test your endpoint you can directly jump on the
    *How to it…* section and apply the rules to tour endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, If you haven’t installed the packages from the `requirements.txt`,
    install `sqlalchemy` package in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s setup the database connection through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `protoapp` folder, at the same level as the `main.py` module, let’s
    create a module `database.py` containing the setup of the database. Let’s start
    by creating the `Base` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the `Base` class to define the `Item` mapping class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then the database `Item` mapping class will be like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the database engine that will handle the session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The engine object will be used to handle the session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, let’s bind the engine to the Base mapping class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the engine can map the database table to our Python classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Last in the `database.py` module let’s create a `SessionLocal` class that will
    generate the session as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SessionLocal` is a class that will initialize the database session object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, before creating the endpoints, let’s create a database session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the app is relatively small, we can do it the same `main.py`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use the session to interact with the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have setup the database connection, in the `main.py` module, we
    can create the endpoints one to add an item to the database and one to read it.
    Let's do it as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the request body for the endpoints as::'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The endpoint used to add an item will then be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The endpoint will return the item ID affected when the item is stored in the
    database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have the endpoint to add the item, we can proceed by creating the
    endpoint to retrieve the item based on its ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the ID does not correspond to any item in the database the endpoint will
    return a 404 status code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have just created the endpoints that will allow us to create an integration
    test.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have the endpoints, in the `tests` folder we should adapt our `test_client`
    fixture to use a different session than the one used in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will break the process into two main actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapt the test client to accommodate the testing database session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the test to simulate the interaction of the endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do it by following these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, In the `conftest.py` file we created earlier in the recipe *Writing
    and running unit tests*, let’s define a new engine that will use an in-memory
    SQLite database and bind it to the mapping `Base` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a dedicated session maker for the testing session as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly to the function `get_db_session` in the `main.py` module, we can
    create a fixture to retrieve the test session in the conftest.py module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we should modify the `test_client` to use this session instead of the
    production one. We can do it by overwriting the dependency that returns the session
    with the one we just created. FastAPI allows you to do it easily by calling the
    test client’s method `dependency_overrides` as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each time the test client needs to call the session, the fixture will replace
    it with the test session that uses the in-memory database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, to verify the interaction of our application with the database, we create
    a test that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the item into the database through the `POST /``item` endpoint
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the item is correctly created into the test database by using the
    test session
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the item through the `GET /``item` endpoint
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can put the test into the `test_main.py` and here is how it would look
    like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve just created an integration test for our proto application, feel free
    to enrich your application and create more tests accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have setup an in-memory SQLite database for our tests. Since each session
    is bonded to a thread, the engine needs to be configured accordingly to not flush
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration strategy has been found on the following documentation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SQLite In-Memory Database* *Configuration*: [https://docs.sqlalchemy.org/en/14/dialects/sqlite.xhtml#using-a-memory-database-in-multiple-threads](https://docs.sqlalchemy.org/en/14/dialects/sqlite.xhtml#using-a-memory-database-in-multiple-threads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By systematically covering all endpoints and scenarios, you ensure that your
    API behaves correctly under various conditions, providing confidence in your application’s
    functionality. Thoroughly testing API endpoints is essential for building reliable
    and robust applications.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will explain to you how to run tests individually or by group and
    how to check the test coverage of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the recipe, make sure you already have some tests in place, or you already
    followed all the previous recipes of the chapter. Also, make sure you have your
    PYTHONPATH for tests defined in your `pytest.ini`. Have a look at the recipe *Setting
    up* *testing environments* on how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by looking at how to run tests by default grouping (individually
    or by module), and then we will cover a technique for customizing test grouping
    based on marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you already know, all unit tests can be run from the terminal with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a test can be run individually according to the test call syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want to run the test function `test_read_main_client`, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes test names become too complicated to remember or we have a specific
    need to run only a targeted set of tests. Here is where test marks come to the
    aid.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine we want to run only integration tests. In our app, the only integration
    test is represented by the function `tests_client_can_add_read_the_item_from_database`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply a mark by adding the specific decorator to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `pytest.ini` configuration add the `integration` marker in the
    dedicated sections to register the mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run the targeted tests by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the output message, you will see that only the marked test has been selected
    and run. You can use markers to group your application’s tests based on logical
    criteria, for example by functional meaning one group for **create, read, update
    and delete** (**CRUD**) operations, one group for security operations, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Check test coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make sure that your endpoints are covered by testing as well as the text
    lines of your code, it can become useful to have an idea of the test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage is a metric used in software testing to measure the extent to
    which the source code of a program is executed when a particular test suite runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it with `pytest`, if you didn’t install the packages with the `requirements.txt`,
    you need to install `pytest-cov` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The way it works is quite straightforward. You need to pass the source code
    root, in our case the `protoapp` directory, to the parameter `–cov` of `pytest`
    and tests root folder, in our case tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a table in the output listing the coverage percentage for each
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In addition, a file named `.coverage` has been created. This is a binary file
    containing data on the test coverage and that can be used with additional tools
    to generate reports out of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It will create a folder `htmlcov` with an `index.xhtml` page containing the
    coverage page and you can visualize it by opening it with a browser.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can check more on various options to invoke unit tests with Pytest and how
    to evaluate test coverage at the official documentation links
  prefs: []
  type: TYPE_NORMAL
- en: '*Invoke Unit test with* *Pytest*: [https://docs.pytest.org/en/7.1.x/how-to/usage.xhtml](https://docs.pytest.org/en/7.1.x/how-to/usage.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pytest* *Coverage*: [https://pytest-cov.readthedocs.io/en/latest/](https://pytest-cov.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling logging messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effectively managing logs in application development not only aids in identifying
    errors promptly but also provides valuable insights into user interactions, system
    performance, and potential security threats. It serves as a crucial tool for auditing,
    compliance, and optimizing resource utilization, ultimately enhancing the reliability
    and scalability of the software.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to efficiently implement a logging system into our
    FastAPI application to monitor the calls to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use some basic features of the Python logging ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the example is basic, you can refer to the official documentation
    to get familiar with related terms such as **logger**, **handler** , **formatter**,
    and **log level**. Follow this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/howto/logging-cookbook.xhtml](https://docs.python.org/3/howto/logging-cookbook.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: To implement logging into FastAPI, make sure you have a running application
    or use the `protoapp` we developed all along the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to create a logger that prints the client’s calls information to the
    terminal and logs them into a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create the logger into a dedicated `logging.py` module under the folder
    `protoapp`, through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the logger with a level value to `INFO`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we want to stream the message to the console and store it in a file, we
    will need to define two separate handlers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let’s define the handler to print log messages to the console. We will
    use a `StreamHandler` object from the `logging` built-in package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will stream the message to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a colorized formatter and add it to the handler we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The formatter will format log messages in the same of the default logger uvicorn
    logger used by FastAPI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then let’s add the handler to the logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just set up the logger to print message to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s repeat the previous *steps from 1 to 4* to create a handler that stores
    messages into a file and adds it to our `client_logger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have our logger setup. Each message will be streamed to the console and
    stored in a `app.log` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have built our `client_logger`, we need to use it in the code to get
    information about clients calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can reach this by adding the logger and a dedicated middleware in the `main.py`
    module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now spin up the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try to call any of the endpoints we defined, you will see on the terminal the
    logs we just defined for the request and response. Also, you will find only the
    messages from our `logger_client` in a newly created `app.log` file automatically
    created by the application.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining a proper logging strategy would require a separate cookbook and it
    is out of the scope of the book. However, when building a logger into an application
    it is important to follow some guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use standard Logging Levels Appropriately**. A classical leveling system
    is made up of 4 levels: **INFO**, **WARNING**, **ERROR**, **CRITICAL**. You may
    need to have more or even less than four depending on the application. Anyway,
    place each message at the appropriate level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consist Log Format**. Maintain a consistent log format across your application.
    This includes consistent datetime formats, including the severity level, and describing
    the event clearly. A consistent format helps in parsing logs and automating log
    analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include Contextual Information**. Include relevant contextual information
    in your logs (e.g., user ID, transaction ID) to help trace and debug issues across
    your application’s workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid Sensitive Information**. Never log sensitive information such as passwords,
    API keys, or **personal identifiable information** (**PII**). If necessary, mask
    or hash these details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make Efficient Logging**. Be mindful of the performance impact of logging.
    Logging excessively can slow down your application and lead to log noise, making
    it hard to find useful information. Balance the need for information against the
    performance impact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And of course, this is not a comprehensive list.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python distribution comes with a powerful built-in package for logging, feel
    to have a look at the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python* *logging*: [https://docs.python.org/3/library/logging.xhtml](https://docs.python.org/3/library/logging.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, discover more on logging best practices and guidelines at the
    **Sentry** blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Logging* *Guidelines*: [https://blog.sentry.io/logging-in-python-a-developers-guide/](https://blog.sentry.io/logging-in-python-a-developers-guide/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sentry** is a tool to monitor Python code.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering debugging application development is crucial for identifying and fixing
    issues efficiently. This recipe delves into the practical use of the debugger,
    leveraging tools and strategies to pinpoint problems in your FastAPI code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need to do to apply the recipe is to have a running application. We
    can keep on working with our `protoapp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python distribution already comes with a default debugger called `pdb`.
    If you use an **integrated development environment** (**IDE**), it usually comes
    with an editor distribution debugger. Whatever you are using to debug your code,
    you must be familiar with the concept of breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: A **breakpoint** is a point within the code that pauses the execution and shows
    you the state of the code variables and calls. It can be attached with a condition
    that, if satisfied, activate it or skips otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you are using the Python distribution debugger `pdb` or the one provided
    by your IDE, it can be useful to define a starting script to spin up the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create on the project root folder a file called `run_server.py` containing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The script imports the `uvicorn` package and our application `app` and runs
    the application into the `uvicorn` server. It is equivalent to the launching command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Having a script gives us more flexibility to run the server and include it into
    a broader python routine if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check that it is correctly setup run the script as you would run a normal
    python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With your favourite browser go to `localhost:8000/docs` and check that the documentation
    has been correctly generated.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with PDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PDB debugger comes by default with any Python distribution. From Python
    versions higher than 3.7, you can define a breakpoint by simply adding the function
    call `breakpoint()` at the line of the code you want to pause, and then run the
    code as you would it normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you then run the code, when it reaches the breakpoint line, the execution
    will automatically shift to debug mode, and you can run debugging commands from
    the terminal. You can find the list of the commands you can run by typing help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can run commands to list variables, show the stack trace to check to recent
    frame, or define new breakpoints with conditions and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can find the list of all the command available: [https://docs.python.org/3/library/pdb.xhtml#debugger-commands](https://docs.python.org/3/library/pdb.xhtml#debugger-commands).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also invoke `pdb` as a module. In this case `pdb` will automatically
    enter **post-mortem** debugging if the program exists abnormally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That means that `pdb` will restart the program automatically by preserving `pdb`
    module's execution state including breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be done when debugging tests by calling `pytest` as a module,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Another debugging strategy consists of leveraging the reload functionality
    of the `uvicorn` server. To do that, you need to modify the `run_server.py` file
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the server without the `pdb` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this way, you can always use the breakpoints at ease with the reloading server
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, `unvicorn`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VS Code Python extension comes with its distribution debugger called *debugpy*.
    Configurations for the running environment can be managed in the `.vscode/launch.json`
    file. An example of the configuration file to debug our server is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The configuration specifies the type of debugger to use (`debugpy`), the program
    to run (our launching script `run_server.py`), and it can be found in the GUI
    options.
  prefs: []
  type: TYPE_NORMAL
- en: The `request` field specifies the mode to run the debugger, it can be *launch*,
    intended to run the program, or *attach*, intended to be attached to an already
    running instance, particularly useful to debug programs running on remote instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging remote instance is out of the scope of the recipe, but you can find
    detailed instructions at on the official documentation: [https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection](https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging configuration can be setup to run unit tests as well by leveraging
    the *Test Explorer* extension. The extension will look for a configuration in
    the `launch.json` containing `"type": "python"` and `"purpose": ["debug-test"]`
    (or `"request": "test"`). An example of configuration to debug tests would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find an extensive explication on the extension page from the VS Code
    marketplace at: [https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.vscode-python-test-adapter](https://marketplace.visualstudio.com/items?itemName=LittleFoxTeam.vscode-python-test-adapter).'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with PyCharm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm manages code execution through run/debug configurations, which are sets
    of named startup properties detailing execution parameters and environments. These
    configurations allow running scripts with different settings, such as using various
    Python interpreters, environment variables, and input sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run/debug configurations are of two kinds:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporary: Automatically generated for each run or debug session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permanent: Manually created from a template or by converting a temporary one,
    and saved within your project indefinitely until deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm by default uses an existing permanent configuration or creates a temporary
    one for each session. Temporary configurations are capped at five, with the oldest
    deleted for new ones. This limit can be adjusted in the settings (**Settings**
    | **Advanced Settings** | **Run/Debug** | **Temporary configurations limit**).
    Icons distinguish between permanent (opaque) and temporary (semi-transparent)
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Each configuration can be stored in a single xml file that is automatically
    detected by the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of configuration for our FastAPI `protoapp` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find a detailed guide on how to setup it at the dedicated Pycharm documentation
    page at: [https://www.jetbrains.com/help/pycharm/run-debug-configuration.xhtml](https://www.jetbrains.com/help/pycharm/run-debug-configuration.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Feel free to dig into each of the debugging solutions and concepts we just
    explained at the links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python distribution* *debugger*: [https://docs.python.org/3/library/pdb.xhtml](https://docs.python.org/3/library/pdb.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Breakpoints*: [https://docs.python.org/3/library/functions.xhtml#breakpoint](https://docs.python.org/3/library/functions.xhtml#breakpoint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Uvicorn* *Settings*: [https://www.uvicorn.org/settings/](https://www.uvicorn.org/settings/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging with VS* *Code*: [https://code.visualstudio.com/docs/python/debugging](https://code.visualstudio.com/docs/python/debugging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugy* *Debugger*: [https://github.com/microsoft/debugpy/](https://github.com/microsoft/debugpy/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging with* *PyCharm*: [https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.xhtml](https://www.jetbrains.com/help/pycharm/debugging-your-first-python-application.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing for high traffic applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance testing is crucial for ensuring your application can handle real-world
    usage scenarios, especially under high load. By systematically implementing and
    running performance tests, analyzing results, and optimizing based on findings,
    you can significantly improve your application’s responsiveness, stability, and
    scalability.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe will show the basics of how to benchmark your application with **Locust**
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run performance testing you need a working application, we will use our `protoapp`,
    and a testing framework. We will use **Locust** framework for the purpose, which
    a testing framework based on Python syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a detailed explication on the official documentation at: [https://docs.locust.io/en/stable/](https://docs.locust.io/en/stable/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, make sure you installed it in your virtual environment by
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to setup our configuration file and run the locust instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the application running and the `locust` package installed, we will proceed
    by specifying our configuration to run the performance test.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `locustfile.py` in your project root. This file will define the behavior
    of users interacting with your application under test.
  prefs: []
  type: TYPE_NORMAL
- en: 'A minimal example of `locustfile.py` can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The configuration defines a client class with the service address and the endpoint
    we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your FastAPI server with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in another terminal window run locust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Open your browser and navigate to `http://localhost:8089` to access the web
    interface of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web interface is intuitively designed, making it straightforward to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set Concurrent Users**: Specify the maximum number of users accessing the
    service simultaneously during peak usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure Ramp-Up Rate**: Determine the rate of new users added per second
    to simulate increasing traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After configuring these parameters, click the `/home` endpoint defined in the
    `locustfile.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can simulate traffic using the command line. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This command runs Locust in a headless mode to simulate:'
  prefs: []
  type: TYPE_NORMAL
- en: 10 users accessing your application concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A spawn rate of 1 user per second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You push your test experience further by including it in a **Continuous Integration
    /Continuous Delivery** (**CI/CD**) pipeline before deploying, or even into a larger
    testing routine.
  prefs: []
  type: TYPE_NORMAL
- en: Dig into the documentation to test every aspect of the traffic for your application.
  prefs: []
  type: TYPE_NORMAL
- en: You have all the tools to debug and fully test your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to build a comprehensive RESTful application
    interacting with an SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find more on Locust on the official documentation pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Locust* *QuickStart*: [https://docs.locust.io/en/stable/quickstart.xhtml](https://docs.locust.io/en/stable/quickstart.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Writing a Locust* *file*: [https://docs.locust.io/en/stable/writing-a-locustfile.xhtml](https://docs.locust.io/en/stable/writing-a-locustfile.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Running Locust from the Command* *Line*: [https://docs.locust.io/en/stable/running-without-web-ui.xhtml](https://docs.locust.io/en/stable/running-without-web-ui.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
