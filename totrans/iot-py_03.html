<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Interacting with Digital Outputs with Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Interacting with Digital Outputs with Python</h1></div></div></div><p>In this chapter, we will work with digital inputs with Python and two libraries: <code class="literal">mraa</code> and <code class="literal">wiring-x86</code>. We shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Wire our first connections between an Intel Galileo Gen 2 and a breadboard with electronic components</li><li class="listitem" style="list-style-type: disc">Write a first version of a Python script that turns on and off electronic components connected to the board</li><li class="listitem" style="list-style-type: disc">Transfer Python code to the Yocto Linux running on the board</li><li class="listitem" style="list-style-type: disc">Execute Python scripts that interact with the board</li><li class="listitem" style="list-style-type: disc">Learn to take advantage of Python's object-oriented features to improve the code and make it easier to understand</li><li class="listitem" style="list-style-type: disc">Prepare the code to make it easy to build an API that will allow us to interact with the IoT device</li></ul></div><div class="section" title="Turning on and off an onboard component"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Turning on and off an onboard component</h1></div></div></div><p>First, we <a id="id99" class="indexterm"/>will take advantage of an onboard LED (Light Emitting Diode) to write our first Python lines that interact with the digital output capabilities included in the Intel Galileo Gen 2 board. The simple example will allow us to understand how the <code class="literal">mraa</code> library allows us to easily turn on and off one of the onboard components with Python code.</p><p>In the previous chapter, we recognized the different elements included in the Intel Galileo Gen 2 board. We know that there are three rectangular LEDs located at the right hand side of the USB 2.0 host connector. The first LED, labeled <span class="strong"><strong>L</strong></span> is connected to pin 13 of the digital I/O pins, and therefore, a high level sent to pin 13 will turn on this LED and a low level will turn it off.</p><p>We will write a few lines of Python code that will use the <code class="literal">mraa</code> library to make the onboard LED labeled <span class="strong"><strong>L</strong></span> to repeat the following loop until the Python program is interrupted:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Turn on</li><li class="listitem" style="list-style-type: disc">Stay turned on for 3 seconds</li><li class="listitem" style="list-style-type: disc">Turn off</li><li class="listitem" style="list-style-type: disc">Stay turned off for 2 seconds.</li></ul></div><p>The following<a id="id100" class="indexterm"/> lines show the Python code that performs the previously explained actions. The code file for the sample is <code class="literal">iot_python_chapter_03_01.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time


if __name__ == "__main__":
    print ("Mraa library version: {0}".format(mraa.getVersion()))
    print ("Mraa detected platform name: {0}".format(mraa.getPlatformName()))

    # Configure GPIO pin #13 to be an output pin
    onboard_led = mraa.Gpio(13)
    onboard_led.dir(mraa.DIR_OUT)

    while True:
        # Turn on the onboard LED
        onboard_led.write(1)
        print("I've turned on the onboard LED.")
        # Sleep 3 seconds
        time.sleep(3)
        # Turn off the onboard LED
        onboard_led.write(0)
        print("I've turned off the onboard LED.")
        time.sleep(2)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Detailed steps to download the code bundle are mentioned in the Preface of this book. Please have a look.</p><p>The code bundle for the book is also hosted on GitHub at <a class="ulink" href="https://github.com/PacktPublishing/Internet-of-Things-with-Python">https://github.com/PacktPublishing/Internet-of-Things-with-Python</a>. We also have other code bundles from our rich catalog of books and videos available at <a class="ulink" href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p></div></div><p>In the previous chapter, we learned that the Yocto Linux running on the board provided both <a id="id101" class="indexterm"/>
<span class="strong"><strong>SSH</strong></span> and <a id="id102" class="indexterm"/>
<span class="strong"><strong>SFTP</strong></span> (short for <span class="strong"><strong>SSH File Transfer Protocol</strong></span> or <span class="strong"><strong>Secure File Transfer Protocol</strong></span>) services by running a Bonjour browser. We can use any SFTP client to connect to the board and transfer the file that we created in any computer or mobile device. Of course, we can also use any Linux editor, such as <code class="literal">vi</code>, in the SSH terminal, or just enter the code in the Python interpreter. However, it is usually more convenient to use our favorite editor or IDE in our computer or mobile device and then transfer the file to the board with any SFTP client.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>Some Python IDEs have remote development capabilities and allow us to easily transfer the necessary files and launch their execution on the board. An example is the paid Professional Edition of JetBrains PyCharm. Unluckily, the Community Edition doesn't include this feature.</p></div></div><p>We don't <a id="id103" class="indexterm"/>want the process to be linked to a specific IDE, and therefore, we will transfer the file with an SFTP client. FileZilla Client is a free, open source and multiplatform FTP client that supports SFTP. You can download and install it here: <a class="ulink" href="http://filezilla-project.org">http://filezilla-project.org</a>.</p><p>Once you have installed and executed FileZilla Client, you must follow the next steps to add the SFTP server running on the board in with the application's Site Manager:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Site Manager</strong></span>.</li><li class="listitem">Click <span class="strong"><strong>New Site</strong></span> on the <span class="strong"><strong>Site Manager</strong></span> dialog box. Enter the desired name, such as <span class="strong"><strong>IntelGalileo2</strong></span> to easily identify the board's SFTP service.</li><li class="listitem">Enter the board's IP address in <span class="strong"><strong>Host</strong></span>. You don't need to enter any value in <span class="strong"><strong>Port</strong></span> because the SFTP server uses the default SFTP port, that is, the same port in which the SSH daemon listens: port 22.</li><li class="listitem">Select <span class="strong"><strong>SFTP - SSH File Transfer Protocol</strong></span> in the Protocol dropdown.</li><li class="listitem">Select <span class="strong"><strong>Normal</strong></span> in the <span class="strong"><strong>Logon Type</strong></span> dropdown.</li><li class="listitem">Enter <span class="strong"><strong>root</strong></span> in <span class="strong"><strong>User</strong></span>. The next screenshots shows the configuration values for a board that has <span class="strong"><strong>192.168.1.107</strong></span> as its assigned IP address.<div class="mediaobject"><img src="images/B05042_03_01.jpg" alt="Turning on and off an onboard component"/></div></li><li class="listitem">Click <span class="strong"><strong>Connect</strong></span>. FileZilla will display an Unknown host key dialog box, indicating that the server's host key is unknown. It is similar to the information provided when you established the first connection to the board with an SSH client. The details include the host and the fingerprint. Activate the <span class="strong"><strong>Always trust this host, add this key to the cache</strong></span> checkbox and click <span class="strong"><strong>OK</strong></span>.</li><li class="listitem">FileZilla <a id="id104" class="indexterm"/>will display the <code class="literal">/home/root</code> folder for the Yocto Linux running on the board at the right-hand side of the window, under <span class="strong"><strong>Remote Site</strong></span>. </li><li class="listitem">Navigate to the folder in which you saved the Python files you want to transfer in your local computer under <span class="strong"><strong>Local site</strong></span>.</li><li class="listitem">Select the file you want to transfer and press <span class="emphasis"><em>Enter</em></span> to transfer the file to the <code class="literal">/home/root</code> folder on the board. Another way is to right-click on the desired file and select <span class="strong"><strong>Upload</strong></span>. FileZilla will display the uploaded file in the <code class="literal">/home/root</code> folder under <span class="strong"><strong>Remote Site</strong></span>. This way, you will be able to access the Python file in the default location that Yocto Linux uses when you login with an SSH terminal, that is, in your home folder for your <code class="literal">root</code> user. The following picture shows many Python files uploaded to the <code class="literal">/home/root</code> folder with FileZilla and listed in the contents of the <code class="literal">/home/root</code> folder.<div class="mediaobject"><img src="images/B05042_03_02.jpg" alt="Turning on and off an onboard component"/></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>As you work with additional projects, you will want to create new folders under <code class="literal">/home/root</code> to provide a better organization for your Python code in the Yocto Linux filesystem.</p></div></div><p>The next<a id="id105" class="indexterm"/> time you have to upload a file to the board, you don't need to setup a new site in the <span class="strong"><strong>Site Manager</strong></span> dialog box in order to establish an SFTP connection. You just need to select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Site Manager</strong></span>, select the site name under <span class="strong"><strong>Select Entry</strong></span> and click <span class="strong"><strong>Connect</strong></span>.</p><p>If you run the following command in the SSH terminal after you login, Linux will print your current folder or directory:</p><div class="informalexample"><pre class="programlisting">pwd</pre></div><p>The result of the previous command will be the same folder in which we uploaded the Python code file.</p><div class="informalexample"><pre class="programlisting">/home/root</pre></div><p>Once we transfer the file to the board, we can run the previous code with the following command on the board's SSH terminal:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_03_01.py</pre></div><p>The previous code is extremely simple. We have used many print statements to make it easy for us to understand what is going on with messages on the console. The following lines show the generated output after we run the code for a few seconds:</p><div class="informalexample"><pre class="programlisting">Mraa library version: v0.9.0
Mraa detected platform name: Intel Galileo Gen 2
Setting GPIO Pin #13 to dir DIR_OUT
I've turned on the onboard LED.
I've turned off the onboard LED.
I've turned on the onboard LED.
I've turned off the onboard LED.</pre></div><p>The first <a id="id106" class="indexterm"/>lines print the <code class="literal">mraa</code> library version and the detected platform name. This way, we have information about the <code class="literal">mraa</code> library version that Python is using and we make sure that the <code class="literal">mraa</code> library has been able to initialize itself and detect the right platform: Intel Galileo Gen 2. In case we have a specific issue, we can use this information to check about specific problems related to the <code class="literal">mraa</code> library and the detected platform.</p><p>The next line creates an instance of the <code class="literal">mraa.Gpio</code> class. <span class="strong"><strong>GPIO</strong></span> stands for <span class="strong"><strong>General Purpose Input/Output</strong></span> and <a id="id107" class="indexterm"/>an instance of the <code class="literal">mraa.Gpio</code> class represents a general purpose Input/Output pin on the board. In this case, we pass <code class="literal">13</code> as an argument for the <code class="literal">pin</code> parameter, and therefore, we are creating an instance of the <code class="literal">mraa.Gpio</code> class that represents the pin number 13 of the GPIO pins in the board. We named the instance <code class="literal">onboard_led</code> to make it easy to understand that the instance allows us to control the status of the onboard LED.</p><div class="informalexample"><pre class="programlisting">onboard_led = mraa.Gpio(13)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>We just need to specify the value for the pin parameter to initialize an instance of the <code class="literal">mraa.Gpio</code> class. There are two additional optional parameters (<code class="literal">owner</code> and <code class="literal">raw</code>), but we should leave them with the default values. By default, whenever we create an instance of the <code class="literal">mraa.Gpio</code> class, we own the pin and the <code class="literal">mraa</code> library will close it on destruct.</p></div></div><p>As we might guess from its name, an instance of the <code class="literal">mraa.Gpio</code> class allows us to work with pins as either Input or Output. Thus, it is necessary to specify the desired direction for our <code class="literal">mraa.Gpio</code> instance. In this case, we want to use pin 13 as an output pin. The following line calls the <code class="literal">dir</code> method to configure the pin to be an output pin, that is, to set is direction to the <code class="literal">mraa.DIR_OUT</code> value.</p><div class="informalexample"><pre class="programlisting">onboard_led.dir(mraa.DIR_OUT)</pre></div><p>Then, the code runs a loop forever, that is, until you interrupt the execution by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> or the button to stop the process in case you are using a Python IDE with remote development features to run the code in your board.</p><p>The first line within the <code class="literal">while</code> loop calls the <code class="literal">write</code> method for the <code class="literal">mraa.Gpio</code> instance, <code class="literal">onboard_led</code>, with <code class="literal">1</code> as an argument for the <code class="literal">value</code> required parameter. This way, we send a high value (<code class="literal">1</code>) to the pin 13 configured for digital output. Because the pin 13 has the onboard LED connected to it, the result of a high value in pin 13 is that the onboard LED turns on.</p><div class="informalexample"><pre class="programlisting">onboard_led.write(1)</pre></div><p>After we<a id="id108" class="indexterm"/> turn on the LED, a line of code uses the <code class="literal">print</code> statement to print a message to the console output, so that we know the LED should be turned on. A call to <code class="literal">time.sleep</code> with <code class="literal">3</code> as the value for the <code class="literal">seconds</code> argument delays the execution for three seconds. Because we didn't change the status of pin 13, the LED will stay turned on during this delay.</p><div class="informalexample"><pre class="programlisting">time.sleep(3)</pre></div><p>The next line calls the <code class="literal">write</code> method for the <code class="literal">mraa.Gpio</code> instance, <code class="literal">onboard_led</code>, but this time with <code class="literal">0</code> as an argument for the <code class="literal">value</code> required parameter. This way, we send a low value (<code class="literal">0</code>) to the pin 13 configured for digital output. Because the pin 13 has the onboard LED connected to it, the result of a low value in pin 13 is that the onboard LED turns off.</p><div class="informalexample"><pre class="programlisting">onboard_led.write(0)</pre></div><p>After we turn off the LED, a line of code uses the <code class="literal">print</code> statement to print a message to the console output, so that we know the LED should be turned off. A call to <code class="literal">time.sleep</code> with <code class="literal">2</code> as the value for the seconds argument delays the execution for 2 seconds. Because we didn't change the status of pin 13, the LED will stay turned off during this delay. Then, the loop starts over again.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>As we can use any <code class="literal">ssh</code> client to run the Python code, we can see the results of the <code class="literal">print</code> statements in the console output and they are extremely useful for us to understand what should be happening with the digital outputs. We will take advantage of more advanced logging features included in Python for more complex scenarios later.</p></div></div><p>As we could learn from the previous example, the <code class="literal">mraa</code> library encapsulates all the necessary methods to work with the GPIO pins in the <code class="literal">mraa.Gpio</code> class. The previous code didn't take advantage of Python's object-oriented features, it just interacted with one of the classes included in the <code class="literal">mraa</code> library. We will take advatange of many Python features in the <a id="id109" class="indexterm"/>forthcoming examples. In addition, once we start working with more complex examples, we will make the board interact through the network.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Prototyping with breadboards"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Prototyping with breadboards</h1></div></div></div><p>In the <a id="id110" class="indexterm"/>previous example, we interacted with the onboard LED, and therefore, we didn't wire any additional electronic component to the board. Now, it is time to move to more complex samples in which we will have to start working with additional components and tools.</p><p>We don't want to create a new printed circuit board (PCB) and solder electronic components to the board each time we want to wire some electronic components to the board. We will be prototyping many electronics projects throught the book and we will also continue prototyping after we learn each lesson towards our IoT adventure. Thus, we will use a solderless breadboard as our construction base for our electronic prototypes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>Solderless breadboards are also known as breadboards, solderless plug-in breadboards or prototype boards. We will call them with their shortests name: breadboards.</p></div></div><p>We will use an 830 tie points (holes for connections) with 2 power lanes breadboard for all our prototypes that require electronic components wired to the board. The following picture shows this kind of breadboard that consists of a chunk of plastic of approximately 6.5" x 2.1" with a bunch number of holes.</p><div class="mediaobject"><img src="images/B05042_03_03.jpg" alt="Prototyping with breadboards"/></div><p>The next picture shows the internal connections for an 830 tie points with 2 power lanes breadboard. There are metal strips inside the breadboard that connect the holes as shown in this picture.</p><div class="mediaobject"><img src="images/B05042_03_04.jpg" alt="Prototyping with breadboards"/></div><p>The <a id="id111" class="indexterm"/>breadboard provides two power lanes, bus strips or horizontal buses at the top and at the bottom of the board. These power lanes connect all the holes within the row. Each column has five row holes connected.</p><p>However, we must be careful because there are similar breadboards that break the power lanes or horizontal buses in the middle, and therefore, the power lanes don't connect all the holes within the row. The following picture shows the connections for these kinds of breadboards.</p><div class="mediaobject"><img src="images/B05042_03_05.jpg" alt="Prototyping with breadboards"/></div><p>In case you decide to work with this kind of breadboard, you have to make the following connections to the buses. This way, you will mimic the wires shown for the first breadboard.</p><div class="mediaobject"><img src="images/B05042_03_06.jpg" alt="Prototyping with breadboards"/></div><p>We can stick <a id="id112" class="indexterm"/>wire ends without insulation into the breadboard holes in order to wire elements. It is convenient to prepare jumper wires with different lengths and using cables with diverse colors. The following picture shows many cables of different lengths without their insulation that will work as jumper wires.</p><div class="mediaobject"><img src="images/B05042_03_07.jpg" alt="Prototyping with breadboards"/></div><p>In case we don't want to spend time building our own jumper wires, we can buy prebuilt male to male<a id="id113" class="indexterm"/> solderless flexible breadboard jumper wires with tiny plugs attached to the wire ends.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>You can use any of the previously explained options to make the necessary connections for each of the examples in which we will be working throught this book. In case you decide to use male to male breadboard jumper wires, make sure they are high quality ones.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Working with schematics to wire digital outputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Working with schematics to wire digital outputs</h1></div></div></div><p>Now, it is<a id="id114" class="indexterm"/> time to take advantage <a id="id115" class="indexterm"/>of the prototyping capabilities of the breadboard and start working on a more complex example. We will turn on and off 9 LEDs by using 9 digital outputs of the Intel Galileo Gen 2 board. Each digital output is going to control whether an LED is turned on or turned off.</p><p>After we finish the necessary wirings, we will write Python code that counts from 1 to 9 by controlling the digital output to turn on the necessary number of LEDs. In this case, our first approach won't be the best one. However, after we learn many things, we will create new versions and we will improve both the initial prototype and the Python code.</p><p>We need the following parts to work with this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Three red ultrabright 5mm LEDs</li><li class="listitem" style="list-style-type: disc">Three white ultrabright 5mm LEDs</li><li class="listitem" style="list-style-type: disc">Three green ultrabright 5mm LEDs</li><li class="listitem" style="list-style-type: disc">Nine 270Ω resistors with 5% tolerance (red violet brown gold)</li></ul></div><p>The following diagram shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_03_02.fzz</code> and the following picture is the breadboard view.</p><div class="mediaobject"><img src="images/B05042_03_08.jpg" alt="Working with schematics to wire digital outputs"/></div><p>In this case, we decided to match the GPIO pin number with the LED number. This way, whenever we want to turn on LED 1, we write a high (1) value to GPIO pin number 1, whenever we want to turn on LED 2, we write a high (1) value to GPIO pin number 2, and so on. Later, we will realize it is not the best decision because the wiring becomes a bit more complex<a id="id116" class="indexterm"/> than expected due to the positions of the pins in the board. However, we will analyze this situation later and we will create a new version of this example with improvements based on everything we learned from the first version.</p><p>The following <a id="id117" class="indexterm"/>picture shows the schematic with the electronic components represented as symbols. The schematic makes it easier to understand the connections between the Intel Galileo Gen 2 board GPIO pins and the electronic components. Clearly, the schematic benefits from the fact that the GPIO pin number matches the LED number and it will be easy to write our first version of the code.</p><div class="mediaobject"><img src="images/B05042_03_09.jpg" alt="Working with schematics to wire digital outputs"/></div><p>As seen in the previous schematic, each GPIO pin labeled from <span class="strong"><strong>D1</strong></span> to <span class="strong"><strong>D9</strong></span> in the board's symbol is connected to a <span class="strong"><strong>270Ω</strong></span> resistor, wired to an LED's anode, and each LED's cathode is connected to ground. This way, whenever we write a high (1) value to any of the GPIO pins, the board will put 5V on the pin and the LED will turn on. Whenever we write a low (0) value to any of the GPIO pins, the board will put 0V on the pin and the LED will turn off.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>As we left the jumper labeled <span class="strong"><strong>IOREF</strong></span> in its default 5V position, the board will be operating with 5V for its GPIO pins. Thus, a GPIO pin will have 5V when we write a high value to it. If we change the position of this jumper to 3.3V, a GPIO pin will have 3.3V when we write a high value to it. Unless specified otherwise, we are using the default position for this jumper in all the examples.</p></div></div><p>Now, it is time<a id="id118" class="indexterm"/> to insert the components in the breadboard and make all the necessary wirings.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>Always shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins. Do the same before plugging or unplugging any shield.</p></div></div><p>In order to <a id="id119" class="indexterm"/>shutdown the Yocto Linux, enter the following command in your <code class="literal">ssh</code> terminal. Make sure you have exited the Python interpreter when you enter the command.</p><div class="informalexample"><pre class="programlisting">shutdown</pre></div><p>As a result of the previous command, you will see the time at which the shutdown process is going to begin. The message will be similar to the following output but with different dates and times.</p><div class="informalexample"><pre class="programlisting">Shutdown scheduled for Mon 2016-01-25 23:50:04 UTC, use 'shutdown -c' to cancel.
root@galileo:~# 
Broadcast message from root@galileo (Mon 2016-01-25 23:49:04 UTC):

The system is going down for power-off at Mon 2016-01-25 23:50:04 UTC!</pre></div><p>Then, wait around 1 minute until the operating system closes down and all the onboard LEDs turn off. At this time, you can safely remove the power supply from the board. </p><p>We have to pay special attention when inserting the LEDs in the breadboard. As we can notice in the schematic, the resistor is wired to an LED's anode, and each LED's cathode is connected to ground.</p><p>We can easily identify the LED's anode, that is, its positive lead, because its lead is slightly longer than the other lead. The LED's cathode, that is, its negative lead is shorter than the other lead. In the following picture, the LED's cathode, that is, its negative lead is the lead located at <a id="id120" class="indexterm"/>the left-hand side (the shorter lead). The LED's anode, that is, its positive lead, is the lead located at the right-hand side (the slightly longer lead). You can also notice <a id="id121" class="indexterm"/>that the metal piece inside the LED connected to the LED's anode, that is, its positive lead, is smaller than the metail piece inside the LED connected to the LED's cathode, that is, its negative lead.</p><div class="mediaobject"><img src="images/B05042_03_10.jpg" alt="Working with schematics to wire digital outputs"/></div><p>The LED in the picture is located in the same position than the LEDs are connected in the previously shown breadboard picture. Thus, we have to connect the shorter lead at the left and the larger lead at the right in the breadboard. The next picture shows the LED representation in the breadboard picture with its cathode and anode.</p><div class="mediaobject"><img src="images/B05042_03_11.jpg" alt="Working with schematics to wire digital outputs"/></div><p>The<a id="id122" class="indexterm"/> following picture shows the schematic electronic symbol for the LED with the same positions for the cathode and anode than in the previous picture that showed the breadboard picture.</p><div class="mediaobject"><img src="images/B05042_03_12.jpg" alt="Working with schematics to wire digital outputs"/></div><p>The following<a id="id123" class="indexterm"/> picture shows all the LEDs connected to the breadboard. You can check the cathode and the anode based on the metal parts that you can see through the LED's plastic.</p><div class="mediaobject"><img src="images/B05042_03_13.jpg" alt="Working with schematics to wire digital outputs"/></div><p>The following picture shows all the LEDs connected to the breadboard where you can check that the LEDs are connected as we have seen in the breadboard view for the Fritzing diagram.</p><div class="mediaobject"><img src="images/B05042_03_14.jpg" alt="Working with schematics to wire digital outputs"/></div><p>Resistors<a id="id124" class="indexterm"/> are the same forward and backwards, and therefore, it doesn't matter which way you use them in the breadboard. The following picture shows a 270Ω axial-lead resistor with 5% tolerance. Notice that the <a id="id125" class="indexterm"/>color bands from left to right are red, violet, brown and gold. The color bands allow us to know the resistance in ohms and their tolerance value without having to measure the resistor.</p><div class="mediaobject"><img src="images/B05042_03_15.jpg" alt="Working with schematics to wire digital outputs"/></div><p>The following picture shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard.</p><div class="mediaobject"><img src="images/B05042_03_16.jpg" alt="Working with schematics to wire digital outputs"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Counting from 1 to 9 with LEDs, Python code and the mraa library"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Counting from 1 to 9 with LEDs, Python code and the mraa library</h1></div></div></div><p>Once we finish the wirings and we make sure that all the components and the wires are in the right place, we can write our first version of the Python code to count from 1 to 9 with the LEDs, transfer it to the board via SFTP and execute it.</p><p>We will write a few<a id="id126" class="indexterm"/> lines of Python code that will use the <code class="literal">mraa</code> library to run the following steps to count from 1 to 9, with a 3 seconds pause between each step:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Turn on LED1</li><li class="listitem" style="list-style-type: disc">Turn on LED1 and LED2</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2 and LED3</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2, LED3 and LED4</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2, LED3, LED4 and LED5</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2, LED3, LED4, LED5 and LED6</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2, LED3, LED4, LED5, LED6 and LED7</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2, LED3, LED4, LED5, LED6, LED7 and LED8</li><li class="listitem" style="list-style-type: disc">Turn on LED1, LED2, LED3, LED4, LED5, LED6, LED7, LED8 and LED9</li></ul></div><p>The <a id="id127" class="indexterm"/>following lines show the Python code that performs the previously explained actions. The code file for the sample is <code class="literal">iot_python_chapter_03_02.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time


if __name__ == "__main__":
    print ("Mraa library version: {0}".format(mraa.getVersion()))
    print ("Mraa detected platform name: {0}".format(mraa.getPlatformName()))

    # Configure GPIO pins #1 to 9 to be output pins
    output = []
    for i in range(1, 10):
        gpio = mraa.Gpio(i)
        gpio.dir(mraa.DIR_OUT)
        output.append(gpio)

    # Count from 1 to 9
    for i in range(1, 10):
        print("==== Turning on {0} LEDs ====".format(i))
        for j in range(0, i):
            output[j].write(1)
            print("I've turned on the LED connected to GPIO Pin #{0}.".format(j + 1))
        time.sleep(3)</pre></div><p>Once we transfer the file to the board, we can run the previous code with the following command on the board's SSH terminal:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_03_02.py</pre></div><p>We have used many <code class="literal">print</code> statements to make it easy for us to understand what is going on with messages<a id="id128" class="indexterm"/> on the console. The following lines show the generated output after we run the code:</p><div class="informalexample"><pre class="programlisting">Mraa library version: v0.9.0
Mraa detected platform name: Intel Galileo Gen 2
Setting GPIO Pin #1 to dir DIR_OUT
Setting GPIO Pin #2 to dir DIR_OUT
Setting GPIO Pin #3 to dir DIR_OUT
Setting GPIO Pin #4 to dir DIR_OUT
Setting GPIO Pin #5 to dir DIR_OUT
Setting GPIO Pin #6 to dir DIR_OUT
Setting GPIO Pin #7 to dir DIR_OUT
Setting GPIO Pin #8 to dir DIR_OUT
Setting GPIO Pin #9 to dir DIR_OUT
==== Turning on 1 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
==== Turning on 2 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
==== Turning on 3 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
==== Turning on 4 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
I've turned on the LED connected to GPIO Pin #4.
==== Turning on 5 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
I've turned on the LED connected to GPIO Pin #4.
I've turned on the LED connected to GPIO Pin #5.
==== Turning on 6 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
I've turned on the LED connected to GPIO Pin #4.
I've turned on the LED connected to GPIO Pin #5.
I've turned on the LED connected to GPIO Pin #6.
==== Turning on 7 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
I've turned on the LED connected to GPIO Pin #4.
I've turned on the LED connected to GPIO Pin #5.
I've turned on the LED connected to GPIO Pin #6.
I've turned on the LED connected to GPIO Pin #7.
==== Turning on 8 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
I've turned on the LED connected to GPIO Pin #4.
I've turned on the LED connected to GPIO Pin #5.
I've turned on the LED connected to GPIO Pin #6.
I've turned on the LED connected to GPIO Pin #7.
I've turned on the LED connected to GPIO Pin #8.
==== Turning on 9 LEDs ====
I've turned on the LED connected to GPIO Pin #1.
I've turned on the LED connected to GPIO Pin #2.
I've turned on the LED connected to GPIO Pin #3.
I've turned on the LED connected to GPIO Pin #4.
I've turned on the LED connected to GPIO Pin #5.
I've turned on the LED connected to GPIO Pin #6.
I've turned on the LED connected to GPIO Pin #7.
I've turned on the LED connected to GPIO Pin #8.
I've turned on the LED connected to GPIO Pin #9.</pre></div><p>The following <a id="id129" class="indexterm"/>nine pictures show the sequence of LEDs that are turned on in the breadboard by executing the Python code.</p><div class="mediaobject"><img src="images/B05042_03_17.jpg" alt="Counting from 1 to 9 with LEDs, Python code and the mraa library"/></div><p>First, the code declares an empty list named <code class="literal">output</code>. Then, a <code class="literal">for</code> loop creates nine instances of the <code class="literal">mraa.Gpio</code> class and each of them represent a general purpose Input/Output pin on the board. We pass <code class="literal">i</code> as an argument for the <code class="literal">pin</code> parameter, and therefore, each instance represents the pin number equal to <code class="literal">i</code> of the GPIO pins in the board. After we create<a id="id130" class="indexterm"/> the instance, we call the <code class="literal">dir</code> method to configure the pin to be an output pin, that is, to set is direction to the <code class="literal">mraa.DIR_OUT</code> value. Then we call the <code class="literal">append</code> method for the <code class="literal">output</code> list to add the <code class="literal">mraa.Gpio</code> instance (<code class="literal">gpio</code>) to the output list. It is important to understand that <code class="literal">range(1, 10)</code> generates the following list: <code class="literal">[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>. Thus, our <code class="literal">for</code> loop will start with <code class="literal">i</code> equal to 1 and its last iteration will be with <code class="literal">i</code> equal to 9.</p><div class="informalexample"><pre class="programlisting">output = []
for i in range(1, 10):
    gpio = mraa.Gpio(i)
    gpio.dir(mraa.DIR_OUT)
    output.append(gpio)</pre></div><p>Another <code class="literal">for</code> loop determines the number of LEDs to be turned on. We use <code class="literal">range(1, 10)</code> to generate the same list than in the previous loop. The first line within the <code class="literal">for</code> loop calls a <code class="literal">print</code> method to display the number of LEDs that we are going to turn on in the iteration. A loop within the loop uses <code class="literal">range(0, i)</code> to generate the list of indexes of the elements in the <code class="literal">output</code> list that we have to turn on for the iteration of the main <code class="literal">for</code> loop (<code class="literal">i</code>).</p><p>The inner loop <a id="id131" class="indexterm"/>uses <code class="literal">j</code> as its variable and the code within this inner loop just calls the <code class="literal">write</code> method for each <code class="literal">mraa.Gpio</code> instance, <code class="literal">output[j]</code>, with <code class="literal">1</code> as an argument for the <code class="literal">value</code> required parameter. This way, we send a high value (<code class="literal">1</code>) to the pin that is equal to <code class="literal">j + 1</code>, configured for digital output. If <code class="literal">j</code> is equal to 0, the first element of the output list is the <code class="literal">mraa.Gpio</code> instance that is configured for pin 1 (<code class="literal">j + 1</code>). Because each pin from 1 to 9 has an LED connected to it, the result of a high value in one or more pins are LEDs turned on. Then, the code prints a message indicating the LED number that has been turned on.</p><p>Once the inner loop finishes, a call to <code class="literal">time.sleep</code> with <code class="literal">3</code> as the value for the <code class="literal">seconds</code> argument delays the execution for three seconds. This way, the LED or LEDs stay turned on during this delay before the outer loop performs another iteration.</p><div class="informalexample"><pre class="programlisting">for i in range(1, 10):
    print("==== Turning on {0} LEDs ====".format(i))
    for j in range(0, i):
        output[j].write(1)
        print("I've turned on the LED connected to GPIO Pin #{0}.".format(j + 1))
    time.sleep(3)</pre></div><p>The following picture shows the console output printed on an SSH terminal in a laptop, the 9 LEDs turned on in the protoboard connected to the board that is running Python code.</p><div class="mediaobject"><img src="images/B05042_03_26.jpg" alt="Counting from 1 to 9 with LEDs, Python code and the mraa library"/></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Taking advantage of object-oriented code to control digital outputs"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Taking advantage of object-oriented code to control digital outputs</h1></div></div></div><p>The previous<a id="id132" class="indexterm"/> example just turns on the LEDs. Thus, in case we want to count in a reverse order, that is, from 9 to 1, the results are <a id="id133" class="indexterm"/>not going to be as expected. After the code turns on 9 LEDs, the code will turn on 8 LEDs but there are still going to be 9 LEDs turned. The problem is that we never turn off the LEDs that we don't need to be turned on, and therefore the 9 LEDs will stay on until the edited loop finishes its execution.</p><p>We are always<a id="id134" class="indexterm"/> talking about LEDs turning on and turning off LEDs. However, we have been using just instanced of the <code class="literal">mraa.Gpio</code> class and called the <code class="literal">write</code> method. Python is an object-oriented programming language, and therefore, we can definitely take advantage of its<a id="id135" class="indexterm"/> object-oriented features to write reusable, easier to understand and simpler to maintain code. For example, in this case, it makes a lot of sense to create an <code class="literal">Led</code> class to represent an LED connected to our board.</p><p>The following lines show the code for the new <code class="literal">Led</code> class. The code file for the sample is <code class="literal">iot_python_chapter_03_03.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time


class Led:
    def __init__(self, pin):
        self.gpio = mraa.Gpio(pin)
        self.gpio.dir(mraa.DIR_OUT)

    def turn_on(self):
        self.gpio.write(1)
        print("I've turned on the LED connected to GPIO Pin #{0}.".format(self.gpio.getPin()))

    def turn_off(self):
        self.gpio.write(0)
        print("I've turned off the LED connected to GPIO Pin #{0}.".format(self.gpio.getPin()))</pre></div><p>We have to specify the pin number to which the LED is connected when we create an instance of the <code class="literal">Led</code> class in the <code class="literal">pin</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">mraa.Gpio</code> instance with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument, saves its reference in the <code class="literal">gpio</code> attribute and calls its <code class="literal">dir</code> method to configure the pin to be an output pin.</p><p>The class defines the following two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">turn_on</code>: Calls the <code class="literal">write</code> method for the related <code class="literal">mraa.Gpio</code> instance to send a high value (1) to the pin and turn on the LED connected to this pin. Then, it prints a message with details about the performed action.</li><li class="listitem" style="list-style-type: disc"><code class="literal">turn_off</code>: Calls the <code class="literal">write</code> method for the related <code class="literal">mraa.Gpio</code> instance to send a low value (0) to the pin and turn off the LED connected to this pin. Then, it prints a message with details about the performed action.</li></ul></div><p>Now, we<a id="id136" class="indexterm"/> can write code that uses the new <code class="literal">Led</code> class to create the necessary instances based on the number of LEDs we want to control and the pins to which they are connected. The following lines show an improved version of the code that uses the new <code class="literal">Led</code> class to count from 1 to 9 with the LEDs. The code file for the sample is <code class="literal">iot_python_chapter_03_03.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    print ("Mraa library version: {0}".format(mraa.getVersion()))
    print ("Mraa detected platform name: {0}".format(mraa.getPlatformName()))

    # Configure GPIO pins #1 to 9 to be output pins
    leds = []
    for i in range(1, 10):
        led = Led(i)
        leds.append(led)

    # Count from 1 to 9
    for i in range(1, 10):
        print("==== Turning on {0} LEDs ====".format(i))
        for j in range(0, i):
            leds[j].turn_on()
        for k in range(i, 9):
            leds[k].turn_off()
        time.sleep(3)</pre></div><p>First, the<a id="id137" class="indexterm"/> code declares an empty list named <code class="literal">leds</code>. Then, a <code class="literal">for</code> loop creates nine instances of the <code class="literal">Led</code> class and each of them represent an LED connected to a GPIO pin on the board. We pass <code class="literal">i</code> as an argument for the <code class="literal">pin</code> parameter. Then, we call the <code class="literal">append</code> method for the <code class="literal">leds</code> list to add the <code class="literal">Led</code> instance (<code class="literal">led</code>) to the <code class="literal">leds</code> list. Our <code class="literal">for</code> loop will start with <code class="literal">i</code> equal to 1 and its last iteration will be with <code class="literal">i</code> equal to 9.</p><p>Another <code class="literal">for</code> loop determines the number of LEDs to be turned on. We use <code class="literal">range(1, 10)</code> to generate the same list than in the previous loop. The first line within the <code class="literal">for</code> loop calls a <code class="literal">print</code> method to display the number of LEDs that we are going to be turned on in the iteration.</p><p>An inner loop within the loop uses <code class="literal">range(0, i)</code> to generate the list of indexes of the elements in the <code class="literal">leds</code> list that we have to turn on for the iteration of the main <code class="literal">for</code> loop (<code class="literal">i</code>). The inner loop uses <code class="literal">j</code> as its variable and the code within this inner loop just calls the <code class="literal">turn_on</code> method for each <code class="literal">Led</code> instance.</p><p>Another inner <a id="id138" class="indexterm"/>loop wihin the loop uses <code class="literal">range(i, 9)</code> to generate the list of indexes of the elements in the <code class="literal">leds</code> list that we have to turn off for the iteration of the main <code class="literal">for</code> loop (<code class="literal">i</code>). The <a id="id139" class="indexterm"/>inner loop uses <code class="literal">k</code> as its variable and the code within this inner loop just calls the <code class="literal">turn_off</code> method for each <code class="literal">Led</code> instance.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>The code is easier to understand than the previous version and the <code class="literal">Led</code> class handles everything related to an LED. We can easily understand that the line that calls the <code class="literal">turn_on</code> method for <code class="literal">leds[j]</code> is turning on an LED. We definitely know that an LED is being turned off in the line that calls the <code class="literal">turn_off</code> method for <code class="literal">leds[k]</code>.</p></div></div><p>As the new code turns off the LEDs that don't have be turned on, we can easily create a new version that counts from 9 to 1 by changing one line. The following lines show the new version of the code that works with the <code class="literal">Led</code> class to count from 9 to 1 with the LEDs. The only line that had to be edited is the highlighted one. The code file for the sample is <code class="literal">iot_python_chapter_03_04.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    print ("Mraa library version: {0}".format(mraa.getVersion()))
    print ("Mraa detected platform name: {0}".format(mraa.getPlatformName()))

    # Configure GPIO pins #1 to 9 to be output pins
    leds = []
    for i in range(1, 10):
        led = Led(i)
        leds.append(led)

    # Count from 9 to 1
<span class="strong"><strong>    for i in range(9, 0, -1):</strong></span>
        print("==== Turning on {0} LEDs ====".format(i))
        for j in range(0, i):
            leds[j].turn_on()
        for k in range(i, 9):
            leds[k].turn_off()
        time.sleep(3)</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Improving our object-oriented code to provide new features"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Improving our object-oriented code to provide new features</h1></div></div></div><p>Now that <a id="id140" class="indexterm"/>we have our counter working with the LEDs connected to the board, we want to add new features. We want to be able to easily transform a number between 1 and 9 into its representation in LEDs connected to the board.</p><p>The following lines show the code for the new <code class="literal">NumberInLeds</code> class. The code file for the sample is <code class="literal">iot_python_chapter_03_05.py</code>.</p><div class="informalexample"><pre class="programlisting">class NumberInLeds:
    def __init__(self):
        self.leds = []
        for i in range(1, 10):
            led = Led(i)
            self.leds.append(led)

    def print_number(self, number):
        print("==== Turning on {0} LEDs ====".format(number))
        for j in range(0, number):
            self.leds[j].turn_on()
        for k in range(number, 9):
            self.leds[k].turn_off()</pre></div><p>The constructor, that is, the <code class="literal">__init__</code> method, declares an empty list attribute named <code class="literal">leds</code> (<code class="literal">self.leds</code>). Then, a <code class="literal">for</code> loop creates nine instances of the <code class="literal">Led</code> class and each of them represent an LED connected to a GPIO pin on the board. We pass <code class="literal">i</code> as an argument for the <code class="literal">pin</code> parameter. Then, we call the <code class="literal">append</code> method for the <code class="literal">self.leds</code> list to add the <code class="literal">Led</code> instance (<code class="literal">led</code>) to the <code class="literal">self.leds</code> list. Our <code class="literal">for</code> loop will start with <code class="literal">i</code> equal to 1 and its last iteration will be with <code class="literal">i</code> equal to 9.</p><p>The class defines a <code class="literal">print_number</code> method that requires the number that we want to represent with LEDs turned on in the <code class="literal">number</code> argument. The method uses a <code class="literal">for</code> loop with <code class="literal">j</code> as its variable to turn on the necessary LEDs by accesing the appropriate members of the <code class="literal">self.leds</code> list and calling the <code class="literal">turn_on</code> method. Then, the method uses another <code class="literal">for</code> loop with <code class="literal">k</code> as its variable to turn off the remaining LEDs by accesing the appropriate members of the <code class="literal">self.leds</code> list and calling the <code class="literal">turn_off</code> method. This way, the method makes sure that only the LEDs that have to be turned on are really turned on and the rest of them are turned off.</p><p>Now, we can write code that uses the new <code class="literal">NumberInLeds</code> class to count from 0 to 9 with the LEDs. In this <a id="id141" class="indexterm"/>case, we start with 0 because the new class is able to turn off all the LEDs that shouldn't be turned on to represent a specific number. The code file for the sample is <code class="literal">iot_python_chapter_03_05.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    print ("Mraa library version: {0}".format(mraa.getVersion()))
    print ("Mraa detected platform name: {0}".format(mraa.getPlatformName()))

    number_in_leds = NumberInLeds()
    # Count from 0 to 9
    for i in range(0, 10):
        number_in_leds.print_number(i)
        time.sleep(3)</pre></div><p>The code is very easy to understand, we just create an instance of the <code class="literal">NumberInLeds</code> class, named <code class="literal">number_in_leds</code>, and then we call its <code class="literal">print_number</code> method with <code class="literal">i</code> as its argument within the <code class="literal">for</code> loop.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/>Tip</h3><p>We took advantage of Python's object-oriented features to create classes that represent the LEDs and the generation of numbers with LEDs. This way, we wrote higher level code that is easier to understand because we don't just read code that writes 0s and 1s to specific pin numbers, we can read code that prints numbers in LEDs, turns on and turns off LEDs.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Isolating the pin numbers to improve wirings"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Isolating the pin numbers to improve wirings</h1></div></div></div><p>Obviously, it <a id="id142" class="indexterm"/>is easy to turn on the LED that represents number 1 when it is connected to GPIO pin number 1. In our previous wiring, the LED that represented each number was connected to the same GPIO pin number. The schema was also very easy to understand with the connections where the LED number matched the pin number.</p><p>However, the wirings between the board and the breadboard were a bit complicated because the GPIO pins in the board go from 13 down to 1, from left to right. The breadboard has the LEDs in the opposite direction, that is, from 1 to 9, left to right. Thus, the wire that connect the GPIO pin number 1 with LED number 1 has to go from right to left and crosses the other jumper wires. We will change the jumper wires to improve our wiring and then we will make the necessary changes to our object-oriented Python code to isolate the pin numbers and make it possible to have a nicer wiring. Don't forget to shutdown the operating system and unplug the power supply from the board before you make changes to the wirings.</p><p>The following diagram shows the components connected to the breadboard and the new wirings from <a id="id143" class="indexterm"/>the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_03_06.fzz</code> and the following picture is the breadboard view.</p><div class="mediaobject"><img src="images/B05042_03_27.jpg" alt="Isolating the pin numbers to improve wirings"/></div><p>Now, whenever we want to turn on LED 1, we must write a high (1) value to GPIO pin number 9, whenever we want to turn on LED 2, we write a high (1) value to GPIO pin number 8, and so on. Because <a id="id144" class="indexterm"/>we changed the wirings, the schematic with the electronic components represented as symbols also changed. The following picture shows the new version of the schematic.</p><div class="mediaobject"><img src="images/B05042_03_28.jpg" alt="Isolating the pin numbers to improve wirings"/></div><p>The following lines show the new code for the <code class="literal">Led</code> class. The code file for the sample is <code class="literal">iot_python_chapter_03_06.py</code>.</p><div class="informalexample"><pre class="programlisting">import mraa
import time


class Led:
<span class="strong"><strong>    def __init__(self, pin, position):</strong></span>
<span class="strong"><strong>        self.position = position</strong></span>
        self.gpio = mraa.Gpio(pin)
        self.gpio.dir(mraa.DIR_OUT)

    def turn_on(self):
        self.gpio.write(1)
<span class="strong"><strong>        print("I've turned on the LED connected to GPIO Pin #{0}, in position {1}.".format(self.gpio.getPin(), self.position))</strong></span>


    def turn_off(self):
        self.gpio.write(0)
<span class="strong"><strong>        print("I've turned off the LED connected to GPIO Pin #{0}, in position {1}.".format(self.gpio.getPin(), self.position))</strong></span>
</pre></div><p>Now, we<a id="id145" class="indexterm"/> have to specify an additional parameter when we create an instance of the <code class="literal">Led</code> class: the <code class="literal">position</code> in the breadboard, that is the LED number in the breadboard. The constructor, that is, the <code class="literal">__init__</code> method, saves the <code class="literal">position</code> value in an attribute with the same name. Both the <code class="literal">turn_on</code> and <code class="literal">turn_off</code> methods use the <code class="literal">self.position</code> attribute value to print a message indicating the position of the LED that has been turned on or off. As the position doesn't match the pin anymore, the message had to be improved to specify the position.</p><p>The following lines show the code for the new version of the <code class="literal">NumberInLeds</code> class. The code file for the sample is <code class="literal">iot_python_chapter_03_06.py</code>.</p><div class="informalexample"><pre class="programlisting">class NumberInLeds:
    def __init__(self):
        self.leds = []
<span class="strong"><strong>        for i in range(9, 0, -1):</strong></span>
<span class="strong"><strong>            led = Led(i, 10 - i)</strong></span>
            self.leds.append(led)

    def print_number(self, number):
        print("==== Turning on {0} LEDs ====".format(number))
        for j in range(0, number):
            self.leds[j].turn_on()
        for k in range(number, 9):
            self.leds[k].turn_off()</pre></div><p>It was necessary to make changes to the highlighted lines in the constructor, that is, the <code class="literal">__init__</code> method. The <code class="literal">for</code> loop that creates the nine instances of the <code class="literal">Led</code> class now starts with <code class="literal">i</code> equal to 9 and its last itearation will be with <code class="literal">i</code> equal to 1. We pass <code class="literal">i</code> as an argument for<a id="id146" class="indexterm"/> the <code class="literal">pin</code> parameter and <code class="literal">10 – i</code> as an argument for the position <code class="literal">parameter</code>. This way, the first <code class="literal">Led</code> instance in the <code class="literal">self.leds</code> list will be the one with pin equal to 9 and position equal to 1.</p><p>The code that uses the new version of the <code class="literal">NumberInLeds</code> class to count from 0 to 9 with the LEDs is the same than the previous code. The code file for the sample is <code class="literal">iot_python_chapter_03_06.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    print ("Mraa library version: {0}".format(mraa.getVersion()))
    print ("Mraa detected platform name: {0}".format(mraa.getPlatformName()))

    number_in_leds = NumberInLeds()
    # Count from 0 to 9
    for i in range(0, 10):
        number_in_leds.print_number(i)
        time.sleep(3)</pre></div><p>We just needed to make a few changes in the class that encapsulates a LED (<code class="literal">Led</code>) and in the class that encapsulates a number represented with LEDs (<code class="literal">NumberInLeds</code>). The following picture shows the 9 LEDs turned on in the breadboard with the new wirings connected between the breadboard and the board that is running the new Python code running.</p><div class="mediaobject"><img src="images/B05042_03_29.jpg" alt="Isolating the pin numbers to improve wirings"/></div><p>We can <a id="id147" class="indexterm"/>easily build an API and provide a REST API to allow any client that has connection to the board to be able to print numbers through HTTP. Our REST API just needs to create an instance of the <code class="literal">NumberInLeds</code> class and call the <code class="literal">print_number</code> method with the specified number to be printed with LEDs. We will build this REST API in the next chapter.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Controlling digital outputs with the wiring-x86 library"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Controlling digital outputs with the wiring-x86 library</h1></div></div></div><p>One of the <a id="id148" class="indexterm"/>great advantages of working with Python as our programming language to interact with the board is that we have plenty of packages available for Python. We have been using the <code class="literal">mraa</code> library to interact with the digital outputs. However, in the previous chapter, we also installed the <code class="literal">wiring-x86</code> library. We can change just a few lines of our object-oriented code to replace the <code class="literal">mraa</code> library with the <code class="literal">wiring-x86</code> one to turn on and off the LEDs.</p><p>The following lines shows the code for a <code class="literal">Board</code> class followed by the new version of the <code class="literal">Led</code> class that works with the <code class="literal">wiring-x86</code> library instead of using <code class="literal">mraa</code>. The code file for the sample is <code class="literal">iot_python_chapter_03_07.py</code>.</p><div class="informalexample"><pre class="programlisting">from wiringx86 import GPIOGalileoGen2 as GPIO
import time


class Board:
    gpio = GPIO(debug=False)


class Led:
    def __init__(self, pin, position):
        self.pin = pin
        self.position = position
        self.gpio = Board.gpio
        self.gpio.pinMode(pin, self.gpio.OUTPUT)

    def turn_on(self):
        self.gpio.digitalWrite(self.pin, self.gpio.HIGH)
        print("I've turned on the LED connected to GPIO Pin #{0}, in position {1}.".format(self.pin, self.position))

    def turn_off(self):
        self.gpio.digitalWrite(self.pin, self.gpio.LOW)
        print("I've turned off the LED connected to GPIO Pin #{0}, in position {1}.".format(self.pin, self.position))</pre></div><p>The <code class="literal">wiring-x86</code> library doesn't include automatic detection of the board, and therefore, it is necessary to use the class that represents our board. The GPIOGalileoGen2 represents the Intel Galileo Gen 2 board, and therefore, the first line of code uses an <code class="literal">import</code> statement to import it as <code class="literal">GPIO</code> from <code class="literal">wiringx86</code>. This way, whenever we reference <code class="literal">GPIO</code>, we will be really using <code class="literal">wiringx86.GPIOGalileoGen2</code>. Notice that the library name is <code class="literal">wiring-x86</code> but the module name is <code class="literal">wiringx86</code>.</p><p>When we create an instance of the <code class="literal">Led</code> class, we have to specify the GPIO digital <code class="literal">pin</code> to which the LED is connected and the <code class="literal">position</code> in the breadboard, that is the LED number in the breadboard. The constructor, that is, the <code class="literal">__init__</code> method, saves a reference to the <code class="literal">Board.gpio</code> class attribute in <code class="literal">self.gpio</code> and calls its <code class="literal">pinMode</code> method with the <a id="id149" class="indexterm"/>received pin as its <code class="literal">pin</code> argument and <code class="literal">self.gpio.OUTPUT</code> as its <code class="literal">mode</code> argument. This way, we configure the pin to be an output pin. All the <code class="literal">Led</code> instances will save a reference to the same <code class="literal">Board.gpio</code> class attribute that created an instance of the <code class="literal">GPIO</code> class, specifically, the <code class="literal">wiringx86.GPIOGalileoGen2</code> class with its <code class="literal">debug</code> argument set to <code class="literal">False</code> to avoid unnecessary debug information for the low-level communications.</p><p>The <code class="literal">turn_on</code> method calls the <code class="literal">digitalWrite</code> method for the GPIO instance to send a high value (<code class="literal">self.GPIO.HIGH</code>) to the pin specified by the <code class="literal">self.pin</code> attribute value and prints a message about the performed action.</p><p>The <code class="literal">turn_off</code> method calls the <code class="literal">digitalWrite</code> method for the GPIO instance to send a low value (<code class="literal">self.GPIO.LOW</code>) to the pin specified by the <code class="literal">self.pin</code> attribute value and prints a message about the performed action.</p><p>The code for the <code class="literal">NumberInLeds</code> class remains the same one that we have used for the previous example. There is no need to make changes to this class because it will automatically work with the new <code class="literal">Led</code> class and there were no changes in the arguments for its constructor or its two methods. We just need to replace the lines that printed information about the <code class="literal">mraa</code> library in the <code class="literal">__main__</code> method because we aren't using the <code class="literal">mraa</code> library anymore.</p><p>The following lines shows the code for the <code class="literal">NumberInLeds</code> class and the <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_03_07.py</code>.</p><div class="informalexample"><pre class="programlisting">class NumberInLeds:
    def __init__(self):
        self.leds = []
        for i in range(9, 0, -1):
            led = Led(i, 10 - i)
            self.leds.append(led)

    def print_number(self, number):
        print("==== Turning on {0} LEDs ====".format(number))
        for j in range(0, number):
            self.leds[j].turn_on()
        for k in range(number, 9):
            self.leds[k].turn_off()


if __name__ == "__main__":
    print ("Working with wiring-x86 on Intel Galileo Gen 2")

    number_in_leds = NumberInLeds()
    # Count from 0 to 9
    for i in range(0, 10):
        number_in_leds.print_number(i)
        time.sleep(3)</pre></div><p>We just <a id="id150" class="indexterm"/>needed to change a few lines of code and we can see how the Python code makes LEDs in the breadboard count from 0 to 9 using the <code class="literal">wiring-x86</code> library. The way in which we work with the GPIO pins for digital output with this library is a bit different from the mechanism used in the <code class="literal">mraa</code> library. However, we could easily encapsulate the changes by taking advantage of Python's object-oriented features. We can decide which library is more convenient for our projects based on our preferences and needs. It is always a nice idea to have more than just one option.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When we send a high value (1) to a GPIO pin configured as output, the GPIO pin will have:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">0 V.</li><li class="listitem">6 V.</li><li class="listitem">The voltage specified in the position in which the IOREF jumper is located.</li></ol></div></li><li class="listitem">An instance of the <code class="literal">mraa.Gpio</code> class represents:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A single GPIO pin in the board.</li><li class="listitem">All the I/O pins in the board.</li><li class="listitem">Two GPIO pins in the board.</li></ol></div></li><li class="listitem">When we create an instance of the <code class="literal">mraa.Gpio</code> class, we must specify:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The pin number as an argument.</li><li class="listitem">The specific board and a pin number as arguments.</li><li class="listitem">The pin number and the desired direction: <code class="literal">mraa.DIR_OUT</code> or <code class="literal">mraa.DIR_IN</code>.</li></ol></div></li><li class="listitem">Which of the following lines write a high value to the GPIO pin configured as output with the instance of <code class="literal">mraa.Gpio</code> named <code class="literal">gpio10</code>:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">gpio10.write(0)</code></li><li class="listitem"><code class="literal">gpio10.write(1)</code></li><li class="listitem"><code class="literal">gpio10.write(mraa.HIGH_VALUE)</code></li></ol></div></li><li class="listitem">Which of the following lines configure the instance of <code class="literal">mraa.Gpio</code> named <code class="literal">gpio10</code> for digital output:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">gpio10.dir(mraa.DIR_DIGITAL).out()</code></li><li class="listitem"><code class="literal">gpio10.dir(mraa.DIR_OUT)</code></li><li class="listitem"><code class="literal">gpio10.dir(mraa.DIR_OUT, mraa.DIGITAL)</code></li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we worked with Python with two different libraries: <code class="literal">mraa</code> and <code class="literal">wiring-x86</code>. We connected LEDs and resistors to a breadboard and we wrote code to turn on from 0 to 9 LEDs. We improved our Python code to take advantage of Python's object-oriented features and we prepared the code to make it easy to build an API that will allow us to print numbers with LEDs with a REST API.</p><p>Now that we finished our first wirings and we started controlling the board with Python, we can start working with additional outputs and combine them with a REST API, which is the topic of the next chapter.</p></div></div>
</body></html>