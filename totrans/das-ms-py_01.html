<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Python Primer</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will be covering the basic syntax of Python, its built-in data structures, functions, classes, its standard library, and the new features in the latest versions of Python. If you need to get up to speed on the language, this is where we'll do that. We'll walk through, step by step, covering the following topics:</p>
<ul>
<li>Python basic syntax and block structure</li>
<li>Built-in data structures and comprehensions</li>
<li>First-class functions and classes</li>
<li>Extensive standard library</li>
<li>What's new in Python</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python basic syntax and block structure</h1>
                </header>
            
            <article>
                
<p>This section primarily provides a basic understanding of the Python language constructs. If you feel you already have a solid grasp of Python, feel free to skip ahead.</p>
<p>Let's get down to the nuts and bolts.</p>
<p>A Python program is written as source code in one or more <kbd>.py</kbd> files and consists of statements and expressions as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="148" width="310" class="image-border" src="assets/067b6eb4-6fe8-44d3-afea-3b49b2ee5a09.jpg"/></div>
<p>Both statements and expressions tell Python to do something. The difference is that expressions can be combined to form more complex expressions, while statements can be combined with expressions, but not with other statements.</p>
<p>For example, a statement looks like this:</p>
<pre>
if 2 &gt; 1: 
</pre>
<p>An expression looks like this:</p>
<pre>
print ("One is the loneliest number") 
</pre>
<p>Python source code files are executed from top to bottom as soon as they're loaded by the Python runtime. This means that for simple programs, we could just write a series of statements in a <kbd>.py</kbd> file and then tell Python to run them. In the preceding example, the <kbd>if</kbd> and <kbd>else</kbd> parts are statements or a single statement with two parts, if you prefer to think of it that way. Everything else is an expression. For more complex programs, we need a more structured approach.</p>
<p>Like most programming languages, Python lets us create functions and classes in order to organize our code.</p>
<div class="packt_infobox">If you don't know what functions or classes are, you could think of functions as miniature programs that can be used as building blocks for larger programs and classes as combinations of functions and data to create new kinds of data.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic building blocks</h1>
                </header>
            
            <article>
                
<p>To organize our code, we can divide it into four basic building blocks. We'll discuss each of these separately for understanding their role and importance in the Python code. These are as follows:</p>
<ul>
<li>Functions</li>
<li>Variables</li>
<li>Expressions</li>
<li>Classes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functions</h1>
                </header>
            
            <article>
                
<p>We'll start with a brief look at functions. Functions are created using a <kbd>def</kbd> statement, which is a statement using the <kbd>def</kbd> keyword as its identifying component. As I said earlier, Python executes the statements in a <kbd>.py</kbd> file, starting from the top, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="108" width="387" class="aligncenter size-full wp-image-708 image-border" src="assets/5dcdfd70-0e62-4fe1-8fb6-0cf72aab81a5.jpg"/></div>
<p>When Python executes a <kbd>def</kbd> statement, it creates a function as a result. This means that the code that runs before the <kbd>def</kbd> statement does not see the function because it doesn't exist yet. The part of the <kbd>def</kbd> line inside parentheses is called the <strong>parameter list</strong>:</p>
<pre>
example_function(name, radius): 
</pre>
<p>The parameter list is a list of internal names for data values that are given to the function as the input. Outside the function, these values might have different names or no names at all, but inside, they'll be stored in these variables.</p>
<p>The indented block of code immediately after the <kbd>def</kbd> line is called the <strong>function body</strong>, and you could think of it as the source code of the function:</p>
<pre>
def example_function(name, radius): 
    <strong>area = math.pi * radius ** 2 
    return "The area of {} is {}" .format(name, area)</strong> 
</pre>
<p>The following screenshot shows the output of the preceding example:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="31" width="397" class="image-border" src="assets/924168dc-9aa4-40b2-b94f-56974235eb75.jpg"/></div>
<p>The code inside the function body is an exception to the rule about running Python code from the top to the bottom of the file. This code is stored away and then executed later, when we tell the function to run.</p>
<div class="packt_infobox">Like the code in a file, the code in a function runs from top to bottom, one statement or expression at a time.</div>
<p>If you're more familiar with C++ or Java, you may be wondering where the function <em>parameter types</em> and <em>return types</em> are. In Python, the data type is inherent in each data value, so the runtime always knows what type of data we're working with and whether what we're trying to do is a valid operation for that data type. Thus, for the most part, we don't need explicit data types.</p>
<p>Python programmers sometimes talk about <em>duck typing</em>, which is a reference to the following saying:</p>
<div class="packt_quote CDPAlignCenter CDPAlign">If it quacks like a duck, it's probably a duck.</div>
<p>What they mean by this saying is that if the operations we're trying to perform on a data value work, it doesn't really matter if it's precisely the kind of data we expected. It's probably close enough. If they don't work, Python will tell us what went wrong and where, which is often more useful to know than the kind of information that can be determined by comparing data types alone.</p>
<div class="packt_infobox">For situations where we want or need to specify data types, we can use function annotations and the standard library typing module.</div>
<p>Function decorators, which we'll discuss in later chapters, can provide a convenient way of enforcing these annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variables</h1>
                </header>
            
            <article>
                
<p>The second major building block of a Python program is called a <strong>variable</strong>. A variable is pretty much just a box for storing a data value. The variable has a name and we can use that name to access the data stored in the variable or to replace the data with a new value.</p>
<p>The function parameters in the previous examples were variables, as was <kbd>area</kbd>:</p>
<pre>
(name, radius):  
</pre>
<p>To set the data stored in a variable, we use an <em>assignment</em> statement. An assignment is a statement, so remember this means that it can't be combined with any other statement. It gets a line of source code all for itself and the expressions that are part of it.</p>
<p>An assignment statement consists of the variable's name on the left-hand side of an equal to symbol and the value we want to store in the variable on the right-hand side, as shown in the following code:</p>
<pre>
outer = "Hello world"  
</pre>
<p>If the variable didn't already exist, it will be created. Irrespective of whether the variable existed before or not, the value is stored in the variable.</p>
<p>Variables that are created inside a function are only visible inside that function and each time the function runs they're created a new.</p>
<p>The following code provides an example of this in action:</p>
<pre>
outer = "Hello world"  
def example_function(param): 
    inner = "Hello function: {}".format(param) 
    print(inner, outer) 
example_function("first") 
example_function("second") 
print(inner) 
</pre>
<p>The last line of the preceding example demonstrates that the variable created inside the function does not exist for code outside the function, as shown in the following output of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="79" width="311" class="image-border" src="assets/4988408e-1651-47ae-b81f-749466233ce3.jpg"/></div>
<p>This code example also shows what happens when we try to ask Python to do something impossible. It tells us what we did wrong and gives us the information about where the problem occurred and how we got there.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Expressions</h1>
                </header>
            
            <article>
                
<p>The third major building block of Python programs is <strong>expressions</strong>. We've seen expressions in every example so far because it's nearly impossible to do anything in Python without using expressions.</p>
<p>Expressions consist of data values and operations to perform on those data values. The very simple expressions are a single data value and with no operations, for example, a single number. More complex expressions involve at least one operation and probably more data values as well, for example, adding two numbers or calculating the area, as shown in the following code example:</p>
<pre>
import math 
 
def example_function(name: str, radius: float) -&gt; str: 
  area = math.pi * radius ** 2 
  return "The area of {} is {}" .format(name, area)  
 
print(example_function('Bob', 5)) 
</pre>
<p>All expressions produce a resulting data value of some sort; for example, adding two numbers produces the sum as another number, while concatenating two text strings produces the concatenation as another text string. Using a <kbd>name</kbd> variable to look up the stored value is an expression, so is running a function.</p>
<div class="packt_infobox">If the function doesn't explicitly return a value, the result is a special value called <strong>none</strong>.</div>
<p>Anywhere we need a value, we can use any expression that produces the needed value. It doesn't matter whether the expression is a simple number, such as <kbd>55</kbd>, a variable name, a complex combination of values and operators, a function call, or any other expression. At least, it doesn't matter as far as the final result is concerned. Some expressions take less time to execute than others, so speed can be a factor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p>The final fundamental building block we're going to discuss in this section is <strong>classes</strong>. The word class is a synonym for category or type; in this case, it is referring to data values.</p>
<p>A class defines a new kind of data value by describing a set of internal data and operations for that type of data value. This is done primarily by defining a group of functions that make up the class. A special function called <kbd>__init__</kbd> is used to set up the internal data for a new data value of this type, and the rest of the functions define the operations on an existing data value of this type:</p>
<pre>
class Frood: 
    def __init__(self, age): 
        self.age = age 
        print("Frood initialized") 
 
    def anniversary(self): 
        self.age += 1 
        print("Frood is now {} years old".format(self.age)) 
 
f1 = Frood(12) 
f2 = Frood(97) 
f1.anniversary() 
f2.anniversary() 
f1.anniversary() 
f2.anniversary() 
</pre>
<p>All the functions of a class receive a parameter called <kbd>self</kbd><strong>,</strong> as shown in the preceding code example for classes. This parameter is the data value being operated on. That's different from C++ or Java because while those languages do basically the same thing, the parameter is implicit instead of being an explicit part of the function's parameter list.</p>
<p>Class functions, including <kbd>__init__</kbd>, should store and retrieve data from <kbd>self</kbd> when they want to manipulate the data value that they're connected to.</p>
<div class="packt_infobox">Classes support <strong>inheritance</strong> and <strong>multiple inheritance</strong>, but we won't go into that in detail at this point in the book.</div>
<p>In the preceding example, we created a new data type called <kbd>Frood</kbd> and then made two separate data values of that type. Then, we used the <kbd>anniversary</kbd> function that we created as part of the class to modify each of them.</p>
<p>The output of the code example for classes is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="102" width="393" class="image-border" src="assets/783c34d1-b6f0-4cae-9265-9bf3547af707.jpg"/></div>
<div class="packt_infobox">The two instances maintain their internal variables with different values, as shown in the preceding output.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flow control statements</h1>
                </header>
            
            <article>
                
<p>Python has several flow control statements that will be familiar to people who know another language in the C family. For example, Python has loops and <kbd>if</kbd>, <kbd>elif</kbd>, and <kbd>else</kbd> branches (shown in the following code example):</p>
<pre>
selector = 5 
 
if selector &lt; 3: 
    print("less than three") 
elif selector &lt; 6: 
    print("less than six") 
else: 
    print("six or more") 
while selector &gt; 0" 
    print('selector is {}' .format(selector)) 
    selector -=1 
 
for x in ['a', 'b', 'c', 'd']: 
    print(x) 
for x in range(5): 
    print(x) 
</pre>
<p>Python also has a <kbd>for</kbd> loop statement, but it's not like the <kbd>for</kbd> loops in C, C++, or Java. Instead of counting through numbers, the <kbd>for</kbd> loop iterates through the values. If we actually want to count through numbers with a <kbd>for</kbd> loop, that's easily done using a <kbd>range</kbd> iterator, as shown in the following screenshot in the output of the preceding code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="223" width="391" class="image-border" src="assets/a27e13ed-6d95-4a21-8b95-023b866dd4ee.jpg"/></div>
<p>Before we wrap-up this section, there's one last thing I should comment on and that's Python's views on <strong>indentation</strong> to signify the block structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indentation</h1>
                </header>
            
            <article>
                
<p>Most other programming languages have explicit symbols that indicate the beginning of a block and the end of a block. However, it's a common practice in all of those languages to indent blocks so that humans find the code easier to read. In fact, failure to do so is often taken as a sign that a programmer is an amateur. This means that the block structure in most languages is actually represented in two different ways: the symbols and the indentation. By incorporating indentation into syntax without the need for explicit symbols, Python both removes this duplication and ensures that the code is readable.</p>
<p>With that, we've come to the end of this section. In the next section, we'll look at some of Python's built-in data structures and the data processing syntax.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python's built-in data structures and comprehensions</h1>
                </header>
            
            <article>
                
<p>Now, let's take a look at the core data structure types of Python. These aren't the only data structures available, of course, because it's fairly easy to create data structures using classes. However, these data structures are built right into the heart of Python and they're highly efficient, so it's a good idea to be very familiar with them.</p>
<p>The first thing to understand is that data structures are themselves data values similar to a filing cabinet-they're one thing that contains many things. Like any other data value, they can be stored in a variable or used as part of an expression.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionaries</h1>
                </header>
            
            <article>
                
<p>The first data structure we're going to look at is Python's dictionary. A dictionary consists of any number of key-value pairs. The key can be used to get or set the value or remove the pair from the dictionary entirely.</p>
<div class="packt_infobox">Similar data structures in other languages are sometimes called maps or hash tables.</div>
<p>There are several ways to create a dictionary in Python. The simplest is to use a dictionary expression, which is just a pair of curly brackets surrounding the key-value pairs we want in the dictionary. Each key-value pair is marked with a colon between the key and value, and each pair is separated by a comma, as shown in the following code example:</p>
<pre>
<strong>example_dict = {'a' :1, 'b' :2, 'c' :3}</strong> 
</pre>
<p>When this expression runs, the result is a dictionary object containing the keys and their values. We can also use the <kbd>dict</kbd> class to create dictionary objects:</p>
<pre>
<strong>another_dict = dict()</strong> 
</pre>
<p>If we don't want to use the special syntax to access one of the stored values in a dictionary, we use a lookup expression. This means that we place square brackets containing the key we want to look up after an expression that gives us the dictionary. Usually, this means, the name of the variable containing the dictionary, an open square bracket, a sub-expression that gives us the key, and then a closing square bracket:</p>
<pre>
<strong>example_dict['b']</strong> 
2 
</pre>
<p>We can also use the <kbd>dict.get</kbd> function if we prefer not to use the special syntax:</p>
<pre>
<strong>example_dict.get('c')</strong> 
3 
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List</h1>
                </header>
            
            <article>
                
<p>The next data type we're going to look at is a <strong>list</strong>, which can be created with the list expression. A list expression is just a pair of square brackets surrounding the data values we want to store in the list, with each value separated by a comma. It is not necessary that each of the values be of the same type. The code example for a list is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="143" width="392" class="image-border" src="assets/25a29cea-8d84-4e12-87ba-d33ffd4dc885.jpg"/></div>
<p>In the preceding example, they're strings, but they could be numbers, or a list, or any other kind of data mixed together. We can use a lookup expression to retrieve data values.</p>
<p>Unlike with a dictionary though, the keys for a list are integers. That's because instead of associating key values with data values, a list just stores its data values in order. The key for the very first item in the list is <kbd>0</kbd>. The key for the next item is <kbd>1</kbd>, and so on. We can also use negative integers for the key. We still get a data value out, but it's counted from the end of the list instead of the beginning, with the item at <kbd>-1</kbd> being the last item in the list.</p>
<p>We can use the <kbd>list.append</kbd> function to add a new item at the end of the list or its <kbd>insert</kbd> function to add a new item anywhere as shown in the following code:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/d3875dba-1cb1-4b47-920e-b9d307709016.jpg"/></div>
<p>The list will automatically grow to be large enough to hold all of the data we put into it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuple</h1>
                </header>
            
            <article>
                
<p>The next data structure we'll look at is the <strong>tuple</strong>. A tuple expression is any sequence of value expressions separated by commas if it happens in the place where the language wasn't already expecting to see a comma.</p>
<p>However, it's common and smart to put parentheses around most tuple expressions because it avoids ambiguity. The code example for tuple is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="57" width="352" class="image-border" src="assets/cd6bfea8-97a4-4663-bf58-26bf56e0c024.jpg"/></div>
<p>Like a list, data values can be retrieved from a tuple using numbers. However, we can't add more data to a tuple, and we cannot replace one data value with another.</p>
<p>Why would we want a data structure like that?</p>
<p>Well, there are several reasons. We can list them as follows:</p>
<ul>
<li>First, because they are constant, tuples make good dictionary keys or set members, but we'll get to that in a while.</li>
<li>Second, they fill a different conceptual role than lists. We tend to expect every member of a list to be the same type, such as a list of names or a list of ages. Lists are sort of like columns of a database in that way. We tend to expect tuples to contain different types of data in each element, but we expect them to be related to each other, such as a name in the first element and an age in the second. To continue our analogy, tuples are something like rows in a database.</li>
<li>Third, tuples tend to be slightly more efficient for the computer to work with, both in terms of time and memory usage. So, in optimization situations, they are preferable to lists when they are sufficient for the task.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Set</h1>
                </header>
            
            <article>
                
<p>The final data structure we'll look at is the <strong>set</strong>. A set is a collection of data values without keys; like a list, but in no particular order, like a dictionary. We can create a set using a set expression, which is a pair of curly brackets around comma-separated values, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="88" width="383" class="image-border" src="assets/55d3fdd7-9a69-439f-8b40-7b2c1500e436.jpg"/></div>
<p>Locating a specific value in a set is fast, as is adding or removing a value, as shown in the following example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="90" width="243" class="image-border" src="assets/2662ba78-fa47-437c-ae0b-6f2077265660.jpg"/></div>
<p>Each value can only be in the set once. Sets support a bunch of mathematical operations, such as union and intersection, and are generally more useful than might be obvious at first, though we can't really prove that here in this section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comprehension</h1>
                </header>
            
            <article>
                
<p>Python has a special kind of expression called a <strong>comprehension</strong>. Comprehensions are variations of the special syntax for creating dictionaries, lists, and sets.</p>
<p>Let's look at some examples. Here we see a list comprehension:</p>
<pre>
<strong>capitals = [x.upper() for x in example_list]</strong> 
</pre>
<p>What this expression does is that it creates a new list containing the uppercase versions of the words in the old list.</p>
<p>The first part after the opening square bracket is an <kbd>x.upper()</kbd> expression. This expression describes how to derive a member of the new list from a member of the old list. After that is the <kbd>for</kbd> keyword, then the name of the <kbd>x</kbd> variable we used in the first expression to represent the values from the old list. Then, the keyword is followed by the <kbd>example_list</kbd> expression that gives us the old list and the closing square bracket. The code output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="45" width="399" class="image-border" src="assets/5ee9358c-def4-4fc5-b9b1-e2d5e04bc9bf.jpg"/></div>
<p>The dictionary and set comprehensions are very similar. If we want to use both the key and the value of an existing dictionary in a comprehension, we need to use the <kbd>dict.items</kbd> function, and dictionary comprehensions need to specify both the key and value separated by a colon, as shown in this example:</p>
<pre>
<strong>squares = {k: v ** 2 for k, v in example_dict.items()} </strong>
</pre>
<p>As shown in the following screenshot, notice that the resulting data type depends on what sort of comprehension we used, not on what sort of data structure we used as the source of data:</p>
<div class="CDPAlignCenter CDPAlign"><img height="158" width="461" class="image-border" src="assets/99820c3d-5e46-48d2-8d4f-260dde7ab93c.jpg"/></div>
<p>We can use a list comprehension to create a list of data pulled from the values of a dictionary, for example, or, as we did here, we can use the set comprehension to create a set.</p>
<p>Tuples are slightly different, but only slightly. A tuple comprehension would look exactly like a different syntactic element called a <strong>generator expression</strong>. The code example for tuple comprehension is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="59" width="436" class="image-border" src="assets/08c1aa39-8f1e-46a7-9abf-96adfcd3fc7f.jpg"/></div>
<p>Python's designers hate ambiguity; so instead, if we want the equivalent of a tuple comprehension, we pass a generator expression to a tuple constructor.</p>
<p>That's it for this quick introduction to Python's built-in data structures. In the next section, we're going to look at some useful, but possibly surprising, traits of functions and classes that are significantly different from C, C++, or Java.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First-class functions and classes</h1>
                </header>
            
            <article>
                
<p>In Python, functions and classes are first-class objects. The phrase <strong>first-class object</strong> is a fancy way of saying that the data values can be accessed, modified, stored, and otherwise manipulated by the program they are a part of. In Python, a function is just as much a data value as a text string is. The same goes for classes.</p>
<p>When a function definition statement is executed, it stores the resulting function in a variable with the name that was specified in the <kbd>def</kbd> statement, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="76" width="261" class="image-border" src="assets/b33d1602-663d-4bd9-933b-a7f1ce1c3d7d.jpg"/></div>
<p>This variable isn't special; it's just like any other variable holding the value. This means that we can use it in expressions, assign the value to other values, or even store a different value in place of the original function.</p>
<p>The function value itself contains quite a few attribute variables, which we can access. More usefully, most of the time, we can add attributes to a <kbd>function</kbd> object, allowing us to store custom information about a function as part of the function and access that information later, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="150" width="263" class="image-border" src="assets/8cb869f9-a052-405b-ac2a-f69cdf18561c.jpg"/></div>
<p>One common task that first-class functions make easy is assigning handlers to events. To bind the <strong>handler</strong> function to an event in Python, we just pass the <kbd>function</kbd> object as a parameter when we call the <strong>binding</strong> function, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="48" width="274" class="image-border" src="assets/119f3862-e411-4f9e-9d33-defdf78c7151.jpg"/></div>
<p>That's a significant improvement over the hoops that C++ or Java imposes on us to do something similar. As function definition statements, class definition statements create a class object and store it in a variable. This can be confusing at first. Classes describe the type of object, how can they be objects themselves?</p>
<p>Think of it this way-a blueprint for a house describes the type of building, but the blueprint is still a thing in its own, right? It's the same with class objects. This means that like function objects, class objects can be stored in variables, and otherwise, be treated as data values. Most interestingly, they could be used as parameters to function calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The defaultdict class</h1>
                </header>
            
            <article>
                
<p>As an example of why that's interesting, consider this-Python's standard library contains a data structure class called <kbd>defaultdict</kbd>, which is like a dictionary except, when we try to look up a key that isn't already in the dictionary. It creates a new value and adds it to the dictionary, before returning it to the code that tried the lookup, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="58" width="292" class="image-border" src="assets/13e6933f-ae86-49da-9b0e-890eb946d6d7.jpg"/></div>
<p>How does the <kbd>defaultdict</kbd> class know how to create the default value?</p>
<p>The <kbd>defaultdict</kbd> class knows because we gave it <kbd>class</kbd> as a parameter when we created the <kbd>defaultdict</kbd> class. Thus, if we want a dictionary of list, we can give the <kbd>defaultdict</kbd> class the list class, as its <em>how to make a default</em> parameter. As an aside, <kbd>defaultdict</kbd> can also work with a function, as its <em>how to make a default</em> parameter.</p>
<p>The <kbd>defaultdict</kbd> class actually doesn't care what that parameter is, as long as the object we passed can create a new object whenever the <kbd>defaultdict</kbd> class needs a new default. This is an example of the duck typing we mentioned in the previous section. It doesn't matter whether the parameter is a function, a class, or anything else, so long as it behaves properly. If it doesn't behave properly, we'll be told what went wrong and where.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attributes</h1>
                </header>
            
            <article>
                
<p>We discussed a little while ago that we could add attributes to function objects, which is often handy. We could do something similar with classes, with one big difference- attributes that we add to functions are only visible to the code that has access to that function object, which usually doesn't include the code of the function itself, but attributes that we add to class objects are visible to any code that has access to the class object or to an object of the type described by the class.</p>
<p>This means that if we add an attribute to a class, the functions defined in that class will be able to access that attribute through the <kbd>self</kbd> parameter, as shown in the following code example:</p>
<div class="CDPAlignCenter CDPAlign"><img height="242" width="410" class="image-border" src="assets/80d56e37-df87-4c9f-8d8a-fd99f5a9cfec.jpg"/></div>
<p>We need to be careful when adding attributes to classes because if we accidentally overwrite one of the class' attributes, we could break the class.</p>
<p>We have a greater ability to manipulate classes than functions. So, we need to use that ability more thoughtfully. Also, notice that, in this example, one of the attributes we added to the class is a function, which then proceeded to work exactly as if it had been defined as a part of the class from the beginning.</p>
<p>Next, let's take a short tour of some of the highlights of Python's standard library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The standard library</h1>
                </header>
            
            <article>
                
<p>The library of code that comes pre-installed with Python is extensive, so we're not going into the details. The goal here is to come away with an understanding of the breadth of quality tools we have available, so if we need them in the future then we know where to look. Thus, we're going to just briefly touch on many useful things. You can find the official documentation on the standard library at <a href="https://docs.python.org/3/library/index.html"><span class="URLPACKT">https://docs.python.org/3/library/index.html</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Different types of packages</h1>
                </header>
            
            <article>
                
<p>The index page contains a list of the different packages available to you in Python's standard library. Let's briefly run through them in order.</p>
<p>First of all, there is the <kbd>Collections</kbd> package, which contains even more data structures: <span class="URLPACKT"><a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a>.</span></p>
<p>The <kbd>Collections</kbd> package contains the <kbd>defaultdict</kbd> class that we spoke about in the previous section. The <kbd>Collections</kbd> package also contains an <kbd>OrderedDict</kbd> parameter that remembers the order in which the items were inserted and gives them back in the same order when we iterate over it. A <kbd>deque</kbd> class is a variation on tuples that uses names to access the element and a <kbd>PseudoDict</kbd> parameter that provides a composite view of several other dictionaries.</p>
<p>There are a few other data structures in there as well. One common data structure missing from the collections package is a <kbd>PriorityQueue</kbd> parameter, but that's just because it has its own package called <kbd>heapq</kbd>:</p>
<p><a href="https://docs.python.org/3/library/heapq.html"><span class="URLPACKT">https://docs.python.org/3/library/heapq.html</span></a></p>
<p>Python's <kbd>PriorityQueue</kbd> operations are implemented as functions that work with built-in lists to add and remove items according to the <strong>heap</strong> property.</p>
<p>Storing and retrieving data is an extremely common need for programs and the <kbd>pickle</kbd> package makes it easy:</p>
<p><a href="https://docs.python.org/3/library/pickle.html"><span class="URLPACKT">https://docs.python.org/3/library/pickle.html</span></a></p>
<p>Inside the <kbd>pickle</kbd> package are classes and functions that facilitate transforming arbitrary Python data into a sequence of bytes that can be stored in a file, sent across the network, or whatever you need. The <kbd>pickle</kbd> package also has the tools to reverse the process and transform those bytes back into fully-fledged Python data objects.</p>
<p>Also, in the vein of storing data, the <kbd>sqlite3</kbd> package provides complete access to the SQLite database manager, allowing us to take advantage of a complete transactional relational database:</p>
<p><a href="https://docs.python.org/3/library/sqlite.html"><span class="URLPACKT">https://docs.python.org/3/library/sqlite.html</span></a></p>
<p>Third-party packages to access other database systems follow pretty much the same interface, so it's easy to make the switch to a different database later, if needed.</p>
<p>The <kbd>json</kbd> package is also relevant to data handling. It parses or generates the de facto standard <strong>Internet Data Exchange</strong> (<strong>IDX</strong>) format:</p>
<p><a href="https://docs.python.org/3/library/json.html"><span class="URLPACKT">https://docs.python.org/3/library/json.html</span></a></p>
<p>The <kbd>json</kbd> package is smart, so it handles <strong>JSON</strong> (<strong>JavaScript Object Notation</strong>) objects, arrays, strings, numbers, null values, and so on, in a sensible way.</p>
<p>Mapping them onto the proper Python datatypes, the <kbd>base64</kbd> package encodes bytes into base64, or decodes base64 into bytes:</p>
<p><a href="https://docs.python.org/3/library/base64.html"><span class="URLPACKT">https://docs.python.org/3/library/base64.html</span></a></p>
<p>There are several other similar packages for <kbd>binhex</kbd>, <kbd>uu</kbd> code, and so on, as well.</p>
<p>The <kbd>html</kbd> and <kbd>xml</kbd> packages provide all sorts of utilities for dealing with the major internet markup languages, including parsers and the document object model:</p>
<p><a href="https://docs.python.org/3/library/html.html"><span class="URLPACKT">https://docs.python.org/3/library/html.html</span></a></p>
<p>The <kbd>urllib</kbd> package provides us with convenient ways to retrieve data from URLs or to send data to them:</p>
<p><a href="https://docs.python.org/3/library/urllib.html"><span class="URLPACKT">https://docs.python.org/3/library/urllib.html</span></a></p>
<p>In particular, the <kbd>urllib.request.url</kbd> open function is extremely useful.</p>
<p>The <kbd>itertools</kbd> and <kbd>functools</kbd> packages provide an assortment of utilities having to do with functional programming paradigms:</p>
<p><a href="https://docs.python.org/3/library/itertools.html"><span class="URLPACKT">https://docs.python.org/3/library/itertools.html</span></a></p>
<p>In particular, the <kbd>functools</kbd> package allows for us to create partially applied functions and the <kbd>itertools</kbd> package lets us concatenate iterators.</p>
<p>The <kbd>enum</kbd> package contains support for creating and using named enumerations:</p>
<p><a href="https://docs.python.org/3/library/enum.html"><span class="URLPACKT">https://docs.python.org/3/library/enum.html</span></a></p>
<p>Each enumeration is a distinct data type, like a class.</p>
<p>The <kbd>pathlib</kbd> package contains classes and functions that provide a cross-platform abstraction of file and file path operations:</p>
<p><a href="https://docs.python.org/3/library/pathlib.html"><span class="URLPACKT">https://docs.python.org/3/library/pathlib.html</span></a></p>
<p>The <kbd>inspect</kbd> package is interesting and quite useful. It provides us with functions that can be used to gather information about data objects, particularly about functions and classes. If we want to know the names of functions, parameters, or we want to access an object's documentation, or any number of things along those lines, the <kbd>inspect</kbd> package will get us there:</p>
<p><a href="https://docs.python.org/3/library/pathlib.html"><span class="URLPACKT">https://docs.python.org/3/library/inspect.html</span></a></p>
<p>The packages we just looked at are by no means the complete list of what's available in the standard library, but hopefully they give some idea of the depth and breadth of what we get just by installing Python. Taking a look through the library documentation on <a href="https://www.python.org/"><span class="URLPACKT">https://www.python.org/</span></a> is highly recommended for people who want to get the most out of Python. There are some particularly useful packages that we didn't mention at all. That's because there are whole other sections devoted to them later in the book.</p>
<p>So, that brings us to the end of our overview of the standard library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What's new in modern Python</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to take a look at a few of the changes that have occurred in the latest releases of Python, specifically we will look at these:</p>
<ul>
<li>The syntactic changes</li>
<li>The changes in the packages</li>
<li>Other changes</li>
</ul>
<p>Let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The changes in the syntactic</h1>
                </header>
            
            <article>
                
<p>Since version 3.5, Python has three new groups of syntactic editions. The first of these groups is the introduction of keywords for describing <strong>coroutines</strong>. Python already supported coroutines, but the keywords make things clear and sometimes simpler. We'll be discussing coroutines in depth in a later chapter, so we won't go into this any further now.</p>
<p>The second piece of the new syntax is the introduction of the <kbd>@</kbd> symbol as an infix binary operator. This means that placing an <kbd>@</kbd> symbol between two sub-expressions is now a valid Python expression, just like placing a <kbd>+</kbd> symbol between the sub-expressions would be as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="54" width="465" class="image-border" src="assets/15be46b7-377f-4fb8-ab72-939d11c66e92.jpg"/></div>
<p>However, since no built-in data type supports the <kbd>@</kbd> symbol operator yet, we won't be finding much use for it in this book. The intended semantic meaning of the <kbd>@</kbd> symbol is that it should represent matrix multiplication and it was added to improve support for an interoperability between third-party packages that implement matrixes and matrix operations.</p>
<p>The third piece of new syntax is an expansion of Python's pre-existing syntax for using lists and dictionaries to provide the parameter values when invoking a function.</p>
<p>Before, it was possible to put an asterisk (<kbd>*</kbd>) before a list of values to indicate that those values should be assigned to the parameters in the same order that they appeared in the list. Here is the code example for a single asterisk:</p>
<div class="CDPAlignCenter CDPAlign"><img height="93" width="228" class="image-border" src="assets/57af75ea-b85c-44ac-b107-4d526e15d7d8.jpg"/></div>
<p>Similarly, <kbd>*</kbd> before two values was used to indicate that the values in a dictionary with text string keys should be assigned to the function's parameters by name, as shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="119" width="407" class="image-border" src="assets/9924a66c-e6a8-4940-bb05-d1c3c703961d.jpg"/></div>
<p>The new syntax is just that we can now use more than one list or dictionary in this way, and that we can use the same asterisk and double asterisk syntax for constructing tuples, lists, dictionaries, and sets.</p>
<p>We mentioned earlier that while Python attaches data types to data values rather than variables, it is possible to use function annotations to describe the expected types of function parameters' return values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changes in packages</h1>
                </header>
            
            <article>
                
<p>Python now includes a package called <kbd>typing</kbd> in the standard library that contains classes and functions supporting the usage of type hints.</p>
<p>Python also includes a package called <kbd>zipapp</kbd> in the standard library.</p>
<div class="packt_infobox">For <kbd>typing</kbd> visit the following website:<br/>
<span class="URLPACKT"><a href="https://docs.python.org/3/library/typing.html">https://docs.python.org/3/library/typing.html<br/>
<br/></a></span> For <kbd>zipapp</kbd>, visit this website:<br/>
<a href="https://docs.python.org/3/library/zipapp.html"><span class="URLPACKT">https://docs.python.org/3/library/zipapp.html</span></a></div>
<p>The <kbd>zipapp</kbd> package makes it easy to construct <kbd>.pyz</kbd> files. A <kbd>.pyz</kbd> file is an archive file containing Python code and arbitrary read-only data, which the Python runtime is able to execute as a self-contained program. Once a program is debugged and ready for distribution, packaging it into a <kbd>.pyz</kbd> file is a simple and smart way to hand it to the users.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other changes in Python packages</h1>
                </header>
            
            <article>
                
<p>Some low-level improvements have been made in Python since version 3.5, such as faster reading of <kbd>filesystem</kbd> directories, automatic retrying of interrupted operating system calls, and a <kbd>math.isclose</kbd> function for checking whether two numbers are approximately equal.</p>
<p>There are also a bunch of more minor additions that improve things throughout the standard library, all backwards compatible with earlier Python 3 versions.</p>
<p>In the rare cases where something is added that breaks backwards compatibility, it's not enabled by default. For such a change, if we want to use it, we'd have to specifically mark our code as supporting the change. Those changes will not become standard until two versions later, so a breaking change in Python 3.5 would not become the default until Python version 3.7, with Python 3.5 and 3.6 issuing warnings when they encounter code that depends on the changing feature.</p>
<p>In Python 3.5, there was only one such change-a small and smart alteration in the iteration protocol. It shouldn't have any effect on code that works properly, but technically it's a change in the interface and so it gets the full wait two versions treatment.</p>
<p>If you want more detail about any of these changes I've mentioned, or if you ever want to find out what's changed between versions of Python, the documentation on <a href="https://docs.python.org/3/"><span class="URLPACKT">https://docs.python.org/3/</span></a> always contains a <strong>what's new</strong> document that goes into some detail about new features and provides links to the full documentation.</p>
<div class="packt_infobox">For details on the Python 3.6 what's new document, visit the following link:<br/>
<a href="https://docs.python.org/3/whatsnew/3.6.html"><span class="URLPACKT">https://docs.python.org/3/whatsnew/3.6.html</span></a></div>
<p>I always look forward to reading the what's new document for each release of Python, to find out what new toys I've just been handed.</p>
<p>So, we've now taken a high-level view of the Python standard library, introducing us to some of the more useful items it contains. That brings us to the end of our Python primer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at some fundamentals of the Python programming language. We have seen how to create and access those data structures, and how to use comprehensions to create and transform data structures based on existing ones.</p>
<p>We looked briefly at what it means for Python to have first-class functions and classes, and how that can affect the possibilities open to us as programmers.</p>
<p>We briefly talked about some of the high points of the Python standard library. We also quickly covered the syntax, basic assumptions, and fundamental tools of the Python programming language.</p>
<p>In the next chapter, we're going to see how to set up a Python programming environment for us to work in for the remainder of the course and learn a bit about how to integrate third-party code.</p>


            </article>

            
        </section>
    </body></html>