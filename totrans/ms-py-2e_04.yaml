- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Pythonic Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pythonic设计模式
- en: The previous chapter covered a lot of guidelines for what to do and what to
    avoid in Python. Next, we will explore a few examples of how to work in a Pythonic
    way using the modules included with Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章涵盖了在Python中应该做什么和避免做什么的大量指南。接下来，我们将探索一些使用Python内置模块以Python风格工作的示例。
- en: Design patterns are largely dependent on storing data; for this, Python comes
    bundled with several very useful collections. The most basic collections such
    as `list`, `tuple`, `set`, and `dict` will already be familiar to you, but Python
    also comes bundled with more advanced collections. Most of these simply combine
    the basic types for more powerful features. In this chapter, I will explain how
    to use these data types and collections in a Pythonic fashion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式在很大程度上依赖于存储数据；为此，Python自带了几个非常有用的集合。最基本的数据结构，如`list`、`tuple`、`set`和`dict`，您可能已经熟悉，但Python还自带了更高级的集合。这些集合中的大多数只是将基本类型组合起来以提供更强大的功能。在本章中，我将解释如何以Python风格使用这些数据类型和集合。
- en: Before we can properly discuss data structures and related performance, a basic
    understanding of time complexity (and specifically the big O notation) is required.
    The concept is really simple, but without it, I cannot easily explain the performance
    characteristics of operations and why seemingly nice-looking code can perform
    horribly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够正确讨论数据结构和相关性能之前，需要基本理解时间复杂度（特别是大O符号）。这个概念非常简单，但如果没有它，我无法轻易解释操作的性能特征以及为什么看起来很漂亮的代码可能会表现得很糟糕。
- en: 'In this chapter, once the big O notation is clear, we will discuss some data
    structures and I will show you some example design patterns, along with how to
    use them. We will start with the following basic data structures:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，一旦大O符号变得清晰，我们将讨论一些数据结构，并展示一些示例设计模式，以及如何使用它们。我们将从以下基本数据结构开始：
- en: '`list`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`'
- en: '`dict`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`'
- en: '`set`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`'
- en: '`tuple`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple`'
- en: 'Building on the basic data structures, we will continue with more advanced
    collections, such as the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本数据结构的基础上，我们将继续探讨更高级的集合，例如以下内容：
- en: 'Dictionary-like types:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似字典的类型：
- en: '`ChainMap`'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`'
- en: '`Counter`'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`'
- en: '`Defaultdict`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Defaultdict`'
- en: '`OrderedDict`'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`'
- en: 'List types: `heapq`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表类型：`heapq`
- en: 'Tuple types: `dataclass`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组类型：`dataclass`
- en: 'Other types: `enum`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型：`enum`
- en: Time complexity – The big O notation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间复杂度 – 大O符号
- en: Before we can begin with this chapter, there is a simple notation that you need
    to understand. This chapter uses the big O notation to indicate the time complexity
    for an operation. Feel free to skip this section if you are already familiar with
    this notation. While the notation sounds really complicated, the concept is actually
    quite simple.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本章之前，有一个简单的符号你需要理解。本章使用大O符号来表示操作的复杂度。如果你已经熟悉这个符号，可以自由跳过这一节。虽然这个符号听起来非常复杂，但概念实际上非常简单。
- en: The big O letter refers to the capital version of the Greek letter Omicron,
    which means small-o (micron o).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大O字母指的是希腊字母奥米克戎的大写版本，它代表小-o（米克戎-o）。
- en: When we say that a function takes `O(1)` time, it means that it generally only
    takes `1` step to execute. Similarly, a function with `O(n)` time would take `n`
    steps to execute, where `n` is generally the size (or length) of the object. This
    time complexity is just a basic indication of what to expect when executing the
    code, as it is generally what matters most.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个函数需要`O(1)`时间时，这意味着它通常只需要`1`步来执行。同样，一个`O(n)`时间的函数将需要`n`步来执行，其中`n`通常是对象的大小（或长度）。这种时间复杂度只是执行代码时预期的一个基本指标，因为它通常是最重要的。
- en: 'In addition to O, several other characters might pop up in literature. Here’s
    an overview of the characters used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了O之外，文献中可能会出现几个其他字符。以下是这些字符的概述：
- en: '`Ο` Big Omicron: The upper bound/worst-case scenario.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ο` 大Ω：上界/最坏情况。'
- en: '`Ω` Big Omega: The lower bound/best-case scenario.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ω` 大Ω：下界/最佳情况。'
- en: '`Θ` Big Theta: The tight bound, which means both O and Ω are identical.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Θ` 大Θ：紧界，意味着O和Ω是相同的。'
- en: A good example of an algorithm where these differ a lot is the quicksort algorithm.
    The quicksort algorithm is one of the most widely used sorting algorithm, which
    is surprising if you only look at time complexity according to the (big) O. The
    worst case for quicksort is `O(n**2)` and the best case is either `Ω(n log n)`
    or `Ω(n)`, depending on the implementation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法在这些方面差异很大的好例子是quicksort算法。quicksort算法是最广泛使用的排序算法之一，如果你只根据时间复杂度（大O）来看，这可能会让你感到惊讶。quicksort的最坏情况是`O(n**2)`，最佳情况是`Ω(n
    log n)`或`Ω(n)`，这取决于实现方式。
- en: Given the worst case of `O(n**2)`, you might not expect the algorithm to be
    used a lot, but it has been the default sorting algorithm for many programming
    languages. Within C, it is still the default; for Java, it was the default up
    to Java 6; and Python used it up to 2002\. So, why is/was quicksort so popular?
    For quicksort, it is very important to look at the average case, which is far
    more likely to occur than the worst case. Indeed, the average case is `O(n log
    n)`, which is really good for a sorting algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到最坏情况为`O(n**2)`，你可能不会期望算法被大量使用，但它一直是许多编程语言的默认排序算法。在C语言中，它仍然是默认的；对于Java，它曾是Java
    6的默认算法；Python则使用它直到2002年。那么，为什么/为什么quicksort如此受欢迎？对于quicksort来说，查看平均情况非常重要，这比最坏情况更有可能发生。实际上，平均情况是`O(n
    log n)`，这对于排序算法来说是非常好的。
- en: The purpose of the big O notation is to indicate the approximate performance
    of an operation based on the number of steps that need to be executed. A piece
    of code that executes a single step 1,000 times faster but needs to execute `O(2**n)`
    steps will still be slower than another version of it that takes only `O(n)` steps
    for a value of `n` equal to 10 or more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大O记号的目的在于根据需要执行的操作步数来指示操作的近似性能。一个执行单个步骤比另一个版本快1,000倍的代码，如果对于`n`等于10或更多，它仍然需要执行`O(2**n)`步骤，那么它仍然会比另一个版本慢。
- en: This is because `2**n` for `n=10` is `2**10=1024`, which is 1,024 steps to execute
    the same code. This makes choosing the right algorithm very important, even when
    using languages such as `C`/`C++`, which are generally expected to perform better
    than Python with the CPython interpreter. If the code uses the wrong algorithm,
    it will still be slower for a non-trivial `n`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`2**n`对于`n=10`是`2**10=1024`，这意味着执行相同代码需要1,024步。这使得选择正确的算法非常重要，即使在像`C`/`C++`这样的语言中，这些语言通常预期会比Python的CPython解释器有更好的性能。如果代码使用了错误的算法，对于非平凡`n`值，它仍然会更慢。
- en: For example, suppose you have a list of 1,000 items and you walk through them.
    This will take `O(n)` time because there are `n=1000` items. Checking to see whether
    an item exists in a list means silently walking through the items in a similar
    way, which means it also takes `O(n)`, so that’s 1,000 steps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个包含1,000个项目的列表，并且你逐个检查它们。这将需要`O(n)`时间，因为共有`n=1000`个项目。检查一个项目是否存在于列表中意味着以类似的方式静默地遍历项目，这意味着它也花费`O(n)`时间，所以是1,000步。
- en: If you do the same with a `dict` or `set` that has 1,000 keys/items, it will
    only take `O(1)` step because of how a `dict`/`set` is structured. How the `dict`
    and `set` are structured internally will be covered later in this chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用有1,000个键/项的`dict`或`set`做同样的操作，它将只需要`O(1)`步，因为`dict`/`set`的结构方式。`dict`和`set`是如何在内部结构化的，将在本章后面讨论。
- en: This means that if you want to check the existence of 100 items in that `list`
    or `dict`, it will take you `100*O(n)` for the `list` and `100*O(1)` for the `dict`
    or `set`. That is the difference between 100 steps and 100,000 steps, which means
    that the `dict`/`set` is `n` or 1,000 times faster in this case.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你想在那个`list`或`dict`中检查100个项目的存在，对于`list`来说需要`100*O(n)`，而对于`dict`或`set`来说则是`100*O(1)`。这就是100步和100,000步之间的区别，这意味着在这种情况下`dict`/`set`比`list`快1,000倍。
- en: 'Even though the code seems very similar, the performance characteristics vary
    enormously:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码看起来非常相似，性能特征差异却很大：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To illustrate `O(1)`, `O(n)`, and `O(n**2)` functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`O(1)`、`O(n)`和`O(n**2)`函数：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To illustrate this, we will look at some slower-growing functions first:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们首先将查看一些增长较慢的函数：
- en: '![](img/B15882_04_01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_04_01.png)'
- en: 'Figure 4.1: Time complexity of slow-growing functions with n=1 to n=10,000'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：n=1到n=10,000时慢增长函数的时间复杂度
- en: As you can see, the `O(log(n))` function scales really well with larger numbers;
    this is why a binary search is so incredibly fast, even for large datasets. Later
    in this chapter, you will see an example of a binary search algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`O(log(n))`函数与较大的数字配合得非常好；这就是为什么二分查找对于大型数据集来说如此之快。在本章的后面部分，你将看到一个二分查找算法的例子。
- en: 'The `O(n*log(n))` result shows a rather fast growth, which is undesirable,
    but better than some of the alternatives, as you can see in *Figure 4.2* with
    faster-growing functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n*log(n))`的结果显示了一种相当快的增长，这是不希望的，但比一些替代方案要好，如你在*图4.2*中看到的更快增长的函数：'
- en: '![](img/B15882_04_02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_04_02.png)'
- en: 'Figure 4.2: Time complexity of fast-growing functions with n=1 to n=10'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：n=1到n=10的快速增长函数的时间复杂度
- en: Looking at these charts, the `O(n*log(n))` looks quite good by comparison. As
    you will see later in this chapter, many sorting algorithms use `O(n*log(n))`
    functions and some use `O(n**2)`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这些图表，与`O(n*log(n))`相比，看起来相当不错。正如你将在本章后面看到的那样，许多排序算法使用`O(n*log(n))`函数，一些使用`O(n**2)`。
- en: These algorithms quickly grow to an incalculable size; the `O(2**n)` function,
    for example, already takes 1,024 steps with 10 items and doubles with every step.
    A famous example of this is the current solution to the Towers of Hanoi problem,
    where `n` is the number of disks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法迅速增长到无法计算的大小；例如，`O(2**n)`函数在10个项目上已经需要1,024步，并且每一步都会翻倍。一个著名的例子是解决汉诺塔问题的当前解决方案，其中`n`是盘子的数量。
- en: 'The `O(n!)` factorial function is far worse and becomes impossibly large after
    just a few steps. One of the most famous examples of this is the Traveling Salesman
    problem: finding the shortest route covering a list of cities exactly once.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`O(n!)`阶乘函数要糟糕得多，在几步之后就会变得无法计算。最著名的例子之一是旅行商问题：找到覆盖一系列城市且恰好访问一次的最短路线。'
- en: Next, we’ll dive into core collections.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨核心集合。
- en: Core collections
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心集合
- en: Before we can look at the more advanced combined collections later in this chapter,
    you need to understand the workings of the core Python collections. This is not
    just about their usage; it is also about the time complexities involved, which
    can strongly affect how your application will behave as it grows. If you are well
    versed in the time complexities of these objects and know the possibilities of
    Python 3’s tuple packing and unpacking by heart, then feel free to jump to the
    *Advanced collections* section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够查看本章后面部分更高级的合并集合之前，你需要了解核心Python集合的工作原理。这不仅仅关于它们的用法；还涉及到它们的时间复杂度，这可能会强烈影响你的应用程序随着增长的行为。如果你对这些对象的时间复杂度了如指掌，并且对Python
    3的元组打包和解包了如指掌，那么你可以自由地跳转到*高级集合*部分。
- en: list – A mutable list of items
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: list – 一个可变的项目列表
- en: The `list` is most likely the container structure that you’ve used most in Python.
    It is simple in terms of its usage, and for most cases, it exhibits great performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`很可能是你在Python中使用最多的容器结构。在用法上很简单，并且在大多数情况下，它表现出优异的性能。'
- en: 'While you may already be very familiar with the usage of `list`, you might
    not be aware of the time complexities of the `list` object. Luckily, many of the
    time complexities of `list` are very low; `append`, get operations, set operations,
    and `len` all take `O(1)` time—the best possible. However, you may not know that
    `remove` and `insert` have `O(n)` worst-case time complexity. So, to delete a
    single item out of 1,000 items, Python might have to walk through 1,000 items.
    Internally, the `remove` and `insert` operations execute something along these
    lines:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能已经非常熟悉`list`的使用，但你可能并不了解`list`对象的时间复杂度。幸运的是，`list`的许多时间复杂度都非常低；`append`、获取操作、设置操作和`len`都只需要`O(1)`时间——这是最好的。然而，你可能不知道`remove`和`insert`的最坏情况时间复杂度是`O(n)`。所以，要从1,000个项目中删除一个项目，Python可能需要遍历1,000个项目。在内部，`remove`和`insert`操作执行的操作大致如下：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To remove or insert a single item from/into the list, Python needs to shift
    the rest of the list after the insertion/deletion point. For a large `list`, this
    can become a performance burden and, if possible, should be avoided by using `append`
    instead of `insert`. When executing this only once, it is, of course, not all
    that bad. But when executing a large number of `remove` operations, a `filter`
    or `list` comprehension is a much faster solution because, if properly structured,
    it needs to copy the list only once.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要从/向列表中移除或插入单个项目，Python 需要在插入/删除点之后移动列表中的其余部分。对于大型 `list`，这可能会成为性能负担，如果可能的话，应通过使用
    `append` 而不是 `insert` 来避免。当只执行一次时，当然，这并不是那么糟糕。但是，当执行大量 `remove` 操作时，使用 `filter`
    或 `list` 简化表达式会是一个更快的方法，因为如果结构合理，它只需要复制一次列表。
- en: For example, suppose we wish to remove a specific set of numbers from the list.
    We have quite a few options for this. The first is a solution using `remove`,
    which becomes slower if the number of items to remove becomes larger.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们希望从列表中删除一组特定的数字。我们有很多选择来做这件事。第一个是使用 `remove` 的解决方案，如果需要删除的项目数量变得很大，它就会变慢。
- en: 'Next up is constructing a new list, a list comprehension, or a `filter` statement.
    *Chapter 5*, *Functional Programming – Readability Versus Brevity*, will explain
    `list` comprehensions and the `filter` statement in more detail. But first, let’s
    check out some examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是构建一个新的列表，一个 `list` 简化表达式，或者一个 `filter` 语句。*第五章*，*函数式编程 – 可读性 versus 简洁性*，将更详细地解释
    `list` 简化表达式和 `filter` 语句。但首先，让我们看看一些例子：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The latter two examples are much faster for large lists of items. This is because
    the operations are much faster. To compare using `n=len(items)` and `m=len(primes)`,
    the first example takes `O(m*n)=5*10=50` operations, whereas the latter two take
    `O(n*1)=10*1=10` operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 后两个例子对于大型项目列表来说要快得多。这是因为操作要快得多。为了比较使用 `n=len(items)` 和 `m=len(primes)`，第一个例子需要
    `O(m*n)=5*10=50` 次操作，而后两个例子需要 `O(n*1)=10*1=10` 次操作。
- en: The first method is actually slightly better than stated because `n` decreases
    during the loop. So, it’s effectively `10+9+8+7+6=40`, but this is an effect that
    is negligible enough to ignore. In the case of `n=1000`, that would be the difference
    between `1000+999+998+997+996=4990` and `5*1000=5000`, which makes no real-world
    difference.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法实际上比所说的稍微好一些，因为 `n` 在循环中会减少。所以，它实际上是 `10+9+8+7+6=40`，但这是一个可以忽略不计的效果。在 `n=1000`
    的情况下，这将是 `1000+999+998+997+996=4990` 和 `5*1000=5000` 之间的差异，这在现实世界中没有真正的区别。
- en: Of course, `min`, `max`, and `in` all take `O(n)` as well, but that is expected
    for a structure that is not optimized for these types of lookups.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`min`、`max` 和 `in` 也都采用 `O(n)`，但对于这种没有针对这些类型查找进行优化的结构来说，这是预期的。
- en: 'They can be implemented like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以像这样实现：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With these examples, it’s also clear that the `in` operator is a good example
    of where the best, worst, and average cases are vastly different. The best case
    is `O(1)`, which is being lucky and finding our value at the first item. The worst
    case is `O(n)` because it might not exist or it could be the last item. From this,
    you might expect the average case to be `O(n/2)`, but you would be wrong. The
    average case is still `O(n)` since there is a large likelihood of the item not
    existing in the list at all.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些例子，也很明显，`in` 操作符是一个很好的例子，其中最佳、最坏和平均情况差异很大。最佳情况是 `O(1)`，这是幸运地在我们找到的第一个项目。最坏情况是
    `O(n)`，因为可能不存在，或者它可能是最后一个项目。从这个角度来看，您可能会期望平均情况是 `O(n/2)`，但您会错了。平均情况仍然是 `O(n)`，因为项目根本不在列表中的可能性很大。
- en: dict – A map of items
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dict – 项目的映射
- en: The `dict` is probably the container structure you will choose to use the most.
    You might not realize that you are using it constantly without explicitly using
    `dict`. Every function call and variable access goes through a `dict` to look
    up the name from the `local()` or `global()` scope dictionaries.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 可能是您将选择使用的容器结构。您可能没有意识到，您一直在不断地使用它，而没有明确地使用 `dict`。每次函数调用和变量访问都会通过 `dict`
    来从 `local()` 或 `global()` 范围字典中查找名称。'
- en: The `dict` is fast, simple to use, and very effective for a wide range of use
    cases. The average time complexity is `O(1)` for the `get`, `set`, and `delete`
    operations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 快速、简单易用，并且对于广泛的用例非常有效。对于 `get`、`set` 和 `delete` 操作的平均时间复杂度是 `O(1)`。'
- en: There are exceptions to this time complexity that you need to be aware of, however.
    The way a `dict` works is by converting the key into a hash using the `hash` function
    (which calls the `__hash__` method of the object given as a key) and storing it
    in a hash table.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要注意这个时间复杂度有一些例外。`dict`的工作方式是通过使用`hash`函数（该函数调用作为键的对象的`__hash__`方法）将键转换为哈希，并将其存储在哈希表中。
- en: Magic methods such as `__hash__` are called either **magic methods** or **dunder
    methods**, where **dunder** is short for double-underscore.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法方法，例如 `__hash__`，被称为**魔法方法**或**双下划线方法**，其中**双下划线**是双下划线的缩写。
- en: There are two problems with hash tables, however. The first and the most obvious
    is that the items will be sorted by hash, which appears at random in most cases.
    The second problem with hash tables is that they can have hash collisions, and
    the result of a hash collision is that in the worst case, all the former operations
    can take `O(n)` instead. Hash collisions are not all that likely to occur, but
    they can occur, and if a large `dict` performs below par, that is the place to
    look.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，哈希表有两个问题。第一个也是最明显的问题是，项目将按哈希排序，这在大多数情况下看起来是随机的。哈希表的第二个问题是它们可能发生哈希冲突，哈希冲突的结果是在最坏的情况下，所有之前的操作都可以用`O(n)`完成。哈希冲突并不太可能发生，但它们确实可能发生，如果一个大的`dict`表现不佳，那就是需要查看的地方。
- en: Since Python 3.6, the default `dict` implementation in CPython has changed to
    a version that is sorted by insertion. Since Python 3.7, this is guaranteed behavior
    since other Python versions such as Jython and PyPy could use different implementations
    before version 3.7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Python 3.6版本以来，CPython中的默认`dict`实现已经改为按插入顺序排序的版本。从Python 3.7版本开始，这被保证为一种行为，因为其他Python版本，如Jython和PyPy，在3.7版本之前可能使用不同的实现。
- en: 'Let’s see how this actually works in practice. For the sake of this example,
    I will use one of the simplest hashing algorithms I can think of, which uses the
    most significant digit of a number. So, for the case of `12345`, this hashing
    function will return `1`, and for `56789`, it will return `5`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在实践中是如何工作的。为了这个示例，我将使用我能想到的最简单的哈希算法之一，它使用数字的最显著位。所以，对于`12345`的情况，这个哈希函数将返回`1`，而对于`56789`，它将返回`5`：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will emulate a `dict` using a `list` of lists with this hashing method.
    We know that our hashing method can only return numbers from `0` to `9`, so we
    need only 10 buckets in our list. Now, we will add a few values and see how a
    `contains` function could work:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用具有这种哈希方法的`list`的`list`来模拟`dict`。我们知道我们的哈希方法只能返回从`0`到`9`的数字，所以我们的列表中只需要10个桶。现在，我们将添加一些值并看看`contains`函数是如何工作的：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is obviously not identical to the `dict` implementation, but it is
    similar. Since we can just get item `1` for a value of `123` by simple indexing,
    we have only `O(1)` lookup costs in the general case. However, since both keys,
    `123` and `101`, are within the `1` bucket, the runtime can actually increase
    to `O(n)` in the worst case, where all keys have the same hash. As mentioned,
    that is a hash collision. To alleviate hash collisions beyond what the `hash()`
    function already does, the Python `dict` uses a probing sequence to automatically
    shift hashes if needed. The details of this method are well explained in the `dictobject.c`
    file of the Python source.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显然与`dict`实现不完全相同，但它是相似的。由于我们可以通过简单的索引直接获取值为`123`的项`1`，所以在一般情况下，我们只有`O(1)`的查找成本。然而，由于两个键`123`和`101`都位于`1`桶中，在最坏的情况下，运行时间实际上可以增加到`O(n)`，即所有键都有相同的哈希。如前所述，这就是哈希冲突。为了缓解`hash()`函数已经做的哈希冲突之外的问题，Python
    `dict`使用探测序列在需要时自动移动哈希。这种方法的具体细节在Python源代码的`dictobject.c`文件中有很好的解释。
- en: To debug hash collisions, you can use the `hash()` function paired with `collections.Counter`.
    This will quickly show you where hash collisions occur but it does not take the
    `dict` probing sequence into consideration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试哈希冲突，你可以使用`hash()`函数与`collections.Counter`配合使用。这将快速显示哈希冲突发生的位置，但它不考虑`dict`的探测序列。
- en: In addition to the hash collision performance problem, there is another behavior
    that might surprise you. When deleting items from a dictionary, it won’t actually
    resize the dictionary in memory. The result is that both copying and iterating
    over the entire dictionary take `O(m)` time (where `m` is the maximum size of
    the dictionary); `n`, the current number of items, is not used. So, if you add
    1,000 items to a `dict` and remove 999, iterating and copying will still take
    1,000 steps. The only way to work around this issue is by recreating the dictionary,
    which is something that both the `copy` and `insert` operations do. Note that
    recreation during an `insert` operation is not guaranteed and depends on the number
    of free slots available internally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了哈希碰撞性能问题之外，还有另一种可能让你感到惊讶的行为。当你从字典中删除项目时，实际上并不会在内存中对字典进行大小调整。结果是，复制和遍历整个字典都需要`O(m)`时间（其中`m`是字典的最大大小）；`n`，当前的项目数量，没有被使用。所以，如果你向一个`dict`中添加1,000个项目并删除999个，遍历和复制仍然需要1,000步。解决这个问题的唯一方法是通过重新创建字典，这是`copy`和`insert`操作都会做的事情。请注意，在`insert`操作期间的重创建不保证，并且取决于内部可用的空闲槽位数量。
- en: set – Like a dict without values
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`set` – 类似于没有值的`dict`'
- en: 'A `set` is a structure that uses the `hash()` function to get a unique collection
    of values. Internally, it is very similar to a `dict`, with the same hash collision
    problem, but there are a few handy features of `set` that need to be shown:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`set`是一个使用`hash()`函数来获取唯一值集合的结构。在内部，它与`dict`非常相似，存在相同的哈希碰撞问题，但`set`有一些实用的特性需要展示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first few are pretty much as expected. When we get to the operators, it
    gets interesting:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前几项基本上符合预期。当我们到达运算符时，事情变得有趣：
- en: '| **Expression** | **Output** | **Explanation** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **输出** | **说明** |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `spam` | `amps` | All unique items. A `set` doesn’t allow for duplicates.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `spam` | `amps` | 所有唯一项。`set`不允许重复项。|'
- en: '| `eggs` | `egs` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `eggs` | `egs` |'
- en: '| `spam & eggs` | `s` | Every item in both. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `spam & eggs` | `s` | 在两个中的每个项。|'
- en: '| `spam &#124; eggs` | `aegmps` | Every item in either or both. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `spam &#124; eggs` | `aegmps` | 要么在其中一个或两个中的每个项。|'
- en: '| `spam ^ eggs` | `aegmp` | Every item in either but not in both. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `spam ^ eggs` | `aegmp` | 要么在其中一个但不在两个中的每个项。|'
- en: '| `spam - eggs` | `amp` | Every item in the first but not the latter. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `spam - eggs` | `amp` | 在第一个中但不在后者中的每个项。|'
- en: '| `eggs - spam` | `eg` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `eggs - spam` | `eg` |'
- en: '| `spam > eggs` | `False` | True if every item in the latter is in the first.
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `spam > eggs` | `False` | 如果后者中的每个项都在第一个中则为真。|'
- en: '| `eggs > spam` | `False` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `eggs > spam` | `False` |'
- en: '| `spam > sp` | `True` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `spam > sp` | `True` |'
- en: '| `spam < sp` | `False` | True if every item in the first is contained in the
    latter. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `spam < sp` | `False` | 如果第一个中的每个项都包含在后者中则为真。|'
- en: 'One useful example of `set` operations is calculating the differences between
    two objects. For example, let’s assume we have two lists:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`操作的一个有用示例是计算两个对象之间的差异。例如，假设我们有两个列表：'
- en: '`current_users`: The current users in a group'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_users`：组中的当前用户'
- en: '`new_users`: The new list of users in a group'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_users`：组中的新用户列表'
- en: 'In permission systems, this is a very common scenario—mass adding and/or removing
    users from a group. Within many permission databases, it’s not easily possible
    to set the entire list at once, so you need a list to insert and a list to delete.
    This is where `set` comes in really handy:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在权限系统中，这是一个非常常见的场景——大量添加和/或从组中删除用户。在许多权限数据库中，一次设置整个列表并不容易，所以你需要一个用于插入的列表和一个用于删除的列表。这就是`set`真正派上用场的地方：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we have lists of all users who were added, removed, and unchanged. Note
    that `sorted` is only needed for consistent output, since a `set` has no predefined
    sort order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了所有添加、删除和未更改的用户列表。请注意，`sorted`只需要用于一致的输出，因为`set`没有预定义的排序顺序。
- en: tuple – The immutable list
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`tuple` – 不可变列表'
- en: A `tuple` is another object that you probably use very often without even noticing
    it. When you look at it initially, it seems like a useless data structure. It’s
    like a list that you can’t modify, so why not just use a `list`? In fact, there
    are a few cases where a `tuple` offers some really useful functionalities that
    a `list` does not.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`是另一个你可能经常使用而甚至没有意识到的对象。当你最初看它时，它似乎是一个无用的数据结构。它就像一个你不能修改的列表，所以为什么不直接使用`list`呢？实际上，有一些情况下`tuple`提供了一些非常实用的功能，而`list`则没有。'
- en: 'Firstly, they are hashable. This means that you can use a `tuple` as a key
    in a `dict` or as an item of a `set`, which is something a `list` can’t do:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们是可哈希的。这意味着你可以使用`tuple`作为`dict`的键或`set`的项，这是`list`无法做到的：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, tuples can contain more than simple numbers. You can use nested tuples,
    strings, numbers, and anything else for which the `hash()` function returns a
    consistent result:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，元组可以包含比简单的数字更多的内容。你可以使用嵌套元组、字符串、数字以及任何`hash()`函数返回一致结果的任何其他内容：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can make these as complex as you need. As long as all the parts of the tuple
    are hashable, you will have no problem hashing the tuple as well. You can still
    construct a tuple containing a `list` or any other unhashable type without a problem,
    but that will make the tuple unhashable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使其变得尽可能复杂。只要元组的所有部分都是可哈希的，你将没有问题对元组进行哈希。你仍然可以构建一个包含`list`或其他不可哈希类型的元组，而不会出现问题，但这将使元组不可哈希。
- en: 'Perhaps even more useful is the fact that tuples also support tuple packing
    and unpacking:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更有用的是这样一个事实，即元组也支持元组打包和解包：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In addition to regular packing and unpacking, from Python 3 onward, we can
    actually pack and unpack objects with a variable number of items:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的打包和解包，从 Python 3 开始，我们实际上可以使用可变数量的项目进行打包和解包对象：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Packing and unpacking can be applied to function arguments:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解包可以应用于函数参数：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They are equally useful when returning from a function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数返回时，它们同样非常有用：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you have seen the core Python collections and their limitations, you
    should understand a bit better when certain collections are a good (or bad) idea.
    And more importantly, if a data structure doesn’t perform as you expect it to,
    you will understand why.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了核心 Python 集合及其局限性，你应该更好地理解何时某些集合是一个好主意（或不是一个好主意）。更重要的是，如果一个数据结构的表现不符合你的预期，你将理解为什么。
- en: 'Unfortunately, often real-world problems are not as simple as the ones you
    have seen in this chapter, so you will have to weigh up the pros and the cons
    of the data structures and choose the best solution for your case. Alternatively,
    you can build a more advanced data structure by combining a few of these structures.
    Before you start building your own structures, however, keep reading because we
    will now dive into more advanced collections that do just that: combine the core
    collections.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，现实世界中的问题通常不像你在本章中看到的那样简单，因此你将不得不权衡数据结构的优缺点，并为你的情况选择最佳解决方案。或者，你也可以通过组合这些结构中的几个来构建一个更高级的数据结构。然而，在你开始构建自己的结构之前，请继续阅读，因为我们将现在深入探讨更多高级集合，它们正是为此而设计的：结合核心集合。
- en: Pythonic patterns using advanced collections
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级集合的 Pythonic 模式
- en: The following collections are mostly just extensions of base collections; some
    of them are fairly simple, while others are a bit more advanced. For all of them,
    though, it is important to know the characteristics of the underlying structures.
    Without understanding them, it will be difficult to comprehend the characteristics
    of the collections.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下集合主要是基础集合的扩展；其中一些相对简单，而其他一些则更高级。对于所有这些，了解底层结构的特征是非常重要的。如果不理解它们，将很难理解集合的特征。
- en: There are a few collections that are implemented in native C code for performance
    reasons, but all of them can easily be implemented in pure Python as well. The
    following examples will show you not only the features and characteristics of
    these collections, but also a few example design patterns where they can be useful.
    Naturally, this is not an exhaustive list, but it should give you an idea of the
    possibilities.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能原因，有一些集合是用原生 C 代码实现的，但它们也可以很容易地在纯 Python 中实现。以下示例不仅将展示这些集合的功能和特征，还将展示一些它们可能有用处的示例设计模式。当然，这不是一个详尽的列表，但它应该能给你一个可能性方面的概念。
- en: Smart data storage with type hinting using dataclasses
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据类进行类型提示的智能数据存储
- en: One of the most useful recent additions to Python (since 3.5) is type hinting.
    With the type annotations, you can give type hints to your editor, documentation
    generator, and others reading your code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python（自 3.5 以来）最有用的最近添加之一是类型提示。通过类型注解，你可以向你的编辑器、文档生成器以及其他阅读你代码的人提供类型提示。
- en: 'Within Python, we are generally expected to be “consenting adults,” which means
    the hints are not enforced in any way. This is similar to how private and protected
    variables in Python are not enforced. This means that we can easily give a completely
    different type from what our hint would suggest:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们通常期望自己是“同意的成年人”，这意味着提示不会被强制执行。这与 Python 中的私有和受保护变量不被强制执行的方式相似。这意味着我们可以很容易地给出与我们的提示完全不同的类型：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Even with the `int` type hint, we can still insert a `str` if we want to.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有`int`类型提示，我们仍然可以插入一个`str`。
- en: 'The `dataclasses` module, which was introduced in Python 3.7 (backports available
    for Python 3.6), uses the type hinting system to automatically generate classes,
    including documentation and constructors based on these types:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataclasses`模块是在Python 3.7中引入的（Python 3.6有后向兼容版本），它使用类型提示系统自动生成类，包括基于这些类型的文档和构造函数：'
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The basic class looks quite simple and like it’s nothing special, but if you
    look carefully, the `dataclass` has generated multiple methods for us. Which ones
    are generated becomes obvious when looking at the `dataclass` arguments:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类看起来相当简单，似乎没有什么特别之处，但如果你仔细观察，`dataclass`已经为我们生成了多个方法。哪些方法被生成，当查看`dataclass`参数时就会变得明显：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, `dataclass` has several Boolean flags that decide what to generate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`dataclass`有几个布尔标志，用于决定生成什么内容。
- en: 'First, the `init` flag tells `dataclass` to create an `__init__` method that
    looks something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`init`标志告诉`dataclass`创建一个类似于下面的`__init__`方法：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Further, `dataclass` has flags for:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`dataclass`还有以下标志：
- en: '`repr`: This generates a `__repr__` magic function that generates a nice and
    readable output like `Sandwich(spam=1, eggs=2)` instead of something like `<__main__.Sandwich
    object at 0x...>`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr`：这生成一个`__repr__`魔法函数，生成一个像`Sandwich(spam=1, eggs=2)`这样既美观又易读的输出，而不是像`<__main__.Sandwich
    object at 0x...>`这样的输出。'
- en: '`eq`: This generates an automatic comparison method that compares two instances
    of `Sandwich` by their value when doing `if sandwich_a == sandwich_b`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq`：这生成一个自动比较方法，当执行`if sandwich_a == sandwich_b`时，通过它们的值来比较两个`Sandwich`实例。'
- en: '`order`: This generates a whole range of methods so that comparison operators
    such as `>=` and `<` work by comparing the output of `dataclasses.astuple`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`order`：这生成一系列方法，以便比较运算符如`>=`和`<`通过比较`dataclasses.astuple`的输出来工作。'
- en: '`unsafe_hash`: This will force the generation of a `__hash__` method so that
    you use the `hash()` function on it. By default, a `__hash__` function is only
    generated when all parts of the object are considered immutable. The reason for
    this is that `hash()` should *always* be consistent. If you wish to store an object
    in a `set`, it needs to have a consistent hash. Since a `set` uses `hash()` to
    decide which memory address to use, if the object changes, the `set` would need
    to move the object as well.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsafe_hash`：这将强制生成一个`__hash__`方法，以便您可以在其上使用`hash()`函数。默认情况下，只有当对象的所有部分都被视为不可变时，才会生成`__hash__`函数。这样做的原因是`hash()`应该*始终*保持一致。如果您希望将对象存储在`set`中，它需要有一个一致的哈希值。由于`set`使用`hash()`来决定使用哪个内存地址，如果对象发生变化，`set`需要移动该对象。'
- en: '`frozen`: This will prevent changes after the instance has been created. The
    main use for this is to make sure the `hash()` of the object remains consistent.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frozen`：这将防止在实例创建后进行更改。这种用法的主要目的是确保对象的`hash()`保持一致。'
- en: '`slots`: This automatically adds a `__slots__` attribute which makes attribute
    access and storage faster and more efficient. More about slots in *Chapter 12*,
    *Performance – Tracking and Reducing Your Memory and CPU Usage*.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slots`：这自动添加一个`__slots__`属性，使属性访问和存储更快、更高效。关于插槽的更多信息请参阅*第12章*，*性能 – 跟踪和减少您的内存和CPU使用*。'
- en: The only flag that adds validation is the `frozen` flag, which makes everything
    read-only and prevents us from changing the `__setattr__` and `__getattr__` methods,
    which could be used to modify the instance otherwise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一添加验证的标志是`frozen`标志，它使所有内容都变为只读，并阻止我们更改`__setattr__`和`__getattr__`方法，否则这些方法可以用来修改实例。
- en: The type hinting system still only provides hints; however, these hints are
    not enforced in any way. In *Chapter 6*, *Decorators – Enabling Code Reuse by
    Decorating*, you will see how we can add these types of enforcements to our code
    using custom decorators.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示系统仍然只提供提示；然而，这些提示以任何方式都不会被强制执行。在*第6章*，*装饰器 – 通过装饰实现代码重用*中，您将看到我们如何使用自定义装饰器将这些类型的强制执行添加到我们的代码中。
- en: 'For a more useful example that includes dependence, let’s say that we have
    some users who all belong to one or multiple groups in a system:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个包含依赖关系的更有用的示例，假设我们有一些用户，他们属于系统中的一个或多个组：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In addition to linking dataclasses to each other, this also shows how to create
    a collection as a field and how to have recursive definitions. As you can see,
    the `Group` class references its own definition as a parent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将数据类相互链接之外，这还展示了如何将集合作为字段创建，以及如何有递归定义。如您所见，`Group`类引用了自己的定义作为父类。
- en: These dataclasses are especially useful when used for reading data from databases
    or CSV files. You can easily extend the behavior of dataclasses to include custom
    methods, which makes them a very useful basis for storing your custom data models.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类在用于从数据库或CSV文件读取数据时特别有用。你可以轻松扩展数据类的行为以包括自定义方法，这使得它们成为存储自定义数据模型的一个非常有用的基础。
- en: Combining multiple scopes with ChainMap
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ChainMap`组合多个作用域
- en: Introduced in Python 3.3, `ChainMap` allows you to combine multiple mappings
    (dictionaries, for example) into one. This is especially useful when combining
    multiple contexts. For example, when looking for a variable in your current scope,
    by default, Python will search in `locals()`, `globals()`, and, lastly, `builtins`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.3开始引入的`ChainMap`允许你将多个映射（例如字典）组合成一个。当组合多个上下文时，这特别有用。例如，当在当前作用域中查找变量时，默认情况下，Python会搜索`locals()`、`globals()`，最后是`builtins`。
- en: 'To explicitly write code to do this, we could do something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确编写代码来完成这个任务，我们可以这样做：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works, but it’s ugly to say the least. We can make it prettier by removing
    some of the repeated code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，但至少看起来很丑。我们可以通过删除一些重复的代码来让它更美观：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That’s a lot better! Moreover, this can actually be considered a nice solution.
    But since Python 3.3, it’s even easier. Now, we can simply use the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了！此外，这实际上可以被认为是一个不错的解决方案。但自从Python 3.3以来，这甚至更容易。现在，我们只需简单地使用以下代码：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the `ChainMap` class is automatically coalescing the requested
    value through every given `dict` until it finds a match. And if the value is not
    available, a `KeyError` is raised since it behaves like a `dict`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ChainMap`类会自动将请求的值通过每个给定的`dict`合并，直到找到匹配项。如果找不到值，则会引发`KeyError`，因为它表现得像`dict`。
- en: 'This is very useful for reading configurations from multiple sources and simply
    getting the first matching item. For a command-line application, this could start
    with the command-line arguments, followed by the local configuration file, followed
    by the global configuration file, and lastly the defaults. To illustrate a bit
    of code similar to what I use in small command-line scripts:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于从多个来源读取配置并简单地获取第一个匹配项非常有用。对于命令行应用程序，这可以从命令行参数开始，然后是本地配置文件，然后是全球配置文件，最后是默认值。为了说明一些类似于我在小型命令行脚本中使用的代码：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The inheritance can clearly be seen here. When a specific command-line argument
    is given (`-vv`), that result is used. Otherwise, the code falls back to the one
    in `DEFAULTS` or any other available variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可以清楚地看到继承。当给出特定的命令行参数（`-vv`）时，将使用该结果。否则，代码将回退到`DEFAULTS`或任何其他可用的变量。
- en: Default dictionary values using defaultdict
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`defaultdict`设置默认字典值
- en: The `defaultdict` is one of my favorite objects in the `collections` package.
    Before it was added to the core, I wrote similar objects several times. While
    it is a fairly simple object, it is extremely useful for all sorts of design patterns.
    Instead of having to check for the existence of a key and adding a value every
    time, you can just declare the default from the beginning, and there is no need
    to worry about the rest.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`是我在`collections`包中最喜欢的对象之一。在它被添加到核心之前，我写过几个类似的对象。虽然它是一个相当简单的对象，但它对各种设计模式非常有用。你不必每次都要检查键的存在并添加一个值，你只需从一开始就声明默认值，就无需担心其他事情。'
- en: For example, let’s say we are building a very basic graph structure from a list
    of connected nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在从一个连接节点的列表中构建一个非常基本的图结构。
- en: 'This is our list of connected nodes (one way):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的连接节点列表（单向）：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s put this graph into a normal dictionary:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这个图放入一个正常的字典中：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Some variations are possible, of course, such as using `setdefault`. However,
    they remain more complex than they need to be.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能有一些变体，例如使用`setdefault`。然而，它们仍然比必要的更复杂。
- en: 'The truly Pythonic version uses `defaultdict` instead:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的Python风格版本使用`defaultdict`：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Isn’t that a beautiful bit of code? The `defaultdict` can also be used as a
    basic version of the `Counter` object. It’s not as fancy and doesn’t have all
    the bells and whistles that `Counter` has, but it does the job in many cases:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不是很好看吗？`defaultdict`也可以用作`Counter`对象的基本版本。它没有`Counter`那么花哨，也没有所有那些装饰，但在许多情况下它都能完成任务：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The default value for `defaultdict` needs to be a callable object. In the previous
    cases, these were `int` and `list`, but you can easily define your own functions
    to use as a default value. That’s what the following example uses, although I
    don’t recommend production usage since it lacks a bit of readability. I do believe,
    however, that it is a beautiful example of the power of Python.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 的默认值需要是一个可调用对象。在前面的例子中，这些是 `int` 和 `list`，但你可以轻松定义自己的函数来用作默认值。这就是以下示例所使用的，尽管我不建议在生产环境中使用，因为它缺乏一些可读性。然而，我相信，这是一个展示
    Python 力量的美丽示例。'
- en: 'This is how we create a `tree` in a single line of Python:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在 Python 中一行代码创建 `tree` 的方法：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Brilliant, isn’t it? Here’s how we can actually use it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，下面是如何实际使用的例子：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The nice thing is that you can make it go as deep as you like. Because of the
    `defaultdict` base, it generates itself recursively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于你可以让它深入到你想要的程度。由于 `defaultdict` 的基础，它会递归地生成。
- en: enum – A group of constants
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举 – 一组常量
- en: 'The `enum` package introduced in Python 3.4 is quite similar in its workings
    to enums in many other programming languages, such as C and C++. It helps to create
    reusable constants for your module so you can avoid arbitrary constants. A basic
    example is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4 中引入的 `enum` 包在功能上与其他许多编程语言（如 C 和 C++）中的枚举非常相似。它有助于为你的模块创建可重用的常量，这样你可以避免使用任意常量。一个基本的例子如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A few of the handy features of the `enum` package are that the objects are iterable,
    accessible through both numeric and textual representation of the values, and,
    with proper inheritance, even comparable to other classes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 包的一些实用功能包括对象是可迭代的，可以通过数值和文本值表示访问，并且，通过适当的继承，甚至可以与其他类进行比较。'
- en: 'The following code shows the usage of a basic API:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了基本 API 的使用：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: One of the lesser-known possibilities of the `enum` package is that you can
    make value comparisons work in addition to the identity comparisons you would
    normally use. And this works for every type—not just integers but (your own) custom
    types as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 包的一个不太为人所知的功能是，除了通常使用的身份比较之外，你还可以使值比较工作。这对所有类型都有效——不仅限于整数，还包括（你自己的）自定义类型。'
- en: 'With a regular `enum`, only an identity check (that is, `a is b`) works:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规的 `enum`，只有身份检查（即 `a is b`）是有效的：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we make the `enum` inherit `str` as well, it starts comparing the values
    in addition to the identity:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `enum` 继承 `str` 时，它开始比较值以及身份：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In addition to the preceding examples, the `enum` package has a few other variants
    such as `enum.Flag` and `enum.IntFlag`, which allow for bitwise operations. These
    can be useful for representing permissions as follows: `permissions = Perm.READ
    | Perm.Write`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的例子之外，`enum` 包还有一些其他变体，如 `enum.Flag` 和 `enum.IntFlag`，它们允许进行位运算。这些可以用于表示权限，如下所示：`permissions
    = Perm.READ | Perm.Write`。
- en: Whenever you have a list of constants that can be grouped together, consider
    using the `enum` package. It makes validation much cleaner than having to use
    `if/elif/elif/else` several times.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一组可以一起分组的常量时，考虑使用 `enum` 包。它使得验证比多次使用 `if/elif/elif/else` 清洁得多。
- en: Sorting collections using heapq
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `heapq` 对集合进行排序
- en: The `heapq` module is a great little module that makes it very easy to create
    a priority queue in Python. It is a data structure that will always make the smallest
    (or largest, depending on the implementation) item available with minimum effort.
    The API is quite simple, and one of the best examples of its usage can be seen
    in the `OrderedDict` object. While you might not need it often, it is a very useful
    structure if you need it. And understanding the inner workings is important if
    you wish to understand the workings of classes such as `OrderedDict`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapq` 模块是一个很棒的模块，它使得在 Python 中创建优先队列变得非常容易。这是一个数据结构，它总是以最小的（或最大的，取决于实现）项可用，且无需太多努力。API
    非常简单，其使用的一个最佳例子可以在 `OrderedDict` 对象中看到。虽然你可能不经常需要它，但如果需要，它是一个非常有用的结构。如果你希望了解 `OrderedDict`
    等类的工作原理，理解其内部工作方式很重要。'
- en: If you are looking for a structure to keep your list always sorted, try the
    `bisect` module instead, which is covered in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个始终保持列表排序的结构，请尝试下一节中介绍的 `bisect` 模块。
- en: 'The basic usage of `heapq` is simple but somewhat confusing initially:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapq` 的基本用法简单，但一开始可能有些令人困惑：'
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One important thing to note here—something that you have probably already understood
    from the preceding example—is that the `heapq` module does not create a special
    object. It consists of a few methods to treat a regular list as a `heap`. That
    doesn’t make it less useful, but it is something to take into consideration.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的一个重要事项——你可能已经从前面的例子中理解到了——`heapq`模块并不创建一个特殊对象。它包含一些方法，可以将普通列表视为一个`heap`。这并不使它变得不那么有用，但这是需要考虑的事情。
- en: 'The really confusing part, at first glance, is the sort order. The array is
    actually sorted but not as a list; it is sorted as a tree. To illustrate this,
    take a look at the following tree, which shows how the tree is supposed to be
    read:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，最令人困惑的部分是排序顺序。实际上，数组是排序的，但不是作为一个列表；它是作为一个树来排序的。为了说明这一点，请看以下树，它显示了树应该如何读取：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The smallest number is always at the top and the biggest numbers are always
    at the bottom row of the tree. Because of that, it’s really easy to find the smallest
    number, but finding the largest is not as easy. To get the sorted version of the
    heap, we simply need to keep removing the top of the tree until all the items
    are gone. Therefore, the heapsort algorithm can be implemented as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的数字始终位于树的顶部，最大的数字始终位于树的底部行。正因为如此，找到最小的数字非常容易，但找到最大的数字就不那么容易了。要获取堆的排序版本，我们只需简单地不断移除树的顶部，直到所有项都消失。因此，堆排序算法可以按以下方式实现：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With `heapq` doing the heavy lifting, it becomes incredibly easy to write your
    own version of the `sorted()` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`heapq`负责重负载，因此编写你自己的`sorted()`函数版本变得极其简单。
- en: Since the `heappush` and `heappop` functions both have `O(log(n))` time complexity,
    they can be considered really fast. Combining those for the `n` items in the preceding
    iterable gives us `O(n*log(n))` for the `heapsort` function. The `heappush` method
    uses `list.append()` internally and swaps the items in the `list` to avoid the
    `O(n)` time complexity of `list.insert()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`heappush`和`heappop`函数都具有`O(log(n))`的时间复杂度，因此它们可以被认为是真的很快。将它们结合用于前面可迭代对象的`n`个元素，我们得到`heapsort`函数的`O(n*log(n))`。`heappush`方法内部使用`list.append()`并交换列表中的项以避免`list.insert()`的`O(n)`时间复杂度。
- en: The `log(n)` refers to the base 2 logarithm function. To calculate this value,
    the `math.log2()` function can be used. This results in an increase of 1 every
    time the number doubles in size. For `n=2`, the value of `log(n)` is `1`, and
    consequently for `n=4` and `n=8`, the log values are `2` and `3`, respectively.
    And `n=1024` results in a log of only `10`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`log(n)`指的是以2为底的对数函数。为了计算这个值，可以使用`math.log2()`函数。这导致每次数字大小加倍时，值增加1。对于`n=2`，`log(n)`的值是`1`，因此对于`n=4`和`n=8`，对数值分别是`2`和`3`。而`n=1024`的结果是一个对数仅为`10`。'
- en: This means that a 32-bit number, which is `2**32 = 4294967296`, has a log of
    `32`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个32位数字，即`2**32 = 4294967296`，其对数是`32`。
- en: Searching through sorted collections using bisect
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bisect在排序集合中进行搜索
- en: The `heapq` module in the previous section gave us an easy way to sort a structure
    and keep it sorted. But what if we want to search through a sorted collection
    to see whether the item exists? Or what’s the next biggest/smallest item if it
    doesn’t? That’s where the `bisect` algorithm helps us.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的`heapq`模块为我们提供了一种简单的方法来排序一个结构并保持其排序。但如果我们想搜索一个排序集合以查看项目是否存在？或者如果不存在，下一个最大/最小项目是什么？这就是`bisect`算法帮助我们的地方。
- en: The `bisect` module inserts items in an object in such a way that they stay
    sorted and are easily searchable. If your primary purpose is searching, then `bisect`
    should be your choice. If you’re modifying your collection a lot, `heapq` might
    be better for you.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect`模块以这种方式在对象中插入项，使它们保持排序并易于搜索。如果你的主要目的是搜索，那么`bisect`应该是你的选择。如果你经常修改你的集合，`heapq`可能更适合你。'
- en: As is the case with `heapq`, `bisect` does not really create a special data
    structure. The `bisect` module expects a `list` and expects that `list` to always
    be sorted. It is important to understand the performance implications of this.
    While appending items to a `list` has `O(1)` time complexity, inserting has `O(n)`
    time complexity, making it a very heavy operation. Effectively, creating a sorted
    list using bisect takes `O(n*n)`, which is quite slow, especially because creating
    the same sorted list using `heapq` or `sorted()` takes `O(n*log(n))` instead.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与`heapq`类似，`bisect`实际上并不创建一个特殊的数据结构。`bisect`模块期望一个`list`，并期望这个`list`始终保持排序状态。理解这一点的性能影响是很重要的。虽然向`list`中添加项的时间复杂度为`O(1)`，但插入的时间复杂度为`O(n)`，这使得它成为一个非常耗时的操作。实际上，使用`bisect`创建一个排序列表的时间复杂度为`O(n*n)`，这相当慢，尤其是因为使用`heapq`或`sorted()`创建相同的排序列表只需要`O(n*log(n))`。
- en: If you have a sorted structure and you only need to add a single item, then
    the `bisect` algorithm can be used for insertion. Otherwise, it’s generally faster
    to simply append the items and call `list.sort()` or `sorted()` afterward.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个已排序的结构，并且只需要添加一个单独的项，那么可以使用`bisect`算法进行插入。否则，通常直接添加项并在之后调用`list.sort()`或`sorted()`会更快速。
- en: 'To illustrate, we have these lines:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们有这些行：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For a small number of items, the difference is negligible, but the number of
    operations needed to sort using `bisect` quickly grows to a point where the difference
    will be large. For `n=4`, the difference is just between `4 * 1 + 8 = 12` and
    `1 + 2 + 3 + 4 = 10`, making the `bisect` solution faster. But if we were to insert
    1,000 items, it would be `1000 + 1000 * log(1000) = 10966` versus `1 + 2 + … 1000
    = 1000 * (1000 + 1) / 2 = 500500`. So, be very careful while inserting many items.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少量项，这种差异是可以忽略不计的，但使用`bisect`进行排序所需的操作数量会迅速增长到差异很大的程度。对于`n=4`，差异只是`4 * 1 +
    8 = 12`与`1 + 2 + 3 + 4 = 10`之间的差异，使得`bisect`解决方案更快。但如果我们插入1,000个项，它将是`1000 + 1000
    * log(1000) = 10966`与`1 + 2 + … 1000 = 1000 * (1000 + 1) / 2 = 500500`。所以，在插入多个项时要非常小心。
- en: 'Searching within the list is very fast, though; because it is sorted, we can
    use a very simple binary search algorithm. For example, what if we want to check
    whether a few numbers exist within the list? The simplest algorithm, shown as
    follows, simply loops through the list and checks all items, resulting in `O(n)`
    worst-case performance:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中进行搜索非常快；因为它是有序的，我们可以使用一个非常简单的二分搜索算法。例如，如果我们想检查几个数字是否存在于列表中？最简单的算法，如下所示，只是简单地遍历列表并检查所有项，导致最坏情况下的性能为`O(n)`：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With the `bisect` algorithm, though, there is no need to walk through the entire
    list:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`bisect`算法，就没有必要遍历整个列表：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `bisect_left` function tries to find the position at which the number is
    supposed to be. This is actually what `bisect.insort` does as well; it inserts
    the number at the correct position by searching for the location of the number.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect_left`函数试图找到数字应该放置的位置。这正是`bisect.insort`所做的；它通过搜索数字的位置来在正确的位置插入数字。'
- en: 'The biggest difference between these methods is that `bisect` does a binary
    search internally, which means that it starts in the middle and jumps to the middle
    of the left or right section, depending on whether the value in the list is bigger
    or smaller than the value we are looking for. To illustrate, we will search for
    `4` in a list of numbers from `0` to `14`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法之间最大的区别是`bisect`在内部执行二分搜索，这意味着它从中间开始，根据列表中的值是否大于我们正在寻找的值，跳到左或右部分的中间。为了说明，我们将在一个从`0`到`14`的数字列表中搜索`4`：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, after only four steps, we have found the number we searched
    for. Depending on the number (`7`, for example), it may go faster, but it will
    never take more than `O(log(n))` steps to find a number.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，经过仅四步，我们就找到了我们搜索的数字。根据数字（例如`7`），它可能更快，但找到数字的步骤永远不会超过`O(log(n))`。
- en: With a regular list, a search will simply walk through all the items until it
    finds the desired item. If you’re lucky, it could be the first number you encounter,
    but if you’re unlucky, it could be the last item. In the case of 1,000 items,
    that would be the difference between 1,000 steps and `log(1000) = 10` steps.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个常规列表，搜索将简单地遍历所有项，直到找到所需的项。如果你很幸运，它可能是你遇到的第一个数字，但如果你不幸，它可能是最后一个项。在1,000个项的情况下，这将是1,000步与`log(1000)
    = 10`步之间的区别。
- en: 'While very fast and efficient, the `bisect` module doesn’t feel Pythonic at
    all. Let’s fix that by creating our own `SortedList` class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非常快速和高效，但`bisect`模块一点也不像Python风格。让我们通过创建自己的`SortedList`类来解决这个问题：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: While functional, this implementation is obviously still a tad limited. But
    it’s certainly a nice starting point in case you need a structure like this.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个实现是功能性的，但显然仍然有点局限。但如果你需要这种结构，这无疑是一个很好的起点。
- en: Global instances using Borg or Singleton patterns
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Borg或单例模式的全局实例
- en: Most programmers will be familiar with the Singleton pattern, which ensures
    that only a single instance of a class will ever exist. Within Python, a common
    alternative solution to this is the Borg pattern, named after the Borg in Star
    Trek. Where a Singleton enforces a single instance, the Borg pattern enforces
    a single state for all instances and subclasses as well. Due to the way class
    creation works in Python, the Borg pattern is a tiny bit easier to implement and
    modify than the Singleton pattern as well.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员都会熟悉单例模式，该模式确保一个类只有一个实例存在。在Python中，对此的一个常见替代解决方案是Borg模式，该模式以《星际迷航》中的博格命名。单例模式强制执行单个实例，而Borg模式则强制所有实例和子类都保持单一状态。由于Python中类创建的方式，Borg模式比单例模式更容易实现和修改。
- en: 'To illustrate an example of both:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这两个示例：
- en: 'The Borg class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Borg类：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The Singleton class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 单例类：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Borg pattern works by overriding the `__dict__` of the instance that contains
    the instance state. The Singleton overrides the `__new__` (note, not `__init__`)
    method so that we only ever return a single instance of the class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Borg模式通过覆盖包含实例状态的实例的`__dict__`来实现。单例通过覆盖`__new__`（注意，不是`__init__`）方法，以确保我们始终只返回该类的单个实例。
- en: No need for getters and setters with properties
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性不需要getters和setters
- en: 'Within many languages (notably Java), a common design pattern for accessing
    instance variables is using getters and setters so that you can modify the behavior
    when needed in the future. Within Python, we can transparently change the behavior
    of attributes for existing classes without the need to touch the calling code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言（尤其是Java）中，访问实例变量的常见设计模式是使用getters和setters，这样你可以在未来需要时修改行为。在Python中，我们可以透明地更改现有类的属性行为，而无需修改调用代码：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The calling code doesn’t need to be changed at all. We can simply change the
    behavior of the property in a completely transparent way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码根本不需要改变。我们可以完全透明地改变属性的调用行为。
- en: Dict union operators
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典联合操作符
- en: This is not actually a separate advanced collection, but it is advanced usage
    of the `dict` collection. Since Python 3.9, we have a few easy options for combining
    multiple `dict` instances. The “old” solution was to use `dict.update()`, possibly
    combined with `dict.copy()` to create a new instance. While that works fine, it
    is rather verbose and a tad clunky.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个单独的高级集合，但它是对`dict`集合的高级使用。自Python 3.9以来，我们有几种简单的方法来组合多个`dict`实例。旧解决方案是使用`dict.update()`，可能还结合使用`dict.copy()`来创建一个新实例。虽然这可以正常工作，但它相当冗长且有点笨拙。
- en: 'Since this is a case where a few examples are much more useful than just explanation,
    let’s see how the old solution works:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个几个示例比仅仅解释更有用的案例，让我们看看旧解决方案是如何工作的：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That solution works great, but with Python 3.9 and above we can do it in a
    much easier and shorter way:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案效果很好，但自Python 3.9及以上版本，我们可以用更简单、更短的方式来做：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is a feature that can be very convenient when specifying arguments to
    a function, especially if you want to automatically fill in keyword arguments
    with default arguments:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在指定函数参数时非常有用的功能，特别是如果你想自动用默认参数填充关键字参数时：
- en: '[PRE47]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now that you have seen a few of the more advanced collections bundled with Python,
    you should have a pretty good idea of when to apply which type of collection.
    You may also have learned about a few new Python design patterns.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了Python附带的一些更高级的集合，你应该对何时应用哪种类型的集合有一个相当好的了解。你可能还了解了一些新的Python设计模式。
- en: Exercises
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In addition to enhancing the examples in this chapter, there are many other
    exercises:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了增强本章中的示例外，还有很多其他的练习：
- en: Create a `SortedDict` collection that takes a `keyfunc` to decide the sort order.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用`keyfunc`来决定排序顺序的`SortedDict`集合。
- en: Create a `SortedList` collection that has `O(log(n))` inserts and always returns
    a sorted list during each iteration.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有`O(log(n))`插入操作和每次迭代都返回排序列表的`SortedList`集合。
- en: Create a Borg pattern that has a state per subclass.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有每个子类状态的Borg模式。
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_4.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_4.xhtml)。我们鼓励你提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Python is a bit unlike other languages in some aspects and several design patterns
    that are common in other languages make little sense in Python. In this chapter,
    you have seen some common Python design patterns, but many more patterns exist.
    Before you start implementing your own collections based on these patterns, quickly
    search the web to see whether there is an existing solution already. In particular,
    the `collections` module receives a lot of updates, so it is possible that your
    problem has already been solved.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，Python与其他语言略有不同，而在其他语言中常见的几种设计模式在Python中几乎没有什么意义。在本章中，你已经看到了一些常见的Python设计模式，但还有很多模式存在。在你开始根据这些模式实现自己的集合之前，快速在网上搜索一下是否已经存在现成的解决方案。特别是，`collections`模块经常更新，所以你的问题可能已经被解决了。
- en: If you are ever wondering how these structures work, have a look at the following
    source:[https://github.com/python/cpython/blob/master/Lib/collections/__init__.py](https://github.com/python/cpython/blob/master/Lib/collections/__init__.py).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾好奇这些结构是如何工作的，可以查看以下源代码：[https://github.com/python/cpython/blob/master/Lib/collections/__init__.py](https://github.com/python/cpython/blob/master/Lib/collections/__init__.py)。
- en: After finishing this chapter, you should be aware of the time complexities of
    the basic Python structures. You should also be familiar with a few Pythonic methods
    of tackling certain problems. Many of these examples use the `collections` module,
    but this chapter does not list all of the classes in the `collections` module.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一章后，你应该了解基本Python结构的时复杂度。你也应该熟悉一些解决特定问题的Python方法。许多示例使用了`collections`模块，但本章并未列出`collections`模块中的所有类。
- en: Selecting the correct data structure within your applications is by far the
    most important performance factor for your code. This makes basic knowledge about
    performance characteristics essential for any serious programmer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中选择正确的数据结构是代码性能最重要的因素。这使得对性能特性的基本知识对于任何严肃的程序员来说都是必不可少的。
- en: In the next chapter, we will continue with functional programming, which covers
    `lambda` functions, `list` comprehensions, `dict` comprehensions, `set` comprehensions,
    and an array of related topics. Additionally, you will learn about the mathematic
    background of functional programming.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续介绍函数式编程，包括`lambda`函数、`list`推导式、`dict`推导式、`set`推导式以及一系列相关主题。此外，你还将了解函数式编程的数学背景。
- en: Join our community on Discord
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
