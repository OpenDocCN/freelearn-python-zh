- en: 9\. Building More Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 构建更多功能
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Use caching to improve API performance and efficiently get the latest information
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存来提高API性能并高效获取最新信息
- en: Add the cache function to the Smilecook application using the Flask-Caching
    package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-Caching包将缓存功能添加到Smilecook应用程序中
- en: Implement rate-limiting functionality to an API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API中实现速率限制功能
- en: Use IP address to perform rate limiting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IP地址进行速率限制
- en: In this chapter, we will cover caching to improve performance and get accustomed
    to using the rate-limiting function.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍缓存以提高性能，并熟悉使用速率限制功能。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: We added pagination, searching, and ordering functions to our Smilecook application
    in our last chapter so that users can navigate to their recipes much easier. This
    also helps to reduce the server burden and improve performance. We have explained
    how making our APIs snappy is important in today's world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向Smilecook应用程序添加了分页、搜索和排序功能，以便用户可以更容易地导航到他们的食谱。这也帮助减轻了服务器负担并提高了性能。我们已经解释了为什么在当今世界使我们的API快速响应很重要。
- en: In this chapter, we will be further improving our API performance from another
    aspect. We will be adding in the `cache` function, which will temporarily save
    data to the application memory. This will allow us to save the time required to
    query the database every time. This can greatly improve API performance and reduce
    server burden. There is a Flask extension package, Flask-Caching, that can help
    us in implementing the caching function. We will first talk about the theory behind
    caching, and through practical exercises, we show you how to implement this function
    in our Smilecook application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从另一个方面进一步改进我们的API性能。我们将添加`cache`功能，它将临时将数据保存到应用内存中。这将使我们能够节省每次查询数据库所需的时间。这可以大大提高API性能并减轻服务器负担。有一个Flask扩展包，Flask-Caching，可以帮助我们实现缓存功能。我们首先将讨论缓存背后的理论，然后通过实际练习，向您展示如何在我们的Smilecook应用程序中实现此功能。
- en: Besides caching, we will implement a rate-limiting function. That will prevent
    certain high-usage users from jeopardizing the whole system by limiting their
    usage. Ensuring fair usage of our APIs is crucial to guarantee service quality.
    We will be using a Flask extension package, `Flask-Limiter`, for that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缓存之外，我们还将实现一个速率限制功能。这将通过限制某些高使用量用户的访问来防止他们危害整个系统。确保我们API的公平使用对于保证服务质量至关重要。我们将使用Flask扩展包`Flask-Limiter`来实现这一点。
- en: These two caching and rate-limiting functions are very common and powerful in
    real-world scenarios. Let's learn about how they work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个缓存和速率限制功能在现实场景中非常常见且强大。让我们了解它们是如何工作的。
- en: Caching
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: '**Caching** means storing data in a temporary space (a cache) so that it can
    be retrieved faster in subsequent requests. The temporary space can be application
    memory, server hard disk space, or something else. The whole purpose of caching
    is to lighten the workload by avoiding any heavy processes for querying the data
    again. For example, in our Smilecook application, if we reckon that the recipes
    from a popular author will always get queried by the users, we can cache these
    recipes. So, the next time that users ask for these recipes, we can just send
    back the recipes in the cache instead of querying against our database. You can
    see caching everywhere. Almost all applications have caching implemented nowadays.
    Even in our local browsers, we save website results on the local hard disk to
    achieve faster access next time.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**意味着将数据存储在临时空间（缓存）中，以便在后续请求中更快地检索。这个临时空间可以是应用内存、服务器硬盘空间或其他。缓存的整体目的是通过避免再次查询数据的任何重过程来减轻工作负载。例如，在我们的Smilecook应用程序中，如果我们认为来自热门作者的食谱总是会由用户查询，我们可以缓存这些食谱。因此，下次用户请求这些食谱时，我们只需从缓存中发送这些食谱，而不是查询我们的数据库。你可以在任何地方看到缓存。现在几乎所有应用程序都实现了缓存。即使在我们的本地浏览器中，我们也会将网站结果保存在本地硬盘上，以便下次访问更快。'
- en: For server-level caching, most of the time, the cache is stored in the same
    web server as the application. But technically speaking, it can be stored in another
    server as well, such as **Redis** (**Remote Dictionary Server**) or **Memcached**
    (a high-performance distributed cached memory). They are all in-memory data storage
    systems that allow key-value storage as well as storing data. For simple applications
    and easy implementation, we can also use a single global dictionary as a cache
    (simple cache).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器级别的缓存，大多数情况下，缓存存储在与应用程序相同的Web服务器上。但从技术上讲，它也可以存储在另一个服务器上，例如**Redis**（**远程字典服务器**）或**Memcached**（高性能分布式缓存内存）。它们都是内存数据存储系统，允许键值存储以及存储数据。对于简单应用和易于实现，我们也可以使用单个全局字典作为缓存（简单缓存）。
- en: Benefit of Caching
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存的优点
- en: 'Through caching, not only can we reduce the volume of data to be transferred,
    but we can also improve the overall performance. This is done by reducing the
    bandwidth required, reducing the server loading time, and more. Take our Smilecook
    application as an example: if we have a low traffic, caching may not be a lot
    of help, because the cache will pretty much expire before the next query comes
    in. But imagine that we have high traffic, say, 10,000 requests per minute, coming
    in asking for recipes. If these recipes are all cached and the cache has not expired,
    we will be able to simply return the recipes in the cache to the client frontend.
    In this scenario, we would be saving 10,000 database queries, which could be a
    substantial cost-saving measure.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过缓存，我们不仅可以减少需要传输的数据量，还可以提高整体性能。这是通过减少所需的带宽、减少服务器加载时间以及更多方式实现的。以我们的Smilecook应用为例：如果我们流量较低，缓存可能帮助不大，因为缓存将在下一次查询到来之前几乎到期。但想象一下，如果我们有高流量，比如说每分钟10,000个请求，都在请求菜谱。如果这些菜谱都缓存了，并且缓存尚未过期，我们就可以直接将缓存中的菜谱返回给客户端前端。在这种情况下，我们将节省10,000个数据库查询，这可能是一项重大的成本节约措施。
- en: Flask-Caching
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-Caching
- en: '`cache` as a dictionary object that contains key-value pairs. The key here
    is used to specify the resource to `cache`, whereas the value is used to store
    the actual data to be cached. Take the resource for retrieving all the recipes
    as an example. The flow contains the following stages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`作为一个包含键值对的字典对象。这里的键用于指定要缓存的资源，而值用于存储实际要缓存的数据。以检索所有菜谱的资源为例。流程包含以下阶段：'
- en: Request the get `/recipes` resource.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求获取`/recipes`资源。
- en: Use the key to search for the existing cache (Flask-Caching will be using `request.path`
    and `hashed_args` to be the key value, for example, `recipesbcd8b0c2eb1fce714eab6cef0d771acc`).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键来搜索现有的缓存（例如，Flask-Caching将使用`request.path`和`hashed_args`作为键值，例如，`recipesbcd8b0c2eb1fce714eab6cef0d771acc`）。
- en: If the recipes were previously cached, return the cached data.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前已经缓存了这些菜谱，则返回缓存的数据。
- en: If no cache for these recipes exists, follow the standard flow to get the recipes
    from the database.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这些菜谱不存在缓存，则遵循标准流程从数据库中获取菜谱。
- en: Save the result (the recipe data) in the cache.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果（菜谱数据）保存到缓存中。
- en: Return the recipe data.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回菜谱数据。
- en: 'The process is better illustrated through the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下图示可以更好地说明这个过程：
- en: '![Figure 9.1: Flask-Caching process flow chart'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：Flask-Caching流程图]'
- en: '](img/C15309_09_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C15309_09_01.jpg]'
- en: 'Figure 9.1: Flask-Caching process flow chart'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.1：Flask-Caching流程图
- en: By following this flow, you can see that data that is cached can be served before
    we query against the database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这个流程，您可以看到缓存的数据可以在我们查询数据库之前提供服务。
- en: I hope you have a better understanding of the theory behind caching. Let's roll
    up our sleeves and work on bringing this feature and our Smilecook application
    together, through the coming exercises.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您对缓存背后的理论有了更好的理解。让我们卷起袖子，通过接下来的练习，将这个功能和我们的Smilecook应用结合起来。
- en: 'Exercise 56: Implementing Caching Functionality Using Flask-Caching'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习56：使用Flask-Caching实现缓存功能
- en: 'In this exercise, we will be installing the Flask-Caching package. Then, we
    will implement the `cache` function in `RecipeListResource`. We will also add
    two decorators, `@app.before_request` and `@app.after_request`, to print application
    logs for easier testing:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将安装Flask-Caching包。然后，我们将在`RecipeListResource`中实现`cache`函数。我们还将添加两个装饰器，`@app.before_request`和`@app.after_request`，以打印应用程序日志，便于测试：
- en: 'Add the Flask-Caching package and version in `requirements.txt`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`requirements.txt`中添加Flask-Caching包和版本：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the `pip` command to install the package:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`pip`命令来安装包：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we have run the `install` command, we should see the following result:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们运行了 `install` 命令，我们应该看到以下结果：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import `Cache` in `extensions.py` and instantiate it:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `extensions.py` 中导入 `Cache` 并实例化它：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Import `cache` from `extensions` in `app.py`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.py` 中从 `extensions` 导入 `cache`：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In `app.py`, put in `cache.init_app(app)` under the `register_extensions` function.
    Pass in the `app` object to initialize the caching function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.py` 中，在 `register_extensions` 函数下添加 `cache.init_app(app)`。传递 `app` 对象以初始化缓存功能：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the caching-related configuration in `config.py`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `config.py` 中添加与缓存相关的配置：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The default `CACHE_TYPE` is `Null`, meaning there is no cache. Here, we set
    `CACHE_TYPE` as `simple`, which means we are going to use the `SimpleCache` strategy.
    The default expiration time is `10 * 60` seconds, which is 10 minutes.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认的 `CACHE_TYPE` 是 `Null`，表示没有缓存。这里，我们将 `CACHE_TYPE` 设置为 `simple`，这意味着我们将使用
    `SimpleCache` 策略。默认过期时间是 `10 * 60` 秒，即 10 分钟。
- en: 'Import `cache` from `extensions` in `resources/recipe.py`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/recipe.py` 中从 `extensions` 导入 `cache`：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `resources/recipe.py`, put the `cache` decorator in the `get` method of
    `RecipeListResource`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/recipe.py` 中，将 `cache` 装饰器放在 `RecipeListResource` 的 `get` 方法中：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are setting the cache expiration time (`timeout`) to be `60` seconds here.
    `query_string = True` means it allows the passing in of arguments.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里将缓存过期时间（`timeout`）设置为 `60` 秒。`query_string = True` 表示允许传递参数。
- en: 'For testing, print a line of `Querying database` in the `RecipeListResource.get`
    method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，在 `RecipeListResource.get` 方法中打印一行 `Querying database`：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For testing, in `app.py`, add in the following decorator definition at the
    bottom of the `register_extensions(app)` function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，在 `app.py` 的 `register_extensions(app)` 函数底部添加以下装饰器定义：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have already completed our first caching function on `RecipeListResource`.
    That should reduce the frequency of having to get recipes from the database. Let's
    test it out in our next exercise to make sure it works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `RecipeListResource` 上完成了第一个缓存功能。这应该会减少从数据库获取食谱的频率。让我们在下一个练习中测试它以确保它正常工作。
- en: 'Exercise 57: Testing the Caching Function with Postman'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 57：使用 Postman 测试缓存功能
- en: 'In this exercise, we will be using Postman to test the caching function. And
    we will verify whether it works or not in the PyCharm console:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 Postman 来测试缓存功能。并且我们将在 PyCharm 控制台中验证它是否正常工作：
- en: First, get all the recipe details back. Click on **GET** **RecipeList**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取所有食谱详情。点击 **GET** **RecipeList**。
- en: 'Then, send the request. The result is shown in the following screenshot:![Figure
    9.2: Getting all recipe details'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，发送请求。结果如下截图所示：![图 9.2：获取所有食谱详情
- en: '](img/C15309_09_02.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_09_02.jpg)'
- en: 'Figure 9.2: Getting all recipe details'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.2：获取所有食谱详情
- en: 'Check the application log in the PyCharm console.![Figure 9.3: Checking the
    application log'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 PyCharm 控制台中检查应用程序日志。![图 9.3：检查应用程序日志
- en: '](img/C15309_09_03.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_09_03.jpg)'
- en: 'Figure 9.3: Checking the application log'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.3：检查应用程序日志
- en: In the console, we can see that before the request, the cache is empty. After
    the database query, the data is cached and returned to the frontend client.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在控制台中，我们可以看到在请求之前，缓存是空的。在数据库查询之后，数据被缓存并返回给前端客户端。
- en: 'Get all the recipe details back again one more time and check the result in
    the PyCharm console:![Figure 9.4: Getting all the recipe details again'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取所有食谱详情并检查 PyCharm 控制台中的结果：![图 9.4：再次获取所有食谱详情
- en: '](img/C15309_09_04.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C15309_09_04.jpg)'
- en: 'Figure 9.4: Getting all the recipe details again'
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.4：再次获取所有食谱详情
- en: Because this is the second time that we are requesting the data, we get it from
    the cache rather than the database; the previous result was cached. We can see
    from the PyCharm console that the result was cached and no query to the database
    was fired.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我们第二次请求数据，所以我们从缓存中获取它，而不是从数据库中获取；之前的结果被缓存了。我们可以从 PyCharm 控制台中看到结果被缓存，并且没有对数据库的查询。
- en: So, we have completed the implementation and testing of the caching function
    here. Since we are just caching one record here, the performance gain may not
    be obvious. But imagine we were getting thousands of requests of the same kind
    in a short period of time; this caching functionality can greatly reduce the workload
    of our database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里完成了缓存功能的实现和测试。由于我们这里只是缓存了一条记录，性能提升可能不明显。但想象一下，如果我们在一个短时间内收到了数千个同类的请求；这种缓存功能可以大大减少我们数据库的工作量。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'If we want to see the data in the cache, we can use this line of code: `print(cache.cache._cache.items())`,
    to check the key-value stored there. There we can see that the value in the cache
    is the JSON data that we return to the client frontend.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看缓存中的数据，可以使用以下代码行：`print(cache.cache._cache.items())`，以检查存储在那里的键值。在那里我们可以看到缓存中的值是我们返回给客户端前端的
    JSON 数据。
- en: Clearing the Cache when Data Updates
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据更新时清除缓存
- en: When data is updated, the data that was cached before becomes stale immediately.
    For example, if the cover image of a recipe is updated, the old cover image is
    removed. But in the cache, there would still be the URL of the old cover image,
    which would no longer work. Therefore, we need a mechanism for clearing the old
    cache and storing the URL of the new cover image to our cache instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据更新时，之前缓存的那些数据立即变得过时。例如，如果食谱的封面图片被更新，旧的封面图片将被移除。但在缓存中，仍然会有旧封面图片的 URL，这将不再有效。因此，我们需要一个机制来清除旧缓存，并将新封面图片的
    URL 存储到我们的缓存中。
- en: 'Activity 16: Getting Cache Data after Updating Recipe Details'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 16：更新食谱详情后获取缓存数据
- en: 'When we get all the recipe details, they will be stored in the cache and can
    be used directly in the next request. In this activity, we will check to see what
    will happen when we try to get recipe details after updating the recipe data:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取所有食谱详情时，它们将被存储在缓存中，可以直接用于下一个请求。在这个活动中，我们将检查在更新食谱数据后尝试获取食谱详情会发生什么：
- en: First, get all the recipe details back.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，获取所有食谱详情。
- en: Update one of the recipe details.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新其中一个食谱详情。
- en: Get all the recipe details back again and check the recipe details.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取所有食谱详情并检查食谱详情。
- en: Note
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 340.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 340 页找到。
- en: In our next exercise, we shall find all the resources that are involved in updating
    data. We shall add a step to clear the cache after data is updated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个练习中，我们将找到所有涉及更新数据的资源。我们将在数据更新后添加一个清除缓存的步骤。
- en: 'Exercise 58: Implementing Cache-Clearing Functionality'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 58：实现缓存清除功能
- en: 'In this exercise, we will try to clear the cache when recipe data is updated.
    There are quite a few resources involved here. We shall tackle them one by one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试在更新食谱数据时清除缓存。这里涉及很多资源。我们将逐一解决它们：
- en: 'Import cache from extensions in utils.py:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 utils.py 中导入缓存：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new function under `utils.py` that is for clearing the cache. The
    function should clear the cache with a specific prefix:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `utils.py` 下创建一个新的用于清除缓存的功能。该函数应使用特定的前缀清除缓存：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the code is to use the `for` loop for `key` in `cache.cache._cache.keys()`
    to iterate all the keys in the cache. If the key is prefixed with the passed-in
    prefix, it will be placed on the `keys` list. Then, we will be using the `cache.delete_many`
    method to clear the cache. The single star, `*`, in the preceding code, is for
    unpacking the list into positional arguments.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，代码是使用 `for` 循环遍历 `cache.cache._cache.keys()` 中的 `key`，以迭代缓存中的所有键。如果键以传入的前缀开头，它将被放置在
    `keys` 列表中。然后，我们将使用 `cache.delete_many` 方法来清除缓存。前述代码中的单个星号 `*` 是用于将列表解包为位置参数。
- en: 'Import the `clear_cache` function in `resources/recipe.py`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/recipe.py` 中导入 `clear_cache` 函数：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Invoke `clear_cache(''/recipes'')` in the resources that update recipe data.
    In the `RecipeResource.patch`, `RecipeResource.delete`, `RecipePublishResource.put`,
    `RecipePublishResource.delete`, and `RecipeCoverUploadResource.put` methods, add
    in `clear_cache(''/recipes'')` before `return`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新食谱数据的资源中调用 `clear_cache('/recipes')`。在 `RecipeResource.patch`、`RecipeResource.delete`、`RecipePublishResource.put`、`RecipePublishResource.delete`
    和 `RecipeCoverUploadResource.put` 方法中，在 `return` 之前添加 `clear_cache('/recipes')`：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, here, if done properly, the old cache data will be cleared when the data
    is updated. Next time, when this updated data is requested, it will be stored
    in the cache again.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在这里，如果操作得当，当数据更新时，旧缓存数据将被清除。下次当请求这些更新后的数据时，它将再次存储在缓存中。
- en: 'Import the `generate_token`, `verify_token`, `save_image`, `clear_cache` function
    in `resources/user.py`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/user.py` 中导入 `generate_token`、`verify_token`、`save_image`、`clear_cache`
    函数：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Invoke `clear_cache(''/recipes'')` in `UserAvatarUploadResource.put` to clear
    the cache when data is updated:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UserAvatarUploadResource.put` 中调用 `clear_cache('/recipes')` 以在数据更新时清除缓存：
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the user updates their avatar image, that will change the `avatar_url`
    attribute. Therefore, we will need to clear the stale cache there as well.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户更新他们的头像图片时，这将改变 `avatar_url` 属性。因此，我们还需要在那里清除过时的缓存。
- en: After this exercise, I believe that you will have a much better understanding
    of how the whole flow of caching works. We build the caching function here to
    improve performance, but at the same time, we want to make sure that the cache
    is refreshed to ensure data quality.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习之后，我相信您将对整个缓存流程有更深入的理解。我们在这里构建缓存功能是为了提高性能，但同时我们还想确保缓存被刷新以保证数据质量。
- en: 'Exercise 59: Verifying the Cache-Clearing Function'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习59：验证缓存清除功能
- en: 'In our previous exercise, we added the step to clear the cache to the resources
    that are involved in data updates. In this activity, we will verify the cache-clearing
    function that we have implemented. We can test it by updating the data and seeing
    whether the API returns the updated data:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的练习中，我们将清除缓存的步骤添加到了涉及数据更新的资源中。在这个活动中，我们将验证我们实现的缓存清除功能。我们可以通过更新数据并查看API是否返回更新后的数据来测试它：
- en: 'Get all the recipe data back. Click on **RecipeList** and send the request.
    The result is shown in the following screenshot:![Figure 9.5: Get all the recipe
    data back and send the request'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有食谱数据。点击**RecipeList**并发送请求。结果如下所示：![图9.5：获取所有食谱数据并发送请求
- en: '](img/C15309_09_05.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_05.jpg)'
- en: 'Figure 9.5: Get all the recipe data back and send the request'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：获取所有食谱数据并发送请求
- en: 'Check the PyCharm console for the application log:![Figure 9.6: Checking the
    PyCharm console for the application log'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm控制台中检查应用程序日志：![图9.6：检查PyCharm控制台中的应用程序日志
- en: '](img/C15309_09_06.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_06.jpg)'
- en: 'Figure 9.6: Checking the PyCharm console for the application log'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：检查PyCharm控制台中的应用程序日志
- en: We can see that the cache is empty before the request. Then, after querying
    the database, the new data is cached.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到在请求之前缓存是空的。然后，在查询数据库后，新的数据被缓存。
- en: Log in to your account. Click on the **Collections** tab and select the **POST
    Token** request.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的账户。点击**Collections**标签并选择**POST Token**请求。
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    9.7: Selecting the POST Token request and sending the request'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下所示：![图9.7：选择POST Token请求并发送请求
- en: '](img/C15309_09_07.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_07.jpg)'
- en: 'Figure 9.7: Selecting the POST Token request and sending the request'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.7：选择POST Token请求并发送请求
- en: Modify a recipe record using the `PATCH` method. First, select the `PATCH Recipe`
    request. Now, select the `Bearer {token}`; the token should be the access token.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PATCH`方法修改食谱记录。首先，选择`PATCH Recipe`请求。现在，选择`Bearer {token}`；令牌应该是访问令牌。
- en: 'Select the `num_of_servings` to `10` and `cook_time` to `100`. Please check
    the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`num_of_servings`为`10`和`cook_time`为`100`。请检查以下内容：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    9.8: Modifying the recipe record using the PATCH method'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求。结果如下所示：![图9.8：使用PATCH方法修改食谱记录
- en: '](img/C15309_09_08.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_08.jpg)'
- en: 'Figure 9.8: Modifying the recipe record using the PATCH method'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.8：使用PATCH方法修改食谱记录
- en: 'Check the PyCharm console for the application log:![Figure 9.9: Checking the
    application log'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PyCharm控制台中检查应用程序日志：![图9.9：检查应用程序日志
- en: '](img/C15309_09_09.jpg)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_09.jpg)'
- en: 'Figure 9.9: Checking the application log'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.9：检查应用程序日志
- en: We can see that the cache is there before the request. But after the recipe
    record is updated, the cache becomes stale and is removed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在请求之前缓存是存在的。但是，在食谱记录更新后，缓存变得过时并被移除。
- en: So, in this exercise, we have completed the testing of the cache-clearing function.
    This will ensure that we are getting the latest data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个练习中，我们已经完成了缓存清除功能的测试。这将确保我们获取到最新的数据。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The printing of the application log is for testing only. Before we go on, we
    need to comment on the `print` command in `before_request` and `after_request`.
    We can do that by using *command + /* on a Mac, or *Ctrl + /* on a Windows machine.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序日志的打印仅用于测试。在我们继续之前，我们需要对`before_request`和`after_request`中的`print`命令进行注释。我们可以在Mac上使用*command
    + /*，或在Windows机器上使用*Ctrl + /*。
- en: API Rate Limiting
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API速率限制
- en: When we provide an API service, we need to ensure fair usage for every user
    so that the system resources are effectively and fairly serving all. We want to
    make sure that the majority of users are getting good server performance; therefore,
    we need to apply restrictions. By limiting a small number of high-traffic users,
    we can make sure that the majority of users are satisfied.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提供API服务时，我们需要确保每个用户都能公平使用，以便系统资源能够有效且公平地为所有用户服务。我们希望确保大多数用户都能获得良好的服务器性能；因此，我们需要施加限制。通过限制少数高流量用户，我们可以确保大多数用户都感到满意。
- en: The way to do that is to set a limit per user. For example, we can limit the
    number of requests per user to be no more than 100 per second. This number will
    be enough for the normal usage of our API. If there is any particular case where
    a user is firing 100+ requests per second, the excess requests will not be handled.
    This is to reserve system resources (such as CPU processing and bandwidth resources)
    for other users.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们需要为每个用户设置一个限制。例如，我们可以限制每个用户的请求次数不超过每秒`100`次。这个数字足以满足我们API的正常使用。如果用户在每秒发起`100`次以上的请求，超出的请求将不会被处理。这是为了为其他用户保留系统资源（如CPU处理和带宽资源）。
- en: To achieve this, we introduce the concept of rate-limiting. By limiting the
    "rate" of our API service per user, we guarantee that the majority of our users
    are able to enjoy the service performance they deserve.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们引入了速率限制的概念。通过限制每个用户的API服务“速率”，我们保证大多数用户能够享受到他们应得的服务性能。
- en: HTTP Headers and Response Codes
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP头信息和响应代码
- en: 'We can use HTTP headers to display rate limit information. The following attributes
    in the HTTP headers can tell us the number of requests (the rate) allowed, the
    remaining quota, and when the limit will be reset:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用HTTP头信息来显示速率限制信息。以下HTTP头信息中的属性可以告诉我们允许的请求数量（速率）、剩余配额以及限制何时将重置：
- en: '**X-RateLimit-Limit**: Shows the rate limit of this API endpoint'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-RateLimit-Limit**：显示此API端点的速率限制'
- en: '**X-RateLimit-Remaining**: Shows the number of remaining requests allowed before
    the next reset'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-RateLimit-Remaining**：显示下一次重置前允许的剩余请求数量'
- en: '**X-RateLimit-Reset**: When the rate limit will be reset (in UTC epoch time)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-RateLimit-Reset**：速率限制将被重置的时间（UTC纪元时间）'
- en: '**Retry-After**: The number of seconds before the next reset'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retry-After**：下一次重置前的秒数'
- en: 'When a user starts to violate the rate limit, the API will return the HTTP
    status code `Too Many Requests`, with the error message in the response body:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始违反速率限制时，API将返回HTTP状态码`Too Many Requests`，并在响应体中包含错误信息：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To implement this rate limit function, we can use the Flask extension package
    Flask-Limiter. The Flask-Limiter package can help us easily add the rate limit
    function to our APIs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此速率限制功能，我们可以使用Flask扩展包Flask-Limiter。Flask-Limiter包可以帮助我们轻松地将速率限制功能添加到我们的API中。
- en: Flask-Limiter
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask-Limiter
- en: '`RATELIMIT_HEADERS_ENABLED` configuration. We, therefore, don''t need to code
    the HTTP header information ourselves. Besides that, it also supports a configurable
    backend for storage with current implementations for Redis, in-memory, Memcached,
    and others.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`RATELIMIT_HEADERS_ENABLED`配置。因此，我们不需要自己编写HTTP头信息代码。除此之外，它还支持可配置的后端存储，当前实现包括Redis、内存、Memcached等。'
- en: We can even set multiple limits; we just need to delimit them using a delimiter.
    For example, we can set the limit to be `100` requests per minute and `1000` requests
    per hour, at the same time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以设置多个限制；我们只需要使用分隔符来界定它们。例如，我们可以同时设置每分钟`100`次请求和每小时`1000`次请求的限制。
- en: 'Use the following syntax to set up the rate limit for our API endpoint:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语法为我们的API端点设置速率限制：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here are some examples:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we understand how rate limits work. We will work on a practical exercise
    together to add this useful functionality to our Smilecook application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了速率限制的工作原理。我们将一起进行一个实际练习，将这个有用的功能添加到我们的Smilecook应用程序中。
- en: 'Exercise 60: Implementing API Rate-Limiting Functionality'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习60：实现API速率限制功能
- en: 'In this exercise, we will implement API rate-limiting functionality using `Flask-Limiter`.
    We will install and set `Flask-Limiter`, and then add the limit in rate-limit
    to `RecipeListResource`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`Flask-Limiter`实现API速率限制功能。我们将安装并设置`Flask-Limiter`，然后将其速率限制添加到`RecipeListResource`：
- en: 'Add `Flask-Limiter` version `1.0.1` to `requirements.txt`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Flask-Limiter`版本`1.0.1`添加到`requirements.txt`：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Install the package using the `pip install` command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip install`命令安装包：
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should be seeing the following installation result:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下安装结果：
- en: '[PRE23]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Import `Limiter` and `get_remote_address` in `extensions.py` and instantiate
    a `limiter` object:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `extensions.py` 中导入 `Limiter` 和 `get_remote_address` 并实例化一个 `limiter` 对象：
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `get_remote_address` function will return the IP address for the current
    request. If the IP address is not found, it will return `127.0.0.1`, which means
    the localhost. Here, our strategy is to limit the rate per IP address.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`get_remote_address` 函数将返回当前请求的 IP 地址。如果找不到 IP 地址，它将返回 `127.0.0.1`，这意味着本地主机。在这里，我们的策略是按
    IP 地址限制速率。'
- en: 'In `app.py`, import `limiter` from `extensions`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.py` 中从 `extensions` 导入 `limiter`：
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In `app.py`, initialize the `limiter` object under `register_extensions`. Pass
    in the `app` object to the `limiter.init_app` method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.py` 中，在 `register_extensions` 下初始化 `limiter` 对象。将 `app` 对象传递给 `limiter.init_app`
    方法：
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `config.py`, set `RATELIMIT_HEADERS_ENABLED` to `True`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `config.py` 中，将 `RATELIMIT_HEADERS_ENABLED` 设置为 `True`：
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will allow Flask-Limiter to put in rate limit-related information in the
    HTTP header, including **X-RateLimit-Limit**, **X-RateLimit-Remaining**, **X-RateLimit-Reset**,
    and **Retry-After**.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将允许 Flask-Limiter 在 HTTP 头中放入与速率限制相关的信息，包括 **X-RateLimit-Limit**、**X-RateLimit-Remaining**、**X-RateLimit-Reset**
    和 **Retry-After**。
- en: 'In `resources/recipe.py`, import `limiter` from `extensions`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `resources/recipe.py` 中从 `extensions` 导入 `limiter`：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In `RecipeListResource`, put the `limiter.limit` function in the `decorators`
    attribute:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipeListResource` 中，将 `limiter.limit` 函数放入 `decorators` 属性：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are setting the number of requests to be only two per minute. The HTTP method
    is `GET` and the error message is `Too Many Requests`.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将请求次数设置为每分钟仅两个。HTTP 方法是 `GET`，错误信息是 `Too Many Requests`。
- en: 'Click **Run** to start the Flask application; then, we are ready to test it:![Figure
    9.10: Start the Flask application and then test it'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **运行** 以启动 Flask 应用程序；然后，我们就可以测试它了：![图 9.10：启动 Flask 应用程序然后测试
- en: '](img/C15309_09_10.jpg)'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_10.jpg)'
- en: 'Figure 9.10: Start the Flask application and then test it'
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.10：启动 Flask 应用程序然后测试
- en: Now that this exercise is complete, our API has rate-limiting functionality.
    In the next exercise, we have to test our rate limit function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个练习已经完成，我们的 API 已经有了速率限制功能。在下一个练习中，我们必须测试我们的速率限制函数。
- en: 'Exercise 61: Verifying the Rate-Limit Function'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 61：验证速率限制功能
- en: 'In the last exercise, we set the API for getting all recipe details, which
    can only be obtained twice per minute. So, in this exercise, we will see whether
    the result is what we expected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们设置了获取所有食谱详情的 API，每分钟只能获取两次。所以，在这个练习中，我们将看到结果是否符合我们的预期：
- en: Get all the recipe data back. Click on GET `RecipeList` and send the request.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有食谱数据。点击 GET `RecipeList` 并发送请求。
- en: Select the `60` seconds later.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `60` 秒后。
- en: Get all the recipe data back again and send the request twice more.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取所有食谱数据并发送两次请求。
- en: 'Select the **Body** in the HTTP response. The result is shown in the following
    screenshot:![Figure 9.12: Getting all the recipe data back again and sending the
    request twice'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTTP 响应中选择 **Body**。结果如下截图所示：![图 9.12：再次获取所有食谱数据并发送两次请求
- en: '](img/C15309_09_12.jpg)'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C15309_09_12.jpg)'
- en: 'Figure 9.12: Getting all the recipe data back again and sending the request
    twice'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.12：再次获取所有食谱数据并发送两次请求
- en: We can see that at the third request, we will receive the error HTTP status
    code **429 TOO MANY REQUESTS**. That means the rate limit is working.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在第三次请求时，我们将收到错误 HTTP 状态码 **429 太多请求**。这意味着速率限制正在起作用。
- en: In this exercise, we have completed the rate limit function. By restricting
    a small number of abusive users, we ensure that the majority of users can enjoy
    high servicing performance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经完成了速率限制功能。通过限制少量滥用用户，我们确保大多数用户可以享受高性能的服务。
- en: 'Exercise 62: Adding a Whitelist'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 62：添加白名单
- en: We want to ease the rate limit for our developers, the testers of the API, because
    they may indeed need to fire frequent requests to the APIs for testing. What should
    we do in this case? In this exercise, we shall see how we can use Flask-Limiter
    to satisfy this requirement.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望减轻我们开发人员和 API 测试人员的速率限制，因为他们可能确实需要频繁地向 API 发送请求进行测试。在这种情况下我们应该怎么做？在这个练习中，我们将看到如何使用
    Flask-Limiter 来满足这一要求。
- en: 'We would like to set up an IP whitelist that can allow certain IP addresses
    to use the API without any rate limit:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望设置一个 IP 白名单，允许某些 IP 地址使用 API 而不受任何速率限制：
- en: 'In `app.py`, import `request`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.py` 中导入 `request`：
- en: '[PRE30]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `app.py`, use the `@limiter.request_filter` decorator and set up the whitelist
    function. Put `127.0.0.1` (localhost) in the whitelist:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.py`中，使用`@limiter.request_filter`装饰器并设置白名单函数。将`127.0.0.1`（本地主机）放入白名单中：
- en: '[PRE31]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run `app.py`:![Figure 9.13: Running the app.py file'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`app.py`：![图9.13：运行app.py文件
- en: '](img/C15309_09_13.jpg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图C15309_09_13.jpg](img/C15309_09_13.jpg)'
- en: 'Figure 9.13: Running the app.py file'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.13：运行app.py文件
- en: 'Test the application by firing a `GET` all recipe request, and check the HTTP
    header for the rate limit. Click on `GET RecipeList` and send the request. Select
    the **Header** tab in **Response**. The result is shown in the following screenshot:![Figure
    9.14: Checking the HTTP header for rate limit'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过发送一个获取所有菜谱的`GET`请求来测试应用程序，并检查HTTP头部的速率限制。点击`GET RecipeList`并发送请求。在**响应**中选择**Header**选项卡。结果如下所示：![图9.14：检查速率限制的HTTP头部
- en: '](img/C15309_09_14.jpg)'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图C15309_09_14.jpg](img/C15309_09_14.jpg)'
- en: 'Figure 9.14: Checking the HTTP header for rate limit'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '![图9.14：检查速率限制的HTTP头部'
- en: We can see that the rate-limit restriction is gone. In this exercise, you have
    seen that the rate-limiting function can be flexible. It can be enacted or withdrawn
    depending on different situations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到速率限制已经消失。在这个练习中，您已经看到速率限制功能可以灵活运用。它可以根据不同的情况实施或撤销。
- en: 'Activity 17: Adding Multiple Rate-Limit Restrictions'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动十七：添加多个速率限制
- en: 'In this activity, we are going to add multiple rate-limit restrictions to the
    same resource. But remember, we added a whitelist to the previous exercise. We
    need to comment out that code, so we can test it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将向同一资源添加多个速率限制。但请记住，我们在之前的练习中添加了一个白名单。我们需要注释掉这段代码，以便我们可以进行测试：
- en: In `UserRecipeListResource`, add the rate limit. The limit is `3` times per
    minute, `30` times per hour, and `300` times a day.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserRecipeListResource`中添加速率限制。限制为每分钟`3`次，每小时`30`次，每天`300`次。
- en: Comment out the whitelist code.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉白名单代码。
- en: Test the rate limit function using Postman.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman测试速率限制功能。
- en: Note
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 343.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第343页找到。
- en: Congratulations! Now that you have completed this activity, you know how to
    flexibly use the rate-limiting function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在您已经完成了这个活动，您知道如何灵活地使用速率限制功能。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about and implemented caching and rate-limiting
    functions in our Smilecook API. Such functions make our APIs even more efficient.
    Our Smilecook application is saving the cache in application memory, though, which
    means the cache will be gone after a server reboot. To address this, we can work
    with Redis or Memcached in the future, which can persist the cache even after
    a server reboot. They also support sharing the cache with multiple servers. This
    is something we encourage you to explore outside of this book. The most important
    thing at the moment is for you to learn all the fundamental concepts covered in
    this book. So, later, if you want to extend to more advanced implementation, it
    shouldn't be too hard for you.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了并在Smilecook API中实现了缓存和速率限制功能。这些功能使我们的API更加高效。然而，我们的Smilecook应用程序将缓存保存在应用内存中，这意味着在服务器重启后缓存将消失。为了解决这个问题，我们可以在未来与Redis或Memcached一起工作，它们可以在服务器重启后持久化缓存。它们还支持多个服务器之间的缓存共享。这是我们鼓励您在本书之外探索的内容。目前最重要的事情是您要学习本书中涵盖的所有基本概念。因此，如果您以后想要扩展到更高级的实现，这对您来说应该不会太难。
- en: In the next and final chapter, we will build the Smilecook frontend client for
    you to work with the backend API. Through this frontend client, we will understand
    the whole picture better. You will see how the frontend and backend interact.
    Finally, we will deploy the whole application to the Heroku cloud platform, which
    means our Smilecook application will be used by everybody.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将为您构建Smilecook前端客户端，以便您与后端API协同工作。通过这个前端客户端，我们将更好地理解整体情况。您将看到前端和后端的交互方式。最后，我们将整个应用程序部署到Heroku云平台，这意味着我们的Smilecook应用程序将被每个人使用。
