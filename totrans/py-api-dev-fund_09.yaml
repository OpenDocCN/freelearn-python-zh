- en: 9\. Building More Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use caching to improve API performance and efficiently get the latest information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the cache function to the Smilecook application using the Flask-Caching
    package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement rate-limiting functionality to an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use IP address to perform rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will cover caching to improve performance and get accustomed
    to using the rate-limiting function.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added pagination, searching, and ordering functions to our Smilecook application
    in our last chapter so that users can navigate to their recipes much easier. This
    also helps to reduce the server burden and improve performance. We have explained
    how making our APIs snappy is important in today's world.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be further improving our API performance from another
    aspect. We will be adding in the `cache` function, which will temporarily save
    data to the application memory. This will allow us to save the time required to
    query the database every time. This can greatly improve API performance and reduce
    server burden. There is a Flask extension package, Flask-Caching, that can help
    us in implementing the caching function. We will first talk about the theory behind
    caching, and through practical exercises, we show you how to implement this function
    in our Smilecook application.
  prefs: []
  type: TYPE_NORMAL
- en: Besides caching, we will implement a rate-limiting function. That will prevent
    certain high-usage users from jeopardizing the whole system by limiting their
    usage. Ensuring fair usage of our APIs is crucial to guarantee service quality.
    We will be using a Flask extension package, `Flask-Limiter`, for that.
  prefs: []
  type: TYPE_NORMAL
- en: These two caching and rate-limiting functions are very common and powerful in
    real-world scenarios. Let's learn about how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Caching** means storing data in a temporary space (a cache) so that it can
    be retrieved faster in subsequent requests. The temporary space can be application
    memory, server hard disk space, or something else. The whole purpose of caching
    is to lighten the workload by avoiding any heavy processes for querying the data
    again. For example, in our Smilecook application, if we reckon that the recipes
    from a popular author will always get queried by the users, we can cache these
    recipes. So, the next time that users ask for these recipes, we can just send
    back the recipes in the cache instead of querying against our database. You can
    see caching everywhere. Almost all applications have caching implemented nowadays.
    Even in our local browsers, we save website results on the local hard disk to
    achieve faster access next time.'
  prefs: []
  type: TYPE_NORMAL
- en: For server-level caching, most of the time, the cache is stored in the same
    web server as the application. But technically speaking, it can be stored in another
    server as well, such as **Redis** (**Remote Dictionary Server**) or **Memcached**
    (a high-performance distributed cached memory). They are all in-memory data storage
    systems that allow key-value storage as well as storing data. For simple applications
    and easy implementation, we can also use a single global dictionary as a cache
    (simple cache).
  prefs: []
  type: TYPE_NORMAL
- en: Benefit of Caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Through caching, not only can we reduce the volume of data to be transferred,
    but we can also improve the overall performance. This is done by reducing the
    bandwidth required, reducing the server loading time, and more. Take our Smilecook
    application as an example: if we have a low traffic, caching may not be a lot
    of help, because the cache will pretty much expire before the next query comes
    in. But imagine that we have high traffic, say, 10,000 requests per minute, coming
    in asking for recipes. If these recipes are all cached and the cache has not expired,
    we will be able to simply return the recipes in the cache to the client frontend.
    In this scenario, we would be saving 10,000 database queries, which could be a
    substantial cost-saving measure.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`cache` as a dictionary object that contains key-value pairs. The key here
    is used to specify the resource to `cache`, whereas the value is used to store
    the actual data to be cached. Take the resource for retrieving all the recipes
    as an example. The flow contains the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the get `/recipes` resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the key to search for the existing cache (Flask-Caching will be using `request.path`
    and `hashed_args` to be the key value, for example, `recipesbcd8b0c2eb1fce714eab6cef0d771acc`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the recipes were previously cached, return the cached data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no cache for these recipes exists, follow the standard flow to get the recipes
    from the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the result (the recipe data) in the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the recipe data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The process is better illustrated through the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Flask-Caching process flow chart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Flask-Caching process flow chart'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By following this flow, you can see that data that is cached can be served before
    we query against the database.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you have a better understanding of the theory behind caching. Let's roll
    up our sleeves and work on bringing this feature and our Smilecook application
    together, through the coming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 56: Implementing Caching Functionality Using Flask-Caching'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be installing the Flask-Caching package. Then, we
    will implement the `cache` function in `RecipeListResource`. We will also add
    two decorators, `@app.before_request` and `@app.after_request`, to print application
    logs for easier testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Flask-Caching package and version in `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `pip` command to install the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we have run the `install` command, we should see the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `Cache` in `extensions.py` and instantiate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `cache` from `extensions` in `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app.py`, put in `cache.init_app(app)` under the `register_extensions` function.
    Pass in the `app` object to initialize the caching function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the caching-related configuration in `config.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The default `CACHE_TYPE` is `Null`, meaning there is no cache. Here, we set
    `CACHE_TYPE` as `simple`, which means we are going to use the `SimpleCache` strategy.
    The default expiration time is `10 * 60` seconds, which is 10 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import `cache` from `extensions` in `resources/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `resources/recipe.py`, put the `cache` decorator in the `get` method of
    `RecipeListResource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are setting the cache expiration time (`timeout`) to be `60` seconds here.
    `query_string = True` means it allows the passing in of arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For testing, print a line of `Querying database` in the `RecipeListResource.get`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For testing, in `app.py`, add in the following decorator definition at the
    bottom of the `register_extensions(app)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have already completed our first caching function on `RecipeListResource`.
    That should reduce the frequency of having to get recipes from the database. Let's
    test it out in our next exercise to make sure it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 57: Testing the Caching Function with Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be using Postman to test the caching function. And
    we will verify whether it works or not in the PyCharm console:'
  prefs: []
  type: TYPE_NORMAL
- en: First, get all the recipe details back. Click on **GET** **RecipeList**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, send the request. The result is shown in the following screenshot:![Figure
    9.2: Getting all recipe details'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.2: Getting all recipe details'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the application log in the PyCharm console.![Figure 9.3: Checking the
    application log'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.3: Checking the application log'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: In the console, we can see that before the request, the cache is empty. After
    the database query, the data is cached and returned to the frontend client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get all the recipe details back again one more time and check the result in
    the PyCharm console:![Figure 9.4: Getting all the recipe details again'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.4: Getting all the recipe details again'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because this is the second time that we are requesting the data, we get it from
    the cache rather than the database; the previous result was cached. We can see
    from the PyCharm console that the result was cached and no query to the database
    was fired.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have completed the implementation and testing of the caching function
    here. Since we are just caching one record here, the performance gain may not
    be obvious. But imagine we were getting thousands of requests of the same kind
    in a short period of time; this caching functionality can greatly reduce the workload
    of our database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we want to see the data in the cache, we can use this line of code: `print(cache.cache._cache.items())`,
    to check the key-value stored there. There we can see that the value in the cache
    is the JSON data that we return to the client frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the Cache when Data Updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When data is updated, the data that was cached before becomes stale immediately.
    For example, if the cover image of a recipe is updated, the old cover image is
    removed. But in the cache, there would still be the URL of the old cover image,
    which would no longer work. Therefore, we need a mechanism for clearing the old
    cache and storing the URL of the new cover image to our cache instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16: Getting Cache Data after Updating Recipe Details'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we get all the recipe details, they will be stored in the cache and can
    be used directly in the next request. In this activity, we will check to see what
    will happen when we try to get recipe details after updating the recipe data:'
  prefs: []
  type: TYPE_NORMAL
- en: First, get all the recipe details back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update one of the recipe details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get all the recipe details back again and check the recipe details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 340.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our next exercise, we shall find all the resources that are involved in updating
    data. We shall add a step to clear the cache after data is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 58: Implementing Cache-Clearing Functionality'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will try to clear the cache when recipe data is updated.
    There are quite a few resources involved here. We shall tackle them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import cache from extensions in utils.py:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new function under `utils.py` that is for clearing the cache. The
    function should clear the cache with a specific prefix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the code is to use the `for` loop for `key` in `cache.cache._cache.keys()`
    to iterate all the keys in the cache. If the key is prefixed with the passed-in
    prefix, it will be placed on the `keys` list. Then, we will be using the `cache.delete_many`
    method to clear the cache. The single star, `*`, in the preceding code, is for
    unpacking the list into positional arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `clear_cache` function in `resources/recipe.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke `clear_cache(''/recipes'')` in the resources that update recipe data.
    In the `RecipeResource.patch`, `RecipeResource.delete`, `RecipePublishResource.put`,
    `RecipePublishResource.delete`, and `RecipeCoverUploadResource.put` methods, add
    in `clear_cache(''/recipes'')` before `return`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, here, if done properly, the old cache data will be cleared when the data
    is updated. Next time, when this updated data is requested, it will be stored
    in the cache again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the `generate_token`, `verify_token`, `save_image`, `clear_cache` function
    in `resources/user.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke `clear_cache(''/recipes'')` in `UserAvatarUploadResource.put` to clear
    the cache when data is updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the user updates their avatar image, that will change the `avatar_url`
    attribute. Therefore, we will need to clear the stale cache there as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After this exercise, I believe that you will have a much better understanding
    of how the whole flow of caching works. We build the caching function here to
    improve performance, but at the same time, we want to make sure that the cache
    is refreshed to ensure data quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 59: Verifying the Cache-Clearing Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our previous exercise, we added the step to clear the cache to the resources
    that are involved in data updates. In this activity, we will verify the cache-clearing
    function that we have implemented. We can test it by updating the data and seeing
    whether the API returns the updated data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get all the recipe data back. Click on **RecipeList** and send the request.
    The result is shown in the following screenshot:![Figure 9.5: Get all the recipe
    data back and send the request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.5: Get all the recipe data back and send the request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the PyCharm console for the application log:![Figure 9.6: Checking the
    PyCharm console for the application log'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.6: Checking the PyCharm console for the application log'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that the cache is empty before the request. Then, after querying
    the database, the new data is cached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Log in to your account. Click on the **Collections** tab and select the **POST
    Token** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    9.7: Selecting the POST Token request and sending the request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.7: Selecting the POST Token request and sending the request'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Modify a recipe record using the `PATCH` method. First, select the `PATCH Recipe`
    request. Now, select the `Bearer {token}`; the token should be the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `num_of_servings` to `10` and `cook_time` to `100`. Please check
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the request. The result is shown in the following screenshot:![Figure
    9.8: Modifying the recipe record using the PATCH method'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.8: Modifying the recipe record using the PATCH method'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Check the PyCharm console for the application log:![Figure 9.9: Checking the
    application log'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.9: Checking the application log'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that the cache is there before the request. But after the recipe
    record is updated, the cache becomes stale and is removed.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this exercise, we have completed the testing of the cache-clearing function.
    This will ensure that we are getting the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The printing of the application log is for testing only. Before we go on, we
    need to comment on the `print` command in `before_request` and `after_request`.
    We can do that by using *command + /* on a Mac, or *Ctrl + /* on a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: API Rate Limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we provide an API service, we need to ensure fair usage for every user
    so that the system resources are effectively and fairly serving all. We want to
    make sure that the majority of users are getting good server performance; therefore,
    we need to apply restrictions. By limiting a small number of high-traffic users,
    we can make sure that the majority of users are satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: The way to do that is to set a limit per user. For example, we can limit the
    number of requests per user to be no more than 100 per second. This number will
    be enough for the normal usage of our API. If there is any particular case where
    a user is firing 100+ requests per second, the excess requests will not be handled.
    This is to reserve system resources (such as CPU processing and bandwidth resources)
    for other users.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we introduce the concept of rate-limiting. By limiting the
    "rate" of our API service per user, we guarantee that the majority of our users
    are able to enjoy the service performance they deserve.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Headers and Response Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use HTTP headers to display rate limit information. The following attributes
    in the HTTP headers can tell us the number of requests (the rate) allowed, the
    remaining quota, and when the limit will be reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X-RateLimit-Limit**: Shows the rate limit of this API endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X-RateLimit-Remaining**: Shows the number of remaining requests allowed before
    the next reset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**X-RateLimit-Reset**: When the rate limit will be reset (in UTC epoch time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retry-After**: The number of seconds before the next reset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a user starts to violate the rate limit, the API will return the HTTP
    status code `Too Many Requests`, with the error message in the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To implement this rate limit function, we can use the Flask extension package
    Flask-Limiter. The Flask-Limiter package can help us easily add the rate limit
    function to our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Limiter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RATELIMIT_HEADERS_ENABLED` configuration. We, therefore, don''t need to code
    the HTTP header information ourselves. Besides that, it also supports a configurable
    backend for storage with current implementations for Redis, in-memory, Memcached,
    and others.'
  prefs: []
  type: TYPE_NORMAL
- en: We can even set multiple limits; we just need to delimit them using a delimiter.
    For example, we can set the limit to be `100` requests per minute and `1000` requests
    per hour, at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following syntax to set up the rate limit for our API endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we understand how rate limits work. We will work on a practical exercise
    together to add this useful functionality to our Smilecook application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 60: Implementing API Rate-Limiting Functionality'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will implement API rate-limiting functionality using `Flask-Limiter`.
    We will install and set `Flask-Limiter`, and then add the limit in rate-limit
    to `RecipeListResource`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `Flask-Limiter` version `1.0.1` to `requirements.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the package using the `pip install` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should be seeing the following installation result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `Limiter` and `get_remote_address` in `extensions.py` and instantiate
    a `limiter` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `get_remote_address` function will return the IP address for the current
    request. If the IP address is not found, it will return `127.0.0.1`, which means
    the localhost. Here, our strategy is to limit the rate per IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `app.py`, import `limiter` from `extensions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app.py`, initialize the `limiter` object under `register_extensions`. Pass
    in the `app` object to the `limiter.init_app` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `config.py`, set `RATELIMIT_HEADERS_ENABLED` to `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow Flask-Limiter to put in rate limit-related information in the
    HTTP header, including **X-RateLimit-Limit**, **X-RateLimit-Remaining**, **X-RateLimit-Reset**,
    and **Retry-After**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `resources/recipe.py`, import `limiter` from `extensions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `RecipeListResource`, put the `limiter.limit` function in the `decorators`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are setting the number of requests to be only two per minute. The HTTP method
    is `GET` and the error message is `Too Many Requests`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click **Run** to start the Flask application; then, we are ready to test it:![Figure
    9.10: Start the Flask application and then test it'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.10: Start the Flask application and then test it'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that this exercise is complete, our API has rate-limiting functionality.
    In the next exercise, we have to test our rate limit function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 61: Verifying the Rate-Limit Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last exercise, we set the API for getting all recipe details, which
    can only be obtained twice per minute. So, in this exercise, we will see whether
    the result is what we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the recipe data back. Click on GET `RecipeList` and send the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `60` seconds later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get all the recipe data back again and send the request twice more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Body** in the HTTP response. The result is shown in the following
    screenshot:![Figure 9.12: Getting all the recipe data back again and sending the
    request twice'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.12: Getting all the recipe data back again and sending the request
    twice'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that at the third request, we will receive the error HTTP status
    code **429 TOO MANY REQUESTS**. That means the rate limit is working.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have completed the rate limit function. By restricting
    a small number of abusive users, we ensure that the majority of users can enjoy
    high servicing performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 62: Adding a Whitelist'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to ease the rate limit for our developers, the testers of the API, because
    they may indeed need to fire frequent requests to the APIs for testing. What should
    we do in this case? In this exercise, we shall see how we can use Flask-Limiter
    to satisfy this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to set up an IP whitelist that can allow certain IP addresses
    to use the API without any rate limit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.py`, import `request`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app.py`, use the `@limiter.request_filter` decorator and set up the whitelist
    function. Put `127.0.0.1` (localhost) in the whitelist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `app.py`:![Figure 9.13: Running the app.py file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.13: Running the app.py file'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Test the application by firing a `GET` all recipe request, and check the HTTP
    header for the rate limit. Click on `GET RecipeList` and send the request. Select
    the **Header** tab in **Response**. The result is shown in the following screenshot:![Figure
    9.14: Checking the HTTP header for rate limit'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_09_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.14: Checking the HTTP header for rate limit'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that the rate-limit restriction is gone. In this exercise, you have
    seen that the rate-limiting function can be flexible. It can be enacted or withdrawn
    depending on different situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 17: Adding Multiple Rate-Limit Restrictions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we are going to add multiple rate-limit restrictions to the
    same resource. But remember, we added a whitelist to the previous exercise. We
    need to comment out that code, so we can test it:'
  prefs: []
  type: TYPE_NORMAL
- en: In `UserRecipeListResource`, add the rate limit. The limit is `3` times per
    minute, `30` times per hour, and `300` times a day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the whitelist code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the rate limit function using Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 343.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Congratulations! Now that you have completed this activity, you know how to
    flexibly use the rate-limiting function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have learned about and implemented caching and rate-limiting
    functions in our Smilecook API. Such functions make our APIs even more efficient.
    Our Smilecook application is saving the cache in application memory, though, which
    means the cache will be gone after a server reboot. To address this, we can work
    with Redis or Memcached in the future, which can persist the cache even after
    a server reboot. They also support sharing the cache with multiple servers. This
    is something we encourage you to explore outside of this book. The most important
    thing at the moment is for you to learn all the fundamental concepts covered in
    this book. So, later, if you want to extend to more advanced implementation, it
    shouldn't be too hard for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will build the Smilecook frontend client for
    you to work with the backend API. Through this frontend client, we will understand
    the whole picture better. You will see how the frontend and backend interact.
    Finally, we will deploy the whole application to the Heroku cloud platform, which
    means our Smilecook application will be used by everybody.
  prefs: []
  type: TYPE_NORMAL
