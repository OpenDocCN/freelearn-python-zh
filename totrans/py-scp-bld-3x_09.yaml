- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **driver** is a function that controls the value of a property. It can take
    the value of other properties as input, creating a connection between two or more
    properties. For example, a driver might set the *X* location of an object based
    on the rotation of another object.
  prefs: []
  type: TYPE_NORMAL
- en: Drivers are similar to animations, with which they share the update system and
    f-curve data but are way more flexible and can be combined with Python to create
    custom setups.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are an essential part of technical animation and are used for creating
    simple controls or complex mechanics. Drivers don’t have a specific purpose: they
    are designed to create custom behaviors. For that reason, they are ubiquitous
    in rigging and help connect properties, even between entities of different types,
    such as objects and shaders.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create and test your Python drivers easily,
    as well as how to script their creation. Besides helping with automating rig mechanics,
    this knowledge will also make it easier for you to understand formulas and implement
    them in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python expressions in drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting mathematic formulas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating the driver setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and **Visual Studio Code** in this chapter, but any IDE
    will do. The examples that were created for this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch9](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch9).
  prefs: []
  type: TYPE_NORMAL
- en: Creating drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The procedure for creating **drivers** is very similar to the one for creating
    animations. While the animation time is the only input of animation curves, drivers
    can depend on one or more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The result of Python expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any property that can be animated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transform channels of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference in rotations between objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we create a driver, we must specify at least one input. In this section,
    we will learn how to set up a simple wheel by creating new drivers with the user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating quick drivers via the right-click menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few shortcuts for creating drivers quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example to understand these shortcuts. Suppose that,
    to animate a wheel, we want an object’s **Location Y** to drive its **Rotation
    X** channel. We can set this up for Blender’s default cube:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the default **Cube** to make it active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *N* to display the Transform properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Location Y** is our input. Rather than look for its data path, we will copy
    it to the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Location Y** to display the **Y:** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, pick **Copy As** **New Driver**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The driver doesn’t exist yet, so we must create it for the property we want
    to affect:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on **Rotation X** to display the **X:** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, pick **Paste Driver**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Rotation X** channel will be colored purple, which is the color that’s
    used for driven properties. Moving the **Cube** object along its **Y**-axis will
    also make it roll:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The Y location drives the X rotation](img/Figure_9.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The Y location drives the X rotation'
  prefs: []
  type: TYPE_NORMAL
- en: The driver that’s using `5` radians is equivalent to about `286` degrees of
    rotation, as reflected in the values we can see in *Figure 9**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switching **Rotation Unit** to **Radians**, as shown in *Figure 9**.2*, makes
    a one-to-one relationship between **Location Y** and **Rotation** **X** evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Location X and Rotation X display the same value using radians](img/Figure_9.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Location X and Rotation X display the same value using radians'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the cube rolls when it is moved, it doesn’t look like a wheel: a wheel
    rotates the other way around. We can set that up using the **Drivers** **Editor**
    area.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a wheel with the Drivers Editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the **Drivers Editor** area, we can display and edit the drivers of the
    objects present in the scene. It can be brought up following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on a **Driven Property**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Open** **Drivers Editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s very similar to the **Graph Editor** area that we looked at in first *section*
    of [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), except it displays drivers
    rather than animation curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The driver f-curve in the Drivers Editor area](img/Figure_9.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The driver f-curve in the Drivers Editor area'
  prefs: []
  type: TYPE_NORMAL
- en: We can get a better view of the curve by selecting **View** | **Frame All**
    from the **Drivers Editor** menu bar or pressing *Home* on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The default driver’s f-curve is the diagonal of the positive cartesian plane,
    with control points at coordinates (`0.0`, `0.0`) and (`1.0`, `1.0`). We can see
    that the result of the curve, displayed in the `5.0`, the same value as the **location**
    input variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the rotation of a wheel is opposite to its motion, we need to invert
    that result by changing the curve. To do that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Drivers Editor** properties, select the **F-Curve** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the top-right point of the f-curve by left-clicking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `1.0` to `-1.0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4: The driver’s f-curve pointing downwards](img/Figure_9.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The driver’s f-curve pointing downwards'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, moving the cube over its **Y**-axis makes it roll in the right direction.
    If you look carefully, something will still be off: this driver is rolling slightly
    too slowly.'
  prefs: []
  type: TYPE_NORMAL
- en: The ratio between a circle of size 1 and the length it covers in one round is
    π, the mathematical constant pi, which is approximately 3.14.
  prefs: []
  type: TYPE_NORMAL
- en: That distance only takes a half round to a wheel twice as large, like our default
    cube of size `2` x `2` x `2`, so typing `pi/2` in the `1.571`, a multiplier slightly
    faster than `1`. Translating the cube on its **Y**-axis now makes it roll like
    a wheel, albeit a square one.
  prefs: []
  type: TYPE_NORMAL
- en: We used a division to get that result, but we can also use Python formulas in
    drivers. We can also create drivers by just typing a formula.
  prefs: []
  type: TYPE_NORMAL
- en: Creating driver expressions in properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A different type of driver, one that relies on Python math formulas, can be
    created by typing a hash symbol (`#`) in a property field. Here are the steps
    for creating a driver expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the default cube to make it active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the `rotation_euler.x` property to edit its value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `#sin(frame)` and press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9\. 5: Typing Python expressions in object properties](img/Figure_9.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9\. 5: Typing Python expressions in object properties'
  prefs: []
  type: TYPE_NORMAL
- en: The expression we have just written is already active. If we start the playback
    by pressing the triangular **Play** button in the **media controls** area, or
    with *Alt* + *A*, the cube will jitter quickly on its **X**-axis.
  prefs: []
  type: TYPE_NORMAL
- en: The `sin(frame)` expression depends on time, as animations do, but the value
    per frame is the output of a Python instruction, and we can enrich it for more
    complex results.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will combine the `frame` variable, the `sin` function,
    and the driver inputs to create a procedural, parametric animation of a pendulum.
  prefs: []
  type: TYPE_NORMAL
- en: We DON’T want results!
  prefs: []
  type: TYPE_NORMAL
- en: Omitting the `#` symbol will set the result of the expression rather than creating
    a driver. Typing `frame` sets the property to the numeric value of the current
    frame, such as `1` or `24`. If we type `#frame`, the value will change as we play
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Driving a cyclic motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pendulum is a weight suspended from a fixed point, free to swing back and
    forth. It has many real-life applications in time, gravity, and geographic measurements,
    while in 3D, an oscillating motion is used for displaying clock mechanisms, hanging
    props, and other cyclic motions. The trigonometric function **sine** is commonly
    used to simulate this kind of motion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sin` function from the `math` module is the Python syntax for *sine*.
    We encountered *sine* in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), where
    we used its inverse, *arcsine*, to orient objects using Python. Sine is a periodic
    wave function – it repeats itself at fixed intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: The sine function](img/Figure_9.6_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The sine function'
  prefs: []
  type: TYPE_NORMAL
- en: Playing the animation will make the cube jitter very fast. To slow it down,
    we can click **Driven Property** and give the formula a slower pace.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we can change it to `sin(frame/10)` and it will slow down tenfold.
    Now, the cube rocks back and forth gently. We can do even better and set up a
    rotation pivot for a proper swing.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the rotation pivot via constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easier way to affect an object’s pivot is by using **constraints**. We came
    across constraints in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075), and used
    them to change an object’s position without altering its transform properties.
    This time, we will use a **Pivot Constraint** to alter the center of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Pivot Constraint in Blender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **Pivot Constraint** moves an object’s center of rotation to a different
    object’s position or specific coordinates. We are going to use an **Empty**, a
    Blender object that doesn’t contain any geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty to the scene via **Add** | **Empty** | **Plain Axes** from the
    **3D View** area. This object will be the new rotation pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move this **Empty** somewhere above the **Cube** object so that it can act as
    a suspension point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can create the constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Cube** object and reach its **Constraints** tab in the properties.
    It is marked with the icon of a connection rod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **Pivot** from the **Add Object Constraint** drop-down. A new constraint
    will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7: Creating a Pivot Constraint](img/Figure_9.07_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Creating a Pivot Constraint'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Target** field in the **Pivot Constraint** panel, and select **Empty**
    among the list of objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click the **Rotation Range** property and change it to **Always** so that
    rotations in all directions are affected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we play the animation, the cube oscillates left and right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: The Pivot Constraint changing the rotation center of the Cube
    object](img/Figure_9.08_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: The Pivot Constraint changing the rotation center of the Cube object'
  prefs: []
  type: TYPE_NORMAL
- en: It starts to look like a pendulum, but the speed of a swinging motion should
    depend on the length of the cord, which we are not considering in our formula.
    To improve our driver, we must learn how the sine function works and how to control
    its period. Then, we must study pendulum physics and write an expression that
    takes the cord length into account.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the period of the sin function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To have better control of the sine period, we need to observe its graph, as
    shown in *Figure 9**.9*. Its value is `0` at frame `0`, and after rising between
    frames `1` and `2`, it goes back to zero just a little bit after frame `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: The sine function](img/Figure_9.9_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: The sine function'
  prefs: []
  type: TYPE_NORMAL
- en: This happens because sine, an angle-related function, depends on the mathematical
    constant π, and its value is zero at points `3.14`, `6.28`, and so on. The relationship
    between angles and circles is due to how angles describe circular arcs.
  prefs: []
  type: TYPE_NORMAL
- en: If the sine function repeats at every full circle, and a full circle measures
    2 * π radians, we can say that the period of the `sin(frame)` formula is `2 *`
    `pi` frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `2 * pi` as an argument of `sin`, we get a formula whose period is
    just one frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this formula is always `0`, but that’s more useful than it seems:
    dividing `frame * 2 * pi` by a specific number of frames, we can set how much
    it takes for the formula to repeat – that is, we now have control over the period.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the result of the following formula repeats every 10 frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can look up the pendulum formula and set up a physically correct oscillation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the pendulum equation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to Wikipedia ([en.wikipedia.org/wiki/Pendulum](https://en.wikipedia.org/wiki/Pendulum)),
    the period of a pendulum depends on the length of its cord, and is approximated
    with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*2π√(L/g)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It reads `2` times `pi` times the `length` over `gravity`. In Python, this
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `sqrt` is the square root operation and `9.8` is the gravity on Earth
    following the **International System of Units** (**SI**). The time unit is seconds
    in this system, so we need to express the formulas in our driver in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression for repeating `sin` in one frame was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And since we need to apply a period in seconds, we divide that expression by
    the frames per second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This slows down our expression to a period of 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: We aim to end up with a period of `2 * pi * sqrt(length / 9.8)` seconds, so
    we divide the argument of `sin` by that amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the division, we end up with a function of two variables, `fps` and `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `2 * pi / 2 *pi` is `1` and can be removed from the multiplication.
    Now, our formula looks much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Typing it inside **Rotation X** creates a *driver*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Implementation of the pendulum formula](img/Figure_9.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Implementation of the pendulum formula'
  prefs: []
  type: TYPE_NORMAL
- en: The driver won’t work yet, though – the `frame` variable is already defined
    by Blender, but `length` and `fps` do not exist and cause an error. We need to
    add these two variables to the driver properties.
  prefs: []
  type: TYPE_NORMAL
- en: Adding variables to drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could perform this operation in the **Drivers Editor** area we used in the
    *Creating drivers* section of this chapter, but since we don’t need to edit the
    *f-curve*, we can use a simpler interface.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Driven Property window
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **Driven Property** window displays the details of a single driver. It is
    quick to access, and its content is the same as the **Drivers** tab in the **Drivers**
    **Editor** area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for displaying and editing a driven property are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on a driven property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Edit Driver** from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Driven Property** window recaps the path of the affected property, which
    **Type** of driver it is, if there are errors in the driver, and which variables
    have been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: Properties of a scripted expression driver](img/Figure_9.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Properties of a scripted expression driver'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the driver type will be set to **Scripted Expression**; the **Expression**
    field contains our pendulum formula, while the error label informs us that something
    went wrong with the Python expression.
  prefs: []
  type: TYPE_NORMAL
- en: This error is caused by the missing `fps` and `length` variables. Adding them
    will fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Hold on to your window!
  prefs: []
  type: TYPE_NORMAL
- en: '**Driven Property** is a popover window that disappears when the mouse pointer
    moves back outside of its borders. Don’t worry, though; every change will still
    be there when you open the window again.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the frame per seconds property
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Clicking the `var`, and it’s an **RNA property** variable – that is, it reads
    the value from another property in Blender. To get that value, we need to specify
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the entity (object, scene, action, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These properties can be set in the **Variable** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: A newly created variable](img/Figure_9.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: A newly created variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to get the **Frames Per Second** render setting of the scene
    through this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Scene** from the property type list, which is displayed with the left
    button below the variable’s name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13: Setting the property variable type](img/Figure_9.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Setting the property variable type'
  prefs: []
  type: TYPE_NORMAL
- en: A Blender file can contain more than one scene. We can display a list of them
    with the right list button and pick one. The name of the default scene is **Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that a scene has been selected, another field, `render.fps` gets the frame
    per second, as set in the render settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We must rename the variable from `var` to `fps` by clicking the current name
    just right of the genetic code (RNA) icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14: The fps variable in the render settings](img/Figure_9.14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: The fps variable in the render settings'
  prefs: []
  type: TYPE_NORMAL
- en: Now, the variable name matches the one used in the driver expression so that
    `frame/fps` is the time at the current frame, in seconds. This allows the next
    variable, `length`, to influence the period with a seconds-based formula.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the pendulum length with a distance variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are four types of driver variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Property**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transform Channel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotational Difference**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distance**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first two, **Single Property** and **Transform Channel**, depend on
    the value of a property, **Rotational Difference** and **Distance** result from
    the difference between the transformations of two objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the length of the cord is the distance between the driven object
    and its pivot – that is, between `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new variable by clicking the **+ Add Input** **Variable** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the RNA icon to change the type to **Distance**. The panel will change,
    allowing you to select two objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.15: Changing the variable type](img/Figure_9.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Changing the variable type'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `length`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.16: Variables settings for the pendulum driver](img/Figure_9.16_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Variables settings for the pendulum driver'
  prefs: []
  type: TYPE_NORMAL
- en: Moving the **Empty** or **Cube** object closer to each other while the animation
    plays makes the swing becomes faster, while setting them apart slows them down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum value of sin is `1`, which, converted from *radians*, gives us
    the maximum angle reached by this driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This value is the amplitude of the oscillation. The amplitude of a pendulum
    depends on its initial position. In real life, the amplitude decreases progressively
    because of the friction of air, until the pendulum reaches its resting position
    and stops. We are not implementing air drag in our driver, but we can still add
    a control to influence the amplitude of the motion.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the amplitude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the term **amplitude** has a specific meaning when dealing with wave graphs,
    for our goal, we can consider it a multiplier of motion.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are programming for animation, it’s more important for our amplitude
    control to make sense visually rather than physically.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already control the pivot’s position with an object of the **empty** type.
    Since moving **Empty** already alters the periodic motion, we can add a new property
    to it, to control the amplitude of the oscillation. This way, we can affect the
    behavior of the pendulum by selecting a single object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure for adding a property to an object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Empty** object that we are using as a pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Object Properties** panel, find the **Custom** **Properties** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **+ New** button to add a property. It will be named **prop** by
    default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17: Adding custom properties to the active object](img/Figure_9.17_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Adding custom properties to the active object'
  prefs: []
  type: TYPE_NORMAL
- en: Click the cog icon and change **Property Name** to **amplitude**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the value (the default, `1.00`, is good) and select **Copy**
    **Data Path**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This copies the path of the property to the clipboard. This will be useful when
    we add the next driver variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom properties in drivers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multiplying the driver expression by the `amp` variable affects its result
    and allows us to modulate its amplitude. To do that, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the oscillating **Cube**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the driven rotation channel and select **Edit Driver** to bring
    up the **Driven** **Property** editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `amp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Prop:** field on the right and pick **Empty** as the property object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the `["amplitude"]`. The square brackets are part of the *custom properties*
    Python path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18: Custom property as a driver variable](img/Figure_9.18_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Custom property as a driver variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could just add `* amp` to the driver expression, but we can do even better:
    since the driver affects a rotation, we can add `pi` to the multiplication too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `sin` function oscillates between `-1.0` and `1.0`, so the result of our
    driver when `1.0` ranges between `-pi` to `pi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that a full circle arc measures `2 * pi`, it’s fair to expect
    a value of `pi` to describe a half-circle rotation in radians. If we play the
    animation now, we’ll see the pendulum oscillate up to its vertical direction –
    that is, rotate half circle to the left, go back, and then rotate half circle
    to the right: an amplitude of `1.0` makes the pendulum describe a full circle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we select the `0.5`, the pendulum will swing through a half-circle arc.
    An amplitude equal to `0.25` gives better results: a 45-degree maximum rotation
    on each side; a value of `0.0` would stop the pendulum.'
  prefs: []
  type: TYPE_NORMAL
- en: A control ranging from `0.0` for a still pendulum to `1.0` for an entire rotation
    has an immediate meaning to animators and 3D users because it allows them to set
    up the fraction of the circle that they wish by changing the amplitude.
  prefs: []
  type: TYPE_NORMAL
- en: We used a Python formula in our driver, but we created the entire setup manually.
    In the next section, we will write a Python add-on to automate this procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the pendulum add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using what we have learned so far, we can write an add-on that sets up a pendulum
    for the active object.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the steps from [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049),
    and create a `.py` file for our add-on.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a folder for [*Chapter 9*](B18375_09.xhtml#_idTextAnchor226) in
    our `ch9` folder as the **Scripts Folder** property and restart the application.
    We can create our new files and folder in our IDE (VS Code in this book) so that
    we can start editing:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch9/addons` in **VS Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `pendulum.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file by double-clicking it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now add the standard elements of most add-ons:'
  prefs: []
  type: TYPE_NORMAL
- en: Add-on information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Operator` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The menu function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registration functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll learn how to write this information.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As usual, the information about our add-on goes into the `bl_info` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This dictionary is just for Blender to display the add-on’s name and description
    in the list. The next step is writing the `Operator` class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Operator class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Operator` class carries on the actual work. We derive `bpy.types.Operator`
    and fill in the information in the static section of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`bl_idname` starts with `object.` so that it will be added to the `bpy.ops.object`
    operators. We are doing that because everything we do in this operator affects
    the scene at the object level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must add the oscillation parameters to the static attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'They will determine the `amplitude` and `length` variables of the motion. By
    using `''REGISTER''` and `''UNDO''` as `bl_options`, the operator will allow live
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s the `poll` method’s turn, where the conditions for running the operator
    are checked. It must return `True` if there is an active object. We can use the
    `bool` function to convert `context.object` on the fly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `execute` method. It performs all the operations from
    the previous section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates the pivot object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a custom property for the amplitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a driver with the pendulum formula and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the start of the function, we store the active object in the `ob` variable,
    then create a new object that will be the pivot. In [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033),
    we learned that new objects can be created in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a new object via `bpy.data.objects.new`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the object to a `Collection` present in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use `context.collection` and link the pivot to the active collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `None` as the second argument of `new` creates a transform with no geometry
    data – that is, an `matrix_world`. The pivot should be placed above the active
    object, and since `location` is stored in the fourth column of the transform matrix,
    we can raise the value of `[2][3]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, it’s time for the custom properties. We have seen how the data path to
    our *amplitude* property was `["amplitude"]`. That’s because Python’s access to
    custom properties follows the same syntax as Python dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python dictionaries, the `dictionary["new_key"] = new_value` syntax adds
    a new item. Likewise, the Python code for creating the `amplitude` float property
    and assigning it the value of the operator’s parameter of the same name is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`amplitude` will now appear under our pivot object. We will use that later
    in the driver. For now, we will add a **Pivot Constraint** to the active object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to create our driver. Drivers, as objects, are slightly more
    complex than constraints as they contain other entities, such as the f-curve,
    and are part of the animation data. So, rather than using the `drivers.new` method
    from `animation_data`, we will resort to the `driver_add` method of the object,
    which sets up all the requirements. It returns the driver curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Who drives the driver?
  prefs: []
  type: TYPE_NORMAL
- en: The `driver_add` method returns the f-curve rather than the driver itself. The
    actual driver can be accessed via the `curve.driver` attribute. This makes it
    easier to access the new curve, but it would have been reasonable to expect that
    `driver_add` would return the driver instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our driver uses a Python expression, so must we set the `type` and `expression`
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `fps`, `length`, and `amp` variables can be added using `variables.new`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve created a variable, we can set its targets. The current `render.fps`
    property of `context.scene`, so it’s only one target. We will set the variable
    type to a single property and fill `id_type`, `id`, and `data_path` of `targets[0]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our pendulum length is the distance between `pivot` and `ob`, so it has two
    targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can look at the amplitude. It’s a custom property of the pivot
    and the variable is of the `''SINGLE_PROP''` type, but this time, `id_type` is
    a Blender object. Once the driver setup is complete, we can exit the function
    by returning the `''``FINISHED''` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ObjectPendulum` class is complete as it now covers the entire setup process.
    As usual, we must also add an entry to one of the Blender menus to make it easier
    to launch.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the menu and registering the class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049), we learned that we can
    add our items to menus by writing a menu function. The argument self and context
    are, respectively, the menu instance and the application context. We must add
    the operator’s `bl_idname` to the menu’s `layout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the register function, we must add `menu_func` to one of Blender’s
    menus. In this example, we will use the right-click menu that’s available in object
    mode. We learned how to look for menu class names in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206),
    and the object context menu class is `VIEW3D_MT_object_context_menu`. We must
    also register the operator class, `ObjectPendulum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds our new functionality to Blender when the **Object Pendulum** add-on
    is enabled. Of course, we must reverse those operations to clean up our add-on
    elements when it is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our add-on is ready, the steps for setting up a pendulum instantly
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Object Mode**, select an object to make it active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and choose **Make Pendulum** to invoke the add-on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set values for `length` and `amplitude` in the operator properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing this add-on put many of the techniques you learned in the previous chapters
    to use. Drivers are a very creative area of scripting, and this was just a taste
    of what we can do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drivers are powerful tools that sit at a crossroads between animation, rigging,
    and programming. On one hand, they can contain Python expressions and implement
    custom mechanics on their own, while on the other hand, the entire driver setup
    process can be automated via scripting.
  prefs: []
  type: TYPE_NORMAL
- en: The tool we wrote in this chapter is a small **auto-rig** that replicates the
    same mechanism, with editable parameters, on any Blender object.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to combine drivers, constraints, and custom properties, as well
    as automate the whole procedure, is an essential part of 3D production as it allows
    non-technical users to carry on with technical tasks.
  prefs: []
  type: TYPE_NORMAL
- en: As a plus, by using Python, we converted a formula from physics into a working
    driver expression, a task that can sometimes be intimidating but can be carried
    out with observation and a little ingenuity.
  prefs: []
  type: TYPE_NORMAL
- en: This topic ends our tour of the animation system. In the next chapter, [*Chapter
    10*](B18375_10.xhtml#_idTextAnchor247), we will learn how our operators can interact
    with the user and listen to events.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What color is used for driven properties in the interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we set keyframes for purple properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a metric property, such as **Location**, drive an angular property, such
    as **Rotation**?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we change the ratio between the driving and driven properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we type Python expressions when we set values in the interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we tell Blender that the expressions we have typed should be a driver?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we edit a driver property in the user interface? Is there only one way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we add custom properties to an object and use them to control other objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Python, can we create new drivers using the `collection.new` method, as we
    do with constraints? If yes, why do we use `object.driver_add` instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `targets` attribute of driver variables a list? Which type of variable
    has more than one target?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
