- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Server Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll introduce the basics of the web server part of Odoo in this chapter. Note
    that this will cover the fundamental aspects; for high-level functionality, you
    should refer to [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734), *CMS* *Website
    Development*.
  prefs: []
  type: TYPE_NORMAL
- en: The Odoo web server is a crucial component of the Odoo framework, responsible
    for handling web requests and serving the web interface to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are key aspects of the Odoo web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The web interface and modules**: The web server provides a user-friendly
    web interface to access and interact with Odoo applications. Users can navigate
    through different modules, access data, and perform various business operations
    using this interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An HTTP server**: Odoo uses an HTTP server to handle web requests. It can
    be configured to work with popular web servers such as Nginx or Apache or can
    run its own built-in HTTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Werkzeug**: Werkzeug is a **WSGI** (**Web Server Gateway Interface**) library
    for Python, and Odoo uses it to handle HTTP requests and responses. Werkzeug helps
    in routing requests, handling sessions, and managing other web-related tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers and routing**: Odoo uses controllers to handle different web
    requests and routes them to the appropriate controllers and methods. The routing
    mechanism ensures that requests are directed to the correct modules and functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views and templates**: Odoo uses views and templates to define how data should
    be presented in the web interface. Views determine the structure of pages, and
    templates provide the HTML and presentation logic to render data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business logic**: The web server is tightly integrated with the business
    logic of Odoo. It communicates with the backend to fetch and update data, ensuring
    that the web interface reflects the most current state of the business applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Security is a critical aspect of the Odoo web server. It includes
    features such as authentication, authorization, and session management to ensure
    that users have appropriate access levels and that their interactions with the
    system are secure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript and CSS**: The Odoo web interface relies on JavaScript and CSS
    to enhance user experience and provide dynamic and responsive features. This includes
    form validation, interactive elements, and real-time updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A RESTful API**: The web server also provides a RESTful API, allowing external
    applications to interact with Odoo programmatically. This enables integration
    with third-party systems and the development of custom applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization and extensions**: Developers can extend and customize the Odoo
    web server to meet specific business requirements. This includes creating custom
    modules, views, and controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Odoo web server is essential for developers and administrators
    working with Odoo to deploy, configure, and customize the system based on the
    unique needs of a business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Werkzeug ([https://werkzeug.palletsprojects.com/en/2.3.x](https://werkzeug.palletsprojects.com/en/2.3.x))
    is a WSGI library for Python and is used by Odoo to handle HTTP requests and responses.
    WSGI is a specification for how web servers and web applications communicate in
    Python. Werkzeug provides a set of utilities and classes that make it easier to
    work with WSGI applications. Here are some details about how Werkzeug is used
    in the context of Odoo:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Request` object that represents an incoming HTTP request. In Odoo, this object
    is used to extract information from the incoming HTTP request, such as form data,
    query parameters, and headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response` object in Werkzeug is used to create HTTP responses. Odoo utilizes
    this to construct and send responses back to the client, including rendering web
    pages or providing data in response to AJAX requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: Werkzeug enables easy URL routing. In Odoo, the routing mechanism
    is used to map incoming requests to the appropriate controller methods or views.
    This helps in directing requests to the correct functionality within the Odoo
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware**: Middleware components can be added to the Odoo application
    using Werkzeug. Middleware sits between the web server and the Odoo application
    and can perform tasks such as authentication, logging, or modifying requests and
    responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URL building**: Werkzeug provides a URL building facility that helps to generate
    URLs for different routes within the Odoo application. This is essential for creating
    links and redirects dynamically in the web interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session management**: Werkzeug supports session management, which Odoo utilizes
    to handle user sessions. This is important for maintaining user state across multiple
    requests and ensuring security features such as user authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilities for common tasks**: Werkzeug includes various utilities that simplify
    common web development tasks. Odoo leverages these utilities for tasks such as
    parsing form data, handling file uploads, and managing cookies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Werkzeug provides mechanisms to handle errors, including
    HTTP error responses. Odoo uses this to ensure that appropriate error messages
    are returned to the client when needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To work with Werkzeug in the context of Odoo, developers often interact with
    these features through the controllers and views defined in Odoo modules. Understanding
    Werkzeug is beneficial for developers who want to extend or customize Odoo, as
    it provides insights into the underlying mechanisms to handle HTTP requests and
    responses within the application. However, in day-to-day Odoo development, developers
    often work at a higher level using the Odoo framework itself, without directly
    interacting with Werkzeug.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a path accessible from a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access to web-accessible paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming parameters passed to your handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying an existing handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include the online Odoo platform.
  prefs: []
  type: TYPE_NORMAL
- en: All the code used in this chapter can be downloaded from the GitHub repository
    at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Making a path accessible from a network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making a path accessible from a network means defining the entry points or URLs
    through which users can access the application. This is fundamental to any web
    development project, as it determines how users will interact with the system.
    In this recipe, we’ll look at how to make a URL of the [http://yourserver/path1/path2](http://yourserver/path1/path2)
    form accessible to users. This can be either a web page or a path returning arbitrary
    data to be consumed by other programs. In the latter case, you would usually use
    the JSON format to consume parameters and offer your data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll make use of the `hostel.student` model, which we looked at in [*Chapter
    4*](B20997_04.xhtml#_idTextAnchor118), *Application Models*; therefore, if you
    haven’t done so yet, grab the initial module from [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13/00_initial_module](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13/00_initial_module)
    so that you will be able to follow the examples.
  prefs: []
  type: TYPE_NORMAL
- en: We want to allow any user to query the full list of students in the hostel.
    Furthermore, we want to provide the same information to programs through a JSON
    request. Let’s check out how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need to add controllers, which go into a folder called `controllers`
    by convention:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `controllers/main.py` file with the HTML version of our page, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function to serve the same information in the JSON format, as shown in
    the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `controllers/__init__.py` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `controllers` into your `my_hostel/__init__.py` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After restarting your server, you can visit `/my_hostel/students` in your browser,
    and you’ll be presented with a flat list of the student names.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – A list of students](img/B20997_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – A list of students
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the JSON-RPC part, you’ll have to craft a JSON request. A simple way
    to do that is by using the following command to receive the output on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you get `404` errors at this point, you probably have more than one database
    available on your instance. If so, it’s impossible for Odoo to determine which
    database is meant to serve the request.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `--db-filter='^yourdatabasename$'` parameter to force Odoo to use the
    exact database you installed the module in. The path should now be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two crucial parts here are that our controller is derived from `odoo.http.Controller`,
    and the methods we use to serve content are decorated with `odoo.http.route`.
    Inheriting from `odoo.http.Controller` registers the controller with Odoo’s routing
    system in a similar way to how the models are registered – by inheriting from
    `odoo.models.Model`. Also, `Controller` has a metaclass that takes care of this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – A diagram of controllers](img/B20997_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – A diagram of controllers
  prefs: []
  type: TYPE_NORMAL
- en: In general, paths handled by your add-on should start with your add-on’s name,
    to avoid name clashes. Of course, if you extend some of the add-on’s functionality,
    you’ll use this add-on’s name.
  prefs: []
  type: TYPE_NORMAL
- en: odoo.http.route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `route` decorator allows us to tell Odoo that a method should be web-accessible
    in the first place, and the first parameter determines on which path it is accessible.
    Instead of a string, you can also pass a list of strings, if you use the same
    function to serve multiple paths.
  prefs: []
  type: TYPE_NORMAL
- en: The `type` argument defaults to `http` and determines what type of request will
    be served. While, strictly speaking, JSON is HTTP, declaring the second function
    as `type='json'` makes life a lot easier because Odoo then handles type conversions
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry about the `auth` parameter for now; it will be addressed in the
    *Restricting access to web-accessible paths* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Odoo’s treatment of the functions’ return values is determined by the `type`
    argument of the `route` decorator. For `type=''http''`, we usually want to deliver
    some HTML, so the first function simply returns a string containing it. An alternative
    is to use `request.make_response()`, which gives you control over the headers
    to send in the response. So, to indicate when our page was last updated, we might
    change the last line in `students()` to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code sends a `Last-modified` header along with the HTML we generated, telling
    the browser when the list was modified for the last time. We can extract this
    information from the `write_date` field of the `hostel.student` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the preceding snippet to work, you’ll have to add some imports
    at the top of the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also create a `Response` object of `werkzeug` manually and return that,
    but there’s little to gain for the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: Generating HTML manually is nice for demonstration purposes, but you should
    never do this in production code. Always use templates, as demonstrated in the
    *Creating or modifying templates – QWeb* recipe in [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861),
    *Web Client Development*, and return them by calling `request.render()`. This
    will give you localization for free and will make your code better by separating
    business logic from the presentation layer. Also, templates provide you with functions
    to escape data before outputting HTML. The preceding code is vulnerable to cross-site
    scripting attacks (if a user manages to slip a `script` tag into the book name,
    for example).
  prefs: []
  type: TYPE_NORMAL
- en: For a JSON request, simply return the data structure you want to hand over to
    the client; Odoo takes care of serialization. For this to work, you should restrict
    yourself to data types that are JSON-serializable, which generally means dictionaries,
    lists, strings, floats, and integers.
  prefs: []
  type: TYPE_NORMAL
- en: odoo.http.request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `request` object is a static object referring to the currently handled request,
    which contains everything you need in order to take action. The most important
    aspect here is the `request.env` property, which contains an `Environment` object
    that is just the same as `self.env` for models. This environment is bound to the
    current user, which is not in the preceding example, because we used `auth='none'`.
    The lack of a user is also why we have to `sudo()` all our calls to model methods
    in the example code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re used to web development, you’ll expect session handling, which is
    perfectly correct. Use `request.session` for an `OpenERPSession` object (which
    is quite a thin wrapper around the `Session` object of `werkzeug`) and `request.session.sid`
    to access the session ID. To store session values, just treat `request.session`
    as a dictionary, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that storing data in the session is no different from using global variables.
    Only do so if you must. This is usually the case for multi-request actions, such
    as a checkout in the `website_sale` module.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `route` decorator can have some extra parameters in order to customize its
    behavior further. By default, all HTTP methods are allowed, and Odoo intermingles
    the parameters passed. Using the `methods` parameter, you can pass a list of methods
    to accept, which would usually be one of either `['GET']` or `['POST']`.
  prefs: []
  type: TYPE_NORMAL
- en: To allow cross-origin requests (browsers block AJAX and some other types of
    requests to domains other than where the script was loaded from, for security
    and privacy reasons), set the `cors` parameter to `*` to allow requests from all
    origins, or a URI to restrict requests to ones originating from that URI. If this
    parameter is unset, which is the default, the `Access-Control-Allow-Origin` header
    is not set, leaving you with the browser’s standard behavior. In our example,
    we might want to set it on
  prefs: []
  type: TYPE_NORMAL
- en: '`/my_module/students/json` in order to allow scripts pulled from other websites
    to access the list of students.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Odoo protects certain types of requests from an attack known as
    cross-site request forgery, by passing a token along on every request. If you
    want to turn that off, set the `csrf` parameter to `False`, but note that this
    is a bad idea, in general.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refer to the following points to learn more about the HTTP routes:'
  prefs: []
  type: TYPE_NORMAL
- en: If you host multiple Odoo databases on the same instance, then different databases
    might be running on different domains. If so, you can use the `--db-filter` options,
    or you can use the `dbfilter_from_header` module from [https://github.com/OCA/server-tools](https://github.com/OCA/server-tools),
    which helps you filter databases based on the domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see how using templates makes modularity possible, check out the *Modifying
    an existing handler* recipe later in the chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access to web-accessible paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an Odoo developer, one of your primary concerns is ensuring the security
    of the application. Restricting access to web-accessible paths is a crucial aspect
    of access control. It involves determining who can or cannot access specific routes
    or functionalities within the Odoo application. Odoo provides different authentication
    mechanisms to control user access. Understanding and implementing these mechanisms
    is essential for ensuring that only authorized users can interact with sensitive
    or protected parts of the application. For instance, you might want to restrict
    certain routes to authenticated users only.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the three authentication mechanisms Odoo provides for routes in
    this recipe. We’ll define routes with different authentication mechanisms in order
    to show their differences.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we extend the code from the previous recipe, we’ll also depend on the `hostel.student`
    model of [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118), *Application Models*,
    so you should retrieve its code in order to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the handlers in `controllers/main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a path that shows all the students, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a path that shows all the students and indicates which ones belong to the
    current user, if any. This is shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a path that shows the current user’s students, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, the `/my_hostel/all-students` and `/my_hostel/all-students/mark-mine`
    paths look the same for unauthenticated users, while a logged-in user sees their
    students in a bold font on the latter path.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Mark as mine students – with login](img/B20997_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Mark as mine students – with login
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results without login:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Mark as mine students – without login](img/B20997_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Mark as mine students – without login
  prefs: []
  type: TYPE_NORMAL
- en: The `/my_hostel/all-students/mine` path is not accessible at all for unauthenticated
    users. If you try to access it without being authenticated, you’ll be redirected
    to the login screen in order to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Access via unauthenticated users](img/B20997_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Access via unauthenticated users
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between authentication methods is basically what you can expect
    from the content of `request.env.user`.
  prefs: []
  type: TYPE_NORMAL
- en: For `auth='none'`, the user record is always empty, even if an authenticated
    user accesses the path. Use this if you want to serve content that has no dependencies
    on users, or if you want to provide database-agnostic functionality in a server-wide
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The `auth='public'` value sets the user record as a special user with an XML
    ID of `base.public_user` for unauthenticated users, and to the user’s record for
    authenticated ones. This is the right choice if you want to offer functionality
    to both unauthenticated and authenticated users, while the authenticated ones
    get some extras, as demonstrated in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Use `auth='user'` to ensure that only authenticated users have access to what
    you’ve got to offer. With this method, you can be sure that `request.env.user`
    points to an existing user.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The magic of authentication methods happens in the `ir.http` model from the
    base add-on. For whatever value you pass to the `auth` parameter in your route,
    Odoo searches for a function called `_auth_method_<yourvalue>` on this model,
    so you can easily customize it by inheriting it and declaring a method that takes
    care of your authentication method of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will provide an authentication method called `base_group_user`,
    which will only authorize the user if the currently logged-in user is part of
    the `base.group_user` group, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can say `auth='base_group_user'` in your decorator and be sure that
    users running this route’s handler are members of the group. With a little trickery,
    you can extend this to `auth='groups(xmlid1,...)'`; its implementation is left
    as an exercise for you but is included in the GitHub repository example code at
    `Chapter13/02_paths_auth/my_hostel/models/sample_auth_http.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming parameters passed to your handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s nice to be able to show content, but it’s better to show content as a result
    of user input. This recipe will demonstrate the different ways to receive this
    input and react to it. As in the previous recipes, we’ll make use of the `hostel.student`
    model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll add a route that expects a traditional parameter with a student’s
    ID to show some details about them. Then, we’ll do the same again, but we’ll incorporate
    our parameter into the path itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a path that expects a student’s ID as a parameter, as shown in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a path where we can pass the student’s ID in the path, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you point your browser to `/my_hostel/student_details?student_id=1`, you
    should see a detailed page of the student with ID 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – The student details web page](img/B20997_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – The student details web page
  prefs: []
  type: TYPE_NORMAL
- en: If this doesn’t exist, you’ll receive an error page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The student not found:Error page](img/B20997_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The student not found:Error page
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Odoo (actually, `werkzeug`) intermingles the `GET` and `POST` parameters
    and passes them as keyword arguments to your handler. So, by simply declaring
    your function as expecting a parameter called `student_id`, you introduce this
    parameter as either `GET` (the parameter in the URL) or `POST` (usually passed
    by the `<form>` element with your handler as the `action` attribute). Given that
    we didn’t add a default value for this parameter, the runtime will raise an error
    if you try to access this path without setting the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The second example makes use of the fact that, in a `werkzeug` environment,
    most paths are virtual anyway. So, we can simply define our path as containing
    some input. In this case, we say that we expect the ID of a `hostel.student` instance
    as the last component of the path. The name after the colon is the name of a keyword
    argument. Our function will be called, with this parameter passed as a keyword
    argument. Here, Odoo takes care of looking up this ID and delivering a browse
    record, which, of course, only works if the user accessing this path has appropriate
    permissions. Given that `student` is a browse record, we can simply recycle the
    first example’s function by passing `student.id` as a `student_id` parameter,
    outputing the same content.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining parameters within a path is a functionality delivered by `werkzeug`,
    called `converters`. The `model` converter is added by Odoo, which also defines
    the converter models that accept a comma-separated list of IDs and pass a recordset
    containing those IDs to your handler.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of converters is that the runtime coerces parameters to the expected
    type, whereas you’re on your own with normal keyword parameters. These are delivered
    as strings, and you have to take care of the necessary type conversions yourself,
    as seen in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in `werkzeug` converters include not only `int`, `float`, and `string`
    but also more intricate ones, such as `path`, `any`, and `uuid`. You can look
    up their semantics at [https://werkzeug.palletsprojects.com/en/2.3.x/](https://werkzeug.palletsprojects.com/en/2.3.x/).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to learn more about the HTTP routes, refer to the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Odoo’s custom converters are defined in `ir_http.py` in the base module and
    registered in the `_get_converters` class method of `ir.http`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to learn more about the form submission on the route, refer to the
    *Getting input from users* recipe from [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734),
    *CMS* *Website Development*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying an existing handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you install the website module, the `/website/info` path displays some
    information about your Odoo instance. In this recipe, we will override this in
    order to change this information page’s layout, as well as to change what is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install the `website` module and inspect the /`website/info` path. In this recipe,
    we will update the `/website/info` route to provide more information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll have to adapt the existing template and override the existing handler.
    We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Override the `qweb` template in a file called `views/templates.xml`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the handler in a file called `controllers/main.py`, as shown in the
    following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when visiting the info page, we’ll only see a filtered list of installed
    applications in a table, as opposed to the original definition list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – The website info page (original)](img/B20997_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – The website info page (original)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the customized page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – The website info page (customized)](img/B20997_13_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – The website info page (customized)
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first step, we overrode an existing QWeb template. In order to find
    out which one it is, you’ll have to consult the code of the original handler.
    Usually, this will give you something similar to the following line, which tells
    you that you need to override `template.name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the handler used a template called `website_info`, but this one
    was immediately extended by another template called `website.show_website_info`,
    so it’s more convenient to override this one. Here, we replaced the definition
    list showing installed apps with a table. For details on how QWeb inheritance
    works, consult [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861), *Web* *Client
    Development*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to override the handler method, we must identify the class that defines
    the handler, which is `odoo.addons.website.controllers.main.Website` in this case.
    We need to import the class to be able to inherit from it. Now, we can override
    the method and change the data passed to the response. Note that what the overridden
    handler returns here is a `Response` object and not a string of HTML, as the previous
    recipes did, for the sake of brevity. This object contains a reference to the
    template to be used and the values accessible to the template, but it is only
    evaluated at the very end of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are three ways to change an existing handler:'
  prefs: []
  type: TYPE_NORMAL
- en: If it uses a QWeb template, the simplest way to change it is to override the
    template. This is the right choice for layout changes and small logic changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QWeb templates get a context passed, which is available in the response as the
    `qcontext` member. This is usually a dictionary where you can add or remove values
    to suit your needs. In the preceding example, we filtered the list of apps to
    the website only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the handler receives parameters, you can also preprocess those in order to
    make the overridden handler behave in the way you want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the preceding section, inheritance with controllers works slightly
    differently than model inheritance; you actually need a reference to the base
    class and to use Python inheritance on it.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to decorate your new handler with the `@http.route` decorator;
    Odoo uses it as a marker, for which methods are exposed to the network layer.
    If you omit the decorator, you actually make the handler’s path inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: The `@http.route` decorator itself behaves similarly to field declarations –
    every value you don’t set will be derived from the decorator of the function you’re
    overriding, so we don’t have to repeat values we don’t want to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'After receiving a `response` object from the function you override, you can
    do a lot more than just change the QWeb context:'
  prefs: []
  type: TYPE_NORMAL
- en: You can add or remove HTTP headers by manipulating `response.headers`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to render an entirely different template, you can overwrite `response.template`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To detect whether a response is based on QWeb in the first place, query `response.is_qweb`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting HTML code is available by calling `response.render()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Details on QWeb templates will be given in [*Chapter 15*](B20997_15.xhtml#_idTextAnchor861),
    *Web* *Client Development*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web pages contain several types of static resources, such as images, videos,
    CSS, and so on. In this recipe, we will see how you can manage such static resources
    for your module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will display an image on the page. Grab the `my_hostel`
    module from the previous recipe. Select any image from your system and put that
    image inside the `/``my_hostel/static/src/img` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to show an image on the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: Add your image to the `/``my_hostel/static/src/img` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the new route in `controller`. In the code, replace the image URL with
    the URL of your image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart the server and update the module to apply the changes. Now, visit `/demo_page`
    to see the image on the page.![Figure 13.10 – The static image on the web page](img/B20997_13_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 13.10 – The static image on the web page
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the files placed under the `/static` folder are considered static resources
    and are publicly accessible. In our example, we have put our image in the `/static/src/img`
    directory. You can place the static resource anywhere under the `static` directory,
    but there is a recommended directory structure based on the type of file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/static/src/img` is the directory used for images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/src/css` is the directory used for CSS files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/src/scss` is the directory used for SCSS files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/src/fonts` is the directory used for font files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/src/js` is the directory used for JavaScript files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/src/xml` is the directory used for XML files for client-side QWeb
    templates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/static/lib` is the directory used for files of external libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we displayed an image on the page. You can also access the image
    directly from `/my_hostel/static/src/image/odoo.png`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we displayed a static resource (an image) on the web page, and
    we saw the recommended directories for different static resources. There are more
    simple ways to present page content and static resources, which we will see in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
