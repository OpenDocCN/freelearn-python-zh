<html><head></head><body><div><h1 class="header-title">Improving Our API and Adding Authentication to it with Flask</h1>
                
            
            
                
<p>In this chapter, we will improve the capabilities of the RESTful API that we started in the previous chapter and we will add authentication-related security to it. We will do the following:</p>
<ul>
<li>Improve unique constraints in the models</li>
<li>Understand the differences between the <kbd>PUT</kbd> and the <kbd>PATCH</kbd> methods</li>
<li>Update fields for a resource with the <kbd>PATCH</kbd> method</li>
<li>Code a generic pagination class</li>
<li>Add pagination features to the API</li>
<li>Understand the steps to add authentication and permissions</li>
<li>Add a user model</li>
<li>Create a schema to validate, serialize, and deserialize users</li>
<li>Add authentication to resources</li>
<li>Create resource classes to handle users</li>
<li>Run migrations to generate the user table</li>
<li>Compose requests with the necessary authentication</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Improving unique constraints in the models</h1>
                
            
            
                
<p>When we coded the <kbd>NotificationCategory</kbd> model in the previous chapter, we specified the <kbd>True</kbd> value for the <kbd>unique</kbd> argument in the creation of the <kbd>orm.Column</kbd> instance named <kbd>name</kbd>. As a result, the migrations process generated the necessary unique constraint to make sure that the <kbd>name</kbd> field has unique values in the <kbd>notification_category</kbd> table. This way, the PostgreSQL database won't allow us to insert duplicate values for the <kbd>notification_category.name</kbd> column. However, the error message generated when we try to do so is not clear. The message includes details about the database structure that shouldn't be mentioned in the error message.</p>
<p>Run the following command to create a category with a duplicate ...</p></div>



  
<div><h1 class="header-title">Understanding the differences between the PUT and the PATCH methods</h1>
                
            
            
                
<p>The HTTP <kbd>PUT</kbd> and <kbd>PATCH</kbd> methods have different purposes. The HTTP <kbd>PUT</kbd> method is meant to replace an entire resource. The HTTP <kbd>PATCH</kbd> method is meant to apply a delta to an existing resource.</p>
<p class="mce-root"/>
<p>Our API is able to update a single field for an existing resource, and therefore, we provide an implementation for the <kbd>PATCH</kbd> method. For example, we can use the <kbd>PATCH</kbd> method to update an existing notification and set the value for its <kbd>displayed_once</kbd> and <kbd>displayed_times</kbd> fields to <kbd>true</kbd> and <kbd>1</kbd>.</p>
<p>We don't want to use the <kbd>PUT</kbd> method to update two fields because this method is meant to replace an entire notification. The <kbd>PATCH</kbd> method is meant to apply a delta to an existing notification, and therefore, it is the appropriate method to just change the value of those two fields.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Updating fields for a resource with the PATCH method</h1>
                
            
            
                
<p>Now we will compose and send an HTTP request to update an existing notification, specifically, to update the value of the <kbd>displayed_once</kbd> and <kbd>displayed_times</kbd> fields. Because we just want to update two fields, we will use the <kbd>PATCH</kbd> method instead of <kbd>PUT</kbd>. Make sure you replace <kbd>2</kbd> with the ID or primary key of an existing notification in your configuration. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd307.txt</kbd> file:</p>
<pre><strong>http PATCH ":5000/service/notifications/2" displayed_once=true displayed_times=1</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd308.txt ...</kbd></p></div>



  
<div><h1 class="header-title">Coding a generic pagination class</h1>
                
            
            
                
<p>Right now, the table that persists the notifications in the database has just a few rows. However, after we start working with our API encapsulated in a microservice in a real-life production environment, we will have hundreds of notifications, and therefore, we will have to deal with large result sets. We don't want an HTTP <kbd>GET</kbd> request to retrieve 1,000 notifications in a single call. Thus, we will create a generic pagination class and we will use it to easily specify how we want large results sets to be split into individual pages of data.</p>
<p>First, we will compose and send HTTP <kbd>POST</kbd> requests to create nine notifications that belong to one of the notification categories we have created: <kbd>Information</kbd>. This way, we will have a total of 12 messages persisted in the database. We had three messages and we add nine more. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd309.txt</kbd> file:</p>
<pre><strong>http POST ":5000/service/notifications/" message='Clash Royale has a new winner' ttl=25 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='Uncharted 4 has a new 2nd position score' ttl=20 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='Fortnite has a new 4th position score' ttl=18 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='Injustice 2 has a new winner' ttl=14 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='PvZ Garden Warfare 2 has a new winner' ttl=22 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='Madden NFL 19 has a new 3rd position score' ttl=15 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='Madden NFL 19 has a new winner' ttl=18 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='FIFA 19 has a new 3rd position score' ttl=16 notification_category='Information'</strong>
<strong>http POST ":5000/service/notifications/" message='NBA Live 19 has a new winner' ttl=5 notification_category='Information'</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following are the equivalent <kbd>curl</kbd> commands. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd310.txt</kbd> file.</p>
<pre><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Clash Royale has a new winner", "ttl":25, "notification_category": "Information"}'<br/>"localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Uncharted 4 has a new 2nd position score", "ttl":20, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Fortnite has a new 4th position score", "ttl":18, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Injustice 2 has a new winner", "ttl":14, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"PvZ Garden Warfare 2 has a new winner", "ttl":22, "notification_category": "Information"}'<br/>"localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Madden NFL 19 has a new 3rd position score", "ttl":15, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Madden NFL 19 has a new winner", "ttl":18, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"FIFA 19 has a new 3rd position score", "ttl":16, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong><br/><br/><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"NBA Live 19 has a new winner", "ttl":5, "notification_category": "Information"}' <br/>"localhost:5000/service/notifications/"</strong></pre>
<p>The previous commands will compose and send nine HTTP <kbd>POST</kbd> requests with the specified JSON key-value pairs. The requests specify <kbd>/service/notifications/</kbd>, and therefore, they will match <kbd>'/notifications/'</kbd> and run the <kbd>NotificationListResource.post</kbd> method, that is, the <kbd>post</kbd> method for the <kbd>NotificationListResource</kbd> class.</p>
<p class="mce-root"/>
<p>After running the previous commands, we will have 12 notifications persisted in our PostgreSQL database. However, we don't want to retrieve the 12 messages when we compose and send an HTTP <kbd>GET</kbd> request to <kbd>/service/notifications/</kbd>. We will create a customizable generic pagination class to include a maximum of four resources in each individual page of data.</p>
<p>Open the <kbd>config.py</kbd> file within the <kbd>service</kbd> folder and add the following lines that declare two variables that configure the global pagination settings.</p>
<p>Open the <kbd>service/config.py</kbd> file and add the following lines that declare two variables that configure the global pagination settings. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/service/config.py</kbd> file:</p>
<pre>PAGINATION_PAGE_SIZE = 4 
PAGINATION_PAGE_ARGUMENT_NAME = 'page' </pre>
<p>The value for the <kbd>PAGINATION_PAGE_SIZE</kbd> variable specifies a global setting with the default value for the page size, also known as limit. The value for <kbd>PAGINATION_PAGE_ARGUMENT_NAME</kbd> specifies a global setting with the default value for the argument name that we will use in our requests to specify the page number we want to retrieve.</p>
<p>Create a new <kbd>helpers.py</kbd> file within the <kbd>service</kbd> folder. The following lines show the code that creates a new <kbd>PaginationHelper</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/service/helpers.py</kbd> file:</p>
<pre>from flask import url_for 
from flask import current_app 
 
 
class PaginationHelper(): 
    def __init__(self, request, query, resource_for_url, key_name, schema): 
        self.request = request 
        self.query = query 
        self.resource_for_url = resource_for_url 
        self.key_name = key_name 
        self.schema = schema 
        self.page_size =<br/>current_app.config['PAGINATION_PAGE_SIZE'] 
        self.page_argument_name = current_app.config['PAGINATION_PAGE_ARGUMENT_NAME'] 
 
    def paginate_query(self): 
        # If no page number is specified, we assume the request requires page #1 
        page_number = self.request.args.get(self.page_argument_name, 1, type=int) 
        paginated_objects = self.query.paginate( 
            page_number, 
            per_page=self.page_size, 
            error_out=False) 
        objects = paginated_objects.items 
        if paginated_objects.has_prev: 
            previous_page_url = url_for( 
                self.resource_for_url,  
                page=page_number-1,  
                _external=True) 
        else: 
            previous_page_url = None 
        if paginated_objects.has_next: 
            next_page_url = url_for( 
                self.resource_for_url, 
                page=page_number+1, 
                _external=True) 
        else: 
            next_page_url = None 
        dumped_objects = self.schema.dump(objects, many=True).data 
        return ({ 
            self.key_name: dumped_objects, 
            'previous': previous_page_url, 
            'next': next_page_url, 
            'count': paginated_objects.total 
        }) </pre>
<p>The <kbd>PaginationHelper</kbd> class declares a constructor, that is, the <kbd>__init__</kbd> method, which receives the following arguments and uses them to initialize the attributes with the same names:</p>
<ul>
<li><kbd>request</kbd>: The Flask request object that will allow the <kbd>paginate_query</kbd> method to retrieve the page number value specified with the HTTP request</li>
<li><kbd>query</kbd>: The SQLAlchemy query that the <kbd>paginate_query</kbd> method has to paginate</li>
<li><kbd>resource_for_url</kbd>: A string with the resource name that the <kbd>paginate_query</kbd> method will use to generate the full URLs for the previous page and the next page</li>
<li><kbd>key_name</kbd>: A string with the key name that the <kbd>paginate_query</kbd> method will use to return the serialized objects</li>
<li><kbd>schema</kbd>: The Flask-Marshmallow <kbd>Schema</kbd> subclass that the <kbd>paginate_query</kbd> method must use to serialize the objects</li>
</ul>
<p class="mce-root"/>
<p>In addition, the constructor reads and saves the values for the configuration variables we added to the <kbd>config.py</kbd> file in the <kbd>page_size</kbd> and <kbd>page_argument_name</kbd> attributes.</p>
<p>The class declares the <kbd>paginate_query</kbd> method. First, the code retrieves the page number specified in the request and saves it in the <kbd>page_number</kbd> variable. If no page number is specified, the code assumes that the request requires the first page. Then, the code calls the <kbd>self.query.paginate</kbd> method to retrieve the page number specified by <kbd>page_number</kbd> of the paginated result of objects from the database, with a number of results per page indicated by the value of the <kbd>self.page_size</kbd> attribute. The next line saves the paginated items from the <kbd>paginated_object.items</kbd> attribute in the <kbd>objects</kbd> variable.</p>
<p>If the value for the <kbd>paginated_objects.has_prev</kbd> attribute is <kbd>True</kbd>, it means that there is a previous page available. In this case, the code calls the <kbd>flask.url_for</kbd> function to generate the full URL for the previous page with the value of the <kbd>self.resource_for_url</kbd> attribute. The <kbd>_external</kbd> argument is set to <kbd>True</kbd> because we want to provide the full URL.</p>
<p>If the value for the <kbd>paginated_objects.has_next</kbd> attribute is <kbd>True</kbd>, it means that there is a next page available. In this case, the code calls the <kbd>flask.url_for</kbd> function to generate the full URL for the next page with the value of the <kbd>self.resource_for_url</kbd> attribute.</p>
<p>Then, the code calls the <kbd>self.schema.dump</kbd> method to serialize the partial results previously saved in the <kbd>objects</kbd> variable, with the <kbd>many</kbd> argument set to <kbd>True</kbd>. The <kbd>dumped_objects</kbd> variable saves the reference to the <kbd>data</kbd> attribute of the results returned by the call to the <kbd>dump</kbd> method.</p>
<p>Finally, the method returns a dictionary with the following key-value pairs:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Key</p>
</td>
<td>
<p>Value</p>
</td>
</tr>
<tr>
<td>
<p><kbd>self.key_name</kbd></p>
</td>
<td>
<p>The serialized partial results saved in the <kbd>dumped_objects</kbd> variable.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'previous'</kbd></p>
</td>
<td>
<p>The full URL for the previous page saved in the <kbd>previous_page_url</kbd> variable.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'next'</kbd></p>
</td>
<td>
<p>The full URL for the next page saved in the <kbd>next_page_url</kbd> variable.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>'count'</kbd></p>
</td>
<td>
<p>The total number of objects available in the complete result set retrieved from the <kbd>paginated_objects.total</kbd> attribute.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding pagination features</h1>
                
            
            
                
<p>Open the <kbd>views.py</kbd> file within the <kbd>service</kbd> folder and replace the code for the <kbd>NotificationListResource.get</kbd> method with the highlighted lines in the next listing. In addition, make sure that you add the highlighted import statement. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre><strong>from helpers import PaginationHelper</strong> 
 
 
class NotificationListResource(Resource): 
<strong>    def get(self):</strong><strong>        pagination_helper = PaginationHelper(</strong><strong>            request,</strong><strong>            query=Notification.query,</strong><strong>                            resource_for_url='service.notificationlistresource',</strong><strong>                                    key_name='results',</strong><strong>            schema=notification_schema)</strong><strong>        pagination_result = pagination_helper.paginate_query()</strong><strong>                return pagination_result</strong></pre>
<p>The new code for the ...</p></div>



  
<div><h1 class="header-title">Understanding the steps to add authentication and permissions</h1>
                
            
            
                
<p>Our current version of the API processes all the incoming requests without requiring any kind of authentication. We will use a Flask extension and other packages to use an HTTP authentication scheme to identify the user that originated the request or the token that signed the request. Then, we will use these credentials to apply the permissions that will determine whether the request must be permitted or not. Unluckily, neither Flask nor Flask-RESTful provide an authentication framework that we can easily plug and configure. Thus, we will have to write code to perform many tasks related to authentication and permissions.</p>
<p>We want to be able to create a new user without any authentication. However, all the other API calls are only going to be available for authenticated users.</p>
<p class="mce-root"/>
<p>First, we will install the <kbd>Flask-HTTPAuth</kbd> Flask extension to make it easier for us to work with HTTP authentication and the <kbd>passlib</kbd> package to allow us to hash a password and check whether a provided password is valid or not.</p>
<p>We will create a new <kbd>User</kbd> model that will represent a user. The model will provide methods to allow us to hash a password and verify whether a password provided for a user is valid or not. We will create a <kbd>UserSchema</kbd> class to specify how we want to serialize and deserialize a user.</p>
<p>Then, we will configure the Flask extension to work with our <kbd>User</kbd> model to verify passwords and set the authenticated user associated with a request. We will make changes to the existing resources to require authentication and we will add new resources to allow us to retrieve existing users and create a new one. Finally, we will configure the routes for the resources related to users.</p>
<p>Once we have completed the previously mentioned tasks, we will run the migrations process to generate the new table that persists the users in the database. Then, we will compose and send HTTP requests to understand how the authentication and permissions work with our new version of the API.</p>
<p>Make sure you quit Flask's development server. You just need to press Ctrl + C in the Terminal or Command Prompt window in which it is running.</p>
<p>Now, we will install many additional packages. Make sure you have activated the virtual environment we have created in <a href="dbf75cef-4962-4e40-8192-03873b774c48.xhtml" target="_blank">Chapter 1</a>, <em>Developing RESTful APIs and Microservices with Flask 1.0.2</em>, and we named <kbd>Flask01</kbd>. After you activate the virtual environment, it is time to run many commands that will be the same for either macOS, Linux, or Windows.</p>
<p>Now we will edit the existing <kbd>requirements.txt</kbd> file to specify the additional set of packages that our application requires to be installed in any supported platform. This way, it will be extremely easy to repeat the installation of the specified packages with their versions in any new virtual environment.</p>
<p>Use your favorite editor to edit the existing text file named <kbd>requirements.txt</kbd> within the root folder for the virtual environment. Add the following lines after the last line to declare the additional packages and the versions that our new version of the API requires. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/requirements.txt</kbd> file:</p>
<pre>flask-HTTPAuth==3.2.4 
passlib==1.7.1</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Each additional line added to the <kbd>requirements.txt</kbd> file indicates the package and the version that needs to be installed. The following table summarizes the packages and the version numbers that we specified as additional requirements to the previously included packages:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Package name</p>
</td>
<td>
<p>Version to be installed</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Flask-HTTPAuth</kbd></p>
</td>
<td>
<p>3.2.4</p>
</td>
</tr>
<tr>
<td>
<p><kbd>passlib</kbd></p>
</td>
<td>
<p>1.7.1</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>
<p>Now we must run the following command on macOS, Linux, or Windows to install the additional packages and the versions explained in the previous table with <kbd>pip</kbd> by using the recently edited <kbd>requirements.txt</kbd> file. Make sure you are in the folder that has the <kbd>requirements.txt</kbd> file before running the command:</p>
<pre><strong>    pip install -r requirements.txt</strong> </pre>
<p>The last lines for the output will indicate that all the new packages and their dependencies have been successfully installed. If you downloaded the source code for the example and you didn't work with the previous version of the API, <kbd>pip</kbd> will also install the other packages included in the <kbd>requirements.txt</kbd> file:</p>
<pre>    <strong>Installing collected packages: Flask-HTTPAuth, passlib</strong>
    <strong>Successfully installed Flask-HTTPAuth-3.2.4 passlib-1.7.1</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding a user model</h1>
                
            
            
                
<p>Now we will create the model that we will use to represent and persist a user. Open the <kbd>models.py</kbd> file within the <kbd>service</kbd> folder and add the following lines after the declaration of the <kbd>ResourceAddUpdateDelete</kbd> class. Make sure that you add the highlighted import statements. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/service/models.py</kbd> file:</p>
<pre><strong>from passlib.apps import custom_app_context as password_context</strong><strong>import re</strong> class User(orm.Model, ResourceAddUpdateDelete): id = orm.Column(orm.Integer, primary_key=True) name = orm.Column(orm.String(50), unique=True, nullable=False) # I save the hash for the password (I don't persist the actual password) password_hash = orm.Column(orm.String(120), ...</pre></div>



  
<div><h1 class="header-title">Creating schemas to validate, serialize, and deserialize users</h1>
                
            
            
                
<p>Now we will create the Flask-Marshmallow schema that we will use to validate, serialize, and deserialize the previously declared <kbd>User</kbd> model. Open the <kbd>models.py</kbd> file within the <kbd>service</kbd> folder and add the following code after the existing lines. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/service/models.py</kbd> file:</p>
<pre>class UserSchema(ma.Schema): 
    id = fields.Integer(dump_only=True) 
    name = fields.String(required=True,  
        validate=validate.Length(3)) 
    url = ma.URLFor('service.userresource',  
        id='&lt;id&gt;',  
        _external=True) </pre>
<p>The code declares the <kbd>UserSchema</kbd> schema, specifically a subclass of the <kbd>ma.Schema</kbd> class. Remember that the previous code we wrote for the <kbd>service/models.py</kbd> file created a <kbd>flask_marshmallow.Mashmallow</kbd> instance named <kbd>ma</kbd>.</p>
<p>We declare the attributes that represent fields as instances of the appropriate class declared in the <kbd>marshmallow.fields</kbd> module. The <kbd>UserSchema</kbd> class declares the <kbd>name</kbd> attribute as an instance of <kbd>fields.String</kbd>. The <kbd>required</kbd> argument is set to <kbd>True</kbd> to specify that the field cannot be an empty string. The <kbd>validate</kbd> argument is set to <kbd>validate.Length(5)</kbd> to specify that the field must have a minimum length of five characters.</p>
<p>The validation for the password isn't included in the schema. We will use the <kbd>check_password_strength_and_hash_if_ok</kbd> method defined in the <kbd>User</kbd> class to validate the password.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding authentication to resources</h1>
                
            
            
                
<p>Now we will perform the following tasks:</p>
<ol>
<li>Configure the <kbd>Flask-HTTPAuth</kbd> extension to work with our <kbd>User</kbd> model to verify passwords and set the authenticated user associated with a request.</li>
<li>Declare a custom function that the <kbd>Flask-HTTPAuth</kbd> extension will use as a callback to verify a password.</li>
<li>Create a new base class for our resources that will require authentication.</li>
</ol>

<p>Open the <kbd>views.py</kbd> file within the <kbd>service</kbd> folder and add the following code after the last line that uses the <kbd>import</kbd> statement and before the lines that declare the <kbd>Blueprint</kbd> instance named <kbd>service_blueprint</kbd>. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre>from flask_httpauth ...</pre></div>



  
<div><h1 class="header-title">Creating resource classes to handle users</h1>
                
            
            
                
<p>We just want to be able to create users and use them to authenticate requests. Thus, we will just focus on creating resource classes with just a few methods. We won't create a complete user management system.</p>
<p>We will create the resource classes that represent the user and the collection of users. First, we will create a <kbd>UserResource</kbd> class, which we will use to represent a user resource. Open the <kbd>views.py</kbd> file within the <kbd>service</kbd> folder and add the following lines after the line that creates the <kbd>Api</kbd> instance named <kbd>service</kbd> and before the declaration of the <kbd>NotificationResource</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre>class UserResource(AuthenticationRequiredResource): 
    def get(self, id): 
        user = User.query.get_or_404(id) 
        result = user_schema.dump(user).data 
        return result </pre>
<p>The <kbd>UserResource</kbd> class is a subclass of the previously coded <kbd>AuthenticationRequiredResource</kbd> and declares a <kbd>get</kbd> method that will be called when the HTTP method with the same name arrives as a request on the represented resource.</p>
<p>The method receives the id of the user that has to be retrieved in the <kbd>id</kbd> argument. The code calls the <kbd>User.query.get_or_404</kbd> method to return an HTTP <kbd>404 Not Found</kbd> status if there is no user with the requested id in the underlying database. If the user exists, the code calls the <kbd>user_schema.dump</kbd> method with the retrieved user as an argument to use the <kbd>UserSchema</kbd> instance to serialize the <kbd>User</kbd> instance whose <kbd>id</kbd> matches the specified <kbd>id</kbd>. The <kbd>dump</kbd> method takes the <kbd>User</kbd> instance and applies the field filtering and output formatting specified in the <kbd>UserSchema</kbd> class. The field filtering specifies that we don't want the hash for the password to be serialized. The code returns the <kbd>data</kbd> attribute of the result returned by the <kbd>dump</kbd> method, that is, the serialized message in JSON format as the body, with the default HTTP <kbd>200 OK</kbd> status code.</p>
<p>Now we will create the <kbd>UserListResource</kbd> class that we will use to represent the collection of users. Open the <kbd>views.py</kbd> file within the <kbd>service</kbd> folder and add the following lines after the code that creates the <kbd>UserResource</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre>class UserListResource(Resource): 
<strong>    @auth.login_required<br/></strong><strong>    def get(self):</strong> 
        pagination_helper = PaginationHelper( 
            request, 
            query=User.query, 
            resource_for_url='service.userlistresource', 
            key_name='results', 
            schema=user_schema) 
        result = pagination_helper.paginate_query() 
        return result 
 
<strong>    def post(self):</strong> 
        user_dict = request.get_json() 
        if not user_dict: 
            response = {'user': 'No input data provided'} 
            return response, HttpStatus.bad_request_400.value 
        errors = user_schema.validate(user_dict) 
        if errors: 
            return errors, HttpStatus.bad_request_400.value 
        user_name = user_dict['name'] 
        existing_user = User.query.filter_by(name=user_name).first() 
        if existing_user is not None: 
            response = {'user': 'An user with the name {} already exists'.format(user_name)} 
            return response, HttpStatus.bad_request_400.value 
        try: 
            user = User(name=user_name) 
            error_message, password_ok = \ 
                user.check_password_strength_and_hash_if_ok(user_dict['password']) 
            if password_ok: 
                user.add(user) 
                query = User.query.get(user.id) 
                dump_result = user_schema.dump(query).data 
                return dump_result, HttpStatus.created_201.value 
            else: 
                return {"error": error_message}, HttpStatus.bad_request_400.value 
        except SQLAlchemyError as e: 
            orm.session.rollback() 
            response = {"error": str(e)} 
            return response, HttpStatus.bad_request_400.value</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>UserListResource</kbd> class is a subclass of the <kbd>flask_restful.Resource</kbd> superclass because we don't want all the methods to require authentication. We want to be able to create a new user without being authenticated, and therefore, we apply the <kbd>@auth.login_required</kbd> decorator only for the <kbd>get</kbd> method. The <kbd>post</kbd> method doesn't require authentication. The class declares the following two methods that will be called when the HTTP method with the same name arrives as a request on the represented resource:</p>
<ul>
<li><kbd>get</kbd>: This method returns a list with all the <kbd>User</kbd> instances persisted in the database. First, the code calls the <kbd>User.query.all</kbd> method to retrieve all the <kbd>User</kbd> instances. Then, the code calls the <kbd>user_schema.dump</kbd> method with the retrieved users and the <kbd>many</kbd> argument set to <kbd>True</kbd> to serialize the iterable collection of objects. The <kbd>dump</kbd> method will take each <kbd>User</kbd> instance retrieved from the database and apply the field filtering and output formatting specified the <kbd>UserSchema</kbd> class. The code returns the <kbd>data</kbd> attribute of the result returned by the <kbd>dump</kbd> method, that is, the serialized messages in JSON format as the body, with the default HTTP <kbd>200 OK</kbd> status code.</li>
<li><kbd>post</kbd>: This method retrieves the key-value pairs received in the JSON body, creates a new <kbd>User</kbd> instance and persists it in the database. First, the code calls the <kbd>request.get_json</kbd> method to retrieve the key-value pairs received as arguments with the request. Then, the code calls the <kbd>user_schema.validate</kbd> method to validate the new user built with the retrieved key-value pairs. In this case, the call to this method will just validate the <kbd>name</kbd> field for the user. If there were validation errors, the code returns a tuple composed of the validation errors and an HTTP <kbd>400 Bad Request</kbd> status code. If the validation is successful, the code checks whether a user with the same name already exists in the database or not to return an appropriate error for the field that must be unique. If the username is unique, the code creates a new user with the specified <kbd>name</kbd> and calls its <kbd>check_password_strength_and_hash_if_ok</kbd> method. If the provided password fulfills all the quality requirements, the code persists the user with the hash for its password in the database. Finally, the code returns a tuple composed of the serialized saved user in JSON format as the body, with the HTTP <kbd>201 Created</kbd> status code.</li>
</ul>
<p class="mce-root"/>
<p>The following table shows the methods of our previously created classes related to users that we want to be executed for each combination of HTTP verb and scope:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Class and method</p>
</td>
<td>
<p>Requires authentication</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of users</p>
</td>
<td>
<p><kbd>UserListResource.get</kbd></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>User</p>
</td>
<td>
<p><kbd>UserResource.get</kbd></p>
</td>
<td>
<p>Yes</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of users</p>
</td>
<td>
<p><kbd>UserListResource.post</kbd></p>
</td>
<td>
<p>No</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines configure the resource routing for the user-related resources to the <kbd>service</kbd> object. Open the <kbd>views.py</kbd> file within the <kbd>service</kbd> folder and add the following lines at the end of the code. The code file for the sample is included in the <kbd>restful_python_2_03_02</kbd> folder, in the <kbd>Flask01/service/views.py</kbd> file:</p>
<pre>service.add_resource(UserListResource,  
    '/users/') 
service.add_resource(UserResource,  
    '/users/&lt;int:id&gt;') </pre>
<p>Each call to the <kbd>service.add_resource</kbd> method routes a URL to one of the previously coded user-related resources. When there is a request to the API, and the URL matches one of the URLs specified in the <kbd>service.add_resource</kbd> method, Flask will call the method that matches the HTTP verb in the request for the specified class.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Running migrations to generate the user table</h1>
                
            
            
                
<p>Now we will run many scripts to run migrations and generate the necessary table to persist users in the PostgreSQL 10.5 database. Make sure you run the scripts in the Terminal or Command Prompt window in which you have activated the virtual environment and that you are located in the <kbd>service</kbd> folder.</p>
<p>Run the first command that populates the migration script with the detected changes in the models. In this case, it is the second time we populate the migration script, and therefore, the migration script will generate the new table that will persist our new <kbd>User</kbd> model: <kbd>user</kbd>:</p>
<pre>    <strong>flask db migrate</strong></pre>




<p>The following lines show the sample output generated after running the previous command. Your output will ...</p></div>



  
<div><h1 class="header-title">Composing requests with the necessary authentication</h1>
                
            
            
                
<p>Now we will compose and send an HTTP request to retrieve the first page of the notifications without authentication credentials. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd317.txt</kbd> file:</p>
<pre>    <strong>http GET ":5000/service/notifications/?page=1"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd318.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:5000/service/notifications/?page=1"</strong></pre>
<p>We will receive a <kbd>401 Unauthorized</kbd> status code in the response header. The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.0 401 UNAUTHORIZED</strong>
    <strong>Content-Length: 19</strong>
    <strong>Content-Type: text/html; charset=utf-8</strong>
    <strong>Date: Sat, 20 Oct 2018 00:30:56 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    <strong>WWW-Authenticate: Basic realm="Authentication Required"</strong>
    
    <strong>Unauthorized Access</strong>
  </pre>
<p>If we want to retrieve notification, that is, to make a <kbd>GET</kbd> request to <kbd>/service/notifications/</kbd>, we need to provide authentication credentials by using HTTP authentication. However, before we can do this, it is necessary to create a new user. We will use the new user to test our new resource classes related to users and our changes in the permissions policies. Run the following command to create a new user. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd319.txt</kbd> file:</p>
<pre><strong>http POST ":5000/service/users/" name='gaston-hillar' password='wrongpassword'</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd320.txt</kbd> file:</p>
<pre><strong>curl -iX POST -H "Content-Type: application/json" -d '{"name": <br/>"gaston-hillar", "password": "wrongpassword"}' "localhost:5000/service/users/"</strong>
  </pre>
<p>Of course, the creation of a user and the execution of the methods that require authentication should only be possible under HTTPS. This way, the username and the password would be encrypted. The microservice that encapsulates the API in production must work under HTTPS.</p>
<p>The previous command will compose and send an HTTP <kbd>POST</kbd> request with the specified JSON key-value pairs. The request specifies <kbd>/service/users/</kbd>, and therefore, it will match the <kbd>'/users/'</kbd> URL route for the <kbd>UserList</kbd> resource and run the <kbd>UserList.post</kbd> method that doesn't require authentication. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <kbd>POST</kbd>, Flask calls the <kbd>post</kbd> method.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The previously specified password only includes lowercase letters, and therefore, it doesn't fulfill all the qualitative requirements we have specified for the passwords in the <kbd>User.check_password_strength_and_hash_if_ok</kbd> method. Thus, we will receive a <kbd>400 Bad Request</kbd> status code in the response header and the error message indicating the requirement that the password didn't fulfill the quality requirements in the JSON body. The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.0 400 BAD REQUEST</strong>
    <strong>Content-Length: 76</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sat, 20 Oct 2018 04:19:45 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    
   <strong>{</strong>
    <strong>    "error": "The password must include at least one uppercase <br/>    letter."</strong>
    <strong>}</strong>
  </pre>
<p>The following command will create a user with a valid password. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd321.txt</kbd> file:</p>
<pre><strong>http POST ":5000/service/users/" name='gaston-hillar' password='TTl#ID16^eplG'</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd322.txt</kbd> file:</p>
<pre> <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name": "gaston-hillar", "password": "TTl#ID16^eplG"}' "localhost:5000/service/users/"</strong>
  </pre>
<p>If the new <kbd>User</kbd> instance is successfully persisted in the database, the call will return an HTTP <kbd>201 Created</kbd> status code and the recently persisted <kbd>User</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>User</kbd> object in the JSON responses. Notice that the response includes the URL, <kbd>url</kbd>, for the created user and doesn't include any information related to the password:</p>
<pre>    <strong>HTTP/1.0 201 CREATED</strong>
    <strong>Content-Length: 97</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sat, 20 Oct 2018 15:58:15 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    
    <strong>{</strong>
    <strong>    "id": 1,</strong>
    <strong>    "name": "gaston-hillar",</strong>
    <strong>    "url": "http://localhost:5000/service/users/1"</strong>
    <strong>}</strong>
  </pre>
<p>We can run the previously explained command to check the contents of the <kbd>user</kbd> table that the migrations created in the PostgreSQL database. We will notice that the <kbd>password_hash</kbd> field contents are hashed for the new row in the <kbd>user</kbd> table. The following screenshot shows the contents for the new row of the <kbd>user</kbd> table in a PostgreSQL database after running the HTTP request:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f485275a-696b-4908-b9a6-1bf1317daee4.png" width="1219" height="237"/></p>
<p>If we want to retrieve the first page of notifications, that is, to make an HTTP <kbd>GET</kbd> request to <kbd>/service/notifications/</kbd>, we need to provide authentication credentials using HTTP authentication.</p>
<p>Now we will compose and send an HTTP request to retrieve the first page of messages with authentication credentials, that is, with the username we have recently created and his password. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd323.txt</kbd> file:</p>
<pre>    <strong>http -a 'gaston-hillar':'TTl#ID16^eplG' ":5000/service/notifications/?page=1"</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_03_01</kbd> folder, in the <kbd>Flask01/cmd324.txt</kbd> file:</p>
<pre><strong>curl --user 'gaston-hillar':'TTl#ID16^eplG' -iX GET "localhost:5000/service/notifications/?page=1"</strong>
  </pre>
<p>The user will be successfully authenticated and we will be able to process the request to retrieve the first page of the notifications persisted in the database. With all the changes we have made to our API, unauthenticated requests can only create a new user.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which HTTP verb is meant to replace an entire resource:
<ol>
<li> <kbd>PATCH</kbd></li>
<li><kbd>POST</kbd></li>
<li><kbd>PUT</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li>Which HTTP verb is meant to apply a delta to an existing resource:
<ol>
<li><kbd>PATCH</kbd></li>
<li><kbd>POST</kbd></li>
<li><kbd>PUT</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>By default, the <kbd>passlib</kbd> library will use the SHA-512 scheme for 64-bit platforms with the minimum number of rounds set to:
<ol>
<li>135,000</li>
<li>335,000</li>
<li>535,000</li>
</ol>
</li>
</ol>
<ol start="4">
<li>The <kbd>flask.g</kbd> object is:
<ol>
<li>A proxy that provides access to the current request</li>
<li>An instance of the <kbd>flask_httpauth.HTTPBasicAuth</kbd> class</li>
<li>A proxy that allows us to store on this whatever we want to share for one request only</li>
</ol>
</li>
</ol>
<ol start="5">
<li>The <kbd>passlib</kbd> package provides:
<ol>
<li>A password hashing framework that supports more than 30 schemes</li>
<li>An authentication framework ...</li></ol></li></ol></div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we improved the RESTful API in many ways. We added user-friendly error messages for when resources aren't unique. We tested how to update single or multiple fields with the <kbd>PATCH</kbd> method and we created our own generic pagination class to enable us to paginate result sets.</p>
<p>Then, we started working with authentication and permissions. We added a user model and we updated the underlying PostgreSQL database. We made many changes in the different pieces of code to achieve a specific security goal and we took advantage of <kbd>Flask-HTTPAuth</kbd> and <kbd>passlib</kbd> to use HTTP authentication in our API.</p>
<p>Now that we have built an improved a complex API that uses pagination and authentication, we will use additional abstractions included in the framework and we will code, execute and improve unit tests to get ready to encapsulate our API in a microservice, which are the topics of the next chapter.</p>


            

            
        
    </div>



  </body></html>