- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Retrieving and Handling Market Data with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python检索和处理市场数据
- en: If you look at the general logical diagram of a trading application’s architecture,
    which we devised in [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014), *Developing
    Trading Strategies – Why They Are Different*, you can see that now we’re moving
    from the very first module named `Receive data` to the second one, `Cleanup and
    filter`, which features the **Store** and **Retrieve** functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看我们设计的交易应用程序架构的一般逻辑图，该图在[*第一章*](B19145_01.xhtml#_idTextAnchor014)“开发交易策略——为什么它们不同”中有所描述，你会发现我们现在正从第一个名为`Receive
    data`的模块转向第二个模块，即`Cleanup and filter`，该模块具有**存储**和**检索**功能。
- en: In previous chapters, we mentioned many times that any algo trading application
    is based on market data, and success in algo trading (that is, the ability to
    make money and not lose it) depends on the quality of the data and its consistency.
    So, let’s proceed to determine which data we really need to collect and how to
    make sure the collected data is consistent, then decide about the internal format
    for the trading app, and the way to store, update, retrieve, and delete data (if
    necessary).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们多次提到，任何算法交易应用程序都是基于市场数据的，而算法交易的成功（即赚钱而不是亏损的能力）取决于数据的质量和一致性。因此，让我们继续确定我们真正需要收集哪些数据，以及如何确保收集到的数据是一致的，然后决定交易应用程序的内部格式，以及存储、更新、检索和删除数据（如果需要）的方式。
- en: Upon finishing this chapter, you will have a clear understanding of the most
    efficient ways of handling and processing market data, and, most importantly,
    you will learn how to keep your trading app universal so that it could be connected
    to virtually any data source, live or historical, without rewriting all your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这一章后，你将对处理和加工市场数据的最有效方法有一个清晰的理解，最重要的是，你将学会如何使你的交易应用通用，以便它可以连接到几乎任何数据源，无论是实时数据还是历史数据，而无需重写所有代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Navigating through data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据导航
- en: Data compression—keeping the amounts to a reasonable minimum
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据压缩——将数量保持在合理的最低水平
- en: Working with saved and live data—keeping your app universal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与保存的和实时数据一起工作——保持你的应用通用
- en: Navigating through data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据导航
- en: 'The problem with data collection starts at the very beginning: every data provider
    offers its own data, quite often in its own format. Some data providers offer
    only compressed data or snapshots (see later in this chapter) while others broadcast
    tick-by-tick data; very few data providers also offer order book (**depth of market**
    or **DOM**; see [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX Market Overview
    from a Developer’s* *Standpoint*) data.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据收集的问题始于一开始：每个数据提供商都提供自己的数据，很多时候是以自己的格式提供。一些数据提供商只提供压缩数据或快照（见本章后面），而其他数据提供商则广播逐tick数据；非常少的数据提供商也提供订单簿（**市场深度**或**DOM**；见[*第三章*](B19145_03.xhtml#_idTextAnchor044)“从开发者的角度来看的FX市场概述”）数据。
- en: 'So, first and above all, you should decide on the data granularity: whether
    your trading algorithm requires tick-by-tick or compressed data, and if you need
    DOM data or not. At this stage, you may feel lost with these questions, but don’t
    worry—you will get a very clear understanding of your data needs when you’ve accomplished
    further chapters of this book.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先也是最重要的，你应该决定数据粒度：你的交易算法是否需要逐tick数据或压缩数据，以及你是否需要DOM数据。在这个阶段，你可能对这些问题的感觉会有些迷茫，但不用担心——当你完成这本书的后续章节时，你会对你的数据需求有一个非常清晰的理解。
- en: Let’s consider all three cases and see how we can actually handle ticks, snapshots,
    and DOM market data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑所有三种情况，看看我们如何实际处理tick、快照和DOM市场数据。
- en: Tick data and snapshots
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tick数据和快照
- en: I would like to reiterate that when we talk about third-party data, formats,
    and protocols, the ultimate source of the exact information about what is supported
    and how the third-party documentation is done is your broker.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我要重申，当我们谈论第三方数据、格式和协议时，关于支持什么以及第三方文档是如何完成的准确信息的最终来源是你的经纪人。
- en: 'However, in general, all data providers support two types of market data: tick
    and snapshots.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一般来说，所有数据提供商都支持两种类型的市场数据：tick和快照。
- en: 'Let’s quickly recap the terminology:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下术语：
- en: 'A **tick** is a recorded change in any of the three prices of the traded asset:
    bid, ask (offer), and last'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tick**是指交易资产（如：买入价、卖出价（报价）和最新价）中的任何一种价格的变化。'
- en: '**Bid** is the price at which market makers, liquidity providers, and other
    price givers agree to buy—and consequently, this is the price at which price takers
    can sell'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bid** 是市场制造者、流动性提供者和其他价格提供者同意购买的价格——因此，这也是价格接受者可以出售的价格'
- en: '**Ask** or **offer** is the price at which price givers are ready to sell—and
    consequently, this is the price at which price takers can buy'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ask** 或 **offer** 是价格提供者愿意出售的价格——因此，这也是价格接受者可以购买的价格'
- en: And **last** is the price at which the latest actual trade was made
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个是最新实际交易的价格
- en: 'Let’s consider an example. This is sample tick data that you can receive from
    LMAX (see the previous chapter for more examples of connecting and retrieving
    data from this **electronic communication** **network** (**ECN**)):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。这是你可以从LMAX收到的示例tick数据（有关连接和检索此**电子通信网络**（**ECN**）数据的更多示例，请参阅上一章）：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, the preceding JSON specifies the type of data. In this example, `type`
    is `TICKER`, which means that we’re dealing with a single tick. It is followed
    by the instrument name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前面的JSON指定了数据的类型。在这个例子中，`type` 是 `TICKER`，这意味着我们正在处理单个tick。它后面跟着工具名称。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Many data providers use different notations for the same names of instruments.
    For example, EUR/USD can be represented by `eur-usd`, `EURUSD`, `EUR/USD`, and
    even `@EURUSD`. So, always check the data provider’s documentation, and don’t
    forget to replace the instrument’s name in the provider’s notation with the internal
    name used in your application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据提供者对同一工具名称使用不同的表示法。例如，EUR/USD 可以表示为 `eur-usd`、`EURUSD`、`EUR/USD`，甚至 `@EURUSD`。因此，请始终检查数据提供者的文档，并且不要忘记将提供者表示法中的工具名称替换为应用程序中使用的内部名称。
- en: 'For example, if you use the traditional `CCY1/CCY2` notation, then you may
    want to use the following code, which will transform the `ccy1-ccy2` notation
    used by LMAX to the traditional one:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用传统的 `CCY1/CCY2` 表示法，那么你可能想使用以下代码，它将LMAX使用的 `ccy1-ccy2` 表示法转换为传统表示法：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `instrument_id` is the name of the instrument received with a tick from
    the data provider, `replace()` is the built-in sting method that replaces one
    character with another, and `upper()` is another built-in method that makes the
    entire string uppercase.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`instrument_id` 是从数据提供者收到的带有tick的工具名称，`replace()` 是内置的字符串方法，用于将一个字符替换为另一个字符，而
    `upper()` 是另一个内置方法，它将整个字符串转换为大写。
- en: Next comes the timestamp, and with timestamps comes another degree of uncertainty
    because data providers use different standards for timestamps. We will discuss
    timestamps for market data a bit later in this section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是时间戳，时间戳带来了另一个不确定性，因为数据提供者使用不同的标准来表示时间戳。我们将在本节稍后讨论市场数据的时间戳。
- en: 'The following fields are self-explanatory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字段是自解释的：
- en: '`best_bid` and `best_ask` mean the top of the book'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`best_bid` 和 `best_ask` 表示订单簿的顶部'
- en: '`trade_id` is the ID of the latest trade made at this ECN'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trade_id` 是在此ECN上最新交易的唯一标识符'
- en: '`last_quantity` and `last_price` are the size and price at which this latest
    trade was made'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_quantity` 和 `last_price` 是最新交易的大小和价格'
- en: '`session_open`, `session_low`, and `session_high` mean the first price of the
    trading session (when the market opens), and the lowest and the highest price
    from the time the market opened till the time the tick is received'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session_open`、`session_low` 和 `session_high` 表示交易时段的第一个价格（当市场开盘时），以及从市场开盘到收到tick的时间内的最低价和最高价'
- en: 'As we can see, most of the fields in a tick are self-explanatory and easy to
    use, but there’s one important exception: `timestamp`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，tick中的大多数字段都是自解释的，易于使用，但有一个重要的例外：`timestamp`。
- en: Timestamps – be careful comparing apples to apples!
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间戳——注意比较苹果和苹果！
- en: In the previous section, when we were analyzing the structure of a tick, we
    noted that it contained a timestamp and that this timestamp may become another
    source of headache for the developer. This happens because every data provider
    thinks they’re using the most convenient data format. As always, refer to the
    provider’s documentation and refer to any tutorial on working with timestamps.
    If you’re not familiar with timestamps and their standards, I’d recommend starting
    with an excellent tutorial on working with timestamps in Python by Avinash Navlani
    on *Dataquest* ([https://www.dataquest.io/blog/python-datetime-tutorial](https://www.dataquest.io/blog/python-datetime-tutorial)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，当我们分析tick的结构时，我们注意到它包含一个时间戳，而这个时间戳可能会成为开发者的另一个头疼之源。这是因为每个数据提供者都认为他们使用的是最方便的数据格式。一如既往，请参考提供者的文档，并参考任何关于处理时间戳的教程。如果你不熟悉时间戳及其标准，我建议从
    Avinash Navlani 在 *Dataquest* 上关于在 Python 中处理时间戳的优秀教程开始（[https://www.dataquest.io/blog/python-datetime-tutorial](https://www.dataquest.io/blog/python-datetime-tutorial)）。
- en: Anyway, to keep things simple, a timestamp is a string formatted to one of the
    standards, and this formatting is normally done by whitespaces, special characters,
    or regular characters. In the LMAX example in the previous section, the date part
    is separated from the time part by the letter `T`, and the entire timestamp is
    ended with the letter `Z`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，为了简化问题，时间戳是一个按照某种标准格式化的字符串，这种格式化通常是通过空格、特殊字符或普通字符来完成的。在前一节的 LMAX 示例中，日期部分通过字母
    `T` 与时间部分分开，整个时间戳以字母 `Z` 结尾。
- en: Python provides a `datetime` library that covers flexible handling of timestamps.
    This library introduces the eponymous `datetime` object, which has multiple methods
    to convert strings into timestamps and vice versa. In the upcoming example, we’re
    going to use `strptime``()` to convert the timestamp from a string to a native
    `datetime` object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个 `datetime` 库，它可以灵活地处理时间戳。这个库引入了同名的 `datetime` 对象，它具有多种方法可以将字符串转换为时间戳，反之亦然。在接下来的示例中，我们将使用
    `strptime()` 将时间戳从字符串转换为原生的 `datetime` 对象。
- en: By using `strptime()` and other methods, all you need is to specify the format
    of the input timestamp using correct specifiers (see the Python documentation
    at [https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior)
    for a complete list of specifiers).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `strptime()` 和其他方法，你所需要做的只是指定输入时间戳的格式，使用正确的指定符（有关指定符的完整列表，请参阅 Python 文档中的
    [https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior)）。
- en: 'So, let’s convert the timestamp from our LMAX example into a native `datetime`
    object. First, we import `datetime` from the `datetime` library (yes—it does look
    ridiculous, but what to do?) and then make the conversion:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将 LMAX 示例中的时间戳转换为原生的 `datetime` 对象。首先，我们从 `datetime` 库中导入 `datetime`（是的，它看起来很荒谬，但又能怎么办呢？）然后进行转换：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we assume that `ts_str1` is the timestamp already extracted from the
    tick received from LMAX as XML (JSON). If we run this code and check the value
    of `ts1`, then we will see the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设 `ts_str1` 是从 LMAX 收到的tick中已提取的时间戳，作为XML（JSON）。如果我们运行此代码并检查 `ts1` 的值，那么我们将看到以下内容：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that the conversion was made correctly, and now we can access any
    component of the timestamp separately. For example, `ts1.day` returns `29` (the
    day of the month), and `ts1.microsecond` returns `755000`, which is actually `755`
    milliseconds.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着转换已经正确完成，现在我们可以单独访问时间戳的任何组件。例如，`ts1.day` 返回 `29`（月份中的日期），而 `ts1.microsecond`
    返回 `755000`，这实际上是 `755` 毫秒。
- en: 'The real advantage of using `datetime` objects is that they can be sorted like
    numbers. For example, if we receive a new timestamp that is just 1 millisecond
    past the original one (`ts_str2 = ''2022-07-29T11:10:54.756Z''`) and convert it
    into a new `datetime` object (`ts2 = datetime.strptime(ts_str2, ''%Y-%m-%dT%H:%M:%S.%fZ'')`),
    then we can easily compare two timestamps, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `datetime` 对象的真正优势是它们可以像数字一样排序。例如，如果我们收到一个新的时间戳，它只是比原始时间戳晚 1 毫秒（`ts_str2
    = '2022-07-29T11:10:54.756Z'`），并将其转换为新的 `datetime` 对象（`ts2 = datetime.strptime(ts_str2,
    '%Y-%m-%dT%H:%M:%S.%fZ')`），那么我们可以轻松地比较两个时间戳，如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Subsequently, we can sort them in ascending or descending order.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们可以按升序或降序对它们进行排序。
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Never use strings as IDs of timestamps for market data time series. You won’t
    be able to easily sort data by the exact time it’s arrived, and thus handling
    data will be extremely inefficient. Use native `datetime` or pandas timestamps
    (see the next section).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用字符串作为市场数据时间序列的时间戳ID。你将无法轻松按到达的确切时间排序数据，因此处理数据将极其低效。请使用原生的`datetime`或pandas时间戳（参见下一节）。
- en: Storing and retrieving tick data
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和检索tick数据
- en: 'There are three main approaches to storing and processing tick data in Python:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中存储和处理tick数据主要有三种方法：
- en: Using high-level objects
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级对象
- en: Using low-level objects
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用底层对象
- en: Using pandas
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pandas
- en: High-level objects are normally created for storing considerable amounts of
    data or processing the entire historical data (see [*Chapter 2*](B19145_02.xhtml#_idTextAnchor028)*,
    Using Python for Trading Strategies*). In this case, we create a single object
    whose properties include lists (in case we’re going to store data samples one
    by one and refer to them by index) or dictionaries (in case we use timestamps
    to refer to a data sample).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 高级对象通常用于存储大量数据或处理整个历史数据（参见[*第2章*](B19145_02.xhtml#_idTextAnchor028)*，使用Python进行交易策略*）。在这种情况下，我们创建一个单一的对象，其属性包括列表（如果我们打算逐个存储数据样本并按索引引用它们）或字典（如果我们使用时间戳来引用数据样本）。
- en: 'Using dictionaries allows for quick and easy handling of data by timestamp,
    so this is the preferred method of storing market data. Let’s see an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典允许通过时间戳快速轻松地处理数据，因此这是存储市场数据的首选方法。让我们看一个例子：
- en: 'Let’s begin with creating a general class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个通用类开始：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `main` dictionary will store all data samples with timestamps used as keywords.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`main`字典将存储所有使用时间戳作为关键字的数据样本。
- en: 'Now, let’s add a method that adds a new data sample to the `main` dictionary:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个方法，将新的数据样本添加到`main`字典中：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we assume that the data sample comes in a form similar to that used by
    LMAX—that is, JSON, which contains a timestamp in *ISO 8601* format. Since the
    JSON (or XML in general) is basically the same as native Python dictionaries,
    we add a dictionary to the dictionary. Now, referring to `self.series` by the
    timestamp as the keyword will return another dictionary that contains the data
    sample itself. This is what we referred to as *low-level objects* at the beginning
    of this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设数据样本的形式类似于LMAX使用的形式——即JSON，其中包含*ISO 8601*格式的时间戳。由于JSON（或通用的XML）基本上与原生的Python字典相同，我们在字典中添加了一个字典。现在，通过时间戳作为关键字引用`self.series`将返回另一个包含数据样本本身的字典。这就是我们在本节开头提到的*底层对象*。
- en: Important note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: We can refer to ticks by timestamp only in case the data feed doesn’t send ticks
    with identical timestamps. This is mostly the case with direct feeds from trading
    venues. The suggested code will always rewrite the contents of a tick with the
    last received value with the same timestamp, so if you really need to keep all
    ticks stored, consider adding **unique IDs** (**UIDs**) to them. The public LMAX
    data feeds that we’re using throughout the book for development and testing purposes
    never send ticks with identical timestamps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在数据馈送不发送具有相同时间戳的tick时，我们才能通过时间戳引用tick。这种情况通常出现在来自交易场所的直接馈送中。建议的代码将始终用具有相同时间戳的最后一个接收到的值重写tick的内容，因此如果你真的需要保留所有存储的tick，请考虑为它们添加**唯一标识符**（**UIDs**）。本书中用于开发和测试目的的公共LMAX数据馈送从未发送具有相同时间戳的tick。
- en: 'So, now, let’s add a basic function that finds a data sample by its timestamp:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在，让我们添加一个基本函数，通过时间戳查找数据样本：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that two keywords (`[ts]` and `[key]`) are used here, one immediately
    after another. This is exactly because of the data structure just explained: we
    have dictionaries in a dictionary, so the first keyword `[ts]` retrieves the data
    sample dictionary, and the second one—`[key]`—actually returns the value.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里使用了两个关键字（`[ts]`和`[key]`），一个紧接着另一个。这正是因为刚刚解释的数据结构：我们有一个字典中的字典，所以第一个关键字`[ts]`检索数据样本字典，而第二个关键字——`[key]`——实际上返回值。
- en: 'It is important to note here that such a method of retrieving ticks by their
    timestamps assumes that we know the exact timestamp with milliseconds precision.
    If we are unsure about it or want to extract a few ticks that came—for example—in
    1 second or even 1 minute, we can use the following code, which will return a
    list of ticks whose timestamps start with the same time (actually, we look for
    a substring in the `timestamp` key):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，通过时间戳检索刻度的这种方法假设我们知道确切的毫秒级时间戳。如果我们不确定或者想要提取例如在1秒或甚至1分钟内到达的几个刻度，我们可以使用以下代码，它将返回一个时间戳以相同时间开始的刻度列表（实际上，我们在`timestamp`键中查找子字符串）：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'OK—let’s give our code a try. Let’s use the same example as before—create a
    new data series object, add a sample to it, and read the `trade_id` value:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的——让我们尝试一下我们的代码。让我们使用之前的例子——创建一个新的数据序列对象，向其中添加一个样本，并读取`trade_id`值：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we run this code (not forgetting to add `from datetime import datetime` at
    the very beginning), we will get `0B5WMAAAAAAAAAAS`, which is indeed the trade
    ID of the stored tick data sample.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码（不要忘记在开头添加`from datetime import datetime`），我们将得到`0B5WMAAAAAAAAAAS`，这确实是存储的刻度数据样本的交易ID。
- en: This way, we can easily implement creating, adding, and reading data from our
    storage without using any database. Of course, this approach will somewhat limit
    the capabilities of retrieving and aggregating data by other keys—for example,
    retrieving all ticks with the same price or with a trade quantity that lies in
    a certain range.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以轻松地实现创建、添加和从我们的存储中读取数据，而不需要使用任何数据库。当然，这种方法将在某种程度上限制通过其他键检索和聚合数据的能力——例如，检索所有具有相同价格或交易数量位于某个范围内的刻度。
- en: Remember
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住
- en: Ignoring or messing with the data, especially the order in which ticks or bars
    are received, will most likely lead you to develop a strategy which will work
    only on this damaged data, and won’t work with real market data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略或篡改数据，尤其是接收到的刻度或条形图顺序，很可能会让你开发出一个仅在损坏数据上才能工作的策略，而无法与真实市场数据兼容。
- en: 'So, for most practical trading applications, it is even better not to be able
    to get data by any other keyword except for the timestamp. However, if you’re
    into some kind of academic research and do need special modes of data retrieval,
    there’s good news for you: pandas will allow you to do even this (we will have
    a surface look at pandas in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130), *Data
    Visualization in FX Trading* *with Python*).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于大多数实际交易应用来说，最好只能通过时间戳以外的任何关键词来获取数据。然而，如果你从事某种学术研究并且确实需要特殊的数据检索模式，那么对你来说是个好消息：pandas
    允许你做到这一点（我们将在[*第8章*](B19145_08.xhtml#_idTextAnchor130)，*使用 Python 进行外汇交易中的数据可视化*)进行简要介绍）。
- en: An alternative way to store tick market data would be in a list, not a dictionary.
    This way, we could forget about timestamps and read data samples one by one, using
    an index—which is especially useful when running backtests using historical data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 存储市场数据的另一种方式是将数据存储在列表中，而不是字典中。这样，我们可以忘记时间戳，并逐个读取数据样本，使用索引——这在使用历史数据进行回测时特别有用。
- en: However, there’s one significant problem with storing market data in lists.
    In case you need to add any data sample *in the past*, you will have to scan the
    list to find the correct place where to insert the new sample, and this operation
    is quite time-consuming. So, using dictionaries with timestamps as keywords is
    always preferable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将市场数据存储在列表中存在一个显著问题。如果你需要添加任何过去的数据样本，你必须扫描列表以找到插入新样本的正确位置，而这个操作相当耗时。因此，使用以时间戳为关键词的字典总是更可取。
- en: You may argue that inserting a sample *in the past* sounds ridiculous and is
    hardly required. Well, just go on reading this chapter, and in the section dedicated
    to cleaning up the market data, you will see how in demand such a capability may
    be.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为在过去的某个时间插入一个样本听起来很荒谬，而且几乎不需要。好吧，继续阅读这一章，在专门介绍清理市场数据的部分，你会看到这种能力是多么受欢迎。
- en: Order book (depth of market)
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订单簿（市场深度）
- en: Some data providers (not many, actually) are kind enough to provide not only
    top of book (the best bid and ask prices), but also some depth of market (see
    the *Exchange and order book* section of [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044),
    *FX Market Overview from a Developer’s Standpoint*). In general, receiving order
    book data is not much different from receiving ticker data. The only difference
    is that ticker data contains a single value for each bid, ask, and last price,
    whereas order book data contains multiple values for bids and asks and does not
    contain any last value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据提供商（实际上并不多）非常慷慨，不仅提供顶部的订单簿（最佳买价和卖价），还提供一些市场深度（参见[*第3章*](B19145_03.xhtml#_idTextAnchor044)的*“交易所和订单簿”部分，*从开发者角度的FX市场概述*）。一般来说，接收订单簿数据与接收股票行情数据没有太大区别。唯一的区别是，股票行情数据包含每个买价、卖价和最后价格的单个值，而订单簿数据包含多个买价和卖价的值，并且不包含任何最后值。
- en: Storing and retrieving order book data
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储和检索订单簿数据
- en: 'If we look at the example provided by LMAX in its API documentation, we can
    see that the JSON representing the order book information can be interpreted by
    Python as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看LMAX在其API文档中提供的示例，我们可以看到表示订单簿信息的JSON可以被Python解释如下：
- en: '**Highest level**: A dictionary similar to that of ticker data, but without
    last trade and session information'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最高级别**：一个类似于股票行情数据的字典，但没有最后交易和会话信息'
- en: '**Lower level**: A list of bids and asks, sorted by price in descending and
    ascending order, respectively'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低级别**：一个按价格降序和升序排序的买价和卖价列表'
- en: '**Lowest level**: Another dictionary that contains the actual price and quantity
    for each bid and ask:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最低级别**：另一个包含每个买价和卖价的实际价格和数量的字典：'
- en: '[PRE31]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Therefore, we can use exactly the same code as we originally used for storing,
    adding, and reading tick data. We will only need to add another level of indexes
    and keywords to access actual values. For example, if we add the preceding sample,
    then we can retrieve the best bid price by the timestamp using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用与最初用于存储、添加和读取tick数据完全相同的代码。我们只需要添加另一个索引级别和关键字来访问实际值。例如，如果我们添加前面的示例，那么我们可以通过以下代码使用时间戳检索最佳买价：
- en: '[PRE58]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The beginning of this line is identical to that of the example with ticker data
    from the previous section, then follows the index `[0]`, which is used to retrieve
    the best bid (as both bids and asks are sorted, the first element in the list
    always contains the best bid or ask), and finally, another keyword—`price`, used
    to retrieve the price information out of the price/volume pair.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这行的开头与上一节中来自股票行情数据的示例相同，然后是索引 `[0]`，它用于检索最佳买价（由于买价和卖价都已排序，列表中的第一个元素总是包含最佳买价或卖价），最后是另一个关键字—`price`，用于从价格/量对中检索价格信息。
- en: Now, we can retrieve tick data, but remember that it may occupy too much space
    in memory or on disk. So, it would be nice to use only the required amount of
    data for a specific trading strategy. That’s why we proceed with data compression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检索tick数据，但请记住，它可能在内存或磁盘上占用太多空间。所以，只使用特定交易策略所需的数据量会更好。这就是我们进行数据压缩的原因。
- en: Data compression – keeping the amounts to a reasonable minimum
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据压缩——将数量保持在合理的最低水平
- en: 'In the previous section, we already considered one of the most popular data
    compression techniques used by data providers: snapshots. The difference is that
    a tick represents a single event (such as a new trade or a change in bid or ask)
    and a single price value, but a snapshot instead discards information about individual
    ticks and replaces it with the following prices per period:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经考虑了数据提供商使用的一种最流行的数据压缩技术：快照。区别在于，一个tick代表一个单一事件（如新交易或买价或卖价的变化）和一个单一的价格值，但快照会丢弃关于单个tick的信息，并用每个周期内的以下价格来替换：
- en: Price of the first tick of the period (or **open**)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期第一个tick的价格（或**开盘价**）
- en: Maximum price for the period (or **high**)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期最高价格（或**最高价**）
- en: Minimum price for the period (or **low**)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期最低价格（或**最低价**）
- en: Price of the last tick of the period (or **close**)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期最后一个tick的价格（或**收盘价**）
- en: For example, if the period is 1 minute and during this minute 100 trades were
    placed, then the snapshot will replace 100 ticks (or 100 prices) with just 4 prices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果周期为1分钟，在这1分钟内进行了100次交易，那么快照将用仅仅4个价格来替换100个tick（或100个价格）。
- en: 'The resulting snapshots are called bars when plotted on charts. Very frequently,
    traders and developers use *bars* instead of *snapshots*. Graphically, a bar is
    typically presented as a vertical line with two dashes. As you can see in the
    following diagram, the one pointing to the left means the opening (first) price
    of the interval represented by this bar, and the one pointing to the right means
    the last (closing) price of the same interval, while the top and bottom of the
    vertical line represent the maximum and the minimum prices of the interval, respectively.
    These bars are called **Open-High-Low-Close bars** or **OHLC bars**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当在图表上绘制时，产生的快照被称为柱状图。非常频繁地，交易者和开发者使用*柱状图*而不是*快照*。从图形上看，柱状图通常表示为带有两个虚线的垂直线。正如你在以下图中可以看到的，指向左侧的虚线表示该柱状图所代表区间的开盘（第一）价格，指向右侧的虚线表示同一区间的最后（收盘）价格，而垂直线的顶部和底部分别代表区间的最高价和最低价。这些柱状图被称为**开盘-最高-最低-收盘柱状图**或**OHLC柱状图**：
- en: '![Figure 5.1 – Bars and Japanese candlesticks as a visual representation of
    data compression](img/B19145_5_1.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 柱状图和日本蜡烛图作为数据压缩的视觉表示](img/B19145_5_1.jpg)'
- en: Figure 5.1 – Bars and Japanese candlesticks as a visual representation of data
    compression
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 柱状图和日本蜡烛图作为数据压缩的视觉表示
- en: In case the left dash is lower than the right one, we say that the bar *closes
    up* or the price movement was upward during that period of time (during that bar).
    If the right dash is lower than the left one, we say that the bar *closes down*
    or the price movement was downward.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧的虚线低于右侧的虚线，我们说柱状图*收盘价上升*或在该时间段（在该柱状图期间）价格走势是上升的。如果右侧的虚线低于左侧的虚线，我们说柱状图*收盘价下降*或价格走势是下降的。
- en: 'There is another way of presenting bars, which is known as **Japanese candlesticks**.
    They don’t have dashes to the left and to the right, but instead the range between
    the open and close prices is drawn as a rectangle. And to show whether the opening
    price was greater or less than the closing one, we use color coding: white or
    green normally means that the bar closes up (that the closing price was greater
    than the opening one), and black or red means that the bar closes down.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表示柱状图的另一种方式被称为**日本蜡烛图**。它们左右没有虚线，而是将开盘价和收盘价之间的范围绘制为矩形。为了显示开盘价是否高于或低于收盘价，我们使用颜色编码：通常是白色或绿色表示柱状图收盘价上升（收盘价高于开盘价），黑色或红色表示柱状图收盘价下降。
- en: Then, is data compression good or bad?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，数据压缩是好事还是坏事？
- en: 'Of course, the answer depends on the intended purpose of using the data compression.
    In general, data compression allows us to dramatically reduce storage space. Just
    to give you an idea: 4 years’ worth of historical market data compressed into
    1-minute bars takes about 152 MB if saved as an American Standard Code for Information
    Interchange (ASCII) CSV file. The same time span of tick data will take about
    1.4 to 3 GB depending on the type of tick data (whether only the last trade is
    transmitted as a tick or every change in bid or ask price is included).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，答案取决于使用数据压缩的预期目的。一般来说，数据压缩可以让我们显著减少存储空间。仅为了给你一个概念：将4年的历史市场数据压缩成1分钟柱状图，如果保存为美国信息交换标准代码（ASCII）CSV文件，大约需要152
    MB。同样时间段的时间戳数据，根据时间戳数据的类型（是否仅传输最后交易作为时间戳，或者包括每次买卖价格的变化），大约需要1.4到3 GB。
- en: Besides that, using data in compressed format radically speeds up the backtesting
    process (remember that backtesting means simulating trades generated by the algorithm
    using pre-stored historical price data). No surprise that processing 100,000 records
    is much faster than processing 1 million.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，使用压缩格式的数据可以极大地加快回测过程（记住，回测意味着使用预先存储的历史价格数据来模拟算法生成的交易）。处理10万条记录比处理100万条记录快得多，这并不令人惊讶。
- en: Therefore, when you use historical data from a data vendor or download it from
    your broker’s website, most likely it will be compressed down to 1 minute, 10
    seconds, or 1 second, but anyway it’s unlikely to be raw tick data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你使用数据供应商的历史数据或从你的经纪人的网站上下载时，很可能会将其压缩到1分钟、10秒或1秒，但无论如何，不太可能是原始的时间戳数据。
- en: When developing trading strategies, we often use much less granular resolutions,
    such as 1 hour, 4 hours, 1 day, and sometimes even 1 week or 1 month.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发交易策略时，我们通常使用更少粒度的分辨率，例如1小时、4小时、1天，有时甚至1周或1个月。
- en: However, using compressed data has a serious disadvantage for developers. Since
    individual ticks are gone, we cannot say which price came first, second, and so
    on inside an individual bar. In [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation in Python*, we will consider serious issues
    related to using compressed data in trade simulation and see how we can minimize
    the risk of making a mistake.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用压缩数据对开发者来说有一个严重的缺点。由于单个tick已经消失，我们无法在单个条中说出哪个价格先出现，第二个，以此类推。在[*第10章*](B19145_10.xhtml#_idTextAnchor171)，“Python中的订单类型及其模拟”，我们将考虑与使用压缩数据进行交易模拟相关的一些严重问题，并看看我们如何最大限度地减少犯错的几率。
- en: As we are now familiar with the concept of data compression, let’s see how we
    can practically use it. We will start with retrieving already compressed data
    and then see how we can compress data in our own code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在熟悉数据压缩的概念，让我们看看我们如何实际使用它。我们将从检索已压缩数据开始，然后看看我们如何在我们的代码中压缩数据。
- en: Retrieving compressed data
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取压缩数据
- en: 'Some data vendors, brokers, and trading venues use compressed data for live
    streaming, but most use it for historical data. In this case, you can download
    it as XML or—more frequently—as traditional CSV files. Contents again (as always!)
    depend on the data provider’s free will, but at the very least it should contain
    the timestamp and the OHLC price data. Some data providers also include the trading
    volume data and even the number of upticks and downticks (moments when the price
    changed up or down respectively), as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据供应商、经纪人和交易场所使用压缩数据进行实时流，但大多数用于历史数据。在这种情况下，您可以将其下载为XML格式，或者更常见的是，作为传统的CSV文件。内容（就像往常一样！）取决于数据供应商的自由意志，但至少应该包含时间戳和开盘价、最高价、收盘价和最低价（OHLC）数据。一些数据供应商还包括交易量数据，甚至包括上涨和下跌的次数（价格分别上涨或下跌的时刻），如下所示：
- en: '[PRE59]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let’s see how we can efficiently read, store, and retrieve historical
    compressed price data:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何高效地读取、存储和检索历史压缩价格数据：
- en: 'First, we need some preparations. We will obviously need the `datetime` module,
    storage for all data (dictionary), and storage for an individual data sample (another
    dictionary):'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要做一些准备工作。显然，我们需要`datetime`模块，用于存储所有数据的存储空间（字典），以及用于存储单个数据样本的存储空间（另一个字典）：
- en: '[PRE60]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we need to read the data. If we’re working with a CSV file, it can be
    done very easily, as shown here:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要读取数据。如果我们正在处理CSV文件，这可以非常容易地完成，如下所示：
- en: '[PRE63]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let’s read the first line (the header) to avoid possible errors when parsing
    price data:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们读取第一行（标题行），以避免在解析价格数据时可能出现的错误：
- en: '[PRE65]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we’re going to read lines from the file, one by one:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将逐行读取文件：
- en: '[PRE66]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the body of this loop, we remove any ending newline characters and parse
    the received line into a `values` list:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环体中，我们删除任何结尾的换行符，并将接收到的行解析为`values`列表：
- en: '[PRE67]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we’re going to merge the date and the time into a single string and convert
    it to a `datetime` object:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将日期和时间合并成一个单独的字符串，并将其转换为`datetime`对象：
- en: '[PRE68]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After that, we will gather the rest of the info into a dictionary:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将其余的信息收集到一个字典中：
- en: '[PRE70]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, add the new sample to the global dataset dictionary using `timestamp`
    as a keyword:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`timestamp`作为关键字，将新样本添加到全局数据集字典中：
- en: '[PRE76]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, if we check the data for the first record in the dataset, we will get
    the following:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们检查数据集中的第一条记录，我们将得到以下结果：
- en: '[PRE77]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, if I want to retrieve a particular value for the closing price on a certain
    date and at a certain time, I may want to use something like the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我想在某个特定日期和特定时间检索收盘价的特定值，我可能想使用以下类似的方法：
- en: '[PRE78]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Where timestamp stands for the timestamp at which you'd like to retrieve the
    closing price.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其中时间戳表示您想要检索收盘价的时间戳。
- en: When running backtests, we do not retrieve data samples by their timestamp,
    though; instead, we’d like to have a method to continuously get samples one by
    one in strict chronological order. Native Python dictionaries normally contain
    unsorted data; however, there’s a workaround that allows us to sort data by keywords—making
    dictionary keys sorted and automatically getting data samples sorted always in
    correct chronological order. Alternatively, you can use the `OrderedDict` subclass
    of the Python native `dict` object, which implements a dictionary with keys pre-sorted
    (you can find a simple tutorial on `OrderedDict` at [https://www.tutorialspoint.com/ordereddict-in-python](https://www.tutorialspoint.com/ordereddict-in-python)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行回测时，我们并不是通过时间戳来检索数据样本的；相反，我们希望有一个方法可以连续逐个按严格的时序顺序获取样本。Python的本地字典通常包含未排序的数据；然而，有一个解决方案允许我们通过关键字排序数据——使字典键排序，并自动确保数据样本始终按正确的时序顺序排序。或者，您可以使用Python本地`dict`对象的子类`OrderedDict`，它实现了一个键预先排序的字典（您可以在[https://www.tutorialspoint.com/ordereddict-in-python](https://www.tutorialspoint.com/ordereddict-in-python)找到关于`OrderedDict`的简单教程）。
- en: 'To do that, we use the built-in `sorted` method, which returns a list of the
    sorted values for any iterable in ascending order by default—exactly what we want:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们使用内置的`sorted`方法，它默认按升序返回任何可迭代对象的排序值列表——这正是我们想要的：
- en: '[PRE79]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The preceding code will print all data samples from the very first to the very
    last in strict chronological order (don’t run this code with massive datasets
    as it will take a lot of time to display!).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将按严格的时序顺序打印从第一个到最后一个的所有数据样本（不要用大量数据集运行此代码，因为它将花费大量时间来显示！）。
- en: Now, we can read historical data, sort it in correct chronological order, and
    retrieve it one by one—that’s all we need to be ready for backtesting of our algorithms.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以读取历史数据，按正确的时序顺序对其进行排序，并逐个检索——这就是我们为算法回测所需要的一切。
- en: Compressing market data in Python
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中压缩市场数据
- en: It is quite possible that even though a full tick data stream is available from
    the data provider, we still want to compress it, and not only to save disk storage
    space. The reason for this compression could be much more important, such as our
    trading algorithm can possibly generate some signals or calculate some auxiliary
    metrics using historical data that is compressed. Therefore, we also need to feed
    the algorithm with data compressed in a similar manner. And although tick data
    provides much more information as such, we may still want to compress it to make
    it compatible with the trading logic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数据提供者提供了完整的价格数据流，我们仍然可能希望对其进行压缩，而不仅仅是节省磁盘存储空间。这种压缩的原因可能更为重要，例如，我们的交易算法可能能够生成一些信号或使用压缩的历史数据计算一些辅助指标。因此，我们还需要以类似的方式向算法提供压缩数据。尽管价格数据提供了更多信息，我们仍然可能希望对其进行压缩，以使其与交易逻辑兼容。
- en: 'The most correct way to compress the data from tick to OHLC bars would be to
    have a method that receives ticks, recalculates OHL (open-high-low) values with
    each tick, and then adds the C (close) value when the time comes. For example,
    if we want to compress ticks into 1-minute bars, this method would create a new
    bar at the beginning of each minute and complete it when the minute’s interval
    has passed. Let’s look at an example to understand this better:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从价格数据压缩到OHLC（开盘价、最高价、最低价、收盘价）条的最正确的方法是有一个接收价格数据的方法，每个价格数据点重新计算OHL（开盘价、最高价、最低价）值，然后在适当的时候添加C（收盘价）值。例如，如果我们想将价格数据压缩成1分钟条，这个方法将在每分钟的开始处创建一个新的条，并在分钟间隔过去时完成它。让我们通过一个例子来更好地理解这一点：
- en: 'Let’s assume we have historical tick data in a local file (we will see how
    properly written code allows us to quickly switch from files to any other source
    of data):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个本地文件中的历史价格数据（我们将看到如何编写良好的代码使我们能够快速从文件切换到任何其他数据源）：
- en: '[PRE80]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We immediately read the first line of the file and never use it as the first
    line as just the header.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即读取文件的第一行，并且永远不会将其用作第一行，因为它只是标题。
- en: 'Next, we don’t forget to import `datetime` and create two dictionaries—one
    for the entire data series and another for an individual bar:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们不要忘记导入`datetime`并创建两个字典——一个用于整个数据系列，另一个用于单个条目：
- en: '[PRE83]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, we set the resolution for our newly formed time-based bars. I recommend
    using a universal measurement unit here. For example, if you work with relatively
    slow trading strategies, then you may want to count time in minutes. For greater
    precision and granularity, you may want to go down to seconds. So, let’s use seconds
    as units and form 1-minute bars (1-minute bar equals to 60 seconds):'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的新形成的时间条设置分辨率。我建议在这里使用一个通用的测量单位。例如，如果您使用的是相对较慢的交易策略，那么您可能希望按分钟计算时间。为了获得更高的精度和粒度，您可能希望降低到秒。所以，让我们使用秒作为单位，形成1分钟的条目（1分钟条目等于60秒）：
- en: '[PRE86]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, we should read another line from the file, still outside the main loop,
    to get the first timestamp. We are going to compare all further timestamps with
    this one, and as soon as the distance (in time) between the two becomes greater
    than the resolution (60 seconds in our case), we will start a new bar:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该从文件中读取另一行，仍然在主循环之外，以获取第一个时间戳。我们将比较所有后续的时间戳与这个时间戳，一旦两个时间戳之间的距离（时间）大于分辨率（在我们的例子中是60秒），我们就会开始一个新的条目：
- en: '[PRE87]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'At last, the main loop starts:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主循环开始：
- en: '[PRE90]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Until this point, the code of the loop body is identical to what we already
    did—we read a new line and parse it. But then, we compare the received timestamp
    with the timestamp of the last formed bar or sample:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，循环体的代码与我们之前所做的完全相同——我们读取一行新内容并解析它。但是，然后我们比较接收到的时间戳与最后一个形成的条目或样本的时间戳：
- en: '[PRE91]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here, you can feel all the beauty of using timestamps in datetime format. You
    can add or subtract them as if they were just regular numbers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以感受到使用日期时间格式的时间戳的所有美丽。您可以像处理常规数字一样添加或减去它们。
- en: Note for nerds
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 神经质者的笔记
- en: 'Python supports multiple types that handle dates and times. Besides `datetime`,
    there is another useful type—`timedelta`, which allows easily defining time spans.
    If you want to learn more about `timedelta` and how to efficiently use it, try
    this tutorial: [https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/](https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持多种处理日期和时间的类型。除了`datetime`之外，还有一个有用的类型——`timedelta`，它允许轻松定义时间跨度。如果您想了解更多关于`timedelta`及其如何高效使用的信息，请尝试这个教程：[https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/](https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/)。
- en: 'Now, when the time delta between the new tick timestamp and the previous fully
    formed bar timestamp is greater than the resolution, we add the current bar to
    our `bars` global dictionary and start a new bar by replacing its values with
    the same price—the price of the last tick. Don’t forget to convert strings to
    numbers down the road:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当新标记的时间戳与上一个完全形成的条目时间戳之间的时间增量大于分辨率时，我们将当前条目添加到我们的`bars`全局字典中，并通过用相同的价格（最后标记的价格）替换其值来开始一个新的条目。别忘了在途中将字符串转换为数字：
- en: '[PRE92]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Alternatively, if the time delta is still less than the resolution (in our
    example, it’s under 1 minute), then we just update the values of the current bar:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果时间增量仍然小于分辨率（在我们的例子中，它小于1分钟），那么我们只需更新当前条目的值：
- en: '[PRE98]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Seems like we’re done with coding. Alright—let’s run our code, and we will
    immediately get an error:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的编码工作已经完成了。好吧——让我们运行我们的代码，我们会立即得到一个错误：
- en: '[PRE99]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This means that the dictionary in which we form the current bar does not have
    the `high` keyword. How can this happen? Of course, it happens during the forming
    of the very first bar: until we save at least one bar, none of its properties
    (open, high, low, or close) is available. So, we fix our code by adding a `try`...`except`
    statement:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们形成当前条目的字典中没有`high`关键字。这是怎么发生的？当然，这是在形成第一个条目时发生的：在我们保存至少一个条目之前，它的任何属性（开盘价、最高价、最低价或收盘价）都是不可用的。因此，我们通过添加一个`try`...`except`语句来修复我们的代码：
- en: '[PRE100]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Now, during the formation of the very first bar, we can see only `First bar
    forming...` on the screen. You can replace this message with anything or completely
    remove it by replacing the `print` statement with `pass`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在形成第一个条目时，我们只能在屏幕上看到`First bar forming...`。您可以替换这条消息，或者通过将`print`语句替换为`pass`来完全删除它。
- en: 'Let’s run the code again, and we can see that now it’s executed successfully.
    If we check the last 4 records in the `bars` variable, we can see that the timestamps
    of bars indeed have a delta of approximately 1 minute:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码，我们可以看到现在它已经成功执行了。如果我们检查`bars`变量中的最后4条记录，我们可以看到这些条目的时间戳确实大约有1分钟的增量：
- en: '[PRE101]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: But wait! The timestamps are OK, but why are all respective prices (comparing
    open to open, close to close, and so on) in all bars identical?!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！时间戳是正确的，但为什么所有条形图中的相应价格（比较开盘到开盘、收盘到收盘等）都是相同的？！
- en: 'Here, we have an issue that actually is one of the most prominent features
    of Python as a very well-developed object-oriented language. What we actually
    do in our code is the following sequence of actions:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个问题，这实际上是Python作为非常成熟面向对象语言的最突出特征之一。我们在代码中实际执行的动作序列如下：
- en: We create `object1` (`bars` dictionary).
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建`object1`（`bars`字典）。
- en: We create `object2` (`bar` dictionary).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建`object2`（`bar`字典）。
- en: We add `object2` to `object1` with a `new` keyword.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`new`关键字将`object2`添加到`object1`中。
- en: Then, we *modify* `object2`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们*修改*`object2`。
- en: Again, we add `object2` to `object1` with a `new` keyword.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们使用`new`关键字将`object2`添加到`object1`中。
- en: '...and then repeat this loop.'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '...然后重复这个循环。'
- en: 'See the point? We thought we’d add a new object every time we wanted to add
    a new bar to `bars`, but in reality, we add *the same* object—the same `bar` dictionary—only
    with modified values. I know that at first, it’s hard to understand, so try to
    think this way: the `bars[ts] = bar` assignment means saving a *link* to the `bar`
    object into the `bars` object with the `ts` keyword. In this case, once the `bar`
    object itself is modified, the reference to it in the `bars` object remains the
    same, so we always get modified values when we try to retrieve the `bar` object
    from `bars`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？我们原本以为每次想要向`bars`中添加新的条形图时，都会添加一个新的对象，但实际上，我们添加的是*相同的*对象——相同的`bar`字典——只是值被修改了。我知道一开始这可能很难理解，所以试着这样想：`bars[ts]
    = bar`这个赋值操作意味着将`bar`对象保存为`bars`对象中的*链接*，使用`ts`关键字。在这种情况下，一旦`bar`对象本身被修改，`bars`对象中对它的引用保持不变，所以当我们尝试从`bars`中检索`bar`对象时，我们总是得到修改后的值。
- en: But what do we actually want here? Of course, we want to save *every bar individually*
    so that if we update the `bar` object outside the `bars` object, its new values
    *will not affect* whatever is already stored in the `bars` object.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上在这里想要做什么呢？当然，我们想要保存*每个条形图单独*，这样如果我们在`bars`对象外部更新`bar`对象，其新值*不会影响*已经存储在`bars`对象中的任何内容。
- en: In fact, we want to save not the `bar` object itself, but *a copy of it,* which
    will remain unmodified when we update the `bar` object in the future. To do that,
    we just replace `bars[ts] = bar` with `bars[ts] = dict(bar)`. Here, `dict` is
    a class that generates a *new* dictionary out of any iterable, mapping object,
    or keyword arguments. In our case, it’s quite simplified as we use a ready dictionary
    (`bar`) as the mapping object.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们想要保存的是`bar`对象的*副本*，这样当我们未来更新`bar`对象时，它将保持未修改。为此，我们只需将`bars[ts] = bar`替换为`bars[ts]
    = dict(bar)`。在这里，`dict`是一个类，可以从任何可迭代对象、映射对象或关键字参数生成*新*字典。在我们的情况下，它相当简化，因为我们使用一个现成的字典（`bar`）作为映射对象。
- en: 'If we run the code now, with this edit, we can see that not only timestamps
    are correct, but the price data in `bars` is correct as well:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行代码，进行这个编辑，我们可以看到，不仅时间戳是正确的，`bars`中的价格数据也是正确的：
- en: '[PRE117]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: So, now, we have 1-minute bars formed from tick data.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，我们有了由tick数据形成的1分钟条形图。
- en: '*But what do their* *timestamps mean?*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是它们的* *时间戳代表什么意思呢？*'
- en: '*Which time do they* *actually reference?*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*它们实际上参考的是哪个时间点呢？*'
- en: '*And why is the seconds value of these timestamps not zero (as we would expect
    for a 1-minute resolution), but also differs slightly from bar* *to bar?*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么为什么这些时间戳的秒值不是零（正如我们期望的1分钟分辨率那样），而且条形图* *到条形图之间也略有不同呢？*'
- en: To answer the first question, our algorithm in its present form saves the timestamp
    *of the last tick of the time interval*. This happens because the trigger by which
    we start forming a new bar is `if delta.seconds >= resolution`. So, `if` starts
    a new bar as soon as (and no earlier than!) a new tick is received, and the timestamp
    of this new tick differs from its immediate predecessor by a value (which is called
    `timedelta`) that is greater than `resolution`. In other words, if we set `resolution`
    to 1 second, then we start a new bar only when we receive a tick whose timestamp
    differs from the start (open) of the currently forming bar by 1,000 milliseconds
    or more.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答第一个问题，我们当前的算法保存的是时间间隔的最后一次tick的*时间戳*。这是因为我们开始形成新条形图的触发器是`if delta.seconds
    >= resolution`。所以，`if`语句在接收到新tick时立即开始新条形图（并且不能早于！）新tick的时间戳与其直接前驱的时间戳之间的差值（称为`timedelta`）大于`resolution`。换句话说，如果我们将`resolution`设置为1秒，那么只有当我们收到一个时间戳与当前正在形成的条形图的开盘（开始）相差1,000毫秒或更多的新tick时，我们才会开始新的条形图。
- en: This also answers two remaining questions. Since the timestamp of the very first
    received tick (the first tick in the data file) may not be a *round* number and
    minutes with zero seconds, we start counting 60 seconds not from the beginning
    of a minute, but from an arbitrary moment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这也回答了两个剩余的问题。由于接收到的第一个tick（数据文件中的第一个tick）的时间戳可能不是一个*整数*，并且分钟数没有零秒，所以我们不是从分钟的开始计算60秒，而是从任意时刻开始计算。
- en: '*“Is it good or bad?”* you may ask.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“*这是好是坏？*”。
- en: Neither.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都不是。
- en: The correct question here would be “*Does it suit my* *trading algorithm?*”.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的问题应该是“*它适合我的交易算法吗？*”。
- en: And the answer depends on the logic of your algorithm. If it only analyzes the
    sequence of prices (or maybe volume, if the volume is provided by the data provider)
    then yes—this method works well and is really easy to implement. However, if your
    strategy logic assumes triggering orders or doing calculations at the real edge
    of a minute (or any other time interval), then this method won’t fit.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 答案取决于你算法的逻辑。如果它只分析价格序列（或者如果数据提供者提供了量，那么可能是量），那么是的——这种方法工作得很好，并且很容易实现。然而，如果你的策略逻辑假设在分钟的真正边缘（或任何其他时间间隔）触发订单或进行计算，那么这种方法就不适用。
- en: Luckily, we can easily modify our code so that it’s generating bars with the
    exact 1-minute resolution. The problem is that there’s no universal way of doing
    that, and the choice depends on whether you work with a live data stream or with
    saved tick data. To better understand it, let’s first quickly go back to the problem
    of retrieving data from external data sources and keeping your trading application
    modular and scalable. Then, you will understand how the problem of generating
    correct timestamps can be elegantly solved within this paradigm. All this, coming
    up in the next section!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以轻松修改我们的代码，使其生成具有精确1分钟分辨率的K线。问题是，没有通用的方法来做这件事，选择取决于你是与实时数据流还是与保存的tick数据进行工作。为了更好地理解这一点，让我们首先快速回顾一下从外部数据源检索数据并保持你的交易应用模块化和可扩展的问题。然后，你就会理解在这个范式下如何优雅地解决生成正确时间戳的问题。所有这些内容将在下一节中介绍！
- en: Working with saved and live data – keeping your app universal
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理保存的和实时数据——保持你的应用通用
- en: In the previous chapter, we quickly observed various methods to get market data
    from LMAX, one of the most important ECNs in the FX market. Without going into
    too much technical detail, we can assume that most other brokers, trading venues,
    and data vendors use more or less the same protocols and APIs based on socket
    connections. So, it should not be a problem to re-adapt your code to start retrieving
    data from a new source.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们快速了解了从LMAX获取市场数据的方法，LMAX是外汇市场最重要的ECN之一。在不深入太多技术细节的情况下，我们可以假设大多数其他经纪商、交易场所和数据供应商使用的是基于套接字连接的更多或更少的相同协议和API。因此，重新适配你的代码以从新的数据源检索数据应该不会是问题。
- en: However, from the previous chapter, I hope you also remember that despite similarities
    in the transport layer of the connection, almost every data source has its own
    features that can only be found in its documentation (and sometimes, unfortunately,
    only in direct talks with its technical support).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从上一章，我希望你也能记住，尽管连接的传输层有相似之处，几乎每个数据源都有其独特的特性，这些特性只能在它的文档中找到（有时，不幸的是，只有在与它的技术支持直接交谈时才能找到）。
- en: This means that even if you implemented—for example—**Financial Information
    eXchange** (**FIX**) protocol version 4.4 with one broker, it is quite possible
    that you will have to modify something in your code or FIX dictionary when you
    want to connect to another broker. With proprietary APIs, the situation is obviously
    more complex, and sometimes the entire code should be rewritten (everything on
    top of the transport layer, such as the socket connection).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使你为例如——**金融信息交换**（**FIX**）协议版本4.4实现了一个经纪商，当你想要连接到另一个经纪商时，你很可能需要在你的代码或FIX字典中修改某些内容。对于专有API，情况显然更加复杂，有时整个代码都应该重写（包括传输层之上的所有内容，如套接字连接）。
- en: 'So, a good practice when building a trading application is to make sure that
    it has a modular structure where modules have interfaces talking to each other
    using an internal, built-in, universal transport infrastructure. Such an infrastructure
    should transfer price information between modules regardless of their particular
    implementation, even if they are provided by third parties. In this case, you
    don’t have to modify the entire application once you want to switch to another
    data source: you just need to write a new module, and a new plugin if you want,
    which would connect to the new source but deliver data in the same internal format
    compatible with the rest of the app’s modules.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在构建交易应用时，一个好的做法是确保它具有模块化结构，其中模块通过使用内部、内置的通用传输基础设施相互通信。这种基础设施应在模块之间传输价格信息，而不管它们的特定实现如何，即使它们由第三方提供。在这种情况下，一旦你想切换到另一个数据源，你不需要修改整个应用程序：你只需要编写一个新的模块，如果你愿意，还可以编写一个新的插件，该插件将连接到新的源，但以与应用程序其余模块兼容的相同内部格式提供数据。
- en: 'In general, we want to create an architecture as shown in *Figure 5**.2*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望创建一个如图 *图 5**.2* 所示的架构：
- en: '![Figure 5.2 – The most simplistic data transport infrastructure for a trading
    app](img/B19145_5_2.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 交易应用最简单的数据传输基础设施](img/B19145_5_2.jpg)'
- en: Figure 5.2 – The most simplistic data transport infrastructure for a trading
    app
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 交易应用最简单的数据传输基础设施
- en: 'However, this simplistic architecture has prominent flaws:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单的架构存在明显的缺陷：
- en: It supports only one source of data
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只支持一个数据源
- en: It supports only one trading algorithm
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只支持一个交易算法
- en: 'So, we may want to upgrade our architecture a bit to add multiple data streams
    to our trading algorithm, as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能想要稍微升级我们的架构，为我们的交易算法添加多个数据流，如下所示：
- en: '![Figure 5.3 – Multiple data sources with a single trading algorithm](img/B19145_5_3.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 使用单个交易算法的多个数据源](img/B19145_5_3.jpg)'
- en: Figure 5.3 – Multiple data sources with a single trading algorithm
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 使用单个交易算法的多个数据源
- en: 'Well, this architecture reveals a new problem: how to sync multiple data streams?
    How to decide which tick to pass to the algo if we have multiple sources? How
    do we request these sources? If we do that from our global infinite loop (`for
    line in file` for data read from a file or `while True` for socket connections),
    then we will have a really hard time switching to another data source because
    it will require rewriting almost the entire code.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个架构揭示了一个新的问题：如何同步多个数据流？如果我们有多个来源，我们如何决定将哪个tick传递给算法？我们如何请求这些来源？如果我们从全局无限循环（例如从文件读取数据时的
    `for line in file` 或套接字连接时的 `while True`）这样做，那么切换到另一个数据源将会非常困难，因为这几乎需要重写整个代码。
- en: 'Moreover, if we want to run a number of trading algorithms in parallel using
    a number of data sources, we quickly come to a complete mess:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想并行运行多个交易算法，使用多个数据源，我们很快就会陷入混乱：
- en: '![Figure 5.4 – Using multiple data sources with multiple algorithms in a bad
    way](img/B19145_5_4.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 以错误的方式使用多个数据源和多个算法](img/B19145_5_4.jpg)'
- en: Figure 5.4 – Using multiple data sources with multiple algorithms in a bad way
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 以错误的方式使用多个数据源和多个算法
- en: 'Now, we clearly understand what we actually need to build a robust infrastructure.
    We need:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们清楚地理解了构建稳健基础设施所需的内容。我们需要：
- en: To be able to run multiple processes of retrieving data *concurrently* without
    interfering with one another
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在不相互干扰的情况下并行运行多个数据检索进程
- en: To be able to store received data in universal elastic storage that is being
    filled with new data and then emptied as older ticks are processed by the trading
    algorithms
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将接收到的数据存储在通用的弹性存储中，该存储正在填充新数据，并在较老的tick被交易算法处理后被清空
- en: 'So, we are talking about an architecture as shown in *Figure 5**.5* with multiple
    data connectors, each of them having methods to connect, get data, and write it
    to a kind of a queue, and multiple trading algorithms (about whose internal architecture
    we don’t know anything yet) exchanging information using universal *elastic storage*,
    as described in the preceding list:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在讨论一个如图 *图 5**.5* 所示的架构，具有多个数据连接器，每个连接器都有连接、获取数据和将其写入某种队列的方法，以及多个交易算法（关于其内部架构我们目前一无所知），它们使用通用
    *弹性存储* 交换信息，如前所述：
- en: '![Figure 5.5 – A better architecture of the data transport layer of a trading
    application](img/B19145_5_5.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 交易应用数据传输层的一个更好的架构](img/B19145_5_5.jpg)'
- en: Figure 5.5 – A better architecture of the data transport layer of a trading
    application
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 交易应用数据传输层更好的架构
- en: Python does offer native solutions to both problems in an exceptionally streamlined
    and convenient way (as always, though). The ability to run data connectors concurrently
    is provided by *threads*, while the “elastic storage” mentioned previously is
    a *queue*. Let’s give both some insight.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Python确实以非常流畅和方便的方式（一如既往）提供了对这两个问题的原生解决方案。运行数据连接器的并发能力由**线程**提供，而之前提到的“弹性存储”是一个**队列**。让我们对两者进行一些深入了解。
- en: A **thread** is a separate branch of execution of the program’s code that runs
    *concurrently* with the main code or in parallel with other threads. It can be
    implemented only within the paradigm of **object-oriented programming** (**OOP**)
    where we no longer have a single algorithm with a single start and a single end
    point, but instead, we have objects with their own behavior that can co-exist
    without interfering with one another or interacting with each other, depending
    on the will of their creator. So, a thread is an object that runs a function (a
    method) in parallel with everything else. Exactly what we need for retrieving
    data from multiple sources without syncing, right?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**是程序代码的独立执行分支，它**并发**地运行与主代码或与其他线程**并行**。它只能在**面向对象编程**（**OOP**）的范式内实现，在那里我们不再有一个单一的算法，它只有一个开始和一个结束点，而是有具有自己行为的对象，它们可以共存而不相互干扰或相互作用，这取决于其创造者的意愿。因此，线程是一个在与其他所有事物并行运行函数（方法）的对象。这正是我们从多个来源检索数据而不需要同步时所需要的，对吧？'
- en: 'A **queue** is... well, a queue that you can see at a cash desk around Christmas
    time. Customers are served on a first-come, first-served basis. The data in a
    Python queue is treated the same way: whatever gets into the queue is moving along
    as older data is being processed. The moment a new element is retrieved, it is
    removed from the queue, freeing up space for newer data.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**...嗯，就像圣诞节时你在收银台看到的队列一样。顾客是按照先到先服务的原则被服务的。Python队列中的数据被以同样的方式处理：任何进入队列的数据都会随着旧数据的处理而移动。一旦检索到新元素，它就会被从队列中移除，为新数据腾出空间。'
- en: 'To better understand how queues work, let’s consider a very simple example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解队列的工作原理，让我们考虑一个非常简单的例子：
- en: '[PRE118]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If you run this code, it will print `Sample 1` because the very first element
    in the queue was the `Sample 1` string. However, if you work in an interactive
    console and type `print(q.get())` again (or just add another `print(q.get())`
    statement to the code), then this second `print` statement will print `Sample
    2` because `Sample 1` was already retrieved by the `.get()` method and deleted
    from the queue.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，它将打印`Sample 1`，因为队列中的第一个元素是`Sample 1`字符串。然而，如果你在一个交互式控制台中再次输入`print(q.get())`（或者只是将另一个`print(q.get())`语句添加到代码中），那么这个第二个`print`语句将打印`Sample
    2`，因为`Sample 1`已经被`.get()`方法检索并从队列中删除。
- en: 'Now that we know what threads and queues are, we can suggest a final draft
    for the architecture of the data transport layer of our trading application:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了线程和队列是什么，我们可以为我们的交易应用数据传输层的架构提出一个最终草案：
- en: '![Figure 5.6 – The final draft of the architecture of the data transport layer
    of a trading app](img/B19145_5_6.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – 交易应用数据传输层架构的最终草案](img/B19145_5_6.jpg)'
- en: Figure 5.6 – The final draft of the architecture of the data transport layer
    of a trading app
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 交易应用数据传输层架构的最终草案
- en: Let’s now try to implement it in code.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试将其在代码中实现。
- en: Universal data connector
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用数据连接器
- en: 'Let’s start with the necessary preparations:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从必要的准备工作开始：
- en: 'We will need to specify the source data file, read the header, and do some
    imports:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要指定源数据文件，读取标题，并进行一些导入：
- en: '[PRE119]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, let’s create a universal data stream, something into which all retrieved
    data will be written. Of course, it’s an instance of Python’s `queue` class:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个通用数据流，所有检索到的数据都将写入其中。当然，它是一个Python的`queue`类的实例：
- en: '[PRE126]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'And now, let’s create our first method that retrieves data, this time from
    a local file:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的第一个检索数据的方法，这次是从本地文件中检索：
- en: '[PRE127]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Can you see the already familiar code? Yes, of course—this is just a copy of
    what we did in the previous section, but this time wrapped into a function. So
    far, no different from what we did before. The difference comes with the following
    two functions:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到已经熟悉的代码吗？是的，当然——这只是一个复制了我们之前所做的，但这次被封装在一个函数中。到目前为止，与之前没有区别。区别在于以下两个函数：
- en: '[PRE134]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The first function, `emulate_tick_stream()`, reads a new tick from the file
    every second and puts it into the `datastream` queue.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`emulate_tick_stream()`，每秒从文件中读取一个新的tick并将其放入`datastream`队列中。
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This 1-second delay is added here only for demonstration purposes—real data
    retrieval methods should not contain any delays!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里添加的1秒延迟只是为了演示目的——真实的数据检索方法不应该包含任何延迟！
- en: The second function is simply a prototype—a dummy trading algorithm. It does
    nothing but report that it successfully received a new data sample.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数只是一个原型——一个模拟的交易算法。它什么也不做，只是报告它成功接收了一个新的数据样本。
- en: 'Now, it’s time to run both processes—retrieving and processing data—in parallel.
    The time has come for Python threads:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候并行运行这两个过程了——检索和处理数据。Python线程的时代到来了：
- en: '[PRE135]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This way, we create two instances of the `Thread` class, one for retrieving
    data (`data_source_thread`) and one for processing data (`data_receiver_thread`).
    As the only argument, we pass the name of the function that we would like to run
    within this thread.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们创建了两个`Thread`类的实例，一个用于检索数据（`data_source_thread`），一个用于处理数据（`data_receiver_thread`）。作为唯一的参数，我们传递了希望在线程中运行的函数的名称。
- en: Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We pass the function name and do not call the function itself! If you type something
    such as `threading.Thread(target = trading_algo())`, the function will be called
    right *at the point it is passed* into the thread, so *the thread will never*
    *actually start*!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递函数名，并不调用函数本身！如果你输入像`threading.Thread(target = trading_algo())`这样的内容，函数将在它被传递到线程中的那一刻被调用，所以*线程永远不会*真正启动！
- en: 'All we need to do now is to run the two threads concurrently:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要做的就是同时运行两个线程：
- en: '[PRE137]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'That’s it! Now if we run the code in a new console window, we will see something
    like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在如果我们在一个新的控制台窗口中运行代码，我们会看到类似这样的内容：
- en: '[PRE139]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: A new line will appear every second (because we have a delay of 1 second in
    the `get_tick()` function).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒会出现一条新行（因为我们`get_tick()`函数中有一个1秒的延迟）。
- en: Even in this simple example, we can see the power of using an object-oriented
    approach to developing trading apps and especially using threads and queues. Now,
    you can rewrite the `get_tick()` function to connect to a totally different data
    source, and the rest of your code will remain completely, absolutely untouched!
    You can replace reading from a file with reading from a socket, from a REST API,
    or from whatever you (or your broker) might imagine. It won’t ever affect the
    rest of your code, given your new `get_tick()` function returns data in the same
    format.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，我们也能看到使用面向对象的方法开发交易应用以及特别是使用线程和队列的强大功能。现在，你可以重写`get_tick()`函数以连接到完全不同的数据源，而你的其余代码将保持完全、绝对的不变！你可以用从套接字读取、从REST
    API读取或从你（或你的经纪人）可能想象的一切来替换从文件读取。只要你的新`get_tick()`函数返回相同格式的数据，它就不会影响你的其余代码。
- en: And now, we can get back to the discussion on data compression, which we somehow
    abruptly dropped in the previous section.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到之前章节中突然中断的数据压缩讨论。
- en: Data compression revisited
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据压缩再探讨
- en: Remember that we compressed tick data into 1-minute bars, but the actual beginning
    and end of a minute was not when the number of seconds was zero, but at an arbitrary
    point inside a minute interval? That time, we were unable to solve this problem
    because we only read data samples one by one from a file at a speed that was unknown
    to us.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们将tick数据压缩成了1分钟的柱状图，但实际的分钟开始和结束并不是当秒数为零时，而是在一分钟间隔内的任意一点。那时，我们无法解决这个问题，因为我们只能以我们不知道的速度逐个从文件中读取数据样本。
- en: But with the power of threading and queuing, we can form *correct* 1-minute
    (or any N-minute) bars with perfect precision when the new bar starts at exactly
    00 seconds. All we need is to add a new function and run it in a thread.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 但有了线程和队列的力量，当新柱状图在正好00秒开始时，我们可以以完美的精度形成*正确*的1分钟（或任何N分钟）柱状图。我们需要的只是添加一个新函数并在一个线程中运行它。
- en: Note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note how easy it is now to customize data processing. We no longer rewrite the
    entire code—we only add new functionality or modify a single function.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在定制数据处理是多么容易。我们不再重写整个代码——我们只需添加新的功能或修改一个函数。
- en: 'So, let’s create a function that will break our incoming data stream into 1-minute
    bars simply by using a system timer:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个函数，它将使用系统计时器将我们的传入数据流拆分成1分钟的柱状图：
- en: 'We will start with creating a dictionary for the currently forming bar (as
    in the previous example), and, as always with functions that are supposed to work
    inside threads, we start with an infinite loop:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一个用于当前正在形成的柱状图的字典开始（如前例所示），并且，正如在应该在工作线程内工作的函数中一样，我们从一个无限循环开始：
- en: '[PRE140]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Then, we will read data from the data stream:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从数据流中读取数据：
- en: '[PRE143]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note that this call is universal for any data recipient, be it a trading strategy,
    a data compressor, a database, or whatever.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个调用对任何数据接收者都是通用的，无论是交易策略、数据压缩器、数据库还是其他任何东西。
- en: 'Next, we will check the current time (system time), and if its seconds value
    is zero, we will save the formed bar and start a new one:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查当前时间（系统时间），如果其秒值为零，我们将保存形成的柱状图并开始一个新的柱状图：
- en: '[PRE144]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The rest of the code is the same as in the aforementioned example and handles
    exceptions that are raised when the first bar is not complete:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分与前面提到的示例相同，它处理在第一根柱状图未完成时引发的异常：
- en: '[PRE151]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: You can see that this function almost completely copies the code we used in
    the *Compressing market data in Python* section, with the only important modification
    being that now, instead of comparing timestamps of individual ticks, we finalize
    the bar *by a system timer*. As soon as the *system time* passes a minute, which
    means that its seconds value is zero, we start a new bar.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个函数几乎完全复制了我们之前在*Python中压缩市场数据*部分使用的代码，唯一的重大修改是现在，我们不是比较单个tick的时间戳，而是通过*系统计时器*来最终确定柱状图。一旦*系统时间*超过一分钟，这意味着其秒值为零，我们就开始一个新的柱状图。
- en: In fact, synching time is one of the greatest problems in algo trading. The
    system time on the trading server may differ from the clock at the data vendor’s,
    and the clock at the broker or ECN may again differ from both. Luckily, in the
    further examples, we are going to use only 1-second snapshots of live data and
    1-minute bars of historical data, so the problem of clock synchronization can
    be set aside for now.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，时间同步是算法交易中最大的问题之一。交易服务器的系统时间可能与数据供应商的时钟不同，而经纪商或ECN的时钟可能又与两者都不同。幸运的是，在接下来的示例中，我们将只使用1秒的实时数据快照和1分钟的的历史数据柱状图，因此现在可以暂时忽略时钟同步的问题。
- en: 'If you run this code using pre-saved historical tick data, you will see something
    like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用预先保存的历史tick数据运行此代码，你会看到类似这样的情况：
- en: '[PRE152]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: You can see that the first bar does not have price data as it was started before
    the first minute ended. All the following bars have OHLC values that correspond
    to the *last ticks of the minute* by the time the system timer triggered a new
    bar.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，第一根柱状图没有价格数据，因为它是在第一分钟结束之前开始的。所有随后的柱状图都有OHLC值，这些值对应于系统计时器触发新柱状图时的*最后几秒钟的tick*。
- en: 'Now, I hope you understand why historical compressed data from a broker always
    has nice *round* timestamps: they do not correspond to actual ticks; they are
    simply split into bars by the system timer.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我希望你理解为什么来自经纪商的历史压缩数据总是有很好的*圆形*时间戳：它们并不对应实际的tick；它们只是被系统计时器分割成柱状图。
- en: You can see that this method works perfectly with live data that is received
    from a broker, a trading venue, or a similar source. It doesn’t really suit for
    processing pre-saved historical data because it can be read back from disk at
    speeds that seriously exceed the real speed at which ticks are being received
    from the market. So, with historical data, it’s better to use the *tick-to-tick
    timestamp compare* approach that we considered in the *Compressing market data
    in Python* section earlier in this chapter.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个方法与从经纪商、交易场所或类似来源接收的实时数据配合得非常好。它并不适合处理预先保存的历史数据，因为它可以从磁盘以严重超过从市场接收tick的实际速度读取。因此，对于历史数据，最好使用我们在本章前面*Python中压缩市场数据*部分考虑的*tick-to-tick时间戳比较*方法。
- en: If you are not familiar with threads and queues and want to learn more about
    the ways you can use them in your trading apps, I’d recommend starting with a
    simple tutorial here ([https://realpython.com/intro-to-python-threading/](https://realpython.com/intro-to-python-threading/))
    and then referring to the official Python documentation here ([https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html))
    for tips and tricks and deeper understanding.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉线程和队列，并且想了解如何在你的交易应用中使用它们，我建议从这里开始一个简单的教程([https://realpython.com/intro-to-python-threading/](https://realpython.com/intro-to-python-threading/))，然后参考这里的官方Python文档([https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html))以获取技巧和深入了解。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to process both live and historical market data
    and, most importantly, how to do it in an efficient way. We are now familiar with
    time-based bars, which are most heavily used in trading strategies. We also learned
    about the solution that helps keep our trading applications flexible and quickly
    switch from one data source to another, which will help when switching from testing
    to production in the future.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何处理实时和历史市场数据，更重要的是，如何以高效的方式进行。我们现在熟悉了基于时间的时间条，这在交易策略中应用最为广泛。我们还了解到了一种解决方案，它有助于保持我们的交易应用灵活，并能快速从一种数据源切换到另一种数据源，这在未来从测试切换到生产时将有所帮助。
- en: Now, we are ready to move on to using the processed market data in our trading
    strategies. Let’s see how we can do this in the next chapter.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将处理过的市场数据应用于我们的交易策略中。让我们看看在下一章我们将如何做到这一点。
