- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving and Handling Market Data with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you look at the general logical diagram of a trading application’s architecture,
    which we devised in [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014), *Developing
    Trading Strategies – Why They Are Different*, you can see that now we’re moving
    from the very first module named `Receive data` to the second one, `Cleanup and
    filter`, which features the **Store** and **Retrieve** functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we mentioned many times that any algo trading application
    is based on market data, and success in algo trading (that is, the ability to
    make money and not lose it) depends on the quality of the data and its consistency.
    So, let’s proceed to determine which data we really need to collect and how to
    make sure the collected data is consistent, then decide about the internal format
    for the trading app, and the way to store, update, retrieve, and delete data (if
    necessary).
  prefs: []
  type: TYPE_NORMAL
- en: Upon finishing this chapter, you will have a clear understanding of the most
    efficient ways of handling and processing market data, and, most importantly,
    you will learn how to keep your trading app universal so that it could be connected
    to virtually any data source, live or historical, without rewriting all your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating through data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data compression—keeping the amounts to a reasonable minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with saved and live data—keeping your app universal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The problem with data collection starts at the very beginning: every data provider
    offers its own data, quite often in its own format. Some data providers offer
    only compressed data or snapshots (see later in this chapter) while others broadcast
    tick-by-tick data; very few data providers also offer order book (**depth of market**
    or **DOM**; see [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044), *FX Market Overview
    from a Developer’s* *Standpoint*) data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first and above all, you should decide on the data granularity: whether
    your trading algorithm requires tick-by-tick or compressed data, and if you need
    DOM data or not. At this stage, you may feel lost with these questions, but don’t
    worry—you will get a very clear understanding of your data needs when you’ve accomplished
    further chapters of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider all three cases and see how we can actually handle ticks, snapshots,
    and DOM market data.
  prefs: []
  type: TYPE_NORMAL
- en: Tick data and snapshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I would like to reiterate that when we talk about third-party data, formats,
    and protocols, the ultimate source of the exact information about what is supported
    and how the third-party documentation is done is your broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in general, all data providers support two types of market data: tick
    and snapshots.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly recap the terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **tick** is a recorded change in any of the three prices of the traded asset:
    bid, ask (offer), and last'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bid** is the price at which market makers, liquidity providers, and other
    price givers agree to buy—and consequently, this is the price at which price takers
    can sell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ask** or **offer** is the price at which price givers are ready to sell—and
    consequently, this is the price at which price takers can buy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And **last** is the price at which the latest actual trade was made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s consider an example. This is sample tick data that you can receive from
    LMAX (see the previous chapter for more examples of connecting and retrieving
    data from this **electronic communication** **network** (**ECN**)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, the preceding JSON specifies the type of data. In this example, `type`
    is `TICKER`, which means that we’re dealing with a single tick. It is followed
    by the instrument name.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Many data providers use different notations for the same names of instruments.
    For example, EUR/USD can be represented by `eur-usd`, `EURUSD`, `EUR/USD`, and
    even `@EURUSD`. So, always check the data provider’s documentation, and don’t
    forget to replace the instrument’s name in the provider’s notation with the internal
    name used in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you use the traditional `CCY1/CCY2` notation, then you may
    want to use the following code, which will transform the `ccy1-ccy2` notation
    used by LMAX to the traditional one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `instrument_id` is the name of the instrument received with a tick from
    the data provider, `replace()` is the built-in sting method that replaces one
    character with another, and `upper()` is another built-in method that makes the
    entire string uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the timestamp, and with timestamps comes another degree of uncertainty
    because data providers use different standards for timestamps. We will discuss
    timestamps for market data a bit later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fields are self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`best_bid` and `best_ask` mean the top of the book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trade_id` is the ID of the latest trade made at this ECN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_quantity` and `last_price` are the size and price at which this latest
    trade was made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session_open`, `session_low`, and `session_high` mean the first price of the
    trading session (when the market opens), and the lowest and the highest price
    from the time the market opened till the time the tick is received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see, most of the fields in a tick are self-explanatory and easy to
    use, but there’s one important exception: `timestamp`.'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps – be careful comparing apples to apples!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, when we were analyzing the structure of a tick, we
    noted that it contained a timestamp and that this timestamp may become another
    source of headache for the developer. This happens because every data provider
    thinks they’re using the most convenient data format. As always, refer to the
    provider’s documentation and refer to any tutorial on working with timestamps.
    If you’re not familiar with timestamps and their standards, I’d recommend starting
    with an excellent tutorial on working with timestamps in Python by Avinash Navlani
    on *Dataquest* ([https://www.dataquest.io/blog/python-datetime-tutorial](https://www.dataquest.io/blog/python-datetime-tutorial)).
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, to keep things simple, a timestamp is a string formatted to one of the
    standards, and this formatting is normally done by whitespaces, special characters,
    or regular characters. In the LMAX example in the previous section, the date part
    is separated from the time part by the letter `T`, and the entire timestamp is
    ended with the letter `Z`.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a `datetime` library that covers flexible handling of timestamps.
    This library introduces the eponymous `datetime` object, which has multiple methods
    to convert strings into timestamps and vice versa. In the upcoming example, we’re
    going to use `strptime``()` to convert the timestamp from a string to a native
    `datetime` object.
  prefs: []
  type: TYPE_NORMAL
- en: By using `strptime()` and other methods, all you need is to specify the format
    of the input timestamp using correct specifiers (see the Python documentation
    at [https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior](https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior)
    for a complete list of specifiers).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s convert the timestamp from our LMAX example into a native `datetime`
    object. First, we import `datetime` from the `datetime` library (yes—it does look
    ridiculous, but what to do?) and then make the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assume that `ts_str1` is the timestamp already extracted from the
    tick received from LMAX as XML (JSON). If we run this code and check the value
    of `ts1`, then we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that the conversion was made correctly, and now we can access any
    component of the timestamp separately. For example, `ts1.day` returns `29` (the
    day of the month), and `ts1.microsecond` returns `755000`, which is actually `755`
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real advantage of using `datetime` objects is that they can be sorted like
    numbers. For example, if we receive a new timestamp that is just 1 millisecond
    past the original one (`ts_str2 = ''2022-07-29T11:10:54.756Z''`) and convert it
    into a new `datetime` object (`ts2 = datetime.strptime(ts_str2, ''%Y-%m-%dT%H:%M:%S.%fZ'')`),
    then we can easily compare two timestamps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Subsequently, we can sort them in ascending or descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Never use strings as IDs of timestamps for market data time series. You won’t
    be able to easily sort data by the exact time it’s arrived, and thus handling
    data will be extremely inefficient. Use native `datetime` or pandas timestamps
    (see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving tick data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three main approaches to storing and processing tick data in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: Using high-level objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using low-level objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pandas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level objects are normally created for storing considerable amounts of
    data or processing the entire historical data (see [*Chapter 2*](B19145_02.xhtml#_idTextAnchor028)*,
    Using Python for Trading Strategies*). In this case, we create a single object
    whose properties include lists (in case we’re going to store data samples one
    by one and refer to them by index) or dictionaries (in case we use timestamps
    to refer to a data sample).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using dictionaries allows for quick and easy handling of data by timestamp,
    so this is the preferred method of storing market data. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with creating a general class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `main` dictionary will store all data samples with timestamps used as keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add a method that adds a new data sample to the `main` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we assume that the data sample comes in a form similar to that used by
    LMAX—that is, JSON, which contains a timestamp in *ISO 8601* format. Since the
    JSON (or XML in general) is basically the same as native Python dictionaries,
    we add a dictionary to the dictionary. Now, referring to `self.series` by the
    timestamp as the keyword will return another dictionary that contains the data
    sample itself. This is what we referred to as *low-level objects* at the beginning
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We can refer to ticks by timestamp only in case the data feed doesn’t send ticks
    with identical timestamps. This is mostly the case with direct feeds from trading
    venues. The suggested code will always rewrite the contents of a tick with the
    last received value with the same timestamp, so if you really need to keep all
    ticks stored, consider adding **unique IDs** (**UIDs**) to them. The public LMAX
    data feeds that we’re using throughout the book for development and testing purposes
    never send ticks with identical timestamps.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now, let’s add a basic function that finds a data sample by its timestamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that two keywords (`[ts]` and `[key]`) are used here, one immediately
    after another. This is exactly because of the data structure just explained: we
    have dictionaries in a dictionary, so the first keyword `[ts]` retrieves the data
    sample dictionary, and the second one—`[key]`—actually returns the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note here that such a method of retrieving ticks by their
    timestamps assumes that we know the exact timestamp with milliseconds precision.
    If we are unsure about it or want to extract a few ticks that came—for example—in
    1 second or even 1 minute, we can use the following code, which will return a
    list of ticks whose timestamps start with the same time (actually, we look for
    a substring in the `timestamp` key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'OK—let’s give our code a try. Let’s use the same example as before—create a
    new data series object, add a sample to it, and read the `trade_id` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run this code (not forgetting to add `from datetime import datetime` at
    the very beginning), we will get `0B5WMAAAAAAAAAAS`, which is indeed the trade
    ID of the stored tick data sample.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can easily implement creating, adding, and reading data from our
    storage without using any database. Of course, this approach will somewhat limit
    the capabilities of retrieving and aggregating data by other keys—for example,
    retrieving all ticks with the same price or with a trade quantity that lies in
    a certain range.
  prefs: []
  type: TYPE_NORMAL
- en: Remember
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring or messing with the data, especially the order in which ticks or bars
    are received, will most likely lead you to develop a strategy which will work
    only on this damaged data, and won’t work with real market data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for most practical trading applications, it is even better not to be able
    to get data by any other keyword except for the timestamp. However, if you’re
    into some kind of academic research and do need special modes of data retrieval,
    there’s good news for you: pandas will allow you to do even this (we will have
    a surface look at pandas in [*Chapter 8*](B19145_08.xhtml#_idTextAnchor130), *Data
    Visualization in FX Trading* *with Python*).'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way to store tick market data would be in a list, not a dictionary.
    This way, we could forget about timestamps and read data samples one by one, using
    an index—which is especially useful when running backtests using historical data.
  prefs: []
  type: TYPE_NORMAL
- en: However, there’s one significant problem with storing market data in lists.
    In case you need to add any data sample *in the past*, you will have to scan the
    list to find the correct place where to insert the new sample, and this operation
    is quite time-consuming. So, using dictionaries with timestamps as keywords is
    always preferable.
  prefs: []
  type: TYPE_NORMAL
- en: You may argue that inserting a sample *in the past* sounds ridiculous and is
    hardly required. Well, just go on reading this chapter, and in the section dedicated
    to cleaning up the market data, you will see how in demand such a capability may
    be.
  prefs: []
  type: TYPE_NORMAL
- en: Order book (depth of market)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some data providers (not many, actually) are kind enough to provide not only
    top of book (the best bid and ask prices), but also some depth of market (see
    the *Exchange and order book* section of [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044),
    *FX Market Overview from a Developer’s Standpoint*). In general, receiving order
    book data is not much different from receiving ticker data. The only difference
    is that ticker data contains a single value for each bid, ask, and last price,
    whereas order book data contains multiple values for bids and asks and does not
    contain any last value.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving order book data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look at the example provided by LMAX in its API documentation, we can
    see that the JSON representing the order book information can be interpreted by
    Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Highest level**: A dictionary similar to that of ticker data, but without
    last trade and session information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower level**: A list of bids and asks, sorted by price in descending and
    ascending order, respectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lowest level**: Another dictionary that contains the actual price and quantity
    for each bid and ask:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Therefore, we can use exactly the same code as we originally used for storing,
    adding, and reading tick data. We will only need to add another level of indexes
    and keywords to access actual values. For example, if we add the preceding sample,
    then we can retrieve the best bid price by the timestamp using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The beginning of this line is identical to that of the example with ticker data
    from the previous section, then follows the index `[0]`, which is used to retrieve
    the best bid (as both bids and asks are sorted, the first element in the list
    always contains the best bid or ask), and finally, another keyword—`price`, used
    to retrieve the price information out of the price/volume pair.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can retrieve tick data, but remember that it may occupy too much space
    in memory or on disk. So, it would be nice to use only the required amount of
    data for a specific trading strategy. That’s why we proceed with data compression.
  prefs: []
  type: TYPE_NORMAL
- en: Data compression – keeping the amounts to a reasonable minimum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we already considered one of the most popular data
    compression techniques used by data providers: snapshots. The difference is that
    a tick represents a single event (such as a new trade or a change in bid or ask)
    and a single price value, but a snapshot instead discards information about individual
    ticks and replaces it with the following prices per period:'
  prefs: []
  type: TYPE_NORMAL
- en: Price of the first tick of the period (or **open**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum price for the period (or **high**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum price for the period (or **low**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price of the last tick of the period (or **close**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if the period is 1 minute and during this minute 100 trades were
    placed, then the snapshot will replace 100 ticks (or 100 prices) with just 4 prices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting snapshots are called bars when plotted on charts. Very frequently,
    traders and developers use *bars* instead of *snapshots*. Graphically, a bar is
    typically presented as a vertical line with two dashes. As you can see in the
    following diagram, the one pointing to the left means the opening (first) price
    of the interval represented by this bar, and the one pointing to the right means
    the last (closing) price of the same interval, while the top and bottom of the
    vertical line represent the maximum and the minimum prices of the interval, respectively.
    These bars are called **Open-High-Low-Close bars** or **OHLC bars**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Bars and Japanese candlesticks as a visual representation of
    data compression](img/B19145_5_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Bars and Japanese candlesticks as a visual representation of data
    compression
  prefs: []
  type: TYPE_NORMAL
- en: In case the left dash is lower than the right one, we say that the bar *closes
    up* or the price movement was upward during that period of time (during that bar).
    If the right dash is lower than the left one, we say that the bar *closes down*
    or the price movement was downward.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way of presenting bars, which is known as **Japanese candlesticks**.
    They don’t have dashes to the left and to the right, but instead the range between
    the open and close prices is drawn as a rectangle. And to show whether the opening
    price was greater or less than the closing one, we use color coding: white or
    green normally means that the bar closes up (that the closing price was greater
    than the opening one), and black or red means that the bar closes down.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, is data compression good or bad?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the answer depends on the intended purpose of using the data compression.
    In general, data compression allows us to dramatically reduce storage space. Just
    to give you an idea: 4 years’ worth of historical market data compressed into
    1-minute bars takes about 152 MB if saved as an American Standard Code for Information
    Interchange (ASCII) CSV file. The same time span of tick data will take about
    1.4 to 3 GB depending on the type of tick data (whether only the last trade is
    transmitted as a tick or every change in bid or ask price is included).'
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, using data in compressed format radically speeds up the backtesting
    process (remember that backtesting means simulating trades generated by the algorithm
    using pre-stored historical price data). No surprise that processing 100,000 records
    is much faster than processing 1 million.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when you use historical data from a data vendor or download it from
    your broker’s website, most likely it will be compressed down to 1 minute, 10
    seconds, or 1 second, but anyway it’s unlikely to be raw tick data.
  prefs: []
  type: TYPE_NORMAL
- en: When developing trading strategies, we often use much less granular resolutions,
    such as 1 hour, 4 hours, 1 day, and sometimes even 1 week or 1 month.
  prefs: []
  type: TYPE_NORMAL
- en: However, using compressed data has a serious disadvantage for developers. Since
    individual ticks are gone, we cannot say which price came first, second, and so
    on inside an individual bar. In [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171),
    *Types of Orders and Their Simulation in Python*, we will consider serious issues
    related to using compressed data in trade simulation and see how we can minimize
    the risk of making a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: As we are now familiar with the concept of data compression, let’s see how we
    can practically use it. We will start with retrieving already compressed data
    and then see how we can compress data in our own code.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving compressed data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some data vendors, brokers, and trading venues use compressed data for live
    streaming, but most use it for historical data. In this case, you can download
    it as XML or—more frequently—as traditional CSV files. Contents again (as always!)
    depend on the data provider’s free will, but at the very least it should contain
    the timestamp and the OHLC price data. Some data providers also include the trading
    volume data and even the number of upticks and downticks (moments when the price
    changed up or down respectively), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s see how we can efficiently read, store, and retrieve historical
    compressed price data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need some preparations. We will obviously need the `datetime` module,
    storage for all data (dictionary), and storage for an individual data sample (another
    dictionary):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to read the data. If we’re working with a CSV file, it can be
    done very easily, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s read the first line (the header) to avoid possible errors when parsing
    price data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’re going to read lines from the file, one by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the body of this loop, we remove any ending newline characters and parse
    the received line into a `values` list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’re going to merge the date and the time into a single string and convert
    it to a `datetime` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will gather the rest of the info into a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the new sample to the global dataset dictionary using `timestamp`
    as a keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we check the data for the first record in the dataset, we will get
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if I want to retrieve a particular value for the closing price on a certain
    date and at a certain time, I may want to use something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where timestamp stands for the timestamp at which you'd like to retrieve the
    closing price.
  prefs: []
  type: TYPE_NORMAL
- en: When running backtests, we do not retrieve data samples by their timestamp,
    though; instead, we’d like to have a method to continuously get samples one by
    one in strict chronological order. Native Python dictionaries normally contain
    unsorted data; however, there’s a workaround that allows us to sort data by keywords—making
    dictionary keys sorted and automatically getting data samples sorted always in
    correct chronological order. Alternatively, you can use the `OrderedDict` subclass
    of the Python native `dict` object, which implements a dictionary with keys pre-sorted
    (you can find a simple tutorial on `OrderedDict` at [https://www.tutorialspoint.com/ordereddict-in-python](https://www.tutorialspoint.com/ordereddict-in-python)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we use the built-in `sorted` method, which returns a list of the
    sorted values for any iterable in ascending order by default—exactly what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will print all data samples from the very first to the very
    last in strict chronological order (don’t run this code with massive datasets
    as it will take a lot of time to display!).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can read historical data, sort it in correct chronological order, and
    retrieve it one by one—that’s all we need to be ready for backtesting of our algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing market data in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is quite possible that even though a full tick data stream is available from
    the data provider, we still want to compress it, and not only to save disk storage
    space. The reason for this compression could be much more important, such as our
    trading algorithm can possibly generate some signals or calculate some auxiliary
    metrics using historical data that is compressed. Therefore, we also need to feed
    the algorithm with data compressed in a similar manner. And although tick data
    provides much more information as such, we may still want to compress it to make
    it compatible with the trading logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most correct way to compress the data from tick to OHLC bars would be to
    have a method that receives ticks, recalculates OHL (open-high-low) values with
    each tick, and then adds the C (close) value when the time comes. For example,
    if we want to compress ticks into 1-minute bars, this method would create a new
    bar at the beginning of each minute and complete it when the minute’s interval
    has passed. Let’s look at an example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have historical tick data in a local file (we will see how
    properly written code allows us to quickly switch from files to any other source
    of data):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We immediately read the first line of the file and never use it as the first
    line as just the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we don’t forget to import `datetime` and create two dictionaries—one
    for the entire data series and another for an individual bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we set the resolution for our newly formed time-based bars. I recommend
    using a universal measurement unit here. For example, if you work with relatively
    slow trading strategies, then you may want to count time in minutes. For greater
    precision and granularity, you may want to go down to seconds. So, let’s use seconds
    as units and form 1-minute bars (1-minute bar equals to 60 seconds):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we should read another line from the file, still outside the main loop,
    to get the first timestamp. We are going to compare all further timestamps with
    this one, and as soon as the distance (in time) between the two becomes greater
    than the resolution (60 seconds in our case), we will start a new bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At last, the main loop starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Until this point, the code of the loop body is identical to what we already
    did—we read a new line and parse it. But then, we compare the received timestamp
    with the timestamp of the last formed bar or sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can feel all the beauty of using timestamps in datetime format. You
    can add or subtract them as if they were just regular numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note for nerds
  prefs: []
  type: TYPE_NORMAL
- en: 'Python supports multiple types that handle dates and times. Besides `datetime`,
    there is another useful type—`timedelta`, which allows easily defining time spans.
    If you want to learn more about `timedelta` and how to efficiently use it, try
    this tutorial: [https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/](https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when the time delta between the new tick timestamp and the previous fully
    formed bar timestamp is greater than the resolution, we add the current bar to
    our `bars` global dictionary and start a new bar by replacing its values with
    the same price—the price of the last tick. Don’t forget to convert strings to
    numbers down the road:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, if the time delta is still less than the resolution (in our
    example, it’s under 1 minute), then we just update the values of the current bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems like we’re done with coding. Alright—let’s run our code, and we will
    immediately get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the dictionary in which we form the current bar does not have
    the `high` keyword. How can this happen? Of course, it happens during the forming
    of the very first bar: until we save at least one bar, none of its properties
    (open, high, low, or close) is available. So, we fix our code by adding a `try`...`except`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Now, during the formation of the very first bar, we can see only `First bar
    forming...` on the screen. You can replace this message with anything or completely
    remove it by replacing the `print` statement with `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the code again, and we can see that now it’s executed successfully.
    If we check the last 4 records in the `bars` variable, we can see that the timestamps
    of bars indeed have a delta of approximately 1 minute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But wait! The timestamps are OK, but why are all respective prices (comparing
    open to open, close to close, and so on) in all bars identical?!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have an issue that actually is one of the most prominent features
    of Python as a very well-developed object-oriented language. What we actually
    do in our code is the following sequence of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We create `object1` (`bars` dictionary).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `object2` (`bar` dictionary).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `object2` to `object1` with a `new` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we *modify* `object2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, we add `object2` to `object1` with a `new` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '...and then repeat this loop.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the point? We thought we’d add a new object every time we wanted to add
    a new bar to `bars`, but in reality, we add *the same* object—the same `bar` dictionary—only
    with modified values. I know that at first, it’s hard to understand, so try to
    think this way: the `bars[ts] = bar` assignment means saving a *link* to the `bar`
    object into the `bars` object with the `ts` keyword. In this case, once the `bar`
    object itself is modified, the reference to it in the `bars` object remains the
    same, so we always get modified values when we try to retrieve the `bar` object
    from `bars`.'
  prefs: []
  type: TYPE_NORMAL
- en: But what do we actually want here? Of course, we want to save *every bar individually*
    so that if we update the `bar` object outside the `bars` object, its new values
    *will not affect* whatever is already stored in the `bars` object.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we want to save not the `bar` object itself, but *a copy of it,* which
    will remain unmodified when we update the `bar` object in the future. To do that,
    we just replace `bars[ts] = bar` with `bars[ts] = dict(bar)`. Here, `dict` is
    a class that generates a *new* dictionary out of any iterable, mapping object,
    or keyword arguments. In our case, it’s quite simplified as we use a ready dictionary
    (`bar`) as the mapping object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code now, with this edit, we can see that not only timestamps
    are correct, but the price data in `bars` is correct as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: So, now, we have 1-minute bars formed from tick data.
  prefs: []
  type: TYPE_NORMAL
- en: '*But what do their* *timestamps mean?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Which time do they* *actually reference?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*And why is the seconds value of these timestamps not zero (as we would expect
    for a 1-minute resolution), but also differs slightly from bar* *to bar?*'
  prefs: []
  type: TYPE_NORMAL
- en: To answer the first question, our algorithm in its present form saves the timestamp
    *of the last tick of the time interval*. This happens because the trigger by which
    we start forming a new bar is `if delta.seconds >= resolution`. So, `if` starts
    a new bar as soon as (and no earlier than!) a new tick is received, and the timestamp
    of this new tick differs from its immediate predecessor by a value (which is called
    `timedelta`) that is greater than `resolution`. In other words, if we set `resolution`
    to 1 second, then we start a new bar only when we receive a tick whose timestamp
    differs from the start (open) of the currently forming bar by 1,000 milliseconds
    or more.
  prefs: []
  type: TYPE_NORMAL
- en: This also answers two remaining questions. Since the timestamp of the very first
    received tick (the first tick in the data file) may not be a *round* number and
    minutes with zero seconds, we start counting 60 seconds not from the beginning
    of a minute, but from an arbitrary moment.
  prefs: []
  type: TYPE_NORMAL
- en: '*“Is it good or bad?”* you may ask.'
  prefs: []
  type: TYPE_NORMAL
- en: Neither.
  prefs: []
  type: TYPE_NORMAL
- en: The correct question here would be “*Does it suit my* *trading algorithm?*”.
  prefs: []
  type: TYPE_NORMAL
- en: And the answer depends on the logic of your algorithm. If it only analyzes the
    sequence of prices (or maybe volume, if the volume is provided by the data provider)
    then yes—this method works well and is really easy to implement. However, if your
    strategy logic assumes triggering orders or doing calculations at the real edge
    of a minute (or any other time interval), then this method won’t fit.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we can easily modify our code so that it’s generating bars with the
    exact 1-minute resolution. The problem is that there’s no universal way of doing
    that, and the choice depends on whether you work with a live data stream or with
    saved tick data. To better understand it, let’s first quickly go back to the problem
    of retrieving data from external data sources and keeping your trading application
    modular and scalable. Then, you will understand how the problem of generating
    correct timestamps can be elegantly solved within this paradigm. All this, coming
    up in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Working with saved and live data – keeping your app universal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we quickly observed various methods to get market data
    from LMAX, one of the most important ECNs in the FX market. Without going into
    too much technical detail, we can assume that most other brokers, trading venues,
    and data vendors use more or less the same protocols and APIs based on socket
    connections. So, it should not be a problem to re-adapt your code to start retrieving
    data from a new source.
  prefs: []
  type: TYPE_NORMAL
- en: However, from the previous chapter, I hope you also remember that despite similarities
    in the transport layer of the connection, almost every data source has its own
    features that can only be found in its documentation (and sometimes, unfortunately,
    only in direct talks with its technical support).
  prefs: []
  type: TYPE_NORMAL
- en: This means that even if you implemented—for example—**Financial Information
    eXchange** (**FIX**) protocol version 4.4 with one broker, it is quite possible
    that you will have to modify something in your code or FIX dictionary when you
    want to connect to another broker. With proprietary APIs, the situation is obviously
    more complex, and sometimes the entire code should be rewritten (everything on
    top of the transport layer, such as the socket connection).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a good practice when building a trading application is to make sure that
    it has a modular structure where modules have interfaces talking to each other
    using an internal, built-in, universal transport infrastructure. Such an infrastructure
    should transfer price information between modules regardless of their particular
    implementation, even if they are provided by third parties. In this case, you
    don’t have to modify the entire application once you want to switch to another
    data source: you just need to write a new module, and a new plugin if you want,
    which would connect to the new source but deliver data in the same internal format
    compatible with the rest of the app’s modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, we want to create an architecture as shown in *Figure 5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The most simplistic data transport infrastructure for a trading
    app](img/B19145_5_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The most simplistic data transport infrastructure for a trading
    app
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this simplistic architecture has prominent flaws:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports only one source of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports only one trading algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we may want to upgrade our architecture a bit to add multiple data streams
    to our trading algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Multiple data sources with a single trading algorithm](img/B19145_5_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Multiple data sources with a single trading algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, this architecture reveals a new problem: how to sync multiple data streams?
    How to decide which tick to pass to the algo if we have multiple sources? How
    do we request these sources? If we do that from our global infinite loop (`for
    line in file` for data read from a file or `while True` for socket connections),
    then we will have a really hard time switching to another data source because
    it will require rewriting almost the entire code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if we want to run a number of trading algorithms in parallel using
    a number of data sources, we quickly come to a complete mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Using multiple data sources with multiple algorithms in a bad
    way](img/B19145_5_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Using multiple data sources with multiple algorithms in a bad way
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we clearly understand what we actually need to build a robust infrastructure.
    We need:'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to run multiple processes of retrieving data *concurrently* without
    interfering with one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to store received data in universal elastic storage that is being
    filled with new data and then emptied as older ticks are processed by the trading
    algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we are talking about an architecture as shown in *Figure 5**.5* with multiple
    data connectors, each of them having methods to connect, get data, and write it
    to a kind of a queue, and multiple trading algorithms (about whose internal architecture
    we don’t know anything yet) exchanging information using universal *elastic storage*,
    as described in the preceding list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A better architecture of the data transport layer of a trading
    application](img/B19145_5_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – A better architecture of the data transport layer of a trading
    application
  prefs: []
  type: TYPE_NORMAL
- en: Python does offer native solutions to both problems in an exceptionally streamlined
    and convenient way (as always, though). The ability to run data connectors concurrently
    is provided by *threads*, while the “elastic storage” mentioned previously is
    a *queue*. Let’s give both some insight.
  prefs: []
  type: TYPE_NORMAL
- en: A **thread** is a separate branch of execution of the program’s code that runs
    *concurrently* with the main code or in parallel with other threads. It can be
    implemented only within the paradigm of **object-oriented programming** (**OOP**)
    where we no longer have a single algorithm with a single start and a single end
    point, but instead, we have objects with their own behavior that can co-exist
    without interfering with one another or interacting with each other, depending
    on the will of their creator. So, a thread is an object that runs a function (a
    method) in parallel with everything else. Exactly what we need for retrieving
    data from multiple sources without syncing, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'A **queue** is... well, a queue that you can see at a cash desk around Christmas
    time. Customers are served on a first-come, first-served basis. The data in a
    Python queue is treated the same way: whatever gets into the queue is moving along
    as older data is being processed. The moment a new element is retrieved, it is
    removed from the queue, freeing up space for newer data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how queues work, let’s consider a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, it will print `Sample 1` because the very first element
    in the queue was the `Sample 1` string. However, if you work in an interactive
    console and type `print(q.get())` again (or just add another `print(q.get())`
    statement to the code), then this second `print` statement will print `Sample
    2` because `Sample 1` was already retrieved by the `.get()` method and deleted
    from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what threads and queues are, we can suggest a final draft
    for the architecture of the data transport layer of our trading application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The final draft of the architecture of the data transport layer
    of a trading app](img/B19145_5_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The final draft of the architecture of the data transport layer
    of a trading app
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now try to implement it in code.
  prefs: []
  type: TYPE_NORMAL
- en: Universal data connector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the necessary preparations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to specify the source data file, read the header, and do some
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a universal data stream, something into which all retrieved
    data will be written. Of course, it’s an instance of Python’s `queue` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now, let’s create our first method that retrieves data, this time from
    a local file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Can you see the already familiar code? Yes, of course—this is just a copy of
    what we did in the previous section, but this time wrapped into a function. So
    far, no different from what we did before. The difference comes with the following
    two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `emulate_tick_stream()`, reads a new tick from the file
    every second and puts it into the `datastream` queue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This 1-second delay is added here only for demonstration purposes—real data
    retrieval methods should not contain any delays!
  prefs: []
  type: TYPE_NORMAL
- en: The second function is simply a prototype—a dummy trading algorithm. It does
    nothing but report that it successfully received a new data sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to run both processes—retrieving and processing data—in parallel.
    The time has come for Python threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way, we create two instances of the `Thread` class, one for retrieving
    data (`data_source_thread`) and one for processing data (`data_receiver_thread`).
    As the only argument, we pass the name of the function that we would like to run
    within this thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We pass the function name and do not call the function itself! If you type something
    such as `threading.Thread(target = trading_algo())`, the function will be called
    right *at the point it is passed* into the thread, so *the thread will never*
    *actually start*!
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do now is to run the two threads concurrently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That’s it! Now if we run the code in a new console window, we will see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: A new line will appear every second (because we have a delay of 1 second in
    the `get_tick()` function).
  prefs: []
  type: TYPE_NORMAL
- en: Even in this simple example, we can see the power of using an object-oriented
    approach to developing trading apps and especially using threads and queues. Now,
    you can rewrite the `get_tick()` function to connect to a totally different data
    source, and the rest of your code will remain completely, absolutely untouched!
    You can replace reading from a file with reading from a socket, from a REST API,
    or from whatever you (or your broker) might imagine. It won’t ever affect the
    rest of your code, given your new `get_tick()` function returns data in the same
    format.
  prefs: []
  type: TYPE_NORMAL
- en: And now, we can get back to the discussion on data compression, which we somehow
    abruptly dropped in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Data compression revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that we compressed tick data into 1-minute bars, but the actual beginning
    and end of a minute was not when the number of seconds was zero, but at an arbitrary
    point inside a minute interval? That time, we were unable to solve this problem
    because we only read data samples one by one from a file at a speed that was unknown
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: But with the power of threading and queuing, we can form *correct* 1-minute
    (or any N-minute) bars with perfect precision when the new bar starts at exactly
    00 seconds. All we need is to add a new function and run it in a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note how easy it is now to customize data processing. We no longer rewrite the
    entire code—we only add new functionality or modify a single function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a function that will break our incoming data stream into 1-minute
    bars simply by using a system timer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with creating a dictionary for the currently forming bar (as
    in the previous example), and, as always with functions that are supposed to work
    inside threads, we start with an infinite loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will read data from the data stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this call is universal for any data recipient, be it a trading strategy,
    a data compressor, a database, or whatever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will check the current time (system time), and if its seconds value
    is zero, we will save the formed bar and start a new one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the code is the same as in the aforementioned example and handles
    exceptions that are raised when the first bar is not complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this function almost completely copies the code we used in
    the *Compressing market data in Python* section, with the only important modification
    being that now, instead of comparing timestamps of individual ticks, we finalize
    the bar *by a system timer*. As soon as the *system time* passes a minute, which
    means that its seconds value is zero, we start a new bar.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, synching time is one of the greatest problems in algo trading. The
    system time on the trading server may differ from the clock at the data vendor’s,
    and the clock at the broker or ECN may again differ from both. Luckily, in the
    further examples, we are going to use only 1-second snapshots of live data and
    1-minute bars of historical data, so the problem of clock synchronization can
    be set aside for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code using pre-saved historical tick data, you will see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the first bar does not have price data as it was started before
    the first minute ended. All the following bars have OHLC values that correspond
    to the *last ticks of the minute* by the time the system timer triggered a new
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I hope you understand why historical compressed data from a broker always
    has nice *round* timestamps: they do not correspond to actual ticks; they are
    simply split into bars by the system timer.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that this method works perfectly with live data that is received
    from a broker, a trading venue, or a similar source. It doesn’t really suit for
    processing pre-saved historical data because it can be read back from disk at
    speeds that seriously exceed the real speed at which ticks are being received
    from the market. So, with historical data, it’s better to use the *tick-to-tick
    timestamp compare* approach that we considered in the *Compressing market data
    in Python* section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with threads and queues and want to learn more about
    the ways you can use them in your trading apps, I’d recommend starting with a
    simple tutorial here ([https://realpython.com/intro-to-python-threading/](https://realpython.com/intro-to-python-threading/))
    and then referring to the official Python documentation here ([https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html))
    for tips and tricks and deeper understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to process both live and historical market data
    and, most importantly, how to do it in an efficient way. We are now familiar with
    time-based bars, which are most heavily used in trading strategies. We also learned
    about the solution that helps keep our trading applications flexible and quickly
    switch from one data source to another, which will help when switching from testing
    to production in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to move on to using the processed market data in our trading
    strategies. Let’s see how we can do this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
