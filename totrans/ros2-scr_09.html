<html><head></head><body>
		<div id="_idContainer046" class="calibre2">
			<h1 class="chapter-number" id="_idParaDest-163"><a id="_idTextAnchor338" class="pcalibre calibre4 pcalibre1"/>7</h1>
			<h1 id="_idParaDest-164" class="calibre6"><a id="_idTextAnchor339" class="pcalibre calibre4 pcalibre1"/>Actions – When Services Are Not Enough</h1>
			<p class="calibre3">In this chapter, we will explore the third communication type in ROS 2: actions. To understand actions, you need to have read the previous chapters on nodes, topics, <span>and services.</span></p>
			<p class="calibre3">Before we begin, I want to alert you that this chapter covers more advanced material compared to what we encountered previously and what’s <span>to come.</span></p>
			<p class="calibre3">If you already have some level of expertise, this chapter will satisfy you as it will give you a full overview of all three ROS 2 communication types. However, if you’re just getting started with ROS with zero experience, it might be a bit too much for you right now. This is OK, and topics/services are more than enough to get started with ROS 2. You can skip this chapter (which is independent of future chapters) for now and continue with parameters and launch files. It might be a good idea to come back to it at a later stage after you’ve built more confidence by working on ROS <span>2 projects.</span></p>
			<p class="calibre3">Throughout this chapter, you will understand why you need actions and how they work by going through an example that we will build step by step. Then, you will write the code to make two nodes communicate with each other. We will use the code in the <strong class="source-inline1">ch6</strong> folder (in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>) as a starting point. You can find the final code in the <span><strong class="source-inline1">ch7</strong></span><span> folder.</span></p>
			<p class="calibre3">By the end of this chapter, you will be able to write an action server and client and take advantage of all action features, such as feedback and <span>cancel mechanisms.</span></p>
			<p class="calibre3">Even though topics and services are more than enough to get started, ROS 2 actions are important as they help you take your code to the next level and implement more complex behaviors in your <span>robotics applications.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre9">
				<li class="calibre10">What is a ROS <span>2 action?</span></li>
				<li class="calibre10">Creating a custom <span>action interface</span></li>
				<li class="calibre10">Writing an <span>action server</span></li>
				<li class="calibre10">Writing an <span>action client</span></li>
				<li class="calibre10">Taking advantage of all the <span>action mechanisms</span></li>
				<li class="calibre10">Additional tools to <span>handle actions</span></li>
			</ul>
			<h1 id="_idParaDest-165" class="calibre6"><a id="_idTextAnchor340" class="pcalibre calibre4 pcalibre1"/>What is a ROS 2 action?</h1>
			<p class="calibre3">To understand ROS 2 actions, we need to understand why we need them. That’s what we will focus <a id="_idIndexMarker416" class="pcalibre calibre4 pcalibre1"/>on first. After that, I will explain how actions work through a <span>real-life example.</span></p>
			<p class="calibre3">You quickly discovered actions in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 3</em></span></a> by running some existing nodes and command-line tools. The intuition you built there will help you better understand the concepts in <span>this chapter.</span></p>
			<p class="calibre3">Let’s dive in and see why and when actions could be needed in a ROS <span>2 application.</span><a id="_idTextAnchor341" class="pcalibre calibre4 pcalibre1"/></p>
			<h2 id="_idParaDest-166" class="calibre6"><a id="_idTextAnchor342" class="pcalibre calibre4 pcalibre1"/>Why actions?</h2>
			<p class="calibre3">So far, we’ve looked at two forms of communication in ROS 2: topics <span>and services.</span></p>
			<p class="calibre3"><em class="italic">Topics</em> are used <a id="_idIndexMarker417" class="pcalibre calibre4 pcalibre1"/>by nodes to send and receive messages. Publishers will publish data on a topic, and subscribers will subscribe to the topic to receive the data. Thus, topics are perfect for sending data streams in <span>your application.</span></p>
			<p class="calibre3"><em class="italic">Services</em> are used <a id="_idIndexMarker418" class="pcalibre calibre4 pcalibre1"/>for client/server interactions between nodes. The client sends a request to the server, after which the server executes or computes something and returns a response to <span>the client.</span></p>
			<p class="calibre3">So, that should be all, right? What else could <span>we need?</span></p>
			<p class="calibre3">In its early <a id="_idIndexMarker419" class="pcalibre calibre4 pcalibre1"/>days, ROS started with only topics and services. However, ROS developers quickly realized that something was missing for some robotics applications. Let’s see that with <span>an example.</span></p>
			<p class="calibre3">Imagine that you have a mobile robot with two wheels. First, you would create a node that’s responsible for controlling the wheels. This node would also be able to receive commands, such as <strong class="source-inline1">Move to (x, y) coordinates</strong>. Those commands would be transformed into a velocity to apply to the wheels. However, you would also like to be able to get <a id="_idIndexMarker420" class="pcalibre calibre4 pcalibre1"/>notified when the robot has <span>finished moving.</span></p>
			<p class="calibre3">With what we know so far, ROS 2 services seem to be a good option. In this server node, you could implement a <strong class="source-inline1">/move_robot</strong> service that will receive coordinates from a client. Once the command is received, the controller starts to move the wheels. Then, when the robot has reached its destination, the server returns a response to <span>the client.</span></p>
			<p class="calibre3">To complete the communication, we must add a service client to another node. The client will send a request to the server with the (x,y) coordinates to reach. When the server returns the response, we know that the robot has finished moving—either successfully by reaching the destination or something prevented it and we get <span>an error:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer043">
					<img alt="Figure 7.1 – Using a service to control a two-wheeled robot" src="image/B22403_07_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Using a service to control a two-wheeled robot</p>
			<p class="calibre3">What’s wrong <span>with that?</span></p>
			<p class="calibre3">Well, moving a physical part of a robot in space can take some time. It could be a fraction of a second in some cases, but also maybe a few seconds, or even a few minutes. The point is that the service execution could take a significant amount <span>of time.</span></p>
			<p class="calibre3">With that said, while the robot is moving, there are a few things you may want to do, and those things are missing when <span>using services:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Since the <a id="_idIndexMarker421" class="pcalibre calibre4 pcalibre1"/>execution is taking some time, it would be nice to get some feedback from the server. With a service, the client has no idea of what’s happening on the server side. So, the client is completely blind and needs to wait for the response to get <span>some information.</span></li>
				<li class="calibre10">How can you cancel the current execution? That would seem a reasonable feature to have. After you start the execution on the server side, the client may want to cancel it. For example, let’s say the client node is also monitoring the environment with a camera. If an obstacle is detected, the client could ask the server to stop the execution. With what we have for now, the client can’t do anything but wait for the server to finish <span>the execution.</span></li>
				<li class="calibre10">Here’s the last point for now, although we could find more: how could the server correctly handle multiple requests? Let’s say you have two or more clients, each one sending a different request. How can you possibly choose between those requests on the server? How can the server refuse to execute a request, or choose to replace a request with a new one, without finishing the first request? Or, in another scenario, how can the server handle multiple requests at the same time? As an analogy, when you download files on your computer, the computer isn’t stuck with just one file. It can download multiple files at the same time. You can even decide to cancel one download while the others are <span>still running.</span></li>
			</ul>
			<p class="calibre3">Coming back to <a id="_idIndexMarker422" class="pcalibre calibre4 pcalibre1"/>our example, you can see that a simple service is not enough. For this use case, we need more functionalities. What we could do is implement additional services, such as one to cancel a request. We could also add a new topic to publish some feedback about where the robot is during <span>the execution.</span></p>
			<p class="calibre3">There’s good news—you don’t have to do this. All these problems are solved by ROS 2 actions. The feedback mechanism, cancel mechanism, and other functionalities are also implemented directly <span>in actions.</span></p>
			<p class="calibre3">To conclude, services are perfect for client/server communication, but only if the action/computation is quick to execute. If the execution could take some time, and you want additional features such as feedback or cancellation, then actions are what <span>you need.</span></p>
			<p class="calibre3">Now that you know why we need actions, it’s time to understand how <span>they <a id="_idTextAnchor343" class="pcalibre calibre4 pcalibre1"/>work.</span></p>
			<h2 id="_idParaDest-167" class="calibre6"><a id="_idTextAnchor344" class="pcalibre calibre4 pcalibre1"/>How do actions work?</h2>
			<p class="calibre3">Let’s use <a id="_idIndexMarker423" class="pcalibre calibre4 pcalibre1"/>the previous example, this time using a ROS 2 action instead of a service. I will show you how actions work at a high level, with the different interactions between the client and the server. Later in this chapter, we will dive into the code and see the <span>implementation details.</span></p>
			<p class="calibre3">We will use two nodes: one containing an <strong class="bold">Action</strong> <strong class="bold">client</strong>, and the other containing an <strong class="bold">Action</strong> <strong class="bold">server</strong> (this is the one responsible for controlling <span>the wheels).</span></p>
			<p class="calibre3">To understand how actions work, let’s follow the execution flow for <span>one action:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer044">
					<img alt="Figure 7.2 – Execution flow for a ROS 2 action" src="image/B22403_07_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Execution flow for a ROS 2 action</p>
			<p class="calibre3">Here are <a id="_idIndexMarker424" class="pcalibre calibre4 pcalibre1"/>the steps for <span>this flow:</span></p>
			<ol class="calibre11">
				<li class="calibre10">The <strong class="bold">Action client</strong> will start the communication by sending a request to the <strong class="bold">Action server</strong>. For actions, the <em class="italic">request</em> is named <em class="italic">goal</em>. Hence, we won’t talk about requests here, but about <strong class="bold">goals</strong>. Here, the goal can be a (x, y) coordinate <span>to reach.</span></li>
				<li class="calibre10">The <strong class="bold">Action server</strong> receives the goal and decides to accept or reject it. The client immediately receives this response from the server. If the goal has been rejected, then the <span>communication ends.</span></li>
				<li class="calibre10">If the goal is accepted, the server can start to process it and execute the corresponding action. With this example, the <strong class="bold">Server node</strong> will make the <span>robot move.</span></li>
				<li class="calibre10">As soon as the client knows that the goal has been accepted, it will send a request to get the <strong class="bold">Result</strong> and wait for it (asynchronously, by registering a callback). For services, we talk about a <em class="italic">response</em>. For actions, this will be <span>a </span><span><em class="italic">result</em></span><span>.</span></li>
				<li class="calibre10">When the server is done executing the goal (either successfully or not), it will send the <strong class="bold">Result</strong> to the client. With this example, the result could be the final reached (x, <span>y) coordinates.</span></li>
				<li class="calibre10">The client receives the <strong class="bold">Result</strong>, after which <span>communication ends.</span></li>
			</ol>
			<p class="calibre3">This is how <a id="_idIndexMarker425" class="pcalibre calibre4 pcalibre1"/>an action works, with a minimal set of functionalities. From the server side, a goal is received, accepted or rejected, then executed, and the result is returned. From the client side, a goal is sent, and if accepted, a request is sent and the result is received from <span>the server.</span></p>
			<p class="calibre3">On top of that, you can add extra functionalities, all of which are optional. Here are the additional mechanisms <span>for actions:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer045">
					<img alt="Figure 7.3 – Action with all communication mechanisms" src="image/B22403_07_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Action with all communication mechanisms</p>
			<p class="calibre3">Let’s take a <span>closer look:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Feedback</strong>: The <a id="_idIndexMarker426" class="pcalibre calibre4 pcalibre1"/>server, while executing the goal, can send some feedback to the client. With this example, the feedback could be the current coordinates for the robot or even a completion rate. Thus, the client can know what’s happening during the <span>goal’s execution.</span></li>
				<li class="calibre10"><strong class="bold">Cancel</strong>: After the <a id="_idIndexMarker427" class="pcalibre calibre4 pcalibre1"/>goal has been accepted by the server and the goal is being executed on the server side, the client can decide to cancel that goal. To do so, it will send a cancel request that must be approved by the server. If the cancel request is accepted, then the server will try to finish the execution. So, in this example, it could make the robot stop. In the end, the server will still return a result to the client, whether the goal was successful, failed, <span>or canceled.</span></li>
				<li class="calibre10"><strong class="bold">Goal status</strong>: This is <a id="_idIndexMarker428" class="pcalibre calibre4 pcalibre1"/>not so important for you as it’s an internal mechanism for actions that you will not use directly in your code (I just added it here for completeness). Each goal will get a state machine, with states such as <em class="italic">accepted</em>, <em class="italic">executing</em>, and others. With each change of state for a goal, the server will notify <span>the client.</span></li>
			</ul>
			<p class="calibre3">With this, you have seen all possible communication mechanisms that can be implemented <span>within actions.</span></p>
			<p class="calibre3">Note that in the <a id="_idIndexMarker429" class="pcalibre calibre4 pcalibre1"/>preceding figure, some communications are represented with a red line, while others are presented with a green line. Behind the scenes, actions just use topics and services. Even if an action is a ROS 2 communication on its own, the underlying code is using the two other communication types. Here, red lines represent services, and green lines <span>represent topics.</span></p>
			<p class="calibre3">Thus, within an action, you have three services (send goal, cancel goal, and receive result) and two topics (feedback and goal status). The good news is that you don’t have to create those topics and services yourself—they are already implemented in the action mechanism. All you have to do is use the action client and server functionalities from the ROS <span>2 libraries.</span></p>
			<p class="calibre3">To create an action, you will need to give it a <strong class="bold">name</strong> (for example, <strong class="source-inline1">move_robot</strong>) so that the client knows where to send the goal. You will also need to use an <strong class="bold">interface (goal, </strong><span><strong class="bold">result, feedback)</strong></span><span>.</span></p>
			<p class="calibre3">One additional thing to note is that there can be only one action server. Just as for services, you can’t have two servers using the same name. On the other hand, you can have multiple action clients. Each client can also send multiple goals; that’s not <span>a<a id="_idTextAnchor345" class="pcalibre calibre4 pcalibre1"/> problem.</span></p>
			<h2 id="_idParaDest-168" class="calibre6"><a id="_idTextAnchor346" class="pcalibre calibre4 pcalibre1"/>Wrapping things up</h2>
			<p class="calibre3">On top of topics and services, you can use actions to make your nodes communicate with each other. Now, when should you use topics, services, <span>or actions?</span></p>
			<p class="calibre3">You should use <em class="italic">topics</em> when you want to send data streams between nodes. With topics, there’s no response. For example, this can work for publishing sensor data or sending a stream <a id="_idIndexMarker430" class="pcalibre calibre4 pcalibre1"/>of commands to another node if you don’t need <span>any confirmation.</span></p>
			<p class="calibre3"><em class="italic">Services</em> are perfect when you want client/server communication, but also if the action to execute is very quick, such as a computation or a simple action, such as switching on <span>an LED.</span></p>
			<p class="calibre3">Finally, you will use <em class="italic">actions</em> for anything that needs client/server communication and may take some time to execute, as well as when you also want to have mechanisms such as feedback <span>and cancel.</span></p>
			<p class="calibre3">Here are some important points about how <span>actions work:</span></p>
			<ul class="calibre9">
				<li class="calibre10">An action is defined by a name and <span>an interface.</span></li>
				<li class="calibre10">The name of an action follows the same rules as for topics and services. It must start with a letter and can be followed by other letters, numbers, underscores, tildes, and slashes. Also, as the action is <em class="italic">doing</em> something, the best practice is to start the name with <span>a verb.</span></li>
				<li class="calibre10">The interface contains three things: a goal, a result, and feedback. Both the client and server must use the <span>same interface.</span></li>
				<li class="calibre10">An action server can only exist once, but you can send multiple goals from one or multiple <span>action clients.</span></li>
				<li class="calibre10">Action clients aren’t aware of the node containing the server. They just know they have to use the action name and interface to reach <span>the server.</span></li>
			</ul>
			<p class="calibre3">To implement an action communication, you will need to do the following at the <span>very least:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Send a goal from the client to <span>the server.</span></li>
				<li class="calibre10">Accept (or not) the goal and execute it on <span>the server.</span></li>
				<li class="calibre10">Once the goal is finished, return a result from the server to <span>the client.</span></li>
			</ul>
			<p class="calibre3">The following are some optional features you <span>can add:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Send some <a id="_idIndexMarker431" class="pcalibre calibre4 pcalibre1"/>execution feedback from the server to the client while the goal is <span>being executed.</span></li>
				<li class="calibre10">Allow the <a id="_idIndexMarker432" class="pcalibre calibre4 pcalibre1"/>client to send a cancel request to the server. If accepted, finish the goal execution on the <span>server side.</span></li>
			</ul>
			<p class="calibre3">To write action servers and clients in your code, you must use the action functionality from the <strong class="source-inline1">rclpy.action</strong> and <span><strong class="source-inline1">rclcpp_action</strong></span><span> libraries.</span></p>
			<p class="calibre3">At this point, we can start writing some code. If you’re still a bit confused, don’t worry—actions are quite <a id="_idIndexMarker433" class="pcalibre calibre4 pcalibre1"/>complex to grasp initially. They contain lots of different mechanisms. Everything will make more sense as we create an action and write the client and <span>server code.</span></p>
			<p class="calibre3">Since we can’t test a client without a server, we will, as we did for services, start with the server side. To create a server, we need an action interface, so that will be our <span>s<a id="_idTextAnchor347" class="pcalibre calibre4 pcalibre1"/>tarting point.</span></p>
			<h1 id="_idParaDest-169" class="calibre6"><a id="_idTextAnchor348" class="pcalibre calibre4 pcalibre1"/>Creating a custom action interface</h1>
			<p class="calibre3">To create <a id="_idIndexMarker434" class="pcalibre calibre4 pcalibre1"/>an action interface, we first need to clearly define what we need to achieve with the action. Then, we can add the interface to the <strong class="source-inline1">my_robot_interfaces</strong> package (in this section, we will continue using the packages we created in the <span>prev<a id="_idTextAnchor349" class="pcalibre calibre4 pcalibre1"/>ious chapters).</span></p>
			<h2 id="_idParaDest-170" class="calibre6"><a id="_idTextAnchor350" class="pcalibre calibre4 pcalibre1"/>Defining the application and the interface we need</h2>
			<p class="calibre3">In the application that we will write in this chapter, the action server will be responsible for counting <a id="_idIndexMarker435" class="pcalibre calibre4 pcalibre1"/>until a given number, with a delay between each count, so that we can simulate that the action takes some time and doesn’t return immediately. The client will have to send a number to the server so that the server can start to count. When the server finishes, it will send the result (last reached number) back to <span>the client.</span></p>
			<p class="calibre3">For example, let’s say the client sends the number 5 to the server, and there’s a delay of 0.5 seconds. The server will start to count from 0, up to 5, and wait 0.5 seconds between each iteration. When finishing, the server will return 5 if it could count until the end, or the last reached number if the execution finished sooner (the goal was canceled, or any other reason that could make the server stop the goal). In addition to that, we will add some feedback about the current count while the server is executing <span>the goal.</span></p>
			<p class="calibre3">Before we write any code, we need to know what interface to use for the action. From the previous paragraph, we can see that we need <span>the following:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Goal</strong>: An integer for the target number and a float number for <span>the delay</span></li>
				<li class="calibre10"><strong class="bold">Result</strong>: An integer for the last <span>reached number</span></li>
				<li class="calibre10"><strong class="bold">Feedback</strong>: An integer for the <span>current count</span></li>
			</ul>
			<p class="calibre3">For topics <a id="_idIndexMarker436" class="pcalibre calibre4 pcalibre1"/>and services, you must first check whether you can find an existing interface that matches your needs as there are already a lot of them you can use without having to create a <span>new one.</span></p>
			<p class="calibre3">For actions, you could try to do the same, but there aren’t as many existing action interfaces. Actions are a bit more complex than the other communication types, so you would need to find an interface that matches the goal, result, and feedback for your application exactly. The probability of that is very low as each action will be quite different. Thus, for actions, we won’t try to find existing interfaces and create a cus<a id="_idTextAnchor351" class="pcalibre calibre4 pcalibre1"/>tom <span>one directly.</span></p>
			<h2 id="_idParaDest-171" class="calibre6"><a id="_idTextAnchor352" class="pcalibre calibre4 pcalibre1"/>Creating a new action interface</h2>
			<p class="calibre3">The process <a id="_idIndexMarker437" class="pcalibre calibre4 pcalibre1"/>of creating an action interface will be the same as for topic and service interfaces. We will follow a <span>similar approach.</span></p>
			<p class="calibre3">First, you need to create and configure a package dedicated to interfaces. We did that in <a href="B22403_05.xhtml#_idTextAnchor211" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 5</em></span></a>, in the <em class="italic">Creating a custom interface for a topic</em> section, with the <strong class="source-inline1">my_robot_interfaces</strong> package. You can reuse this package to add your action interfaces. If you don’t have it, go back and configure it first, then continue with the <span>following steps.</span></p>
			<p class="calibre3">In this package, we already have <strong class="source-inline1">msg</strong> and <strong class="source-inline1">srv</strong> folders for topic and service interfaces, respectively. We will add a third folder, named <strong class="source-inline1">action</strong>, for—as you may have <span>guessed—action interfaces:</span></p>
			<pre class="console">
$ cd ros2_ws/src/my_robot_interfaces/
$ mkdir action</pre>			<p class="calibre3">In this new folder, you will place all the action interfaces specific to your robot <span>or application.</span></p>
			<p class="calibre3">Now, create a <a id="_idIndexMarker438" class="pcalibre calibre4 pcalibre1"/>new file for your action. Here are the rules you must follow regarding <span>the filename:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Use UpperCamelCase—for <span>example, </span><span><strong class="source-inline">CountUntil</strong></span><span>.</span></li>
				<li class="calibre10">Don’t write <strong class="source-inline">Action</strong> or <strong class="source-inline">Interface</strong> in the name as this will add <span>unnecessary redundancy.</span></li>
				<li class="calibre10">Use <strong class="source-inline">.action</strong> for the <span>file extension.</span></li>
				<li class="calibre10">As a best practice, use a verb in the interface’s name—for example, <strong class="source-inline">NavigateToPosition</strong>, <strong class="source-inline">OpenDoor</strong>, <strong class="source-inline">PickObjectFromTable</strong>, or <strong class="source-inline">FetchDrinkFromFridge</strong>. Actions, just like services, are about performing an action or computation (which can take some time), so by using a verb, you make it very clear what the action <span>is doing.</span></li>
			</ul>
			<p class="calibre3">Since we want to count until a given number, let’s call the <span>interface </span><span><strong class="source-inline1">CountUntil</strong></span><span>:</span></p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_robot_interfaces/action/
$ touch CountUntil.action</pre>			<p class="calibre3">You can write the definition for the action in this file. Since we have three different parts (goal, result, and feedback), we need to separate them. You must add three dashes (<strong class="source-inline1">---</strong>) between the goal and the result, and another three dashes between the result and <span>the feedback.</span></p>
			<p class="calibre3">Even if you don’t want to send any feedback, or if the result is empty, you still have to add the two separations with three dashes (<strong class="source-inline1">---</strong>). A very simple action definition with nothing in the result and feedback would look <span>like this:</span></p>
			<pre class="source-code">
int64 goal_number
---
---</pre>			<p class="calibre3">For the goal, result, and feedback, you can use <span>the following:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Built-in types (<strong class="source-inline">bool</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">int64</strong>, and <span>so on).</span></li>
				<li class="calibre10">Existing message interfaces. For example, the goal of the action could <span>contain </span><span><strong class="source-inline">geometry_msgs/Twist</strong></span><span>.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">You can’t include an action or service definition inside an action definition. You can only include messages (topic definition) inside the goal, result, or feedback. Those three parts can be seen as three <span>independent messages.</span></p>
			<p class="calibre3">Since we are <a id="_idIndexMarker439" class="pcalibre calibre4 pcalibre1"/>creating a rather simple application, we will only use built-in <span>types here:</span></p>
			<pre class="source-code">
# Goal
int64 target_number
float64 delay
---
# Result 
int64 reached_number 
---
# Feedback 
int64 current_number</pre>			<p class="calibre3">As for topic and service interfaces, all fields inside the definition must follow the <strong class="source-inline1">snake_case</strong> convention (use underscores between words, all letters must be lowercase, and <span>no spaces).</span></p>
			<p class="calibre3">I’ve also added comments to specify which part is the goal, result, and feedback. You don’t need to do this—I only did it for your first action definition so that you don’t get confused. Often, people make mistakes regarding the order and put the feedback before the result, which can lead to hard-to-debug errors later. The order is goal, result, and <span>then feedback.</span></p>
			<p class="calibre3">Now that we’ve written our interface, we need to build it so that we can use it in our code. Go back to the <strong class="source-inline1">CMakeLists.txt</strong> file of the <strong class="source-inline1">my_robot_interfaces</strong> package. Since the package has already been configured, we just need to do one thing: add the relative path to the interface on a new line inside the <strong class="source-inline1">rosidl_generate_interfaces()</strong> function. Don’t use any commas between <span>the lines:</span></p>
			<pre class="source-code">
rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/HardwareStatus.msg"
  "srv/ResetCounter.srv"
  "srv/ActivateTurtle.srv"
<strong class="bold1">  "action/CountUntil.action"</strong>
)</pre>			<p class="calibre3">After this, save <a id="_idIndexMarker440" class="pcalibre calibre4 pcalibre1"/>all files and build the <span><strong class="source-inline1">my_robot_interfaces</strong></span><span> package:</span></p>
			<pre class="console">
$ colcon build --packages-select my_robot_interfaces</pre>			<p class="calibre3">Once built, source the environment. You should be able to find your <span>new interface:</span></p>
			<pre class="console">
$ ros2 interface show my_robot_interfaces/action/CountUntil
# Action interface definition here</pre>			<p class="calibre3">If you see the action definition, you know that your action interface has been successfully built, and you can now use it in your code. That’s what we will do, starting with the action server<a id="_idTextAnchor353" class="pcalibre calibre4 pcalibre1"/> for <span>our application.</span></p>
			<h1 id="_idParaDest-172" class="calibre6"><a id="_idTextAnchor354" class="pcalibre calibre4 pcalibre1"/>Writing an action server</h1>
			<p class="calibre3">In this section, you’ll write your first action server. In this server, we will be able to receive goals. When a goal is received, we will decide whether to accept or reject it. If it’s accepted, we will execute the goal. For this application, executing the goal means we will start <a id="_idIndexMarker441" class="pcalibre calibre4 pcalibre1"/>to count from zero to the target number and wait for the provided delay between each iteration. Once the goal has been executed, we will return a result to <span>the client.</span></p>
			<p class="calibre3">That’s what we will implement in the code, starting with Python and then C++. In this section, we start only with the minimum functionalities for the action communication to work correctly. We will add the feedback and cancel mechanisms later. Since actions are a bit more complex than topics and services, let’s start simple and go step <span>by step.</span></p>
			<p class="calibre3">For a better learning experience, make sure you use the GitHub code while following along as I will not necessarily display all lines in this chapter, only the important ones. The code for this section is located in the <strong class="source-inline1">count_until_server_minimal</strong> file (with <strong class="source-inline1">.py</strong> or <strong class="source-inline1">.cpp</strong> appended at the end). We won’t use the <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> <span>nodes here.</span></p>
			<p class="calibre3">Before we <a id="_idIndexMarker442" class="pcalibre calibre4 pcalibre1"/>write any code for the server, we need to choose a name and interface for our action. Since we want to count until a given number, we will name the action <strong class="source-inline1">count_until</strong>, and we will use the <strong class="source-inline1">CountUntil</strong> interface we’ve <span>just created.</span></p>
			<p class="calibre3">We now have everything we need to start w<a id="_idTextAnchor355" class="pcalibre calibre4 pcalibre1"/>riting the <span>Python code.</span></p>
			<h2 id="_idParaDest-173" class="calibre6"><a id="_idTextAnchor356" class="pcalibre calibre4 pcalibre1"/>Writing a Python action server</h2>
			<p class="calibre3">You will <a id="_idIndexMarker443" class="pcalibre calibre4 pcalibre1"/>need to write your action server inside a node. Create a new file named <strong class="source-inline1">count_until_server_minimal.py</strong> inside the <strong class="source-inline1">my_py_pkg</strong> package (along with the other Python files). Ma<a id="_idTextAnchor357" class="pcalibre calibre4 pcalibre1"/>ke this <span>file executable.</span></p>
			<h3 class="calibre8">Importing the interface and creating the server</h3>
			<p class="calibre3">Let’s <a id="_idIndexMarker444" class="pcalibre calibre4 pcalibre1"/>start by setting up the <span>action server.</span></p>
			<p class="calibre3">First, we must import a bunch of libraries and classes that we will need in <span>the code:</span></p>
			<pre class="source-code">
import rclpy
import time
from rclpy.node import Node
from rclpy.action import ActionServer, GoalResponse
from rclpy.action.server import ServerGoalHandle</pre>			<p class="calibre3">Unlike topics and services, the action server is not directly included in the <strong class="source-inline1">Node</strong> class. So, we need to import the <strong class="source-inline1">ActionServer</strong> class <span>from </span><span><strong class="source-inline1">rclpy.action</strong></span><span>.</span></p>
			<p class="calibre3">After this, you must also import the interface for <span>the action:</span></p>
			<pre class="source-code">
from my_robot_interfaces.action import CountUntil</pre>			<p class="calibre3">When you import an interface from another package, make sure to add the dependency to <strong class="source-inline1">my_robot_interfaces</strong> in the <strong class="source-inline1">package.xml</strong> file of <strong class="source-inline1">my_py_pkg</strong> (you should have already done this if you’ve been <span>following along):</span></p>
			<pre class="source-code">
&lt;depend&gt;my_robot_interfaces&lt;/depend&gt;</pre>			<p class="calibre3">Going back to the <strong class="source-inline1">count_until_server_minimal.py</strong> file, let’s create the action server in the node’s constructor (as stated in the introduction to this section, I’ll only display the important and relevant snippets; the full constructor code is available <span>on GitHub):</span></p>
			<pre class="source-code">
self.count_until_server_ = ActionServer(
           self,
           CountUntil,
           "count_until",
           goal_callback=self.goal_callback,
           execute_callback=self.execute_callback)</pre>			<p class="calibre3">To create <a id="_idIndexMarker445" class="pcalibre calibre4 pcalibre1"/>an action server with Python, you must use the <strong class="source-inline1">ActionServer</strong> class we imported previously. Provide the <span>following arguments:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Action node</strong>: The node to link the action server to. For topics and services, we started with <strong class="source-inline">self.create…()</strong>. Here, it’s a bit different: the object (<strong class="source-inline">self</strong>) is provided as the <span>first argument.</span></li>
				<li class="calibre10"><strong class="bold">Action interface</strong>: We use the <strong class="source-inline">CountUntil</strong> interface <span>we’ve imported.</span></li>
				<li class="calibre10"><strong class="bold">Action name</strong>: Since we’re writing the code for the server, we’re creating the action here. This is where you will choose the action name that all clients will have to use to send goals. As seen previously, we will <span>use </span><span><strong class="source-inline">count_until</strong></span><span>.</span></li>
				<li class="calibre10"><strong class="bold">Goal callback</strong>: When a goal is received, it will be processed inside <span>this callback.</span></li>
				<li class="calibre10"><strong class="bold">Execute callback</strong>: If the goal has been accepted in the goal callback, then it will be processed in the execute callback. This is where you will execute <span>the action.</span></li>
			</ul>
			<p class="calibre3">We specified <a id="_idIndexMarker446" class="pcalibre calibre4 pcalibre1"/>two callback methods when creating the action server. When the node spins, the action server will be in <em class="italic">waiting mode</em>. As soon as a goal is received, the node will trigger the goal callback, and then the execute callback if needed. Let’s<a id="_idTextAnchor358" class="pcalibre calibre4 pcalibre1"/> implement <span>those callbacks.</span></p>
			<h3 class="calibre8">Accepting or rejecting a goal</h3>
			<p class="calibre3">The action server can now receive goals. We need to decide whether to accept or <span>reject them.</span></p>
			<p class="calibre3">Let’s start <a id="_idIndexMarker447" class="pcalibre calibre4 pcalibre1"/>writing the goal callback, which is the first <a id="_idIndexMarker448" class="pcalibre calibre4 pcalibre1"/>method to be called whenever a goal is received by <span>the server:</span></p>
			<pre class="source-code">
def goal_callback(self, goal_request: CountUntil.Goal):
    self.get_logger().info("Received a goal")
    if goal_request.target_number &lt;= 0:
        self.get_logger().warn("Rejecting the goal, target number must be positive")
        return GoalResponse.REJECT
    self.get_logger().info("Accepting the goal")
    return GoalResponse.ACCEPT</pre>			<p class="calibre3">In this callback, we receive the goal that was sent by the client (it’s of the <span><strong class="source-inline1">CountUntil.Goal</strong></span><span> type).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">An action interface contains a goal, a result, and feedback. You get one class for each message: <strong class="source-inline">CountUntil.Goal</strong>, <strong class="source-inline">CountUntil.Result</strong>, and <strong class="source-inline">CountUntil.Feedback</strong>. We will use all three in <span>this chapter.</span></p>
			<p class="calibre3">The best practice is to validate the data you receive whenever you write the code for a server. For this application, let’s say we want to only accept positive target numbers. If the number is negative, we reject <span>the goal.</span></p>
			<p class="calibre3">After validating the data, you need to return either <strong class="source-inline1">GoalResponse.ACCEPT</strong> or <strong class="source-inline1">GoalResponse.REJECT</strong> to accept or reject the goal, respectively. The client will be notified <a id="_idIndexMarker449" class="pcalibre calibre4 pcalibre1"/>immediately of that decision. Then, if the <a id="_idIndexMarker450" class="pcalibre calibre4 pcalibre1"/>goal is rejected, nothing more happens on the server side. If the goal is accepted, the exec<a id="_idTextAnchor359" class="pcalibre calibre4 pcalibre1"/>ute callback will <span>be triggered.</span></p>
			<h3 class="calibre8">Executing the goal</h3>
			<p class="calibre3">Let’s <a id="_idIndexMarker451" class="pcalibre calibre4 pcalibre1"/>implement the execute callback. Here’s the beginning of <span>the code:</span></p>
			<pre class="source-code">
def execute_callback(self, goal_handle: ServerGoalHandle):
    target_number = goal_handle.request.target_number
    delay = goal_handle.request.delay
    result = CountUntil.Result()
    counter = 0</pre>			<p class="calibre3">In this callback, you get what’s called a goal handle, which is of the <strong class="source-inline1">ServerGoalHandle</strong> type. I’ve made the argument type explicit so that we can get auto-completion with VS Code. This goal handle contains the goal information, but you can also use it to set the goal’s final state, which we will see in <span>a minute.</span></p>
			<p class="calibre3">The first thing you must typically do is extract the data from the goal. Here, we get the target number and delay that we will use when executing the action. Then, we initialize a few things: the result from the <strong class="source-inline1">CountUntil.Result</strong> class, and a counter starting <span>at </span><span><strong class="source-inline1">0</strong></span><span>.</span></p>
			<p class="calibre3">With this, we can start to execute <span>the goal:</span></p>
			<pre class="source-code">
    self.get_logger().info("Executing the goal")
    for i in range (target_number):
        counter += 1
        self.get_logger().info(str(counter))
        time.sleep(delay)</pre>			<p class="calibre3">This part of the code will be different every time as it depends entirely on your application. Here, we’re incrementing the counter until the target number is reached, with a delay between <span>each iteration.</span></p>
			<p class="calibre3">The point of using a delay here is just to make this method take more time so that we can simulate the behavior of an action. If we wanted to count as fast as possible, without any delay, we could have used a service since the action would finish <span>almost immediately.</span></p>
			<p class="calibre3">Once the <a id="_idIndexMarker452" class="pcalibre calibre4 pcalibre1"/>execution is finished, we need to do two things—set a final state for the goal and return a result to <span>the client:</span></p>
			<pre class="source-code">
    goal_handle.succeed()
    result.reached_number = counter
    return result</pre>			<p class="calibre3">During the execution of the action, the goal is in the <em class="italic">executing</em> state. When finishing the execution, you need to make it transition into a <span>final state.</span></p>
			<p class="calibre3">In this case, since everything went smoothly and we didn’t expect any problems during the execution, we set the goal to <em class="italic">succeeded</em> by using the <strong class="source-inline1">succeed()</strong> method on the goal handle. If, for example, your action was responsible for moving the wheels of a robot, and if the communication with the wheels is lost during the execution, you would stop the action and set the goal to <em class="italic">aborted</em> with the <strong class="source-inline1">abort()</strong> method. The last possible state is <em class="italic">canceled</em>, which we will see a bit later in <span>this chapter.</span></p>
			<p class="calibre3">We’ve now written the minimal code for the action server to work properly. Before we write an action client, let’s switch to C++. If you only want to follow the Python explanations, then go ah<a id="_idTextAnchor360" class="pcalibre calibre4 pcalibre1"/>ead and skip the <span>next section.</span></p>
			<h2 id="_idParaDest-174" class="calibre6"><a id="_idTextAnchor361" class="pcalibre calibre4 pcalibre1"/>Writing a C++ action server</h2>
			<p class="calibre3">The code <a id="_idIndexMarker453" class="pcalibre calibre4 pcalibre1"/>logic for C++ actions is very similar to Python, but there are quite a few specificities about the syntax. We will focus mostly on those differences. Also, as the code starts to become quite large, I will not necessarily display the full code, only the important parts for comprehension. Make sure you take a look at this book’s GitHu<a id="_idTextAnchor362" class="pcalibre calibre4 pcalibre1"/>b repository to see the <span>full code.</span></p>
			<h3 class="calibre8">Importing the interface and creating the server</h3>
			<p class="calibre3">Let’s start <a id="_idIndexMarker454" class="pcalibre calibre4 pcalibre1"/>by setting up the action server. First, create a new file named <strong class="source-inline1">count_until_server_minimal.cpp</strong> in the <strong class="source-inline1">src</strong> directory of your <span><strong class="source-inline1">my_cpp_pkg</strong></span><span> package.</span></p>
			<p class="calibre3">Open the file and start by adding the <span>necessary includes:</span></p>
			<pre class="source-code">
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_action/rclcpp_action.hpp"
#include "my_robot_interfaces/action/count_until.hpp"</pre>			<p class="calibre3">As you can see, the action library is not a sub-library of <strong class="source-inline1">rclcpp</strong>—it’s a completely independent one from a different <span>package: </span><span><strong class="source-inline1">rclcpp_action</strong></span><span>.</span></p>
			<p class="calibre3">For each new package we use, we need to add the dependency to the <strong class="source-inline1">package.xml</strong> file of the <span><strong class="source-inline1">my_cpp_pkg</strong></span><span> package:</span></p>
			<pre class="source-code">
&lt;depend&gt;my_robot_interfaces&lt;/depend&gt;
&lt;depend&gt;rclcpp_action&lt;/depend&gt;</pre>			<p class="calibre3">You will also need to specify those dependencies in the <span><strong class="source-inline1">CMakeLists.txt</strong></span><span> file:</span></p>
			<pre class="source-code">
find_package(my_robot_interfaces REQUIRED)
find_package(rclcpp_action REQUIRED)</pre>			<p class="calibre3">Finally, when you create your executable, don’t forget to add both dependencies to the <span><strong class="source-inline1">ament_target_dependencies()</strong></span><span> function:</span></p>
			<pre class="source-code">
add_executable(count_until_server src/count_until_server_minimal.cpp)
ament_target_dependencies(count_until_server rclcpp rclcpp_action my_robot_interfaces)</pre>			<p class="calibre3">Back to the <strong class="source-inline1">count_until_server_minimal.cpp</strong> file, we add a few <strong class="source-inline1">using</strong> lines to simplify the code (you can find those lines at the top of the file, under the <strong class="source-inline1">#include</strong> lines). After that, you can add an action server to your class as a <span>private attribute:</span></p>
			<pre class="source-code">
rclcpp_action::Server&lt;CountUntil&gt;::SharedPtr count_until_server_;</pre>			<p class="calibre3">Once again, we’re going to use a shared pointer to keep <span>the object.</span></p>
			<p class="calibre3">Then, in the constructor, you can create the <span>action server:</span></p>
			<pre class="source-code">
count_until_server_ = rclcpp_action::create_server&lt;CountUntil&gt;(
    this,
    "count_until",
    std::bind(&amp;CountUntilServerNode::goalCallback, this, _1, _2),
    std::bind(&amp;CountUntilServerNode::cancelCallback, this, _1),
    std::bind(&amp;CountUntilServerNode::executeCallback, this, _1)
);</pre>			<p class="calibre3">For actions, the C++ syntax is stricter than Python. On top of the action interface, object to link to, and <a id="_idIndexMarker455" class="pcalibre calibre4 pcalibre1"/>action name, you have to provide three callbacks (even if you don’t want to use <span>them all):</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Goal callback</strong>: To accept or reject <span>incoming goals.</span></li>
				<li class="calibre10"><strong class="bold">Cancel callback</strong>: To receive <span>cancel requests.</span></li>
				<li class="calibre10"><strong class="bold">Execute callback</strong>: This is called the <em class="italic">handle accepted callback</em> in C++, but I named it <em class="italic">execute callback</em> to make the code similar to the Python one. In this callback, we execute goals that have <span>been accepted.</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">I’ve designed this chapter so that we write minimal code first, and then add the extra optional features. However, the C++ <strong class="source-inline">create_server()</strong> method will not work if you don’t provide a cancel callback. Thus, what we will do for now is add this callback but not fully implement the cancel mechanism; we’ll do <span>that later.</span></p>
			<p class="calibre3">At this point, we need to im<a id="_idTextAnchor363" class="pcalibre calibre4 pcalibre1"/>plement the three <span>callback methods.</span></p>
			<h3 class="calibre8">Implementing the callbacks</h3>
			<p class="calibre3">The arguments inside the callbacks can be quite long to write. That’s why I suggest simplifying the code with <strong class="source-inline1">using</strong> lines at the beginning, as well as double-checking everything as it’s easy to <span>make mistakes.</span></p>
			<p class="calibre3">Here’s <a id="_idIndexMarker456" class="pcalibre calibre4 pcalibre1"/>the beginning of the goal <span>callback method:</span></p>
			<pre class="source-code">
rclcpp_action::GoalResponse goalCallback(const rclcpp_action::GoalUUID &amp;uuid, std::shared_ptr&lt;const CountUntil::Goal&gt; goal)</pre>			<p class="calibre3">Here, you get a unique identifier for the goal and the goal itself (to be precise, this is a <strong class="source-inline1">const</strong> shared pointer to the goal). In the callback, we validate the goal and then accept or reject it. For example, to accept the goal, you would return <span>the following:</span></p>
			<pre class="source-code">
return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;</pre>			<p class="calibre3">The next callback method is the cancel callback, in which you can decide whether to accept or reject an incoming cancel request. As I will explain the cancel mechanism later in this chapter, I will skip this part now—you just have to write the callback so that the code <span>can compile.</span></p>
			<p class="calibre3">The most important callback here is the execute callback. In this method, we receive a goal handle (<strong class="source-inline1">const std::shared_ptr&lt;CountUntilGoalHandle&gt; goal_handle</strong>). The first thing we must do is extract the data from the goal and initialize a <span>few things:</span></p>
			<pre class="source-code">
int target_number = goal_handle-&gt;get_goal()-&gt;target_number;
double delay = goal_handle-&gt;get_goal()-&gt;delay;
auto result = std::make_shared&lt;CountUntil::Result&gt;();
int counter = 0;
rclcpp::Rate loop_rate(1.0/delay);</pre>			<p class="calibre3">You’ve probably started to get used to seeing shared pointers everywhere, and here is no exception. We don’t create a result object, but a shared pointer to a <span>result object.</span></p>
			<p class="calibre3">Then, to handle the waiting time between each count iteration, we use a <strong class="source-inline1">rclcpp::Rate</strong> object. This is a bit different from what we did with Python. In this rate object, we have to pass the rate—that is, the frequency we want for the loop. For example, if the delay is 0.5 seconds, the frequency would be 2.0 Hz. We can now execute <span>the action:</span></p>
			<pre class="source-code">
RCLCPP_INFO(this-&gt;get_logger(), "Executing the goal");
for (int i = 0; i &lt; target_number; i++) {
    counter++;
    RCLCPP_INFO(this-&gt;get_logger(), "%d", counter);
    loop_rate.sleep();
}</pre>			<p class="calibre3">Here, we use the <strong class="source-inline1">sleep()</strong> function of the rate object to pause <span>the execution.</span></p>
			<p class="calibre3">Finally, once the <strong class="source-inline1">for</strong> loop ends, we can finish <span>the execution:</span></p>
			<pre class="source-code">
result-&gt;reached_number = counter;
goal_handle-&gt;succeed(result);</pre>			<p class="calibre3">In Python, we would set the goal’s final state first, and then return the result. In C++, we don’t <a id="_idIndexMarker457" class="pcalibre calibre4 pcalibre1"/>return anything (note the <strong class="source-inline1">void</strong> return type). We send the result at the same time as setting the <span>goal state.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Writing C++ code with actions starts to be quite complex, especially if you don’t have much C++ experience. If you feel completely lost, maybe either continue with Python only or, as mentioned previously, skip this chapter for now and come back to <span>it later.</span></p>
			<p class="calibre3">That’s it for the C++ action server. We can now write the <a id="_idTextAnchor364" class="pcalibre calibre4 pcalibre1"/>client node and try <span>the communication.</span></p>
			<h1 id="_idParaDest-175" class="calibre6"><a id="_idTextAnchor365" class="pcalibre calibre4 pcalibre1"/>Writing an action client</h1>
			<p class="calibre3">We now have <a id="_idIndexMarker458" class="pcalibre calibre4 pcalibre1"/>the minimal code required for the server to receive a goal, accept it, execute it, and return a result. At this point, we can write the client side of <span>the communication.</span></p>
			<p class="calibre3">The action client will send a goal to the server. It will then register a callback to find out whether the goal was accepted or rejected. If the goal is accepted, the client will register yet another callback to get the final result. That’s what we’re going to implement now—first with Python, then <span>with C++.</span></p>
			<p class="calibre3">Where should you write the action client? In your own ROS 2 applications, you could add an action client to any node. As an example, let’s say you have a node that monitors the battery level of a mobile robot. This node could already have some publishers, subscribers, services, and so on. On top of all that, you can add an action client that will send a goal to <a id="_idIndexMarker459" class="pcalibre calibre4 pcalibre1"/>another node (such as the server node, which controls the wheels of the robot) when the battery <span>runs low.</span></p>
			<p class="calibre3">For this chapter, and to keep things simple, we will create a new node, just for the action client. You can then use this code as a template for adding an action client anywhere you want. You can find the code for this section in <strong class="source-inline1">count_until_client_minimal</strong> (<strong class="source-inline1">.py</strong> <span>or </span><span><strong class="source-inline1">.cpp</strong></span><span>).</span></p>
			<p class="calibre3">Le<a id="_idTextAnchor366" class="pcalibre calibre4 pcalibre1"/>t’s start with the Python <span>action client.</span></p>
			<h2 id="_idParaDest-176" class="calibre6"><a id="_idTextAnchor367" class="pcalibre calibre4 pcalibre1"/>Writing a Python action client</h2>
			<p class="calibre3">Create a <a id="_idIndexMarker460" class="pcalibre calibre4 pcalibre1"/>new Python file named <strong class="source-inline1">count_until_client_minimal.py</strong> in the <strong class="source-inline1">my_p<a id="_idTextAnchor368" class="pcalibre calibre4 pcalibre1"/>y_pkg</strong> package. Make this <span>file executable.</span></p>
			<h2 id="_idParaDest-177" class="calibre6"><a id="_idTextAnchor369" class="pcalibre calibre4 pcalibre1"/>Creating an action client</h2>
			<p class="calibre3">Let’s start <a id="_idIndexMarker461" class="pcalibre calibre4 pcalibre1"/>by setting up the action client. First, add the dependencies we <span>will need:</span></p>
			<pre class="source-code">
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle, GoalStatus
from my_robot_interfaces.action import CountUntil</pre>			<p class="calibre3">As for the action server, we don’t get the action client directly from the <strong class="source-inline1">Node</strong> class. Instead, we have to import <strong class="source-inline1">ActionClient</strong> <span>from </span><span><strong class="source-inline1">rclpy.action</strong></span><span>.</span></p>
			<p class="calibre3">We must also import the action interface, which should be the same as for the server. If we import this interface, we also need to add a dependency to the <strong class="source-inline1">package.xml</strong> file. However, we have already done that, so there’s no need to add <span>anything else.</span></p>
			<p class="calibre3">Then, in the node’s constructor, we create an <span>action client:</span></p>
			<pre class="source-code">
self.count_until_client_ = ActionClient(
self, CountUntil, "count_until")</pre>			<p class="calibre3">We use the <strong class="source-inline1">ActionClient</strong> class directly, and we pass three arguments: the object to bind to (<strong class="source-inline1">self</strong>), the action interface, and the action name. Double-check that the name is the same as on the <span>server side.</span></p>
			<p class="calibre3">Then, to send <a id="_idIndexMarker462" class="pcalibre calibre4 pcalibre1"/>a goal to the server, we add a <span>new method:</span></p>
			<pre class="source-code">
def send_goal(self, target_number, delay):
    self.count_until_client_.wait_for_server()
    goal = CountUntil.Goal()
    goal.target_number = target_number
    goal.delay = delay
    self.count_until_client_.send_goal_async(
        goal).add_done_callback(self.goal_response_callback)</pre>			<p class="calibre3">Here are the steps for sending a goal from the client to <span>the server:</span></p>
			<ol class="calibre11">
				<li class="calibre10">You can wait for the server with <strong class="source-inline">wait_for_server()</strong>. If you send a goal when the server isn’t up and running, you will get an error, so ensure it’s ready before you do anything. I didn’t provide a timeout here, so it will wait indefinitely. You could add a timeout and do something similar to what we did in <a href="B22403_06.xhtml#_idTextAnchor282" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 6</em></span></a>, in the <em class="italic">Writing a service </em><span><em class="italic">client</em></span><span> section.</span></li>
				<li class="calibre10">Create a goal object from the <span>interface: </span><span><strong class="source-inline">Interface.Goal()</strong></span><span>.</span></li>
				<li class="calibre10">Fill in the goal fields. Any field you omit will get a default value (<strong class="source-inline">0</strong> for numbers, <strong class="source-inline">""</strong> <span>for strings).</span></li>
				<li class="calibre10">Send the goal with <strong class="source-inline">send_goal_async()</strong>. This will return a Python <span><strong class="source-inline">Future</strong></span><span> object.</span></li>
				<li class="calibre10">Register a callback for the goal’s response so that you know it’s been accepted <span>or rejected.</span></li>
			</ol>
			<p class="calibre3">Note that <a id="_idIndexMarker463" class="pcalibre calibre4 pcalibre1"/>just as for services, we make an asynchronous call with <strong class="source-inline1">send_goal_async()</strong>. This way, the method will return and we won’t block the execution. If we were to block the execution, we would also block the spi<a id="_idTextAnchor370" class="pcalibre calibre4 pcalibre1"/>n, and thus we would never get <span>any response.</span></p>
			<h3 class="calibre8">Implementing the callbacks</h3>
			<p class="calibre3">So far, we’ve <a id="_idIndexMarker464" class="pcalibre calibre4 pcalibre1"/>sent a goal with the action client and registered a callback, <strong class="source-inline1">goal_response_callback()</strong>. Let’s implement <span>this method:</span></p>
			<pre class="source-code">
def goal_response_callback(self, future):
    self.goal_handle_: ClientGoalHandle = future.result()
    if self.goal_handle_.accepted:
        self.get_logger().info("Goal got accepted")
        self.goal_handle_.get_result_async().add_done_callback(
            self.goal_result_callback)
    else:
        self.get_logger().info("Goal got rejected")</pre>			<p class="calibre3">In this callback, we get a <strong class="source-inline1">ClientGoalHandle</strong> object from the result of the Python <strong class="source-inline1">Future</strong> object. From this goal handle, we can find out whether the goal was accepted <span>or not.</span></p>
			<p class="calibre3">Please note that you won’t get the final result in this goal response callback. Here, we only get to know whether the server accepted the goal or not. If the goal is accepted, we know that the server will start executing it and return a result at <span>some point.</span></p>
			<p class="calibre3">Then, in the client, we can register another callback for the <span>goal result:</span></p>
			<pre class="source-code">
def goal_result_callback(self, future):
    status = future.result().status
    result = future.result().result
    if status == GoalStatus.STATUS_SUCCEEDED:
        self.get_logger().info("Success")
    elif status == GoalStatus.STATUS_ABORTED:
        self.get_logger().error("Aborted")
    elif status == GoalStatus.STATUS_CANCELED:
        self.get_logger().warn("Canceled")
    self.get_logger().info("Result: " + str(result.reached_number))</pre>			<p class="calibre3">In this callback, we get the goal’s final state and result after the server has finished executing <span>the goal.</span></p>
			<p class="calibre3">You can <a id="_idIndexMarker465" class="pcalibre calibre4 pcalibre1"/>do anything you want with this result—here, we simply print it. As you can see, we will receive any of those three final states for the goal: <strong class="source-inline1">STATUS_SUCCEEDED</strong>, <strong class="source-inline1">STATUS_ABORTED</strong>, <span>and </span><span><strong class="source-inline1">STATUS_CANCELED</strong></span><span>.</span></p>
			<p class="calibre3">Finally, let’s not forget to call the <strong class="source-inline1">send_goal()</strong> method. We will do this in the <strong class="source-inline1">main()</strong> function, just after we initialize the node, and before we make the <span>node spin:</span></p>
			<pre class="source-code">
node = CountUntilClientNode()
node.send_goal(5, 0.5)
rclpy.spin(node)</pre>			<p class="calibre3">This will ask the server to count un<a id="_idTextAnchor371" class="pcalibre calibre4 pcalibre1"/>til <strong class="source-inline1">5</strong> and wait <strong class="source-inline1">0.5</strong> seconds between <span>each count.</span></p>
			<h3 class="calibre8">Trying the communication</h3>
			<p class="calibre3">We can now try the communication between the client <span>and server.</span></p>
			<p class="calibre3">Create an executable (in <strong class="source-inline1">setup.py</strong>) for both the client and server nodes. Build the package and source <span>the environment.</span></p>
			<p class="calibre3">Then, start the <a id="_idIndexMarker466" class="pcalibre calibre4 pcalibre1"/>server node and the client node in two different Terminals. You should see some logs in both Terminals as the communication progresses. In the end, you will get something like this for <span>the server:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg count_until_server
[count_until_server]: Action server has been started.
[count_until_server]: Received a goal
[count_until_server]: Accepting the goal
[count_until_server]: Executing the goal
[count_until_server]: 1
...
[count_until_server]: 5</pre>			<p class="calibre3">For <span>the client:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg count_until_client
[count_until_client]: Goal got accepted
[count_until_client]: Success
[count_until_client]: Result: 5</pre>			<p class="calibre3">You can see the flow of execution with the timestamp in each log. Here, we tested the case when the target number was positive—and thus, the goal was accepted. If you want, you can also test the case when the target number is negative; you should see the goal being rejected and <span>not executed.</span></p>
			<p class="calibre3">Now, let’<a id="_idTextAnchor372" class="pcalibre calibre4 pcalibre1"/>s learn how to write an action client <span>with C++.</span></p>
			<h2 id="_idParaDest-178" class="calibre6"><a id="_idTextAnchor373" class="pcalibre calibre4 pcalibre1"/>Writing a C++ action client</h2>
			<p class="calibre3">For the C++ code, I will focus on the few important points to notice in the <span><strong class="source-inline1">count_until_client_minimal.cpp</strong></span><span> file.</span></p>
			<p class="calibre3">First, we have <a id="_idIndexMarker467" class="pcalibre calibre4 pcalibre1"/>all the includes and <strong class="source-inline1">using</strong> lines. Those are almost the same as for the C++ action server. However, for the goal handle, we get <strong class="source-inline1">ClientGoalHandle</strong> (this was <strong class="source-inline1">ServerGoalHandle</strong> in the <span>server code):</span></p>
			<pre class="source-code">
using CountUntilGoalHandle = rclcpp_action::<strong class="bold1">ClientGoalHandle</strong>&lt;CountUntil&gt;;</pre>			<p class="calibre3">To create an action client, we declare the client as a private attribute of <span>the class:</span></p>
			<pre class="source-code">
rclcpp_action::Client&lt;CountUntil&gt;::SharedPtr count_until_client_;</pre>			<p class="calibre3">Then, we initialize the client in <span>the constructor:</span></p>
			<pre class="source-code">
count_until_client_ = rclcpp_action::create_client&lt;CountUntil&gt;(this, "count_until");</pre>			<p class="calibre3">As you can see (but that shouldn’t be a surprise anymore), we store a shared pointer to the action client. When initializing it, we provide the action interface, the object to bind to (<strong class="source-inline1">this</strong>), and the action name, which should be the same as the one defined in the <span>server code.</span></p>
			<p class="calibre3">At this point, we can create a <strong class="source-inline1">sendGoal()</strong> method to send a goal to the server. This method follows the same steps as for the Python client. We wait for the server, then create a goal, fill in the goal fields, send the goal, and register a callback. However, there is a big difference in how we handle <span>the callbacks:</span></p>
			<pre class="source-code">
auto options = rclcpp_action::Client&lt;CountUntil&gt;::SendGoalOptions();
options.goal_response_callback = std::bind(
    &amp;CountUntilClientNode::goalResponseCallback, this, _1);
options.result_callback = std::bind(
    &amp;CountUntilClientNode::goalResultCallback, this, _1);
count_until_client_-&gt;async_send_goal(goal, options);</pre>			<p class="calibre3">In Python, we would chain the callbacks after sending the goal. In C++, you first need to create a <strong class="source-inline1">SendGoalOptions</strong> object. In this object, you can register the different callback methods for your client. Here, we register the response and the result callback. Then, you must pass this object to the <strong class="source-inline1">async_send_goal()</strong> method. This will register all the callbacks for when the node <span>is spinning.</span></p>
			<p class="calibre3">Now that we’ve registered two callbacks, we need to <span>implement them.</span></p>
			<p class="calibre3">In the goal <a id="_idIndexMarker468" class="pcalibre calibre4 pcalibre1"/>response callback, to check if the goal was accepted or rejected, we can simply write <span>the following:</span></p>
			<pre class="source-code">
if (!goal_handle) {</pre>			<p class="calibre3">If this returns <strong class="source-inline1">false</strong>, we know the goal was rejected. If it returns <strong class="source-inline1">true</strong>, there’s no need to do anything else in this callback as the result callback was already registered with the <span><strong class="source-inline1">SendGoalOptions</strong></span><span> object.</span></p>
			<p class="calibre3">In the result callback, we get the goal’s final state with <strong class="source-inline1">result.code</strong>. We can then compare it with the different codes in <strong class="source-inline1">rclcpp_action::ResultCode</strong>, which are <strong class="source-inline1">SUCCEEDED</strong>, <strong class="source-inline1">ABORTED</strong>, and <strong class="source-inline1">CANCELED</strong>. To get access to the actual result, we write <strong class="source-inline1">result.result</strong>. This will be a shared pointer to the <span>result object.</span></p>
			<p class="calibre3">Finally, let’s not forget to call the <strong class="source-inline1">sendGoal()</strong> method in the <span><strong class="source-inline1">main()</strong></span><span> function:</span></p>
			<pre class="source-code">
auto node = std::make_shared&lt;CountUntilClientNode&gt;();
node-&gt;sendGoal(5, 0.5);
rclcpp::spin(node);</pre>			<p class="calibre3">That’s about it for the C++ action client. After writing both the client and server, create an executable for both (in <strong class="source-inline1">CMakeLists.txt</strong>); then, build, source, and run the two nodes. You can even try running the Python client with the C++ server, or any <span>other combination.</span></p>
			<p class="calibre3">Now that both the client and server are running correctly, we can add the extra function<a id="_idTextAnchor374" class="pcalibre calibre4 pcalibre1"/>alities we get with actions: feedback <span>and cancel.</span></p>
			<h1 id="_idParaDest-179" class="calibre6"><a id="_idTextAnchor375" class="pcalibre calibre4 pcalibre1"/>Taking advantage of all the action mechanisms</h1>
			<p class="calibre3">The reason <a id="_idIndexMarker469" class="pcalibre calibre4 pcalibre1"/>I’m talking about feedback and cancel mechanisms now and didn’t previously is to try not to overwhelm you with too much code at once. I know that actions are more complex than everything you’ve seen before with ROS 2. The minimal code alone is already quite long and contains lots of small details you must pay <span>attention to.</span></p>
			<p class="calibre3">Also, as explained in the first part of this chapter, the feedback and cancel mechanisms are optional. You can create a fully working client/server communication <span>without them.</span></p>
			<p class="calibre3">We’re now going to improve the minimal code and add a few more functionalities so that we can take full advantage of ROS 2 actions. Here’s what you can do to prepare the files for <span>this section:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Make a copy of the files <span>containing </span><span><strong class="source-inline">_minimal</strong></span><span>.</span></li>
				<li class="calibre10">Rename those new files by removing <span>the </span><span><strong class="source-inline">_minimal</strong></span><span>.</span></li>
			</ol>
			<p class="calibre3">For example, you can <a id="_idIndexMarker470" class="pcalibre calibre4 pcalibre1"/>make a copy of <strong class="source-inline1">count_until_client_minimal.py</strong> (we won’t modify this file anymore) and rename the copy <strong class="source-inline1">count_until_client.py</strong> (this is where we will add more code). You can find the same organization in this book’s <span>GitHub repository.</span></p>
			<p class="calibre3">So, let’s explore the feedback and cancel mechanisms<a id="_idTextAnchor376" class="pcalibre calibre4 pcalibre1"/>, starting with feedback, which is the <span>easiest one.</span></p>
			<h2 id="_idParaDest-180" class="calibre6"><a id="_idTextAnchor377" class="pcalibre calibre4 pcalibre1"/>Adding the feedback mechanism</h2>
			<p class="calibre3">When we <a id="_idIndexMarker471" class="pcalibre calibre4 pcalibre1"/>wrote the action interface, we had to define three things: goal, result, and feedback. So far, we’ve only used the goal and result. The feedback is optional, and you could choose to leave it empty in the action definition. In this case, there’s nothing else <span>to do.</span></p>
			<p class="calibre3">Since we’ve defined feedback in <strong class="source-inline1">CountUntil.action</strong> (<strong class="source-inline1">int64 current_number</strong>), let’s use it in our code so that we can make the server send feedback every time it increases the counter. The action client will<a id="_idTextAnchor378" class="pcalibre calibre4 pcalibre1"/> be able to receive this feedback inside <span>a callback.</span></p>
			<h3 class="calibre8">Feedback with Python</h3>
			<p class="calibre3">Let’s start <a id="_idIndexMarker472" class="pcalibre calibre4 pcalibre1"/>with the action server. There are just a few lines to add so that we can publish <span>the feedback.</span></p>
			<p class="calibre3">Open <strong class="source-inline1">count_until_server.py</strong>. In the <strong class="source-inline1">execute_callback()</strong> method, at the same time as creating a result object, create a <span>feedback object:</span></p>
			<pre class="source-code">
feedback = CountUntil.Feedback()</pre>			<p class="calibre3">Now, when you execute the goal, you have to do <span>the following:</span></p>
			<pre class="source-code">
feedback.current_number = counter
goal_handle.publish_feedback(feedback)</pre>			<p class="calibre3">We must fill in the different fields of the feedback object and then send the feedback to the client with the <strong class="source-inline1">publish_feedback()</strong> method from the <span>goal handle.</span></p>
			<p class="calibre3">That’s all <a id="_idIndexMarker473" class="pcalibre calibre4 pcalibre1"/>there is to it for the server side. Now, let’s write the code to receive <span>the feedback.</span></p>
			<p class="calibre3">Open the <strong class="source-inline1">count_until_client.py</strong> file and modify the line where you send the goal <span>with </span><span><strong class="source-inline1">send_goal_async()</strong></span><span>:</span></p>
			<pre class="source-code">
self.count_until_client_.send_goal_async(
    goal, <strong class="bold1">feedback_callback=self.goal_feedback_callback</strong>). \
    add_done_callback(self.goal_response_callback)</pre>			<p class="calibre3">To get the feedback with a Python action client, you must register a callback function when you send the goal. Here’s the implementation for <span>this callback:</span></p>
			<pre class="source-code">
def goal_feedback_callback(self, feedback_msg):
   number = feedback_msg.feedback.current_number
   self.get_logger().info("Got feedback: " + str(number))</pre>			<p class="calibre3">With this, we get a feedback message and can access each field of that message. You can do anything you want with this feedback. For example, if your action client is asking for a robot to move to certain (x, y) coordinates, you might receive feedback on the current progress of the robot. From this, you could take any appropriate measure: cancel the goal (see the next section), send a new goal, and <span>so on.</span></p>
			<p class="calibre3">That’s it regarding feedback. You can build your package again, source it, and run the two nodes. Here’s what you will see on the <span>client side:</span></p>
			<pre class="console">
$ ros2 run my_py_pkg count_until_client
[count_until_client]: Goal got accepted
[count_until_client]: Got feedback: 1</pre>			<p class="calibre3">It will continue <span>as follows:</span></p>
			<pre class="console">
[count_until_client]: Got feedback: 5
[count_until_client]: Success
[count_until_client]: Result: 5</pre>			<p class="calibre3">With this <a id="_idIndexMarker474" class="pcalibre calibre4 pcalibre1"/>feedback, the client isn’t in the dark anymore. It can get to know what’s happe<a id="_idTextAnchor379" class="pcalibre calibre4 pcalibre1"/>ning between sending the goal and receiving <span>the result.</span></p>
			<h3 class="calibre8">Feedback with C++</h3>
			<p class="calibre3">The behavior for adding the feedback for the action server in <strong class="source-inline1">count_until_server.cpp</strong> is the same as it is <span>for Python.</span></p>
			<p class="calibre3">First, you <a id="_idIndexMarker475" class="pcalibre calibre4 pcalibre1"/>must create a feedback object in the <span>execute callback:</span></p>
			<pre class="source-code">
auto result = std::make_shared&lt;CountUntil::Result&gt;();</pre>			<p class="calibre3">The only difference is that we use a shared <span>pointer here.</span></p>
			<p class="calibre3">Then, you must publish <span>the feedback:</span></p>
			<pre class="source-code">
feedback-&gt;current_number = counter;
goal_handle-&gt;publish_feedback(feedback);</pre>			<p class="calibre3">On the client side, the way a callback is registered is a bit different. Open <strong class="source-inline1">count_until_client.cpp</strong> and add the following line to the <span><strong class="source-inline1">sendGoal()</strong></span><span> method:</span></p>
			<pre class="source-code">
options.feedback_callback = std::bind(
    &amp;CountUntilClientNode::goalFeedbackCallback, this, _1, _2);</pre>			<p class="calibre3">For a C++ action, we register all callbacks in the <strong class="source-inline1">SendGoalOptions</strong> object that we pass to the <span><strong class="source-inline1">async_send_goal()</strong></span><span> method.</span></p>
			<p class="calibre3">Then, you can implement <span>the callback:</span></p>
			<pre class="source-code">
void goalFeedbackCallback(const CountUntilGoalHandle::SharedPtr &amp;goal_handle, const std::shared_ptr&lt;const CountUntil::Feedback&gt; feedback)
{
   (void)goal_handle;
   int number = feedback-&gt;current_number;
   RCLCPP_INFO(this-&gt;get_logger(), "Got feedback: %d", number);
}</pre>			<p class="calibre3">Here, we receive <a id="_idIndexMarker476" class="pcalibre calibre4 pcalibre1"/>both the goal handle and the feedback (as <strong class="source-inline1">const</strong> <span>shared pointers).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">As you can see, whenever there’s an argument we don’t use in a function, I write <strong class="source-inline">(void)</strong>, followed by <a id="_idIndexMarker477" class="pcalibre calibre4 pcalibre1"/>the argument. This is a way to prevent getting <em class="italic">unused parameter</em> warnings when compiling with <strong class="source-inline">colcon build</strong>. As a best practice, you should address all errors and warnings in your code when developing a ROS 2 application. If you don’t do this, you will end up with lots of ignored warnings, and you could miss the important ones, leading to hard-to-debug issues in <span>the future.</span></p>
			<p class="calibre3">Now that the code is complete, you can compile the package and run the client and server nodes in two different Terminals. You should see a similar output to what we had <span>for Python.</span></p>
			<p class="calibre3">Implementing the feedback mechanism is relatively easy. Now, let’s learn how to cancel a goal. This will be more co<a id="_idTextAnchor380" class="pcalibre calibre4 pcalibre1"/>mplex and require the use of more advanced ROS <span>2 concepts.</span></p>
			<h2 id="_idParaDest-181" class="calibre6"><a id="_idTextAnchor381" class="pcalibre calibre4 pcalibre1"/>Adding the cancel mechanism</h2>
			<p class="calibre3">After sending <a id="_idIndexMarker478" class="pcalibre calibre4 pcalibre1"/>a goal, the client can decide to ask the server to cancel it. The server will receive this request and accept (or not) to cancel the goal. If the cancel request is accepted, the server will take any appropriate action to cancel the execution of the goal. In the end, the server will still send a result to <span>the client.</span></p>
			<p class="calibre3">What do we need to do in the code? In the server node, we will add another callback so that we can receive cancel requests and decide to accept or reject them. Then, in the execute callback, we will be able to check whether the goal should be canceled; if so, we will terminate the <span>execution sooner.</span></p>
			<p class="calibre3">However, if we <a id="_idIndexMarker479" class="pcalibre calibre4 pcalibre1"/>just do this, it’s not going to work and the cancel requests will never be received. Why is that? Let’s explore this <span>question now.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This section introduces a few concepts that are outside the scope of this (beginner) book. I will talk about them briefly without going into full detail. If you’d like to understand these in more depth, feel free to explore the advanced concepts by yourself (you will find additional resources in <a href="B22403_14.xhtml#_idTextAnchor665" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 14</em></span></a><em class="italic">).</em> You can see this section as a going further with <span>actions section.</span></p>
			<h3 class="calibre8">Understanding the problem with cancel and spin</h3>
			<p class="calibre3">We will only focus on the server side here as this is where the issue will occur. I will explain <a id="_idIndexMarker480" class="pcalibre calibre4 pcalibre1"/>what the issue is so that we can implement the <span>solution later.</span></p>
			<p class="calibre3">So, when you start the action server, three callbacks will be registered: a goal callback, a cancel callback, and an <span>execute callback.</span></p>
			<p class="calibre3">With our current code, when the server receives a goal, here’s <span>what happens:</span></p>
			<ol class="calibre11">
				<li class="calibre10">The goal is received by the goal callback and is accepted <span>or rejected.</span></li>
				<li class="calibre10">If accepted, we execute the goal in the execute callback. Something crucial to note is that while we execute the goal with the <strong class="source-inline">for</strong> loop, the thread <span>is blocked.</span></li>
				<li class="calibre10">Once the goal is executed, we return the result and exit from the <span>execute callback.</span></li>
			</ol>
			<p class="calibre3">The problem is with <em class="italic">Step 2</em>. Since we’re blocking the execution, we’re blocking the <span>spin mechanism.</span></p>
			<p class="calibre3">When you make a node spin, what’s happening? As mentioned previously, the node will be kept alive and all callbacks can be processed. However, the spin is working in a single thread. This means that if you have one callback taking 5 seconds to execute, it will block the following callbacks for <span>5 seconds.</span></p>
			<p class="calibre3">We never had any issues before because all the callbacks we wrote were very quick to execute. However, with the execute callback for an action, we’re in a situation where the execution could take quite some time, and thus block all the <span>other callbacks.</span></p>
			<p class="calibre3">That’s quite <a id="_idIndexMarker481" class="pcalibre calibre4 pcalibre1"/>the problem. How can you ask to cancel a goal if the cancel request is only received after the goal’s execution <span>has finished?</span></p>
			<p class="calibre3">To solve this problem, we have two <span>possible solutions:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">The classic programming way</strong>: We could create a new thread in the execute callback. The callback can then exit while the goal is processed in the background. The spin continues, and thus, other callbacks can <span>be called.</span></li>
				<li class="calibre10"><strong class="bold">The ROS 2 way</strong>: We can use a multi-threaded executor, which means that our spin mechanism will work not in a single thread, but in multiple threads. Thus, if one callback is blocking, you can still execute other callbacks—including the <span>cancel callback.</span></li>
			</ul>
			<p class="calibre3">Since we want to follow ROS 2 principles to stay consistent with other developers, we’re going to follow the ROS 2 way and solve that issue with a <span>multi-threaded executor.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">I’m not going to go into more detail about single and multi-threaded executors here. I’m using them now so that we can implement the cancel mechanism correctly. Executors can be a great topic to explore after reading <span>this book.</span></p>
			<p class="calibre3">The process for the cancel mechanism in the server code will be the same for Python <span>and C++:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Register a callback to handle <span>cancel requests.</span></li>
				<li class="calibre10">Cancel the goal in the <span>execut<a id="_idTextAnchor382" class="pcalibre calibre4 pcalibre1"/>e callback.</span></li>
				<li class="calibre10">Make the node spin with a <span>multi-threaded executor.</span></li>
			</ol>
			<h3 class="calibre8">Canceling with Python</h3>
			<p class="calibre3">We will <a id="_idIndexMarker482" class="pcalibre calibre4 pcalibre1"/>start with the server code, which can be found <span>in </span><span><strong class="source-inline1">count_until_server.py</strong></span><span>.</span></p>
			<p class="calibre3">First, let’s register a callback to receive <span>cancel requests:</span></p>
			<pre class="source-code">
ActionServer(
    …
    cancel_callback=self.cancel_callback,
    …)</pre>			<p class="calibre3">Here’s the <span>callback’s implementation:</span></p>
			<pre class="source-code">
def cancel_callback(self, goal_handle: ServerGoalHandle):
    self.get_logger().info("Received a cancel request")
    return CancelResponse.ACCEPT</pre>			<p class="calibre3">In this callback, you receive a goal handle corresponding to the goal the client wants to cancel. You can then create any kind of condition to decide whether the goal should be canceled or not. To accept, you must return <strong class="source-inline1">CancelResponse.ACCEPT</strong>; to reject, you must return <strong class="source-inline1">CancelResponse.REJECT</strong>. With this example, I kept things simple and we just accepted the cancel request without implementing any <span>other checks.</span></p>
			<p class="calibre3">Now, if the cancel request has been accepted, we need to do something about it. In the execute callback, while we’re executing the goal (inside the <strong class="source-inline1">for</strong> loop), add the <span>following code:</span></p>
			<pre class="source-code">
if goal_handle.is_cancel_requested:
    self.get_logger().info("Canceling goal")
    goal_handle.canceled()
    result.reached_number = counter
    return result</pre>			<p class="calibre3">When we accept a cancel request, an <strong class="source-inline1">is_cancel_requested</strong> flag in the goal handle will be set to <strong class="source-inline1">True</strong>. Now, in the execute callback, we simply need to check <span>this flag.</span></p>
			<p class="calibre3">What we do in the code is stop the current execution. If, for example, your action server controls the wheels of a robot, you could interpret <strong class="source-inline1">cancel</strong> as “decelerate and stop moving,” “step on the side so we don’t block the main way,” or even “go back to base.” The way you handle the behavior for the cancellation depends on each application. Here, we just <span>stop counting.</span></p>
			<p class="calibre3">In the execute callback, you need to set the goal’s final state and return a result, even if you cancel the goal. Thus, we use the <strong class="source-inline1">canceled()</strong> method to set the state, and we return a result that contains the last reached number. If the client asks the server to count to 10 and then cancels the goal when the counter is at 7, the result will <span>contain 7.</span></p>
			<p class="calibre3">That’s it for <a id="_idIndexMarker483" class="pcalibre calibre4 pcalibre1"/>the cancel mechanism. However, to make things work, as we’ve seen previously, we need to use a <span>multi-threaded executor.</span></p>
			<p class="calibre3">First, you’ll need to import <span>the following:</span></p>
			<pre class="source-code">
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import ReentrantCallbackGroup</pre>			<p class="calibre3">When using multi-threaded executors, we also need to use <em class="italic">callback groups</em>. Here, <strong class="source-inline1">ReentrantCallbackGroup</strong> will allow all callbacks to be executed in parallel. This means that you can have several goal, cancel, and execute callbacks running at the same time for one <span>action server.</span></p>
			<p class="calibre3">When you create the action server, add a <span><strong class="source-inline1">callback_group</strong></span><span> argument:</span></p>
			<pre class="source-code">
ActionServer(
    …
    callback_group=ReentrantCallbackGroup())</pre>			<p class="calibre3">Finally, modify the line to make the node spin in the <span><strong class="source-inline1">main()</strong></span><span> function:</span></p>
			<pre class="source-code">
rclpy.spin(node, MultiThreadedExecutor())</pre>			<p class="calibre3">That’s all there is to it. It’s just a few lines of code, but adding this requires a good understanding of ROS 2 and its <span>underlying mechanisms.</span></p>
			<p class="calibre3">Let’s write the code for the client so that we can send a cancel request for a goal that’s being executed. In <strong class="source-inline1">count_until_client.py</strong>, add a method to cancel <span>a goal:</span></p>
			<pre class="source-code">
def cancel_goal(self):
   self.get_logger().info("Send a cancel goal request")
   self.goal_handle_.cancel_goal_async()</pre>			<p class="calibre3">Here, we’re using the goal handle that we saved in the goal response callback (<strong class="source-inline1">self.goal_handle_: ClientGoalHandle = future.result()</strong>). From this goal handle object, we have access to a <span><strong class="source-inline1">cancel_goal_async()</strong></span><span> method.</span></p>
			<p class="calibre3">So, where do we cancel the goal? This can be done from anywhere: from the feedback callback, an independent subscriber callback, and so on. It will depend on <span>your application.</span></p>
			<p class="calibre3">To make a <a id="_idIndexMarker484" class="pcalibre calibre4 pcalibre1"/>quick test, let’s arbitrarily decide that we want to cancel the goal if the <strong class="source-inline1">current_number</strong> field from the feedback is greater than or equal to 2. It doesn’t make any sense (why would we ask to count until 5, only to cancel if the number reaches 2?), but it’s a quick way to test the <span>cancel mechanism.</span></p>
			<p class="calibre3">In the goal feedback callback, add the <span>following code:</span></p>
			<pre class="source-code">
if number &gt;= 2:
    self.cancel_goal()</pre>			<p class="calibre3">Then, build the package, source it, and run both the server and client. Here’s the log for <span>the client:</span></p>
			<pre class="console">
[count_until_client]: Goal got accepted
[count_until_client]: Got feedback: 1
[count_until_client]: Got feedback: 2
[count_until_client]: Send a cancel goal request
[count_until_client]: Canceled
[count_until_client]: Result: 2</pre>			<p class="calibre3">For the server, you will <span>see this:</span></p>
			<pre class="console">
[count_until_server]: Executing the goal
[count_until_server]: 1
[count_until_server]: 2
[count_until_server]: Received a cancel request
[count_until_server]: Canceling goal</pre>			<p class="calibre3">With this, we used all the mechanisms available for actions. Now, you can comment the lines to cancel the goal <a id="_idTextAnchor383" class="pcalibre calibre4 pcalibre1"/>from the feedback callback—this was just for <span>testing purposes.</span></p>
			<h3 class="calibre8">Canceling with C++</h3>
			<p class="calibre3">In the server code (<strong class="source-inline1">count_until_server.cpp</strong>), we added a cancel callback when we created <a id="_idIndexMarker485" class="pcalibre calibre4 pcalibre1"/>the action server. This was mandatory so that the code <span>could compile.</span></p>
			<p class="calibre3">In this callback, we just accept the <span>cancel request:</span></p>
			<pre class="source-code">
return rclcpp_action::CancelResponse::ACCEPT;</pre>			<p class="calibre3">Then, to handle the cancellation of the goal in the execute callback, add the following code to the <span><strong class="source-inline1">for</strong></span><span> loop:</span></p>
			<pre class="source-code">
if (goal_handle-&gt;is_canceling()) {
    RCLCPP_INFO(this-&gt;get_logger(), "Canceling goal");
    result-&gt;reached_number = counter;
    goal_handle-&gt;canceled(result);
    return;
}</pre>			<p class="calibre3">In C++, we check the <strong class="source-inline1">is_canceling()</strong> method inside the goal handle. If it returns <strong class="source-inline1">true</strong>, this means that a cancel request for this goal has been accepted, and we need to do something <span>about it.</span></p>
			<p class="calibre3">We set the goal’s final state and result with <strong class="source-inline1">canceled()</strong>, and we exit from the <span>execute callback.</span></p>
			<p class="calibre3">That’s it for the cancel mechanism, but now we need to make the node spin with a <span>multi-threaded executor.</span></p>
			<p class="calibre3">In the <strong class="source-inline1">main()</strong> function, we must replace the <strong class="source-inline1">rclcpp::spin(node);</strong> line with the <span>following code:</span></p>
			<pre class="source-code">
rclcpp::executors::MultiThreadedExecutor executor;
executor.add_node(node);
executor.spin();</pre>			<p class="calibre3">Here, we create an executor, add the node, and make the executor spin. Then, as we did for Python, inside the node, we need to add a callback group. We can declare one as a <span>private attribute:</span></p>
			<pre class="source-code">
rclcpp::CallbackGroup::SharedPtr cb_group_;</pre>			<p class="calibre3">Finally, we modify the code in the node’s constructor to give a reentrant callback group to the <a id="_idIndexMarker486" class="pcalibre calibre4 pcalibre1"/>action server, so that all callbacks can be executed <span>in parallel:</span></p>
			<pre class="source-code">
cb_group_ = this-&gt;create_callback_group(
    rclcpp::CallbackGroupType::Reentrant);
count_until_server_ = rclcpp_action::create_server&lt;CountUntil&gt;(
    …
    rcl_action_server_get_default_options(),
    cb_group_
);</pre>			<p class="calibre3">We also need to add <strong class="source-inline1">rcl_action_server_get_default_options()</strong> after the callbacks and before the callback group; otherwise, the compiler will complain about not finding an overload for the <span><strong class="source-inline1">create_server()</strong></span><span> function.</span></p>
			<p class="calibre3">Now that we’ve finished writing the server code, let’s send a cancel request from the client. In <strong class="source-inline1">count_until_client.cpp</strong>, add a <span><strong class="source-inline1">cancelGoal()</strong></span><span> method:</span></p>
			<pre class="source-code">
void cancelGoal()
{
    RCLCPP_INFO(this-&gt;get_logger(), "Send a cancel goal request");
    count_until_client_-&gt;async_cancel_all_goals();
}</pre>			<p class="calibre3">In C++, we cancel goals from the action client, not from the goal handle. To make things simpler here, we’re canceling all goals that could have been sent by <span>this client.</span></p>
			<p class="calibre3">To test the cancel mechanism, we add those lines to the <span>feedback callback:</span></p>
			<pre class="source-code">
if (number &gt;= 2) {
    cancelGoal();
}</pre>			<p class="calibre3">Once you’ve completed the code, run your C++ action client and server nodes. You can also try <a id="_idIndexMarker487" class="pcalibre calibre4 pcalibre1"/>any combination of Python and C++ nodes; they should behave the same way. Once you’ve tested your code, comment the lines to cancel the goal from the <span>feedback callback.</span></p>
			<p class="calibre3">Let’s finish this chapter with a few more command-line tools <a id="_idTextAnchor384" class="pcalibre calibre4 pcalibre1"/>that will help you when you’re developing applications <span>with actions.</span></p>
			<h1 id="_idParaDest-182" class="calibre6"><a id="_idTextAnchor385" class="pcalibre calibre4 pcalibre1"/>Additional tools to handle actions</h1>
			<p class="calibre3">Since actions are part of the core ROS 2 functionalities, they also get their own command-line tool: <span><strong class="source-inline1">ros2 action</strong></span><span>.</span></p>
			<p class="calibre3">In this section, we’ll learn how to introspect actions, send a goal from the Terminal, and change an action nam<a id="_idTextAnchor386" class="pcalibre calibre4 pcalibre1"/>e <span>at runtime.</span></p>
			<p class="calibre3">To see all the possible commands, type <strong class="source-inline1">ros2 </strong><span><strong class="source-inline1">action -h</strong></span><span>.</span></p>
			<h2 id="_idParaDest-183" class="calibre6"><a id="_idTextAnchor387" class="pcalibre calibre4 pcalibre1"/>Listing and introspecting actions</h2>
			<p class="calibre3">Actions are based on topics and services. Since <strong class="source-inline1">rqt_graph</strong> doesn’t support services (for now), we could <a id="_idIndexMarker488" class="pcalibre calibre4 pcalibre1"/>see the topics for an action server and client, but that’s <a id="_idIndexMarker489" class="pcalibre calibre4 pcalibre1"/>about it. Thus, <strong class="source-inline1">rqt_graph</strong> won’t be very useful for introspecting actions. Because of this, we will use the <strong class="source-inline1">ros2</strong> command-line <span>tool here.</span></p>
			<p class="calibre3">Let’s learn how to find existing actions and how to get the interface for <span>one action.</span></p>
			<p class="calibre3">Stop all nodes and start the <strong class="source-inline1">count_until_server</strong> node (Python or C++ one). Then, list all available actions by running the <span>following command:</span></p>
			<pre class="console">
$ ros2 action list
/count_until</pre>			<p class="calibre3">Here, we found the <strong class="source-inline1">/count_until</strong> action. As we’ve seen with topics and services, if you don’t provide any namespace for the name (we wrote <strong class="source-inline1">count_until</strong> in the server code), a leading slash will be <span>added automatically.</span></p>
			<p class="calibre3">From this action name, we can get more information, including the <span>action interface.</span></p>
			<p class="calibre3">Run <strong class="source-inline1">ros2 action info &lt;</strong><span><strong class="source-inline1">action_name&gt; -t</strong></span><span>:</span></p>
			<pre class="console">
$ ros2 action info /count_until -t
Action: /count_until
Action clients: 0
Action servers: 1
/count_until_server [my_robot_interfaces/action/CountUntil]</pre>			<p class="calibre3">From this, we can <a id="_idIndexMarker490" class="pcalibre calibre4 pcalibre1"/>see that the action server is hosted in the <strong class="source-inline1">count_until_server</strong> node, and we also find the action interface. For <strong class="source-inline1">ros2 action info</strong> to show <a id="_idIndexMarker491" class="pcalibre calibre4 pcalibre1"/>the interface, don’t forget to add <strong class="source-inline1">-t</strong>; otherwise, you’ll just see the <span>node’s name.</span></p>
			<p class="calibre3">Finally, we can get <span>the interface:</span></p>
			<pre class="console">
$ ros2 interface show my_robot_interfaces/action/CountUntil
# Here you should see the action definition</pre>			<p class="calibre3">This process is the same as what we followed for services. Now that we know the actio<a id="_idTextAnchor388" class="pcalibre calibre4 pcalibre1"/>n name and interface, we can try the service directly from <span>the Terminal.</span></p>
			<h2 id="_idParaDest-184" class="calibre6"><a id="_idTextAnchor389" class="pcalibre calibre4 pcalibre1"/>Sending a goal from the Terminal</h2>
			<p class="calibre3">If you write <a id="_idIndexMarker492" class="pcalibre calibre4 pcalibre1"/>a service server and want to try it before writing the action client, you can use the <strong class="source-inline1">ros2 action send_goal</strong> <span>command line.</span></p>
			<p class="calibre3">The complete command is <strong class="source-inline1">ros2 action send_goal &lt;action_name&gt; &lt;action_interface&gt; "&lt;goal_in_json&gt;"</strong>. You can also add <strong class="source-inline1">--feedback</strong> after the command to receive the (optional) feedback from the server. Let’s try <span>it out:</span></p>
			<pre class="console">
$ ros2 action send_goal /count_until my_robot_interfaces/action/CountUntil "{target_number: 3, delay: 0.4}" --feedback</pre>			<p class="calibre3">You will <a id="_idIndexMarker493" class="pcalibre calibre4 pcalibre1"/>get the <span>following result:</span></p>
			<pre class="console">
Waiting for an action server to become available...
Sending goal:
 target_number: 3
delay: 0.4
Goal accepted with ID: cad1aa41829d42c5bb1bf73dd4d66600
Feedback:
current_number: 1
Feedback:
current_number: 2
Feedback:
current_number: 3
Result:
reached_number: 3
Goal finished with status: SUCCEEDED</pre>			<p class="calibre3">This command is very useful for developing action servers. However, it will only work well for actions for which the goal is simple. Here, we only have an integer number and a double number. If the goal contains an array of 20 3D points, you will spend more time trying to write the command correctly than implementing an action client. In this case, to go <a id="_idTextAnchor390" class="pcalibre calibre4 pcalibre1"/>faster, use the action client we’ve written in this chapter as <span>a template.</span></p>
			<h2 id="_idParaDest-185" class="calibre6"><a id="_idTextAnchor391" class="pcalibre calibre4 pcalibre1"/>Topics and services inside actions</h2>
			<p class="calibre3">By <a id="_idIndexMarker494" class="pcalibre calibre4 pcalibre1"/>default, with <strong class="source-inline1">ros2 topic list</strong> and <strong class="source-inline1">ros2 service list</strong>, you won’t <a id="_idIndexMarker495" class="pcalibre calibre4 pcalibre1"/>see the two topics and three services inside the action. However, they do exist—you just have to add <strong class="source-inline1">--include-hidden-topics</strong> and <strong class="source-inline1">--</strong><span><strong class="source-inline1">include-hidden-services</strong></span><span>, respectively:</span></p>
			<pre class="console">
$ ros2 topic list --include-hidden-topics
/count_until/_action/feedback
/count_until/_action/status
...
$ ros2 service list --include-hidden-services
/count_until/_action/cancel_goal
/count_until/_action/get_result
/count_until/_action/send_goal
...</pre>			<p class="calibre3">With that, we’ve found all the topics and services that are being used. You can explore these a bit more by yourself by using the other <strong class="source-inline1">ros2 topic</strong> and <strong class="source-inline1">ros2 service</strong> <span>command lines.</span></p>
			<p class="calibre3">Now, there’s <a id="_idIndexMarker496" class="pcalibre calibre4 pcalibre1"/>one thing we’ve done for nodes, topics, and services: we’ve changed <a id="_idIndexMarker497" class="pcalibre calibre4 pcalibre1"/>the name at runtime. For some reason, this feature isn’t available for actions yet. As a workaround, you can still do this by renaming the two topics and three services when you start the <span>action server:</span></p>
			<pre class="console">
$ ros2 run my_cpp_pkg count_until_server --ros-args \
    -r /count_until/_action/feedback:=/count_until1/_action/feedback \
    -r /count_until/_action/status:=/count_until1/_action/status \
    -r /count_until/_action/cancel_goal:=/count_until1/_action/cancel_goal \
    -r /count_until/_action/get_result:=/count_until1/_action/get_result \
    -r /count_until/_action/send_goal:=/count_until1/_action/send_goal</pre>			<p class="calibre3">With this, the action will be renamed <strong class="source-inline1">/count_until1</strong>. The command is a bit ugly and prone to errors, but when we start nodes using launch files in <a href="B22403_09.xhtml#_idTextAnchor443" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 9</em></span></a>, in the <em class="italic">Configuring nodes inside a launch file</em> section, this won’t be <span>a problem.</span></p>
			<p class="calibre3">With that, we’ve come to the end of this chapter. I haven’t added any challenges here as I think that this <a id="_idIndexMarker498" class="pcalibre calibre4 pcalibre1"/>chapter itself is a big enough challenge. I would prefer you <a id="_idIndexMarker499" class="pcalibre calibre4 pcalibre1"/>to spend your time continuing with the other concepts in this book instead of bein<a id="_idTextAnchor392" class="pcalibre calibre4 pcalibre1"/>g stuck too long on actions, especially if you’re just getting started <span>with ROS.</span></p>
			<h1 id="_idParaDest-186" class="calibre6"><a id="_idTextAnchor393" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you worked on ROS 2 actions. You created various actions to solve a problem that services don’t handle well: when the server may take some time to execute <span>the request.</span></p>
			<p class="calibre3">With actions, you can properly handle this case. While the goal is being executed, you can get some feedback from the server, or even decide to cancel the goal. Also, you could handle several goals at the same time, queue them, replace one with another one, and so on (we haven’t seen this in this chapter as it’s something you can look into if you want to develop your <span>skills further).</span></p>
			<p class="calibre3">You can implement action servers and clients in your code using the <strong class="source-inline1">rclpy.action</strong> library for Python and the <strong class="source-inline1">rclcpp_action</strong> library <span>for C++.</span></p>
			<p class="calibre3">Here are the main steps for writing an <span>action server:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Since we’re on the server side, we must choose the action name and interface. Usually, for an action, you will have to create a custom interface (in a <span>dedicated package).</span></li>
				<li class="calibre10">Then, you must import the interface into your code and create an action server in the constructor. Here, you will register three <span>callback methods:</span><ul class="calibre12"><li class="calibre10"><strong class="bold">Goal callback</strong>: When the server receives a goal, choose whether to accept or <span>reject it.</span></li><li class="calibre10"><strong class="bold">Execute callback</strong>: After a goal has been accepted, you can execute it. During the execution of the goal, you can also publish <span>optional feedback.</span></li><li class="calibre10"><strong class="bold">Cancel callback (optional mechanism)</strong>: If you receive a cancel request, you can accept or reject it. If accepted, you will have to cancel the current <span>goal execution.</span></li></ul></li>
			</ol>
			<p class="calibre3">To write an action client, you must follow <span>these steps:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Find which name and interface you need to use so that you can communicate with <span>the server.</span></li>
				<li class="calibre10">Import the interface into your code and create an action client in <span>the constructor.</span></li>
				<li class="calibre10">Add a method to send a goal. After you send a goal, you will have to write <span>several callbacks:</span><ul class="calibre12"><li class="calibre10"><strong class="bold">Goal response callback</strong>: You will know whether the goal has been accepted or rejected by <span>the server.</span></li><li class="calibre10"><strong class="bold">Goal result callback</strong>: After the goal has been executed by the server, you will get the result and the goal’s final <span>state here.</span></li><li class="calibre10"><strong class="bold">Feedback callback (optional)</strong>: If the server publishes any feedback, you can receive <span>it here.</span></li></ul></li>
				<li class="calibre10">Finally, from anywhere in the code, you can decide to cancel the execution of a currently <span>active goal.</span></li>
			</ol>
			<p class="calibre3">On top of all that, with the <strong class="source-inline1">ros2 action</strong> command line, you can introspect your actions and send goals directly from the Terminal. Also, since actions are based on topics and services, you can introspect each underlying communication with <strong class="source-inline1">ros2 topic</strong> and <strong class="source-inline1">ros2 </strong><span><strong class="source-inline1">service</strong></span><span>, respectively.</span></p>
			<p class="calibre3">Now, if you managed to get here while reading this book for the first time, congratulations—this chapter is probably one of the most difficult to follow. If you’re still wondering what I was talking about the whole time, don’t worry—you can come back to actions later once you’ve finished this book and become more experienced <span>with ROS.</span></p>
			<p class="calibre3">We’re now done with the three types of communication in ROS 2. In the next chapter, we will go back to a more beginner level and continue to work on nodes. This time, we will learn how to customize nodes when we start them so that we can make our application <span>more dynamic.</span></p>
		</div>
	</body></html>