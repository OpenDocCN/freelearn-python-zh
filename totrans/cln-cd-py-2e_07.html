<html><head></head><body>
  <div id="_idContainer086">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-182" class="chapterTitle">Generators, Iterators, and Asynchronous Programming</h1>
    <p class="normal">Generators are another one of those features that makes Python a peculiar language over more traditional ones. In this chapter, we will explore their rationale, why they were introduced in the language, and the problems they solve. We will also cover how to address problems idiomatically by using generators, and how to make our generators (or any iterable, for that matter) Pythonic.</p>
    <p class="normal">We will understand why iteration (in the form of the iterator pattern) is automatically supported in the language. From there, we will take another journey and explore how generators became such a fundamental feature of Python in order to support other functionality, such as coroutines and asynchronous programming.</p>
    <p class="normal">The goals of this chapter are as follows:</p>
    <ul>
      <li class="bullet">To create generators that improve the performance of our programs</li>
      <li class="bullet">To study how iterators (and the iterator pattern, in particular) are deeply embedded in Python</li>
      <li class="bullet">To solve problems that involve iteration idiomatically</li>
      <li class="bullet">To understand how generators work as the basis for coroutines and asynchronous programming</li>
      <li class="bullet">To explore the syntactic support for coroutines—<code class="Code-In-Text--PACKT-">yield from</code>, <code class="Code-In-Text--PACKT-">await</code>, and <code class="Code-In-Text--PACKT-">async</code> <code class="Code-In-Text--PACKT-">def</code></li>
    </ul>
    <p class="normal">Mastering generators will take you a long way in writing idiomatic Python, hence the importance of them for this book. In this chapter, we not only study how to use generators, but we also explore their internals, in order to deeply understand how they work.</p>
    <h1 id="_idParaDest-183" class="title">Technical requirements</h1>
    <p class="normal">The examples in this chapter will work with any version of Python 3.9 on any platform.</p>
    <p class="normal">The code used in this chapter can be found at <a href="https://github.com/PacktPublishing/Clean-Code-in-Python-Second-Edition"><span class="url">https://github.com/PacktPublishing/Clean-Code-in-Python-Second-Edition</span></a>. The instructions are available in the <code class="Code-In-Text--PACKT-">README</code> file.</p>
    <h1 id="_idParaDest-184" class="title">Creating generators</h1>
    <p class="normal">Generators were<a id="_idIndexMarker455"/> introduced in Python a long time ago (PEP-255), with the idea of introducing iteration in Python while improving the performance of the program (by using less memory) at the same time.</p>
    <p class="normal">The idea of a generator is to create an object that is iterable, and, while it's being iterated, will produce the elements it contains, one at a time. The main use of generators is to save memory—instead of having a very large list of elements in memory, holding everything at once, we have an object that knows how to produce each particular element, one at a time, as it is required.</p>
    <p class="normal">This feature enables lazy computations of heavyweight objects in memory, in a similar manner to what other functional programming languages (Haskell, for instance) provide. It would even be possible to work with infinite sequences because the lazy nature of generators enables such an option.</p>
    <h2 id="_idParaDest-185" class="title">A first look at generators</h2>
    <p class="normal">Let's start with an example. The<a id="_idIndexMarker456"/> problem at hand now is that we want to process a large list of records and get some metrics and indicators over them. Given a large dataset with information about purchases, we want to process it in order to get the lowest sale, the highest sale, and the average price of a sale.</p>
    <p class="normal">For the simplicity of this example, we will assume a CSV with only two fields, in the following format:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;purchase_date&gt;, &lt;price&gt;
...
</code></pre>
    <p class="normal">We are going to create an object that receives all the purchases, and this will give us the necessary metrics. We could get some of these values out of the box by simply using the <code class="Code-In-Text--PACKT-">min()</code> and <code class="Code-In-Text--PACKT-">max()</code> built-in functions, but that would require iterating all of the purchases more than once, so instead, we are using our custom object, which will get these values in a single iteration.</p>
    <p class="normal">The code that will<a id="_idIndexMarker457"/> get the numbers for us looks rather simple. It's just an object with a method that will process all the prices in one go, and, at each step, will update the value of each particular metric we are interested in. First, we will show the first implementation in the following listing, and, later on in this chapter (once we have seen more about iteration), we will revisit this implementation and get a much better (and more compact) version of it. For now, we are settling with the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">PurchasesStats</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, purchases</span><span class="hljs-function">):</span>
        self.purchases = <span class="hljs-built_in">iter</span>(purchases)
        self.min_price: <span class="hljs-built_in">float</span> = <span class="hljs-literal">None</span>
        self.max_price: <span class="hljs-built_in">float</span> = <span class="hljs-literal">None</span>
        self._total_purchases_price: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
        self._total_purchases = <span class="hljs-number">0</span>
        self._initialize()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_initialize</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">try</span>:
            first_value = <span class="hljs-built_in">next</span>(self.purchases)
        <span class="hljs-keyword">except</span> StopIteration:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-stri">"no values provided"</span>)
        self.min_price = self.max_price = first_value
        self._update_avg(first_value)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">for</span> purchase_value <span class="hljs-keyword">in</span> self.purchases:
            self._update_min(purchase_value)
            self._update_max(purchase_value)
            self._update_avg(purchase_value)
        <span class="hljs-keyword">return</span> self
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_update_min</span><span class="hljs-function">(</span><span class="hljs-params">self, new_value: </span><span class="hljs-built_in">float</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">if</span> new_value &lt; self.min_price:
            self.min_price = new_value
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_update_max</span><span class="hljs-function">(</span><span class="hljs-params">self, new_value: </span><span class="hljs-built_in">float</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">if</span> new_value &gt; self.max_price:
            self.max_price = new_value
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">avg_price</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> self._total_purchases_price / self._total_purchases
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_update_avg</span><span class="hljs-function">(</span><span class="hljs-params">self, new_value: </span><span class="hljs-built_in">float</span><span class="hljs-function">):</span>
        self._total_purchases_price += new_value
        self._total_purchases += <span class="hljs-number">1</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__str__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> (
            <span class="hljs-stri">f"</span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-stri">(</span><span class="hljs-subst">{self.min_price}</span><span class="hljs-stri">, "</span>
            <span class="hljs-stri">f"</span><span class="hljs-subst">{self.max_price}</span><span class="hljs-stri">, </span><span class="hljs-subst">{self.avg_price}</span><span class="hljs-stri">)"</span>
        )
</code></pre>
    <p class="normal">This object will receive all the totals for <code class="Code-In-Text--PACKT-">purchases</code> and process the required values. Now, we need a function that loads these numbers into something that this object can process. Here is the first version:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_load_purchases</span><span class="hljs-function">(</span><span class="hljs-params">filename</span><span class="hljs-function">):</span>
    purchases = []
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
            *_, price_raw = line.partition(<span class="hljs-stri">","</span>)
            purchases.append(<span class="hljs-built_in">float</span>(price_raw))
    <span class="hljs-keyword">return</span> purchases
</code></pre>
    <p class="normal">This code works; it<a id="_idIndexMarker458"/> loads all the numbers of the file into a list that, when passed to our custom object, will produce the numbers we want. It has a performance issue, though. If you run it with a rather large dataset, it will take a while to complete, and it might even fail if the dataset is large enough to not fit into the main memory.</p>
    <p class="normal">If we take a look at our code that consumes this data, it is processing purchases, one at a time, so we might be wondering why our producer fits everything in memory at once. It is creating a list where it puts all of the content of the file, but we know we can do better.</p>
    <p class="normal">The solution is to create a generator. Instead of loading the entire content of the file in a list, we will produce the results one at a time. The code will now look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">load_purchases</span><span class="hljs-function">(</span><span class="hljs-params">filename</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
            *_, price_raw = line.partition(<span class="hljs-stri">","</span>)
            <span class="hljs-keyword">yield</span> <span class="hljs-built_in">float</span>(price_raw)
</code></pre>
    <p class="normal">If you measure the process this time, you will notice that the usage of memory has dropped significantly. We can also see how the code looks simpler—there is no need to define the list (therefore, there is no need to append to it), and the <code class="Code-In-Text--PACKT-">return</code> statement has also disappeared.</p>
    <p class="normal">In this case, the <code class="Code-In-Text--PACKT-">load_purchases</code> function is a generator function, or simply a generator.</p>
    <p class="normal">In Python, the mere <a id="_idIndexMarker459"/>presence of the keyword <code class="Code-In-Text--PACKT-">yield</code> in any function makes it a generator, and, as a result, when calling it, nothing other than creating an instance of the generator will happen:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; load_purchases(<span class="hljs-co -stri">"file"</span>)
&lt;generator object load_purchases at 0x...&gt;
</code></pre>
    <p class="normal">A generator object is an iterable (we will revisit iterables in more detail later on), which means that it can work with <code class="Code-In-Text--PACKT-">for</code> loops. Note how we did not have to change anything on the consumer code—our statistics processor remained the same, with the <code class="Code-In-Text--PACKT-">for</code> loop unmodified, after the new implementation.</p>
    <p class="normal">Working with iterables allows us to create these kinds of powerful abstractions that are polymorphic with respect to <code class="Code-In-Text--PACKT-">for</code> loops. As long as we keep the iterable interface, we can iterate over that object transparently.</p>
    <p class="normal">What we're exploring in this chapter is another case of idiomatic code that blends well with Python itself. In previous chapters, we have seen how we can implement our own context managers to connect our objects into with statements, or how can we create custom container objects to leverage the <code class="Code-In-Text--PACKT-">in</code> operator, or booleans for the <code class="Code-In-Text--PACKT-">if</code> statement, and so on. Now it's the turn of the <code class="Code-In-Text--PACKT-">for</code> operator, and for that, we'll create iterators.</p>
    <p class="normal">Before going into the details and nuances of generators, we can take a quick look at how generators relate to a concept that we have already seen: comprehensions. A generator in the form of a comprehension is called a generator expression, and we'll discuss it briefly in the next section.</p>
    <h2 id="_idParaDest-186" class="title">Generator expressions</h2>
    <p class="normal">Generators save a lot of memory, and<a id="_idIndexMarker460"/> since they are iterators, they are a convenient alternative to other iterables or containers that require more space in memory such as lists, tuples, or sets.</p>
    <p class="normal">Much like these data structures, they can also be defined by comprehension, only that they are called a generator expression (there is an ongoing argument about whether they should be called generator comprehensions. In this book, we will just refer to them by their canonical name, but feel free to use whichever you prefer).</p>
    <p class="normal">In the same way, we would define a list<a id="_idIndexMarker461"/> comprehension. If we replace the square brackets with parentheses, we get a generator that results from the expression. Generator expressions can also be passed directly to functions that work with iterables, such as <code class="Code-In-Text--PACKT-">sum()</code> and <code class="Code-In-Text--PACKT-">max()</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; [x**2 <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; (x**2 <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> range(10))
&lt;generator object &lt;genexpr&gt; at 0x...&gt;
<span class="hljs-con-meta">&gt;</span>&gt;&gt; sum(x**2 <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> range(10))
285
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Always pass a generator expression, instead of a list comprehension, to functions that expect iterables, such as <code class="Code-In-Text--PACKT-">min()</code>, <code class="Code-In-Text--PACKT-">max()</code>, and <code class="Code-In-Text--PACKT-">sum()</code>. This is more efficient and Pythonic.</p>
    </div>
    <p class="normal">What the previous recommendation means is to try to avoid passing lists to functions that already work with generators. The example in the next code is something you would want to avoid, and favor the approach from the previous listing:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; sum([x**2 <span class="hljs-con-keyword">for</span> x <span class="hljs-con-keyword">in</span> range(10)])  <span class="hljs-con-comment"># here the list can be avoided</span>
</code></pre>
    <p class="normal">And, of course, you can assign a generator expression to a variable and use it somewhere else (as with comprehensions). Keep in mind that there is an important distinction in this case, because we're talking about generators here. A list can be reused and iterated multiple times, but a generator will be exhausted after it has been iterated over. For this reason, make sure the result of the expression is consumed only once, or you'll get unexpected results.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Remember that generators are exhausted after they're iterated over, because they don't hold all the data in memory.</p>
    </div>
    <p class="normal">A common approach is to create new generator expressions in the code. This way, the first one will be exhausted <a id="_idIndexMarker462"/>after is iterated, but then a new one is created. Chaining generator expressions this way is useful and helps to save memory as well as to make the code more expressive because it's resolving different iterations in different steps. One scenario where this is useful is when you need to apply multiple filters on an iterable; you can achieve this by using multiple generator expressions that act as chained filters.</p>
    <p class="normal">Now that we have a new tool in our toolbox (iterators), let's see how we can use it to write more idiomatic code.</p>
    <h1 id="_idParaDest-187" class="title">Iterating idiomatically</h1>
    <p class="normal">In this section, we will first explore<a id="_idIndexMarker463"/> some idioms that come in handy when we have to deal with iteration in Python. These code recipes will help us get a better idea of the types of things we can do with generators (especially after we have already seen generator expressions), and how to solve typical problems in relation to them.</p>
    <p class="normal">Once we have seen some idioms, we will move on to exploring iteration in Python in more depth, analyzing the methods that make iteration possible, and how iterable objects work.</p>
    <h2 id="_idParaDest-188" class="title">Idioms for iteration</h2>
    <p class="normal">We are already familiar with the built-in <code class="Code-In-Text--PACKT-">enumerate()</code> function that, given an iterable, will return another one on which the element is a tuple, whose first element is the index of the second one (corresponding to the element in the original iterable):</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; list(enumerate(<span class="hljs-co -stri">"abcdef"</span>))
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]
</code></pre>
    <p class="normal">We wish to create a similar object, but in a more low-level fashion; one that can simply create an infinite sequence. We want an object that can produce a sequence of numbers, from a starting one, without any limits.</p>
    <p class="normal">An object as simple as the following one can do the trick. Every time we call this object, we get the next number of the sequence ad infinitum:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">NumberSequence</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, start=</span><span class="hljs-number">0</span><span class="hljs-function">):</span>
        self.current = start
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">next</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        current = self.current
        self.current += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> current
</code></pre>
    <p class="normal">Based on this interface, we would have to use this object by explicitly invoking its <code class="Code-In-Text--PACKT-">next()</code> method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; seq = NumberSequence()
<span class="hljs-con-meta">&gt;</span>&gt;&gt; seq.next()
0
<span class="hljs-con-meta">&gt;</span>&gt;&gt; seq.next()
1
<span class="hljs-con-meta">&gt;</span>&gt;&gt; seq2 = NumberSequence(10)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; seq2.next()
10
<span class="hljs-con-meta">&gt;</span>&gt;&gt; seq2.next()
11
</code></pre>
    <p class="normal">But with this code, we<a id="_idIndexMarker464"/> cannot reconstruct the <code class="Code-In-Text--PACKT-">enumerate()</code> function as we would like to, because its interface does not support being iterated over a regular Python <code class="Code-In-Text--PACKT-">for</code> loop, which also means that we cannot pass it as a parameter to functions that expect something to iterate over. Notice how the following code fails:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; list(zip(NumberSequence(), <span class="hljs-co -stri">"abcdef"</span>))
Traceback (most recent call last):
  File "...", line 1, in &lt;module&gt;
TypeError: zip argument #1 must support iteration
</code></pre>
    <p class="normal">The problem lies in the fact that <code class="Code-In-Text--PACKT-">NumberSequence</code> does not support iteration. To fix this, we have to make the object an iterable by implementing the magic method <code class="Code-In-Text--PACKT-">__iter__()</code>. We have also changed the previous <code class="Code-In-Text--PACKT-">next()</code> method, by using the <code class="Code-In-Text--PACKT-">__next__ magic method</code>, which makes the object an iterator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SequenceOfNumbers</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, start=</span><span class="hljs-number">0</span><span class="hljs-function">):</span>
        self.current = start
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__next__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        current = self.current
        self.current += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> current
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__iter__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> self
</code></pre>
    <p class="normal">This has an advantage—not only can we iterate over the element, but we also don't even need the <code class="Code-In-Text--PACKT-">.next()</code> method anymore because having <code class="Code-In-Text--PACKT-">__next__()</code> allows us to use the <code class="Code-In-Text--PACKT-">next()</code> built-in function:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; list(zip(SequenceOfNumbers(), <span class="hljs-co -stri">"abcdef"</span>))
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; seq = SequenceOfNumbers(100)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(seq)
100
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(seq)
101
</code></pre>
    <p class="normal">This makes use of the iteration protocol. Similar to the context manager protocol we have explored in previous chapters, which consists of the <code class="Code-In-Text--PACKT-">__enter__</code> and <code class="Code-In-Text--PACKT-">__exit__</code> methods, this protocol relies on the <code class="Code-In-Text--PACKT-">__iter__</code> and <code class="Code-In-Text--PACKT-">__next__</code> methods.</p>
    <p class="normal">Having these<a id="_idIndexMarker465"/> protocols in Python has an advantage: everyone that knows Python will be familiar with this interface already, so there's a sort of "standard contract." This means, instead of having to define your own methods and agree with the team (or any potential reader of the code), that this is the expected standard or protocol your code works with (as with our custom <code class="Code-In-Text--PACKT-">next()</code> method in the first example); Python already provides an interface and has a protocol already. We only have to implement it properly.</p>
    <h3 id="_idParaDest-189" class="title">The next() function</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">next()</code> built-in function will <a id="_idIndexMarker466"/>advance the iterable to its next element and return it:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; word = iter(<span class="hljs-co -stri">"hello"</span>)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(word)
'h'
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(word)
'e'  # ...
</code></pre>
    <p class="normal">If the iterator does not have more elements to produce, the <code class="Code-In-Text--PACKT-">StopIteration</code> exception is raised:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; ...
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(word)
'o'
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(word)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration
<span class="hljs-con-meta">&gt;</span>&gt;&gt;
</code></pre>
    <p class="normal">This exception signals that the iteration is over and that there are no more elements to consume.</p>
    <p class="normal">If we wish to handle this case, besides catching the <code class="Code-In-Text--PACKT-">StopIteration</code> exception, we could provide this function with a default value in its second parameter. Should this be provided, it will be the return value in lieu of throwing <code class="Code-In-Text--PACKT-">StopIteration</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; next(word, <span class="hljs-co -stri">"default value"</span>)
'default value'
</code></pre>
    <p class="normal">It is advisable to use the <a id="_idIndexMarker467"/>default value most of the time, to avoid having exceptions at runtime in our programs. If we are absolutely sure that the iterator we're dealing with cannot be empty, it's still better to be implicit (and intentional) about it, and not rely on side effects of built-in functions (that is, to properly assert the case).</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">next()</code> function can be quite useful in combination with generator expressions, in situations where we want to look for the first elements of an iterable that meets certain criteria. We'll see examples of this idiom throughout the chapter, but the main idea is to use this function instead of creating a list comprehension and then taking its first element.</p>
    <h3 id="_idParaDest-190" class="title">Using a generator</h3>
    <p class="normal">The previous code can be <a id="_idIndexMarker468"/>simplified significantly by simply using a generator. Generator objects are iterators. This way, instead of creating a class, we can define a function that yields the values as needed:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sequence</span><span class="hljs-function">(</span><span class="hljs-params">start=</span><span class="hljs-number">0</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">yield</span> start
        start += <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">Remember that from our first definition, the <code class="Code-In-Text--PACKT-">yield</code> keyword in the body of the function makes it a generator. Because it is a generator, it's perfectly fine to create an infinite loop like this, because, when this generator function is called, it will run all the code until the next <code class="Code-In-Text--PACKT-">yield</code> statement is reached. It will produce its value and suspend there:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; seq = sequence(10)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(seq)
10
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(seq)
11
<span class="hljs-con-meta">&gt;</span>&gt;&gt; list(zip(sequence(), <span class="hljs-co -stri">"abcdef"</span>))
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e'), (5, 'f')]
</code></pre>
    <p class="normal">This difference can be<a id="_idIndexMarker469"/> thought of as an analogy of the different ways there are to create a decorator, as we explored in the previous chapter (with an object of functions). Here as well, we can use a generator function, or an iterable object, as in the previous section. Whenever is possible, constructing a generator is recommended, because it's syntactically simpler, and therefore easier to understand.</p>
    <h3 id="_idParaDest-191" class="title">Itertools</h3>
    <p class="normal">Working with iterable objects <a id="_idIndexMarker470"/>has the advantage that the code blends better with Python itself because iteration is a key component of the language. Besides that, we can take full advantage of the <code class="Code-In-Text--PACKT-">itertools</code> module (ITER-01). Actually, the <code class="Code-In-Text--PACKT-">sequence()</code> generator we just created is fairly similar to <code class="Code-In-Text--PACKT-">itertools.count()</code>. However, there is more we can do.</p>
    <p class="normal">One of the nicest things about iterators, generators, and itertools is that they are composable objects that can be chained together.</p>
    <p class="normal">For instance, going back to our first example that processed <code class="Code-In-Text--PACKT-">purchases</code> in order to get some metrics, what if we want to do the same, but only for those values over a certain threshold? The naïve approach to solving this problem would be to place the condition while iterating:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">for</span> purchase <span class="hljs-keyword">in</span> self.purchases:
            <span class="hljs-keyword">if</span> purchase &gt; <span class="hljs-number">1000.0</span>:
                ...
</code></pre>
    <p class="normal">This is not only non-Pythonic, but it's also rigid (and rigidity is a trait that denotes bad code). It doesn't handle changes very well. What if the number changes now? Do we pass it by parameter? What if we need more than one? What if the condition is different (less than, for instance)? Do we pass a <code class="Code-In-Text--PACKT-">lambda</code>?</p>
    <p class="normal">These questions should not <a id="_idIndexMarker471"/>be answered by this object, whose sole responsibility is to compute a set of well-defined metrics over a stream of purchases represented as numbers. And, of course, the answer is no. It would be a huge mistake to make such a change (once again, clean code is flexible, and we don't want to make it rigid by coupling this object to external factors). These requirements will have to be addressed elsewhere.</p>
    <p class="normal">It's better to keep this object independent of its clients. The less responsibility this class has, the more useful it will be for more clients, hence enhancing its chances of being reused.</p>
    <p class="normal">Instead of changing this code, we're going to keep it as it is and assume that the new data is filtered according to whatever requirements each customer of the class has.</p>
    <p class="normal">For instance, if we wanted to process only the first <code class="Code-In-Text--PACKT-">10</code> purchases that amount to more than <code class="Code-In-Text--PACKT-">1000</code>, we would do the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; from itertools import islice
<span class="hljs-con-meta">&gt;</span>&gt;&gt; purchases = islice(filter(lambda p: p &gt; 1000.0, purchases), 10)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; stats = PurchasesStats(purchases).process()  <span class="hljs-con-comment"># ...</span>
</code></pre>
    <p class="normal">There is no memory penalization for filtering this way because since they are all generators, the evaluation is always lazy. This gives us the power of thinking as if we had filtered the entire set at once and then passed it to the object, but without actually fitting everything in memory.</p>
    <p class="normal">Keep in mind the trade-off mentioned at the beginning of the chapter, between memory and CPU usage. While the code might use less memory, it could take up more CPU time, but most of the times, this is acceptable, when we have to process lots of objects in memory while keeping the code maintainable.</p>
    <h3 id="_idParaDest-192" class="title">Simplifying code through iterators</h3>
    <p class="normal">Now, we will briefly <a id="_idIndexMarker472"/>discuss some situations that can be improved with the help of iterators, and occasionally the <code class="Code-In-Text--PACKT-">itertools</code> module. After discussing each case, and its proposed optimization, we will close each point with a corollary.</p>
    <h4 class="title">Repeated iterations</h4>
    <p class="normal">Now that we have seen more<a id="_idIndexMarker473"/> about iterators, and introduced the <code class="Code-In-Text--PACKT-">itertools</code> module, we can show you how one of the first examples of this chapter (the one for computing statistics about some purchases) can be dramatically simplified:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">process_purchases</span><span class="hljs-function">(</span><span class="hljs-params">purchases</span><span class="hljs-function">):</span>
    min_, max_, avg = itertools.tee(purchases, <span class="hljs-number">3</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(min_), <span class="hljs-built_in">max</span>(max_), median(avg)
</code></pre>
    <p class="normal">In this example, <code class="Code-In-Text--PACKT-">itertools.tee</code> will split the original iterable into three new ones. We will use each of these for the different kinds of iterations that we require, without needing to repeat three different loops over <code class="Code-In-Text--PACKT-">purchases</code>.</p>
    <p class="normal">The reader can simply verify that if we pass an iterable object as the <code class="Code-In-Text--PACKT-">purchases</code> parameter, this one is traversed only once (thanks to the <code class="Code-In-Text--PACKT-">itertools.tee</code> function [TEE]), which was our main requirement. It is also possible to verify how this version is equivalent to our original implementation. In this case, there is no need to manually raise <code class="Code-In-Text--PACKT-">ValueError</code> because passing an empty sequence to the <code class="Code-In-Text--PACKT-">min()</code> function will do this.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If you are thinking about running a loop over the same object more than once, stop and think if <code class="Code-In-Text--PACKT-">itertools.tee</code> can be of any help.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">itertools</code> module<a id="_idIndexMarker474"/> contains many useful functions and nice abstractions that come in handy when dealing with iterations in Python. It also contains good recipes about how to solve typical iteration problems in an idiomatic fashion. As general advice, if you're thinking about how to solve a particular problem that involves iteration, go and take a look at this module. Even if the answer isn't literally there, it'll be good inspiration.</p>
    <h4 class="title">Nested loops</h4>
    <p class="normal">In some situations, we <a id="_idIndexMarker475"/>need to iterate over more than one dimension, looking for a value, and nested loops come as the first idea. When the value is found, we need to stop iterating, but the <code class="Code-In-Text--PACKT-">break</code> keyword doesn't work entirely because we have to escape from two (or more) <code class="Code-In-Text--PACKT-">for</code> loops, not just one.</p>
    <p class="normal">What would be the solution to this? A flag signaling escape? No. Raising an exception? No, this would be the same as the flag, but even worse because we know that exceptions are not to be used for control flow logic. Moving the code to a smaller function and returning it? Close, but not quite.</p>
    <p class="normal">The answer is, whenever possible, flatten the iteration to a single <code class="Code-In-Text--PACKT-">for</code> loop.</p>
    <p class="normal">This is the kind of code we would like to avoid:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">search_nested_bad</span><span class="hljs-function">(</span><span class="hljs-params">array, desired_value</span><span class="hljs-function">):</span>
    coords = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array):
        <span class="hljs-keyword">for</span> j, cell <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(row):
            <span class="hljs-keyword">if</span> cell == desired_value:
                coords = (i, j)
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> coords <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">if</span> coords <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-stri">f"</span><span class="hljs-subst">{desired_value}</span><span class="hljs-stri"> not found"</span>)
    logger.info(<span class="hljs-stri">"value %r found at [%i, %i]"</span>, desired_value, *coords)
    <span class="hljs-keyword">return</span> coords
</code></pre>
    <p class="normal">And here is a simplified version <a id="_idIndexMarker476"/>of it that does not rely on flags to signal termination, and has a simpler, more compact structure of iteration:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_iterate_array2d</span><span class="hljs-function">(</span><span class="hljs-params">array2d</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array2d):
        <span class="hljs-keyword">for</span> j, cell <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(row):
            <span class="hljs-keyword">yield</span> (i, j), cell
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">search_nested</span><span class="hljs-function">(</span><span class="hljs-params">array, desired_value</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
        coord = <span class="hljs-built_in">next</span>(
            coord
            <span class="hljs-keyword">for</span> (coord, cell) <span class="hljs-keyword">in</span> _iterate_array2d(array)
            <span class="hljs-keyword">if</span> cell == desired_value
        )
    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-stri">f"</span><span class="hljs-subst">{desired_value}</span><span class="hljs-stri"> not found"</span>) <span class="hljs-keyword">from</span> e
    logger.info(<span class="hljs-stri">"value %r found at [%i, %i]"</span>, desired_value, *coord)
    <span class="hljs-keyword">return</span> coord
</code></pre>
    <p class="normal">It's worth mentioning how the auxiliary generator that was created works as an abstraction for the iteration that's required. In this case, we just need to iterate over two dimensions, but if we needed more, a different object could handle this without the client needing to know about it. This is the essence of the iterator design pattern, which, in Python, is transparent, since it supports iterator objects automatically, which is the topic covered in the next section.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Try to simplify the iteration as much as possible with as many abstractions as are required, flattening the loops wherever possible.</p>
    </div>
    <p class="normal">Hopefully, this example serves as inspiration to you to get the idea that we can use generators for something more than just saving memory. We can take advantage of the iteration as an abstraction. That is, we can create abstractions not only by defining classes or functions but also by taking advantage of the syntax of Python. In the same way that we have seen how to abstract away some logic behind a context manager (so we don't know the details of what happens under the <code class="Code-In-Text--PACKT-">with</code> statement), we can do the same with iterators (so we can forget the underlying logic of a <code class="Code-In-Text--PACKT-">for</code> loop).</p>
    <p class="normal">That's why we will start exploring how the iterator pattern works in Python, starting with the next section.</p>
    <h3 id="_idParaDest-193" class="title">The iterator pattern in Python</h3>
    <p class="normal">Here, we will take a <a id="_idIndexMarker477"/>small detour from generators to understand iteration in Python more deeply. Generators are a particular case of iterable objects, but iteration in Python goes beyond generators, and being able to create good iterable objects will give us the chance to create more efficient, compact, and readable code.</p>
    <p class="normal">In the previous code listings, we have been seeing examples of <code class="Code-In-Text--PACKT-">iterable</code> objects that are also iterators, because they implement both the <code class="Code-In-Text--PACKT-">__iter__()</code> and <code class="Code-In-Text--PACKT-">__next__()</code> magic methods. While this is fine in general, it's not strictly required that they always have to implement both methods, and here we'll show the subtle differences between an <code class="Code-In-Text--PACKT-">iterable</code> object (one that implements <code class="Code-In-Text--PACKT-">__iter__</code>) and an iterator (that implements <code class="Code-In-Text--PACKT-">__next__</code>).</p>
    <p class="normal">We also explore other topics related to iterations, such as sequences and container objects.</p>
    <h4 class="title">The interface for iteration</h4>
    <p class="normal">An <code class="Code-In-Text--PACKT-">iterable</code> is an <a id="_idIndexMarker478"/>object that supports iteration, which, at a very high level, means that we can run a <code class="Code-In-Text--PACKT-">for</code> .. <code class="Code-In-Text--PACKT-">in</code> ... loop over it, and it will work without any issues. However, <code class="Code-In-Text--PACKT-">iterable</code> does not mean the same as iterator.</p>
    <p class="normal">Generally speaking, an <code class="Code-In-Text--PACKT-">iterable</code> is just something we can iterate, and it uses an iterator to do so. This means that in the <code class="Code-In-Text--PACKT-">__iter__</code> magic method, we would like to return an iterator, namely, an object with a <code class="Code-In-Text--PACKT-">__next__()</code> method implemented.</p>
    <p class="normal">An iterator is <a id="_idIndexMarker479"/>an object<a id="_idIndexMarker480"/> that only knows how to produce a series of values, one at a time, when it's being called by the already explored built-in <code class="Code-In-Text--PACKT-">next()</code> function, while the iterator is not called, it's simply frozen, sitting idly by until it's called again for the next value to produce. In this sense, generators are iterators.</p>
    <table id="table001-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Python concept</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Magic method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Considerations</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Iterable</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">__iter__</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">They work with an iterator to construct the iteration logic.</p>
            <p class="Table-Column-Content--PACKT-">These objects can be iterated in a <code class="Code-In-Text--PACKT-">for</code> ... <code class="Code-In-Text--PACKT-">in</code> ...: loop.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Iterator</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">__next__</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Define the logic for producing values one at a time.</p>
            <p class="Table-Column-Content--PACKT-">The <code class="Code-In-Text--PACKT-">StopIteration</code> exception signals that the iteration is over.</p>
            <p class="Table-Column-Content--PACKT-">The values can be obtained one by one via the built-in <code class="Code-In-Text--PACKT-">next()</code> function.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 7.1: Iterables and iterators</p>
    <p class="normal">In the following code, we will see an example of an iterator object that is not iterable—it only supports invoking its values, one at a time. Here, the name <code class="Code-In-Text--PACKT-">sequence</code> refers just to a series of consecutive numbers, not to the sequence concept in Python, which we will explore later on:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SequenceIterator</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, start=</span><span class="hljs-number">0</span><span class="hljs-params">, step=</span><span class="hljs-number">1</span><span class="hljs-function">):</span>
        self.current = start
        self.step = step
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__next__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        value = self.current
        self.current += self.step
        <span class="hljs-keyword">return</span> value
</code></pre>
    <p class="normal">Notice that we can get the values <a id="_idIndexMarker481"/>of the sequence one at a time, but we can't iterate over this object (this is fortunate because it would otherwise result in an endless loop):</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; si = SequenceIterator(1, 2)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(si)
1
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(si)
3
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(si)
5
<span class="hljs-con-meta">&gt;</span>&gt;&gt; <span class="hljs-con-keyword">for</span> _ <span class="hljs-con-keyword">in</span> SequenceIterator(): pass
... 
Traceback (most recent call last):
  ...
TypeError: 'SequenceIterator' object is not iterable
</code></pre>
    <p class="normal">The error message is clear, as the object doesn't implement <code class="Code-In-Text--PACKT-">__iter__()</code>.</p>
    <p class="normal">Just for explanatory purposes, we can separate the iteration in another object (again, it would be enough to make the object implement both <code class="Code-In-Text--PACKT-">__iter__</code> and <code class="Code-In-Text--PACKT-">__next__</code>, but doing so separately will help clarify the distinctive point we're trying to make in this explanation).</p>
    <h4 class="title">Sequence objects as iterables</h4>
    <p class="normal">As we have just seen, if an <a id="_idIndexMarker482"/>object implements the <code class="Code-In-Text--PACKT-">__iter__()</code> magic method, it means it can be used in a <code class="Code-In-Text--PACKT-">for</code> loop. While this is a great feature, it's not the only possible form of iteration we can achieve. When we write a <code class="Code-In-Text--PACKT-">for</code> loop, Python will try to see if the object we're using implements <code class="Code-In-Text--PACKT-">__iter__</code>, and if it does, it will use that to construct the iteration, but if it doesn't, there are fallback options.</p>
    <p class="normal">If the object happens to be a sequence (meaning that it implements the <code class="Code-In-Text--PACKT-">__getitem__()</code> and <code class="Code-In-Text--PACKT-">__len__()</code> magic methods), it can also be iterated. If that is the case, the interpreter will then provide values in sequence, until the <code class="Code-In-Text--PACKT-">IndexError</code> exception is raised, which, analogous to the aforementioned <code class="Code-In-Text--PACKT-">StopIteration</code>, also signals the stop for the iteration.</p>
    <p class="normal">With the sole purpose of illustrating such a behavior, we will run the following experiment that shows a sequence object that implements <code class="Code-In-Text--PACKT-">map()</code> over a range of numbers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># generators_iteration_2.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MappedRange</span><span class="hljs-class">:</span>
    <span class="hljs-stri">"""Apply a transformation to a range of numbers."""</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, transformation, start, end</span><span class="hljs-function">):</span>
        self._transformation = transformation
        self._wrapped = <span class="hljs-built_in">range</span>(start, end)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__getitem__</span><span class="hljs-function">(</span><span class="hljs-params">self, index</span><span class="hljs-function">):</span>
        value = self._wrapped.__getitem__(index)
        result = self._transformation(value)
        logger.info(<span class="hljs-stri">"Index %d: %s"</span>, index, result)
        <span class="hljs-keyword">return</span> result
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__len__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self._wrapped)
</code></pre>
    <p class="normal">Keep in mind that this <a id="_idIndexMarker483"/>example is only designed to illustrate that an object such as this one can be iterated with a regular <code class="Code-In-Text--PACKT-">for</code> loop. There is a logging line placed in the <code class="Code-In-Text--PACKT-">__getitem__</code> method to explore what values are passed while the object is being iterated, as we can see from the following test:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; mr = MappedRange(abs, -10, 5)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; mr[0]
Index 0: 10
10
<span class="hljs-con-meta">&gt;</span>&gt;&gt; mr[-1]
Index -1: 4
4
<span class="hljs-con-meta">&gt;</span>&gt;&gt; list(mr)
Index 0: 10
Index 1: 9
Index 2: 8
Index 3: 7
Index 4: 6
Index 5: 5
Index 6: 4
Index 7: 3
Index 8: 2
Index 9: 1
Index 10: 0
Index 11: 1
Index 12: 2
Index 13: 3
Index 14: 4
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 1, 2, 3, 4]
</code></pre>
    <p class="normal">As a word of caution, it's important to highlight that while it is useful to know this, it's also a fallback mechanism for when the object doesn't implement <code class="Code-In-Text--PACKT-">__iter__</code>, so most of the time we'll want to resort to these methods by thinking about creating proper sequences, and not just objects we want to iterate over.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">When thinking about designing an object for iteration, favor a proper iterable object (with <code class="Code-In-Text--PACKT-">__iter__</code>), rather than a sequence that can coincidentally also be iterated.</p>
    </div>
    <p class="normal">Iterables are an important<a id="_idIndexMarker484"/> part of Python, not only because of the capabilities they offer to us as software engineers, but also because they play a fundamental role in the internals of Python.</p>
    <p class="normal">We have seen in <em class="italic">A brief introduction to asynchronous code</em> in <em class="chapterRef">Chapter 2</em>, <em class="italic">Pythonic Code</em>, how to read asynchronous code. Now that we have also explored iterators in Python, we can see how these two concepts are related. In particular, the next section explores coroutines, and we'll see how iterators are at the core of them.</p>
    <h1 id="_idParaDest-194" class="title">Coroutines</h1>
    <p class="normal">The idea of a coroutine<a id="_idIndexMarker485"/> is to have a function, whose execution can be suspended at a given point in time, to be later resumed. By having this kind of functionality, a program might be able to suspend a part of the code, in order to dispatch something else for processing, and then come back to this original point to resume.</p>
    <p class="normal">As we already know, generator objects are iterables. They implement <code class="Code-In-Text--PACKT-">__iter__()</code> and <code class="Code-In-Text--PACKT-">__next__()</code>. This is provided by Python automatically so that when we create a generator object function, we get an object that can be iterated or advanced through the <code class="Code-In-Text--PACKT-">next()</code> function.</p>
    <p class="normal">Besides this basic functionality, they have more methods so that they can work as coroutines (PEP-342). Here, we will explore how generators evolved into coroutines to support the basis of asynchronous programming before we go into more detail in the next section, where we will explore the new features of Python and the syntax that covers programming asynchronously. </p>
    <p class="normal">The basic methods added in PEP-342 to support coroutines are as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.close()</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.throw(ex_type[, ex_value[, ex_traceback]])</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">.send(value)</code></li>
    </ul>
    <p class="normal">Python takes advantage of<a id="_idIndexMarker486"/> generators in order to create coroutines. Because generators can naturally suspend, they're a convenient starting point. But generators weren't enough as they were originally thought to be, so these methods were added. This is because typically, it's not enough to just be able to suspend some part of the code; you'd also want to communicate with it (pass data, and signal about changes in the context).</p>
    <p class="normal">By exploring each method in more detail, we'll be able to learn more about the internals of coroutines in Python. After this, I'll present another recapitulation of how asynchronous programming works, but unlike the one presented in <em class="chapterRef">Chapter 2</em>, <em class="italic">Pythonic Code</em>, this one will relate to the internal concepts we just learned.</p>
    <h2 id="_idParaDest-195" class="title">The methods of the generator interface</h2>
    <p class="normal">In this section, we will<a id="_idIndexMarker487"/> explore what each of the aforementioned methods does, how it works, and how it is expected to be used. By understanding how to use these methods, we will be able to make use of simple coroutines.</p>
    <p class="normal">Later on, we will explore more advanced uses of coroutines, and how to delegate to sub-generators (coroutines) in order to refactor code, and how to orchestrate different coroutines.</p>
    <h3 id="_idParaDest-196" class="title">close()</h3>
    <p class="normal">When calling this method, the <a id="_idIndexMarker488"/>generator will receive the <code class="Code-In-Text--PACKT-">GeneratorExit</code> exception. If it's not handled, then the generator will finish without producing any more values, and its iteration will stop.</p>
    <p class="normal">This exception can be used to handle a finishing status. In general, if our coroutine does some sort of resource management, we want to catch this exception and use that control block to release all resources being held by the coroutine. It is similar to using a context manager or placing the code in the <code class="Code-In-Text--PACKT-">finally</code> block of an exception control, but handling this exception specifically makes it more explicit.</p>
    <p class="normal">In the following example, we have a coroutine that makes use of a database handler object that holds a connection to a database, and runs queries over it, streaming data by pages of a fixed length (instead of reading everything that is available at once):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream_db_records</span><span class="hljs-function">(</span><span class="hljs-params">db_handler</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            <span class="hljs-keyword">yield</span> db_handler.read_n_records(<span class="hljs-number">10</span>)
    <span class="hljs-keyword">except</span> GeneratorExit:
        db_handler.close()
</code></pre>
    <p class="normal">At each call to the generator, it <a id="_idIndexMarker489"/>will return <code class="Code-In-Text--PACKT-">10</code> rows obtained from the database handler, but when we decide to explicitly finish the iteration and call <code class="Code-In-Text--PACKT-">close()</code>, we also want to close the connection to the database:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer = stream_db_records(DBHandler(<span class="hljs-co -stri">"testdb"</span>))
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(streamer)
[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), ...]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(streamer)
[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), ...]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer.close()
INFO:...:closing connection to database 'testdb'
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Use the <code class="Code-In-Text--PACKT-">close()</code> method on generators to perform finishing-up tasks when needed.</p>
    </div>
    <p class="normal">This method is intended to be used for resource cleanup, so you'd typically use it for manually freeing resources when you couldn't do this automatically (for example, if you didn't use a context manager). Next, we'll see how to pass exceptions to the generator.</p>
    <h3 id="_idParaDest-197" class="title">throw(ex_type[, ex_value[, ex_traceback]])</h3>
    <p class="normal">This method will <code class="Code-In-Text--PACKT-">throw</code> the <a id="_idIndexMarker490"/>exception at the line where the generator is currently suspended. If the generator handles the exception that was sent, the code in that particular <code class="Code-In-Text--PACKT-">except</code> clause will be called; otherwise, the exception will propagate to the caller.</p>
    <p class="normal">Here, we are modifying the previous example slightly to show the difference when we use this method for an exception that is handled by the coroutine, and when it's not:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CustomException</span><span class="hljs-class">(</span><span class="hljs-params">Exception</span><span class="hljs-class">):</span>
    <span class="hljs-stri">"""A type of exception that is under control."""</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream_data</span><span class="hljs-function">(</span><span class="hljs-params">db_handler</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">yield</span> db_handler.read_n_records(<span class="hljs-number">10</span>)
        <span class="hljs-keyword">except</span> CustomException <span class="hljs-keyword">as</span> e:
            logger.info(<span class="hljs-stri">"controlled error %r, continuing"</span>, e)
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            logger.info(<span class="hljs-stri">"unhandled error %r, stopping"</span>, e)
            db_handler.close()
            <span class="hljs-keyword">break</span>
</code></pre>
    <p class="normal">Now, it is a part of the control flow to receive a <code class="Code-In-Text--PACKT-">CustomException</code>, and, in such a case, the generator will log an informative message (of course, we can adapt this according to our business logic on each case), and move on to the next <code class="Code-In-Text--PACKT-">yield</code> statement, which is the line where the coroutine reads from the database and returns that data.</p>
    <p class="normal">This particular example <a id="_idIndexMarker491"/>handles all exceptions, but if the last block (except <code class="Code-In-Text--PACKT-">Exception</code>:) wasn't there, the result would be that the generator is raised at the line where the generator is paused (again, <code class="Code-In-Text--PACKT-">yield</code>), and it will propagate from there to the caller:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer = stream_data(DBHandler(<span class="hljs-co -stri">"testdb"</span>))
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(streamer)
[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(streamer)
[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer.throw(CustomException)
WARNING:controlled error CustomException(), continuing
[(0, 'row 0'), (1, 'row 1'), (2, 'row 2'), (3, 'row 3'), (4, 'row 4'), ...]
<span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer.throw(RuntimeError)
ERROR:unhandled error RuntimeError(), stopping
INFO:closing connection to database 'testdb'
Traceback (most recent call last):
  ...
StopIteration
</code></pre>
    <p class="normal">When our exception <a id="_idIndexMarker492"/>from the domain was received, the generator continued. However, when it received another exception that was not expected, the default block caught where we closed the connection to the database and finished the iteration, which resulted in the generator being stopped. As we can see from the <code class="Code-In-Text--PACKT-">StopIteration</code> that was raised, this generator can't be iterated further.</p>
    <h3 id="_idParaDest-198" class="title">send(value)</h3>
    <p class="normal">In the previous example, we <a id="_idIndexMarker493"/>created a simple generator that reads rows from a database, and when we wished to finish its iteration, this generator released the resources linked to the database. This is a good example of using one of the methods that generators provide (<code class="Code-In-Text--PACKT-">close()</code>), but there is more we can do.</p>
    <p class="normal">An obvservation of the generator is that it was reading a fixed number of rows from the database.</p>
    <p class="normal">We would like to parametrize that number (<code class="Code-In-Text--PACKT-">10</code>) so that we can change it throughout different calls. Unfortunately, the <code class="Code-In-Text--PACKT-">next()</code> function does not provide us with options for that. But luckily, we have <code class="Code-In-Text--PACKT-">send()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream_db_records</span><span class="hljs-function">(</span><span class="hljs-params">db_handler</span><span class="hljs-function">):</span>
    retrieved_data = <span class="hljs-literal">None</span>
    previous_page_size = <span class="hljs-number">10</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            page_size = <span class="hljs-keyword">yield</span> retrieved_data
            <span class="hljs-keyword">if</span> page_size <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
                page_size = previous_page_size
            previous_page_size = page_size
            retrieved_data = db_handler.read_n_records(page_size)
    <span class="hljs-keyword">except</span> GeneratorExit:
        db_handler.close()
</code></pre>
    <p class="normal">The idea is that we have now made the coroutine able to receive values from the caller by means of the <code class="Code-In-Text--PACKT-">send()</code> method. This method is the one that actually distinguishes a generator from a coroutine because when it's used, it means that the <code class="Code-In-Text--PACKT-">yield</code> keyword will appear on the right-hand side of the statement, and its return value will be assigned to something else.</p>
    <p class="normal">In coroutines, we generally find the <code class="Code-In-Text--PACKT-">yield</code> keyword to be used in the following form:</p>
    <pre class="programlisting code"><code class="hljs-code">receive = <span class="hljs-keyword">yield</span> produced
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">yield</code>, in this case, will do two things. It will send <code class="Code-In-Text--PACKT-">produced</code> back to the caller, which will pick it up on the next round of iteration (after calling <code class="Code-In-Text--PACKT-">next()</code>, for example), and it will suspend there. At a later point, the caller will want to send a value back to the coroutine by using the <code class="Code-In-Text--PACKT-">send()</code> method. This value will become the result of the <code class="Code-In-Text--PACKT-">yield</code> statement, assigned in this case to the variable named <code class="Code-In-Text--PACKT-">receive</code>.</p>
    <p class="normal">Sending values to the <a id="_idIndexMarker494"/>coroutine only works when this one is suspended at a <code class="Code-In-Text--PACKT-">yield</code> statement, waiting for something to produce. For this to happen, the coroutine will have to be advanced to that status. The only way to do this is by calling <code class="Code-In-Text--PACKT-">next()</code> on it. This means that before sending anything to the coroutine, this has to be advanced at least once via the <code class="Code-In-Text--PACKT-">next()</code> method. Failure to do so will result in an exception:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; def coro():
...     y = yield
...
<span class="hljs-con-meta">&gt;</span>&gt;&gt; c = coro()
<span class="hljs-con-meta">&gt;</span>&gt;&gt; c.send(1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: can't send non-None value to a just-started generator
<span class="hljs-con-meta">&gt;</span>&gt;&gt;
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Always remember to advance a coroutine by calling <code class="Code-In-Text--PACKT-">next()</code> before sending any values to it.</p>
    </div>
    <p class="normal">Back to our example. We are changing the way elements are produced or streamed to make it able to receive the length of the records it expects to read from the database.</p>
    <p class="normal">The first time we call <code class="Code-In-Text--PACKT-">next()</code>, the generator will advance up to the line containing <code class="Code-In-Text--PACKT-">yield</code>; it will provide a value to the caller (<code class="Code-In-Text--PACKT-">None</code>, as set in the variable), and it will suspend there). From there, we have two options. If we choose to advance the generator by calling <code class="Code-In-Text--PACKT-">next()</code>, the default value of <code class="Code-In-Text--PACKT-">10</code> will be used, and it will go on with this as usual. This is because calling <code class="Code-In-Text--PACKT-">next()</code> is technically the same as <code class="Code-In-Text--PACKT-">send(None)</code>, but this is covered in the <code class="Code-In-Text--PACKT-">if</code> statement that will handle the value that we previously set.</p>
    <p class="normal">If, on the other hand, we decide to provide an explicit value via <code class="Code-In-Text--PACKT-">send(&lt;value&gt;)</code>, this one will become the result of the <code class="Code-In-Text--PACKT-">yield</code> statement, which will be assigned to the variable containing the length of the page to use, which, in turn, will be used to read from the database.</p>
    <p class="normal">Successive calls will have this logic, but the important point is that now we can dynamically change the length of the data to read in the middle of the iteration, at any point.</p>
    <p class="normal">Now that we understand <a id="_idIndexMarker495"/>how the previous code works, most Pythonistas would expect a simplified version of it (after all, Python is also about brevity and clean and compact code):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">stream_db_records</span><span class="hljs-function">(</span><span class="hljs-params">db_handler</span><span class="hljs-function">):</span>
    retrieved_data = <span class="hljs-literal">None</span>
    page_size = <span class="hljs-number">10</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            page_size = (<span class="hljs-keyword">yield</span> retrieved_data) <span class="hljs-keyword">or</span> page_size
            retrieved_data = db_handler.read_n_records(page_size)
    <span class="hljs-keyword">except</span> GeneratorExit:
        db_handler.close()
</code></pre>
    <p class="normal">This version is not only more compact, but it also illustrates the idea better. The parentheses around <code class="Code-In-Text--PACKT-">yield</code> makes it clearer that it's a statement (think of it as if it were a function call), and that we are using the result of it to compare it against the previous value.</p>
    <p class="normal">This works as we expect it does, but we always have to remember to advance the coroutine before sending any data to it. If we forget to call the first <code class="Code-In-Text--PACKT-">next()</code>, we'll get a <code class="Code-In-Text--PACKT-">TypeError</code>. This call could be ignored for our purposes because it doesn't return anything we'll use.</p>
    <p class="normal">It would be good if we could use the coroutine directly, right after it is created, without having to remember to call <code class="Code-In-Text--PACKT-">next()</code> the first time, every time we are going to use it. Some authors (PYCOOK) devised an interesting decorator to achieve this. The idea of this decorator is to advance the coroutine, so the following definition works automatically:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@prepare_coroutine</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">auto_stream_db_records</span><span class="hljs-function">(</span><span class="hljs-params">db_handler</span><span class="hljs-function">):</span>
    retrieved_data = <span class="hljs-literal">None</span>
    page_size = <span class="hljs-number">10</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
            page_size = (<span class="hljs-keyword">yield</span> retrieved_data) <span class="hljs-keyword">or</span> page_size
            retrieved_data = db_handler.read_n_records(page_size)
    <span class="hljs-keyword">except</span> GeneratorExit:
        db_handler.close()
</code></pre>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer = auto_stream_db_records(DBHandler(<span class="hljs-co -stri">"testdb"</span>))
<span class="hljs-con-meta">&gt;</span>&gt;&gt; len(streamer.send(5))
5
</code></pre>
    <p class="normal">Keep in mind, these <a id="_idIndexMarker496"/>are the fundamentals of how coroutines work in Python. By following these examples, you'll get an idea of what's actually going on in Python when working with coroutines. However, in modern Python, you wouldn't typically write these sorts of coroutines by yourself, because there's new syntax available (which we have mentioned, but we'll revisit to see how they relate to the ideas we have just seen).</p>
    <p class="normal">Before jumping into the new syntactic capabilities, we need to explore the last jump the coroutines took in terms of their added functionality, in order to bridge missing gaps. After that, we'll be able to understand the meaning behind each keyword and statement used in asynchronous programming.</p>
    <h2 id="_idParaDest-199" class="title">More advanced coroutines</h2>
    <p class="normal">So far, we have a better understanding of<a id="_idIndexMarker497"/> coroutines, and we can create simple ones to handle small tasks. We can say that these coroutines are, in fact, just more advanced generators (and that would be right, coroutines are just fancy generators), but, if we actually want to start supporting more complex scenarios, we usually have to go for a design that handles many coroutines concurrently, and that requires more features.</p>
    <p class="normal">When handling many coroutines, we find new problems. As the control flow of our application becomes more complex, we want to pass values up and down the stack (as well as exceptions), be able to capture values from sub-coroutines we might call at any level, and finally, schedule multiple coroutines to run toward a common goal.</p>
    <p class="normal">To make things simpler, generators had to be extended once again. That is what PEP-380 addressed by changing the semantics of generators so that they can return values and by introducing the new <code class="Code-In-Text--PACKT-">yield from</code> construction.</p>
    <h3 id="_idParaDest-200" class="title">Returning values in coroutines</h3>
    <p class="normal">As introduced<a id="_idIndexMarker498"/> at the beginning of this chapter, iteration is a <a id="_idIndexMarker499"/>mechanism that calls <code class="Code-In-Text--PACKT-">next()</code> on an iterable object many times until a <code class="Code-In-Text--PACKT-">StopIteration</code> exception is raised.</p>
    <p class="normal">So far, we have been exploring the iterative nature of generators—we produce values one at a time, and, in general, we only care about each value as it's being produced at every step of the <code class="Code-In-Text--PACKT-">for</code> loop. This is a very logical way of thinking about generators, but coroutines have a different idea; even though they are technically generators, they weren't conceived with the idea of iteration in mind, but with the goal of suspending the execution of code until it's resumed later on.</p>
    <p class="normal">This is an interesting challenge; when we design a coroutine, we usually care more about suspending the state rather than iterating (and iterating a coroutine would be an odd case). The challenge lies in that it is easy to mix them both. This is because of a technical implementation detail; the support for coroutines in Python was built upon generators.</p>
    <p class="normal">If we want to use coroutines to process some information and suspend its execution, it would make sense to think of them as lightweight threads (or green threads, as they are called in other platforms). In such a case, it would make sense if they could return values, much like calling any other regular function.</p>
    <p class="normal">But let's remember that generators are not regular functions, so in a generator, the construction <code class="Code-In-Text--PACKT-">value = generator()</code> will do nothing other than create a generator object. What would be the semantics for making a generator return a value? It will have to be after the iteration is done.</p>
    <p class="normal">When a generator returns a value, its iteration is immediately stopped (it can't be iterated any further). To preserve the semantics, the <code class="Code-In-Text--PACKT-">StopIteration</code> exception is still raised, and the value to be returned is stored inside the <code class="Code-In-Text--PACKT-">exception</code> object. It's the responsibility of the caller to catch it.</p>
    <p class="normal">In the following example, we are creating a simple generator that produces two values and then returns a third. Notice how we have to catch the exception in order to get this value, and how it's stored precisely inside the exception under the attribute named <code class="Code-In-Text--PACKT-">value</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; def generator():
...     yield 1
...     yield 2
...     return 3
... 
&gt;&gt;&gt; value = generator()
&gt;&gt;&gt; next(value)
1
&gt;&gt;&gt; next(value)
2
&gt;&gt;&gt; try:
...     next(value)
... except StopIteration as e:
...     print(f"&gt;&gt;&gt;&gt;&gt;&gt; returned value: {e.value}")
... 
&gt;&gt;&gt;&gt;&gt;&gt; returned value: 3
</code></pre>
    <p class="normal">As we'll see later, this<a id="_idIndexMarker500"/> mechanism is used to make coroutines return values. Before PEP-380, this didn't make any sense, and any attempt at having a <code class="Code-In-Text--PACKT-">return</code> <a id="_idIndexMarker501"/>statement inside a generator was considered a syntax error. But now, the idea is that, when the iteration is over, we want to return a final value, and the way to provide it is to store it in the exception being raised at the end of the iteration (<code class="Code-In-Text--PACKT-">StopIteration</code>). That might not be the cleanest approach, but it's completely backward-compatible, as it doesn't change the interface of the generator.</p>
    <h3 id="_idParaDest-201" class="title">Delegating into smaller coroutines – the 'yield from' syntax</h3>
    <p class="normal">The previous <a id="_idIndexMarker502"/>feature is interesting in the sense that it opens up a lot of new possibilities with coroutines (generators), now that they can return values. But this feature, by itself, would not be so useful without proper syntax support, because catching the returned value this way is a bit cumbersome.</p>
    <p class="normal">This is one of the main features <a id="_idIndexMarker503"/>of the <code class="Code-In-Text--PACKT-">yield from</code> syntax. Among other things (that we'll review in detail), it can collect the value returned by a sub-generator. Remember that we said that returning data in a generator was nice, but that, unfortunately, writing statements as <code class="Code-In-Text--PACKT-">value = generator()</code> wouldn't work? Well, writing them as <code class="Code-In-Text--PACKT-">value = yield from generator()</code> would.</p>
    <h4 class="title">The simplest use of yield from</h4>
    <p class="normal">In its most basic form, the <a id="_idIndexMarker504"/>new <code class="Code-In-Text--PACKT-">yield from</code> syntax can be used to chain generators from nested <code class="Code-In-Text--PACKT-">for</code> loops into a single one, which will end up with a single string of all the values in a continuous stream.</p>
    <p class="normal">A canonical example is about creating a function similar to <code class="Code-In-Text--PACKT-">itertools.chain()</code> from the <code class="Code-In-Text--PACKT-">standard</code> library. This is a very nice function because it allows you to pass any number of <code class="Code-In-Text--PACKT-">iterables</code> and will return them all together in one stream.</p>
    <p class="normal">The naïve implementation might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">chain</span><span class="hljs-function">(</span><span class="hljs-params">*iterables</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> iterables:
        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> it:
            <span class="hljs-keyword">yield</span> value
</code></pre>
    <p class="normal">It receives a variable number of <code class="Code-In-Text--PACKT-">iterables</code>, traverses through all of them, and since each value is iterable, it supports a <code class="Code-In-Text--PACKT-">for... in..</code> construction, so we have another <code class="Code-In-Text--PACKT-">for</code> loop to get every value inside each <a id="_idIndexMarker505"/>particular iterable, which is produced by the caller function. </p>
    <p class="normal">This might be helpful in multiple cases, such as chaining generators together or trying to iterate things that it wouldn't normally be possible to compare in one go (such as lists with tuples, and so on).</p>
    <p class="normal">However, the <code class="Code-In-Text--PACKT-">yield from</code> syntax allows us to go further and avoid the nested loop because it's able to produce the values from a sub-generator directly. In this case, we could simplify the code like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">chain</span><span class="hljs-function">(</span><span class="hljs-params">*iterables</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> iterables:
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> it
</code></pre>
    <p class="normal">Notice that for both implementations, the behavior of the generator is exactly the same:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; list(chain(<span class="hljs-co -stri">"hello"</span>, [<span class="hljs-co -stri">"world"</span>], (<span class="hljs-co -stri">"tuple"</span>, <span class="hljs-co -stri">" of "</span>, <span class="hljs-co -stri">"values."</span>)))
['h', 'e', 'l', 'l', 'o', 'world', 'tuple', ' of ', 'values.']
</code></pre>
    <p class="normal">This means that we can use <code class="Code-In-Text--PACKT-">yield from</code> over any other iterable, and it will work as if the top-level generator (the one the <code class="Code-In-Text--PACKT-">yield from</code> is using) were generating those values itself.</p>
    <p class="normal">This works with any iterable, and even generator expressions aren't the exception. Now that we're familiar with its syntax, let's see how we could write a simple generator function that will produce all the powers of a number (for instance, if provided with <code class="Code-In-Text--PACKT-">all_powers(2, 3)</code>, it will have to produce <code class="Code-In-Text--PACKT-">2^0</code>, <code class="Code-In-Text--PACKT-">2^1</code>,<code class="Code-In-Text--PACKT-">... 2^3</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">all_powers</span><span class="hljs-function">(</span><span class="hljs-params">n, </span><span class="hljs-built_in">pow</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> (n ** i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">pow</span> + <span class="hljs-number">1</span>))
</code></pre>
    <p class="normal">While this simplifies the syntax a bit, saving one line of a <code class="Code-In-Text--PACKT-">for</code> statement isn't a big advantage, and it wouldn't justify adding such a change to the language.</p>
    <p class="normal">Indeed, this is actually just a side effect and the real raison d'être of the <code class="Code-In-Text--PACKT-">yield from</code> construction is what we are going to explore in the following two sections.</p>
    <h4 class="title">Capturing the value returned by a sub-generator</h4>
    <p class="normal">In the following example, we have a <a id="_idIndexMarker506"/>generator that calls another two nested generators, producing values in a sequence. Each one of these nested generators returns a value, and we will see how the top-level generator is able to effectively capture the return value since it's calling the internal generators through <code class="Code-In-Text--PACKT-">yield from</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sequence</span><span class="hljs-function">(</span><span class="hljs-params">name, start, end</span><span class="hljs-function">):</span>
    logger.info(<span class="hljs-stri">"%s started at %i"</span>, name, start)
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> <span class="hljs-built_in">range</span>(start, end)
    logger.info(<span class="hljs-stri">"%s finished at %i"</span>, name, end)
    <span class="hljs-keyword">return</span> end
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function">():</span>
    step1 = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> sequence(<span class="hljs-stri">"first"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
    step2 = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> sequence(<span class="hljs-stri">"second"</span>, step1, <span class="hljs-number">10</span>)
    <span class="hljs-keyword">return</span> step1 + step2
</code></pre>
    <p class="normal">This is a possible execution of the code in <code class="Code-In-Text--PACKT-">main</code> while it's being iterated:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; g = main()
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
INFO:generators_yieldfrom_2:first started at 0
0
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
1
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
2
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
3
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
4
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
INFO:generators_yieldfrom_2:first finished at 5
INFO:generators_yieldfrom_2:second started at 5
5
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
6
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
7
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
8
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
9
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
INFO:generators_yieldfrom_2:second finished at 10
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration: 15
</code></pre>
    <p class="normal">The first <a id="_idIndexMarker507"/>line of <code class="Code-In-Text--PACKT-">main</code> delegates into the internal generator, and produces the values, extracting them directly from it. This is nothing new, as we have already seen. Notice, though, how the <code class="Code-In-Text--PACKT-">sequence()</code> generator function returns the end value, which is assigned in the first line to the variable named <code class="Code-In-Text--PACKT-">step1</code>, and how this value is correctly used at the start of the following instance of that generator.</p>
    <p class="normal">In the end, this other generator also returns the second end value (<code class="Code-In-Text--PACKT-">10</code>), and the main generator, in turn, returns the sum of them (<code class="Code-In-Text--PACKT-">5+10=15</code>), which is the value we see once the iteration has stopped.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">We can use <code class="Code-In-Text--PACKT-">yield from</code> to capture the last value of a coroutine after it has finished its processing.</p>
    </div>
    <p class="normal">With this example and the ones presented in the previous section, you can get an idea of what the <code class="Code-In-Text--PACKT-">yield from</code> construction does in Python. The <code class="Code-In-Text--PACKT-">yield from</code> construction will take the generator, and forward the iteration of it downstream, but once it's done, it'll catch its <code class="Code-In-Text--PACKT-">StopIteration</code> exception, get the value of it, and return that value to the caller function. The value attribute of the <code class="Code-In-Text--PACKT-">StopIteration</code> exception becomes the result of the statement.</p>
    <p class="normal">This is a powerful construction, because in conjunction with the topic of the next section (how to send and receive contextual information from a sub-generator), this means coroutines can take the shape of something similar to threads.</p>
    <h4 class="title">Sending and receiving data to and from a sub-generator</h4>
    <p class="normal">Now, we will<a id="_idIndexMarker508"/> see the other nice feature of the <code class="Code-In-Text--PACKT-">yield from</code> syntax, which<a id="_idIndexMarker509"/> is probably what gives it its full power. As <a id="_idIndexMarker510"/>we already introduced when we explored generators <a id="_idIndexMarker511"/>acting as coroutines, we know that we can send values and throw exceptions at them, and, in such cases, the coroutine will either receive the value for its internal processing, or it will have to handle the exception accordingly.</p>
    <p class="normal">If we now have a coroutine that delegates into other ones (such as in the previous example), we would also like to preserve this logic. Having to do so manually would be quite complex (you can take a look at the code described in PEP-380 if we didn't have this handled by <code class="Code-In-Text--PACKT-">yield from</code> automatically).</p>
    <p class="normal">In order to <a id="_idIndexMarker512"/>illustrate this, let's keep the same top-level generator (main) unmodified <a id="_idIndexMarker513"/>with respect to the previous example (calling other internal generators), but let's modify the internal generators to <a id="_idIndexMarker514"/>make them able to receive values and handle exceptions. </p>
    <p class="normal">The<a id="_idIndexMarker515"/> code is probably not idiomatic, only for the purposes of showing how this mechanism works:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">sequence</span><span class="hljs-function">(</span><span class="hljs-params">name, start, end</span><span class="hljs-function">):</span>
    value = start
    logger.info(<span class="hljs-stri">"%s started at %i"</span>, name, value)
    <span class="hljs-keyword">while</span> value &lt; end:
        <span class="hljs-keyword">try</span>:
            received = <span class="hljs-keyword">yield</span> value
            logger.info(<span class="hljs-stri">"%s received %r"</span>, name, received)
            value += <span class="hljs-number">1</span>
        <span class="hljs-keyword">except</span> CustomException <span class="hljs-keyword">as</span> e:
            logger.info(<span class="hljs-stri">"%s is handling %s"</span>, name, e)
            received = <span class="hljs-keyword">yield</span> <span class="hljs-stri">"OK"</span>
    <span class="hljs-keyword">return</span> end
</code></pre>
    <p class="normal">Now, we will call the <code class="Code-In-Text--PACKT-">main</code> coroutine, not only by iterating it, but also by providing values and throwing exceptions at it in order to see how they are handled inside sequence:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;</span>&gt;&gt; g = main()
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
INFO: first started at 0
0
<span class="hljs-con-meta">&gt;</span>&gt;&gt; next(g)
INFO: first received None
1
<span class="hljs-con-meta">&gt;</span>&gt;&gt; g.send(<span class="hljs-co -stri">"value for 1"</span>)
INFO: first received 'value for 1'
2
<span class="hljs-con-meta">&gt;</span>&gt;&gt; g.throw(CustomException(<span class="hljs-co -stri">"controlled error"</span>))
INFO: first is handling controlled error
'OK'
... # advance more times
INFO:second started at 5
5
<span class="hljs-con-meta">&gt;</span>&gt;&gt; g.throw(CustomException(<span class="hljs-co -stri">"exception at second generator"</span>))
INFO: second is handling exception at second generator
'OK'
</code></pre>
    <p class="normal">This <a id="_idIndexMarker516"/>example is telling us a lot of different things. Notice how we <a id="_idIndexMarker517"/>never send values to <code class="Code-In-Text--PACKT-">sequence</code>, but only to <code class="Code-In-Text--PACKT-">main</code>, and even so, the code that is receiving those values is the nested generators. Even though we never explicitly send anything to <code class="Code-In-Text--PACKT-">sequence</code>, it's receiving the data as it's being passed along by <code class="Code-In-Text--PACKT-">yield from</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">main</code> coroutine<a id="_idIndexMarker518"/> calls two other coroutines internally, producing their values, and it will be suspended at a particular point in time in any of those. When it's stopped at the first one, we can see the logs telling us that it is that instance of the coroutine that received the value we sent. The same happens when we throw an exception to it. When the first coroutine finishes, it returns the value that was assigned in the variable <a id="_idIndexMarker519"/>named <code class="Code-In-Text--PACKT-">step1</code>, and passed as input for the second coroutine, which will do the same (it will handle the <code class="Code-In-Text--PACKT-">send()</code> and <code class="Code-In-Text--PACKT-">throw()</code> calls, accordingly).</p>
    <p class="normal">The same happens for the values that each coroutine produces. When we are at any given step, the return from calling <code class="Code-In-Text--PACKT-">send()</code> corresponds to the value that the sub-coroutine (the one that <code class="Code-In-Text--PACKT-">main</code> is currently suspended at) has produced. When we throw an exception that is being handled, the <code class="Code-In-Text--PACKT-">sequence</code> coroutine produces the value <code class="Code-In-Text--PACKT-">OK</code>, which is propagated to the called coroutine (<code class="Code-In-Text--PACKT-">main</code>), and that in turn will end up at <code class="Code-In-Text--PACKT-">main's</code> caller.</p>
    <p class="normal">As anticipated, these methods, together with <code class="Code-In-Text--PACKT-">yield from</code>, provide us with a lot of new functionality (something that can resemble threads). This opens up the doors for asynchronous programming, which we will explore next.</p>
    <h1 id="_idParaDest-202" class="title">Asynchronous programming</h1>
    <p class="normal">With the <a id="_idIndexMarker520"/>constructions we have seen so far, we can create asynchronous programs in Python. This means that we can create programs that have many coroutines, schedule them to work in a particular order, and switch between them when they're suspended after a <code class="Code-In-Text--PACKT-">yield from</code> has been called on each of them.</p>
    <p class="normal">The main advantage that we can take from this is the possibility of parallelizing I/O operations in a non-blocking way. What we would need is a low-level generator (usually implemented by a third-party library) that knows how to handle the actual I/O while the coroutine is suspended. The idea is for the coroutine to effect suspension so that our program can handle another task in the meantime. The way the application would retrieve the control back is by means of the <code class="Code-In-Text--PACKT-">yield from</code> statement, which will suspend and produce a value to the caller (as in the examples we saw previously when we used this syntax to alter the control flow of the program).</p>
    <p class="normal">This is roughly the way<a id="_idIndexMarker521"/> asynchronous programming had been working in Python for quite a few years, until it was decided that better syntactic support was needed.</p>
    <p class="normal">The fact that coroutines and generators are technically the same causes some confusion. Syntactically (and technically), they are the same, but semantically, they are different. We create generators when we want to achieve efficient iteration. We typically create coroutines with the goal of running non-blocking I/O operations.</p>
    <p class="normal">While this difference is clear, the dynamic nature of Python would still allow developers to mix these different types of objects, ending up with a runtime error at a very late stage of the program. Remember that in the simplest and most basic form of the <code class="Code-In-Text--PACKT-">yield from</code> syntax, we used this construction over iterable objects (we created a sort of <code class="Code-In-Text--PACKT-">chain</code> function applied over strings, lists, and so on). None of these objects were coroutines, and it still worked. Then, we saw that we can have multiple coroutines, use <code class="Code-In-Text--PACKT-">yield from</code> to send the value (or exceptions), and get some results back. These are clearly two very different use cases; however, if we write something along the lines of the following statement:</p>
    <pre class="programlisting code"><code class="hljs-code">result = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> iterable_or_awaitable()
</code></pre>
    <p class="normal">It's not clear what <code class="Code-In-Text--PACKT-">iterable_or_awaitable</code> returns. It can be a simple iterable such as a <code class="Code-In-Text--PACKT-">string</code>, and it might still be syntactically correct. Or, it might be an actual coroutine. The cost of this mistake will be paid much later, at runtime.</p>
    <p class="normal">For this reason, the typing system in Python had to be extended. Before Python 3.5, coroutines were just generators with a <code class="Code-In-Text--PACKT-">@coroutine</code> decorator applied, and they were to be called with the <code class="Code-In-Text--PACKT-">yield from</code> syntax. Now, there is a specific type of object the Python interpreter recognizes as such, that is, a coroutine.</p>
    <p class="normal">This change heralded syntax changes as well. The <code class="Code-In-Text--PACKT-">await</code> and <code class="Code-In-Text--PACKT-">async def</code> syntax were introduced. The former is intended to be used instead of <code class="Code-In-Text--PACKT-">yield from</code>, and it only works with <code class="Code-In-Text--PACKT-">awaitable</code> objects (which coroutines conveniently happen to be). Trying to call <code class="Code-In-Text--PACKT-">await</code> with something that doesn't respect the interface of an <code class="Code-In-Text--PACKT-">awaitable</code> will raise an exception (this is a good example of how interfaces can help to achieve a more solid design, preventing runtime errors).</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">async def</code> is the new way of defining coroutines, replacing the aforementioned decorator, and this actually creates an object that, when called, will return an instance of a coroutine. In the same way as when you invoke a generator function, the interpreter will return you a generator object, when you invoke an object defined with <code class="Code-In-Text--PACKT-">async def</code>, it'll give you a coroutine object that has an <code class="Code-In-Text--PACKT-">__await__</code> method, and therefore can be used in await expressions.</p>
    <p class="normal">Without going into all the details and possibilities of asynchronous programming in Python, we can say that despite the new syntax and the new types, this is not doing anything fundamentally different from the concepts we have covered in this chapter.</p>
    <p class="normal">The idea behind programming<a id="_idIndexMarker522"/> asynchronously in Python is that there is an <code class="Code-In-Text--PACKT-">event</code> loop (typically <code class="Code-In-Text--PACKT-">asyncio</code> because it's the one that is included in the <code class="Code-In-Text--PACKT-">standard</code> library, but there are many others that will work just the same) that manages a series of coroutines. These coroutines belong to the event loop, which is going to call them according to its scheduling mechanism. When each one of these runs, it will call our code (according to the logic we have defined inside the coroutine we programmed), and when we want to get control back to the event loop, we call <code class="Code-In-Text--PACKT-">await &lt;coroutine&gt;</code>, which will process a task asynchronously. The event loop will resume and another coroutine will take place while that operation is left running.</p>
    <p class="normal">This mechanism represents the basics of how asynchronous programming works in Python. You can think that the new syntax added for coroutines (<code class="Code-In-Text--PACKT-">async def</code> / <code class="Code-In-Text--PACKT-">await</code>) is just an API for you to write code in a way that's going to be called by the event loop. By default, that event loop will typically be <code class="Code-In-Text--PACKT-">asyncio</code> because it's the one that comes in the <code class="Code-In-Text--PACKT-">standard</code> library, but any event loop system that matches the API would work. This means you can use libraries<a id="_idIndexMarker523"/> like <code class="Code-In-Text--PACKT-">uvloop</code> (<a href="https://github.com/MagicStack/uvloop"><span class="url">https://github.com/MagicStack/uvloop</span></a>) and <code class="Code-In-Text--PACKT-">trio</code> (<a href="https://github.com/python-trio/trio"><span class="url">https://github.com/python-trio/trio</span></a>), and the code would work the<a id="_idIndexMarker524"/> same. You can even register your own event loop, and it should also work the same (provided compliance with the API, that is).</p>
    <p class="normal">In practice, there are more particularities and edge cases that are beyond the scope of this book. It is, however, worth mentioning that these concepts are related to the ideas introduced in this chapter and that this arena is another place where generators demonstrate being a core concept of the language, as there are many things constructed on top of them.</p>
    <h2 id="_idParaDest-203" class="title">Magic asynchronous methods</h2>
    <p class="normal">I've made the case in <a id="_idIndexMarker525"/>previous chapters (and hopefully convinced you) that whenever possible, we can take advantage of the magic methods in Python in order to make the abstractions we created blend naturally with the syntax of the language and this way achieve better, more compact, and perhaps cleaner code.</p>
    <p class="normal">But what happens if on any of these methods we need to call a coroutine? If we have to call <code class="Code-In-Text--PACKT-">await</code> in a function, that means the function itself would have to be a coroutine (defined with <code class="Code-In-Text--PACKT-">async def</code>), or else there will be a syntax error.</p>
    <p class="normal">But then, how does this work with the current syntax and magic methods? It doesn't. We need new syntax, and new magic methods, in order to work with asynchronous programming. The good news is that they're analogous to the previous ones.</p>
    <p class="normal">Here's a summary of the new magic methods and how they relate to the new syntax.</p>
    <table id="table002" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Concept</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Magic methods</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Syntax usage</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Context manager</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">__aenter__</code></p>
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">__aexit__</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">async with async_cm() as x:</code></p>
            <p class="Table-Column-Content--PACKT-">...</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Iteration</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">__aiter__</code></p>
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">__anext__</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">async for e in aiter:</code></p>
            <p class="Table-Column-Content--PACKT-">...</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 7.2: Asynchronous syntax and their magic methods</p>
    <p class="normal">This new syntax is mentioned in PEP-492 (<a href="https://www.python.org/dev/peps/pep-0492/"><span class="url">https://www.python.org/dev/peps/pep-0492/</span></a>).</p>
    <h3 id="_idParaDest-204" class="title">Asynchronous context managers</h3>
    <p class="normal">The idea is simple: if we were to use a <a id="_idIndexMarker526"/>context manager but needed to call a coroutine on it, we couldn't use the normal <code class="Code-In-Text--PACKT-">__enter__</code> and <code class="Code-In-Text--PACKT-">__exit__</code> methods because they're defined as regular functions, so instead we need to use the new <code class="Code-In-Text--PACKT-">__aenter__</code> and <code class="Code-In-Text--PACKT-">__aexit__</code> coroutine methods. And instead of calling it merely using with, we'd have to use <code class="Code-In-Text--PACKT-">async</code> with.</p>
    <p class="normal">There's even an <code class="Code-In-Text--PACKT-">@asynccontextmanager</code> decorator available in the <code class="Code-In-Text--PACKT-">contextlib</code> module, to create an asynchronous context manager in the same way as shown before.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">async</code> with syntax for asynchronous context managers works in a similar way: when the context is entered, the <code class="Code-In-Text--PACKT-">__aenter__</code> coroutine is called automatically, and when it's being exited, <code class="Code-In-Text--PACKT-">__aexit__</code> will trigger. It's even possible to group multiple asynchronous context managers in the same <code class="Code-In-Text--PACKT-">async</code> with statement, but it's not possible to mix them with regular ones. An attempt of using a regular context manager with the <code class="Code-In-Text--PACKT-">async</code> with syntax will fail with an <code class="Code-In-Text--PACKT-">AttributeError</code>.</p>
    <p class="normal">Our example from <em class="chapterRef">Chapter 2</em>, <em class="italic">Pythonic Code</em>, would look like the following code if adapted to asynchronous programming:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@contextlib.asynccontextmanager</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">db_management</span><span class="hljs-function">():</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">await</span> stop_database()
        <span class="hljs-keyword">yield</span>
    <span class="hljs-keyword">finally</span>:
        <span class="hljs-keyword">await</span> start_database()
</code></pre>
    <p class="normal">Moreover, if we had more than <a id="_idIndexMarker527"/>one context manager that we wanted to use, we could do, for example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@contextlib.asynccontextmanager</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">metrics_logger</span><span class="hljs-function">():</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">await</span> create_metrics_logger()
 
 
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">run_db_backup</span><span class="hljs-function">():</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> db_management(), metrics_logger():
        print(<span class="hljs-stri">"Performing DB backup..."</span>)
</code></pre>
    <p class="normal">As you'd expect, the <code class="Code-In-Text--PACKT-">contextlib</code> module provides the abstract base class <code class="Code-In-Text--PACKT-">AbstractAsyncContextManager</code>, which requires the implementation of the <code class="Code-In-Text--PACKT-">__aenter__</code> and <code class="Code-In-Text--PACKT-">__aexit__</code> methods.</p>
    <h3 id="_idParaDest-205" class="title">Other magic methods</h3>
    <p class="normal">What happens with the rest of the <a id="_idIndexMarker528"/>magic methods? Do they all get their asynchronous counterpart? No, but there's something I wanted to point out about that: it shouldn't be needed.</p>
    <p class="normal">Remember that achieving clean code is in part about making sure you distribute the responsibilities correctly in the code and place things in their proper places. To give an example, if you're thinking about calling a coroutine inside a <code class="Code-In-Text--PACKT-">__getattr__</code> method, there's something probably amiss in your design, as there should probably be a better place for that coroutine.</p>
    <p class="normal">Coroutines that we await are used in order to have parts of our code running concurrently, so they typically relate to external resources being managed, whereas the logic we put in the rest of the magic methods <code class="Code-In-Text--PACKT-">(__getitem__</code>, <code class="Code-In-Text--PACKT-">__getattr__</code>, etc.) should be object-oriented code, or code that can be resolved in terms of solely the internal representation of that object.</p>
    <p class="normal">By the same token (and also following up on good design practices), it wouldn't be good to make <code class="Code-In-Text--PACKT-">__init__</code> a coroutine, because we typically want lightweight objects that we can initialize safely without side effects. Even better, we have already covered the benefits of using dependency injection, so that's even more reason not to want an asynchronous initialization method: our object should work with dependencies already initialized.</p>
    <p class="normal">The second case <a id="_idIndexMarker529"/>of the previous table, asynchronous iteration, is of more interest for the purposes of this chapter, so we'll explore it in the next section.</p>
    <p class="normal">The syntax for asynchronous iteration (<code class="Code-In-Text--PACKT-">async</code> for) works with any asynchronous iterator, whether it is created by us (as we'll see how to do in the next section), or whether it's an asynchronous generator (which we'll see in the section after that).</p>
    <h2 id="_idParaDest-206" class="title">Asynchronous iteration</h2>
    <p class="normal">In the same way<a id="_idIndexMarker530"/> that we have the iterator objects we saw at the beginning of the chapter (that is, objects that support being iterated over with Python's built-in <code class="Code-In-Text--PACKT-">for</code> loop), we can do the same, but in an asynchronous fashion.</p>
    <p class="normal">Imagine we want to create an iterator to abstract the way in which we read data from an external source (like a database), but the part that extracts the data itself is a coroutine, so we couldn't call it during the already familiar <code class="Code-In-Text--PACKT-">__next__</code> operation as before. That's why we need to make use of the <code class="Code-In-Text--PACKT-">__anext__</code> coroutine.</p>
    <p class="normal">The following example illustrates in a simple way how this can be achieved. Disregarding external dependencies, or any other accidental complexity, we'll focus on the methods that make this type of operation possible, in order to study them:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">import</span> random
 
 
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">coroutine</span><span class="hljs-function">():</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">0.1</span>)
    <span class="hljs-keyword">return</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>)
 
 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">RecordStreamer</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, max_rows=</span><span class="hljs-number">100</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self._current_row = <span class="hljs-number">0</span>
        self._max_rows = max_rows
 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__aiter__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">return</span> self
 
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__anext__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">if</span> self._current_row &lt; self._max_rows:
            row = (self._current_row, <span class="hljs-keyword">await</span> coroutine())
            self._current_row += <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> row
        <span class="hljs-keyword">raise</span> StopAsyncIteration
</code></pre>
    <p class="normal">The first method, <code class="Code-In-Text--PACKT-">__aiter__</code>, is used<a id="_idIndexMarker531"/> to indicate that the object is an asynchronous iterator. Just as in the synchronous version, most of the time it's enough to return self, and therefore it doesn't need to be a coroutine.</p>
    <p class="normal">But <code class="Code-In-Text--PACKT-">__anext__</code>, on the other hand, is precisely the part of our code where our asynchronous logic lies, so that needs to be a coroutine for starters. In this case, we're awaiting another coroutine in order to return part of the data to be returned.</p>
    <p class="normal">It also needs a separate exception in order to signal the end of the iteration, in this case, called <code class="Code-In-Text--PACKT-">StopAsyncIteration</code>.</p>
    <p class="normal">This exception works in an analogous way, only that it's meant for the <code class="Code-In-Text--PACKT-">async for</code> kind of loops. When encountered, the interpreter will finish the loop.</p>
    <p class="normal">This sort of object can be used in the following form:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> RecordStreamer(<span class="hljs-number">10</span>):
    ...
</code></pre>
    <p class="normal">You can clearly see how this is analogous to the synchronous version we explored at the beginning of the chapter. One important distinction though is that, as we would expect, the <code class="Code-In-Text--PACKT-">next()</code> function wouldn't work on this object (it doesn't implement <code class="Code-In-Text--PACKT-">__next__</code> after all), so advancing an asynchronous generator by one place would require a different idiom.</p>
    <p class="normal">Advancing the asynchronous iterator by one place could be achieved by doing something like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">await</span> async_iterator.__anext__()
</code></pre>
    <p class="normal">But more interesting constructions, like the ones we saw before about using the <code class="Code-In-Text--PACKT-">next()</code> function to work over a generator expression to search for the first value that meets certain conditions, wouldn't be supported, because they're not capable of handling asynchronous iterators.</p>
    <p class="normal">Inspired by the previous<a id="_idIndexMarker532"/> idiom, we can create a generator expression using the asynchronous iteration, and then take the first value from it. Better yet, we can create our own version of this function to work with asynchronous generators, which might look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">NOT_SET = <span class="hljs-built_in">object</span>()
 
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">anext</span><span class="hljs-function">(</span><span class="hljs-params">async_generator_expression, default=NOT_SET</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> async_generator_expression.__anext__()
    <span class="hljs-keyword">except</span> StopAsyncIteration:
        <span class="hljs-keyword">if</span> default <span class="hljs-keyword">is</span> NOT_SET:
            <span class="hljs-keyword">raise</span>
        <span class="hljs-keyword">return</span> default
</code></pre>
    <p class="normal">Starting from Python 3.8, the <code class="Code-In-Text--PACKT-">asyncio</code> module has a nice capability that allows us to interact with coroutines directly from the REPL. That way, we can test interactively how the previous code would work:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$</span> python -m asyncio
<span class="hljs-con-meta">&gt;</span>&gt;&gt; streamer = RecordStreamer(10)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; await anext(streamer)
(0, 5017)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; await anext(streamer)
(1, 5257)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; await anext(streamer)
(2, 3507)
...
<span class="hljs-con-meta">&gt;</span>&gt;&gt; await anext(streamer)
(9, 5440)
<span class="hljs-con-meta">&gt;</span>&gt;&gt; await anext(streamer)
Traceback (most recent call last):
    ...
    raise StopAsyncIteration
StopAsyncIteration
<span class="hljs-con-meta">&gt;</span>&gt;&gt;
</code></pre>
    <p class="normal">You'll note that it resembles the original <code class="Code-In-Text--PACKT-">next()</code> function both in terms of interface and behavior.</p>
    <p class="normal">Now we know how to use iteration in <a id="_idIndexMarker533"/>asynchronous programming, but we can do better than that. Most of the time we just need a generator and not a whole iterator object. Generators have the advantage that their syntax makes them easier to write and understand, so in the next section, I'll mention how to create generators for asynchronous programs.</p>
    <h2 id="_idParaDest-207" class="title">Asynchronous generators</h2>
    <p class="normal">Before Python 3.6, the functionality <a id="_idIndexMarker534"/>explored in the previous section was the only way to achieve asynchronous iteration in Python. Because of the intricacies of the coroutines and generators we explored in previous sections, trying to use the <code class="Code-In-Text--PACKT-">yield</code> statement inside a coroutine was not entirely defined, hence not allowed (for example, would <code class="Code-In-Text--PACKT-">yield</code> try to suspend the coroutine, or generate a value for the caller?).</p>
    <p class="normal">Asynchronous generators were introduced in PEP-525 (<a href="https://www.python.org/dev/peps/pep-0525/"><span class="url">https://www.python.org/dev/peps/pep-0525/</span></a>).</p>
    <p class="normal">The issue with the use of the <code class="Code-In-Text--PACKT-">yield</code> keyword inside a coroutine was solved in this PEP, and it's now allowed, but with a different and clear meaning. Unlike the first example of coroutines we have seen, <code class="Code-In-Text--PACKT-">yield</code> inside a coroutine properly defined (with <code class="Code-In-Text--PACKT-">async</code> def) doesn't mean to suspend or pause the execution of that coroutine, but instead to produce a value for the caller. This is an asynchronous generator: same as the generators we've seen at the very beginning of the chapter, but that can be used in an asynchronous way (meaning they probably await other coroutines inside their definition).</p>
    <p class="normal">The main advantage of asynchronous generators over iterators is the same advantage regular generators have; they allow us to achieve the same thing but in a more compact way.</p>
    <p class="normal">As promised, the previous example looks more compact when written with an asynchronous generator:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">record_streamer</span><span class="hljs-function">(</span><span class="hljs-params">max_rows</span><span class="hljs-function">):</span>
    current_row = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> current_row &lt; max_rows:
        row = (current_row, <span class="hljs-keyword">await</span> coroutine())
        current_row += <span class="hljs-number">1</span>
        <span class="hljs-keyword">yield</span> row
</code></pre>
    <p class="normal">This feels closer to <a id="_idIndexMarker535"/>a regular generator as the structure is the same except for the <code class="Code-In-Text--PACKT-">async def</code> / <code class="Code-In-Text--PACKT-">await</code> construction. Moreover, you'll have to remember fewer details (as to the methods that need implementation and the right exception that has to be triggered), so I'd recommend that whenever possible you try to favor asynchronous generators over iterators.</p>
    <p class="normal">This concludes our journey through iteration in Python and asynchronous programming. In particular, this last topic we've just explored is the pinnacle of it, because it relates to all the concepts we've learned in this chapter.</p>
    <h1 id="_idParaDest-208" class="title">Summary</h1>
    <p class="normal">Generators are everywhere in Python. Since their inception in Python a long time ago, they proved to be a great addition that makes programs more efficient and iteration much simpler.</p>
    <p class="normal">As time passed by, and more complex tasks needed to be added to Python, generators helped again in supporting coroutines.</p>
    <p class="normal">And, while in Python coroutines are generators, we still don't have to forget that they're semantically different. Generators are created with the idea of iteration, while coroutines have the goal of asynchronous programming (suspending and resuming the execution of a part of our program at any given time). This distinction became so important that it made Python's syntax (and type system) evolve.</p>
    <p class="normal">Iteration and asynchronous programming constitute the last of the main pillars of Python programming. Now, it's time to see how everything fits together and to put all of these concepts we have been exploring over the past few chapters into action. This means that by now, you have a complete understanding of Python's capabilities.</p>
    <p class="normal">It's now time to use this to your advantage, so in the next chapters, we'll see how to put these concepts into action, related to more general ideas of software engineering, such as testing, design patterns, and architecture.</p>
    <p class="normal">We'll start this new part of our journey by exploring unit testing and refactoring in the next chapter.</p>
    <h1 id="_idParaDest-209" class="title">References</h1>
    <p class="normal">Here is a list of information you can refer to:</p>
    <ul>
      <li class="bullet"><em class="italic">PEP-234</em>: <em class="italic">Iterators</em> (<a href="https://www.python.org/dev/peps/pep-0234/"><span class="url">https://www.python.org/dev/peps/pep-0234/</span></a>)</li>
      <li class="bullet"><em class="italic">PEP-255</em>: <em class="italic">Simple Generators</em> (<a href="https://www.python.org/dev/peps/pep-0255/"><span class="url">https://www.python.org/dev/peps/pep-0255/</span></a>)</li>
      <li class="bullet"><em class="italic">ITER-01</em>: <em class="italic">Python's itertools module</em> (<a href="https://docs.python.org/3/library/itertools.html"><span class="url">https://docs.python.org/3/library/itertools.html</span></a>)</li>
      <li class="bullet"><em class="italic">GoF</em>: The book written by <em class="italic">Erich Gamma</em>, <em class="italic">Richard Helm</em>, <em class="italic">Ralph Johnson</em>, and <em class="italic">John Vlissides</em> named <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em></li>
      <li class="bullet"><em class="italic">PEP-342</em>: <em class="italic">Coroutines via Enhanced Generators</em> (<a href="https://www.python.org/dev/peps/pep-0342/"><span class="url">https://www.python.org/dev/peps/pep-0342/</span></a>)</li>
      <li class="bullet"><em class="italic">PYCOOK</em>: The book written by <em class="italic">Brian Jones</em> and <em class="italic">David Beazley</em> named <em class="italic">Python Cookbook: Recipes for Mastering Python 3, Third Edition</em></li>
      <li class="bullet"><em class="italic">PY99</em>: <em class="italic">Fake threads (generators, coroutines, and continuations)</em> (<a href="https://mail.python.org/pipermail/python-dev/1999-July/000467.html"><span class="url">https://mail.python.org/pipermail/python-dev/1999-July/000467.html</span></a>)</li>
      <li class="bullet"><em class="italic">CORO-01</em>: <em class="italic">Co Routine</em> (<a href="http://wiki.c2.com/?CoRoutine"><span class="url">http://wiki.c2.com/?CoRoutine</span></a>)</li>
      <li class="bullet"><em class="italic">CORO-02</em>: <em class="italic">Generators Are Not Coroutines</em> (<a href="http://wiki.c2.com/?GeneratorsAreNotCoroutines"><span class="url">http://wiki.c2.com/?GeneratorsAreNotCoroutines</span></a>)</li>
      <li class="bullet"><em class="italic">PEP-492</em>: <em class="italic">Coroutines with async and await syntax</em> (<a href="https://www.python.org/dev/peps/pep-0492/"><span class="url">https://www.python.org/dev/peps/pep-0492/</span></a>)</li>
      <li class="bullet"><em class="italic">PEP-525</em>: <em class="italic">Asynchronous Generators</em> (<a href="https://www.python.org/dev/peps/pep-0525/"><span class="url">https://www.python.org/dev/peps/pep-0525/</span></a>)</li>
      <li class="bullet"><em class="italic">TEE</em>: <em class="italic">The itertools.tee function</em> (<a href="https://docs.python.org/3/library/itertools.html#itertools.tee"><span class="url">https://docs.python.org/3/library/itertools.html#itertools.tee</span></a>)</li>
    </ul>
  </div>
</body></html>