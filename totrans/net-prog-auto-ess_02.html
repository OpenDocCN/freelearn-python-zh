<html><head></head><body>
<div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.2.1">Programmable Networks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Initially, computer networks were something physical and static, with wires and hardware, but with advanced computation, virtualization, and connectivity, networks have become more flexible and configurable by software. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we’re going to talk about how software has changed the picture for computer networks. </span><span class="koboSpan" id="kobo.3.3">We are going first to examine several different technologies used today to create networks via software, then we are going to examine the current standard technology, known as </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">software-defined networks</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SDNs</span></strong><span class="koboSpan" id="kobo.7.1">).</span></p>
<p><span class="koboSpan" id="kobo.8.1">As we saw in the first chapter, computer networks can be quite complex and difficult to maintain. </span><span class="koboSpan" id="kobo.8.2">There are several different sets of equipment that range from routers, switches, and NATs to load balancers and more. </span><span class="koboSpan" id="kobo.8.3">In addition, within each piece of equipment, there are several different types of operation, such as </span><em class="italic"><span class="koboSpan" id="kobo.9.1">core</span></em><span class="koboSpan" id="kobo.10.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.11.1">access</span></em><span class="koboSpan" id="kobo.12.1"> routers. </span><span class="koboSpan" id="kobo.12.2">Network equipment is typically configured individually with interfaces that are very different between each vendor. </span><span class="koboSpan" id="kobo.12.3">Although there are management systems that can help centralize the configuration in one single place, network equipment is configured at an individual level. </span><span class="koboSpan" id="kobo.12.4">This kind of operation means complexity in operation and slow innovation for new features.</span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we are going to cover the following topics:</span></p>
<ul>
<li><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.14.1">Exploring the history of programmable networks and looking at those used in the present day</span></li>
<li><span class="koboSpan" id="kobo.15.1">Virtual network technologies</span></li>
<li><span class="koboSpan" id="kobo.16.1">SDNs and OpenFlow</span></li>
<li><span class="koboSpan" id="kobo.17.1">Understanding cloud computing </span></li>
<li><span class="koboSpan" id="kobo.18.1">Using OpenStack for networking</span></li>
</ul>
<h1 id="_idParaDest-44"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.19.1">Exploring the history of programmable networks and looking at those used in the present day </span></h1>
<p><span class="koboSpan" id="kobo.20.1">Several years have passed since </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">programmable networks</span></strong><span class="koboSpan" id="kobo.22.1"> were initially conceived by engineers, so let’s touch</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.23.1"> on a few historical milestones before we get into the current technologies.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.24.1">Active networking</span></h2>
<p><span class="koboSpan" id="kobo.25.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">Defense Advanced Research Projects Agency</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">DARPA</span></strong><span class="koboSpan" id="kobo.29.1">) began funding research</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.30.1"> in the mid-1990s to create a network</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.31.1"> that could easily be changed</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.32.1"> and customized by programming, called the </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">active networking</span></strong><span class="koboSpan" id="kobo.34.1"> project. </span><span class="koboSpan" id="kobo.34.2">The main goal of the project was to create network technologies that, in contrast to then-current networks, were easy to innovate and evolve, allowing fast application and protocol development.</span></p>
<p><span class="koboSpan" id="kobo.35.1">But it was not easy to create such a flexible network in the 1990s because programming languages, signaling and network protocols, and operating systems were not mature enough to accommodate such innovative ideas. </span><span class="koboSpan" id="kobo.35.2">For instance, operation systems were monolithic and adding features required recompilation and reboot. </span><span class="koboSpan" id="kobo.35.3">In addition, service APIs were non-existent and distributed programming languages were still in early development.</span></p>
<p><span class="koboSpan" id="kobo.36.1">The active networking research programs explored radical alternatives to the services provided by the traditional internet</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.37.1"> stack via IP. </span><span class="koboSpan" id="kobo.37.2">Examples of</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.38.1"> this work can be found in projects such as </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Global Environment for Network Innovations</span></strong><span class="koboSpan" id="kobo.40.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.41.1">GENIs</span></strong><span class="koboSpan" id="kobo.42.1">), which can be viewed</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.43.1"> at </span><a href="https://www.geni.net/"><span class="koboSpan" id="kobo.44.1">https://www.geni.net/</span></a><span class="koboSpan" id="kobo.45.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">Nacional Science Foundation</span></strong><span class="koboSpan" id="kobo.47.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.48.1">NSF</span></strong><span class="koboSpan" id="kobo.49.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Future Internet Design</span></strong><span class="koboSpan" id="kobo.51.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.52.1">FIND</span></strong><span class="koboSpan" id="kobo.53.1">) which can be viewed</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.54.1"> at </span><a href="http://www.nets-find.net/"><span class="koboSpan" id="kobo.55.1">http://www.nets-find.net/</span></a><span class="koboSpan" id="kobo.56.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">Future Internet Research and Experimentation Initiative</span></strong><span class="koboSpan" id="kobo.58.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.59.1">EU FIRE</span></strong><span class="koboSpan" id="kobo.60.1">).</span></p>
<p><span class="koboSpan" id="kobo.61.1">At the time, the active networking research community pursued two programming models:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.62.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">capsule model</span></strong><span class="koboSpan" id="kobo.64.1">, where the code to execute</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.65.1"> at the nodes was carried in-band in data packets</span></li>
<li><span class="koboSpan" id="kobo.66.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">programmable router/switch model</span></strong><span class="koboSpan" id="kobo.68.1">, where the code to execute at the</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.69.1"> nodes was established</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.70.1"> by out-of-band</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.71.1"> mechanisms</span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.72.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.73.1">Further reading can be found in </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Active Networking – One View of the Past, Present, and Future</span></em><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">Jonathan M. </span><span class="koboSpan" id="kobo.75.3">Smith and Scott M. </span><span class="koboSpan" id="kobo.75.4">Nettles – </span><em class="italic"><span class="koboSpan" id="kobo.76.1">IEEE TRANSACTIONS ON SYSTEMS - PART C: Application and Reviews, Vol 34 No 1, February 2004.</span></em></p>
<p><span class="koboSpan" id="kobo.77.1">Let’s dive into one of the first attempts at creating a node that was programmable, known as </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">NodeOS</span></strong><span class="koboSpan" id="kobo.79.1">.</span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.80.1">NodeOS</span></h2>
<p><span class="koboSpan" id="kobo.81.1">One of the first goals</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.82.1"> of the active networking</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.83.1"> project was to create </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">NodeOS</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">It was an operating system whose primary purpose was to support packet forwarding in an active network. </span><span class="koboSpan" id="kobo.85.3">NodeOS ran at the lowest level in an active node and multiplexed the node resources, such as memory and CPU, among the packet flows that traverse the node. </span><span class="koboSpan" id="kobo.85.4">NodeOS provided several important services to active network execution environments, including resource scheduling and accounting and fast packet input-output. </span><span class="koboSpan" id="kobo.85.5">The two important</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.86.1"> design milestones on NodeOS were the creation of </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">application programming interfaces</span></strong><span class="koboSpan" id="kobo.88.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.89.1">APIs</span></strong><span class="koboSpan" id="kobo.90.1">) and resource management.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.91.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.92.1">Additional reading on NodeOS can be found at </span><em class="italic"><span class="koboSpan" id="kobo.93.1">An OS Interface for Active Routers April 2001</span></em><span class="koboSpan" id="kobo.94.1"> – </span><em class="italic"><span class="koboSpan" id="kobo.95.1">IEEE Journal on Selected Areas in Communications 19(3):473 – 487.</span></em></p>
<p><span class="koboSpan" id="kobo.96.1">Following this, we are now going to explore a few projects that were the early attempts from the community toward SDN.</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.97.1">Data and control plane separation</span></h2>
<p><span class="koboSpan" id="kobo.98.1">One of the major</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.99.1"> steps toward</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.100.1"> programmable</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.101.1"> networks and </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">SDNs</span></strong><span class="koboSpan" id="kobo.103.1"> was the separation of the </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">control</span></strong><span class="koboSpan" id="kobo.105.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">data </span></strong><span class="koboSpan" id="kobo.107.1">planes. </span><span class="koboSpan" id="kobo.107.2">In </span><a href="B18165_01.xhtml#_idTextAnchor015"><em class="italic"><span class="koboSpan" id="kobo.108.1">Chapter 1</span></em></a><span class="koboSpan" id="kobo.109.1">, we discussed the difference between the control and data planes, and here we are going to discuss a bit of the history behind them. </span><span class="koboSpan" id="kobo.109.2">It’s worth</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.110.1"> remembering that the data plane is also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">forwarding plane</span></strong><span class="koboSpan" id="kobo.112.1">.</span></p>
<p><span class="koboSpan" id="kobo.113.1">By the 1990s, such separation was already present on public telephone networks but was not yet implemented in computer networks or on the internet. </span><span class="koboSpan" id="kobo.113.2">As network complexity increased and internet services started to become the main revenue for several backbone providers, reliability, predictability, and performance were key points for network operators to seek better approaches for managing networks.</span></p>
<p><span class="koboSpan" id="kobo.114.1">In the early 2000s, a community of researchers who either worked for or regularly interacted with network operators started to explore pragmatic approaches using either standard protocols or other imminent technologies that were just about to become deployable. </span><span class="koboSpan" id="kobo.114.2">At that time, routers and switches had tight integration between the control and forwarding planes. </span><span class="koboSpan" id="kobo.114.3">This coupling made various network management tasks difficult, such as debugging configuration problems and controlling routing behavior. </span><span class="koboSpan" id="kobo.114.4">To address these challenges, various efforts to separate the forwarding and control planes began to emerge. </span><span class="koboSpan" id="kobo.114.5">Let’s explore a few of the earlier efforts in the following sections.</span></p>
<h3><span class="koboSpan" id="kobo.115.1">IETF ForCES</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.116.1">Forwarding and Control Element Separation </span></strong><span class="koboSpan" id="kobo.117.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.118.1">IETF ForCES</span></strong><span class="koboSpan" id="kobo.119.1">) working groups intended</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.120.1"> to create a framework, a list of requirements, a solution protocol, a logical function block library, and other associated</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.121.1"> documents in support of data and control element separation (</span><a href="https://datatracker.ietf.org/wg/forces/about/"><span class="koboSpan" id="kobo.122.1">https://datatracker.ietf.org/wg/forces/about/</span></a><span class="koboSpan" id="kobo.123.1">).</span></p>
<h3><span class="koboSpan" id="kobo.124.1">The NetLink interface</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.125.1">NetLink</span></strong><span class="koboSpan" id="kobo.126.1"> was perhaps the clearest separation</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.127.1"> of the control plane and data plane</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.128.1"> on the Linux</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.129.1"> kernel. </span><span class="koboSpan" id="kobo.129.2">In 2003, IETF published the </span><em class="italic"><span class="koboSpan" id="kobo.130.1">RFC3549</span></em><span class="koboSpan" id="kobo.131.1"> describing the separation of the </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">control plane components</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">CPCs</span></strong><span class="koboSpan" id="kobo.135.1">) and the </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">forwarding engine components</span></strong><span class="koboSpan" id="kobo.137.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.138.1">FECs</span></strong><span class="koboSpan" id="kobo.139.1">). </span><em class="italic"><span class="koboSpan" id="kobo.140.1">Figure 2.1</span></em><span class="koboSpan" id="kobo.141.1"> (from the original RFC) illustrates how Linux was using Netlink</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.142.1"> as the main separator between the control and data planes (</span><a href="https://datatracker.ietf.org/doc/html/rfc3549"><span class="koboSpan" id="kobo.143.1">https://datatracker.ietf.org/doc/html/rfc3549</span></a><span class="koboSpan" id="kobo.144.1">).</span></p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.145.1"><img alt="Figure 2.1 – Control and data plane separation, as shown in RFC3549" src="image/B18165_02_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.146.1">Figure 2.1 – Control and data plane separation, as shown in RFC3549</span></p>
<p><span class="koboSpan" id="kobo.147.1"> Netlink</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.148.1"> was first created on series 2.0 of the Linux kernel. </span></p>
<h3><span class="koboSpan" id="kobo.149.1">Routing Control Platform</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.150.1">Routing Control Platform</span></strong><span class="koboSpan" id="kobo.151.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.152.1">RCP</span></strong><span class="koboSpan" id="kobo.153.1">) is a pragmatic design to separate the control</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.154.1"> and data planes. </span><span class="koboSpan" id="kobo.154.2">The idea was to create a centralized control where all routing information was collected and then run an algorithm to select the best routing path for each of the routers of the network.</span></p>
<p><span class="koboSpan" id="kobo.155.1">RCP was implemented by collecting routing tables from external and internal </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">Border Gateway Protocol</span></strong><span class="koboSpan" id="kobo.157.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.158.1">BGP</span></strong><span class="koboSpan" id="kobo.159.1">) from the routers in the current</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.160.1"> network, using this information in a centralized manner to choose the best path to each of the routers. </span><span class="koboSpan" id="kobo.160.2">With this approach, it was possible to leverage the existing network devices and have control plane</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.161.1"> and data plane separation.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.162.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.163.1">More about RCP using BGP can be found in the paper </span><em class="italic"><span class="koboSpan" id="kobo.164.1">Design and implementation of a routing control platform</span></em><span class="koboSpan" id="kobo.165.1"> – Authors:  Matthew Caesar, Donald Caldwell, Nick Feamster, Jennifer Rexford, Aman Shaikh, Jacobus van der Merwe – </span><em class="italic"><span class="koboSpan" id="kobo.166.1">NSDI’05: Proceedings of the 2nd conference on Symposium on Networked Systems Design &amp; Implementation – Volume 2 May 2005 Pages 15–28.</span></em></p>
<h3><span class="koboSpan" id="kobo.167.1">SoftRouter</span></h3>
<p><span class="koboSpan" id="kobo.168.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">SoftRouter</span></strong><span class="koboSpan" id="kobo.170.1"> idea was presented at a conference</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.171.1"> in 2004 and patented in 2005. </span><span class="koboSpan" id="kobo.171.2">Again, the architecture had separation between control plane functions and data plane functions.</span></p>
<p><span class="koboSpan" id="kobo.172.1">All control plane functions</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.173.1"> were implemented on general-purpose servers called </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">control elements</span></strong><span class="koboSpan" id="kobo.175.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.176.1">CEs</span></strong><span class="koboSpan" id="kobo.177.1">), which may be multiple hops away from the </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">forwarding elements</span></strong><span class="koboSpan" id="kobo.179.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.180.1">FEs</span></strong><span class="koboSpan" id="kobo.181.1">). </span><span class="koboSpan" id="kobo.181.2">There were two main types of network</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.182.1"> entities in the SoftRouter architecture, which</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.183.1"> were the FEs and CEs. </span><span class="koboSpan" id="kobo.183.2">Together, they constituted a </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">network element</span></strong><span class="koboSpan" id="kobo.185.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.186.1">NE</span></strong><span class="koboSpan" id="kobo.187.1">) router. </span><span class="koboSpan" id="kobo.187.2">The key difference from a traditional router was the absence of any control logic (such as OSPF or BGP) running locally. </span><span class="koboSpan" id="kobo.187.3">Instead, the control logic was hosted remotely.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.188.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.189.1">More details on SoftRouter can be found in the original 2004 paper </span><em class="italic"><span class="koboSpan" id="kobo.190.1">The SoftRouter Architecture</span></em><span class="koboSpan" id="kobo.191.1"> – T. </span><span class="koboSpan" id="kobo.191.2">V. </span><span class="koboSpan" id="kobo.191.3">Lakshman, T. </span><span class="koboSpan" id="kobo.191.4">Nandagopal, R. </span><span class="koboSpan" id="kobo.191.5">Ramjee, K. </span><span class="koboSpan" id="kobo.191.6">Sabnani, T. </span><span class="koboSpan" id="kobo.191.7">Woo – </span><em class="italic"><span class="koboSpan" id="kobo.192.1">Bell Laboratories, Lucent Technologies, ACM HOTNETS - January 2004.</span></em></p>
<h3><span class="koboSpan" id="kobo.193.1">The path computation element architecture</span></h3>
<p><span class="koboSpan" id="kobo.194.1">In 2006, the IETF Network Working Group</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.195.1"> published an RFC describing an architecture of a centralized controlled entity to make route path decisions, which they called the </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">path computation element</span></strong><span class="koboSpan" id="kobo.197.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.198.1">PCE</span></strong><span class="koboSpan" id="kobo.199.1">) architecture.</span></p>
<p><span class="koboSpan" id="kobo.200.1">Initially, PCE architecture</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.201.1"> was invented to solve a problem in </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">multiprotocol label switching</span></strong><span class="koboSpan" id="kobo.203.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">MPLS</span></strong><span class="koboSpan" id="kobo.205.1">) where the </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">label switch path</span></strong><span class="koboSpan" id="kobo.207.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.208.1">LSP</span></strong><span class="koboSpan" id="kobo.209.1">) calculations were becoming</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.210.1"> very slow and heavy for each router to calculate. </span><span class="koboSpan" id="kobo.210.2">It was designed to do the calculations on a server inside or outside the network instead.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.211.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.212.1">More details on PCE</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.213.1"> can be found in </span><em class="italic"><span class="koboSpan" id="kobo.214.1">RFC4655:</span></em> <a href="https://datatracker.ietf.org/doc/html/rfc4655"><span class="koboSpan" id="kobo.215.1">https://datatracker.ietf.org/doc/html/rfc4655</span></a></p>
<p><span class="koboSpan" id="kobo.216.1">Let’s now look at the most important project of all, which was the work that went toward OpenFlow and SDNs.</span></p>
<h3><span class="koboSpan" id="kobo.217.1">Ethane</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.218.1">Ethane</span></strong><span class="koboSpan" id="kobo.219.1"> was one of the most important projects </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.220.1">and culminated in the creation of OpenFlow and SDNs. </span><span class="koboSpan" id="kobo.220.2">Initially, it was just a project from a PhD student that defined a network as a group of data flows and network policies to control the traffic, which is another way to see the separation between the data plane and the control plane.</span></p>
<p><span class="koboSpan" id="kobo.221.1">The Ethane project had the idea of centralizing all network policies in one place. </span><span class="koboSpan" id="kobo.221.2">A new device joining the Ethane network should have all its communication turned off by default. </span><span class="koboSpan" id="kobo.221.3">The new device should get explicit permissions from the centralized server before connecting and its data flow should only be allowed on the permitted paths.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.222.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.223.1">More on the Ethane project can be found in the 2007 original paper </span><em class="italic"><span class="koboSpan" id="kobo.224.1">Ethane: taking control of the enterprise</span></em><span class="koboSpan" id="kobo.225.1"> – Authors: M. </span><span class="koboSpan" id="kobo.225.2">Casado, M. </span><span class="koboSpan" id="kobo.225.3">J. </span><span class="koboSpan" id="kobo.225.4">Freedman, J. </span><span class="koboSpan" id="kobo.225.5">Pettit, J. </span><span class="koboSpan" id="kobo.225.6">Luo, N. </span><span class="koboSpan" id="kobo.225.7">McKeown, Scott Shenker – </span><em class="italic"><span class="koboSpan" id="kobo.226.1">SIGCOMM ‘07: Proceedings of the 2007 conference, pages 1–12.</span></em></p>
<p><span class="koboSpan" id="kobo.227.1">In this section, we explored</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.228.1"> a bit of the history behind programmable networks. </span><span class="koboSpan" id="kobo.228.2">We also explored a few of the main projects that led to the separation of the control and data planes, which was an important milestone toward SDNs. </span><span class="koboSpan" id="kobo.228.3">You should now be able to identify the significance of the separation and why it happened.</span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.229.1">Virtual network technologies </span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.230.1">Network virtualization</span></strong><span class="koboSpan" id="kobo.231.1"> is when software acts like network hardware</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.232.1"> and it is accomplished by using</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.233.1"> logically simulated hardware platforms.</span></p>
<p><span class="koboSpan" id="kobo.234.1">Virtualization of networks is not a new concept, and we can find one of the first implementations in the mid-1970s with virtual circuits on X.25 networks. </span><span class="koboSpan" id="kobo.234.2">Later, other technologies also started using virtual concepts, such as Frame Relay and ATM, but they are now obsolete.</span></p>
<p><span class="koboSpan" id="kobo.235.1">Loopback interfaces were based on electronics where loopbacks are used to create electric loops for the signal to return to its source for testing purposes. </span><span class="koboSpan" id="kobo.235.2">In 1981, the IETF referred</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.236.1"> to the reserved address range </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">127.rrr.rrr.rrr</span></strong><span class="koboSpan" id="kobo.238.1"> with </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">RFC790</span></strong><span class="koboSpan" id="kobo.240.1">, which also outlined 32-bit IP</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.241.1"> address space classes. </span><span class="koboSpan" id="kobo.241.2">In 1986, with </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">RFC990</span></strong><span class="koboSpan" id="kobo.243.1">, the address</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.244.1"> range </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">127.rrr.rrr.rrr</span></strong><span class="koboSpan" id="kobo.246.1"> was officially called </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">loopback</span></strong><span class="koboSpan" id="kobo.248.1">. </span><span class="koboSpan" id="kobo.248.2">Today, this IP range is used in computer platforms to designate the localhost IP address of the computer when using the TCP/IP stack (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">127.0.0.1</span></strong><span class="koboSpan" id="kobo.250.1">)</span></p>
<p><span class="koboSpan" id="kobo.251.1">Another early implementation</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.252.1"> of network virtualization was the </span><strong class="bold"><span class="koboSpan" id="kobo.253.1">virtual</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.254.1">LAN</span></strong><span class="koboSpan" id="kobo.255.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">VLAN</span></strong><span class="koboSpan" id="kobo.257.1">. </span><span class="koboSpan" id="kobo.257.2">By 1981, David Sincoskie was testing segmenting voice-over-Ethernet networks to facilitate fault tolerance, something similar to what VLAN does. </span><span class="koboSpan" id="kobo.257.3">However, it was only after 17 years that, in 1998, VLAN was finally published as a standard by IEEE by the name </span><em class="italic"><span class="koboSpan" id="kobo.258.1">802.1Q</span></em><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">By the 2000s, switched networks dominated the landscape with switches, repeaters, and bridges, making VLANs commonplace. </span><span class="koboSpan" id="kobo.259.3">A LAN without a VLAN is virtually impossible today.</span></p>
<p><span class="koboSpan" id="kobo.260.1">There are several other network virtualization technologies that are used today. </span><span class="koboSpan" id="kobo.260.2">Let’s explore the important</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.261.1"> ones in the following sections.</span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.262.1">Virtual private networks</span></h2>
<p><span class="koboSpan" id="kobo.263.1">This is the concept of creating</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.264.1"> an isolated secured network overlay that is implemented on network carriers, service providers, and over the internet.</span></p>
<p><span class="koboSpan" id="kobo.265.1">In other words, </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">virtual private network</span></strong><span class="koboSpan" id="kobo.267.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.268.1">VPN</span></strong><span class="koboSpan" id="kobo.269.1">) is a generic term that describes the use of public or private networks to create groups of users that are isolated from other network users, allowing them to communicate between themselves as if they were on a private network.</span></p>
<p><span class="koboSpan" id="kobo.270.1">VPNs use end-to-end traffic encryption to enhance data separation, especially when using public networks, but this is not necessarily the case for all implementations. </span><span class="koboSpan" id="kobo.270.2">For instance, when using VPNs in MPLS networks, the traffic is not encrypted as it runs over private domains, and data separation exists only by packet encapsulation.</span></p>
<p><span class="koboSpan" id="kobo.271.1">VPN is a generic name, but more specific names can be found, such as L3VPN, L2VPN, VPLS, Pseudo Wires, and VLLS, among others.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.272.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.273.1">More on VPN and all related</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.274.1"> families can be found at </span><a href="https://datatracker.ietf.org/doc/html/rfc2764"><span class="koboSpan" id="kobo.275.1">https://datatracker.ietf.org/doc/html/rfc2764</span></a><span class="koboSpan" id="kobo.276.1"> and </span><a href="https://datatracker.ietf.org/doc/html/rfc4026"><span class="koboSpan" id="kobo.277.1">https://datatracker.ietf.org/doc/html/rfc4026</span></a><span class="koboSpan" id="kobo.278.1">.</span></p>
<p><span class="koboSpan" id="kobo.279.1">The VLAN was perhaps one of the most important virtualizations created in L2 networks. </span><span class="koboSpan" id="kobo.279.2">Let’s now look at an interesting virtualization created for router gateways.</span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.280.1">The Virtual Router Redundancy Protocol</span></h2>
<p><span class="koboSpan" id="kobo.281.1">This protocol</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.282.1"> was initially created</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.283.1"> by Cisco in 1998 with the name </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">Hot Standby Router Protocol</span></strong><span class="koboSpan" id="kobo.285.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.286.1">HSRP</span></strong><span class="koboSpan" id="kobo.287.1">), defined in </span><em class="italic"><span class="koboSpan" id="kobo.288.1">RFC2281</span></em><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">As the use of HSRP was very popular at the time, the IETF Network Working Group created the </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">Virtual Router Redundancy Protocol</span></strong><span class="koboSpan" id="kobo.291.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.292.1">VRRP</span></strong><span class="koboSpan" id="kobo.293.1">) (</span><em class="italic"><span class="koboSpan" id="kobo.294.1">RFC3768</span></em><span class="koboSpan" id="kobo.295.1">).</span></p>
<p><span class="koboSpan" id="kobo.296.1">The concept is simple, giving computers only one default gateway on their routing table by acquiring automatically using DHCP or by configuring manually. </span><span class="koboSpan" id="kobo.296.2">To use two routers redundantly, you might need to update all computers or use VRRP. </span></p>
<p><span class="koboSpan" id="kobo.297.1">VRRP uses a virtual Ethernet address to associate with an IP address; this IP address is the default gateway to all computers on the network. </span><em class="italic"><span class="koboSpan" id="kobo.298.1">Figure 2.2</span></em><span class="koboSpan" id="kobo.299.1"> illustrates </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">Router A</span></strong><span class="koboSpan" id="kobo.301.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Router B</span></strong><span class="koboSpan" id="kobo.303.1">, which can assume the IP address </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">10.0.0.1</span></strong><span class="koboSpan" id="kobo.305.1"> using a virtual MAC address that is associated with both routers.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.306.1"><img alt="Figure 2.2 – VRRP using a virtual Ethernet address as the default gateway" src="image/B18165_02_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.307.1">Figure 2.2 – VRRP using a virtual Ethernet address as the default gateway</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.308.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.309.1">More details</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.310.1"> on VRRP and HSRP</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.311.1"> can be found at </span><a href="https://datatracker.ietf.org/doc/html/rfc2281"><span class="koboSpan" id="kobo.312.1">https://datatracker.ietf.org/doc/html/rfc2281</span></a><span class="koboSpan" id="kobo.313.1"> and </span><a href="https://datatracker.ietf.org/doc/html/rfc3768"><span class="koboSpan" id="kobo.314.1">https://datatracker.ietf.org/doc/html/rfc3768</span></a><span class="koboSpan" id="kobo.315.1">.</span></p>
<p><span class="koboSpan" id="kobo.316.1">VLANs were created</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.317.1"> a long time ago, but its concept was used to extend to a more flexible usage, as we are going to see in the next section.</span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.318.1">The Virtual Extensible Local Area Network</span></h2>
<p><span class="koboSpan" id="kobo.319.1">Perhaps the most important</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.320.1"> of all in virtualization today is the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">Virtual Extensible Local Area Network</span></strong><span class="koboSpan" id="kobo.322.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.323.1">VXLAN</span></strong><span class="koboSpan" id="kobo.324.1">). </span><span class="koboSpan" id="kobo.324.2">This standard was published in 2014 and is heavily used for network virtualization to provide connectivity. </span><span class="koboSpan" id="kobo.324.3">With VXLANs, it’s possible to create a network with interfaces connected back-to-back to routers like they are physical entities, but in reality, they are virtual.</span></p>
<p><span class="koboSpan" id="kobo.325.1">A VXLAN encapsulates data link layer Ethernet frames (layer 2) within the transport layer using UDP datagrams (layer 4). </span><span class="koboSpan" id="kobo.325.2">VXLAN endpoints, which terminate VXLAN</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.326.1"> tunnels and may be either virtual or physical switch ports, are known as </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">Virtual Tunnel Endpoints</span></strong><span class="koboSpan" id="kobo.328.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.329.1">VTEPs</span></strong><span class="koboSpan" id="kobo.330.1">).</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.331.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.332.1">More about VXLANs</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.333.1"> can be found at </span><a href="https://datatracker.ietf.org/doc/html/rfc7348"><span class="koboSpan" id="kobo.334.1">https://datatracker.ietf.org/doc/html/rfc7348</span></a><span class="koboSpan" id="kobo.335.1">.</span></p>
<p><span class="koboSpan" id="kobo.336.1">Let’s now explore an open source project that puts in place several virtual network technologies, including VLANs, VRRP, and VXLANs.</span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.337.1">Open vSwitch</span></h2>
<p><span class="koboSpan" id="kobo.338.1">This open source project is perhaps the most</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.339.1"> important in</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.340.1"> network virtualization today. </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">Open vSwitch</span></strong><span class="koboSpan" id="kobo.342.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.343.1">OVS</span></strong><span class="koboSpan" id="kobo.344.1">) runs on any Linux-based virtualization platform (kernel 3.10 and newer) and is used to create connectivity in virtual and physical environments. </span><span class="koboSpan" id="kobo.344.2">The majority of the code is written in C, and it supports several protocols including VXLAN, IPSEC, and GRE, among others. </span><span class="koboSpan" id="kobo.344.3">OVS is an OpenStack component of SDNs and perhaps the most popular implementation of OpenFlow. </span><span class="koboSpan" id="kobo.344.4">A basic architecture of how OVS works can be found in </span><em class="italic"><span class="koboSpan" id="kobo.345.1">Figure 2.3</span></em><span class="koboSpan" id="kobo.346.1">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.347.1"><img alt="Figure 2.3 – Simplified OVS architecture" src="image/B18165_02_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.348.1">Figure 2.3 – Simplified OVS architecture</span></p>
<p><span class="koboSpan" id="kobo.349.1">More details</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.350.1"> on OVS can be found at </span><a href="https://github.com/openvswitch/ovs.git"><span class="koboSpan" id="kobo.351.1">https://github.com/openvswitch/ovs.git</span></a><span class="koboSpan" id="kobo.352.1">.</span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.353.1">Linux Containers</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.354.1">Linux Containers</span></strong><span class="koboSpan" id="kobo.355.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.356.1">LXC</span></strong><span class="koboSpan" id="kobo.357.1">) provides operating-system-level</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.358.1"> virtualization</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.359.1"> using CPU, network, memory, and I/O space isolation. </span><span class="koboSpan" id="kobo.359.2">Its first implementation was on Linux kernel 2.6.24 in January 2008, but the concept is old and can be found</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.360.1"> in a FreeBSD implementation called </span><strong class="bold"><span class="koboSpan" id="kobo.361.1">jails</span></strong><span class="koboSpan" id="kobo.362.1"> implemented in 1999 and published on FreeBSD 4.0 in March 2000 (details at: docs.freebsd.org/en/books/handbook/jails/).</span></p>
<p><span class="koboSpan" id="kobo.363.1">Today, more and more implementations of LXC can be found, but the concept of CPU, network, memory, and I/O space isolation is the same. </span><span class="koboSpan" id="kobo.363.2">The most popular</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.364.1"> LXC implementation today is </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">Docker</span></strong><span class="koboSpan" id="kobo.366.1">.</span></p>
<p><span class="koboSpan" id="kobo.367.1">With LXC and Open vSwitch, it’s possible to create an entire</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.368.1"> virtual network topology</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.369.1"> with hundreds of routers. </span><span class="koboSpan" id="kobo.369.2">A powerful example is </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">Mininet</span></strong><span class="koboSpan" id="kobo.371.1"> (</span><a href="http://mininet.org/"><span class="koboSpan" id="kobo.372.1">http://mininet.org/</span></a><span class="koboSpan" id="kobo.373.1"> and  </span><a href="https://github.com/mininet/mininet"><span class="koboSpan" id="kobo.374.1">https://github.com/mininet/mininet</span></a><span class="koboSpan" id="kobo.375.1">).</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.376.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.377.1">More on LXC</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.378.1"> and FreeBSD jail</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.379.1"> can be found at </span><a href="https://en.wikipedia.org/wiki/LXC"><span class="koboSpan" id="kobo.380.1">https://en.wikipedia.org/wiki/LXC</span></a><span class="koboSpan" id="kobo.381.1"> and </span><a href="https://en.wikipedia.org/wiki/FreeBSD_jail"><span class="koboSpan" id="kobo.382.1">https://en.wikipedia.org/wiki/FreeBSD_jail</span></a><span class="koboSpan" id="kobo.383.1">.</span></p>
<p><span class="koboSpan" id="kobo.384.1">Containers for Linux</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.385.1"> can create most virtualizations, however</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.386.1"> they are limited by using the same operational system because containers share the same kernel. </span><span class="koboSpan" id="kobo.386.2">Virtual machines, as we’ll see next, can be used to virtualize a wide range of other operating systems.</span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.387.1">Virtual machines</span></h2>
<p><span class="koboSpan" id="kobo.388.1">LXC is powerful in isolating</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.389.1"> parts of the operating system; however, they aren’t able to run applications that require a different CPU or hardware. </span><span class="koboSpan" id="kobo.389.2">So, </span><strong class="bold"><span class="koboSpan" id="kobo.390.1">virtual machines</span></strong><span class="koboSpan" id="kobo.391.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.392.1">VMs</span></strong><span class="koboSpan" id="kobo.393.1">) are there to add this extra virtualization by simulating physical hardware and CPU.</span></p>
<p><span class="koboSpan" id="kobo.394.1">A VM can further isolate the operating system by creating a whole new layer of CPU, I/O, memory, and network. For instance, in network virtualization, it’s possible to run different operating systems with different CPUs, such as Juniper JunOS using Intel CPUs, and Cisco IOS using MIPS CPUs.</span></p>
<p><span class="koboSpan" id="kobo.395.1">The most popular open source</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.396.1"> implementation of VMs is </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">Xen</span></strong><span class="koboSpan" id="kobo.398.1"> (</span><a href="https://xenproject.org/"><span class="koboSpan" id="kobo.399.1">https://xenproject.org/</span></a><span class="koboSpan" id="kobo.400.1">).</span></p>
<p><span class="koboSpan" id="kobo.401.1">We do have much more</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.402.1"> to talk about regarding network virtualization, but that would be a topic for another book. </span><span class="koboSpan" id="kobo.402.2">At least for the time being, what we have examined in this section is sufficient to identify the main technologies used by programmable networks. </span><span class="koboSpan" id="kobo.402.3">At this point, you should be able to identify these technologies easily if you encounter them.</span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.403.1">SDNs and OpenFlow</span></h1>
<p><span class="koboSpan" id="kobo.404.1">We have investigated</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.405.1"> a few historical milestones of programmable</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.406.1"> networks and network virtualization that form the base of what we know today as SDNs. </span><span class="koboSpan" id="kobo.406.2">Next, let’s talk about the details behind SDNs.</span></p>
<p><span class="koboSpan" id="kobo.407.1">In order for SDNs to be successful, they need to be flexible and programmable, making it simple to deploy and control traffic and manage their components. </span><span class="koboSpan" id="kobo.407.2">None of this could be done without separation between the control plane and the forwarding plane (the data plane).</span></p>
<p><span class="koboSpan" id="kobo.408.1">SDN implementation is done by having an application that uses the decoupling of these two planes to construct the data flows of the network. </span><span class="koboSpan" id="kobo.408.2">This application can run in a network server or in a VM, which sends control packets to the network devices using an OpenFlow protocol when possible.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.409.1">History of OpenFlow</span></h2>
<p><span class="koboSpan" id="kobo.410.1">OpenFlow is a standard protocol</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.411.1"> used in SDNs. </span><span class="koboSpan" id="kobo.411.2">Its origins can be traced back to 2006 with the project mentioned earlier in this chapter called Ethane. </span><span class="koboSpan" id="kobo.411.3">Eventually, the Ethane</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.412.1"> project led to what became known as OpenFlow, thanks to a joint research effort by teams at Stanford and Berkeley universities. </span><span class="koboSpan" id="kobo.412.2">The initial idea was to centrally manage policies using a flow-based network and a controller with a focus on network security; that is the reason for </span><em class="italic"><span class="koboSpan" id="kobo.413.1">Flow</span></em><span class="koboSpan" id="kobo.414.1"> being in the name </span><em class="italic"><span class="koboSpan" id="kobo.415.1">OpenFlow</span></em><span class="koboSpan" id="kobo.416.1">.</span></p>
<p><span class="koboSpan" id="kobo.417.1">After the initial work by Berkeley and Stanford, companies such as Nicira and Big Switch Networks started to raise significant amounts of venture capital funding to help push their products with ideas on a flow-based controlled network, but at that time no standards were yet published. </span><span class="koboSpan" id="kobo.417.2">A protocol was needed to move network control out of proprietary network switches and into control software that was open source and locally managed. </span><span class="koboSpan" id="kobo.417.3">This is the reason that the name </span><em class="italic"><span class="koboSpan" id="kobo.418.1">OpenFlow</span></em><span class="koboSpan" id="kobo.419.1"> has the word </span><em class="italic"><span class="koboSpan" id="kobo.420.1">Open</span></em><span class="koboSpan" id="kobo.421.1"> in it.</span></p>
<p><span class="koboSpan" id="kobo.422.1">By 2011, the </span><strong class="bold"><span class="koboSpan" id="kobo.423.1">Open Networking Foundation</span></strong><span class="koboSpan" id="kobo.424.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.425.1">ONF</span></strong><span class="koboSpan" id="kobo.426.1">) had been created with the aim of standardizing emerging</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.427.1"> technologies for networking and data center management. </span><span class="koboSpan" id="kobo.427.2">The founding members were Google, Facebook, and Microsoft, while Citrix, Cisco, Dell, HP, F5 Networks, IBM, NEC, Huawei, Juniper Networks, Oracle, and VMware joined later.</span></p>
<p><span class="koboSpan" id="kobo.428.1">The ONF working group</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.429.1"> released the first version of the OpenFlow protocol in December 2009, and in February 2011 they made version 1.1 public. </span><span class="koboSpan" id="kobo.429.2">The most updated version</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.430.1"> is from March 2015 – version 1.5.1 (</span><a href="https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf"><span class="koboSpan" id="kobo.431.1">https://opennetworking.org/wp-content/uploads/2014/10/openflow-switch-v1.5.1.pdf</span></a><span class="koboSpan" id="kobo.432.1">).</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.433.1">SDN architecture</span></h2>
<p><span class="koboSpan" id="kobo.434.1">The simple architecture</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.435.1"> of an SDN</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.436.1"> is shown in </span><em class="italic"><span class="koboSpan" id="kobo.437.1">Figure 2.4</span></em><span class="koboSpan" id="kobo.438.1">. </span><span class="koboSpan" id="kobo.438.2">The SDN</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.439.1"> controller has </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">northbound interfaces</span></strong><span class="koboSpan" id="kobo.441.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.442.1">NBIs</span></strong><span class="koboSpan" id="kobo.443.1">) toward business-level applications and </span><strong class="bold"><span class="koboSpan" id="kobo.444.1">southbound interfaces</span></strong><span class="koboSpan" id="kobo.445.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.446.1">SBIs</span></strong><span class="koboSpan" id="kobo.447.1">) toward network devices.</span></p>
<p><span class="koboSpan" id="kobo.448.1">To communicate with network devices, the SBI requires a control protocol. </span><span class="koboSpan" id="kobo.448.2">It is desirable for the control protocol to be OpenFlow; however, other protocols can be used if the device does not support it, such as Cisco OpFlex, SNMP, or even CLI via SSH (this will be covered in the next chapter).</span></p>
<p><span class="koboSpan" id="kobo.449.1">The NBI is used to collect information from the business or for the business to collect information from the network (in </span><em class="italic"><span class="koboSpan" id="kobo.450.1">Figure 2.4</span></em><span class="koboSpan" id="kobo.451.1">, this is represented by the application plane), for instance, allowing administrators to access the SDN controller to retrieve information about the network. </span><span class="koboSpan" id="kobo.451.2">Access to the controller is normally done via an API protocol.</span></p>
<p><span class="koboSpan" id="kobo.452.1">Normally, the NBI</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.453.1"> is used for the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.454.1">Getting information from devices</span></li>
<li><span class="koboSpan" id="kobo.455.1">Getting the status of physical interfaces</span></li>
<li><span class="koboSpan" id="kobo.456.1">Configuring devices</span></li>
<li><span class="koboSpan" id="kobo.457.1">Constructing data flows between devices</span></li>
</ul>
<p><span class="koboSpan" id="kobo.458.1">But the available methods on the NBI API will depend on the SDN application and what the vendor made available.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.459.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.460.1">It’s important to emphasize that the NBI API for the SDN</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.461.1"> has no responsibility for managing the network devices, such as attributing configuration or doing software updates. </span><span class="koboSpan" id="kobo.461.2">The main responsibility of the SDN NBI API is to allow administrators and businesses to give directions to the SDN controller in order to make decisions on how traffic will flow through the network devices based on pre-defined criteria.</span></p>
<p><span class="koboSpan" id="kobo.462.1">Now, let’s look at the simple</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.463.1"> architecture of an SDN: </span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.464.1"><img alt="Figure 2.4 – Basic SDN architecture" src="image/B18165_02_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.465.1">Figure 2.4 – Basic SDN architecture</span></p>
<p><span class="koboSpan" id="kobo.466.1">Despite being used</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.467.1"> in SDN and being a very well-known term in the internet community, OpenFlow’s future might be not that bright. </span><span class="koboSpan" id="kobo.467.2">Let’s find out why.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.468.1">OpenFlow and its future</span></h2>
<p><span class="koboSpan" id="kobo.469.1">Looking at how the OpenFlow</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.470.1"> standard track is being updated and how vendors are implementing it, its future doesn’t look promising.</span></p>
<p><span class="koboSpan" id="kobo.471.1">The first usable version of OpenFlow</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.472.1"> was published in 2011, known as version 1.1. </span><span class="koboSpan" id="kobo.472.2">Since then, updates have been incorporated until 2015 with version 1.5.1. </span><span class="koboSpan" id="kobo.472.3">But more than six years have passed and no updates have been published yet.</span></p>
<p><span class="koboSpan" id="kobo.473.1">Version 1.6 of OpenFlow has been available</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.474.1"> since 2016, but only for members of the ONF, which does not help the user’s confidence in OpenFlow’s future.</span></p>
<p><span class="koboSpan" id="kobo.475.1">In addition to the lack of updates, Cisco (one of the major network vendors) has been working on its own version of OpenFlow called OpFlex since 2014 because it saw</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.476.1"> limitations in OpenFlow’s approach. </span><span class="koboSpan" id="kobo.476.2">Cisco also has made OpFlex open, allowing others to use without restriction and has started working</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.477.1"> on an RFC to publish OpFlex (</span><a href="https://datatracker.ietf.org/doc/draft-smith-opflex/"><span class="koboSpan" id="kobo.478.1">https://datatracker.ietf.org/doc/draft-smith-opflex/</span></a><span class="koboSpan" id="kobo.479.1">). </span></p>
<p><span class="koboSpan" id="kobo.480.1">So, the SBIs described in </span><em class="italic"><span class="koboSpan" id="kobo.481.1">Figure 2.4</span></em><span class="koboSpan" id="kobo.482.1"> do not necessarily use OpenFlow. </span><span class="koboSpan" id="kobo.482.2">Today, SDN implementations vary and may use different types of SBIs that are associated to the methods available for device communication for creation of the traffic flow policies.</span></p>
<p><span class="koboSpan" id="kobo.483.1">Other methods and protocols besides OpenFlow are being used with SDN communication, such as OpenStack, OpFlex, CLI vis SSH, SNMP, and NETCONF, among others.</span></p>
<p><span class="koboSpan" id="kobo.484.1">As we’ve seen in this section, the SDN</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.485.1"> is a very well-delineated concept on how to work with programmable networks; however, because of the lack of OpenFlow adoption, SDNs have become more of a concept than a standard. </span><span class="koboSpan" id="kobo.485.2">From now on, you should have enough knowledge to decide whether your network automation should follow OpenFlow or not.</span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.486.1">Understanding cloud computing </span></h1>
<p><span class="koboSpan" id="kobo.487.1">The goal of </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">cloud computing</span></strong><span class="koboSpan" id="kobo.489.1"> is to allow users to benefit from virtual</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.490.1"> technologies without having in-depth knowledge about them. </span><span class="koboSpan" id="kobo.490.2">The objective of cloud computing is to cut costs and help users focus on their core business instead of the physical infrastructure.</span></p>
<p><span class="koboSpan" id="kobo.491.1">Cloud computing advocates for </span><strong class="bold"><span class="koboSpan" id="kobo.492.1">Everything as a Service</span></strong><span class="koboSpan" id="kobo.493.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.494.1">EaaS</span></strong><span class="koboSpan" id="kobo.495.1">), including </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">Infrastructure as a Service</span></strong><span class="koboSpan" id="kobo.497.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.498.1">IaaS</span></strong><span class="koboSpan" id="kobo.499.1">), which is implemented by providing</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.500.1"> high-level APIs used</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.501.1"> to abstract various low-level details of underlying network infrastructure such as physical computing resources, locations, data partitioning, scaling, security, and backup.</span></p>
<p><span class="koboSpan" id="kobo.502.1">Our focus here will be the networking</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.503.1"> services offered by cloud computing, which</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.504.1"> we usually refer to as cloud networking services.</span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.505.1">Commercial cloud computing</span></h2>
<p><span class="koboSpan" id="kobo.506.1">Perhaps the most popular</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.507.1"> cloud computing service today</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.508.1"> is the 2002 Amazon-created subsidiary called </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.510.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.511.1">AWS</span></strong><span class="koboSpan" id="kobo.512.1">). </span><span class="koboSpan" id="kobo.512.2">AWS uses its proprietary API to offer cloud services; one of them is created by using </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">AWS CloudFormation</span></strong><span class="koboSpan" id="kobo.514.1"> to provide infrastructure as</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.515.1"> code.</span></p>
<p><span class="koboSpan" id="kobo.516.1">In 2008, Google started offering cloud services; in 2010, Microsoft started offering Microsoft Azure; in 2011, IBM announced IBM SmartCloud; and in 2012, Oracle start offering Oracle Cloud.</span></p>
<p><span class="koboSpan" id="kobo.517.1">There are hundreds of other</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.518.1"> providers and a list of all can be found at the following link: </span><a href="https://www.intricately.com/industry/cloud-hosting"><span class="koboSpan" id="kobo.519.1">https://www.intricately.com/industry/cloud-hosting</span></a><span class="koboSpan" id="kobo.520.1">.</span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.521.1">The OpenStack Foundation</span></h2>
<p><span class="koboSpan" id="kobo.522.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.523.1">OpenStack Foundation</span></strong><span class="koboSpan" id="kobo.524.1"> was the first initiative created by NASA</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.525.1"> and Rackspace to start an open source cloud service software. </span><span class="koboSpan" id="kobo.525.2">The foundation</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.526.1"> eventually changed its name to the </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">OpenInfra Foundation</span></strong><span class="koboSpan" id="kobo.528.1">, and today they have more than 500 members. </span><span class="koboSpan" id="kobo.528.2">Their work has been tremendous, and they created a great set of open source code for cloud</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.529.1"> computing. </span><span class="koboSpan" id="kobo.529.2">More details can be found at </span><a href="https://openinfra.dev/about/"><span class="koboSpan" id="kobo.530.1">https://openinfra.dev/about/</span></a><span class="koboSpan" id="kobo.531.1">. </span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.532.1">Cloud Native Computing Foundation</span></h2>
<p><span class="koboSpan" id="kobo.533.1">It sounds</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.534.1"> a bit</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.535.1"> confusing, but the </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">CloudStack Foundation</span></strong><span class="koboSpan" id="kobo.537.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">Cloud Native Computing Foundation</span></strong><span class="koboSpan" id="kobo.539.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.540.1">CNCF</span></strong><span class="koboSpan" id="kobo.541.1">) focus on different aspects of cloud services. </span><span class="koboSpan" id="kobo.541.2">The CNCF was basically created by Kubernetes as a Linux-container-based idea, and CloudStack is a bit older and based on VMs.</span></p>
<p><span class="koboSpan" id="kobo.542.1">The CNCF is a Linux Foundation project that was founded in 2015 to help advance Linux container technologies and help to align the tech industry around its evolution. </span><span class="koboSpan" id="kobo.542.2">It was announced alongside Kubernetes 1.0, which was given to the Linux Foundation by Google as a seed technology.</span></p>
<p><span class="koboSpan" id="kobo.543.1">We’ve covered quite a bit about cloud computing, but the key takeaway is that even though it was originally intended to add programmability to computers, cloud computing is also growing in the network space. </span><span class="koboSpan" id="kobo.543.2">One of the most programmable networks in this space is OpenStack, which we are going to explore next.</span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.544.1">Using OpenStack for networking</span></h1>
<p><span class="koboSpan" id="kobo.545.1">In contrast to OpenFlow, OpenStack</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.546.1"> has been busy and promising. </span><span class="koboSpan" id="kobo.546.2">It started in 2010 after a joint project between NASA and Rackspace. </span><span class="koboSpan" id="kobo.546.3">Rackspace wanted to rewrite the infrastructure code running its cloud servers and at the same time, Anso Labs (contracting for NASA) had published beta code for Nova, a Python-based cloud computing fabric controller.</span></p>
<p><span class="koboSpan" id="kobo.547.1">By 2012, the OpenStack Foundation was established to promote OpenStack software to the cloud community. </span><span class="koboSpan" id="kobo.547.2">By 2018, more than 500 companies had joined the OpenStack Foundation. </span><span class="koboSpan" id="kobo.547.3">By the end of 2020, the foundation announced</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.548.1"> that would change its name starting in 2021 to the </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">Open Infrastructure Foundation</span></strong><span class="koboSpan" id="kobo.550.1">. </span><span class="koboSpan" id="kobo.550.2">The reason is that the foundation started to add other projects to OpenStack, and therefore the name would not reflect their goals.</span></p>
<p><span class="koboSpan" id="kobo.551.1">OpenStack tracks its versions with different names; the first version in 2010 was called Austin, which included</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.552.1"> two components (Nova and Swift). </span><span class="koboSpan" id="kobo.552.2">By 2015, the new version of OpenStack</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.553.1"> had arrived, which was called Kilo and had 12 components. </span><span class="koboSpan" id="kobo.553.2">By October 2021, OpenStack Xena had</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.554.1"> been released, with 38 service components (</span><a href="https://docs.openstack.org/xena/"><span class="koboSpan" id="kobo.555.1">https://docs.openstack.org/xena/</span></a><span class="koboSpan" id="kobo.556.1">).</span></p>
<p><span class="koboSpan" id="kobo.557.1">For us, what matters in OpenStack are the components that will allow us to automate the network infrastructure. </span><span class="koboSpan" id="kobo.557.2">Although not designed for physical devices, the API methods for networking might be extended</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.558.1"> to physical devices instead of being only used in cloud virtual environments. </span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.559.1">OpenStack Neutron</span></h2>
<p><span class="koboSpan" id="kobo.560.1">The goal of OpenStack</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.561.1"> is to create standard services that allow software engineers to integrate their applications with cloud computing services. </span><span class="koboSpan" id="kobo.561.2">The Xena version released in October 2021 had 38 services available.</span></p>
<p><span class="koboSpan" id="kobo.562.1">One of the most important</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.563.1"> services for networking is called </span><strong class="bold"><span class="koboSpan" id="kobo.564.1">Neutron</span></strong><span class="koboSpan" id="kobo.565.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">OpenStack Networking</span></strong><span class="koboSpan" id="kobo.567.1">), which is an OpenStack project</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.568.1"> aimed at providing </span><em class="italic"><span class="koboSpan" id="kobo.569.1">network connectivity as a service</span></em><span class="koboSpan" id="kobo.570.1"> between interface devices. </span><span class="koboSpan" id="kobo.570.2">It implements the OpenStack networking API.</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.571.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.572.1">Neutron API definitions</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.573.1"> can be found at the following link: </span><a href="https://docs.openstack.org/api-ref/network/"><span class="koboSpan" id="kobo.574.1">https://docs.openstack.org/api-ref/network/</span></a><span class="koboSpan" id="kobo.575.1">.</span></p>
<p><span class="koboSpan" id="kobo.576.1">Neutron manages</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.577.1"> all networking configurations for the </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">virtual networking infrastructure</span></strong><span class="koboSpan" id="kobo.579.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.580.1">VNI</span></strong><span class="koboSpan" id="kobo.581.1">) and the access layer aspects of the </span><strong class="bold"><span class="koboSpan" id="kobo.582.1">physical networking infrastructure</span></strong><span class="koboSpan" id="kobo.583.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.584.1">PNI</span></strong><span class="koboSpan" id="kobo.585.1">). </span><span class="koboSpan" id="kobo.585.2">It also enables projects to create advanced virtual network</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.586.1"> topologies, which may include services such as a firewall and a VPN. </span><span class="koboSpan" id="kobo.586.2">It provides networks, subnets, and routers as object abstractions. </span><span class="koboSpan" id="kobo.586.3">Each abstraction has functionality that mimics its physical counterpart: networks contain subnets, and routers route traffic between different subnets and networks.</span></p>
<p><span class="koboSpan" id="kobo.587.1">For more details</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.588.1"> on Neutron, visit the following link: </span><a href="https://docs.openstack.org/neutron"><span class="koboSpan" id="kobo.589.1">https://docs.openstack.org/neutron</span></a><span class="koboSpan" id="kobo.590.1">.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.591.1">The Neutron API</span></h2>
<p><span class="koboSpan" id="kobo.592.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">Neutron API</span></strong><span class="koboSpan" id="kobo.594.1"> is a RESTful HTTP service that uses all</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.595.1"> aspects of the HTTP protocol, including methods, URIs, media types, response codes, and more. </span><span class="koboSpan" id="kobo.595.2">API clients can use existing features of the protocol, including caching, persistent connections, and content compression.</span></p>
<p><span class="koboSpan" id="kobo.596.1">As an example, let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">HTTP GET</span></strong><span class="koboSpan" id="kobo.598.1"> BGP peers’ method.</span></p>
<p><span class="koboSpan" id="kobo.599.1">To obtain a list of BGP peers use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">HTTP</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.601.1">GET</span></strong><span class="koboSpan" id="kobo.602.1"> request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">/v2.0/bgp-peers</span></strong><span class="koboSpan" id="kobo.604.1">. </span><span class="koboSpan" id="kobo.604.2">The possible responses are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.605.1">Normal response codes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">200</span></strong></li>
<li><span class="koboSpan" id="kobo.607.1">Error response codes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">400, 401, 403</span></strong></li>
</ul>
<p><span class="koboSpan" id="kobo.609.1">Fields that can be added to the API request: </span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.610.1">Name</span></strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.611.1">In</span></strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.612.1">Type</span></strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.613.1">Description</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">fields </span></strong><span class="koboSpan" id="kobo.615.1">(optional)</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.616.1">Query</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.617.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.618.1">The fields that you want the server to return. </span><span class="koboSpan" id="kobo.618.2">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">fields</span></strong><span class="koboSpan" id="kobo.620.1"> query parameter is not specified, the networking API returns all attributes allowed by the policy settings. </span><span class="koboSpan" id="kobo.620.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">fields</span></strong><span class="koboSpan" id="kobo.622.1"> parameter, the API returns only the requested set of attributes. </span><span class="koboSpan" id="kobo.622.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">fields</span></strong><span class="koboSpan" id="kobo.624.1"> parameter can be specified multiple times. </span><span class="koboSpan" id="kobo.624.2">For example, if you specify </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">fields=id&amp;fields=name</span></strong><span class="koboSpan" id="kobo.626.1"> in the request URL, only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">id</span></strong><span class="koboSpan" id="kobo.628.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">name</span></strong><span class="koboSpan" id="kobo.630.1"> attributes will be returned.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.631.1">Table 2.1 – API request fields</span></p>
<p><span class="koboSpan" id="kobo.632.1">The parameters that are returned in the API response are as follows:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.633.1">Name</span></strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.634.1">In</span></strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.635.1">Type</span></strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.636.1">Description</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">bgp_peers</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.638.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.639.1">Array</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.640.1">A list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">bgp_peer</span></strong><span class="koboSpan" id="kobo.642.1"> objects. </span><span class="koboSpan" id="kobo.642.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">bgp_peer</span></strong><span class="koboSpan" id="kobo.644.1"> object represents real BGP infrastructure, such as routers, route reflectors, and route servers.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">remote_as</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.646.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.647.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.648.1">The remote autonomous system number of the BGP peer.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">name</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.650.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.651.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.652.1">A more descriptive name of the BGP peer.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">peer_ip</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.654.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.655.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.656.1">The IP address of the peer.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">id</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.658.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.659.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.660.1">The ID of the BGP peer.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">tenant_id</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.662.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.663.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.664.1">The ID of the tenant.</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">project_id</span></strong></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.666.1">Body</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.667.1">String</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.668.1">The ID of the project.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.669.1">Table 2.2 – API response fields</span></p>
<p><span class="koboSpan" id="kobo.670.1">The following</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.671.1"> is an example of the API response:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.672.1">
{ 
    "bgp_peers":[ 
    { 
        "auth_type":"none", 
        "remote_as":1001, 
        "name":"bgp-peer",
        "tenant_id":"34a6e17a48cf414ebc890367bf42266b", 
        "peer_ip":"10.0.0.3", 
        "id":"a7193581-a31c-4ea5-8218-b3052758461f" 
    }
    ]
}</span></pre>
<p><span class="koboSpan" id="kobo.673.1">The API</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.674.1"> is well documented at the following link: </span><a href="https://docs.openstack.org/api-ref/network/"><span class="koboSpan" id="kobo.675.1">https://docs.openstack.org/api-ref/network/</span></a><span class="koboSpan" id="kobo.676.1">.</span></p>
<p><span class="koboSpan" id="kobo.677.1">As we have seen</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.678.1"> in this section, OpenStack is perhaps the cloud computing platform that is closest to network programming, as demonstrated by the CloudStack Neutron API. </span><span class="koboSpan" id="kobo.678.2">Additional features are probably going to be added as more network elements are migrated to the cloud. </span><span class="koboSpan" id="kobo.678.3">You should now be familiar with OpenStack terms and be able to explore them in depth if necessary.</span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.679.1">Summary </span></h1>
<p><span class="koboSpan" id="kobo.680.1">In this chapter, we talked about how programmable networks have evolved up until the present day. </span><span class="koboSpan" id="kobo.680.2">We discussed the history of data plane and control plane separation. </span><span class="koboSpan" id="kobo.680.3">We’ve seen how network virtualization has improved over time. </span><span class="koboSpan" id="kobo.680.4">We also looked at some technologies and standards for SDNs and cloud networking, such as OpenFlow and OpenStack. </span></p>
<p><span class="koboSpan" id="kobo.681.1">You now have the knowledge required to understand why some technologies are used today to automate and code networks.  </span></p>
<p><span class="koboSpan" id="kobo.682.1">In the next chapter, we’re going to dive deeper into the methods, protocols, and standards used to configure and communicate with network devices.</span></p>
</div>
</body></html>