- en: '*Chapter 18*: Other Creational Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered a third creational pattern, builder, which
    offers a nice way of creating the various parts of a complex object. Apart from
    the factory method, the abstract factory, and the builder patterns covered so
    far, other creational patterns are interesting to discuss, such as the **prototype**
    pattern and the **singleton** pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics will complete our discussions on creational patterns and help cover
    the use cases where the design patterns we have seen so far are not appropriate.
    By the end of the chapter, we will have an overall understanding of creational
    patterns and the use cases of each one.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter18](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter18).'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype pattern is useful when you need to create objects based on an
    existing object using the **cloning** technique. As you may have guessed, the
    idea is to use a copy of that object's complete structure to produce the new object.
    We will see that this is almost natural in Python because we have a **copy** feature
    that helps greatly in using this technique. In the general case of creating a
    copy of an object, what happens is that you make a new reference to the same object,
    a method called a **shallow copy**. But if you need to duplicate the object, which
    is the case with a prototype, you make a **deep copy**.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to create an exact copy of an object. For instance, assume
    that you want to create an application for storing, sharing, and editing presentation
    and marketing content for products promoted by a group of salespeople. Think of
    the popular distribution model called **direct selling** or **network marketing**,
    the home-based activity where individuals partner with a company to distribute
    products within their social network using promotional tools (brochures, PowerPoint
    presentations, videos, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Let's say a user, *Bob*, leads a team of distributors within a network marketing
    organization. They use a presentation video daily to introduce the product to
    their prospects. At some point, Bob gets his friend, Alice, to join him and she
    also uses the same video (one of the governing principles is to follow the system
    or, as they say, *Duplicate what already works*). But Alice soon finds prospects
    that could join her team and help her business grow, if only the video was in
    French, or at least subtitled. *What should they do?* The original presentation
    video cannot be used for the different custom needs that may arise.
  prefs: []
  type: TYPE_NORMAL
- en: To help everyone, the system could allow distributors with certain rank or trust
    levels, such as *Bob*, to create independent copies of the original presentation
    video, as long as the new version is validated by the compliance team of the backing
    company before public use. Each copy is called a **clone**; it is an exact copy
    of the original object at a specific point in time.
  prefs: []
  type: TYPE_NORMAL
- en: So, Bob, with the validation of the compliance team, makes a copy of the presentation
    video to address the new need and hands it over to Alice. She could then adapt
    that version by adding French subtitles.
  prefs: []
  type: TYPE_NORMAL
- en: With cloning, Bob and Alice can have their own copy of a video, and as such,
    changes by each one of them will not affect the other person's version of the
    material. In the alternative situation, which is what actually happens by default,
    each person would hold a reference to the same (reference) object; changes made
    by Bob would impact Alice, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype design pattern helps us with creating object clones. In its simplest
    version, this pattern is just a `clone()` function that accepts an object as an
    input parameter and returns a clone of it. In Python, this can be done using the
    `deepcopy()` function from the `copy` module.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of our discussions will be the same as in previous chapters. First,
    we will briefly discuss real-life applications and use cases, and then implement
    a hands-on example in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A famous non-technical example is the sheep named Dolly, which was created by
    researchers in Scotland by cloning a cell from a mammary gland.
  prefs: []
  type: TYPE_NORMAL
- en: Many Python applications make use of the prototype pattern (`j.mp/pythonprot`),
    but it is seldom referred to as *prototype* since cloning objects is a built-in
    feature of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern is useful when we have an existing object that needs to
    stay untouched, and we want to create an exact copy of it, allowing changes in
    some parts of the copy.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the frequent need for duplicating an object that is populated
    from a database and has references to other database-based objects. It is costly
    (multiple queries to a database) to clone such a complex object, so a prototype
    is a convenient way to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nowadays, some organizations, even of small size, deal with many websites and
    apps via their infrastructure/DevOps teams, hosting providers, or cloud service
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: When you have to manage multiple websites, there is a point where it becomes
    difficult to manage everything. You need to access information quickly, such as
    IP addresses that are involved, domain names and their expiration dates, and maybe
    details about the DNS parameters. So, you need a kind of inventory tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine how these teams deal with this type of data for daily activities
    and touch on the implementation of a piece of software that helps consolidate
    and maintain the data (other than in Excel spreadsheets):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import Python''s standard `copy` module, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the heart of this system, we will have a `Website` class for holding all
    the useful information such as the name, the domain name, the description, and
    the author of a website we are managing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `__init__()` method of the class, only some parameters are fixed, `name`,
    `domain`, `description`, and `author`, which correspond to the information we
    listed previously. But we also want flexibility, and client code can pass more
    parameters in the form of keywords (`name=value`) using the `kwargs` variable-length
    collection (a Python dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is a Python idiom to set an arbitrary attribute named `attr`
    with a value, `val`, on an object, `obj`, using the `setattr()` built-in function:
    `setattr(obj, attr, val)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are using this technique for the optional attributes of our class, at
    the end of the initialization method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our `Website` class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, the `Prototype` class implements the prototype design pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the heart of the `Prototype` class is the `clone()` method, which is in charge
    of cloning the object using the `copy.deepcopy()` function. Since cloning means
    we allow values to be set for optional attributes, notice how we use the `setattr()`
    technique here with the `attrs` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, for more convenience, the `Prototype` class contains the `register()`
    and `unregister()` methods, which can be used to keep track of the cloned objects
    in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, as shown in the following code, we can clone a first
    `Website` instance, `site1`, to get a second object, `site2`. Basically, we instantiate
    the `Prototype` class and we use its `.clone()` method. That is what the following
    code shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To end that function, we can use the `id()` function, which returns the memory
    address of an object, for comparing both objects'' addresses, as follows. When
    we clone an object using a deep copy, the memory addresses of the clone must be
    different from the memory addresses of the original object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will find the program''s full code in the `prototype.py` file. Here is
    a summary of what we do in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the `copy` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Website` class, with its initialization method, `(__init__())`,
    and its string representation method `(__str__()`), as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define our `Prototype` class as shown earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have the `main()` function, where we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `keywords` list we need.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create the instance of the `Website` class, called `site1` (we use the `keywords`
    list here).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create the `Prototype` object and we use its `register()` method to register
    `site1` with its identifier (this helps us keep track of the cloned objects in
    a dictionary).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We clone the `site1` object to get `site2`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We display the result (both `Website` objects)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following is the sample output when I execute the `python prototype.py` command
    on my machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, `Prototype` works as expected. We can see the information about the
    original `Website` object and its clone. Looking at the output of the `id()` function,
    we can see that the two addresses are different.
  prefs: []
  type: TYPE_NORMAL
- en: With this program, we mark the end of our discussion on the prototype pattern.
    In the next section, we will cover the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton pattern offers a way to implement a class from which you can only
    create one object, hence the name singleton. As you will understand with our exploration
    of this pattern, or while doing your own research, there have always been discussions
    about this pattern, and some even consider it an **anti-pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, what is interesting is that it is useful when we need to create
    one and only one object, for example, to store and maintain a global state for
    our program. In Python, this pattern can be implemented using some special built-in
    features.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern restricts the instantiation of a class to *one* object,
    which is useful when you need one object to coordinate actions for the system.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that only one instance of a particular class is created for
    the needs of the program. To ensure that this works, we need mechanisms that prevent
    the instantiation of the class more than once and also prevent cloning.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's discuss some real-life examples of the singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can think of a captain of a ship or a boat as a real-life example of the
    singleton pattern. On the ship, he is the one in charge. He is responsible for
    important decisions, and several requests are directed to him because of this
    responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: In software, the Plone CMS has, at its core, an implementation of the singleton.
    There are actually several singleton objects available at the root of a Plone
    site, called `singleton` class, and you can't create another instance of that
    `singleton` class in the context of the site.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated previously, one use case of the singleton pattern is to create a
    single object that maintains the global state of your program. Other possible
    use cases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling concurrent access to a shared resource; for example, an object class
    that manages the connection to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service or resource that is transversal in the sense that it can be accessed
    from different parts of the application or by different users and does its work;
    for example, the class at the core of the logging system or utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's implement a program to fetch content from web pages, inspired by the tutorial
    from Michael Ford ([https://docs.python.org/3/howto/urllib2.html](https://docs.python.org/3/howto/urllib2.html)).
    We have only taken the simple part since the focus is to illustrate our pattern
    more than it is to build a special web-scraping tool.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `urllib` module to connect to web pages using their URLs; the
    core of the program would be the `URLFetcher` class, which takes care of doing
    the work via a `fetch()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to be able to track the list of web pages that were tracked, hence
    the use of the singleton pattern. We need a single object to maintain that global
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our naive version, inspired by the tutorial but modified to help us
    track the list of URLs that were fetched, would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As an exercise, add the usual `if __name__ == '__main__'` block with a few lines
    of code to call the `.fetch()` method on an instance of `URLFetcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But then, does our class implement a singleton? Here is a clue. To create a
    singleton, we need to make sure you can only create one instance of it. So, to
    see whether our class implements a singleton, we could use a trick that consists
    of comparing two instances using the `is` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have guessed the second exercise. Put the following code in your `if
    __name__ == ''__main__''` block instead of what you had previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, use this concise, but still elegant, form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this change, when executing the program, you should get `False` as the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Okay! This means that the first try does not yet give us a singleton. Remember,
    we want to manage a global state, using one, and only one, instance of the class
    for the program. The current version of the class does not yet implement a singleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After checking the literature and the forums on the web, you will find that
    there are several techniques, each with pros and cons, and some are probably outdated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since many people use Python 3 nowadays, the recommended technique we will
    choose is the **metaclass** technique. We first implement a metaclass for the
    singleton. This class implements the singleton pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will rewrite our `URLFetcher` class to use that metaclass. We also
    add a `dump_url_registry()` method, which is useful for getting the current list
    of URLs tracked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, you get `True` by executing the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete the program to do what we wanted, using a `main()` function
    that we will call as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will find the program''s full code in the `singleton.py` file. Here is
    a summary of what we do:'
  prefs: []
  type: TYPE_NORMAL
- en: We start with our required module imports (`urllib.parse` and `urllib.request`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown earlier, we define the `SingletonType` class, with its special `__call__()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown earlier, we define `URLFetcher`, the class implementing the fetcher
    for the web pages, initializing it with the `urls` attribute. As discussed, we
    add its `fetch()` and `dump_url_registry()` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add our `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we add Python's conventional snippet used to call the `main` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the output when executing the `python singleton.py` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that we get the expected result: both the content of the pages that
    the program was able to connect to and the list of URLs the operation was successful
    for.'
  prefs: []
  type: TYPE_NORMAL
- en: We see that the URL, `https://www.python.org/error`, does not come in the list
    returned by `fetcher.dump_url_registry()`; indeed, it is an erroneous URL and
    the `urlllib` request to it gets a `404` response code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The link to the preceding URL is not supposed to work; that's exactly the point.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen how to use two other creational design patterns:
    the prototype and the singleton.'
  prefs: []
  type: TYPE_NORMAL
- en: A prototype is used to create exact copies of objects. As seen in the implementation
    example we discussed, using a prototype in Python is natural and based on built-in
    features, so it is not something even mentioned. The singleton pattern can be
    implemented by making the `singleton` class use a metaclass, its type, having
    previously defined said metaclass. As required, the metaclass's `__call__()` method
    holds the code that ensures that only one instance of the class can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, these two design patterns help us implement the use cases that other
    creational patterns do not support; in effect, we have grown our design pattern
    toolbox to cover more use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about the adapter pattern, a structural design pattern that
    can be used to make two incompatible software interfaces compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the high-level benefits of using the prototype pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the prototype pattern useful in the specific case of database management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the high-level benefits of using the singleton pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the context of concurrency, in which situation should the singleton pattern
    be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Design Patterns* by Gamma Enrich, Helm Richard, Johnson Ralph, and Vlissides
    John available at [https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)'
  prefs: []
  type: TYPE_NORMAL
