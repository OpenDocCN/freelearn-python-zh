<html><head></head><body>
  <div><h1 class="chapterNumber">Appendix</h1>
    <h1 id="_idParaDest-249" class="chapterTitle">Answers to the Questions</h1>
    <h1 id="_idParaDest-250" class="heading-1">Chapter 2: Introduction to Algorithm Design</h1>
    <h2 id="_idParaDest-251" class="heading-2">Question 1</h2>
    <p class="normal">Find the time complexity of the following Python snippets:</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">
        <pre class="programlisting code"><code class="hljs-code">i=1 
while(i&lt;n): 
    i*=2 
    print("data")
</code></pre>
      </li>
      <li class="alphabeticList">
        <pre class="programlisting code"><code class="hljs-code">i =n
while(i&gt;0):
    print("complexity")
    i/ = 2
</code></pre>
      </li>
      <li class="alphabeticList">
        <pre class="programlisting code"><code class="hljs-code">for i in range(1,n):
    j = i 
    while(j&lt;n):
        j*=2
</code></pre>
      </li>
      <li class="alphabeticList">
        <pre class="programlisting code"><code class="hljs-code">i=1
while(i&lt;n): 
    print("python")
    i = i**2
</code></pre>
      </li>
    </ol>
    <h2 id="_idParaDest-252" class="heading-2">Solution</h2>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">The complexity will be <code class="inlineCode">O(log(n))</code>. <p class="normal">As we are multiplying the integer <code class="inlineCode">i</code> by <code class="inlineCode">2</code> in each step there will be exactly <code class="inlineCode">log(n)</code> steps. (<code class="inlineCode">1</code>, <code class="inlineCode">2</code>, <code class="inlineCode">4</code>, …… till <code class="inlineCode">n</code>).</p>
      </li>
    </ol>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="2">The complexity will be <code class="inlineCode">O(log(n))</code>. <p class="normal">As we are dividing the integer <code class="inlineCode">i</code> by <code class="inlineCode">2</code> in each step there will be exactly <code class="inlineCode">log(n)</code> steps. (<code class="inlineCode">n</code>, <code class="inlineCode">n</code>/<code class="inlineCode">2</code>, <code class="inlineCode">n</code>/<code class="inlineCode">4</code>, …… till <code class="inlineCode">1</code>).</p>
      </li>
    </ol>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="3">The outer loop will run <code class="inlineCode">n</code> times for each <code class="inlineCode">i</code> in the outer loop, while the inner <code class="inlineCode">while</code> loop will run <code class="inlineCode">log(i)</code> times because we are multiplying each of the <code class="inlineCode">j</code> values by <code class="inlineCode">2</code> until it is less than <code class="inlineCode">n</code>. Hence, there will be a maximum of <code class="inlineCode">log(n)</code> steps in the inner loop. Therefore, the overall complexity will <code class="inlineCode">be</code> <code class="inlineCode">O(nlog(n))</code>. <pre>while</code> loop will execute based on the value of <code class="inlineCode">i</code> until the condition becomes <code class="inlineCode">false</code>. The value of <code class="inlineCode">i</code> is incrementing in the following series:</pre>
        <p class="normal"><code class="inlineCode">2, 4, 16, 256, ... n </code></p>
        <p class="normal">We can see that the number of times the loop is executing is log<sub class="subscript">2</sub>(log<sub class="subscript">2</sub>(n)) for a given value of <code class="inlineCode">n</code>. So, for this series there will be exactly log<sub class="subscript">2</sub>(log<sub class="subscript">2</sub>(n)) executions of the loop. Hence the time complexity will be O(log<sub class="subscript">2</sub>(log<sub class="subscript">2</sub>(n)).</p>
      </li>
    </ol>
    <h1 id="_idParaDest-253" class="heading-1">Chapter 3: Algorithm Design Techniques and Strategies</h1>
    <h2 id="_idParaDest-254" class="heading-2">Question 1</h2>
    <p class="normal">Which of the following options will be correct when a top-down approach of dynamic programming is applied to solve a given problem related to the space and time complexity?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">It will increase both time and space complexity</li>
      <li class="alphabeticList">It will increase the time complexity, and decrease the space complexity</li>
      <li class="alphabeticList">It will increase the space complexity, and decrease the time complexity</li>
      <li class="alphabeticList">It will decrease both time and space complexities</li>
    </ol>
    <h2 id="_idParaDest-255" class="heading-2">Solution</h2>
    <p class="normal">Option c is correct.</p>
    <p class="normal">Since the top-down approach of dynamic programming uses the memoization technique, which stores the pre-calculated solution of a subproblem. It avoids recalculation of the same subproblem that decreases the time complexity, but at the same time, the space complexity will increase because of storing the extra solutions of the subproblems.</p>
    <h2 id="_idParaDest-256" class="heading-2">Question 2</h2>
    <p class="normal">What will be the sequence of nodes in the following edge-weighted directed graph using the greedy approach (assume node <strong class="keyWord">A</strong> as the source)?</p>
    <figure class="mediaobject"><img src="img/B17217_15_01.png" alt=""/></figure>
    <p class="packt_figref">Figure A.1: A weighted directed graph</p>
    <h2 id="_idParaDest-257" class="heading-2">Solution</h2>
    <p class="normal">A, B, C, F, E, D</p>
    <p class="normal">In Dijkstra’s algorithm, at each, point we choose the smallest weight edge, which starts from any one of the vertices in the shortest path found so far, and add it to the shortest path.</p>
    <h2 id="_idParaDest-258" class="heading-2">Question 3</h2>
    <p class="normal">Consider the weights and values of the items in <em class="italic">Table 3.8</em>. Note that there is only one unit of each item.</p>
    <table id="table001-6" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Item</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Weight</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Value</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">A</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">10</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">B</p>
          </td>
          <td class="table-cell">
            <p class="normal">10</p>
          </td>
          <td class="table-cell">
            <p class="normal">8</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">C</p>
          </td>
          <td class="table-cell">
            <p class="normal">4</p>
          </td>
          <td class="table-cell">
            <p class="normal">5</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">D</p>
          </td>
          <td class="table-cell">
            <p class="normal">7</p>
          </td>
          <td class="table-cell">
            <p class="normal">6</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table A.1: The weights and values of different items</p>
    <p class="normal">We need to maximize the value; the maximum weight should be 11 kg. No item may be split. Establish the values of the items using a greedy approach.</p>
    <h2 id="_idParaDest-259" class="heading-2">Solution</h2>
    <p class="normal">Firstly, we picked item A (weight 2 kg) as the value is the maximum (10). The second highest value is for item B, but as the total weight becomes 12 kg, this violates the given condition, so we cannot pick it. The next highest value is item D, and now the total weight becomes 2+7 = 9 kg (item A + item D). The next remaining item, C, cannot be picked because after adding it, the total weight condition will be violated.</p>
    <p class="normal">So, the total value of the items picked up using the greedy approach = 10 + 6 = 16</p>
    <h1 id="_idParaDest-260" class="heading-1">Chapter 4: Linked Lists</h1>
    <h2 id="_idParaDest-261" class="heading-2">Question 1</h2>
    <p class="normal">What will be the time complexity when inserting a data element after an element that is being pointed to by a pointer in a linked list?</p>
    <h2 id="_idParaDest-262" class="heading-2">Solution</h2>
    <p class="normal">It will be <code class="inlineCode">O(1)</code>, since there is no need to traverse the list to reach the desired location where a new element is to be added. A pointer is pointing to the current location, and a new element can be directly added by linking it.</p>
    <h2 id="_idParaDest-263" class="heading-2">Question 2</h2>
    <p class="normal">What will be the time complexity when ascertaining the length of the given linked list?</p>
    <h2 id="_idParaDest-264" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">O(n)</code>.</p>
    <p class="normal">In order to find out the length, each node of the list has to be traversed, which will take <code class="inlineCode">O(n)</code>.</p>
    <h2 id="_idParaDest-265" class="heading-2">Question 3</h2>
    <p class="normal">What will be the worst-case time complexity for searching a given element in a singly linked list of length n?</p>
    <h2 id="_idParaDest-266" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">O(n)</code>.</p>
    <p class="normal">In the worst case, the data element to be searched will be at the end of the list, or will not be present in the list. In that case, there will be a total <code class="inlineCode">n</code> number of comparisons, thus making the worst-case time complexity <code class="inlineCode">O(n)</code>.</p>
    <h2 id="_idParaDest-267" class="heading-2">Question 4</h2>
    <p class="normal">For a given linked list, assuming it has only one <code class="inlineCode">head</code> pointer that points to the starting point of the list, what will be the time complexity for the following operations?</p>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">Insertion at the front of the linked list</li>
      <li class="alphabeticList">Insertion at the end of the linked list</li>
      <li class="alphabeticList">Deletion of the front node of the linked list</li>
      <li class="alphabeticList">Deletion of the last node of the linked list</li>
    </ol>
    <h2 id="_idParaDest-268" class="heading-2">Solution</h2>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1"><code class="inlineCode">O(1)</code>. This operation can be performed directly through the head node.</li>
      <li class="alphabeticList"><code class="inlineCode">O(n)</code>. It will require traversing the list to reach the end of the list.</li>
      <li class="alphabeticList"><code class="inlineCode">O(1)</code>. This operation can be performed directly through the head node.</li>
      <li class="alphabeticList"><code class="inlineCode">O(n)</code>. It will require traversing the list to reach the end of the list.</li>
    </ol>
    <h2 id="_idParaDest-269" class="heading-2">Question 5</h2>
    <p class="normal">Find the n<sup class="superscript">th</sup> node from the end of a linked list.</p>
    <h2 id="_idParaDest-270" class="heading-2">Solution</h2>
    <p class="normal">In order to find out the n<sup class="superscript">th</sup> node from the end of the linked list, we can use two pointers – <code class="inlineCode">f</code><code class="inlineCode">irst</code> and <code class="inlineCode">second</code>. Firstly, move the second pointer to <code class="inlineCode">n</code> nodes from the starting point. Then, move both the pointers one step at a time until the second pointer reaches the end of the list. At that time, the first pointer will point to the n<sup class="superscript">th</sup> node from the end of the list.</p>
    <h2 id="_idParaDest-271" class="heading-2">Question 6</h2>
    <p class="normal">How can you establish whether there is a loop (or circle) in a given linked list?</p>
    <h2 id="_idParaDest-272" class="heading-2">Solution</h2>
    <p class="normal">To find out the loop in a linked list, it is most efficient to use <strong class="keyWord">Floyd’s cycle-finding algorithm</strong>. In this approach, two pointers are used to detect the loop – let’s say the first and second pointers. We start moving both the pointers from the starting point of the list. </p>
    <p class="normal">We move the first and second pointers by one and two nodes at a time. If these two pointers meet at the same node, that indicates that there is a loop, otherwise, there is no loop in the given linked list.</p>
    <p class="normal">The process is shown in the below figure with an example:</p>
    <figure class="mediaobject"><img src="img/B17217_15_02.png" alt=""/></figure>
    <p class="packt_figref">Figure A.2: Loop in a singly linked list</p>
    <h2 id="_idParaDest-273" class="heading-2">Question 7</h2>
    <p class="normal">How can you ascertain the middle element of the linked list?</p>
    <h2 id="_idParaDest-274" class="heading-2">Solution</h2>
    <p class="normal">It can be done with two pointers, say, the first and second pointers. Start moving these two pointers from the starting node. The first and second pointers should move one and two nodes at a time, respectively. When the second node reaches the end of the list, the first node will point to the middle element of the singly linked list.</p>
    <h1 id="_idParaDest-275" class="heading-1">Chapter 5: Stacks and Queues</h1>
    <h2 id="_idParaDest-276" class="heading-2">Question 1</h2>
    <p class="normal">Which of the following options is a true queue implementation using linked lists?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">If, in the enqueue operation, new data elements are added at the start of the list, then the dequeue operation must be performed from the end.</li>
      <li class="alphabeticList">If, in the enqueue operation, new data elements are added to the end of the list, then the enqueue operation must be performed from the start of the list.</li>
      <li class="alphabeticList">Both of the above.</li>
      <li class="alphabeticList">None of the above.</li>
    </ol>
    <h2 id="_idParaDest-277" class="heading-2">Solution</h2>
    <p class="normal">B is correct. The queue data structure follows a FIFO order, hence data elements must be added to the end of the list, and then removed from the front.</p>
    <h2 id="_idParaDest-278" class="heading-2">Question 2</h2>
    <p class="normal">Assume a queue is implemented using a singly linked list that has <code class="inlineCode">head</code> and <code class="inlineCode">tail</code> pointers. The enqueue operation is implemented at <code class="inlineCode">head</code>, and the dequeue operation is implemented at the <code class="inlineCode">tail</code> of the queue. What will be the time complexity of the enqueue and dequeue operations?</p>
    <h2 id="_idParaDest-279" class="heading-2">Solution</h2>
    <p class="normal">The time complexity of the enqueue operation will be <code class="inlineCode">O(1)</code> and <code class="inlineCode">O(n)</code> for the dequeue operation. As for the enqueue operation, we only need to delete the <code class="inlineCode">head</code> node, which can be achieved in <code class="inlineCode">O(1)</code> for a singly linked list. For the dequeue operation, to delete the <code class="inlineCode">tail</code>, we need to traverse the whole list first to the <code class="inlineCode">tail</code>, and then we can delete it. For this we need linear, <code class="inlineCode">O(n)</code>, time.</p>
    <h2 id="_idParaDest-280" class="heading-2">Question 3</h2>
    <p class="normal">What is the minimum number of stacks required to implement a queue?</p>
    <h2 id="_idParaDest-281" class="heading-2">Solution</h2>
    <p class="normal">Two stacks.</p>
    <p class="normal">Using two stacks and the enqueue operation, the new element is entered at the top of <code class="inlineCode">stack1</code>. In the dequeue process, if <code class="inlineCode">stack2</code> is empty, all the elements are moved to <code class="inlineCode">stack2</code>, and finally, the top of <code class="inlineCode">stack2</code> is returned.</p>
    <h2 id="_idParaDest-282" class="heading-2">Question 4</h2>
    <p class="normal">The enqueue and dequeue operations in a queue are implemented efficiently using an array. What will be the time complexity for both of these operations?</p>
    <h2 id="_idParaDest-283" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">O(1)</code> for both operations.</p>
    <p class="normal">If we use a circular array for the implementation of a queue, then we do not need to shift the elements, just the pointers, so we can implement both the enqueue and dequeue operations in <code class="inlineCode">O(1)</code> time.</p>
    <h2 id="_idParaDest-284" class="heading-2">Question 5</h2>
    <p class="normal">How can we print the data elements of a queue data structure in reverse order?</p>
    <h2 id="_idParaDest-285" class="heading-2">Solution</h2>
    <p class="normal">Make an empty stack, then enqueue each of the elements from the queue and push them into the stack. After the queue is empty, start popping out the elements from the stack and then printing them one by one.</p>
    <h1 id="_idParaDest-286" class="heading-1">Chapter 6: Trees</h1>
    <h2 id="_idParaDest-287" class="heading-2">Question 1</h2>
    <p class="normal">Which of the following is true about binary trees:</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">Every binary tree is either complete or full</li>
      <li class="alphabeticList">Every complete binary tree is also a full binary tree</li>
      <li class="alphabeticList">Every full binary tree is also a complete binary tree</li>
      <li class="alphabeticList">No binary tree is both complete and full</li>
      <li class="alphabeticList">None of the above</li>
    </ol>
    <h2 id="_idParaDest-288" class="heading-2">Solution</h2>
    <p class="normal">Option A is incorrect since it is not compulsory that a binary tree should be complete or full.</p>
    <p class="normal">Option B is incorrect since a complete binary tree can have some nodes that are not filled in the last level, so a complete binary tree will not always be a full binary tree.</p>
    <p class="normal">Option C is incorrect, as it is not always true, the following figure is a full binary tree, but not a complete binary tree:</p>
    <figure class="mediaobject"><img src="img/B17217_15_03.png" alt=""/></figure>
    <p class="packt_figref">Figure A.3: A binary tree that is full, but not complete</p>
    <p class="normal">Option D is incorrect, as it is not always true. The following tree is both a complete and full binary tree:</p>
    <figure class="mediaobject"><img src="img/B17217_15_04.png" alt=""/></figure>
    <p class="packt_figref">Figure A.4: A binary tree, that is full and complete</p>
    <h2 id="_idParaDest-289" class="heading-2">Question 2</h2>
    <p class="normal">Which of the tree traversal algorithms visit the root node last?</p>
    <h2 id="_idParaDest-290" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">postorder</code> traversal.</p>
    <p class="normal">Using <code class="inlineCode">postorder</code> traversal, we first visit the left subtree, then the right subtree, and finally we visit the <code class="inlineCode">root</code> node.</p>
    <h2 id="_idParaDest-291" class="heading-2">Question 3</h2>
    <p class="normal">Consider this binary search tree:</p>
    <figure class="mediaobject"><img src="img/B17217_15_05.png" alt=""/></figure>
    <p class="packt_figref">Figure A.5: Sample binary search tree</p>
    <p class="normal">Suppose we remove the root node <code class="inlineCode">8</code>, and we wish to replace it with any node from the left subtree then what will be the new root?</p>
    <h2 id="_idParaDest-292" class="heading-2">Solution</h2>
    <p class="normal">The new node will be node <code class="inlineCode">6</code>. To maintain the properties of the binary search tree, the maximum value from the left subtree should be the new root.</p>
    <h2 id="_idParaDest-293" class="heading-2">Question 4</h2>
    <p class="normal">What will be the <code class="inlineCode">inorder</code>, <code class="inlineCode">postorder</code>, and <code class="inlineCode">preorder</code> traversal of the following tree?</p>
    <figure class="mediaobject"><img src="img/B17217_15_06.png" alt=""/></figure>
    <p class="packt_figref">Figure A.6: Example tree</p>
    <h2 id="_idParaDest-294" class="heading-2">Solution</h2>
    <p class="normal">The <code class="inlineCode">preorder</code> traversal will be <code class="inlineCode">7</code>-<code class="inlineCode">5</code>-<code class="inlineCode">1</code>-<code class="inlineCode">6</code>-<code class="inlineCode">8</code>-<code class="inlineCode">9</code>.</p>
    <p class="normal">The <code class="inlineCode">inorder</code> traversal will be <code class="inlineCode">1</code>-<code class="inlineCode">5</code>-<code class="inlineCode">6</code>-<code class="inlineCode">7</code>-<code class="inlineCode">8</code>-<code class="inlineCode">9</code>.</p>
    <p class="normal">The <code class="inlineCode">postorder</code> traversal will be <code class="inlineCode">1</code>-<code class="inlineCode">6</code>-<code class="inlineCode">5</code>-<code class="inlineCode">9</code>-<code class="inlineCode">8</code>-<code class="inlineCode">7</code>.</p>
    <h2 id="_idParaDest-295" class="heading-2">Question 5</h2>
    <p class="normal">How do you find out if two trees are identical?</p>
    <h2 id="_idParaDest-296" class="heading-2">Solution</h2>
    <p class="normal">In order to find out if two binary trees are identical or not, both of the trees should have exactly the same data and element arrangement. This can be done by traversing both of the trees with any of the traversal algorithms (it should be the same for both trees) and matching them element by element. If all the elements are the same in traversing both of the trees, then the trees are identical.</p>
    <h2 id="_idParaDest-297" class="heading-2">Question 6</h2>
    <p class="normal">How many leaves are there in the tree mentioned in <em class="italic">question 4</em>?</p>
    <h2 id="_idParaDest-298" class="heading-2">Solution</h2>
    <p class="normal">Three, nodes <code class="inlineCode">1</code>, <code class="inlineCode">6</code>, and <code class="inlineCode">9</code>.</p>
    <h2 id="_idParaDest-299" class="heading-2">Question 7</h2>
    <p class="normal">What is the relation between a perfect binary tree’s height and the number of nodes in that tree?</p>
    <h2 id="_idParaDest-300" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">log<sub class="subscript">2</sub>(n+1) = h.</code></p>
    <p class="normal">The number of nodes in each level:</p>
    <p class="normal">Level <code class="inlineCode">0</code>: <code class="inlineCode">2</code><sup class="superscript">0</sup> = 1 nodes</p>
    <p class="normal">Level <code class="inlineCode">1</code>: <code class="inlineCode">2</code><sup class="superscript">1</sup> = 2 nodes</p>
    <p class="normal">Level <code class="inlineCode">2</code>: <code class="inlineCode">2</code><sup class="superscript">2</sup> = 4 nodes</p>
    <p class="normal">Level <code class="inlineCode">3</code>: <code class="inlineCode">2</code><sup class="superscript">3</sup> = 8 nodes</p>
    <p class="normal">The total nodes at level <code class="inlineCode">h</code> can be computed by adding all nodes in each level:</p>
    <p class="normal">n = 2<sup class="superscript">0 </sup>+ <sup class="superscript"> </sup>2<sup class="superscript">1 </sup>+ <sup class="superscript"> </sup>2<sup class="superscript">2 </sup>+ 2<sup class="superscript">3 </sup>+ ……. 2<sup class="superscript">h-1 </sup>= 2<sup class="superscript">h </sup>- 1</p>
    <p class="normal">So, the relationship between <code class="inlineCode">n</code> and <code class="inlineCode">h</code> is: <code class="inlineCode">n = 2</code><sup class="superscript">h</sup> - 1</p>
    <p class="normal"> = log (n+1) = log2<sup class="superscript">h</sup></p>
    <p class="normal"> = log<sub class="subscript">2</sub> (n+1) = h</p>
    <h1 id="_idParaDest-301" class="heading-1">Chapter 7: Heaps and Priority Queues</h1>
    <h2 id="_idParaDest-302" class="heading-2">Question 1</h2>
    <p class="normal">What will be the time complexity for deleting an arbitrary element from the <code class="inlineCode">min-heap</code>?</p>
    <h2 id="_idParaDest-303" class="heading-2">Solution</h2>
    <p class="normal">To delete any element from the <code class="inlineCode">heap</code>, we first have to search the element that is to be deleted, and then we delete the element.</p>
    <p class="normal">Total time complexity = Time for searching the element + Deleting the element</p>
    <p class="normal">= <code class="inlineCode">O(n)</code> + <code class="inlineCode">O(log n)</code></p>
    <p class="normal">= <code class="inlineCode">O(n)</code></p>
    <h2 id="_idParaDest-304" class="heading-2">Question 2</h2>
    <p class="normal">What will be the time complexity for finding the k<sup class="superscript">th</sup> smallest element from the <code class="inlineCode">min-heap</code>?</p>
    <h2 id="_idParaDest-305" class="heading-2">Solution</h2>
    <p class="normal">The k<sup class="superscript">th</sup> element can be found out from the <code class="inlineCode">min-heap</code> by performing <code class="inlineCode">delete</code> operations k times. For each <code class="inlineCode">delete</code> operation, the time complexity is <code class="inlineCode">O(logn)</code>. So, the total time complexity for finding out the k<sup class="superscript">th</sup> smallest element will be <code class="inlineCode">O(klogn)</code>.</p>
    <h2 id="_idParaDest-306" class="heading-2">Question 3</h2>
    <p class="normal">What will be the time complexity to make a <code class="inlineCode">max-heap</code> that combines two <code class="inlineCode">max-heap</code> each of size <code class="inlineCode">n</code>?</p>
    <h2 id="_idParaDest-307" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">O(n)</code>.</p>
    <p class="normal">Since the time complexity of creating a <code class="inlineCode">heap</code> from <code class="inlineCode">n</code> elements is <code class="inlineCode">O(n)</code>, creating a <code class="inlineCode">heap</code> of <code class="inlineCode">2n</code> elements will also be <code class="inlineCode">O(n)</code>.</p>
    <h2 id="_idParaDest-308" class="heading-2">Question 4</h2>
    <p class="normal">What will be the worst-case time complexity for ascertaining the smallest element from a binary max-heap and binary min-heap?</p>
    <h2 id="_idParaDest-309" class="heading-2">Solution</h2>
    <p class="normal">In a max-heap, the smallest element will always be present at a leaf node. So, in order to find out the smallest element, we have to search all the leaf nodes. So, the worst-case complexity will be <code class="inlineCode">O(n)</code>. </p>
    <p class="normal">The worst-case time complexity to find out the smallest element in the min-heap will be <code class="inlineCode">O(1)</code> since it will always be present at the root node.</p>
    <h2 id="_idParaDest-310" class="heading-2">Question 5</h2>
    <p class="normal">The level order traversal of <code class="inlineCode">max-heap</code> is <code class="inlineCode">12</code>, <code class="inlineCode">9</code>, <code class="inlineCode">7</code>, <code class="inlineCode">4</code>, <code class="inlineCode">2</code>. After inserting new elements <code class="inlineCode">1</code> and <code class="inlineCode">8</code>, what will be the final <code class="inlineCode">max-heap</code> and level order traversal of the final <code class="inlineCode">max-heap</code>?</p>
    <h2 id="_idParaDest-311" class="heading-2">Solution</h2>
    <p class="normal">The <code class="inlineCode">max-heap</code> after the insertion of element <code class="inlineCode">1</code> is shown in the below figure:</p>
    <figure class="mediaobject"><img src="img/B17217_15_07.png" alt=""/></figure>
    <p class="packt_figref">Figure A.7: The max-heap before insertion of element 8</p>
    <p class="normal">The final <code class="inlineCode">max-heap</code> after the insertion of element <code class="inlineCode">8</code> is shown in the below figure:</p>
    <figure class="mediaobject"><img src="img/B17217_15_08.png" alt=""/></figure>
    <p class="packt_figref">Figure A.8: The max-heap after the insertion of elements 1 and 8</p>
    <p class="normal">The level order traversal of the final <code class="inlineCode">max-heap</code> will be <code class="inlineCode">12</code>, <code class="inlineCode">9</code>, <code class="inlineCode">8</code>, <code class="inlineCode">4</code>, <code class="inlineCode">2</code>, <code class="inlineCode">1</code>, <code class="inlineCode">7</code>.</p>
    <h2 id="_idParaDest-312" class="heading-2">Question 6</h2>
    <p class="normal">Which of the following is a binary <code class="inlineCode">max-heap</code>?</p>
    <figure class="mediaobject"><img src="img/B17217_15_09.1.png" alt=""/></figure>
    <figure class="mediaobject"><img src="img/B17217_15_09.2.png" alt=""/></figure>
    <p class="packt_figref">Figure A.9: Example trees</p>
    <h2 id="_idParaDest-313" class="heading-2">Solution</h2>
    <p class="normal">B.</p>
    <p class="normal">A binary <code class="inlineCode">max-heap</code> should be a complete binary tree and all the levels should be filled, except the last level. The value of the parent should be greater or equal to the values of its children. </p>
    <p class="normal">Option A is not correct because it is not a complete binary tree. Options C and D are not correct because they are not fulfilling the <code class="inlineCode">heap</code> property. Option B is correct because it is complete and fulfills the <code class="inlineCode">heap</code> property.</p>
    <h1 id="_idParaDest-314" class="heading-1">Chapter 8: Hash Tables</h1>
    <h2 id="_idParaDest-315" class="heading-2">Question 1</h2>
    <p class="normal">There is a hash table with 40 slots and there are 200 elements stored in the table. What will be the load factor of the hash table?</p>
    <h2 id="_idParaDest-316" class="heading-2">Solution</h2>
    <p class="normal">The load factor of the hash table = (no. of elements) / (no. of table slots) = 200/40 = 5.</p>
    <h2 id="_idParaDest-317" class="heading-2">Question 2 </h2>
    <p class="normal">What is the worst-case search time of hashing using a separate chaining algorithm?</p>
    <h2 id="_idParaDest-318" class="heading-2">Solution</h2>
    <p class="normal">The worst-case time complexity for searching in a separate chaining algorithm using linked lists is <code class="inlineCode">O(n)</code>, because in the worst case, all the items will be added to <code class="inlineCode">index 1</code> in a linked list, searching an item will work similarly to a linked list.</p>
    <h2 id="_idParaDest-319" class="heading-2">Question 3</h2>
    <p class="normal">Assume a uniform distribution of keys in the hash table. What will be the time complexities for the <code class="inlineCode">search</code>/<code class="inlineCode">insert</code>/<code class="inlineCode">delete</code> operations?</p>
    <h2 id="_idParaDest-320" class="heading-2">Solution</h2>
    <p class="normal">The index of the hash table is computed from the key in <code class="inlineCode">O(1)</code> time when the keys are uniformly distributed in the hash table. The creation of the table will take <code class="inlineCode">O(n)</code> time, and other operations such as <code class="inlineCode">search</code>, <code class="inlineCode">insert</code>, and <code class="inlineCode">delete</code> operations will take <code class="inlineCode">O(1)</code> time because all the elements are uniformly distributed, hence, we directly get the required element.</p>
    <h2 id="_idParaDest-321" class="heading-2">Question 4</h2>
    <p class="normal">What will be the worst-case complexity for removing the duplicate characters from an array of characters?</p>
    <h2 id="_idParaDest-322" class="heading-2">Solution</h2>
    <p class="normal">The brute force algorithm starts with the first character and searches linearly with all the characters of the array. If a duplicate character is found, then that character should be swapped with the last character and then the length of the string should be decremented by one. The same process is repeated until all characters are processed. The time complexity of this process is O(n<sup class="superscript">2</sup>).</p>
    <p class="normal">It can be implemented more efficiently using a hash table in <code class="inlineCode">O(n)</code> time.</p>
    <p class="normal">Using this method, we start with the first character of the array and store it in the hash table according to the hash value. We do it for all the characters. If there is any collision, then that character can be ignored, otherwise, the character is stored in the hash table.</p>
    <h1 id="_idParaDest-323" class="heading-1">Chapter 9: Graphs and Algorithms</h1>
    <h2 id="_idParaDest-324" class="heading-2">Question 1</h2>
    <p class="normal">What is the maximum number of edges (without self-loops) possible in an undirected simple graph with five nodes?</p>
    <h2 id="_idParaDest-325" class="heading-2">Solution</h2>
    <p class="normal">Each node can be connected to every other node in the graph. So, the first node can be connected to <code class="inlineCode">n-1</code> nodes, the second node can be connected to <code class="inlineCode">n-2</code> nodes, the third node can be connected to <code class="inlineCode">n-3</code> nodes, and so on. The total number of nodes will be:</p>
    <p class="normal"><em class="italic">[(n-1)+(n-2)+ … +3+2+1] = n(n-1)/2.</em></p>
    <h2 id="_idParaDest-326" class="heading-2">Question 2</h2>
    <p class="normal">What do we call a graph in which all the nodes have an equal degree?</p>
    <h2 id="_idParaDest-327" class="heading-2">Solution</h2>
    <p class="normal">A complete graph.</p>
    <h2 id="_idParaDest-328" class="heading-2">Question 3</h2>
    <p class="normal">Explain what cut vertices are and identify the cut vertices in the given graph?</p>
    <figure class="mediaobject"><img src="img/B17217_15_10.png" alt=""/></figure>
    <p class="packt_figref">Figure A.10: Sample graph</p>
    <h2 id="_idParaDest-329" class="heading-2">Solution</h2>
    <p class="normal">Cut vertices also known as articulation points. These are the vertices in the graph, after removal of which, the graph splits in two disconnected components. In the given graph, the vertices <code class="inlineCode">B</code>, and <code class="inlineCode">C</code> are cut vertices since after removal of node <code class="inlineCode">B</code>, the graph will split into <code class="inlineCode">{A,D}</code>, <code class="inlineCode">{C,E}</code> vertices. And, after removal of node <code class="inlineCode">C</code>, the graph will split into <code class="inlineCode">{A,B,D}</code>, <code class="inlineCode">{E}</code> vertices.</p>
    <h2 id="_idParaDest-330" class="heading-2">Question 4</h2>
    <p class="normal">Assuming a graph <code class="inlineCode">G</code> of order <code class="inlineCode">n</code>, what will be the maximum number of cut vertices possible in graph <code class="inlineCode">G</code>?</p>
    <h2 id="_idParaDest-331" class="heading-2">Solution</h2>
    <p class="normal">It will be <code class="inlineCode">n-2</code>, since the first and last vertices will not be cut vertices, except those two nodes, all nodes can split the graph into two disconnected graphs. See the below graph:</p>
    <figure class="mediaobject"><img src="img/B17217_15_11.png" alt=""/></figure>
    <p class="packt_figref">Figure A.11: A graph G</p>
    <h1 id="_idParaDest-332" class="heading-1">Chapter 10: Searching</h1>
    <h2 id="_idParaDest-333" class="heading-2">Question 1</h2>
    <p class="normal">On average, how many comparisons are required in a linear search of <code class="inlineCode">n</code> elements?</p>
    <h2 id="_idParaDest-334" class="heading-2">Solution</h2>
    <p class="normal">The average number of comparisons in linear search will be as follows. When a search element is found at the <code class="inlineCode">1</code><sup class="superscript">st </sup>position, <code class="inlineCode">2</code><sup class="superscript">nd</sup> position, <code class="inlineCode">3</code><sup class="superscript">rd</sup> position, and similarly at the <code class="inlineCode">n</code><sup class="superscript">th</sup> position, correspondingly, it will require <code class="inlineCode">1</code>, <code class="inlineCode">2</code>, <code class="inlineCode">3</code>… <code class="inlineCode">n</code> number of comparisons.</p>
    <p class="normal">Total average number of comparisons </p>
    <figure class="mediaobject">= <a id="_idIndexMarker1078"/><img src="img/B17217_15_001.png" alt=""/></figure>
    <p class="packt_figref">= <img src="img/B17217_15_002.png" alt=""/></p>
    <p class="packt_figref">= <img src="img/B17217_15_003.png" alt=""/></p>
    <h2 id="_idParaDest-335" class="heading-2">Question 2</h2>
    <p class="normal">Assume there are eight elements in a sorted array. What is the average number of comparisons that will be required if all the searches are successful and if the binary search algorithm is used?</p>
    <h2 id="_idParaDest-336" class="heading-2">Solution</h2>
    <p class="normal">Average number of comparisons = (1+2+2+3+3+3+3+4)/8</p>
    <p class="normal">= 21/8</p>
    <p class="normal">= 2.625</p>
    <figure class="mediaobject"><img src="img/B17217_15_12.png" alt=""/></figure>
    <p class="packt_figref">Figure A.12: Demonstration of number of the comparisons in the given array</p>
    <h2 id="_idParaDest-337" class="heading-2">Question 3</h2>
    <p class="normal">What is the worst-case time complexity of the binary search algorithm?</p>
    <h2 id="_idParaDest-338" class="heading-2">Solution</h2>
    <p class="normal"><code class="inlineCode">O(logn)</code>.</p>
    <p class="normal">The worst-case scenario of the binary search algorithm will occur when the desired element is present in the first position or at the last position. In that case, <code class="inlineCode">log(n)</code> comparisons will be required. Hence the worst-case complexity will be <code class="inlineCode">O(logn)</code>.</p>
    <h2 id="_idParaDest-339" class="heading-2">Question 4</h2>
    <p class="normal">When should the interpolation search algorithm perform better than the binary search algorithm?</p>
    <h2 id="_idParaDest-340" class="heading-2">Solution</h2>
    <p class="normal">The interpolation search algorithm performs better than the binary search algorithm when the data items in the array are uniformly distributed.</p>
    <h1 id="_idParaDest-341" class="heading-1">Chapter 11: Sorting</h1>
    <h2 id="_idParaDest-342" class="heading-2">Question 1</h2>
    <p class="normal">If an array <code class="inlineCode">arr = {55, 42, 4, 31}</code> is given and bubble sort is used to sort the array elements, then how many passes will be required to sort the array?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">3</li>
      <li class="alphabeticList">2</li>
      <li class="alphabeticList">1</li>
      <li class="alphabeticList">0</li>
    </ol>
    <h2 id="_idParaDest-343" class="heading-2">Solution</h2>
    <p class="normal">The answer is a. To sort <code class="inlineCode">n</code> elements, the bubble sort algorithm requires (<code class="inlineCode">n-1</code>) iterations (passes), where <code class="inlineCode">n</code> is the number of elements in the given array. Here in the question, the value of <code class="inlineCode">n</code> = <code class="inlineCode">4</code>, so <code class="inlineCode">4</code>-<code class="inlineCode">1</code> = <code class="inlineCode">3</code> iterations will be required to sort the given array.</p>
    <h2 id="_idParaDest-344" class="heading-2">Question 2</h2>
    <p class="normal">What is the worst-case complexity of bubble sort?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">O(nlogn)</li>
      <li class="alphabeticList">O(logn)</li>
      <li class="alphabeticList">O(n)</li>
      <li class="alphabeticList">O(n<sup class="superscript">2</sup>)</li>
    </ol>
    <h2 id="_idParaDest-345" class="heading-2">Solution</h2>
    <p class="normal">The answer is d. The worst case appears when the given array is in reverse order. In that case, the time complexity of bubble sort would be O(n<sup class="superscript">2</sup>).</p>
    <h2 id="_idParaDest-346" class="heading-2">Question 3</h2>
    <p class="normal">Apply quicksort to the sequence (<code class="inlineCode">56</code>, <code class="inlineCode">89</code>, <code class="inlineCode">23</code>, <code class="inlineCode">99</code>, <code class="inlineCode">45</code>, <code class="inlineCode">12</code>, <code class="inlineCode">66</code>, <code class="inlineCode">78</code>, <code class="inlineCode">34</code>). What is the sequence after the first phase, and what pivot is the first element?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">45, 23, 12, 34, 56, 99, 66, 78, 89</li>
      <li class="alphabeticList">34, 12, 23, 45, 56, 99, 66, 78, 89</li>
      <li class="alphabeticList">12, 45, 23, 34, 56, 89, 78, 66, 99</li>
      <li class="alphabeticList">34, 12, 23, 45, 99, 66, 89, 78, 56</li>
    </ol>
    <h2 id="_idParaDest-347" class="heading-2">Solution</h2>
    <p class="normal">b.</p>
    <p class="normal">After the first phase, <code class="inlineCode">56</code> would be in the right position so that all the elements smaller than <code class="inlineCode">56</code> will be on the left side of it, and elements bigger than <code class="inlineCode">56</code> will be on the right side of it. Further, quicksort is applied recursively to the left subarray and right subarray. The process of the quicksort for the given sequence, as shown in the below figure.</p>
    <figure class="mediaobject"><img src="img/B17217_15_13.png" alt=""/></figure>
    <p class="packt_figref">Figure A.13: Demonstration of the quicksort algorithm</p>
    <h2 id="_idParaDest-348" class="heading-2">Question 4</h2>
    <p class="normal">Quicksort is a ___________</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">Greedy algorithm</li>
      <li class="alphabeticList">Divide-and-conquer algorithm</li>
      <li class="alphabeticList">Dynamic programming algorithm</li>
      <li class="alphabeticList">Backtracking algorithm</li>
    </ol>
    <h2 id="_idParaDest-349" class="heading-2">Solution</h2>
    <p class="normal">The answer is b. Quicksort is a divide-and-conquer algorithm. Quick sort first partitions a large array into two smaller sub arrays and then recursively sorts the sub-arrays. Here, we find the pivot element such that all elements to the left side of the pivot element would be smaller than the pivot element and create the first subarray. The elements to the right side of the pivot element are greater than the pivot element and create the second subarray. Thus, the given problem is reduced into two smaller sets. Now, sort these two subarrays again, finding the pivot element in each subarray, i.e. apply quicksort on each subarray.</p>
    <h2 id="_idParaDest-350" class="heading-2">Question 5</h2>
    <p class="normal">Consider a situation where a <code class="inlineCode">swap</code> operation is very costly. Which of the following sorting algorithms should be used so that the number of <code class="inlineCode">swap</code> operations is minimized?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">Heap sort</li>
      <li class="alphabeticList">Selection sort</li>
      <li class="alphabeticList">Insertion sort</li>
      <li class="alphabeticList">Merge sort</li>
    </ol>
    <h2 id="_idParaDest-351" class="heading-2">Solution</h2>
    <p class="normal">b. In the selection sort algorithm, in general, we identify the largest element, and then swap it with the last element so that in each iteration, only one <code class="inlineCode">swap</code> is required. For <code class="inlineCode">n</code> elements, the total (<code class="inlineCode">n-1</code>) swaps will be required, which is the lowest in comparison to all other algorithms.</p>
    <h2 id="_idParaDest-352" class="heading-2">Question 6</h2>
    <p class="normal">If the input array <code class="inlineCode">A = {15, 9, 33, 35, 100, 95, 13, 11, 2, 13}</code> is given, using selection sort, what would be the order of the array after the fifth <code class="inlineCode">swap</code>? (Note: it counts regardless of whether they exchange or remain in the same position.)</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">2, 9, 11, 13, 13, 95, 35, 33, 15, 100</li>
      <li class="alphabeticList">2, 9, 11, 13, 13, 15, 35, 33, 95, 100</li>
      <li class="alphabeticList">35, 100, 95, 2, 9, 11, 13, 33, 15, 13</li>
      <li class="alphabeticList">11, 13, 9, 2, 100, 95, 35, 33, 13, 13</li>
    </ol>
    <h2 id="_idParaDest-353" class="heading-2">Solution</h2>
    <p class="normal">The answer is a. In selection sort, select the smallest element. Start the comparison from the beginning of the array and swap the smallest element with the first greatest element. Now, exclude the previous element that was chosen as the smallest element, as it has been put in the right place.</p>
    <figure class="mediaobject"><img src="img/B17217_15_14.png" alt=""/></figure>
    <p class="packt_figref">Figure A.14: Demonstration of insertion sort on the given sequence</p>
    <h2 id="_idParaDest-354" class="heading-2">Question 7</h2>
    <p class="normal">What will be the number of iterations to sort the elements <code class="inlineCode">{44, 21, 61, 6, 13, 1}</code> using insertion sort?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">6</li>
      <li class="alphabeticList">5</li>
      <li class="alphabeticList">7</li>
      <li class="alphabeticList">1</li>
    </ol>
    <h2 id="_idParaDest-355" class="heading-2">Solution</h2>
    <p class="normal">The answer is a. Suppose there are <code class="inlineCode">N</code> keys in an input list, then it requires <code class="inlineCode">N</code> iterations to sort the entire list using insertion sort.</p>
    <h2 id="_idParaDest-356" class="heading-2">Question 8</h2>
    <p class="normal">How will the array elements <code class="inlineCode">A= [35, 7, 64, 52, 32, 22]</code> look after the second iteration, if the elements are sorted using insertion sort?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">7, 22, 32, 35, 52, 64</li>
      <li class="alphabeticList">7, 32, 35, 52, 64, 22</li>
      <li class="alphabeticList">7, 35, 52, 64, 32, 22</li>
      <li class="alphabeticList">7, 35, 64, 52, 32, 22</li>
    </ol>
    <h2 id="_idParaDest-357" class="heading-2">Solutions</h2>
    <p class="normal">d. Here <code class="inlineCode">N</code> = <code class="inlineCode">6</code>. In the first iteration, the first element, that is, <code class="inlineCode">A[1]</code> <code class="inlineCode">=</code> <code class="inlineCode">35</code>, is inserted into array <code class="inlineCode">B</code>, which is initially empty. In the second iteration, <code class="inlineCode">A[2] = 7</code> is compared with the elements in <code class="inlineCode">B</code> starting from the rightmost element of <code class="inlineCode">B</code> to find its place. So, after the second iteration, the input array would be <code class="inlineCode">A = [7, 35, 64, 52, 32, 22]</code>.</p>
    <h1 id="_idParaDest-358" class="heading-1">Chapter 12: Selection Algorithm</h1>
    <h2 id="_idParaDest-359" class="heading-2">Question 1</h2>
    <p class="normal">What will be the output if the quickselect algorithm is applied to the given array <code class="inlineCode">arr=[3, 1, 10, 4, 6, 5]</code> with <code class="inlineCode">k</code> given as 2?</p>
    <h2 id="_idParaDest-360" class="heading-2">Solution</h2>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Given the initial array: <code class="inlineCode">[3, 1, 10, 4, 6, 5]</code>, we can find the median of medians: <code class="inlineCode">4</code> (index = <code class="inlineCode">3</code>).</li>
      <li class="numberedList">We swap the pivot element with the first element: <code class="inlineCode">[4, 1, 3, 10, 6, 5]</code>.</li>
      <li class="numberedList">We will move the pivot element to its correct position: <code class="inlineCode">[1, 3, 4, 10, 6, 5]</code>.</li>
      <li class="numberedList">Now we get a split index equal to <code class="inlineCode">2</code> but the value of <code class="inlineCode">k</code> is also equal to <code class="inlineCode">2</code>, hence the value at index <code class="inlineCode">2</code> will be our output. Hence the output will be <code class="inlineCode">4</code>.</li>
    </ol>
    <h2 id="_idParaDest-361" class="heading-2">Question 2</h2>
    <p class="normal">Can quickselect find the smallest element in an array with duplicate values?</p>
    <h2 id="_idParaDest-362" class="heading-2">Solution</h2>
    <p class="normal">Yes, it works. By the end of every iteration, we have all elements less than the current pivot stored to the left of the pivot. Let’s consider when all elements are the same. In this case, every iteration ends up putting a pivot element to the left of the array. And the next iteration will continue with one element shorter in the array.</p>
    <h2 id="_idParaDest-363" class="heading-2">Question 3</h2>
    <p class="normal">What is the difference between the quicksort algorithm and the quickselect algorithm?</p>
    <h2 id="_idParaDest-364" class="heading-2">Solution</h2>
    <p class="normal">In quickselect, we do not sort the array, and it is specifically for finding the k<sup class="superscript">th</sup> smallest element in the array. The algorithm repeatedly divides the array into two sections based on the value of the pivot element. As we know, the pivot element will be placed such that all the elements to its left are smaller than the pivot element, and all the elements to the right are larger than the pivot element. Thus, we can select any one of the segments of the array based on the target value. This way, the size of the operable range of our array keeps on reducing. This reduces the complexity from O(nlog<sub class="subscript">2</sub>(n)) to O(n).</p>
    <h2 id="_idParaDest-365" class="heading-2">Question 4</h2>
    <p class="normal">What is the main difference between the deterministic selection algorithm and the quickselect algorithm?</p>
    <h2 id="_idParaDest-366" class="heading-2">Solution</h2>
    <p class="normal">In the <code class="inlineCode">quickselect</code> algorithm, we find the k<sup class="superscript">th</sup> smallest element in an unordered list based on picking up the pivot element randomly. Whereas, in the deterministic selection algorithm, which is also used for finding the k<sup class="superscript">th</sup> smallest element from an unordered list, but in this algorithm, we choose a pivot element by using median of medians, instead of taking any random pivot element.</p>
    <h2 id="_idParaDest-367" class="heading-2">Question 5</h2>
    <p class="normal">What triggers the worst-case behavior of the selection algorithm?</p>
    <h2 id="_idParaDest-368" class="heading-2">Solution</h2>
    <p class="normal">Continuously picking the largest or smallest element on each iteration triggers the worst-case behavior of the selection algorithm.</p>
    <h1 id="_idParaDest-369" class="heading-1">Chapter 13: String Matching Algorithms</h1>
    <h2 id="_idParaDest-370" class="heading-2">Question 1</h2>
    <p class="normal">Show the KMP <code class="inlineCode">prefix</code> function for the pattern <code class="inlineCode">"aabaabcab"</code>.</p>
    <h2 id="_idParaDest-371" class="heading-2">Solution</h2>
    <p class="normal">The <code class="inlineCode">prefix</code> function values are given below:</p>
    <table id="table002-4" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">pattern</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
          <td class="table-cell">
            <p class="normal">b</p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
          <td class="table-cell">
            <p class="normal">b</p>
          </td>
          <td class="table-cell">
            <p class="normal">c</p>
          </td>
          <td class="table-cell">
            <p class="normal">a</p>
          </td>
          <td class="table-cell">
            <p class="normal">b</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">prefix_function</code> <a id="_idIndexMarker1079"/><img src="img/Appendix_02.png" alt=""/></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal">3</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table A.2: Prefix function for the given patten</p>
    <h2 id="_idParaDest-372" class="heading-2">Question 2</h2>
    <p class="normal">If the expected number of valid shifts is small and the modulus is larger than the length of the pattern, then what is the matching time of the Rabin-Karp algorithm?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">Theta (<code class="inlineCode">m</code>)</li>
      <li class="alphabeticList">Big O (<code class="inlineCode">n+m</code>)</li>
      <li class="alphabeticList">Theta (<code class="inlineCode">n-m</code>)</li>
      <li class="alphabeticList">Big O (<code class="inlineCode">n</code>)</li>
    </ol>
    <h2 id="_idParaDest-373" class="heading-2">Solution</h2>
    <p class="normal">Big O (<code class="inlineCode">n+m</code>)</p>
    <h2 id="_idParaDest-374" class="heading-2">Question 3</h2>
    <p class="normal">How many spurious hits does the Rabin-Karp string matching algorithm encounter in the text <code class="inlineCode">T = "3141512653849792"</code> when looking for all occurrences of the pattern <code class="inlineCode">P = "26"</code>, working modulo <code class="inlineCode">q = 11</code> and over the alphabet set <code class="inlineCode">Σ = {0, 1, 2,..., 9}</code>?</p>
    <h2 id="_idParaDest-375" class="heading-2">Solution</h2>
    <p class="normal">2.</p>
    <h2 id="_idParaDest-376" class="heading-2">Question 4</h2>
    <p class="normal">What is the basic formula applied in the Rabin-Karp algorithm to get the computation time as Theta (m)?</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">Halving rule</li>
      <li class="alphabeticList">Horner’s rule</li>
      <li class="alphabeticList">Summation lemma</li>
      <li class="alphabeticList">Cancellation lemma</li>
    </ol>
    <h2 id="_idParaDest-377" class="heading-2">Solution</h2>
    <p class="normal">Horner’s rule.</p>
    <h2 id="_idParaDest-378" class="heading-2">Question 5</h2>
    <p class="normal">The Rabin-Karp algorithm can be used for discovering plagiarism in text documents.</p>
    <ol type="a" class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList">True</li>
      <li class="alphabeticList">False</li>
    </ol>
    <h2 id="_idParaDest-379" class="heading-2">Solution</h2>
    <p class="normal">True, the Rabin-Karp algorithm is a string matching algorithm, and it can be used for detecting plagiarism in text documents.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4">https://packt.link/MEvK4</a></p>
    <p class="normal"><img src="img/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>