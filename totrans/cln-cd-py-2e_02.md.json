["```py\n>>> my_numbers = (4, 5, 3, 9)\n>>> my_numbers[-1]\n9\n>>> my_numbers[-3]\n5 \n```", "```py\n>>> my_numbers = (1, 1, 2, 3, 5, 8, 13, 21)\n>>> my_numbers[2:5]\n(2, 3, 5) \n```", "```py\n>>> my_numbers[:3]\n(1, 1, 2)\n>>> my_numbers[3:]\n(3, 5, 8, 13, 21)\n>>> my_numbers[::]  # also my_numbers[:], returns a copy\n(1, 1, 2, 3, 5, 8, 13, 21)\n>>> my_numbers[1:7:2]\n(1, 3, 8) \n```", "```py\n>>> interval = slice(1, 7, 2)\n>>> my_numbers[interval]\n(1, 3, 8)\n>>> interval = slice(None, 3)\n>>> my_numbers[interval] == my_numbers[:3]\nTrue \n```", "```py\nfrom collections.abc import Sequence\nclass Items(Sequence):\n    def __init__(self, *values):\n        self._values = list(values)\n    def __len__(self):\n        return len(self._values)\n    def __getitem__(self, item):\n        return self._values.__getitem__(item) \n```", "```py\n>>> range(1, 100)[25:50]\nrange(26, 51) \n```", "```py\nfd = open(filename)\ntry:\n    process_file(fd)\nfinally:\n    fd.close() \n```", "```py\nwith open(filename) as fd:\n    process_file(fd) \n```", "```py\ndef stop_database():\n    run(\"systemctl stop postgresql.service\")\ndef start_database():\n    run(\"systemctl start postgresql.service\")\nclass DBHandler:\n    def __enter__(self):\n        stop_database()\n        return self\n    def __exit__(self, exc_type, ex_value, ex_traceback):\n        start_database()\ndef db_backup():\n    run(\"pg_dump database\")\ndef main():\n    with DBHandler():\n        db_backup() \n```", "```py\nimport contextlib\n@contextlib.contextmanager\ndef db_handler():\n    try:\n        stop_database()\n        yield\n    finally:\n       start_database()\nwith db_handler():\n    db_backup() \n```", "```py\nclass dbhandler_decorator(contextlib.ContextDecorator):\n    def __enter__(self):\n        stop_database()\n        return self\n    def __exit__(self, ext_type, ex_value, ex_traceback):\n        start_database()\n@dbhandler_decorator()\ndef offline_backup():\n    run(\"pg_dump database\") \n```", "```py\ndef offline_backup():\n    with dbhandler_decorator() as handler: ... \n```", "```py\nimport contextlib\nwith contextlib.suppress(DataConversionException):\n    parse_data(input_json_or_dict) \n```", "```py\nnumbers = []  \nfor i in range(10):  \n    numbers.append(run_calculation(i)) \n```", "```py\nnumbers = [run_calculation(i) for i in range(10)] \n```", "```py\nfrom typing import Iterable, Set\ndef collect_account_ids_from_arns(arns: Iterable[str]) -> Set[str]:\n    \"\"\"Given several ARNs in the form\n        arn:partition:service:region:account-id:resource-id\n    Collect the unique account IDs found on those strings, and return them.\n    \"\"\"\n    collected_account_ids = set()\n    for arn in arns:\n        matched = re.match(ARN_REGEX, arn)\n        if matched is not None:\n            account_id = matched.groupdict()[\"account_id\"]\n            collected_account_ids.add(account_id)\n    return collected_account_ids \n```", "```py\ndef collect_account_ids_from_arns(arns):\n    matched_arns = filter(None, (re.match(ARN_REGEX, arn) for arn in arns))\n    return {m.groupdict()[\"account_id\"] for m in matched_arns} \n```", "```py\ndef collect_account_ids_from_arns(arns: Iterable[str]) -> Set[str]:\n    return {\n        matched.groupdict()[\"account_id\"]\n        for arn in arns\n        if (matched := re.match(ARN_REGEX, arn)) is not None\n    } \n```", "```py\n>>> class Connector:\n...     def __init__(self, source):\n...         self.source = source\n...         self._timeout = 60\n... \n>>> conn = Connector(\"postgresql://localhost\")\n>>> conn.source\n'postgresql://localhost'\n>>> conn._timeout\n60\n>>> conn.__dict__\n{'source': 'postgresql://localhost', '_timeout': 60} \n```", "```py\n>>> class Connector:\n...     def __init__(self, source):\n...         self.source = source\n...         self.__timeout = 60\n...\n...      def connect(self):\n...         print(\"connecting with {0}s\".format(self.__timeout))\n...         # ...\n... \n>>> conn = Connector(\"postgresql://localhost\")\n>>> conn.connect()\nconnecting with 60s\n>>> conn.__timeout\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'Connector' object has no attribute '__timeout' \n```", "```py\n>>> vars(conn)\n{'source': 'postgresql://localhost', '_Connector__timeout': 60}\n>>> conn._Connector__timeout\n60\n>>> conn._Connector__timeout = 30\n>>> conn.connect()\nconnecting with 30s \n```", "```py\nclass Coordinate:\n    def __init__(self, lat: float, long: float) -> None:\n        self._latitude = self._longitude = None\n        self.latitude = lat\n        self.longitude = long\n    @property\n    def latitude(self) -> float:\n        return self._latitude\n    @latitude.setter\n    def latitude(self, lat_value: float) -> None:\n        if lat_value not in range(-90, 90 + 1):\n            raise ValueError(f\"{lat_value} is an invalid value for latitude\")\n        self._latitude = lat_value\n    @property\n    def longitude(self) -> float:\n        return self._longitude\n    @longitude.setter\n    def longitude(self, long_value: float) -> None:\n        if long_value not in range(-180, 180 + 1):\n            raise ValueError(f\"{long_value} is an invalid value for longitude\")\n        self._longitude = long_value \n```", "```py\ncoordinate.latitude = <new-latitude-value>  # similar for longitude \n```", "```py\ndef __init__(self, x, y, … ):\n    self.x = x\n    self.y = y \n```", "```py\nfrom typing import List\nfrom dataclasses import dataclass, field\nR = 26\n@dataclass\nclass RTrieNode:\n    size = R\n    value: int\n    next_: List[\"RTrieNode\"] = field(\n        default_factory=lambda: [None] * R)\n\n    def __post_init__(self):\n        if len(self.next_) != self.size:\n            raise ValueError(f\"Invalid length provided for next list\") \n```", "```py\nfrom datetime import timedelta\nclass DateRangeIterable:\n    \"\"\"An iterable that contains its own iterator object.\"\"\"\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n        self._present_day = start_date\n    def __iter__(self):\n        return self\n    def __next__(self):\n        if self._present_day >= self.end_date:\n            raise StopIteration()\n        today = self._present_day\n        self._present_day += timedelta(days=1)\n        return today \n```", "```py\n>>> from datetime import date\n>>> for day in DateRangeIterable(date(2018, 1, 1), date(2018, 1, 5)):\n...     print(day)\n... \n2018-01-01\n2018-01-02\n2018-01-03\n2018-01-04\n>>> \n```", "```py\n>>> r = DateRangeIterable(date(2018, 1, 1), date(2018, 1, 5))\n>>> next(r)\ndatetime.date(2018, 1, 1)\n>>> next(r)\ndatetime.date(2018, 1, 2)\n>>> next(r)\ndatetime.date(2018, 1, 3)\n>>> next(r)\ndatetime.date(2018, 1, 4)\n>>> next(r)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File ... __next__\n    raise StopIteration\nStopIteration\n>>> \n```", "```py\n>>> r1 = DateRangeIterable(date(2018, 1, 1), date(2018, 1, 5))\n>>> \", \".join(map(str, r1))\n'2018-01-01, 2018-01-02, 2018-01-03, 2018-01-04'\n>>> max(r1)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: max() arg is an empty sequence\n>>> \n```", "```py\nclass DateRangeContainerIterable:\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n    def __iter__(self):\n        current_day = self.start_date\n        while current_day < self.end_date:\n            yield current_day\n            current_day += timedelta(days=1) \n```", "```py\n>>> r1 = DateRangeContainerIterable(date(2018, 1, 1), date(2018, 1, 5))\n>>> \", \".join(map(str, r1))\n'2018-01-01, 2018-01-02, 2018-01-03, 2018-01-04'\n>>> max(r1)\ndatetime.date(2018, 1, 4)\n>>> \n```", "```py\nclass DateRangeSequence:\n    def __init__(self, start_date, end_date):\n        self.start_date = start_date\n        self.end_date = end_date\n        self._range = self._create_range()\n    def _create_range(self):\n        days = []\n        current_day = self.start_date\n        while current_day < self.end_date:\n            days.append(current_day)\n            current_day += timedelta(days=1)\n        return days\n    def __getitem__(self, day_no):\n        return self._range[day_no]\n    def __len__(self):\n        return len(self._range) \n```", "```py\n>>> s1 = DateRangeSequence(date(2018, 1, 1), date(2018, 1, 5))\n>>> for day in s1:\n...     print(day)\n... \n2018-01-01\n2018-01-02\n2018-01-03\n2018-01-04\n>>> s1[0]\ndatetime.date(2018, 1, 1)\n>>> s1[3]\ndatetime.date(2018, 1, 4)\n>>> s1[-1]\ndatetime.date(2018, 1, 4) \n```", "```py\nelement in container \n```", "```py\ncontainer.__contains__(element) \n```", "```py\ndef mark_coordinate(grid, coord):\n    if 0 <= coord.x < grid.width and 0 <= coord.y < grid.height:\n        grid[coord] = MARKED \n```", "```py\nclass Boundaries:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    def __contains__(self, coord):\n        x, y = coord\n        return 0 <= x < self.width and 0 <= y < self.height\nclass Grid:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n        self.limits = Boundaries(width, height)\n    def __contains__(self, coord):\n        return coord in self.limits \n```", "```py\ndef mark_coordinate(grid, coord):\n    if coord in grid:\n        grid[coord] = MARKED \n```", "```py\nclass DynamicAttributes:\n    def __init__(self, attribute):\n        self.attribute = attribute\n    def __getattr__(self, attr):\n        if attr.startswith(\"fallback_\"):\n            name = attr.replace(\"fallback_\", \"\")\n            return f\"[fallback resolved] {name}\"\n        raise AttributeError(\n            f\"{self.__class__.__name__} has no attribute {attr}\"\n        ) \n```", "```py\n>>> dyn = DynamicAttributes(\"value\")\n>>> dyn.attribute\n'value'\n>>> dyn.fallback_test\n'[fallback resolved] test'\n>>> dyn.__dict__[\"fallback_new\"] = \"new value\"\n>>> dyn.fallback_new\n'new value'\n>>> getattr(dyn, \"something\", \"default\")\n'default' \n```", "```py\nfrom collections import defaultdict\nclass CallCount:\n    def __init__(self):\n        self._counts = defaultdict(int)\n    def __call__(self, argument):\n        self._counts[argument] += 1\n        return self._counts[argument] \n```", "```py\n>>> cc = CallCount()\n>>> cc(1)\n1\n>>> cc(2)\n1\n>>> cc(1)\n2\n>>> cc(1)\n3\n>>> cc(\"something\")\n1\n>>> callable(cc)\n    True \n```", "```py\ndef wrong_user_display(user_metadata: dict = {\"name\": \"John\", \"age\": 30}):\n    name = user_metadata.pop(\"name\")\n    age = user_metadata.pop(\"age\")\n    return f\"{name} ({age})\" \n```", "```py\n>>> wrong_user_display()\n'John (30)'\n>>> wrong_user_display({\"name\": \"Jane\", \"age\": 25})\n'Jane (25)'\n>>> wrong_user_display()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File ... in wrong_user_display\n    name = user_metadata.pop(\"name\")\nKeyError: 'name' \n```", "```py\ndef user_display(user_metadata: dict = None):\n    user_metadata = user_metadata or {\"name\": \"John\", \"age\": 30}\n    name = user_metadata.pop(\"name\")\n    age = user_metadata.pop(\"age\")\n    return f\"{name} ({age})\" \n```", "```py\nclass BadList(list):\n    def __getitem__(self, index):\n        value = super().__getitem__(index)\n        if index % 2 == 0:\n            prefix = \"even\"\n        else:\n            prefix = \"odd\"\n        return f\"[{prefix}] {value}\" \n```", "```py\n>>> bl = BadList((0, 1, 2, 3, 4, 5))\n>>> bl[0]\n'[even] 0'\n>>> bl[1]\n'[odd] 1'\n>>> \"\".join(bl)\nTraceback (most recent call last):\n...\nTypeError: sequence item 0: expected str instance, int found \n```", "```py\nfrom collections import UserList\nclass GoodList(UserList):\n    def __getitem__(self, index):\n        value = super().__getitem__(index)\n        if index % 2 == 0:\n            prefix = \"even\"\n        else:\n            prefix = \"odd\"\n        return f\"[{prefix}] {value}\" \n```", "```py\n>>> gl = GoodList((0, 1, 2))\n>>> gl[0]\n'[even] 0'\n>>> gl[1]\n'[odd] 1'\n>>> \"; \".join(gl)\n'[even] 0; [odd] 1; [even] 2' \n```", "```py\nasync def mycoro(*args, **kwargs):\n    # … logic\n    await third_party.coroutine(…)\n    # … more of our logic \n```", "```py\nresult = await mycoro(…)   #  doing result = mycoro() would be erroneous \n```", "```py\nimport asyncio\nasyncio.run(mycoro(…)) \n```"]