<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 7. Window Layout and Design"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Window Layout and Design</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using a<code class="literal"> BoxSizer</code></li><li class="listitem" style="list-style-type: disc">Understanding proportions, flags, and borders</li><li class="listitem" style="list-style-type: disc">Laying out controls with the<code class="literal"> GridBagSizer</code></li><li class="listitem" style="list-style-type: disc">Standard dialog button layout</li><li class="listitem" style="list-style-type: disc">Using XML resources</li><li class="listitem" style="list-style-type: disc">Making a custom resource handler</li><li class="listitem" style="list-style-type: disc">Using the<code class="literal"> AuiFrameManager</code></li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Introduction</h1></div></div></div><p>Once you have an idea of how the interface of your applications should look, it comes the time to put it all together. Being able to take your vision and translate it into code can be a tricky and often tedious task. A window's layout is defined on a two dimensional plane with the origin being the window's top-left corner. All positioning and sizing of any widgets, no matter what it's onscreen appearance, is based on rectangles. Clearly understanding these two basic concepts goes a long way towards being able to understand and efficiently work with the toolkit.</p><p>Traditionally in older applications, window layout was commonly done by setting explicit static sizes and positions for all the controls contained within a window. This approach, however, can be rather limiting as the windows will not be resizable, they may not fit on the screen under different resolutions, trying to support localization becomes more difficult because labels and other text will differ in length in different languages, the native widgets will often be different sizes on different platforms making it difficult to write platform independent code, and the list goes on.</p><p>So, you may ask what the solution to this is. In wxPython, the method of choice is to use the<code class="literal"> Sizer</code> classes to define and manage the layout of controls. Sizers are classes that manage the size and positioning of controls through an algorithm that queries all of the controls that have been added to the Sizer for their recommended best minimal sizes and their ability to stretch or not, if the amount of available space increases, such as if a user makes a dialog bigger. Sizers also handle cross-platform widget differences, for example, buttons on GTK tend to have an icon and be generally larger than the buttons on Windows or OS X. Using a<code class="literal"> Sizer</code> to manage the button's layout will allow the rest of the dialog to be proportionally sized correctly to handle this without the need for any platform-specific code.<a id="id260" class="indexterm"/>
</p><p>So let us begin our adventure into the world of window layout and design by taking a look at a number of the tools that wxPython provides in order to facilitate this task.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using a BoxSizer"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Using a BoxSizer</h1></div></div></div><p>A<code class="literal"> BoxSizer</code> is the most basic of<code class="literal"> Sizer</code> classes. It supports a layout that goes in a single direction—either a vertical column or a horizontal row. Even though it is the most basic to work with, a<code class="literal"> BoxSizer</code> is one of the most useful<code class="literal"> Sizer</code> classes and tends to produce more consistent cross-platform behavior when compared to some of the other<code class="literal"> Sizers</code> types. This recipe creates a simple window where we want to have two text controls stacked in a vertical column, each with a label to the left of it. This will be used to illustrate the most simplistic usage of a<code class="literal"> BoxSizer</code> in order to manage the layout of a window's controls.<a id="id261" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec01"/>How to do it...</h2></div></div></div><p>Here we define our top level Frame, which will use a BoxSizer to manage the size of its Panel:<a id="id262" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class BoxSizerFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(BoxSizerFrame, self).__init__(*args, **kwargs)

        # Attributes
        self.panel = BoxSizerPanel(self)

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)
        self.SetInitialSize()

</pre></div><p>The<code class="literal"> BoxSizerPanel</code> class is the next layer in the window hierarchy, and is where we will perform the main layout of the controls:<a id="id263" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class BoxSizerPanel(wx.Panel):
    def __init__(self, parent, *args, **kwargs):
        super(BoxSizerPanel, self).__init__(*args, **kwargs)

        # Attributes
        self._field1 = wx.TextCtrl(self)
        self._field2 = wx.TextCtrl(self)

        # Layout
        self._DoLayout()

</pre></div><p>Just to help reduce clutter in the<code class="literal"> __init__</code> method, we will do all the layout in a separate<code class="literal"> _DoLayout</code> method:<a id="id264" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">    def _DoLayout(self):
        """Layout the controls"""
        vsizer = wx.BoxSizer(wx.VERTICAL)
        field1_sz = wx.BoxSizer(wx.HORIZONTAL)
        field2_sz = wx.BoxSizer(wx.HORIZONTAL)

        # Make the labels
        field1_lbl = wx.StaticText(self, label="Field 1:")
        field2_lbl = wx.StaticText(self, label="Field 2:")

        # Make the first row by adding the label and field
        # to the first horizontal sizer
        field1_sz.AddSpacer(50)
        field1_sz.Add(field1_lbl)
        field1_sz.AddSpacer(5) # put 5px of space between
        field1_sz.Add(self._field1)
        field1_sz.AddSpacer(50)

        # Do the same for the second row
        field2_sz.AddSpacer(50)
        field2_sz.Add(field2_lbl)
        field2_sz.AddSpacer(5)
        field2_sz.Add(self._field2)
        field2_sz.AddSpacer(50)

        # Now finish the layout by adding the two sizers
        # to the main vertical sizer.
        vsizer.AddSpacer(50)
        vsizer.Add(field1_sz)
        vsizer.AddSpacer(15)
        vsizer.Add(field2_sz)
        vsizer.AddSpacer(50)

        # Finally assign the main outer sizer to the panel
        self.SetSizer(vsizer)

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec02"/>How it works...</h2></div></div></div><p>The previous code shows the basic pattern of how to create a simple window layout programmatically, using sizers to manage the controls. First let's start by taking a look at the<code class="literal"> BoxSizerPanel</code> class's<code class="literal"> _DoLayout</code> method, as this is where the majority of the layout in this example takes place.<a id="id265" class="indexterm"/>
</p><p>First, we started off by creating three<code class="literal"> BoxSizer</code> classes: one with a vertical orientation, and two with a horizontal orientation. The layout we desired for this window requires us to use three<code class="literal"> BoxSizer</code> classes and this is why. If you break down what we want to do into simple rectangles, you will see that:<a id="id266" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We wanted two<code class="literal"> TextCtrl</code> objects each with a label to the left of them which can simply be thought of as two horizontal rectangles.</li></ol></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We wanted the<code class="literal"> TextCtrl</code> objects stacked vertically in the window which is just a vertical rectangle that will contain the other two rectangles.</li></ol></div><p>This is illustrated by the following screenshot (borders are drawn in and labels are added to show the area managed by each of<code class="literal"> Panel's</code> three<code class="literal"> BoxSizers):</code>
</p><div class="mediaobject"><img src="images/1780_07_01.jpg" alt="How it works..."/></div><p>In the section where we populate the first horizontal sizer (<code class="literal">field1_sz</code>), we use two of the<code class="literal"> BoxSizer</code> methods to add items to the layout. The first is<code class="literal"> AddSpacer</code>, which does simply as its named and adds a fixed amount of empty space in the left-hand side of the sizer. Then we use the<code class="literal"> Add</code> method to add our<code class="literal"> StaticText</code> control to the right of the spacer, and continue from here to add other items to complete this row. As you can see, these methods add items to the layout from left to right in the sizer. After this, we again do the same thing with the other label and<code class="literal"> TextCtrl</code> in the second horizontal sizer.<a id="id267" class="indexterm"/>
</p><p>The last part of the Panel's layout is done by adding the two horizontal sizers to the vertical sizer. This time, since the sizer was created with a<code class="literal"> VERTICAL</code> orientation, the items are added from top to bottom. Finally, we use the<code class="literal"> Panel's SetSizer</code> method to assign the main outer<code class="literal"> BoxSizer</code> as the<code class="literal"> Panel's</code> sizer.</p><p>The<code class="literal"> BoxSizerFrame</code> also uses a<code class="literal"> BoxSizer</code> to manage the layout of its<code class="literal"> Panel</code>. The only difference here is that we used the<code class="literal"> Add</code> method's<code class="literal"> proportion</code> and<code class="literal"> flags</code> parameters to tell it to make the Panel expand to use the entire space available. After setting the Frame's sizer, we used its<code class="literal"> SetInitialSize</code> method, which queries the window's sizer and its descendents to get and set the best minimal size to set the window to. We will go into more detail about these other parameters and their effects in the next recipe.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec03"/>There's more...</h2></div></div></div><p>Included below is a little more additional information about adding spacers and items to a sizer's layout.</p><div class="section" title="Spacers"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec01"/>Spacers</h3></div></div></div><p>The<code class="literal"> AddSpacer</code> will add a square-shaped spacer that is X pixels wide by X pixels tall to the<code class="literal"> BoxSizer</code>, where X is the value passed to the<code class="literal"> AddSpacer</code> method. Spacers of other dimensions can be added by passing a<code class="literal"> tuple</code> as the first argument to the<code class="literal"> BoxSizer's Add</code> method.<a id="id268" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">someBoxSizer.Add((20,5))
</pre></div><p>This will add a 20x5 pixel spacer to the sizer. This can be useful when you don't want the vertical space to be increased by as much as the horizontal space, or vice versa.</p></div><div class="section" title="AddMany"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec02"/>AddMany</h3></div></div></div><p>The<code class="literal"> AddMany</code> method can be used to add an arbitrary number of items to the sizer in one call.<code class="literal"> AddMany</code> takes a<code class="literal"> list</code> of<code class="literal"> tuples</code> that contain values that are in the same order as the<code class="literal"> Add</code> method expects.<a id="id269" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">someBoxSizer.AddMany([(staticText,),
                      ((10, 10),),
                      (txtCtrl, 0, wx.EXPAND)]))

</pre></div><p>This will add three items to the sizer: the first two items only specify the one required parameter, and the third specifies the<code class="literal"> proportion</code> and<code class="literal"> flags</code> parameters.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec04"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Understanding proportions, flags, and borders</em></span> recipe in this chapter expands into further detail about the behavioral attributes of<code class="literal"> SizerItems</code>.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Understanding proportions, flags, and borders"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Understanding proportions, flags, and borders</h1></div></div></div><p>Through the use of the optional parameters in a sizer's various<code class="literal"> Add</code> methods, it is possible to control the relative proportions, alignment, and padding around every item that is managed by the sizer. Without using these additional settings, all the items in the sizer will just use their "best" minimum size and will be aligned to the top-left of the rectangle of space that the sizer provides. This means that the controls will not stretch or contract when the window is resized. Also, for example, if in a horizontal row of items in a<code class="literal"> BoxSizer</code> one of the items has a greater height than some of the other items in that same row, they may not be aligned as desired (see the following diagram).<a id="id270" class="indexterm"/>
</p><div class="mediaobject"><img src="images/1780_07_02.jpg" alt="Understanding proportions, flags, and borders"/></div><p>This diagram illustrates an alignment issue that can occur when some controls have a different-sized rectangle than the one next to it. This is a realistic example of a problem that can occur on GTK (Linux), as its<code class="literal"> ComboBoxes</code> tend to be much taller than a<code class="literal"> StaticTextCtrl</code>. So where on other platforms these two controls may appear to be properly center-aligned, they will look like this on Linux.</p><p>This recipe will re-implement the previous recipe's<code class="literal"> BoxSizerPanel</code>, using these additional<code class="literal"> Add</code> parameters to improve its layout, in order to show how these parameters can be used to influence how the sizer manages each of the controls that have been added to it.</p><div class="section" title="Getting Started"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec05"/>Getting Started</h2></div></div></div><p>Before getting started on this recipe, make sure you have reviewed the previous recipe,<span class="emphasis"><em> Using a BoxSizer</em></span>, as we will be modifying its<code class="literal"> _DoLayout</code> method in this recipe to define some additional behaviors that the sizers should apply to its layout.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec06"/>How to do it...</h2></div></div></div><p>Here, we will make some modifications to the<code class="literal"> SizerItems</code> proportions, flags, and borders to change the behavior of the layout:<a id="id271" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">    def _DoLayout(self):
        """Layout the controls"""
        vsizer = wx.BoxSizer(wx.VERTICAL)
        field1_sz = wx.BoxSizer(wx.HORIZONTAL)
        field2_sz = wx.BoxSizer(wx.HORIZONTAL)

        # Make the labels
        field1_lbl = wx.StaticText(self, label="Field 1:")
        field2_lbl = wx.StaticText(self, label="Field 2:")

        # 1) HORIZONTAL BOXSIZERS
        field1_sz.Add(field1_lbl, 0,
                      wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5)
        field1_sz.Add(self._field1, 1, wx.EXPAND)

        field2_sz.Add(field2_lbl, 0,
                      wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5)
        field2_sz.Add(self._field2, 1, wx.EXPAND)

        # 2) VERTICAL BOXSIZER
        vsizer.AddStretchSpacer()
        BOTH_SIDES = wx.EXPAND|wx.LEFT|wx.RIGHT
        vsizer.Add(field1_sz, 0, BOTH_SIDES|wx.TOP, 50)
        vsizer.AddSpacer(15)
        vsizer.Add(field2_sz, 0, BOTH_SIDES|wx.BOTTOM, 50)
        vsizer.AddStretchSpacer()

        # Finally assign the main outer sizer to the panel
        self.SetSizer(vsizer)

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec07"/>How it works...</h2></div></div></div><p>This recipe just shows what we changed in the previous recipe's<code class="literal"> __DoLayout</code> method to take advantage of some of these extra options. The first thing to notice in the section where we add the controls to the horizontal sizers is that we no longer have the<code class="literal"> AddSpacer</code> calls. These have been replaced by specifying a border in the<code class="literal"> Add</code> calls. When adding each of the labels we added two sizer flags,<code class="literal"> ALIGN_CENTER_VERTICAL</code> and<code class="literal"> RIGHT</code>. The first flag is an alignment flag that specifies the desired behavior of the alignment and the second is a border flag that specifies where we want the border parameter to be applied. In this case, the sizer will align the<code class="literal"> StaticText</code> in the center of the vertical space and add a 5px padding to the right side of it.</p><p>Next, where we add the<code class="literal"> TextCtrl</code> objects to the sizer, we specified a<code class="literal"> 1</code> for the proportion and<code class="literal"> EXPAND</code> for the sizer flag. Setting the proportion greater than the default of<code class="literal"> 0</code> will tell the sizer to give that control proportionally more of the space in the sizer's managed area. A proportion value greater than 0 in combination with the<code class="literal"> EXPAND</code> flag which tells the control to get bigger as space is available will let it stretch as the dialog is resized to a bigger size. Typically you will only need to specify<code class="literal"> 0</code> or<code class="literal"> 1</code> for the proportion parameter, but under some complex layouts it may be necessary to give different controls a relatively different amount of the total available space. For example, in a layout with two controls if both are given a proportion of 1, they would each get 50 percent of the space. Changing the proportion of one of the controls to 2 would change the space allocation to a 66/33 percent balance.<a id="id272" class="indexterm"/>
</p><p>We also made some changes to the final layout with the vertical sizer. First, instead of using the regular<code class="literal"> AddSpacer</code> function to add some static spacers to the layout, we changed it to use<code class="literal"> AddStretchSpacer</code> instead.<code class="literal"> AddStretchSpacer</code> is basically the equivalent of doing<code class="literal"> Add((-1,-1), 1, wx.EXPAND)</code>, which just adds a spacer of indeterminate size that will stretch as the window size is changed. This allows us to keep the controls in the center of the dialog as its vertical size changes.</p><p>Finally, when adding the two horizontal sizers to the vertical sizer, we used some flags to apply a static 50px of spacing around the<code class="literal"> LEFT, RIGHT</code>, and<code class="literal"> TOP</code> or<code class="literal"> BOTTOM</code> of the sizers. It's also important to notice that we once again passed the<code class="literal"> EXPAND</code> flag. If we did not do this, the vertical sizer would not allow those two items to expand which in turn would nullify us adding the<code class="literal"> EXPAND</code> flag for the<code class="literal"> TextCtrl</code> objects. Try running this and the previous sample side-by-side and resizing each window to see the difference in behavior.</p><div class="mediaobject"><img src="images/1780_07_03.jpg" alt="How it works..."/></div><p>The previous screenshot has had some lines drawn over it to show the five items that are managed by the main top level<code class="literal"> VERTICAL</code> sizer<code class="literal"> vsizer</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec08"/>There's more...</h2></div></div></div><p>There are a number of flags that can be used to affect the layout in various ways. The following three tables list the different categories of these flags that can be combined in the flag's bitmask:</p><div class="section" title="Alignment flags"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec03"/>Alignment flags</h3></div></div></div><p>This table shows a listing of all the alignment flags and a description of what each one does:<a id="id273" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Alignment flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALIGN_TOP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Align the item to the top of the available space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALIGN_BOTTOM</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Align the item to the bottom of the available space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALIGN_LEFT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Align the item to the left of the available space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALIGN_RIGHT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Align the item to the right of the available space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALIGN_CENTER_VERTICAL</code>
</p>
<p>
<code class="literal">wx.ALIGN_CENTRE_VERTICAL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Align the item in the center of the vertical space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALIGN_CENTER_HORIZONTAL</code>
</p>
<p>
<code class="literal">wx.ALIGN_CENTRE_HORIZONTAL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Align the item in the center of the horizontal space</p>
</td></tr></tbody></table></div></div><div class="section" title="Border flags"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec04"/>Border flags</h3></div></div></div><p>The following flags can be used to control which side(s) of the control the border argument of the Sizer's<code class="literal"> Add</code> method is applied to:<a id="id274" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Border flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.TOP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Apply the border to the top of the item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.BOTTOM</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Apply the border to the bottom of item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.LEFT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Apply the border to the left of the item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.RIGHT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Apply the border to the right of the item</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.ALL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Apply the border to all sides of the item</p>
</td></tr></tbody></table></div></div><div class="section" title="Behavior flags"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec05"/>Behavior flags</h3></div></div></div><p>The sizer flags in this table can be used to control how a control is resized within a sizer:<a id="id275" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Behaviour flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.EXPAND</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Item will expand to fill the space provided to it (<code class="literal">wx.GROW</code> is the same)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.SHAPED</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Similar to<code class="literal"> EXPAND</code> but maintains the item's aspect ratio</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.FIXED_MINSIZE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Don't let the item become smaller than its initial minimum size</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.RESERVE_SPACE_EVEN_IF_HIDDEN</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Don't allow the sizer to reclaim an item's space when it is hidden</p>
</td></tr></tbody></table></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec09"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<span class="emphasis"><em> Using a BoxSizer</em></span> recipe in this chapter for the basics of using a<code class="literal"> BoxSizer</code>.</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Laying out controls with the GridBagSizer</em></span> recipe in this chapter shows how to use one of the more complex sizer classes.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Laying out controls with the GridBagSizer"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec04"/>Laying out controls with the GridBagSizer</h1></div></div></div><p>There are a number of other types of sizers in wxPython, besides the<code class="literal"> BoxSizer</code>, that are designed to help simplify different kinds of layouts. The<code class="literal"> GridSizer, FlexGridSizer</code>, and<code class="literal"> GridBagSizer</code> can be used to lay items out in a grid-like manner. The<code class="literal"> GridSizer</code> provides a fixed grid layout where items are added into different "cells" in the grid. The<code class="literal"> FlexGridSizer</code> is just like the<code class="literal"> GridSizer</code>, except that the columns in the grid can be different widths. Finally, the<code class="literal"> GridBagSizer</code> is similar to the<code class="literal"> FlexGridSizer</code> but also allows items to span over multiple "cells" in the grid, which makes it possible to achieve layouts that can usually only be achieved by nesting several<code class="literal"> BoxSizers</code>. This recipe will discuss the use of the<code class="literal"> GridBagSizer</code>, and use it to create a dialog that could be used for viewing the details of a log event.<a id="id276" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec10"/>How to do it...</h2></div></div></div><p>Here we will create a custom<code class="literal"> DetailsDialog</code> that could be used for viewing log messages or system events. It has two fields in it for displaying the type of message and the verbose message text:<a id="id277" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class DetailsDialog(wx.Dialog):
    def __init__(self, parent, type, details, title=""):
        """Create the dialog
        @param type: event type string
        @param details: long details string
        """
        super(DetailsDialog, self).__init__(parent, title=title)

        # Attributes
        self.type = wx.TextCtrl(self, value=type,
                                style=wx.TE_READONLY)
        self.details = wx.TextCtrl(self, value=details,
                                   style=wx.TE_READONLY|
                                         wx.TE_MULTILINE)

        # Layout
        self.__DoLayout()
        self.SetInitialSize()

    def __DoLayout(self):
        sizer = wx.GridBagSizer(vgap=8, hgap=8)

        type_lbl = wx.StaticText(self, label="Type:")
        detail_lbl = wx.StaticText(self, label="Details:")

        # Add the event type fields
        sizer.Add(type_lbl, (1, 1))
        sizer.Add(self.type, (1, 2), (1, 15), wx.EXPAND)

        # Add the details field
        sizer.Add(detail_lbl, (2, 1))
        sizer.Add(self.details, (2, 2), (5, 15), wx.EXPAND)

        # Add a spacer to pad out the right side
        sizer.Add((5, 5), (2, 17))
        # And another to the pad out the bottom
        sizer.Add((5, 5), (7, 0))

        self.SetSizer(sizer)

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec11"/>How it works...</h2></div></div></div><p>The<code class="literal"> GridBagSizer's Add</code> method of<code class="literal"> GridBagSizer</code> takes some additional parameters compared to the other types of sizers. It is necessary to specify the grid position and optionally the number of columns and rows to span. We used this in our details dialog in order to allow the<code class="literal"> TextCtrl</code> fields to span multiple columns and multiple rows in the case of the details field. The way this layout works can get a little complicated, so let's go over our<code class="literal"> __DoLayout</code> method line-by-line to see how each of them affect the dialog's layout.<a id="id278" class="indexterm"/>
</p><p>First, we create out<code class="literal"> GridBagSizer</code>, and in its constructor we specify how much padding we want between the rows and columns. Next, we start adding our items to the sizer. The first item that we add is the type<code class="literal"> StaticText</code> label, which we added at row 1, column 1. This was done to leave some padding around the outside edge. Next, we added the<code class="literal"> TextCtrl</code> to the right of the label at row 1, column 2. For this item, we also specified the span parameter to tell the item to span 1 row and 15 columns. The column width is proportionally based upon the size of the first column in the grid.</p><p>Next we add the details fields, starting with the details label, which is added at row 2, column 1, in order to line up with the type<code class="literal"> StaticText</code> label. Since the details text may be long, we want it to span multiple rows. Hence, for its span parameter we specified for it to span 5 rows and 15 columns.</p><p>Finally, so that the padding around our controls on the bottom and right-hand side matches the top and left, we need to add a spacer to the right and bottom to create an extra column and row. Notice that for this step we need to take into account the span parameters of the previous items we added, so that our items do not overlap. Items cannot occupy the same column or row as any other item in the sizer. So first we add a spacer to row 2, column 17, to create a new column on the right-hand side of our<code class="literal"> TextCtrl</code> objects. We specified column 17 because the<code class="literal"> TextCtrl</code> objects start at column 2 and span 15 columns. Likewise, we did the same when adding one to the bottom, to take into account the span of the details text field. Note that instead of offsetting the first item in the grid and then adding spacers, it would have been easier to nest our<code class="literal"> GridBagSizer</code> inside of a<code class="literal"> BoxSizer</code> and specify a border. The approach in this recipe was done just to illustrate the need to account for an item's span when adding additional items to the grid:</p><div class="mediaobject"><img src="images/1780_07_04.jpg" alt="How it works..."/></div><p>See the sample code that accompanies this chapter for a small application that uses this dialog.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec12"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Understanding proportions, flags, and borders</em></span> recipe in this chapter describes the use of sizer flags in detail.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Standard dialog button layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Standard dialog button layout</h1></div></div></div><p>Each platform has different standards for how different dialog buttons are placed in the dialog. This is where the<code class="literal"> StdDialogButtonSizer</code> comes into play. It can be used to add standard buttons to a dialog, and automatically take care of the specific platform standards for where the button is positioned. This recipe shows how to use the<code class="literal"> StdDialogButtonSizer</code> to quickly and easily add standard buttons to a<code class="literal"> Dialog</code>.<a id="id279" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec13"/>How to do it...</h2></div></div></div><p>Here is the code for our custom message box class that can be used as a replacement for the standard<code class="literal"> MessageBox</code> in cases where the application wants to display custom icons in their pop-up dialogs:</p><div class="informalexample"><pre class="programlisting">class CustomMessageBox(wx.Dialog):
    def __init__(self, parent, message, title="",
                 bmp=wx.NullBitmap, style=wx.OK):
        super(CustomMessageBox, self).__init__(parent, title=title)

        # Attributes
        self._flags = style
        self._bitmap = wx.StaticBitmap(self, bitmap=bmp)
        self._msg = wx.StaticText(self, label=message)

        # Layout
        self.__DoLayout()
        self.SetInitialSize()
        self.CenterOnParent()

    def __DoLayout(self):
        vsizer = wx.BoxSizer(wx.VERTICAL)
        hsizer = wx.BoxSizer(wx.HORIZONTAL)

        # Layout the bitmap and caption
        hsizer.AddSpacer(10)
        hsizer.Add(self._bitmap, 0, wx.ALIGN_CENTER_VERTICAL)
        hsizer.AddSpacer(8)
        hsizer.Add(self._msg, 0, wx.ALIGN_CENTER_VERTICAL)
        hsizer.AddSpacer(10)

        # Create the buttons specified by the style flags
        # and the StdDialogButtonSizer to manage them
        btnsizer = self.CreateButtonSizer(self._flags)

        # Finish the layout
        vsizer.AddSpacer(10)
        vsizer.Add(hsizer, 0, wx.ALIGN_CENTER_HORIZONTAL)
        vsizer.AddSpacer(8)
        vsizer.Add(btnsizer, 0, wx.EXPAND|wx.ALL, 5)

        self.SetSizer(vsizer)

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec14"/>How it works...</h2></div></div></div><p>Here, we created a custom<code class="literal"> MessageBox</code> clone that can accept a custom<code class="literal"> Bitmap</code> to display instead of just the standard icons available in the regular<code class="literal"> MessageBox</code> implementation. This class is pretty simple, so let's jump into the<code class="literal"> __DoLayout</code> method to see how we made use of the<code class="literal"> StdDialogButtonSizer</code>.<a id="id280" class="indexterm"/>
</p><p>In<code class="literal"> __DoLayout</code>, we first created some regular<code class="literal"> BoxSizers</code> to do the main part of the layout, and then in one single line of code we created the entire layout for our buttons. To do this, we used the<code class="literal"> CreateButtonSizer</code> method of the base<code class="literal"> wx.Dialog</code> class. This method takes a bitmask of flags that specifies the buttons to create, then creates them, and adds them to a<code class="literal"> StdDialogButtonSizer</code> that it returns. All we need to do after this is to add the sizer to our dialog's main sizer and we are done!</p><p>The following screenshots show how the<code class="literal"> StdDialogButtonSizer</code> handles the differences in platform standards.</p><p>For example, the<span class="strong"><strong> OK</strong></span> and<span class="strong"><strong> Cancel</strong></span> buttons on a dialog are ordered as<span class="strong"><strong> OK/Cancel</strong></span> on Windows:<a id="id281" class="indexterm"/>
</p><div class="mediaobject"><img src="images/1780_07_05.jpg" alt="How it works..."/></div><p>On Macintosh OS X, the standard layout for the buttons is<span class="strong"><strong> Cancel/OK:</strong></span>
</p><div class="mediaobject"><img src="images/1780_07_06.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec15"/>There's more...</h2></div></div></div><p>Here is a quick reference to the flags that can be passed as a bitmask to the<code class="literal"> CreateButtonSizer</code> method in order to create the buttons that the button sizer will manage:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.OK</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates an OK button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.CANCEL</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a Cancel button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.YES</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a Yes button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.NO</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a No button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.HELP</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a Help button</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wx.NO_DEFAULT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Sets the No button as the default</p>
</td></tr></tbody></table></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec16"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Creating Stock Buttons</em></span> recipe in<a class="link" href="ch03.html" title="Chapter 3. Basic Building Blocks of a User Interface"> Chapter 3</a>,<span class="emphasis"><em> Basic Building Blocks of a User Interface</em></span> discusses how to create common buttons from built-in IDs.</li><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Using a BoxSizer</em></span> recipe in this chapter discusses the basics of window layout using<code class="literal"> BoxSizers</code>.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using XML resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec06"/>Using XML resources</h1></div></div></div><p>XRC is a way of creating and design window layouts with XML resource files. The hierarchical nature of XML parallels that of an application's window hierarchy, which makes it a very sensible data format to serialize a window layout with. This recipe shows how to create and load a simple dialog with two<code class="literal"> CheckBoxe</code> objects and two<code class="literal"> Button</code> objects on it, from an XML resource file.<a id="id282" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec17"/>How to do it...</h2></div></div></div><p>Here is the XML for our dialog that we have in a file called<code class="literal"> xrcdlg.xrc:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" ?&gt;
&lt;resource&gt;
  &lt;object class="wxDialog" name="xrctestdlg"&gt;
    &lt;object class="wxBoxSizer"&gt;
      &lt;orient&gt;wxVERTICAL&lt;/orient&gt;
      &lt;object class="spacer"&gt;
        &lt;option&gt;1&lt;/option&gt;
        &lt;flag&gt;wxEXPAND&lt;/flag&gt;
      &lt;/object&gt;
      &lt;object class="sizeritem"&gt;
        &lt;object class="wxCheckBox"&gt;
          &lt;label&gt;CheckBox Label&lt;/label&gt;
        &lt;/object&gt;
        &lt;flag&gt;wxALL|wxALIGN_CENTRE_HORIZONTAL&lt;/flag&gt;
        &lt;border&gt;5&lt;/border&gt;
      &lt;/object&gt;
      &lt;object class="spacer"&gt;
        &lt;option&gt;1&lt;/option&gt;
        &lt;flag&gt;wxEXPAND&lt;/flag&gt;
      &lt;/object&gt;
      &lt;object class="sizeritem"&gt;
        &lt;object class="wxBoxSizer"&gt;
          &lt;object class="sizeritem"&gt;
            &lt;object class="wxButton" name="wxID_OK"&gt;
              &lt;label&gt;Ok&lt;/label&gt;
            &lt;/object&gt;
            &lt;flag&gt;wxALL&lt;/flag&gt;
            &lt;border&gt;5&lt;/border&gt;
          &lt;/object&gt;
          &lt;object class="sizeritem"&gt;
            &lt;object class="wxButton" name="wxID_CANCEL"&gt;
              &lt;label&gt;Cancel&lt;/label&gt;
            &lt;/object&gt;
            &lt;flag&gt;wxALL&lt;/flag&gt;
            &lt;border&gt;5&lt;/border&gt;
          &lt;/object&gt;
          &lt;orient&gt;wxHORIZONTAL&lt;/orient&gt;
        &lt;/object&gt;
        &lt;flag&gt;wxALIGN_BOTTOM|wxALIGN_CENTRE_HORIZONTAL&lt;/flag&gt;
        &lt;border&gt;5&lt;/border&gt;
      &lt;/object&gt;
    &lt;/object&gt;
    &lt;title&gt;Xrc Test Dialog&lt;/title&gt;
    &lt;style&gt;wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER&lt;/style&gt;
  &lt;/object&gt;
&lt;/resource&gt;

</pre></div><p>When loaded, the above XML will generate the following dialog:</p><div class="mediaobject"><img src="images/1780_07_07.jpg" alt="How to do it..."/></div><p>This is a minimal program to load this XML resource to make and show the dialog it represents:</p><div class="informalexample"><pre class="programlisting">import wx
import wx.xrc as xrc
app = wx.App()
frame = wx.Frame(None)
resource = xrc.XmlResource("xrcdlg.xrc")
dlg = resource.LoadDialog(frame, "xrctestdlg")
dlg.ShowModal()
app.MainLoop()

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec18"/>How it works...</h2></div></div></div><p>The XML in this recipe was created with the help of<code class="literal"> xrced</code>, which is an XML resource editor tool that is a part of the wxPython tools package. The<code class="literal"> object</code> tag is used to represent a class object. Nesting other objects inside is how the parent child relationship is represented with the XML. The<code class="literal"> class</code> attribute of the<code class="literal"> object</code> tag is what is used to specify the type of class to create. The values should be a class name and in the case of wxPython provided classes, they use the<code class="literal"> wxWidgets</code> names, which are prefixed with "wx". To work with<code class="literal"> XmlResource</code> classes, it is highly recommended to use a tool like<code class="literal"> xrced</code> to generate the XML.<a id="id284" class="indexterm"/>
</p><p>In order to load the XML to create the object(s) that are used for representation, you need to import the<code class="literal"> wx.xrc</code> package, which provides the<code class="literal"> XmlResource</code> class. There are a few ways to use<code class="literal"> XmlResource</code> to perform the transformations on the XML. In this example, we created our<code class="literal"> XmlResource</code> object by passing the path to our<code class="literal"> xrc</code> file in its constructor. This object has a number of load methods for instantiating different types of objects. We want to load a dialog, so we called its<code class="literal"> LoadDialog</code> method, passing a parent window as the first argument and then the name of the dialog we want to load from the XML. It will then instantiate an instance of that dialog and return it so that we can show it.<a id="id285" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec19"/>There's more...</h2></div></div></div><p>Included below are some additional references to features available when using the XRC library.</p><div class="section" title="Loading other types of resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec06"/>Loading other types of resources</h3></div></div></div><p>The<code class="literal"> XmlResource</code> object has methods for loading many different kinds of resources from XML. Here is quick reference to some of the additional methods:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadBitmap(name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the Bitmap identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadDialog(parent, name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the Dialog identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadFrame(parent, name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the Frame identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadIcon(name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the Icon identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadMenu(name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the Menu identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadMenuBar(parent, name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the MenuBar identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadPanel(parent, name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the Panel identified by name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LoadToolBar(parent, name)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Loads and returns the ToolBar identified by name</p>
</td></tr></tbody></table></div></div><div class="section" title="Specifying standard IDs"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec07"/>Specifying standard IDs</h3></div></div></div><p>In order to give an object a standard ID in XRC, it should be specified in the<code class="literal"> object</code> tag's<code class="literal"> name</code> attribute, using the<code class="literal"> wxWidgets</code> naming for the ID (that is,<code class="literal"> wxID_OK</code> without the '.').</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec20"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<span class="emphasis"><em> Making a custom resource handler</em></span> recipe in this chapter contains some additional information on using XRC.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Making a custom resource handler"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec07"/>Making a custom resource handler</h1></div></div></div><p>Although XRC has built-in support for a large number of the standard controls, any non-trivial application will use its own subclasses and/or custom widgets. Creating a custom<code class="literal"> XmlResource</code> class will allow these custom classes to be loaded from an XML resource file. This recipe shows how to create an XML resource handler for a custom<code class="literal"> Panel</code> class and then use that handler to load the resource.<a id="id286" class="indexterm"/>
</p><div class="section" title="Getting Started"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec21"/>Getting Started</h2></div></div></div><p>This recipe discusses how to customize and extend the handling of XML resources. Please review the<span class="emphasis"><em> Using XML resources</em></span> recipe in this chapter to learn the basics of how XRC works.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec22"/>How to do it...</h2></div></div></div><p>In the following code, we will show how to create a custom XML resource handler for a Panel and then how to use XRC to load that resource into a Frame:</p><div class="informalexample"><pre class="programlisting">import wx
import wx.xrc as xrc

# Xml to load our object
RESOURCE = r"""&lt;?xml version="1.0"?&gt;
&lt;resource&gt;
&lt;object class="TextEditPanel" name="TextEdit"&gt;
&lt;/object&gt;
&lt;/resource&gt;
"""
</pre></div><p>Here, in our Frame subclass, we simply create an instance of our custom resource handler and use it to load our custom Panel:<a id="id287" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class XrcTestFrame(wx.Frame):
    def __init__(self, parent, *args, **kwargs):
        super(XrcTestFrame, self).__init__(*args, **kwargs)

        # Attributes
        resource = xrc.EmptyXmlResource()
        handler = TextEditPanelXmlHandler()
        resource.InsertHandler(handler)
        resource.LoadFromString(RESOURCE)
        self.panel = resource.LoadObject(self,
                                         "TextEdit",
                                         "TextEditPanel")

        # Layout
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.panel, 1, wx.EXPAND)
        self.SetSizer(sizer)

</pre></div><p>Here is the Panel class that our custom resource handler will be used to create. It is just a simple Panel with a<code class="literal"> TextCtrl</code> and two<code class="literal"> Buttons</code> on it:</p><div class="informalexample"><pre class="programlisting">class TextEditPanel(wx.Panel):
    """Custom Panel containing a TextCtrl and Buttons
    for Copy and Paste actions.
    """
    def __init__(self, parent, *args, **kwargs):
        super(TextEditPanel, self).__init__(*args, **kwargs)

        # Attributes
        self.txt = wx.TextCtrl(self, style=wx.TE_MULTILINE)
        self.copy = wx.Button(self, wx.ID_COPY)
        self.paste = wx.Button(self, wx.ID_PASTE)

        # Layout
        self._DoLayout()

        # Event Handlers
        self.Bind(wx.EVT_BUTTON, self.OnCopy, self.copy)
        self.Bind(wx.EVT_BUTTON, self.OnPaste, self.paste)

    def _DoLayout(self):
        """Layout the controls"""
        vsizer = wx.BoxSizer(wx.VERTICAL)
        hsizer = wx.BoxSizer(wx.HORIZONTAL)

        vsizer.Add(self.txt, 1, wx.EXPAND)
        hsizer.AddStretchSpacer()
        hsizer.Add(self.copy, 0, wx.RIGHT, 5)
        hsizer.Add(self.paste)
        hsizer.AddStretchSpacer()
        vsizer.Add(hsizer, 0, wx.EXPAND|wx.ALL, 10)

        # Finally assign the main outer sizer to the panel
        self.SetSizer(vsizer)

    def OnCopy(self, event):
        self.txt.Copy()

    def OnPaste(self, event):
        self.txt.Paste()

</pre></div><p>Finally, here is our custom XML resource handler class, where we just have to override two methods to implement the handling for our<code class="literal"> TextEditPanel</code> class:<a id="id288" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">class TextEditPanelXmlHandler(xrc.XmlResourceHandler):
    """Resource handler for our TextEditPanel"""
    def CanHandle(self, node):
        """Required override. Returns a bool to say
        whether or not this handler can handle the given class
        """
        return self.IsOfClass(node, "TextEditPanel")

    def DoCreateResource(self):
        """Required override to create the object"""
        panel = TextEditPanel(self.GetParentAsWindow(),
                              self.GetID(),
                              self.GetPosition(),
                              self.GetSize(),
                              self.GetStyle("style",
                                            wx.TAB_TRAVERSAL),
                              self.GetName())
        self.SetupWindow(panel)
        self.CreateChildren(panel)
        return panel

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec23"/>How it works...</h2></div></div></div><p>The<code class="literal"> TextEditPanel</code> is our custom class that we want to create a custom resource handler for. The<code class="literal"> TextEditPanelXmlHandler</code> class is a minimal resource handler that we created to be able to load our class from XML. This class has two required overrides that need to be implemented for it to function properly. The first is<code class="literal"> CanHandle</code>, which is called by the framework to check if the handler can handle a given node type. We used the<code class="literal"> IsOfClass</code> method to check if the node was of the same type as our<code class="literal"> TextEditPanel</code>. The second is<code class="literal"> DoCreateResource</code>, which is what is called to create our class. To create the class, all of its arguments can be retrieved from the resource handler.<a id="id289" class="indexterm"/>
</p><p>The<code class="literal"> XrcTestFrame</code> class is where we made use of our custom resource handler. First, we created an<code class="literal"> EmptyXmlResource</code> object and used its<code class="literal"> InsertHandler</code> method to add our custom handler to it. Then we loaded the XML from the<code class="literal"> RESOURCE</code> string that we defined using the handler's<code class="literal"> LoadFromString</code> method. After that, all there was to do was load the object using the resource's<code class="literal"> LoadObject</code> method, which takes three arguments: the<code class="literal"> parent</code> window of the object to be loaded, the<code class="literal"> name</code> of the object in the XML resource, and the<code class="literal"> classname</code>.<a id="id290" class="indexterm"/>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec24"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">See the<span class="emphasis"><em> Understanding inheritance limitations</em></span> recipe in<a class="link" href="ch01.html" title="Chapter 1. Getting Started with wxPython"> Chapter 1</a>,<span class="emphasis"><em> Getting Started with wxPython</em></span> for some additional information about overriding virtual methods in wxPython classes.</li><li class="listitem" style="list-style-type: disc">See the<span class="emphasis"><em> Using XML resources</em></span> recipe in this chapter for more examples of using XML to create screen layouts.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using the AuiFrameManager"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec08"/>Using the AuiFrameManager</h1></div></div></div><p>The<code class="literal"> AuiFrameManager</code> is part of the Advanced User Interface (wx.aui) library added to wxPython in 2.8. It allows a Frame to have a very user customizable interface. It automatically manages children windows in panes that can be undocked and turned into separate floating windows. There are also some built-in features to help with persisting and restoring the window's layout during running the application. This recipe will create a Frame base class that has AUI support and will automatically save its perspective and reload it when the application is next launched.<a id="id291" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec25"/>How to do it...</h2></div></div></div><p>The following code will define a base class that encapsulates some of the usage of an<code class="literal"> AuiManager:</code>
<a id="id292" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">import wx
import wx.aui as aui

class AuiBaseFrame(wx.Frame):
    """Frame base class with builtin AUI support"""
    def __init__(self, parent, *args, **kwargs):
        super(AuiBaseFrame, self).__init__(*args, **kwargs)
wx.Frame.__init__(self, parent, *args, **kwargs)

        # Attributes
        auiFlags = aui.AUI_MGR_DEFAULT
        if wx.Platform == '__WXGTK__' and \
           aui.AUI_MGR_DEFAUL &amp; aui.AUI_MGR_TRANSPARENT_HINT:
            # Use venetian blinds style as transparent can 
            # cause crashes on Linux when desktop compositing
            # is used. (wxAUI bug in 2.8)
            auiFlags -= aui.AUI_MGR_TRANSPARENT_HINT
            auiFlags |= aui.AUI_MGR_VENETIAN_BLINDS_HINT
        self._mgr = aui.AuiManager(self, flags=auiFlags)

        # Event Handlers
        self.Bind(wx.EVT_CLOSE, self.OnAuiBaseClose)

</pre></div><p>
<code class="literal">OnAuiBaseClose</code> will be called when the Frame closes. We use this as the point to get the current window layout perspective and save it for the next time the application is launched:</p><div class="informalexample"><pre class="programlisting">def OnAuiBaseClose(self, event):
        """Save perspective on exit"""
        appName = wx.GetApp().GetAppName()
        assert appName, “No App Name Set!”
        config = wx.Config(appName)
        perspective = self._mgr.SavePerspective()
        config.Write("perspective", perspective)
        event.Skip() # Allow event to propagate

</pre></div><p>
<code class="literal">AddPane</code> simply wraps getting access to the Frame's<code class="literal"> AuiManager</code> and adds the given pane and<code class="literal"> auiInfo</code> to it:</p><div class="informalexample"><pre class="programlisting">    def AddPane(self, pane, auiInfo):
        """Add a panel to be managed by this Frame's
        AUI Manager.
        @param pane: wx.Window instance
        @param auiInfo: AuiInfo Object
        """
        # Delegate to AuiManager
        self._mgr.AddPane(pane, auiInfo)
        self._mgr.Update() # Refresh the layout

</pre></div><p>The next method is simply a convenience method for creating and adding the main center pane to the managed window:<a id="id293" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">    def SetCenterPane(self, pane):
        """Set the main center pane of the frame.
        Convenience method for AddPane.
        @param pane: wx.Window instance
        """
        info = aui.AuiPaneInfo()
        info = info.Center().Name("CenterPane")
        info = info.Dockable(False).CaptionVisible(False)
        self._mgr.AddPane(pane, info)

</pre></div><p>This final method is used to load the last saved window layout from the last time the window was opened:</p><div class="informalexample"><pre class="programlisting">    def LoadDefaultPerspective(self):
        appName = wx.GetApp().GetAppName()
        assert appName, "Must set an AppName!"
        config = wx.Config(appName)
        perspective = config.Read("perspective")
        if perspective:
            self._mgr.LoadPerspective(perspective)

</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec26"/>How it works...</h2></div></div></div><p>In this recipe, we created a class to help encapsulate some of the<code class="literal"> AuiManager's</code> functionality. So let's take a look at some of the functionality that this class provides, and how it works.<a id="id294" class="indexterm"/>
</p><p>The<code class="literal"> __init__</code> method is where we create the<code class="literal"> AuiManager</code> object that will manage the panes that we want to add to the Frame. The<code class="literal"> AuiManager</code> accepts a number of possible flags to dictate its behavior. We employed a small workaround for a bug on Linux platforms that use desktop compositing. Using the transparent docking hints can cause an AUI application to crash in this scenario, so we replaced it with the venetian blind style instead.</p><p>
<code class="literal">OnAuiBaseClose</code> is used as an event handler for when the<code class="literal"> Frame</code> closes. We use this as a hook to automatically store the current layout of the<code class="literal"> AuiManager</code>, which is called a perspective, for the next application launch. To implement this feature, we have created a requirement that the App object's<code class="literal"> SetName</code> method was called to set the application name because we need this in order to use<code class="literal"> wx.Config</code>. The<code class="literal"> wx.Config</code> object is simply an interface used to access the Registry on Windows or an application configuration file on other platforms.<code class="literal"> SavePerspective</code> returns a string encoded with all of the information that the<code class="literal"> AuiManager</code> needs in order to restore the current window layout. The application can then simply call our<code class="literal"> LoadDefaultPerspective</code> method when the application starts up, in order to restore the user's last window layout.</p><p>The other two methods in this class are quite simple and are provided simply for convenience to delegate to the<code class="literal"> AuiManager</code> of the<code class="literal"> Frame</code>. The<code class="literal"> AddPane</code> method of the<code class="literal"> AuiManager</code> is how to add panes to be managed by it. The<code class="literal"> pane</code> argument needs to be a window object that is a child of the<code class="literal"> Frame</code>. In practice, this is usually some sort of<code class="literal"> Panel</code> subclass. The<code class="literal"> auiInfo</code> argument is an<code class="literal"> AuiPaneInfo</code> object. This is what the<code class="literal"> AuiManager</code> uses to determine how to manage the pane. See the sample code that accompanies this recipe for an example of this class in action.<a id="id295" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec27"/>There's more...</h2></div></div></div><p>Here is a quick reference to the flags that can be used in the flags bitmask for the<code class="literal"> AuiManager</code> in order to customize its behavior and the styles of some of its components:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_DEFAULT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Equivalent of<code class="literal"> AUI_MGR_ALLOW_FLOATING| AUI_MGR_TRANSPARENT_HINT| AUI_MGR_HINT_FADE| AUI_MGR_NO_VENETIAN_BLINDS_FADE</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_ALLOW_FLOATING</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allow for floating panes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_ALLOW_ACTIVE_PANE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Highlight the caption bar of the currently-active pane</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_HINT_FADE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Fade docking hints out of view</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_LIVE_RESIZE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Resize panes while the sash between them is being dragged</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_NO_VENETIAN_BLINDS_FADE</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Disable the venetian blind fade in/out</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_RECTANGLE_HINT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Show a simple rectangle docking hint when dragging floating panes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_TRANSPARENT_DRAG</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Make floating panes partially-transparent when they are being dragged</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_TRANSPARENT_HINT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Show a partially-transparent light blue docking hint when dragging floating panels</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AUI_MGR_VENETIAN_BLINDS_HINT</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Use a venetian blind style docking hint for floating panels</p>
</td></tr></tbody></table></div></div></div></div>
</body></html>