<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Working with a RESTful API and Pulse Width Modulation</h1></div></div></div><p>In this chapter, we will interact with the board with HTTP requests and we will use pulse width modulation to generate different output voltages. We shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Work with the Tornado web server to build a RESTful API in Python</li><li class="listitem" style="list-style-type: disc">Compose and send HTTP requests to print numbers in LEDs</li><li class="listitem" style="list-style-type: disc">Work with pulse width modulation to control the output voltage in pins</li><li class="listitem" style="list-style-type: disc">Fade in and fade out LEDs connected to the board</li><li class="listitem" style="list-style-type: disc">Use different tools to compose and send HTTP requests that interact with the board</li><li class="listitem" style="list-style-type: disc">Build a RESTful API to mix red, green and blue and generate millions of colors with an RGB LED</li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">mraa</code> and <code class="literal">wiring-x86</code> libraries to control pulse width modulation</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Printing numbers in LEDs with a RESTful API</h1></div></div></div><p>Tornado<a id="id151" class="indexterm"/> is a <a id="id152" class="indexterm"/>Python web framework and asynchronous networking library. It is well known for providing great <a id="id153" class="indexterm"/>scalability due to its non-blocking network I/O. We will take advantage of the fact that Tornado makes it really easy to build a RESTful API and make it possible for any client to consume this API and print numbers in LEDs connected to the board. The following<a id="id154" class="indexterm"/> is the web page for the Tornado web server: <a class="ulink" href="http://www.tornadoweb.org">http://www.tornadoweb.org</a>.</p><p>In <a class="link" href="ch01.html" title="Chapter 1. Understanding and Setting up the Base IoT Hardware">Chapter 1</a>, <em>Understanding and Setting up the Base IoT Hardware</em>, we installed the <code class="literal">pip</code> installer to easily install additional Python 2.7.3 packages in the Yocto Linux that we are running on the board. Now, we will use a <code class="literal">pip</code> installer to install Tornado 4.3. We just need to run the following command in the SSH terminal to install the package. </p><div><pre class="programlisting">pip install tornado</pre></div><p>The last lines for the output will indicate that the <code class="literal">tornado</code> package has been successfully installed. Don't <a id="id155" class="indexterm"/>worry about the error<a id="id156" class="indexterm"/> messages related to building wheel and the insecure platform warning.</p><div><pre class="programlisting">Collecting tornado
/usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/util/ssl_.py:90: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
  InsecurePlatformWarning
  Downloading tornado-4.3.tar.gz (450kB)
    100% |################################| 454kB 25kB/s 
Collecting backports.ssl-match-hostname (from tornado)
  Downloading backports.ssl_match_hostname-3.5.0.1.tar.gz
Collecting singledispatch (from tornado)
  Downloading singledispatch-3.4.0.3-py2.py3-none-any.whl
Collecting certifi (from tornado)
  Downloading certifi-2015.11.20.1-py2.py3-none-any.whl (368kB)
    100% |################################| 372kB 31kB/s 
Collecting backports-abc&gt;=0.4 (from tornado)
  Downloading backports_abc-0.4-py2.py3-none-any.whl
Collecting six (from singledispatch-&gt;tornado)
  Downloading six-1.10.0-py2.py3-none-any.whl
...
Installing collected packages: backports.ssl-match-hostname, six, singledispatch, certifi, backports-abc, tornado
  Running setup.py install for backports.ssl-match-hostname
  Running setup.py install for tornado
Successfully installed backports-abc-0.4 backports.ssl-match-hostname-3.5.0.1 certifi-2015.11.20.1 singledispatch-3.4.0.3 six-1.10.0 tornado-4.3</pre></div><p>Now, we will install HTTPie, a command-line HTTP client written in Python that makes it easy to send HTTP requests and uses a syntax that is easier than curl (also known as cURL). HTTPie displays colorized output and will make it easy for us to send HTTP requests to test our RESTful API. We just need to run the following command in the SSH terminal to install the package.</p><div><pre class="programlisting">pip install --upgrade httpie</pre></div><p>The last lines for the output will indicate that the <code class="literal">httpie</code> package has been successfully installed. Don't worry about the insecure platform warning.</p><div><pre class="programlisting">Collecting httpie
/usr/lib/python2.7/site-packages/pip/_vendor/requests/packages/urllib3/util/ssl_.py:90: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
  InsecurePlatformWarning
  Downloading httpie-0.9.3-py2.py3-none-any.whl (66kB)
    100% |################################| 69kB 117kB/s 
Collecting Pygments&gt;=1.5 (from httpie)
  Downloading Pygments-2.0.2-py2-none-any.whl (672kB)
    100% |################################| 675kB 17kB/s 
Collecting requests&gt;=2.3.0 (from httpie)
  Downloading requests-2.9.1-py2.py3-none-any.whl (501kB)
    100% |################################| 503kB 23kB/s 
Installing collected packages: Pygments, requests, httpie
Successfully installed Pygments-2.0.2 httpie-0.9.3 requests-2.9.1</pre></div><p>Now, we<a id="id157" class="indexterm"/> can use an <code class="literal">http</code> command to easily send HTTP requests to <code class="literal">localhost</code> and test the RESTful API built with Tornado. Obviously, after we test that the RESTful API is working OK locally, we want to send HTTP requests from a computer or device connected to our<a id="id158" class="indexterm"/> LAN. You can install HTTPie in your computer or use any other application that allows you to compose and send HTTP requests, such as the previously mentioned<a id="id159" class="indexterm"/> curl utility (<a class="ulink" href="http://curl.haxx.se">http://curl.haxx.se</a>) or <a id="id160" class="indexterm"/>Telerik Fiddler (<a class="ulink" href="http://www.telerik.com/fiddler">http://www.telerik.com/fiddler</a>) in case you are working on Windows. Telerik Fiddler is a free web debugging proxy with a GUI but it only runs on Windows. You can even use apps that can compose and send HTTP requests from mobile devices and test the RESTful API by using them. </p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>If you are working on either OS X or Linux, you can open a Terminal and start using curl from the command line. If you are working on Windows, you can easily install curl from the Cygwin package installation option, and execute it from the Cygwin terminal. </p></div></div><p>In order to build a RESTful API with Tornado, first we have to create subclasses of the <code class="literal">tornado.web.RequestHandler</code> class and override the necessary methods to handle the HTTP requests to the URL. For example, if we want to handle an HTTP <code class="literal">GET</code> request with a synchronous operation, we must create a new subclass of the <code class="literal">tornado.web.RequestHandler</code> class and define the <code class="literal">get</code> method with the required arguments, if any. If we want to handle an HTTP <code class="literal">PUT</code> request, we just need to define the <code class="literal">put</code> method with the required arguments. Then, we have to map the URL pattern in an instance of the <code class="literal">tornado.web.Application</code> class.</p><p>The<a id="id161" class="indexterm"/> following lines show the new classes that we must add to our existing code with either the <code class="literal">mraa</code> or the <code class="literal">wiring-x86</code> libraries that made it possible to print numbers in LEDs in the <a id="id162" class="indexterm"/>previous chapter. We already had the <code class="literal">Led</code> and <code class="literal">NumberInLeds</code> classes and the code adds the following classes: <code class="literal">BoardInteraction</code>, <code class="literal">VersionHandler</code>, <code class="literal">PutNumberInLedsHandler</code>, <code class="literal">GetCurrentNumberHandler</code>. The code file for the sample is <code class="literal">iot_python_chapter_04_01.py</code>.</p><div><pre class="programlisting">import mraa
from datetime import date
import tornado.escape
import tornado.ioloop
import tornado.web

class BoardInteraction:
    number_in_leds = NumberInLeds()
    current_number = 0


class VersionHandler(tornado.web.RequestHandler):
    def get(self):
        response = {'version': '1.0',
                    'last_build': date.today().isoformat()}
        self.write(response)


class PutNumberInLedsHandler(tornado.web.RequestHandler):
    def put(self, number):
        int_number = int(number)
        BoardInteraction.number_in_leds.print_number(int_number)
        BoardInteraction.current_number = int_number
        response = {'number': int_number}
        self.write(response)


class GetCurrentNumberHandler(tornado.web.RequestHandler):
    def get(self):
        response = {'number': BoardInteraction.current_number}
        self.write(response)</pre></div><p>The <code class="literal">BoardInteraction</code> class declares two class attributes: <code class="literal">number_in_leds</code> and <code class="literal">current_number</code>. The other classes define methods that work with these class attributes, to access a common <code class="literal">NumberInLeds</code> instance, saved in <code class="literal">number_in_leds</code>, and the current number that is being displayed with LEDs, saved in <code class="literal">current_number</code>.</p><p>The code declares the following three subclasses of <code class="literal">tornado.web.RequestHandler</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">VersionHandler</code>: Defines<a id="id163" class="indexterm"/> the parameter less <code class="literal">get</code> method that returns a response with the version number and the last build date.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PutNumberInLedsHandler</code>: Defines<a id="id164" class="indexterm"/> the <code class="literal">put</code> method that requires a number argument that specifies the number that has to be printed with LEDs. The method calls the <code class="literal">print_number</code> method for the <code class="literal">NumberInLeds</code> instance stored in the <code class="literal">BoardInteraction.number_in_leds</code> class attribute with the desired number of LEDs to be turned on specified in the <code class="literal">number</code> attribute. Then, the code saves the number that is being printed with LEDs in the <code class="literal">BoardInteraction.current_number</code> class attribute and returns a response with the printed number.</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetCurrentNumberHandler</code>: Defines <a id="id165" class="indexterm"/>the parameter less <code class="literal">get</code> method that returns a response with the value of the <code class="literal">BoardInteraction.current_number</code> class attribute, that is, the number that is being printed with LEDs.</li></ul></div><p>The<a id="id166" class="indexterm"/> following<a id="id167" class="indexterm"/> lines use the previously declared subclasses of <code class="literal">tornado.web.RequestHandler</code> to make up the web application with Tornado that represents the RESTful API and the new <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_04_01.py</code>.</p><div><pre class="programlisting">application = tornado.web.Application([
    (r"/putnumberinleds/([0-9])", PutNumberInLedsHandler),
    (r"/getcurrentnumber", GetCurrentNumberHandler),
    (r"/version", VersionHandler)])


if __name__ == "__main__":
       print("Listening at port 8888")
    BoardInteraction.number_in_leds.print_number(0)
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()</pre></div><p>First, the code creates an instance of the <code class="literal">tornado.web.Application</code> class named <code class="literal">application</code> with the list of request handlers that make up the web application. The code passes a list of tuples to the <code class="literal">Application</code> constructor. The list is composed of a regular expression (<code class="literal">regexp</code>) and a subclass of <code class="literal">tornado.web.RequestHandler</code> (<code class="literal">request_class</code>).</p><p>The <code class="literal">__main__</code> method prints a message indicating the port number in which the HTTP server is listening and uses the <code class="literal">NumberInLeds</code> instance saved in <code class="literal">BoardInteraction.number_in_leds</code> to print number 0, that is, to turn off the nine LEDs. The next line calls the <code class="literal">application.listen</code> method to build an HTTP server for the application with the defined rules on the specified port. The code passes <code class="literal">8888</code> for the <code class="literal">port</code> argument, that is, the default port value for the Tornado HTTP server.</p><p>Then, the <a id="id168" class="indexterm"/>call to <code class="literal">tornado.ioloop.IOLoop.instance().start()</code> starts the server created with <code class="literal">application.listen</code>. This way, whenever the web application receives a request, Tornado iterates over the list of request handlers that make up the web application <a id="id169" class="indexterm"/>and creates an instance of the first <code class="literal">tornado.web.RequestHandler</code> subclass whose associated regular expression matches the request path. Then, Tornado calls one of the following methods the corresponding parameters for the new instance based on the HTTP request:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">head</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">get</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">post</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">patch</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">put</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">options</code></li></ul></div><p>The following table shows some HTTP requests that match the regular expressions defined in the preceding code. In this case, the HTTP requests use localhost because they are executed locally on the Yocto Linux running on the board. If we replace localhost with the board's assigned IP address, we can make the HTTP requests from any computer or device connected to our LAN.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>HTTP verb and request URL</p>
</th><th style="text-align: left" valign="bottom">
<p>Tuple (<code class="literal">regexp</code>, <code class="literal">request_class</code>) that matches the request path</p>
</th><th style="text-align: left" valign="bottom">
<p>
<code class="literal">RequestHandler</code> subclass and method that is called</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET http://localhost:8888/version</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/version", VersionHandler)])</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">VersionHandler.get()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT http://localhost:8888/putnumberinleds/5</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/putnumberinleds/([0-9])", PutNumberInLedsHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">PutNumberInLedsHandler.put(5)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT http://localhost:8888/putnumberinleds/8</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/putnumberinleds/([0-9])", PutNumberInLedsHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">PutNumberInLedsHandler.put(8)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET http://localhost:8888/getcurrentnumber</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/getcurrentnumber", GetCurrentNumberHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">GetCurrentNumberHandler.get()</code>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">RequestHandler</code> class declares a <code class="literal">SUPPORTED_METHODS</code> class attribute with the following code. In this case, we haven't overridden the class attribute, and therefore, we inherit superclass declaration:</p><div><pre class="programlisting">SUPPORTED_METHODS = ("GET", "HEAD", "POST", "DELETE", "PATCH", "PUT", "OPTIONS")</pre></div><p>The <a id="id170" class="indexterm"/>default code declared in the superclass for the <code class="literal">get</code>, <code class="literal">head</code>, <code class="literal">post</code>, <code class="literal">delete</code>, <code class="literal">patch</code>, <code class="literal">put</code>, and <code class="literal">options</code> methods is a single line that raises an <code class="literal">HTTPError</code>. For example, the following line shows the code for the <code class="literal">get</code> method defined in the <code class="literal">RequestHandler</code> class.</p><div><pre class="programlisting">def get(self, *args, **kwargs):
    raise HTTPError(405)</pre></div><p>Whenever<a id="id171" class="indexterm"/> the web application receives a request and matches the URL pattern, Tornado performs the following actions:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new instance of the <code class="literal">RequestHandler</code> subclass that has been mapped to the URL pattern.</li><li class="listitem">Call the <code class="literal">initialize</code> method with the keyword arguments specified in the application configuration. We can override the <code class="literal">initialize</code> method to save the arguments into member variables.</li><li class="listitem">No matter which is the HTTP request, call the <code class="literal">prepare</code> method. If we call either <code class="literal">finish</code> or <code class="literal">send_error</code>, Tornado won't call any additional methods. We can override the <code class="literal">prepare</code> method to execute code that is necessary for any HTTP request and then write the specific code in the <code class="literal">get</code>, <code class="literal">head</code>, <code class="literal">post</code>, <code class="literal">delete</code>, <code class="literal">patch</code>, <code class="literal">put</code> or <code class="literal">options</code> methods.</li><li class="listitem">Call the method according to the HTTP request with the arguments based on the URL regular expression that captured the different groups. As previously explained, we must override the methods we want our <code class="literal">RequestHandler</code> subclass to be able to process. For example, if there was an HTTP <code class="literal">GET</code> request, Tornado will call the <code class="literal">get</code> method with the different arguments.</li><li class="listitem">In this case, we are working with synchronous handlers, and therefore, Tornado calls <code class="literal">on_finish</code> after the previous method called according to the HTTP request returned. We can override the <code class="literal">on_finish</code> method to perform cleanup or logging. It is very important to understand that Tornado calls <code class="literal">on_finish</code> after it sent the response to the client.</li></ol></div><p>The <a id="id172" class="indexterm"/>following line will start the HTTP server and our RESTful API in the Yocto Linux running on the board. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client, as explained in the previous chapter.</p><div><pre class="programlisting">python iot_python_chapter_04_01.py</pre></div><p>After we start<a id="id173" class="indexterm"/> the HTTP server, we will see the following output and all the LEDs on the board are going to be turned off.</p><div><pre class="programlisting">Listening at port 8888
==== Turning on 0 LEDs ====
I've turned off the LED connected to GPIO Pin #9, in position 1.
I've turned off the LED connected to GPIO Pin #8, in position 2.
I've turned off the LED connected to GPIO Pin #7, in position 3.
I've turned off the LED connected to GPIO Pin #6, in position 4.
I've turned off the LED connected to GPIO Pin #5, in position 5.
I've turned off the LED connected to GPIO Pin #4, in position 6.
I've turned off the LED connected to GPIO Pin #3, in position 7.
I've turned off the LED connected to GPIO Pin #2, in position 8.
I've turned off the LED connected to GPIO Pin #1, in position 9.</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Composing and sending HTTP requests</h1></div></div></div><p>The <a id="id174" class="indexterm"/>HTTP server is running in Yocto Linux and waiting for our HTTP requests to control the LEDs on connected to the Intel Galileo Gen 2 board. Now, we <a id="id175" class="indexterm"/>will compose and send HTTP requests locally in Yocto Linux and then from other computer or devices connected to our LAN. </p><p>HTTPie supports curl-like shorthands for localhost. For example, <code class="literal">:8888</code> is a shorthand that expands to <code class="literal">http://localhost:8888</code>. We already have an SSH terminal running the HTTP server, and therefore, we can run the following command in another SSH terminal.</p><div><pre class="programlisting">http GET :8888/version</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">GET http://localhost:8888/version</code>. The request is the simplest case in our RESTful API because it will match and run the <code class="literal">VersionHandler.get</code> method that just receives <code class="literal">self</code> as a parameter because the URL pattern doesn't include any parameters. The method creates a response dictionary and then calls the <code class="literal">self.write</code> method with <code class="literal">response</code> as a parameter. The <code class="literal">self.write</code> method writes the received chunk to the output buffer. Because the chunk (<code class="literal">response</code>) is a dictionary, <code class="literal">self.write</code> writes it as JSON and sets the <code class="literal">Content-Type</code> of the response to <code class="literal">application/json</code>. The following lines show an<a id="id176" class="indexterm"/> example response for the HTTP request, including the response headers:</p><div><pre class="programlisting">HTTP/1.1 200 OK
Content-Length: 46
Content-Type: application/json; charset=UTF-8
Date: Thu, 28 Jan 2016 03:15:21 GMT
Etag: "fb066668a345b0637fdc112ac0ddc37c318d8709"
Server: TornadoServer/4.3

{
    "last_build": "2016-01-28", 
    "version": "1.0"
}</pre></div><p>We can<a id="id177" class="indexterm"/> execute HTTPie with the <code class="literal">-b</code> option in case we don't want to include the header in the response. For example, the following line performs the same HTTP request but doesn't display the header in the response output.</p><div><pre class="programlisting">http –b GET :8888/version</pre></div><p>Once we know that our request is running OK, we can open a new terminal, command-line or the GUI tool that we want to use to compose and send HTTP requests from a computer or any device connected to the LAN. We just need to use the IP address assigned to the board instead of <code class="literal">localhost</code> in our request URLs. Don't forget to replace <code class="literal">192.168.1.107</code> with your board's IP address in the next requests.</p><p>Now, we can run the following HTTPie command in a computer or device to use the RESTful API to make the board turn on the five LEDs. After you enter the command, you will notice the SSH terminal that displays the output for the Python code will display a message indicating that it is turning on 5 LEDs and the additional messages indicating the LEDs that are being turned on and off. In addition, you will see 5 LEDs turned on.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putnumberinleds/5</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">PUT http://192.168.1.107:8888/putnumberinleds/5</code>. The request will match and run the <code class="literal">PutNumberInLedsHandler.put</code> method that receives <code class="literal">5</code> in its <code class="literal">number</code> parameter. The following lines show the response from the HTTP server with the number that has been printed in LEDs, that is, the number of LEDs that have been turned on:</p><div><pre class="programlisting">{
    "number": 5
}</pre></div><p>The following image shows two Terminal windows side-by-side on OS X. The Terminal window at the left-hand side is running on a computer that is generating the HTTP requests and the Terminal window at the right-hand side is the SSH terminal that is running the Tornado HTTP server in Yocto Linux and displays the output for our Python code. It is a<a id="id178" class="indexterm"/> good idea to use a similar configuration to check the output <a id="id179" class="indexterm"/>while we compose and send the HTTP requests.</p><div><img src="img/B05042_04_01.jpg" alt="Composing and sending HTTP requests"/></div><p>In Fiddler, click <strong>Composer</strong> or press <em>F9</em>, select <strong>PUT</strong> in the dropdown menu in the <strong>Parsed</strong> tab, and enter <code class="literal">192.168.1.107:8888/putnumberinleds/5</code> in the textbox at the right-hand side of the dropdown (don't forget to replace the IP with your board's IP). Then, click <strong>Execute</strong> and double-click on the 200 result that appears on the capture log. If you want to see the raw response, just click on the <strong>Raw</strong> button below the <strong>Request Headers</strong> panel.</p><p>The following image shows a Fiddler window side-by-side with a Putty terminal window on Windows. The Fiddler window at the left-hand side is running on a computer that is generating the HTTP requests and the Putty terminal window at the right-hand side is the SSH terminal that is running the Tornado HTTP server in Yocto Linux and displays the output for our Python code.</p><div><img src="img/B05042_04_02.jpg" alt="Composing and sending HTTP requests"/></div><p>We can run<a id="id180" class="indexterm"/> the following HTTPie command in a computer or device to use the RESTful API to tell us how many LEDs are turned on.</p><div><pre class="programlisting">http -b GET 192.168.1.107:8888/getcurrentnumber</pre></div><p>The <a id="id181" class="indexterm"/>previous command will compose and send the following HTTP request: <code class="literal">GET http://192.168.1.107:8888/getcurrentnumber</code>. The request will match and run the <code class="literal">GetCurrentNumber.get</code> method. The following lines show the response from the HTTP server with the number that has been printed in LEDs, that is, the number of LEDs that have been turned on with the last API call:</p><div><pre class="programlisting">{
    "number": 5
}</pre></div><p>If we take a<a id="id182" class="indexterm"/> look again at the list of request handlers that make up the web application, we will notice that the entry for <code class="literal">putnumberinleds</code> specifies a regular expression that accepts numbers from 0 to 9 as its parameters:</p><div><pre class="programlisting">(r"/putnumberinleds/([0-9])", PutNumberInLedsHandler)</pre></div><p>If we run <a id="id183" class="indexterm"/>the following HTTPie command in a computer or device to use the RESTful API to make the board turn on twelve LEDs, the request won't match any regular expression in the list of request handlers.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putnumberinleds/12</pre></div><p>Thus, Tornado will return a <code class="literal">404: Not found</code> error as a result.</p><div><pre class="programlisting">&lt;html&gt;&lt;title&gt;404: Not Found&lt;/title&gt;&lt;body&gt;404: Not Found&lt;/body&gt;&lt;/html&gt;</pre></div><p>The same will happen if we run the following HTTPie command in a computer or device because <code class="literal">x</code> isn't a number between 0 and 9.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putnumberinleds/x</pre></div><p>The following HTTPie command will turn on 8 LEDs.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putnumberinleds/8</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">PUT http://192.168.1.107:8888/putnumberinleds/8</code>. The request will match and run the <code class="literal">PutNumberInLedsHandler.put</code> method that receives <code class="literal">8</code> in its <code class="literal">number</code> parameter. The following lines show the response from the HTTP server with the number that has been printed in LEDs, that is, the number of LEDs that have been turned on:</p><div><pre class="programlisting">{
    "number": 8
}</pre></div><p>The number of LEDs that are turned on changed from 5 to 8, and therefore, we can run the following HTTPie command in a computer or device to use the RESTful API to tell us how many LEDs are turned on.</p><div><pre class="programlisting">http -b GET 192.168.1.107:8888/getcurrentnumber</pre></div><p>The following lines show the response from the HTTP server with the number that has been printed in LEDs:</p><div><pre class="programlisting">{
    "number": 8
}</pre></div><p>We created a very simple RESTful API that allows us to turn on LEDs and check which is the number that is currently printed in LEDs. Of course, we should add authentication and overall <a id="id184" class="indexterm"/>security to the RESTful API in order to make it complete. Our RESTful API makes it possible for us to print numbers in LEDs with any application, mobile <a id="id185" class="indexterm"/>app or web application that can compose and send HTTP requests.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Wiring pins with PWM capabilities</h1></div></div></div><p>We <a id="id186" class="indexterm"/>want to control the output voltage to make it possible to fade in and fade out three LEDs of three different colors: red, green and blue. The lower the output voltage, the lower the brightness level for the LEDs. The higher the <a id="id187" class="indexterm"/>output voltage, the higher the brightness level for the LEDs. Thus, as the output voltage is nearer to 0V, the brightness for the LEDs is lower and when the output voltage is nearer the IOREF voltage, that is, 5V in our actual configuration, the brightness is higher for the LEDs. Specifically, we want to be able to set 256 brightness levels for each LED, from 0 to 255. In this case, we will use three LEDs but we will move to a single RGB LED capable of mixing the three colors in a single electronic component later in this chapter.</p><p>When we worked with GPIO pins configured as digital outputs, we could set an output voltage of 0V (low value) or the IOREF voltage, that is, 5V in our actual configuration (high value). Thus, we could just turn off or turn on the LED with its maximum brightness level (without burning it).</p><p>If we connect our red, green and blue LEDs to three GPIO pins and we configure them as digital outputs, we won't be able to set 256 brightness levels. We have to connect the three LEDs to three of the digital I/O pins that we can use as<a id="id188" class="indexterm"/> <strong>PWM</strong> (short for <strong>Pulse Width Modulation</strong>) output pins. In <a class="link" href="ch01.html" title="Chapter 1. Understanding and Setting up the Base IoT Hardware">Chapter 1</a>, <em>Understanding and Setting up the Base IoT Hardware</em>, when we learned about the I/O pins included in the Intel Galileo Gen 2 board, we learned that the pins labeled with a tilde symbol (~) as a prefix for the number can be used as PWM output pins. Thus, we can use the following pins to connect the three LEDs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pin <strong>~6</strong> to connect the red LED</li><li class="listitem" style="list-style-type: disc">Pin <strong>~5 </strong>to connect the green LED</li><li class="listitem" style="list-style-type: disc">Pin <strong>~3</strong> to connect the blue LED</li></ul></div><p>After we finish the necessary wirings, we will write Python code to create another RESTful API that will allow us to set the brightness for each of the three LEDs. We need the following parts to work with this example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One red ultrabright 5mm LED</li><li class="listitem" style="list-style-type: disc">One green ultrabright 5mm LED</li><li class="listitem" style="list-style-type: disc">One blue ultrabright 5mm LED</li><li class="listitem" style="list-style-type: disc">Three 270Ω resistors with 5% tolerance (red violet brown gold)</li></ul></div><p>The<a id="id189" class="indexterm"/> following <a id="id190" class="indexterm"/>diagram shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_04_02.fzz</code> and the following image is the breadboard view:</p><div><img src="img/B05042_04_03.jpg" alt="Wiring pins with PWM capabilities"/></div><p>In this case, we wanted the three LEDs to be close to each other. This way, the three LEDs can <a id="id191" class="indexterm"/>project their light to a black surface and <a id="id192" class="indexterm"/>we can see how the intersection of the three colors generates a color that will be similar to a color selected in a color picker we will use later.</p><p>The following image shows the schematic with the electronic components represented as symbols.</p><div><img src="img/B05042_04_04.jpg" alt="Wiring pins with PWM capabilities"/></div><p>As <a id="id193" class="indexterm"/>seen in<a id="id194" class="indexterm"/> the previous schematic, three PWM capable GPIO pins labeled <strong>D3 PWM</strong>, <strong>D5 PWM</strong> and <strong>D6 PWM</strong> in the board's symbol is connected to a <strong>270Ω</strong> resistor, wired to an LED's anode, and each LED's cathode is connected to ground.</p><p>Now, it is time to insert the components in the breadboard and make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Using PWM to generate analog values</h1></div></div></div><p>Pulse <a id="id195" class="indexterm"/>width modulation, known<a id="id196" class="indexterm"/> as PWM, is a technique that makes it possible to generate an analog result with digital means through the usage of a digital on-off pattern. The pins that provide PWM capabilities use a digital control to create a square wave and it can simulate voltages between the configured <strong>IOREF</strong> voltage (5V in the default board configuration) and 0V by controlling the amount of time that the signal spends in the ON status (<strong>IOREF</strong> voltage) and the time the signal spends in the OFF status (0V). The pulse width is the duration of the signal in the ON status (<strong>IOREF</strong> voltage), and therefore, pulse width modulation means changing the pulse width to get perceived analog values.</p><p>When you repeat <a id="id197" class="indexterm"/>the signal in the ON status and the signal in the OFF status hundreds of times per second with a LED connected to the PWM pin, we can generate the same result as if the signal is a steady voltage between 0V and the <strong>IOREF</strong> voltage to control the LED's brightness level.</p><p>We can write<a id="id198" class="indexterm"/> floating point values from 0 to 1 to the PWM enabled pins configured as analog output, that is, from 0% duty cycle (always signal in the OFF status) to 100% duty cycle (always signal in the ON status). We want to represent 256 brightness values (from 0 to 255 inclusive), and therefore, the following graph shows the brightness values in the abscissa axis (<em>x</em>-axis) and the corresponding floating point values that have to be written to the pin in the ordinate axis (<em>y</em>-axis).</p><div><img src="img/B05042_04_05.jpg" alt="Using PWM to generate analog values"/></div><p>The equation for the previous graph is the following: <code class="literal">y = x / 255</code>, specifically <code class="literal">value = brightness / 255</code>. We can run the following code in our Python interpreter to see the output with all the values that will be written for each brightness level from 0 to 255 inclusive.</p><div><pre class="programlisting">for brightness in range(0, 256):
    print(brightness / 255.0)</pre></div><p>We can multiply the floating point values by 5 to calculate the voltage value for each brightness level. As we are working with the default settings for the board, the <strong>IOREF</strong> jumper is set to 5V, and therefore, a 1.0 value in the output means 5V (<code class="literal">1.0 x 5 = 5</code>). A value of 0.5 in<a id="id199" class="indexterm"/> the output means 2.5V (<code class="literal">0.5 x 5 = 2.5</code>). The following graph shows the brightness values in the abscissa axis (x-axis) and the corresponding voltage values in the output that<a id="id200" class="indexterm"/> will generate the corresponding brightness value in the LEDs in the ordinate axis (<em>y</em>-axis).</p><div><img src="img/B05042_04_06.jpg" alt="Using PWM to generate analog values"/></div><p>The equation for the previous graph is the following: <code class="literal">y = x / 255 * 5</code>, specifically <code class="literal">voltage = brightness / 255 * 5</code>. We can run the following code in our Python interpreter to see the output with all the voltages that will be generated for each brightness level from 0 to 255 inclusive.</p><div><pre class="programlisting">for brightness in range(0, 256):
    print(brightness / 255.0 * 5)</pre></div><p>We will create a new <code class="literal">AnalogLed</code> class to represent an LED connected to our board that can have a brightness level from 0 to 255 inclusive. The following lines show the code for the new <code class="literal">AnalogLed</code> class. The code file for the sample is <code class="literal">iot_python_chapter_04_02.py</code>.</p><div><pre class="programlisting">import mraa
from datetime import date
import tornado.escape
import tornado.ioloop
import tornado.web


class AnalogLed:
    def __init__(self, pin, name):
        self.pin = pin
        self.name = name
        self.pwm = mraa.Pwm(pin)
        self.pwm.period_us(700)
        self.pwm.enable(True)
        self.brightness_value = 0
        self.set_bightness(0)

    def set_brightness(self, value):
        brightness_value = value
        if brightness_value &gt; 255:
            brightness_value = 255
        elif brightness_value &lt; 0:
            brightness_value = 0
        led_value = brightness_value / 255.0
        self.pwm.write(led_value)
        self.brightness_value = brightness_value
        print("{0} LED connected to PWM Pin #{1} set to brightness {2}.".format(self.name, self.pin, brightness_value))</pre></div><p>We <a id="id201" class="indexterm"/>have to specify the pin number to which the LED is connected when we create an instance of the <code class="literal">AnalogLed</code> class in the <code class="literal">pin</code> required argument, and a name for the LED in the <code class="literal">name</code> required argument. The<a id="id202" class="indexterm"/> constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">mraa.Pwm</code> instance with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument, saves its reference in the <code class="literal">pwm</code> attribute and calls its <code class="literal">period_us</code> method to configure the PWM period in 700 microseconds (700 µs). Thus, the output duty cycle will determine the percentage of the 700 microsecond period during which the signal is in the ON status. For example, a 0.5 (50%) output duty cycle means that the signal will be ON during 350 microseconds of the 700 microseconds period (700 * 0.5 = 350).</p><p>Then, the the code calls the <code class="literal">pwm.enable</code> method with <code class="literal">True</code> as a parameter to set the enable status of the PWM pin and allow us to start setting the output duty-cycle percentage for the PWM pin with calls to the <code class="literal">pwm.write</code> method.</p><p>The next line creates a <code class="literal">brightness_value</code> attribute initialized with 0 that will allow us to easily retrieve the last brightness value set to the LED connected to the pin. Finally, the constructor calls the <code class="literal">set_brightness</code> method with 0 as the value for the <code class="literal">value</code> argument to set the brightness level for the LED connected to the configured pin to 0.</p><p>The class defines a <code class="literal">set_brightness</code> method that receives a brightness level value in the <code class="literal">value</code> argument. The first lines of code make sure that we always set a brightness level between 0 and 255 (inclusive). In case the <code class="literal">value</code> argument has a value that isn't included in that range, the code assigns the lower-level (0) or upper-level value (255) to the <code class="literal">brightness_value</code> variable.</p><p>Then, the<a id="id203" class="indexterm"/> code calculates the necessary output duty-cycle percentage for the PWM pin to represent the brightness level as a floating point value between <code class="literal">1.0f</code> (100%) and <code class="literal">0.0f</code> (0%). The code saves the value in the <code class="literal">led_value</code> variable and then calls the <code class="literal">self.pwm.write</code> method with this variable for the percentage argument to set the output duty-cycle for the pin configured as PWM output to <code class="literal">led_value</code>. The next line saves the valid brightness level to the <code class="literal">brightness_value</code> attribute.</p><p>Finally, the <a id="id204" class="indexterm"/>code prints details about the LED name, the pin number and the brightness level that has been set. This way, the method translates a brightness level from 0 to 255 (inclusive) into the appropriate output duty-cycle value for the pin and writes the output to control the connected LED's brightness level.</p><p>Now, we can write code that uses the new <code class="literal">AnalogLed</code> class to create one instance for each of the three LEDs and easily control their brightness levels. The following lines show the code for the <code class="literal">BoardInteraction</code> class. The code file for the sample is <code class="literal">iot_python_chapter_04_02.py</code>.</p><div><pre class="programlisting">class BoardInteraction:
    # The Red LED is connected to pin ~6
    red_led = AnalogLed(6, 'Red')
    # The Green LED is connected to Pin ~5
    green_led = AnalogLed(5, 'Green')
    # The Blue LED is connected to Pin ~3
    blue_led = AnalogLed(3, 'Blue')</pre></div><p>The <code class="literal">BoardInteraction</code> class just declares three class attributes: <code class="literal">red_led</code>, <code class="literal">green_led</code> and <code class="literal">blue_led</code>. The three class attributes save new instances of the previously created <code class="literal">AnalogLed</code> class and represent the red, green and blue LEDs connected to pins <strong>~6</strong>, <strong>~5</strong> and <strong>~3</strong>. Now, we will create other classes that define methods that work with these class attributes to access common <code class="literal">AnalogLed</code> instances.</p><p>The next lines show the code that adds the following classes: <code class="literal">VersionHandler</code>, <code class="literal">PutRedBrightnessHandler</code>, <code class="literal">PutGreenBrightnessHandler</code> and <code class="literal">PutBlueBrightnessHandler</code>. The code file for the sample is <code class="literal">iot_python_chapter_04_02.py</code>.</p><div><pre class="programlisting">class VersionHandler(tornado.web.RequestHandler):
    def get(self):
        response = {'version': '1.0',
                    'last_build': date.today().isoformat()}
        self.write(response)


class PutRedBrightnessHandler(tornado.web.RequestHandler):
    def put(self, value):
        int_value = int(value)
        BoardInteraction.red_led.set_brightness(int_value)
        response = {'red': BoardInteraction.red_led.brightness_value}
        self.write(response)


class PutGreenBrightnessHandler(tornado.web.RequestHandler):
    def put(self, value):
        int_value = int(value)
        BoardInteraction.green_led.set_brightness(int_value)
        response = {'green': BoardInteraction.green_led.brightness_value}
        self.write(response)


class PutBlueBrightnessHandler(tornado.web.RequestHandler):
    def put(self, value):
        int_value = int(value)
        BoardInteraction.blue_led.set_brightness(int_value)
        response = {'blue': BoardInteraction.blue_led.brightness_value}
        self.write(response)</pre></div><p>The code <a id="id205" class="indexterm"/>declares the<a id="id206" class="indexterm"/> following four subclasses of <code class="literal">tornado.web.RequestHandler</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">VersionHandler</code>: Defines <a id="id207" class="indexterm"/>the parameter less <code class="literal">get</code> method that returns a response with the version number and the last build date.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PutRedBrightnessHandler</code>: Defines <a id="id208" class="indexterm"/>the <code class="literal">put</code> method that requires a value argument that specifies the desired brightness level for the red LED. The method calls the <code class="literal">set_brightness</code> method for the <code class="literal">AnalogNumber</code> instance stored in the <code class="literal">BoardInteraction.red_led</code> class attribute with the desired brightness level specified in the <code class="literal">value</code> argument. Then, the code returns a response with the brightness level that has been translated to an output duty cycle percentage in the PWM pin to which the red LED is connected to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PutGreenBrightnessHandler</code>: Defines<a id="id209" class="indexterm"/> the <code class="literal">put</code> method to set the desired brightness level for the green LED. It works as the previously described <code class="literal">PutRedBrightnessHandler</code> method but instead of using the <code class="literal">BoardInteraction.red_led</code> class attribute, the code uses <code class="literal">BoardInteraction.green_led</code> class attribute to control the brightness level for the green LED.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PutBlueBrightnessHandler</code>: Defines<a id="id210" class="indexterm"/> the <code class="literal">put</code> method to set the desired brightness level for the blue LED. It works as the previously described <code class="literal">PutRedBrightnessHandler</code> method but instead of using the <code class="literal">BoardInteraction.red_led</code> class attribute, the code uses <code class="literal">BoardInteraction.blue_led</code> class attribute to control the brightness level for the blue LED.</li></ul></div><p>The next<a id="id211" class="indexterm"/> lines show the code that adds the following classes: <code class="literal">GetRedBrightnessHandler</code>, <code class="literal">GetGreenBrightnessHandler</code> and <code class="literal">GetBlueBrightnessHandler</code>. The code file for the sample is <code class="literal">iot_python_chapter_04_02.py</code>.</p><div><pre class="programlisting">class GetRedBrightnessHandler(tornado.web.RequestHandler):
    def get(self):
        response = {'red': BoardInteraction.red_led.brightness_value}
        self.write(response)


class GetGreenBrightnessHandler(tornado.web.RequestHandler):
    def get(self):
        response = {'green': BoardInteraction.green_led.brightness_value}
        self.write(response)


class GetBlueBrightnessHandler(tornado.web.RequestHandler):
    def get(self):
        response = {'blue': BoardInteraction.blue_led.brightness_value}
        self.write(response)</pre></div><p>The code declares the following three subclasses of <code class="literal">tornado.web.RequestHandler</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GetRedBrightnessHandler</code>: Defines <a id="id212" class="indexterm"/>the parameter less <code class="literal">get</code> method that returns a response with the value of the <code class="literal">BoardInteraction.red_led.brightness_value</code> attribute, that is, the brightness value set to the red LED</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetGREENBrightnessHandler</code>: Defines<a id="id213" class="indexterm"/> the parameter less <code class="literal">get</code> method that returns a response with the value of the <code class="literal">BoardInteraction.green_led.brightness_value</code> attribute, that is, the brightness value set to the green LED</li><li class="listitem" style="list-style-type: disc"><code class="literal">GetBlueBrightnessHandler</code>: Defines <a id="id214" class="indexterm"/>the parameter less <code class="literal">get</code> method that returns a response with the value of the <code class="literal">BoardInteraction.blue_led.brightness_value</code> attribute, that is, the brightness value set to the blue LED</li></ul></div><p>The following lines use the previously declared subclasses of <code class="literal">tornado.web.RequestHandler</code> to make up the web application with Tornado that represents a new RESTful API and the new <code class="literal">__main__</code> method. The code file for the sample is <code class="literal">iot_python_chapter_04_02.py</code>.</p><div><pre class="programlisting">application = tornado.web.Application([
    (r"/putredbrightness/([0-9]+)", PutRedBrightnessHandler),
    (r"/putgreenbrightness/([0-9]+)", PutGreenBrightnessHandler),
    (r"/putbluebrightness/([0-9]+)", PutBlueBrightnessHandler),
    (r"/getredbrightness", GetRedBrightnessHandler),
    (r"/getgreenbrightness", GetGreenBrightnessHandler),
    (r"/getbluebrightness", GetBlueBrightnessHandler),
    (r"/version", VersionHandler)])


if __name__ == "__main__":
    print("Listening at port 8888")
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()</pre></div><p>As <a id="id215" class="indexterm"/>happened in our previous example, the code creates an instance of the <code class="literal">tornado.web.Application</code> class named <code class="literal">application</code> with the list of request handlers that make up the web application, that is, the tuples of regular expressions and subclasses of <code class="literal">tornado.web.RequestHandler</code>.</p><p>The following table shows some HTTP requests that match the regular expressions defined in the preceding code. In this case, the HTTP requests use <code class="literal">192.168.1.107</code> because they are executed from a computer connected to our LAN. Don't forget to replace <code class="literal">192.168.1.107</code> with your board's IP address in the next requests.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>HTTP verb and request URL</p>
</th><th style="text-align: left" valign="bottom">
<p>Tuple (<code class="literal">regexp</code>, <code class="literal">request_class</code>) that matches the request path</p>
</th><th style="text-align: left" valign="bottom">
<p>
<code class="literal">RequestHandler</code> subclass and method that is called</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT http:// 192.168.1.107:8888/putredbrightness/30</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/putredbrightness/([0-9]+)", PutRedBrightnessHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">PutRedBrightnessHandler.put(30)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT http:// 192.168.1.107:8888/putgreenbrightness/128</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/putgreenbrightness/([0-9]+)", PutGreenBrightnessHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">PutGreenBrightnessHandler.put(128)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">PUT http:// 192.168.1.107:8888/putbluebrightness/255</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/putbluebrightness/([0-9]+)", PutBlueBrightnessHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">PutGreenBrightnessHandler.put(255)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET http:// 192.168.1.107:8888/getredbrightness</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/getredbrightness", GetRedBrightnessHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">GetRedBrightnessHandler.get()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET http:// 192.168.1.107:8888/getgreenbrightness</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/getgreenbrightness", GetGreenBrightnessHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">GetGreenBrightnessHandler.get()</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">GET http:// 192.168.1.107:8888/getbluebrightness</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">(r"/getbluebrightness", GetBlueBrightnessHandler)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">GetBlueBrightnessHandler.get()</code>
</p>
</td></tr></tbody></table></div><p>The<a id="id216" class="indexterm"/> following line will start the HTTP server and our RESTful API that allows us to control the brightness level for red, green and blue LEDs in the Yocto Linux running on the board. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client, as explained in the previous chapter.</p><div><pre class="programlisting">python iot_python_chapter_04_02.py</pre></div><p>After we start the HTTP server, we will see the following output and all the red, green and blue LEDs are going to be turned off.</p><div><pre class="programlisting">Red LED connected to PWM Pin #6 set to brightness 0.
Green LED connected to PWM Pin #5 set to brightness 0.
Blue LED connected to PWM Pin #3 set to brightness 0.
Listening at port 8888</pre></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Generating analog values via HTTP requests</h1></div></div></div><p>The <a id="id217" class="indexterm"/>HTTP server is running in Yocto Linux and waiting for our HTTP requests to control the LEDs on connected to the Intel Galileo Gen 2 board. Now, we <a id="id218" class="indexterm"/>will compose and send HTTP requests from other computer or devices connected to our LAN and we will control the brightness levels for the red, green and blue LEDs.</p><p>Open a new terminal, command-line or the GUI tool that we want to use to compose and send HTTP requests from a computer or any device connected to the LAN. Don't forget to replace <code class="literal">192.168.1.107</code> with your board's IP address in the next requests.</p><p>Run the following HTTPie command in a computer or device to use the RESTful API to make the board set the brightness level for the red LED to 30. After you enter the command, you will notice the SSH terminal that displays the output for the Python code will display the following message: <strong>Red LED connected to PWM Pin #6 set to brightness 30</strong>. In addition, you will see the red LED turned on with a very low brightness level.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putredbrightness/30</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">PUT http://192.168.1.107:8888/putredbrightness/30</code>. The request will match and run the <code class="literal">PutRedBrightnessHandler.put</code> method that receives <code class="literal">30</code> in its <code class="literal">value</code> parameter. The following lines show the response from the HTTP server with the brightness level that has been set for the red LED by taking advantage of PWM:</p><div><pre class="programlisting">{
    "red": 30
}</pre></div><p>We can run the following HTTPie command in a computer or device to use the RESTful API to tell us the current brightness level for the red LED.</p><div><pre class="programlisting">http -b GET 192.168.1.107:8888/getredbrightness</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">GET http://192.168.1.107:8888/getredbrightness</code>. The request will match and run the <code class="literal">GetRedBrightnessHandler.get</code> method. The following lines show the response from the HTTP server with the brightness level that has been previously set for the red LED with the API call:</p><div><pre class="programlisting">{
    "red": 30
}</pre></div><p>Now, run the following HTTPie command in a computer or device to use the RESTful API to make the board set the brightness level for the green LED to 128. After you enter the command, you will notice the SSH terminal that displays the output for the Python code will display the following message: <strong>Green LED connected to PWM Pin #5 set to brightness 128</strong>. In addition, you will see the green LED turned on with a very low brightness level.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putredbrightness/128</pre></div><p>The <a id="id219" class="indexterm"/>previous command will compose <a id="id220" class="indexterm"/>and send the following HTTP request: <code class="literal">PUT http://192.168.1.107:8888/putgreenbrightness/128</code>. The request will match and run the <code class="literal">PutGreenBrightnessHandler.put</code> method that receives <code class="literal">128</code> in its <code class="literal">value</code> parameter. The following lines show the response from the HTTP server with the brightness level that has been set for the green LED:</p><div><pre class="programlisting">{
    "green": 128
}</pre></div><p>Finally, we run the following HTTPie command in a computer or device to use the RESTful API to make the board set the brightness level for the blue LED to <code class="literal">255</code>, that is, its highest brightness level. After you enter the command, you will notice the SSH terminal that displays the output for the Python code will display the following message: <strong>Blue LED connected to PWM Pin #3 set to brightness 255</strong>. In addition, you will see the blue LED turned on with its highest brightness level.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putbluebrightness/255</pre></div><p>The previous command will compose and send the following HTTP request: <code class="literal">PUT http://192.168.1.107:8888/putbluebrightness/255</code>. The request will match and run the <code class="literal">PutBlueBrightnessHandler.put</code> method that receives 255 in its <code class="literal">value</code> parameter. The following lines show the response from the HTTP server with the brightness level that has been set for the blue LED:</p><div><pre class="programlisting">{
    "blue": 255
}</pre></div><p>Now, we can run the following two HTTPie commands to use the RESTful API to tell us the current brightness levels for the green and blue LEDs.</p><div><pre class="programlisting">http -b GET 192.168.1.107:8888/getgreenbrightness
http -b GET 192.168.1.107:8888/getbluebrightness</pre></div><p>The following lines show the two responses from the HTTP server with the brightness levels that had been set for the green and blue LEDs:</p><div><pre class="programlisting">{
    "green": 128
}

{
    "blue": 255
}</pre></div><p>We created a very simple RESTful API that allows us to set the desired brightness for red, green and<a id="id221" class="indexterm"/> blue LEDs, and check their current brightness levels. Our RESTful API makes it possible for us to generate different <a id="id222" class="indexterm"/>colors with the intersections of the three color and their different brightness levels with any application, mobile app or web application that can compose and send HTTP requests.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Preparing the RESTful API for Web application requirements</h1></div></div></div><p>We want<a id="id223" class="indexterm"/> to develop a simple web application that displays a color picker to allow the user to choose a color. Once the user picks a color, we can obtain the red, green and blue components from 0 to 255 inclusive. We want to set the brightness level for the red, green and blue LEDs on the board based on the red, green and blue values for the selected color. Based on this requirement, it is convenient to add a new <code class="literal">PUT</code> method to our RESTful API to allow us to change the brightness levels for the three LEDs in single API call.</p><p>The next lines show the code that adds a new <code class="literal">PutRGBBrightnessHandler</code> class. The code file for the sample is <code class="literal">iot_python_chapter_04_03.py</code>.</p><div><pre class="programlisting">class PutRGBBrightnessHandler(tornado.web.RequestHandler):
    def put(self, red, green, blue):
        int_red = int(red)
        int_green = int(green)
        int_blue = int(blue)
        BoardInteraction.red_led.set_brightness(int_red)
        BoardInteraction.green_led.set_brightness(int_green)
        BoardInteraction.blue_led.set_brightness(int_blue)
        response = dict(
            red=BoardInteraction.red_led.brightness_value,
            green=BoardInteraction.green_led.brightness_value,
            blue=BoardInteraction.blue_led.brightness_value)
        self.write(response)</pre></div><p>The code declares a new subclass of <code class="literal">tornado.web.RequestHandler</code> named <code class="literal">PutRGBBrightnessHandler</code>. The class defines the <code class="literal">put</code> method that requires three arguments that specify the desired brightness for each of the three LEDs: red, green and blue. The method calls the <code class="literal">set_brightness</code> method for the <code class="literal">AnalogNumber</code> instances stored in the <code class="literal">BoardInteraction.red_led</code>, <code class="literal">BoardInteraction.green_led</code> and <code class="literal">BoardInteraction.blue_led</code> class attributes with the desired brightness levels specified in the arguments. Then, the code returns a response with the brightness levels that have been translated to output duty cycle percentages in the PWM pins to which the red, green and blue LEDs are connected to.</p><p>Now, it is <a id="id224" class="indexterm"/>necessary to add the highlighted lines to the code that creates an instance of the <code class="literal">tornado.web.Application</code> class named <code class="literal">application</code> with the list of request handlers that make up the web application, that is, the tuples of regular expressions and subclasses of <code class="literal">tornado.web.RequestHandler</code>. The code file for the sample is <code class="literal">iot_python_chapter_04_03.py</code>.</p><div><pre class="programlisting">application = tornado.web.Application([
    (r"/putredbrightness/([0-9]+)", PutRedBrightnessHandler),
    (r"/putgreenbrightness/([0-9]+)", PutGreenBrightnessHandler),
    (r"/putbluebrightness/([0-9]+)", PutBlueBrightnessHandler),
<strong>    (r"/putrgbbrightness/r([0-9]+)g([0-9]+)b([0-9]+)", </strong>
<strong>     PutRGBBrightnessHandler),</strong>
    (r"/getredbrightness", GetRedBrightnessHandler),
    (r"/getgreenbrightness", GetGreenBrightnessHandler),
    (r"/getbluebrightness", GetBlueBrightnessHandler),
    (r"/version", VersionHandler)])</pre></div><p>The following line will start the HTTP server and our new version of the RESTful API that allows us to control the brightness level for red, green and blue LEDs with a single API call in the Yocto Linux running on the board. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client, as explained in the previous chapter.</p><div><pre class="programlisting">python iot_python_chapter_04_03.py</pre></div><p>After we start the HTTP server, we will see the following output and all the red, green and blue LEDs are going to be turned off.</p><div><pre class="programlisting">Red LED connected to PWM Pin #6 set to brightness 0.
Green LED connected to PWM Pin #5 set to brightness 0.
Blue LED connected to PWM Pin #3 set to brightness 0.
Listening at port 8888</pre></div><p>With the new RESTful API we can compose the following HTTP verb and request URL:</p><div><pre class="programlisting">
<code class="literal">PUT http://192.168.1.107:8888/putrgbbrightness/r30g128b255</code>
</pre></div><p>The previous request path will match the previously added tuple (<code class="literal">regexp</code>, <code class="literal">request_class</code>) <code class="literal">(r"/putrgbbrightness/r([0-9]+)g([0-9]+)b([0-9]+)", PutRGBBrightnessHandler)</code> and Tornado will call the <code class="literal">PutRGBBrightnessHandler.put</code> method with the values for <code class="literal">red</code>, <code class="literal">green</code> and <code class="literal">blue</code>, specifically <code class="literal">PutRGBBrightnessHandler.put(30, 128, 255)</code>.</p><p>Run the following HTTPie command in a computer or device to use the RESTful API to make the board set the brightness level for the three LEDs with the previously analyzed request path.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putrgbbrightness/r30g128b255</pre></div><p>After you <a id="id225" class="indexterm"/>enter the command, you will notice the SSH terminal that displays the output for the Python code will display the following three messages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Red LED connected to PWM Pin #6 set to brightness 30</strong></li><li class="listitem" style="list-style-type: disc"><strong>Green LED connected to PWM Pin #5 set to brightness 128</strong></li><li class="listitem" style="list-style-type: disc"><strong>Blue LED connected to PWM Pin #3 set to brightness 255</strong></li></ul></div><p>In addition, you will see the three LEDs turned on with their different brightness levels. The following lines show the response from the HTTP server with the brightness levels that have been set for the three LEDs:</p><div><pre class="programlisting">{
    "blue": 255, 
    "green": 128, 
    "red": 30
}</pre></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Using PWM plus a RESTful API to set colors for an RGB LED</h1></div></div></div><p>Now, we <a id="id226" class="indexterm"/>will use the same source code to make it possible to change the color of an RGB LED, specifically, a common cathode RGB LED. This electronic component provides a common cathode and three anodes, that is, an anode for each of the three colors: red, green and blue. We can use our code to pulse width modulate the three colors and make the LED produce the mixed colors. We don't need to use a black surface to see the intersection of the three colors because the RGB LED mixes the three colors for us.</p><p>The following image shows a common cathode RGB LED with one of the most common configurations for the pins, where the common cathode is the second pin and the longest one.</p><div><img src="img/B05042_04_07.jpg" alt="Using PWM plus a RESTful API to set colors for an RGB LED"/></div><p>The following table shows the pin configuration for the previous RGB LED, from left to right. However, always <a id="id227" class="indexterm"/>make sure that you check the datasheet for your RGB LED to check the right pins for the common cathode and the anode for each color.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Pin number</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>Anode pin for red LED</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>Common cathode pin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>Anode pin for green LED</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>Anode pin for blue LED</p>
</td></tr></tbody></table></div><p>Based on the previous table, we will connect the three anode pins to three of the digital I/O pins that we can use as <strong>PWM</strong> (short for <strong>Pulse Width Modulation</strong>) output pins. We will use the same PWM output pins that we used in our previous example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pin <strong>~6</strong> to connect the anode pin for red LED</li><li class="listitem" style="list-style-type: disc">Pin <strong>~5 </strong>to connect the anode pin for green LED</li><li class="listitem" style="list-style-type: disc">Pin <strong>~3</strong> to connect the anode pin for blue LED.</li></ul></div><p>After we finish the necessary wirings, we will use the same Python code to run our RESTful API and mix colors by changing the brightness levels for red, green and blue. We need the following parts to work with this example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One common cathode 5mm RGB LED </li><li class="listitem" style="list-style-type: disc">Three 270Ω resistors with 5% tolerance (red violet brown gold)</li></ul></div><p>The following diagram shows the components connected to the breadboard, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_python_chapter_04_03.fzz</code> and the following image is the breadboard view:</p><div><img src="img/B05042_04_08.jpg" alt="Using PWM plus a RESTful API to set colors for an RGB LED"/></div><p>The <a id="id228" class="indexterm"/>following image shows the schematic with the electronic components represented as symbols:</p><div><img src="img/B05042_04_09.jpg" alt="Using PWM plus a RESTful API to set colors for an RGB LED"/></div><p>As seen <a id="id229" class="indexterm"/>in the previous schematic, three PWM capable GPIO pins labeled <strong>D3 PWM</strong>, <strong>D5 PWM</strong> and <strong>D6 PWM</strong> in the board's symbol is connected to a <strong>270Ω</strong> resistor, wired to an anode pin for each LED color, and the common cathode is connected to ground.</p><p>Now, it is time to insert the components in the breadboard and make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p><p>After the board boots Yocto Linux, we have to start the HTTP server with our latest version of the RESTful API that allows us to control the brightness level for red, green and blue LEDs with a single API call.</p><div><pre class="programlisting">python iot_python_chapter_04_03.py</pre></div><p>Run the following HTTPie command in a computer or device to use the RESTful API to make the board set the brightness level for the colors included in the RGB LED.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putrgbbrightness/r255g255b0</pre></div><p>After you enter the command, you will notice the RGB LED displays a yellow light because we set both red and green to its maximum brightness level while we turned off the blue component. The following lines show the response from the HTTP server with the brightness levels that have been set for the three colors:</p><div><pre class="programlisting">{
    "blue": 0, 
    "green": 255, 
    "red": 255
}</pre></div><p>Now, run the following HTTPie command.</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putrgbbrightness/r255g0b128</pre></div><p>After you<a id="id230" class="indexterm"/> enter the command, you will notice the RGB LED displays a pink or light magenta light because we set green to its maximum brightness level and blue to half its maximum brightness level while we turned off the green component. The following lines show the response from the HTTP server with the brightness levels that have been set for the three colors:</p><div><pre class="programlisting">{
    "blue": 128, 
    "green": 0, 
    "red": 255
}</pre></div><p>Now, run the following HTTPie command:</p><div><pre class="programlisting">http -b PUT 192.168.1.107:8888/putrgbbrightness/r0g255b255</pre></div><p>After you enter the command, you will notice the RGB LED displays a cyan light because we set both green and blue to its maximum brightness level while we turned off the red component. The following lines show the response from the HTTP server with the brightness levels that have been set for the three colors:</p><div><pre class="programlisting">{
    "blue": 255, 
    "green": 255, 
    "red": 0
}</pre></div><p>We can generate 256 * 256 * 256 different colors, which is 16,777,216 colors (more than 16 million colors) for the light generated by the RGB LED. We just need to use our RESTful API and change the values for the red, green and blue components.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Controlling PWM with the wiring-x86 library</h1></div></div></div><p>So far, we<a id="id231" class="indexterm"/> have been using the <code class="literal">mraa</code> library to work with PWM and change the brightness level for the different LEDs and colors within an RGB LED. However, in the first chapter, we also installed the <code class="literal">wiring-x86</code> library. We can change just a few lines of our object-oriented code to replace the <code class="literal">mraa</code> library with the <code class="literal">wiring-x86</code> one to change the brightness levels for the red, green and blue components.</p><p>There is <a id="id232" class="indexterm"/>an important difference between the <code class="literal">mraa</code> library and the <code class="literal">wiring-x86</code> library when working with PWM. The former works with floating point values from 0.0f to 1.0f to set the output duty cycle percentage, but the latter works with values from 0 to 255 inclusive to set this value. Thus, when working with the <code class="literal">wiring-x86</code> library, we don't need to translate the desired brightness level to an output duty cycle percentage and we can use the brightness level value to specify the value for PWM. As a result, the code is simpler in this case.</p><p>The following lines shows the code for a <code class="literal">Board</code> class followed by the new version of the <code class="literal">AnalogLed</code> class that works with the <code class="literal">wiring-x86</code> library instead of using <code class="literal">mraa</code>. The code file for the sample is <code class="literal">iot_python_chapter_04_04.py</code>.</p><div><pre class="programlisting">from wiringx86 import GPIOGalileoGen2 as GPIO

class Board:
    gpio = GPIO(debug=False)


class AnalogLed:
    def __init__(self, pin, name):
        self.pin = pin
        self.name = name
<strong>        self.gpio = Board.gpio</strong>
<strong>        self.gpio.pinMode(pin, self.gpio.PWM)</strong>
        self.brightness_value = 0
        self.set_brightness(0)

    def set_brightness(self, value):
        brightness_value = value
        if brightness_value &gt; 255:
            brightness_value = 255
        elif brightness_value &lt; 0:
            brightness_value = 0
<strong>        self.gpio.analogWrite(self.pin, brightness_value)</strong>
        self.brightness_value = brightness_value
        print("{0} LED connected to PWM Pin #{1} set to brightness {2}.".format(self.name, self.pin, brightness_value))</pre></div><p>We just needed to change a few lines from the previous code of the <code class="literal">AnalogLed</code> class. The new lines that interact with the <code class="literal">wiring-x86</code> library are highlighted in the previous code. The constructor, that is, the <code class="literal">__init__</code> method, saves a reference to the <code class="literal">Board.gpio</code> class attribute in <code class="literal">self.gpio</code> and calls its <code class="literal">pinMode</code> method with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument and <code class="literal">self.gpio.PWM</code> as its <code class="literal">mode</code> argument. This way, we configure the pin to be an output PWM pin. All the <code class="literal">Led</code> instances will save a reference to<a id="id233" class="indexterm"/> the same <code class="literal">Board.gpio</code> class attribute that created an instance of the <code class="literal">GPIO</code> class, specifically, the <code class="literal">wiringx86.GPIOGalileoGen2</code> class with its <code class="literal">debug</code> argument set to <code class="literal">False</code> to avoid <a id="id234" class="indexterm"/>unnecessary debug information for the low-level communications.</p><p>The <code class="literal">set_brightness</code> method calls the <code class="literal">analogWrite</code> method for the GPIO instance (<code class="literal">self.gpio</code>) to set the output duty-cycle for the pin configured as PWM output to <code class="literal">brightness_value</code>. The <code class="literal">self.pin</code> attribute specifies the <code class="literal">pin</code> value for the <code class="literal">analogWrite</code> method call. Because <code class="literal">brightness_value</code> is already a value between 0 and 255 (inclusive), it is valid value for the <code class="literal">analogWrite</code> method.</p><p>The rest of the code for our RESTful API remains the same one that we have used for the previous example. There is no need to make changes to this class because it will automatically work with the new <code class="literal">AnalogLed</code> class and there were no changes in the arguments for its constructor or its <code class="literal">set_brightness</code> methods.</p><p>The following line will start the HTTP server and our new version of the RESTful API that works with the <code class="literal">wiring-x86</code> library. Don't forget that you need to transfer the Python source code file to the Yocto Linux with an SFTP client, as explained in the previous chapter.</p><div><pre class="programlisting">python iot_python_chapter_04_04.py</pre></div><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>We can make the same HTTP requests we made in our previous example to check that we can achieve exactly the same results with the <code class="literal">wiring-x86</code> library.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">PWM stands for:<div><ol class="orderedlist arabic"><li class="listitem">Pin Work Mode.</li><li class="listitem">Pulse Weight Modulation.</li><li class="listitem">Pulse Width Modulation.</li></ol></div></li><li class="listitem">In the Intel Galileo Gen 2 board, the pins labeled with the following symbol as a prefix for the number can be used as PWM output pins:<div><ol class="orderedlist arabic"><li class="listitem">Hash sign (<strong>#</strong>).</li><li class="listitem">Dollar sign (<strong>$</strong>).</li><li class="listitem">Tilde symbol (<strong>~</strong>).</li></ol></div></li><li class="listitem">A 100% duty cycle (always signal in the ON status) in a PWM pin will generate a steady voltage equal to:<div><ol class="orderedlist arabic"><li class="listitem">0 V.</li><li class="listitem">The voltage specified in the position in which the IOREF jumper is located.</li><li class="listitem">6 V.</li></ol></div></li><li class="listitem">A 0% duty cycle (always signal in the OFF status) in a PWM pin will generate a steady voltage equal to:<div><ol class="orderedlist arabic"><li class="listitem">0 V.</li><li class="listitem">The voltage specified in the position in which the IOREF jumper is located.</li><li class="listitem">6 V.</li></ol></div></li><li class="listitem">A 50% duty cycle in a PWM pin with a LED connected to it will generate the same result as a steady voltage equal to:<div><ol class="orderedlist arabic"><li class="listitem">0 V.</li><li class="listitem">Half the voltage specified in the position in which the IOREF jumper is located.</li><li class="listitem">6 V * 0.5 = 3 V.</li></ol></div></li></ol></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Summary</h1></div></div></div><p>In this chapter, we worked with Tornado web server, Python, the HTTPie command-line HTTP client, and the <code class="literal">mraa</code> and <code class="literal">wiring-x86</code> libraries. As in the previous chapters, we took advantage of Python's object-oriented features and we generated many versions of RESTful APIs that allowed us to interact with the board in computers and devices connected to the LAN.</p><p>We could compose and send HTTP requests that printed number in LEDs, changed the brightness levels for three LEDs and generated millions of colors with an RGB LED.</p><p>Now that we created our first RESTful APIs that made is possible for computers and devices to interact with our IoT device, we can take advantage of additional features that allow us to read digital inputs and analog values, which is the topic of the next chapter. </p></div></div>
</body></html>