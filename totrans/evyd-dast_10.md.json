["```py\n    public class HeapNode \n    { \n        public int Data; \n    } \n\n```", "```py\n    List<HeapNode> elements; \n    public int Count \n    { \n        get \n        { \n            return elements.Count; \n        } \n    } \n\n    public MinHeap() \n    { \n        elements = new List<HeapNode>(); \n    } \n\n```", "```py\n    public void Insert(HeapNode item) \n    { \n        elements.Add(item); \n        OrderHeap(); \n    } \n\n```", "```py\n    public void Delete(HeapNode item) \n    { \n        int i = elements.IndexOf(item); \n        int last = elements.Count - 1; \n\n        elements[i] = elements[last]; \n        elements.RemoveAt(last); \n        OrderHeap(); \n    } \n\n```", "```py\n    public HeapNode ExtractMin() \n    { \n        if (elements.Count > 0) \n        { \n            HeapNode item = elements[0]; \n            Delete(item); \n            return item; \n        } \n\n        return null; \n    } \n\n```", "```py\n    public HeapNode FindMin() \n    { \n        if (elements.Count > 0) \n        { \n            return elements[0]; \n        } \n\n        return null; \n    } \n\n```", "```py\n    private void OrderHeap() \n    { \n        for (int i = elements.Count - 1; i > 0; i--) \n        { \n            int parentPosition = (i - 1) / 2; \n\n            if (elements[parentPosition].Data > elements[i].Data) \n            { \n                SwapElements(parentPosition, i); \n            } \n        } \n    }   \n\n    private void SwapElements(int firstIndex, int secondIndex) \n    { \n        HeapNode tmp = elements[firstIndex]; \n        elements[firstIndex] = elements[secondIndex]; \n        elements[secondIndex] = tmp; \n    } \n\n```", "```py\n    public List<HeapNode> GetChildren(int parentIndex) \n    { \n        if (parentIndex >= 0) \n        { \n            List<HeapNode> children = new List<HeapNode>(); \n            int childIndexOne = (2 * parentIndex) + 1; \n            int childIndexTwo = (2 * parentIndex) + 2; \n            children.Add(elements[childIndexOne]); \n            children.Add(elements[childIndexTwo]); \n\n            return children; \n        } \n\n        return null; \n    } \n\n```", "```py\n    public HeapNode GetParent(int childIndex) \n    { \n        if (childIndex > 0 && elements.Count > childIndex) \n        { \n            int parentIndex = (childIndex - 1) / 2; \n            return elements[parentIndex]; \n        } \n\n        return null; \n    } \n\n```", "```py\n    List<HeapNode> elements; \n\n    public int size() \n    { \n        return elements.size(); \n    } \n\n    public MinHeap() \n    { \n        elements = new ArrayList<HeapNode>();  \n    } \n\n```", "```py\n    public void insert(HeapNode item) \n    { \n        elements.add(item); \n        orderHeap(); \n    } \n\n```", "```py\n    public void delete(HeapNode item) \n    { \n        int i = elements.indexOf(item); \n        int last = elements.size() - 1; \n\n        elements.set(i, elements.get(last)); \n        elements.remove(last); \n        orderHeap(); \n    } \n\n```", "```py\n    public HeapNode extractMin() \n    { \n        if (elements.size() > 0) \n        { \n            HeapNode item = elements.get(0); \n            delete(item); \n            return item; \n        } \n\n        return null; \n    } \n\n```", "```py\n    public HeapNode findMin() \n    { \n        if (elements.size() > 0) \n        { \n            return elements.get(0); \n        } \n\n        return null; \n    } \n\n```", "```py\n    private void orderHeap() \n    { \n        for (int i = elements.size() - 1; i > 0; i--) \n        { \n            int parentPosition = (i - 1) / 2; \n\n            if (elements.get(parentPosition).Data > elements.get(i).Data) \n            { \n                swapElements(parentPosition, i); \n            } \n        } \n    } \n\n    private void swapElements(int firstIndex, int secondIndex) \n    { \n        HeapNode tmp = elements.get(firstIndex); \n        elements.set(firstIndex, elements.get(secondIndex)); \n        elements.set(secondIndex, tmp); \n    } \n\n```", "```py\n    public List<HeapNode> getChildren(int parentIndex) \n    { \n        if (parentIndex >= 0) \n        { \n            ArrayList<HeapNode> children = new ArrayList<HeapNode>(); \n            int childIndexOne = (2 * parentIndex) + 1; \n            int childIndexTwo = (2 * parentIndex) + 2; \n            children.add(elements.get(childIndexOne)); \n            children.add(elements.get(childIndexTwo)); \n\n            return children; \n        } \n\n        return null; \n    } \n\n```", "```py\n    public HeapNode getParent(int childIndex) \n    { \n        if (childIndex > 0 && elements.size() > childIndex) \n        { \n            int parentIndex = (childIndex - 1) / 2; \n            return elements.get(parentIndex); \n        } \n\n        return null; \n    } \n\n```", "```py\n    @interface EDSMinHeap() \n    { \n        NSMutableArray<EDSHeapNode*> *_elements; \n    } \n\n    @implementation EDSMinHeap \n\n    -(instancetype)initMinHeap{ \n\n        if (self = [super init]) \n        { \n            _elements = [NSMutableArray array]; \n        } \n\n        return self; \n    } \n\n```", "```py\n    -(NSInteger)getCount \n    { \n        return [_elements count]; \n    } \n\n```", "```py\n    -(void)insert:(EDSHeapNode*)item \n    { \n        [_elements addObject:item]; \n        [self orderHeap]; \n    } \n\n```", "```py\n    -(void)delete:(EDSHeapNode*)item \n    { \n        long i = [_elements indexOfObject:item]; \n\n        _elements[i] = [_elements lastObject]; \n        [_elements removeLastObject]; \n        [self orderHeap]; \n    } \n\n```", "```py\n    -(EDSHeapNode*)extractMin \n    { \n        if ([_elements count] > 0) \n        { \n            EDSHeapNode *item = _elements[0]; \n            [self delete:item]; \n            return item; \n        } \n\n        return nil; \n    } \n\n```", "```py\n    -(EDSHeapNode*)findMin \n    { \n        if ([_elements count] > 0) \n        { \n            return _elements[0]; \n        } \n\n        return nil; \n    } \n\n```", "```py\n    -(void)orderHeap \n    { \n        for (long i = [_elements count] - 1; i > 0; i--) \n        { \n            long parentPosition = (i - 1) / 2; \n\n            if (_elements[parentPosition].data > _elements[i].data) \n            { \n                [self swapElement:parentPosition withElement:i]; \n            } \n        } \n    } \n\n    -(void)swapElement:(long)firstIndex withElement:(long)secondIndex \n    { \n        EDSHeapNode *tmp = _elements[firstIndex]; \n        _elements[firstIndex] = _elements[secondIndex]; \n        _elements[secondIndex] = tmp; \n    } \n\n```", "```py\n    -(NSArray<EDSHeapNode*>*)childrenOfParentIndex:(NSInteger)parentIndex \n    { \n        if (parentIndex >= 0) \n        { \n            NSMutableArray *children = [NSMutableArray array]; \n            long childIndexOne = (2 * parentIndex) + 1; \n            long childIndexTwo = (2 * parentIndex) + 2; \n            [children addObject:_elements[childIndexOne]]; \n            [children addObject:_elements[childIndexTwo]]; \n\n            return children; \n        } \n        return nil; \n    } \n\n```", "```py\n    -(EDSHeapNode*)parentOfChildIndex:(NSInteger)childIndex \n    { \n        if (childIndex > 0 && [_elements count] > childIndex) \n        { \n            long parentIndex = (childIndex - 1) / 2; \n            return _elements[parentIndex]; \n        } \n\n        return nil; \n    } \n\n```", "```py\n    public var _elements: Array = [HeapNode]() \n    public init () {} \n\n    public func getCount() -> Int \n    { \n        return _elements.count \n    } \n\n```", "```py\n    public func insert(item: HeapNode) \n    { \n        _elements.append(item) \n        orderHeap() \n    } \n\n```", "```py\n    public func delete(item: HeapNode) \n    { \n        if let index = _elements.index(of: item) \n        { \n            _elements[index] = _elements.last! \n            _elements.removeLast() \n            orderHeap() \n        } \n    } \n\n```", "```py\n    public func extractMin() -> HeapNode? \n    { \n        if (_elements.count > 0) \n        { \n            let item = _elements[0] \n            delete(item: item) \n            return item \n        } \n\n        return nil \n    } \n\n```", "```py\n    public func findMin() -> HeapNode? \n    { \n        if (_elements.count > 0) \n        { \n            return _elements[0] \n        } \n\n        return nil \n    } \n\n```", "```py\n    public func orderHeap() \n    { \n        for i in (0..<(_elements.count) - 1).reversed() \n        { \n            let parentPosition = (i - 1) / 2 \n\n            if (_elements[parentPosition].data! > _elements[i].data!) \n            { \n                swapElements(first: parentPosition, second: i) \n            } \n        } \n    } \n\n    public func swapElements(first: Int, second: Int) \n    { \n        let tmp = _elements[first] \n        _elements[first] = _elements[second] \n        _elements[second] = tmp \n    } \n\n```", "```py\n    public func getChildren(parentIndex: Int) -> [HeapNode]? \n    { \n        if (parentIndex >= 0) \n        { \n            var children: Array = [HeapNode]() \n\n            let childIndexOne = (2 * parentIndex) + 1; \n            let childIndexTwo = (2 * parentIndex) + 2; \n            children.append(_elements[childIndexOne]) \n            children.append(_elements[childIndexTwo]) \n\n            return children; \n        } \n\n        return nil; \n    } \n\n```", "```py\n    public func getParent(childIndex: Int) -> HeapNode? \n    { \n        if (childIndex > 0 && _elements.count > childIndex) \n        { \n            let parentIndex = (childIndex - 1) / 2; \n            return _elements[parentIndex]; \n        } \n\n        return nil; \n    } \n\n```"]