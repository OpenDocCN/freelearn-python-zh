- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a URDF for a Robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started with an intuitive introduction to TFs, or
    TransForms. You have seen that TFs are very important; they will be the backbone
    of almost any ROS application. We concluded by saying that in order to generate
    TFs for a robot, you need to create a **Unified Robot Description Format** (**URDF**)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, a URDF file will contain a description of all the elements of a robot.
    You will define each **link** (rigid part) of the robot. Then, to create relationships
    between the links, you will add some **joints**, which will be used to generate
    the TFs.
  prefs: []
  type: TYPE_NORMAL
- en: To write the content of a URDF, we will use XML. As you develop the URDF, you
    will be able to visualize it with RViz. This will be very helpful to see whether
    the links and joints/TFs are correct. We will also improve the URDF file and make
    it more dynamic with an additional tool named **Xacro**.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this chapter, we are going to start the project for *Part 3*, with the
    URDF for a robot. We will create a mobile base with two wheels. This will be the
    foundation for the next few chapters. You can find the finalized URDF files inside
    the **ch11** folder of the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
  prefs: []
  type: TYPE_NORMAL
- en: The hardest part about URDF is understanding how to assemble two links of a
    robot with a joint. Getting to do this without guidance is quite difficult because
    there are so many parameters and origins you can modify. I will explain the complete
    process, step by step, to make sure that you build something that works properly.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create your own URDF for almost
    any robot powered by ROS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a URDF with a link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of assembling links and joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a URDF for a mobile robot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the URDF with Xacro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a URDF with a link
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will dive directly in and create your first URDF. We will
    first create an XML file for the URDF. In this file, we will add a link, which
    will represent one rigid part of a robot, and visualize it in RViz. We will also
    explore the different types of shapes you can use—boxes, cylinders, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This will be a good first step, so you can get familiar with URDF and be ready
    to dive into the process of adding several links and joints together (in the next
    section).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by setting up our URDF file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a URDF file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A URDF file is simply an XML file with the **.****urdf** extension.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to keep things simple for this chapter, we will create a URDF file inside
    our home directory. In the next chapter, you will learn how to correctly package
    the URDF inside a ROS 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: How should you name the URDF file? You could choose any name; it doesn’t really
    matter. Usually, you will give it the name of your robot. If your robot’s name
    is **abc**, then you will create an **abc.urdf** file. Let’s use the name **my_robot**,
    as we previously did in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and create a new file in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then open this file with any text editor or IDE, for example, with
    VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the minimum code you have to write inside a URDF file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We first open the file with the **<?xml version="1.0"?>** line, to specify that
    this file is an XML file—we also give the XML version.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to open and close a **<robot>** tag. Everything you write in
    your URDF will be inside this tag. You also have to provide the name of the robot
    with the **name** argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is the minimum code for a URDF, but it will be useless if you don’t
    define at least one element. Let’s add a link inside this URDF.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now write your first link, which corresponds to one rigid part of a
    robot, and visualize it in RViz. With this, you will be able to see whether the
    link is correctly defined and modify it if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the XML code to add the link.
  prefs: []
  type: TYPE_NORMAL
- en: Basic code for a link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a visual element for a link, you can use existing shapes: boxes,
    cylinders, and spheres (we will also see later how to include a custom shape made
    from **Computer-Aided Design** (**CAD**) software).'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let’s imagine the main base of a robot, represented as a box.
    The box is 60 cm x 40 cm x 20 cm, or **0.6** m x **0.4** m x **0.2** m.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In ROS, only the metric system is used. Here are a few units that we will use
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Meters will be used for distances. If you have to specify 70 mm for example,
    you will write `0.07`.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Radians will be used for angles. 180 degrees corresponds to pi (about `3.14`)
    radians.'
  prefs: []
  type: TYPE_NORMAL
- en: '- Meters per second will be used for velocity instances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this first link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to define the **<link>** inside the **<robot>** tag. Also, although
    indentation is not a requirement in XML, the best practice is to add some indentation
    to get a more readable file. Here, I used four spaces for each indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the elements of this link. The **<link>** tag defines the link.
    All the properties for this link must be inside the tag. You also have to provide
    a **name** attribute for the link. As a convention, for the first link, we use
    **base_link**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside this tag, we have the **<visual>** tag. If you want to define
    a visual appearance for the link (rigid part), you can do so with this tag. Inside,
    you will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<geometry>`: This will define the shape of the link. Here, we use the `<box>`
    tag and provide the dimensions with the `size` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<origin>`: This tag is quite important, as it defines the origin of the visual
    relative to the origin of the link. We will come back to this later in this chapter
    and see how to avoid confusion. The origin contains six elements for translation
    and rotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The origin of rotation is written as `rpy`. This means *roll*, *pitch*, *yaw*.
    It’s the same as `x`, `y`, and `z`, but using different names. Roll, pitch, and
    yaw are quite frequently used for aviation. You just need to get used to it for
    URDF.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we first set all origins to **0**. For now, the only thing we
    have specified are the dimensions of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the URDF in RViz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have enough code to visualize the URDF in RViz. The goal here is to see the
    box in 3D and verify that everything is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing this is very important when you develop a URDF. I would recommend always
    doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the smallest modification (add or modify something)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visualize the URDF in RViz
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If correct, continue with the next feature; if not, go back, fix it, and check
    again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, how can we visualize the URDF in RViz?
  prefs: []
  type: TYPE_NORMAL
- en: 'Good news: we can reuse the **urdf_tutorial** package (installed in [*Chapter
    10*](B22403_10.xhtml#_idTextAnchor488)) and provide our own URDF instead of the
    example ones. This is great because we can easily test a URDF file outside of
    a ROS 2 workspace, and we don’t need to create any package yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and start the **display.launch.py** launch file, with the absolute
    path to your URDF file for the **model** argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will then see a box (red color by default) inside **RViz**. You will also
    have the **Joint State Publisher** window, empty, with no cursor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Visualization of your URDF in RViz](img/B22403_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Visualization of your URDF in RViz
  prefs: []
  type: TYPE_NORMAL
- en: If you go to **RobotModel** | **Links**, you will see the **base_link**. This
    is the link you have created; you can enable or disable the visual for that link.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate around the box in **RViz**. You will see that the visual (box) is centered
    around the link origin. You can leave it like this or decide to offset the visual
    relative to the frame. Let’s do this.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the origin of the visual
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The link we have created is perfectly fine. However, we will offset the visual
    a bit so that the origin is not centered in the middle of the box, but instead,
    at the bottom of the box.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t necessarily need to do this. Sometimes, leaving the visual centered
    on the link origin is what you need. We will see some examples to illustrate this
    when we create the URDF for the mobile base a bit later in this chapter. For now,
    let’s just assume we want to offset the visual.
  prefs: []
  type: TYPE_NORMAL
- en: To offset the visual, we will need to modify the **<origin>** tag inside the
    **<visual>** tag. In this **<origin>** tag, we have six elements for translation
    and rotation. We just want to move the visual up, so the only component we need
    to modify is the translation on the *Z*-axis (if you remember, with the right-hand
    rule, Z points up).
  prefs: []
  type: TYPE_NORMAL
- en: How much of an offset should we apply? As the box is currently centered on the
    link origin, we need to lift it up by half of its height.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the height as **0.2** m, so we need to offset the visual by
    **0.1** m.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify this line so that the z offset is **0.1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, and to visualize the change, stop RViz (press *Ctrl* + *C* on
    the terminal where you launched it with **urdf_tutorial**), and start it again.
    You can do this every time you modify the URDF.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should see the box sitting on the ground, which means that the offset
    for the visual was correctly applied.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The link origin is still the same; you only changed the visual relative to the
    link. This is an important distinction. If you feel confused, continue reading
    and everything will make sense after you see the full process with links and joints.
  prefs: []
  type: TYPE_NORMAL
- en: You have created your first link. Let’s now see what kind of shapes you can
    use, and what customization you can add to the links in your URDF.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the link visual
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A link is one rigid part of your robot. You could make it look like anything
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the different shapes you can give to your links, and how to change
    their color.
  prefs: []
  type: TYPE_NORMAL
- en: Different shapes for a link
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you saw with the first link you created, you will define the shape of the
    link inside the **<geometry>** tag sitting in the **<****visual>** tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of basic shapes you can use. For each one you will need
    to provide the dimensions with different attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<box>`: You need to add a `size` argument with three components: `x`, `y`,
    and `z`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<cylinder>`: You need to add two arguments, `radius` and `length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sphere>`: You need only one argument, `radius`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have just seen how to create a box in the previous code example. Here is
    an example of a cylinder of radius **0.2** m and length **0.5** m:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And an example for a sphere of radius **0.35** m:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On top of those basic shapes, you can also use custom meshes that you export
    from CAD software, such as SolidWorks, Blender, and so on. You can use STL and
    Collada files, with **.stl** and **.dae** extensions, respectively. Setting up
    those files is not complicated but requires you to properly package your application
    around the URDF, which is something we will see in [*Chapter 12*](B22403_12.xhtml#_idTextAnchor573).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are even some tools that allow you to generate the complete URDF (links,
    joints, meshes, and so on) for a robot, directly from the CAD software. Great,
    isn’t it? However, those tools are not always up to date or stable, and if you
    have an error, you could spend lots of time finding and fixing it. I recommend
    you write the URDF yourself and add the meshes one by one. You will end up with
    more control over what you’re doing, and fixing errors will take much less time.
  prefs: []
  type: TYPE_NORMAL
- en: With the three basic shapes (box, cylinder, sphere), you can already do quite
    a lot and design a complete robot. We don’t need more than that to get started,
    and we’ll use them for the mobile robot that we’ll create in this chapter. The
    link visuals have no effect on the TF generation, so this is not going to be a
    problem. Even when you start designing your own custom robot, you can start with
    basic shapes, and everything will work fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete reference with every tag and attribute you can add in
    a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.ros.org/urdf/XML/link](https://wiki.ros.org/urdf/XML/link)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now finish this section and see how to change the color of the link visual.
  prefs: []
  type: TYPE_NORMAL
- en: Link color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you look at the first link on RViz, you can see that the visual color is
    red. This will be the default color for any basic shape you create.
  prefs: []
  type: TYPE_NORMAL
- en: As we add more shapes and combine them, it could be nice to modify their color,
    so that we can have some contrast between the different links. Otherwise, it will
    be hard to differentiate them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To add a color to a link, you first need to create a **<material>** tag with
    a name. Then, you can use the color in your link visual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code to make the link green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the definition of the **<material>** tag is inside the **<robot>**
    tag, but outside of any **<link>** tag. In this new tag, you need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a name with the `name` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a color with the `<color>` tag and `rgba` attribute (red, green, blue,
    alpha). Each of the four values should be between `0` and `1`. To create a basic,
    not-so-bright green color, we set the red and blue to `0`, and green to `0.6`.
    You can keep the alpha (transparency) set to `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to define this tag once, and then you can use it in any **<visual>**
    tag, inside any link. The color will apply to the basic shape. It should also
    apply to STL files if you have imported custom meshes (Collada files already contain
    the color, so there’s no need for a **<****material>** tag).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using the `<material>` tag inside a link, make sure to place it inside
    the `<visual>` tag, but not inside `<geometry>`. The `<geometry>`, `<origin>`,
    and `<material>` tags should be direct children of the `<``visual>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Great, you can now create a link with different kinds of shapes and colors.
    This is a great start so you can represent any rigid part of your robot in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how to assemble different links together and thus create a complete
    robot model.
  prefs: []
  type: TYPE_NORMAL
- en: The process of assembling links and joints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a URDF file with one link, let’s add another link, and connect
    them with a joint. This joint will be used to generate a TF.
  prefs: []
  type: TYPE_NORMAL
- en: Properly assembling two links with a joint is the main problem anybody faces
    when learning URDF. There are several origins and axes you can modify, and getting
    two parts to be correctly placed between each other, with the correct movement,
    can be challenging.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will focus on that process, so it becomes easier for you.
    I have condensed it into five steps that you can follow in the order every time
    you add a new link.
  prefs: []
  type: TYPE_NORMAL
- en: After you get confident with the process, you will be able to create a URDF
    for any kind of robot. A complete robot model is just a sequence of links connected
    to each other. If you correctly understand how to do it for two links, adding
    twenty more links won’t be that difficult.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explore the different kinds of joints you can use in a URDF. To
    verify that everything works fine, we will use RViz, as well as the TF tree generated
    by the **tf2_tools** package.
  prefs: []
  type: TYPE_NORMAL
- en: This section is very important, and I recommend that you do not skip it. Also,
    feel free to come back to it later, whenever you have some doubts about how to
    connect two links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with the first step of the process: adding a second link
    to the URDF.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – adding a second link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we want to add a cylinder (radius: **0.1** m, length: **0.3**
    m) on top of the box. We will make this cylinder gray (to create a contrast with
    the green box), so, let’s first create another **<material>** tag with gray color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add this new tag just after the previous **<****material>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s add the link. Create another **<link>** tag inside the **<robot>**
    tag, with the specifications for the second link. You can place this link just
    after the **base_link**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can give any name for the link. Here, I specify **shoulder_link** because
    we will create the beginning of a robotic arm for this example. You could then
    have several parts: base, shoulder, arm, forearm, hand, and so on. The best practice
    is to give meaningful names to the links of your robot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we set all the origin elements to **0**. This is quite important
    and will be the first step of the process: you add a link, but you don’t modify
    the origin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to visualize the URDF in RViz (stop and start from the terminal),
    you will get an error. Among the logs, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You get this because all links in a URDF need to be related to each other with
    a parent/child relationship, as we saw in the previous chapter. Here, there is
    no explicit relationship, so ROS cannot know which one is the parent, and which
    one is the child.
  prefs: []
  type: TYPE_NORMAL
- en: We will define this relationship with a joint. This will also allow us to generate
    our first TF for the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – adding a joint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define how two links are connected, you need to add a joint. Here is the
    code you can write after the two **<link>** tags (and still inside the **<****robot>**
    tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a joint, you add a **<joint>** tag, which contains two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: You can choose whatever you want, as long as it makes sense. I usually
    combine the names of the two links I want to connect: `base_link` and `shoulder_link`
    become `base_shoulder_joint`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: We will come back to the different joint types you can use in *Step
    4*. For now, we set it as `fixed`, which means that the two links won’t move between
    each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the **<joint>** tag, you then have three more tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<parent>`: This is the parent link. You have to write the exact name of the
    link with the `link` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<child>`: You will write the exact name of the child link with the `link`
    attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<origin>`: This will define the origin of the child link relative to the origin
    of the parent link. Once again, we use `xyz` for translation and `rpy` for rotation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the second step of the process: you add a joint between the two links
    and define which one is the parent and which one is the child. For now, you leave
    all origin elements to **0**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code, you can start RViz again, and this time, as there is a relationship
    between the links, the URDF will be displayed. Here is what you will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Two links and one joint, with all origins set to 0](img/B22403_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Two links and one joint, with all origins set to 0
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we now have a box (**base_link**) and a cylinder (**shoulder_link**).
    As all origin elements are set to **0**, both link origins are at the same place.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, you can also validate that the TF you’ve created with the joint
    is correctly placed in the TF tree. With the **ros2 run tf2_tools view_frames**
    command, you can generate the TF tree. In the newly created PDF file, you will
    see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – TF tree to validate the relationship between the two links](img/B22403_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – TF tree to validate the relationship between the two links
  prefs: []
  type: TYPE_NORMAL
- en: We can validate that the relationship we have defined is correct. We now need
    to correctly place the **shoulder_link** relative to the **base_link**.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – fixing the joint origin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the step where most people get confused. If you look at the current
    code, we have three **<origin>** tags: one in each link and one in the joint.
    So, which origin do we need to modify?'
  prefs: []
  type: TYPE_NORMAL
- en: The classic error is to start to modify several random origins at once and try
    to find something that works by tinkering with the values. Even if that seems
    to work in the end, it will probably create more problems when you add other joints.
  prefs: []
  type: TYPE_NORMAL
- en: So, for this step, I emphasize that you have to follow the *exact* process I
    will describe, every time.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to modify the **<origin>** tag of the joint, so you
    get the frame of the child link correctly placed. This is what matters the most.
    You will first fix the joint origin, and then, and *only* then, fix the visual
    origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, expand **RobotModel** and **Links**, and uncheck the **shoulder_link**
    visual (at this stage, seeing the visual can cause confusion, so we disable it).
    Then, ask yourself this question: where should be the frame for the **shoulder_link**,
    relative to the frame of the **base_link**?'
  prefs: []
  type: TYPE_NORMAL
- en: We want the **shoulder_link** to be on top of the box, so we need to move the
    frame by the height of the box; here, that’s **0.2** m. There is no rotation needed
    for this joint, just a translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can now modify the **<origin>** tag inside the **<****joint>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Start RViz again, disable the visual for the **shoulder_link**, and check whether
    the frame is correctly placed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Setting the joint origin without the visual](img/B22403_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Setting the joint origin without the visual
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, it seems that the frame for the **shoulder_link** is in the right place:
    on top of the box.'
  prefs: []
  type: TYPE_NORMAL
- en: This origin is the most important; this is what will define the TF. In the end,
    TFs will be generated with all the joint origins in your URDF. The visual will
    not be taken into account (visuals will be used for inertial and collision properties
    in the Gazebo simulator).
  prefs: []
  type: TYPE_NORMAL
- en: We have our joint origin correctly set up. Now, let’s see how to specify the
    joint type, so we can define the movement between the two links.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – setting up the joint type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep things simple for the previous explanation, we have set the joint type
    as *fixed*, which means that the two links are not moving relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of joints you will create will be like this. For example, if you place
    a sensor (camera, lidar) on your robot, the sensor won’t move. You can create
    a link for the sensor, and then a fixed joint to connect this sensor to your robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for some rigid parts (an arm in a robotic arm, wheels, torso, and
    so on), you will need to specify that the child link is moving relative to its
    parent link. I will not describe all possible joint types, but the most common
    movements you will find in any robot will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed**: As previously mentioned, this is if you have two parts that are
    not moving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revolute**: A rotation with a minimum and maximum angle, for example, in
    robotic arms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous**: An infinite rotation, usually used for wheels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prismatic**: If you need to make a part of your robot slide (only translation,
    no rotation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the comp[lete reference for all joint types](http://wiki.ros.org/urdf/XML/joint)
    at [http://wiki.ros.org/urdf/XML/joint](http://wiki.ros.org/urdf/XML/joint). There,
    you can get all possible elements you can add in a **<joint>** tag. Most of them
    are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our example, let’s say that the shoulder link is rotating (with
    a minimum and maximum) on the *Z*-axis on top of the box. You can specify this
    with the **revolute** joint type. By doing this, you will also need to add an
    **<axis>** tag to specify the axis of rotation, and a **<limit>** tag for the
    minimum and maximum angle. Let’s modify the **<****base_shoulder_joint>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When choosing **revolute**, we first need to define which axis will be rotating.
    As we chose **z** (if you look at *Figure 11**.4*, we want to rotate around the
    blue axis), we write **"0 0 1"**, which means: no rotation on **x** and **y**,
    and a rotation on **z**.'
  prefs: []
  type: TYPE_NORMAL
- en: We set the revolution between -180 and +180 degrees (about **-3.14** and **3.14**
    radians). We also have to specify a value for the velocity and effort limits.
    Those two will usually be overridden by other ROS nodes. Set them to **100** by
    default; it won’t be important here.
  prefs: []
  type: TYPE_NORMAL
- en: With this joint, you have created a TF that defines the position of the **shoulder_link**
    relative to the **base_link**, and the movement between those two links.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can start RViz again (disable the visual), and you will find a cursor
    in the **Joint State Publisher** window. Move the cursor to make the **shoulder_link**
    rotate on top of the **base_link**. Once again, it’s all about making the frame
    correctly move. If the visual still doesn’t look right, don’t worry about it;
    this is what we will fix in the last step of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – fixing the visual origin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now fix the origin of the **shoulder_link** visual. Don’t modify the
    **base_link** origin, as it’s already correct. Here, we only modify the visual
    for the child link.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, you can enable the **shoulder_link** visual again on RViz and see
    that the frame is at the center of the cylinder. Thus, we need to offset the visual
    by half of the length of the cylinder, which means **0.15** m (half of **0.3**
    m).
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the **<origin>** tag inside the **<link>** tag of the **shoulder_link**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you start RViz again, you will then see that everything is correctly placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – The end of the process for fixing the origins](img/B22403_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – The end of the process for fixing the origins
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we want the cylinder to be placed on top of the frame. If you
    wanted the frame to be in the center of the cylinder, you would place the joint
    origin higher on the *Z*-axis, and then leave the visual origin as it is (I talk
    more about this later in this chapter, when we work on the wheels of the mobile
    robot).
  prefs: []
  type: TYPE_NORMAL
- en: The process is now finished. As it is very important, let’s now do a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – the process to follow every time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a URDF, you will first start with a link, usually named **base_link**.
    Then, for each link that you add, you will also add a joint, to connect this new
    link to an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the process to add a new link to your URDF:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `<link>` tag and set all origin elements to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `<joint>` tag. You have to specify a parent and child link. The parent
    link will be an existing link you’ve already created, and the child link is the
    new link you’ve just added. Set all origin elements to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the origin of the joint. Visualize the URDF in RViz, disable the visual
    for the new link, and figure out where the frame for the new link should be relative
    to its parent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the joint is associated with a movement, set the joint type. Depending on
    the type, you might have to set the axis of rotation/translation, some limits,
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the frame origin is correct, enable the visual in RViz and fix the visual
    origin for the link (only for the child link, not the parent link).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this is done, congratulations, you have successfully connected two links,
    and the joint will be used to generate a TF. You can repeat this process for each
    new link that you add to your URDF.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important things to remember are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only add one link and one joint at a time. Finish the process, then add another
    link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t modify the origin of the parent link or any link you’ve already created
    before. This is a sure way to start messing up with the URDF and spending hours
    on debugging. If you need to go back to a previous link, then disable all children,
    fix the link, and continue from there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One link can have several children, but only one parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After each modification, as small as it can be, always verify in RViz. Don’t
    try to modify several origin elements at the same time. Change one, validate it,
    then go to the next one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can verify that the relationship between all links is correct by printing
    the TF tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, this process is not that complicated. Following these steps to the
    letter will ensure that you build your URDF right the first time. Not only will
    you be sure about what you are doing but, it will save you lots of time in the
    long term, and your URDF will be cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the information we need to create a complete URDF for a robot.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a URDF for a mobile robot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen the complete process of adding links and joints in a URDF file.
    By repeating this process several times, you can create a complete model for any
    robot.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to use this process to create a mobile robot. We will then
    use this URDF as a base for the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: I will first show you the final robot model so you get an idea, and then we
    will build the URDF, step by step. You will get the specs for the robot as we
    build it. I encourage you to follow along and even write the code at the same
    time as you read the section. This is good practice for you to get more comfortable
    with URDF. As a reminder, you can find the complete code on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to achieve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing any code, it’s important to define what we want to achieve.
    The final result will look like this in RViz:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Final result for the mobile robot](img/B22403_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Final result for the mobile robot
  prefs: []
  type: TYPE_NORMAL
- en: We will start the URDF with the robot’s main structure (chassis), represented
    by a box. This box is the same as the one we have created with the **base_link**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will add two wheels, on each side of the chassis. Those two wheels
    will have a continuous rotation. Finally, for stability, we add a caster wheel
    (sphere) that will help the robot not fall forward when we simulate it in Gazebo.
    This caster wheel will be a fixed joint, and we won’t add any movement to it.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, at the end, we will also add another link named **base_footprint**
    (with no visual, we can consider it as a virtual link), which is the projection
    of the **base_link** on the ground. I will explain this further when we do it.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, go back to the **my_robot.urdf** file we have written previously,
    and keep the **base_link**. Remove the **shoulder_link** as well as the **base_shoulder_joint**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now add the two wheels to the side of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the wheels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add the wheels one by one, starting with the right wheel. Unless you’re
    an expert already, it’s important that you only add one link and one joint at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: Right wheel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add the right wheel, we will follow the five-step process we just described.
    Let’s name this link **right_wheel_link**. For the visual, we will use a cylinder,
    with a radius of **0.1** m and a length of **0.05** m. Here is the code for the
    link (*Step 1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As the wheel will be attached to the **base_link** (green color), we choose
    the gray color to make a contrast. As you can see, we set all origin elements
    to **0**. We will only come back to those elements at the end of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s add a joint between the base and the right wheel (*Step 2*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When you get more experienced, you can set the movement type when creating the
    joint, but let’s go step by step. For now, we set the type to **fixed**, so we
    can set the joint origin first, and then specify the type of movement. This will
    make things simpler and less prone to errors.
  prefs: []
  type: TYPE_NORMAL
- en: With this code, you can already visualize the URDF in RViz. Disable the **right_wheel_link**
    visual (**RobotModel** | **Links**) as we don’t need this for now, and it could
    make us confused when setting the joint origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the question is: where do we place the **right_wheel_link** frame relative
    to the **base_link** frame (*Step 3*)? Let’s see for each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-0.15` m offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-0.2`m (half of the width of the box). Then, later on, you would need to add
    an offset in the wheel visual, like we did for the `shoulder_link` in the previous
    example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you can add a small additional offset to the joint, so that the
    wheel would be outside of the box, and the visual would be centered around the
    frame. This second option is a good idea for wheels and some sensors—for example,
    when using a lidar, this is required to make the scan work properly. We then need
    to add `-0.2` m, and an additional `-0.025` m (half of the length of the wheel).
    The total offset is `-0.225`m.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z translation (blue axis)**: There is no need for any offset here, as we
    want the center of the wheel to be at the bottom of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have our three values for the translation. That’s all we need. You might
    think that we have to rotate the joint axis because the visual is not correctly
    orientated. However, this is one of the most common mistakes, and it’s where you
    could start to modify the wrong values to fix the wrong problem. As we saw in
    the process, we first fix the joint with the visual disabled, and then, and only
    then, we fix the visual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the **<origin>** tag inside the **<joint>** tag (again: not in
    the link, only in the joint):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, start RViz again, disable the visual for the wheel (this visual is still
    wrong, but not a problem), and you can see that the joint is placed a bit outside
    the box.
  prefs: []
  type: TYPE_NORMAL
- en: We can now easily add the movement (*Step 4*). As the wheel will continuously
    rotate (there is no minimum or maximum position), we choose the **continuous**
    type. We also need to specify the rotation axis. By looking at the robot model
    in RViz, we can see that we have to pick the *Y*-axis (the wheel should rotate
    around the green axis).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we modify the **<joint>** tag accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to specify a **<limit>** tag for **continuous**, as we did
    with the **revolute** type previously.
  prefs: []
  type: TYPE_NORMAL
- en: You can now start RViz again, disable the wheel visual, and move the new cursor
    named **base_right_wheel_link** on the **Joint State Publisher** window. You should
    see the joint correctly rotating around the base.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With the cursor, you will see a minimum of about `-3.14` and a maximum of about
    `3.14` (total of 360 degrees). Don’t worry about this, it’s just a graphical element.
    As the joint type is continuous, there will be no minimum or maximum position
    when we control it later on.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the joint. With this, the TF will be correctly generated. We can
    now finish the process and fix the visual for the link (*Step 5*). If you re-enable
    the wheel visual, you will see that it’s not correctly orientated. You would need
    to add a 90-degree rotation on the *X*-axis (around the red axis). This corresponds
    to pi/2, or about **1.57** radian (we will see later in this chapter how to use
    a precise value of pi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the **<origin>** tag for the **right_wheel_link**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Start RViz again, and now everything should be fine: the wheel visual will
    be correctly placed (just outside of the box) and with the right orientation.
    When you move the cursor for the joint, the wheel will turn correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: The right wheel was probably the most complicated part of this robot, but as
    you can see, if you follow the process in the order, there should be no problem.
    You can be sure that all values are correct, and that there is no error that will
    propagate onto the next links that you add.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now write the code for the left wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Left wheel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the left wheel is the same as the right wheel, but on the opposite side of
    the box, writing the code will be fairly straightforward. Here I won’t repeat
    the full process and will just show you the final **<link>** and **<****joint>**
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is the same code as for the **right_wheel_link**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the left wheel will be connected to the chassis, so the parent of the
    **left_wheel_link** will be **base_link**. Here is the code for the joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Everything is the same, except for the offset on the *Y*-axis. For the right
    wheel, we had to go on the negative side, but for the left wheel, we went on the
    positive side.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to check is that when you move the two cursors on the **Joint
    State Publisher** window on the positive side, both wheels are rotating in the
    same direction. If you have this, then your differential drive system is correctly
    designed.
  prefs: []
  type: TYPE_NORMAL
- en: We can now add the **caster wheel** for the stability of the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the caster wheel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we add physics and gravity later on in the Gazebo simulator, you can guess
    that the robot would fall on the front side, because it’s out of balance. To fix
    this, we will add what’s called a caster wheel. It’s the same principle as the
    wheels under a desk chair.
  prefs: []
  type: TYPE_NORMAL
- en: To make things simple, the caster wheel will be represented by a sphere (with
    a radius of **0.05** m). For the movement, even if the wheel is rotating, this
    is not a rotation we control with ROS. It is a passive rotation; thus, we will
    consider the joint as **fixed**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the link first (*Step 1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s nothing too complicated here. Now, the caster wheel will be connected
    to the chassis of the robot. Let’s add the joint (*Step 2*). To follow the process,
    we first set all origin elements to **0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Start RViz and disable the visual. From this, let’s see where to place the
    origin of the caster wheel relative to the origin of the base (*Step 3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`0.2` m.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0.05` as the radius so that the diameter of the caster wheel (0.1 m) corresponds
    to the radius of the wheel. Thus, in order for the wheels and caster wheels to
    be aligned on the ground, we need to offset the *Z*-axis by `-0.05` m. If you
    are not so sure about this, it’s simple: try some values and see the results in
    RViz.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no need to set any rotation for the joint, as we won’t move the caster
    wheel, and it’s a sphere. Let’s apply the offset in the **<origin>** tag of the
    **<****joint>** tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now the caster wheel will be correctly placed under the chassis, and you can
    verify that the bottoms of both wheels and caster wheel seem to be aligned. Here,
    there is no need to set a movement type (*Step 4*) nor to fix the visual (*Step
    5*).
  prefs: []
  type: TYPE_NORMAL
- en: The robot model is now finished. There is just one more thing we will do to
    better prepare the robot for the following.
  prefs: []
  type: TYPE_NORMAL
- en: Extra link – base footprint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The robot is correctly designed and will work fine when we add control to it.
    However, there is one improvement we can make.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the robot in RViz, the **base_link** frame is not at the same
    altitude (**z** offset) as the bottom of the three wheels. This is fine, but it
    would be nice to have the origin of the robot aligned with the ground where the
    robot will be.
  prefs: []
  type: TYPE_NORMAL
- en: Not only will it make the robot look better in RViz (although it’s not important),
    but it will also make things easier in the future. An example would be when you
    want to create a transformation from a docking station to a mobile robot, or from
    one robot to another one. Another example would be if you want to use the **Navigation
    2** stack. If all robot origins are on the ground, you can then work in 2D, which
    is easier to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, it’s quite common to add a virtual link named **base_footprint**,
    which will be the projection of the **base_link** on the ground. We say the link
    is *virtual* because it doesn’t contain any visuals; it’s just an additional frame
    we define in the space. Here is the code for the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this link is extremely simple, as we didn’t include any **<visual>**
    tag. For a link name, we usually start with the rigid part name and add the **_link**
    suffix. Here, we make an exception. You will find this **base_footprint** name
    in many URDF files for existing mobile robots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a new **fixed** joint, with the **base_footprint** as the parent,
    and the **base_link** as the child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We apply a **0.1** m offset on the *Z*-axis, which corresponds to the right
    and left wheels’ radius.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To organize all links and joints in a URDF, I usually write all the links first,
    followed by all the joints. You could also decide to alternate between links and
    joints. There is no right or wrong method; it’s a question of preference.
  prefs: []
  type: TYPE_NORMAL
- en: You can now visualize the final result on RViz. To get the correct view, click
    on **Global Options**, and in the **Fixed Frame** menu, choose **base_footprint**.
    You will see that the bottoms of the wheels, and the **base_footprint**, are aligned
    on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'While RViz is still running, you can print and visualize the TF tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Final TF tree for the mobile robot](img/B22403_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Final TF tree for the mobile robot
  prefs: []
  type: TYPE_NORMAL
- en: We are now done with the URDF. Before we finish this chapter, let’s explore
    Xacro, which will allow you to improve your URDF file and make it more scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the URDF with Xacro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The more complex your robot, the bigger the URDF. As you add more links and
    joints, you will end up having problems scaling your robot model. Also, what we
    have written so far is not so dynamic: all the values are hardcoded.'
  prefs: []
  type: TYPE_NORMAL
- en: Xacro is an additional ROS feature you can use to solve all those issues. We
    will now see how to make a URDF file compatible with Xacro, how to create variables
    and functions, and how to split your URDF into several files.
  prefs: []
  type: TYPE_NORMAL
- en: With Xacro, your URDF files will become more dynamic and scalable. All serious
    ROS 2 projects use Xacro, so it’s important to learn how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started with the setup.
  prefs: []
  type: TYPE_NORMAL
- en: Making a URDF file compatible with Xacro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by making sure our URDF file can use Xacro features. Before doing
    anything, let’s make sure that Xacro is installed (it should already be there
    with all the previous packages we installed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, to use Xacro in your URDF file, you need to make two changes.
  prefs: []
  type: TYPE_NORMAL
- en: First, change the file extension. The file is currently named **my_robot.urdf**.
    For Xacro, you will use the **.xacro** extension. A common practice is to use
    the **.urdf.xacro** extension for the main URDF file of your robot, so the file
    would be named **my_robot.urdf.xacro** (the important thing is to have **.xacro**
    at the end).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve changed the extension, open the file and modify the **<****robot>**
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**Every time you want to use Xacro in a URDF file, you will have to add this
    **xmlns:xacro** argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it for the setup. Now, to visualize the URDF in RViz, you will run the
    same command as before, with the new file name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now discover how to use variables with Xacro.
  prefs: []
  type: TYPE_NORMAL
- en: Xacro properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In programming, one of the first and most important things you learn is how
    to use variables. Variables do not exist in URDF, but you can use them with Xacro.
    Here, a variable is called a **property**.
  prefs: []
  type: TYPE_NORMAL
- en: With Xacro properties, we will be able to specify values such as dimensions
    at the beginning of the file and use those properties inside the **<link>** and
    **<joint>** tags. This way, values and computations are not hardcoded. It will
    make things less confusing and more readable. Plus, if we ever need to modify
    a dimension of the robot, we just need to modify one value at the beginning of
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it’s important to note that Xacro properties are considered constant variables.
    After you set their value, you won’t modify them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare and define a Xacro property, you will use the **<xacro:property>**
    tag and provide two arguments: **name** and **value**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s declare a few properties at the beginning of the file (inside the **<****robot>**
    tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Those are all the values we need for computing everything else in the URDF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to use a Xacro property, you simply have to write **${property_name}**.
    You can also do computations. For example, to multiply a value by 2.5, you will
    write **${property_name * 2.5}**. With this information, let’s modify the content
    inside the **base_link** to remove any hardcoded value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we specify the box size with only properties. The most interesting
    part is how we compute the visual offset on the *Z*-axis. Writing **${base_height
    / 2.0}** is much more explicit than just writing **0.1**. Not only is it more
    dynamic, but we also have a better idea of what this computation is about. Imagine
    coming back to this URDF in six months and trying to figure out why the offset
    value is **0.1**, without any context. With this property, there is no possible
    doubt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now modify the visual for the links of the right wheel and left wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Xacro property, or constant pi, is already defined. Instead of hardcoding
    an approximation of pi, you can just use it with `${pi}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is the code for the caster wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we didn’t define a **caster_wheel_radius** property. This is
    because the caster wheel radius needs to be proportional to the right and left
    wheel radius. It needs to be half of the value so that both wheels and caster
    wheels can touch the ground while making the robot stable. By using a Xacro property
    here, if we were to modify the wheel radius, then the caster wheel would automatically
    resize to make the robot stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now modified all the links; let’s change the values in the joint origins.
    For the **base_joint**, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The **base_right_wheel_joint** is a bit more complex. However, once again,
    by writing this, we will make the computation more readable and less prone to
    errors in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The **base_left_wheel_joint** will be the same, except that the sign on the
    *Y*-axis is positive. We finish with the **base_caster_wheel_joint**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All those changes in the code didn’t modify the robot model. When visualizing
    it in Rviz, it should look the same.
  prefs: []
  type: TYPE_NORMAL
- en: To test that everything worked, try modifying the values for some Xacro properties
    at the beginning of the file. The robot model in RViz will have different dimensions,
    but it should still make sense.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for Xacro properties. This concept is not that hard to understand
    and apply, especially if you’re already familiar with variables and constants.
    Let’s now switch to functions, or macros.
  prefs: []
  type: TYPE_NORMAL
- en: Xacro macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Xacro macro is the equivalent of a function in programming. With Xacro, a
    macro works like a template: it’s a piece of XML code that you can reuse with
    different values (parameters). A macro doesn’t return anything.'
  prefs: []
  type: TYPE_NORMAL
- en: Macros are quite useful when you have to duplicate a link or a joint several
    times. Imagine a robot with four cameras. You can create a macro for the camera
    link, and then call the macro instead of re-writing the same code four times.
  prefs: []
  type: TYPE_NORMAL
- en: With our robot model, we have almost the same code for the **right_wheel_link**
    and the **left_wheel_link**. The only difference is the name of the link. Let’s
    create a macro for those links.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a macro, you will use the **<xacro:macro>** tag and give a name as
    well as a list of **params**. You can specify zero, or as many parameters as you
    want—just separate them with a space. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code won’t do anything by itself. We need to call it, just like
    you would call a function. To call a macro, you will write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the **right_wheel_link** and the **left_wheel_link**, and write this
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The **"right"** value in the prefix parameter will be applied to the link name
    inside the macro, making the name **right_wheel_link**. The same thing applies
    for the left wheel.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, macros can help you reduce code duplication. In this example,
    the benefit is not as big, but if you need to duplicate some links or joints more
    than three times, then macros can be extremely useful. Also, if you are creating
    part of a URDF that will be used by other people, writing a macro can help them
    to easily integrate your code into theirs, and customize it with the different
    parameters they can give as input.
  prefs: []
  type: TYPE_NORMAL
- en: Xacro properties and macros will allow you to make one URDF file more dynamic.
    Let’s finish this section by seeing how to make a URDF even more scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Including a Xacro file in another file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to Xacro, you can split your URDF into several files.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful to separate different parts of your robot, for example, the main
    core base, and extra sensors that you add on top. If you combine two robots, for
    example, a robotic arm on top of a mobile robot, you can create one URDF for each
    robot and combine them into a third one. Another benefit is collaboration. Creating
    a macro inside one file that other developers can include will make it easier
    for them to work with your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our URDF, let’s split the file into three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`common_properties.xacro`: This will contain the material tags and other properties
    that could apply to any part of our robotics application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobile_base.xacro`: This file will contain the properties, macros, links,
    and joints that are specific to the mobile base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_robot.urdf.xacro`: In this main file, we include the two previous files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing this, we will make the URDF more dynamic and easier to modify in the
    future. If you want to combine several mobile bases or add other robots or sensors,
    you can create more Xacro files that you include into the main one (**my_robot.urdf.xacro**).
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the two additional files, and let’s see how to organize the code.
    Make sure to put all three files in the same directory. In the next chapter, we
    will install them properly inside a ROS 2 package, but for now, keep them all
    in the same place (it will make it easier to include the first two files into
    the third one, using the relative path).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with **common_properties.xacro**. Here is the first thing to write
    inside this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All Xacro files must have this code, with a **<robot>** tag containing the **xmlns:xacro**
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t add the `name` attribute in the `<robot>` tag. This attribute will only
    be added once in the main Xacro file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the **<robot>** tag, you can copy and paste the two **<material>**
    tags we have previously written. You can then remove those tags from **my_robot.urdf.xacro.**
  prefs: []
  type: TYPE_NORMAL
- en: In **mobile_base.xacro**, you will also start the file with the **<?xml>** and
    **<robot>** tags, like we did in **common_properties.xacro**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can copy and paste all the **<xacro:property>**, **<xacro:macro>**,
    **<link>**, and **<joint>** tags that are related to the mobile base, which are
    basically all the tags left.
  prefs: []
  type: TYPE_NORMAL
- en: In **my_robot.urdf.xacro**, we have nothing left, only the **<?xml>** tag and
    the **<robot>** tag that contains the **name** and **xmlns:xacro** attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include a Xacro file inside another file, you will write a **<xacro:include>**
    tag and provide the path to the file with the **filename** attribute. Here is
    the final content for **my_robot.urdf.xacro**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our URDF is now split into several files and uses Xacro properties and macros.
    With those modifications, we didn’t change anything about the robot model, but
    we made the URDF more dynamic and scalable, as well as easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, you can find the complete code—all URDF and Xacro files—for this
    chapter inside the **ch11** folder of the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you discovered the full process of writing a URDF for a robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'A URDF defines a robot model and contains two main things: links and joints.
    A link is a rigid part of a robot that does nothing on its own. A link can have
    a visual (simple shapes such as boxes, cylinders, spheres, or meshes exported
    from CAD software). You can see a robot as a collection of links put together.
    A joint defines the connection between two links. It specifies which link is the
    parent and which one is the child, as well as where the two links are connected,
    and how they move relative to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: You learned that what you write inside a joint will define a TF for the robot.
    In the end, with all the joints inside a URDF, you are creating a TF tree.
  prefs: []
  type: TYPE_NORMAL
- en: You also saw the complete process for adding a new link and joint on top of
    the previous ones. Make sure to follow this process every time. To help you develop
    and verify each step of the process, you learned that it’s a good idea to use
    tools such as RViz to visualize the robot model, and **tf2_tools** to see the
    TF tree.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned that you can also improve your URDF with Xacro. You can define
    some properties and macros, and even split a URDF into several files. This will
    be useful as your application scales and will make collaboration easier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a URDF for a robot is the first step, as mentioned in this chapter.
    This will allow you to generate the TFs, which are the backbone of any robot using
    ROS.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can create the URDF, let’s see how to start packaging our application,
    and discover what to start so we can properly generate the TFs (without using
    the **urdf_tutorial** package). This will be the focus of the next chapter.**
  prefs: []
  type: TYPE_NORMAL
