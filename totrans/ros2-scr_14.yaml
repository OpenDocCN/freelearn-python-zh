- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Creating a URDF for a Robot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为机器人创建URDF
- en: In the previous chapter, we started with an intuitive introduction to TFs, or
    TransForms. You have seen that TFs are very important; they will be the backbone
    of almost any ROS application. We concluded by saying that in order to generate
    TFs for a robot, you need to create a **Unified Robot Description Format** (**URDF**)
    file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从一个直观的介绍开始，介绍了TFs，或称为变换。您已经看到TFs非常重要；它们将是几乎所有ROS应用程序的骨干。我们总结说，为了为机器人生成TFs，您需要创建一个**统一机器人描述格式**（**URDF**）文件。
- en: Basically, a URDF file will contain a description of all the elements of a robot.
    You will define each **link** (rigid part) of the robot. Then, to create relationships
    between the links, you will add some **joints**, which will be used to generate
    the TFs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一个URDF文件将包含机器人所有元素的描述。您将定义机器人的每个**链接**（刚性部分）。然后，为了在链接之间建立关系，您将添加一些**关节**，这些关节将用于生成TFs。
- en: To write the content of a URDF, we will use XML. As you develop the URDF, you
    will be able to visualize it with RViz. This will be very helpful to see whether
    the links and joints/TFs are correct. We will also improve the URDF file and make
    it more dynamic with an additional tool named **Xacro**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写URDF的内容，我们将使用XML。随着您开发URDF，您将能够使用RViz可视化它。这将非常有帮助，以查看链接和关节/TFs是否正确。我们还将使用一个名为**Xacro**的额外工具改进URDF文件，使其更加动态。
- en: So, in this chapter, we are going to start the project for *Part 3*, with the
    URDF for a robot. We will create a mobile base with two wheels. This will be the
    foundation for the next few chapters. You can find the finalized URDF files inside
    the **ch11** folder of the book’s GitHub repository ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将从*第3部分*的项目开始，创建机器人的URDF。我们将创建一个带有两个轮子的移动底盘。这将是下一章的基础。您可以在本书GitHub仓库的**ch11**文件夹中找到最终的URDF文件（[https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))。
- en: The hardest part about URDF is understanding how to assemble two links of a
    robot with a joint. Getting to do this without guidance is quite difficult because
    there are so many parameters and origins you can modify. I will explain the complete
    process, step by step, to make sure that you build something that works properly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: URDF最难的部分是理解如何使用关节组装机器人的两个链接。在没有指导的情况下完成这项工作相当困难，因为您可以修改许多参数和原点。我将逐步解释整个过程，以确保您构建的东西能够正常工作。
- en: By the end of this chapter, you will be able to create your own URDF for almost
    any robot powered by ROS.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够为几乎任何由ROS驱动的机器人创建自己的URDF。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a URDF with a link
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用链接创建URDF
- en: The process of assembling links and joints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接和关节的组装过程
- en: Creating a URDF for a mobile robot
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动机器人创建URDF
- en: Improving the URDF with Xacro
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Xacro改进URDF
- en: Creating a URDF with a link
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用链接创建URDF
- en: In this section, you will dive directly in and create your first URDF. We will
    first create an XML file for the URDF. In this file, we will add a link, which
    will represent one rigid part of a robot, and visualize it in RViz. We will also
    explore the different types of shapes you can use—boxes, cylinders, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将直接创建您的第一个URDF。我们首先创建一个用于URDF的XML文件。在这个文件中，我们将添加一个链接，它将代表机器人的一个刚性部分，并在RViz中可视化它。我们还将探索您可以使用的不同类型的形状——盒子、圆柱体等。
- en: This will be a good first step, so you can get familiar with URDF and be ready
    to dive into the process of adding several links and joints together (in the next
    section).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个很好的第一步，这样您可以熟悉URDF并准备好深入到添加多个链接和关节的过程（在下一节中）。
- en: Let’s get started by setting up our URDF file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置我们的URDF文件开始。
- en: Setting up a URDF file
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置URDF文件
- en: A URDF file is simply an XML file with the **.****urdf** extension.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: URDF文件只是一个具有**.urdf**扩展名的XML文件。
- en: Now, to keep things simple for this chapter, we will create a URDF file inside
    our home directory. In the next chapter, you will learn how to correctly package
    the URDF inside a ROS 2 application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使本章的内容简单，我们将在我们的主目录中创建一个URDF文件。在下一章中，您将学习如何正确地将URDF打包到ROS 2应用程序中。
- en: How should you name the URDF file? You could choose any name; it doesn’t really
    matter. Usually, you will give it the name of your robot. If your robot’s name
    is **abc**, then you will create an **abc.urdf** file. Let’s use the name **my_robot**,
    as we previously did in this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应该如何命名URDF文件？您可以选择任何名称；实际上并不重要。通常，您会将其命名为您的机器人名称。如果您的机器人名称是**abc**，那么您将创建一个**abc.urdf**文件。让我们使用之前在这本书中使用的名称**my_robot**。
- en: 'Open a terminal and create a new file in your home directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并在您的家目录中创建一个新文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can then open this file with any text editor or IDE, for example, with
    VS Code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何文本编辑器或IDE打开此文件，例如，使用VS Code：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the minimum code you have to write inside a URDF file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您必须在URDF文件中编写的最小代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first open the file with the **<?xml version="1.0"?>** line, to specify that
    this file is an XML file—we also give the XML version.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用**<?xml version="1.0"?>**行打开文件，以指定此文件是一个XML文件——我们也给出了XML版本。
- en: Then, you need to open and close a **<robot>** tag. Everything you write in
    your URDF will be inside this tag. You also have to provide the name of the robot
    with the **name** argument.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要打开和关闭`**<robot>**`标签。您在URDF中编写的所有内容都必须在这个标签内。您还必须通过**name**参数提供机器人的名称。
- en: Now, this is the minimum code for a URDF, but it will be useless if you don’t
    define at least one element. Let’s add a link inside this URDF.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是URDF的最小代码，但如果您不至少定义一个元素，它将毫无用处。让我们在这个URDF中添加一个链接。
- en: Creating a link
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建链接
- en: You will now write your first link, which corresponds to one rigid part of a
    robot, and visualize it in RViz. With this, you will be able to see whether the
    link is correctly defined and modify it if necessary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将编写您的第一个链接，这对应于机器人的一个刚性部分，并在RViz中可视化它。通过这样做，您将能够看到链接是否正确定义，并在必要时进行修改。
- en: Let’s start with the XML code to add the link.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加链接的XML代码开始。
- en: Basic code for a link
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接的基本代码
- en: 'To create a visual element for a link, you can use existing shapes: boxes,
    cylinders, and spheres (we will also see later how to include a custom shape made
    from **Computer-Aided Design** (**CAD**) software).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要为链接创建一个视觉元素，您可以使用现有的形状：盒子、圆柱体和球体（我们稍后还将看到如何包含由**计算机辅助设计**（**CAD**）软件创建的自定义形状）。
- en: To get started, let’s imagine the main base of a robot, represented as a box.
    The box is 60 cm x 40 cm x 20 cm, or **0.6** m x **0.4** m x **0.2** m.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们想象机器人的主要基座，表示为一个盒子。这个盒子是60厘米 x 40厘米 x 20厘米，或**0.6**米 x **0.4**米 x **0.2**米。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In ROS, only the metric system is used. Here are a few units that we will use
    in this chapter:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROS中，只使用公制系统。以下是本章中我们将使用的一些单位：
- en: '- Meters will be used for distances. If you have to specify 70 mm for example,
    you will write `0.07`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '- 距离将使用米。如果您需要指定70毫米，例如，您将写`0.07`。'
- en: '- Radians will be used for angles. 180 degrees corresponds to pi (about `3.14`)
    radians.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '- 弧度将用于角度。180度对应于π（约`3.14`）弧度。'
- en: '- Meters per second will be used for velocity instances.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '- 每秒米数将用于速度实例。'
- en: 'Here is the code for this first link:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个链接的代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Make sure to define the **<link>** inside the **<robot>** tag. Also, although
    indentation is not a requirement in XML, the best practice is to add some indentation
    to get a more readable file. Here, I used four spaces for each indentation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`**<robot>**`标签内定义`**<link>**`。尽管在XML中缩进不是必需的，但最佳实践是添加一些缩进以获得更易读的文件。在这里，我使用了每个缩进四个空格。
- en: Let’s analyze the elements of this link. The **<link>** tag defines the link.
    All the properties for this link must be inside the tag. You also have to provide
    a **name** attribute for the link. As a convention, for the first link, we use
    **base_link**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个链接的元素。`**<link>**`标签定义了链接。此链接的所有属性都必须在标签内。您还必须为链接提供一个**name**属性。按照惯例，对于第一个链接，我们使用**base_link**。
- en: 'Then, inside this tag, we have the **<visual>** tag. If you want to define
    a visual appearance for the link (rigid part), you can do so with this tag. Inside,
    you will have the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在这个标签内部，我们有`**<visual>**`标签。如果您想为链接（刚性部分）定义视觉外观，可以使用此标签。在内部，您将有以下内容：
- en: '`<geometry>`: This will define the shape of the link. Here, we use the `<box>`
    tag and provide the dimensions with the `size` attribute.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<geometry>`: 这将定义链接的形状。在这里，我们使用`<box>`标签，并通过`size`属性提供尺寸。'
- en: '`<origin>`: This tag is quite important, as it defines the origin of the visual
    relative to the origin of the link. We will come back to this later in this chapter
    and see how to avoid confusion. The origin contains six elements for translation
    and rotation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<origin>`：这个标签非常重要，因为它定义了可视化相对于链接原点的原点。我们将在本章稍后回到这一点，并了解如何避免混淆。原点包含六个元素用于平移和旋转。'
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The origin of rotation is written as `rpy`. This means *roll*, *pitch*, *yaw*.
    It’s the same as `x`, `y`, and `z`, but using different names. Roll, pitch, and
    yaw are quite frequently used for aviation. You just need to get used to it for
    URDF.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转的原点以 `rpy` 表示。这意味着 *翻滚*，*俯仰*，*偏航*。它与 `x`，`y` 和 `z` 相同，但使用了不同的名称。翻滚，俯仰和偏航在航空中非常常用。你只需要习惯
    URDF 中的这种用法。
- en: As you can see, we first set all origins to **0**. For now, the only thing we
    have specified are the dimensions of the box.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先将所有原点设置为 **0**。现在，我们唯一指定的是盒子的尺寸。
- en: Visualizing the URDF in RViz
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 RViz 中可视化 URDF
- en: We have enough code to visualize the URDF in RViz. The goal here is to see the
    box in 3D and verify that everything is correct.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有足够的代码在 RViz 中可视化 URDF。这里的目的是在 3D 中看到盒子，并验证一切是否正确。
- en: 'Doing this is very important when you develop a URDF. I would recommend always
    doing the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 URDF 时这样做非常重要。我建议始终执行以下操作：
- en: Make the smallest modification (add or modify something)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行最小的修改（添加或修改某些内容）
- en: Visualize the URDF in RViz
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 RViz 中可视化 URDF
- en: If correct, continue with the next feature; if not, go back, fix it, and check
    again
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果正确，继续下一个功能；如果不正确，返回，修复它，并再次检查
- en: Now, how can we visualize the URDF in RViz?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何在 RViz 中可视化 URDF？
- en: 'Good news: we can reuse the **urdf_tutorial** package (installed in [*Chapter
    10*](B22403_10.xhtml#_idTextAnchor488)) and provide our own URDF instead of the
    example ones. This is great because we can easily test a URDF file outside of
    a ROS 2 workspace, and we don’t need to create any package yet.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息：我们可以重用 **urdf_tutorial** 包（在 [*第 10 章*](B22403_10.xhtml#_idTextAnchor488)
    中安装）并提供我们自己的 URDF 而不是示例 URDF。这很好，因为我们可以在 ROS 2 工作空间之外轻松测试 URDF 文件，而且我们目前不需要创建任何包。
- en: 'Open a terminal and start the **display.launch.py** launch file, with the absolute
    path to your URDF file for the **model** argument:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端并启动 **display.launch.py** 启动文件，为 **model** 参数提供 URDF 文件的绝对路径：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will then see a box (red color by default) inside **RViz**. You will also
    have the **Joint State Publisher** window, empty, with no cursor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到 **RViz** 内部的一个盒子（默认为红色）。你还将有一个空的 **Joint State Publisher** 窗口，没有光标。
- en: '![Figure 11.1 – Visualization of your URDF in RViz](img/B22403_11_1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 在 RViz 中的 URDF 可视化](img/B22403_11_1.jpg)'
- en: Figure 11.1 – Visualization of your URDF in RViz
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 在 RViz 中的 URDF 可视化
- en: If you go to **RobotModel** | **Links**, you will see the **base_link**. This
    is the link you have created; you can enable or disable the visual for that link.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 **RobotModel** | **链接**，你会看到 **基础链接**。这是你创建的链接；你可以为该链接启用或禁用可视化。
- en: Navigate around the box in **RViz**. You will see that the visual (box) is centered
    around the link origin. You can leave it like this or decide to offset the visual
    relative to the frame. Let’s do this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **RViz** 中绕着盒子导航。你会看到可视化（盒子）围绕链接原点居中。你可以保持这样，或者决定相对于框架偏移可视化。让我们这样做。
- en: Modifying the origin of the visual
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改可视化的原点
- en: The link we have created is perfectly fine. However, we will offset the visual
    a bit so that the origin is not centered in the middle of the box, but instead,
    at the bottom of the box.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的链接是完美的。然而，我们将稍微偏移可视化，以便原点不在盒子的中间，而是在盒子的底部。
- en: You don’t necessarily need to do this. Sometimes, leaving the visual centered
    on the link origin is what you need. We will see some examples to illustrate this
    when we create the URDF for the mobile base a bit later in this chapter. For now,
    let’s just assume we want to offset the visual.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要这样做。有时，将可视化中心对准链接原点就是你所需要的。当我们稍后在本章中创建移动基座的 URDF 时，我们将看到一些示例来说明这一点。现在，让我们假设我们想要偏移可视化。
- en: To offset the visual, we will need to modify the **<origin>** tag inside the
    **<visual>** tag. In this **<origin>** tag, we have six elements for translation
    and rotation. We just want to move the visual up, so the only component we need
    to modify is the translation on the *Z*-axis (if you remember, with the right-hand
    rule, Z points up).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整视觉效果，我们需要修改`<visual>`标签内的`<origin>`标签。在这个`<origin>`标签中，我们有六个元素用于平移和旋转。我们只想将视觉效果向上移动，因此我们只需要修改*Z*轴上的平移（如果您还记得，使用右手定则，Z轴向上）。
- en: How much of an offset should we apply? As the box is currently centered on the
    link origin, we need to lift it up by half of its height.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该应用多大的偏移量？由于盒子目前位于链接原点中心，我们需要将其向上抬起一半的高度。
- en: We have defined the height as **0.2** m, so we need to offset the visual by
    **0.1** m.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将高度定义为**0.2**米，因此我们需要将视觉效果偏移**0.1**米。
- en: 'Modify this line so that the z offset is **0.1**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 修改此行，使z偏移为**0.1**：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save the file, and to visualize the change, stop RViz (press *Ctrl* + *C* on
    the terminal where you launched it with **urdf_tutorial**), and start it again.
    You can do this every time you modify the URDF.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，为了可视化更改，停止RViz（在启动**urdf_tutorial**的终端上按*Ctrl* + *C*），然后再次启动。每次修改URDF时，您都可以这样做。
- en: Now, you should see the box sitting on the ground, which means that the offset
    for the visual was correctly applied.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到盒子坐在地面上，这意味着视觉效果的正确偏移已经应用。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The link origin is still the same; you only changed the visual relative to the
    link. This is an important distinction. If you feel confused, continue reading
    and everything will make sense after you see the full process with links and joints.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 链接的原点仍然是相同的；您只是改变了相对于链接的视觉效果。这是一个重要的区别。如果您感到困惑，请继续阅读，在您看到完整的链接和关节过程后，一切都会变得清晰。
- en: You have created your first link. Let’s now see what kind of shapes you can
    use, and what customization you can add to the links in your URDF.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了您的第一个链接。现在让我们看看您可以使用哪些形状，以及您可以在URDF中的链接上添加哪些自定义设置。
- en: Customizing the link visual
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义链接视觉效果
- en: A link is one rigid part of your robot. You could make it look like anything
    you want.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是您机器人的一个刚性部分。您可以使其看起来像任何您想要的样子。
- en: Let’s explore the different shapes you can give to your links, and how to change
    their color.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索您可以赋予链接的不同形状，以及如何更改它们的颜色。
- en: Different shapes for a link
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接的不同形状
- en: As you saw with the first link you created, you will define the shape of the
    link inside the **<geometry>** tag sitting in the **<****visual>** tag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在创建的第一个链接中看到的那样，您将在`<visual>`标签内的`<geometry>`标签中定义链接的形状。
- en: 'There are three types of basic shapes you can use. For each one you will need
    to provide the dimensions with different attributes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用三种基本形状。对于每一种形状，您都需要提供不同的属性来指定尺寸：
- en: '`<box>`: You need to add a `size` argument with three components: `x`, `y`,
    and `z`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<box>`: 您需要添加一个包含三个组件的`size`参数：`x`、`y`和`z`'
- en: '`<cylinder>`: You need to add two arguments, `radius` and `length`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<cylinder>`: 您需要添加两个参数，`radius`（半径）和`length`（长度）'
- en: '`<sphere>`: You need only one argument, `radius`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sphere>`: 您只需要一个参数，`radius`（半径）'
- en: 'We have just seen how to create a box in the previous code example. Here is
    an example of a cylinder of radius **0.2** m and length **0.5** m:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在之前的代码示例中看到了如何创建一个盒子。以下是一个半径为**0.2**米、长度为**0.5**米的圆柱体示例：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And an example for a sphere of radius **0.35** m:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个半径为**0.35**米的球体示例：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On top of those basic shapes, you can also use custom meshes that you export
    from CAD software, such as SolidWorks, Blender, and so on. You can use STL and
    Collada files, with **.stl** and **.dae** extensions, respectively. Setting up
    those files is not complicated but requires you to properly package your application
    around the URDF, which is something we will see in [*Chapter 12*](B22403_12.xhtml#_idTextAnchor573).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些基本形状之上，您还可以使用从CAD软件（如SolidWorks、Blender等）导出的自定义网格。您可以使用STL和Collada文件，分别具有**.stl**和**.dae**扩展名。设置这些文件并不复杂，但需要您正确地将应用程序打包在URDF周围，这是我们将在[*第12章*](B22403_12.xhtml#_idTextAnchor573)中看到的。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: There are even some tools that allow you to generate the complete URDF (links,
    joints, meshes, and so on) for a robot, directly from the CAD software. Great,
    isn’t it? However, those tools are not always up to date or stable, and if you
    have an error, you could spend lots of time finding and fixing it. I recommend
    you write the URDF yourself and add the meshes one by one. You will end up with
    more control over what you’re doing, and fixing errors will take much less time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有一些工具允许您直接从 CAD 软件中为机器人生成完整的 URDF（链接、关节、网格等）。太棒了，不是吗？然而，这些工具并不总是最新或稳定的，如果您遇到错误，您可能需要花费大量时间查找和修复它。我建议您自己编写
    URDF 并逐个添加网格。这样，您将对自己的操作有更多的控制，修复错误也将花费更少的时间。
- en: With the three basic shapes (box, cylinder, sphere), you can already do quite
    a lot and design a complete robot. We don’t need more than that to get started,
    and we’ll use them for the mobile robot that we’ll create in this chapter. The
    link visuals have no effect on the TF generation, so this is not going to be a
    problem. Even when you start designing your own custom robot, you can start with
    basic shapes, and everything will work fine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个基本形状（盒子、圆柱体、球体），您已经可以完成很多事情并设计一个完整的机器人。我们不需要更多东西来开始，我们将使用它们来创建本章中我们将创建的移动机器人。链接的可视化对
    TF 生成没有影响，所以这不会成为问题。即使您开始设计自己的定制机器人，您也可以从基本形状开始，一切都会顺利。
- en: 'Here is the complete reference with every tag and attribute you can add in
    a link:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是包含您可以在链接中添加的每个标签和属性的完整参考：
- en: '[https://wiki.ros.org/urdf/XML/link](https://wiki.ros.org/urdf/XML/link)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.ros.org/urdf/XML/link](https://wiki.ros.org/urdf/XML/link)'
- en: Let’s now finish this section and see how to change the color of the link visual.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来完成这个部分，看看如何更改链接可视化的颜色。
- en: Link color
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接颜色
- en: If you look at the first link on RViz, you can see that the visual color is
    red. This will be the default color for any basic shape you create.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 RViz 上的第一个链接，您可以看到其可视化颜色为红色。这将是您创建的任何基本形状的默认颜色。
- en: As we add more shapes and combine them, it could be nice to modify their color,
    so that we can have some contrast between the different links. Otherwise, it will
    be hard to differentiate them on the screen.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们添加更多形状并将它们组合起来，修改它们的颜色可能是个不错的选择，这样我们可以在不同的链接之间获得一些对比度。否则，在屏幕上区分它们将很困难。
- en: To add a color to a link, you first need to create a **<material>** tag with
    a name. Then, you can use the color in your link visual.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要为链接添加颜色，您首先需要创建一个名为 `<material>` 的标签。然后，您可以在链接的可视化中使用该颜色。
- en: 'Here is the complete code to make the link green:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使链接变绿的完整代码：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Make sure the definition of the **<material>** tag is inside the **<robot>**
    tag, but outside of any **<link>** tag. In this new tag, you need to do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 确保定义 `<material>` 标签的内容位于 `<robot>` 标签内，但不在任何 `<link>` 标签内。在这个新标签中，您需要执行以下操作：
- en: Define a name with the `name` attribute.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `name` 属性定义一个名称。
- en: Define a color with the `<color>` tag and `rgba` attribute (red, green, blue,
    alpha). Each of the four values should be between `0` and `1`. To create a basic,
    not-so-bright green color, we set the red and blue to `0`, and green to `0.6`.
    You can keep the alpha (transparency) set to `1`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<color>` 标签和 `rgba` 属性（红色、绿色、蓝色、透明度）定义颜色。这四个值应在 `0` 和 `1` 之间。要创建一个基本、不太明亮的绿色，我们将红色和蓝色设置为
    `0`，绿色设置为 `0.6`。您可以保持透明度（不透明度）设置为 `1`。
- en: You only need to define this tag once, and then you can use it in any **<visual>**
    tag, inside any link. The color will apply to the basic shape. It should also
    apply to STL files if you have imported custom meshes (Collada files already contain
    the color, so there’s no need for a **<****material>** tag).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要定义此标签一次，然后您可以在任何 `<visual>` 标签中使用它，无论在哪个链接中。颜色将应用于基本形状。如果已导入自定义网格（Collada
    文件已包含颜色，因此不需要 `<material>` 标签），它也应应用于 STL 文件。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `<material>` tag inside a link, make sure to place it inside
    the `<visual>` tag, but not inside `<geometry>`. The `<geometry>`, `<origin>`,
    and `<material>` tags should be direct children of the `<``visual>` tag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当在链接中使用 `<material>` 标签时，请确保将其放置在 `<visual>` 标签内，但不要放在 `<geometry>` 标签内。《geometry`、`origin`
    和 `material` 标签应该是 `<visual>` 标签的直接子标签。
- en: Great, you can now create a link with different kinds of shapes and colors.
    This is a great start so you can represent any rigid part of your robot in 3D.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，您现在可以创建具有不同形状和颜色的链接。这是一个很好的开始，这样您就可以在 3D 中表示机器人中的任何刚性部件。
- en: Let’s now see how to assemble different links together and thus create a complete
    robot model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何组装不同的链接，从而创建一个完整的机器人模型。
- en: The process of assembling links and joints
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装连杆和关节的过程
- en: Now that you have a URDF file with one link, let’s add another link, and connect
    them with a joint. This joint will be used to generate a TF.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个包含一个连杆的URDF文件，让我们添加另一个连杆，并通过关节将它们连接起来。这个关节将用于生成一个TF。
- en: Properly assembling two links with a joint is the main problem anybody faces
    when learning URDF. There are several origins and axes you can modify, and getting
    two parts to be correctly placed between each other, with the correct movement,
    can be challenging.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正确组装两个连杆并使用关节是任何人在学习URDF时面临的主要问题。你可以修改几个原点和轴，使两个部分正确地放置在彼此之间，并具有正确的运动，这可能具有挑战性。
- en: In this section, we will focus on that process, so it becomes easier for you.
    I have condensed it into five steps that you can follow in the order every time
    you add a new link.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于这个过程，以便它对你来说更容易。我已经将其简化为五个步骤，每次添加新连杆时你都可以按照这个顺序进行。
- en: After you get confident with the process, you will be able to create a URDF
    for any kind of robot. A complete robot model is just a sequence of links connected
    to each other. If you correctly understand how to do it for two links, adding
    twenty more links won’t be that difficult.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对这个过程有信心之后，你将能够为任何类型的机器人创建URDF。一个完整的机器人模型只是连接到彼此的一系列连杆。如果你正确理解了如何为两个连杆操作，添加二十个更多的连杆就不会那么困难了。
- en: We will also explore the different kinds of joints you can use in a URDF. To
    verify that everything works fine, we will use RViz, as well as the TF tree generated
    by the **tf2_tools** package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探索在URDF中可以使用的不同类型的关节。为了验证一切正常，我们将使用RViz以及由**tf2_tools**包生成的TF树。
- en: This section is very important, and I recommend that you do not skip it. Also,
    feel free to come back to it later, whenever you have some doubts about how to
    connect two links.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分非常重要，我建议你不要跳过它。同时，如果你对如何连接两个连杆有疑问，随时可以回来查看。
- en: 'Let’s get started with the first step of the process: adding a second link
    to the URDF.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这个过程的第1步：向URDF中添加第二个连杆。
- en: Step 1 – adding a second link
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 – 添加第二个连杆
- en: 'For this example, we want to add a cylinder (radius: **0.1** m, length: **0.3**
    m) on top of the box. We will make this cylinder gray (to create a contrast with
    the green box), so, let’s first create another **<material>** tag with gray color.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们想在盒子上方添加一个圆柱体（半径：**0.1** 米，长度：**0.3** 米）。我们将把这个圆柱体设置为灰色（以与绿色盒子形成对比），因此，让我们首先创建另一个带有灰色颜色的**<material>**标签。
- en: 'You can add this new tag just after the previous **<****material>** tag:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在之前的**<material>**标签之后添加这个新标签：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, let’s add the link. Create another **<link>** tag inside the **<robot>**
    tag, with the specifications for the second link. You can place this link just
    after the **base_link**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加连杆。在**<robot>**标签内创建另一个**<link>**标签，并指定第二个连杆的规格。你可以把这个连杆放在**base_link**之后：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can give any name for the link. Here, I specify **shoulder_link** because
    we will create the beginning of a robotic arm for this example. You could then
    have several parts: base, shoulder, arm, forearm, hand, and so on. The best practice
    is to give meaningful names to the links of your robot.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为连杆命名任何名称。在这里，我指定为**shoulder_link**，因为我们将在本例中创建机器人手臂的起始部分。你还可以有多个部分：基础、肩部、手臂、前臂、手等等。最佳实践是为你的机器人连杆命名具有意义的名称。
- en: 'As you can see, we set all the origin elements to **0**. This is quite important
    and will be the first step of the process: you add a link, but you don’t modify
    the origin.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将所有原点元素设置为**0**。这非常重要，将是这个过程的第一步：你添加一个连杆，但不要修改原点。
- en: 'Now, if you try to visualize the URDF in RViz (stop and start from the terminal),
    you will get an error. Among the logs, you will see this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试在RViz中可视化URDF（从终端停止并重新启动），你会得到一个错误。在日志中，你会看到这个：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You get this because all links in a URDF need to be related to each other with
    a parent/child relationship, as we saw in the previous chapter. Here, there is
    no explicit relationship, so ROS cannot know which one is the parent, and which
    one is the child.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到这个结果，因为URDF中的所有连杆都需要通过父/子关系相互关联，正如我们在上一章中看到的。在这里，没有明确的关系，所以ROS无法知道哪个是父节点，哪个是子节点。
- en: We will define this relationship with a joint. This will also allow us to generate
    our first TF for the robot.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过关节来定义这种关系。这也会使我们能够为机器人生成第一个TF。
- en: Step 2 – adding a joint
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 – 添加关节
- en: 'To define how two links are connected, you need to add a joint. Here is the
    code you can write after the two **<link>** tags (and still inside the **<****robot>**
    tag):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义两个链接如何连接，你需要添加一个关节。以下是你在两个`<link>`标签之后（并且仍然在`<robot>`标签内）可以写入的代码：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To create a joint, you add a **<joint>** tag, which contains two attributes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个关节，你添加一个`<joint>`标签，它包含两个属性：
- en: '`name`: You can choose whatever you want, as long as it makes sense. I usually
    combine the names of the two links I want to connect: `base_link` and `shoulder_link`
    become `base_shoulder_joint`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：你可以选择任何你想要的，只要它有意义。我通常将我想连接的两个链接的名称组合起来：`base_link`和`shoulder_link`变成`base_shoulder_joint`。'
- en: '`type`: We will come back to the different joint types you can use in *Step
    4*. For now, we set it as `fixed`, which means that the two links won’t move between
    each other.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：我们将在第4步中回到你可以使用的不同关节类型。目前，我们将它设置为`fixed`，这意味着两个链接之间不会移动。'
- en: 'Inside the **<joint>** tag, you then have three more tags:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<joint>`标签内，你还有三个更多的标签：
- en: '`<parent>`: This is the parent link. You have to write the exact name of the
    link with the `link` attribute.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<parent>`：这是父链接。你必须使用`link`属性写出链接的确切名称。'
- en: '`<child>`: You will write the exact name of the child link with the `link`
    attribute.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<child>`：你将使用`link`属性写出子链接的确切名称。'
- en: '`<origin>`: This will define the origin of the child link relative to the origin
    of the parent link. Once again, we use `xyz` for translation and `rpy` for rotation.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<origin>`：这将定义子链接相对于父链接原点的原点。再次强调，我们使用`xyz`进行平移，使用`rpy`进行旋转。'
- en: 'This is the second step of the process: you add a joint between the two links
    and define which one is the parent and which one is the child. For now, you leave
    all origin elements to **0**.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是过程的第二步：你在两个链接之间添加一个关节，并定义哪个是父链接，哪个是子链接。目前，你将所有原点元素都设置为**0**。
- en: 'With this code, you can start RViz again, and this time, as there is a relationship
    between the links, the URDF will be displayed. Here is what you will get:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你可以再次启动RViz，这次，由于链接之间存在关系，URDF将会显示。以下是你会得到的结果：
- en: '![Figure 11.2 – Two links and one joint, with all origins set to 0](img/B22403_11_2.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 两个链接和一个关节，所有原点都设置为0](img/B22403_11_2.jpg)'
- en: Figure 11.2 – Two links and one joint, with all origins set to 0
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 两个链接和一个关节，所有原点都设置为0
- en: As you can see, we now have a box (**base_link**) and a cylinder (**shoulder_link**).
    As all origin elements are set to **0**, both link origins are at the same place.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在有一个盒子（**base_link**）和一个圆柱体（**shoulder_link**）。由于所有原点元素都设置为**0**，两个链接的原点都在同一个位置。
- en: 'On top of that, you can also validate that the TF you’ve created with the joint
    is correctly placed in the TF tree. With the **ros2 run tf2_tools view_frames**
    command, you can generate the TF tree. In the newly created PDF file, you will
    see this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以验证你用关节创建的TF是否正确地放置在TF树中。使用`ros2 run tf2_tools view_frames`命令，你可以生成TF树。在新创建的PDF文件中，你会看到这个：
- en: '![Figure 11.3 – TF tree to validate the relationship between the two links](img/B22403_11_3.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 验证两个链接之间关系的TF树](img/B22403_11_3.jpg)'
- en: Figure 11.3 – TF tree to validate the relationship between the two links
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 验证两个链接之间关系的TF树
- en: We can validate that the relationship we have defined is correct. We now need
    to correctly place the **shoulder_link** relative to the **base_link**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证我们定义的关系是否正确。现在我们需要正确地将**shoulder_link**相对于**base_link**放置。
- en: Step 3 – fixing the joint origin
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 – 调整关节原点
- en: 'This is the step where most people get confused. If you look at the current
    code, we have three **<origin>** tags: one in each link and one in the joint.
    So, which origin do we need to modify?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数人感到困惑的步骤。如果你查看当前的代码，我们有三个`<origin>`标签：每个链接中一个，一个在关节中。那么，我们需要修改哪个原点？
- en: The classic error is to start to modify several random origins at once and try
    to find something that works by tinkering with the values. Even if that seems
    to work in the end, it will probably create more problems when you add other joints.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的错误是同时修改几个随机的起点，并通过调整值来尝试找到可以工作的情况。即使最终看起来似乎可行，但在添加其他关节时可能会产生更多问题。
- en: So, for this step, I emphasize that you have to follow the *exact* process I
    will describe, every time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这一步，我强调你必须每次都遵循我将要描述的*精确*过程。
- en: The first thing to do is to modify the **<origin>** tag of the joint, so you
    get the frame of the child link correctly placed. This is what matters the most.
    You will first fix the joint origin, and then, and *only* then, fix the visual
    origin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是修改关节的**<origin>**标签，以便正确放置子连接的框架。这是最重要的。你将首先固定关节原点，然后，并且*仅*然后，固定视觉原点。
- en: 'For this, expand **RobotModel** and **Links**, and uncheck the **shoulder_link**
    visual (at this stage, seeing the visual can cause confusion, so we disable it).
    Then, ask yourself this question: where should be the frame for the **shoulder_link**,
    relative to the frame of the **base_link**?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，展开**RobotModel**和**Links**，并取消选择**shoulder_link**的视觉（在这个阶段，看到视觉可能会造成混淆，所以我们禁用它）。然后，问问自己这个问题：**shoulder_link**的框架相对于**base_link**的框架应该在哪个位置？
- en: We want the **shoulder_link** to be on top of the box, so we need to move the
    frame by the height of the box; here, that’s **0.2** m. There is no rotation needed
    for this joint, just a translation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望**shoulder_link**位于盒子的顶部，因此我们需要将框架移动到盒子的高度；这里，那是**0.2**米。这个关节不需要旋转，只需要平移。
- en: 'So, you can now modify the **<origin>** tag inside the **<****joint>** tag:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你现在可以修改**<joint>**标签内的**<origin>**标签：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Start RViz again, disable the visual for the **shoulder_link**, and check whether
    the frame is correctly placed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动RViz，禁用**shoulder_link**的视觉，并检查框架是否放置正确。
- en: '![Figure 11.4 – Setting the joint origin without the visual](img/B22403_11_4.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4 – 不使用视觉设置关节原点](img/B22403_11_4.jpg)'
- en: Figure 11.4 – Setting the joint origin without the visual
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 不使用视觉设置关节原点
- en: 'Great, it seems that the frame for the **shoulder_link** is in the right place:
    on top of the box.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，看起来**shoulder_link**的框架在正确的位置：在盒子的顶部。
- en: This origin is the most important; this is what will define the TF. In the end,
    TFs will be generated with all the joint origins in your URDF. The visual will
    not be taken into account (visuals will be used for inertial and collision properties
    in the Gazebo simulator).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原点是至关重要的；这将定义TF。最终，TFs将使用你的URDF中的所有关节原点生成。视觉将不被考虑（在Gazebo模拟器中，视觉将用于惯性和碰撞属性）。
- en: We have our joint origin correctly set up. Now, let’s see how to specify the
    joint type, so we can define the movement between the two links.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经正确设置了关节原点。现在，让我们看看如何指定关节类型，这样我们就可以定义两个连接之间的运动。
- en: Step 4 – setting up the joint type
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 – 设置关节类型
- en: To keep things simple for the previous explanation, we have set the joint type
    as *fixed*, which means that the two links are not moving relative to each other.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的解释简单，我们将关节类型设置为*固定*，这意味着两个连接相对于彼此不移动。
- en: Lots of joints you will create will be like this. For example, if you place
    a sensor (camera, lidar) on your robot, the sensor won’t move. You can create
    a link for the sensor, and then a fixed joint to connect this sensor to your robot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建的许多关节将类似于这种情况。例如，如果你在你的机器人上放置一个传感器（摄像头、激光雷达），该传感器不会移动。你可以为传感器创建一个连接，然后创建一个固定关节将这个传感器连接到你的机器人上。
- en: 'However, for some rigid parts (an arm in a robotic arm, wheels, torso, and
    so on), you will need to specify that the child link is moving relative to its
    parent link. I will not describe all possible joint types, but the most common
    movements you will find in any robot will be as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于一些刚性部件（机器人臂中的手臂、轮子、躯干等），你需要指定子连接相对于父连接是移动的。我不会描述所有可能的关节类型，但在任何机器人中你都会找到以下最常见的运动：
- en: '**Fixed**: As previously mentioned, this is if you have two parts that are
    not moving'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定**：如前所述，这是如果你有两个不移动的部分'
- en: '**Revolute**: A rotation with a minimum and maximum angle, for example, in
    robotic arms'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**：具有最小和最大角度的旋转，例如在机器人臂中'
- en: '**Continuous**: An infinite rotation, usually used for wheels'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续**：无限旋转，通常用于轮子'
- en: '**Prismatic**: If you need to make a part of your robot slide (only translation,
    no rotation)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动**：如果你需要使机器人的某个部分滑动（只有平移，没有旋转）'
- en: You can find the comp[lete reference for all joint types](http://wiki.ros.org/urdf/XML/joint)
    at [http://wiki.ros.org/urdf/XML/joint](http://wiki.ros.org/urdf/XML/joint). There,
    you can get all possible elements you can add in a **<joint>** tag. Most of them
    are optional.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://wiki.ros.org/urdf/XML/joint](http://wiki.ros.org/urdf/XML/joint)找到所有关节类型的完整参考。在那里，你可以获取所有可以在**<joint>**标签中添加的元素。其中大部分是可选的。
- en: 'Coming back to our example, let’s say that the shoulder link is rotating (with
    a minimum and maximum) on the *Z*-axis on top of the box. You can specify this
    with the **revolute** joint type. By doing this, you will also need to add an
    **<axis>** tag to specify the axis of rotation, and a **<limit>** tag for the
    minimum and maximum angle. Let’s modify the **<****base_shoulder_joint>** tag:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，假设肩部链接在盒子上方的*Z*-轴上旋转（有一个最小值和最大值）。你可以使用**revolute**关节类型来指定这一点。通过这样做，你还需要添加一个**<axis>**标签来指定旋转轴，以及一个**<limit>**标签来指定最小和最大角度。让我们修改**<****base_shoulder_joint>**标签：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When choosing **revolute**, we first need to define which axis will be rotating.
    As we chose **z** (if you look at *Figure 11**.4*, we want to rotate around the
    blue axis), we write **"0 0 1"**, which means: no rotation on **x** and **y**,
    and a rotation on **z**.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择**revolute**时，我们首先需要定义哪个轴将旋转。因为我们选择了**z**（如果你看*图11**.4*，我们想要围绕蓝色轴旋转），我们写**"0
    0 1"**，这意味着：**x**和**y**没有旋转，**z**上有旋转。
- en: We set the revolution between -180 and +180 degrees (about **-3.14** and **3.14**
    radians). We also have to specify a value for the velocity and effort limits.
    Those two will usually be overridden by other ROS nodes. Set them to **100** by
    default; it won’t be important here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旋转角度设置为-180到+180度（大约**-3.14**和**3.14**弧度）。我们还需要指定速度和努力限制的值。这两个值通常会被其他ROS节点覆盖。默认设置为**100**；在这里它不会很重要。
- en: With this joint, you have created a TF that defines the position of the **shoulder_link**
    relative to the **base_link**, and the movement between those two links.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个关节，你创建了一个TF，它定义了**shoulder_link**相对于**base_link**的位置，以及这两个链接之间的运动。
- en: Now, you can start RViz again (disable the visual), and you will find a cursor
    in the **Joint State Publisher** window. Move the cursor to make the **shoulder_link**
    rotate on top of the **base_link**. Once again, it’s all about making the frame
    correctly move. If the visual still doesn’t look right, don’t worry about it;
    this is what we will fix in the last step of this process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以再次启动RViz（禁用视觉），你将在**Joint State Publisher**窗口中找到一个光标。将光标移动到使**shoulder_link**在**base_link**上方旋转。再一次，这完全是关于正确移动框架。如果视觉仍然看起来不正确，不要担心；这是我们将在本过程的最后一步修复的。
- en: Step 5 – fixing the visual origin
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 – 修复视觉原点
- en: We can now fix the origin of the **shoulder_link** visual. Don’t modify the
    **base_link** origin, as it’s already correct. Here, we only modify the visual
    for the child link.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以固定**shoulder_link**视觉的原点。不要修改**base_link**的原点，因为它已经正确了。在这里，我们只修改子链接的视觉。
- en: To do so, you can enable the **shoulder_link** visual again on RViz and see
    that the frame is at the center of the cylinder. Thus, we need to offset the visual
    by half of the length of the cylinder, which means **0.15** m (half of **0.3**
    m).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你可以在RViz中再次启用**shoulder_link**视觉，并看到框架位于圆柱体的中心。因此，我们需要将视觉偏移到圆柱体长度的一半，这意味着**0.15**米（**0.3**米的一半）。
- en: 'Modify the **<origin>** tag inside the **<link>** tag of the **shoulder_link**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 修改**<origin>**标签，位于**<link>**标签内的**shoulder_link**：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you start RViz again, you will then see that everything is correctly placed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次启动RViz，你会看到一切都被正确放置：
- en: '![Figure 11.5 – The end of the process for fixing the origins](img/B22403_11_5.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5 – 修复原点的过程结束](img/B22403_11_5.jpg)'
- en: Figure 11.5 – The end of the process for fixing the origins
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 修复原点的过程结束
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we want the cylinder to be placed on top of the frame. If you
    wanted the frame to be in the center of the cylinder, you would place the joint
    origin higher on the *Z*-axis, and then leave the visual origin as it is (I talk
    more about this later in this chapter, when we work on the wheels of the mobile
    robot).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要将圆柱体放置在框架上方。如果你想要框架位于圆柱体的中心，你会在*Z*-轴上更高处放置关节原点，然后保持视觉原点不变（我将在本章后面，当我们处理移动机器人的轮子时，更多地讨论这一点）。
- en: The process is now finished. As it is very important, let’s now do a quick recap.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在过程已经完成。由于它非常重要，让我们现在快速回顾一下。
- en: Recap – the process to follow every time
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾 – 每次都要遵循的过程
- en: When you create a URDF, you will first start with a link, usually named **base_link**.
    Then, for each link that you add, you will also add a joint, to connect this new
    link to an existing one.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个URDF时，你首先会从一个链接开始，通常命名为**base_link**。然后，对于你添加的每个链接，你也会添加一个关节，以将这个新链接连接到现有的一个链接上。
- en: 'Here is the process to add a new link to your URDF:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将新链接添加到你的URDF中的过程：
- en: Add a new `<link>` tag and set all origin elements to `0`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的**<link>**标签，并将所有原点元素设置为`0`。
- en: Add a new `<joint>` tag. You have to specify a parent and child link. The parent
    link will be an existing link you’ve already created, and the child link is the
    new link you’ve just added. Set all origin elements to `0`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 `<joint>` 标签。你必须指定一个父链接和一个子链接。父链接将是你已经创建的现有链接，而子链接是你刚刚添加的新链接。将所有原点元素设置为
    `0`。
- en: Fix the origin of the joint. Visualize the URDF in RViz, disable the visual
    for the new link, and figure out where the frame for the new link should be relative
    to its parent.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定关节的原点。在 RViz 中可视化 URDF，禁用新链接的视觉，并确定新链接的框架相对于其父链接的位置。
- en: If the joint is associated with a movement, set the joint type. Depending on
    the type, you might have to set the axis of rotation/translation, some limits,
    and so on.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果关节与运动相关联，设置关节类型。根据类型，你可能需要设置旋转/平移轴、一些限制等。
- en: Once the frame origin is correct, enable the visual in RViz and fix the visual
    origin for the link (only for the child link, not the parent link).
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦框架原点正确，在 RViz 中启用视觉并固定链接的视觉原点（仅针对子链接，不是父链接）。
- en: After this is done, congratulations, you have successfully connected two links,
    and the joint will be used to generate a TF. You can repeat this process for each
    new link that you add to your URDF.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个步骤后，恭喜你，你已经成功连接了两个链接，关节将用于生成 TF。你可以为 URDF 中添加的每个新链接重复此过程。
- en: 'A few important things to remember are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一些重要事项如下：
- en: Only add one link and one joint at a time. Finish the process, then add another
    link.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次只添加一个链接和一个关节。完成这个过程后，再添加另一个链接。
- en: Don’t modify the origin of the parent link or any link you’ve already created
    before. This is a sure way to start messing up with the URDF and spending hours
    on debugging. If you need to go back to a previous link, then disable all children,
    fix the link, and continue from there.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要修改父链接或你之前创建的任何链接的原点。这是开始弄乱 URDF 并花费数小时进行调试的可靠方法。如果你需要回到之前的链接，那么禁用所有子链接，修复链接，然后继续。
- en: One link can have several children, but only one parent.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个链接可以有多个子链接，但只有一个父链接。
- en: After each modification, as small as it can be, always verify in RViz. Don’t
    try to modify several origin elements at the same time. Change one, validate it,
    then go to the next one.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次修改后，无论修改得多小，都要在 RViz 中进行验证。不要尝试同时修改多个原点元素。改变一个，验证它，然后进行下一个。
- en: You can verify that the relationship between all links is correct by printing
    the TF tree.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过打印 TF 树来验证所有链接之间的关系。
- en: In the end, this process is not that complicated. Following these steps to the
    letter will ensure that you build your URDF right the first time. Not only will
    you be sure about what you are doing but, it will save you lots of time in the
    long term, and your URDF will be cleaner.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个过程并不复杂。严格按照这些步骤操作将确保你第一次就能正确构建 URDF。这不仅会让你对自己的操作有信心，而且从长远来看，这将节省你大量时间，并且你的
    URDF 将更加整洁。
- en: We now have all the information we need to create a complete URDF for a robot.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了创建一个完整的 URDF 所需的所有信息。
- en: Writing a URDF for a mobile robot
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动机器人编写 URDF
- en: You have seen the complete process of adding links and joints in a URDF file.
    By repeating this process several times, you can create a complete model for any
    robot.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在 URDF 文件中添加链接和关节的完整过程。通过重复这个过程几次，你可以为任何机器人创建一个完整的模型。
- en: We are now going to use this process to create a mobile robot. We will then
    use this URDF as a base for the next chapters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用这个过程来创建一个移动机器人。然后我们将把这个 URDF 作为下一章的基础。
- en: I will first show you the final robot model so you get an idea, and then we
    will build the URDF, step by step. You will get the specs for the robot as we
    build it. I encourage you to follow along and even write the code at the same
    time as you read the section. This is good practice for you to get more comfortable
    with URDF. As a reminder, you can find the complete code on GitHub.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先会向你展示最终的机器人模型，这样你就能有一个概念，然后我们将逐步构建 URDF。随着我们的构建，你将获得机器人的规格。我鼓励你在阅读本节的同时跟随操作，甚至可以边读边写代码。这对于你熟悉
    URDF 来说是一个很好的实践。作为提醒，你可以在 GitHub 上找到完整的代码。
- en: What we want to achieve
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们想要实现的目标
- en: 'Before writing any code, it’s important to define what we want to achieve.
    The final result will look like this in RViz:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，定义我们想要实现的目标是非常重要的。最终的结果在 RViz 中将看起来像这样：
- en: '![Figure 11.6 – Final result for the mobile robot](img/B22403_11_6.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 移动机人的最终结果](img/B22403_11_6.jpg)'
- en: Figure 11.6 – Final result for the mobile robot
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 移动机人的最终结果
- en: We will start the URDF with the robot’s main structure (chassis), represented
    by a box. This box is the same as the one we have created with the **base_link**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从代表机器人主要结构（底盘）的盒子开始，这个盒子与**base_link**我们创建的相同。
- en: Then, we will add two wheels, on each side of the chassis. Those two wheels
    will have a continuous rotation. Finally, for stability, we add a caster wheel
    (sphere) that will help the robot not fall forward when we simulate it in Gazebo.
    This caster wheel will be a fixed joint, and we won’t add any movement to it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在底盘的两侧各添加两个轮子。这两个轮子将具有连续旋转。最后，为了稳定性，我们添加一个转向轮（球体），这将帮助机器人在Gazebo中模拟时不会向前倾倒。这个转向轮将是一个固定关节，我们不会给它添加任何运动。
- en: On top of that, at the end, we will also add another link named **base_footprint**
    (with no visual, we can consider it as a virtual link), which is the projection
    of the **base_link** on the ground. I will explain this further when we do it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，最后，我们还将添加另一个名为**base_footprint**的链接（没有视觉，我们可以将其视为虚拟链接），它是**base_link**在地面上的投影。我将在我们做的时候进一步解释。
- en: To get started, go back to the **my_robot.urdf** file we have written previously,
    and keep the **base_link**. Remove the **shoulder_link** as well as the **base_shoulder_joint**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，回到我们之前编写的**my_robot.urdf**文件，并保留**base_link**。同时移除**shoulder_link**以及**base_shoulder_joint**。
- en: Let’s now add the two wheels to the side of the robot.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将两个轮子添加到机器人的侧面。
- en: Adding the wheels
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加轮子
- en: We will add the wheels one by one, starting with the right wheel. Unless you’re
    an expert already, it’s important that you only add one link and one joint at
    a time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个添加轮子，从右轮开始。除非你已经是一位专家，否则每次只添加一个链接和一个关节是很重要的。
- en: Right wheel
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右轮
- en: 'To add the right wheel, we will follow the five-step process we just described.
    Let’s name this link **right_wheel_link**. For the visual, we will use a cylinder,
    with a radius of **0.1** m and a length of **0.05** m. Here is the code for the
    link (*Step 1*):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加右轮，我们将遵循我们刚刚描述的五步流程。让我们把这个链接命名为**right_wheel_link**。对于视觉，我们将使用一个半径为**0.1**米，长度为**0.05**米的圆柱体。以下是链接的代码（*步骤1*）：
- en: '[PRE16]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As the wheel will be attached to the **base_link** (green color), we choose
    the gray color to make a contrast. As you can see, we set all origin elements
    to **0**. We will only come back to those elements at the end of the process.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于轮子将连接到**base_link**（绿色），我们选择灰色以产生对比。正如你所见，我们将所有原点元素设置为**0**。我们将在过程结束时再回到这些元素。
- en: Now, let’s add a joint between the base and the right wheel (*Step 2*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在底盘和右轮之间添加一个关节（*步骤2*）。
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you get more experienced, you can set the movement type when creating the
    joint, but let’s go step by step. For now, we set the type to **fixed**, so we
    can set the joint origin first, and then specify the type of movement. This will
    make things simpler and less prone to errors.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更有经验时，你可以在创建关节时设置运动类型，但让我们一步一步来。现在，我们将类型设置为**fixed**，这样我们就可以首先设置关节原点，然后指定运动类型。这将使事情更简单，更不容易出错。
- en: With this code, you can already visualize the URDF in RViz. Disable the **right_wheel_link**
    visual (**RobotModel** | **Links**) as we don’t need this for now, and it could
    make us confused when setting the joint origin.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你现在已经可以在RViz中可视化URDF了。禁用**right_wheel_link**的视觉（**RobotModel** | **Links**），因为我们现在不需要它，这可能会在设置关节原点时让我们感到困惑。
- en: 'Then, the question is: where do we place the **right_wheel_link** frame relative
    to the **base_link** frame (*Step 3*)? Let’s see for each axis:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题是：我们将**right_wheel_link**框架相对于**base_link**框架放置在哪里（*步骤3*）？让我们看看每个轴：
- en: '`-0.15` m offset.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-0.15`米偏移量。'
- en: '`-0.2`m (half of the width of the box). Then, later on, you would need to add
    an offset in the wheel visual, like we did for the `shoulder_link` in the previous
    example.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-0.2`米（箱子宽度的一半）。然后，稍后，你需要在轮子的视觉中添加一个偏移量，就像我们在之前的例子中对**shoulder_link**所做的那样。'
- en: Alternatively, you can add a small additional offset to the joint, so that the
    wheel would be outside of the box, and the visual would be centered around the
    frame. This second option is a good idea for wheels and some sensors—for example,
    when using a lidar, this is required to make the scan work properly. We then need
    to add `-0.2` m, and an additional `-0.025` m (half of the length of the wheel).
    The total offset is `-0.225`m.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你也可以在关节上添加一个小的额外偏移量，这样轮子就会在箱子外面，视觉将围绕框架中心。对于轮子和一些传感器来说，这是一个好主意——例如，当使用激光雷达时，这是使扫描正常工作的必要条件。然后我们需要添加`-0.2`米，以及额外的`-0.025`米（轮子长度的一半）。总偏移量是`-0.225`米。
- en: '**Z translation (blue axis)**: There is no need for any offset here, as we
    want the center of the wheel to be at the bottom of the box.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z 轴平移（蓝色轴）**：这里不需要任何偏移，因为我们希望轮子的中心位于盒子的底部。'
- en: We have our three values for the translation. That’s all we need. You might
    think that we have to rotate the joint axis because the visual is not correctly
    orientated. However, this is one of the most common mistakes, and it’s where you
    could start to modify the wrong values to fix the wrong problem. As we saw in
    the process, we first fix the joint with the visual disabled, and then, and only
    then, we fix the visual.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了三个平移值。这就足够了。你可能认为我们必须旋转关节轴，因为视觉方向不正确。然而，这是最常见的错误之一，而且你可能会开始修改错误的值来修复错误的问题。正如我们在过程中看到的那样，我们首先禁用视觉来固定关节，然后，而且只有然后，我们才固定视觉。
- en: 'Let’s modify the **<origin>** tag inside the **<joint>** tag (again: not in
    the link, only in the joint):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次修改 **<joint>** 标签内的 **<origin>** 标签（再次强调：不是在链接中，而是在关节中）：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, start RViz again, disable the visual for the wheel (this visual is still
    wrong, but not a problem), and you can see that the joint is placed a bit outside
    the box.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次启动 RViz，禁用轮子的视觉（这个视觉仍然不正确，但不是问题），你会发现关节放置在盒子外面一点。
- en: We can now easily add the movement (*Step 4*). As the wheel will continuously
    rotate (there is no minimum or maximum position), we choose the **continuous**
    type. We also need to specify the rotation axis. By looking at the robot model
    in RViz, we can see that we have to pick the *Y*-axis (the wheel should rotate
    around the green axis).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以轻松地添加运动（*步骤 4*）。由于轮子将不断旋转（没有最小或最大位置），我们选择**连续**类型。我们还需要指定旋转轴。通过在 RViz
    中查看机器人模型，我们可以看到我们必须选择 *Y* 轴（轮子应该围绕绿色轴旋转）。
- en: 'Thus, we modify the **<joint>** tag accordingly:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们相应地修改了 **<joint>** 标签：
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no need to specify a **<limit>** tag for **continuous**, as we did
    with the **revolute** type previously.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **连续** 类型，不需要指定 **<limit>** 标签，就像我们之前对 **revolute** 类型所做的那样。
- en: You can now start RViz again, disable the wheel visual, and move the new cursor
    named **base_right_wheel_link** on the **Joint State Publisher** window. You should
    see the joint correctly rotating around the base.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以再次启动 RViz，禁用轮子视觉，并将名为 **base_right_wheel_link** 的新光标移动到 **Joint State
    Publisher** 窗口中。你应该看到关节正确地围绕基础旋转。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With the cursor, you will see a minimum of about `-3.14` and a maximum of about
    `3.14` (total of 360 degrees). Don’t worry about this, it’s just a graphical element.
    As the joint type is continuous, there will be no minimum or maximum position
    when we control it later on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用光标，你会看到一个最小值约为 `-3.14` 和一个最大值约为 `3.14`（总共 360 度）。不用担心这个，这只是一个图形元素。由于关节类型是连续的，当我们后来控制它时，将没有最小或最大位置。
- en: That’s it for the joint. With this, the TF will be correctly generated. We can
    now finish the process and fix the visual for the link (*Step 5*). If you re-enable
    the wheel visual, you will see that it’s not correctly orientated. You would need
    to add a 90-degree rotation on the *X*-axis (around the red axis). This corresponds
    to pi/2, or about **1.57** radian (we will see later in this chapter how to use
    a precise value of pi).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关节来说，这就结束了。有了这个，TF 将会正确生成。我们现在可以完成这个过程，并修复链接的视觉（*步骤 5*）。如果你重新启用轮子视觉，你会看到它没有正确定位。你需要添加一个在
    *X* 轴上的 90 度旋转（围绕红色轴）。这对应于 π/2，或者大约 **1.57** 弧度（我们将在本章后面看到如何使用 π 的精确值）。
- en: 'Let’s modify the **<origin>** tag for the **right_wheel_link**:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 **right_wheel_link** 的 **<origin>** 标签：
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Start RViz again, and now everything should be fine: the wheel visual will
    be correctly placed (just outside of the box) and with the right orientation.
    When you move the cursor for the joint, the wheel will turn correctly.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动 RViz，现在一切应该都正常：轮子视觉将正确放置（正好在盒子外面）并且方向正确。当你移动关节的光标时，轮子将正确转动。
- en: The right wheel was probably the most complicated part of this robot, but as
    you can see, if you follow the process in the order, there should be no problem.
    You can be sure that all values are correct, and that there is no error that will
    propagate onto the next links that you add.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 右轮可能是这个机器人最复杂的一部分，但正如你所看到的，如果你按照顺序遵循这个过程，应该不会有问题。你可以确信所有值都是正确的，而且没有错误会传播到你添加的下一个链接。
- en: Let’s now write the code for the left wheel.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为左轮编写代码。
- en: Left wheel
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 左轮
- en: As the left wheel is the same as the right wheel, but on the opposite side of
    the box, writing the code will be fairly straightforward. Here I won’t repeat
    the full process and will just show you the final **<link>** and **<****joint>**
    tags.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于左轮与右轮相同，但位于箱子的对面，编写代码将相当直接。这里我不会重复整个过程，只会展示最终的**<link>**和**<joint>**标签。
- en: 'Let’s start with the link:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从链接开始：
- en: '[PRE21]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the same code as for the **right_wheel_link**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这与**right_wheel_link**的代码相同。
- en: 'Then, the left wheel will be connected to the chassis, so the parent of the
    **left_wheel_link** will be **base_link**. Here is the code for the joint:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，左轮将连接到底盘，因此**left_wheel_link**的父级将是**base_link**。以下是关节的代码：
- en: '[PRE22]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Everything is the same, except for the offset on the *Y*-axis. For the right
    wheel, we had to go on the negative side, but for the left wheel, we went on the
    positive side.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的东西都一样，只是在*Y*-轴上的偏移不同。对于右轮，我们必须在负方向上移动，但对于左轮，我们在正方向上移动。
- en: The important thing to check is that when you move the two cursors on the **Joint
    State Publisher** window on the positive side, both wheels are rotating in the
    same direction. If you have this, then your differential drive system is correctly
    designed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 需要检查的重要事项是，当你将两个光标在**Joint State Publisher**窗口的正方向移动时，两个轮子都朝同一方向旋转。如果你有这种情况，那么你的差速驱动系统设计是正确的。
- en: We can now add the **caster wheel** for the stability of the robot.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加万向轮以提高机器人的稳定性。
- en: Adding the caster wheel
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加万向轮
- en: When we add physics and gravity later on in the Gazebo simulator, you can guess
    that the robot would fall on the front side, because it’s out of balance. To fix
    this, we will add what’s called a caster wheel. It’s the same principle as the
    wheels under a desk chair.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Gazebo模拟器中稍后添加物理和重力时，你可以猜到机器人会落在前面，因为它不平衡。为了解决这个问题，我们将添加一个称为万向轮的东西。这与桌子椅子下的轮子原理相同。
- en: To make things simple, the caster wheel will be represented by a sphere (with
    a radius of **0.05** m). For the movement, even if the wheel is rotating, this
    is not a rotation we control with ROS. It is a passive rotation; thus, we will
    consider the joint as **fixed**.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，万向轮将用一个球体（半径为**0.05** m）来表示。对于运动，即使轮子在旋转，这也不是我们用ROS控制的旋转。这是一个被动旋转；因此，我们将考虑关节为**固定**。
- en: 'Let’s create the link first (*Step 1*):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建链接（*步骤1*）：
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There’s nothing too complicated here. Now, the caster wheel will be connected
    to the chassis of the robot. Let’s add the joint (*Step 2*). To follow the process,
    we first set all origin elements to **0**:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多复杂的事情。现在，万向轮将连接到机器人的底盘。让我们添加关节（*步骤2*）。为了遵循这个过程，我们首先将所有原点元素设置为**0**：
- en: '[PRE24]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Start RViz and disable the visual. From this, let’s see where to place the
    origin of the caster wheel relative to the origin of the base (*Step 3*):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 启动RViz并禁用视觉。从这一点来看，让我们看看万向轮相对于底盘原点的位置在哪里（*步骤3*）：
- en: '`0.2` m.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.2` m。'
- en: '`0`.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`。'
- en: '`0.05` as the radius so that the diameter of the caster wheel (0.1 m) corresponds
    to the radius of the wheel. Thus, in order for the wheels and caster wheels to
    be aligned on the ground, we need to offset the *Z*-axis by `-0.05` m. If you
    are not so sure about this, it’s simple: try some values and see the results in
    RViz.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半径设置为`0.05`，这样滚轮的直径（0.1 m）就对应于轮子的半径。因此，为了使轮子和万向轮在地面上对齐，我们需要将*Z*-轴偏移`-0.05` m。如果你对此不太确定，很简单：尝试一些值，并在RViz中查看结果。
- en: 'There is no need to set any rotation for the joint, as we won’t move the caster
    wheel, and it’s a sphere. Let’s apply the offset in the **<origin>** tag of the
    **<****joint>** tag:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关节，我们不需要设置任何旋转，因为我们不会移动万向轮，它是一个球体。让我们在**<origin>**标签的**<joint>**标签中应用偏移：
- en: '[PRE25]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now the caster wheel will be correctly placed under the chassis, and you can
    verify that the bottoms of both wheels and caster wheel seem to be aligned. Here,
    there is no need to set a movement type (*Step 4*) nor to fix the visual (*Step
    5*).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，万向轮将被正确地放置在底盘下方，你可以验证两个轮子和万向轮的底部似乎是对齐的。在这里，没有必要设置移动类型（*步骤4*）或固定视觉（*步骤5*）。
- en: The robot model is now finished. There is just one more thing we will do to
    better prepare the robot for the following.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人模型现在完成了。我们还将做一件事，以更好地为后续步骤准备机器人。
- en: Extra link – base footprint
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外链接 - 底部足迹
- en: The robot is correctly designed and will work fine when we add control to it.
    However, there is one improvement we can make.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人设计正确，当我们添加控制时，它将正常工作。然而，我们可以进行一项改进。
- en: If you look at the robot in RViz, the **base_link** frame is not at the same
    altitude (**z** offset) as the bottom of the three wheels. This is fine, but it
    would be nice to have the origin of the robot aligned with the ground where the
    robot will be.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 RViz 中的机器人，**base_link** 框架的 **z** 偏移量与三个车轮底部不在同一高度。这是可以的，但最好将机器人的原点与机器人将放置的地面对齐。
- en: Not only will it make the robot look better in RViz (although it’s not important),
    but it will also make things easier in the future. An example would be when you
    want to create a transformation from a docking station to a mobile robot, or from
    one robot to another one. Another example would be if you want to use the **Navigation
    2** stack. If all robot origins are on the ground, you can then work in 2D, which
    is easier to handle.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅会使机器人在 RViz 中的外观更好（尽管这不是很重要），而且还会使未来的事情更容易处理。一个例子是当你想从一个对接站创建一个到移动机器人的变换，或者从一个机器人到另一个机器人。另一个例子是如果你想使用
    **Navigation 2** 堆栈。如果所有机器人的原点都在地面上，那么你就可以在 2D 中工作，这更容易处理。
- en: 'For that reason, it’s quite common to add a virtual link named **base_footprint**,
    which will be the projection of the **base_link** on the ground. We say the link
    is *virtual* because it doesn’t contain any visuals; it’s just an additional frame
    we define in the space. Here is the code for the link:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加一个名为 **base_footprint** 的虚拟链接是很常见的，它将是 **base_link** 在地面上的投影。我们说这个链接是 *虚拟的*，因为它不包含任何视觉元素；它只是在空间中定义的一个额外的框架。以下是链接的代码：
- en: '[PRE26]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this link is extremely simple, as we didn’t include any **<visual>**
    tag. For a link name, we usually start with the rigid part name and add the **_link**
    suffix. Here, we make an exception. You will find this **base_footprint** name
    in many URDF files for existing mobile robots.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个链接非常简单，因为我们没有包含任何 **<visual>** 标签。对于链接名称，我们通常从刚体部分名称开始，并添加 **_link**
    后缀。在这里，我们做一个例外。你将在许多现有移动机器人的 URDF 文件中找到这个 **base_footprint** 名称。
- en: 'Now, we can add a new **fixed** joint, with the **base_footprint** as the parent,
    and the **base_link** as the child:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个新的 **固定** 关节，以 **base_footprint** 作为父节点，以 **base_link** 作为子节点：
- en: '[PRE27]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We apply a **0.1** m offset on the *Z*-axis, which corresponds to the right
    and left wheels’ radius.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *Z* 轴上应用了一个 **0.1** 米的偏移量，这对应于左右轮的半径。
- en: Note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To organize all links and joints in a URDF, I usually write all the links first,
    followed by all the joints. You could also decide to alternate between links and
    joints. There is no right or wrong method; it’s a question of preference.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 URDF 中组织所有链接和关节，我通常先写所有链接，然后写所有关节。你也可以决定交替使用链接和关节。没有正确或错误的方法；这是一个关于偏好的问题。
- en: You can now visualize the final result on RViz. To get the correct view, click
    on **Global Options**, and in the **Fixed Frame** menu, choose **base_footprint**.
    You will see that the bottoms of the wheels, and the **base_footprint**, are aligned
    on the ground.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在 RViz 中可视化最终结果。要获得正确的视图，点击 **全局选项**，然后在 **固定框架** 菜单中选择 **base_footprint**。你会看到车轮底部和
    **base_footprint** 都与地面齐平。
- en: 'While RViz is still running, you can print and visualize the TF tree:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当 RViz 仍在运行时，你可以打印和可视化 TF 树：
- en: '![Figure 11.7 – Final TF tree for the mobile robot](img/B22403_11_7.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 移动机器人的最终 TF 树](img/B22403_11_7.jpg)'
- en: Figure 11.7 – Final TF tree for the mobile robot
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 移动机器人的最终 TF 树
- en: We are now done with the URDF. Before we finish this chapter, let’s explore
    Xacro, which will allow you to improve your URDF file and make it more scalable.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了 URDF。在我们完成这一章之前，让我们探索 Xacro，这将允许你改进你的 URDF 文件并使其更具可扩展性。
- en: Improving the URDF with Xacro
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Xacro 改进 URDF
- en: 'The more complex your robot, the bigger the URDF. As you add more links and
    joints, you will end up having problems scaling your robot model. Also, what we
    have written so far is not so dynamic: all the values are hardcoded.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人越复杂，URDF 就越大。随着你添加更多的链接和关节，你最终会遇到在机器人模型上缩放的问题。此外，我们迄今为止所写的内容并不那么动态：所有值都是硬编码的。
- en: Xacro is an additional ROS feature you can use to solve all those issues. We
    will now see how to make a URDF file compatible with Xacro, how to create variables
    and functions, and how to split your URDF into several files.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Xacro 是一个额外的 ROS 功能，你可以用它来解决所有这些问题。现在我们将看到如何使 URDF 文件与 Xacro 兼容，如何创建变量和函数，以及如何将你的
    URDF 分割成几个文件。
- en: With Xacro, your URDF files will become more dynamic and scalable. All serious
    ROS 2 projects use Xacro, so it’s important to learn how to work with it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Xacro，你的 URDF 文件将变得更加动态和可扩展。所有严肃的 ROS 2 项目都使用 Xacro，因此学习如何与之协同工作是很重要的。
- en: Let’s get started with the setup.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置开始。
- en: Making a URDF file compatible with Xacro
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使 URDF 文件与 Xacro 兼容
- en: 'We will start by making sure our URDF file can use Xacro features. Before doing
    anything, let’s make sure that Xacro is installed (it should already be there
    with all the previous packages we installed):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保我们的 URDF 文件可以使用 Xacro 功能。在开始任何操作之前，让我们确认 Xacro 是否已安装（它应该已经随着我们之前安装的所有包一起安装了）：
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, to use Xacro in your URDF file, you need to make two changes.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在你的 URDF 文件中使用 Xacro，你需要进行两个更改。
- en: First, change the file extension. The file is currently named **my_robot.urdf**.
    For Xacro, you will use the **.xacro** extension. A common practice is to use
    the **.urdf.xacro** extension for the main URDF file of your robot, so the file
    would be named **my_robot.urdf.xacro** (the important thing is to have **.xacro**
    at the end).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改文件扩展名。文件当前命名为**my_robot.urdf**。对于 Xacro，你将使用**.xacro**扩展名。一个常见的做法是为你的机器人主
    URDF 文件使用**.urdf.xacro**扩展名，因此文件将被命名为**my_robot.urdf.xacro**（重要的是要在末尾有**.xacro**）。
- en: 'Once you’ve changed the extension, open the file and modify the **<****robot>**
    tag:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你更改了扩展名，打开文件并修改**<robot>**标签：
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Every time you want to use Xacro in a URDF file, you will have to add this
    **xmlns:xacro** argument.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**每次你想在 URDF 文件中使用 Xacro，你都必须添加这个** xmlns:xacro **参数**。'
- en: 'That’s it for the setup. Now, to visualize the URDF in RViz, you will run the
    same command as before, with the new file name:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 设置到此结束。现在，为了在 RViz 中可视化 URDF，你将运行与之前相同的命令，但使用新的文件名：
- en: '[PRE30]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s now discover how to use variables with Xacro.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何使用 Xacro 中的变量。
- en: Xacro properties
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xacro 属性
- en: In programming, one of the first and most important things you learn is how
    to use variables. Variables do not exist in URDF, but you can use them with Xacro.
    Here, a variable is called a **property**.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，你最先和最重要的学习之一是如何使用变量。URDF 中没有变量，但你可以使用 Xacro 来使用它们。在这里，变量被称为**属性**。
- en: With Xacro properties, we will be able to specify values such as dimensions
    at the beginning of the file and use those properties inside the **<link>** and
    **<joint>** tags. This way, values and computations are not hardcoded. It will
    make things less confusing and more readable. Plus, if we ever need to modify
    a dimension of the robot, we just need to modify one value at the beginning of
    the file.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Xacro 属性，我们将在文件开始处指定诸如尺寸之类的值，并在**<link>**和**<joint>**标签中使用这些属性。这样，值和计算就不会是硬编码的。这将使事情更少混淆，更易读。此外，如果我们需要修改机器人的尺寸，我们只需修改文件开始处的值。
- en: Also, it’s important to note that Xacro properties are considered constant variables.
    After you set their value, you won’t modify them anymore.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得注意的是，Xacro 属性被视为常量变量。在你设置它们的值之后，你将不再修改它们。
- en: 'To declare and define a Xacro property, you will use the **<xacro:property>**
    tag and provide two arguments: **name** and **value**.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明和定义一个 Xacro 属性，你将使用**<xacro:property>**标签并提供两个参数：**name**和**value**。
- en: 'Let’s declare a few properties at the beginning of the file (inside the **<****robot>**
    tag):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件的开始处（在**<robot>**标签内）声明一些属性：
- en: '[PRE31]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Those are all the values we need for computing everything else in the URDF.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们计算 URDF 中其他所有值所需的所有值。
- en: 'Then, to use a Xacro property, you simply have to write **${property_name}**.
    You can also do computations. For example, to multiply a value by 2.5, you will
    write **${property_name * 2.5}**. With this information, let’s modify the content
    inside the **base_link** to remove any hardcoded value:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要使用 Xacro 属性，你只需写出**${property_name}**。你也可以进行计算。例如，要乘以 2.5，你将写出**${property_name
    * 2.5}**。有了这些信息，让我们修改**base_link**内的内容，以删除任何硬编码的值：
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we specify the box size with only properties. The most interesting
    part is how we compute the visual offset on the *Z*-axis. Writing **${base_height
    / 2.0}** is much more explicit than just writing **0.1**. Not only is it more
    dynamic, but we also have a better idea of what this computation is about. Imagine
    coming back to this URDF in six months and trying to figure out why the offset
    value is **0.1**, without any context. With this property, there is no possible
    doubt.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们仅使用属性来指定盒子大小。最有趣的部分是我们如何计算 *Z* 轴上的视觉偏移。写作**${base_height / 2.0}**比仅仅写作**0.1**要明确得多。这不仅更动态，而且我们还能更好地了解这个计算的目的。想象一下六个月后回到这个
    URDF，试图弄清楚偏移值为什么是**0.1**，而没有任何上下文。有了这个属性，就不会有任何可能的疑问。
- en: 'Let’s now modify the visual for the links of the right wheel and left wheel:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改右轮和左轮的视觉：
- en: '[PRE33]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Xacro property, or constant pi, is already defined. Instead of hardcoding
    an approximation of pi, you can just use it with `${pi}`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Xacro 属性或常数 pi 已经定义。你不必硬编码 pi 的近似值，可以直接使用 `${pi}`。
- en: 'Finally, here is the code for the caster wheel:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是 caster 轮的代码：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we didn’t define a **caster_wheel_radius** property. This is
    because the caster wheel radius needs to be proportional to the right and left
    wheel radius. It needs to be half of the value so that both wheels and caster
    wheels can touch the ground while making the robot stable. By using a Xacro property
    here, if we were to modify the wheel radius, then the caster wheel would automatically
    resize to make the robot stable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们没有定义 **caster_wheel_radius** 属性。这是因为 caster 轮的半径需要与左右轮的半径成比例。它需要是值的一半，这样两个轮子和
    caster 轮都可以接触地面，同时使机器人保持稳定。通过在这里使用 Xacro 属性，如果我们修改轮子半径，那么 caster 轮将自动调整大小以使机器人保持稳定。
- en: 'We have now modified all the links; let’s change the values in the joint origins.
    For the **base_joint**, we have the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经修改了所有链接；让我们更改关节原点中的值。对于 **base_joint**，我们有以下内容：
- en: '[PRE35]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The **base_right_wheel_joint** is a bit more complex. However, once again,
    by writing this, we will make the computation more readable and less prone to
    errors in the future:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**base_right_wheel_joint** 要复杂一些。然而，再次强调，通过编写这段代码，我们将使计算更加可读，并减少未来出错的可能性：'
- en: '[PRE36]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The **base_left_wheel_joint** will be the same, except that the sign on the
    *Y*-axis is positive. We finish with the **base_caster_wheel_joint**:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**base_left_wheel_joint** 将与之前相同，只是在 *Y* 轴上的符号是正的。我们以 **base_caster_wheel_joint**
    结束：'
- en: '[PRE37]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All those changes in the code didn’t modify the robot model. When visualizing
    it in Rviz, it should look the same.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码更改都没有修改机器人模型。在 Rviz 中可视化时，它应该看起来相同。
- en: To test that everything worked, try modifying the values for some Xacro properties
    at the beginning of the file. The robot model in RViz will have different dimensions,
    but it should still make sense.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试一切是否正常工作，尝试修改文件开头的一些 Xacro 属性值。在 RViz 中的机器人模型将具有不同的尺寸，但它仍然应该是有意义的。
- en: That’s it for Xacro properties. This concept is not that hard to understand
    and apply, especially if you’re already familiar with variables and constants.
    Let’s now switch to functions, or macros.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Xacro 属性就到这里。这个概念并不难理解和应用，尤其是如果你已经熟悉变量和常量。现在让我们转向函数或宏。
- en: Xacro macros
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xacro 宏
- en: 'A Xacro macro is the equivalent of a function in programming. With Xacro, a
    macro works like a template: it’s a piece of XML code that you can reuse with
    different values (parameters). A macro doesn’t return anything.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Xacro 宏在编程中相当于函数。使用 Xacro，宏就像一个模板：它是一段可以重复使用不同值（参数）的 XML 代码。宏不返回任何内容。
- en: Macros are quite useful when you have to duplicate a link or a joint several
    times. Imagine a robot with four cameras. You can create a macro for the camera
    link, and then call the macro instead of re-writing the same code four times.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要多次复制一个链接或关节时，宏非常有用。想象一个有四个摄像头的机器人。你可以为摄像头链接创建一个宏，然后调用宏而不是重写相同的代码四次。
- en: With our robot model, we have almost the same code for the **right_wheel_link**
    and the **left_wheel_link**. The only difference is the name of the link. Let’s
    create a macro for those links.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的机器人模型，**right_wheel_link** 和 **left_wheel_link** 几乎有相同的代码。唯一的区别是链接的名称。让我们为这些链接创建一个宏。
- en: 'To create a macro, you will use the **<xacro:macro>** tag and give a name as
    well as a list of **params**. You can specify zero, or as many parameters as you
    want—just separate them with a space. Here is an example:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个宏，你将使用 **<xacro:macro>** 标签，并给出一个名称以及一个参数列表。你可以指定零个或任意多个参数——只需用空格分隔即可。以下是一个示例：
- en: '[PRE38]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This piece of code won’t do anything by itself. We need to call it, just like
    you would call a function. To call a macro, you will write the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身不会做任何事情。我们需要调用它，就像调用一个函数一样。要调用一个宏，你将编写以下内容：
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Remove the **right_wheel_link** and the **left_wheel_link**, and write this
    instead:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 **right_wheel_link** 和 **left_wheel_link**，改为以下内容：
- en: '[PRE40]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The **"right"** value in the prefix parameter will be applied to the link name
    inside the macro, making the name **right_wheel_link**. The same thing applies
    for the left wheel.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀参数中的 **"right"** 值将被应用于宏内部的链接名称，使其成为 **right_wheel_link**。对于左轮也是如此。
- en: As you can see, macros can help you reduce code duplication. In this example,
    the benefit is not as big, but if you need to duplicate some links or joints more
    than three times, then macros can be extremely useful. Also, if you are creating
    part of a URDF that will be used by other people, writing a macro can help them
    to easily integrate your code into theirs, and customize it with the different
    parameters they can give as input.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Xacro properties and macros will allow you to make one URDF file more dynamic.
    Let’s finish this section by seeing how to make a URDF even more scalable.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Including a Xacro file in another file
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to Xacro, you can split your URDF into several files.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: This is useful to separate different parts of your robot, for example, the main
    core base, and extra sensors that you add on top. If you combine two robots, for
    example, a robotic arm on top of a mobile robot, you can create one URDF for each
    robot and combine them into a third one. Another benefit is collaboration. Creating
    a macro inside one file that other developers can include will make it easier
    for them to work with your code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our URDF, let’s split the file into three:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`common_properties.xacro`: This will contain the material tags and other properties
    that could apply to any part of our robotics application'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobile_base.xacro`: This file will contain the properties, macros, links,
    and joints that are specific to the mobile base'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_robot.urdf.xacro`: In this main file, we include the two previous files'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing this, we will make the URDF more dynamic and easier to modify in the
    future. If you want to combine several mobile bases or add other robots or sensors,
    you can create more Xacro files that you include into the main one (**my_robot.urdf.xacro**).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the two additional files, and let’s see how to organize the code.
    Make sure to put all three files in the same directory. In the next chapter, we
    will install them properly inside a ROS 2 package, but for now, keep them all
    in the same place (it will make it easier to include the first two files into
    the third one, using the relative path).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with **common_properties.xacro**. Here is the first thing to write
    inside this file:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All Xacro files must have this code, with a **<robot>** tag containing the **xmlns:xacro**
    attribute.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Don’t add the `name` attribute in the `<robot>` tag. This attribute will only
    be added once in the main Xacro file.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the **<robot>** tag, you can copy and paste the two **<material>**
    tags we have previously written. You can then remove those tags from **my_robot.urdf.xacro.**
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: In **mobile_base.xacro**, you will also start the file with the **<?xml>** and
    **<robot>** tags, like we did in **common_properties.xacro**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can copy and paste all the **<xacro:property>**, **<xacro:macro>**,
    **<link>**, and **<joint>** tags that are related to the mobile base, which are
    basically all the tags left.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: In **my_robot.urdf.xacro**, we have nothing left, only the **<?xml>** tag and
    the **<robot>** tag that contains the **name** and **xmlns:xacro** attributes.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'To include a Xacro file inside another file, you will write a **<xacro:include>**
    tag and provide the path to the file with the **filename** attribute. Here is
    the final content for **my_robot.urdf.xacro**:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our URDF is now split into several files and uses Xacro properties and macros.
    With those modifications, we didn’t change anything about the robot model, but
    we made the URDF more dynamic and scalable, as well as easier to read.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, you can find the complete code—all URDF and Xacro files—for this
    chapter inside the **ch11** folder of the book’s GitHub repository.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you discovered the full process of writing a URDF for a robot.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'A URDF defines a robot model and contains two main things: links and joints.
    A link is a rigid part of a robot that does nothing on its own. A link can have
    a visual (simple shapes such as boxes, cylinders, spheres, or meshes exported
    from CAD software). You can see a robot as a collection of links put together.
    A joint defines the connection between two links. It specifies which link is the
    parent and which one is the child, as well as where the two links are connected,
    and how they move relative to each other.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: You learned that what you write inside a joint will define a TF for the robot.
    In the end, with all the joints inside a URDF, you are creating a TF tree.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: You also saw the complete process for adding a new link and joint on top of
    the previous ones. Make sure to follow this process every time. To help you develop
    and verify each step of the process, you learned that it’s a good idea to use
    tools such as RViz to visualize the robot model, and **tf2_tools** to see the
    TF tree.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned that you can also improve your URDF with Xacro. You can define
    some properties and macros, and even split a URDF into several files. This will
    be useful as your application scales and will make collaboration easier.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Creating a URDF for a robot is the first step, as mentioned in this chapter.
    This will allow you to generate the TFs, which are the backbone of any robot using
    ROS.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can create the URDF, let’s see how to start packaging our application,
    and discover what to start so we can properly generate the TFs (without using
    the **urdf_tutorial** package). This will be the focus of the next chapter.**
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
