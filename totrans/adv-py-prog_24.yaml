- en: '*Chapter 21*: The Bridge Pattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we covered our first structural pattern, **adapter**,
    which is used to make two incompatible interfaces compatible, and **decorator**,
    which allows us to add responsibilities to an object in a dynamic way. There are
    more similar patterns. Let's continue with the series!
  prefs: []
  type: TYPE_NORMAL
- en: A third structural pattern to look at is the **bridge** pattern. We can actually
    compare the *bridge* and the *adapter* patterns by looking at the way they work.
    While the adapter is used to make unrelated classes work together (as we saw in
    the implementation example discussed in [*Chapter 19*](B17499_19_Final_SS_ePub.xhtml#_idTextAnchor310),
    *The Adapter Pattern*), the bridge pattern is designed upfront to decouple an
    implementation from its abstraction, as we are going to see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will know how to implement this design pattern
    and understand better the aforementioned difference with the adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter21](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter21).'
  prefs: []
  type: TYPE_NORMAL
- en: Real-world examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our modern, everyday lives, one example of the bridge pattern that I can
    think of is **information products** from the *digital economy*. Nowadays, the
    information product, or **infoproduct** is part of the resources you can find
    online for training, self-improvement, or your ideas and business development.
    The purpose of an information product found on certain marketplaces, or the website
    of the provider, is to deliver information on a given topic in such a way that
    it is easy to access and consume. The material provided can be a PDF document
    or ebook, an ebook series, a video, a video series, an online course, a subscription-based
    newsletter, or a combination of all those formats.
  prefs: []
  type: TYPE_NORMAL
- en: In the software realm, **device drivers** are often cited as an example of the
    bridge pattern, when the developer of an **operating system** (**OS**) defines
    the interface for device vendors to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss when this design pattern should be employed.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the bridge pattern is a good idea when you want to share an implementation
    among multiple objects. Basically, instead of implementing several specialized
    classes, defining all that is required within each class, you can define the following
    special components:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstraction that applies to all the classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separate interface for the different objects involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will see an implementation example that illustrates this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume we are building an application where the user is going to manage
    and deliver content after fetching it from diverse sources, which could be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A web page (based on its URL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A resource accessed on an FTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file on the local filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, here is the idea: instead of implementing several content classes, each
    holding the methods responsible for getting the content pieces, assembling them,
    and showing them inside the application, we can define an abstraction for the
    `Resource Content`and a separate interface for the objects that are responsible
    for fetching the content. Let''s try it!'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with the class for our `Resource Content` abstraction, called `ResourceContent`.
    Then, we will need to define the interface for implementation classes that help
    fetch content, that is, the `ResourceContentFetcher` class. This concept is called
    the **Implementor**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first trick we use here is to use the `_imp` attribute on the `ResourceContent`
    class to maintain a reference to the object, which represents the *Implementor*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may know by now, we define the equivalent of an interface in the Python
    language using two features: the `metaclass` feature (which helps define the *type
    of a type*), and **abstract base classes** (**ABC**), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add an implementation class called `URLFetcher` to fetch content
    from a web page or resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add an implementation class called `LocalFileFecher` to fetch content
    from a file on the local filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on that, our `main` function for showing content using both *content
    fetchers* could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, our process could be summarized in the following UML diagram, where
    `LocalFileFetcher` and `URLFetcher` both inherit from `ResrouceContentFetcher`,
    and `ResourceContent` stores a `Fetcher` object in its `_imp` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.1 — UML diagram of the content-fetching application ](img/Figure_21.1_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21.1 — UML diagram of the content-fetching application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a summary for the complete code of our example (the `bridge.py`
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: We import the three modules we need for the program (`abc`, `urllib.parse`,
    and `urllib.request`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `ResourceContent` class for the interface of the abstraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `ResourceContentFetcher` class for the implementator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define two `implementation` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`URLFetcher` for fetching content from a URL'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalFileFetcher` for fetching content from the local filesystem'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add the `main()` function, as shown previously, and the usual trick
    to call it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is some sample output when executing the `python bridge.py` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a basic illustration of how, using the bridge pattern in your design,
    you can extract content from different sources and integrate the results in the
    same data manipulation system or user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the bridge pattern. Sharing similarities with
    the adapter pattern, the bridge pattern differs in the sense that it is used upfront
    to define an abstraction and its implementation in a decoupled way so that both
    can vary independently.
  prefs: []
  type: TYPE_NORMAL
- en: The bridge pattern is useful when writing software for problem domains such
    as OSs, device drivers, GUIs, and website builders where we have multiple themes,
    and we need to change the theme of a website based on certain properties.
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand this pattern, we discussed an example in the domain of
    content extraction and management, where we defined an interface for the abstraction,
    an interface for the Implementor, and two implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to cover the façade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main motivation for the bridge pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the bridge pattern differ from the adapter pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the bridge pattern implemented in the Python example of content extraction
    we considered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
