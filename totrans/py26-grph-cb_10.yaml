- en: 'Chapter 10. GUI Construction: Part 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Widget configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button focus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest push button with validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data entry box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Colored button causing message pop-ups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex interaction between buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images on buttons and widget packing geometry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The grid geometry manager and button arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drop-down menus to select from a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text in a window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provide recipes for the components that are used to create
    user interfaces of the graphical kind. These are known as **GUI** or **Graphic
    User Interface**. The commonly-used term for GUI components is **Widget**. The
    word Widget has no particular meaning other than "general sort of gadget". If
    you used the example from [Chapter 4](ch04.html "Chapter 4. Animation Principles"),
    *Animation Principles* on a color-mixing palette, then you would have used the
    slider or scale widget which will be explained in this chapter. We will also demonstrate
    that it is not too difficult to create our own widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Widget configuration a label
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We see here how to change the properties (attributes) of most widgets using
    its `configuration()` method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All widgets have default values such as a gray background, and 12 point font
    size. Once the code for the creation of a widget has been executed the widget
    appears on the screen with all its assigned properties. Further down the code,
    as the program is being executed, the properties of the widget can be changed
    using the `widget.config(attribute=new value)` method. The result is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choice is good because it allows us to make our GUIs look good. The downside
    of this choice is that it allows us to make poor choices. But as the adage goes:
    poor choices made with intelligence lead to good choices.'
  prefs: []
  type: TYPE_NORMAL
- en: If we run this program we will see that the combination of colors made is about
    the worst that can be made they interfere with the eye's focusing mechanics because
    the two colors have different wavelengths and follow slightly different paths
    on their way to the retina.
  prefs: []
  type: TYPE_NORMAL
- en: Button focus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we demonstrate the concept of focus, which is easier to show than describe.
    When there are a group of widgets inside a window, only one widget can react to
    an event like the click of the mouse button. In this example, the button underneath
    the mouse cursor has focus and therefore is the one that will respond to a click
    of the mouse. As the cursor moves over another button, then *that button has focus*.
    In this example, the button that has focus changes its color, on a Linux-operating
    system. On MS Windows, the buttons do not change color but the mouse cursor changes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run the preceding code under Linux, we will see that the color of each
    button change as it acquires focus. The button that has focus is the only one
    of the group that will react to a left mouse click. Under MS Windows 7, this change
    of color with focus does not work. Nevertheless, the logic of focus behavior and
    reaction to mouse events is unaffected.
  prefs: []
  type: TYPE_NORMAL
- en: We have also taken the opportunity to look at the different button border styles
    available.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing to note in this example is that the size of a button is determined
    by the font size and amount of text placed on the button.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest push button with validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now home in on the simplest example of event processing by means of a `callback()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The validation referred to previously is any kind of reaction that provides
    confirmation that our code did what we wanted it to do. When you are developing
    code experimentally you need some kind of validation at the earliest stage in
    order build up insight.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy, save and execute. The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you push the little button with your mouse pointer, a message will appear
    on your terminal. The appearance of the message is the vital validation action
    your program produces.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple example demonstrates the fundamental design of all programs that
    react to user input. Then all you have to do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for some external event such as the click of a mouse or the tap of a key
    on the keyboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If and when the external event occurs, we must have an `event handler` function
    inside our program that specifies what actions must occur. These are often referred
    to as `callback` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the code, that makes an instance of any widget designed to accept user
    input, there must always be an option-specifier like `command=callback_1` that
    points to the name of your event-processing function named `callback_1` that will
    do all the things we want it to do when the event occurs. We do not have to use
    the actual word `callback_1` - we could have chosen any word we liked. In this
    case, the event is the push of a button. All we ask it to do inside the `callback()`
    function is to print a message. However, the list of resulting actions initiated
    by our `callback()` function can be as long as we like.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Programming literature often uses the word instantiation, especially with reference
    to objects in the object-oriented programming context. The word instantiation
    means to transform some object, which previously only existed as a semi-abstract
    description, into an actual block of code with a real namespace for its variables
    that interact with the data and commands inside your program. Python with Tkinter
    has a pre-defined object called a button. In our preceding program, we instantiate
    a button named `button_1` into existence by the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`button_1= Button(root, command=callback_1).grid(row=1, column=0)`'
  prefs: []
  type: TYPE_NORMAL
- en: The description to the right of the equals sign is the pre-existing abstract
    description taken from a long list of objects inside the Tkinter library. The
    name `button_1` on the left is the name of the instance that will have all of
    the actual properties that were previously just words in a library. This is like
    having a file with engineering drawings and assembly instructions for a sports
    car (the abstract description) and then getting some engineering workshop to actually
    manufacture an instance of the gleaming steel and chrome speedster. The file with
    drawings and manufacturing instructions is the equivalent of the object definition
    in our Python code. The thing with a metallic blue paint job, which you will sit
    in and drive with the wind in your hair, is an instance of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Buttons behave differently on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The button in this recipe behaves slightly differently in MS Windows compared
    to Linux. Windows displays the normal minimize, maximize, close symbols on the
    top right of the frame containing the button. We close the application by clicking
    on the top right "X" symbol. In Linux, there is a round button in the top of the
    frame. When we click this button, a menu opens up with a close command that can
    end the program.
  prefs: []
  type: TYPE_NORMAL
- en: A data entry box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We make a GUI that provides a data entry box and a button for handling whatever
    text is typed into the box.
  prefs: []
  type: TYPE_NORMAL
- en: The **Entry** widget is a standard Tkinter widget used to enter or display a
    single line of text.
  prefs: []
  type: TYPE_NORMAL
- en: The button `callback()` function (event handler) assigns the contents of the
    textbox to be the value of a variable. All these actions are verified by displaying
    the value of this variable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A text entry box on its own is not much use. It is like a post box text can
    be sent to it or picked up from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: It sets up a parent frame or window named `root` inside of which is a labeled
    button and a textbox with an initial message `enter text here` displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can click on the entry box and replace the initial text with new text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we click on the button it takes the contents of the box, and assigns them
    as the value of a variable called `data_inp_1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It displays the value of `data_inp_1` as a label to the right of the textbox.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key to getting buttons to perform useful functions lies in the code you
    place in the `callback()` function that gets executed when the button is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: Programming buttons can get very complicated and we can easily get confounded
    by our own ingenuity. The rule is to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: You can locate more than one button in the same position inside a frame, with
    the button that is visible being the last one our Python program placed there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, we can make sets of buttons that appear ''illuminated'' when on and
    ''dark'' when off. It is fun to do these things but be wary of getting too clever.
    A very brilliant and wise programmer said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: —Brian W. Kernighan, co-author of the C programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Did we keep things simple?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the sixth recipe of this chapter called "complex interaction between buttons",
    we ignore the wise advice just to explore what may be possible. We do this kind
    of thing for our own edification and fun but should shun it for any kind of professional
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Single-line versus multi-line entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The widget used here is called the **Entry** widget and is for single-line input
    only. There is another one called the **Text** widget that is designed for multi-line
    input. There is an example of how to use this widget later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Clever Geometry Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the size of the parent window changes to accommodate the size of
    the label text during the execution of the program. This is a very intelligent
    program design.
  prefs: []
  type: TYPE_NORMAL
- en: Colored button causing a message pop-up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buttons can be given different visual properties and complex behaviors. Here
    we create a blue raised button that changes appearance when clicked with a mouse.
    A message box widget is made to pop up when the button is pushed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_5.jpg)![How it works...](img/3845_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What we see now is that buttons are highly customizable, as are many Tkinter
    widgets. This recipe illustrates another term that you are bound to come across
    as a GUI programmer and that is the word focus.
  prefs: []
  type: TYPE_NORMAL
- en: Focus is the idea that when there are several widgets on a graphic container
    only one of them can be given attention or listened to at a time. Each button
    is programmed to respond to the click of a mouse but when the mouse is clicked,
    only one button should respond. The widget responding is the one that the program
    focuses on. In our example, you actually see the focus being given to the button
    when the mouse pointer moves across it the focus is used to change the button's
    coloring in a Linux operating system. It is like the chairman offering the floor
    to someone wanting to address a meeting group. The aspirant talker can only do
    so when the chairman offers them the floor (gives them focus). When this happens,
    everyone else is expected to be quiet and listen courteously.
  prefs: []
  type: TYPE_NORMAL
- en: Complex interaction between buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we show how button actions can be made as complex as we choose
    by getting a set of three buttons that modify each other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_7.jpg)![How it works...](img/3845_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All the action happens in the event handler (callback()) functions. Every instantiated
    object, like the buttons used here, has a collection of attributes like color,
    text, and appearance that can be modified by specifications like: `message_button_2["bg"]=
    "grey"`'
  prefs: []
  type: TYPE_NORMAL
- en: So what happens is that when button 1 is clicked, button 2 has its background
    color changed from green to grey.
  prefs: []
  type: TYPE_NORMAL
- en: While it is fun to create very complicated interactive behavior with button
    actions, it rapidly becomes nearly impossible to keep track of what behavior you
    want. The more complexity you add, the more unintended behaviors appear. The best
    advice then is to try to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Images on buttons and button packing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By placing GIF format images onto buttons, we can create any appearance desirable.
    The images can convey information about the function of the button. Image size
    has to be taken into account and the geometry manager has to be used thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in exactly the same way as usual.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The thing to notice here is that the grid geometry manager packs all the widgets
    together as neatly as it can regardless of widget size.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the wonderful thoughts behind the design of Python modules is that their
    actions should be kind and tolerant. This means that if attributes are coded with
    unsuitable values then defaults will be selected by the interpreter as at least
    some choice that is likely to work. This is an enormous boon to coders. If you
    ever come across one of the inner circle of Python developers they deserve an
    affectionate hug for this reason alone.
  prefs: []
  type: TYPE_NORMAL
- en: Grid Geometry Manager and button arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By placing GIF format images onto buttons, we can create any desired appearance.
    Image size has to be taken into account and the geometry manager has to be used
    thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are two geometry managers in Tkinter. In this book, we have used the Grid
    Geometry Manager exclusively up until now because it keeps the level of complexity
    down and also because it is easy to use and gives you direct control of your interface
    layout. The other layout geometry manager is called **pack** and is addressed
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The rules are simple. Our parent window or frame is divided into rows and columns.
    `Row=0` is the first row along the top and `column=0` is the first column down
    the left-hand side. `columnspan=2` means that the widget using this attribute
    sits in the center of two adjacent columns. Note that the button with the vine
    icon on it sits in the center of four grid regions because it has both `columnspan=2`
    and `rowspan=2`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By changing the grid attributes in this example, you can help yourself acquire
    an insight to the Grid Geometry Manager. Please experiment with the grid manager
    for a while it will pay dividends in your programming endeavors.
  prefs: []
  type: TYPE_NORMAL
- en: Drop-down menus to select from a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we use a drop-down menu widget as a way to select one item from a choice
    of several on offer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the program shown in the usual way. The result is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3845_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The drop-down menu has its own button. The `callback()` function that gets called
    when this button is clicked is named `grab_and_assign` in this particular recipe
    and one of the instructions in this event service routine is to assign the value
    of the menu item selected to the variable `chosen_option`. The instruction that
    does this is `chosen_option = var.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: As we did previously, we reassure ourselves that everything works as expected
    by printing the new value of `chosen_option` as a label on the parent window.
  prefs: []
  type: TYPE_NORMAL
- en: Listbox variable selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **listbox** is a widget that shows a choice of alternatives in a list form.
    An item in the list can be selected by clicking the mouse cursor on it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A listbox named `listbox1` is created and placed inside a Tkinter window. It
    is populated with five string items using a for loop.
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse cursor is clicked on an item, the function `get_list` assigns
    that item as the value of a variable `seltext`. The value of this variable is
    displayed in the yellow entry box.
  prefs: []
  type: TYPE_NORMAL
- en: Text in a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a simple way to place text in a window. There is no provision made to
    interact with the text.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Text widget is created by the `Text(root)` method and the `insert(…)` function
    places the text inside. The END attribute places each new line at the end of the
    previous one.
  prefs: []
  type: TYPE_NORMAL
