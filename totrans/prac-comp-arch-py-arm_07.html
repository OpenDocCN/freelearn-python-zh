<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-91" class="chapter-number" lang="en-GB"><a id="_idTextAnchor091"/>6</h1>&#13;
			<h1 id="_idParaDest-92" lang="en-GB"><a id="_idTextAnchor092"/>TC1 Assembler and Simulator Design</h1>&#13;
			<p lang="en-GB">In this chapter, we will put together the lessons we have learned in previous chapters and construct a computer simulator. The key topics we will cover in this chapter are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Analyzing instructions</li>&#13;
				<li lang="en-GB">Dealing with assembler directives</li>&#13;
				<li lang="en-GB">Building the binary instruction</li>&#13;
				<li lang="en-GB">The pre-TC1 (a prequel to the actual simulator)</li>&#13;
				<li lang="en-GB">The TC1 simulator program</li>&#13;
				<li lang="en-GB">A TC1 assembly language program</li>&#13;
				<li lang="en-GB">TC1 postscript</li>&#13;
			</ul>&#13;
			<p lang="en-GB">By the end of this chapter, you should understand how a simulator is designed and be able to create one. The following two chapters concentrate on expanding the simulator and providing more facilities, such as error detection in the input.</p>&#13;
			<h1 id="_idParaDest-93" lang="en-GB"><a id="_idTextAnchor093"/>Technical requirements</h1>&#13;
			<p lang="en-GB">You can find the programs used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06</a>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In order to construct a Python-based simulator, you need the same tools used in earlier chapters; that is, you require an editor to create the Python program and a Python interpreter. These are included in the freely available Python package we introduced in <a href="B19624_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>.</p>&#13;
			<h1 id="_idParaDest-94" lang="en-GB"><a id="_idTextAnchor094"/>Analyzing instructions</h1>&#13;
			<p lang="en-GB">In this section, we will look <a id="_idIndexMarker333"/><a id="_idIndexMarker334"/>at the way in which we take a text string representing an assembly language instruction and process it to create binary code that can be executed by the simulator.</p>&#13;
			<p lang="en-GB">Interestingly, the assembler can be more complicated than the actual simulator. Indeed, we devote relatively little space to the simulator itself in this chapter. We don’t actually need an assembler, because it’s easy to hand-translate assembly-level <a id="_idIndexMarker335"/><a id="_idIndexMarker336"/>operations into binary code; it’s just a matter of filling in the fields of the 32-bit instruction format. For example, <em class="italic">load register R7 with the literal value 42</em> can be written as <code>LDRL</code> <code>R7</code>,<code>42</code>. This has a 7-bit opcode, <code>01 </code><code>01010</code>, the destination register is <code>r7</code> (code <code>111</code>), the two source registers are not used, and their fields can both be set to <code>000</code>. The literal is <code>42</code>, or <code>0000000000101010</code> as a 16-bit binary value. The binary-encoded instruction is as follows:</p>&#13;
			<p lang="en-GB">0001010111<code>000000</code>0000000000101010</p>&#13;
			<p lang="en-GB">It’s easy to translate code by hand, but it’s no fun. We are going to create an assembler that automates the process of translation and lets you use symbolic names rather than actual literals (constants). Consider the following example of assembly language code. This is written using <em class="italic">numeric values</em> (shaded), rather than symbolic names. This is not intended to be a specific assembly language; it is designed to illustrate the basic concepts:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        LDRL <strong class="bold">R0</strong>,60              @ Load R0 with the time factor, 60&#13;
        .&#13;
        CMP  <strong class="bold">R3</strong>,R5              @ Compare R3 and R5&#13;
        BEQ  1                  @ If equal, jump to next-but-one instruction&#13;
        ADD  <strong class="bold">R2</strong>,R2,4&#13;
        SUB  <strong class="bold">R7</strong>,R1,R2</pre>&#13;
			<p lang="en-GB">In the following example, literals have been replaced with symbolic names. These are shaded:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Minutes EQU  60                 @ Set up a constant&#13;
Test    EQU  4&#13;
.       LDRL <strong class="bold">R0</strong>,Minutes         @ Load R0 with the time factor&#13;
.       CMP  <strong class="bold">R3</strong>,R5&#13;
        BEQ  Next&#13;
        ADD  <strong class="bold">R2</strong>,R2,Test&#13;
Next    SUB  <strong class="bold">R7</strong>,R1,R2</pre>&#13;
			<p lang="en-GB">Python’s dictionary structure makes the handling of symbolic names very easy indeed. The preceding shows the processing of a text file containing the assembly language. This file is called <code>sFile</code> and is simply a <code>.txt</code> file containing the assembly language instructions.</p>&#13;
			<h2 id="_idParaDest-95" lang="en-GB"><a id="_idTextAnchor095"/>Processing the input</h2>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We will now look at how the raw<a id="_idIndexMarker337"/><a id="_idIndexMarker338"/> input – that is, the text file containing the assembly language source code – can be processed. In principle, it would be nice to have a source file where the assembly language instructions were all perfectly formatted and laid out.</p>&#13;
			<p lang="en-GB">In reality, a program may not be formatted ideally; for example, there may be blank lines or program comments that need to be ignored.</p>&#13;
			<p lang="en-GB">We have designed this assembly language to allow considerable latitude in the writing of a TC1 program. In fact, it allows a free format that is not implemented by most real assemblers. We took this approach for several reasons. First, it demonstrates how to perform text processing, which is a fundamental part of the design of assemblers. Second, a free format means you don’t have to remember whether to use uppercase or lowercase names and labels.</p>&#13;
			<p lang="en-GB">Some languages are case-sensitive <a id="_idIndexMarker339"/><a id="_idIndexMarker340"/>and some are not. The assembly language we have designed is <em class="italic">case-insensitive</em>; that is, you can write either <code>ADD </code>r0<code>,r1,r2</code> or <code>ADD </code>R0<code>,R1,R2.</code> Consequently, we can write the load register immediate assembly instruction in all the following forms to execute a <em class="italic">load </em><em class="italic">register-indexed</em> operation:</p>&#13;
			<p lang="en-GB"><code>LDRI </code><code>R2,[R1],10 </code>or</p>&#13;
			<p lang="en-GB"><code>LDRI </code><code>R2,r1,10 </code>or</p>&#13;
			<p lang="en-GB"><code>LDRI </code><code>R2,[R1,10] </code>or<code>,</code></p>&#13;
			<p lang="en-GB"><code>LDRI r2,r1,10</code></p>&#13;
			<p lang="en-GB">This level of freedom of notation is possible because the <code>[]</code> brackets are not actually necessary to identify the instruction; they are used in programs because programmers associate <code>[r0]</code> with indirect addressing. In other words, the brackets are there for the programmer, not the computer, and are redundant.</p>&#13;
			<p lang="en-GB">However, this level of freedom is not necessarily desirable because it could lead to errors and make it more difficult for one person to read another person’s program. All design decisions come with pros and cons.</p>&#13;
			<p lang="en-GB">The following Python example includes a short embedded assembly language program. The Python code has been designed so that you can use either an assembly language program that is part of the assembler (this is just for testing and debugging purposes because it avoids having to go into a text editor every time you want to test a feature) or a program in text form on disk. In this example, we located the test program at <code>E\:testCode.txt</code> on my computer. When the demonstration text-processing code runs, it asks you whether the code is to come from disk or is the embedded code. Typing <code>d</code> reads the disk, and entering any other input reads the embedded code.</p>&#13;
			<p lang="en-GB">The filename of the assembly language program is <code>testCode = 'E://testCode.txt'</code>. A double backslash is used instead of the conventional filenaming convention in Python programs.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The text-processing program removes blank lines, converts text into uppercase (allowing you to write <code>r0</code> or <code>R0</code>), and lets you use a comma or a space as a separator (you can write <code>ADD R0,R1,R2</code> or <code>ADD r0 r1 r2</code>). We also remove surplus spaces before and after the instruction. The final result is a tokenized list; that is, <code>ADD r0,r1,r2</code> is converted into the <code>['ADD','R0','R1','R2']</code> list. Now, the assembler can look up the instruction and then extract the information it requires (register numbers and literals).</p>&#13;
			<p lang="en-GB">In the following program, we used a new variable every time we processed a line in order to help you keep track of variables. The following is an example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile2 = [i.upper() for i in sFile1]          # Convert in to uppercase&#13;
sFile3 = [i.split('@')[0] for i in sFile2]    # Remove comments</pre>&#13;
			<p lang="en-GB">We’ve used different variable names for clarity. Normally, you would write:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile = [i.upper() for i in sFile]            #&#13;
sFile = [i.split('@')[0] for i in sFile]      #</pre>&#13;
			<p lang="en-GB">We use file comprehension to remove comments in the code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile3 = [i.split('@')[0] for i in sFile2]    # Remove comments</pre>&#13;
			<p lang="en-GB">This is a rather clever trick and requires explanation. It copies each line of <code>sFile2</code> to <code>sFile3</code>. However, the value copied for each line is <code>i.split('@')[0]</code>, where <code>i</code> is the<a id="_idIndexMarker341"/><a id="_idIndexMarker342"/> current line. The <code>split('@')</code> method divides the list into strings using <code>'@'</code> as a divider. If there is no <code>'@'</code> in the original string, the string is copied. If there is an <code>'@'</code>, it is copied as two strings; for example, <code>ADD R1,R2,R3 @ Sum the totals</code> is copied to <code>sFile3</code> as <code>'ADD R1,R2,R3','@ Sum the totals'</code>. However, only the first element of the list is copied because of the <code>[0]</code> index; that is, only <code>'ADD R1,R2,R3'</code> is copied and the comment is removed.</p>&#13;
			<p lang="en-GB">The text input processing block is given here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
testCode = 'E://testCode.txt'&#13;
altCode  = ['nop', 'NOP 5', 'add R1,R2','', 'LDR r1,[r2]', \&#13;
            'ldr r1,[R2]','\n', 'BEQ test @www','\n']&#13;
x = input('For disk enter d, else any character ')&#13;
if x == 'd':&#13;
    with open(testCode, 'r') as source0:&#13;
         source = source0.readlines()&#13;
    source = [i.replace('\n','') for i in source]&#13;
else:    source = altCode&#13;
print('Source code to test is',source)&#13;
sFile0 = []&#13;
for i in range(0,len(source)):                # Process the source file in list sFile&#13;
    t1 =  source[i].replace(',',' ')          # Replace comma with space&#13;
    t2 =  t1.replace('[',' ')                 # Remove [ brackets&#13;
    t3 =  t2.replace(']',' ')                 # Remove ] brackets&#13;
    t4 =  t3.replace('  ',' ')                # Remove any double spaces&#13;
    sFile0.append(t4)                         # Add result to source file&#13;
sFile1= [i for i in sFile0 if i[-1:]!='\n']   # Remove end-of-lines&#13;
sFile2= [i.upper() for i in sFile1]           # All uppercase&#13;
sFile3= [i.split('@')[0] for i in sFile2]     # Remove comments with @&#13;
sFile4= [i.rstrip(' ') for i in sFile3 ]      # Remove trailing spaces&#13;
sFile5= [i.lstrip(' ') for i in sFile4 ]      # Remove leading spaces&#13;
sFile6=[i for i in sFile5 if i != '']         # Remove blank lines&#13;
print ('Post-processed output',  sFile6)</pre>&#13;
			<p lang="en-GB">The following are two examples of using this code. In the first case, the user input is <code>d</code>, indicating a disk program, and in the second case, the<a id="_idIndexMarker343"/><a id="_idIndexMarker344"/> input is <code>x</code>, indicating the use of the embedded source program. In each case, the course and output values are <a id="_idIndexMarker345"/><a id="_idIndexMarker346"/>printed to demonstrate the string-processing operations.</p>&#13;
			<h3 lang="en-GB">Case 1 – Disk input</h3>&#13;
			<pre class="source-code" lang="en-GB">&#13;
For disk enter d, else any character d&#13;
Source code to test is ['diskCode', 'b', 'add r1,r2,[r3]', '', 'ADD r3 @test', ' ', 'r2,,r3', ' ', 'gg']&#13;
Post-processed output ['DISKCODE', 'B', 'ADD R1 R2 R3', 'ADD R3', 'R2 R3', 'GG']</pre>&#13;
			<h3 lang="en-GB">Case 2 – Using the embedded test program</h3>&#13;
			<pre class="source-code" lang="en-GB">&#13;
For disk enter d, else any character x&#13;
Source code to test is ['nop', 'NOP 5', 'add R1,R2', '', 'LDR r1,[r2]', 'ldr r1,[R2]', '\n', 'BEQ test @www', '\n']&#13;
Post-processed output ['NOP', 'NOP 5', 'ADD R1 R2', 'LDR R1 R2', 'LDR R1 R2', 'BEQ TEST']</pre>&#13;
			<p lang="en-GB">The preceding code does not represent an <a id="_idIndexMarker347"/><a id="_idIndexMarker348"/>optimum text-processing system. It was designed to demonstrate the basic process involved in manipulating text before you process it. However, these concepts will appear again in TC1.</p>&#13;
			<h3 lang="en-GB">Dealing with Mnemonics</h3>&#13;
			<p lang="en-GB">What’s in a name? How do we know<a id="_idIndexMarker349"/><a id="_idIndexMarker350"/> that a <code>NOP</code> instruction stands alone, but an <code>ADD</code> instruction requires three registers? In this section, we begin a discussion of how assembly language instructions are processed in order to extract their meaning (i.e., convert them into binary form).</p>&#13;
			<p lang="en-GB">Consider the following fragment of TC1 assembly language:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">ADD</strong>  R1,R3,R7        @ Three operands (three registers)&#13;
<strong class="bold">NOP</strong>                  @ No operands&#13;
<strong class="bold">LDRL</strong> R4,27           @ Two operands (register and a literal value)</pre>&#13;
			<p lang="en-GB">When the assembler reads a line, it needs to know how to deal with the opcode and its operands. So, how does it know how to proceed? We can use Python’s dictionary facility to solve this problem in a very simple way, by just looking in a table to see what information an opcode requires.</p>&#13;
			<p lang="en-GB">Recall that a dictionary is a set or collection of items, where each item has two components; for example, an English-German dictionary has items that consist of an English word and its German equivalent. The word you look up is called a <em class="italic">key</em> and that provides a <em class="italic">value</em>. For example, in the English-German dictionary, the item <code>'town':'Stadt'</code> consists of the key <code>town</code> and the value <code>Stadt</code>. A dictionary is a fancy name for a <em class="italic">look-up table</em>.</p>&#13;
			<p lang="en-GB">A dictionary in Python is defined by its punctuation (i.e., it doesn’t require any special reserved Python words); it’s a type of list enclosed by curly braces, <code>{}</code>. Each list item consists of a key and its value separated with a colon. Successive items are separated with commas, exactly as in a list.</p>&#13;
			<p lang="en-GB">A <em class="italic">key</em> is used to access the appropriate value in a dictionary. In TC1, the key is the <em class="italic">mnemonic</em> used to look up the details of the instruction. Let’s create a<a id="_idIndexMarker351"/><a id="_idIndexMarker352"/> dictionary called <code>codes</code> with three keys that are strings representing valid TC1 instructions: <code>STOP</code>, <code>ADD</code>, and <code>LDRL</code>. This dictionary can be written as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
codes = {'STOP':P, 'ADD':Q, 'LDRL':R}               # P, Q, R are variables</pre>&#13;
			<p lang="en-GB">Each key is a string terminated by a colon, followed by its value. The key doesn’t have to be a string. In this case, it’s a string because we are using it to look up mnemonics, which are text strings. The first <code>key:value</code> pair is <code>'STOP':P</code> , where <code>'STOP'</code>is the key and <code>P</code> is its value. Suppose we want to know whether <code>ADD</code> is a legal instruction (i.e., in the dictionary). We can test whether this instruction (i.e., key) is in the dictionary with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if 'ADD' <strong class="bold">in</strong> codes:  # Test whether 'ADD' is a valid mnemonic in the dictionary</pre>&#13;
			<p lang="en-GB">This returns <code>True</code> if the key is in the dictionary, and <code>False</code> otherwise. You can use <code>not in</code> to test whether something is <em class="italic">not</em> in a dictionary.</p>&#13;
			<p lang="en-GB">Python allows a key to be associated with any valid object, for example, a list. We could write, for example, the following <code>key:value</code> pair:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
 'ADD': [3, 0b1101001, 'Addition', '07/05/2021', timesUsed]</pre>&#13;
			<p lang="en-GB">Here, the value associated with a key is a five-element list that associates the <code>ADD</code> mnemonic with the number of its operands, its binary encoding, its name, the date it was designed, and the number of times it was used in the current program (as well as being able to read a value from a dictionary, you can write to it and update it).</p>&#13;
			<p lang="en-GB">The following code sets up a dictionary that binds mnemonics to variables (preset to integers <code>1,2,3,4</code>):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
P,Q,R,N = 1,2,3,4                                   # Set up dummy opcodes&#13;
validCd = {'STOP':P, 'ADD':Q, 'LDRL':R, 'NOP':N}    # Dictionary of codes&#13;
x = input('Please enter a code  ')                  # Request an opcode&#13;
if x not in validCd:                                # Check dictionary for errors&#13;
    print('Error! This is not valid')&#13;
if x in validCd:                                    # Check for valid opcode&#13;
    print('Valid op ', <strong class="bold">validCd.get(x)</strong>)              # If found, read its value</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this example, we used the <code>get()</code> method to read the value associated with a key. If the key is <code>x</code>, its value is given by <code>validCd.get(x)</code>; that is, the syntax is <code>dictionaryName.get(key)</code>.</p>&#13;
			<p lang="en-GB">Assembly language contains instructions that are executed. However, it also contains information called <em class="italic">assembler directives</em> that tells the program something about the environment; for example, where to put data in memory or how to bind symbolic names to values. We will now look at assembler directives.</p>&#13;
			<h1 id="_idParaDest-96" lang="en-GB"><a id="_idTextAnchor096"/>Dealing with assembler directives</h1>&#13;
			<p lang="en-GB">In this section, we will learn<a id="_idIndexMarker353"/><a id="_idIndexMarker354"/> about the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">What assembler directives do</li>&#13;
				<li lang="en-GB">How to create a symbol table linking symbolic names to values</li>&#13;
				<li lang="en-GB">How to access the symbol table</li>&#13;
				<li lang="en-GB">How to update the symbol table</li>&#13;
				<li lang="en-GB">Processing labels</li>&#13;
			</ul>&#13;
			<p lang="en-GB">We will demonstrate how the names the programmer chooses are manipulated and translated into their appropriate numerical values.</p>&#13;
			<p lang="en-GB">The first version of TC1 required you to provide actual values for all names and labels. If you wanted to jump to an instruction, you had to provide the number of lines to jump. It’s much better to allow the programmer to write the following:</p>&#13;
			<p lang="en-GB"><code>JMP next</code></p>&#13;
			<p lang="en-GB">Here, <code>next</code> is the label of the target line. This is preferred over writing the following:</p>&#13;
			<p lang="en-GB"><code>JMP 21</code></p>&#13;
			<p lang="en-GB">Similarly, if the literal <code>60</code> represents minutes in an hour, write the following:</p>&#13;
			<p lang="en-GB"><code>MULL </code><code>,R1,MINUTES</code></p>&#13;
			<p lang="en-GB">This is preferred over the following:</p>&#13;
			<p lang="en-GB"> <code>MULL </code><code>,R1,60</code></p>&#13;
			<p lang="en-GB">We need a means of <em class="italic">linking</em> <code>next</code> with <code>21</code> and <code>MINUTES</code> with <code>60</code>.</p>&#13;
			<p lang="en-GB">Python’s <em class="italic">dictionary</em> structure solves this problem. We simply create <code>key:value</code> pairs, where <code>key</code> is the label that we want to define and <code>value</code> is its value. In this example, a dictionary for the preceding example would be <code>{'NEXT':21, 'MINUTES':60}</code>. Note this example uses <em class="italic">integers</em> as values. In this book, we will also use <em class="italic">strings</em> as values, because we input data in text form; for example, <code>'MINUTES':'60'</code>.</p>&#13;
			<p lang="en-GB">The <code>EQU</code> assembler directive equates a value with a symbolic name. For example, TC1 lets you write the following:</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>MINUTES </code><code>EQU 60</code></p>&#13;
			<h2 id="_idParaDest-97" lang="en-GB"><a id="_idTextAnchor097"/>Using the dictionary</h2>&#13;
			<p lang="en-GB">The <code>MINUTES EQU 60</code> assembler <a id="_idIndexMarker355"/><a id="_idIndexMarker356"/>directive has three tokens: a label, a function (equate), and a value. We extract the <code>'MINUTES':60</code> dictionary pair from the source code and insert it into a dictionary called <code>symbolTab</code>. The following code demonstrates the procedure. The first line sets up a symbol table. We initialize it with a dummy entry, <code>'START':0</code>. We’ve created this initial entry for testing purposes:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
symbolTab = {'START':0}                              # Symbol table for labels&#13;
for i in range (0,len(sFile)):                       # Deal with equates&#13;
    if len(sFile[i]) &gt; 2 and sFile[i][1] == 'EQU':   # Is token 'EQU'?&#13;
        symbolTab[sFile[i][0]] = sFile[i][2]         # If so, update table&#13;
sFile = [i for i in sFile if i.count('EQU') == 0]    # Delete EQU from source</pre>&#13;
			<p lang="en-GB">The <code>for</code> loop (shaded) reads each line of the source code, <code>sFile</code>, and tests for lines where <code>'EQU'</code> is the second token in the line. The <code>len(sFile[i]) &gt; 2</code> comparison ensures that this line has at least three tokens to ensure it’s a valid equate directive. The text is in bold font.</p>&#13;
			<p lang="en-GB">We can perform two tests together by employing an <code>and</code> Boolean operator so that the test is true only if both conditions are true.</p>&#13;
			<p lang="en-GB">We check that the second token is <code>'EQU'</code> with <code>sFile[i][1] == 'EQU'</code>. The <code>sFile</code>[i][1] notation has two list indexes. The first, in bold, indicates line <code>i</code> of the source code, and the second index indicates token 1 of that line; that is, it is the second element.</p>&#13;
			<p lang="en-GB">If <code>'EQU'</code> is found, we add (i.e., insert) the first token,<code>[</code>sFile[i][0]<code>]</code>, into the symbol table as the key, and the third token, sFile[i][2], as the value.</p>&#13;
			<p lang="en-GB">Consider the <code>MINUTES EQU 60</code> source code line.</p>&#13;
			<p lang="en-GB">The key is <code>sFile[i][0]</code> and its value is <code>sFile[i][2]</code>, because <code>MINUTES</code> is the first token on line <code>i</code> and <code>60</code> is the third token on line <code>i</code>. The stored key is <code>'MINUTES'</code> and its value is <code>60</code>. But note that the value <code>60</code> is in <em class="italic">string</em> form and not <em class="italic">integer</em> form. Why? Because the assembler directive is a string and not an integer. If we want the numeric value, we have to use <code>int()</code>.</p>&#13;
			<p lang="en-GB">The final line of this block of code is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile = [i for i in sFile if i.count('EQU') == 0]</pre>&#13;
			<p lang="en-GB">This line uses a list comprehension to scan the source file and delete any line with <code>EQU</code>, because only instructions are loaded in program memory. A line containing <code>EQU</code> is a directive and not an instruction. This operation uses the count method, <code>i.count('EQU')</code>, to count the number of times <code>EQU</code> appears in a line, and then deletes that line if the count isn’t <code>0</code>. The condition we test for before moving (i.e., keeping) a line is as follows:</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>if i.count('EQU') == </code><code>0:</code></p>&#13;
			<p lang="en-GB">Here, <code>i</code> is the current line being processed. The <code>count</code> method is applied to the current line and counts the number of occurrences of the <code>'EQU'</code> string in the line. Only if the count is <code>0</code> (i.e., it isn’t a line with an <code>EQU</code> directive) does that line get copied into <code>sFile</code>.</p>&#13;
			<p lang="en-GB">Because detecting an <code>EQU</code> <a id="_idIndexMarker357"/><a id="_idIndexMarker358"/>directive, putting it in the symbol table, and removing it from the code are so important, we will demonstrate its operation with a little piece of test code. The following code fragment sets up a list of three instructions in <code>sFile</code> to test. Remember that <code>sFile</code> is a list of lists and each list is an instruction composed of tokens, each of which is a string:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile=[['test','EQU','5'],['not','a','thing'],['xxx','EQU','88'], \&#13;
       ['ADD','r1','r2','r3']]&#13;
print('Source: ', sFile)&#13;
<strong class="bold">symbolTab = {}</strong>                                    # Creates empty symbol table&#13;
<strong class="bold">for i in range (0,len(sFile)):</strong>                    # Deal with equates e.g., PQR EQU 25&#13;
    print('sFile[i]', sFile[i])&#13;
    <strong class="bold">if len(sFile[i]) &gt; 2 and sFile[i][1] == 'EQU':</strong>  # Is the second token 'EQU'?&#13;
        <strong class="bold">print('key/val', sFile[i][0], sFile[i][2])</strong>  # Display key-value pair&#13;
        <strong class="bold">symbolTab[sFile[i][0]] = sFile[i][2]</strong>        # Now update symbol table&#13;
<strong class="bold">sFile = [i for i in sFile if i.count('EQU') == 0]</strong>   # Delete equates from source file&#13;
print('Symbol table: ', symbolTab)&#13;
print('Processed input: ',sFile)</pre>&#13;
			<p lang="en-GB">The code in bold is the code we’ve discussed. The remaining code is made up of <code>print</code> statements used to observe the code’s behavior. The key line in this code is as follows:</p>&#13;
			<p lang="en-GB"><code>symbolTab[sFile[i][0]] = </code><code>sFile[i][2]</code></p>&#13;
			<p lang="en-GB">This updates the symbol table by adding a <code>key:value</code> pair in the following format:</p>&#13;
			<p lang="en-GB"><code>symbolTab[key] = </code><code>value</code></p>&#13;
			<p lang="en-GB">When this code is run, it generates the following output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Source [['test','EQU','5'],['not','a','thing'],['xxx','EQU','88'], ['ADD','r1','r2','r3']]&#13;
sFile[i] ['test', 'EQU', '5']&#13;
key/val test 5&#13;
sFile[i] ['not', 'a', 'thing']&#13;
sFile[i] ['xxx', 'EQU', '88']&#13;
key/val xxx 88&#13;
sFile[i] ['ADD', 'r1', 'r2', 'r3']&#13;
<strong class="bold">Symbol table {'test': '5', 'xxx': '88'}</strong>&#13;
<strong class="bold">Processed input [['not', 'a', 'thing'], ['ADD', 'r1', 'r2', 'r3']]</strong></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The final two lines give the symbol table and the post-processed version of <code>sFile</code>. The two equates have been loaded into the dictionary (symbol table) and the processed output has had the two equates stripped.</p>&#13;
			<p lang="en-GB">There are several ways to add new <code>key:value</code> pairs to a dictionary. We could have applied the <code>update</code> method to <code>symbolTab</code> and written the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
symbolTab.update({<strong class="bold">[sFile[i][0]]:sFile[i][2]</strong>})</pre>&#13;
			<p lang="en-GB">In a later example of an assembler, we will adopt a different convention for assembler directives and use the format .<code>equ name value</code> because this convention is adopted by ARM processors, as we’ll see in later chapters. There is often more than <a id="_idIndexMarker359"/><a id="_idIndexMarker360"/>one way of representing assembly directives, each with its own advantages and disadvantages (e.g., ease of coding or fitting in with particular standards and conventions).</p>&#13;
			<h2 id="_idParaDest-98" lang="en-GB"><a id="_idTextAnchor098"/>Labels</h2>&#13;
			<p lang="en-GB">The next step in processing the source file is to deal <a id="_idIndexMarker361"/><a id="_idIndexMarker362"/>with labels. Take the following example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      DEC  r1                                   @ Decrement r1&#13;
      BEQ  <strong class="bold">NEXT1</strong>                                @ If result in r1 is 0, then jump to line NEXT1&#13;
      INC  r2                                   @ If result not 0, increment r2&#13;
      .&#13;
<strong class="bold">NEXT1</strong> .</pre>&#13;
			<p lang="en-GB">In this example, the decrement operation subtracts <code>1</code> from the contents of register <code>r1</code>. If the result is <code>0</code>, the <code>Z flag</code> is set. The next instruction is <em class="italic">branch on zero to NEXT1</em>. If <em class="italic">Z = 1</em>, a jump is made to the line labeled <code>NEXT1</code>; otherwise, the <code>INC r2</code> instruction immediately following <code>BEQ</code> is executed.</p>&#13;
			<p lang="en-GB">The binary program (machine code) generated by TC1 does not store or use labels. It requires either the actual address of the next instruction or its relative address (i.e., how far it needs to jump from the current location). In other words, we need to translate the <code>NEXT1</code> label into its actual address in the program.</p>&#13;
			<p lang="en-GB">This is a job for the dictionary. All we have to do is put a label in the dictionary as a key and then insert the corresponding address as the value associated with the key. The following three lines of Python demonstrate how we collect label addresses and put them in the symbol table:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
1. for i in range(0,len(sFile)):                  # Add branch addresses to symbol tab&#13;
2.     if sFile[i]<strong class="bold">[0]</strong> not in codes:               # If first token not an opcode, it's a label&#13;
3.        symbolTab.update({<strong class="bold">sFile[i][0]:str(i)</strong>})  # Add pc value, i to sym tab as string&#13;
4. print('\nEquate and branch table\n')           # Display symbol table&#13;
5. for x,y in symbolTab.items():                  # Step through symbol table&#13;
6.     print('{:&lt;8}'.format(x),y)</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The three lines, 1 to 3, define a <code>for</code> loop that steps through every line in the source code in <code>sFile</code>. Because we’ve processed the code to convert each instruction into a list of tokens, each line begins with either a valid mnemonic or a label. All we have to do is check whether the first token on a line is in the list (or dictionary) of mnemonics. If the first token is in the list, it’s an instruction. If it’s not in the list, then it’s a label (we are ignoring the case that it’s an error).</p>&#13;
			<p lang="en-GB">We perform the check for a valid mnemonic with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
2. if sFile[i][0] <strong class="bold">not in</strong> codes:</pre>&#13;
			<p lang="en-GB">Here, <code>sFile[i][0]</code> represents the first item (i.e., token) of line <code>i</code> in the dictionary of mnemonics. The <code>not in</code> Python code returns <code>True</code> if the mnemonic is not in the dictionary called <code>codes</code>. If the test does return <code>True</code>, then we have a label and must put it in the symbol table with the following operation:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
3. symbolTab.update({sFile[i][0]<strong class="bold">:str(i)</strong>})                  # i is the pc value</pre>&#13;
			<p lang="en-GB">This expression says, “<em class="italic">Add the specified </em><code>key:value</code><em class="italic"> pair to the dictionary called </em><code>symbolTable</code><em class="italic">.</em>” Why is the value associated with the label given as <code>i</code>? The <a id="_idIndexMarker363"/><a id="_idIndexMarker364"/>value associated with the label is the address of that line (i.e., the value of the program counter, <code>pc</code>, when that line is executed). Since we are stepping through the source code line by line, the counter, <code>i</code>, is the corresponding value of the program counter.</p>&#13;
			<p lang="en-GB">The <code>update</code> method is applied to the symbol table with sFile[i][0] as the key and <code>str(i)</code> as the value. The key is sFile[i][0], which is the label (i.e., a string). However, the <em class="italic">value</em> of <code>i</code> is not a <em class="italic">string</em>. The value is an <em class="italic">integer</em>, <code>i</code>, which is the current line address. We convert the integer address into a string with str(i) because equates are stored in the table as strings (i.e., this is a design decision made by me).</p>&#13;
			<p lang="en-GB">The next two lines print the symbol table:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
4. print('\nEquate and branch table\n')                    # Display symbol table&#13;
5. for x,y in symbolTab.items(): print('{:&lt;8}'.format(x),y) # Step through symbol table</pre>&#13;
			<p lang="en-GB">The value of the symbol table is printed using a <code>for</code> loop. We extract a <code>key:value</code> pair by using the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
5. for x,y in symbolTab<strong class="bold">.items():</strong></pre>&#13;
			<p lang="en-GB">The items() method steps through all the elements of the <code>symbolTab</code> dictionary and allows us to print each <code>key:pair</code> value (i.e., all names/labels and their values). The <code>print</code> statement displays eight characters, right justified, by using <code>{:&lt;8}.format(x)</code> to format the value of <code>x</code>.</p>&#13;
			<p lang="en-GB">Having decoded an instruction, we next have to convert it into the appropriate binary code.</p>&#13;
			<h1 id="_idParaDest-99" lang="en-GB"><a id="_idTextAnchor099"/>Building the binary instruction</h1>&#13;
			<p lang="en-GB">The next step in the assembly process is to <a id="_idIndexMarker365"/><a id="_idIndexMarker366"/>generate the appropriate binary pattern for each instruction. In this section, we show how the components of an instruction are put together to create a binary value that can later be executed by the computer.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Note that the code in this section describes some of the instruction processing involved in analyzing instructions. The actual simulator differs in minor details, although the principles are the same.</p>&#13;
			<p lang="en-GB">We first have to extract the mnemonic, convert it into binary, then extract the register numbers (where appropriate), and finally, insert the 16-bit literal. Moreover, because the assembler is in text form, we have to be able to deal with literals that are symbolic (i.e., they are names rather than numbers), decimal, negative, binary, or hexadecimal; that is, we have to handle instructions of the following form:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
LDRL <strong class="bold">r0</strong>,24                   @ Decimal numeric value&#13;
LDRL <strong class="bold">r0</strong>,0xF2C3               @ Hexadecimal numeric value&#13;
LDRL <strong class="bold">r0</strong>,$F2C3                @ Hexadecimal numeric value (alternative representation)&#13;
LDRL <strong class="bold">r0</strong>,%00110101            @ Binary numeric value&#13;
LDRL <strong class="bold">r0</strong>,0b00110101           @ Binary numeric value (alternative representation)&#13;
LDRL <strong class="bold">r0</strong>,-234                 @ Negative decimal numeric value&#13;
LDRL <strong class="bold">r0</strong>,ALAN2                @ Symbolic value requiring symbol table look-up</pre>&#13;
			<p lang="en-GB">The assembler looks at each line of the source code and extracts the mnemonic. An instruction is a list of tokens (e.g., <code>'NEXT'</code>, <code>'ADD'</code>, <code>'r1'</code>, <code>'r2'</code>, <code>'0x12FA'</code>, which is five tokens, or <code>'STOP'</code>, which is one token). The situation is made more complex because the mnemonic may be the <em class="italic">first</em> token, or the <em class="italic">second</em> token if the instruction has a label. In the <a id="_idIndexMarker367"/><a id="_idIndexMarker368"/>following example, <code>sFile</code> contains the program as a list of instructions, and we are processing line <code>i</code>, <code>sFile[i]</code>. Our solution is as follows:</p>&#13;
			<ol>&#13;
				<li lang="en-GB">Read the first token, <code>sFile[i][0]</code>. If this token is in the list of codes, then it’s an instruction. If it is not in the list of codes, it’s a label, and the second token, <code>sFile[i][1]</code>, is the instruction.</li>&#13;
				<li lang="en-GB">Get the instruction details. These are stored in a dictionary called <code>codes</code>. If the mnemonic is in the dictionary, the key returns a tuple with two components. The first component is the format of the instruction, which defines the required operands in the sequence <code>rD</code>, <code>rS1</code>, <code>rS2</code>, <code>literal</code>; for example, the code <code>1001</code> indicates an instruction with a destination register and a literal. The second component of the tuple is the value of the opcode. We use a decimal value for this (ideally, it should be binary for the sake of readability, but binary values were too long and made the text harder to read).</li>&#13;
				<li lang="en-GB">Read the register numbers from the tokens in the instruction; for example, <code>ADD</code> <code>r3</code>,<code>r2</code>,<code>r7</code> would return <code>3</code>,<code>2</code>,<code>7</code>, whereas <code>NOP</code> would return <code>0</code>,<code>0</code>,<code>0</code> (if a register field is not used, it is set to <code>0</code>).</li>&#13;
				<li lang="en-GB">Read any literal and convert it into a 16-bit integer. This is the most complex operation because the literal may have one of the seven different formats described previously.</li>&#13;
				<li lang="en-GB">The discussion in this section refers to the TC1 program that is presented in full at the end of the chapter. Here, we present slices of that program and explain how they work and the steps in the assembly process.</li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-100" lang="en-GB"><a id="_idTextAnchor100"/>Extracting the instruction and its parameters</h2>&#13;
			<p lang="en-GB">The following fragment of code <a id="_idIndexMarker369"/><a id="_idIndexMarker370"/>shows the beginning of the loop that scans the source code and creates the binary value. This code initializes variables, extracts the opcode as a mnemonic, extracts any labels, extracts the parameters required by the mnemonic, and looks up the opcode and its format:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for i in range(0,len(sFile)):                     # Assembly loop reads instruction&#13;
    opCode,label,literal,predicate = [],[],[],[]  # Initialize opcode, label, literal, predicate&#13;
    rD, rS1, rS2  = 0, 0, 0                       # Clear register-select fields to zeros&#13;
    if sFile[i][0] in codes: <strong class="bold">opCode = sFile[i][0]</strong>   # If first token is a valid opcode, get it&#13;
    else:                    opCode = sFile[i][1]   # If not, then opcode is second token&#13;
    if (sFile[i][0] in codes) and (len(sFile[i]) &gt; 1): # If opcode valid and length &gt; 1&#13;
        predicate = sFile[i][1:]&#13;
    else:&#13;
        if len(sFile[i]) &gt; 2: predicate = sFile[i][2:] \&#13;
                                              # Lines with a label longer than 2 tokens&#13;
    form = codes.get(opCode)                  # Use mnemonic to read instruction format&#13;
    if form[0] &amp; 0b1000 == 0b1000:            # Bit 4 of format selects destination register rD&#13;
    if predicate[0] in symbolTab:                 # If first token in symbol tab, it's a label&#13;
            rD = int(symbolTab[predicate[0]][1:]) # If it is a label, then get its value</pre>&#13;
			<p lang="en-GB">Lines 2 and 3 in the loop declare and initialize the variables and provide default values.</p>&#13;
			<p lang="en-GB">The first <code>if…else</code> statement <a id="_idIndexMarker371"/><a id="_idIndexMarker372"/>on line 4 looks at the first<a id="_idIndexMarker373"/><a id="_idIndexMarker374"/> token on line <code>i</code> of the source code, <code>sFile[i][0]</code>. If that token is in the <code>codes</code> dictionary, then <code>sFile[i][0]</code> is the opcode. If it isn’t in the dictionary, then that token must be a label and the second token is the opcode (lines 4 and 5):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
4.    if sFile[i][0] in codes: opcode = sFile[i][0] # If first token is a valid opcode, get it&#13;
5.    <strong class="bold">else:                    opCode = sFile[i][1]</strong> # If not, then it's the second token</pre>&#13;
			<p lang="en-GB">If we encounter a label, we can convert it into its actual address, which is in <code>symbolTab</code>, using the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if sFile[i][0] in symbolTab: label = sFile[i][0] # Get label</pre>&#13;
			<p lang="en-GB">Lines 6, 7, 8, and 9 extract the predicate from the assembly language. Remember, the predicate comprises the tokens following the mnemonic and consists of any registers and literal required by the instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
6. if (sFile[i][0] in codes) and (len(sFile[i])&gt;1): # Get everything after opcode&#13;
7.                        predicate = sFile[i][1:]  # Line with opcode&#13;
8. else:&#13;
9.    if len(sFile[i])&gt;2: predicate = sFile[i][2:]  # If label and len &gt; 2 tokens</pre>&#13;
			<p lang="en-GB">We have to deal with two cases: the first token is the mnemonic and the second token is the mnemonic. We also check that the line is long enough to have a predicate. If there is a predicate, it is extracted by lines <code>7</code> and <code>9</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
7.          <strong class="bold">predicate = sFile[i][1:]</strong>     # The predicate is the second and following tokens&#13;
9.          <strong class="bold">predicate = sFile[i]</strong>[2:]     # The predicate is the third and following tokens</pre>&#13;
			<p lang="en-GB">The notation <code>[2:]</code> indicates <em class="italic">everything from token 2 to the end of the line</em>. This is a very nice feature of Python because it doesn’t require you to explicitly state the length of the line. Once we’ve extracted the predicate containing the register and literal information, we can start to assemble the instruction.</p>&#13;
			<p lang="en-GB">Next, we extract the current line’s code format to get the information required from the predicate. Line <code>10</code>, form<code> = codes.get(opCode)</code>, accesses the <code>codes</code> dictionary to look for the mnemonic, which is in the <code>opCode</code> variable. The <code>get</code> method is applied to <code>codes</code> and the <code>form</code> variable receives the key value, which is the (<code>format</code>,<code>code</code>) tuple, for example, (<code>8</code>,<code>10</code>). The <code>form[0]</code> variable is the instruction format, and <code>form[1]</code> is the opcode:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
10. form = codes.get(opCode)                    # Use opcode to read instruction format&#13;
11. if form[0] &amp; 0b1000 == 0b1000:              # Bit 3 of format selects destination reg rD&#13;
12.     if predicate[0] in symbolTab:           # Check whether first token is symbol table&#13;
13.        rD =int(symbolTab[predicate[0]][1:]) # If it's a label, then get its value</pre>&#13;
			<p lang="en-GB">The second element of the tuple, <code>form[1]</code>, gives the 7-bit opcode; that is, <code>0100010</code> for <code>LDRL</code>. Lines <code>10</code> to <code>13</code> demonstrate how the destination register is extracted. We first use <code>AND</code> <code>form[0]</code> with <code>0b1000</code> to test the most significant bit that indicates whether a destination register, <code>rD</code>, is required by this instruction. If it is required, we first test whether the <a id="_idIndexMarker375"/><a id="_idIndexMarker376"/>register is expressed in the form <code>R0</code>, or whether it’s given as a name, for example, <code>TIME</code>. We have to do this because TC1 lets you rename registers by using the <code>EQU</code> directive.</p>&#13;
			<p lang="en-GB">You can check whether an item is in the dictionary by using <code> dictionary</code>. Take the following example:</p>&#13;
			<p lang="en-GB">if <code>'INC'</code> in opCodes:</p>&#13;
			<p lang="en-GB">To obtain information about a particular mnemonic, we can use the <code>get</code> method to read the value associated with the key <code>–</code> for example, <code>format = </code><code>opCodes.get('INC')</code>.</p>&#13;
			<p lang="en-GB">The preceding example returns <code>format = (8,82)</code>. <code>8</code> refers to the format code <code>0b1000</code> (specifying a destination register). <code>82</code> is the opcode for this instruction. We access the two fields of the value associated with <code>'INC'</code> with, for example, the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binaryCode  = format[0]&#13;
formatStyle = format[1]</pre>&#13;
			<p lang="en-GB">We first test whether a register has a symbolic name in line <code>12</code> with. <code>if predicate[0]</code> in <code>symbolTab:</code> and, if it is in the symbol table, we read its value in line <code>13</code> with. </p>&#13;
			<p lang="en-GB"><code>rD = </code><code>int(symbolTab[predicate[0]][1:])</code></p>&#13;
			<p lang="en-GB">We interrogate the symbol table with a key, which is the first element of the predicate since the destination register always comes first in a TC1 assembly <a id="_idIndexMarker377"/><a id="_idIndexMarker378"/>language instruction (e.g., in <code>ADD </code>r4,<code>r7</code>,<code>r2</code>, register <code>r4</code> is the first element). The register is given by <code>predicate[0]</code>. The <code>symbolTab</code>[predicate[0]] expression looks up the symbolic name and provides its value; for example, consider <code>TIME EQU R3</code>. The <code>INC TIME</code> assembly language instruction will look up <code>TIME</code> and return <code>R3</code>. We now have the destination operand, but it is a string, <code>'R3'</code>, and not a number. We just want <code>3</code> and have to use the <code>int</code> function to convert a number in string format into an integer value.</p>&#13;
			<p lang="en-GB">Let’s simplify the Python expression to make the explanation easier. Suppose we write the following:</p>&#13;
			<p lang="en-GB"><code>destReg = </code><code>symbolTab</code>[predicate[0]]</p>&#13;
			<p lang="en-GB">The value of <code>destReg</code> is the string representing the destination register. Assume that this is <code>'R3'</code>. What we need to do is to isolate <code>'3'</code> from <code>'R3'</code> and then convert the character <code>'3'</code> into the integer <code>3</code>. We can write <code>destRegNum = destReg[1:]</code> to return all characters in the string except the initial <code>'R'</code>. The final step is to convert into an integer, which we can do with <code>rD = </code><code>int(destRegNum)</code>.</p>&#13;
			<p lang="en-GB">Remember that <code>[1:]</code> means all the characters after the first character, <code>'R'</code>. Consequently, this returns <code>'3'</code> if the register was <code>'R3'</code>. We could have written <code>[1:2]</code> rather than <code>[1:]</code> since the number is in the range 1 to 7. However, by using the <code>[1:]</code> notation, we can later increase the number of registers beyond 9 without changing the program.</p>&#13;
			<p lang="en-GB">Putting all three steps together, we get <code>rD = </code><code>int(symbolTab[predicate[0]][1:])</code>.</p>&#13;
			<p lang="en-GB">The following Python code shows<a id="_idIndexMarker379"/><a id="_idIndexMarker380"/> the entire decoding process:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
form = codes.get(opCode)                      # Use opcode to read type of instruction&#13;
if form[0] &amp; <strong class="bold">0b1000</strong> == 0b1000:                # Bit 4 of format selects destination register rD&#13;
    if predicate[0] in symbolTab:             # Check whether first token is sym tab&#13;
          rD = int(symbolTab[predicate[0]][1:])  # If it is, then get its value&#13;
    else: rD = int(predicate[0][1:])          # If it's not a label, get from the predicate&#13;
if form[0] &amp; <strong class="bold">0b0100</strong> == 0b0100:                # Bit 3 selects register source register 1, rS1&#13;
    if predicate[1] in symbolTab:&#13;
          rS1 = int(symbolTab[predicate[1]][1:])&#13;
    else: rS1 = int(predicate[1][1:])&#13;
if form[0] &amp; <strong class="bold">0b0010</strong> == 0b0010:                # Bit 2 of format selects register rS1&#13;
    if predicate[2] in symbolTab:&#13;
          rS2 = int(symbolTab[predicate[2]][1:])&#13;
    else: rS2 = int(predicate[2][1:])&#13;
if form[0] &amp; 0b0001 == 0b0001:                # Bit 1 of format indicates a literal&#13;
    if predicate[-1] in symbolTab:            # If literal in symbol table, get it&#13;
        predicate[-1] = symbolTab[predicate[-1]]&#13;
    elif type(predicate[-1]) == 'int':                                # Integer&#13;
        literal = str(literal)&#13;
    elif predicate[-1][0]    == '%':                                  # Binary&#13;
        literal=int(predicate[-1][1:],2) &#13;
    elif predicate[-1][0:2]  == '0B':                                 # Binary &#13;
        literal=int(predicate[-1][2:],2)&#13;
    elif predicate[-1][0:1]  == '$':                                  # Hex&#13;
        literal=int(predicate[-1][1:],16)&#13;
    elif predicate[-1][0:2]  == '0X':                                 # Hex&#13;
        literal=int(predicate[-1][2:],16)&#13;
    elif predicate[-1].isnumeric():                                   # Decimal&#13;
        literal=int(predicate[-1])&#13;
    elif predicate[-1][0]    == '-':                                  # Negative&#13;
        literal=(-int(predicate[-1][1:]))&amp;0xFFFF&#13;
    else:  literal = 0                                                # Default</pre>&#13;
			<p lang="en-GB">This block of code performs the same sequence of operations three times, processing <code>rD</code>, then <code>rS1</code> (the first source register), and then <code>rS2</code> (the second source register) in the same way. The last section of this block of code (shaded)) is more complicated because we allow several representations of the literal. We use an <code>if…elif</code> structure to test for a symbolic literal, a binary literal, a hexadecimal literal, an unsigned decimal numeric literal, and finally, a negative decimal numeric literal.</p>&#13;
			<p lang="en-GB">The literal is a numeric constant used by an instruction. However, in the assembly language, the literal is represented by a text string; that is, if the literal is <code>12</code>, it is the string <code>'12'</code> and not the numeric value <code>12</code>. It has to be converted into numeric form by the <code>int()</code> function.</p>&#13;
			<p lang="en-GB">We initially decided to allow decimal, binary, or hexadecimal integers. Later, we included symbolic names because they are so easy to deal with using Python’s dictionary. Suppose we have an instruction that has been tokenized into a mnemonic and a predicate that contains registers and a literal or symbolic name, for example, <code>['R1', 'R2' , 'myData']</code>. Consider the following code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if <strong class="bold">predicate[-1]</strong> in symbolTab:                 # If literal is in symbol table, look up value&#13;
   predicate[-1] = symbolTab[predicate[-1]]    # Get its value from the symbol table</pre>&#13;
			<p lang="en-GB">This takes the last element of the predicate (indicated by the <code>[-1]</code> index) and looks to see whether it’s in the symbol table. If it isn’t, the code tests for other types of literal. If it is in the symbol table, it is extracted and the <code>myData</code> symbolic name is replaced <a id="_idIndexMarker381"/><a id="_idIndexMarker382"/>with its actual value.</p>&#13;
			<p lang="en-GB">The literal in the table may be an integer or a string. The following converts it into a string if it is a literal:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">if type(predicate[-1])=='int':</strong> literal=str(literal) # Integer to string</pre>&#13;
			<p lang="en-GB">The <code>if</code> construct uses the <code>type()</code> function, which returns the type of an object. In this case, it will be <code>'int'</code> if the object is an integer. The <code>str()</code> function converts an integer object into a string object.</p>&#13;
			<p lang="en-GB">This action may seem strange because we are converting an integer (which we want) into a string (which we don’t want). The reason for this anomaly is that we are later going to test for hex, binary, and signed values that will be strings, and keeping all literals as strings simplifies the coding.</p>&#13;
			<p lang="en-GB">The following code demonstrates how three number formats are converted into integer form, ready for packing into the final 32-bit TC1 machine instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if   predicate[-1][0]   == '%':  literal = int(predicate[-1][1:],2)&#13;
elif predicate[-1][0:2  == '0B': literal = int(predicate[-1][2:],2)&#13;
elif predicate[-1][0:1] == '$':  literal = int(predicate[-1][1:],16)&#13;
elif predicate[-1][0:2] == '0X': literal = int(predicate[-1][2:],16)&#13;
elif predicate[-1].isnumeric():  literal = int(predicate[-1])</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Binary numbers are prefixed with either <code>%</code> or <code>0b</code> in the TC1 assembly language, and hexadecimal values with <code>$</code> or <code>0x</code>. The constant is tested to see whether it’s decimal, binary, or hex, and then the appropriate conversion is performed. Converting a binary string, <code>x</code>, into an integer, <code>y</code>, is done with <code>y = int(x,2)</code>. The parameter in bold is the number base. In this case, it’s <code>2</code> in binary format. In hexadecimal format, it’s 16.</p>&#13;
			<p lang="en-GB">Let’s look at the hex conversion. We have to make two selections: the token and then the specific characters of the token. Consider <code>ADDL R1,R2,0XF2A4</code>. The predicate is <code>'R1 R2 0XF2A4'</code>, which is tokenized as <code>predicate = ['R1', '</code><code>R2', '0XF2A4']</code>.</p>&#13;
			<p lang="en-GB">The value of <code>predicate[-1]</code> is <code>'</code>0XF2A4<code>'</code>. To test for a hexadecimal value, we have to look at the first two characters to see whether they are <code>'0X'</code>. Note <code>0X</code> not <code>0x</code> because TC1 converts input into uppercase. We could write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
lastToken = predicate[-1]              # Get the last token from the predicate&#13;
prefix = lastToken[0:2]                # Get the first two characters of this token to test for '0X'</pre>&#13;
			<p lang="en-GB">We can save a line by combining the two list-index suffixes, <code>[-1]</code> and <code>[0:2</code>], into <code>predicate[-1][0:2]</code>.</p>&#13;
			<p lang="en-GB">The third line of the code, <code>elif predicate[-1].isnumeric(): literal=int(predicate[-1])</code>, detects decimal strings and converts them into numeric form. Since decimal values don’t have a prefix, we use the <code>isnumeric</code> method to test for a string that has a numeric value. This line is read as, "<em class="italic">If the last token in the predicate is numeric, then convert it into an </em><em class="italic">integer value</em>."</p>&#13;
			<p lang="en-GB">Finally, we have to deal with negative numbers (e.g., -5). If a literal is prefixed with -, the remaining string is read and converted into two’s complement binary form in 16 bits. This is necessary because the TC1 computer represents signed integers in 16-bit two’s complement form.</p>&#13;
			<p lang="en-GB">The generation of the final 32-bit binary <a id="_idIndexMarker383"/><a id="_idIndexMarker384"/>code of an instruction is easy. We have an opcode and zero to four fields to insert. The fields are initially set to all zeros (the default values). Then, each field is shifted left to its required place in the instruction and inserted into the instruction by using a bit-wise <code>OR</code> operation. The code for this is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
s2      = s2      &lt;&lt; 16                # Shift source 2 16 places left&#13;
s1      = s1      &lt;&lt; 19                # Shift source 1 19 places left&#13;
destReg = destReg &lt;&lt; 22                # Shift destination register 22 places left&#13;
op      = op      &lt;&lt; 25                # Shift opcode 25 places left&#13;
binCode = lit | s2 | s1 | destReg | op # Logical OR the fields</pre>&#13;
			<p lang="en-GB">We could do all this in one line, as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
binCode = lit | (s2 &lt;&lt; 16) | (s1 &lt;&lt; 19) | (destReg &lt;&lt; 22)| (op &lt;&lt; 25)</pre>&#13;
			<p lang="en-GB">In the next chapter, we’ll return to the TC1 simulator and expand it. We’ll also demonstrate how the TC1 simulator can be extended by adding new operations to the instruction set and some ways of printing the results of a simulator.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Before presenting the full TC1, we are going to demonstrate a simplified version that can execute an assembly language program, essentially the same as the TC1. However, this version has been designed to reduce the total complexity by leaving out features such as symbolic names or the ability to use different number bases when specifying a constant. In this case, all literals are simple decimal integers.</p>&#13;
			<h1 id="_idParaDest-101" lang="en-GB"><a id="_idTextAnchor101"/>Intermission: The Pre-TC1</h1>&#13;
			<p lang="en-GB">In order to provide a more complete overview of the operation of a CPU simulator, we are going to introduce a highly simplified, but complete, version to give you an idea of how things fit together, before we create a more complex system.</p>&#13;
			<p lang="en-GB">In this section, you will learn how to design a simulator without some of the complications associated with a fully fledged design.</p>&#13;
			<p lang="en-GB">This version of TC1, called TC1mini, can execute assembly language. However, we use a fixed format for assembly-level instructions (input is case-sensitive) and a fixed literal format (no hexadecimal or binary numbers), and we don’t support labels and symbolic names. This approach helps stop the details from getting in the way of the bigger picture.</p>&#13;
			<h2 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor102"/>The Simulator</h2>&#13;
			<p lang="en-GB">The simulator supports <a id="_idIndexMarker385"/><a id="_idIndexMarker386"/>register-to-register operations, such as <code>ADD r1,r2,r3</code>. Its only memory access is pointer-based, that is, <code>LDRI r1,[r2]</code> and <code>STRI r1,[r2]</code>. It provides increment and decrement instructions, <code>INC r1</code> and <code>INC r2</code>. There are two compare operations: <code>CMPI r1,5</code> and <code>CMP r1,r2</code> (the former compares a register with a literal and the latter compares two registers). To keep things simple, the only status flag is <code>z</code> (zero) and this is used only by compare and subtract operations.</p>&#13;
			<p lang="en-GB">Three branch instructions are provided (unconditional branch, branch on zero, and branch on not zero). Since this simulator doesn’t support symbolic names, a branch requires a literal to indicate the destination. Branching is relative to the current location of the branch instruction; for example, <code>BRA 3</code> means jump to the instruction three locations forward, and <code>BRA -2</code> means jump two instructions backward.</p>&#13;
			<p lang="en-GB">I did not provide a file-based program input mechanism (i.e., reading a source program as a text file). The assembly language program to be executed is embedded as a Python list of strings called <code>sFile</code>. You can readily modify this or substitute the code to input a file.</p>&#13;
			<p lang="en-GB">The opcodes are set up in a dictionary of the following form:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
codes = {'STOP':[0], 'LDRL':[3], 'STRL':[7]}</pre>&#13;
			<p lang="en-GB">The <code>key:value</code> pair uses a mnemonic as the key and a list with one item, the class of the instruction, as the value. The classes range from <code>0</code> (a mnemonic with no operands) to <code>7</code> (a mnemonic with a register and register indirect operand). We’ve not implemented TC1’s 4-bit format code, which is used to determine the parameters required by an instruction, because that information is implicit in the class. Moreover, we do not assemble the instruction into a binary code. We read the mnemonic in text form and directly execute it.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">When an instruction is read, it is first tokenized to create a list of one to four tokens, for example, <code>['CMPL', 'r3', '5']</code>. When an instruction is read from the source, the class is determined and used to extract the required information from the tokens.</p>&#13;
			<p lang="en-GB">Once the mnemonic and register numbers/values and literal are known, a simple <code>if .. elif</code> structure is used to select the appropriate instruction and then execute it. Most instructions are interpreted in a single line of Python.</p>&#13;
			<p lang="en-GB">At the end of the instruction reading and execution loop, you are invited to hit a key to execute the next instruction in sequence. The data displayed after each instruction is the program counter, z-bit, instruction, registers, and memory location. We use <a id="_idIndexMarker387"/><a id="_idIndexMarker388"/>only four registers and eight memory locations.</p>&#13;
			<p lang="en-GB">We have split this program into sections with brief descriptions between them. The first part provides the source code as a built-in list. It defines the instruction classes and provides a list of opcodes and their classes. We don’t use a dictionary for this. However, we do provide dictionaries for the registers and their indirect versions to simplify analyzing instructions. For example, we can look up both <code>r1</code> and <code>r2</code> in the <code>LDRI </code><code>r1,[r2]</code> instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
sFile = ['LDRL r2,1','LDRL r0,4','NOP','STRI r0,[r2]','LDRI r3,[r2]',   \&#13;
         'INC r3','ADDL r3,r3,2','NOP','DEC r3', 'BNE -2','DEC r3','STOP']&#13;
                                            # Source program for testing&#13;
# Simple CPU instruction interpreter. Direct instruction interpretation. 30 September 2022. V1.0&#13;
# Class 0: no operand                   NOP&#13;
# Class 1: literal                      BEQ  3&#13;
# Class 2: register                     INC  r1&#13;
# Class 3: register,literal             LDRL r1,5&#13;
# Class 4: register,register,           MOV  r1,r2&#13;
# Class 5: register,register,literal    ADDL r1,r2,5&#13;
# Class 6: register,register,register   ADD  r1,r2,r3&#13;
# Class 7: register,[register]          LDRI r1,[r2]&#13;
codes = {'NOP':[0],'STOP':[0],'BEQ':[1],'BNE':[1],'BRA':[1],  \&#13;
         'INC':[2],'DEC':[2],'CMPL':[3],'LDRL':[3],'MOV':[4],  \&#13;
         'CMP':[4],'SUBL':[5],'ADDL':[5],'ANDL':[5],'ADD':[6], \&#13;
         'SUB':[6], 'AND':[6],'LDRI':[7],'STRI':[7]}&#13;
reg1  = {'r0':0,'r1':1,'r2':2,'r3':3}       # Legal registers&#13;
reg2  = {'[r0]':0,'[r1]':1,'[r2]':2,'[r3]':3} # Legal pointer registers&#13;
r = [0] * 4                                 # Four registers&#13;
r[0],r[1],r[2],r[3] = 1,2,3,4               # Preset registers for testing&#13;
m  = [0] * 8                                # Eight memory locations&#13;
pc = 0                                      # Program counter initialize to 0&#13;
go = 1                                      # go is the run control (1 to run)&#13;
z  = 0                                      # z is the zero flag. Set/cleared by SUB, DEC, CMP&#13;
while go == 1:                              # Repeat execute fetch and execute loop&#13;
    thisLine = sFile[pc]                    # Get current instruction&#13;
    pc = pc + 1                             # Increment pc&#13;
    pcOld = pc                              # Remember pc value for this cycle&#13;
    temp = thisLine.replace(',',' ')        # Remove commas: ADD r1,r2,r3 to ADD r1 r2 r3</pre>&#13;
			<pre class="source-code">    tokens = temp.split(' ')                # Tokenize:  ADD r1 r2 r3 to ['ADD','r1','r2','r3']</pre>&#13;
			<p lang="en-GB">In the following section, we analyze an instruction to extract the values of the operands required by the instruction. This is achieved by looking at the<a id="_idIndexMarker389"/><a id="_idIndexMarker390"/> instruction’s op-class and then extracting the appropriate information (e.g., the register number):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    mnemonic = tokens[0]                  # Extract first token, the mnemonic&#13;
    opClass = codes[mnemonic][0]          # Extract instruction class&#13;
                                          # Process the current instruction and analyze it&#13;
    rD,rDval,rS1,rS1val,rS2,rS2val,lit, rPnt,rPntV = 0,0,0,0,0,0,0,0,0 &#13;
                                          # Clear all parameters&#13;
    if opClass in [0]: pass               # If class 0, nothing to be done (simple opcode only)&#13;
    if opClass in [2,3,4,5,6,7,8]:        # Look for ops with destination register rD&#13;
        rD     = reg1[tokens[1]]          # Get token 1 and use it to get register number as rD&#13;
        rDval  = r[rD]                    # Get contents of register rD&#13;
    if opClass in [4,5,6]:                # Look at instructions with first source register rS1&#13;
        rS1    = reg1[tokens[2]]          # Get rS1 register number and then contents&#13;
        rS1val = r[rS1]&#13;
    if opClass in [6]:                    # If class 6, it's got three registers. Extract rS2&#13;
        rS2    = reg1[tokens[3]]          # Get rS2 and rS2val&#13;
        rS2val = r[rS2]&#13;
    if opClass in [1,3,5,8]:              # The literal is the last element in instructions&#13;
        lit    = int(tokens[-1])          # Get the literal&#13;
    if opClass in [7]:                    # Class 7 involves register indirect addressing&#13;
        rPnt   = reg2[tokens[2]]          # Get the pointer (register) and value of the pointer&#13;
        rPntV  = r[rPnt]                  # Get the register number&#13;
    if mnemonic == 'STOP':                # Now execute instructions. If STOP, clear go and exit&#13;
        go = 0&#13;
        print('Program terminated')</pre>&#13;
			<p lang="en-GB">This is the instruction execution part of the program. We use a series of comparisons of the mnemonic with the opcodes and then directly execute the instruction. Unlike TC1, we do not convert the mnemonic into binary code and then execute it by converting the binary code into appropriate operations:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    elif mnemonic == 'NOP':  pass         # NOP does nothing. Just drop to end of loop&#13;
    elif mnemonic == 'INC': r[rD] = rDval + 1  # Increment: add 1 to destination register&#13;
    elif mnemonic == 'DEC':               # Decrement: subtract 1 from register and update z bit&#13;
        z = 0&#13;
        r[rD] = rDval - 1&#13;
        if r[rD] == 0: z = 1&#13;
    elif mnemonic == 'BRA':               # Unconditional branch&#13;
        pc = pc + lit - 1&#13;
    elif mnemonic == 'BEQ':               # Conditional branch on zero&#13;
        if z == 1: pc = pc + lit - 1&#13;
    elif mnemonic == 'BNE':               # Conditional branch on not zero&#13;
        if z == 0: pc = pc + lit - 1&#13;
    elif mnemonic == 'ADD': r[rD]=rS1val+rS2val # Add&#13;
    elif mnemonic == 'ADDL': r[rD] = rS1val+lit # Add literal&#13;
    elif mnemonic == 'SUB':                     # Subtract and set/clear z&#13;
        r[rD] = rS1val - rS2val&#13;
        z = 0&#13;
        if r[rD] == 0: z = 1&#13;
    elif mnemonic == 'SUBL':                    # Subtract literal&#13;
        r[rD] = rS1val - lit&#13;
        z = 0&#13;
        if r[rD] == 0: z = 1&#13;
    elif mnemonic == 'CMPL':                    # Compare literal&#13;
        diff = rDval - lit&#13;
        z = 0&#13;
        if diff == 0 : z = 1&#13;
    elif mnemonic == 'CMP':                     # Compare&#13;
        diff = rDval - rS1val&#13;
        z = 0&#13;
        if diff == 0: z = 1&#13;
    elif mnemonic == 'MOV':  r[rD] = rS1val     # Move, load, and store operations&#13;
    elif mnemonic == 'LDRL': r[rD] = lit&#13;
    elif mnemonic == 'LDRI': r[rD] = m[rPntV]&#13;
    elif mnemonic == 'STRI': m[rPntV] = rDval&#13;
    regs = ' '.join('%02x' % b for b in r)      # Format memory locations hex&#13;
    mem  = ' '.join('%02x' % b for b in m)      # Format registers hex&#13;
    print('pc =','{:&lt;3}'.format(pcOld), '{:&lt;14}'.format(thisLine), \&#13;
          'Regs =',regs, 'Mem =',mem, 'z =', z)&#13;
    x = input('&gt;&gt;&gt; ')               # Request keyboard input before dealing with next instruction</pre>&#13;
			<p lang="en-GB">Note that the execution loop ends with an input <a id="_idIndexMarker391"/><a id="_idIndexMarker392"/>request from the keyboard. In this way, the next cycle is not executed until the <em class="italic">Enter</em>/<em class="italic">Return</em> key is pressed.</p>&#13;
			<p lang="en-GB">The following shows the output of the simulator as the embedded program is executed. Changed registers, memory locations, and flag values are in bold font:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pc = 1   LDRL r2,1     Regs = 01 02 <strong class="bold">01</strong> 04 Mem = 00 00 00 00 00 00 00 00 z = 0&#13;
pc = 2   LDRL r0,4     Regs = <strong class="bold">04</strong> 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0&#13;
pc = 3   NOP           Regs = 04 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0&#13;
pc = 4   STRI r0,[r2]  Regs = 04 02 01 04 Mem = 00 <strong class="bold">04</strong> 00 00 00 00 00 00 z = 0&#13;
pc = 5   LDRI r3,[r2]  Regs = 04 02 01 <strong class="bold">04</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 6   INC r3        Regs = 04 02 01 <strong class="bold">05</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 7   ADDL r3,r3,2  Regs = 04 02 01 <strong class="bold">07</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 07 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">06</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 10  BNE -2        Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">05</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 10  BNE -2        Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">04</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 10  BNE -2        Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">03</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 10  BNE -2        Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">02</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 10  BNE -2        Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">01</strong> Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 10  BNE -2        Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 8   NOP           Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">00</strong> Mem = 00 04 00 00 00 00 00 00 <strong class="bold">z = 1</strong>&#13;
pc = 10  BNE -2        Regs = 04 02 01 00 Mem = 00 04 00 00 00 00 00 00 z = 1&#13;
pc = 11  DEC r3        Regs = 04 02 01 -1 Mem = 00 04 00 00 00 00 00 00 z = 0&#13;
Program terminated&#13;
pc = 12  STOP          Regs = 04 02 01 -1 Mem = 00 04 00 00 00 00 00 00 z = 0</pre>&#13;
			<p lang="en-GB">We will now look at the program for the TC1 simulator. We will include<a id="_idIndexMarker393"/><a id="_idIndexMarker394"/> a short introduction to some of its facilities before providing the code.</p>&#13;
			<h1 id="_idParaDest-103" lang="en-GB">T<a id="_idTextAnchor103"/>he TC1 simulator program</h1>&#13;
			<p lang="en-GB">In this section, we provide<a id="_idIndexMarker395"/><a id="_idIndexMarker396"/> the full code for the TC1 assembler and simulator. This will enable you to construct and modify a computer assembler and simulator that can execute the code supported by TC1 or your own instruction set (if you modify TC1).</p>&#13;
			<p lang="en-GB">The assembler is the more complicated part because it involves reading text, analyzing it, and formatting it into binary codes. The simulator itself simply reads each binary code and then performs the appropriate action.</p>&#13;
			<p lang="en-GB">The simulator includes features that we haven’t covered yet in previous sections (e.g., debugging and trace facilities). In the first draft of this book, TC1 was rather more basic with a minimal subset of features. As the book was edited and the program modified, the set of features was enhanced to make it a more practical tool. We first provide brief notes on some of these features to aid understanding of the program.</p>&#13;
			<h2 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor104"/>Single-stepping</h2>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">A computer executes instructions sequentially unless a branch or subroutine call is encountered. When testing a simulator, you frequently want to execute a batch of instructions together (i.e., without printing register values), or you may wish to execute instructions one at a time by hitting <em class="italic">Enter</em>/<em class="italic">Return</em> after each instruction has been executed or to execute instructions until you hit a specific instruction.</p>&#13;
			<p lang="en-GB">In this version of TC1, you can execute and display an instruction, skip the display of the next n instructions, or not display instructions until a change-of-flow instruction is encountered. After the program is loaded, the input prompt is displayed. If you enter a return, the simulator executes the next instruction and waits. If you enter an integer (and return), the specified number of instructions is executed without displaying the results. If you enter b followed by a return, the<a id="_idIndexMarker397"/><a id="_idIndexMarker398"/> simulator executes instructions without displaying them until the next branch instruction is encountered.</p>&#13;
			<p lang="en-GB">Consider the following example. The code is just a set of random instructions for demonstration. I’ve used no-operations (<code>nop</code>) as a filler. I’ve also tested literal address formats (hex and binary) and demonstrated case insensitivity:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
@ test trace modes&#13;
    nop&#13;
    nop&#13;
    inc r1&#13;
    NOP&#13;
    dec r2&#13;
    ldrl r6,0b10101010&#13;
    bra abc&#13;
    nop&#13;
    inc R7&#13;
    nop&#13;
abc ldrl r3,$ABCD&#13;
    nop&#13;
    inc r3&#13;
    INC r4&#13;
    nop&#13;
    nop&#13;
    inc r5&#13;
    END!</pre>&#13;
			<p lang="en-GB">I’ve edited it to remove memory locations as they are not accessed. After the prompt, <code>&gt;&gt;&gt;</code>, you select what is to happen: trace one instruction, execute <code>n</code> instructions without stopping or displaying registers, or execute code to the next branch instruction without displaying it. In each case, the following program counter value is highlighted in the following output. The text in bold is a comment I left on an action on the current line (trace indicates a <em class="italic">Return</em>/<em class="italic">Enter</em> was hit, which executes the next instruction):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
  &gt;&gt;&gt;  <strong class="bold CharOverride-1">trace</strong>&#13;
0      NOP           PC= 0 z=0 n=0 c=0 R 0000 0000 0000 0000 0000 0000 0000 0000&#13;
&gt;&gt;&gt;3 <strong class="bold CharOverride-1">jump 3 instructions (silent trace)</strong>&#13;
4      DEC R2        PC= 4 z=0 n=1 c=1 R 0000 0001 ffff 0000 0000 0000 0000 0000&#13;
&gt;&gt;&gt;b <strong class="bold CharOverride-1">jump to branch (silent mode up to next branch/rts/jsr)</strong>&#13;
6      BRA ABC       PC= 6 z=0 n=1 c=1 R 0000 0001 ffff 0000 0000 0000 00aa 0000&#13;
&gt;&gt;&gt;  <strong class="bold CharOverride-1">trace</strong> Here's the sample run&#13;
10 ABC LDRL R3 $ABCD PC=10 z=0 n=1 c=1 R 0000 0001 ffff abcd 0000 0000 00aa 0000&#13;
&gt;&gt;&gt;  <strong class="bold CharOverride-1">trace</strong>&#13;
11     NOP           PC=11 z=0 n=1 c=1 R 0000 0001 ffff abcd 0000 0000 00aa 0000&#13;
&gt;&gt;&gt;4 <strong class="bold CharOverride-1">jump 4</strong>&#13;
16     INC R5        PC=16 z=0 n=0 c=1 R 0000 0001 ffff abce 0001 0001 00aa 0000&#13;
&gt;&gt;&gt;  <strong class="bold CharOverride-2">trace</strong>&#13;
17     END!          PC=17 z=0 n=0 c=1 R 0000 0001 ffff abce 0001 0001 00aa 0000</pre>&#13;
			<h2 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor105"/>File input</h2>&#13;
			<p lang="en-GB">When we first started writing a simulator, we<a id="_idIndexMarker399"/><a id="_idIndexMarker400"/> inputted test programs the easy way by typing the instructions in one by one. This worked for the simplest of tests but soon became tedious. Later, programs were input as a text file. That worked well when the filename was short, such as <code>t.txt</code>, but it got more tedious with long filenames (e.g., when I stored the source code in a specific directory).</p>&#13;
			<p lang="en-GB">We then included the filename in the actual TC1 program. That’s convenient when you’re going to be running the same program over and over again while you’re testing various features of the simulator. What we needed was a means of using my working program (baked into the simulator) most of the time, but to switch to an alternative when required.</p>&#13;
			<p lang="en-GB">One sensible solution would be to generate an input banner prompting you to press <em class="italic">Enter</em> for the default file, or provide a filename for an alternative source program, say, <em class="italic">Enter return for the default file</em> or <em class="italic">Enter a filename for an alternative source program</em>. We decided to use Python’s exception mechanism to implement this. In computing, an <em class="italic">exception</em> (also called a <em class="italic">software interrupt</em>) is a mechanism designed to deal with unexpected events. In Python, the exception handler uses two reserved words: <code>try</code> and <code>exception</code>.</p>&#13;
			<p lang="en-GB">As their names suggest, <code>try</code> requires Python to run the following block of code, and <code>exception</code> is a block of code that is executed if the <code>try</code> block failed. Essentially, it means, <em class="italic">“If you can’t do this, do that.”</em> The difference between <code>if</code> and <code>try</code> is that <code>if</code> returns <code>True</code> or <code>False</code> and performs the specified action if <code>True</code>, whereas <code>try</code> <em class="italic">attempts</em> to run a block and calls an exception if it fails, that is, if it crashes.</p>&#13;
			<p lang="en-GB"><code>try</code> allows you to attempt to open a file and then gives you a way out if the file doesn’t exist (i.e., it avoids a fatal error). Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
myProg = 'testException1.txt'                      # Name of default program&#13;
<strong class="bold">try:</strong>                                               # Check whether this file exists&#13;
    with open(myProg,'r') as prgN:                 # If it's there, open it and read it&#13;
        myFile = prgN.readlines()&#13;
<strong class="bold">except:</strong>                                            # Call exception if file not there&#13;
    altProg = input('Enter source file name: ')    # Request a filename&#13;
    with open(altProg,'r') as prgN:                # Open the user file&#13;
        myFile = prgN.readlines()&#13;
print('File loaded: ', myFile)</pre>&#13;
			<p lang="en-GB">This code looks for a file called <code>testException1.txt</code>. If it’s present (as it is in this case), the simulator runs it and we get the following output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; %Run testTry.py&#13;
File loaded:  ['   @ Test exception file\n', ' nop\n', ' nop\n', ' inc\n', ' end!']</pre>&#13;
			<p lang="en-GB">In the next case, we’ve deleted <code>testException1.txt</code>. We now get the following output after the prompt:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; %Run testTry.py&#13;
<strong class="bold">Enter source file name: testException2.txt</strong>&#13;
File loaded:  ['   @ Test exception file TWO\n', ' dec r1\n', ' nop\n', ' inc r2\n', ' end!']</pre>&#13;
			<p lang="en-GB">The line in bold is the alternative filename.</p>&#13;
			<p lang="en-GB">In the TC1 program, I further simplify <a id="_idIndexMarker401"/><a id="_idIndexMarker402"/>things by including the file directory in the exception (because I always use the same directory) and I include the file extension, <code>.txt</code>. This looks as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
prgN = 'E://ArchitectureWithPython//' + prgN + '.txt'</pre>&#13;
			<p lang="en-GB">This expression automatically provides the path for the filename and address of the file type.</p>&#13;
			<p lang="en-GB">Remember that Python lets you use the <code>+</code> operator to concatenate strings.</p>&#13;
			<h3 lang="en-GB">TC1 program</h3>&#13;
			<p lang="en-GB">The first part of the program<a id="_idIndexMarker403"/><a id="_idIndexMarker404"/> provides a list of instructions and their encoding. This text is placed between two <code>'''</code> markers that indicate it is not part of the program. This avoids having to start each line with <code>#</code>. The triple quote marks is called a docstring comment.</p>&#13;
			<p lang="en-GB">The first part of TC1 is a listing of the instructions. These are provided to make the program easier to follow:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
### TC1 computer simulator and assembler. Version of 11 September 2022&#13;
<code>'''</code> This is the table of instructions for reference and is not part of the program code&#13;
00 00000  stop operation            STOP             00 00000 000 000 000 0  0000&#13;
00 00001  no operation              NOP              00 00001 000 000 000 0  0000&#13;
00 00010  get character from keyboard  GET  r0         00 00010 rrr 000 000 0  1000&#13;
00 00011  get character from keyboard  RND  r0         00 00011 rrr 000 000 L  1001&#13;
00 00100  swap bytes in register        SWAP r0         00 00100 rrr 000 000 0  1000&#13;
00 01000  print hex value in register     PRT r0          00 01000 rrr 000 000 0  1000&#13;
00 11111  terminate program         END!            00 11111 000 000 000 0  0000&#13;
01 00000  load register from register     MOVE r0,r1      01 00000 rrr aaa 000 0  1100&#13;
01 00001  load register from memory   LDRM r0,L       01 00001 rrr 000 000 L  1001&#13;
01 00010  load register with literal       LDRL r0,L       01 00010 rrr 000 000 L  1001&#13;
01 00011  load register indirect        LDRI r0,[r1,L]  01 00011 rrr aaa 000 L  1101&#13;
01 00100  store register in memory      STRM r0,L       01 00100 rrr 000 000 L  1001&#13;
01 00101  store register indirect       STRI r0,[r1,L]  01 00101 rrr aaa 000 L  1101&#13;
10 00000  add register to register      ADD  r0,r1,r2   10 00000 rrr aaa bbb 0  1110&#13;
10 00001  add literal to register        ADDL r0,r1,L    10 00001 rrr aaa 000 L  1101&#13;
10 00010  subtract register from register SUB  r0,r1,r2   10 00010 rrr aaa bbb 0  1110&#13;
10 00011  subtract literal from register    SUBL r0,r1,L    10 00011 rrr aaa 000 L  1101&#13;
10 00100  multiply register by register   MUL  r0,r1,r2   10 00100 rrr aaa bbb 0  1110&#13;
10 00101  multiply literal by register     MULL r0,r1,L    10 00101 rrr aaa 000 L  1101&#13;
10 00110  divide register by register     DIV  r0,r1,r2   10 00110 rrr aaa bbb 0  1110&#13;
10 00111  divide register by literal       DIVL r0,r1,L    10 00111 rrr aaa 000 L  1101&#13;
10 01000  mod register by register      MOD  r0,r1,r2   10 01000 rrr aaa bbb 0  1110&#13;
10 01001  mod register by literal        MODL r0,r1,L    10 01001 rrr aaa 000 L  1101&#13;
10 01010  AND register to register      AND  r0,r1,r2   10 01000 rrr aaa bbb 0  1110&#13;
10 01011  AND register to literal         ANDL r0,r1,L    10 01001 rrr aaa 000 L  1101&#13;
10 01100  OR register to register        OR   r0,r1,r2   10 01010 rrr aaa bbb 0  1110&#13;
10 01101  NOR register to literal        ORL  r0,r1,L    10 01011 rrr aaa 000 L  1101&#13;
10 01110  EOR register to register       OR   r0,r1,r2   10 01010 rrr aaa bbb 0  1110&#13;
10 01111  EOR register to literal       ORL  r0,r1,L    10 01011 rrr aaa 000 L  1101&#13;
10 10000  NOT register              NOT  r0         10 10000 rrr 000 000 0  1000&#13;
10 10010  increment register          INC  r0          10 10010 rrr 000 000 0  1000&#13;
10 10011  decrement register         DEC  r0         10 10011 rrr 000 000 0  1000&#13;
10 10100  compare register with register CMP  r0,r1      10 10100 rrr aaa 000 0  1100&#13;
10 10101  compare register with literal   CMPL r0,L       10 10101 rrr 000 000 L  1001&#13;
10 10110  add with carry            ADC              10 10110 rrr aaa bbb 0  1110&#13;
10 10111  subtract with borrow        SBC             10 10111 rrr aaa bbb 0  1110&#13;
10 11000  logical shift left           LSL  r0,L       10 10000 rrr 000 000 0  1001&#13;
10 11001  logical shift left literal       LSLL r0,L       10 10000 rrr 000 000 L  1001&#13;
10 11010  logical shift right          LSR  r0,L       10 10001 rrr 000 000 0  1001&#13;
10 11011  logical shift right literal      LSRL r0,L       10 10001 rrr 000 000 L  1001&#13;
10 11100  rotate left               ROL  r0,L        10 10010 rrr 000 000 0  1001&#13;
10 11101  rotate left literal           ROLL r0,L        10 10010 rrr 000 000 L  1001&#13;
10 11110  rotate right              ROR  r0,L        10 10010 rrr 000 000 0  1001&#13;
10 11111  rotate right literal          RORL r0,L        10 10010 rrr 000 000 L  1001&#13;
11 00000  branch unconditionally       BRA  L           11 00000 000 000 000 L  0001&#13;
11 00001  branch on zero           BEQ  L           11 00001 000 000 000 L  0001&#13;
11 00010  branch on not zero         BNE  L           11 00010 000 000 000 L  0001&#13;
11 00011  branch on minus           BMI  L           11 00011 000 000 000 L  0001&#13;
11 00100  branch to subroutine       BSR  L           11 00100 000 000 000 L  0001&#13;
11 00101  return from subroutine       RTS              11 00101 000 000 000 0  0000&#13;
11 00110  decrement &amp; branch on not zero DBNE r0,L       11 00110 rrr 000 000 L  1001&#13;
11 00111  decrement &amp; branch on zero  DBEQ r0,L        11 00111 rrr 000 000 L  1001&#13;
11 01000  push register on stack       PUSH r0           11 01000 rrr 000 000 0  1000&#13;
11 01001  pull register off stack       PULL r0           11 01001 rrr 000 000 0  1000&#13;
'''&#13;
import random                       # Get library for random number generator&#13;
def alu(fun,a,b):                   # Alu defines operation and a and b are inputs&#13;
   global c,n,z                     # Status flags are global and are set up here&#13;
    if   fun == 'ADD': s = a + b&#13;
    elif fun == 'SUB': s = a - b&#13;
    elif fun == 'MUL': s = a * b&#13;
    elif fun == 'DIV': s = a // b   # Floor division returns an integer result&#13;
    elif fun == 'MOD': s = a % b    # Modulus operation gives remainder: 12 % 5 = 2&#13;
    elif fun == 'AND': s = a &amp; b    # Logic functions&#13;
    elif fun == 'OR':  s = a | b&#13;
    elif fun == 'EOR': s = a &amp; b&#13;
    elif fun == 'NOT': s = ~a&#13;
    elif fun == 'ADC': s = a + b + c # Add with carry&#13;
    elif fun == 'SBC': s = a - b – c # Subtract with borrow&#13;
    c,n,z = 0,0,0                    # Clear flags before recalculating them&#13;
    if s &amp; 0xFFFF == 0: z = 1        # Calculate the c, n, and z flags&#13;
    if s &amp; 0x8000 != 0: n = 1        # Negative if most sig bit 15 is 1&#13;
    if s &amp; 0xFFFF != 0: c = 1        # Carry set if bit 16 is 1&#13;
    return (s &amp; 0xFFFF)              # Return the result constrained to 16 bits</pre>&#13;
			<p lang="en-GB">Because the <code>shift</code> operation is rather<a id="_idIndexMarker405"/><a id="_idIndexMarker406"/> complex with left and right shifts, variable-length shifts, plus shifts, and rotates, we have provided a function to implement shifts. This takes the type of shift, direction, and number of places shifted as input parameters, together with the word to be shifted:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def shift(dir,mode,p,q):   # Shifter: performs shifts and rotates. dir = left/right, mode = logical/rotate&#13;
    global z,n,c                    # Make flag bits global. Note v-bit not implemented&#13;
    if dir == 0:                    # dir = 0 for left shift, 1 for right shift&#13;
        for i in range (0,q):       # Perform q left shifts on p&#13;
            sign = (0x8000 &amp; p) &gt;&gt; 15            # Sign bit&#13;
            p = (p &lt;&lt; 1) &amp; 0xFFFF                # Shift p left one place&#13;
            if mode == 1:p = (p &amp; 0xFFFE) | sign # For rotate left, add in bit shifted out&#13;
    else:                                        # dir = 1 for right shift&#13;
        for i in range (0,q):                    # Perform q right shifts&#13;
            bitOut = 0x0001 &amp; p                  # Save lsb shifted out&#13;
            sign = (0x8000 &amp; p) &gt;&gt; 15            # Get sign-bit for ASR&#13;
            p = p &gt;&gt; 1                           # Shift p one place right&#13;
            if mode == 1:p = (p&amp;0x7FFF)|(bitOut&lt;&lt;15) # If mode = 1, insert bit rotated out&#13;
            if mode == 2:p = (p&amp;0x7FFF)|(sign &lt;&lt; 15) # If mode = 2, propagate sign bit&#13;
    z,c,n = 0,0,0                                # Clear all flags&#13;
    if p == 0:          z = 1                    # Set z if p is zero&#13;
    if p &amp; 0x8000 != 0: n = 1                    # Set n-bit if p = 1&#13;
    if (dir == 0) and (sign == 1):   c = 1       # Set carry if left shift and sign 1&#13;
    if (dir == 1) and (bitOut == 1): c = 1  # Set carry bit if right shift and bit moved out = 1&#13;
    return(0xFFFF &amp; p)               # Ensure output is 16 bits wide&#13;
def listingP():                      # Function to perform listing and formatting of source code&#13;
    global listing                   # Listing contains the formatted source code&#13;
    listing = [0]*128                # Create formatted listing file for display&#13;
    if debugLevel &gt; 1: print('Source assembly code listing ')&#13;
    for i in range (0,len(sFile)):        # Step through the program&#13;
        if sFile[i][0] in codes:          # Is first token in opcodes (no label)?&#13;
            i2 =  (' ').join(sFile[i])    # Convert tokens into string for printing&#13;
            i1 = ''                       # Dummy string i1 represents missing label&#13;
        else:&#13;
            i2 = (' ').join(sFile[i][1:]) # If first token not opcode, it's a label&#13;
            i1 = sFile[i][0]              # i1 is the label (first token)&#13;
        listing[i] = '{:&lt;3}'.format(i) + '{:&lt;7}'.format(i1) + \&#13;
                     '{:&lt;10}'.format(i2)  # Create listing table entry&#13;
        if debugLevel  &gt; 1:               # If debug  = 1, don't print source program&#13;
            print('{:&lt;3}'.format(i),'{:&lt;7}'.format(i1),'{:&lt;10}'.format(i2)) \&#13;
                                          # print: pc, label, opcode&#13;
    return()</pre>&#13;
			<p lang="en-GB">This is the function, <code>getLit</code>, that <a id="_idIndexMarker407"/><a id="_idIndexMarker408"/>processes a literal. It can handle literals in a range of possible formats, including decimal, binary, hexadecimal, and symbolic form:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def getLit(litV):                                  # Extract a literal&#13;
    if  litV[0]    == '#': litV = litV[1:]         # Some systems prefix literal with '#&#13;
    if  litV in symbolTab:                         # Look in sym tab and get value if there&#13;
        literal = symbolTab[litV]                  # Read the symbol value as a string&#13;
        literal = int(literal)                     # Convert string into integer&#13;
    elif  litV[0]   == '%': literal = int(litV[1:],2)&#13;
                                                   # If first char is %, convert to integer&#13;
    elif  litV[0:2] == '0B':literal = int(litV[2:],2)&#13;
                                                   # If prefix 0B, convert binary to integer&#13;
    elif  litV[0:2] == '0X':literal = int(litV[2:],16)&#13;
                                                   # If 0x, convert hex string to integer&#13;
    elif  litV[0:1] == '$': literal = int(litV[1:],16)&#13;
                                                   # If $, convert hex string to integer&#13;
    elif  litV[0]   == '-': literal = (-int(litV[1:]))&amp;0xFFFF &#13;
                                                   # Convert 2's complement to int&#13;
    elif  litV.isnumeric():  literal = int(litV)&#13;
                                                   # If decimal string, convert to integer&#13;
    else:                    literal = 0           # Default value 0 (default value)</pre>&#13;
			<pre class="source-code">    return(literal)</pre>&#13;
			<p lang="en-GB"><code>Print</code> statements can be a little complicated. Consequently, we have created a <code>print</code> function that is used to display register and memory contents. We discuss print formatting elsewhere in this book. We generate the data as strings to be printed, <code>m</code>, <code>m1</code>, and <code>m2</code>, and then <a id="_idIndexMarker409"/><a id="_idIndexMarker410"/>print them using the appropriate formatting:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def printStatus():                             # Display machine status (registers, memory)&#13;
    text = '{:&lt;27}'.format(listing[pcOld])     # Format instruction for listing&#13;
    m = mem[0:8]                               # Get the first 8 memory locations&#13;
    m1 = ' '.join('%04x' % b for b in m)       # Format memory location's hex&#13;
    m2 = ' '.join('%04x' % b for b in r)       # Format register's hex&#13;
    print(text, 'PC =', '{:&gt;2}'.format(pcOld) , 'z =',z,'n =',n,'c =',c, m1,\&#13;
    'Registers ', m2)&#13;
    if debugLevel == 5:&#13;
        print('Stack =', ' '.join('%04x' % b for b in stack), \&#13;
        'Stack pointer =', sp)&#13;
    return()&#13;
print('TC1 CPU simulator 11 September 2022 ')  # Print the opening banner&#13;
debugLevel = input('Input debug level 1 - 5: ') # Ask for debugging level&#13;
if debugLevel.isnumeric():                     # If debug level is an integer, get it&#13;
    debugLevel = int(debugLevel)               # Convert text to integer&#13;
else: debugLevel = 1                           # Else, set default value to level 1&#13;
if debugLevel not in range (1,6): debugLevel = 1 # Ensure range 1 to 5&#13;
print()                                        # New line</pre>&#13;
			<p lang="en-GB">The preceding block of code provides a debug functionality and is intended to demonstrate the concept of debugging and provide a facility to check the assembly process by displaying intermediate information during the assembly phase. A variable, <code>debugLevel</code>, is read from the keyboard at the start of the program. This determines the level of the debugging facility from 1 (none) to 5 (maximum). Debugging information can include the source code, decoded operations, and other parameters:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
global c,n,z                                   # Processor flags (global variables)&#13;
symbolTab = {'START':0}             # Create symbol table for labels + equates with dummy entry&#13;
c,n,z = 0,0,0                                  # Initialize flags: carry, negative, zero&#13;
sFile = ['']* 128                              # sFile holds the source text&#13;
memP  = [0] * 128                              # Create program memory of 128 locations&#13;
mem   = [0] * 128                              # Create data memory of 128 locations&#13;
stack = [0] * 16                               # Create a stack for return addresses&#13;
# codes is a dictionary of instructions {'mnemonic':(x.y)} where x is the instruction operand format, and y the opcode&#13;
codes = {                                                            \&#13;
        'STOP':(0,0),  'NOP' :(0,1),  'GET' :(8,2),  'RND' : (9,3),  \&#13;
        'SWAP':(8,4),  'SEC' :(0,5),  'PRT' :(8,8),  'END!':(0,31),  \&#13;
        'MOVE':(12,32),'LDRM':(9,33), 'LDRL':(9,34), 'LDRI':(13,35), \&#13;
        'STRM':(9,36), 'STRI':(13,37),'ADD' :(14,64),'ADDL':(13,65), \&#13;
        'SUB' :(14,66),'SUBL':(13,67),'MUL' :(14,68),'MULL':(13,69), \&#13;
        'DIV' :(14,70),'DIVL':(13,71),'MOD' :(14,72),'MODL':(13,73), \&#13;
        'AND' :(14,74),'ANDL':(13,75),'OR'  :(14,76),'ORL' :(13,77), \&#13;
        'EOR' :(14,78),'EORL':(13,79),'NOT' :(8,80), 'INC' :(8,82),  \&#13;
        'DEC' :(8,83), 'CMP' :(12,84),'CMPL':(9,85), 'LSL' :(12,88), \&#13;
        'LSLL':(9,89), 'LSR' :(12,90),'LSRL':(9,91), 'ROL' :(12,92), \&#13;
        'ROLL':(9,93), 'ROR' :(12,94),'RORL':(9,95), 'ADC':(14,102), \&#13;
        'SBC':(14,103),'BRA' :(1,96), 'BEQ' :(1,97), 'BNE' :(1,98),  \&#13;
        'BMI' :(1,99), 'BSR' :(1,100),'RTS' :(0,101),'DBNE':(9,102), \&#13;
        'DBEQ':(9,103),'PUSH':(8,104),'PULL':(8,105) }&#13;
branchGroup = ['BRA', 'BEQ', 'BNE', 'BSR', 'RTS'] # Operations responsible for flow control</pre>&#13;
			<p lang="en-GB">The following section is responsible for reading the source file to be assembled and executed. This source code should be in the form of a <code>.txt</code> file. Note that <a id="_idIndexMarker411"/><a id="_idIndexMarker412"/>this code uses Python’s <code>try</code> and <code>except</code> mechanism, which is able to perform an action (in this case, try and load a file from disk) and, if the action fails, perform a new action instead. Here, we use it to test for a default filename and then get one from the terminal if that file does not exist:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Read the input source code text file and format it. This uses a default file and a user file if default is absent&#13;
prgN = 'E://ArchitectureWithPython//C_2_test.txt' # prgN = program name: default test file&#13;
try:                                              # Check whether this file exists&#13;
    with open(prgN,'r') as prgN:                  # If it's there, open it and read it&#13;
        prgN = prgN.readlines()&#13;
except:                                           # Call exception program if not there&#13;
    prgN = input('Enter source file name: ')    # Request a filename (no extension needed)&#13;
    prgN = 'E://ArchitectureWithPython//' + prgN + '.txt' # Build filename&#13;
    with open(prgN,'r') as prgN:                  # Open user file&#13;
        prgN = prgN.readlines()                   # Read it&#13;
for i in range (0,len(prgN)):                     # Scan source prgN and copy it to sFile&#13;
    sFile[i] = prgN[i]                            # Copy prgN line to sFile line&#13;
    if 'END!' in prgN[i]: break                   # If END! found, then stop copying&#13;
             # Format source code&#13;
sFile = [i.split('@')[0] for i in sFile]          # But first, remove comments     ###&#13;
for i in range(0,len(sFile)):                     # Repeat: scan input file line by line&#13;
    sFile[i] = sFile[i].strip()                   # Remove leading/trailing spaces and eol&#13;
    sFile[i] = sFile[i].replace(',',' ')          # Allow use of commas or spaces&#13;
    sFile[i] = sFile[i].replace('[','')           # Remove left bracket&#13;
    sFile[i] = sFile[i].replace(']','')       # Remove right bracket and convert [R4] to R4&#13;
    while '  ' in sFile[i]:                       # Remove multiple spaces&#13;
        sFile[i] = sFile[i].replace('  ', ' ')&#13;
sFile = [i.upper() for i in sFile]                # Convert to uppercase</pre>&#13;
			<pre class="source-code">sFile = [i.split(' ') for i in sFile if i != '']  # Split the tokens into list items</pre>&#13;
			<p lang="en-GB">This short section deals with the equate assembler directive and binds values to symbolic names using the <code>EQU</code> directive. These bindings are placed in the <code>symbol table</code> dictionary and the equates are removed from the source code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                    # Remove assembler directives from source code&#13;
for i in range (0,len(sFile)):      # Deal with equates of the form PQR EQU 25&#13;
    if len(sFile[i]) &gt; 2 and sFile[i][1] == 'EQU': # If line is &gt; 2 tokens and second is EQU&#13;
        symbolTab[sFile[i][0]] = sFile[i][2]       # Put third token EQU in symbol table&#13;
sFile = [i for i in sFile if i.count('EQU') == 0]  # Remove all lines with 'EQU'&#13;
                                    # Debug: 1 none, 2 source, 3 symbol tab, 4 Decode i, 5 stack&#13;
listingP()                          # List the source code if debug level is 1</pre>&#13;
			<p lang="en-GB">Here, we perform the instruction <a id="_idIndexMarker413"/><a id="_idIndexMarker414"/>decoding; that is, we analyze the text of each instruction to extract the opcode and parameters:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                    # Look for labels and add to symbol table&#13;
for i in range(0,len(sFile)):       # Add branch addresses to symbol table&#13;
    if sFile[i][0] not in codes:    # If first token not opcode, then it is a label&#13;
        symbolTab.update({sFile[i][0]:str(i)})     # Add it to the symbol table&#13;
if debugLevel &gt; 2:                  # Display symbol table if debug level 2&#13;
    print('\nEquate and branch table\n')           # Display the symbol table&#13;
    for x,y in symbolTab.items(): print('{:&lt;8}'.format(x),y) \&#13;
                                             # Step through the symbol table dictionary&#13;
    print('\n')&#13;
            # Assemble source code in sFile&#13;
if debugLevel &gt; 3: print('Decoded instructions')   # If debug level 4/5, print decoded ops&#13;
for pcA in range(0,len(sFile)):              # ASSEMBLY: pcA = prog counter in assembly&#13;
    opCode, label, literal, predicate = [], [], 0, []   # Initialize variables&#13;
                                             # Instruction = label + opcode + predicate&#13;
    rD, rS1, rS2  = 0, 0, 0                  # Clear all register-select fields&#13;
    thisOp = sFile[pcA]                      # Get current instruction, thisOPp, in text form&#13;
                                             # Instruction: label + opcode or opcode&#13;
    if thisOp[0] in codes: opCode = thisOp[0]      # If token opcode, then get token&#13;
    else:                                    # Otherwise, opcode is second token&#13;
        opCode = thisOp[1]                   # Read the second token to get opcode&#13;
        label = sFile[i][0]                  # Read the first token to get the label&#13;
    if (thisOp[0] in codes) and (len(thisOp) &gt; 1): # If first token opcode, rest is predicate&#13;
        predicate = thisOp[1:]               # Now get the predicate&#13;
    else:                                    # Get predicate if the line has a label&#13;
        if len(thisOp) &gt; 2: predicate = thisOp[2:]&#13;
    form = codes.get(opCode)                 # Use opcode to read type (format)&#13;
                                             # Now check the bits of the format code&#13;
    if form[0] &amp; 0b1000 == 0b1000:           # Bit 4 selects destination register rD&#13;
        if predicate[0] in symbolTab:        # Check if first token in symbol table&#13;
            rD = int(symbolTab[predicate[0]][1:]) # If it is, then get its value&#13;
        else: rD = int(predicate[0][1:])     # If not label, get register from the predicate&#13;
    if form[0] &amp; 0b0100 == 0b0100:           # Bit 3 selects source register 1, rS1&#13;
        if predicate[1] in symbolTab:&#13;
            rS1 = int(symbolTab[predicate[1]][1:])&#13;
        else: rS1 = int(predicate[1][1:])&#13;
    if form[0] &amp; 0b0010 == 0b0010:           # Bit 2 of format selects register rS1&#13;
        if predicate[2] in symbolTab:&#13;
            rS2 = int(symbolTab[predicate[2]][1:])&#13;
        else: rS2 = int(predicate[2][1:])&#13;
    if form[0] &amp; 0b0001 == 0b0001:           # Bit 1 of format selects the literal field&#13;
        litV = predicate[-1]&#13;
        literal = getLit(litV)</pre>&#13;
			<p lang="en-GB">This section was added after the development of TC1. We introduce the concept of a debug level. That is, at the beginning of a simulation run, you can<a id="_idIndexMarker415"/><a id="_idIndexMarker416"/> set a parameter in the range of <code>1</code> to <code>3</code> that determines how much information is displayed during the assembly processing. This allows you to get more information about the instruction encoding when testing the program:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if debugLevel &gt; 3:                       # If debug level &gt; 3, print decoded fields&#13;
        t0 = '%02d' % pcA                    # Format instruction counter&#13;
        t1 = '{:&lt;23}'.format(' '.join(thisOp)) # Format operation to 23 spaces&#13;
        t3 = '%04x' % literal                # Format literal to 4-character hex&#13;
        t4 = '{:04b}'.format(form[0])        # Format the 4-bit opcode format field&#13;
        print('pc =',t0,'Op =',t1,'literal',t3,'Dest reg =',rD,'rS1 =', \&#13;
              'rS1,'rS2 =',rS2,'format =',t4)  # Concatenate fields to create 32-bit opcode&#13;
    binCode = form[1]&lt;&lt;25|(rD)&lt;&lt;22|(rS1)&lt;&lt;19|(rS2)&lt;&lt;16|literal # Binary pattern&#13;
    memP[pcA] = binCode                      # Store instruction in program memory&#13;
                                             # End of the assembly portion of the program</pre>&#13;
			<p lang="en-GB">We are about to execute the instructions. Before we do that, it is necessary to initialize several variables concerning the current operation (e.g., tracing):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                           # The code is executed here&#13;
r = [0] * 8                                # Define registers r[0] to r[7]&#13;
pc = 0                                     # Set program counter to 0&#13;
run = 1                                    # run = 1 during execution&#13;
sp = 16                                    # Initialize the stack pointer (BSR/RTS)&#13;
goCount = 0                                # goCount executes n operations with no display&#13;
traceMode    = 0                           # Set to 1 to execute n instructions without display&#13;
skipToBranch = 0                           # Used when turning off tracing until a branch</pre>&#13;
			<pre class="source-code">silent = 0                                 # silent = 1 to turn off single stepping</pre>&#13;
			<p lang="en-GB">This is the main loop where we decode instructions to extract the parameters (register numbers and the literal):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                           # Executes instructions when run is 1&#13;
while run == 1:                            # Step through instructions: first, decode them!&#13;
    binCode = memP[pc]                     # Read binary code of instruction&#13;
    pcOld = pc                             # pc in pcOld (for display purposes)&#13;
    pc = pc + 1                            # Increment the pc&#13;
    binOp = binCode &gt;&gt; 25                  # Extract the 7-bit opcode as binOp&#13;
    rD    = (binCode &gt;&gt; 22) &amp; 7            # Extract the destination register, rD&#13;
    rS1   = (binCode &gt;&gt; 19) &amp; 7            # Extract source register 1, rS1&#13;
    rS2   = (binCode &gt;&gt; 16) &amp; 7            # Extract source register 2, rS2&#13;
    lit   = binCode &amp; 0xFFFF               # Extract the 16-bit literal&#13;
    op0 = r[rD]                            # Get contents of destination register&#13;
    op1 = r[rS1]                           # Get contents of source register 1&#13;
    op2 = r[rS2]                           # Get contents of source register 2</pre>&#13;
			<p lang="en-GB">In the next section, we depart from the original version of TC1. The first version of TC1 decoded the opcode as a binary string and then looked it up. However, as we have the source file, it is easier to go directly from the text of the mnemonic and execute it. This <a id="_idIndexMarker417"/><a id="_idIndexMarker418"/>makes the code so much easier to read:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Instead of using the binary opcode to determine the instruction, I use the text opcode&#13;
# It makes the code more readable if I use 'ADD' rather than its opcode&#13;
    mnemonic=next(key for key,value in codes.items() if value[1]==binOp&#13;
                                           # Get mnemonic from dictionary&#13;
### INTERPRET INSTRUCTIONS                    # Examine the opcode and execute it&#13;
    if   mnemonic == 'STOP': run = 0       # STOP ends the simulation&#13;
    elif mnemonic == 'END!': run = 0       # END! terminates reading source code and stops&#13;
    elif mnemonic == 'NOP':  pass          # NOP is a dummy instruction that does nothing&#13;
    elif mnemonic == 'GET':                # Reads integer from the keyboard&#13;
        printStatus()&#13;
        kbd = (input('Type integer '))     # Get input&#13;
        kbd = getLit(kbd)                  # Convert string to integer&#13;
        r[rD] = kbd                        # Store in register&#13;
        continue&#13;
    elif mnemonic == 'RND':  r[rD] = random.randint(0,lit)&#13;
                                           # Generate random number&#13;
    elif mnemonic == 'SWAP': r[rD] = shift(0,1,r[rD],8)&#13;
                                           # Swap bytes in a 16-bit word&#13;
    elif mnemonic == 'SEC':  c = 1         # Set carry flag&#13;
    elif mnemonic == 'LDRL': r[rD] = lit   # LDRL R0,20 loads R0 with literal 20&#13;
    elif mnemonic == 'LDRM': r[rD] = mem[lit]&#13;
                                           # Load register with memory location (LDRM)&#13;
    elif mnemonic == 'LDRI': r[rD] = mem[op1 + lit]&#13;
                                                   # LDRI r1,[r2,4] memory location [r2]+4&#13;
    elif mnemonic == 'STRM': mem[lit] = r[rD]      # STRM stores register in memory&#13;
    elif mnemonic == 'STRI': mem[op1 + lit] = r[rD] # STRI stores rD at location [rS1]+L&#13;
    elif mnemonic == 'MOVE': r[rD] = op1           # MOVE copies register rS1 to rD&#13;
    elif mnemonic == 'ADD':  r[rD] = alu('ADD',op1, op2)&#13;
                                                   # Adds [r2] to [r3] and puts result in r1&#13;
    elif mnemonic == 'ADDL': r[rD] = alu('ADD',op1,lit) # Adds 12 to [r2] and puts result in r1&#13;
    elif mnemonic == 'SUB':  r[rD] = alu('SUB',op1,op2) #&#13;
    elif mnemonic == 'SUBL': r[rD] = alu('SUB',op1,lit)&#13;
    elif mnemonic == 'MUL':  r[rD] = alu('MUL',op1,op2)&#13;
    elif mnemonic == 'MULL': r[rD] = alu('MUL',op1,lit)&#13;
    elif mnemonic == 'DIV':  r[rD] = alu('DIV',op1,op2) # Logical OR&#13;
    elif mnemonic == 'DIVL': r[rD] = alu('DIV',op1,lit)&#13;
    elif mnemonic == 'MOD':  r[rD] = alu('MOD',op1,op2) # Modulus&#13;
    elif mnemonic == 'MODL': r[rD] = alu('MOD',op1,lit)&#13;
    elif mnemonic == 'AND':  r[rD] = alu('AND',op1,op2) # Logical AND&#13;
    elif mnemonic == 'ANDL': r[rD] = alu('AND',op1,lit)&#13;
    elif mnemonic == 'OR':   r[rD] = alu('OR', op1,op2) # Logical OR&#13;
    elif mnemonic == 'ORL':  r[rD] = alu('OR', op1,lit)&#13;
    elif mnemonic == 'EOR':  r[rD] = alu('EOR',op1,op2) # Exclusive OR&#13;
    elif mnemonic == 'EORL': r[rD] = alu('EOR',op1,lit)&#13;
    elif mnemonic == 'NOT':  r[rD] = alu('NOT',op0,1)   # NOT r1 uses only one operand&#13;
    elif mnemonic == 'INC':  r[rD] = alu('ADD',op0,1)&#13;
    elif mnemonic == 'DEC':  r[rD] = alu('SUB',op0,1)&#13;
    elif mnemonic == 'CMP':  rr    = alu('SUB',op0,op1) # rr is a dummy variable&#13;
    elif mnemonic == 'CMPL': rr    = alu('SUB',op0,lit)&#13;
    elif mnemonic == 'ADC':  r[rD] = alu('ADC',op1,op2)&#13;
    elif mnemonic == 'SBC':  r[rD] = alu('SBC',op1,op2)&#13;
    elif mnemonic == 'LSL':  r[rD] = shift(0,0,op0,op1)&#13;
    elif mnemonic == 'LSLL': r[rD] = shift(0,0,op0,lit)&#13;
    elif mnemonic == 'LSR':  r[rD] = shift(1,0,op0,op1)&#13;
    elif mnemonic == 'LSRL': r[rD] = shift(1,0,op0,lit)&#13;
    elif mnemonic == 'ROL':  r[rD] = shift(1,1,op0,op2)&#13;
    elif mnemonic == 'ROLL': r[rD] = shift(1,1,op0,lit)&#13;
    elif mnemonic == 'ROR':  r[rD] = shift(0,1,op0,op2)&#13;
    elif mnemonic == 'RORL': r[rD] = shift(0,1,op0,lit)&#13;
    elif mnemonic == 'PRT':  print('Reg',rD,'=', '%04x' % r[rD])&#13;
    elif mnemonic == 'BRA':             pc = lit&#13;
    elif mnemonic == 'BEQ' and  z == 1: pc = lit&#13;
    elif mnemonic == 'BNE' and  z == 0: pc = lit&#13;
    elif mnemonic == 'BMI' and  n == 1: pc = lit&#13;
    elif mnemonic == 'DBEQ':                     # Decrement register and branch on zero&#13;
        r[rD] = r[rD] - 1&#13;
        if r[rD] != 0: pc = lit&#13;
    elif mnemonic == 'DBNE':            # Decrement register and branch on not zero&#13;
        r[rD] = alu('SUB',op0,1)        # Note the use of the alu function&#13;
        if z == 0: pc = lit&#13;
    elif mnemonic == 'BSR':             # Stack-based operations. Branch to subroutine&#13;
        sp = sp - 1                     # Pre-decrement stack pointer&#13;
        stack[sp] = pc                  # Push the pc (return address)&#13;
        pc = lit                        # Jump to target address&#13;
    elif mnemonic == 'RTS':             # Return from subroutine&#13;
        pc = stack[sp]                  # Pull pc address of the stack&#13;
        sp = sp + 1                     # Increment stack pointer&#13;
    elif mnemonic == 'PUSH':            # Push register to stack&#13;
        sp = sp - 1                     # Move stack pointer up to make space&#13;
        stack[sp] = op0                 # Push register in op on the stack&#13;
    elif mnemonic == 'PULL':            # Pull register off the stack&#13;
        r[rD] = stack[sp]               # Transfer stack value to register&#13;
        sp = sp + 1                     # Move stack down</pre>&#13;
			<p lang="en-GB">This section performs a function called tracing<a id="_idIndexMarker419"/><a id="_idIndexMarker420"/> and allows us to list the contents of the register or turn off the listing as we execute the code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                        # Instruction interpretation complete. Deal with display&#13;
    if silent == 0:                     # Read keyboard ONLY if not in silent mode&#13;
       x = input('&gt;&gt;&gt;')                 # Get keyboard input to continue&#13;
       if x == 'b': skipToBranch = 1    # Set flag to execute to branch with no display&#13;
       if x.isnumeric():                # Is this a trace mode with a number of steps to skip?&#13;
           traceMode = 1                # If so, set traceMode&#13;
           goCount   = getLit(x) + 1    # Record the number of lines to skip printing&#13;
    if skipToBranch == 1:               # Are we in skip-to-branch mode?&#13;
        silent = 1                      # If so, turn off printing status&#13;
        if mnemonic in branchGroup:     # Have we reached a branch?&#13;
            silent = 0                  # If branch, turn off silent mode and allow tracing&#13;
            skipToBranch = 0            # Turn off skip-to-branch mode&#13;
    if traceMode == 1:                  # If in silent mode (no display of data)&#13;
        silent = 1                      # Set silent flag&#13;
        goCount = goCount – 1           # Decrement silent mode count&#13;
        if goCount == 0:                # If we've reached zero, turn display on&#13;
            traceMode = 0               # Leave trace mode&#13;
            silent = 0                  # Set silent flag back to zero (off)</pre>&#13;
			<pre class="source-code">    if silent == 0: printStatus()</pre>&#13;
			<p lang="en-GB">Now that we’ve explained the TC1<a id="_idIndexMarker421"/><a id="_idIndexMarker422"/> simulator, we’ll demonstrate its use.</p>&#13;
			<h1 id="_idParaDest-106" lang="en-GB"><a id="_idTextAnchor106"/>Example of a TC1 assembly language program</h1>&#13;
			<p lang="en-GB">Here, we <a id="_idIndexMarker423"/><a id="_idIndexMarker424"/>demonstrate a TC1 program in assembly language. This offers a means of testing the simulator and showing how it works. We would like to test a range of facilities, so we should include looping, conditional testing, and pointer-based memory access. We will write a program to do the following:</p>&#13;
			<ol>&#13;
				<li lang="en-GB">Fill a region of memory from locations 0 to 4 with random numbers.</li>&#13;
				<li lang="en-GB">Reverse the order of the numbers.</li>&#13;
			</ol>&#13;
			<p lang="en-GB">Since this problem uses memory and sequential addresses, it involves register indirect addressing, that is, <code>LDRI</code> and <code>STRI</code> instructions. Creating the random numbers and storing them sequentially in memory can be done by doing the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Set a pointer to the first memory location (i.e.,0)&#13;
Set a counter to 5 (we are going to access five locations 0 to 4)&#13;
Repeat&#13;
  Generate a random number&#13;
  Store this number at the pointer address&#13;
  Point to next number (i.e., add 1 to the pointer)&#13;
  Decrement the counter (i.e., counter 5,4,3,2,1,0)&#13;
  Until counter = 0</pre>&#13;
			<p lang="en-GB">In TC1 code, we can translate this as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        LDRL <strong class="bold">r0</strong>,0             @ Use r0 as a memory pointer and set it to 0&#13;
        LDRL <strong class="bold">r1</strong>,5             @ Use r1 as the loop counter&#13;
  Loop1 RND  <strong class="bold">r2</strong>               @ Loop: Generate a random number in r2&#13;
        STRI r2,<strong class="bold">[r0]</strong>,<strong class="bold">0</strong>        @ Store the random number in memory using pointer r0&#13;
        INC  <strong class="bold">r0</strong>               @ Point to the next location (add 1 to the pointer)&#13;
        DEC  <strong class="bold">r1</strong>               @ Decrement the loop counter (subtract 1 from the counter)&#13;
        BNE  Loop1            @ Repeat until 0 (branch back to Loop1 if the last result was not 0)</pre>&#13;
			<p lang="en-GB">We’ve filled a region of memory with random values. We now need to reverse their order. There are many ways of reversing the order of numbers. One is to move the numbers from the source to a temporary location in memory and then write them back in reverse order. Of course, this takes up extra memory for the temporary copy. Consider another solution that does not require a buffer. We will write down the source addresses above the destination addresses:</p>&#13;
			<p lang="en-GB"><code>Original (source)        0   1   2   3   4</code></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>Swapped (destination)    4   3   2   1   0</code></p>&#13;
			<p lang="en-GB">As you can see, location <code>0</code> is swapped with location <code>4</code>, then location <code>1</code> with location <code>3</code>; then, at location <code>2</code>, we have reached the middle point and the reversal is complete. To perform this action, we need two pointers, one for each end of the string. We select the two characters at the ends of the string and swap them. Then, we move the pointers inward and do a second swap. The task is<a id="_idIndexMarker425"/><a id="_idIndexMarker426"/> complete when the pointers meet in the middle. Note that this assumes an odd number of items to reverse:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Set upper pointer to top&#13;
Set lower pointer to bottom&#13;
Repeat&#13;
   Get value at upper pointer&#13;
   Get value at lower pointer&#13;
   Swap values and store&#13;
Until upper pointer and lower pointer are equal</pre>&#13;
			<p lang="en-GB">In TC1 assembly language, this looks as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      LDRL <strong class="bold">r0</strong>,0                @ Lower pointer points at first entry in table&#13;
      LDRL <strong class="bold">r1</strong>,4                @ Upper pointer points at last entry in table&#13;
<strong class="bold">Loop2 LDRI r2,[r0],0</strong>           @ REPEAT: Get lower value pointed at by r0&#13;
      <strong class="bold">LDRI r3,[r1],0</strong>           @ Get upper value pointed at by r1&#13;
      MOVE r2,r4               @ Save lower value in r4 temporarily&#13;
      <strong class="bold">STRI r3,[r0],0</strong>           @ Store upper value in lower entry position&#13;
      <strong class="bold">STRI r4,[r1],0</strong>           @ Store saved lower value in upper entry position&#13;
      INC  <strong class="bold">r0</strong>                  @ Increase lower pointer&#13;
      DEC  <strong class="bold">r1</strong>                  @ Decrease upper pointer&#13;
      CMP  r0,r1               @ Compare pointers&#13;
      BNE  Loop2               @ UNTIL all characters moved</pre>&#13;
			<p lang="en-GB">The following shows the output when this program is executed, instruction by instruction. In order to simplify the reading of this data, we’ve put changes in register and memory values in bold. The branch operations are shaded. Comparison instructions are in italics.</p>&#13;
			<p lang="en-GB">The first block is the source code printed by TC1 before the start of the instruction execution:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
TC1 CPU simulator 11 September 2022&#13;
Input debug level 1 - 5: 4&#13;
Source assembly code listing&#13;
0           LDRL R0 0&#13;
1           LDRL R1 5&#13;
2   LOOP1   RND  R2&#13;
3           STRI R2 R0 0&#13;
4           INC  R0&#13;
5           DEC  R1&#13;
6           BNE  LOOP1&#13;
7           NOP&#13;
8           LDRL R0 0&#13;
9           LDRL R1 4&#13;
10  LOOP2   LDRI R2 R0 0&#13;
11          LDRI R3 R1 0&#13;
12          MOVE R4 R2&#13;
13          STRI R3 R0 0&#13;
14          STRI R4 R1 0&#13;
15          INC  R0&#13;
16          DEC  R1&#13;
17          CMP  R0 R1&#13;
18          BNE  LOOP2&#13;
19          NOP&#13;
20          STOP&#13;
21          END!&#13;
Equate and branch table&#13;
START    0&#13;
LOOP1    2&#13;
LOOP2    10</pre>&#13;
			<p lang="en-GB">The second code block shows the <a id="_idIndexMarker427"/><a id="_idIndexMarker428"/>output of the assembler as instructions are decoded. You can see the various registers, the literal, and the format field:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Decoded instructions&#13;
pc=00 Op =       LDRL R0 0        literal 0000 RD=0 rS1=0 rS2=0 format=1001&#13;
pc=01 Op =       LDRL R1 5        literal 0005 RD=1 rS1=0 rS2=0 format=1001&#13;
<strong class="bold">pc</strong>=02 Op=  LOOP1 RND R2 0XFFFF    literal ffff RD=2 rS1=0 rS2=0 format=1001&#13;
pc=03 Op =       STRI R2 R0 0     literal 0000 RD=2 rS1=0 rS2=0 format=1101&#13;
pc=04 Op =       INC  R0          literal 0000 RD=0 rS1=0 rS2=0 format=1000&#13;
pc=05 Op =       DEC  R1          literal 0000 RD=1 rS1=0 rS2=0 format=1000&#13;
pc=06 Op =       BNE  LOOP1       literal 0002 RD=0 rS1=0 rS2=0 format=0001&#13;
pc=07 Op =       NOP              literal 0000 RD=0 rS1=0 rS2=0 format=0000&#13;
pc=08 Op =       LDRL R0 0        literal 0000 RD=0 rS1=0 rS2=0 format=1001&#13;
pc=09 Op =       LDRL R1 4        literal 0004 RD=1 rS1=0 rS2=0 format=1001&#13;
pc=10 Op=  LOOP2 LDRI R2 R0 0     literal 0000 RD=2 rS1=0 rS2=0 format=1101&#13;
pc=11 Op =       LDRI R3 R1 0     literal 0000 RD=3 rS1=1 rS2=0 format=1101&#13;
pc=12 Op =       MOVE R4 R2       literal 0000 RD=4 rS1=2 rS2=0 format=1100&#13;
pc=13 Op =       STRI R3 R0 0     literal 0000 RD=3 rS1=0 rS2=0 format=1101&#13;
pc=14 Op =       STRI R4 R1 0     literal 0000 RD=4 rS1=1 rS2=0 format=1101&#13;
pc=15 Op =       INC  R0          literal 0000 RD=0 rS1=0 rS2=0 format=1000&#13;
pc=16 Op =       DEC  R1          literal 0000 RD=1 rS1=0 rS2=0 format=1000&#13;
pc=17 Op =       CMP  R0 R1       literal 0000 RD=0 rS1=1 rS2=0 format=1100&#13;
pc=18 Op =       BNE  LOOP2       literal 000a RD=0 rS1=0 rS2=0 format=0001&#13;
pc=19 Op =       NOP              literal 0000 RD=0 rS1=0 rS2=0 format=0000&#13;
pc=20 Op =       STOP             literal 0000 RD=0 rS1=0 rS2=0 format=0000&#13;
pc=21 Op =       END!             literal 0000 RD=0 rS1=0 rS2=0 format=0000</pre>&#13;
			<p lang="en-GB">The following provides the output of a run using this program. We’ve set the trace level to <code>4</code> to show the source code (after text processing), the symbol table, and the decoded instructions.</p>&#13;
			<p lang="en-GB">Then, we’ve executed the code line by line. In order to make the output more readable and to fit it on the page, we’ve removed registers and <a id="_idIndexMarker429"/><a id="_idIndexMarker430"/>memory locations that don’t change, and we’ve highlighted values (memory, registers, and z-flag) that change as the result of an instruction. You can follow this through and see how memory/registers change with each instruction.</p>&#13;
			<p lang="en-GB">As you can see, we create five random numbers in memory locations <code>0</code> to <code>4</code> and then reverse their order. This does not match the output of the print status because it’s been modified for printing:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
0         LDRL R0 0         PC =  0 z = 0 0000 0000 0000 0000 0000&#13;
                            R  <strong class="bold">0000</strong> 0000 0000 0000 0000&#13;
1         LDRL R1 5         PC =  1 z = 0 0000 0000 0000 0000 0000&#13;
                            R  0000 <strong class="bold">0005</strong> 0000 0000 0000&#13;
2  LOOP1  RND  R2           PC =  2 z = 0 0000 0000 0000 0000 0000&#13;
                            R  0000 0005 9eff 0000 0000&#13;
3         STRI R2 R0 0      PC =  3 z = 0 <strong class="bold">9eff</strong> 0000 0000 0000 0000&#13;
                            R  0000 0005 9eff 0000 0000&#13;
4         INC  R0           PC =  4 z = 0 9eff 0000 0000 0000 0000&#13;
                            R  <strong class="bold">0001</strong> 0005 9eff 0000 0000&#13;
5         DEC  R1           PC =  5 z = 0 9eff 0000 0000 0000 0000&#13;
                            R  0001 <strong class="bold">0004</strong> 9eff 0000 0000&#13;
6         <strong class="bold">BNE  LOOP1</strong>        PC =  6 z = 0 9eff 0000 0000 0000 0000&#13;
                            R  0001 0004 9eff 0000 0000&#13;
2  LOOP1  RND  R2           <strong class="bold">PC =  2</strong> z = 0 9eff 0000 0000 0000 0000&#13;
                            R  0001 0004 <strong class="bold">6d4a</strong> 0000 0000&#13;
3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a 0000 0000 0000&#13;
                            R  0001 0004 6d4a 0000 0000&#13;
4         INC  R0           PC =  4 z = 0 9eff 6d4a 0000 0000 0000&#13;
                            R  <strong class="bold">0002</strong> 0004 6d4a 0000 0000&#13;
5         DEC  R1           PC =  5 z = 0 9eff 6d4a 0000 0000 0000&#13;
                            R  0002 <strong class="bold">0003</strong> 6d4a 0000 0000&#13;
6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a 0000 0000 0000&#13;
                            R  0002 0003 6d4a 0000 0000&#13;
2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a 0000 0000 0000&#13;
                            R  0002 0003 <strong class="bold">a387</strong> 0000 0000&#13;
3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 0000 0000&#13;
                            R  0002 0003 a387 0000 0000&#13;
4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 0000 0000&#13;
                            R  0003 <strong class="bold">0003</strong> a387 0000 0000&#13;
5         DEC  R1           PC =  5 z = 0 9eff 6d4a a387 0000 0000&#13;
                            R  0003 <strong class="bold">0002</strong> a387 0000 0000&#13;
6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a a387 0000 0000&#13;
                            R  0003 0002 a387 0000 0000&#13;
2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a a387 0000 0000&#13;
                            R  0003 0002 <strong class="bold">2937</strong> 0000 0000&#13;
3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 2937 0000&#13;
                            R  0003 0002 2937 0000 0000&#13;
4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 2937 0000&#13;
                            R  <strong class="bold">0004</strong> 0002 2937 0000 0000&#13;
5         DEC  R1           PC =  5 z = 0 9eff 6d4a a387 2937 0000&#13;
                            R  0004 <strong class="bold">0001</strong> 2937 0000 0000&#13;
6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a a387 2937 0000&#13;
                            R  0004 0001 2937 0000 0000&#13;
2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a a387 2937 0000&#13;
                            R  0004 0001 <strong class="bold">db95</strong> 0000 0000&#13;
3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 2937 <strong class="bold">db95</strong>&#13;
                            R  0004 0001 db95 0000 0000&#13;
4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 2937 db95&#13;
                            R  <strong class="bold">0005</strong> 0001 db95 0000 0000&#13;
5         DEC  R1           PC =  5 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0005 <strong class="bold">0000</strong> db95 0000 0000&#13;
6         BNE LOOP1         PC =  6 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0005 0000 db95 0000 0000&#13;
7         NOP               PC =  7 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0005 0000 db95 0000 0000&#13;
8         LDRL R0 0         PC =  8 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0000 0000 db95 0000 0000&#13;
9         LDRL R1 4         PC =  9 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0000 <strong class="bold">0004</strong> db95 0000 0000&#13;
10 LOOP2  LDRI R2 R0 0      PC = 10 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0000 0004 <strong class="bold">9eff</strong> 0000 0000&#13;
11        LDRI R3 R1 0      PC = 11 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0000 0004 9eff <strong class="bold">db95</strong> 0000&#13;
12        MOVE R4 R2        PC = 12 z = 1 9eff 6d4a a387 2937 db95&#13;
                            R  0000 0004 9eff db95 <strong class="bold">9eff</strong>&#13;
13        STRI R3 R0 0      PC = 13 z = 1 <strong class="bold">db95</strong> 6d4a a387 2937 db95&#13;
                            R  0000 0004 9eff db95 9eff&#13;
14        STRI R4 R1 0      PC = 14 z = 1 db95 6d4a a387 2937 <strong class="bold">9eff</strong>&#13;
                            R  0000 0004 9eff db95 9eff&#13;
15        INC  R0           PC = 15 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  <strong class="bold">0001</strong> 0004 9eff db95 9eff&#13;
16        DEC  R1           PC = 16 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  0001 <strong class="bold">0003</strong> 9eff db95 9eff&#13;
17        CMP  R0 R1        PC = 17 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  0001 0003 9eff db95 9eff&#13;
18        BNE  LOOP2        PC = 18 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  0001 0003 9eff db95 9eff&#13;
10 LOOP2  LDRI R2 R0 0      PC = 10 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  0001 0003 <strong class="bold">6d4a</strong> db95 9eff&#13;
11        LDRI R3 R1 0      PC = 11 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  0001 0003 6d4a <strong class="bold">2937</strong> 9eff&#13;
12        MOVE R4 R2        PC = 12 z = 0 db95 6d4a a387 2937 9eff&#13;
                            R  0001 0003 6d4a 2937 <strong class="bold">6d4a</strong>&#13;
13        STRI R3 R0 0      PC = 13 z = 0 db95 <strong class="bold">2937</strong> a387 2937 9eff&#13;
                            R  0001 0003 6d4a 2937 6d4a&#13;
14        STRI R4 R1 0      PC = 14 z = 0 db95 2937 a387 6d4a 9eff&#13;
                            R  0001 0003 6d4a 2937 6d4a&#13;
15        INC  R0           PC = 15 z = 0 db95 2937 a387 6d4a 9eff&#13;
                            R  <strong class="bold">0002</strong> 0003 6d4a 2937 6d4a&#13;
16        DEC  R1           PC = 16 z = 0 db95 2937 a387 6d4a 9eff&#13;
                            R  <strong class="bold">0002</strong> 0002 6d4a 2937 6d4a&#13;
17        CMP  R0 R1        PC = 17 z = 1 db95 2937 a387 6d4a 9eff&#13;
                            R  0002 0002 6d4a 2937 6d4a&#13;
18        BNE  LOOP2        PC = 18 <strong class="bold">z = 1</strong> db95 2937 a387 6d4a 9eff&#13;
                            R  0002 0002 6d4a 2937 6d4a&#13;
19        NOP               PC = 19 z = 1 db95 2937 a387 6d4a 9eff&#13;
                            R  0002 0002 6d4a 2937 6d4a&#13;
20        STOP              PC = 20 z = 1 db95 2937 a387 6d4a 9eff&#13;
                            R  0002 0002 6d4a 2937 6d4a</pre>&#13;
			<p lang="en-GB">In the next section, we demonstrate how <a id="_idIndexMarker431"/><a id="_idIndexMarker432"/>you might go about testing the operation of TC1. We cover the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Testing the assembler (e.g., the ability to use a free format of code)</li>&#13;
				<li lang="en-GB">Testing flow control instructions (branches)</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Testing shift operations</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-107" lang="en-GB"><a id="_idTextAnchor107"/>Testing the assembler</h1>&#13;
			<p lang="en-GB">Since the TC1 assembler can<a id="_idIndexMarker433"/><a id="_idIndexMarker434"/> deal with several typographic features (e.g., uppercase or lowercase and multiple spaces), a simple way of testing the assembler is to give it a file to assemble that includes various conditions, such as multiple spaces, equates, and uppercase and lowercase conversion. My initial test source code was as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
     NOP&#13;
 BRA eee&#13;
      INC r4&#13;
alan inc r5&#13;
eee    STOP&#13;
aa NOP @comment2&#13;
bb NOP     1&#13;
      LDRL      r0,   12&#13;
      LDRL r3,0x123 @ comment1&#13;
      LDRL r7,     0xFF&#13;
      INC R2&#13;
  BRA last&#13;
test1     EQU    999&#13;
  @comment3&#13;
@comment4&#13;
  @ qqq EQU 7&#13;
www STRI r1,r2,1&#13;
abc   equ 25&#13;
qwerty  equ   888&#13;
last LDRL r5,0xFAAF&#13;
  beQ Aa&#13;
      STOP 2</pre>&#13;
			<p lang="en-GB">This is not exactly stylish code; it’s just random test code. In the following code, we provide the output of the assembler when operated in <code>debug</code> mode. This includes the formatting of the code (removal of blank lines and lowercase to uppercase conversion). The first listing provides the instructions as an array of lists of tokens:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
TC1 CPU simulator 11 September 2022&#13;
Input debug level 1 - 5: 4&#13;
Source assembly code listing&#13;
0           NOP&#13;
1           BRA EEE&#13;
2           INC R4&#13;
3   ALAN    INC R5&#13;
4   EEE     STOP&#13;
5   AA      NOP&#13;
6   BB      NOP 1&#13;
7           LDRL R0 12&#13;
8           LDRL R3 0X123&#13;
9           LDRL R7 0XFF&#13;
10          INC R2&#13;
11          BRA LAST&#13;
12  WWW     STRI R1 R2 1&#13;
13  LAST    LDRL R5 0XFAAF&#13;
14          BEQ AA&#13;
15          STOP 2</pre>&#13;
			<p lang="en-GB">The second listing is the symbol table that ties<a id="_idIndexMarker435"/><a id="_idIndexMarker436"/> symbol names and labels to integer values:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Equate and branch table&#13;
START    0&#13;
TEST1    999&#13;
ABC      25&#13;
QWERTY   888&#13;
ALAN     3&#13;
EEE      4&#13;
AA       5&#13;
BB       6&#13;
WWW      12&#13;
LAST     13&#13;
LOOP1    18&#13;
LOOP2    26</pre>&#13;
			<p lang="en-GB">The next listing was used largely for debugging when an instruction didn’t behave as intended. It lets you determine whether an instruction has been correctly decoded:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Decoded instructions&#13;
pc=0  op=NOP                  literal 000 Dest reg=0 rS1-0 rS2=0 format=0000&#13;
pc=00 Op=NOP                  literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000&#13;
pc=01 Op=BRA EEE              literal 0004 Dest reg=0 rS1=0 rS2=0 format=0001&#13;
pc=02 Op=INC R4               literal 0000 Dest reg=4 rS1=0 rS2=0 format=1000&#13;
pc=03 Op=ALAN INC R5          literal 0000 Dest reg=5 rS1=0 rS2=0 format=1000&#13;
pc=04 Op=EEE STOP             literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000&#13;
pc=05 Op=AA NOP               literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000&#13;
pc=06 Op=BB NOP 1             literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000&#13;
pc=07 Op=LDRL R0 12           literal 000c Dest reg=0 rS1=0 rS2=0 format=1001&#13;
pc=08 Op=LDRL R3 0X123        literal 0123 Dest reg=3 rS1=0 rS2=0 format=1001&#13;
pc=09 Op=LDRL R7 0XFF         literal 00ff Dest reg=7 rS1=0 rS2=0 format=1001&#13;
pc=10 Op=INC R2               literal 0000 Dest reg=2 rS1=0 rS2=0 format=1000&#13;
pc=11 Op=BRA LAST             literal 000d Dest reg=0 rS1=0 rS2=0 format=0001&#13;
pc=12 Op=WWW STRI R1 R2 1     literal 0001 Dest reg=1 rS1=2 rS2=0 format=1101&#13;
pc=13 Op=LAST LDRL R5 0XFAAF   literal faaf Dest reg=5 rS1=0 rS2=0 format=1001&#13;
pc=14 Op=BEQ AA               literal 0005 Dest reg=0 rS1=0 rS2=0 format=0001&#13;
pc=15 Op=STOP 2               literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000&#13;
&gt;&gt;&gt;</pre>&#13;
			<h2 id="_idParaDest-108" lang="en-GB"><a id="_idTextAnchor108"/>Testing flow control operations</h2>&#13;
			<p lang="en-GB">Here, we demonstrate how to test the<a id="_idIndexMarker437"/><a id="_idIndexMarker438"/> computer’s most important class of operations, the flow-control instruction, that is, the conditional branch.</p>&#13;
			<p lang="en-GB">One of the most important classes of instructions to test are those that change the flow of control: the branch and subroutine call instructions. The following fragment of code is also meaningless (it serves only to test instruction execution) and is designed only to test loops. One loop is built using a branch on a not-zero operation, and the other uses an automatic loop mechanism that operates by decrementing a register and branching until the register decrements to zero. The <code>DBNE</code> <code>r0</code>,<code>loop</code>, where <code>r0</code> is the<a id="_idIndexMarker439"/><a id="_idIndexMarker440"/> counter being decremented and <code>loop</code> is the branch target address.</p>&#13;
			<p lang="en-GB">We first provide the source listing and symbol table:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; %Run TC1_FinalForBook_V1.2_20220911.py&#13;
TC1 CPU simulator 11 September 2022&#13;
Input debug level 1 - 5: 4&#13;
Source assembly code listing&#13;
0           NOP&#13;
1           BRA LAB1&#13;
2           INC R0&#13;
3   LAB1    INC R2&#13;
4           NOP&#13;
5           BRA LAB6&#13;
6           NOP&#13;
7   LAB2    LDRL R2 3&#13;
8   LAB4    DEC R2&#13;
9           NOP&#13;
10          BNE LAB4&#13;
11          NOP&#13;
12          BSR LAB7&#13;
13          NOP&#13;
14          LDRL R3 4&#13;
15  LAB5    NOP&#13;
16          INC R7&#13;
17          DBNE R3 LAB5&#13;
18          NOP&#13;
19          STOP&#13;
20  LAB6    BRA LAB2&#13;
21          NOP&#13;
22  LAB7    DEC R7&#13;
23          DEC R7&#13;
24          RTS&#13;
25          END!&#13;
Equate and branch table&#13;
START    0&#13;
LAB1     3&#13;
LAB2     7&#13;
LAB4     8&#13;
LAB5     15&#13;
LAB6     20&#13;
LAB7     22</pre>&#13;
			<p lang="en-GB">The following provides the output after a<a id="_idIndexMarker441"/><a id="_idIndexMarker442"/> debugging session. As you can see, the sequence of branches is faithfully implemented. Note that we’ve highlighted the branch actions and consequences (i.e., the next instruction):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
0         NOP               PC= 0 z=0 n=0 c=0 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
1         <strong class="bold">BRA LAB1</strong>          PC= 1 z=0 n=0 c=0&#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
<strong class="bold">3  LAB1</strong>   INC R2            PC= 3 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
4         NOP               PC= 4 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
5         <strong class="bold">BRA LAB6</strong>          PC= 5 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
<strong class="bold">20 LAB6</strong>   <strong class="bold">BRA LAB2</strong>          PC=20 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
<strong class="bold">7  LAB2</strong>   LDRL R2 3         PC= 7 z=0 n=0 c=1 &#13;
                            R  0000 0000 0003 0000 0000 0000 0000 0000&#13;
<strong class="bold">8  LAB4</strong>   DEC R2            PC= 8 z=0 n=0 c=1 &#13;
                            R  0000 0000 0002 0000 0000 0000 0000 0000&#13;
9         NOP               PC= 9 z=0 n=0 c=1 &#13;
                            R  0000 0000 0002 0000 0000 0000 0000 0000&#13;
10        <strong class="bold">BNE LAB4</strong>          PC=10 z=0 n=0 c=1 &#13;
                            R  0000 0000 0002 0000 0000 0000 0000 0000&#13;
<strong class="bold">8  LAB4</strong>   DEC R2            PC= 8 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
9         NOP               PC= 9 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
10        <strong class="bold">BNE LAB4</strong>          PC=10 z=0 n=0 c=1 &#13;
                            R  0000 0000 0001 0000 0000 0000 0000 0000&#13;
<strong class="bold">8  LAB4</strong>   DEC R2            PC= 8 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
9         NOP               PC= 9 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
10        <strong class="bold">BNE LAB4</strong>          PC=10 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
11        NOP               PC=11 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
12        BSR LAB7          PC=12 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0000&#13;
<strong class="bold">22 LAB7</strong>   DEC R7            PC=22 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 ffff&#13;
23        DEC R7            PC=23 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 fffe&#13;
24        <strong class="bold">RTS</strong>               PC=24 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 fffe&#13;
13        NOP               PC=13 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 fffe&#13;
14        LDRL R3 4         PC=14 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0004 0000 0000 0000 fffe&#13;
<strong class="bold">15 LAB5</strong>   NOP               PC=15 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0004 0000 0000 0000 fffe&#13;
16        INC R7            PC=16 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0004 0000 0000 0000 ffff&#13;
17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0003 0000 0000 0000 ffff&#13;
<strong class="bold">15 LAB5</strong>   NOP               PC=15 z=0 n=1 c=1 &#13;
                            R  0000 0000 0000 0003 0000 0000 0000 ffff&#13;
16        INC R7            PC=16 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0003 0000 0000 0000 0000&#13;
17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0002 0000 0000 0000 0000&#13;
<strong class="bold">15 LAB5</strong>   NOP               PC=15 z=1 n=0 c=0 &#13;
                            R  0000 0000 0000 0002 0000 0000 0000 0000&#13;
16        INC R7            PC=16 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0002 0000 0000 0000 0001&#13;
17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0001 0000 0000 0000 0001&#13;
<strong class="bold">15 LAB5</strong>   NOP               PC=15 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0001 0000 0000 0000 0001&#13;
16        INC R7            PC=16 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0001 0000 0000 0000 0002&#13;
17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0002&#13;
18        NOP               PC=18 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0002&#13;
19        STOP              PC=19 z=0 n=0 c=1 &#13;
                            R  0000 0000 0000 0000 0000 0000 0000 0002</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In the next chapter, we will look at <a id="_idIndexMarker443"/><a id="_idIndexMarker444"/>some of the ways in which the TC1 program can be enhanced to add facilities such as error checking, the inclusion of new instructions, and special features such as variable-length operand fields.</p>&#13;
			<h2 id="_idParaDest-109" lang="en-GB"><a id="_idTextAnchor109"/>Testing shift operations</h2>&#13;
			<p lang="en-GB">TC1 supports two shift types: <em class="italic">logical </em>and <em class="italic">rotate</em>. A logical shift moves the bits left or right. At one end, vacated bits are replaced by zeros and, at the other end, the bit shifted out is copied to the carry flag. In a rotation, the bit that is shifted out of one<a id="_idIndexMarker445"/><a id="_idIndexMarker446"/> end is copied to the other end; that is, the string of bits is treated as a ring. No bit is lost, no matter how many shifts take place. At each bit shift, the bit that was shifted to the other end is also copied to the carry bit.</p>&#13;
			<p lang="en-GB">Most real computers have two other shift variations: an arithmetic shift that preserves the sign of two’s complement numbers when shifted right (divide-by-2 operation) and a rotate-through-carry shift where the bit shifted in at one end is the old carry bit and the bit shifted out becomes the new carry bit. Essentially, if the register has <code>m</code> bits, the carry bit is included to create an <code>m+1</code> bit word. This feature is used for multi-precision arithmetic. We haven’t included these modes in TC1.</p>&#13;
			<p lang="en-GB">As well as specifying the shift type, we have to specify the shift direction (left or right). Most computers let you specify the number of shifts. We provide both facilities and the number of shifts can be specified using either a register or a literal. In a multi-length shift, the state of the carry bit is the last bit shifted out into the carry. The shift operations (with examples) are as follows:</p>&#13;
			<table id="table001-4" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Shift Type</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Register/Literal</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="bold">Example</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical shift left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LSLL r0,r1,2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical shift left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LSL r3,r1,r4</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical shift right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LSRL r0,r1,2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical shift right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>LSR r3,r1,r2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Rotate left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ROLL r0,r1,2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Rotate left</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ROL  </code><code>r3,r1,r0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Rotate right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">literal</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>RORL r0,r3,2</code></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Rotate right</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">register</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><code>ROR  </code><code>r3,r1,r0</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – TC1 shifting modes</p>&#13;
			<p lang="en-GB">When we test these instructions, we have to ensure that the shift direction is correct, the right number of shifts take place, the end bits (those <a id="_idIndexMarker447"/><a id="_idIndexMarker448"/>shifted out or in) behave correctly, and the flag bits are set appropriately.</p>&#13;
			<p lang="en-GB">Consider the following fragment of code using the 16-bit value <code>1000000110000001</code> in a series of shifts:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
LDRL r1,%1000000110000001&#13;
LSLL r0,r1,1&#13;
LSLL r0,r1,2&#13;
LSRL r0,r1,1&#13;
LSRL r0,r1,1&#13;
LDRL r1,%1000000110000001&#13;
LDRL r2,1&#13;
LDRL r3,2&#13;
LSLL r0,r1,r2&#13;
LSLL r0,r1,r3&#13;
LSRL r0,r1,r2&#13;
LSRL r0,r1,r2</pre>&#13;
			<p lang="en-GB">The following output from the simulator (edited to show only relevant information) gives the registers and condition codes as the preceding code is executed. The binary value of register <code>r0</code> is displayed on the right. This allows us to verify whether the operations have been executed correctly by manual inspection:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
1  LDRL R1 %1000000110000001 z = 0 n = 0 c = 0 &#13;
   Regs 0 - 3  0000 8181 0000 0000  R0 =  0000000000000000&#13;
2  LSLL R0 R1 1              z = 0 n = 0 c = 1 &#13;
   Regs 0 – 3  0302 8181 0000 0000  R0 =  <strong class="bold">0000001100000010</strong>&#13;
3  LSLL R0 R1 2              z = 0 n = 0 c = 0 &#13;
   Regs 0 - 3  0604 8181 0000 0000  R0 =  <strong class="bold">0000011000000100</strong>&#13;
4  LSRL R0 R1 1              z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  40c0 8181 0000 0000  R0 =  <strong class="bold">0100000011000000</strong>&#13;
5  LSRL R0 R1 1              z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  40c0 8181 0000 0000  R0 =  <strong class="bold">0100000011000000</strong>&#13;
6  LDRL R1 %1000000110000001 z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  40c0 8181 0000 0000  R0 =  0100000011000000&#13;
7  LDRL R2 1                 z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  40c0 8181 0001 0000  R0 =  0100000011000000&#13;
8  LDRL R3 2                 z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  40c0 8181 0001 0002  R0 =  0100000011000000&#13;
9  LSL  R0 R1 R2             z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  0302 8181 0001 0002  R0 =  0000001100000010&#13;
10 LSL  R0 R1 R3             z = 0 n = 0 c = 0 &#13;
   Regs 0 - 3  0604 8181 0001 0002  R0 =  0000011000000100&#13;
11 LSR  R0 R1 R2             z = 0 n = 0 c = 1 &#13;
   Regs 0 - 3  40c0 8181 0001 0002  R0 =  0100000011000000&#13;
12 LSR  R0 R1 R2             z = 0 n = 0 c = 1 </pre>&#13;
			<pre class="source-code">   Regs 0 – 3  40c0 8181 0001 0002  R0 =  0100000011000000</pre>&#13;
			<p lang="en-GB">Note that a load operation does not affect the z-bit. Some computers update the z-bit after almost every operation. Some update the z-bit on demand (e.g., ARM, which we will introduce later), and some update it only after certain operations.</p>&#13;
			<p lang="en-GB">The penultimate section of this chapter<a id="_idIndexMarker449"/><a id="_idIndexMarker450"/> covers adding a postscript to TC1 where we provide a simpler example that performs the same basic function but carries out some operations in a different way, such as instruction decoding. The purpose of this is to demonstrate that there are many ways of constructing a simulator.</p>&#13;
			<h1 id="_idParaDest-110" lang="en-GB"><a id="_idTextAnchor110"/>TC1 postscript</h1>&#13;
			<p lang="en-GB">The version of TC1 presented here <a id="_idIndexMarker451"/><a id="_idIndexMarker452"/>grew during the development of this book. The current version has more features than the prototype; for example, initially, it didn’t include symbolic branch addresses and required users to enter actual line numbers.</p>&#13;
			<p lang="en-GB">Here, we’re presenting a cut-down version of TC1, called TC1mini, where we do some things differently; for example, by not allowing a free format (mnemonics must be uppercase and registers lowercase, and you can’t use spaces and commas as interchangeable delimiters). In this version, a simple function checks that the mnemonic is valid and terminates the program if it isn’t. Similarly, we’ve added a feature that checks whether an address generated by a pointer lies within the bounds of your memory space. The following section provides some comments on this version.</p>&#13;
			<h2 id="_idParaDest-111" lang="en-GB"><a id="_idTextAnchor111"/>The classDecode function</h2>&#13;
			<p lang="en-GB">TC1 associates a 4-bit binary value with each<a id="_idIndexMarker453"/><a id="_idIndexMarker454"/> instruction to indicate that parameters are required by the current instruction; for example, <code>1101</code> indicates registers <code>rD</code>, <code>rS1</code>, and a literal. The TC1mini version associates a <em class="italic">class number</em> in the<a id="_idIndexMarker455"/><a id="_idIndexMarker456"/> range <code>0</code> to <code>7</code>, with each instruction that describes its type. The classes range from <code>0</code> (mnemonic with no parameters) to <code>7</code> (mnemonic with an indirect address, such as <code>LDRI r2,[r4])</code>. Unlike TC1, the <code>[ ]</code> brackets are not optional in TC1mini's assembly language.</p>&#13;
			<p lang="en-GB">The difference between the two simulators, TC1 and TC1mini, is that the 4-bit binary code provides <em class="italic">pre-decoding</em>; that is, the simulator doesn’t have to calculate what parameters the instruction requires because the code directly tells you that. If you use a class number instead, you have to decode the class number to determine the actual parameters required. However, a class number can be very creative. TC1mini uses seven different instruction formats and requires a minimum of seven classes to be defined. If you had, say, 14 classes, each addressing mode class could be divided into two subclasses to give you greater control over the instruction execution process.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The <code>classDecode</code> function takes in an instruction’s predicate and returns the four predicate values, the destination register, source register <code>1</code>, source register <code>2</code>, and the literal. Of course, instructions may have from zero to four of these values. Consequently, these parameters are initially set to dummy values, either a <code>null</code> string or zero.</p>&#13;
			<p lang="en-GB">Before continuing, recall that Python’s <code>in</code> operator is useful for testing whether an element is a member of a set. For example, if an operation is in classes 2, 4, 5, and 9, we can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if thisThing in [2, 4, 5, 9]:                         # Test for membership of the set&#13;
def classDecode(predicate):&#13;
    lit,rD,rS1,rS2 = '',0,0,0                         # The literal is a null string initially&#13;
    if opClass in [1]:      lit = predicate           # Class 1 is mnemonic plus a literal&#13;
    if opClass in [2]:      rD  = reg1[predicate]     # Class 2 is mnemonic plus a literal&#13;
    if opClass in [3,4,5,6,7]:                   # Classes 3 to 7 have multiple parameters&#13;
        predicate = predicate.split(',')              # So, split predicate into tokens&#13;
        rD = reg1[predicate[0]]                       # Get first token (register number)</pre>&#13;
			<p lang="en-GB">The current instruction’s <code>opClass</code> is used to <a id="_idIndexMarker457"/><a id="_idIndexMarker458"/>extract the parameters. Instead of using <code>if</code> constructs, we’ve used Python’s <code>if in [list]</code> construct; for example, <code>if opClass in [3,4,5,6,7]</code> returns <code>True</code> if the instruction is in classes <code>3</code> to <code>7</code>. If it is, the predicate (a string) is divided into a list using the <code>split()</code> function, and the first <a id="_idIndexMarker459"/><a id="_idIndexMarker460"/>element is read to extract the destination register, <code>rD</code>. Note that we need to split the predicate only once, because all the following cases also fall within this group.</p>&#13;
			<h2 id="_idParaDest-112" lang="en-GB"><a id="_idTextAnchor112"/>The testLine function</h2>&#13;
			<p lang="en-GB">Another limitation of TC1 is the lack of testing<a id="_idIndexMarker461"/><a id="_idIndexMarker462"/> and validation; for example, I sometimes type <code>MOVE</code> instead of <code>MOV</code> and the program crashes. Normally, this isn’t a problem; you just re-edit the source program. However, when debugging TC1, I often assumed an <a id="_idIndexMarker463"/><a id="_idIndexMarker464"/>error was due to a mistake in my new code, only to discover that it was simply a misprint in the assembly language program. So, I added a small amount of testing. The following provides the testing function:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def testLine(tokens):                    # Check whether there's a valid instruction in this line&#13;
    error = 1                            # error flag = 1 for no error and 0 for an error state&#13;
    if len(tokens) == 1:                 # If the line is a single token, it must be a mnemonic&#13;
        if tokens[0] in codes: error = 0 # If the token is in codes, there's no error&#13;
    else:                                # Otherwise, we have a multi-token line&#13;
        if (tokens[0] in codes) or (tokens[1] in codes): error = 0:&#13;
    return(error)                        # Return the error code</pre>&#13;
			<p lang="en-GB">The only line of interest is the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if (tokens[0] in codes) or (tokens[1] in codes): error = 0:</pre>&#13;
			<p lang="en-GB">There are two cases to consider: instructions with a label and those without a label. In the former case, the mnemonic is the second token in the instruction, and in the latter case, the mnemonic is the first token. We can test whether a token is a mnemonic by using Python’s <code>if ... in</code> construct. Say we have the following construct:</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><code>if token[0] </code><code>in codes</code></p>&#13;
			<p lang="en-GB">This returns <code>True</code> if the first<a id="_idIndexMarker465"/><a id="_idIndexMarker466"/> token is a valid mnemonic. We can combine the two tests with an <code>or</code> Boolean to get the preceding expression. In the<a id="_idIndexMarker467"/><a id="_idIndexMarker468"/> program, we call <code>testLine</code> with the <code>tokens</code> parameter and it returns an error. We use the error to print a message and return it to the operating system with the <code>sys.exit()</code> function.</p>&#13;
			<h2 id="_idParaDest-113" lang="en-GB"><a id="_idTextAnchor113"/>The testIndex() function</h2>&#13;
			<p lang="en-GB">This simulator<a id="_idIndexMarker469"/><a id="_idIndexMarker470"/> provides an instruction in <a id="_idIndexMarker471"/><a id="_idIndexMarker472"/>the form <code>LDRI r1,[r2]</code> to provide memory indirect addressing (i.e., pointer-based or indexed addressing).</p>&#13;
			<p lang="en-GB">In this case, register <code>r1</code> is loaded with the contents of memory pointed at by register <code>r2</code>. If the pointer register contains an invalid value that is outside the range of legal addresses, the program will crash. By testing the index, we can ensure that an out-of-range index is detected. Note that only the first source register, <code>rS1</code>, is ever used as a memory pointer:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def testIndex():                        # Test for register or memory index out of range&#13;
    if (rD &gt; 7) or (rS1 &gt; 7) or (rS2 &gt; 7): # Ensure register numbers are in the range 0 to 7&#13;
        print('Register number error')&#13;
        sys.exit()                      # Call operating system to leave the Python program&#13;
    if mnemonic in ['LDRI', 'STRI']:    # Memory index testing only for memory load and store&#13;
        if r[rS1] &gt; len(m) - 1:         # Test rS1 contents are less than memory size&#13;
            print(' Memory index error')&#13;
            sys.exit()&#13;
    return()</pre>&#13;
			<h2 id="_idParaDest-114" lang="en-GB"><a id="_idTextAnchor114"/>General comments</h2>&#13;
			<p lang="en-GB">The following line demonstrates how we extract the operation class from the mnemonic. The expression looks strange because of the <code>()</code> and <code>[]</code> parentheses. The <code>codes.get(key)</code> operation uses <code>key</code> to get the associated value from the <code>codes</code> dictionary:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
opClass = codes.get(mnemonic)[0]     # Use mnemonic to read opClass from the codes dictionary</pre>&#13;
			<p lang="en-GB">In this case, the key is the mnemonic, and the value returned is the operation class; for example, if the mnemonic is <code>'LDRL'</code>, the corresponding value is <code>[3]</code>. Note that the value returned is not <code>3</code>! It is a <em class="italic">list</em> with the single value <code>3</code>. Consequently, we have to extract the value from the list by specifying the first item, that is, <code>mnemonic[0]</code>.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">There are many ways to build an instruction. In TC1, we create a binary value, just like a real assembler. In TC1mini, we directly execute the instruction from the assembly language form. So, when we compile the instructions, we create a program in text form. To do that, we need to combine the label, mnemonic, registers, and literal into a list.</p>&#13;
			<p lang="en-GB">The code to do that is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
thisLine = list((i,label,mnemonic,predicate,opClass))&#13;
                                        # Combine the component parts in a list&#13;
prog.append(thisLine)                   # Add the new line to the existing program</pre>&#13;
			<p lang="en-GB">In this example, we use<a id="_idIndexMarker473"/><a id="_idIndexMarker474"/> the <code>list()</code> function to combine items into a list, and then we use <code>append()</code> to add this item to an existing list. Note the syntax of <code>list()</code>. You might expect it to be <code>list(a,b,c)</code>. No. It’s <code>list((a,b,c))</code>. The <code>list()</code> function uses parentheses as normal but the list itself must be in parentheses. That’s because the list items constitute a <em class="italic">single</em> parameter to list.</p>&#13;
			<h2 id="_idParaDest-115" lang="en-GB"><a id="_idTextAnchor115"/>The TC1tiny code listing</h2>&#13;
			<p lang="en-GB">This is the listing of the cut-down<a id="_idIndexMarker475"/><a id="_idIndexMarker476"/> version of TC1. Instructions fall into eight classes depending on the number and arrangements of operands. Each instruction is in a dictionary, <code>codes</code>, which provides the class number that is used to decode operands. The instruction itself is executed directly from its mnemonic. Unlike TC1, there is no intermediate binary code. Similarly, both register names and indirect register names are in dictionaries to simplify instruction decoding:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Simple CPU instruction interpreter. Direct instruction interpretation. 30 September 2022. V1.0&#13;
# Class 0: no operand                   NOP&#13;
# Class 1: literal                      BEQ  3&#13;
# Class 2: register                     INC  r1&#13;
# Class 3: register,literal             LDRL r1,5&#13;
# Class 4: register,register,           MOV  r1,r2&#13;
# Class 5: register,register,literal    ADDL r1,r2,5&#13;
# Class 6: register,register,register   ADD  r1,r2,r3&#13;
# Class 7: register,[register]          LDRI r1,[r2]&#13;
import sys                              #NEW&#13;
codes = {'NOP':[0],'STOP':[0],'END':[0],'ERR':[0], 'BEQ':[1],'BNE':[1], \&#13;
         'BRA':[1],'INC':[2],'DEC':[2],'NOT':[2],'CMPL':[3],'LDRL':[3], \&#13;
         'DBNE':[3],'MOV':[4],'CMP':[4],'SUBL':[5],'ADDL':[5],'ANDL':[5], \&#13;
         'ADD':[6],'SUB':[6],'AND':[6],'OR':[6],'LDRI':[7],'STRI':[7]}&#13;
reg1  = {'r0':0,   'r1':1,   'r2':2,  'r3':3,   'r4':4,   'r5':5, \&#13;
         'r6':6,  'r7':7}               # Registers&#13;
reg2  = {'[r0]':0, '[r1]':1, '[r2]':2,'[r3]':3, '[r4]':4, \&#13;
         '[r5]':5, '[r6]':6,'[r7]':7}   # Pointer registers&#13;
symTab = {}                             # Symbol table&#13;
r = [0] * 8                             # Register set&#13;
m = [0] * 8&#13;
prog = [] * 32                          # Program memory&#13;
def equates():                          # Process directives and delete from source&#13;
    global symTab, sFile&#13;
    for i in range (0,len(sFile)):      # Deal with equates&#13;
        tempLine = sFile[i].split()&#13;
        if len(tempLine) &gt; 2 and tempLine[1] == 'EQU':&#13;
                                        # If line &gt; 2 tokens and second EQU&#13;
            print('SYMB' , sFile[i])&#13;
            symTab[tempLine[0]] = tempLine[2] # Put third token EQU in symbol table&#13;
    sFile = [ i for i in sFile if i.count('EQU') == 0] # Remove all lines with 'EQU'&#13;
    print('Symbol table ', symTab, '\n')&#13;
    return()</pre>&#13;
			<p lang="en-GB">This section deals with decoding instructions into<a id="_idIndexMarker477"/><a id="_idIndexMarker478"/> the appropriate task in order to correctly execute them with the appropriate parameters:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def c<a id="_idTextAnchor116"/>lassDecode(predicate):&#13;
    lit,rD,rS1,rS2 = '',0,0,0                         # Initialize variables&#13;
    if opClass in [1]:      lit =  predicate&#13;
    if opClass in [2]:      rD  = reg1[predicate]&#13;
    if opClass in [3,4,5,6,7]:&#13;
        predicate = predicate.split(',')&#13;
        rD = reg1[predicate[0]]&#13;
    if opClass in [4,5,6]:  rS1 = reg1[predicate[1]] \&#13;
                                                # Get source reg 1 for classes 4, 5, and 6&#13;
    if opClass in [3,5]:    lit = (predicate[-1])     # Get literal for classes 3 and 5&#13;
    if opClass in [6]:      rS2 = reg1[predicate[2]]  # Get source reg 2 for class 6&#13;
    if opClass in [7]:      rS1 = reg2[predicate[1]]  # Get source pointer reg for class 7&#13;
    return(lit,rD,rS1,rS2)</pre>&#13;
			<p lang="en-GB">Unlike TC1, we perform a little testing on the input, for example, whether the memory or register index is out of range. This is simply an illustrative example of data validation:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def t<a id="_idTextAnchor117"/>estLine(tokens):   # Check there's a valid instruction in this line&#13;
    error = 1&#13;
    if len(tokens) == 1:&#13;
        if tokens[0] in codes: error = 0&#13;
    else:&#13;
        if (tokens[0] in codes) or (tokens[1] in codes): error = 0&#13;
    return(error)&#13;
    def t<a id="_idTextAnchor118"/>estIndex():                    # Test for reg or memory index out of range&#13;
    print('rD,rS1 =', rD,rS1, 'r[rS1] =', r[rS1], 'len(m)', len(m),\&#13;
    'mnemonic =', mnemonic)&#13;
    if rD &gt; 7 or rS1 &gt; 7 or rS2 &gt; 7:&#13;
        print('Register number error')&#13;
        sys.exit()                                  # Exit program on register error&#13;
    if mnemonic in ['LDRI', 'STRI']:&#13;
        if r[rS1] &gt; len(m) - 1:&#13;
            print(' Memory index error')&#13;
            sys.exit()                              # Exit program on pointer error&#13;
    return()&#13;
def getLit(litV):                                   # Extract a literal (convert formats)&#13;
    if litV == '': return(0)                        # Return 0 if literal field empty&#13;
    if  litV in symTab:                    # Look in symbol table and get value if there&#13;
        litV = symTab[litV]                         # Read the symbol value as a string&#13;
        lit = int(litV)                             # Convert string to integer&#13;
    elif  litV[0]    == '%': lit = int(litV[1:],2)  # If % convert binary to int&#13;
    elif  litV[0:1]  == '$': lit = int(litV[1:],16) # If first symbol $, convert hex to int&#13;
    elif  litV[0]    == '-':&#13;
        lit = (-int(litV[1:]))&amp;0xFFFF               # Deal with negative values&#13;
    elif  litV.isnumeric():  lit = int(litV)        # Convert decimal string to integer&#13;
    else:                    lit = 0                # Default value 0 (if all else fails)&#13;
    return(lit)&#13;
prgN = 'E://ArchitectureWithPython//NewIdeas_1.txt' # prgN = program name:  test file&#13;
sFile = [ ]                                         # sFile source data&#13;
with open(prgN,'r') as prgN:                        # Open it and read it&#13;
    prgN = prgN.readlines()&#13;
for i in range(0,len(prgN)):                        # First level of text-processing&#13;
    prgN[i] = prgN[i].replace('\n','')              # Remove newline code in source&#13;
    prgN[i] = ' '.join(prgN[i].split())             # Remove multiple spaces&#13;
    prgN[i] = prgN[i].strip()                       # First strip spaces&#13;
prgN = [i.split('@')[0] for i in prgN]              # Remove comment fields&#13;
while '' in prgN: prgN.remove('')                   # Remove blank lines&#13;
for i in range(0,len(prgN)):                        # Copy source to sFile: stop on END&#13;
    sFile.append(prgN[i])                           # Build new source text file sFile&#13;
    if 'END' in sFile[i]: break            # Leave on 'END' and ignore any more source text&#13;
for i in range(0,len(sFile)): print(sFile[i])&#13;
print()&#13;
equates()                                           # Deal with equates&#13;
for i in range(0,len(sFile)): print(sFile[i])&#13;
print()&#13;
for i in range(0,len(sFile)):         # We need to compile a list of labels&#13;
    label = ''                        # Give each line a default empty label&#13;
    predicate = ''                    # Create default predicate (label + mnemonic + predicate)&#13;
    tokens = sFile[i].split(' ')      # Split into separate groups&#13;
    error = testLine(tokens)          # Test for an invalid instruction&#13;
    if error == 1:                    # If error found&#13;
        print('Illegal instruction', tokens, 'at',i)&#13;
        sys.exit()                    # Exit program&#13;
    numTokens = len(tokens)           # Process this line&#13;
    if numTokens == 1: mnemonic = tokens[0]&#13;
    if numTokens &gt; 1:&#13;
        if tokens[0][-1] == ':':&#13;
            symTab.update({tokens[0][0:-1]:i})    # Insert new value and line number&#13;
            label = tokens[0][0:-1]&#13;
            mnemonic = tokens[1]&#13;
        else: mnemonic = tokens[0]&#13;
        predicate = tokens[-1]&#13;
    opClass = codes.get(mnemonic)[0] # Use the mnemonic to read opClass from codes dictionary&#13;
    thisLine = list((i,label,mnemonic,predicate,opClass))&#13;
    prog.append(thisLine)            # Program line + label + mnemonic + predicate + opClass&#13;
print('Symbol table ', symTab, '\n') # Display symbol table for equates and line labels</pre>&#13;
			<p lang="en-GB">The following is the actual instruction <a id="_idIndexMarker479"/><a id="_idIndexMarker480"/>execution loop. As you can see, it is remarkably compact:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                             # Instruction execution&#13;
run = 1&#13;
z = 0&#13;
pc = 0&#13;
while run == 1:&#13;
    thisOp = prog[pc]&#13;
    if thisOp[2] in ['STOP', 'END']: run = 0 # Terminate on STOP or END (comment on this)&#13;
    pcOld = pc&#13;
    pc = pc + 1&#13;
    mnemonic  = thisOp[2]&#13;
    predicate = thisOp[3]&#13;
    opClass   = thisOp[4]&#13;
    lit,rD,rS1,rS2 = classDecode(predicate)&#13;
    lit = getLit(lit)&#13;
    if   mnemonic == 'NOP': pass&#13;
    elif mnemonic == 'BRA': pc = lit&#13;
    elif mnemonic == 'BEQ':&#13;
        if z == 1: pc = lit&#13;
    elif mnemonic == 'BNE':&#13;
        if z == 0: pc = lit&#13;
    elif mnemonic == 'INC': r[rD] = r[rD] + 1&#13;
    elif mnemonic == 'DEC':&#13;
        z = 0&#13;
        r[rD] = r[rD] - 1&#13;
        if r[rD] == 0: z = 1&#13;
    elif mnemonic == 'NOT': r[rD] = (~r[rD])&amp;0xFFFF  # Logical NOT&#13;
    elif mnemonic == 'CMPL':&#13;
        z = 0&#13;
        diff = r[rD] - lit&#13;
        if diff == 0: z = 1&#13;
    elif mnemonic == 'LDRL': r[rD] = lit&#13;
    elif mnemonic == 'DBNE':&#13;
        r[rD] = r[rD] - 1&#13;
        if r[rD] != 0: pc = lit&#13;
    elif mnemonic == 'MOV':  r[rD] = r[rS1]&#13;
    elif mnemonic == 'CMP':&#13;
        z = 0&#13;
        diff = r[rD] - r[rS1]&#13;
        if diff == 0: z = 1&#13;
    elif mnemonic == 'ADDL': r[rD] = r[rS1] + lit&#13;
    elif mnemonic == 'SUBL': r[rD] = r[rS1] - lit&#13;
    elif mnemonic == 'ADD':  r[rD] = r[rS1] + r[rS2]&#13;
    elif mnemonic == 'SUB':  r[rD] = r[rS1] - r[rS2]&#13;
    elif mnemonic == 'AND':  r[rD] = r[rS1] &amp; r[rS2]&#13;
    elif mnemonic == 'OR':   r[rD] = r[rS1] | r[rS2]&#13;
    elif mnemonic == 'LDRI':&#13;
        testIndex()&#13;
        r[rD] = m[r[rS1]]&#13;
    elif mnemonic == 'STRI':&#13;
        testIndex()&#13;
        m[r[rS1]] = r[rD]&#13;
    regs = ' '.join('%04x' % b for b in r)           # Format memory location's hex&#13;
    mem  = ' '.join('%04x' % b for b in m)           # Format register's hex&#13;
    print('pc =','{:&lt;3}'.format(pcOld),'{:&lt;18}'.format(sFile[pcOld]),\&#13;
          'regs =',regs,'Mem =',mem,'z =',z)</pre>&#13;
			<p lang="en-GB">The code execution loop, like most of the simulators we discuss, is remarkably straightforward. The current instruction is fetched and decoded into mnemonic, class, and register numbers. The program counter is advanced and the mnemonic is presented to a series of <code>then...elif</code> statements.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Many of the instructions are executed in only one line of code; for example, <code>ADD</code> is implemented by adding two registers together: <code>r[rD] = r[rS1] + r[rS2]</code>. Some instructions, such as <code>compare</code>, require two registers to be subtracted and then the status bits to be set accordingly.</p>&#13;
			<p lang="en-GB">We included one relatively complex<a id="_idIndexMarker481"/><a id="_idIndexMarker482"/> instruction, decrement and branch on not zero, which decrements a register and then branches to a target address if the register has not counted down to <code>0</code>.</p>&#13;
			<p lang="en-GB">In the final section, we will look at yet another variation of TC1.</p>&#13;
			<h1 id="_idParaDest-116" lang="en-GB"><a id="_idTextAnchor119"/>TC1 postscript mark II</h1>&#13;
			<p lang="en-GB">If one postscript is good, two <a id="_idIndexMarker483"/><a id="_idIndexMarker484"/>are even better. We’ve added this second variation on a theme to demonstrate some different ways of doing things. Much of the program’s structure is the same as before. The features are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Direct execution (revisited)</li>&#13;
				<li lang="en-GB">The ability to avoid different mnemonics (e.g., <code>ADD</code> and <code>ADDL</code>) for the same basic operation</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The principal enhancement is the way to handle instructions and decode them. In TC1, we use a 4-bit code to define the structure of each instruction in terms of its parameters. When a mnemonic is looked up in the dictionary, it returns a code giving the required parameters.</p>&#13;
			<p lang="en-GB">One feature (problem?) with TC1 is that we have different mnemonics for variations on an instruction, for example, <code>ADD</code> and <code>ADDL</code>. The suffix <code>L</code> tells the assembler that a literal operand (rather than a register number) is required. In this example, we avoid different instruction formats and use a single mnemonic by putting instructions into classes. Each class defines an instruction format, ranging from class <code>0</code> (instruction with no parameters) to class <code>9</code> (instruction with <em class="italic">four</em> registers).</p>&#13;
			<p lang="en-GB">This example uses the direct execution of an instruction. That is, we don’t compile an instruction into binary and then execute the binary. We execute an instruction directly from its mnemonic.</p>&#13;
			<p lang="en-GB">A consequence of this arrangement is that an instruction may fall into multiple classes; for example, <code>LDR</code> is in <em class="italic">three</em> classes, rather than having the <code>LDR</code>, <code>LDRL</code>, and <code>LDRI</code> variants. When an instruction is encountered, it is checked against each class. If the mnemonic is in a class, the attributes of the instruction are checked before deciding whether we’ve found the correct class.</p>&#13;
			<p lang="en-GB">Consider <code>ADD</code>. We can write <code>ADD r1,r2,5</code> or <code>ADD r1,r2,r3</code>; that is, the second number added to a register may be a literal or a register. Consequently, <code>ADD</code> is in class <code>5</code> and class <code>6</code>. To resolve the ambiguity, we look at the final operand; if it’s a literal, then it’s class <code>5</code>, and if it’s a register, it’s class <code>6</code>.</p>&#13;
			<p lang="en-GB">Testing for a register is easy because we’ve put registers in a dictionary, so it’s necessary only to check whether the final operand is in the dictionary or not. Consider class <code>3</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
if <strong class="bold">(mnemonic in class3)</strong> and <strong class="bold">(predLen == 2)</strong> and <strong class="bold">(predicate[1] not in regList)</strong></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Here, we do a triple test. First, we check <a id="_idIndexMarker485"/><a id="_idIndexMarker486"/>whether the mnemonic is in class <code>3</code>. Then, we test the predicate length (it’s <code>2</code> for two operands, such as <code>CMP r1,5</code>). Finally, we test for a numeric second operand by ensuring that the operand is not in the list of registers.</p>&#13;
			<p lang="en-GB">The Python program for this experiment is as follows.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Instruction formats&#13;
# NOP             # class 0&#13;
# BRA 4           # Class 1&#13;
# INC r1          # class 2&#13;
# LDR r1,#4       # class 3&#13;
# MOV r1,r2       # class 4&#13;
# ADD r1,r2,5     # class 5&#13;
# ADD r1,r2,r3    # class 6&#13;
# LDR r1,[r2]     # class 7&#13;
# LDR r1,[r2],4   # class 8&#13;
# MLA r1,r2,r3,r4 # class 9 [r1] = [r2] + [r3] * [r3]&#13;
def getLit(lit):                        # Extract a literal&#13;
    if    lit in symTab:    literal = symTab[lit] \&#13;
                                        # Look in symbol table and get if there&#13;
    elif  lit       == '%': literal = iint(lit[1:],2) \&#13;
                                        # If first symbol is %, convert binary to integer&#13;
    elif  lit[0:1]  == '$': literal = int(lit[1:],16) \&#13;
                                        # If first symbol is $, convert hex to integer&#13;
    elif  lit[0]    == '-': literal = i(-int(lit[1:]))&amp;0xFFFF \&#13;
                                        # Deal with negative values&#13;
    elif  lit.isnumeric():  literal = iint(lit) \&#13;
                                        # If number is a decimal string, then convert to integer&#13;
    else:                   literal = 0 # Default value 0 if all else fails&#13;
    return(literal)&#13;
regList = {'r0':0,'r1':1,'r2':2,'r3':3,'r4':4,'r5':5,'r6':6,'r7':7}&#13;
iRegList = {'[r0]':0,'[r1]':1,'[r2]':2,'[r3]':3,'[r4]':4,'[r5]':5, \&#13;
            '[r6]':6,'[r7]':7}&#13;
class0 = ['NOP','STOP','RTS']           # none&#13;
class1 = ['BRA','BEQ', 'BSR']           # register&#13;
class2 = ['INC', 'DEC']                 # register&#13;
class3 = ['LDR', 'STR','CMP','DBNE','LSL','LSR','ROR']  # register, literal&#13;
class4 = ['MOV','CMP','ADD']            # register, register Note ADD r1,r2&#13;
class5 = ['ADD','SUB']                  # register, register, literal&#13;
class6 = ['ADD','SUB']                  # register, register, register&#13;
class7 = ['LDR','STR']                  # register, pointer&#13;
class8 = ['LDR','STR']                  # register, pointer, literal&#13;
class9 = ['MLA']                        # register, register, register, register&#13;
inputSource = 0                         # Manual (keyboard) input if 0; file input if 1&#13;
singleStep  = 0                         # Select single-step mode or execute all-to-end mode&#13;
x = input('file input? type y or n ')   # Ask for file input (y) or keyboard input (any key)&#13;
if x == 'y':&#13;
    inputSource = 1&#13;
    x = input('Single step type y ')    # Type 'y' for single-step mode&#13;
    if x == 'y': singleStep = 1&#13;
    with open('C:/Users/AlanClements/Desktop/c.txt','r') as fileData:&#13;
        fileData = fileData.readlines()&#13;
    for i in range (0,len(fileData)):   # Remove leading and trailing spaces&#13;
        fileData[i] = fileData[i].strip()&#13;
r =     [0] * 8                         # Eight registers&#13;
m =     [0] * 16                        # 16 memory locations&#13;
stack = [0] * 8                         # Stack for return addresses (BSR/RTS)&#13;
prog =  []  * 64                        # Program memory&#13;
progDisp = [] * 64                      # Program for display&#13;
symTab = {}                             # Symbol table for symbolic name to value binding&#13;
run = True&#13;
pc = 0                                  # Clear program counter&#13;
sp = 7                                  # Set stack pointer to bottom of stack&#13;
while run == True:                      # Program processing loop&#13;
    predicate = []                      # Dummy&#13;
    if inputSource == 1:                # Get instruction from file&#13;
        line = fileData[pc]&#13;
    else: line = input('&gt;&gt; &gt; ')         # Or input instruction from keyboard&#13;
    if line == '':&#13;
        run = False&#13;
        break&#13;
    line = ' '.join(line.split())       # Remove multiple spaces. Uses join and split&#13;
    progDisp.append(line)               # Make a copy of this line for later display&#13;
    line = line.replace(',',' ')&#13;
    line = line.split(' ')              # Split instruction into tokens&#13;
    if (len(line) &gt; 1) and (line[0][-1] == ':'): # Look for a label (token 0 ending in :)&#13;
        label = line[0]&#13;
        symTab[line[0]] = pc            # Put a label in symTab alongside the pc&#13;
    else:&#13;
        line.insert(0,'    :')          # If no label+, insert a dummy one (for pretty printing)&#13;
    mnemonic  = line[1]                 # Get the mnemonic, second token&#13;
    predicate = line[2:]                # What's left is the predicate (registers and literal)&#13;
    prog.append(line)                   # Append the line to the program&#13;
    pc = pc + 1                         # And bump up the program counter&#13;
    progLength = pc – 1                 # Record the total number of instructions&#13;
for i in range (0,pc-1):&#13;
    print('pc =', f'{i:3}', (' ').join(prog[i])) # Print the program&#13;
print('Symbol table =', symTab, '\n')   # Display the symbol table&#13;
pc = 0&#13;
run = True&#13;
z = 0&#13;
c = 0&#13;
classNim = 10&#13;
while run == True:                      # Program execution loop&#13;
    instruction = prog[pc]&#13;
    pcOld = pc&#13;
    pc = pc + 1&#13;
    if instruction[1] == 'STOP':        # Halt on STOP instruction&#13;
        print('End of program exit')&#13;
        break&#13;
    mnemonic  = instruction[1]&#13;
    predicate = instruction[2:]&#13;
    predLen   = len(predicate)&#13;
    if (predLen &gt; 0) and (mnemonic not in class1): rD = regList[predicate[0]]&#13;
                                        # Get rD for classes 2 to 8</pre>&#13;
			<p lang="en-GB">In this simulator, we deal with instructions by class rather than by mnemonic. This feature means that the same mnemonic can have different addressing modes, such as literal, register, or even memory. The first class, <code>0</code>, is reserved for mnemonics with no <a id="_idIndexMarker487"/><a id="_idIndexMarker488"/>operands, such as <code>NOP</code>. Of course, this mechanism would make it possible to invent a new operation, such as, say, <code>NOP 4</code>, that acts in a different way:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if mnemonic in class0:              # Deal with instructions by their group (class)&#13;
        classNum = 0&#13;
        if mnemonic == 'NOP': pass&#13;
        if mnemonic == 'RTS':           # Return from subroutine pull address off the stack&#13;
            pc = stack[sp]&#13;
            sp = sp + 1&#13;
    if mnemonic in class1:              # Class deals with branch operations so get literal&#13;
        classNum = 1&#13;
        literal = getLit(predicate[0])&#13;
        if   mnemonic == 'BRA': pc = literal&#13;
        elif mnemonic == 'BEQ':&#13;
            if z == 1: pc = literal&#13;
        elif mnemonic == 'BSR':         # Deal with subroutine call&#13;
            sp = sp - 1                 # Push return address on the stack&#13;
            stack[sp] = pc&#13;
            pc = literal&#13;
    if mnemonic in class2:                 # Class 2 increment and decrement so get register&#13;
        classNum = 2&#13;
        if mnemonic == 'INC': r[rD] = r[rD] + 1&#13;
        if mnemonic == 'DEC':&#13;
            r[rD] = r[rD] - 1&#13;
            if r[rD] == 0: z = 1           # Decrement sets z flag&#13;
            else: z = 0&#13;
    if (mnemonic in class3) and (predLen == 2) and \&#13;
    (predicate[1] not in regList):         &#13;
        classNum = 3&#13;
        literal = getLit(predicate[-1])&#13;
        if mnemonic == 'CMP':&#13;
            diff = r[rD] - literal&#13;
            if diff == 0: z = 1&#13;
            else:         z = 0&#13;
        elif mnemonic == 'LDR': r[rD] = literal&#13;
        elif mnemonic == 'STR': m[literal] = r[rD]&#13;
        elif mnemonic == 'DBNE':&#13;
            r[rD] = r[rD] - 1&#13;
            if r[rD] != 0: pc = literal        # Note we don't use z flag&#13;
        elif mnemonic == 'LSL':&#13;
            for i in range(0,literal):&#13;
                c = ((0x8000) &amp; r[rD]) &gt;&gt; 16&#13;
                r[rD] = (r[rD] &lt;&lt; 1) &amp; 0xFFFF  # Shift left and constrain to 16 bits&#13;
        elif mnemonic == 'LSR':&#13;
            for i in range(0,literal):&#13;
                c = ((0x0001) &amp; r[rD])&#13;
                r[rD] = r[rD] &gt;&gt; 1&#13;
        elif mnemonic == 'ROR':&#13;
            for i in range(0,literal):&#13;
                c = ((0x0001) &amp; r[rD])&#13;
                r[rD] = r[rD] &gt;&gt; 1&#13;
                r[rD] = r[rD] | (c &lt;&lt; 15)&#13;
    if (mnemonic in class4) and (predLen == 2) and (predicate[1]\&#13;
    in regList):                           #&#13;
        classNum = 4&#13;
        rS1 = regList[predicate[1]]        # Get second register&#13;
        if mnemonic == 'MOV':              # Move source register to destination register&#13;
           r[rD] = r[rS1]&#13;
        elif mnemonic == 'CMP':&#13;
            diff = r[rD] -  r[rS1]&#13;
            if diff == 0: z = 1&#13;
            else:         z = 0&#13;
        elif mnemonic == 'ADD':            # Add source to destination register&#13;
            r[rD] = r[rD] + r[rS1]&#13;
    if (mnemonic in class5) and (predLen == 3) and (predicate[2] not\&#13;
    in regList):&#13;
        classNum = 5                       # Class 5 is register with literal operand&#13;
        literal = getLit(predicate[2])&#13;
        rS1 = regList[predicate[1]]&#13;
        if   mnemonic == 'ADD': r[rD] = r[rS1] + literal&#13;
        elif mnemonic == 'SUB': r[rD] = r[rS1] - literal&#13;
    if (mnemonic in class6) and (predLen == 3) and (predicate[-1]\&#13;
    in regList):&#13;
        classNum = 6                       # Class 6 uses three registers&#13;
        rS1 = regList[predicate[1]]&#13;
        rS2 = regList[predicate[2]]&#13;
        if   mnemonic == 'ADD': r[rD] = r[rS1] + r[rS2]&#13;
        elif mnemonic == 'SUB': r[rD] = r[rS1] - r[rS2]&#13;
    if (mnemonic in class7) and (predLen == 2) and (predicate[1]\&#13;
    in iRegList):&#13;
        classNum = 7                       # Class 7 uses a pointer register with load and store&#13;
        pReg  = predicate[1]&#13;
        pReg1 = iRegList[pReg]&#13;
        pReg2 = r[pReg1]&#13;
        if   mnemonic == 'LDR': r[rD] = m[pReg2]&#13;
        elif mnemonic == 'STR': m[pReg2] = r[rD]&#13;
    if (mnemonic in class8) and (predLen == 3):&#13;
        classNum = 8                       # Class 8 uses a pointer register and a literal offset&#13;
        pReg  = predicate[1]&#13;
        pReg1 = iRegList[pReg]&#13;
        pReg2 = r[pReg1]&#13;
        literal = getLit(predicate[2])&#13;
        if   mnemonic == 'LDR': r[rD] = m[pReg2 + literal]&#13;
        elif mnemonic == 'STR': m[pReg2 + literal] = r[rD]&#13;
    if mnemonic in class9:                 # Class 9 demonstrates a 4-operand instruction&#13;
        classNum = 9&#13;
        if mnemonic == 'MLA':&#13;
            rS1 = regList[predicate[1]]&#13;
            rS2 = regList[predicate[2]]&#13;
            rS3 = regList[predicate[3]]&#13;
            r[rD] = r[rS1] * r[rS2] + r[rS3]&#13;
    pInst = ' '.join(instruction)          ##############&#13;
    Regs = ' '.join('%04x' % i for i in r)&#13;
    print('pc {:&lt;2}'.format(pcOld),'Class =', classNum,      \&#13;
          '{:&lt;20}'.format(pInst),'Regs: ', regs, 'Mem', m,   \&#13;
          'r[0] =', '{:016b}'.format(r[0]),                  \&#13;
          'c =', c, 'z =', z, '\n')&#13;
    print(progDisp[pcOld])&#13;
    if singleStep == 1: input(' &gt;&gt;&gt; ')</pre>&#13;
			<p lang="en-GB">The purpose of the previous program<a id="_idIndexMarker489"/><a id="_idIndexMarker490"/> is to demonstrate another way of categorizing instructions and using the number of operands to distinguish between instruction types, such as <code>ADD r1,r2</code> and <code>ADD r1,r2,r3</code>.</p>&#13;
			<h1 id="_idParaDest-117" lang="en-GB"><a id="_idTextAnchor120"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we presented the TC1 simulator, which can take a text file in TC1 assembly language, convert it into machine code, and then execute it. TC1’s instruction set architecture is close to the classic RISC architecture with a register-to-register architecture (i.e., data operations take place on the contents of registers). The only memory operations permitted are loading a register from memory (or a literal) and storing a register in memory.</p>&#13;
			<p lang="en-GB">The simulator has two basic components: an assembler that translates a mnemonic such as <code>ADD r1,r2,r3</code> into a 32-bit binary instruction, and an interpreter that reads the instruction, extracts the necessary information, and then executes the instruction.</p>&#13;
			<p lang="en-GB">Some of the elements of TC1 are rather unusual. A free-format structure for the source code is provided; for example, you can write <code>ADD r1,r2,r3</code> or <code>adD R1 r2 r3</code> and both instructions will be happily accepted. Why? First, it was done to demonstrate the use of string processing in Python. Second, it makes it easier for the user to enter input in their chosen case. All input is automatically converted into uppercase to make the language case-free. Similarly, a comma or space is allowed as a separator between parameters. Finally, the need for <code>[]</code> brackets to indicate indirect addressing was removed. Users may enter <code>LDRI r0,[r1]</code> or <code>LDRI r0,r1</code>.</p>&#13;
			<p lang="en-GB">Similarly, numbers can be entered in different forms (decimal, binary, or hexadecimal); for example, number bases can be indicated in <em class="italic">Motorola format</em> or <em class="italic">Python format</em>. Most real assemblers don’t permit such luxury.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The first versions of TC1 required all addresses to be numeric; if you wanted to branch to line <code>30</code>, you had to write <code>BRA 30</code>. It was the remarkable power and ease of use of Python’s dictionary structure that made it so easy to include labels. All you have to do is recognize a label, pop it in the dictionary together with its value, and then, whenever you encounter that label, just look up its value in the dictionary.</p>&#13;
			<p lang="en-GB">We also provided an example assembly language program to test TC1 and a short discussion of how we go about testing various instructions.</p>&#13;
			<p lang="en-GB">Having designed TC1, we created a rather simplified version and called it TC1mini. This simulator does not provide the same flexibility in writing instructions, and it does not have a large instruction set. It also does not encode the instruction into a binary form and then decode it again and execute it. It executes the assembly instruction directly (thanks one more to Python’s dictionary mechanism).</p>&#13;
			<p lang="en-GB">At the end of this chapter, we provided yet another simplified computer simulator to both emphasize the structure of a computer simulator and provide an example of the way in which you can modify the basic design.</p>&#13;
			<p lang="en-GB">In this key chapter, we introduced the TC1 computer simulator and presented its design. We also looked at variations of TC1 to help create a more complete picture of the simulator and assembler. In the next chapter, we will take things a step further and look at some more aspects of the simulator. We will describe several simulators that have different architectures.</p>&#13;
		</p>&#13;
	</div></body></html>