<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer042" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-91" class="chapter-number" lang="en-GB"><a id="_idTextAnchor091"/>6</h1>&#13;
			<h1 id="_idParaDest-92" lang="en-GB"><a id="_idTextAnchor092"/>TC1 Assembler and Simulator Design</h1>&#13;
			<p lang="en-GB">In this chapter, we will put together the lessons we have learned in previous chapters and construct a computer simulator. The key topics we will cover in this chapter are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><span class="No-Break">Analyzing instructions</span></li>&#13;
				<li lang="en-GB">Dealing with <span class="No-Break">assembler directives</span></li>&#13;
				<li lang="en-GB">Building the <span class="No-Break">binary instruction</span></li>&#13;
				<li lang="en-GB">The pre-TC1 (a prequel to the <span class="No-Break">actual simulator)</span></li>&#13;
				<li lang="en-GB">The TC1 <span class="No-Break">simulator program</span></li>&#13;
				<li lang="en-GB">A TC1 assembly <span class="No-Break">language program</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">TC1 postscript</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">By the end of this chapter, you should understand how a simulator is designed and be able to create one. The following two chapters concentrate on expanding the simulator and providing more facilities, such as error detection in <span class="No-Break">the input.</span></p>&#13;
			<h1 id="_idParaDest-93" lang="en-GB"><a id="_idTextAnchor093"/>Technical requirements</h1>&#13;
			<p lang="en-GB">You can find the programs used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In order to construct a Python-based simulator, you need the same tools used in earlier chapters; that is, you require an editor to create the Python program and a Python interpreter. These are included in the freely available Python package we introduced in <a href="B19624_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-94" lang="en-GB"><a id="_idTextAnchor094"/>Analyzing instructions</h1>&#13;
			<p lang="en-GB">In this section, we will look <a id="_idIndexMarker333"/><a id="_idIndexMarker334"/>at the way in which we take a text string representing an assembly language instruction and process it to create binary code that can be executed by <span class="No-Break">the simulator.</span></p>&#13;
			<p lang="en-GB">Interestingly, the assembler can be more complicated than the actual simulator. Indeed, we devote relatively little space to the simulator itself in this chapter. We don’t actually need an assembler, because it’s easy to hand-translate assembly-level <a id="_idIndexMarker335"/><a id="_idIndexMarker336"/>operations into binary code; it’s just a matter of filling in the fields of the 32-bit instruction format. For example, <em class="italic">load register R7 with the literal value 42</em> can be written as <strong class="source-inline">LDRL</strong> <strong class="source-inline">R7</strong>,<strong class="source-inline">42</strong>. This has a 7-bit opcode, <strong class="source-inline">01 </strong><strong class="source-inline">01010</strong>, the destination register is <strong class="source-inline">r7</strong> (code <strong class="source-inline">111</strong>), the two source registers are not used, and their fields can both be set to <strong class="source-inline">000</strong>. The literal is <strong class="source-inline">42</strong>, or <strong class="source-inline">0000000000101010</strong> as a 16-bit binary value. The binary-encoded instruction is <span class="No-Break">as follows:</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><span class="pcode-bold">0001010</span></span><span class="No-Break"><span class="pcode-bg">111</span></span><span class="No-Break"><strong class="source-inline">000000</strong></span><span class="No-Break"><span class="pcode-bg">0000000000101010</span></span></p>&#13;
			<p lang="en-GB">It’s easy to translate code by hand, but it’s no fun. We are going to create an assembler that automates the process of translation and lets you use symbolic names rather than actual literals (constants). Consider the following example of assembly language code. This is written using <em class="italic">numeric values</em> (shaded), rather than symbolic names. This is not intended to be a specific assembly language; it is designed to illustrate the <span class="No-Break">basic concepts:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        LDRL <strong class="bold">R0</strong>,<span class="sc-source-bg">60</span>              <span class="sc-comment">@ Load R0 with the time factor, 60</span></span>&#13;
<span>        .</span>&#13;
<span>        CMP  <strong class="bold">R3</strong>,R5              <span class="sc-comment-bg">@ Compare R3 and R5</span></span>&#13;
<span>        BEQ  <span class="sc-source-bg">1</span>                  <span class="sc-comment-bg">@ If equal, jump to next-but-one instruction</span></span>&#13;
<span>        ADD  <strong class="bold">R2</strong>,R2,<span class="sc-source-bg">4</span></span>&#13;
<span>        SUB  <strong class="bold">R7</strong>,R1,R2</span></pre>&#13;
			<p lang="en-GB">In the following example, literals have been replaced with symbolic names. These <span class="No-Break">are shaded:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-source-bg">Minutes</span> EQU  60                 <span class="sc-comment">@ Set up a constant</span></span>&#13;
<span><span class="sc-source-bg">Test</span>    EQU  4</span>&#13;
<span>.       LDRL <strong class="bold">R0</strong>,<span class="sc-source-bg">Minutes</span>         <span class="sc-comment">@ Load R0 with the time factor</span></span>&#13;
<span>.       CMP  <strong class="bold">R3</strong>,R5</span>&#13;
<span>        BEQ  <span class="sc-source-bg">Next</span></span>&#13;
<span>        ADD  <strong class="bold">R2</strong>,R2,<span class="sc-source-bg">Test</span></span>&#13;
<span><span class="sc-source-bg">Next</span>    SUB  <strong class="bold">R7</strong>,R1,R2</span></pre>&#13;
			<p lang="en-GB">Python’s dictionary structure makes the handling of symbolic names very easy indeed. The preceding shows the processing of a text file containing the assembly language. This file is called <strong class="source-inline">sFile</strong> and is simply a <strong class="source-inline">.txt</strong> file containing the assembly <span class="No-Break">language instructions.</span></p>&#13;
			<h2 id="_idParaDest-95" lang="en-GB"><a id="_idTextAnchor095"/>Processing the input</h2>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We will now look at how the raw<a id="_idIndexMarker337"/><a id="_idIndexMarker338"/> input – that is, the text file containing the assembly language source code – can be processed. In principle, it would be nice to have a source file where the assembly language instructions were all perfectly formatted and <span class="No-Break">laid out.</span></p>&#13;
			<p lang="en-GB">In reality, a program may not be formatted ideally; for example, there may be blank lines or program comments that need to <span class="No-Break">be ignored.</span></p>&#13;
			<p lang="en-GB">We have designed this assembly language to allow considerable latitude in the writing of a TC1 program. In fact, it allows a free format that is not implemented by most real assemblers. We took this approach for several reasons. First, it demonstrates how to perform text processing, which is a fundamental part of the design of assemblers. Second, a free format means you don’t have to remember whether to use uppercase or lowercase names <span class="No-Break">and labels.</span></p>&#13;
			<p lang="en-GB">Some languages are case-sensitive <a id="_idIndexMarker339"/><a id="_idIndexMarker340"/>and some are not. The assembly language we have designed is <em class="italic">case-insensitive</em>; that is, you can write either <strong class="source-inline">ADD </strong><span class="pcode-bold">r0</span><strong class="source-inline">,r1,r2</strong> or <strong class="source-inline">ADD </strong><span class="pcode-bold">R0</span><strong class="source-inline">,R1,R2.</strong> Consequently, we can write the load register immediate assembly instruction in all the following forms to execute a <em class="italic">load </em><span class="No-Break"><em class="italic">register-indexed</em></span><span class="No-Break"> operation:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">LDRI </strong><span class="No-Break"><strong class="source-inline">R2,[R1],10 </strong></span><span class="No-Break">or</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">LDRI </strong><span class="No-Break"><strong class="source-inline">R2,r1,10 </strong></span><span class="No-Break">or</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">LDRI </strong><span class="No-Break"><strong class="source-inline">R2,[R1,10] </strong></span><span class="No-Break">or</span><span class="No-Break"><strong class="source-inline">,</strong></span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LDRI r2,r1,10</strong></span></p>&#13;
			<p lang="en-GB">This level of freedom of notation is possible because the <strong class="source-inline">[]</strong> brackets are not actually necessary to identify the instruction; they are used in programs because programmers associate <strong class="source-inline">[r0]</strong> with indirect addressing. In other words, the brackets are there for the programmer, not the computer, and <span class="No-Break">are redundant.</span></p>&#13;
			<p lang="en-GB">However, this level of freedom is not necessarily desirable because it could lead to errors and make it more difficult for one person to read another person’s program. All design decisions come with pros <span class="No-Break">and cons.</span></p>&#13;
			<p lang="en-GB">The following Python example includes a short embedded assembly language program. The Python code has been designed so that you can use either an assembly language program that is part of the assembler (this is just for testing and debugging purposes because it avoids having to go into a text editor every time you want to test a feature) or a program in text form on disk. In this example, we located the test program at <strong class="source-inline">E\:testCode.txt</strong> on my computer. When the demonstration text-processing code runs, it asks you whether the code is to come from disk or is the embedded code. Typing <strong class="source-inline">d</strong> reads the disk, and entering any other input reads the <span class="No-Break">embedded code.</span></p>&#13;
			<p lang="en-GB">The filename of the assembly language program is <strong class="source-inline">testCode = 'E://testCode.txt'</strong>. A double backslash is used instead of the conventional filenaming convention in <span class="No-Break">Python programs.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The text-processing program removes blank lines, converts text into uppercase (allowing you to write <strong class="source-inline">r0</strong> or <strong class="source-inline">R0</strong>), and lets you use a comma or a space as a separator (you can write <strong class="source-inline">ADD R0,R1,R2</strong> or <strong class="source-inline">ADD r0 r1 r2</strong>). We also remove surplus spaces before and after the instruction. The final result is a tokenized list; that is, <strong class="source-inline">ADD r0,r1,r2</strong> is converted into the <strong class="source-inline">['ADD','R0','R1','R2']</strong> list. Now, the assembler can look up the instruction and then extract the information it requires (register numbers <span class="No-Break">and literals).</span></p>&#13;
			<p lang="en-GB">In the following program, we used a new variable every time we processed a line in order to help you keep track of variables. The following is <span class="No-Break">an example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile2 = [i.upper() for i in sFile1]          <span class="sc-comment"># Convert in to uppercase</span></span>&#13;
<span>sFile3 = [i.split('@')[0] for i in sFile2]    <span class="sc-comment"># Remove comments</span></span></pre>&#13;
			<p lang="en-GB">We’ve used different variable names for clarity. Normally, you <span class="No-Break">would write:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile = [i.upper() for i in sFile]            <span class="sc-comment">#</span></span>&#13;
<span>sFile = [i.split('@')[0] for i in sFile]      <span class="sc-comment">#</span></span></pre>&#13;
			<p lang="en-GB">We use file comprehension to remove comments in <span class="No-Break">the code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile3 = [i.split('@')[0] for i in sFile2]    <span class="sc-comment"># Remove comments</span></span></pre>&#13;
			<p lang="en-GB">This is a rather clever trick and requires explanation. It copies each line of <strong class="source-inline">sFile2</strong> to <strong class="source-inline">sFile3</strong>. However, the value copied for each line is <strong class="source-inline">i.split('@')[0]</strong>, where <strong class="source-inline">i</strong> is the<a id="_idIndexMarker341"/><a id="_idIndexMarker342"/> current line. The <strong class="source-inline">split('@')</strong> method divides the list into strings using <strong class="source-inline">'@'</strong> as a divider. If there is no <strong class="source-inline">'@'</strong> in the original string, the string is copied. If there is an <strong class="source-inline">'@'</strong>, it is copied as two strings; for example, <strong class="source-inline">ADD R1,R2,R3 @ Sum the totals</strong> is copied to <strong class="source-inline">sFile3</strong> as <strong class="source-inline">'ADD R1,R2,R3','@ Sum the totals'</strong>. However, only the first element of the list is copied because of the <strong class="source-inline">[0]</strong> index; that is, only <strong class="source-inline">'ADD R1,R2,R3'</strong> is copied and the comment <span class="No-Break">is removed.</span></p>&#13;
			<p lang="en-GB">The text input processing block is <span class="No-Break">given here:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>testCode = 'E://testCode.txt'</span>&#13;
<span>altCode  = ['nop', 'NOP 5', 'add R1,R2','', 'LDR r1,[r2]', \</span>&#13;
<span>            'ldr r1,[R2]','\n', 'BEQ test @www','\n']</span>&#13;
<span>x = input('For disk enter d, else any character ')</span>&#13;
<span>if x == 'd':</span>&#13;
<span>    with open(testCode, 'r') as source0:</span>&#13;
<span>         source = source0.readlines()</span>&#13;
<span>    source = [i.replace('\n','') for i in source]</span>&#13;
<span>else:    source = altCode</span>&#13;
<span>print('Source code to test is',source)</span>&#13;
<span>sFile0 = []</span>&#13;
<span>for i in range(0,len(source)):                <span class="sc-comment"># Process the source file in list sFile</span></span>&#13;
<span>    t1 =  source[i].replace(',',' ')          <span class="sc-comment"># Replace comma with space</span></span>&#13;
<span>    t2 =  t1.replace('[',' ')                 <span class="sc-comment"># Remove [ brackets</span></span>&#13;
<span>    t3 =  t2.replace(']',' ')                 <span class="sc-comment"># Remove ] brackets</span></span>&#13;
<span>    t4 =  t3.replace('  ',' ')                <span class="sc-comment"># Remove any double spaces</span></span>&#13;
<span>    sFile0.append(t4)                         <span class="sc-comment"># Add result to source file</span></span>&#13;
<span>sFile1= [i for i in sFile0 if i[-1:]!='\n']   <span class="sc-comment"># Remove end-of-lines</span></span>&#13;
<span>sFile2= [i.upper() for i in sFile1]           <span class="sc-comment"># All uppercase</span></span>&#13;
<span>sFile3= [i.split('@')[0] for i in sFile2]     <span class="sc-comment"># Remove comments with @</span></span>&#13;
<span>sFile4= [i.rstrip(' ') for i in sFile3 ]      <span class="sc-comment"># Remove trailing spaces</span></span>&#13;
<span>sFile5= [i.lstrip(' ') for i in sFile4 ]      <span class="sc-comment"># Remove leading spaces</span></span>&#13;
<span>sFile6=[i for i in sFile5 if i != '']         <span class="sc-comment"># Remove blank lines</span></span>&#13;
<span>print ('Post-processed output',  sFile6)</span></pre>&#13;
			<p lang="en-GB">The following are two examples of using this code. In the first case, the user input is <strong class="source-inline">d</strong>, indicating a disk program, and in the second case, the<a id="_idIndexMarker343"/><a id="_idIndexMarker344"/> input is <strong class="source-inline">x</strong>, indicating the use of the embedded source program. In each case, the course and output values are <a id="_idIndexMarker345"/><a id="_idIndexMarker346"/>printed to demonstrate the <span class="No-Break">string-processing operations.</span></p>&#13;
			<h3 lang="en-GB">Case 1 – Disk input</h3>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>For disk enter d, else any character d</span>&#13;
<span>Source code to test is ['diskCode', 'b', 'add r1,r2,[r3]', '', 'ADD r3 @test', ' ', 'r2,,r3', ' ', 'gg']</span>&#13;
<span>Post-processed output ['DISKCODE', 'B', 'ADD R1 R2 R3', 'ADD R3', 'R2 R3', 'GG']</span></pre>&#13;
			<h3 lang="en-GB">Case 2 – Using the embedded test program</h3>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>For disk enter d, else any character x</span>&#13;
<span>Source code to test is ['nop', 'NOP 5', 'add R1,R2', '', 'LDR r1,[r2]', 'ldr r1,[R2]', '\n', 'BEQ test @www', '\n']</span>&#13;
<span>Post-processed output ['NOP', 'NOP 5', 'ADD R1 R2', 'LDR R1 R2', 'LDR R1 R2', 'BEQ TEST']</span></pre>&#13;
			<p lang="en-GB">The preceding code does not represent an <a id="_idIndexMarker347"/><a id="_idIndexMarker348"/>optimum text-processing system. It was designed to demonstrate the basic process involved in manipulating text before you process it. However, these concepts will appear again <span class="No-Break">in TC1.</span></p>&#13;
			<h3 lang="en-GB">Dealing with Mnemonics</h3>&#13;
			<p lang="en-GB">What’s in a name? How do we know<a id="_idIndexMarker349"/><a id="_idIndexMarker350"/> that a <strong class="source-inline">NOP</strong> instruction stands alone, but an <strong class="source-inline">ADD</strong> instruction requires three registers? In this section, we begin a discussion of how assembly language instructions are processed in order to extract their meaning (i.e., convert them into <span class="No-Break">binary form).</span></p>&#13;
			<p lang="en-GB">Consider the following fragment of TC1 <span class="No-Break">assembly language:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">ADD</strong>  R1,R3,R7        <span class="sc-comment">@ Three operands (three registers)</span></span>&#13;
<span><strong class="bold">NOP</strong>                  <span class="sc-comment">@ No operands</span></span>&#13;
<span><strong class="bold">LDRL</strong> R4,27           <span class="sc-comment">@ Two operands (register and a literal value)</span></span></pre>&#13;
			<p lang="en-GB">When the assembler reads a line, it needs to know how to deal with the opcode and its operands. So, how does it know how to proceed? We can use Python’s dictionary facility to solve this problem in a very simple way, by just looking in a table to see what information an <span class="No-Break">opcode requires.</span></p>&#13;
			<p lang="en-GB">Recall that a dictionary is a set or collection of items, where each item has two components; for example, an English-German dictionary has items that consist of an English word and its German equivalent. The word you look up is called a <em class="italic">key</em> and that provides a <em class="italic">value</em>. For example, in the English-German dictionary, the item <strong class="source-inline">'town':'Stadt'</strong> consists of the key <strong class="source-inline">town</strong> and the value <strong class="source-inline">Stadt</strong>. A dictionary is a fancy name for a <span class="No-Break"><em class="italic">look-up table</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">A dictionary in Python is defined by its punctuation (i.e., it doesn’t require any special reserved Python words); it’s a type of list enclosed by curly braces, <strong class="source-inline">{}</strong>. Each list item consists of a key and its value separated with a colon. Successive items are separated with commas, exactly as in <span class="No-Break">a list.</span></p>&#13;
			<p lang="en-GB">A <em class="italic">key</em> is used to access the appropriate value in a dictionary. In TC1, the key is the <em class="italic">mnemonic</em> used to look up the details of the instruction. Let’s create a<a id="_idIndexMarker351"/><a id="_idIndexMarker352"/> dictionary called <strong class="source-inline">codes</strong> with three keys that are strings representing valid TC1 instructions: <strong class="source-inline">STOP</strong>, <strong class="source-inline">ADD</strong>, and <strong class="source-inline">LDRL</strong>. This dictionary can be written <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>codes = {'STOP':P, 'ADD':Q, 'LDRL':R}               <span class="sc-comment"># P, Q, R are variables</span></span></pre>&#13;
			<p lang="en-GB">Each key is a string terminated by a colon, followed by its value. The key doesn’t have to be a string. In this case, it’s a string because we are using it to look up mnemonics, which are text strings. The first <strong class="source-inline">key:value</strong> pair is <strong class="source-inline">'STOP':P</strong> , where <strong class="source-inline">'STOP'</strong>is the key and <strong class="source-inline">P</strong> is its value. Suppose we want to know whether <strong class="source-inline">ADD</strong> is a legal instruction (i.e., in the dictionary). We can test whether this instruction (i.e., key) is in the dictionary with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if 'ADD' <strong class="bold">in</strong> codes:  <span class="sc-comment"># Test whether 'ADD' is a valid mnemonic in the dictionary</span></span></pre>&#13;
			<p lang="en-GB">This returns <strong class="source-inline">True</strong> if the key is in the dictionary, and <strong class="source-inline">False</strong> otherwise. You can use <strong class="source-inline">not in</strong> to test whether something is <em class="italic">not</em> in <span class="No-Break">a dictionary.</span></p>&#13;
			<p lang="en-GB">Python allows a key to be associated with any valid object, for example, a list. We could write, for example, the following <span class="No-Break"><strong class="source-inline">key:value</strong></span><span class="No-Break"> pair:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span> 'ADD': [3, 0b1101001, 'Addition', '07/05/2021', timesUsed]</span></pre>&#13;
			<p lang="en-GB">Here, the value associated with a key is a five-element list that associates the <strong class="source-inline">ADD</strong> mnemonic with the number of its operands, its binary encoding, its name, the date it was designed, and the number of times it was used in the current program (as well as being able to read a value from a dictionary, you can write to it and <span class="No-Break">update it).</span></p>&#13;
			<p lang="en-GB">The following code sets up a dictionary that binds mnemonics to variables (preset to <span class="No-Break">integers </span><span class="No-Break"><strong class="source-inline">1,2,3,4</strong></span><span class="No-Break">):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>P,Q,R,N = 1,2,3,4                                   <span class="sc-comment"># Set up dummy opcodes</span></span>&#13;
<span>validCd = {'STOP':P, 'ADD':Q, 'LDRL':R, 'NOP':N}    <span class="sc-comment"># Dictionary of codes</span></span>&#13;
<span>x = input('Please enter a code  ')                  <span class="sc-comment"># Request an opcode</span></span>&#13;
<span>if x not in validCd:                                <span class="sc-comment"># Check dictionary for errors</span></span>&#13;
<span>    print('Error! This is not valid')</span>&#13;
<span>if x in validCd:                                    <span class="sc-comment"># Check for valid opcode</span></span>&#13;
<span>    print('Valid op ', <strong class="bold">validCd.get(x)</strong>)              <span class="sc-comment"># If found, read its value</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In this example, we used the <strong class="source-inline">get()</strong> method to read the value associated with a key. If the key is <strong class="source-inline">x</strong>, its value is given by <strong class="source-inline">validCd.get(x)</strong>; that is, the syntax <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">dictionaryName.get(key)</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Assembly language contains instructions that are executed. However, it also contains information called <em class="italic">assembler directives</em> that tells the program something about the environment; for example, where to put data in memory or how to bind symbolic names to values. We will now look at <span class="No-Break">assembler directives.</span></p>&#13;
			<h1 id="_idParaDest-96" lang="en-GB"><a id="_idTextAnchor096"/>Dealing with assembler directives</h1>&#13;
			<p lang="en-GB">In this section, we will learn<a id="_idIndexMarker353"/><a id="_idIndexMarker354"/> about <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">What assembler <span class="No-Break">directives do</span></li>&#13;
				<li lang="en-GB">How to create a symbol table linking symbolic names <span class="No-Break">to values</span></li>&#13;
				<li lang="en-GB">How to access the <span class="No-Break">symbol table</span></li>&#13;
				<li lang="en-GB">How to update the <span class="No-Break">symbol table</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">Processing labels</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">We will demonstrate how the names the programmer chooses are manipulated and translated into their appropriate <span class="No-Break">numerical values.</span></p>&#13;
			<p lang="en-GB">The first version of TC1 required you to provide actual values for all names and labels. If you wanted to jump to an instruction, you had to provide the number of lines to jump. It’s much better to allow the programmer to write <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><strong class="source-inline">JMP next</strong></span></p>&#13;
			<p lang="en-GB">Here, <strong class="source-inline">next</strong> is the label of the target line. This is preferred over writing <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><strong class="source-inline">JMP 21</strong></span></p>&#13;
			<p lang="en-GB">Similarly, if the literal <strong class="source-inline">60</strong> represents minutes in an hour, write <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><strong class="source-inline">MULL </strong></span><span class="No-Break"><strong class="bold">R0</strong></span><span class="No-Break"><strong class="source-inline">,R1,MINUTES</strong></span></p>&#13;
			<p lang="en-GB">This is preferred over <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"> <span class="No-Break"><strong class="source-inline">MULL </strong></span><span class="No-Break"><strong class="bold">R0</strong></span><span class="No-Break"><strong class="source-inline">,R1,60</strong></span></p>&#13;
			<p lang="en-GB">We need a means of <em class="italic">linking</em> <strong class="source-inline">next</strong> with <strong class="source-inline">21</strong> and <strong class="source-inline">MINUTES</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">60</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Python’s <em class="italic">dictionary</em> structure solves this problem. We simply create <strong class="source-inline">key:value</strong> pairs, where <strong class="source-inline">key</strong> is the label that we want to define and <strong class="source-inline">value</strong> is its value. In this example, a dictionary for the preceding example would be <strong class="source-inline">{'NEXT':21, 'MINUTES':60}</strong>. Note this example uses <em class="italic">integers</em> as values. In this book, we will also use <em class="italic">strings</em> as values, because we input data in text form; for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">'MINUTES':'60'</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">EQU</strong> assembler directive equates a value with a symbolic name. For example, TC1 lets you write <span class="No-Break">the following:</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><strong class="source-inline">MINUTES </strong><span class="No-Break"><strong class="source-inline">EQU 60</strong></span></p>&#13;
			<h2 id="_idParaDest-97" lang="en-GB"><a id="_idTextAnchor097"/>Using the dictionary</h2>&#13;
			<p lang="en-GB">The <strong class="source-inline">MINUTES EQU 60</strong> assembler <a id="_idIndexMarker355"/><a id="_idIndexMarker356"/>directive has three tokens: a label, a function (equate), and a value. We extract the <strong class="source-inline">'MINUTES':60</strong> dictionary pair from the source code and insert it into a dictionary called <strong class="source-inline">symbolTab</strong>. The following code demonstrates the procedure. The first line sets up a symbol table. We initialize it with a dummy entry, <strong class="source-inline">'START':0</strong>. We’ve created this initial entry for <span class="No-Break">testing purposes:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>symbolTab = {'START':0}                              <span class="sc-comment"># Symbol table for labels</span></span>&#13;
<span class="sc-grey" lang="en-GB">for i in range (0,len(sFile)):                       <span class="sc-comment"># Deal with equates</span></span>&#13;
<span class="sc-grey" lang="en-GB">    if len(sFile[i]) &gt; 2 and sFile[i][1] == 'EQU':   <span class="sc-comment"># Is token 'EQU'?</span></span>&#13;
<span class="sc-grey" lang="en-GB">        symbolTab[sFile[i][0]] = sFile[i][2]         <span class="sc-comment"># If so, update table</span></span>&#13;
<span class="sc-bottom" lang="en-GB">sFile = [i for i in sFile if i.count('EQU') == 0]    <span class="sc-comment"># Delete EQU from source</span></span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">for</strong> loop (shaded) reads each line of the source code, <strong class="source-inline">sFile</strong>, and tests for lines where <strong class="source-inline">'EQU'</strong> is the second token in the line. The <strong class="source-inline">len(sFile[i]) &gt; 2</strong> comparison ensures that this line has at least three tokens to ensure it’s a valid equate directive. The text is in <span class="No-Break">bold font.</span></p>&#13;
			<p lang="en-GB">We can perform two tests together by employing an <strong class="source-inline">and</strong> Boolean operator so that the test is true only if both conditions <span class="No-Break">are true.</span></p>&#13;
			<p lang="en-GB">We check that the second token is <strong class="source-inline">'EQU'</strong> with <strong class="source-inline">sFile[i][1] == 'EQU'</strong>. The <strong class="source-inline">sFile</strong><span class="pcode-bold">[i]</span><span class="pcode-bg">[1]</span> notation has two list indexes. The first, in bold, indicates line <strong class="source-inline">i</strong> of the source code, and the second index indicates token 1 of that line; that is, it is the <span class="No-Break">second element.</span></p>&#13;
			<p lang="en-GB">If <strong class="source-inline">'EQU'</strong> is found, we add (i.e., insert) the first token,<strong class="source-inline">[</strong><span class="pcode-bg">sFile[i][0]</span><strong class="source-inline">]</strong>, into the symbol table as the key, and the third token, <span class="pcode-bold">sFile[i][2]</span>, as <span class="No-Break">the value.</span></p>&#13;
			<p lang="en-GB">Consider the <strong class="source-inline">MINUTES EQU 60</strong> source <span class="No-Break">code line.</span></p>&#13;
			<p lang="en-GB">The key is <strong class="source-inline">sFile[i][0]</strong> and its value is <strong class="source-inline">sFile[i][2]</strong>, because <strong class="source-inline">MINUTES</strong> is the first token on line <strong class="source-inline">i</strong> and <strong class="source-inline">60</strong> is the third token on line <strong class="source-inline">i</strong>. The stored key is <strong class="source-inline">'MINUTES'</strong> and its value is <strong class="source-inline">60</strong>. But note that the value <strong class="source-inline">60</strong> is in <em class="italic">string</em> form and not <em class="italic">integer</em> form. Why? Because the assembler directive is a string and not an integer. If we want the numeric value, we have to <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">int()</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The final line of this block of code is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile = [i for i in sFile if i.count('EQU') == 0]</span></pre>&#13;
			<p lang="en-GB">This line uses a list comprehension to scan the source file and delete any line with <strong class="source-inline">EQU</strong>, because only instructions are loaded in program memory. A line containing <strong class="source-inline">EQU</strong> is a directive and not an instruction. This operation uses the count method, <strong class="source-inline">i.count('EQU')</strong>, to count the number of times <strong class="source-inline">EQU</strong> appears in a line, and then deletes that line if the count isn’t <strong class="source-inline">0</strong>. The condition we test for before moving (i.e., keeping) a line is <span class="No-Break">as follows:</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><strong class="source-inline">if i.count('EQU') == </strong><span class="No-Break"><strong class="source-inline">0:</strong></span></p>&#13;
			<p lang="en-GB">Here, <strong class="source-inline">i</strong> is the current line being processed. The <strong class="source-inline">count</strong> method is applied to the current line and counts the number of occurrences of the <strong class="source-inline">'EQU'</strong> string in the line. Only if the count is <strong class="source-inline">0</strong> (i.e., it isn’t a line with an <strong class="source-inline">EQU</strong> directive) does that line get copied <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">sFile</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Because detecting an <strong class="source-inline">EQU</strong> <a id="_idIndexMarker357"/><a id="_idIndexMarker358"/>directive, putting it in the symbol table, and removing it from the code are so important, we will demonstrate its operation with a little piece of test code. The following code fragment sets up a list of three instructions in <strong class="source-inline">sFile</strong> to test. Remember that <strong class="source-inline">sFile</strong> is a list of lists and each list is an instruction composed of tokens, each of which is <span class="No-Break">a string:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile=[['test','EQU','5'],['not','a','thing'],['xxx','EQU','88'], \</span>&#13;
<span>       ['ADD','r1','r2','r3']]</span>&#13;
<span>print('Source: ', sFile)</span>&#13;
<span><strong class="bold">symbolTab = {}</strong>                                    <span class="sc-comment-bold"># Creates empty symbol table</span></span>&#13;
<span><strong class="bold">for i in range (0,len(sFile)):</strong>                    <span class="sc-comment-bold"># Deal with equates e.g., PQR EQU 25</span></span>&#13;
<span>    print('sFile[i]', sFile[i])</span>&#13;
<span>    <strong class="bold">if len(sFile[i]) &gt; 2 and sFile[i][1] == 'EQU':</strong>  <span class="sc-comment-bold"># Is the second token 'EQU'?</span></span>&#13;
<span>        <strong class="bold">print('key/val', sFile[i][0], sFile[i][2])</strong>  <span class="sc-comment-bold"># Display key-value pair</span></span>&#13;
<span>        <strong class="bold">symbolTab[sFile[i][0]] = sFile[i][2]</strong>        <span class="sc-comment-bold"># Now update symbol table</span></span>&#13;
<span><strong class="bold">sFile = [i for i in sFile if i.count('EQU') == 0]</strong>   <span class="sc-comment-bold"># Delete equates from source file</span></span>&#13;
<span>print('Symbol table: ', symbolTab)</span>&#13;
<span>print('Processed input: ',sFile)</span></pre>&#13;
			<p lang="en-GB">The code in bold is the code we’ve discussed. The remaining code is made up of <strong class="source-inline">print</strong> statements used to observe the code’s behavior. The key line in this code is <span class="No-Break">as follows:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">symbolTab[sFile[i][0]] = </strong><span class="No-Break"><strong class="source-inline">sFile[i][2]</strong></span></p>&#13;
			<p lang="en-GB">This updates the symbol table by adding a <strong class="source-inline">key:value</strong> pair in the <span class="No-Break">following format:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">symbolTab[key] = </strong><span class="No-Break"><strong class="source-inline">value</strong></span></p>&#13;
			<p lang="en-GB">When this code is run, it generates the <span class="No-Break">following output:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Source [['test','EQU','5'],['not','a','thing'],['xxx','EQU','88'], ['ADD','r1','r2','r3']]</span>&#13;
<span>sFile[i] ['test', 'EQU', '5']</span>&#13;
<span>key/val test 5</span>&#13;
<span>sFile[i] ['not', 'a', 'thing']</span>&#13;
<span>sFile[i] ['xxx', 'EQU', '88']</span>&#13;
<span>key/val xxx 88</span>&#13;
<span>sFile[i] ['ADD', 'r1', 'r2', 'r3']</span>&#13;
<span><strong class="bold">Symbol table {'test': '5', 'xxx': '88'}</strong></span>&#13;
<span><strong class="bold">Processed input [['not', 'a', 'thing'], ['ADD', 'r1', 'r2', 'r3']]</strong></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The final two lines give the symbol table and the post-processed version of <strong class="source-inline">sFile</strong>. The two equates have been loaded into the dictionary (symbol table) and the processed output has had the two <span class="No-Break">equates stripped.</span></p>&#13;
			<p lang="en-GB">There are several ways to add new <strong class="source-inline">key:value</strong> pairs to a dictionary. We could have applied the <strong class="source-inline">update</strong> method to <strong class="source-inline">symbolTab</strong> and written <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>symbolTab.update({<strong class="bold">[sFile[i][0]]:sFile[i][2]</strong>})</span></pre>&#13;
			<p lang="en-GB">In a later example of an assembler, we will adopt a different convention for assembler directives and use the format .<strong class="source-inline">equ name value</strong> because this convention is adopted by ARM processors, as we’ll see in later chapters. There is often more than <a id="_idIndexMarker359"/><a id="_idIndexMarker360"/>one way of representing assembly directives, each with its own advantages and disadvantages (e.g., ease of coding or fitting in with particular standards <span class="No-Break">and conventions).</span></p>&#13;
			<h2 id="_idParaDest-98" lang="en-GB"><a id="_idTextAnchor098"/>Labels</h2>&#13;
			<p lang="en-GB">The next step in processing the source file is to deal <a id="_idIndexMarker361"/><a id="_idIndexMarker362"/>with labels. Take the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      DEC  r1                                   <span class="sc-comment">@ Decrement r1</span></span>&#13;
<span>      BEQ  <strong class="bold">NEXT1</strong>                                <span class="sc-comment">@ If result in r1 is 0, then jump to line NEXT1</span></span>&#13;
<span>      INC  r2                                   <span class="sc-comment">@ If result not 0, increment r2</span></span>&#13;
<span>      .</span>&#13;
<span><strong class="bold">NEXT1</strong> .</span></pre>&#13;
			<p lang="en-GB">In this example, the decrement operation subtracts <strong class="source-inline">1</strong> from the contents of register <strong class="source-inline">r1</strong>. If the result is <strong class="source-inline">0</strong>, the <strong class="source-inline">Z flag</strong> is set. The next instruction is <em class="italic">branch on zero to NEXT1</em>. If <em class="italic">Z = 1</em>, a jump is made to the line labeled <strong class="source-inline">NEXT1</strong>; otherwise, the <strong class="source-inline">INC r2</strong> instruction immediately following <strong class="source-inline">BEQ</strong> <span class="No-Break">is executed.</span></p>&#13;
			<p lang="en-GB">The binary program (machine code) generated by TC1 does not store or use labels. It requires either the actual address of the next instruction or its relative address (i.e., how far it needs to jump from the current location). In other words, we need to translate the <strong class="source-inline">NEXT1</strong> label into its actual address in <span class="No-Break">the program.</span></p>&#13;
			<p lang="en-GB">This is a job for the dictionary. All we have to do is put a label in the dictionary as a key and then insert the corresponding address as the value associated with the key. The following three lines of Python demonstrate how we collect label addresses and put them in the <span class="No-Break">symbol table:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>1. for i in range(0,len(sFile)):                  <span class="sc-comment"># Add branch addresses to symbol tab</span></span>&#13;
<span>2.     if sFile[i]<strong class="bold">[0]</strong> not in codes:               <span class="sc-comment"># If </span><span class="sc-comment-bold">first</span><span class="sc-comment"> token not an opcode, it's a label</span></span>&#13;
<span>3.        <span class="sc-source-bold-bg">symbolTab.update</span>({<strong class="bold">sFile[i][0]:str(i)</strong>})  <span class="sc-comment"># Add pc value, i to sym tab as string</span></span>&#13;
<span>4. print('\nEquate and branch table\n')           <span class="sc-comment"># Display symbol table</span></span>&#13;
<span>5. for <span class="sc-source-bold-bg">x,y in symbolTab.items()</span>:                  <span class="sc-comment"># Step through symbol table</span></span>&#13;
<span>6.     print('{:&lt;8}'.format(<span class="sc-source-bold-bg">x</span>),<span class="sc-source-bold-bg">y</span>)</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The three lines, 1 to 3, define a <strong class="source-inline">for</strong> loop that steps through every line in the source code in <strong class="source-inline">sFile</strong>. Because we’ve processed the code to convert each instruction into a list of tokens, each line begins with either a valid mnemonic or a label. All we have to do is check whether the first token on a line is in the list (or dictionary) of mnemonics. If the first token is in the list, it’s an instruction. If it’s not in the list, then it’s a label (we are ignoring the case that it’s <span class="No-Break">an error).</span></p>&#13;
			<p lang="en-GB">We perform the check for a valid mnemonic with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>2. if sFile[i][0] <strong class="bold">not in</strong> codes:</span></pre>&#13;
			<p lang="en-GB">Here, <strong class="source-inline">sFile[i][0]</strong> represents the first item (i.e., token) of line <strong class="source-inline">i</strong> in the dictionary of mnemonics. The <strong class="source-inline">not in</strong> Python code returns <strong class="source-inline">True</strong> if the mnemonic is not in the dictionary called <strong class="source-inline">codes</strong>. If the test does return <strong class="source-inline">True</strong>, then we have a label and must put it in the symbol table with the <span class="No-Break">following operation:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-source-bg">3. symbolTab.update</span>({sFile[i][0]<strong class="bold">:str(i)</strong>})                  <span class="sc-comment"># i is the pc</span><span class="sc-comment"> value</span></span></pre>&#13;
			<p lang="en-GB">This expression says, “<em class="italic">Add the specified </em><strong class="source-inline">key:value</strong><em class="italic"> pair to the dictionary called </em><strong class="source-inline">symbolTable</strong><em class="italic">.</em>” Why is the value associated with the label given as <strong class="source-inline">i</strong>? The <a id="_idIndexMarker363"/><a id="_idIndexMarker364"/>value associated with the label is the address of that line (i.e., the value of the program counter, <strong class="source-inline">pc</strong>, when that line is executed). Since we are stepping through the source code line by line, the counter, <strong class="source-inline">i</strong>, is the corresponding value of the <span class="No-Break">program counter.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">update</strong> method is applied to the symbol table with <span class="pcode-bold">sFile[i][0]</span> as the key and <strong class="source-inline">str(i)</strong> as the value. The key is <span class="pcode-bold">sFile[i][0]</span>, which is the label (i.e., a string). However, the <em class="italic">value</em> of <strong class="source-inline">i</strong> is not a <em class="italic">string</em>. The value is an <em class="italic">integer</em>, <strong class="source-inline">i</strong>, which is the current line address. We convert the integer address into a string with <span class="pcode-bold">str(i)</span><span class="No-Break"> </span>because equates are stored in the table as strings (i.e., this is a design decision made <span class="No-Break">by me).</span></p>&#13;
			<p lang="en-GB">The next two lines print the <span class="No-Break">symbol table:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>4. print('\nEquate and branch table\n')                    <span class="sc-comment"># Display symbol table</span></span>&#13;
<span>5. for <span class="sc-source-bg CharOverride-1">x,y in symbolTab.items()</span>: print('{:&lt;8}'.format(<span class="sc-source-bg CharOverride-1">x</span>),<span class="sc-source-bg CharOverride-1">y</span>) <span class="sc-comment"># Step through symbol table</span></span></pre>&#13;
			<p lang="en-GB">The value of the symbol table is printed using a <strong class="source-inline">for</strong> loop. We extract a <strong class="source-inline">key:value</strong> pair by using <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>5. for x,y in symbolTab<strong class="bold">.items():</strong></span></pre>&#13;
			<p lang="en-GB">The <span class="pcode-bold">items()</span> method steps through all the elements of the <strong class="source-inline">symbolTab</strong> dictionary and allows us to print each <strong class="source-inline">key:pair</strong> value (i.e., all names/labels and their values). The <strong class="source-inline">print</strong> statement displays eight characters, right justified, by using <strong class="source-inline">{:&lt;8}.format(x)</strong> to format the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Having decoded an instruction, we next have to convert it into the appropriate <span class="No-Break">binary code.</span></p>&#13;
			<h1 id="_idParaDest-99" lang="en-GB"><a id="_idTextAnchor099"/>Building the binary instruction</h1>&#13;
			<p lang="en-GB">The next step in the assembly process is to <a id="_idIndexMarker365"/><a id="_idIndexMarker366"/>generate the appropriate binary pattern for each instruction. In this section, we show how the components of an instruction are put together to create a binary value that can later be executed by <span class="No-Break">the computer.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Note that the code in this section describes some of the instruction processing involved in analyzing instructions. The actual simulator differs in minor details, although the principles are <span class="No-Break">the same.</span></p>&#13;
			<p lang="en-GB">We first have to extract the mnemonic, convert it into binary, then extract the register numbers (where appropriate), and finally, insert the 16-bit literal. Moreover, because the assembler is in text form, we have to be able to deal with literals that are symbolic (i.e., they are names rather than numbers), decimal, negative, binary, or hexadecimal; that is, we have to handle instructions of the <span class="No-Break">following form:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>LDRL <strong class="bold">r0</strong>,24                   <span class="sc-comment">@ Decimal numeric value</span></span>&#13;
<span>LDRL <strong class="bold">r0</strong>,0xF2C3               <span class="sc-comment">@ Hexadecimal numeric value</span></span>&#13;
<span>LDRL <strong class="bold">r0</strong>,$F2C3                <span class="sc-comment">@ Hexadecimal numeric value (alternative representation)</span></span>&#13;
<span>LDRL <strong class="bold">r0</strong>,%00110101            <span class="sc-comment">@ Binary numeric value</span></span>&#13;
<span>LDRL <strong class="bold">r0</strong>,0b00110101           <span class="sc-comment">@ Binary numeric value (alternative representation)</span></span>&#13;
<span>LDRL <strong class="bold">r0</strong>,-234                 <span class="sc-comment">@ Negative decimal numeric value</span></span>&#13;
<span>LDRL <strong class="bold">r0</strong>,ALAN2                <span class="sc-comment">@ Symbolic value requiring symbol table look-up</span></span></pre>&#13;
			<p lang="en-GB">The assembler looks at each line of the source code and extracts the mnemonic. An instruction is a list of tokens (e.g., <strong class="source-inline">'NEXT'</strong>, <strong class="source-inline">'ADD'</strong>, <strong class="source-inline">'r1'</strong>, <strong class="source-inline">'r2'</strong>, <strong class="source-inline">'0x12FA'</strong>, which is five tokens, or <strong class="source-inline">'STOP'</strong>, which is one token). The situation is made more complex because the mnemonic may be the <em class="italic">first</em> token, or the <em class="italic">second</em> token if the instruction has a label. In the <a id="_idIndexMarker367"/><a id="_idIndexMarker368"/>following example, <strong class="source-inline">sFile</strong> contains the program as a list of instructions, and we are processing line <strong class="source-inline">i</strong>, <strong class="source-inline">sFile[i]</strong>. Our solution is <span class="No-Break">as follows:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB">Read the first token, <strong class="source-inline">sFile[i][0]</strong>. If this token is in the list of codes, then it’s an instruction. If it is not in the list of codes, it’s a label, and the second token, <strong class="source-inline">sFile[i][1]</strong>, is <span class="No-Break">the instruction.</span></li>&#13;
				<li lang="en-GB">Get the instruction details. These are stored in a dictionary called <strong class="source-inline">codes</strong>. If the mnemonic is in the dictionary, the key returns a tuple with two components. The first component is the format of the instruction, which defines the required operands in the sequence <strong class="source-inline">rD</strong>, <strong class="source-inline">rS1</strong>, <strong class="source-inline">rS2</strong>, <strong class="source-inline">literal</strong>; for example, the code <strong class="source-inline">1001</strong> indicates an instruction with a destination register and a literal. The second component of the tuple is the value of the opcode. We use a decimal value for this (ideally, it should be binary for the sake of readability, but binary values were too long and made the text harder <span class="No-Break">to read).</span></li>&#13;
				<li lang="en-GB">Read the register numbers from the tokens in the instruction; for example, <strong class="source-inline">ADD</strong> <strong class="source-inline">r3</strong>,<strong class="source-inline">r2</strong>,<strong class="source-inline">r7</strong> would return <strong class="source-inline">3</strong>,<strong class="source-inline">2</strong>,<strong class="source-inline">7</strong>, whereas <strong class="source-inline">NOP</strong> would return <strong class="source-inline">0</strong>,<strong class="source-inline">0</strong>,<strong class="source-inline">0</strong> (if a register field is not used, it is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">).</span></li>&#13;
				<li lang="en-GB">Read any literal and convert it into a 16-bit integer. This is the most complex operation because the literal may have one of the seven different formats <span class="No-Break">described previously.</span></li>&#13;
				<li lang="en-GB">The discussion in this section refers to the TC1 program that is presented in full at the end of the chapter. Here, we present slices of that program and explain how they work and the steps in the <span class="No-Break">assembly process.</span></li>&#13;
			</ol>&#13;
			<h2 id="_idParaDest-100" lang="en-GB"><a id="_idTextAnchor100"/>Extracting the instruction and its parameters</h2>&#13;
			<p lang="en-GB">The following fragment of code <a id="_idIndexMarker369"/><a id="_idIndexMarker370"/>shows the beginning of the loop that scans the source code and creates the binary value. This code initializes variables, extracts the opcode as a mnemonic, extracts any labels, extracts the parameters required by the mnemonic, and looks up the opcode and <span class="No-Break">its format:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for i in range(0,len(sFile)):                     <span class="sc-comment"># Assembly loop reads instruction</span></span>&#13;
<span>    opCode,label,literal,predicate = [],[],[],[]  <span class="sc-comment"># Initialize opcode, label, literal, predicate</span></span>&#13;
<span>    rD, rS1, rS2  = 0, 0, 0                       <span class="sc-comment"># Clear register-select fields to zeros</span></span>&#13;
<span>    if sFile[i][0] in codes: <strong class="bold">opCode = sFile[i][0]</strong>   <span class="sc-comment"># If first token is a valid opcode, get it</span></span>&#13;
<span>    <span class="sc-source-bold-bg">else:                    opCode = sFile[i][1]</span>   <span class="sc-comment"># If not, then opcode is second token</span></span>&#13;
<span>    if (sFile[i][0] in codes) and (len(sFile[i]) &gt; 1): <span class="sc-comment"># If opcode valid and length &gt; 1</span></span>&#13;
<span>        predicate = sFile[i][1:]</span>&#13;
<span>    else:</span>&#13;
<span>        if len(sFile[i]) &gt; 2: predicate = sFile[i][2:] \</span>&#13;
<span>                                              <span class="sc-comment"># Lines with a label longer than 2 tokens</span></span>&#13;
<span>    form = codes.get(opCode)                  <span class="sc-comment"># Use mnemonic to read instruction format</span></span>&#13;
<span>    if form[0] &amp; 0b1000 == 0b1000:            <span class="sc-comment"># Bit 4 of format selects destination register rD</span></span>&#13;
<span>    if predicate[0] in symbolTab:                 <span class="sc-comment"># If first token in symbol tab, it's a label</span></span>&#13;
<span>            rD = int(symbolTab[predicate[0]][1:]) <span class="sc-comment"># If it is a label, then get its value</span></span></pre>&#13;
			<p lang="en-GB">Lines <span class="No-Break">2 and 3</span> in the loop declare and initialize the variables and provide <span class="No-Break">default values.</span></p>&#13;
			<p lang="en-GB">The first <strong class="source-inline">if…else</strong> statement <a id="_idIndexMarker371"/><a id="_idIndexMarker372"/>on line 4 looks at the first<a id="_idIndexMarker373"/><a id="_idIndexMarker374"/> token on line <strong class="source-inline">i</strong> of the source code, <strong class="source-inline">sFile[i][0]</strong>. If that token is in the <strong class="source-inline">codes</strong> dictionary, then <strong class="source-inline">sFile[i][0]</strong> is the opcode. If it isn’t in the dictionary, then that token must be a label and the second token is the opcode (lines 4 <span class="No-Break">and 5):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>4.    if <span class="sc-source-bg">sFile[i][0] in codes:</span> opcode = sFile[i][0] <span class="sc-comment"># If first token is a valid opcode, get it</span></span>&#13;
<span>5.    <strong class="bold">else:                    opCode = sFile[i][1]</strong> <span class="sc-comment"># If not, then it's the second token</span></span></pre>&#13;
			<p lang="en-GB">If we encounter a label, we can convert it into its actual address, which is in <strong class="source-inline">symbolTab</strong>, using <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if sFile[i][0] in symbolTab: label = sFile[i][0] <span class="sc-comment"># Get label</span></span></pre>&#13;
			<p lang="en-GB">Lines <span class="No-Break">6, </span><span class="No-Break">7, 8, and 9</span> extract the predicate from the assembly language. Remember, the predicate comprises the tokens following the mnemonic and consists of any registers and literal required by <span class="No-Break">the instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>6. if (sFile[i][0] in codes) and (len(sFile[i])&gt;1): <span class="sc-comment"># Get everything after opcode</span></span>&#13;
<span>7.                        <span class="sc-source-bg">predicate = sFile[i][1:]</span>  <span class="sc-comment"># Line with opcode</span></span>&#13;
<span>8. else:</span>&#13;
<span>9.    if len(sFile[i])&gt;2: <span class="sc-source-bg">predicate = sFile[i][2:]</span>  <span class="sc-comment"># If label and len &gt; 2 tokens</span></span></pre>&#13;
			<p lang="en-GB">We have to deal with two cases: the first token is the mnemonic and the second token is the mnemonic. We also check that the line is long enough to have a predicate. If there is a predicate, it is extracted by lines <strong class="source-inline">7</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">9</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>7.          <strong class="bold">predicate = sFile[i][1:]</strong>     <span class="sc-comment"># The predicate is the second and following tokens</span></span>&#13;
<span>9.          <strong class="bold">predicate = sFile[i]</strong><span class="sc-source-bg">[2:]</span>     <span class="sc-comment"># The predicate is the third and following tokens</span></span></pre>&#13;
			<p lang="en-GB">The notation <strong class="source-inline">[2:]</strong> indicates <em class="italic">everything from token 2 to the end of the line</em>. This is a very nice feature of Python because it doesn’t require you to explicitly state the length of the line. Once we’ve extracted the predicate containing the register and literal information, we can start to assemble <span class="No-Break">the instruction.</span></p>&#13;
			<p lang="en-GB">Next, we extract the current line’s code format to get the information required from the predicate. Line <strong class="source-inline">10</strong>, <span class="pcode-bg">form</span><strong class="source-inline"> = codes.get(opCode)</strong>, accesses the <strong class="source-inline">codes</strong> dictionary to look for the mnemonic, which is in the <strong class="source-inline">opCode</strong> variable. The <strong class="source-inline">get</strong> method is applied to <strong class="source-inline">codes</strong> and the <strong class="source-inline">form</strong> variable receives the key value, which is the (<strong class="source-inline">format</strong>,<strong class="source-inline">code</strong>) tuple, for example, (<strong class="source-inline">8</strong>,<strong class="source-inline">10</strong>). The <strong class="source-inline">form[0]</strong> variable is the instruction format, and <strong class="source-inline">form[1]</strong> is <span class="No-Break">the opcode:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-source-bg">10. form = codes.get(opCode)</span>                    <span class="sc-comment"># Use opcode to read instruction format</span></span>&#13;
<span>11. if form[0] &amp; 0b1000 == 0b1000:              <span class="sc-comment"># Bit 3 of format selects destination reg rD</span></span>&#13;
<span>12.     if predicate[0] in symbolTab:           <span class="sc-comment"># Check whether first token is symbol table</span></span>&#13;
<span>13.        rD =int(symbolTab[predicate[0]][1:]) <span class="sc-comment"># If it's a label, then get its value</span></span></pre>&#13;
			<p lang="en-GB">The second element of the tuple, <strong class="source-inline">form[1]</strong>, gives the 7-bit opcode; that is, <strong class="source-inline">0100010</strong> for <strong class="source-inline">LDRL</strong>. Lines <strong class="source-inline">10</strong> to <strong class="source-inline">13</strong> demonstrate how the destination register is extracted. We first use <strong class="source-inline">AND</strong> <strong class="source-inline">form[0]</strong> with <strong class="source-inline">0b1000</strong> to test the most significant bit that indicates whether a destination register, <strong class="source-inline">rD</strong>, is required by this instruction. If it is required, we first test whether the <a id="_idIndexMarker375"/><a id="_idIndexMarker376"/>register is expressed in the form <strong class="source-inline">R0</strong>, or whether it’s given as a name, for example, <strong class="source-inline">TIME</strong>. We have to do this because TC1 lets you rename registers by using the <span class="No-Break"><strong class="source-inline">EQU</strong></span><span class="No-Break"> directive.</span></p>&#13;
			<p lang="en-GB">You can check whether an item is in the dictionary by using <strong class="bold">if</strong><span class="No-Break"> key </span><strong class="bold">in</strong><strong class="source-inline"> dictionary</strong>. Take the <span class="No-Break">following example:</span></p>&#13;
			<p lang="en-GB">if <strong class="source-inline">'INC'</strong> <span class="No-Break">in opCodes:</span></p>&#13;
			<p lang="en-GB">To obtain information about a particular mnemonic, we can use the <strong class="source-inline">get</strong> method to read the value associated with the key <strong class="source-inline">–</strong> for example, <strong class="source-inline">format = </strong><span class="No-Break"><strong class="source-inline">opCodes.get('INC')</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The preceding example returns <strong class="source-inline">format = (8,82)</strong>. <strong class="source-inline">8</strong> refers to the format code <strong class="source-inline">0b1000</strong> (specifying a destination register). <strong class="source-inline">82</strong> is the opcode for this instruction. We access the two fields of the value associated with <strong class="source-inline">'INC'</strong> with, for example, <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>binaryCode  = format[0]</span>&#13;
<span>formatStyle = format[1]</span></pre>&#13;
			<p lang="en-GB">We first test whether a register has a symbolic name in line <strong class="source-inline">12</strong> with. <strong class="source-inline">if predicate[0]</strong> in <strong class="source-inline">symbolTab:</strong> and, if it is in the symbol table, we read its value in line <strong class="source-inline">13</strong> with. </p>&#13;
			<p lang="en-GB"><strong class="source-inline">rD = </strong><span class="No-Break"><strong class="source-inline">int(symbolTab[predicate[0]][1:])</strong></span></p>&#13;
			<p lang="en-GB">We interrogate the symbol table with a key, which is the first element of the predicate since the destination register always comes first in a TC1 assembly <a id="_idIndexMarker377"/><a id="_idIndexMarker378"/>language instruction (e.g., in <strong class="source-inline">ADD </strong><span class="pcode-bg">r4</span>,<strong class="source-inline">r7</strong>,<strong class="source-inline">r2</strong>, register <strong class="source-inline">r4</strong> is the first element). The register is given by <strong class="source-inline">predicate[0]</strong>. The <strong class="source-inline">symbolTab</strong><span class="pcode-bold">[predicate[0]]</span> expression looks up the symbolic name and provides its value; for example, consider <strong class="source-inline">TIME EQU R3</strong>. The <strong class="source-inline">INC TIME</strong> assembly language instruction will look up <strong class="source-inline">TIME</strong> and return <strong class="source-inline">R3</strong>. We now have the destination operand, but it is a string, <strong class="source-inline">'R3'</strong>, and not a number. We just want <strong class="source-inline">3</strong> and have to use the <strong class="source-inline">int</strong> function to convert a number in string format into an <span class="No-Break">integer value.</span></p>&#13;
			<p lang="en-GB">Let’s simplify the Python expression to make the explanation easier. Suppose we write <span class="No-Break">the following:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">destReg = </strong><span class="No-Break"><strong class="source-inline">symbolTab</strong></span><span class="No-Break"><span class="pcode-bold">[predicate[0]]</span></span></p>&#13;
			<p lang="en-GB">The value of <strong class="source-inline">destReg</strong> is the string representing the destination register. Assume that this is <strong class="source-inline">'R3'</strong>. What we need to do is to isolate <strong class="source-inline">'3'</strong> from <strong class="source-inline">'R3'</strong> and then convert the character <strong class="source-inline">'3'</strong> into the integer <strong class="source-inline">3</strong>. We can write <strong class="source-inline">destRegNum = destReg[1:]</strong> to return all characters in the string except the initial <strong class="source-inline">'R'</strong>. The final step is to convert into an integer, which we can do with <strong class="source-inline">rD = </strong><span class="No-Break"><strong class="source-inline">int(destRegNum)</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Remember that <strong class="source-inline">[1:]</strong> means all the characters after the first character, <strong class="source-inline">'R'</strong>. Consequently, this returns <strong class="source-inline">'3'</strong> if the register was <strong class="source-inline">'R3'</strong>. We could have written <strong class="source-inline">[1:2]</strong> rather than <strong class="source-inline">[1:]</strong> since the number is in the range 1 to 7. However, by using the <strong class="source-inline">[1:]</strong> notation, we can later increase the number of registers beyond 9 without changing <span class="No-Break">the program.</span></p>&#13;
			<p lang="en-GB">Putting all three steps together, we get <strong class="source-inline">rD = </strong><span class="No-Break"><strong class="source-inline">int(symbolTab[predicate[0]][1:])</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The following Python code shows<a id="_idIndexMarker379"/><a id="_idIndexMarker380"/> the entire <span class="No-Break">decoding process:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>form = codes.get(opCode)                      <span class="sc-comment"># Use opcode to read type of instruction</span></span>&#13;
<span>if form[0] &amp; <strong class="bold">0b1000</strong> == 0b1000:                <span class="sc-comment"># Bit 4 of format selects destination register rD</span></span>&#13;
<span>    if predicate[0] in symbolTab:             <span class="sc-comment"># Check whether first token is sym tab</span></span>&#13;
<span>          rD = int(symbolTab[predicate[0]][1:])  <span class="sc-comment"># If it is, then get its value</span></span>&#13;
<span>    else: rD = int(predicate[0][1:])          <span class="sc-comment"># If it's not a label, get from the predicate</span></span>&#13;
<span>if form[0] &amp; <strong class="bold">0b0100</strong> == 0b0100:                <span class="sc-comment"># Bit 3 selects register source register 1, rS1</span></span>&#13;
<span>    if predicate[1] in symbolTab:</span>&#13;
<span>          rS1 = int(symbolTab[predicate[1]][1:])</span>&#13;
<span>    else: rS1 = int(predicate[1][1:])</span>&#13;
<span>if form[0] &amp; <strong class="bold">0b0010</strong> == 0b0010:                <span class="sc-comment"># Bit 2 of format selects register rS1</span></span>&#13;
<span>    if predicate[2] in symbolTab:</span>&#13;
<span>          rS2 = int(symbolTab[predicate[2]][1:])</span>&#13;
<span>    else: rS2 = int(predicate[2][1:])</span>&#13;
<span class="sc-grey" lang="en-GB">if form[0] &amp; 0b0001 == 0b0001:                <span class="sc-comment"># Bit 1 of format indicates a literal</span></span>&#13;
<span class="sc-grey" lang="en-GB">    if predicate[-1] in symbolTab:            <span class="sc-comment"># If literal in symbol table, get it</span></span>&#13;
<span class="sc-grey" lang="en-GB">        predicate[-1] = symbolTab[predicate[-1]]</span>&#13;
<span class="sc-grey" lang="en-GB">    elif type(predicate[-1]) == 'int':                                <span class="sc-comment"># Integer</span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal = str(literal)</span>&#13;
<span class="sc-grey" lang="en-GB">    elif predicate[-1][0]    == '%':                                  <span class="sc-comment"># Binary</span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal=int(predicate[-1][1:],2) </span>&#13;
<span class="sc-grey" lang="en-GB">    elif predicate[-1][0:2]  == '0B':                                 <span class="sc-comment"># Binary </span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal=int(predicate[-1][2:],2)</span>&#13;
<span class="sc-grey" lang="en-GB">    elif predicate[-1][0:1]  == '$':                                  <span class="sc-comment"># Hex</span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal=int(predicate[-1][1:],16)</span>&#13;
<span class="sc-grey" lang="en-GB">    elif predicate[-1][0:2]  == '0X':                                 <span class="sc-comment"># Hex</span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal=int(predicate[-1][2:],16)</span>&#13;
<span class="sc-grey" lang="en-GB">    elif predicate[-1].isnumeric():                                   <span class="sc-comment"># Decimal</span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal=int(predicate[-1])</span>&#13;
<span class="sc-grey" lang="en-GB">    elif predicate[-1][0]    == '-':                                  <span class="sc-comment"># Negative</span></span>&#13;
<span class="sc-grey" lang="en-GB">        literal=(-int(predicate[-1][1:]))&amp;0xFFFF</span>&#13;
<span class="sc-grey">    else:  literal = 0                                                <span class="sc-comment"># Default</span></span></pre>&#13;
			<p lang="en-GB">This block of code performs the same sequence of operations three times, processing <strong class="source-inline">rD</strong>, then <strong class="source-inline">rS1</strong> (the first source register), and then <strong class="source-inline">rS2</strong> (the second source register) in the same way. The last section of this block of code (shaded)) is more complicated because we allow several representations of the literal. We use an <strong class="source-inline">if…elif</strong> structure to test for a symbolic literal, a binary literal, a hexadecimal literal, an unsigned decimal numeric literal, and finally, a negative decimal <span class="No-Break">numeric literal.</span></p>&#13;
			<p lang="en-GB">The literal is a numeric constant used by an instruction. However, in the assembly language, the literal is represented by a text string; that is, if the literal is <strong class="source-inline">12</strong>, it is the string <strong class="source-inline">'12'</strong> and not the numeric value <strong class="source-inline">12</strong>. It has to be converted into numeric form by the <span class="No-Break"><strong class="source-inline">int()</strong></span><span class="No-Break"> function.</span></p>&#13;
			<p lang="en-GB">We initially decided to allow decimal, binary, or hexadecimal integers. Later, we included symbolic names because they are so easy to deal with using Python’s dictionary. Suppose we have an instruction that has been tokenized into a mnemonic and a predicate that contains registers and a literal or symbolic name, for example, <strong class="source-inline">['R1', 'R2' , 'myData']</strong>. Consider the <span class="No-Break">following code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if <strong class="bold">predicate[-1]</strong> in symbolTab:                 <span class="sc-comment"># If literal is in symbol table, look up value</span></span>&#13;
<span>   predicate[-1] = symbolTab[predicate[-1]]    <span class="sc-comment"># Get its value from the symbol table</span></span></pre>&#13;
			<p lang="en-GB">This takes the last element of the predicate (indicated by the <strong class="source-inline">[-1]</strong> index) and looks to see whether it’s in the symbol table. If it isn’t, the code tests for other types of literal. If it is in the symbol table, it is extracted and the <strong class="source-inline">myData</strong> symbolic name is replaced <a id="_idIndexMarker381"/><a id="_idIndexMarker382"/>with its <span class="No-Break">actual value.</span></p>&#13;
			<p lang="en-GB">The literal in the table may be an integer or a string. The following converts it into a string if it is <span class="No-Break">a literal:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">if type(predicate[-1])=='int':</strong> literal=str(literal) <span class="sc-comment"># Integer to string</span></span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">if</strong> construct uses the <strong class="source-inline">type()</strong> function, which returns the type of an object. In this case, it will be <strong class="source-inline">'int'</strong> if the object is an integer. The <strong class="source-inline">str()</strong> function converts an integer object into a <span class="No-Break">string object.</span></p>&#13;
			<p lang="en-GB">This action may seem strange because we are converting an integer (which we want) into a string (which we don’t want). The reason for this anomaly is that we are later going to test for hex, binary, and signed values that will be strings, and keeping all literals as strings simplifies <span class="No-Break">the coding.</span></p>&#13;
			<p lang="en-GB">The following code demonstrates how three number formats are converted into integer form, ready for packing into the final 32-bit TC1 <span class="No-Break">machine instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if   predicate[-1][0]   == '%':  literal = int(predicate[-1][1:],2)</span>&#13;
<span>elif predicate[-1][0:2  == '0B': literal = int(predicate[-1][2:],2)</span>&#13;
<span>elif predicate[-1][0:1] == '$':  literal = int(predicate[-1][1:],16)</span>&#13;
<span>elif predicate[-1][0:2] == '0X': literal = int(predicate[-1][2:],16)</span>&#13;
<span>elif predicate[-1].isnumeric():  literal = int(predicate[-1])</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Binary numbers are prefixed with either <strong class="source-inline">%</strong> or <strong class="source-inline">0b</strong> in the TC1 assembly language, and hexadecimal values with <strong class="source-inline">$</strong> or <strong class="source-inline">0x</strong>. The constant is tested to see whether it’s decimal, binary, or hex, and then the appropriate conversion is performed. Converting a binary string, <strong class="source-inline">x</strong>, into an integer, <strong class="source-inline">y</strong>, is done with <strong class="source-inline">y = int(x,2)</strong>. The parameter in bold is the number base. In this case, it’s <strong class="source-inline">2</strong> in binary format. In hexadecimal format, <span class="No-Break">it’s 16.</span></p>&#13;
			<p lang="en-GB">Let’s look at the hex conversion. We have to make two selections: the token and then the specific characters of the token. Consider <strong class="source-inline">ADDL R1,R2,0XF2A4</strong>. The predicate is <strong class="source-inline">'R1 R2 0XF2A4'</strong>, which is tokenized as <strong class="source-inline">predicate = ['R1', '</strong><span class="No-Break"><strong class="source-inline">R2', '0XF2A4']</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The value of <strong class="source-inline">predicate[-1]</strong> is <strong class="source-inline">'</strong><span class="pcode-bold-bg">0X</span><span class="pcode-bold">F2A4</span><strong class="source-inline">'</strong>. To test for a hexadecimal value, we have to look at the first two characters to see whether they are <strong class="source-inline">'0X'</strong>. Note <strong class="source-inline">0X</strong><span class="No-Break"> </span>not <strong class="source-inline">0x</strong> because TC1 converts input into uppercase. We could write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>lastToken = predicate[-1]              <span class="sc-comment"># Get the last token from the predicate</span></span>&#13;
<span>prefix = lastToken[0:2]                <span class="sc-comment"># Get the first two characters of this token to test for '</span><span class="sc-comment-bg">0X</span>'</span></pre>&#13;
			<p lang="en-GB">We can save a line by combining the two list-index suffixes, <strong class="source-inline">[-1]</strong> and <strong class="source-inline">[0:2</strong>], <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">predicate[-1][0:2]</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The third line of the code, <strong class="source-inline">elif predicate[-1].isnumeric(): literal=int(predicate[-1])</strong>, detects decimal strings and converts them into numeric form. Since decimal values don’t have a prefix, we use the <strong class="source-inline">isnumeric</strong> method to test for a string that has a numeric value. This line is read as, "<em class="italic">If the last token in the predicate is numeric, then convert it into an </em><span class="No-Break"><em class="italic">integer value</em></span><span class="No-Break">."</span></p>&#13;
			<p lang="en-GB">Finally, we have to deal with negative numbers (e.g., -5). If a literal is prefixed with -, the remaining string is read and converted into two’s complement binary form in 16 bits. This is necessary because the TC1 computer represents signed integers in 16-bit two’s <span class="No-Break">complement form.</span></p>&#13;
			<p lang="en-GB">The generation of the final 32-bit binary <a id="_idIndexMarker383"/><a id="_idIndexMarker384"/>code of an instruction is easy. We have an opcode and zero to four fields to insert. The fields are initially set to all zeros (the default values). Then, each field is shifted left to its required place in the instruction and inserted into the instruction by using a bit-wise <strong class="source-inline">OR</strong> operation. The code for this is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>s2      = s2      &lt;&lt; 16                <span class="sc-comment"># Shift source 2 16 places left</span></span>&#13;
<span>s1      = s1      &lt;&lt; 19                <span class="sc-comment"># Shift source 1 19 places left</span></span>&#13;
<span>destReg = destReg &lt;&lt; 22                <span class="sc-comment"># Shift destination register 22 places left</span></span>&#13;
<span>op      = op      &lt;&lt; 25                <span class="sc-comment"># Shift opcode 25 places left</span></span>&#13;
<span>binCode = lit | s2 | s1 | destReg | op <span class="sc-comment"># Logical OR the fields</span></span></pre>&#13;
			<p lang="en-GB">We could do all this in one line, <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>binCode = lit | (s2 &lt;&lt; 16) | (s1 &lt;&lt; 19) | (destReg &lt;&lt; 22)| (op &lt;&lt; 25)</span></pre>&#13;
			<p lang="en-GB">In the next chapter, we’ll return to the TC1 simulator and expand it. We’ll also demonstrate how the TC1 simulator can be extended by adding new operations to the instruction set and some ways of printing the results of <span class="No-Break">a simulator.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Before presenting the full TC1, we are going to demonstrate a simplified version that can execute an assembly language program, essentially the same as the TC1. However, this version has been designed to reduce the total complexity by leaving out features such as symbolic names or the ability to use different number bases when specifying a constant. In this case, all literals are simple <span class="No-Break">decimal integers.</span></p>&#13;
			<h1 id="_idParaDest-101" lang="en-GB"><a id="_idTextAnchor101"/>Intermission: The Pre-TC1</h1>&#13;
			<p lang="en-GB">In order to provide a more complete overview of the operation of a CPU simulator, we are going to introduce a highly simplified, but complete, version to give you an idea of how things fit together, before we create a more <span class="No-Break">complex system.</span></p>&#13;
			<p lang="en-GB">In this section, you will learn how to design a simulator without some of the complications associated with a fully <span class="No-Break">fledged design.</span></p>&#13;
			<p lang="en-GB">This version of TC1, called TC1<span class="subscript">mini</span>, can execute assembly language. However, we use a fixed format for assembly-level instructions (input is case-sensitive) and a fixed literal format (no hexadecimal or binary numbers), and we don’t support labels and symbolic names. This approach helps stop the details from getting in the way of the <span class="No-Break">bigger picture.</span></p>&#13;
			<h2 id="_idParaDest-102" lang="en-GB"><a id="_idTextAnchor102"/>The Simulator</h2>&#13;
			<p lang="en-GB">The simulator supports <a id="_idIndexMarker385"/><a id="_idIndexMarker386"/>register-to-register operations, such as <strong class="source-inline">ADD r1,r2,r3</strong>. Its only memory access is pointer-based, that is, <strong class="source-inline">LDRI r1,[r2]</strong> and <strong class="source-inline">STRI r1,[r2]</strong>. It provides increment and decrement instructions, <strong class="source-inline">INC r1</strong> and <strong class="source-inline">INC r2</strong>. There are two compare operations: <strong class="source-inline">CMPI r1,5</strong> and <strong class="source-inline">CMP r1,r2</strong> (the former compares a register with a literal and the latter compares two registers). To keep things simple, the only status flag is <strong class="source-inline">z</strong> (zero) and this is used only by compare and <span class="No-Break">subtract operations.</span></p>&#13;
			<p lang="en-GB">Three branch instructions are provided (unconditional branch, branch on zero, and branch on not zero). Since this simulator doesn’t support symbolic names, a branch requires a literal to indicate the destination. Branching is relative to the current location of the branch instruction; for example, <strong class="source-inline">BRA 3</strong> means jump to the instruction three locations forward, and <strong class="source-inline">BRA -2</strong> means jump two <span class="No-Break">instructions backward.</span></p>&#13;
			<p lang="en-GB">I did not provide a file-based program input mechanism (i.e., reading a source program as a text file). The assembly language program to be executed is embedded as a Python list of strings called <strong class="source-inline">sFile</strong>. You can readily modify this or substitute the code to input <span class="No-Break">a file.</span></p>&#13;
			<p lang="en-GB">The opcodes are set up in a dictionary of the <span class="No-Break">following form:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>codes = {'STOP':[0], 'LDRL':[3], 'STRL':[7]}</span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">key:value</strong> pair uses a mnemonic as the key and a list with one item, the class of the instruction, as the value. The classes range from <strong class="source-inline">0</strong> (a mnemonic with no operands) to <strong class="source-inline">7</strong> (a mnemonic with a register and register indirect operand). We’ve not implemented TC1’s 4-bit format code, which is used to determine the parameters required by an instruction, because that information is implicit in the class. Moreover, we do not assemble the instruction into a binary code. We read the mnemonic in text form and directly <span class="No-Break">execute it.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">When an instruction is read, it is first tokenized to create a list of one to four tokens, for example, <strong class="source-inline">['CMPL', 'r3', '5']</strong>. When an instruction is read from the source, the class is determined and used to extract the required information from <span class="No-Break">the tokens.</span></p>&#13;
			<p lang="en-GB">Once the mnemonic and register numbers/values and literal are known, a simple <strong class="source-inline">if .. elif</strong> structure is used to select the appropriate instruction and then execute it. Most instructions are interpreted in a single line <span class="No-Break">of Python.</span></p>&#13;
			<p lang="en-GB">At the end of the instruction reading and execution loop, you are invited to hit a key to execute the next instruction in sequence. The data displayed after each instruction is the program counter, z-bit, instruction, registers, and memory location. We use <a id="_idIndexMarker387"/><a id="_idIndexMarker388"/>only four registers and eight <span class="No-Break">memory locations.</span></p>&#13;
			<p lang="en-GB">We have split this program into sections with brief descriptions between them. The first part provides the source code as a built-in list. It defines the instruction classes and provides a list of opcodes and their classes. We don’t use a dictionary for this. However, we do provide dictionaries for the registers and their indirect versions to simplify analyzing instructions. For example, we can look up both <strong class="source-inline">r1</strong> and <strong class="source-inline">r2</strong> in the <strong class="source-inline">LDRI </strong><span class="No-Break"><strong class="source-inline">r1,[r2]</strong></span><span class="No-Break"> instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>sFile = ['LDRL r2,1','LDRL r0,4','NOP','STRI r0,[r2]','LDRI r3,[r2]',   \</span>&#13;
<span>         'INC r3','ADDL r3,r3,2','NOP','DEC r3', 'BNE -2','DEC r3','STOP']</span>&#13;
<span>                                            <span class="sc-comment"># Source program for testing</span></span>&#13;
<span><span class="sc-comment"># Simple CPU instruction interpreter. Direct instruction interpretation. 30 September 2022. V1.0</span></span>&#13;
<span># Class 0: no operand                   NOP</span>&#13;
<span># Class 1: literal                      BEQ  3</span>&#13;
<span># Class 2: register                     INC  r1</span>&#13;
<span># Class 3: register,literal             LDRL r1,5</span>&#13;
<span># Class 4: register,register,           MOV  r1,r2</span>&#13;
<span># Class 5: register,register,literal    ADDL r1,r2,5</span>&#13;
<span># Class 6: register,register,register   ADD  r1,r2,r3</span>&#13;
<span># Class 7: register,[register]          LDRI r1,[r2]</span>&#13;
<span>codes = {'NOP':[0],'STOP':[0],'BEQ':[1],'BNE':[1],'BRA':[1],  \</span>&#13;
<span>         'INC':[2],'DEC':[2],'CMPL':[3],'LDRL':[3],'MOV':[4],  \</span>&#13;
<span>         'CMP':[4],'SUBL':[5],'ADDL':[5],'ANDL':[5],'ADD':[6], \</span>&#13;
<span>         'SUB':[6], 'AND':[6],'LDRI':[7],'STRI':[7]}</span>&#13;
<span>reg1  = {'r0':0,'r1':1,'r2':2,'r3':3}       <span class="sc-comment"># Legal registers</span></span>&#13;
<span>reg2  = {'[r0]':0,'[r1]':1,'[r2]':2,'[r3]':3} <span class="sc-comment"># Legal pointer registers</span></span>&#13;
<span>r = [0] * 4                                 <span class="sc-comment"># Four registers</span></span>&#13;
<span>r[0],r[1],r[2],r[3] = 1,2,3,4               <span class="sc-comment"># Preset registers for testing</span></span>&#13;
<span>m  = [0] * 8                                <span class="sc-comment"># Eight memory locations</span></span>&#13;
<span>pc = 0                                      <span class="sc-comment"># Program counter initialize to 0</span></span>&#13;
<span>go = 1                                      <span class="sc-comment"># go is the run control (1 to run)</span></span>&#13;
<span>z  = 0                                      <span class="sc-comment"># z is the zero flag. Set/cleared by SUB, DEC, CMP</span></span>&#13;
<span>while go == 1:                              <span class="sc-comment"># Repeat execute fetch and execute loop</span></span>&#13;
<span>    thisLine = sFile[pc]                    <span class="sc-comment"># Get current instruction</span></span>&#13;
<span>    pc = pc + 1                             <span class="sc-comment"># Increment pc</span></span>&#13;
<span>    pcOld = pc                              <span class="sc-comment"># Remember pc value for this cycle</span></span>&#13;
<span>    temp = thisLine.replace(',',' ')        <span class="sc-comment"># Remove commas: ADD r1,r2,r3 to ADD r1 r2 r3</span></span></pre>&#13;
			<pre class="source-code">    tokens = temp.split(' ')                <span class="sc-comment"># Tokenize:  ADD r1 r2 r3 to ['ADD','r1','r2','r3']</span></pre>&#13;
			<p lang="en-GB">In the following section, we analyze an instruction to extract the values of the operands required by the instruction. This is achieved by looking at the<a id="_idIndexMarker389"/><a id="_idIndexMarker390"/> instruction’s op-class and then extracting the appropriate information (e.g., the <span class="No-Break">register number):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    mnemonic = tokens[0]                  <span class="sc-comment"># Extract first token, the mnemonic</span></span>&#13;
<span>    opClass = codes[mnemonic][0]          #<span class="sc-comment"> Extract instruction class</span></span>&#13;
<span>                                          #<span class="sc-comment"> Process the current instruction and analyze it</span></span>&#13;
<span>    rD,rDval,rS1,rS1val,rS2,rS2val,lit, rPnt,rPntV = 0,0,0,0,0,0,0,0,0 </span>&#13;
<span>                                          <span class="sc-comment"># Clear all parameters</span></span>&#13;
<span>    if opClass in [0]: pass               #<span class="sc-comment"> If class 0, nothing to be done (simple opcode only)</span></span>&#13;
<span>    if opClass in [2,3,4,5,6,7,8]:        #<span class="sc-comment"> Look for ops with destination register rD</span></span>&#13;
<span>        rD     = reg1[tokens[1]]          #<span class="sc-comment"> Get token 1 and use it to get register number as rD</span></span>&#13;
<span>        rDval  = r[rD]                    #<span class="sc-comment"> Get contents of register rD</span></span>&#13;
<span>    if opClass in [4,5,6]:                #<span class="sc-comment"> Look at instructions with first source register rS1</span></span>&#13;
<span>        rS1    = reg1[tokens[2]]          #<span class="sc-comment"> Get rS1 register number and then contents</span></span>&#13;
<span>        rS1val = r[rS1]</span>&#13;
<span>    if opClass in [6]:                    #<span class="sc-comment"> If class 6, it's got three registers. Extract rS2</span></span>&#13;
<span>        rS2    = reg1[tokens[3]]          #<span class="sc-comment"> Get rS2 and rS2val</span></span>&#13;
<span>        rS2val = r[rS2]</span>&#13;
<span>    if opClass in [1,3,5,8]:              #<span class="sc-comment"> The literal is the last element in instructions</span></span>&#13;
<span>        lit    = int(tokens[-1])          #<span class="sc-comment"> Get the literal</span></span>&#13;
<span>    if opClass in [7]:                    #<span class="sc-comment"> Class 7 involves register indirect addressing</span></span>&#13;
<span>        rPnt   = reg2[tokens[2]]          <span class="sc-comment"># Get the pointer (register) and value of the pointer</span></span>&#13;
<span>        rPntV  = r[rPnt]                  <span class="sc-comment"># Get the register number</span></span>&#13;
<span>    if mnemonic == 'STOP':                <span class="sc-comment"># Now execute instructions. If STOP, clear go and exit</span></span>&#13;
<span>        go = 0</span>&#13;
<span>        print('Program terminated')</span></pre>&#13;
			<p lang="en-GB">This is the instruction execution part of the program. We use a series of comparisons of the mnemonic with the opcodes and then directly execute the instruction. Unlike TC1, we do not convert the mnemonic into binary code and then execute it by converting the binary code into <span class="No-Break">appropriate operations:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    elif mnemonic == 'NOP':  pass         #<span class="sc-comment"> NOP does nothing. Just drop to end of loop</span></span>&#13;
<span>    elif mnemonic == 'INC': r[rD] = rDval + 1  <span class="sc-comment"># Increment: add 1 to destination register</span></span>&#13;
<span>    elif mnemonic == 'DEC':               #<span class="sc-comment"> Decrement: subtract 1 from register and update z bit</span></span>&#13;
<span>        z = 0</span>&#13;
<span>        r[rD] = rDval - 1</span>&#13;
<span>        if r[rD] == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'BRA':               <span class="sc-comment"># Unconditional branch</span></span>&#13;
<span>        pc = pc + lit - 1</span>&#13;
<span>    elif mnemonic == 'BEQ':               <span class="sc-comment"># Conditional branch on zero</span></span>&#13;
<span>        if z == 1: pc = pc + lit - 1</span>&#13;
<span>    elif mnemonic == 'BNE':               <span class="sc-comment"># Conditional branch on not zero</span></span>&#13;
<span>        if z == 0: pc = pc + lit - 1</span>&#13;
<span>    elif mnemonic == 'ADD': r[rD]=rS1val+rS2val <span class="sc-comment"># Add</span></span>&#13;
<span>    elif mnemonic == 'ADDL': r[rD] = rS1val+lit <span class="sc-comment"># Add literal</span></span>&#13;
<span>    elif mnemonic == 'SUB':                     #<span class="sc-comment"> Subtract and set/clear z</span></span>&#13;
<span>        r[rD] = rS1val - rS2val</span>&#13;
<span>        z = 0</span>&#13;
<span>        if r[rD] == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'SUBL':                    #<span class="sc-comment"> Subtract literal</span></span>&#13;
<span>        r[rD] = rS1val - lit</span>&#13;
<span>        z = 0</span>&#13;
<span>        if r[rD] == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'CMPL':                    #<span class="sc-comment"> Compare literal</span></span>&#13;
<span>        diff = rDval - lit</span>&#13;
<span>        z = 0</span>&#13;
<span>        if diff == 0 : z = 1</span>&#13;
<span>    elif mnemonic == 'CMP':                     <span class="sc-comment"># Compare</span></span>&#13;
<span>        diff = rDval - rS1val</span>&#13;
<span>        z = 0</span>&#13;
<span>        if diff == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'MOV':  r[rD] = rS1val     <span class="sc-comment"># Move, load, and store operations</span></span>&#13;
<span>    elif mnemonic == 'LDRL': r[rD] = lit</span>&#13;
<span>    elif mnemonic == 'LDRI': r[rD] = m[rPntV]</span>&#13;
<span>    elif mnemonic == 'STRI': m[rPntV] = rDval</span>&#13;
<span>    regs = ' '.join('%02x' % b for b in r)      <span class="sc-comment"># Format memory locations hex</span></span>&#13;
<span>    mem  = ' '.join('%02x' % b for b in m)      <span class="sc-comment"># Format registers hex</span></span>&#13;
<span>    print('pc =','{:&lt;3}'.format(pcOld), '{:&lt;14}'.format(thisLine), \</span>&#13;
<span>          'Regs =',regs, 'Mem =',mem, 'z =', z)</span>&#13;
<span>    x = input('&gt;&gt;&gt; ')               <span class="sc-comment"># Request keyboard input before dealing with next instruction</span></span></pre>&#13;
			<p lang="en-GB">Note that the execution loop ends with an input <a id="_idIndexMarker391"/><a id="_idIndexMarker392"/>request from the keyboard. In this way, the next cycle is not executed until the <em class="italic">Enter</em>/<em class="italic">Return</em> key <span class="No-Break">is pressed.</span></p>&#13;
			<p lang="en-GB">The following shows the output of the simulator as the embedded program is executed. Changed registers, memory locations, and flag values are in <span class="No-Break">bold font:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pc = 1   LDRL r2,1     Regs = 01 02 <strong class="bold">01</strong> 04 Mem = 00 00 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 2   LDRL r0,4     Regs = <strong class="bold">04</strong> 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 3   NOP           Regs = 04 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 4   STRI r0,[r2]  Regs = 04 02 01 04 Mem = 00 <strong class="bold">04</strong> 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 5   LDRI r3,[r2]  Regs = 04 02 01 <strong class="bold">04</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 6   INC r3        Regs = 04 02 01 <strong class="bold">05</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 7   ADDL r3,r3,2  Regs = 04 02 01 <strong class="bold">07</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 07 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">06</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">05</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">04</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">03</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">02</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">01</strong> Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 8   NOP           Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>pc = 9   DEC r3        Regs = 04 02 01 <strong class="bold">00</strong> Mem = 00 04 00 00 00 00 00 00 <strong class="bold">z = 1</strong></span>&#13;
<span>pc = 10  BNE -2        Regs = 04 02 01 00 Mem = 00 04 00 00 00 00 00 00 z = 1</span>&#13;
<span>pc = 11  DEC r3        Regs = 04 02 01 -1 Mem = 00 04 00 00 00 00 00 00 z = 0</span>&#13;
<span>Program terminated</span>&#13;
<span>pc = 12  STOP          Regs = 04 02 01 -1 Mem = 00 04 00 00 00 00 00 00 z = 0</span></pre>&#13;
			<p lang="en-GB">We will now look at the program for the TC1 simulator. We will include<a id="_idIndexMarker393"/><a id="_idIndexMarker394"/> a short introduction to some of its facilities before providing <span class="No-Break">the code.</span></p>&#13;
			<h1 id="_idParaDest-103" lang="en-GB">T<a id="_idTextAnchor103"/>he TC1 simulator program</h1>&#13;
			<p lang="en-GB">In this section, we provide<a id="_idIndexMarker395"/><a id="_idIndexMarker396"/> the full code for the TC1 assembler and simulator. This will enable you to construct and modify a computer assembler and simulator that can execute the code supported by TC1 or your own instruction set (if you <span class="No-Break">modify TC1).</span></p>&#13;
			<p lang="en-GB">The assembler is the more complicated part because it involves reading text, analyzing it, and formatting it into binary codes. The simulator itself simply reads each binary code and then performs the <span class="No-Break">appropriate action.</span></p>&#13;
			<p lang="en-GB">The simulator includes features that we haven’t covered yet in previous sections (e.g., debugging and trace facilities). In the first draft of this book, TC1 was rather more basic with a minimal subset of features. As the book was edited and the program modified, the set of features was enhanced to make it a more practical tool. We first provide brief notes on some of these features to aid understanding of <span class="No-Break">the program.</span></p>&#13;
			<h2 id="_idParaDest-104" lang="en-GB"><a id="_idTextAnchor104"/>Single-stepping</h2>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">A computer executes instructions sequentially unless a branch or subroutine call is encountered. When testing a simulator, you frequently want to execute a batch of instructions together (i.e., without printing register values), or you may wish to execute instructions one at a time by hitting <em class="italic">Enter</em>/<em class="italic">Return</em> after each instruction has been executed or to execute instructions until you hit a <span class="No-Break">specific instruction.</span></p>&#13;
			<p lang="en-GB">In this version of TC1, you can execute and display an instruction, skip the display of the next n instructions, or not display instructions until a change-of-flow instruction is encountered. After the program is loaded, the input prompt is displayed. If you enter a return, the simulator executes the next instruction and waits. If you enter an integer (and return), the specified number of instructions is executed without displaying the results. If you enter b followed by a return, the<a id="_idIndexMarker397"/><a id="_idIndexMarker398"/> simulator executes instructions without displaying them until the next branch instruction <span class="No-Break">is encountered.</span></p>&#13;
			<p lang="en-GB">Consider the following example. The code is just a set of random instructions for demonstration. I’ve used no-operations (<strong class="source-inline">nop</strong>) as a filler. I’ve also tested literal address formats (hex and binary) and demonstrated <span class="No-Break">case insensitivity:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>@ test trace modes</span>&#13;
<span>    nop</span>&#13;
<span>    nop</span>&#13;
<span>    inc r1</span>&#13;
<span>    NOP</span>&#13;
<span>    dec r2</span>&#13;
<span>    ldrl r6,0b10101010</span>&#13;
<span>    bra abc</span>&#13;
<span>    nop</span>&#13;
<span>    inc R7</span>&#13;
<span>    nop</span>&#13;
<span>abc ldrl r3,$ABCD</span>&#13;
<span>    nop</span>&#13;
<span>    inc r3</span>&#13;
<span>    INC r4</span>&#13;
<span>    nop</span>&#13;
<span>    nop</span>&#13;
<span>    inc r5</span>&#13;
<span>    END!</span></pre>&#13;
			<p lang="en-GB">I’ve edited it to remove memory locations as they are not accessed. After the prompt, <strong class="source-inline">&gt;&gt;&gt;</strong>, you select what is to happen: trace one instruction, execute <strong class="source-inline">n</strong> instructions without stopping or displaying registers, or execute code to the next branch instruction without displaying it. In each case, the following program counter value is highlighted in the following output. The text in bold is a comment I left on an action on the current line (trace indicates a <em class="italic">Return</em>/<em class="italic">Enter</em> was hit, which executes the <span class="No-Break">next instruction):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>  &gt;&gt;&gt;  <strong class="bold CharOverride-1">trace</strong></span>&#13;
<span>0      NOP           PC= 0 z=0 n=0 c=0 R 0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span>&gt;&gt;&gt;3 <strong class="bold CharOverride-1">jump 3 instructions (silent trace)</strong></span>&#13;
<span>4      DEC R2        PC= 4 z=0 n=1 c=1 R 0000 0001 ffff 0000 0000 0000 0000 0000</span>&#13;
<span>&gt;&gt;&gt;b <strong class="bold CharOverride-1">jump to branch (silent mode up to next branch/rts/jsr)</strong></span>&#13;
<span>6      BRA ABC       PC= 6 z=0 n=1 c=1 R 0000 0001 ffff 0000 0000 0000 00aa 0000</span>&#13;
<span>&gt;&gt;&gt;  <strong class="bold CharOverride-1">trace</strong> Here's the sample run</span>&#13;
<span>10 ABC LDRL R3 $ABCD PC=10 z=0 n=1 c=1 R 0000 0001 ffff abcd 0000 0000 00aa 0000</span>&#13;
<span>&gt;&gt;&gt;  <strong class="bold CharOverride-1">trace</strong></span>&#13;
<span>11     NOP           PC=11 z=0 n=1 c=1 R 0000 0001 ffff abcd 0000 0000 00aa 0000</span>&#13;
<span>&gt;&gt;&gt;4 <strong class="bold CharOverride-1">jump 4</strong></span>&#13;
<span>16     INC R5        PC=16 z=0 n=0 c=1 R 0000 0001 ffff abce 0001 0001 00aa 0000</span>&#13;
<span>&gt;&gt;&gt;  <strong class="bold CharOverride-2">trace</strong></span>&#13;
<span>17     END!          PC=17 z=0 n=0 c=1 R 0000 0001 ffff abce 0001 0001 00aa 0000</span></pre>&#13;
			<h2 id="_idParaDest-105" lang="en-GB"><a id="_idTextAnchor105"/>File input</h2>&#13;
			<p lang="en-GB">When we first started writing a simulator, we<a id="_idIndexMarker399"/><a id="_idIndexMarker400"/> inputted test programs the easy way by typing the instructions in one by one. This worked for the simplest of tests but soon became tedious. Later, programs were input as a text file. That worked well when the filename was short, such as <strong class="source-inline">t.txt</strong>, but it got more tedious with long filenames (e.g., when I stored the source code in a <span class="No-Break">specific directory).</span></p>&#13;
			<p lang="en-GB">We then included the filename in the actual TC1 program. That’s convenient when you’re going to be running the same program over and over again while you’re testing various features of the simulator. What we needed was a means of using my working program (baked into the simulator) most of the time, but to switch to an alternative <span class="No-Break">when required.</span></p>&#13;
			<p lang="en-GB">One sensible solution would be to generate an input banner prompting you to press <em class="italic">Enter</em> for the default file, or provide a filename for an alternative source program, say, <em class="italic">Enter return for the default file</em> or <em class="italic">Enter a filename for an alternative source program</em>. We decided to use Python’s exception mechanism to implement this. In computing, an <em class="italic">exception</em> (also called a <em class="italic">software interrupt</em>) is a mechanism designed to deal with unexpected events. In Python, the exception handler uses two reserved words: <strong class="source-inline">try</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">exception</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">As their names suggest, <strong class="source-inline">try</strong> requires Python to run the following block of code, and <strong class="source-inline">exception</strong> is a block of code that is executed if the <strong class="source-inline">try</strong> block failed. Essentially, it means, <em class="italic">“If you can’t do this, do that.”</em> The difference between <strong class="source-inline">if</strong> and <strong class="source-inline">try</strong> is that <strong class="source-inline">if</strong> returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> and performs the specified action if <strong class="source-inline">True</strong>, whereas <strong class="source-inline">try</strong> <em class="italic">attempts</em> to run a block and calls an exception if it fails, that is, if <span class="No-Break">it crashes.</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">try</strong> allows you to attempt to open a file and then gives you a way out if the file doesn’t exist (i.e., it avoids a fatal error). Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>myProg = 'testException1.txt'                      <span class="sc-comment"># Name of default program</span></span>&#13;
<span class="sc-grey" lang="en-GB"><strong class="bold">try:</strong>                                               <span class="sc-comment"># Check whether this file exists</span></span>&#13;
<span class="sc-grey" lang="en-GB">    with open(myProg,'r') as prgN:                 <span class="sc-comment"># If it's there, open it and read it</span></span>&#13;
<span class="sc-grey" lang="en-GB">        myFile = prgN.readlines()</span>&#13;
<span class="sc-bottom" lang="en-GB"><strong class="bold">except:</strong>                                            <span class="sc-comment"># Call exception if file not there</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    altProg = input('Enter source file name: ')    <span class="sc-comment"># Request a filename</span></span>&#13;
<span class="sc-bottom" lang="en-GB">    with open(altProg,'r') as prgN:                <span class="sc-comment"># Open the user file</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        myFile = prgN.readlines()</span>&#13;
<span class="sc-bottom">print('File loaded: ', myFile)</span></pre>&#13;
			<p lang="en-GB">This code looks for a file called <strong class="source-inline">testException1.txt</strong>. If it’s present (as it is in this case), the simulator runs it and we get the <span class="No-Break">following output:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; %Run testTry.py</span>&#13;
<span>File loaded:  ['   @ Test exception file\n', ' nop\n', ' nop\n', ' inc\n', ' end!']</span></pre>&#13;
			<p lang="en-GB">In the next case, we’ve deleted <strong class="source-inline">testException1.txt</strong>. We now get the following output after <span class="No-Break">the prompt:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; %Run testTry.py</span>&#13;
<span><strong class="bold">Enter source file name: testException2.txt</strong></span>&#13;
<span>File loaded:  ['   @ Test exception file TWO\n', ' dec r1\n', ' nop\n', ' inc r2\n', ' end!']</span></pre>&#13;
			<p lang="en-GB">The line in bold is the <span class="No-Break">alternative filename.</span></p>&#13;
			<p lang="en-GB">In the TC1 program, I further simplify <a id="_idIndexMarker401"/><a id="_idIndexMarker402"/>things by including the file directory in the exception (because I always use the same directory) and I include the file extension, <strong class="source-inline">.txt</strong>. This looks <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>prgN = 'E://ArchitectureWithPython//' + prgN + '.txt'</span></pre>&#13;
			<p lang="en-GB">This expression automatically provides the path for the filename and address of the <span class="No-Break">file type.</span></p>&#13;
			<p lang="en-GB">Remember that Python lets you use the <strong class="source-inline">+</strong> operator to <span class="No-Break">concatenate strings.</span></p>&#13;
			<h3 lang="en-GB">TC1 program</h3>&#13;
			<p lang="en-GB">The first part of the program<a id="_idIndexMarker403"/><a id="_idIndexMarker404"/> provides a list of instructions and their encoding. This text is placed between two <strong class="source-inline">'''</strong> markers that indicate it is not part of the program. This avoids having to start each line with <strong class="source-inline">#</strong>. The triple quote marks is called a <span class="No-Break">docstring comment.</span></p>&#13;
			<p lang="en-GB">The first part of TC1 is a listing of the instructions. These are provided to make the program easier <span class="No-Break">to follow:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment">### TC1 computer simulator and assembler. Version of 11 September 2022</span></span>&#13;
<span><strong class="source-inline">'''</strong><span class="sc-comment"> This is the table of instructions for reference and is not part of the program code</span></span>&#13;
<span>00 00000  <span class="sc-comment">stop operation</span>           <span class="sc-comment"> </span>STOP           <span class="sc-comment">  </span>00 00000 000 000 000 0  0000</span>&#13;
<span>00 00001  <span class="sc-comment">no operation</span>            <span class="sc-comment">  </span>NOP            <span class="sc-comment">  </span>00 00001 000 000 000 0  0000</span>&#13;
<span>00 00010  <span class="sc-comment">get character from keyboard</span>  GET  r0         00 00010 rrr 000 000 0  1000</span>&#13;
<span>00 00011  <span class="sc-comment">get character from keyboard</span>  RND  r0         00 00011 rrr 000 000 L  1001</span>&#13;
<span>00 00100  <span class="sc-comment">swap bytes in register</span>      <span class="sc-comment">  </span>SWAP r0         00 00100 rrr 000 000 0  1000</span>&#13;
<span>00 01000  <span class="sc-comment">print hex value in register</span>    <span class="sc-comment"> </span>PRT r0          00 01000 rrr 000 000 0  1000</span>&#13;
<span>00 11111  <span class="sc-comment">terminate program</span>        <span class="sc-comment"> </span>END!            00 11111 000 000 000 0  0000</span>&#13;
<span>01 00000  <span class="sc-comment">load register from register</span>   <span class="sc-comment">  </span>MOVE r0,r1      01 00000 rrr aaa 000 0  1100</span>&#13;
<span>01 00001  <span class="sc-comment">load register from memory</span>   LDRM r0,L       01 00001 rrr 000 000 L  1001</span>&#13;
<span>01 00010  <span class="sc-comment">load register with literal</span>     <span class="sc-comment">  </span>LDRL r0,L       01 00010 rrr 000 000 L  1001</span>&#13;
<span>01 00011  <span class="sc-comment">load register indirect</span>       <span class="sc-comment"> </span>LDRI r0,[r1,L]  01 00011 rrr aaa 000 L  1101</span>&#13;
<span>01 00100  <span class="sc-comment">store register in memory</span>    <span class="sc-comment">  </span>STRM r0,L       01 00100 rrr 000 000 L  1001</span>&#13;
<span>01 00101  <span class="sc-comment">store register indirect</span>       STRI r0,[r1,L]  01 00101 rrr aaa 000 L  1101</span>&#13;
<span>10 00000  <span class="sc-comment">add register to register</span>      ADD  r0,r1,r2   10 00000 rrr aaa bbb 0  1110</span>&#13;
<span>10 00001  <span class="sc-comment">add literal to register</span>       <span class="sc-comment"> </span>ADDL r0,r1,L    10 00001 rrr aaa 000 L  1101</span>&#13;
<span>10 00010  <span class="sc-comment">subtract register from register</span> SUB  r0,r1,r2   10 00010 rrr aaa bbb 0  1110</span>&#13;
<span>10 00011  <span class="sc-comment">subtract literal from register</span>  <span class="sc-comment">  </span>SUBL r0,r1,L    10 00011 rrr aaa 000 L  1101</span>&#13;
<span>10 00100  <span class="sc-comment">multiply register by register</span>   MUL  r0,r1,r2   10 00100 rrr aaa bbb 0  1110</span>&#13;
<span>10 00101  <span class="sc-comment">multiply literal by register</span>    <span class="sc-comment"> </span>MULL r0,r1,L    10 00101 rrr aaa 000 L  1101</span>&#13;
<span>10 00110  <span class="sc-comment">divide register by register</span>    <span class="sc-comment"> </span>DIV  r0,r1,r2   10 00110 rrr aaa bbb 0  1110</span>&#13;
<span>10 00111  <span class="sc-comment">divide register by literal</span>     <span class="sc-comment">  </span>DIVL r0,r1,L    10 00111 rrr aaa 000 L  1101</span>&#13;
<span>10 01000  <span class="sc-comment">mod register by register</span>     <span class="sc-comment"> </span>MOD  r0,r1,r2   10 01000 rrr aaa bbb 0  1110</span>&#13;
<span>10 01001  <span class="sc-comment">mod register by literal</span>      <span class="sc-comment">  </span>MODL r0,r1,L    10 01001 rrr aaa 000 L  1101</span>&#13;
<span>10 01010  <span class="sc-comment">AND register to register</span>     <span class="sc-comment"> </span>AND  r0,r1,r2   10 01000 rrr aaa bbb 0  1110</span>&#13;
<span>10 01011  <span class="sc-comment">AND register to literal</span>      <span class="sc-comment">   </span>ANDL r0,r1,L    10 01001 rrr aaa 000 L  1101</span>&#13;
<span>10 01100  <span class="sc-comment">OR register to register</span>      <span class="sc-comment">  </span>OR   r0,r1,r2   10 01010 rrr aaa bbb 0  1110</span>&#13;
<span>10 01101  <span class="sc-comment">NOR register to literal</span>      <span class="sc-comment">  </span>ORL  r0,r1,L    10 01011 rrr aaa 000 L  1101</span>&#13;
<span>10 01110  <span class="sc-comment">EOR register to register</span>     <span class="sc-comment">  </span>OR   r0,r1,r2   10 01010 rrr aaa bbb 0  1110</span>&#13;
<span>10 01111  <span class="sc-comment">EOR register to literal</span>       ORL  r0,r1,L    10 01011 rrr aaa 000 L  1101</span>&#13;
<span>10 10000  <span class="sc-comment">NOT register</span>            <span class="sc-comment">  </span>NOT  r0         10 10000 rrr 000 000 0  1000</span>&#13;
<span>10 10010  <span class="sc-comment">increment register</span>        <span class="sc-comment">  </span>INC  r0         <span class="sc-comment"> </span>10 10010 rrr 000 000 0  1000</span>&#13;
<span>10 10011  <span class="sc-comment">decrement register</span>        <span class="sc-comment"> </span>DEC  r0         10 10011 rrr 000 000 0  1000</span>&#13;
<span>10 10100  <span class="sc-comment">compare register with register</span> CMP  r0,r1      10 10100 rrr aaa 000 0  1100</span>&#13;
<span>10 10101  <span class="sc-comment">compare register with literal</span>  <span class="sc-comment"> </span>CMPL r0,L       10 10101 rrr 000 000 L  1001</span>&#13;
<span>10 10110  <span class="sc-comment">add with carry</span>            ADC            <span class="sc-comment">  </span>10 10110 rrr aaa bbb 0  1110</span>&#13;
<span>10 10111  <span class="sc-comment">subtract with borrow</span>       <span class="sc-comment"> </span>SBC             10 10111 rrr aaa bbb 0  1110</span>&#13;
<span>10 11000  <span class="sc-comment">logical shift left</span>           LSL  r0,L       10 10000 rrr 000 000 0  1001</span>&#13;
<span>10 11001  <span class="sc-comment">logical shift left literal</span>       LSLL r0,L       10 10000 rrr 000 000 L  1001</span>&#13;
<span>10 11010  <span class="sc-comment">logical shift right</span>          LSR  r0,L       10 10001 rrr 000 000 0  1001</span>&#13;
<span>10 11011  <span class="sc-comment">logical shift right literal</span>      LSRL r0,L       10 10001 rrr 000 000 L  1001</span>&#13;
<span>10 11100  <span class="sc-comment">rotate left</span>              <span class="sc-comment"> </span>ROL  r0,L       <span class="sc-comment"> </span>10 10010 rrr 000 000 0  1001</span>&#13;
<span>10 11101  <span class="sc-comment">rotate left literal</span>          <span class="sc-comment"> </span>ROLL r0,L       <span class="sc-comment"> </span>10 10010 rrr 000 000 L  1001</span>&#13;
<span>10 11110  <span class="sc-comment">rotate right</span>             <span class="sc-comment"> </span>ROR  r0,L       <span class="sc-comment"> </span>10 10010 rrr 000 000 0  1001</span>&#13;
<span>10 11111  <span class="sc-comment">rotate right literal</span>         <span class="sc-comment"> </span>RORL r0,L       <span class="sc-comment"> </span>10 10010 rrr 000 000 L  1001</span>&#13;
<span>11 00000  <span class="sc-comment">branch unconditionally</span>     <span class="sc-comment">  </span>BRA  L          <span class="sc-comment"> </span>11 00000 000 000 000 L  0001</span>&#13;
<span>11 00001  <span class="sc-comment">branch on zero</span>           BEQ  L          <span class="sc-comment"> </span>11 00001 000 000 000 L  0001</span>&#13;
<span>11 00010  <span class="sc-comment">branch on not zero</span>        <span class="sc-comment"> </span>BNE  L          <span class="sc-comment"> </span>11 00010 000 000 000 L  0001</span>&#13;
<span>11 00011  <span class="sc-comment">branch on minus</span>         <span class="sc-comment">  </span>BMI  L          <span class="sc-comment"> </span>11 00011 000 000 000 L  0001</span>&#13;
<span>11 00100  <span class="sc-comment">branch to subroutine</span>       BSR  L          <span class="sc-comment"> </span>11 00100 000 000 000 L  0001</span>&#13;
<span>11 00101  <span class="sc-comment">return from subroutine</span>     <span class="sc-comment">  </span>RTS             <span class="sc-comment"> </span>11 00101 000 000 000 0  0000</span>&#13;
<span>11 00110  <span class="sc-comment">decrement &amp; branch on not zero</span> DBNE r0,L     <span class="sc-comment">  </span>11 00110 rrr 000 000 L  1001</span>&#13;
<span>11 00111  <span class="sc-comment">decrement &amp; branch on zero</span>  DBEQ r0,L       <span class="sc-comment"> </span>11 00111 rrr 000 000 L  1001</span>&#13;
<span>11 01000  <span class="sc-comment">push register on stack</span>      <span class="sc-comment"> </span>PUSH r0         <span class="sc-comment">  </span>11 01000 rrr 000 000 0  1000</span>&#13;
<span>11 01001  <span class="sc-comment">pull register off stack</span>       PULL r0         <span class="sc-comment">  </span>11 01001 rrr 000 000 0  1000</span>&#13;
<span>'''</span>&#13;
<span>import random                       <span class="sc-comment"># Get library for random number generator</span></span>&#13;
<span>def alu(fun,a,b):                   <span class="sc-comment"># Alu defines operation and a and b are inputs</span></span>&#13;
<span>   global c,n,z                     <span class="sc-comment"># Status flags are global and are set up here</span></span>&#13;
<span>    if   fun == 'ADD': s = a + b</span>&#13;
<span>    elif fun == 'SUB': s = a - b</span>&#13;
<span>    elif fun == 'MUL': s = a * b</span>&#13;
<span>    elif fun == 'DIV': s = a // b   <span class="sc-comment"># Floor division returns an integer result</span></span>&#13;
<span>    elif fun == 'MOD': s = a % b    <span class="sc-comment"># Modulus operation gives remainder: 12 % 5 = 2</span></span>&#13;
<span>    elif fun == 'AND': s = a &amp; b    <span class="sc-comment"># Logic functions</span></span>&#13;
<span>    elif fun == 'OR':  s = a | b</span>&#13;
<span>    elif fun == 'EOR': s = a &amp; b</span>&#13;
<span>    elif fun == 'NOT': s = ~a</span>&#13;
<span>    elif fun == 'ADC': s = a + b + c <span class="sc-comment"># Add with carry</span></span>&#13;
<span>    elif fun == 'SBC': s = a - b – c <span class="sc-comment"># Subtract with borrow</span></span>&#13;
<span>    c,n,z = 0,0,0                    <span class="sc-comment"># Clear flags before recalculating them</span></span>&#13;
<span>    if s &amp; 0xFFFF == 0: z = 1        <span class="sc-comment"># Calculate the c, n, and z flags</span></span>&#13;
<span>    if s &amp; 0x8000 != 0: n = 1        <span class="sc-comment"># Negative if most sig bit 15 is 1</span></span>&#13;
<span>    if s &amp; 0xFFFF != 0: c = 1        <span class="sc-comment"># Carry set if bit 16 is 1</span></span>&#13;
<span>    return (s &amp; 0xFFFF)              <span class="sc-comment"># Return the result constrained to 16 bits</span></span></pre>&#13;
			<p lang="en-GB">Because the <strong class="source-inline">shift</strong> operation is rather<a id="_idIndexMarker405"/><a id="_idIndexMarker406"/> complex with left and right shifts, variable-length shifts, plus shifts, and rotates, we have provided a function to implement shifts. This takes the type of shift, direction, and number of places shifted as input parameters, together with the word to <span class="No-Break">be shifted:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def shift(dir,mode,p,q):   <span class="sc-comment"># Shifter: performs shifts and rotates. dir = left/right, mode = logical/rotate</span></span>&#13;
<span>    global z,n,c                    <span class="sc-comment"># Make flag bits global. Note v-bit not implemented</span></span>&#13;
<span>    if dir == 0:                    <span class="sc-comment"># dir = 0 for left shift, 1 for right shift</span></span>&#13;
<span>        for i in range (0,q):       <span class="sc-comment"># Perform q left shifts on p</span></span>&#13;
<span>            sign = (0x8000 &amp; p) &gt;&gt; 15            <span class="sc-comment"># Sign bit</span></span>&#13;
<span>            p = (p &lt;&lt; 1) &amp; 0xFFFF                <span class="sc-comment"># Shift p left one place</span></span>&#13;
<span>            if mode == 1:p = (p &amp; 0xFFFE) | sign <span class="sc-comment"># For rotate left, add in bit shifted out</span></span>&#13;
<span>    else:                                        <span class="sc-comment"># dir = 1 for right shift</span></span>&#13;
<span>        for i in range (0,q):                    <span class="sc-comment"># Perform q right shifts</span></span>&#13;
<span>            bitOut = 0x0001 &amp; p                  <span class="sc-comment"># Save lsb shifted out</span></span>&#13;
<span>            sign = (0x8000 &amp; p) &gt;&gt; 15            <span class="sc-comment"># Get sign-bit for ASR</span></span>&#13;
<span>            p = p &gt;&gt; 1                           <span class="sc-comment"># Shift p one place right</span></span>&#13;
<span>            if mode == 1:p = (p&amp;0x7FFF)|(bitOut&lt;&lt;15) <span class="sc-comment"># If mode = 1, insert bit rotated out</span></span>&#13;
<span>            if mode == 2:p = (p&amp;0x7FFF)|(sign &lt;&lt; 15) <span class="sc-comment"># If mode = 2, propagate sign bit</span></span>&#13;
<span>    z,c,n = 0,0,0                                <span class="sc-comment"># Clear all flags</span></span>&#13;
<span>    if p == 0:          z = 1                    <span class="sc-comment"># Set z if p is zero</span></span>&#13;
<span>    if p &amp; 0x8000 != 0: n = 1                    <span class="sc-comment"># Set n-bit if p = 1</span></span>&#13;
<span>    if (dir == 0) and (sign == 1):   c = 1       <span class="sc-comment"># Set carry if left shift and sign 1</span></span>&#13;
<span>    if (dir == 1) and (bitOut == 1): c = 1  <span class="sc-comment"># Set carry bit if right shift and bit moved out = 1</span></span>&#13;
<span>    return(0xFFFF &amp; p)               <span class="sc-comment"># Ensure output is 16 bits wide</span></span>&#13;
<span>def listingP():                      <span class="sc-comment"># Function to perform listing and formatting of source code</span></span>&#13;
<span>    global listing                   <span class="sc-comment"># Listing contains the formatted source code</span></span>&#13;
<span>    listing = [0]*128                <span class="sc-comment"># Create formatted listing file for display</span></span>&#13;
<span>    if debugLevel &gt; 1: print('Source assembly code listing ')</span>&#13;
<span>    for i in range (0,len(sFile)):        <span class="sc-comment"># Step through the program</span></span>&#13;
<span>        if sFile[i][0] in codes:          <span class="sc-comment"># Is first token in opcodes (no label)?</span></span>&#13;
<span>            i2 =  (' ').join(sFile[i])    <span class="sc-comment"># Convert tokens into string for printing</span></span>&#13;
<span>            i1 = ''                       <span class="sc-comment"># Dummy string i1 represents missing label</span></span>&#13;
<span>        else:</span>&#13;
<span>            i2 = (' ').join(sFile[i][1:]) <span class="sc-comment"># If first token not opcode, it's a label</span></span>&#13;
<span>            i1 = sFile[i][0]              <span class="sc-comment"># i1 is the label (first token)</span></span>&#13;
<span>        listing[i] = '{:&lt;3}'.format(i) + '{:&lt;7}'.format(i1) + \</span>&#13;
<span>                     '{:&lt;10}'.format(i2)  <span class="sc-comment"># Create listing table entry</span></span>&#13;
<span>        if debugLevel  &gt; 1:               <span class="sc-comment"># If debug  = 1, don't print source program</span></span>&#13;
<span>            print('{:&lt;3}'.format(i),'{:&lt;7}'.format(i1),'{:&lt;10}'.format(i2)) \</span>&#13;
<span>                                          <span class="sc-comment"># print: pc, label, opcode</span></span>&#13;
<span>    return()</span></pre>&#13;
			<p lang="en-GB">This is the function, <strong class="source-inline">getLit</strong>, that <a id="_idIndexMarker407"/><a id="_idIndexMarker408"/>processes a literal. It can handle literals in a range of possible formats, including decimal, binary, hexadecimal, and <span class="No-Break">symbolic form:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def getLit(litV):                                  <span class="sc-comment"># Extract a literal</span></span>&#13;
<span>    if  litV[0]    == '#': litV = litV[1:]         <span class="sc-comment"># Some systems prefix literal with '#</span></span>&#13;
<span>    if  litV in symbolTab:                         <span class="sc-comment"># Look in sym tab and get value if there</span></span>&#13;
<span>        literal = symbolTab[litV]                  <span class="sc-comment"># Read the symbol value as a string</span></span>&#13;
<span>        literal = int(literal)                     <span class="sc-comment"># Convert string into integer</span></span>&#13;
<span>    elif  litV[0]   == '%': literal = int(litV[1:],2)</span>&#13;
<span>                                                   <span class="sc-comment"># If first char is %, convert to integer</span></span>&#13;
<span>    elif  litV[0:2] == '0B':literal = int(litV[2:],2)</span>&#13;
<span>                                                   <span class="sc-comment"># If prefix 0B, convert binary to integer</span></span>&#13;
<span>    elif  litV[0:2] == '0X':literal = int(litV[2:],16)</span>&#13;
<span>                                                   <span class="sc-comment"># If 0x, convert hex string to integer</span></span>&#13;
<span>    elif  litV[0:1] == '$': literal = int(litV[1:],16)</span>&#13;
<span>                                                   <span class="sc-comment"># If $, convert hex string to integer</span></span>&#13;
<span>    elif  litV[0]   == '-': literal = (-int(litV[1:]))&amp;0xFFFF </span>&#13;
<span>                                                   <span class="sc-comment"># Convert 2's complement to int</span></span>&#13;
<span>    elif  litV.isnumeric():  literal = int(litV)</span>&#13;
<span>                                                   <span class="sc-comment"># If decimal string, convert to integer</span></span>&#13;
<span>    else:                    literal = 0           <span class="sc-comment"># Default value 0 (default value)</span></span></pre>&#13;
			<pre class="source-code">    return(literal)</pre>&#13;
			<p lang="en-GB"><strong class="source-inline">Print</strong> statements can be a little complicated. Consequently, we have created a <strong class="source-inline">print</strong> function that is used to display register and memory contents. We discuss print formatting elsewhere in this book. We generate the data as strings to be printed, <strong class="source-inline">m</strong>, <strong class="source-inline">m1</strong>, and <strong class="source-inline">m2</strong>, and then <a id="_idIndexMarker409"/><a id="_idIndexMarker410"/>print them using the <span class="No-Break">appropriate formatting:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def printStatus():                             <span class="sc-comment"># Display machine status (registers, memory)</span></span>&#13;
<span>    text = '{:&lt;27}'.format(listing[pcOld])     <span class="sc-comment"># Format instruction for listing</span></span>&#13;
<span>    m = mem[0:8]                               <span class="sc-comment"># Get the first 8 memory locations</span></span>&#13;
<span>    m1 = ' '.join('%04x' % b for b in m)       <span class="sc-comment"># Format memory location's hex</span></span>&#13;
<span>    m2 = ' '.join('%04x' % b for b in r)       <span class="sc-comment"># Format register's hex</span></span>&#13;
<span>    print(text, 'PC =', '{:&gt;2}'.format(pcOld) , 'z =',z,'n =',n,'c =',c, m1,\</span>&#13;
<span>    'Registers ', m2)</span>&#13;
<span>    if debugLevel == 5:</span>&#13;
<span>        print('Stack =', ' '.join('%04x' % b for b in stack), \</span>&#13;
<span>        'Stack pointer =', sp)</span>&#13;
<span>    return()</span>&#13;
<span>print('TC1 CPU simulator 11 September 2022 ')  <span class="sc-comment"># Print the opening banner</span></span>&#13;
<span>debugLevel = input('Input debug level 1 - 5: ') <span class="sc-comment"># Ask for debugging level</span></span>&#13;
<span>if debugLevel.isnumeric():                     <span class="sc-comment"># If debug level is an integer, get it</span></span>&#13;
<span>    debugLevel = int(debugLevel)               <span class="sc-comment"># Convert text to integer</span></span>&#13;
<span>else: debugLevel = 1                           <span class="sc-comment"># Else, set default value to level 1</span></span>&#13;
<span>if debugLevel not in range (1,6): debugLevel = 1 <span class="sc-comment"># Ensure range 1 to 5</span></span>&#13;
<span>print()                                        <span class="sc-comment"># New line</span></span></pre>&#13;
			<p lang="en-GB">The preceding block of code provides a debug functionality and is intended to demonstrate the concept of debugging and provide a facility to check the assembly process by displaying intermediate information during the assembly phase. A variable, <strong class="source-inline">debugLevel</strong>, is read from the keyboard at the start of the program. This determines the level of the debugging facility from 1 (none) to 5 (maximum). Debugging information can include the source code, decoded operations, and <span class="No-Break">other parameters:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>global c,n,z                                   <span class="sc-comment"># Processor flags (global variables)</span></span>&#13;
<span>symbolTab = {'START':0}             <span class="sc-comment"># Create symbol table for labels + equates with dummy entry</span></span>&#13;
<span>c,n,z = 0,0,0                                  <span class="sc-comment"># Initialize flags: carry, negative, zero</span></span>&#13;
<span>sFile = ['']* 128                              <span class="sc-comment"># sFile holds the source text</span></span>&#13;
<span>memP  = [0] * 128                              <span class="sc-comment"># Create program memory of 128 locations</span></span>&#13;
<span>mem   = [0] * 128                              <span class="sc-comment"># Create data memory of 128 locations</span></span>&#13;
<span>stack = [0] * 16                               <span class="sc-comment"># Create a stack for return addresses</span></span>&#13;
<span><span class="sc-comment"># codes is a dictionary of instructions {'mnemonic':(x.y)} where x is the instruction operand format, and y the opcode</span></span>&#13;
<span>codes = {                                                            \</span>&#13;
<span>        'STOP':(0,0),  'NOP' :(0,1),  'GET' :(8,2),  'RND' : (9,3),  \</span>&#13;
<span>        'SWAP':(8,4),  'SEC' :(0,5),  'PRT' :(8,8),  'END!':(0,31),  \</span>&#13;
<span>        'MOVE':(12,32),'LDRM':(9,33), 'LDRL':(9,34), 'LDRI':(13,35), \</span>&#13;
<span>        'STRM':(9,36), 'STRI':(13,37),'ADD' :(14,64),'ADDL':(13,65), \</span>&#13;
<span>        'SUB' :(14,66),'SUBL':(13,67),'MUL' :(14,68),'MULL':(13,69), \</span>&#13;
<span>        'DIV' :(14,70),'DIVL':(13,71),'MOD' :(14,72),'MODL':(13,73), \</span>&#13;
<span>        'AND' :(14,74),'ANDL':(13,75),'OR'  :(14,76),'ORL' :(13,77), \</span>&#13;
<span>        'EOR' :(14,78),'EORL':(13,79),'NOT' :(8,80), 'INC' :(8,82),  \</span>&#13;
<span>        'DEC' :(8,83), 'CMP' :(12,84),'CMPL':(9,85), 'LSL' :(12,88), \</span>&#13;
<span>        'LSLL':(9,89), 'LSR' :(12,90),'LSRL':(9,91), 'ROL' :(12,92), \</span>&#13;
<span>        'ROLL':(9,93), 'ROR' :(12,94),'RORL':(9,95), 'ADC':(14,102), \</span>&#13;
<span>        'SBC':(14,103),'BRA' :(1,96), 'BEQ' :(1,97), 'BNE' :(1,98),  \</span>&#13;
<span>        'BMI' :(1,99), 'BSR' :(1,100),'RTS' :(0,101),'DBNE':(9,102), \</span>&#13;
<span>        'DBEQ':(9,103),'PUSH':(8,104),'PULL':(8,105) }</span>&#13;
<span>branchGroup = ['BRA', 'BEQ', 'BNE', 'BSR', 'RTS'] <span class="sc-comment"># Operations responsible for flow control</span></span></pre>&#13;
			<p lang="en-GB">The following section is responsible for reading the source file to be assembled and executed. This source code should be in the form of a <strong class="source-inline">.txt</strong> file. Note that <a id="_idIndexMarker411"/><a id="_idIndexMarker412"/>this code uses Python’s <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> mechanism, which is able to perform an action (in this case, try and load a file from disk) and, if the action fails, perform a new action instead. Here, we use it to test for a default filename and then get one from the terminal if that file does <span class="No-Break">not exist:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># Read the input source code text file and format it. This uses a default file and a user file if default is absent</span></span>&#13;
<span>prgN = 'E://ArchitectureWithPython//C_2_test.txt' <span class="sc-comment"># prgN = program name: default test file</span></span>&#13;
<span>try:                                              <span class="sc-comment"># Check whether this file exists</span></span>&#13;
<span>    with open(prgN,'r') as prgN:                  <span class="sc-comment"># If it's there, open it and read it</span></span>&#13;
<span>        prgN = prgN.readlines()</span>&#13;
<span>except:                                           <span class="sc-comment"># Call exception program if not there</span></span>&#13;
<span>    prgN = input('Enter source file name: ')    <span class="sc-comment"># Request a filename (no extension needed)</span></span>&#13;
<span>    prgN = 'E://ArchitectureWithPython//' + prgN + '.txt' <span class="sc-comment"># Build filename</span></span>&#13;
<span>    with open(prgN,'r') as prgN:                  <span class="sc-comment"># Open user file</span></span>&#13;
<span>        prgN = prgN.readlines()                   <span class="sc-comment"># Read it</span></span>&#13;
<span>for i in range (0,len(prgN)):                     <span class="sc-comment"># Scan source prgN and copy it to sFile</span></span>&#13;
<span>    sFile[i] = prgN[i]                            <span class="sc-comment"># Copy prgN line to sFile line</span></span>&#13;
<span>    if 'END!' in prgN[i]: break                   <span class="sc-comment"># If END! found, then stop copying</span></span>&#13;
<span>             <span class="sc-comment"># Format source code</span></span>&#13;
<span>sFile = [i.split('@')[0] for i in sFile]          <span class="sc-comment"># But first, remove comments     ###</span></span>&#13;
<span>for i in range(0,len(sFile)):                     <span class="sc-comment"># Repeat: scan input file line by line</span></span>&#13;
<span>    sFile[i] = sFile[i].strip()                   <span class="sc-comment"># Remove leading/trailing spaces and eol</span></span>&#13;
<span>    sFile[i] = sFile[i].replace(',',' ')          <span class="sc-comment"># Allow use of commas or spaces</span></span>&#13;
<span>    sFile[i] = sFile[i].replace('[','')           <span class="sc-comment"># Remove left bracket</span></span>&#13;
<span>    sFile[i] = sFile[i].replace(']','')       <span class="sc-comment"># Remove right bracket and convert [R4] to R4</span></span>&#13;
<span>    while '  ' in sFile[i]:                       <span class="sc-comment"># Remove multiple spaces</span></span>&#13;
<span>        sFile[i] = sFile[i].replace('  ', ' ')</span>&#13;
<span>sFile = [i.upper() for i in sFile]                <span class="sc-comment"># Convert to uppercase</span></span></pre>&#13;
			<pre class="source-code">sFile = [i.split(' ') for i in sFile if i != '']  <span class="sc-comment"># Split the tokens into list items</span></pre>&#13;
			<p lang="en-GB">This short section deals with the equate assembler directive and binds values to symbolic names using the <strong class="source-inline">EQU</strong> directive. These bindings are placed in the <strong class="source-inline">symbol table</strong> dictionary and the equates are removed from the <span class="No-Break">source code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                    <span class="sc-comment"># Remove assembler directives from source code</span></span>&#13;
<span>for i in range (0,len(sFile)):      <span class="sc-comment"># Deal with equates of the form PQR EQU 25</span></span>&#13;
<span>    if len(sFile[i]) &gt; 2 and sFile[i][1] == 'EQU': <span class="sc-comment"># If line is &gt; 2 tokens and second is EQU</span></span>&#13;
<span>        symbolTab[sFile[i][0]] = sFile[i][2]       <span class="sc-comment"># Put third token EQU in symbol table</span></span>&#13;
<span>sFile = [i for i in sFile if i.count('EQU') == 0]  <span class="sc-comment"># Remove all lines with 'EQU'</span></span>&#13;
<span>                                    <span class="sc-comment"># Debug: 1 none, 2 source, 3 symbol tab, 4 Decode i, 5 stack</span></span>&#13;
<span>listingP()                          <span class="sc-comment"># List the source code if debug level is 1</span></span></pre>&#13;
			<p lang="en-GB">Here, we perform the instruction <a id="_idIndexMarker413"/><a id="_idIndexMarker414"/>decoding; that is, we analyze the text of each instruction to extract the opcode <span class="No-Break">and parameters:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                    <span class="sc-comment"># Look for labels and add to symbol table</span></span>&#13;
<span>for i in range(0,len(sFile)):       <span class="sc-comment"># Add branch addresses to symbol table</span></span>&#13;
<span>    if sFile[i][0] not in codes:    <span class="sc-comment"># If first token not opcode, then it is a label</span></span>&#13;
<span>        symbolTab.update({sFile[i][0]:str(i)})     <span class="sc-comment"># Add it to the symbol table</span></span>&#13;
<span>if debugLevel &gt; 2:                  <span class="sc-comment"># Display symbol table if debug level 2</span></span>&#13;
<span>    print('\nEquate and branch table\n')           <span class="sc-comment"># Display the symbol table</span></span>&#13;
<span>    for x,y in symbolTab.items(): print('{:&lt;8}'.format(x),y) \</span>&#13;
<span>                                             <span class="sc-comment"># Step through the symbol table dictionary</span></span>&#13;
<span>    print('\n')</span>&#13;
<span>            <span class="sc-comment"># Assemble source code in sFile</span></span>&#13;
<span>if debugLevel &gt; 3: print('Decoded instructions')   <span class="sc-comment"># If debug level 4/5, print decoded ops</span></span>&#13;
<span>for pcA in range(0,len(sFile)):              <span class="sc-comment"># ASSEMBLY: pcA = prog counter in assembly</span></span>&#13;
<span>    opCode, label, literal, predicate = [], [], 0, []   <span class="sc-comment"># Initialize variables</span></span>&#13;
<span>                                             <span class="sc-comment"># Instruction = label + opcode + predicate</span></span>&#13;
<span>    rD, rS1, rS2  = 0, 0, 0                  <span class="sc-comment"># Clear all register-select fields</span></span>&#13;
<span>    thisOp = sFile[pcA]                      <span class="sc-comment"># Get current instruction, thisOPp, in text form</span></span>&#13;
<span>                                             <span class="sc-comment"># Instruction: label + opcode or opcode</span></span>&#13;
<span>    if thisOp[0] in codes: opCode = thisOp[0]      <span class="sc-comment"># If token opcode, then get token</span></span>&#13;
<span>    else:                                    <span class="sc-comment"># Otherwise, opcode is second token</span></span>&#13;
<span>        opCode = thisOp[1]                   <span class="sc-comment"># Read the second token to get opcode</span></span>&#13;
<span>        label = sFile[i][0]                  <span class="sc-comment"># Read the first token to get the label</span></span>&#13;
<span>    if (thisOp[0] in codes) and (len(thisOp) &gt; 1): <span class="sc-comment"># If first token opcode, rest is predicate</span></span>&#13;
<span>        predicate = thisOp[1:]               <span class="sc-comment"># Now get the predicate</span></span>&#13;
<span>    else:                                    <span class="sc-comment"># Get predicate if the line has a label</span></span>&#13;
<span>        if len(thisOp) &gt; 2: predicate = thisOp[2:]</span>&#13;
<span>    form = codes.get(opCode)                 <span class="sc-comment"># Use opcode to read type (format)</span></span>&#13;
<span>                                             <span class="sc-comment"># Now check the bits of the format code</span></span>&#13;
<span>    if form[0] &amp; 0b1000 == 0b1000:           <span class="sc-comment"># Bit 4 selects destination register rD</span></span>&#13;
<span>        if predicate[0] in symbolTab:        <span class="sc-comment"># Check if first token in symbol table</span></span>&#13;
<span>            rD = int(symbolTab[predicate[0]][1:]) <span class="sc-comment"># If it is, then get its value</span></span>&#13;
<span>        else: rD = int(predicate[0][1:])     <span class="sc-comment"># If not label, get register from the predicate</span></span>&#13;
<span>    if form[0] &amp; 0b0100 == 0b0100:           <span class="sc-comment"># Bit 3 selects source register 1, rS1</span></span>&#13;
<span>        if predicate[1] in symbolTab:</span>&#13;
<span>            rS1 = int(symbolTab[predicate[1]][1:])</span>&#13;
<span>        else: rS1 = int(predicate[1][1:])</span>&#13;
<span>    if form[0] &amp; 0b0010 == 0b0010:           <span class="sc-comment"># Bit 2 of format selects register rS1</span></span>&#13;
<span>        if predicate[2] in symbolTab:</span>&#13;
<span>            rS2 = int(symbolTab[predicate[2]][1:])</span>&#13;
<span>        else: rS2 = int(predicate[2][1:])</span>&#13;
<span>    if form[0] &amp; 0b0001 == 0b0001:           <span class="sc-comment"># Bit 1 of format selects the literal field</span></span>&#13;
<span>        litV = predicate[-1]</span>&#13;
<span>        literal = getLit(litV)</span></pre>&#13;
			<p lang="en-GB">This section was added after the development of TC1. We introduce the concept of a debug level. That is, at the beginning of a simulation run, you can<a id="_idIndexMarker415"/><a id="_idIndexMarker416"/> set a parameter in the range of <strong class="source-inline">1</strong> to <strong class="source-inline">3</strong> that determines how much information is displayed during the assembly processing. This allows you to get more information about the instruction encoding when testing <span class="No-Break">the program:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if debugLevel &gt; 3:                       <span class="sc-comment"># If debug level &gt; 3, print decoded fields</span></span>&#13;
<span>        t0 = '%02d' % pcA                    <span class="sc-comment"># Format instruction counter</span></span>&#13;
<span>        t1 = '{:&lt;23}'.format(' '.join(thisOp)) <span class="sc-comment"># Format operation to 23 spaces</span></span>&#13;
<span>        t3 = '%04x' % literal                <span class="sc-comment"># Format literal to 4-character hex</span></span>&#13;
<span>        t4 = '{:04b}'.format(form[0])        <span class="sc-comment"># Format the 4-bit opcode format field</span></span>&#13;
<span>        print('pc =',t0,'Op =',t1,'literal',t3,'Dest reg =',rD,'rS1 =', \</span>&#13;
<span>              'rS1,'rS2 =',rS2,'format =',t4)  <span class="sc-comment"># Concatenate fields to create 32-bit opcode</span></span>&#13;
<span>    binCode = form[1]&lt;&lt;25|(rD)&lt;&lt;22|(rS1)&lt;&lt;19|(rS2)&lt;&lt;16|literal <span class="sc-comment"># Binary pattern</span></span>&#13;
<span>    memP[pcA] = binCode                      <span class="sc-comment"># Store instruction in program memory</span></span>&#13;
<span>                                             <span class="sc-comment"># End of the assembly portion of the program</span></span></pre>&#13;
			<p lang="en-GB">We are about to execute the instructions. Before we do that, it is necessary to initialize several variables concerning the current operation (<span class="No-Break">e.g., tracing):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                           <span class="sc-comment"># The code is executed here</span></span>&#13;
<span>r = [0] * 8                                <span class="sc-comment"># Define registers r[0] to r[7]</span></span>&#13;
<span>pc = 0                                     <span class="sc-comment"># Set program counter to 0</span></span>&#13;
<span>run = 1                                    <span class="sc-comment"># run = 1 during execution</span></span>&#13;
<span>sp = 16                                    <span class="sc-comment"># Initialize the stack pointer (BSR/RTS)</span></span>&#13;
<span>goCount = 0                                <span class="sc-comment"># goCount executes n operations with no display</span></span>&#13;
<span>traceMode    = 0                           <span class="sc-comment"># Set to 1 to execute n instructions without display</span></span>&#13;
<span>skipToBranch = 0                           <span class="sc-comment"># Used when turning off tracing until a branch</span></span></pre>&#13;
			<pre class="source-code">silent = 0                                 <span class="sc-comment"># silent = 1 to turn off single stepping</span></pre>&#13;
			<p lang="en-GB">This is the main loop where we decode instructions to extract the parameters (register numbers and <span class="No-Break">the literal):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                           <span class="sc-comment"># Executes instructions when run is 1</span></span>&#13;
<span>while run == 1:                            <span class="sc-comment"># Step through instructions: first, decode them!</span></span>&#13;
<span>    binCode = memP[pc]                     <span class="sc-comment"># Read binary code of instruction</span></span>&#13;
<span>    pcOld = pc                             <span class="sc-comment"># pc in pcOld (for display purposes)</span></span>&#13;
<span>    pc = pc + 1                            <span class="sc-comment"># Increment the pc</span></span>&#13;
<span>    binOp = binCode &gt;&gt; 25                  <span class="sc-comment"># Extract the 7-bit opcode as binOp</span></span>&#13;
<span>    rD    = (binCode &gt;&gt; 22) &amp; 7            <span class="sc-comment"># Extract the destination register, rD</span></span>&#13;
<span>    rS1   = (binCode &gt;&gt; 19) &amp; 7            <span class="sc-comment"># Extract source register 1, rS1</span></span>&#13;
<span>    rS2   = (binCode &gt;&gt; 16) &amp; 7            <span class="sc-comment"># Extract source register 2, rS2</span></span>&#13;
<span>    lit   = binCode &amp; 0xFFFF               <span class="sc-comment"># Extract the 16-bit literal</span></span>&#13;
<span>    op0 = r[rD]                            <span class="sc-comment"># Get contents of destination register</span></span>&#13;
<span>    op1 = r[rS1]                           <span class="sc-comment"># Get contents of source register 1</span></span>&#13;
<span>    op2 = r[rS2]                           <span class="sc-comment"># Get contents of source register 2</span></span></pre>&#13;
			<p lang="en-GB">In the next section, we depart from the original version of TC1. The first version of TC1 decoded the opcode as a binary string and then looked it up. However, as we have the source file, it is easier to go directly from the text of the mnemonic and execute it. This <a id="_idIndexMarker417"/><a id="_idIndexMarker418"/>makes the code so much easier <span class="No-Break">to read:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># Instead of using the binary opcode to determine the instruction, I use the text opcode</span></span>&#13;
<span><span class="sc-comment"># It makes the code more readable if I use 'ADD' rather than its opcode</span></span>&#13;
<span>    mnemonic=next(key for key,value in codes.items() if value[1]==binOp</span>&#13;
<span>                                           <span class="sc-comment"># Get mnemonic from dictionary</span></span>&#13;
<span><span class="sc-comment">### INTERPRET INSTRUCTIONS</span>                    <span class="sc-comment"># Examine the opcode and execute it</span></span>&#13;
<span>    if   mnemonic == 'STOP': run = 0       <span class="sc-comment"># STOP ends the simulation</span></span>&#13;
<span>    elif mnemonic == 'END!': run = 0       <span class="sc-comment"># END! terminates reading source code and stops</span></span>&#13;
<span>    elif mnemonic == 'NOP':  pass          <span class="sc-comment"># NOP is a dummy instruction that does nothing</span></span>&#13;
<span>    elif mnemonic == 'GET':                <span class="sc-comment"># Reads integer from the keyboard</span></span>&#13;
<span>        printStatus()</span>&#13;
<span>        kbd = (input('Type integer '))     <span class="sc-comment"># Get input</span></span>&#13;
<span>        kbd = getLit(kbd)                  <span class="sc-comment"># Convert string to integer</span></span>&#13;
<span>        r[rD] = kbd                        <span class="sc-comment"># Store in register</span></span>&#13;
<span>        continue</span>&#13;
<span>    elif mnemonic == 'RND':  r[rD] = random.randint(0,lit)</span>&#13;
<span>                                           <span class="sc-comment"># Generate random number</span></span>&#13;
<span>    elif mnemonic == 'SWAP': r[rD] = shift(0,1,r[rD],8)</span>&#13;
<span>                                           <span class="sc-comment"># Swap bytes in a 16-bit word</span></span>&#13;
<span>    elif mnemonic == 'SEC':  c = 1         <span class="sc-comment"># Set carry flag</span></span>&#13;
<span>    elif mnemonic == 'LDRL': r[rD] = lit   <span class="sc-comment"># LDRL R0,20 loads R0 with literal 20</span></span>&#13;
<span>    elif mnemonic == 'LDRM': r[rD] = mem[lit]</span>&#13;
<span>                                           <span class="sc-comment"># Load register with memory location (LDRM)</span></span>&#13;
<span>    elif mnemonic == 'LDRI': r[rD] = mem[op1 + lit]</span>&#13;
<span>                                                   <span class="sc-comment"># LDRI r1,[r2,4] memory location [r2]+4</span></span>&#13;
<span>    elif mnemonic == 'STRM': mem[lit] = r[rD]      <span class="sc-comment"># STRM stores register in memory</span></span>&#13;
<span>    elif mnemonic == 'STRI': mem[op1 + lit] = r[rD] <span class="sc-comment"># STRI stores rD at location [rS1]+L</span></span>&#13;
<span>    elif mnemonic == 'MOVE': r[rD] = op1           <span class="sc-comment"># MOVE copies register rS1 to rD</span></span>&#13;
<span>    elif mnemonic == 'ADD':  r[rD] = alu('ADD',op1, op2)</span>&#13;
<span>                                                   <span class="sc-comment"># Adds [r2] to [r3] and puts result in r1</span></span>&#13;
<span>    elif mnemonic == 'ADDL': r[rD] = alu('ADD',op1,lit) <span class="sc-comment"># Adds 12 to [r2] and puts result in r1</span></span>&#13;
<span>    elif mnemonic == 'SUB':  r[rD] = alu('SUB',op1,op2) <span class="sc-comment">#</span></span>&#13;
<span>    elif mnemonic == 'SUBL': r[rD] = alu('SUB',op1,lit)</span>&#13;
<span>    elif mnemonic == 'MUL':  r[rD] = alu('MUL',op1,op2)</span>&#13;
<span>    elif mnemonic == 'MULL': r[rD] = alu('MUL',op1,lit)</span>&#13;
<span>    elif mnemonic == 'DIV':  r[rD] = alu('DIV',op1,op2) <span class="sc-comment"># Logical OR</span></span>&#13;
<span>    elif mnemonic == 'DIVL': r[rD] = alu('DIV',op1,lit)</span>&#13;
<span>    elif mnemonic == 'MOD':  r[rD] = alu('MOD',op1,op2) <span class="sc-comment"># Modulus</span></span>&#13;
<span>    elif mnemonic == 'MODL': r[rD] = alu('MOD',op1,lit)</span>&#13;
<span>    elif mnemonic == 'AND':  r[rD] = alu('AND',op1,op2) <span class="sc-comment"># Logical AND</span></span>&#13;
<span>    elif mnemonic == 'ANDL': r[rD] = alu('AND',op1,lit)</span>&#13;
<span>    elif mnemonic == 'OR':   r[rD] = alu('OR', op1,op2) <span class="sc-comment"># Logical OR</span></span>&#13;
<span>    elif mnemonic == 'ORL':  r[rD] = alu('OR', op1,lit)</span>&#13;
<span>    elif mnemonic == 'EOR':  r[rD] = alu('EOR',op1,op2) <span class="sc-comment"># Exclusive OR</span></span>&#13;
<span>    elif mnemonic == 'EORL': r[rD] = alu('EOR',op1,lit)</span>&#13;
<span>    elif mnemonic == 'NOT':  r[rD] = alu('NOT',op0,1)   <span class="sc-comment"># NOT r1 uses only one operand</span></span>&#13;
<span>    elif mnemonic == 'INC':  r[rD] = alu('ADD',op0,1)</span>&#13;
<span>    elif mnemonic == 'DEC':  r[rD] = alu('SUB',op0,1)</span>&#13;
<span>    elif mnemonic == 'CMP':  rr    = alu('SUB',op0,op1) <span class="sc-comment"># rr is a dummy variable</span></span>&#13;
<span>    elif mnemonic == 'CMPL': rr    = alu('SUB',op0,lit)</span>&#13;
<span>    elif mnemonic == 'ADC':  r[rD] = alu('ADC',op1,op2)</span>&#13;
<span>    elif mnemonic == 'SBC':  r[rD] = alu('SBC',op1,op2)</span>&#13;
<span>    elif mnemonic == 'LSL':  r[rD] = shift(0,0,op0,op1)</span>&#13;
<span>    elif mnemonic == 'LSLL': r[rD] = shift(0,0,op0,lit)</span>&#13;
<span>    elif mnemonic == 'LSR':  r[rD] = shift(1,0,op0,op1)</span>&#13;
<span>    elif mnemonic == 'LSRL': r[rD] = shift(1,0,op0,lit)</span>&#13;
<span>    elif mnemonic == 'ROL':  r[rD] = shift(1,1,op0,op2)</span>&#13;
<span>    elif mnemonic == 'ROLL': r[rD] = shift(1,1,op0,lit)</span>&#13;
<span>    elif mnemonic == 'ROR':  r[rD] = shift(0,1,op0,op2)</span>&#13;
<span>    elif mnemonic == 'RORL': r[rD] = shift(0,1,op0,lit)</span>&#13;
<span>    elif mnemonic == 'PRT':  print('Reg',rD,'=', '%04x' % r[rD])</span>&#13;
<span>    elif mnemonic == 'BRA':             pc = lit</span>&#13;
<span>    elif mnemonic == 'BEQ' and  z == 1: pc = lit</span>&#13;
<span>    elif mnemonic == 'BNE' and  z == 0: pc = lit</span>&#13;
<span>    elif mnemonic == 'BMI' and  n == 1: pc = lit</span>&#13;
<span>    elif mnemonic == 'DBEQ':                     <span class="sc-comment"># Decrement register and branch on zero</span></span>&#13;
<span>        r[rD] = r[rD] - 1</span>&#13;
<span>        if r[rD] != 0: pc = lit</span>&#13;
<span>    elif mnemonic == 'DBNE':            <span class="sc-comment"># Decrement register and branch on not zero</span></span>&#13;
<span>        r[rD] = alu('SUB',op0,1)        <span class="sc-comment"># Note the use of the alu function</span></span>&#13;
<span>        if z == 0: pc = lit</span>&#13;
<span>    elif mnemonic == 'BSR':             <span class="sc-comment"># Stack-based operations. Branch to subroutine</span></span>&#13;
<span>        sp = sp - 1                     <span class="sc-comment"># Pre-decrement stack pointer</span></span>&#13;
<span>        stack[sp] = pc                  <span class="sc-comment"># Push the pc (return address)</span></span>&#13;
<span>        pc = lit                        <span class="sc-comment"># Jump to target address</span></span>&#13;
<span>    elif mnemonic == 'RTS':             <span class="sc-comment"># Return from subroutine</span></span>&#13;
<span>        pc = stack[sp]                  <span class="sc-comment"># Pull pc address of the stack</span></span>&#13;
<span>        sp = sp + 1                     <span class="sc-comment"># Increment stack pointer</span></span>&#13;
<span>    elif mnemonic == 'PUSH':            <span class="sc-comment"># Push register to stack</span></span>&#13;
<span>        sp = sp - 1                     <span class="sc-comment"># Move stack pointer up to make space</span></span>&#13;
<span>        stack[sp] = op0                 <span class="sc-comment"># Push register in op on the stack</span></span>&#13;
<span>    elif mnemonic == 'PULL':            <span class="sc-comment"># Pull register off the stack</span></span>&#13;
<span>        r[rD] = stack[sp]               <span class="sc-comment"># Transfer stack value to register</span></span>&#13;
<span>        sp = sp + 1                     <span class="sc-comment"># Move stack down</span></span></pre>&#13;
			<p lang="en-GB">This section performs a function called tracing<a id="_idIndexMarker419"/><a id="_idIndexMarker420"/> and allows us to list the contents of the register or turn off the listing as we execute <span class="No-Break">the code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                        <span class="sc-comment"># Instruction interpretation complete. Deal with display</span></span>&#13;
<span>    if silent == 0:                     <span class="sc-comment"># Read keyboard ONLY if not in silent mode</span></span>&#13;
<span>       x = input('&gt;&gt;&gt;')                 <span class="sc-comment"># Get keyboard input to continue</span></span>&#13;
<span>       if x == 'b': skipToBranch = 1    <span class="sc-comment"># Set flag to execute to branch with no display</span></span>&#13;
<span>       if x.isnumeric():                <span class="sc-comment"># Is this a trace mode with a number of steps to skip?</span></span>&#13;
<span>           traceMode = 1                <span class="sc-comment"># If so, set traceMode</span></span>&#13;
<span>           goCount   = getLit(x) + 1    <span class="sc-comment"># Record the number of lines to skip printing</span></span>&#13;
<span>    if skipToBranch == 1:               <span class="sc-comment"># Are we in skip-to-branch mode?</span></span>&#13;
<span>        silent = 1                      <span class="sc-comment"># If so, turn off printing status</span></span>&#13;
<span>        if mnemonic in branchGroup:     <span class="sc-comment"># Have we reached a branch?</span></span>&#13;
<span>            silent = 0                  <span class="sc-comment"># If branch, turn off silent mode and allow tracing</span></span>&#13;
<span>            skipToBranch = 0            <span class="sc-comment"># Turn off skip-to-branch mode</span></span>&#13;
<span>    if traceMode == 1:                  <span class="sc-comment"># If in silent mode (no display of data)</span></span>&#13;
<span>        silent = 1                      <span class="sc-comment"># Set silent flag</span></span>&#13;
<span>        goCount = goCount – 1           <span class="sc-comment"># Decrement silent mode count</span></span>&#13;
<span>        if goCount == 0:                <span class="sc-comment"># If we've reached zero, turn display on</span></span>&#13;
<span>            traceMode = 0               <span class="sc-comment"># Leave trace mode</span></span>&#13;
<span>            silent = 0                  <span class="sc-comment"># Set silent flag back to zero (off)</span></span></pre>&#13;
			<pre class="source-code">    if silent == 0: printStatus()</pre>&#13;
			<p lang="en-GB">Now that we’ve explained the TC1<a id="_idIndexMarker421"/><a id="_idIndexMarker422"/> simulator, we’ll demonstrate <span class="No-Break">its use.</span></p>&#13;
			<h1 id="_idParaDest-106" lang="en-GB"><a id="_idTextAnchor106"/>Example of a TC1 assembly language program</h1>&#13;
			<p lang="en-GB">Here, we <a id="_idIndexMarker423"/><a id="_idIndexMarker424"/>demonstrate a TC1 program in assembly language. This offers a means of testing the simulator and showing how it works. We would like to test a range of facilities, so we should include looping, conditional testing, and pointer-based memory access. We will write a program to do <span class="No-Break">the following:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB">Fill a region of memory from locations 0 to 4 with <span class="No-Break">random numbers.</span></li>&#13;
				<li lang="en-GB">Reverse the order of <span class="No-Break">the numbers.</span></li>&#13;
			</ol>&#13;
			<p lang="en-GB">Since this problem uses memory and sequential addresses, it involves register indirect addressing, that is, <strong class="source-inline">LDRI</strong> and <strong class="source-inline">STRI</strong> instructions. Creating the random numbers and storing them sequentially in memory can be done by doing <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Set a pointer to the first memory location (i.e.,0)</span>&#13;
<span>Set a counter to 5 (we are going to access five locations 0 to 4)</span>&#13;
<span>Repeat</span>&#13;
<span>  Generate a random number</span>&#13;
<span>  Store this number at the pointer address</span>&#13;
<span>  Point to next number (i.e., add 1 to the pointer)</span>&#13;
<span>  Decrement the counter (i.e., counter 5,4,3,2,1,0)</span>&#13;
<span>  Until counter = 0</span></pre>&#13;
			<p lang="en-GB">In TC1 code, we can translate this <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        LDRL <strong class="bold">r0</strong>,0             <span class="sc-comment">@ Use r0 as a memory pointer and set it to 0</span></span>&#13;
<span>        LDRL <strong class="bold">r1</strong>,5             <span class="sc-comment">@ Use r1 as the loop counter</span></span>&#13;
<span>  Loop1 RND  <strong class="bold">r2</strong>               <span class="sc-comment">@ Loop: Generate a random number in r2</span></span>&#13;
<span>        STRI r2,<strong class="bold">[r0]</strong>,<strong class="bold">0</strong>        <span class="sc-comment">@ Store the random number in memory using pointer r0</span></span>&#13;
<span>        INC  <strong class="bold">r0</strong>               <span class="sc-comment">@ Point to the next location (add 1 to the pointer)</span></span>&#13;
<span>        DEC  <strong class="bold">r1</strong>               <span class="sc-comment">@ Decrement the loop counter (subtract 1 from the counter)</span></span>&#13;
<span>        BNE  Loop1            <span class="sc-comment">@ Repeat until 0 (branch back to Loop1 if the last result was not 0)</span></span></pre>&#13;
			<p lang="en-GB">We’ve filled a region of memory with random values. We now need to reverse their order. There are many ways of reversing the order of numbers. One is to move the numbers from the source to a temporary location in memory and then write them back in reverse order. Of course, this takes up extra memory for the temporary copy. Consider another solution that does not require a buffer. We will write down the source addresses above the <span class="No-Break">destination addresses:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">Original (source)        0   1   2   3   4</strong></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><strong class="source-inline">Swapped (destination)    4   3   2   1   0</strong></p>&#13;
			<p lang="en-GB">As you can see, location <strong class="source-inline">0</strong> is swapped with location <strong class="source-inline">4</strong>, then location <strong class="source-inline">1</strong> with location <strong class="source-inline">3</strong>; then, at location <strong class="source-inline">2</strong>, we have reached the middle point and the reversal is complete. To perform this action, we need two pointers, one for each end of the string. We select the two characters at the ends of the string and swap them. Then, we move the pointers inward and do a second swap. The task is<a id="_idIndexMarker425"/><a id="_idIndexMarker426"/> complete when the pointers meet in the middle. Note that this assumes an odd number of items <span class="No-Break">to reverse:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Set upper pointer to top</span>&#13;
<span>Set lower pointer to bottom</span>&#13;
<span>Repeat</span>&#13;
<span>   Get value at upper pointer</span>&#13;
<span>   Get value at lower pointer</span>&#13;
<span>   Swap values and store</span>&#13;
<span>Until upper pointer and lower pointer are equal</span></pre>&#13;
			<p lang="en-GB">In TC1 assembly language, this looks <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      LDRL <strong class="bold">r0</strong>,0                <span class="sc-comment">@ Lower pointer points at first entry in table</span></span>&#13;
<span>      LDRL <strong class="bold">r1</strong>,4                <span class="sc-comment">@ Upper pointer points at last entry in table</span></span>&#13;
<span><strong class="bold">Loop2 LDRI r2,[r0],0</strong>           <span class="sc-comment">@ REPEAT: Get lower value pointed at by r0</span></span>&#13;
<span>      <strong class="bold">LDRI r3,[r1],0</strong>           <span class="sc-comment">@ Get upper value pointed at by r1</span></span>&#13;
<span>      MOVE r2,r4               <span class="sc-comment">@ Save lower value in r4 temporarily</span></span>&#13;
<span>      <strong class="bold">STRI r3,[r0],0</strong>           <span class="sc-comment">@ Store upper value in lower entry position</span></span>&#13;
<span>      <strong class="bold">STRI r4,[r1],0</strong>           <span class="sc-comment">@ Store saved lower value in upper entry position</span></span>&#13;
<span>      INC  <strong class="bold">r0</strong>                  <span class="sc-comment">@ Increase lower pointer</span></span>&#13;
<span>      DEC  <strong class="bold">r1</strong>                  <span class="sc-comment">@ Decrease upper pointer</span></span>&#13;
<span>      CMP  r0,r1               <span class="sc-comment">@ Compare pointers</span></span>&#13;
<span>      BNE  Loop2               <span class="sc-comment">@ UNTIL all characters moved</span></span></pre>&#13;
			<p lang="en-GB">The following shows the output when this program is executed, instruction by instruction. In order to simplify the reading of this data, we’ve put changes in register and memory values in bold. The branch operations are shaded. Comparison instructions are <span class="No-Break">in italics.</span></p>&#13;
			<p lang="en-GB">The first block is the source code printed by TC1 before the start of the <span class="No-Break">instruction execution:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>TC1 CPU simulator 11 September 2022</span>&#13;
<span>Input debug level 1 - 5: 4</span>&#13;
<span>Source assembly code listing</span>&#13;
<span>0           LDRL R0 0</span>&#13;
<span>1           LDRL R1 5</span>&#13;
<span>2   LOOP1   RND  R2</span>&#13;
<span>3           STRI R2 R0 0</span>&#13;
<span>4           INC  R0</span>&#13;
<span>5           DEC  R1</span>&#13;
<span>6           BNE  LOOP1</span>&#13;
<span>7           NOP</span>&#13;
<span>8           LDRL R0 0</span>&#13;
<span>9           LDRL R1 4</span>&#13;
<span>10  LOOP2   LDRI R2 R0 0</span>&#13;
<span>11          LDRI R3 R1 0</span>&#13;
<span>12          MOVE R4 R2</span>&#13;
<span>13          STRI R3 R0 0</span>&#13;
<span>14          STRI R4 R1 0</span>&#13;
<span>15          INC  R0</span>&#13;
<span>16          DEC  R1</span>&#13;
<span>17          CMP  R0 R1</span>&#13;
<span>18          BNE  LOOP2</span>&#13;
<span>19          NOP</span>&#13;
<span>20          STOP</span>&#13;
<span>21          END!</span>&#13;
<span>Equate and branch table</span>&#13;
<span>START    0</span>&#13;
<span>LOOP1    2</span>&#13;
<span>LOOP2    10</span></pre>&#13;
			<p lang="en-GB">The second code block shows the <a id="_idIndexMarker427"/><a id="_idIndexMarker428"/>output of the assembler as instructions are decoded. You can see the various registers, the literal, and the <span class="No-Break">format field:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Decoded instructions</span>&#13;
<span>pc=00 Op =       LDRL R0 0        literal 0000 RD=0 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=01 Op =       LDRL R1 5        literal 0005 RD=1 rS1=0 rS2=0 format=1001</span>&#13;
<span><strong class="bold">pc</strong>=02 Op=  LOOP1 RND R2 0XFFFF    literal ffff RD=2 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=03 Op =       STRI R2 R0 0     literal 0000 RD=2 rS1=0 rS2=0 format=1101</span>&#13;
<span>pc=04 Op =       INC  R0          literal 0000 RD=0 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=05 Op =       DEC  R1          literal 0000 RD=1 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=06 Op =       BNE  LOOP1       literal 0002 RD=0 rS1=0 rS2=0 format=0001</span>&#13;
<span>pc=07 Op =       NOP              literal 0000 RD=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=08 Op =       LDRL R0 0        literal 0000 RD=0 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=09 Op =       LDRL R1 4        literal 0004 RD=1 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=10 Op=  LOOP2 LDRI R2 R0 0     literal 0000 RD=2 rS1=0 rS2=0 format=1101</span>&#13;
<span>pc=11 Op =       LDRI R3 R1 0     literal 0000 RD=3 rS1=1 rS2=0 format=1101</span>&#13;
<span>pc=12 Op =       MOVE R4 R2       literal 0000 RD=4 rS1=2 rS2=0 format=1100</span>&#13;
<span>pc=13 Op =       STRI R3 R0 0     literal 0000 RD=3 rS1=0 rS2=0 format=1101</span>&#13;
<span>pc=14 Op =       STRI R4 R1 0     literal 0000 RD=4 rS1=1 rS2=0 format=1101</span>&#13;
<span>pc=15 Op =       INC  R0          literal 0000 RD=0 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=16 Op =       DEC  R1          literal 0000 RD=1 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=17 Op =       CMP  R0 R1       literal 0000 RD=0 rS1=1 rS2=0 format=1100</span>&#13;
<span>pc=18 Op =       BNE  LOOP2       literal 000a RD=0 rS1=0 rS2=0 format=0001</span>&#13;
<span>pc=19 Op =       NOP              literal 0000 RD=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=20 Op =       STOP             literal 0000 RD=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=21 Op =       END!             literal 0000 RD=0 rS1=0 rS2=0 format=0000</span></pre>&#13;
			<p lang="en-GB">The following provides the output of a run using this program. We’ve set the trace level to <strong class="source-inline">4</strong> to show the source code (after text processing), the symbol table, and the <span class="No-Break">decoded instructions.</span></p>&#13;
			<p lang="en-GB">Then, we’ve executed the code line by line. In order to make the output more readable and to fit it on the page, we’ve removed registers and <a id="_idIndexMarker429"/><a id="_idIndexMarker430"/>memory locations that don’t change, and we’ve highlighted values (memory, registers, and z-flag) that change as the result of an instruction. You can follow this through and see how memory/registers change with <span class="No-Break">each instruction.</span></p>&#13;
			<p lang="en-GB">As you can see, we create five random numbers in memory locations <strong class="source-inline">0</strong> to <strong class="source-inline">4</strong> and then reverse their order. This does not match the output of the print status because it’s been modified <span class="No-Break">for printing:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>0         LDRL R0 0         PC =  0 z = 0 0000 0000 0000 0000 0000</span>&#13;
<span>                            R  <strong class="bold">0000</strong> 0000 0000 0000 0000</span>&#13;
<span>1         LDRL R1 5         PC =  1 z = 0 0000 0000 0000 0000 0000</span>&#13;
<span>                            R  0000 <strong class="bold">0005</strong> 0000 0000 0000</span>&#13;
<span>2  LOOP1  RND  R2           PC =  2 z = 0 0000 0000 0000 0000 0000</span>&#13;
<span>                            R  0000 0005 9eff 0000 0000</span>&#13;
<span>3         STRI R2 R0 0      PC =  3 z = 0 <strong class="bold">9eff</strong> 0000 0000 0000 0000</span>&#13;
<span>                            R  0000 0005 9eff 0000 0000</span>&#13;
<span>4         INC  R0           PC =  4 z = 0 9eff 0000 0000 0000 0000</span>&#13;
<span>                            R  <strong class="bold">0001</strong> 0005 9eff 0000 0000</span>&#13;
<span>5         DEC  R1           PC =  5 z = 0 9eff 0000 0000 0000 0000</span>&#13;
<span>                            R  0001 <strong class="bold">0004</strong> 9eff 0000 0000</span>&#13;
<span>6         <strong class="bold">BNE  LOOP1</strong>        PC =  6 z = 0 9eff 0000 0000 0000 0000</span>&#13;
<span>                            R  0001 0004 9eff 0000 0000</span>&#13;
<span>2  LOOP1  RND  R2           <strong class="bold">PC =  2</strong> z = 0 9eff 0000 0000 0000 0000</span>&#13;
<span>                            R  0001 0004 <strong class="bold">6d4a</strong> 0000 0000</span>&#13;
<span>3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a 0000 0000 0000</span>&#13;
<span>                            R  0001 0004 6d4a 0000 0000</span>&#13;
<span>4         INC  R0           PC =  4 z = 0 9eff 6d4a 0000 0000 0000</span>&#13;
<span>                            R  <strong class="bold">0002</strong> 0004 6d4a 0000 0000</span>&#13;
<span>5         DEC  R1           PC =  5 z = 0 9eff 6d4a 0000 0000 0000</span>&#13;
<span>                            R  0002 <strong class="bold">0003</strong> 6d4a 0000 0000</span>&#13;
<span>6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a 0000 0000 0000</span>&#13;
<span>                            R  0002 0003 6d4a 0000 0000</span>&#13;
<span>2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a 0000 0000 0000</span>&#13;
<span>                            R  0002 0003 <strong class="bold">a387</strong> 0000 0000</span>&#13;
<span>3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 0000 0000</span>&#13;
<span>                            R  0002 0003 a387 0000 0000</span>&#13;
<span>4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 0000 0000</span>&#13;
<span>                            R  0003 <strong class="bold">0003</strong> a387 0000 0000</span>&#13;
<span>5         DEC  R1           PC =  5 z = 0 9eff 6d4a a387 0000 0000</span>&#13;
<span>                            R  0003 <strong class="bold">0002</strong> a387 0000 0000</span>&#13;
<span>6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a a387 0000 0000</span>&#13;
<span>                            R  0003 0002 a387 0000 0000</span>&#13;
<span>2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a a387 0000 0000</span>&#13;
<span>                            R  0003 0002 <strong class="bold">2937</strong> 0000 0000</span>&#13;
<span>3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 2937 0000</span>&#13;
<span>                            R  0003 0002 2937 0000 0000</span>&#13;
<span>4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 2937 0000</span>&#13;
<span>                            R  <strong class="bold">0004</strong> 0002 2937 0000 0000</span>&#13;
<span>5         DEC  R1           PC =  5 z = 0 9eff 6d4a a387 2937 0000</span>&#13;
<span>                            R  0004 <strong class="bold">0001</strong> 2937 0000 0000</span>&#13;
<span>6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a a387 2937 0000</span>&#13;
<span>                            R  0004 0001 2937 0000 0000</span>&#13;
<span>2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a a387 2937 0000</span>&#13;
<span>                            R  0004 0001 <strong class="bold">db95</strong> 0000 0000</span>&#13;
<span>3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 2937 <strong class="bold">db95</strong></span>&#13;
<span>                            R  0004 0001 db95 0000 0000</span>&#13;
<span>4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  <strong class="bold">0005</strong> 0001 db95 0000 0000</span>&#13;
<span>5         DEC  R1           PC =  5 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0005 <strong class="bold">0000</strong> db95 0000 0000</span>&#13;
<span>6         BNE LOOP1         PC =  6 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0005 0000 db95 0000 0000</span>&#13;
<span>7         NOP               PC =  7 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0005 0000 db95 0000 0000</span>&#13;
<span>8         LDRL R0 0         PC =  8 z = 1 <span class="sc-source-bg">9eff 6d4a a387 2937 db95</span></span>&#13;
<span>                            R  0000 0000 db95 0000 0000</span>&#13;
<span>9         LDRL R1 4         PC =  9 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0000 <strong class="bold">0004</strong> db95 0000 0000</span>&#13;
<span>10 LOOP2  LDRI R2 R0 0      PC = 10 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0000 0004 <strong class="bold">9eff</strong> 0000 0000</span>&#13;
<span>11        LDRI R3 R1 0      PC = 11 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0000 0004 9eff <strong class="bold">db95</strong> 0000</span>&#13;
<span>12        MOVE R4 R2        PC = 12 z = 1 9eff 6d4a a387 2937 db95</span>&#13;
<span>                            R  0000 0004 9eff db95 <strong class="bold">9eff</strong></span>&#13;
<span>13        STRI R3 R0 0      PC = 13 z = 1 <strong class="bold">db95</strong> 6d4a a387 2937 db95</span>&#13;
<span>                            R  0000 0004 9eff db95 9eff</span>&#13;
<span>14        STRI R4 R1 0      PC = 14 z = 1 db95 6d4a a387 2937 <strong class="bold">9eff</strong></span>&#13;
<span>                            R  0000 0004 9eff db95 9eff</span>&#13;
<span>15        INC  R0           PC = 15 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  <strong class="bold">0001</strong> 0004 9eff db95 9eff</span>&#13;
<span>16        DEC  R1           PC = 16 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  0001 <strong class="bold">0003</strong> 9eff db95 9eff</span>&#13;
<span>17        CMP  R0 R1        PC = 17 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  0001 0003 9eff db95 9eff</span>&#13;
<span>18        BNE  LOOP2        PC = 18 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  0001 0003 9eff db95 9eff</span>&#13;
<span>10 LOOP2  LDRI R2 R0 0      PC = 10 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  0001 0003 <strong class="bold">6d4a</strong> db95 9eff</span>&#13;
<span>11        LDRI R3 R1 0      PC = 11 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  0001 0003 6d4a <strong class="bold">2937</strong> 9eff</span>&#13;
<span>12        MOVE R4 R2        PC = 12 z = 0 db95 6d4a a387 2937 9eff</span>&#13;
<span>                            R  0001 0003 6d4a 2937 <strong class="bold">6d4a</strong></span>&#13;
<span>13        STRI R3 R0 0      PC = 13 z = 0 db95 <strong class="bold">2937</strong> a387 2937 9eff</span>&#13;
<span>                            R  0001 0003 6d4a 2937 6d4a</span>&#13;
<span>14        STRI R4 R1 0      PC = 14 z = 0 db95 2937 a387 6d4a 9eff</span>&#13;
<span>                            R  0001 0003 6d4a 2937 6d4a</span>&#13;
<span>15        INC  R0           PC = 15 z = 0 db95 2937 a387 6d4a 9eff</span>&#13;
<span>                            R  <strong class="bold">0002</strong> 0003 6d4a 2937 6d4a</span>&#13;
<span>16        DEC  R1           PC = 16 z = 0 db95 2937 a387 6d4a 9eff</span>&#13;
<span>                            R  <strong class="bold">0002</strong> 0002 6d4a 2937 6d4a</span>&#13;
<span>17        CMP  R0 R1        PC = 17 z = 1 db95 2937 a387 6d4a 9eff</span>&#13;
<span>                            R  0002 0002 6d4a 2937 6d4a</span>&#13;
<span>18        BNE  LOOP2        PC = 18 <strong class="bold">z = 1</strong> db95 2937 a387 6d4a 9eff</span>&#13;
<span>                            R  0002 0002 6d4a 2937 6d4a</span>&#13;
<span>19        NOP               PC = 19 z = 1 db95 2937 a387 6d4a 9eff</span>&#13;
<span>                            R  0002 0002 6d4a 2937 6d4a</span>&#13;
<span>20        STOP              PC = 20 z = 1 <span class="sc-source-bg">db95 2937 a387 6d4a 9eff</span></span>&#13;
<span>                            R  0002 0002 6d4a 2937 6d4a</span></pre>&#13;
			<p lang="en-GB">In the next section, we demonstrate how <a id="_idIndexMarker431"/><a id="_idIndexMarker432"/>you might go about testing the operation of TC1. We cover <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Testing the assembler (e.g., the ability to use a free format <span class="No-Break">of code)</span></li>&#13;
				<li lang="en-GB">Testing flow control <span class="No-Break">instructions (branches)</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Testing <span class="No-Break">shift operations</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-107" lang="en-GB"><a id="_idTextAnchor107"/>Testing the assembler</h1>&#13;
			<p lang="en-GB">Since the TC1 assembler can<a id="_idIndexMarker433"/><a id="_idIndexMarker434"/> deal with several typographic features (e.g., uppercase or lowercase and multiple spaces), a simple way of testing the assembler is to give it a file to assemble that includes various conditions, such as multiple spaces, equates, and uppercase and lowercase conversion. My initial test source code was <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>     NOP</span>&#13;
<span> BRA eee</span>&#13;
<span>      INC r4</span>&#13;
<span>alan inc r5</span>&#13;
<span>eee    STOP</span>&#13;
<span>aa NOP <span class="sc-comment">@comment2</span></span>&#13;
<span>bb NOP     1</span>&#13;
<span>      LDRL      r0,   12</span>&#13;
<span>      LDRL r3,0x123 <span class="sc-comment">@ comment1</span></span>&#13;
<span>      LDRL r7,     0xFF</span>&#13;
<span>      INC R2</span>&#13;
<span>  BRA last</span>&#13;
<span>test1     EQU    999</span>&#13;
<span>  <span class="sc-comment">@comment3</span></span>&#13;
<span><span class="sc-comment">@comment4</span></span>&#13;
<span>  <span class="sc-comment">@ qqq EQU 7</span></span>&#13;
<span>www STRI r1,r2,1</span>&#13;
<span>abc   equ 25</span>&#13;
<span>qwerty  equ   888</span>&#13;
<span>last LDRL r5,0xFAAF</span>&#13;
<span>  beQ Aa</span>&#13;
<span>      STOP 2</span></pre>&#13;
			<p lang="en-GB">This is not exactly stylish code; it’s just random test code. In the following code, we provide the output of the assembler when operated in <strong class="source-inline">debug</strong> mode. This includes the formatting of the code (removal of blank lines and lowercase to uppercase conversion). The first listing provides the instructions as an array of lists <span class="No-Break">of tokens:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>TC1 CPU simulator 11 September 2022</span>&#13;
<span>Input debug level 1 - 5: 4</span>&#13;
<span>Source assembly code listing</span>&#13;
<span>0           NOP</span>&#13;
<span>1           BRA EEE</span>&#13;
<span>2           INC R4</span>&#13;
<span>3   ALAN    INC R5</span>&#13;
<span>4   EEE     STOP</span>&#13;
<span>5   AA      NOP</span>&#13;
<span>6   BB      NOP 1</span>&#13;
<span>7           LDRL R0 12</span>&#13;
<span>8           LDRL R3 0X123</span>&#13;
<span>9           LDRL R7 0XFF</span>&#13;
<span>10          INC R2</span>&#13;
<span>11          BRA LAST</span>&#13;
<span>12  WWW     STRI R1 R2 1</span>&#13;
<span>13  LAST    LDRL R5 0XFAAF</span>&#13;
<span>14          BEQ AA</span>&#13;
<span>15          STOP 2</span></pre>&#13;
			<p lang="en-GB">The second listing is the symbol table that ties<a id="_idIndexMarker435"/><a id="_idIndexMarker436"/> symbol names and labels to <span class="No-Break">integer values:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Equate and branch table</span>&#13;
<span>START    0</span>&#13;
<span>TEST1    999</span>&#13;
<span>ABC      25</span>&#13;
<span>QWERTY   888</span>&#13;
<span>ALAN     3</span>&#13;
<span>EEE      4</span>&#13;
<span>AA       5</span>&#13;
<span>BB       6</span>&#13;
<span>WWW      12</span>&#13;
<span>LAST     13</span>&#13;
<span>LOOP1    18</span>&#13;
<span>LOOP2    26</span></pre>&#13;
			<p lang="en-GB">The next listing was used largely for debugging when an instruction didn’t behave as intended. It lets you determine whether an instruction has been <span class="No-Break">correctly decoded:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Decoded instructions</span>&#13;
<span>pc=0  op=NOP                  literal 000 Dest reg=0 rS1-0 rS2=0 format=0000</span>&#13;
<span>pc=00 Op=NOP                  literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=01 Op=BRA EEE              literal 0004 Dest reg=0 rS1=0 rS2=0 format=0001</span>&#13;
<span>pc=02 Op=INC R4               literal 0000 Dest reg=4 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=03 Op=ALAN INC R5          literal 0000 Dest reg=5 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=04 Op=EEE STOP             literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=05 Op=AA NOP               literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=06 Op=BB NOP 1             literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>pc=07 Op=LDRL R0 12           literal 000c Dest reg=0 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=08 Op=LDRL R3 0X123        literal 0123 Dest reg=3 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=09 Op=LDRL R7 0XFF         literal 00ff Dest reg=7 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=10 Op=INC R2               literal 0000 Dest reg=2 rS1=0 rS2=0 format=1000</span>&#13;
<span>pc=11 Op=BRA LAST             literal 000d Dest reg=0 rS1=0 rS2=0 format=0001</span>&#13;
<span>pc=12 Op=WWW STRI R1 R2 1     literal 0001 Dest reg=1 rS1=2 rS2=0 format=1101</span>&#13;
<span>pc=13 Op=LAST LDRL R5 0XFAAF  <span class="sc-comment"> </span>literal faaf Dest reg=5 rS1=0 rS2=0 format=1001</span>&#13;
<span>pc=14 Op=BEQ AA               literal 0005 Dest reg=0 rS1=0 rS2=0 format=0001</span>&#13;
<span>pc=15 Op=STOP 2               literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000</span>&#13;
<span>&gt;&gt;&gt;</span></pre>&#13;
			<h2 id="_idParaDest-108" lang="en-GB"><a id="_idTextAnchor108"/>Testing flow control operations</h2>&#13;
			<p lang="en-GB">Here, we demonstrate how to test the<a id="_idIndexMarker437"/><a id="_idIndexMarker438"/> computer’s most important class of operations, the flow-control instruction, that is, the <span class="No-Break">conditional branch.</span></p>&#13;
			<p lang="en-GB">One of the most important classes of instructions to test are those that change the flow of control: the branch and subroutine call instructions. The following fragment of code is also meaningless (it serves only to test instruction execution) and is designed only to test loops. One loop is built using a branch on a not-zero operation, and the other uses an automatic loop mechanism that operates by decrementing a register and branching until the register decrements to zero. The <strong class="bold">decrement and branch on not zero </strong>(<strong class="bold">DBNE</strong>) instruction has the format <strong class="source-inline">DBNE</strong> <strong class="source-inline">r0</strong>,<strong class="source-inline">loop</strong>, where <strong class="source-inline">r0</strong> is the<a id="_idIndexMarker439"/><a id="_idIndexMarker440"/> counter being decremented and <strong class="source-inline">loop</strong> is the branch <span class="No-Break">target address.</span></p>&#13;
			<p lang="en-GB">We first provide the source listing and <span class="No-Break">symbol table:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; %Run TC1_FinalForBook_V1.2_20220911.py</span>&#13;
<span>TC1 CPU simulator 11 September 2022</span>&#13;
<span>Input debug level 1 - 5: 4</span>&#13;
<span>Source assembly code listing</span>&#13;
<span>0           NOP</span>&#13;
<span>1           BRA LAB1</span>&#13;
<span>2           INC R0</span>&#13;
<span>3   LAB1    INC R2</span>&#13;
<span>4           NOP</span>&#13;
<span>5           BRA LAB6</span>&#13;
<span>6           NOP</span>&#13;
<span>7   LAB2    LDRL R2 3</span>&#13;
<span>8   LAB4    DEC R2</span>&#13;
<span>9           NOP</span>&#13;
<span>10          BNE LAB4</span>&#13;
<span>11          NOP</span>&#13;
<span>12          BSR LAB7</span>&#13;
<span>13          NOP</span>&#13;
<span>14          LDRL R3 4</span>&#13;
<span>15  LAB5    NOP</span>&#13;
<span>16          INC R7</span>&#13;
<span>17          DBNE R3 LAB5</span>&#13;
<span>18          NOP</span>&#13;
<span>19          STOP</span>&#13;
<span>20  LAB6    BRA LAB2</span>&#13;
<span>21          NOP</span>&#13;
<span>22  LAB7    DEC R7</span>&#13;
<span>23          DEC R7</span>&#13;
<span>24          RTS</span>&#13;
<span>25          END!</span>&#13;
<span>Equate and branch table</span>&#13;
<span>START    0</span>&#13;
<span>LAB1     3</span>&#13;
<span>LAB2     7</span>&#13;
<span>LAB4     8</span>&#13;
<span>LAB5     15</span>&#13;
<span>LAB6     20</span>&#13;
<span>LAB7     22</span></pre>&#13;
			<p lang="en-GB">The following provides the output after a<a id="_idIndexMarker441"/><a id="_idIndexMarker442"/> debugging session. As you can see, the sequence of branches is faithfully implemented. Note that we’ve highlighted the branch actions and consequences (i.e., the <span class="No-Break">next instruction):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>0         NOP               PC= 0 z=0 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span>1         <strong class="bold">BRA LAB1</strong>          PC= 1 z=0 n=0 c=0</span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">3  LAB1</strong>   INC R2            PC= 3 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span>4         NOP               PC= 4 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span>5         <strong class="bold">BRA LAB6</strong>          PC= 5 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">20 LAB6</strong>   <strong class="bold">BRA LAB2</strong>          PC=20 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">7  LAB2</strong>   LDRL R2 3         PC= 7 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0003 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">8  LAB4</strong>   DEC R2            PC= 8 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0002 0000 0000 0000 0000 0000</span>&#13;
<span>9         NOP               PC= 9 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0002 0000 0000 0000 0000 0000</span>&#13;
<span>10        <strong class="bold">BNE LAB4</strong>          PC=10 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0002 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">8  LAB4</strong>   DEC R2            PC= 8 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span>9         NOP               PC= 9 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span>10        <strong class="bold">BNE LAB4</strong>          PC=10 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0001 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">8  LAB4</strong>   DEC R2            PC= 8 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span>9         NOP               PC= 9 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span>10        <strong class="bold">BNE LAB4</strong>          PC=10 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span>11        NOP               PC=11 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span>12        BSR LAB7          PC=12 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">22 LAB7</strong>   DEC R7            PC=22 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 ffff</span>&#13;
<span>23        DEC R7            PC=23 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 fffe</span>&#13;
<span>24        <strong class="bold">RTS</strong>               PC=24 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 fffe</span>&#13;
<span>13        NOP               PC=13 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 fffe</span>&#13;
<span>14        LDRL R3 4         PC=14 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0004 0000 0000 0000 fffe</span>&#13;
<span><strong class="bold">15 LAB5</strong>   NOP               PC=15 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0004 0000 0000 0000 fffe</span>&#13;
<span>16        INC R7            PC=16 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0004 0000 0000 0000 ffff</span>&#13;
<span>17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0003 0000 0000 0000 ffff</span>&#13;
<span><strong class="bold">15 LAB5</strong>   NOP               PC=15 z=0 n=1 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0003 0000 0000 0000 ffff</span>&#13;
<span>16        INC R7            PC=16 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0003 0000 0000 0000 0000</span>&#13;
<span>17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0002 0000 0000 0000 0000</span>&#13;
<span><strong class="bold">15 LAB5</strong>   NOP               PC=15 z=1 n=0 c=0 </span>&#13;
<span>                            R  0000 0000 0000 0002 0000 0000 0000 0000</span>&#13;
<span>16        INC R7            PC=16 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0002 0000 0000 0000 0001</span>&#13;
<span>17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0001 0000 0000 0000 0001</span>&#13;
<span><strong class="bold">15 LAB5</strong>   NOP               PC=15 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0001 0000 0000 0000 0001</span>&#13;
<span>16        INC R7            PC=16 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0001 0000 0000 0000 0002</span>&#13;
<span>17        <strong class="bold">DBNE R3 LAB5</strong>      PC=17 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0002</span>&#13;
<span>18        NOP               PC=18 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0002</span>&#13;
<span>19        STOP              PC=19 z=0 n=0 c=1 </span>&#13;
<span>                            R  0000 0000 0000 0000 0000 0000 0000 0002</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">In the next chapter, we will look at <a id="_idIndexMarker443"/><a id="_idIndexMarker444"/>some of the ways in which the TC1 program can be enhanced to add facilities such as error checking, the inclusion of new instructions, and special features such as variable-length <span class="No-Break">operand fields.</span></p>&#13;
			<h2 id="_idParaDest-109" lang="en-GB"><a id="_idTextAnchor109"/>Testing shift operations</h2>&#13;
			<p lang="en-GB">TC1 supports two shift types: <em class="italic">logical </em>and <em class="italic">rotate</em>. A logical shift moves the bits left or right. At one end, vacated bits are replaced by zeros and, at the other end, the bit shifted out is copied to the carry flag. In a rotation, the bit that is shifted out of one<a id="_idIndexMarker445"/><a id="_idIndexMarker446"/> end is copied to the other end; that is, the string of bits is treated as a ring. No bit is lost, no matter how many shifts take place. At each bit shift, the bit that was shifted to the other end is also copied to the <span class="No-Break">carry bit.</span></p>&#13;
			<p lang="en-GB">Most real computers have two other shift variations: an arithmetic shift that preserves the sign of two’s complement numbers when shifted right (divide-by-2 operation) and a rotate-through-carry shift where the bit shifted in at one end is the old carry bit and the bit shifted out becomes the new carry bit. Essentially, if the register has <strong class="source-inline">m</strong> bits, the carry bit is included to create an <strong class="source-inline">m+1</strong> bit word. This feature is used for multi-precision arithmetic. We haven’t included these modes <span class="No-Break">in TC1.</span></p>&#13;
			<p lang="en-GB">As well as specifying the shift type, we have to specify the shift direction (left or right). Most computers let you specify the number of shifts. We provide both facilities and the number of shifts can be specified using either a register or a literal. In a multi-length shift, the state of the carry bit is the last bit shifted out into the carry. The shift operations (with examples) are <span class="No-Break">as follows:</span></p>&#13;
			<table id="table001-4" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Shift Type</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Register/Literal</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="bold">Example</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical <span class="No-Break">shift left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LSLL r0,r1,2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical <span class="No-Break">shift left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LSL r3,r1,r4</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical <span class="No-Break">shift right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LSRL r0,r1,2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB">Logical <span class="No-Break">shift right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">LSR r3,r1,r2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Rotate left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">ROLL r0,r1,2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Rotate left</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">ROL  </strong><span class="No-Break"><strong class="source-inline">r3,r1,r0</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Rotate right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">literal</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break"><strong class="source-inline">RORL r0,r3,2</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">Rotate right</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><span class="No-Break">register</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p lang="en-GB"><strong class="source-inline">ROR  </strong><span class="No-Break"><strong class="source-inline">r3,r1,r0</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – TC1 shifting modes</p>&#13;
			<p lang="en-GB">When we test these instructions, we have to ensure that the shift direction is correct, the right number of shifts take place, the end bits (those <a id="_idIndexMarker447"/><a id="_idIndexMarker448"/>shifted out or in) behave correctly, and the flag bits are <span class="No-Break">set appropriately.</span></p>&#13;
			<p lang="en-GB">Consider the following fragment of code using the 16-bit value <strong class="source-inline">1000000110000001</strong> in a series <span class="No-Break">of shifts:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>LDRL r1,%1000000110000001</span>&#13;
<span>LSLL r0,r1,1</span>&#13;
<span>LSLL r0,r1,2</span>&#13;
<span>LSRL r0,r1,1</span>&#13;
<span>LSRL r0,r1,1</span>&#13;
<span>LDRL r1,%1000000110000001</span>&#13;
<span>LDRL r2,1</span>&#13;
<span>LDRL r3,2</span>&#13;
<span>LSLL r0,r1,r2</span>&#13;
<span>LSLL r0,r1,r3</span>&#13;
<span>LSRL r0,r1,r2</span>&#13;
<span>LSRL r0,r1,r2</span></pre>&#13;
			<p lang="en-GB">The following output from the simulator (edited to show only relevant information) gives the registers and condition codes as the preceding code is executed. The binary value of register <strong class="source-inline">r0</strong> is displayed on the right. This allows us to verify whether the operations have been executed correctly by <span class="No-Break">manual inspection:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>1  LDRL R1 %1000000110000001 z = 0 n = 0 c = 0 </span>&#13;
<span>   Regs 0 - 3  0000 8181 0000 0000  R0 =  0000000000000000</span>&#13;
<span>2  LSLL R0 R1 1              z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 – 3  0302 8181 0000 0000  R0 =  <strong class="bold">0000001100000010</strong></span>&#13;
<span>3  LSLL R0 R1 2              z = 0 n = 0 c = 0 </span>&#13;
<span>   Regs 0 - 3  0604 8181 0000 0000  R0 =  <strong class="bold">0000011000000100</strong></span>&#13;
<span>4  LSRL R0 R1 1              z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  40c0 8181 0000 0000  R0 =  <strong class="bold">0100000011000000</strong></span>&#13;
<span>5  LSRL R0 R1 1              z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  40c0 8181 0000 0000  R0 =  <strong class="bold">0100000011000000</strong></span>&#13;
<span>6  LDRL R1 %1000000110000001 z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  40c0 8181 0000 0000  R0 =  0100000011000000</span>&#13;
<span>7  LDRL R2 1                 z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  40c0 8181 0001 0000  R0 =  0100000011000000</span>&#13;
<span>8  LDRL R3 2                 z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  40c0 8181 0001 0002  R0 =  0100000011000000</span>&#13;
<span>9  LSL  R0 R1 R2             z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  0302 8181 0001 0002  R0 =  0000001100000010</span>&#13;
<span>10 LSL  R0 R1 R3             z = 0 n = 0 c = 0 </span>&#13;
<span>   Regs 0 - 3  0604 8181 0001 0002  R0 =  0000011000000100</span>&#13;
<span>11 LSR  R0 R1 R2             z = 0 n = 0 c = 1 </span>&#13;
<span>   Regs 0 - 3  40c0 8181 0001 0002  R0 =  0100000011000000</span>&#13;
<span>12 LSR  R0 R1 R2             z = 0 n = 0 c = 1 </span></pre>&#13;
			<pre class="source-code">   Regs 0 – 3  40c0 8181 0001 0002  R0 =  0100000011000000</pre>&#13;
			<p lang="en-GB">Note that a load operation does not affect the z-bit. Some computers update the z-bit after almost every operation. Some update the z-bit on demand (e.g., ARM, which we will introduce later), and some update it only after <span class="No-Break">certain operations.</span></p>&#13;
			<p lang="en-GB">The penultimate section of this chapter<a id="_idIndexMarker449"/><a id="_idIndexMarker450"/> covers adding a postscript to TC1 where we provide a simpler example that performs the same basic function but carries out some operations in a different way, such as instruction decoding. The purpose of this is to demonstrate that there are many ways of constructing <span class="No-Break">a simulator.</span></p>&#13;
			<h1 id="_idParaDest-110" lang="en-GB"><a id="_idTextAnchor110"/>TC1 postscript</h1>&#13;
			<p lang="en-GB">The version of TC1 presented here <a id="_idIndexMarker451"/><a id="_idIndexMarker452"/>grew during the development of this book. The current version has more features than the prototype; for example, initially, it didn’t include symbolic branch addresses and required users to enter actual <span class="No-Break">line numbers.</span></p>&#13;
			<p lang="en-GB">Here, we’re presenting a cut-down version of TC1, called TC1<span class="subscript">mini</span>, where we do some things differently; for example, by not allowing a free format (mnemonics must be uppercase and registers lowercase, and you can’t use spaces and commas as interchangeable delimiters). In this version, a simple function checks that the mnemonic is valid and terminates the program if it isn’t. Similarly, we’ve added a feature that checks whether an address generated by a pointer lies within the bounds of your memory space. The following section provides some comments on <span class="No-Break">this version.</span></p>&#13;
			<h2 id="_idParaDest-111" lang="en-GB"><a id="_idTextAnchor111"/>The classDecode function</h2>&#13;
			<p lang="en-GB">TC1 associates a 4-bit binary value with each<a id="_idIndexMarker453"/><a id="_idIndexMarker454"/> instruction to indicate that parameters are required by the current instruction; for example, <strong class="source-inline">1101</strong> indicates registers <strong class="source-inline">rD</strong>, <strong class="source-inline">rS1</strong>, and a literal. The TC1<span class="subscript">mini</span> version associates a <em class="italic">class number</em> in the<a id="_idIndexMarker455"/><a id="_idIndexMarker456"/> range <strong class="source-inline">0</strong> to <strong class="source-inline">7</strong>, with each instruction that describes its type. The classes range from <strong class="source-inline">0</strong> (mnemonic with no parameters) to <strong class="source-inline">7</strong> (mnemonic with an indirect address, such as <strong class="source-inline">LDRI r2,[r4])</strong>. Unlike TC1, the <strong class="source-inline">[ ]</strong> brackets are not optional in TC1<span class="subscript">mini's</span> <span class="No-Break">assembly language.</span></p>&#13;
			<p lang="en-GB">The difference between the two simulators, TC1 and TC1<span class="subscript">mini</span>, is that the 4-bit binary code provides <em class="italic">pre-decoding</em>; that is, the simulator doesn’t have to calculate what parameters the instruction requires because the code directly tells you that. If you use a class number instead, you have to decode the class number to determine the actual parameters required. However, a class number can be very creative. TC1<span class="subscript">mini</span> uses seven different instruction formats and requires a minimum of seven classes to be defined. If you had, say, 14 classes, each addressing mode class could be divided into two subclasses to give you greater control over the instruction <span class="No-Break">execution process.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The <strong class="source-inline">classDecode</strong> function takes in an instruction’s predicate and returns the four predicate values, the destination register, source register <strong class="source-inline">1</strong>, source register <strong class="source-inline">2</strong>, and the literal. Of course, instructions may have from zero to four of these values. Consequently, these parameters are initially set to dummy values, either a <strong class="source-inline">null</strong> string <span class="No-Break">or zero.</span></p>&#13;
			<p lang="en-GB">Before continuing, recall that Python’s <strong class="source-inline">in</strong> operator is useful for testing whether an element is a member of a set. For example, if an operation is in classes 2, 4, 5, and 9, we can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if thisThing in [2, 4, 5, 9]:                         <span class="sc-comment"># Test for membership of the set</span></span>&#13;
<span>def classDecode(predicate):</span>&#13;
<span>    lit,rD,rS1,rS2 = '',0,0,0                         <span class="sc-comment"># The literal is a null string initially</span></span>&#13;
<span>    if opClass in [1]:      lit = predicate           <span class="sc-comment"># Class 1 is mnemonic plus a literal</span></span>&#13;
<span>    if opClass in [2]:      rD  = reg1[predicate]     <span class="sc-comment"># Class 2 is mnemonic plus a literal</span></span>&#13;
<span>    if opClass in [3,4,5,6,7]:                   <span class="sc-comment"># Classes 3 to 7 have multiple parameters</span></span>&#13;
<span>        predicate = predicate.split(',')              <span class="sc-comment"># So, split predicate into tokens</span></span>&#13;
<span>        rD = reg1[predicate[0]]                       <span class="sc-comment"># Get first token (register number)</span></span></pre>&#13;
			<p lang="en-GB">The current instruction’s <strong class="source-inline">opClass</strong> is used to <a id="_idIndexMarker457"/><a id="_idIndexMarker458"/>extract the parameters. Instead of using <strong class="source-inline">if</strong> constructs, we’ve used Python’s <strong class="source-inline">if in [list]</strong> construct; for example, <strong class="source-inline">if opClass in [3,4,5,6,7]</strong> returns <strong class="source-inline">True</strong> if the instruction is in classes <strong class="source-inline">3</strong> to <strong class="source-inline">7</strong>. If it is, the predicate (a string) is divided into a list using the <strong class="source-inline">split()</strong> function, and the first <a id="_idIndexMarker459"/><a id="_idIndexMarker460"/>element is read to extract the destination register, <strong class="source-inline">rD</strong>. Note that we need to split the predicate only once, because all the following cases also fall within <span class="No-Break">this group.</span></p>&#13;
			<h2 id="_idParaDest-112" lang="en-GB"><a id="_idTextAnchor112"/>The testLine function</h2>&#13;
			<p lang="en-GB">Another limitation of TC1 is the lack of testing<a id="_idIndexMarker461"/><a id="_idIndexMarker462"/> and validation; for example, I sometimes type <strong class="source-inline">MOVE</strong> instead of <strong class="source-inline">MOV</strong> and the program crashes. Normally, this isn’t a problem; you just re-edit the source program. However, when debugging TC1, I often assumed an <a id="_idIndexMarker463"/><a id="_idIndexMarker464"/>error was due to a mistake in my new code, only to discover that it was simply a misprint in the assembly language program. So, I added a small amount of testing. The following provides the <span class="No-Break">testing function:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def testLine(tokens):                    <span class="sc-comment"># Check whether there's a valid instruction in this line</span></span>&#13;
<span>    error = 1                            <span class="sc-comment"># error flag = 1 for no error and 0 for an error state</span></span>&#13;
<span>    if len(tokens) == 1:                 <span class="sc-comment"># If the line is a single token, it must be a mnemonic</span></span>&#13;
<span>        if tokens[0] in codes: error = 0 <span class="sc-comment"># If the token is in codes, there's no error</span></span>&#13;
<span>    else:                                <span class="sc-comment"># Otherwise, we have a multi-token line</span></span>&#13;
<span>        if (tokens[0] in codes) or (tokens[1] in codes): error = 0:</span>&#13;
<span>    return(error)                        <span class="sc-comment"># Return the error code</span></span></pre>&#13;
			<p lang="en-GB">The only line of interest is <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if (tokens[0] in codes) or (tokens[1] in codes): error = 0:</span></pre>&#13;
			<p lang="en-GB">There are two cases to consider: instructions with a label and those without a label. In the former case, the mnemonic is the second token in the instruction, and in the latter case, the mnemonic is the first token. We can test whether a token is a mnemonic by using Python’s <strong class="source-inline">if ... in</strong> construct. Say we have the <span class="No-Break">following construct:</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><strong class="source-inline">if token[0] </strong><span class="No-Break"><strong class="source-inline">in codes</strong></span></p>&#13;
			<p lang="en-GB">This returns <strong class="source-inline">True</strong> if the first<a id="_idIndexMarker465"/><a id="_idIndexMarker466"/> token is a valid mnemonic. We can combine the two tests with an <strong class="source-inline">or</strong> Boolean to get the preceding expression. In the<a id="_idIndexMarker467"/><a id="_idIndexMarker468"/> program, we call <strong class="source-inline">testLine</strong> with the <strong class="source-inline">tokens</strong> parameter and it returns an error. We use the error to print a message and return it to the operating system with the <span class="No-Break"><strong class="source-inline">sys.exit()</strong></span><span class="No-Break"> function.</span></p>&#13;
			<h2 id="_idParaDest-113" lang="en-GB"><a id="_idTextAnchor113"/>The testIndex() function</h2>&#13;
			<p lang="en-GB">This simulator<a id="_idIndexMarker469"/><a id="_idIndexMarker470"/> provides an instruction in <a id="_idIndexMarker471"/><a id="_idIndexMarker472"/>the form <strong class="source-inline">LDRI r1,[r2]</strong> to provide memory indirect addressing (i.e., pointer-based or <span class="No-Break">indexed addressing).</span></p>&#13;
			<p lang="en-GB">In this case, register <strong class="source-inline">r1</strong> is loaded with the contents of memory pointed at by register <strong class="source-inline">r2</strong>. If the pointer register contains an invalid value that is outside the range of legal addresses, the program will crash. By testing the index, we can ensure that an out-of-range index is detected. Note that only the first source register, <strong class="source-inline">rS1</strong>, is ever used as a <span class="No-Break">memory pointer:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def testIndex():                        <span class="sc-comment"># Test for register or memory index out of range</span></span>&#13;
<span>    if (rD &gt; 7) or (rS1 &gt; 7) or (rS2 &gt; 7): <span class="sc-comment"># Ensure register numbers are in the range 0 to 7</span></span>&#13;
<span>        print('Register number error')</span>&#13;
<span>        sys.exit()                      <span class="sc-comment"># Call operating system to leave the Python program</span></span>&#13;
<span>    if mnemonic in ['LDRI', 'STRI']:    <span class="sc-comment"># Memory index testing only for memory load and store</span></span>&#13;
<span>        if r[rS1] &gt; len(m) - 1:         <span class="sc-comment"># Test rS1 contents are less than memory size</span></span>&#13;
<span>            print(' Memory index error')</span>&#13;
<span>            sys.exit()</span>&#13;
<span>    return()</span></pre>&#13;
			<h2 id="_idParaDest-114" lang="en-GB"><a id="_idTextAnchor114"/>General comments</h2>&#13;
			<p lang="en-GB">The following line demonstrates how we extract the operation class from the mnemonic. The expression looks strange because of the <strong class="source-inline">()</strong> and <strong class="source-inline">[]</strong> parentheses. The <strong class="source-inline">codes.get(key)</strong> operation uses <strong class="source-inline">key</strong> to get the associated value from the <span class="No-Break"><strong class="source-inline">codes</strong></span><span class="No-Break"> dictionary:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>opClass = codes.get(mnemonic)[0]     <span class="sc-comment"># Use mnemonic to read opClass from the codes dictionary</span></span></pre>&#13;
			<p lang="en-GB">In this case, the key is the mnemonic, and the value returned is the operation class; for example, if the mnemonic is <strong class="source-inline">'LDRL'</strong>, the corresponding value is <strong class="source-inline">[3]</strong>. Note that the value returned is not <strong class="source-inline">3</strong>! It is a <em class="italic">list</em> with the single value <strong class="source-inline">3</strong>. Consequently, we have to extract the value from the list by specifying the first item, that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">mnemonic[0]</strong></span><span class="No-Break">.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">There are many ways to build an instruction. In TC1, we create a binary value, just like a real assembler. In TC1<span class="subscript">mini</span>, we directly execute the instruction from the assembly language form. So, when we compile the instructions, we create a program in text form. To do that, we need to combine the label, mnemonic, registers, and literal into <span class="No-Break">a list.</span></p>&#13;
			<p lang="en-GB">The code to do that is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>thisLine = list((i,label,mnemonic,predicate,opClass))</span>&#13;
<span>                                        <span class="sc-comment"># Combine the component parts in a list</span></span>&#13;
<span>prog.append(thisLine)                   <span class="sc-comment"># Add the new line to the existing program</span></span></pre>&#13;
			<p lang="en-GB">In this example, we use<a id="_idIndexMarker473"/><a id="_idIndexMarker474"/> the <strong class="source-inline">list()</strong> function to combine items into a list, and then we use <strong class="source-inline">append()</strong> to add this item to an existing list. Note the syntax of <strong class="source-inline">list()</strong>. You might expect it to be <strong class="source-inline">list(a,b,c)</strong>. No. It’s <strong class="source-inline">list((a,b,c))</strong>. The <strong class="source-inline">list()</strong> function uses parentheses as normal but the list itself must be in parentheses. That’s because the list items constitute a <em class="italic">single</em> parameter <span class="No-Break">to list.</span></p>&#13;
			<h2 id="_idParaDest-115" lang="en-GB"><a id="_idTextAnchor115"/>The TC1<span class="subscript">tiny</span> code listing</h2>&#13;
			<p lang="en-GB">This is the listing of the cut-down<a id="_idIndexMarker475"/><a id="_idIndexMarker476"/> version of TC1. Instructions fall into eight classes depending on the number and arrangements of operands. Each instruction is in a dictionary, <strong class="source-inline">codes</strong>, which provides the class number that is used to decode operands. The instruction itself is executed directly from its mnemonic. Unlike TC1, there is no intermediate binary code. Similarly, both register names and indirect register names are in dictionaries to simplify <span class="No-Break">instruction decoding:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># Simple CPU instruction interpreter. Direct instruction interpretation. 30 September 2022. V1.0</span></span>&#13;
<span># Class 0: no operand                   NOP</span>&#13;
<span># Class 1: literal                      BEQ  3</span>&#13;
<span># Class 2: register                     INC  r1</span>&#13;
<span># Class 3: register,literal             LDRL r1,5</span>&#13;
<span># Class 4: register,register,           MOV  r1,r2</span>&#13;
<span># Class 5: register,register,literal    ADDL r1,r2,5</span>&#13;
<span># Class 6: register,register,register   ADD  r1,r2,r3</span>&#13;
<span># Class 7: register,[register]          LDRI r1,[r2]</span>&#13;
<span>import sys                              <span class="sc-comment">#NEW</span></span>&#13;
<span>codes = {'NOP':[0],'STOP':[0],'END':[0],'ERR':[0], 'BEQ':[1],'BNE':[1], \</span>&#13;
<span>         'BRA':[1],'INC':[2],'DEC':[2],'NOT':[2],'CMPL':[3],'LDRL':[3], \</span>&#13;
<span>         'DBNE':[3],'MOV':[4],'CMP':[4],'SUBL':[5],'ADDL':[5],'ANDL':[5], \</span>&#13;
<span>         'ADD':[6],'SUB':[6],'AND':[6],'OR':[6],'LDRI':[7],'STRI':[7]}</span>&#13;
<span>reg1  = {'r0':0,   'r1':1,   'r2':2,  'r3':3,   'r4':4,   'r5':5, \</span>&#13;
<span>         'r6':6,  'r7':7}               <span class="sc-comment"># Registers</span></span>&#13;
<span>reg2  = {'[r0]':0, '[r1]':1, '[r2]':2,'[r3]':3, '[r4]':4, \</span>&#13;
<span>         '[r5]':5, '[r6]':6,'[r7]':7}   <span class="sc-comment"># Pointer registers</span></span>&#13;
<span>symTab = {}                             <span class="sc-comment"># Symbol table</span></span>&#13;
<span>r = [0] * 8                             <span class="sc-comment"># Register set</span></span>&#13;
<span>m = [0] * 8</span>&#13;
<span>prog = [] * 32                          <span class="sc-comment"># Program memory</span></span>&#13;
<span>def equates():                          <span class="sc-comment"># Process directives and delete from source</span></span>&#13;
<span>    global symTab, sFile</span>&#13;
<span>    for i in range (0,len(sFile)):      <span class="sc-comment"># Deal with equates</span></span>&#13;
<span>        tempLine = sFile[i].split()</span>&#13;
<span>        if len(tempLine) &gt; 2 and tempLine[1] == 'EQU':</span>&#13;
<span>                                        <span class="sc-comment"># If line &gt; 2 tokens and second EQU</span></span>&#13;
<span>            print('SYMB' , sFile[i])</span>&#13;
<span>            symTab[tempLine[0]] = tempLine[2] <span class="sc-comment"># Put third token EQU in symbol table</span></span>&#13;
<span>    sFile = [ i for i in sFile if i.count('EQU') == 0] <span class="sc-comment"># Remove all lines with 'EQU'</span></span>&#13;
<span>    print('Symbol table ', symTab, '\n')</span>&#13;
<span>    return()</span></pre>&#13;
			<p lang="en-GB">This section deals with decoding instructions into<a id="_idIndexMarker477"/><a id="_idIndexMarker478"/> the appropriate task in order to correctly execute them with the <span class="No-Break">appropriate parameters:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def c<a id="_idTextAnchor116"/>lassDecode(predicate):</span>&#13;
<span>    lit,rD,rS1,rS2 = '',0,0,0                         <span class="sc-comment"># Initialize variables</span></span>&#13;
<span>    if opClass in [1]:      lit =  predicate</span>&#13;
<span>    if opClass in [2]:      rD  = reg1[predicate]</span>&#13;
<span>    if opClass in [3,4,5,6,7]:</span>&#13;
<span>        predicate = predicate.split(',')</span>&#13;
<span>        rD = reg1[predicate[0]]</span>&#13;
<span>    if opClass in [4,5,6]:  rS1 = reg1[predicate[1]] \</span>&#13;
<span>                                                <span class="sc-comment"># Get source reg 1 for classes 4, 5, and 6</span></span>&#13;
<span>    if opClass in [3,5]:    lit = (predicate[-1])     <span class="sc-comment"># Get literal for classes 3 and 5</span></span>&#13;
<span>    if opClass in [6]:      rS2 = reg1[predicate[2]]  <span class="sc-comment"># Get source reg 2 for class 6</span></span>&#13;
<span>    if opClass in [7]:      rS1 = reg2[predicate[1]]  <span class="sc-comment"># Get source pointer reg for class 7</span></span>&#13;
<span>    return(lit,rD,rS1,rS2)</span></pre>&#13;
			<p lang="en-GB">Unlike TC1, we perform a little testing on the input, for example, whether the memory or register index is out of range. This is simply an illustrative example of <span class="No-Break">data validation:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def t<a id="_idTextAnchor117"/>estLine(tokens):   <span class="sc-comment"># Check there's a valid instruction in this line</span></span>&#13;
<span>    error = 1</span>&#13;
<span>    if len(tokens) == 1:</span>&#13;
<span>        if tokens[0] in codes: error = 0</span>&#13;
<span>    else:</span>&#13;
<span>        if (tokens[0] in codes) or (tokens[1] in codes): error = 0</span>&#13;
<span>    return(error)</span>&#13;
<span>    def t<a id="_idTextAnchor118"/>estIndex():                    <span class="sc-comment"># Test for reg or memory index out of range</span></span>&#13;
<span>    print('rD,rS1 =', rD,rS1, 'r[rS1] =', r[rS1], 'len(m)', len(m),\</span>&#13;
<span>    'mnemonic =', mnemonic)</span>&#13;
<span>    if rD &gt; 7 or rS1 &gt; 7 or rS2 &gt; 7:</span>&#13;
<span>        print('Register number error')</span>&#13;
<span>        sys.exit()                                  <span class="sc-comment"># Exit program on register error</span></span>&#13;
<span>    if mnemonic in ['LDRI', 'STRI']:</span>&#13;
<span>        if r[rS1] &gt; len(m) - 1:</span>&#13;
<span>            print(' Memory index error')</span>&#13;
<span>            sys.exit()                              <span class="sc-comment"># Exit program on pointer error</span></span>&#13;
<span>    return()</span>&#13;
<span>def getLit(litV):                                   <span class="sc-comment"># Extract a literal (convert formats)</span></span>&#13;
<span>    if litV == '': return(0)                        <span class="sc-comment"># Return 0 if literal field empty</span></span>&#13;
<span>    if  litV in symTab:                    <span class="sc-comment"># Look in symbol table and get value if there</span></span>&#13;
<span>        litV = symTab[litV]                         <span class="sc-comment"># Read the symbol value as a string</span></span>&#13;
<span>        lit = int(litV)                             <span class="sc-comment"># Convert string to integer</span></span>&#13;
<span>    elif  litV[0]    == '%': lit = int(litV[1:],2)  <span class="sc-comment"># If % convert binary to int</span></span>&#13;
<span>    elif  litV[0:1]  == '$': lit = int(litV[1:],16) <span class="sc-comment"># If first symbol $, convert hex to int</span></span>&#13;
<span>    elif  litV[0]    == '-':</span>&#13;
<span>        lit = (-int(litV[1:]))&amp;0xFFFF               <span class="sc-comment"># Deal with negative values</span></span>&#13;
<span>    elif  litV.isnumeric():  lit = int(litV)        <span class="sc-comment"># Convert decimal string to integer</span></span>&#13;
<span>    else:                    lit = 0                <span class="sc-comment"># Default value 0 (if all else fails)</span></span>&#13;
<span>    return(lit)</span>&#13;
<span>prgN = 'E://ArchitectureWithPython//NewIdeas_1.txt' <span class="sc-comment"># prgN = program name:  test file</span></span>&#13;
<span>sFile = [ ]                                         <span class="sc-comment"># sFile source data</span></span>&#13;
<span>with open(prgN,'r') as prgN:                        <span class="sc-comment"># Open it and read it</span></span>&#13;
<span>    prgN = prgN.readlines()</span>&#13;
<span>for i in range(0,len(prgN)):                        <span class="sc-comment"># First level of text-processing</span></span>&#13;
<span>    prgN[i] = prgN[i].replace('\n','')              <span class="sc-comment"># Remove newline code in source</span></span>&#13;
<span>    prgN[i] = ' '.join(prgN[i].split())             <span class="sc-comment"># Remove multiple spaces</span></span>&#13;
<span>    prgN[i] = prgN[i].strip()                       <span class="sc-comment"># First strip spaces</span></span>&#13;
<span>prgN = [i.split('@')[0] for i in prgN]              <span class="sc-comment"># Remove comment fields</span></span>&#13;
<span>while '' in prgN: prgN.remove('')                   <span class="sc-comment"># Remove blank lines</span></span>&#13;
<span>for i in range(0,len(prgN)):                        <span class="sc-comment"># Copy source to sFile: stop on END</span></span>&#13;
<span>    sFile.append(prgN[i])                           <span class="sc-comment"># Build new source text file sFile</span></span>&#13;
<span>    if 'END' in sFile[i]: break            <span class="sc-comment"># Leave on 'END' and ignore any more source text</span></span>&#13;
<span>for i in range(0,len(sFile)): print(sFile[i])</span>&#13;
<span>print()</span>&#13;
<span>equates()                                           <span class="sc-comment"># Deal with equates</span></span>&#13;
<span>for i in range(0,len(sFile)): print(sFile[i])</span>&#13;
<span>print()</span>&#13;
<span>for i in range(0,len(sFile)):         <span class="sc-comment"># We need to compile a list of labels</span></span>&#13;
<span>    label = ''                        <span class="sc-comment"># Give each line a default empty label</span></span>&#13;
<span>    predicate = ''                    <span class="sc-comment"># Create default predicate (label + mnemonic + predicate)</span></span>&#13;
<span>    tokens = sFile[i].split(' ')      <span class="sc-comment"># Split into separate groups</span></span>&#13;
<span>    error = testLine(tokens)          <span class="sc-comment"># Test for an invalid instruction</span></span>&#13;
<span>    if error == 1:                    <span class="sc-comment"># If error found</span></span>&#13;
<span>        print('Illegal instruction', tokens, 'at',i)</span>&#13;
<span>        sys.exit()                    <span class="sc-comment"># Exit program</span></span>&#13;
<span>    numTokens = len(tokens)           <span class="sc-comment"># Process this line</span></span>&#13;
<span>    if numTokens == 1: mnemonic = tokens[0]</span>&#13;
<span>    if numTokens &gt; 1:</span>&#13;
<span>        if tokens[0][-1] == ':':</span>&#13;
<span>            symTab.update({tokens[0][0:-1]:i})    <span class="sc-comment"># Insert new value and line number</span></span>&#13;
<span>            label = tokens[0][0:-1]</span>&#13;
<span>            mnemonic = tokens[1]</span>&#13;
<span>        else: mnemonic = tokens[0]</span>&#13;
<span>        predicate = tokens[-1]</span>&#13;
<span>    opClass = codes.get(mnemonic)[0] <span class="sc-comment"># Use the mnemonic to read opClass from codes dictionary</span></span>&#13;
<span>    thisLine = list((i,label,mnemonic,predicate,opClass))</span>&#13;
<span>    prog.append(thisLine)            <span class="sc-comment"># Program line + label + mnemonic + predicate + opClass</span></span>&#13;
<span>print('Symbol table ', symTab, '\n') <span class="sc-comment"># Display symbol table for equates and line labels</span></span></pre>&#13;
			<p lang="en-GB">The following is the actual instruction <a id="_idIndexMarker479"/><a id="_idIndexMarker480"/>execution loop. As you can see, it is <span class="No-Break">remarkably compact:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                             <span class="sc-comment"># Instruction execution</span></span>&#13;
<span>run = 1</span>&#13;
<span>z = 0</span>&#13;
<span>pc = 0</span>&#13;
<span>while run == 1:</span>&#13;
<span>    thisOp = prog[pc]</span>&#13;
<span>    if thisOp[2] in ['STOP', 'END']: run = 0 <span class="sc-comment"># Terminate on STOP or END (comment on this)</span></span>&#13;
<span>    pcOld = pc</span>&#13;
<span>    pc = pc + 1</span>&#13;
<span>    mnemonic  = thisOp[2]</span>&#13;
<span>    predicate = thisOp[3]</span>&#13;
<span>    opClass   = thisOp[4]</span>&#13;
<span>    lit,rD,rS1,rS2 = classDecode(predicate)</span>&#13;
<span>    lit = getLit(lit)</span>&#13;
<span>    if   mnemonic == 'NOP': pass</span>&#13;
<span>    elif mnemonic == 'BRA': pc = lit</span>&#13;
<span>    elif mnemonic == 'BEQ':</span>&#13;
<span>        if z == 1: pc = lit</span>&#13;
<span>    elif mnemonic == 'BNE':</span>&#13;
<span>        if z == 0: pc = lit</span>&#13;
<span>    elif mnemonic == 'INC': r[rD] = r[rD] + 1</span>&#13;
<span>    elif mnemonic == 'DEC':</span>&#13;
<span>        z = 0</span>&#13;
<span>        r[rD] = r[rD] - 1</span>&#13;
<span>        if r[rD] == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'NOT': r[rD] = (~r[rD])&amp;0xFFFF  <span class="sc-comment"># Logical NOT</span></span>&#13;
<span>    elif mnemonic == 'CMPL':</span>&#13;
<span>        z = 0</span>&#13;
<span>        diff = r[rD] - lit</span>&#13;
<span>        if diff == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'LDRL': r[rD] = lit</span>&#13;
<span>    elif mnemonic == 'DBNE':</span>&#13;
<span>        r[rD] = r[rD] - 1</span>&#13;
<span>        if r[rD] != 0: pc = lit</span>&#13;
<span>    elif mnemonic == 'MOV':  r[rD] = r[rS1]</span>&#13;
<span>    elif mnemonic == 'CMP':</span>&#13;
<span>        z = 0</span>&#13;
<span>        diff = r[rD] - r[rS1]</span>&#13;
<span>        if diff == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'ADDL': r[rD] = r[rS1] + lit</span>&#13;
<span>    elif mnemonic == 'SUBL': r[rD] = r[rS1] - lit</span>&#13;
<span>    elif mnemonic == 'ADD':  r[rD] = r[rS1] + r[rS2]</span>&#13;
<span>    elif mnemonic == 'SUB':  r[rD] = r[rS1] - r[rS2]</span>&#13;
<span>    elif mnemonic == 'AND':  r[rD] = r[rS1] &amp; r[rS2]</span>&#13;
<span>    elif mnemonic == 'OR':   r[rD] = r[rS1] | r[rS2]</span>&#13;
<span>    elif mnemonic == 'LDRI':</span>&#13;
<span>        testIndex()</span>&#13;
<span>        r[rD] = m[r[rS1]]</span>&#13;
<span>    elif mnemonic == 'STRI':</span>&#13;
<span>        testIndex()</span>&#13;
<span>        m[r[rS1]] = r[rD]</span>&#13;
<span>    regs = ' '.join('%04x' % b for b in r)           <span class="sc-comment"># Format memory location's hex</span></span>&#13;
<span>    mem  = ' '.join('%04x' % b for b in m)           <span class="sc-comment"># Format register's hex</span></span>&#13;
<span>    print('pc =','{:&lt;3}'.format(pcOld),'{:&lt;18}'.format(sFile[pcOld]),\</span>&#13;
<span>          'regs =',regs,'Mem =',mem,'z =',z)</span></pre>&#13;
			<p lang="en-GB">The code execution loop, like most of the simulators we discuss, is remarkably straightforward. The current instruction is fetched and decoded into mnemonic, class, and register numbers. The program counter is advanced and the mnemonic is presented to a series of <span class="No-Break"><strong class="source-inline">then...elif</strong></span><span class="No-Break"> statements.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Many of the instructions are executed in only one line of code; for example, <strong class="source-inline">ADD</strong> is implemented by adding two registers together: <strong class="source-inline">r[rD] = r[rS1] + r[rS2]</strong>. Some instructions, such as <strong class="source-inline">compare</strong>, require two registers to be subtracted and then the status bits to be <span class="No-Break">set accordingly.</span></p>&#13;
			<p lang="en-GB">We included one relatively complex<a id="_idIndexMarker481"/><a id="_idIndexMarker482"/> instruction, decrement and branch on not zero, which decrements a register and then branches to a target address if the register has not counted down <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">In the final section, we will look at yet another variation <span class="No-Break">of TC1.</span></p>&#13;
			<h1 id="_idParaDest-116" lang="en-GB"><a id="_idTextAnchor119"/>TC1 postscript mark II</h1>&#13;
			<p lang="en-GB">If one postscript is good, two <a id="_idIndexMarker483"/><a id="_idIndexMarker484"/>are even better. We’ve added this second variation on a theme to demonstrate some different ways of doing things. Much of the program’s structure is the same as before. The features are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Direct <span class="No-Break">execution (revisited)</span></li>&#13;
				<li lang="en-GB">The ability to avoid different mnemonics (e.g., <strong class="source-inline">ADD</strong> and <strong class="source-inline">ADDL</strong>) for the same <span class="No-Break">basic operation</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The principal enhancement is the way to handle instructions and decode them. In TC1, we use a 4-bit code to define the structure of each instruction in terms of its parameters. When a mnemonic is looked up in the dictionary, it returns a code giving the <span class="No-Break">required parameters.</span></p>&#13;
			<p lang="en-GB">One feature (problem?) with TC1 is that we have different mnemonics for variations on an instruction, for example, <strong class="source-inline">ADD</strong> and <strong class="source-inline">ADDL</strong>. The suffix <strong class="source-inline">L</strong> tells the assembler that a literal operand (rather than a register number) is required. In this example, we avoid different instruction formats and use a single mnemonic by putting instructions into classes. Each class defines an instruction format, ranging from class <strong class="source-inline">0</strong> (instruction with no parameters) to class <strong class="source-inline">9</strong> (instruction with <span class="No-Break"><em class="italic">four</em></span><span class="No-Break"> registers).</span></p>&#13;
			<p lang="en-GB">This example uses the direct execution of an instruction. That is, we don’t compile an instruction into binary and then execute the binary. We execute an instruction directly from <span class="No-Break">its mnemonic.</span></p>&#13;
			<p lang="en-GB">A consequence of this arrangement is that an instruction may fall into multiple classes; for example, <strong class="source-inline">LDR</strong> is in <em class="italic">three</em> classes, rather than having the <strong class="source-inline">LDR</strong>, <strong class="source-inline">LDRL</strong>, and <strong class="source-inline">LDRI</strong> variants. When an instruction is encountered, it is checked against each class. If the mnemonic is in a class, the attributes of the instruction are checked before deciding whether we’ve found the <span class="No-Break">correct class.</span></p>&#13;
			<p lang="en-GB">Consider <strong class="source-inline">ADD</strong>. We can write <strong class="source-inline">ADD r1,r2,5</strong> or <strong class="source-inline">ADD r1,r2,r3</strong>; that is, the second number added to a register may be a literal or a register. Consequently, <strong class="source-inline">ADD</strong> is in class <strong class="source-inline">5</strong> and class <strong class="source-inline">6</strong>. To resolve the ambiguity, we look at the final operand; if it’s a literal, then it’s class <strong class="source-inline">5</strong>, and if it’s a register, it’s <span class="No-Break">class </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Testing for a register is easy because we’ve put registers in a dictionary, so it’s necessary only to check whether the final operand is in the dictionary or not. Consider <span class="No-Break">class </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>if <strong class="bold">(mnemonic in class3)</strong> and <strong class="bold">(predLen == 2)</strong> and <strong class="bold">(predicate[1] not in regList)</strong></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Here, we do a triple test. First, we check <a id="_idIndexMarker485"/><a id="_idIndexMarker486"/>whether the mnemonic is in class <strong class="source-inline">3</strong>. Then, we test the predicate length (it’s <strong class="source-inline">2</strong> for two operands, such as <strong class="source-inline">CMP r1,5</strong>). Finally, we test for a numeric second operand by ensuring that the operand is not in the list <span class="No-Break">of registers.</span></p>&#13;
			<p lang="en-GB">The Python program for this experiment is <span class="No-Break">as follows.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment"># Instruction formats</span></span>&#13;
<span># NOP             <span class="sc-comment"># class 0</span></span>&#13;
<span># BRA 4           <span class="sc-comment"># Class 1</span></span>&#13;
<span># INC r1          <span class="sc-comment"># class 2</span></span>&#13;
<span># LDR r1,#4       <span class="sc-comment"># class 3</span></span>&#13;
<span># MOV r1,r2       <span class="sc-comment"># class 4</span></span>&#13;
<span># ADD r1,r2,5     <span class="sc-comment"># class 5</span></span>&#13;
<span># ADD r1,r2,r3    <span class="sc-comment"># class 6</span></span>&#13;
<span># LDR r1,[r2]     <span class="sc-comment"># class 7</span></span>&#13;
<span># LDR r1,[r2],4   <span class="sc-comment"># class 8</span></span>&#13;
<span># MLA r1,r2,r3,r4 <span class="sc-comment"># class 9 [r1] = [r2] + [r3] * [r3]</span></span>&#13;
<span>def getLit(lit):                        <span class="sc-comment"># Extract a literal</span></span>&#13;
<span>    if    lit in symTab:    literal = symTab[lit] \</span>&#13;
<span>                                        <span class="sc-comment"># Look in symbol table and get if there</span></span>&#13;
<span>    elif  lit       == '%': literal = iint(lit[1:],2) \</span>&#13;
<span>                                        <span class="sc-comment"># If first symbol is %, convert binary to integer</span></span>&#13;
<span>    elif  lit[0:1]  == '$': literal = int(lit[1:],16) \</span>&#13;
<span>                                        <span class="sc-comment"># If first symbol is $, convert hex to integer</span></span>&#13;
<span>    elif  lit[0]    == '-': literal = i(-int(lit[1:]))&amp;0xFFFF \</span>&#13;
<span>                                        <span class="sc-comment"># Deal with negative values</span></span>&#13;
<span>    elif  lit.isnumeric():  literal = iint(lit) \</span>&#13;
<span>                                        <span class="sc-comment"># If number is a decimal string, then convert to integer</span></span>&#13;
<span>    else:                   literal = 0 <span class="sc-comment"># Default value 0 if all else fails</span></span>&#13;
<span>    return(literal)</span>&#13;
<span>regList = {'r0':0,'r1':1,'r2':2,'r3':3,'r4':4,'r5':5,'r6':6,'r7':7}</span>&#13;
<span>iRegList = {'[r0]':0,'[r1]':1,'[r2]':2,'[r3]':3,'[r4]':4,'[r5]':5, \</span>&#13;
<span>            '[r6]':6,'[r7]':7}</span>&#13;
<span>class0 = ['NOP','STOP','RTS']           <span class="sc-comment"># none</span></span>&#13;
<span>class1 = ['BRA','BEQ', 'BSR']           <span class="sc-comment"># register</span></span>&#13;
<span>class2 = ['INC', 'DEC']                 <span class="sc-comment"># register</span></span>&#13;
<span>class3 = ['LDR', 'STR','CMP','DBNE','LSL','LSR','ROR']  <span class="sc-comment"># register, literal</span></span>&#13;
<span>class4 = ['MOV','CMP','ADD']            <span class="sc-comment"># register, register Note ADD r1,r2</span></span>&#13;
<span>class5 = ['ADD','SUB']                  <span class="sc-comment"># register, register, literal</span></span>&#13;
<span>class6 = ['ADD','SUB']                  <span class="sc-comment"># register, register, register</span></span>&#13;
<span>class7 = ['LDR','STR']                  <span class="sc-comment"># register, pointer</span></span>&#13;
<span>class8 = ['LDR','STR']                  <span class="sc-comment"># register, pointer, literal</span></span>&#13;
<span>class9 = ['MLA']                        <span class="sc-comment"># register, register, register, register</span></span>&#13;
<span>inputSource = 0                         <span class="sc-comment"># Manual (keyboard) input if 0; file input if 1</span></span>&#13;
<span>singleStep  = 0                         <span class="sc-comment"># Select single-step mode or execute all-to-end mode</span></span>&#13;
<span>x = input('file input? type y or n ')   <span class="sc-comment"># Ask for file input (y) or keyboard input (any key)</span></span>&#13;
<span>if x == 'y':</span>&#13;
<span>    inputSource = 1</span>&#13;
<span>    x = input('Single step type y ')    <span class="sc-comment"># Type 'y' for single-step mode</span></span>&#13;
<span>    if x == 'y': singleStep = 1</span>&#13;
<span>    with open('C:/Users/AlanClements/Desktop/c.txt','r') as fileData:</span>&#13;
<span>        fileData = fileData.readlines()</span>&#13;
<span>    for i in range (0,len(fileData)):   <span class="sc-comment"># Remove leading and trailing spaces</span></span>&#13;
<span>        fileData[i] = fileData[i].strip()</span>&#13;
<span>r =     [0] * 8                         <span class="sc-comment"># Eight registers</span></span>&#13;
<span>m =     [0] * 16                        <span class="sc-comment"># 16 memory locations</span></span>&#13;
<span>stack = [0] * 8                         <span class="sc-comment"># Stack for return addresses (BSR/RTS)</span></span>&#13;
<span>prog =  []  * 64                        <span class="sc-comment"># Program memory</span></span>&#13;
<span>progDisp = [] * 64                      <span class="sc-comment"># Program for display</span></span>&#13;
<span>symTab = {}                             <span class="sc-comment"># Symbol table for symbolic name to value binding</span></span>&#13;
<span>run = True</span>&#13;
<span>pc = 0                                  <span class="sc-comment"># Clear program counter</span></span>&#13;
<span>sp = 7                                  <span class="sc-comment"># Set stack pointer to bottom of stack</span></span>&#13;
<span>while run == True:                      <span class="sc-comment"># Program processing loop</span></span>&#13;
<span>    predicate = []                      <span class="sc-comment"># Dummy</span></span>&#13;
<span>    if inputSource == 1:                <span class="sc-comment"># Get instruction from file</span></span>&#13;
<span>        line = fileData[pc]</span>&#13;
<span>    else: line = input('&gt;&gt; &gt; ')         <span class="sc-comment"># Or input instruction from keyboard</span></span>&#13;
<span>    if line == '':</span>&#13;
<span>        run = False</span>&#13;
<span>        break</span>&#13;
<span>    line = ' '.join(line.split())       <span class="sc-comment"># Remove multiple spaces. Uses join and split</span></span>&#13;
<span>    progDisp.append(line)               <span class="sc-comment"># Make a copy of this line for later display</span></span>&#13;
<span>    line = line.replace(',',' ')</span>&#13;
<span>    line = line.split(' ')              <span class="sc-comment"># Split instruction into tokens</span></span>&#13;
<span>    if (len(line) &gt; 1) and (line[0][-1] == ':'): <span class="sc-comment"># Look for a label (token 0 ending in :)</span></span>&#13;
<span>        label = line[0]</span>&#13;
<span>        symTab[line[0]] = pc            <span class="sc-comment"># Put a label in symTab alongside the pc</span></span>&#13;
<span>    else:</span>&#13;
<span>        line.insert(0,'    :')          <span class="sc-comment"># If no label+, insert a dummy one (for pretty printing)</span></span>&#13;
<span>    mnemonic  = line[1]                 <span class="sc-comment"># Get the mnemonic, second token</span></span>&#13;
<span>    predicate = line[2:]                <span class="sc-comment"># What's left is the predicate (registers and literal)</span></span>&#13;
<span>    prog.append(line)                   <span class="sc-comment"># Append the line to the program</span></span>&#13;
<span>    pc = pc + 1                         <span class="sc-comment"># And bump up the program counter</span></span>&#13;
<span>    progLength = pc – 1                 <span class="sc-comment"># Record the total number of instructions</span></span>&#13;
<span>for i in range (0,pc-1):</span>&#13;
<span>    print('pc =', f'{i:3}', (' ').join(prog[i])) <span class="sc-comment"># Print the program</span></span>&#13;
<span>print('Symbol table =', symTab, '\n')   <span class="sc-comment"># Display the symbol table</span></span>&#13;
<span>pc = 0</span>&#13;
<span>run = True</span>&#13;
<span>z = 0</span>&#13;
<span>c = 0</span>&#13;
<span>classNim = 10</span>&#13;
<span>while run == True:                      <span class="sc-comment"># Program execution loop</span></span>&#13;
<span>    instruction = prog[pc]</span>&#13;
<span>    pcOld = pc</span>&#13;
<span>    pc = pc + 1</span>&#13;
<span>    if instruction[1] == 'STOP':        <span class="sc-comment"># Halt on STOP instruction</span></span>&#13;
<span>        print('End of program exit')</span>&#13;
<span>        break</span>&#13;
<span>    mnemonic  = instruction[1]</span>&#13;
<span>    predicate = instruction[2:]</span>&#13;
<span>    predLen   = len(predicate)</span>&#13;
<span>    if (predLen &gt; 0) and (mnemonic not in class1): rD = regList[predicate[0]]</span>&#13;
<span>                                        <span class="sc-comment"># Get rD for classes 2 to 8</span></span></pre>&#13;
			<p lang="en-GB">In this simulator, we deal with instructions by class rather than by mnemonic. This feature means that the same mnemonic can have different addressing modes, such as literal, register, or even memory. The first class, <strong class="source-inline">0</strong>, is reserved for mnemonics with no <a id="_idIndexMarker487"/><a id="_idIndexMarker488"/>operands, such as <strong class="source-inline">NOP</strong>. Of course, this mechanism would make it possible to invent a new operation, such as, say, <strong class="source-inline">NOP 4</strong>, that acts in a <span class="No-Break">different way:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if mnemonic in class0:              <span class="sc-comment"># Deal with instructions by their group (class)</span></span>&#13;
<span>        classNum = 0</span>&#13;
<span>        if mnemonic == 'NOP': pass</span>&#13;
<span>        if mnemonic == 'RTS':           <span class="sc-comment"># Return from subroutine pull address off the stack</span></span>&#13;
<span>            pc = stack[sp]</span>&#13;
<span>            sp = sp + 1</span>&#13;
<span>    if mnemonic in class1:              <span class="sc-comment"># Class deals with branch operations so get literal</span></span>&#13;
<span>        classNum = 1</span>&#13;
<span>        literal = getLit(predicate[0])</span>&#13;
<span>        if   mnemonic == 'BRA': pc = literal</span>&#13;
<span>        elif mnemonic == 'BEQ':</span>&#13;
<span>            if z == 1: pc = literal</span>&#13;
<span>        elif mnemonic == 'BSR':         <span class="sc-comment"># Deal with subroutine call</span></span>&#13;
<span>            sp = sp - 1                 <span class="sc-comment"># Push return address on the stack</span></span>&#13;
<span>            stack[sp] = pc</span>&#13;
<span>            pc = literal</span>&#13;
<span>    if mnemonic in class2:                 <span class="sc-comment"># Class 2 increment and decrement so get register</span></span>&#13;
<span>        classNum = 2</span>&#13;
<span>        if mnemonic == 'INC': r[rD] = r[rD] + 1</span>&#13;
<span>        if mnemonic == 'DEC':</span>&#13;
<span>            r[rD] = r[rD] - 1</span>&#13;
<span>            if r[rD] == 0: z = 1           <span class="sc-comment"># Decrement sets z flag</span></span>&#13;
<span>            else: z = 0</span>&#13;
<span>    if (mnemonic in class3) and (predLen == 2) and \</span>&#13;
<span>    (predicate[1] not in regList):         </span>&#13;
<span>        classNum = 3</span>&#13;
<span>        literal = getLit(predicate[-1])</span>&#13;
<span>        if mnemonic == 'CMP':</span>&#13;
<span>            diff = r[rD] - literal</span>&#13;
<span>            if diff == 0: z = 1</span>&#13;
<span>            else:         z = 0</span>&#13;
<span>        elif mnemonic == 'LDR': r[rD] = literal</span>&#13;
<span>        elif mnemonic == 'STR': m[literal] = r[rD]</span>&#13;
<span>        elif mnemonic == 'DBNE':</span>&#13;
<span>            r[rD] = r[rD] - 1</span>&#13;
<span>            if r[rD] != 0: pc = literal        <span class="sc-comment"># Note we don't use z flag</span></span>&#13;
<span>        elif mnemonic == 'LSL':</span>&#13;
<span>            for i in range(0,literal):</span>&#13;
<span>                c = ((0x8000) &amp; r[rD]) &gt;&gt; 16</span>&#13;
<span>                r[rD] = (r[rD] &lt;&lt; 1) &amp; 0xFFFF  <span class="sc-comment"># Shift left and constrain to 16 bits</span></span>&#13;
<span>        elif mnemonic == 'LSR':</span>&#13;
<span>            for i in range(0,literal):</span>&#13;
<span>                c = ((0x0001) &amp; r[rD])</span>&#13;
<span>                r[rD] = r[rD] &gt;&gt; 1</span>&#13;
<span>        elif mnemonic == 'ROR':</span>&#13;
<span>            for i in range(0,literal):</span>&#13;
<span>                c = ((0x0001) &amp; r[rD])</span>&#13;
<span>                r[rD] = r[rD] &gt;&gt; 1</span>&#13;
<span>                r[rD] = r[rD] | (c &lt;&lt; 15)</span>&#13;
<span>    if (mnemonic in class4) and (predLen == 2) and (predicate[1]\</span>&#13;
<span>    in regList):                           #</span>&#13;
<span>        classNum = 4</span>&#13;
<span>        rS1 = regList[predicate[1]]        <span class="sc-comment"># Get second register</span></span>&#13;
<span>        if mnemonic == 'MOV':              <span class="sc-comment"># Move source register to destination register</span></span>&#13;
<span>           r[rD] = r[rS1]</span>&#13;
<span>        elif mnemonic == 'CMP':</span>&#13;
<span>            diff = r[rD] -  r[rS1]</span>&#13;
<span>            if diff == 0: z = 1</span>&#13;
<span>            else:         z = 0</span>&#13;
<span>        elif mnemonic == 'ADD':            <span class="sc-comment"># Add source to destination register</span></span>&#13;
<span>            r[rD] = r[rD] + r[rS1]</span>&#13;
<span>    if (mnemonic in class5) and (predLen == 3) and (predicate[2] not\</span>&#13;
<span>    in regList):</span>&#13;
<span>        classNum = 5                       <span class="sc-comment"># Class 5 is register with literal operand</span></span>&#13;
<span>        literal = getLit(predicate[2])</span>&#13;
<span>        rS1 = regList[predicate[1]]</span>&#13;
<span>        if   mnemonic == 'ADD': r[rD] = r[rS1] + literal</span>&#13;
<span>        elif mnemonic == 'SUB': r[rD] = r[rS1] - literal</span>&#13;
<span>    if (mnemonic in class6) and (predLen == 3) and (predicate[-1]\</span>&#13;
<span>    in regList):</span>&#13;
<span>        classNum = 6                       <span class="sc-comment"># Class 6 uses three registers</span></span>&#13;
<span>        rS1 = regList[predicate[1]]</span>&#13;
<span>        rS2 = regList[predicate[2]]</span>&#13;
<span>        if   mnemonic == 'ADD': r[rD] = r[rS1] + r[rS2]</span>&#13;
<span>        elif mnemonic == 'SUB': r[rD] = r[rS1] - r[rS2]</span>&#13;
<span>    if (mnemonic in class7) and (predLen == 2) and (predicate[1]\</span>&#13;
<span>    in iRegList):</span>&#13;
<span>        classNum = 7                       <span class="sc-comment"># Class 7 uses a pointer register with load and store</span></span>&#13;
<span>        pReg  = predicate[1]</span>&#13;
<span>        pReg1 = iRegList[pReg]</span>&#13;
<span>        pReg2 = r[pReg1]</span>&#13;
<span>        if   mnemonic == 'LDR': r[rD] = m[pReg2]</span>&#13;
<span>        elif mnemonic == 'STR': m[pReg2] = r[rD]</span>&#13;
<span>    if (mnemonic in class8) and (predLen == 3):</span>&#13;
<span>        classNum = 8                       <span class="sc-comment"># Class 8 uses a pointer register and a literal offset</span></span>&#13;
<span>        pReg  = predicate[1]</span>&#13;
<span>        pReg1 = iRegList[pReg]</span>&#13;
<span>        pReg2 = r[pReg1]</span>&#13;
<span>        literal = getLit(predicate[2])</span>&#13;
<span>        if   mnemonic == 'LDR': r[rD] = m[pReg2 + literal]</span>&#13;
<span>        elif mnemonic == 'STR': m[pReg2 + literal] = r[rD]</span>&#13;
<span>    if mnemonic in class9:                 <span class="sc-comment"># Class 9 demonstrates a 4-operand instruction</span></span>&#13;
<span>        classNum = 9</span>&#13;
<span>        if mnemonic == 'MLA':</span>&#13;
<span>            rS1 = regList[predicate[1]]</span>&#13;
<span>            rS2 = regList[predicate[2]]</span>&#13;
<span>            rS3 = regList[predicate[3]]</span>&#13;
<span>            r[rD] = r[rS1] * r[rS2] + r[rS3]</span>&#13;
<span>    pInst = ' '.join(instruction)          ##############</span>&#13;
<span>    Regs = ' '.join('%04x' % i for i in r)</span>&#13;
<span>    print('pc {:&lt;2}'.format(pcOld),'Class =', classNum,      \</span>&#13;
<span>          '{:&lt;20}'.format(pInst),'Regs: ', regs, 'Mem', m,   \</span>&#13;
<span>          'r[0] =', '{:016b}'.format(r[0]),                  \</span>&#13;
<span>          'c =', c, 'z =', z, '\n')</span>&#13;
<span>    print(progDisp[pcOld])</span>&#13;
<span>    if singleStep == 1: input(' &gt;&gt;&gt; ')</span></pre>&#13;
			<p lang="en-GB">The purpose of the previous program<a id="_idIndexMarker489"/><a id="_idIndexMarker490"/> is to demonstrate another way of categorizing instructions and using the number of operands to distinguish between instruction types, such as <strong class="source-inline">ADD r1,r2</strong> and <span class="No-Break"><strong class="source-inline">ADD r1,r2,r3</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-117" lang="en-GB"><a id="_idTextAnchor120"/>Summary</h1>&#13;
			<p lang="en-GB">In this chapter, we presented the TC1 simulator, which can take a text file in TC1 assembly language, convert it into machine code, and then execute it. TC1’s instruction set architecture is close to the classic RISC architecture with a register-to-register architecture (i.e., data operations take place on the contents of registers). The only memory operations permitted are loading a register from memory (or a literal) and storing a register <span class="No-Break">in memory.</span></p>&#13;
			<p lang="en-GB">The simulator has two basic components: an assembler that translates a mnemonic such as <strong class="source-inline">ADD r1,r2,r3</strong> into a 32-bit binary instruction, and an interpreter that reads the instruction, extracts the necessary information, and then executes <span class="No-Break">the instruction.</span></p>&#13;
			<p lang="en-GB">Some of the elements of TC1 are rather unusual. A free-format structure for the source code is provided; for example, you can write <strong class="source-inline">ADD r1,r2,r3</strong> or <strong class="source-inline">adD R1 r2 r3</strong> and both instructions will be happily accepted. Why? First, it was done to demonstrate the use of string processing in Python. Second, it makes it easier for the user to enter input in their chosen case. All input is automatically converted into uppercase to make the language case-free. Similarly, a comma or space is allowed as a separator between parameters. Finally, the need for <strong class="source-inline">[]</strong> brackets to indicate indirect addressing was removed. Users may enter <strong class="source-inline">LDRI r0,[r1]</strong> or <span class="No-Break"><strong class="source-inline">LDRI r0,r1</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Similarly, numbers can be entered in different forms (decimal, binary, or hexadecimal); for example, number bases can be indicated in <em class="italic">Motorola format</em> or <em class="italic">Python format</em>. Most real assemblers don’t permit <span class="No-Break">such luxury.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The first versions of TC1 required all addresses to be numeric; if you wanted to branch to line <strong class="source-inline">30</strong>, you had to write <strong class="source-inline">BRA 30</strong>. It was the remarkable power and ease of use of Python’s dictionary structure that made it so easy to include labels. All you have to do is recognize a label, pop it in the dictionary together with its value, and then, whenever you encounter that label, just look up its value in <span class="No-Break">the dictionary.</span></p>&#13;
			<p lang="en-GB">We also provided an example assembly language program to test TC1 and a short discussion of how we go about testing <span class="No-Break">various instructions.</span></p>&#13;
			<p lang="en-GB">Having designed TC1, we created a rather simplified version and called it TC1<span class="subscript">mini</span>. This simulator does not provide the same flexibility in writing instructions, and it does not have a large instruction set. It also does not encode the instruction into a binary form and then decode it again and execute it. It executes the assembly instruction directly (thanks one more to Python’s <span class="No-Break">dictionary mechanism).</span></p>&#13;
			<p lang="en-GB">At the end of this chapter, we provided yet another simplified computer simulator to both emphasize the structure of a computer simulator and provide an example of the way in which you can modify the <span class="No-Break">basic design.</span></p>&#13;
			<p lang="en-GB">In this key chapter, we introduced the TC1 computer simulator and presented its design. We also looked at variations of TC1 to help create a more complete picture of the simulator and assembler. In the next chapter, we will take things a step further and look at some more aspects of the simulator. We will describe several simulators that have <span class="No-Break">different architectures.</span></p>&#13;
		</div>&#13;
	</div></body></html>