- en: Chapter 4. Advanced Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a cancel button to forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding confirmation on form submit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching data dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding multiple forms in one page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting and blocking concurrent updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a form wizard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: De-normalizing data temporarily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing form labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `fileuploader.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading files using a `LOADed` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making image thumbnails from uploaded images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring upload progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto tooltip in forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color picker widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortening text fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multi-table forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-table form with references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-table update form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Star rating widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web2py comes with powerful functions for form generation. In this chapter, we
    provide examples of customization of forms from adding buttons to creating custom
    form widgets. We also provide examples of complex forms, such as wizards and multi-table
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a cancel button to forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe explains a method to add cancel buttons to forms, that is, a button
    that does not submit the forms, ignores any changes, and goes back to the previous
    page (or moves on to the next, depending on settings). The cancel button is really
    just a special case of a more general mechanism described herein to add buttons
    to your form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our recipe assumes a generic model.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The controller builds the form and button with the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add a button using the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last line shows how adding a `Cancel` button to a form is as simple as appending
    to the form. The index of the `SQLFORM`, where you choose append (or insert) your
    cancel button, determines where your button will appear on your page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here form`[0]` is the TABLE inside the form. `form[0]`[-1] is the last TR. form`[0][-1][1]`
    is column number one (the second TD in the last TR). The `_onclick` argument takes
    the user to the URL specified in the right-hand-side of the `window.location=
    statement.`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An equivalent notation to put the `Cancel` button after the `Submit` button
    would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the element method partially accepts CSS3 syntax.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, buttons of any type can be added into a form using this same mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you prefer more control and transparency over the creation of your `Cancel`
    button, or other buttons, then a custom view might be in order. However, you may
    not mix this method with a form that has been appended to. This example shows
    a custom form, where the form was created by the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The example assumes a generic table with fields numbered `1` to `N`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, cannot `field1...field3` must be actual field names. Once more, the `_onclick`
    action can be of any kind and flavor you like.
  prefs: []
  type: TYPE_NORMAL
- en: Adding confirmation on form submit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you want to double-check that the user is not accidentally submitting
    an incorrect form. You can do this by prompting the user for confirmation when
    he/she presses the submit button. This can be done in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way is by using `jQuery` to only edit the view that renders the form. In
    the view add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `confirm` is a JavaScript function that instructs the browser to create
    a confirmation dialog-box. If you press [**yes**] the `onclick` function returns
    true, and the form is submitted. If you press [**no**], the `onclick` function
    returns false, and the form is not submitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The same can be achieved by adding the string to the `onclick` attribute of
    the button when the form is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In web2py, there is an easy way to do it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we grab the `form.element(...)` using the `jQuery` syntax on the
    server-side (before the form is actually rendered in HTML), and we modify its
    `onclick` attribute (using the web2py notation with the preceding underscore).
  prefs: []
  type: TYPE_NORMAL
- en: Searching data dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web2py comes with a `crud.search` mechanism that allows you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, `form` is a search form and `records` are the result of the search. To
    understand how this works, we present in this recipe a simplified implementation
    of this function that you can further customize depending on your needs. Here,
    `db.things` is a table containing our things. The actual name of the table or
    its structure are not relevant here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all crate a new model, for example `dynamic_search.py`, and add the
    following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can use `dynamic_search` as a replacement for `crud.search`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can render this with the following view:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is how it looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/5467OS_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Embedding multiple forms in one page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe explains how to embed more than one form in a page. Doing so can
    increase user productivity by reducing HTTP calls, but carries a risk of cluttering
    the page layout.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate a page with multiple forms, we create a stripped-down system for
    storing a person's educational **Curriculum Vitae (CV)** . We begin by defining
    tables for schools, students, and the degrees they received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `index()` controller creates a form for each of the tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In a typical web2py controller, you would see only one `form=SQLFORM(...)` statement,
    and one `if form.accepts(...)` clause. Since we have three forms to render and
    process, we need three `SQLFORM(...)` statements, and three `if specific_form.accepts(...)`
    statements. Each form must be given a unique name, so that when one of the forms
    is POSTed, its respective `form.accepts` clause will be triggered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that forms about tables that contain references to other tables must be
    defined and processed in the order of the dependences. So if a new `school` or
    a new `student` is added, it shows the `education` form drop-down menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The simplest view to display all three forms on a single page is something
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If two or more forms are relative to the same table, the accepts must be passed
    a `formname` argument, and it must be different for the two forms.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another option consists of implementing the different forms and components
    loaded in the main (index) page using the `LOAD` command. Also notice that a submission
    of the `education` form does not affect the other two, while the other two affect
    the drop-down in the `education` form. This allows us to create different actions
    for each of the forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A view `views/default/index.html` embeds the three forms and traps the `education`
    form, so that when this form is submitted, the other two are not processed and
    reloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Multiple-form pages can also be created using the `FORM, SQLFORM.factory`, and
    `crud` statements, or a combination of all form-generating statements. Customized
    forms can be mixed with automatically-generated forms. There is no limit to the
    flexibility available to generating beautiful form-entry pages with web2py.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting and blocking concurrent updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider for example a wiki page. You open the page, edit it, and save it. It
    is possible that while you edit your page, somebody accesses the same page, and
    saves a new version of the page before you do. Your save action will result in
    the previous edits being lost.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can prevent concurrent edits by implementing a locking mechanism,
    but it is difficult to properly implement such a mechanism. What if a user opens
    a page for editing, leaves the browser open, and forgets about it? Everybody else
    would be prevented to edit the same page. Implementing a timeout re-introduces
    the original problem.
  prefs: []
  type: TYPE_NORMAL
- en: There is a simple solution. Every time you save a page (or any record for that
    matters) ask web2py to check whether the original record has been modified on
    the server since the moment when the record was originally retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: This is easy in web2py, as we will explain in the this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will consider, as an example, an application with following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following edit form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All you have to do is pass an extra attribute to `form.accepts, detect_record_change`,
    and check whether the record has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On `record-changed`, you can the write your own logic to deal with the conflict.
    The data on the server is always in the page (`page.title` and `page.body)`; the
    submitted values are in `request.vars.title` and `request.vars.body`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What about `crud` forms? It turns out that `crud.create` and `crud.update`
    forms have `detect_record_change=True`, by default (while it is `False` by default
    for normal SQLFORMs). Therefore, if a record is modified on the server, the newly
    submitted values are not saved. Yet crud forms do not provide any logic to deal
    with this situation, and leave it to the developer. For example, you can rewrite
    the previous example using `crud` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when a submission is rejected because the record changed on the
    server, a second submission will succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form wizard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to gather information from a user (for example, to populate a
    database or perform some other operation), yet we do not want to overwhelm the
    user with a very large form. A better approach consists of breaking the form into
    multiple pages that the user can navigate with a `[next]` button. Such an approach
    is a called a **wizard**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we assume we want to use a wizard to populate multiple fields in a table
    called `mytable:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It does not matter how many fields you have.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can handle the wizard with a single action. The action needs to know how
    many steps, which fields to query at each step, and where to go after the last
    step. Here is a possible implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can render the wizard with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is pretty simple, actually. The wizard action gets its page number from `request.args(0)`,
    and looks up in `STEPS` which fields to display. It uses `SQLFORM.factory` to
    build the partial form. Completed data from `form.vars` are stored in `session.wizard`.
    The last page instead of a tuple for the list of fields, contains a `URL('done')`,
    which is a string. When the wizard encounters this condition, it knows that it
    is time to insert the `session.wizard` variables in a new table and redirect them
    to the said URL. Notice that validation is done at each step for the fields that
    are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: De-normalizing data temporarily
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we consider the model described in the recipe *Efficient search
    by tag*, and we want to create insert, update forms, or a table `data` that allows
    the user to type in tags in a single input type text-box within the same form.
    In other words, we want to create a form that is automatically populated from
    the `data`, and all `tag` records referring to this `data` record. On submission,
    the form should update both the `data` and the `tag` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We assume our usual application, and the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will also assume the following function in `controllers/default.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to do this in two steps, each represented by a function. One function
    will assume we have new tags, delete old tags, and store the new tags. Another
    function will modify the crud form and add an input field containing the current
    tags. These two functions can then be used to modify our original form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `make_taggable` function takes a form object (forms are always derivatives
    of the `FORM` class), and injects into the form table a new row containing a label
    (`Tags:`), and an `INPUT` element. The `INPUT` value defaults to a string containing
    the current tags for the record.
  prefs: []
  type: TYPE_NORMAL
- en: When the form is submitted and accepted, `crud.update` ignores the `request.vars.tags`
    because it is not a field of the `db.data` table. If the form is accepted, the
    `onaccept` function is called, which points to `update_tags`. This function deletes
    the current tags and updates them.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this mechanism is very general, and there is nothing specific to
    the table `db.data`. In fact, the two functions `update_tags` and `make_taggable`
    can be used with any table, as long as it is referenced by a `db.tags` table,
    and both by `crud.update` and `crud.create` forms.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need a minor tweak if the tags field needs validation. We will assume
    that each tag name needs validation and the validator is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That is, each tag must contain at least two characters. The first one must be
    alphanumeric (`\w`), while the subsequent ones can be alphanumeric (`\w`), or
    dash (`\-`), or dot (`\.`), or forward slash (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to perform the validation, we need a smart validation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to force its call on validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If all the other fields are validated, the `onvalidation` function is called.
    This function loops over all the tags, and validates them using the `db.tag.name`
    validator. If one of them does not pass, the error is stored in `form.errors`,
    which is a `Storage` object. The presence of form errors prevents the form from
    being accepted. When the form is rendered, the `INPUT(...,_name='tags')` object
    will pick up the error from the form, and display it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Removing form labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use `SQLFORM` or crud, the generated form has labels. You can use
    the `formstyle` attribute of the form to decide how the labels should display:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table3cols` (on the left of the input widgets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`table2cols` (on the top of the input widgets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`divs` (on separate `divs` without a table, so you can position them by coordinates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ul` (on the left of the input widgets but using unordered lists instead of
    a table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yet sometimes you just want to hide labels.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way consists of generating the form and removing them from the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another method consists of using a custom form in the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The net effect is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using fileuploader.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will assume you have a database table to store uploaded files
    and you want to create an interface that allows users to upload multiple files
    using Ajax. `fileuploader.js` is a jQuery plugin that uses XHR for uploading multiple
    files, and displays a progress-bar. It works in Firefox 3.6+, Safari 4+, and Chrome,
    and falls back to the hidden iframe-based upload in other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First you need to download the plugin from [https://github.com/valums/file-uploader](http://https://github.com/valums/file-uploader),
    and place the file `fileuploader.js` into the application `static/js/`. Also,
    place the `fileuploader.css` into the application `static/css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we will assume you have a model, such as the following where you would
    store uploaded files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create the following upload action in `controllers/default.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `upload_callback` action will receive a file in the `request.body` with
    a name in `request.vars.qqfile`. It will rename it, store it, insert the new name
    in the database, and return success. The `upload` action, instead, does nothing
    but its view will display the jQuery plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin is very powerful, and it has many configuration options. To learn
    more about it we refer to its website: [http://valums.com/ajax-upload/](http://valums.com/ajax-upload/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A screenshot of the result can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5467OS_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Uploading files using a LOADed component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: web2py allows you to design pages in a modular way and LOAD components in the
    page using Ajax. A component is a subset of the page served by its own action.
    The component may, for example, render a form. The component traps form submission,
    and only refreshes itself upon submission. This magic is possible, thanks to the
    `static/js/web2py_ajax.js` utilities, and the LOAD helper. The problem is that
    this mechanism breaks for multi-part forms, and it does not work when the form
    in a LOADed component includes a file `upload` field.
  prefs: []
  type: TYPE_NORMAL
- en: To fix the problem, we need a jQuery plugin called `jquery.form.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, you need to download the required jQuery plugin from [http://github.com/malsup/form/raw/master/jquery.form.js?v2.43](http://github.com/malsup/form/raw/master/jquery.form.js?v2.43),
    and place it into the `static/js` folder as `jquery.form.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also assume the following models (same as previous recipe), but we
    will ignore authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And `views/default/index.html:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For any form but the one we created, this would work fine. It would not work
    with our form, because it contains an `upload` field. Notice that, in this recipe,
    we have used `user_signature=True` and `auth.requires_signature()` decorator.
    This will make sure that all URLs are signed, and any authentication/authorization
    that we apply to the parent page `index` will propagate to the components.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fix the problem, we need two steps. First we need to include the plugins
    by adding this line in `views/web2py_ajax.html:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to modify `static/js/web2py_ajax.js`, by adding the logic to capture
    the form and handle the uploads using the `ajaxForm` function, defined in `jqeury.form.js`.
    To achieve this, edit `web2py_ajax.js` and replace the function `web2py_trap_form`
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will handle the form upload using ajaxForm, only if the form contains an
    input element of the upload class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then we need to create a view for the action `component_form` called `views/default/component_form.load`
    that contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The script should not be necessary, but the `ajaxForm` function does not properly
    pass the headers back-and-forth to the server. Therefore, we need to explicitly
    include in the view, the logic to show `response.flash`, and execute `response.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Making image thumbnails from uploaded images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The title says it all. We want to upload images, and dynamically make thumbnails
    images from them. We will store the thumbnail references in the same records as
    the uploaded images.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the recipe, you must install the **Python Imaging Library** (PIL). You
    can find it at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pythonware.com/products/pil/](http://www.pythonware.com/products/pil/)'
  prefs: []
  type: TYPE_NORMAL
- en: That requires running web2py from source. As usual with Python, you can use
    `easy_install:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or from a Debian compatible distribution with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this purpose, we will modify the model used in the two previous recipes
    by adding a field called `thumbnail`, and we will ignore authentication, since
    it is an orthogonal issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Monitoring upload progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to create a JavaScript widget that displays
    a progress bar, and displays the upload progress. Our solution is server-based
    and more reliable than pure JavaScript solutions. Be aware that no browser can
    handle a file over 2GB.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe is based on the following recipes adapted to web2py:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.motobit.com/help/scptutl/pa98.htm](http://www.motobit.com/help/scptutl/pa98.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.djangosnippets.org/snippets/679/](http://www.djangosnippets.org/snippets/679/)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea consists of using `cache.ram` to store the progress server-side,
    and expose an action to query for the value of this variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is accomplished in two steps. In the first step, we choose an X-Progress-ID
    key, so that we can later retrieve the cache value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then we retrieve the upload total length from `cache.ram:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And the current uploaded length:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `myuuid` has to be replaced everywhere with a server generated UUID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's do it now in more detail with a concrete example. Consider this controller
    action in `controllers/default.py:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that this action servers two purposes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It creates and processes the form
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If called with `.json`, and passed an `X-Progress-ID`, it returns the length
    and uploaded variables in json
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we need to customize the form in `views/default/post.html:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The important part in this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It passes the `uuid` variable as a `GET` variable. The rest of the magic is
    done automatically by web2py, which reads this variables, computes the upload
    programs, and stores it in `cache.ram`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These lines is also important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: They tell web2py to use the same URL, but with the `.json` extension to get
    the length and uploaded values necessary to update the progress bar.
  prefs: []
  type: TYPE_NORMAL
- en: Auto tooltips in forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows you how to display tooltips in forms created through Crud
    or SQLFORM, using the field's `comment` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, you have to fill the `comment` attribute in the `field` definition
    where you want the tooltip to appear. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you do only this, the tip will appear on the right side of the field when
    the form is generated through Crud or SQLFORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that you can put HTML code in a comment using helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need a jQuery plugin to show the tip, so you may Google it and pick
    one. Or you can use this link: [http://jquery.bassistance.de/tooltip/jquery.tooltip.zip](http://jquery.bassistance.de/tooltip/jquery.tooltip.zip).
    See what it looks like here: [http://jquery.bassistance.de/tooltip/demo/](http://jquery.bassistance.de/tooltip/demo/).'
  prefs: []
  type: TYPE_NORMAL
- en: Extract `jquery.tooltip.min.js` in `static/js`, and `jquery.tooltip.css` to
    `static/css` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit your layout file, and in the head, before `{{include ''web2py_ajax.html''}}`
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you have this script on every page you want tooltips:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your comment column will be converted into nice tooltips.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also include this script in `web2py_ajax.html` or `layout.html`, to
    reuse the code. Or you may put this code in another file, and include it when
    needed; maybe this is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Color picker widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a table field that is supposed to contain a color (red, green,
    #ff24dc, and so on.) you may want to a widget to represent the feild that allows
    you to change/select the color by picking it from a color canvas. Here we show
    you how to build a widget to do just that.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to download `mColorPicker` from [http://www.bertera.it/software/web2py/mColorPicker-w2p.tgz](http://www.bertera.it/software/web2py/mColorPicker-w2p.tgz),
    and uncompress it in the `static/` folder of your application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define the widget in the file `models/plugin_colorpicker.py:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test it, create a table, and set the widget to our new `colorpicker` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create the form in your controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Shortening text fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we assume we have a table like the following, and we want to
    display a list of selected post bodies, but shortened.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to do this depends on whether the post contains HTML or wiki syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We'll consider HTML first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is done in three steps. In the controller we select the rows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we shorten by serializing and truncating the HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we display in the associated view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that TAG(`post.body`) parses the HTML, and then `flatten()` serializes
    the parsed HTML into text, omitting tags. We then extract the first 100 characters
    and add '...'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the body contained wiki syntax instead of HTML, then things are simpler,
    because we do not need to parse, and we could render the shortened text. Here
    we assume `MARKMIN` wiki syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the latter case, if you are using a relational database, the truncation can
    be done in the database server, thus reducing the amount of data transferred from
    `db` server to `db` client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: An even better approach is to store the shortened text in a different database
    field instead of shortening every time it is needed. This will result in a faster
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multi-table forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us consider the example case of a database table called bottles with fields
    representing guests bringing a bottle of wine to a tasting party. Each bottle
    can have one or two tasters. Rest assured, there is also a one-to-many relation
    for the tasting, but here we assume only two testers. Our goal is to create a
    custom form that allows inserting a description of the bottle, and fill in the
    names of the two tasters, even if the one-to-may relation is implemented through
    a separate table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will assume the following minimalist model, where the latter table implements
    the one-to-many relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we ask the `factory` to make us a form that contains a description of
    the bottle and a list field for the tasters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can handle the `accept` in the following two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We insert the `bottle` into the `db.bottle` table
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We insert each of the `tasters` into the `db.taster` table
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have to filter fields from `form.vars`, before we can perform
    a `db.bottle.insert`, because the form contains fields that do not belong to the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multi-table form with references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to modify the previous example, so that tasters must be registered
    users in the system, and we want to select them using drop-boxes. One easy way
    to do this is by setting a maximum number of tasters (here we choose `10)`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we need to modify the model, so that tasters is now a many-to-many link
    table (a bottle can have many tasters, and a taster can taste multiple bottles):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we change the action accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A naive way to render this form is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'But, it is possible to make it smarter using JavaScript. The idea consists
    of hiding all rows of the form related to tasters, but showing only the first
    one and then letting the following rows appear as needed. jQuery is a fantastic
    tool for this kind of manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all, we hide all rows, but `taster0`. Then we register `js` actions
    to events. When a field value changes, for example, `taster2`, we make the next
    one, `taster3`, appear `(i+1)`. Notice that if `taster3` is a field name, then
    `#no_table_taster3` is the ID of the `input/select` tag, and `#no_table_taster3__row`
    is the ID of the row in the table. This is a web2py convention. `no_table` comes
    from the fact that the form is generated by a `SQLFORM.factory`, and is not uniquely
    associated to a database table.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multi-table update form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we now want is to update a record of the `db.bottle` table and its associated
    `db.tasters` in one single form. This can be done using a mechanism similar to
    the one explained in the previous recipe. We need to do a little more work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will retain the same model structure as in the previous example,
    but we change the controller action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very much like the previous form, but the bottle fields are passed explicitly
    to the `SQLFORM.factory`, so that they can be pre-populated. The `tasters%i` fields
    are also pre-populated with existing tasters. When the form is submitted, the
    corresponding bottle record is updated, the past tasters are deleted, and new
    relations between the bottle and new tasters are inserted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is always more. The problem is that the JS code that hides empty rows,
    is now more complex. This is because, when editing the custom form, we do not
    want to hide rows that have a selected value. Here is a possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Can you figure out what it does?
  prefs: []
  type: TYPE_NORMAL
- en: Star rating widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we show you how to use the `jquery` star rating plugin, and
    integrate it with web2py.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to download the jQuery star rating widget from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://orkans-tmp.22web.net/star_rating/index.html](http://orkans-tmp.22web.net/star_rating/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the files under a new `static/stars` folder, so that `stars/ui.stars.js,
    stars/ui.stars.css`, and the necessary images provided by the plugin are in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a model file called `models/plugin_rating.py`, and in the file write
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a model. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the widget to the `rating_widget`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The plugin model must be executed before the above two lines or the `rating_widget`
    function will be undefined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important here that the field represented by the star rating be an integer
    with `IS_IN_SET(range(0,6))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how the `rating_plugin` uses a `UUID` to define the `id` attribute of
    the `DIV` that renders the widget. In this way, you can have more than one field
    using the `rating` plugin
  prefs: []
  type: TYPE_NORMAL
