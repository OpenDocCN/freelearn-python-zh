- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: 'SOLID Foundations: Building Robust Python Applications'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID基础：构建稳健的Python应用程序
- en: In the previous chapter, we explored Clean Architecture, a powerful approach
    to building maintainable, flexible, and scalable Python applications. We learned
    how it separates concerns into distinct layers, from core business logic to external
    interfaces, promoting independence and testability. Now, we’ll dive deeper into
    a set of principles that form the foundation of Clean Architecture. These are
    known as the **SOLID** principles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了清洁架构，这是一种构建可维护、灵活和可扩展的Python应用程序的强大方法。我们学习了它是如何将关注点分离到不同的层中，从核心业务逻辑到外部接口，促进独立性和可测试性。现在，我们将更深入地探讨构成清洁架构基础的一系列原则。这些被称为**SOLID原则**。
- en: The acronym SOLID ([https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID))
    represents five key principles of object-oriented programming and design. These
    principles, when applied correctly, help developers create software structures
    that are more understandable, flexible, and maintainable. In this chapter, we’ll
    explore each of these principles in depth, focusing on their application in Python
    and how they support the goals of Clean Architecture we discussed earlier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写SOLID（[https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID)）代表了面向对象编程和设计的五个关键原则。当正确应用时，这些原则有助于开发者创建更易于理解、灵活和可维护的软件结构。在本章中，我们将深入探讨这些原则的每个方面，重点关注它们在Python中的应用以及它们如何支持我们之前讨论的清洁架构目标。
- en: 'By the end of this chapter, you’ll have a clear understanding of the following
    aspects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将清楚地理解以下方面：
- en: The **Single Responsibility Principle** (**SRP**) and its role in creating focused,
    maintainable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责原则**（**SRP**）及其在创建专注、可维护的代码中的作用'
- en: The **Open–Closed Principle** (**OCP**) and how it enables building extensible
    systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）及其如何使构建可扩展的系统成为可能'
- en: The **Interface Segregation Principle** (**ISP**) and its application in Python’s
    duck-typed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）及其在Python的鸭子类型中的应用'
- en: environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: The **Liskov Substitution Principle** (**LSP**) and its importance in designing
    robust abstractions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）及其在设计稳健抽象中的重要性'
- en: The **Dependency Inversion Principle** (**DIP**) and its crucial role in supporting
    the Dependency Rule of Clean Architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）及其在支持清洁架构依赖规则中的关键作用'
- en: We’ll examine each principle through the lens of Python development, providing
    practical examples and best practices. You’ll learn how to apply these principles
    so that you can write cleaner, more maintainable Python code, setting a strong
    foundation for implementing Clean Architecture in your projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过Python开发的视角来审视每个原则，提供实际示例和最佳实践。你将学习如何应用这些原则，以便能够编写更干净、更易于维护的Python代码，为在你的项目中实施清洁架构打下坚实的基础。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, code examples in the chapter may be
    partially implemented. Complete versions of all examples can be found in the book’s
    accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分提供的代码示例均使用Python 3.13进行测试。为了简洁，章节中的代码示例可能只部分实现。所有示例的完整版本可以在本书配套的GitHub仓库[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)中找到。
- en: '**A note about the order in which we’ll cover the SOLID principles**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于我们将如何介绍SOLID原则的顺序的说明**'
- en: While the SOLID principles are traditionally presented in the order of their
    acronyms, this book adopts a more strategic sequence. We’ll cover SRP, OCP, then
    ISP, followed by LSP, and finally DIP. The start of each section will detail the
    relationship between its topic and the ones before.  This order creates a natural
    progression from writing clean, modular code to designing flexible, maintainable
    systems, directly supporting the goals of Clean Architecture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SOLID原则传统上按照其首字母缩写的顺序介绍，但本书采用了一种更战略性的顺序。我们将从SRP开始，然后是OCP，接着是ISP，然后是LSP，最后是DIP。每个部分的开始将详细说明其主题与之前主题之间的关系。这种顺序从编写干净的、模块化的代码到设计灵活、可维护的系统，直接支持清洁架构的目标。
- en: 'Crafting focused, maintainable code: the power of single responsibility'
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精心打造专注、可维护的代码：单一职责的力量
- en: In the hierarchy of software design, we have high-level architecture at the
    top, followed by components, modules, classes, and, finally, functions. The SOLID
    principles primarily operate at the module level, providing guidelines for creating
    well-structured, maintainable code. These module-level practices form the foundation
    for good architecture in general, including Clean Architecture. By applying SOLID
    principles, we can create loosely coupled, highly cohesive components that are
    easier to test, modify, and extend. These qualities are fundamental attributes
    of Clean Architecture.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计的层次结构中，我们顶部有高级架构，然后是组件、模块、类，最后是函数。SOLID原则主要在模块级别起作用，为创建结构良好、易于维护的代码提供指导。这些模块级实践构成了良好架构的基础，包括Clean
    Architecture。通过应用SOLID原则，我们可以创建松散耦合、高度内聚的组件，这些组件更容易进行测试、修改和扩展。这些品质是Clean Architecture的基本属性。
- en: Understanding single responsibility
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单一职责
- en: The Single Responsibility Principle (SRP) states that each software module should
    have one and only one reason to change ([https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）指出，每个软件模块应该只有一个且仅有一个变更的理由（[https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html](https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html)）。
- en: At first glance, the concept of *single responsibility* might seem straightforward.
    However, in practice, it can be challenging to define and implement. Let’s consider
    a simple example to illustrate this principle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，*单一职责*的概念可能看起来很简单。然而，在实践中，定义和实现它可能具有挑战性。让我们考虑一个简单的例子来说明这个原则。
- en: 'Let’s consider a `User` class intended to serve as an entity in a social media
    application. Recall that entities in Clean Architecture should represent core
    business objects with the most general rules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个旨在在社交媒体应用程序中作为实体的`User`类。回想一下，Clean Architecture中的实体应该代表具有最一般规则的核心业务对象：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initially, this `User` class might seem reasonable. It encapsulates user data
    and provides methods for common user actions in a social media application. However,
    while intended to be an entity, it deviates significantly from the Clean Architecture
    concept introduced in [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor015). Remember,
    entities should represent core business objects that encapsulate the most general
    and high-level rules, independent of specific application behaviors or external
    concerns. Our current `User` class violates these principles by taking on too
    many responsibilities:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这个`User`类可能看起来合理。它封装了用户数据，并为社交媒体应用程序中的常见用户操作提供了方法。然而，尽管旨在成为一个实体，但它与在[*第一章*](Chapter_01.xhtml#_idTextAnchor015)中引入的Clean
    Architecture概念有显著偏差。记住，实体应该代表封装最一般和最高级规则的核心业务对象，独立于特定的应用行为或外部关注点。我们当前的`User`类通过承担过多的职责违反了这些原则：
- en: User data management (handling `user_id`, `username`, and `email`)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据管理（处理`user_id`、`username`和`email`）
- en: Post-creation and management
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建后和管理工作
- en: Timeline generation
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线生成
- en: Profile updates
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人资料更新
- en: This structure combines core user data with application-specific behaviors,
    violating both SRP and the entity concept. As the product grows, this class could
    become a bottleneck, leading to development challenges, merge conflicts, and unintended
    side effects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构将核心用户数据与应用特定的行为相结合，违反了SRP和实体概念。随着产品的增长，这个类可能会成为瓶颈，导致开发挑战、合并冲突和意外的副作用。
- en: 'When identifying and separating responsibilities, consider these tips:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别和分离职责时，请考虑以下建议：
- en: Look for groups of methods operating on different subsets of the class’s data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找对类数据的不同子集进行操作的多个方法组
- en: Consider which aspects would be affected by different types of changes or requirements
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑不同类型的变更或需求会影响哪些方面
- en: 'Use the *reason to change* heuristic: if you can think of more than one reason
    for the class to change, consider splitting it'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*变更理由*启发式方法：如果你能想到一个类变更的多个理由，考虑将其拆分
- en: 'Let’s refactor our `User` class so that it adheres to SRP and the entity concept:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的`User`类，使其遵循SRP和实体概念：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This refactored version not only adheres more closely to SRP but also aligns
    with the concept of entities in Clean Architecture. Let’s break down the changes
    and their implications:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构版本不仅更紧密地遵循SRP，而且与Clean Architecture中的实体概念相一致。让我们分析这些更改及其影响：
- en: '`User`: Now stripped down to its essence, the User class truly embodies an
    entity. It encapsulates the most general and high-level rules, independent of
    specific application behaviors. It has a single responsibility: managing core
    user data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`User`: 现在简化到其本质，用户类真正体现了一个实体。它封装了最通用和最高级的规则，独立于特定应用行为。它只有一个职责：管理核心用户数据。'
- en: '`PostManager`: This takes on the focused responsibility of creating and managing
    posts.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostManager`: 这承担了创建和管理帖子的专注职责。'
- en: '`TimelineService`: This handles timeline generation logic independently.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimelineService`: 这处理时间线生成逻辑的独立部分。'
- en: '`ProfileManager`: This manages profile updates, further reducing the `User`
    class’s responsibilities.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProfileManager`: 这管理个人资料更新，进一步减少 `User` 类的职责。'
- en: 'Each of these classes now has a clear, focused role that adheres to SRP and
    promotes separation of concerns. This refactoring brings several benefits:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类现在都有一个清晰、专注的角色，遵循 SRP 并促进关注点的分离。这次重构带来了几个好处：
- en: '**Improved maintainability and testability**: Each class has a single, well-defined
    purpose, making it easier to understand, modify, and test independently'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可维护性和可测试性**：每个类都有一个单一、明确的目的，这使得它更容易理解、修改和独立测试'
- en: '**Greater flexibility and reduced coupling**: We can extend or modify one aspect
    of the system without affecting others, making our codebase more resilient to
    change'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更大的灵活性和减少耦合**：我们可以扩展或修改系统的一个方面，而不会影响其他方面，这使得我们的代码库更能适应变化'
- en: This modular and flexible design aligns well with Clean Architecture principles,
    creating clear boundaries between different components of our system. While it
    might seem like overkill for a small application, it sets a foundation for a more
    maintainable and scalable system as it grows.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化和灵活的设计与清洁架构原则相吻合，为我们的系统不同组件之间创造了清晰的边界。虽然对于小型应用程序来说可能有些过度，但它为更可维护和可扩展的系统奠定了基础。
- en: Remember, most of us work on applications we intend to be successful. With success
    come feature requests, pivots, and scaling challenges. Preparing for this growth
    from the start by applying SRP judiciously can save significant refactoring effort
    later, creating a structure that’s both flexible and comprehensible as your system
    evolves.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们中的大多数人都在开发我们希望成功的应用程序。随着成功而来的是功能请求、转型和扩展挑战。从一开始就通过明智地应用 SRP 为这种增长做准备，可以在以后节省大量的重构工作，创建一个随着系统发展既灵活又可理解的架构。
- en: SRP and testing
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SRP 和测试
- en: 'Classes with a single responsibility are generally easier to test as they have
    fewer dependencies and edge cases. This facilitates the creation of testable systems,
    a key tenet of Clean Architecture. For example, testing `PostManager` becomes
    straightforward:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 具有单一职责的类通常更容易测试，因为它们有更少的依赖和边缘情况。这促进了可测试系统的创建，这是清洁架构的一个关键原则。例如，测试 `PostManager`
    变得简单：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This test case showcases the clarity SRP brings to unit testing. Here, `PostManager`,
    with its single responsibility, is easily tested in isolation without complex
    setup or mocking. We can verify all essential aspects of post-creation straightforwardly.
    This simplicity in testing is a direct benefit of SRP and aligns with Clean Architecture
    principles. As systems become more complex, the ability to test individual responsibilities
    in isolation becomes crucial. It allows us to maintain high code quality, catch
    issues early, and evolve our test suite alongside the system, ensuring the correctness
    of each focused component without the need to resort to complex integration tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试案例展示了 SRP 为单元测试带来的清晰性。在这里，具有单一职责的 `PostManager` 可以在隔离状态下轻松测试，无需复杂的设置或模拟。我们可以直接验证创建帖子后的所有基本方面。这种测试的简单性是
    SRP 的直接好处，并与清洁架构原则相符。随着系统的日益复杂，独立测试单个职责的能力变得至关重要。它使我们能够保持高代码质量，早期发现问题，并随着系统的发展，与测试套件一起进化，确保每个专注组件的正确性，而无需依赖复杂的集成测试。
- en: Balancing the SRP
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡 SRP
- en: While SRP is a powerful principle, it’s important not to take it to extremes.
    Over-applying SRP can lead to an explosion of tiny classes and functions, which
    can make the overall system harder to understand and navigate. Misinterpreting
    SRP *as a class or module that should do only one thing* can lead to the creation
    of too many tiny classes. The principle is about single reasons to change, not
    strictly about single actions performed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SRP是一个强大的原则，但重要的是不要将其推向极端。过度应用SRP可能导致大量微小类和函数的爆炸式增长，这可能会使整个系统更难以理解和导航。错误地将SRP理解为“应该只做一件事的类或模块”可能会导致创建过多的微小类。这个原则是关于单一变更原因，而不是严格关于单一执行动作。
- en: The key is to find a balance, where each unit of code (be it a class, function,
    or module) has a clear, cohesive purpose, without becoming so granular that the
    overall structure becomes fragmented. Remember, the goal of SRP is to make your
    code more maintainable and understandable. If splitting a class or function makes
    the overall system harder to understand, it might not be the right move. Use your
    judgment and always consider the context of your specific application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要找到一个平衡点，其中每个代码单元（无论是类、函数还是模块）都有一个清晰、一致的目的，而不会变得过于细分以至于整体结构变得碎片化。记住，SRP的目标是使你的代码更易于维护和理解。如果拆分一个类或函数使整个系统更难以理解，可能不是正确的做法。运用你的判断力，并始终考虑你特定应用的上下文。
- en: In summary, SRP provides a powerful foundation for creating maintainable and
    flexible code. By ensuring each module or class has a single, well-defined purpose,
    we can set the stage for systems that are easier to understand, modify, and extend.
    As we’ve seen, the key is finding the right balance for your specific context
    to avoid the extremes of overly complex classes or an explosion of tiny, fragmented
    components.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，SRP为创建可维护和灵活的代码提供了一个强大的基础。通过确保每个模块或类都有一个单一、明确的目的，我们可以为易于理解、修改和扩展的系统奠定基础。正如我们所看到的，关键是找到适合你特定上下文的正确平衡，以避免过度复杂的类或微小、碎片化组件的爆炸式增长。
- en: This principle of balanced application extends throughout Clean Architecture.
    Each pattern and abstraction layer we explore offers specific benefits like improved
    testability, easier maintenance, and enhanced flexibility, but also adds complexity.
    As you progress through this book, consider each pattern through the lens of your
    specific needs. A startup building an MVP might defer some abstractions until
    growth demands them, while an enterprise system might benefit from the full architectural
    approach from day one. With SRP as our starting point, we’re now ready to explore
    how OCP builds upon this foundation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种平衡应用的原则贯穿于整洁架构的始终。我们探索的每个模式和抽象层都提供了特定的好处，如提高可测试性、易于维护和增强灵活性，但也增加了复杂性。随着你阅读本书的进展，请通过你具体的需求来审视每个模式。一个构建最小可行产品（MVP）的初创公司可能会推迟一些抽象，直到增长需求出现，而一个企业级系统可能从第一天起就受益于完整的架构方法。以单一职责原则（SRP）作为我们的起点，我们现在准备探索开放封闭原则（OCP）是如何在这个基础上构建的。
- en: 'Building extensible systems: embracing open–closed design in Python'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可扩展系统：在Python中拥抱开放封闭设计
- en: 'Having explored SRP and its role in creating focused, maintainable classes,
    we’ll turn our attention to another crucial aspect of robust software design:
    extensibility. The Open–Closed Principle (OCP), introduced by Bertrand Meyer in
    1988 ([https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)),
    builds upon the foundation laid by SRP. It guides us in creating systems that
    are said to be *open for extension but closed for modification*. This means that
    we should be able to add new functionality without changing existing code, essentially
    extending our system’s behavior through new code rather than modifying what’s
    already in place.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了SRP及其在创建专注、可维护的类中的作用后，我们将把注意力转向稳健软件设计的另一个关键方面：可扩展性。开放封闭原则（OCP）由伯特兰·迈耶于1988年提出（[https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)），它建立在SRP的基础上。它指导我们创建所谓的“对扩展开放但对修改封闭”的系统。这意味着我们应该能够添加新功能而不改变现有代码，本质上是通过新代码扩展我们的系统行为，而不是修改现有的内容。
- en: 'OCP is a powerful tool in our SOLID principles toolkit as it works in harmony
    with SRP to create modular, flexible code. It addresses a common challenge in
    software development: how to add new features or behaviors without altering existing,
    tested code. By adhering to OCP, we can design our Python classes and modules
    so that they can be easily extended, reducing the risk of introducing bugs when
    adding new functionality.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: OCP是我们SOLID原则工具箱中的一个强大工具，因为它与SRP协同工作，创建模块化、灵活的代码。它解决了软件开发中一个常见的挑战：如何在不改变现有、经过测试的代码的情况下添加新功能或行为。通过遵循OCP，我们可以设计我们的Python类和模块，以便它们可以轻松扩展，降低在添加新功能时引入错误的风险。
- en: In the context of Clean Architecture, OCP plays a vital role in creating systems
    that can accommodate change over time. It supports the creation of stable, core
    business logic that remains untouched as we add new features or adapt to new technologies.
    As we explore OCP in Python, we’ll see how it contributes to building maintainable,
    scalable applications that align with Clean Architecture principles.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clean Architecture的背景下，OCP在创建能够随着时间的推移适应变化的系统中起着至关重要的作用。它支持创建稳定的核心业务逻辑，在添加新功能或适应新技术时保持不变。当我们探索Python中的OCP时，我们将看到它如何有助于构建符合Clean
    Architecture原则的易于维护、可扩展的应用程序。
- en: 'Let’s explore this principle using a practical example of an area calculator
    for different shapes. Consider the following initial implementation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个不同形状面积计算器的实际例子来探讨这个原则。考虑以下初始实现：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have a simple `AreaCalculator` class that can calculate the area of
    rectangles and circles. However, this design violates OCP. If we want to add support
    for a new shape, such as a triangle, we’d need to modify the `calculate_area`
    method of the `AreaCalculator` class. This modification could potentially introduce
    bugs in the existing working code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个简单的`AreaCalculator`类，它可以计算矩形和圆的面积。然而，这种设计违反了OCP原则。如果我们想添加对新形状的支持，例如三角形，我们就需要修改`AreaCalculator`类的`calculate_area`方法。这种修改可能会在现有正常工作的代码中引入错误。
- en: 'To adhere to OCP, we need to restructure our code so that we can add new shapes
    without modifying the existing `AreaCalculator` class. Here’s how we can refactor
    this code so that it embraces OCP:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循OCP原则，我们需要重构我们的代码，以便在不修改现有的`AreaCalculator`类的情况下添加新的形状。以下是我们可以如何重构这段代码以实现OCP原则：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this refactored version, we’ve made several key changes to adhere to the
    concept of OCP:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构版本中，我们为了遵循OCP的概念进行了几个关键更改：
- en: We introduced an abstract `Shape` class with an `area` method. This serves as
    the interface that all shapes must implement.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了一个具有`area`方法的抽象`Shape`类。这作为所有形状必须实现的接口。
- en: Each concrete shape (`Rectangle`, `Circle`, and now `Triangle`) inherits from
    `Shape` and implements its own `area` method.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个具体形状（`Rectangle`、`Circle`和现在的`Triangle`）都从`Shape`继承，并实现了自己的`area`方法。
- en: The `AreaCalculator` class now depends on the abstract `Shape` class rather
    than concrete implementations. It calls the `area` method on any shape object
    it receives, without needing to know the specific type of shape.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AreaCalculator`类现在依赖于抽象的`Shape`类，而不是具体的实现。它对任何接收到的形状对象调用`area`方法，而无需知道具体的形状类型。'
- en: We can now add new shapes (such as `Triangle`) without modifying the `AreaCalculator`
    class. The system is open for extension but closed for modification.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在可以添加新的形状（如`Triangle`），而不需要修改`AreaCalculator`类。系统对扩展是开放的，但对修改是封闭的。
- en: 'This refactored design exemplifies OCP in action, while also maintaining adherence
    to SRP. Let’s examine the key aspects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构设计展示了OCP的实际应用，同时也保持了遵循SRP。让我们检查关键方面：
- en: '**Open for extension**: We can add new shapes (such as `Triangle`) without
    modifying existing code. Each shape class has the single responsibility of defining
    its properties and calculating its own area.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对扩展开放**：我们可以添加新的形状（如`Triangle`），而不需要修改现有代码。每个形状类都有单一的责任，即定义其属性并计算其自身的面积。'
- en: '**Closed for modification**: The core `AreaCalculator` class remains unchanged
    when adding new shapes, demonstrating closure to modification.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对修改封闭**：在添加新形状时，核心的`AreaCalculator`类保持不变，这展示了对其修改的封闭性。'
- en: '**Polymorphism**: By using an abstract `Shape` class, we can treat different
    shape objects uniformly. This allows `AreaCalculator` to work with any shape through
    a common interface, without knowing specific implementations.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**：通过使用抽象的`Shape`类，我们可以统一处理不同的形状对象。这使得`AreaCalculator`可以通过一个公共接口与任何形状一起工作，而无需了解具体的实现。'
- en: 'This design aligns perfectly with Clean Architecture’s goals:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计完美符合Clean Architecture的目标：
- en: '**Extensibility**: New requirements (such as adding shapes) can be met without
    disturbing existing, tested code'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：在不干扰现有已测试代码的情况下，可以满足新的需求（如添加形状）'
- en: '**Isolation of core logic**: Each shape’s area calculation is protected from
    external changes'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心逻辑的隔离**：每个形状的面积计算受到外部变化的保护'
- en: '**Testability**: The clear separation of responsibilities facilitates straightforward
    unit testing'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：职责的清晰分离促进了直接的单元测试'
- en: By combining OCP and SRP, we’ve created a foundation for building larger, more
    complex systems that can evolve without becoming brittle. This example, though
    small, demonstrates how Clean Architecture principles can be applied effectively
    in Python to create systems that are well-organized, maintainable, and adaptable
    to changing requirements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合OCP（开闭原则）和SRP，我们为构建更大、更复杂的系统奠定了基础，这些系统可以在不变得脆弱的情况下进行演化。这个例子虽然很小，但展示了如何在Python中有效地应用Clean
    Architecture原则来创建组织良好、可维护且能够适应变化需求的系统。
- en: 'ISP: tailoring interfaces to clients'
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ISP：根据客户端定制接口
- en: As we delve deeper into the SOLID principles, we’ve seen how SRP promotes focused
    classes and OCP enables extensibility. Now, we’ll turn our attention to the interfaces
    these classes expose to the world. The Interface Segregation Principle (ISP) ([https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle))
    guides us in creating lean, purpose-specific interfaces that cater to the exact
    needs of their clients. This principle is crucial for developing flexible, modular
    Python code that’s easy to understand and maintain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入探讨SOLID原则，我们已经看到SRP如何促进专注的类和OCP如何实现可扩展性。现在，我们将把注意力转向这些类向世界暴露的接口。接口分离原则（ISP）([https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)）指导我们创建精简、目的特定的接口，以满足其客户端的精确需求。这个原则对于开发灵活、模块化的Python代码至关重要，这些代码易于理解且易于维护。
- en: ISP not only builds upon the concept of single responsibility introduced by
    SRP but also applies it at the interface level. It advocates for designing interfaces
    that are narrowly focused on specific tasks, rather than interfaces that attempt
    to encompass too many responsibilities. This approach leads to more flexible and
    maintainable systems as clients only depend on the methods they actually use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ISP不仅建立在SRP（单一职责原则）引入的单一职责概念之上，而且在接口级别上应用它。它主张设计专注于特定任务的接口，而不是试图包含过多职责的接口。这种方法导致更灵活、可维护的系统，因为客户端只依赖于它们实际使用的那些方法。
- en: 'To illustrate the importance of ISP and how it relates to classes doing too
    much, let’s consider an example of a multimedia player system:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明ISP的重要性以及它与过度承担职责的类之间的关系，让我们考虑一个多媒体播放器系统的例子：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This design violates ISP by trying to do too much (excess of methods). Let’s
    examine the issues that arise from this approach:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计违反了ISP，试图做太多（方法过多）。让我们检查由此产生的问题：
- en: '**Unnecessary methods and a confusing API**: Here, `MusicPlayer` is forced
    to implement `apply_video_filter`, which doesn’t make sense for an audio-only
    player. This leads to awkward implementations and potential runtime errors. Moreover,
    users of the `MusicPlayer` class see methods such as `apply_video_filter` in the
    interface, which can lead to confusion about what the class can actually do. This
    lack of clarity makes the class harder to use correctly and increases the risk
    of misuse.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不必要的方法和混乱的API**：在这里，`MusicPlayer`被迫实现`apply_video_filter`，这对于一个仅播放音频的播放器来说是没有意义的。这导致尴尬的实现和潜在的运行时错误。此外，`MusicPlayer`类的用户在接口中看到`apply_video_filter`这样的方法，这可能导致对类实际能做什么的困惑。这种缺乏清晰性使得类更难正确使用，并增加了误用的风险。'
- en: '**Lack of modularity**: The interface doesn’t allow for easy creation of specialized
    players. For instance, we can’t easily create a lyrics-only display without also
    implementing media playback methods. This rigid structure limits extensibility
    and reuse, making it difficult to adapt the system to new requirements or use
    cases.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏模块化**：接口不允许轻松创建专门的播放器。例如，我们无法轻松创建一个仅显示歌词的显示，而不需要实现媒体播放方法。这种僵化的结构限制了可扩展性和重用性，使得适应新的需求或用例变得困难。'
- en: '**Increased maintenance burden**: If we want to add more video-specific features
    to the `MultimediaPlayer` interface later, we’ll need to update all implementing
    classes each time, even though these features aren’t relevant to some of them.
    This makes the system more difficult to evolve and increases the risk of introducing
    bugs when making changes.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加维护负担**：如果我们以后想向`MultimediaPlayer`接口添加更多视频特定功能，每次都需要更新所有实现类，即使这些功能对其中一些类并不相关。这使得系统更难进化，并增加了在更改时引入错误的风险。'
- en: These issues demonstrate how violating ISP can lead to inflexible, confusing,
    and hard-to-maintain code. By addressing these problems, we can create a more
    modular, flexible, and easy-to-use design.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题展示了违反ISP如何导致代码不灵活、混乱且难以维护。通过解决这些问题，我们可以创建一个更模块化、灵活且易于使用的架构。
- en: 'Let’s refactor this design so that it adheres to ISP:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构这个设计，使其符合ISP：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this refactored design, we’ve leveraged Python’s **abstract base classes**
    (**ABCs**) to create a set of focused interfaces. This approach allows us to define
    clear contracts for different functionalities without forcing classes to implement
    methods they don’t need. By breaking down the original monolithic interface into
    smaller, more specific ones, we’ve created a flexible structure that adheres to
    ISP. Let’s examine the key components of this refactored design:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构设计中，我们利用Python的**抽象基类**（**ABCs**）创建了一组专注的接口。这种方法允许我们为不同的功能定义清晰的合同，而无需强迫类实现它们不需要的方法。通过将原始的单个接口分解成更小、更具体的接口，我们创建了一个符合ISP的灵活结构。让我们来检查这个重构设计的关键组件：
- en: '`MediaPlayable`: This interface focuses solely on playing and stopping media,
    a core functionality shared by all media players'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaPlayable`：这个接口专注于播放和停止媒体，这是所有媒体播放器共享的核心功能'
- en: '`LyricsDisplayable`: By separating the lyrics display into its own interface,
    we’ve ensured that classes that don’t support lyrics (such as `VideoPlayer`) aren’t
    forced to implement unnecessary methods'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LyricsDisplayable`：通过将歌词显示分离到其自己的接口中，我们确保了不支持歌词的类（如`VideoPlayer`）不会被强迫实现不必要的方法'
- en: '`VideoFilterable`: This interface isolates video-specific functionality, preventing
    audio-only players from implementing irrelevant methods'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VideoFilterable`：这个接口隔离了视频特定功能，防止仅支持音频的播放器实现不相关的功能'
- en: The concrete classes (`MusicPlayer`, `VideoPlayer`, and `BasicAudioPlayer`)
    now implement only the interfaces relevant to their functionality. This design
    allows for easy creation and use of different types of media player. For example,
    `MusicPlayer` can play media and display lyrics, while `BasicAudioPlayer` only
    needs to implement media playback. This flexibility makes it simple to create
    new types of player by combining the relevant interfaces, without the burden of
    implementing unnecessary methods.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在具体的类（`MusicPlayer`、`VideoPlayer`和`BasicAudioPlayer`）仅实现与其功能相关的接口。这种设计使得创建和使用不同类型的媒体播放器变得简单。例如，`MusicPlayer`可以播放媒体并显示歌词，而`BasicAudioPlayer`只需实现媒体播放功能。这种灵活性使得通过组合相关接口创建新类型的播放器变得简单，无需承担实现不必要方法的负担。
- en: 'Let’s summarize the overall benefits of ISP:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结ISP的整体好处：
- en: '**Reduced coupling**: Classes depend only on the methods they actually use'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低耦合**：类只依赖于它们实际使用的功能'
- en: '**Improved maintainability**: Changes to one aspect (for example, video filtering)
    don’t affect unrelated classes'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可维护性**：对某一方面的更改（例如，视频过滤）不会影响无关的类'
- en: '**Enhanced flexibility**: We can easily create new types of player by combining
    relevant interfaces'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强灵活性**：我们可以轻松地通过组合相关接口创建新类型的播放器'
- en: '**Better testability**: We can mock interfaces more easily by focusing tests
    on specific functionalities'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的可测试性**：我们可以通过将测试集中在特定功能上来更容易地模拟接口'
- en: This ISP-driven design supports Clean Architecture by creating clear, focused
    interfaces that align with specific use cases. Recall from [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor015)
    that use cases in Clean Architecture represent application-specific business rules,
    describing how and when the system uses entities to achieve its goals. ISP facilitates
    this by allowing us to define precise interfaces for each use case. For instance,
    the `LyricsDisplayable` interface directly supports a *display lyrics* use case
    without burdening other player types. This approach allows for a more modular
    system where components can evolve independently, making it easier to implement
    new use cases or modify existing ones without affecting unrelated parts of the
    system. As a result, our application can adapt more readily to changing requirements
    while maintaining the integrity of its core business logic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种由 ISP 驱动的设计通过创建与特定用例一致的清晰、专注的接口来支持 Clean Architecture。回想一下[第 1 章](Chapter_01.xhtml#_idTextAnchor015)，在
    Clean Architecture 中，用例代表特定于应用程序的业务规则，描述系统如何以及何时使用实体来实现其目标。ISP 通过允许我们为每个用例定义精确的接口来促进这一点。例如，`LyricsDisplayable`
    接口直接支持*显示歌词*用例，而不会给其他播放器类型带来负担。这种方法允许构建更模块化的系统，其中组件可以独立发展，使得实现新的用例或修改现有用例而不会影响系统的不相关部分变得更加容易。因此，我们的应用程序可以更容易地适应变化的需求，同时保持其核心业务逻辑的完整性。
- en: In conclusion, ISP guides us in creating more flexible, maintainable systems
    by encouraging the design of focused, specific interfaces. By applying ISP alongside
    SRP and OCP, we can create Python code that’s easier to understand, test, and
    extend. ISP helps us avoid the pitfall of classes trying to *do too much*, just
    as OCP helps us avoid classes trying to *be too many things*. Together, these
    principles support Clean Architecture’s goals, helping us create systems that
    can adapt to changing requirements while maintaining a clear, modular structure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，ISP 通过鼓励设计专注、具体的接口，引导我们创建更灵活、可维护的系统。通过将 ISP 与 SRP 和 OCP 结合使用，我们可以创建易于理解、测试和扩展的
    Python 代码。ISP 帮助我们避免类试图*做太多*的陷阱，正如 OCP 帮助我们避免类试图*成为太多事物*的陷阱。这些原则共同支持了 Clean Architecture
    的目标，帮助我们创建能够适应变化需求同时保持清晰、模块化结构的系统。
- en: 'From rigid to flexible: rethinking inheritance and interfaces in Python'
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从僵化到灵活：在 Python 中重新思考继承和接口
- en: As we’ve explored the Single Responsibility, Open–Closed, and Interface Segregation
    Principles, we’ve built a foundation for creating modular, extensible, and focused
    code. These principles guide us in structuring our classes and interfaces to be
    more maintainable and adaptable. Now, we turn our attention to the Liskov Substitution
    Principle (LSP), which complements and reinforces the principles we’ve discussed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨了单一职责、开闭和接口分离原则之后，我们为创建模块化、可扩展和专注的代码奠定了基础。这些原则指导我们构建类和接口的结构，使其更易于维护和适应。现在，我们将注意力转向
    Liskov 替换原则（LSP），它补充并加强了我们所讨论的原则。
- en: While SRP guides us in creating focused, cohesive classes, OCP allows us to
    extend our code without modifying existing components, and ISP promotes the creation
    of specific, client-tailored interfaces. LSP ensures that our abstractions are
    well-formed, and our components are truly interchangeable. This principle is crucial
    for creating robust, flexible systems by ensuring that our inheritance hierarchies
    behave predictably.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SRP 引导我们创建专注、内聚的类，OCP 允许我们在不修改现有组件的情况下扩展我们的代码，而 ISP 促进创建特定、客户定制的接口。LSP 确保我们的抽象是良好形成的，并且我们的组件确实是可互换的。这一原则对于通过确保我们的继承层次结构具有可预测的行为来创建健壮、灵活的系统至关重要。
- en: In the context of Clean Architecture, LSP plays a vital role in supporting the
    flexibility promised by OCP and the focused design encouraged by SRP and ISP.
    As we delve into LSP, we’ll see how it works in concert with the other SOLID principles
    to create a system that’s not just modular, but also reliable and intuitive to
    use and extend.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clean Architecture 的背景下，LSP 在支持 OCP 承诺的灵活性和 SRP 及 ISP 鼓励的专注设计方面发挥着至关重要的作用。当我们深入研究
    LSP 时，我们将看到它是如何与其他 SOLID 原则协同工作，以创建一个不仅模块化，而且可靠且易于使用和扩展的系统。
- en: Understanding LSP
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 LSP
- en: The Liskov Substitution Principle (LSP), introduced by Barbara Liskov in 1987
    ([https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)),
    provides a guideline for creating inheritance hierarchies that behave predictably
    and intuitively. At its core, LSP is about maintaining the integrity of a base
    class’s contract throughout its inheritance hierarchy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Liskov替换原则（LSP）是由Barbara Liskov在1987年提出的（[https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)），为创建行为可预测且直观的继承层次结构提供了指导。在其核心，LSP是关于在整个继承层次结构中维护基类合约的完整性。
- en: 'Here’s what LSP tells us:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是LSP告诉我们的内容：
- en: A base class defines a contract that users of the class can rely on. This contract
    consists of a set of behaviors and properties.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类定义了一个用户可以依赖的合约。这个合约由一系列行为和属性组成。
- en: Subclasses shouldn’t alter or be destructive to this contract. They must honor
    the promises made by the base class.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类不应更改或破坏这个合约。它们必须遵守基类做出的承诺。
- en: Subclasses can extend or refine the contract, making it more specific to themselves,
    but they can’t reduce or violate the original contract.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类可以扩展或细化合约，使其更具体，但它们不能减少或违反原始合约。
- en: In other words, if we have a base class, any of its subclasses should be able
    to stand in for that base class without breaking the program or violating the
    expectations set by the base class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们有一个基类，那么它的任何子类都应该能够代替这个基类，而不会破坏程序或违反基类设定的期望。
- en: 'This principle is crucial for several reasons:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则有几个关键原因：
- en: '**Predictability**: When LSP is followed, users of a base class can trust that
    all derived classes will behave in a way that’s consistent with the base class.
    This makes the system more predictable and easier to reason about.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：当遵循LSP时，基类的用户可以信任所有派生类将以与基类一致的方式行为。这使得系统更具可预测性，更容易推理。'
- en: '**Flexibility**: LSP allows us to use polymorphism effectively. We can write
    code that works with the base class and trust that it will work correctly with
    any of its subclasses.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：LSP允许我们有效地使用多态。我们可以编写与基类一起工作的代码，并相信它将正确地与任何子类一起工作。'
- en: '**Extensibility**: By ensuring that subclasses respect the base class contract,
    we create a system that’s easier to extend. New subclasses can be added without
    fear of breaking existing code that relies on the base class.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：通过确保子类遵守基类合约，我们创建了一个更容易扩展的系统。可以添加新的子类，而不用担心会破坏依赖于基类的现有代码。'
- en: However, adhering to LSP isn’t always straightforward. It requires careful thought
    about how we model our objects and their relationships. Let’s look at an example
    to see how violating LSP can lead to problems, and how we can refactor our code
    to follow this principle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，遵循LSP（里氏替换原则）并不总是直截了当的。它需要我们仔细思考如何建模我们的对象及其关系。让我们通过一个例子来看看违反LSP可能导致的问题，以及我们如何重构我们的代码来遵循这一原则。
- en: The pitfalls of rigid hierarchies
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刻板层次结构的陷阱
- en: 'Consider a system for managing different vehicle types and their fuel consumption:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用于管理不同车辆类型及其燃料消耗的系统：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This `Vehicle` class represents a typical fuel-based vehicle. Now, let’s introduce
    an `ElectricCar` class that inherits from `Vehicle`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Vehicle`类代表了一个典型的基于燃料的车辆。现在，让我们引入一个继承自`Vehicle`的`ElectricCar`类：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At first glance, this might seem like a reasonable approach. However, it leads
    to several issues:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这可能会被认为是一个合理的做法。然而，它导致了一些问题：
- en: It violates LSP because `ElectricCar` can’t be substituted for `Vehicle` without
    causing incorrect behavior
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它违反了LSP，因为`ElectricCar`不能替代`Vehicle`而不引起不正确的行为
- en: The `ElectricCar` class changes the meaning of *fuel consumption*, violating
    the contract established by `Vehicle`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElectricCar`类改变了*燃料消耗*的含义，违反了`Vehicle`类建立的合约'
- en: It creates a fragile design where functions that work with `Vehicle` may silently
    produce incorrect results with `ElectricCar`
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个脆弱的设计，其中与`Vehicle`一起工作的函数可能会在`ElectricCar`上默默地产生不正确的结果
- en: 'To illustrate this, consider the following function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下函数：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This `drive_vehicle` function works correctly for `Vehicle` but produces misleading
    output for `ElectricCar`. These problems stem from forcing `ElectricCar` into
    an inheritance relationship with `Vehicle`, even though an electric car’s energy
    consumption works differently from a fuel-based vehicle. This is a common pitfall
    when modeling *is-a* relationships too literally.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`drive_vehicle`函数对`Vehicle`类工作正常，但对`ElectricCar`类产生误导性的输出。这些问题源于将`ElectricCar`强制与`Vehicle`建立继承关系，尽管电动汽车的能量消耗与基于燃料的车辆不同。这是在建模“是”关系时过于字面化的一种常见陷阱。
- en: Embracing flexibility with LSP
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采用LSP（里氏替换原则）的灵活性
- en: 'Let’s refactor this so that it adheres to LSP. We’ll start by defining an abstract
    base class for power sources:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构它，使其符合LSP（里氏替换原则）。我们首先定义一个电源的抽象基类：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can create specific implementations for different types of power source:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为不同类型的电源创建具体的实现：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With these power sources defined, we can create a more flexible `Vehicle` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些电源后，我们可以创建一个更灵活的`Vehicle`类：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can update our `drive_vehicle` function so that it works with this
    new design:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新我们的`drive_vehicle`函数，使其与这个新设计兼容：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This refactored design demonstrates LSP in action. The key change is the introduction
    of abstraction and separation of concerns. We’ve decoupled the concept of a power
    source from the vehicle itself, allowing for different types of power sources
    to be used interchangeably. This abstraction is achieved through the `PowerSource`
    base class, which defines a common interface for all types of energy sources.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构的设计展示了LSP（里氏替换原则）的实际应用。关键变化是引入了抽象和关注点的分离。我们将电源的概念与车辆本身解耦，允许不同类型的电源可以互换使用。这种抽象是通过`PowerSource`基类实现的，它为所有类型的能源源定义了一个通用接口。
- en: 'Let’s break down the key components of this new design:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个新设计的核心组件：
- en: '**The** `PowerSource` **abstract base class**: This defines a contract with
    the `level` and `consume` methods that all power sources must fulfill. It establishes
    a common interface for different types of energy source.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“**`PowerSource`**”抽象基类**：这定义了一个所有电源都必须满足的`level`和`consume`方法的合同。它为不同类型的能源源建立了通用接口。'
- en: '**Concrete implementations (**`FuelTank` and `Battery`**)**: These classes
    inherit from `PowerSource` and provide specific implementations of the `consume`
    method. Crucially, they maintain the behavioral contract defined by `PowerSource`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体实现（**`FuelTank`和`Battery`**）**：这些类从`PowerSource`继承，并提供了`consume`方法的具体实现。关键的是，它们维护了由`PowerSource`定义的行为合同。'
- en: '**The** `Vehicle` **class**: This class depends on the abstract `PowerSource`
    base class, not on concrete implementations. This adherence to LSP allows any
    subclass of `PowerSource` to be used interchangeably without affecting the behavior
    of `Vehicle`.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“**`Vehicle`**”类**：这个类依赖于抽象的`PowerSource`基类，而不是具体的实现。这种对LSP（里氏替换原则）的遵守允许任何`PowerSource`的子类可以互换使用，而不会影响`Vehicle`的行为。'
- en: '**The** `drive_vehicle` **function**: This function demonstrates how LSP enables
    polymorphism. It can work with any `Vehicle` class, regardless of its specific
    power source, without modification.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“**`drive_vehicle`**”函数**：这个函数展示了LSP（里氏替换原则）如何实现多态。它可以与任何`Vehicle`类一起工作，无论其具体的电源是什么，而无需修改。'
- en: LSP’s impact on this design is multifaceted. It ensures behavioral consistency,
    allowing all power sources to be treated uniformly by the `Vehicle` class. This
    polymorphic flexibility enables functions like `drive_vehicle` to work with any
    vehicle type without knowing specific implementation details. The design improves
    extensibility, as new power sources (like hydrogen fuel cells) can be added by
    implementing the `PowerSource` interface without changing existing code. It also
    enhances testability by allowing us to create mock power sources for testing `Vehicle`
    behavior.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: LSP（里氏替换原则）对这个设计的影响是多方面的。它确保了行为一致性，允许所有电源都能被`Vehicle`类统一处理。这种多态灵活性使得像`drive_vehicle`这样的函数可以与任何车辆类型一起工作，而无需了解具体的实现细节。该设计提高了可扩展性，因为可以通过实现`PowerSource`接口来添加新的电源（如氢燃料电池），而无需更改现有代码。它还通过允许我们创建用于测试`Vehicle`行为的模拟电源来增强可测试性。
- en: 'By adhering to LSP, we’ve created a flexible system where core business logic
    remains protected from changes in specific power source implementations. This
    separation is a key aspect of Clean Architecture that promotes long-term stability
    while enabling easy extension. LSP works harmoniously with other SOLID principles:
    it builds upon SRP by ensuring interfaces have clear purposes, supports OCP by
    allowing extension without modification, and complements ISP by promoting focused,
    substitutable interfaces.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循LSP（里氏替换原则），我们创建了一个灵活的系统，其中核心业务逻辑免受特定电源实现变化的影响。这种分离是Clean Architecture的关键方面，它促进了长期稳定性，同时使扩展变得容易。LSP与其他SOLID原则和谐共存：它通过确保接口具有明确的目的而建立在SRP（单一职责原则）之上，通过允许在不修改的情况下进行扩展而支持OCP（开闭原则），并通过促进专注的、可替换的接口来补充ISP（接口隔离原则）。
- en: This alignment enhances modularity, a cornerstone of Clean Architecture. Components
    like `FuelTank` and `Battery` can be swapped without affecting the rest of the
    system, allowing our application to evolve with minimal disruption. Clear interfaces
    like `PowerSource` make the system easier to understand and navigate, serving
    as guideposts for developers whether new to the project or returning months later.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一致性增强了模块化，这是Clean Architecture的基石。像 `FuelTank` 和 `Battery` 这样的组件可以在不影响系统其他部分的情况下进行交换，使我们的应用程序能够以最小的干扰进行演变。清晰的接口，如
    `PowerSource`，使系统更容易理解和导航，无论开发者是新加入项目还是几个月后返回，都可作为指南。
- en: In conclusion, LSP guides us in creating hierarchies that are both flexible
    and reliable. By ensuring derived classes can truly substitute for their base
    classes, we build more robust, extensible Python applications aligned with Clean
    Architecture goals. As we move forward to explore DIP, remember how LSP works
    with the other SOLID principles to form a powerful toolkit for creating enduring
    applications.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，LSP指导我们创建既灵活又可靠的层次结构。通过确保派生类可以真正替换其基类，我们构建了更健壮、可扩展的Python应用程序，与Clean Architecture的目标保持一致。当我们继续探索DIP时，请记住LSP如何与其他SOLID原则一起形成一个强大的工具包，用于创建持久的应用程序。
- en: 'Decoupling for flexibility: inverting dependencies in Python'
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了灵活性而解耦：在Python中反转依赖关系
- en: 'Upon exploring LSP and its role in creating robust abstractions, we’ve seen
    how it contributes to the flexibility and maintainability of our Python code.
    Now let’s turn our attention to the final piece of the SOLID puzzle: the Dependency
    Inversion Principle (DIP).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索LSP及其在创建健壮抽象中的作用后，我们看到了它如何有助于我们Python代码的灵活性和可维护性。现在让我们将注意力转向SOLID谜题的最后一部分：依赖倒置原则（DIP）。
- en: DIP serves as a capstone to the SOLID principles, tying together and reinforcing
    the concepts we explored in the previous principles. It provides a powerful mechanism
    for structuring the relationships between different components of our system,
    further enhancing the flexibility and maintainability we’ve been building throughout
    our journey through SOLID.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DIP（依赖倒置原则）作为SOLID原则的基石，将我们之前原则中探讨的概念联系起来并加强。它为我们系统不同组件之间的关系提供了一个强大的结构化机制，进一步增强了我们在通过SOLID的旅程中构建的灵活性和可维护性。
- en: While LSP ensures that our abstractions are well-formed and substitutable, DIP
    focuses on how these abstractions should relate to one another. It guides us in
    creating a structure where high-level modules aren’t dependent on low-level modules,
    but both depend on abstractions. This inversion of traditional dependency structures
    is crucial for implementing Clean Architecture in Python as it allows us to create
    systems that are truly decoupled and adaptable to change.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 LSP 确保我们的抽象结构良好且可替换，但 DIP 关注这些抽象应该如何相互关联。它指导我们创建一个结构，其中高级模块不依赖于低级模块，但两者都依赖于抽象。这种传统依赖结构的反转对于在Python中实现Clean
    Architecture至关重要，因为它允许我们创建真正解耦且能够适应变化的系统。
- en: As we delve into DIP, we’ll see how it provides a practical approach to implementing
    the Dependency Rule, a cornerstone of Clean Architecture that we introduced in
    [*Chapter 1*](Chapter_01.xhtml#_idTextAnchor015). Recall that the Dependency Rule
    states that source code dependencies should only point inwards, with inner circles
    containing high-level policies and outer circles containing implementation details.
    DIP offers a concrete strategy for adhering to this rule, allowing us to structure
    our code so that high-level modules are independent of low-level modules. Let’s
    explore how we can invert our dependencies to create more flexible, maintainable
    Python systems that truly embody the principles of Clean Architecture and respect
    the Dependency Rule.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究 DIP（依赖倒置原则）时，我们将看到它如何提供一种实现依赖规则的实际方法，这是我们在 [*第一章*](Chapter_01.xhtml#_idTextAnchor015)
    中介绍的 Clean Architecture 的基石。回忆一下，依赖规则指出源代码依赖应仅指向内部，内部圈包含高级策略，外部圈包含实现细节。DIP 提供了一种具体策略来遵守这一规则，使我们能够构建代码结构，使高级模块独立于低级模块。让我们探讨如何反转我们的依赖关系，以创建更灵活、可维护的
    Python 系统，真正体现 Clean Architecture 的原则并尊重依赖规则。
- en: Understanding DIP
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 DIP
- en: 'Before we dive into the intricacies of DIP, let’s clarify what we mean by *depends
    on* in the context of software design. Consider this simple code example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入 DIP 的复杂性之前，让我们明确在软件设计上下文中我们所说的 *依赖于* 是什么意思。考虑这个简单的代码示例：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, we say that `A` depends on `B`. This dependency manifests because
    `A` knows about `B`. This is evident in the line that creates an instance of `B`:
    `self.b = B()`. However, `B` knows nothing about `A`. We typically represent this
    dependency with an arrow pointing from `A` to `B`, as shown in *Figure 2.1*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们说 `A` 依赖于 `B`。这种依赖关系体现在 `A` 知道 `B`。这在创建 `B` 实例的行中很明显：`self.b = B()`。然而，`B`
    对 `A` 一无所知。我们通常用从 `A` 指向 `B` 的箭头来表示这种依赖关系，如图 *图 2.1* 所示：
- en: '![Figure 2.1: A depends on B](img/B31577_02_1.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：A 依赖于 B](img/B31577_02_1.png)'
- en: 'Figure 2.1: A depends on B'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：A 依赖于 B
- en: This simple example sets the stage for understanding the problem that DIP aims
    to solve. In many software systems, high-level modules (which contain the core
    business logic) often depend on low-level modules (which handle specific details
    or implementations). This can lead to inflexible designs that are difficult to
    modify and maintain.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子为理解 DIP 旨在解决的问题奠定了基础。在许多软件系统中，高级模块（包含核心业务逻辑）通常依赖于低级模块（处理特定细节或实现）。这可能导致难以修改和维护的不灵活设计。
- en: 'To illustrate this, let’s consider a more concrete example involving a `UserEntity`
    class that relies on a low-level detail:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑一个更具体的例子，它涉及一个依赖于底层细节的 `UserEntity` 类：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, `UserEntity` directly depends on `MySQLDatabase`, a low-level
    module. Now, imagine that we receive a feature request to support multiple database
    systems. With the current design, we’d need to modify `UserEntity` so that it
    can accommodate this change, violating OCP and potentially introducing bugs into
    our core business logic. The following are some additional problems with this
    design:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`UserEntity` 直接依赖于低级模块 `MySQLDatabase`。现在，假设我们收到一个支持多个数据库系统的功能请求。按照当前的设计，我们需要修改
    `UserEntity` 以适应这一变化，这违反了 OCP（开闭原则），并可能将错误引入我们的核心业务逻辑。以下是一些与这种设计相关的问题：
- en: The `UserEntity` class is tightly coupled to `MySQLDatabase`, making it difficult
    to change the database system in the future
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserEntity` 类与 `MySQLDatabase` 紧密耦合，这使得未来更改数据库系统变得困难'
- en: Testing `UserEntity` becomes challenging because we can’t easily substitute
    a mock database for testing purposes
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 `UserEntity` 变得具有挑战性，因为我们不能轻易地用一个模拟数据库来替换测试目的
- en: The core business logic (`UserEntity`) is polluted with infrastructure concerns
    (database operations)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心业务逻辑（`UserEntity`）被基础设施关注点（数据库操作）所污染
- en: Fixing the design with DIP
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DIP 修复设计
- en: 'DIP, introduced by Robert C. Martin ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)),
    proposes a solution to the problems seen in the preceding example. It states the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由罗伯特·C·马丁（[https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)）提出的
    DIP，为前面例子中看到的问题提供了一个解决方案。它陈述如下：
- en: High-level modules shouldn’t depend on low-level modules. Both should depend
    on abstractions.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级模块不应该依赖于低级模块。两者都应依赖于抽象。
- en: Abstractions shouldn’t depend on details. Details should depend on abstractions.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象不应当依赖于细节。细节应当依赖于抽象。
- en: 'These two points fundamentally change how we structure our code. Instead of
    having direct dependencies between high-level and low-level modules, we introduce
    abstractions that both depend on. However, the key insight of DIP lies in what’s
    actually *inverted*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个要点从根本上改变了我们构建代码的方式。我们不再让高层和低层模块之间有直接的依赖关系，而是引入了两者都依赖的抽象。然而，DIP的关键洞察力实际上在于什么被**反转**了：
- en: Traditionally, low-level modules define abstractions that high-level modules
    use
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统上，低层模块定义抽象，高层模块使用这些抽象。
- en: With DIP, high-level modules define abstractions that low-level modules implement
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 DIP，高层模块定义抽象，低层模块实现这些抽象
- en: This inversion of abstraction ownership is what gives DIP its name, not a simple
    reversal of dependency direction between modules. The high-level module now controls
    the abstraction, while low-level modules conform to it. This shift in control
    allows high-level modules to remain independent of low-level implementation details,
    promoting flexibility and maintainability in our system design.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象所有权的反转是DIP名称的由来，而不仅仅是模块间依赖方向的简单反转。现在，高层模块控制抽象，而低层模块则遵循它。这种控制权的转变使得高层模块可以独立于低层实现细节，从而促进系统设计的灵活性和可维护性。
- en: 'Let’s look at how this changes our dependency diagram:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何改变我们的依赖图的：
- en: '![Figure 2.2: A and B depend on an interface](img/B31577_02_2.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：A和B依赖于一个接口](img/B31577_02_2.png)'
- en: 'Figure 2.2: A and B depend on an interface'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：A和B依赖于一个接口
- en: 'As shown in *Figure 2.2*, the dependencies now point toward the abstraction,
    inverting the traditional flow. The high-level module (`A`) and the low-level
    module (`B`) both depend on an abstraction (Interface), rather than on each other
    directly. This change is profound: `A` no longer *knows of* `B`; rather, it knows
    of a contract that a *thing like* `B` will adhere to.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图2.2*所示，依赖现在指向抽象，反转了传统的流向。高层模块（`A`）和低层模块（`B`）都依赖于一个抽象（接口），而不是直接依赖于对方。这种变化是深刻的：`A`不再*知道*`B`；而是知道一个*类似*`B`的东西将遵守的契约。
- en: 'This shift from concrete knowledge to abstract contract has far-reaching implications:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从具体知识到抽象契约的转变具有深远的影响：
- en: '**Decoupling** **and flexibility**: Now, `A` is decoupled from the specifics
    of `B`, only knowing the contract it must fulfill. This allows us to easily swap
    or upgrade components without affecting the rest of the system, making it more
    adaptable to future requirements.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦** **和灵活性**：现在，`A`与`B`的具体实现细节解耦，只知道它必须满足的契约。这使我们能够轻松地交换或升级组件，而不会影响系统的其余部分，使其更能适应未来的需求。'
- en: '**Improved testability**: We can create mock objects that implement the interface
    for testing purposes, allowing us to test components in isolation without a complex
    setup.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可测试性**：我们可以创建实现接口的模拟对象，用于测试目的，这样我们就可以在无需复杂设置的情况下单独测试组件。'
- en: '**Clarity and** **encapsulation**: The interface clearly defines component
    interactions, making the code more self-documenting. Changes in implementation
    are contained, reducing ripple effects across the system.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰性和封装性**：接口清楚地定义了组件之间的交互，使代码更具自文档性。实现上的变化被限制在内部，减少了系统中的连锁反应。'
- en: '**Design by contract**: This approach encourages thinking in terms of interfaces
    rather than concrete implementations, promoting better-designed, more modular
    systems that are easier to understand and maintain.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计由契约驱动**：这种方法鼓励以接口而不是具体实现来思考，从而促进设计更优、更模块化的系统，这些系统更容易理解和维护。'
- en: By adhering to DIP, we’re not just changing the direction of dependencies; we’re
    fundamentally altering how different parts of our system interact. This creates
    a more loosely coupled, flexible, and maintainable architecture that can better
    withstand the test of time and changing requirements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循DIP，我们不仅仅是改变依赖的方向；我们从根本上改变了系统不同部分之间的交互方式。这创造了一个更松散耦合、灵活且可维护的架构，能够更好地经受时间的考验和不断变化的需求。
- en: 'To align our `UserEntity` code with DIP, we need to introduce an abstraction
    that both the high-level and low-level modules can depend on. This abstraction
    typically takes the form of an interface. Let’s refactor our code so that it adheres
    to DIP:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`UserEntity`代码与DIP（依赖倒置原则）保持一致，我们需要引入一个高层和低层模块都可以依赖的抽象。这种抽象通常以接口的形式出现。让我们重构我们的代码，使其遵循DIP：
- en: '[PRE16]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this refactored version, we did the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个重构版本中，我们做了以下操作：
- en: We introduced an abstraction (`DatabaseInterface`) that both high-level (`UserEntity`)
    and low-level (`MySQLDatabase`, `PostgreSQLDatabase`) modules depend on.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了一个抽象（`DatabaseInterface`），它既被高级模块（`UserEntity`）也被低级模块（`MySQLDatabase`，`PostgreSQLDatabase`）所依赖。
- en: The `UserEntity` class no longer creates its database dependency, instead receiving
    it through its constructor. This technique is known as dependency injection, which
    is a key practice in implementing DIP.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserEntity`类不再创建其数据库依赖，而是通过构造函数接收它。这种技术被称为依赖注入，它是实现DIP的关键实践。'
- en: We can easily add support for new database systems by creating new classes that
    implement `DatabaseInterface`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过创建实现`DatabaseInterface`的新类来轻松添加对新数据库系统的支持。
- en: '*Figure 2.3* represents the new state of relationships between these components:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.3* 表示这些组件之间新关系的状态：'
- en: '![Figure 2.3: UserEntity is decoupled from the concrete storage classes](img/B31577_02_3.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：UserEntity与具体存储类解耦](img/B31577_02_3.png)'
- en: 'Figure 2.3: UserEntity is decoupled from the concrete storage classes'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：UserEntity与具体存储类解耦
- en: 'This diagram’s significance lies in several key aspects:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表的重要性体现在几个关键方面：
- en: '**Inverted dependency and abstraction as a contract**: The `UserEntity` class
    depends on the `DatabaseInterface` abstraction, not concrete implementations.
    This interface serves as a contract for any database implementation.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转依赖和抽象作为契约**：`UserEntity`类依赖于`DatabaseInterface`抽象，而不是具体的实现。该接口作为任何数据库实现的契约。'
- en: '**Separation of concerns**: The `UserEntity` class is decoupled from specific
    database operations, knowing only about the abstract operations defined in `DatabaseInterface`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：`UserEntity`类与特定的数据库操作解耦，只知道`DatabaseInterface`中定义的抽象操作。'
- en: '**Extensibility and flexibility**: The design allows us to easily add new database
    implementations and swap between them without affecting `UserEntity`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性和灵活性**：这种设计使我们能够轻松添加新的数据库实现，并在它们之间进行交换，而不会影响`UserEntity`。'
- en: By applying DIP, we’ve created a flexible, maintainable system where our core
    business logic (`UserEntity`) is protected from changes in external details (database
    implementations). This separation is a cornerstone of Clean Architecture that
    promotes long-term system stability and adaptability. The preceding diagram shows
    how multiple implementations (`MySQLDatabase` and `PostgreSQLDatabase`) can coexist,
    demonstrating the power of this abstraction-based approach. We could easily add
    more implementations, such as `OracleDatabase` or `MongoDBAdapter`, without modifying
    `UserEntity`, further illustrating the extensibility benefits of DIP.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用DIP，我们创建了一个灵活、可维护的系统，其中我们的核心业务逻辑（`UserEntity`）免受外部细节（数据库实现）变化的影响。这种分离是Clean
    Architecture的基石，它促进了长期系统的稳定性和适应性。前面的图表显示了多个实现（`MySQLDatabase`和`PostgreSQLDatabase`）如何共存，展示了这种基于抽象方法的力量。我们可以轻松添加更多实现，例如`OracleDatabase`或`MongoDBAdapter`，而无需修改`UserEntity`，进一步说明了DIP的可扩展性优势。
- en: DIP’s effect on testing
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DIP对测试的影响
- en: 'As we’ve seen with other SOLID principles, the use of dependency injection
    significantly aids in testing. We can now easily create a mock database for testing
    `UserEntity`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过其他SOLID原则所看到的，依赖注入的使用显著有助于测试。我们现在可以轻松地为测试创建一个模拟数据库`UserEntity`：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This ability to easily substitute dependencies makes our code much more testable,
    allowing us to verify the behavior of `UserEntity` in isolation from any actual
    database implementation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轻松替换依赖的能力使我们的代码更容易测试，允许我们在与任何实际数据库实现隔离的情况下验证`UserEntity`的行为。
- en: DIP in the context of SOLID and Clean Architecture
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DIP在SOLID和Clean Architecture中的上下文
- en: DIP serves as a cornerstone in both SOLID principles and Clean Architecture.
    It complements other SOLID principles by enabling the separation of interface
    definitions from implementations and supporting the easy extension of system behavior.
    In Clean Architecture, DIP is crucial for implementing the Dependency Rule, allowing
    inner layers to define interfaces that outer layers must adhere to. This inversion
    separates business logic from implementation details, creating more flexible,
    maintainable, and testable systems that align perfectly with Clean Architecture
    goals.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: DIP在SOLID原则和Clean Architecture中都起着基石的作用。它通过使接口定义与实现分离，并支持系统行为的轻松扩展，补充了其他SOLID原则。在Clean
    Architecture中，DIP对于实施依赖规则至关重要，它允许内部层定义外部层必须遵守的接口。这种反转将业务逻辑与实现细节分离，创建出更灵活、可维护和可测试的系统，与Clean
    Architecture的目标完美契合。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored the SOLID principles and their application in
    Python to create clean, maintainable, and flexible architectures. We learned how
    each principle contributes to robust software design:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 SOLID 原则及其在 Python 中的应用，以创建干净、可维护和灵活的架构。我们学习了每个原则如何有助于稳健的软件设计：
- en: SRP for creating focused, cohesive classes
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRP 用于创建专注、一致的类
- en: OCP for extending behavior without modification
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCP 用于在不修改行为的情况下扩展行为
- en: LSP for ensuring well-formed, substitutable abstractions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LSP 用于确保良好的、可替换的抽象
- en: ISP for designing targeted, client-specific interfaces
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISP 用于设计针对特定客户端的接口
- en: DIP for structuring dependencies to maximize flexibility
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DIP 用于构建依赖关系以最大化灵活性
- en: These principles are crucial for developing Python applications that can evolve
    with changing requirements, resist software entropy, and remain clear as systems
    grow in complexity. They form the foundation of Clean Architecture, enabling us
    to create more modular, testable, and adaptable code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则对于开发能够随着需求变化而演变的 Python 应用程序至关重要，可以抵抗软件熵，并在系统复杂性增加时保持清晰。它们是 Clean Architecture
    的基础，使我们能够创建更模块化、可测试和可适应的代码。
- en: 'In the next chapter, we’ll explore how to leverage Python’s type system to
    further enhance the robustness and clarity of our Clean Architecture designs.
    You’ll see how type hints can strengthen several SOLID principles we’ve just covered:
    creating more explicit interfaces for ISP, defining clearer contracts for DIP,
    and making substitutability more apparent for LSP. These typing capabilities will
    help us create even more maintainable and self-documenting code while maintaining
    Python’s flexibility.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何利用 Python 的类型系统进一步增强我们的 Clean Architecture 设计的稳健性和清晰度。您将看到类型提示如何加强我们刚刚覆盖的几个
    SOLID 原则：为 ISP 创建更明确的接口，为 DIP 定义更清晰的契约，以及使 LSP 的可替换性更加明显。这些类型功能将帮助我们创建更易于维护和自文档化的代码，同时保持
    Python 的灵活性。
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*SOLID Principles* ([https://realpython.com/solid-principles-python/](https://realpython.com/solid-principles-python/)).
    This is a comprehensive tutorial that walks through each SOLID principle with
    Python-specific examples.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SOLID 原则* ([https://realpython.com/solid-principles-python/](https://realpython.com/solid-principles-python/)).
    这是一个全面的教程，通过 Python 特定的示例逐一讲解每个 SOLID 原则。'
- en: '*Agile Software Development, Principles, Patterns, and Practices* by Robert
    C. Martin.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*敏捷软件开发：原则、模式和实践* 由 Robert C. Martin 编著。'
- en: '*Python Design Patterns* by Brandon Rhodes ([https://python-patterns.guide/](https://python-patterns.guide/)).
    While not exclusively about SOLID, this resource covers many design patterns that
    complement SOLID principles in Python.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python 设计模式* 由 Brandon Rhodes 编著 ([https://python-patterns.guide/](https://python-patterns.guide/)).
    虽然不是专门关于 SOLID 的，但这个资源涵盖了与 Python 中的 SOLID 原则相辅相成的许多设计模式。'
- en: '*SOLID: The First Five Principles of Object-Oriented Design* ([https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design](https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)).
    This comprehensive article provides a clear explanation of each SOLID principle
    with practical code examples. While the examples are in PHP, the concepts are
    universally applicable and can be easily translated into Python, making it a valuable
    resource for deepening your understanding of SOLID principles in object-oriented
    design.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SOLID：面向对象设计的五大原则* ([https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design](https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)).
    这篇文章全面地解释了每个 SOLID 原则，并提供了实用的代码示例。虽然示例使用的是 PHP，但概念是普遍适用的，并且可以轻松地转换为 Python，使其成为深化你对面向对象设计中
    SOLID 原则理解的宝贵资源。'
