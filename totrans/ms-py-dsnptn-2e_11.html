<html><head></head><body>
		<div><h1 id="_idParaDest-249" class="chapter-number"><a id="_idTextAnchor273"/>11</h1>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor274"/>Python Anti-Patterns</h1>
			<p>In this final chapter, we will explore Python anti-patterns. These are common programming practices that, while not necessarily wrong, often lead to less efficient, less readable, and less maintainable code. By understanding these pitfalls, you can write cleaner, more efficient code for your Python applications.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Code style violations</li>
				<li>Correctness anti-patterns</li>
				<li>Maintainability anti-patterns</li>
				<li>Performance anti-patterns</li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor275"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor276"/>Code style violations</h1>
			<p>The <a id="_idIndexMarker979"/>Python style guide, also<a id="_idIndexMarker980"/> known as <strong class="bold">Python Enhancement Proposal no 8</strong> (<strong class="bold">PEP 8</strong>), provides recommendations for readability and consistency in your code, making it easier for developers to collaborate and maintain projects over time. You can find the style guide details on its official page <a id="_idIndexMarker981"/>here: <a href="https://peps.python.org/pep-0008">https://peps.python.org/pep-0008</a>. In this section, we are going to present some of the recommendations of the style guide so that you can avoid them when writing your application’s or library’s code.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor277"/>Tools for fixing coding style violations</h1>
			<p>Note that we have <a id="_idIndexMarker982"/>formatting tools <a id="_idIndexMarker983"/>such as <em class="italic">Black</em> (<a href="https://black.readthedocs.io/en/stable/">https://black.readthedocs.io/en/stable/</a>), <em class="italic">isort</em> (<a href="https://pycqa.github.io/isort/">https://pycqa.github.io/isort/</a>), and/or <em class="italic">Ruff</em> (<a href="https://docs.astral.sh/ruff/">https://docs.astral.sh/ruff/</a>) that can help you fix code that does not <a id="_idIndexMarker984"/>follow the <a id="_idIndexMarker985"/>style guide recommendations. We are not going to spend time on how to use these tools here since you can find all the needed documentation on their official documentation pages and start using them in a matter of minutes.</p>
			<p>Now, let’s explore our selected code style recommendations.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor278"/>Indentation</h2>
			<p>You should use four spaces per indentation<a id="_idIndexMarker986"/> level, and you should avoid mixing tabs and spaces.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor279"/>Maximum line length and blank lines</h2>
			<p>The style guide <a id="_idIndexMarker987"/>recommends limiting all lines <a id="_idIndexMarker988"/>of code to a maximum of 79 characters, for better readability.</p>
			<p>Also, there are rules related to blank lines. First, you should surround top-level function and class definitions with two blank lines. Second, method definitions inside a class should be surrounded by a single blank line.</p>
			<p>For example, the formatting with the following code snippet is incorrect:</p>
			<pre class="source-code">
class MyClass:
    def method1(self):
        pass
    def method2(self):
        pass
def top_level_function():
    pass</pre>			<p>The right formatting is as follows:</p>
			<pre class="source-code">
class MyClass:
    def method1(self):
        pass
    def method2(self):
        pass
def top_level_function():
    pass</pre>			<h2 id="_idParaDest-256"><a id="_idTextAnchor280"/>Imports</h2>
			<p>The way you write, organize, and<a id="_idIndexMarker989"/> order your import lines is also important. According to the style guide, imports should be on separate lines and grouped into three categories in this order: standard library imports, related third-party imports, and local-specific imports within the application’s or library’s code base. Also, each group should be separated by a blank line.</p>
			<p>For example, the following is not compliant with the style guide:</p>
			<pre class="source-code">
import os, sys
import numpy as np
from mymodule import myfunction</pre>			<p>The best practice for the same imports is the following:</p>
			<pre class="source-code">
import os
import sys
import numpy as np
from mymodule import myfunction</pre>			<h2 id="_idParaDest-257"><a id="_idTextAnchor281"/>Naming conventions</h2>
			<p>You should use descriptive <a id="_idIndexMarker990"/>names for variables, functions, classes, and modules. The following are specific naming conventions for different types of cases:</p>
			<ul>
				<li><code>lower_case_with_underscores</code></li>
				<li><code>CapWords</code></li>
				<li><code>ALL_CAPS_WITH_UNDERSCORES</code></li>
			</ul>
			<p>For example, the following is not good practice:</p>
			<pre class="source-code">
def calculateSum(a, b):
    return a + b
class my_class:
    pass
maxValue = 100</pre>			<p>The best practice is the following:</p>
			<pre class="source-code">
def calculate_sum(a, b):
    return a + b
class MyClass:
    pass
MAX_VALUE = 100</pre>			<h2 id="_idParaDest-258"><a id="_idTextAnchor282"/>Comments</h2>
			<p>Comments should be <a id="_idIndexMarker991"/>complete sentences, with the first word capitalized, and should be clear and concise. We have specific recommendations for two cases of comments—block comments and inline comments:</p>
			<ul>
				<li>Block comments generally apply to some (or all) code that follows them and are indented to the same level as that code. Each line of a block comment starts with <code>#</code> and a single space.</li>
				<li>Inline comments should be used sparingly. An inline comment is placed on the same line as a statement, separated by at least two spaces from the statement.</li>
			</ul>
			<p>For example, in the following, we have a bad comment style:</p>
			<pre class="source-code">
#This is a poorly formatted block comment.
def foo():  #This is a poorly formatted inline comment.
    pass</pre>			<p>Here is the equivalent code, with the style fixed:</p>
			<pre class="source-code">
# This is a block comment.
# It spans multiple lines.
def foo():
    pass  # This is an inline comment.</pre>			<h2 id="_idParaDest-259"><a id="_idTextAnchor283"/>Whitespace in expressions and statements</h2>
			<p>You should avoid <a id="_idIndexMarker992"/>extraneous whitespace in the following situations:</p>
			<ul>
				<li>Immediately inside parentheses, brackets, or braces</li>
				<li>Immediately before a comma, semicolon, or colon</li>
				<li>More than one space around an assignment operator to align it with another</li>
			</ul>
			<p>This ends our<a id="_idIndexMarker993"/> review of the most common code style violations to pay attention to. As previously said, there are tools to detect and fix such violations in your code in a productive way, and they are generally included in the developer workflow (for example, via <code>git commit</code> hooks and/or in the project’s CI/CD processes).</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor284"/>Correctness anti-patterns</h1>
			<p>These anti-patterns can <a id="_idIndexMarker994"/>lead to bugs or unintended behavior if not addressed. We are going to discuss the most common of these anti-patterns and alternative, recommended ways and approaches. We are going to focus on the following anti-patterns:</p>
			<ul>
				<li>Using the <code>type()</code> function for comparing types</li>
				<li>Mutable default argument</li>
				<li>Accessing a protected member from outside a class</li>
			</ul>
			<p>Note that using IDEs such as <em class="italic">Visual Studio Code</em> or <em class="italic">PyCharm</em> or command-line tools such as <em class="italic">Flake8</em> will help you spot such bad practices in your code, but it is important to know the recommendations and the reason behind each one.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor285"/>Using the type() function for comparing types</h2>
			<p>Sometimes, we<a id="_idIndexMarker995"/> need to identify the type of a value through comparison, for our algorithm. The common technique one may think of for that is to use the <code>type()</code> function. But using <code>type()</code> to compare object types does not account for subclassing and is not as flexible as the alternative which is based on using the <code>isinstance()</code> function.</p>
			<p>Imagine we have two classes, <code>CustomListA</code> and <code>CustomListB</code>, that are subclasses of the <code>UserList</code> class, which is the recommended class one should inherit from when defining a class for a custom list, as follows:</p>
			<pre class="source-code">
from collections import UserList
class CustomListA(UserList):
    pass
class CustomListB(UserList):
    pass</pre>			<p>If we wanted to check if an object is of one of the custom list types, using the first approach, we would test the <code>type(obj) in (CustomListA, </code><code>CustomListB)</code> condition.</p>
			<p>Alternatively, we would simply test <code>isinstance(obj, UserList)</code>, and that would be enough since <code>CustomListA</code> and <code>CustomListB</code> are subclasses of <code>UserList</code>.</p>
			<p>As a<a id="_idIndexMarker996"/> demonstration, we write a <code>compare()</code> function that uses the first approach, as follows:</p>
			<pre class="source-code">
def compare(obj):
    if type(obj) in (CustomListA, CustomListB):
        print("It's a custom list!")
    else:
        print("It's a something else!")</pre>			<p>Then, we write a <code>better_compare()</code> function to do the equivalent using the alternative approach, as follows:</p>
			<pre class="source-code">
def better_compare(obj):
    if isinstance(obj, UserList):
        print("It's a custom list!")
    else:
        print("It's a something else!")</pre>			<p>The following lines of code can help test both functions:</p>
			<pre class="source-code">
obj1 = CustomListA([1, 2, 3])
obj2 = CustomListB(["a", "b", "c"])
compare(obj1)
compare(obj2)
better_compare(obj1)
better_compare(obj2)</pre>			<p>The <a id="_idIndexMarker997"/>complete demonstration code is in the <code>ch11/compare_types.py</code> file. Running the <code>python ch11/compare_types.py</code> command should give the following output:</p>
			<pre class="console">
It's a custom list!
It's a custom list!
It's a custom list!
It's a custom list!</pre>			<p>This shows that both functions can produce the expected result. But the function using the recommended technique, <code>isinstance()</code>, is simpler to write and more flexible since it takes subclasses into account.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor286"/>Mutable default argument</h2>
			<p>When you define a function with a <a id="_idIndexMarker998"/>parameter that expects a mutable value, such as a list or a dictionary, you may be tempted to provide a default argument (<code>[]</code> or <code>{}</code> respectively). But such a function retains changes between calls, which will lead to unexpected behaviors.</p>
			<p>The recommended practice is to use a default value of <code>None</code> and set it to a mutable data structure within the function if needed.</p>
			<p>Let’s <a id="_idIndexMarker999"/>create a function called <code>manipulate()</code> whose <code>mylist</code> parameter has a default value of <code>[]</code>. The function appends the <code>"test"</code> string to the <code>mylist</code> list and then returns it, as follows:</p>
			<pre class="source-code">
def manipulate(mylist=[]):
    mylist.append("test")
    return mylist</pre>			<p>In another function called <code>better_manipulate()</code> whose <code>mylist</code> parameter has a default value of <code>None</code>, we start by setting <code>mylist</code> to <code>[]</code> if it is <code>None</code>, then we append the <code>"test"</code> string to <code>mylist</code> before returning it, as follows:</p>
			<pre class="source-code">
def better_manipulate(mylist=None):
    if not mylist:
        mylist = []
    mylist.append("test")
    return mylist</pre>			<p>The following lines help us test each function by calling it several times with the default argument:</p>
			<pre class="source-code">
if __name__ == "__main__":
    print("function manipulate()")
    print(manipulate())
    print(manipulate())
    print(manipulate())
    print("function better_manipulate()")
    print(better_manipulate())
    print(better_manipulate())</pre>			<p>Running<a id="_idIndexMarker1000"/> the <code>python ch11/mutable_default_argument.py</code> command should give the following output:</p>
			<pre class="source-code">
<strong class="bold">function manipulate()</strong>
<strong class="bold">['test']</strong>
<strong class="bold">['test', 'test']</strong>
<strong class="bold">['test', 'test', 'test']</strong>
<strong class="bold">function better_manipulate()</strong>
<strong class="bold">['test']</strong>
<code>"test"</code> string several times in the list returned; the string is accumulating because each subsequent time the function has been called, the <code>mylist</code> argument kept its previous value instead of being reset to the empty list. But, with the recommended solution, we see with the result that we get the expected behavior.</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor287"/>Accessing a protected member from outside a class</h2>
			<p>Accessing a <a id="_idIndexMarker1001"/>protected member (an attribute prefixed with <code>_</code>) of a class from outside that class usually calls for trouble since the creator of that class did not intend this member to be exposed. Someone maintaining the code could change or rename that attribute later down the road, and parts of the code accessing it could result in unexpected behavior.</p>
			<p>If you have code that accesses a protected member that way, the recommended practice is to refactor that code so that it is part of the public interface of the class.</p>
			<p>To demonstrate this, let’s define a <code>Book</code> class with two protected attributes, <code>_title</code> and <code>_author</code>, as follows:</p>
			<pre class="source-code">
class Book:
    def __init__(self, title, author):
        self._title = title
        self._author = author</pre>			<p>Now, let’s create another class, <code>BetterBook</code>, with the same attributes and a <code>presentation_line()</code> method that accesses the <code>_title</code> and <code>_author</code> attributes and<a id="_idIndexMarker1002"/> returns a concatenated string based on them. The class definition is as follows:</p>
			<pre class="source-code">
class BetterBook:
    def __init__(self, title, author):
        self._title = title
        self._author = author
    def presentation_line(self):
        return f"{self._title} by {self._author}"</pre>			<p>Finally, in the code for testing both classes, we get and print the presentation line for an instance of each class, accessing the protected members for the first one (instance of <code>Book</code>) and calling the <code>presentation_line()</code> method for the second one (instance of <code>BetterBook</code>), as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    b1 = Book(
        "Mastering Object-Oriented Python",
        "Steven F. Lott",
    )
    print(
        "Bad practice: Direct access of protected members"
    )
    print(f"{b1._title} by {b1._author}")
    b2 = BetterBook(
        "Python Algorithms",
        "Magnus Lie Hetland",
    )
    print(
        "Recommended: Access via the public interface"
    )
    print(b2.presentation_line())</pre>			<p>The complete <a id="_idIndexMarker1003"/>code is in the <code>ch11/ protected_member_of_class.py</code> file. Running the <code>python ch11/ protected_member_of_class.py</code> command gives the following output:</p>
			<pre class="console">
Bad practice: Direct access of protected members
Mastering Object-Oriented Python by Steven F. Lott
Recommended: Access via the public interface
Python Algorithms by Magnus Lie Hetland</pre>			<p>This shows that we get the same result, without any error, in both cases, but using the <code>presentation_line()</code> method, as done in the case of the second class, is the best practice. The <code>_title</code> and <code>_author</code> attributes are protected, so it is not recommended to call them directly. The developer could change those attributes in the future. That is why they must be encapsulated in a public method.</p>
			<p>Also, it is good practice to provide an attribute that encapsulates each protected member of the class using the <code>@property</code> decorator, as we have seen in the <em class="italic">Techniques for achieving encapsulation</em> section of <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Foundational </em><em class="italic">Design Principles</em>.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor288"/>Maintainability anti-patterns</h1>
			<p>These anti-patterns make your code difficult to<a id="_idIndexMarker1004"/> understand or maintain over time. We are going to discuss several anti-patterns that should be avoided for better quality in your Python application or library’s code base. We will focus on the following points:</p>
			<ul>
				<li>Using a <a id="_idIndexMarker1005"/>wildcard import</li>
				<li><strong class="bold">Look Before You Leap</strong> (<strong class="bold">LBYL</strong>) versus <strong class="bold">Easier to Ask for Forgiveness than </strong><strong class="bold">Permission</strong> (<strong class="bold">EAFP</strong>)</li>
				<li>Overusing <a id="_idIndexMarker1006"/>inheritance and tight coupling</li>
				<li>Using global variables for sharing data between functions</li>
			</ul>
			<p>As mentioned for the previous category of anti-patterns, using tools such as Flake8 as part of your developer workflow can be handy to help find some of those potential issues when they are already present in your code.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor289"/>Using a wildcard import</h2>
			<p>This way of <a id="_idIndexMarker1007"/>importing (<code>from mymodule import *</code>) can clutter the namespace and make it difficult to determine where an imported variable or function came from. Also, the code may end up with bugs because of name collision.</p>
			<p>The best practice is to use specific imports or import the module itself to maintain clarity.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor290"/>LBYL versus EAFP</h2>
			<p>LBYL often leads to more <a id="_idIndexMarker1008"/>cluttered code, while EAFP makes use of Python’s handling of exceptions and tends to be cleaner.</p>
			<p>For example, we may want to check if a file exists, before opening it, with code such as the following:</p>
			<pre class="source-code">
if os.path.exists(filename):
    with open(filename) as f:
        print(f.text)</pre>			<p>This is<a id="_idIndexMarker1009"/> LBYL, and when new to Python, you would think that it is the right way to treat such situations. But in Python, it is recommended to favor EAFP, where appropriate, for cleaner, more Pythonic code. So, the recommended way for the expected result would give the following code:</p>
			<pre class="source-code">
try:
    with open(filename) as f:
        print(f.text)
except FileNotFoundError:
    print("No file there")</pre>			<p>As a demonstration, let’s write a <code>test_open_file()</code> function that uses the LBYL approach, as follows:</p>
			<pre class="source-code">
def test_open_file(filename):
    if os.path.exists(filename):
        with open(filename) as f:
            print(f.text)
    else:
        print("No file there")</pre>			<p>Then, we add a function that uses the recommended approach:</p>
			<pre class="source-code">
def better_test_open_file(filename):
    try:
        with open(filename) as f:
            print(f.text)
    except FileNotFoundError:
        print("No file there")</pre>			<p>We can then test these functions with the following code:</p>
			<pre class="source-code">
filename = "no_file.txt"
test_open_file(filename)
better_test_open_file(filename)</pre>			<p>You can check the complete code of the example in the <code>ch11/lbyl_vs_eafp.py</code> file, and running it should give the following output:</p>
			<pre class="source-code">
<strong class="bold">No file there</strong>
<code>try</code>/<code>except</code> way makes our code cleaner.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor291"/>Overusing inheritance and tight coupling</h2>
			<p>Inheritance is a <a id="_idIndexMarker1011"/>powerful feature of OOP, but overusing it – for example, creating a new class for every slight variation of behavior – can lead to tight coupling between classes. This increases complexity and makes the code less flexible and harder to maintain.</p>
			<p>It is not recommended to create a deep inheritance hierarchy such as the following (as a simplified example):</p>
			<pre class="source-code">
class GrandParent:
    pass
class Parent(GrandParent):
    pass
class Child(Parent):
    Pass</pre>			<p>The best practice is<a id="_idIndexMarker1012"/> to create smaller, more focused classes and combine them to achieve the desired behavior, as with the following:</p>
			<pre class="source-code">
class Parent:
    pass
class Child:
    def __init__(self, parent):
        self.parent = parent</pre>			<p>As you may remember, this is the composition approach, which we discussed in the <em class="italic">Following the Favor Composition over Inheritance principle</em> section of <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Foundational </em><em class="italic">Design Principles</em>.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor292"/>Using global variables for sharing data between functions</h2>
			<p>Global variables <a id="_idIndexMarker1013"/>are variables that are accessible througho<a id="_idTextAnchor293"/>ut the entire program, making them tempting to use for sharing data between functions—for example, configuration settings that are used across multiple modules or shared resources such as database connections.</p>
			<p>However, they can lead to bugs where different parts of the application unexpectedly modify global state. Also, they make it harder to scale applications as they can lead to issues in multithreaded environments where multiple threads might attempt to modify the global variable simultaneously.</p>
			<p>Here is an example of the non-recommended practice:</p>
			<pre class="source-code">
# Global variable
counter = 0
def increment():
    global counter
    counter += 1
def reset():
    global counter
    counter = 0</pre>			<p>Instead of using a global variable, you should pass the needed data as arguments to functions or encapsulate state within a class, which improves the modularity and testability of the code. So, the best-practice equivalent for the counterexample would be <a id="_idIndexMarker1014"/>defining a <code>Counter</code> class holding a <code>counter</code> attribute, as follows:</p>
			<pre class="source-code">
class Counter:
    def __init__(self):
        self.counter = 0
    def increment(self):
        self.counter += 1
    def reset(self):
        self.counter = 0</pre>			<p>Next, we add code for testing the <code>Counter</code> class as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    c = Counter()
    print(f"Counter value: {c.counter}")
    c.increment()
    print(f"Counter value: {c.counter}")
    c.reset()</pre>			<p>You can<a id="_idIndexMarker1015"/> check the complete code of the example in the  <code>ch11/instead_of_global_variable.py</code> file, and running it should give the following output:</p>
			<pre class="source-code">
<strong class="bold">Counter value: 0</strong>
<strong class="bold">Counter value: 1</strong></pre>			<p>This shows how using a class instead of global variables is effective and can be scalable, thus the recommended practice.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor294"/>Performance anti-patterns</h1>
			<p>These anti-patterns<a id="_idIndexMarker1016"/> lead to inefficiencies that can degrade performance, especially noticeable in large-scale applications or data-intensive tasks. We will focus on the following such anti-patterns:</p>
			<ul>
				<li>Not using <code>.join()</code> to concatenate strings in a loop</li>
				<li>Using global variables for caching</li>
			</ul>
			<p>Let’s start.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor295"/>Not using .join() to concatenate strings in a loop</h2>
			<p>Concatenating <a id="_idIndexMarker1017"/>strings with <code>+</code> or <code>+=</code> in a loop creates a new string object each time, which is inefficient. The best solution is to use the <code>.join()</code> method on strings, which is designed for efficiency when concatenating strings from a sequence or iterable.</p>
			<p>Let’s create a <code>concatenate()</code> function where we use <code>+=</code> for concatenating items from a list of strings, as follows:</p>
			<pre class="source-code">
def concatenate(string_list):
    result = ""
    for item in string_list:
        result += item
    return result</pre>			<p>Then, let’s create a <code>better_concatenate()</code> function for the same result, but using the <code>str.join()</code> method, as follows:</p>
			<pre class="source-code">
def better_concatenate(string_list):
    result = "".join(string_list)
    return result</pre>			<p>We can then test both functions using the following:</p>
			<pre class="source-code">
if __name__ == "__main__":
    string_list = ["Abc", "Def", "Ghi"]
    print(concatenate(string_list))
    print(better_concatenate(string_list))</pre>			<p>Running the code (in the <code>ch11/concatenate_strings_in_loop.py</code> file) gives the following output:</p>
			<pre class="source-code">
<strong class="bold">AbcDefGhi</strong>
<code>.join()</code> is the recommended practice for performance reasons.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor296"/>Using global variables for caching</h2>
			<p>Using global variables <a id="_idIndexMarker1019"/>for caching can seem like a quick and easy solution but often leads to poor maintainability, potential data consistency issues, and difficulties in managing the cache life cycle effectively. A more robust approach involves using specialized caching libraries designed to handle these aspects more efficiently.</p>
			<p>In this example (in the <code>ch11/caching/using_global_var.py</code> file), a global dictionary is used to cache results from a function that simulates a time-consuming operation (for example, a database query) done in the <code>perform_expensive_operation()</code> function. The <a id="_idIndexMarker1020"/>complete code for this demonstration is as follows:</p>
			<pre class="source-code">
import time
import random
# Global variable as cache
_cache = {}
def get_data(query):
    if query in _cache:
        return _cache[query]
    else:
        result = perform_expensive_operation(query)
        _cache[query] = result
        return result
def perform_expensive_operation(user_id):
    time.sleep(random.uniform(0.5, 2.0))
    user_data = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"},
        3: {"name": "Charlie", "email": "charlie@example.com"},
    }
    result = user_data.get(user_id, {"error": "User not found"})
    return result
if __name__ == "__main__":
    print(get_data(1))
    print(get_data(1))</pre>			<p>Testing the code by running the <code>python ch11/caching/using_global_var.py</code> command gives the following output:</p>
			<pre class="source-code">
<strong class="bold">{'name': 'Alice', 'email': 'alice@example.com'}</strong>
<code>functools.lru_cache()</code> function. The <code>lru_cache</code> decorator provides<a id="_idIndexMarker1022"/> a <code>lru_cache</code> are optimized for performance, using efficient data structures and algorithms to manage the cache.</p>
			<p>Here’s how you can implement the functionality of caching results from a time-consuming function using <code>functools.lru_cache</code>. The complete code (in the <code>ch11/caching/using_lru_cache.py</code> file) is as follows:</p>
			<pre class="source-code">
import random
import time
from functools import lru_cache
@lru_cache(maxsize=100)
def get_data(user_id):
    return perform_expensive_operation(user_id)
def perform_expensive_operation(user_id):
    time.sleep(random.uniform(0.5, 2.0))
    user_data = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"},
        3: {"name": "Charlie", "email": "charlie@example.com"},
    }
    result = user_data.get(user_id, {"error": "User not found"})
    return result
if __name__ == "__main__":
    print(get_data(1))
    print(get_data(1))
    print(get_data(2))
    print(get_data(99))</pre>			<p>To test this<a id="_idIndexMarker1023"/> code, run the <code>python ch11/caching/using_lru_cache.py</code>  command. You should get the following output:</p>
			<pre class="console">
{'name': 'Alice', 'email': 'alice@example.com'}
{'name': 'Alice', 'email': 'alice@example.com'}
{'name': 'Bob', 'email': 'bob@example.com'}
{'error': 'User not found'}</pre>			<p>As we can see, this approach not only enhances the robustness of the caching mechanism but also improves code readability and maintainability.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor297"/>Summary</h1>
			<p>Understanding and avoiding common Python anti-patterns will help you write cleaner, more efficient, and maintainable code.</p>
			<p>First, we presented common Python code style violations. Then we discussed several anti-patterns that are related to correctness and can lead to bugs. Next, we covered practices that, beyond the code style itself, are not good for code readability and maintainability. Finally, we saw a couple of anti-patterns that one should avoid for writing code that has good performance.</p>
			<p>Always remember – the best code is not just about making it work but also about making it work well. Even more, ideally, it should be easy to maintain.</p>
			<p>We finally reached the end of this book. It was quite a journey. We started with the main design principles, then moved on to cover the most popular design patterns in the way they can be applied to Python, and finally touched upon Python anti-patterns. That’s a lot! The ideas and examples we discussed help us to think about different implementation options or techniques to choose from whenever we have a use case. Whatever the solution you choose, keep in mind that Python favors simplicity, try to use patterns and techniques that are considered Pythonic, and avoid Python’s anti-patterns.</p>
		</div>
	</body></html>