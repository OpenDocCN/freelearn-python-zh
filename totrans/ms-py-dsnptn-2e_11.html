<html><head></head><body>
		<div id="_idContainer034">
			<h1 id="_idParaDest-249" class="chapter-number"><a id="_idTextAnchor273"/>11</h1>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor274"/>Python Anti-Patterns</h1>
			<p>In this final chapter, we will explore Python anti-patterns. These are common programming practices that, while not necessarily wrong, often lead to less efficient, less readable, and less maintainable code. By understanding these pitfalls, you can write cleaner, more efficient code for your <span class="No-Break">Python applications.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Code <span class="No-Break">style violations</span></li>
				<li><span class="No-Break">Correctness anti-patterns</span></li>
				<li><span class="No-Break">Maintainability anti-patterns</span></li>
				<li><span class="No-Break">Performance anti-patterns</span></li>
			</ul>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor275"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor276"/>Code style violations</h1>
			<p>The <a id="_idIndexMarker979"/>Python style guide, also<a id="_idIndexMarker980"/> known as <strong class="bold">Python Enhancement Proposal no 8</strong> (<strong class="bold">PEP 8</strong>), provides recommendations for readability and consistency in your code, making it easier for developers to collaborate and maintain projects over time. You can find the style guide details on its official page <a id="_idIndexMarker981"/>here: <a href="https://peps.python.org/pep-0008">https://peps.python.org/pep-0008</a>. In this section, we are going to present some of the recommendations of the style guide so that you can avoid them when writing your application’s or <span class="No-Break">library’s code.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor277"/>Tools for fixing coding style violations</h1>
			<p>Note that we have <a id="_idIndexMarker982"/>formatting tools <a id="_idIndexMarker983"/>such as <em class="italic">Black</em> (<a href="https://black.readthedocs.io/en/stable/">https://black.readthedocs.io/en/stable/</a>), <em class="italic">isort</em> (<a href="https://pycqa.github.io/isort/">https://pycqa.github.io/isort/</a>), and/or <em class="italic">Ruff</em> (<a href="https://docs.astral.sh/ruff/">https://docs.astral.sh/ruff/</a>) that can help you fix code that does not <a id="_idIndexMarker984"/>follow the <a id="_idIndexMarker985"/>style guide recommendations. We are not going to spend time on how to use these tools here since you can find all the needed documentation on their official documentation pages and start using them in a matter <span class="No-Break">of minutes.</span></p>
			<p>Now, let’s explore our selected code <span class="No-Break">style recommendations.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor278"/>Indentation</h2>
			<p>You should use four spaces per indentation<a id="_idIndexMarker986"/> level, and you should avoid mixing tabs <span class="No-Break">and spaces.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor279"/>Maximum line length and blank lines</h2>
			<p>The style guide <a id="_idIndexMarker987"/>recommends limiting all lines <a id="_idIndexMarker988"/>of code to a maximum of 79 characters, for <span class="No-Break">better readability.</span></p>
			<p>Also, there are rules related to blank lines. First, you should surround top-level function and class definitions with two blank lines. Second, method definitions inside a class should be surrounded by a single <span class="No-Break">blank line.</span></p>
			<p>For example, the formatting with the following code snippet <span class="No-Break">is incorrect:</span></p>
			<pre class="source-code">
class MyClass:
    def method1(self):
        pass
    def method2(self):
        pass
def top_level_function():
    pass</pre>			<p>The right formatting is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class MyClass:
    def method1(self):
        pass
    def method2(self):
        pass
def top_level_function():
    pass</pre>			<h2 id="_idParaDest-256"><a id="_idTextAnchor280"/>Imports</h2>
			<p>The way you write, organize, and<a id="_idIndexMarker989"/> order your import lines is also important. According to the style guide, imports should be on separate lines and grouped into three categories in this order: standard library imports, related third-party imports, and local-specific imports within the application’s or library’s code base. Also, each group should be separated by a <span class="No-Break">blank line.</span></p>
			<p>For example, the following is not compliant with the <span class="No-Break">style guide:</span></p>
			<pre class="source-code">
import os, sys
import numpy as np
from mymodule import myfunction</pre>			<p>The best practice for the same imports is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
import os
import sys
import numpy as np
from mymodule import myfunction</pre>			<h2 id="_idParaDest-257"><a id="_idTextAnchor281"/>Naming conventions</h2>
			<p>You should use descriptive <a id="_idIndexMarker990"/>names for variables, functions, classes, and modules. The following are specific naming conventions for different types <span class="No-Break">of cases:</span></p>
			<ul>
				<li><strong class="bold">Name for function and variable (including class attributes and methods)</strong>: <span class="No-Break">Use </span><span class="No-Break"><strong class="source-inline">lower_case_with_underscores</strong></span></li>
				<li><strong class="bold">Name for class</strong>: <span class="No-Break">Use </span><span class="No-Break"><strong class="source-inline">CapWords</strong></span></li>
				<li><strong class="bold">Name for constant</strong>: <span class="No-Break">Use </span><span class="No-Break"><strong class="source-inline">ALL_CAPS_WITH_UNDERSCORES</strong></span></li>
			</ul>
			<p>For example, the following is not <span class="No-Break">good practice:</span></p>
			<pre class="source-code">
def calculateSum(a, b):
    return a + b
class my_class:
    pass
maxValue = 100</pre>			<p>The best practice is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
def calculate_sum(a, b):
    return a + b
class MyClass:
    pass
MAX_VALUE = 100</pre>			<h2 id="_idParaDest-258"><a id="_idTextAnchor282"/>Comments</h2>
			<p>Comments should be <a id="_idIndexMarker991"/>complete sentences, with the first word capitalized, and should be clear and concise. We have specific recommendations for two cases of comments—block comments and <span class="No-Break">inline comments:</span></p>
			<ul>
				<li>Block comments generally apply to some (or all) code that follows them and are indented to the same level as that code. Each line of a block comment starts with <strong class="source-inline">#</strong> and a <span class="No-Break">single space.</span></li>
				<li>Inline comments should be used sparingly. An inline comment is placed on the same line as a statement, separated by at least two spaces from <span class="No-Break">the statement.</span></li>
			</ul>
			<p>For example, in the following, we have a bad <span class="No-Break">comment style:</span></p>
			<pre class="source-code">
#This is a poorly formatted block comment.
def foo():  #This is a poorly formatted inline comment.
    pass</pre>			<p>Here is the equivalent code, with the <span class="No-Break">style fixed:</span></p>
			<pre class="source-code">
# This is a block comment.
# It spans multiple lines.
def foo():
    pass  # This is an inline comment.</pre>			<h2 id="_idParaDest-259"><a id="_idTextAnchor283"/>Whitespace in expressions and statements</h2>
			<p>You should avoid <a id="_idIndexMarker992"/>extraneous whitespace in the <span class="No-Break">following situations:</span></p>
			<ul>
				<li>Immediately inside parentheses, brackets, <span class="No-Break">or braces</span></li>
				<li>Immediately before a comma, semicolon, <span class="No-Break">or colon</span></li>
				<li>More than one space around an assignment operator to align it <span class="No-Break">with another</span></li>
			</ul>
			<p>This ends our<a id="_idIndexMarker993"/> review of the most common code style violations to pay attention to. As previously said, there are tools to detect and fix such violations in your code in a productive way, and they are generally included in the developer workflow (for example, via <strong class="source-inline">git commit</strong> hooks and/or in the project’s <span class="No-Break">CI/CD processes).</span></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor284"/>Correctness anti-patterns</h1>
			<p>These anti-patterns can <a id="_idIndexMarker994"/>lead to bugs or unintended behavior if not addressed. We are going to discuss the most common of these anti-patterns and alternative, recommended ways and approaches. We are going to focus on the <span class="No-Break">following anti-patterns:</span></p>
			<ul>
				<li>Using the <strong class="source-inline">type()</strong> function for <span class="No-Break">comparing types</span></li>
				<li>Mutable <span class="No-Break">default argument</span></li>
				<li>Accessing a protected member from outside <span class="No-Break">a class</span></li>
			</ul>
			<p>Note that using IDEs such as <em class="italic">Visual Studio Code</em> or <em class="italic">PyCharm</em> or command-line tools such as <em class="italic">Flake8</em> will help you spot such bad practices in your code, but it is important to know the recommendations and the reason behind <span class="No-Break">each one.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor285"/>Using the type() function for comparing types</h2>
			<p>Sometimes, we<a id="_idIndexMarker995"/> need to identify the type of a value through comparison, for our algorithm. The common technique one may think of for that is to use the <strong class="source-inline">type()</strong> function. But using <strong class="source-inline">type()</strong> to compare object types does not account for subclassing and is not as flexible as the alternative which is based on using the <span class="No-Break"><strong class="source-inline">isinstance()</strong></span><span class="No-Break"> function.</span></p>
			<p>Imagine we have two classes, <strong class="source-inline">CustomListA</strong> and <strong class="source-inline">CustomListB</strong>, that are subclasses of the <strong class="source-inline">UserList</strong> class, which is the recommended class one should inherit from when defining a class for a custom list, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
from collections import UserList
class CustomListA(UserList):
    pass
class CustomListB(UserList):
    pass</pre>			<p>If we wanted to check if an object is of one of the custom list types, using the first approach, we would test the <strong class="source-inline">type(obj) in (CustomListA, </strong><span class="No-Break"><strong class="source-inline">CustomListB)</strong></span><span class="No-Break"> condition.</span></p>
			<p>Alternatively, we would simply test <strong class="source-inline">isinstance(obj, UserList)</strong>, and that would be enough since <strong class="source-inline">CustomListA</strong> and <strong class="source-inline">CustomListB</strong> are subclasses <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">UserList</strong></span><span class="No-Break">.</span></p>
			<p>As a<a id="_idIndexMarker996"/> demonstration, we write a <strong class="source-inline">compare()</strong> function that uses the first approach, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def compare(obj):
    if type(obj) in (CustomListA, CustomListB):
        print("It's a custom list!")
    else:
        print("It's a something else!")</pre>			<p>Then, we write a <strong class="source-inline">better_compare()</strong> function to do the equivalent using the alternative approach, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def better_compare(obj):
    if isinstance(obj, UserList):
        print("It's a custom list!")
    else:
        print("It's a something else!")</pre>			<p>The following lines of code can help test <span class="No-Break">both functions:</span></p>
			<pre class="source-code">
obj1 = CustomListA([1, 2, 3])
obj2 = CustomListB(["a", "b", "c"])
compare(obj1)
compare(obj2)
better_compare(obj1)
better_compare(obj2)</pre>			<p>The <a id="_idIndexMarker997"/>complete demonstration code is in the <strong class="source-inline">ch11/compare_types.py</strong> file. Running the <strong class="source-inline">python ch11/compare_types.py</strong> command should give the <span class="No-Break">following output:</span></p>
			<pre class="console">
It's a custom list!
It's a custom list!
It's a custom list!
It's a custom list!</pre>			<p>This shows that both functions can produce the expected result. But the function using the recommended technique, <strong class="source-inline">isinstance()</strong>, is simpler to write and more flexible since it takes subclasses <span class="No-Break">into account.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor286"/>Mutable default argument</h2>
			<p>When you define a function with a <a id="_idIndexMarker998"/>parameter that expects a mutable value, such as a list or a dictionary, you may be tempted to provide a default argument (<strong class="source-inline">[]</strong> or <strong class="source-inline">{}</strong> respectively). But such a function retains changes between calls, which will lead to <span class="No-Break">unexpected behaviors.</span></p>
			<p>The recommended practice is to use a default value of <strong class="source-inline">None</strong> and set it to a mutable data structure within the function <span class="No-Break">if needed.</span></p>
			<p>Let’s <a id="_idIndexMarker999"/>create a function called <strong class="source-inline">manipulate()</strong> whose <strong class="source-inline">mylist</strong> parameter has a default value of <strong class="source-inline">[]</strong>. The function appends the <strong class="source-inline">"test"</strong> string to the <strong class="source-inline">mylist</strong> list and then returns it, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def manipulate(mylist=[]):
    mylist.append("test")
    return mylist</pre>			<p>In another function called <strong class="source-inline">better_manipulate()</strong> whose <strong class="source-inline">mylist</strong> parameter has a default value of <strong class="source-inline">None</strong>, we start by setting <strong class="source-inline">mylist</strong> to <strong class="source-inline">[]</strong> if it is <strong class="source-inline">None</strong>, then we append the <strong class="source-inline">"test"</strong> string to <strong class="source-inline">mylist</strong> before returning it, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def better_manipulate(mylist=None):
    if not mylist:
        mylist = []
    mylist.append("test")
    return mylist</pre>			<p>The following lines help us test each function by calling it several times with the <span class="No-Break">default argument:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    print("function manipulate()")
    print(manipulate())
    print(manipulate())
    print(manipulate())
    print("function better_manipulate()")
    print(better_manipulate())
    print(better_manipulate())</pre>			<p>Running<a id="_idIndexMarker1000"/> the <strong class="source-inline">python ch11/mutable_default_argument.py</strong> command should give the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">function manipulate()</strong>
<strong class="bold">['test']</strong>
<strong class="bold">['test', 'test']</strong>
<strong class="bold">['test', 'test', 'test']</strong>
<strong class="bold">function better_manipulate()</strong>
<strong class="bold">['test']</strong>
<strong class="bold">['test']</strong></pre>			<p>As you can see, with the non-recommended way of doing this, we end up with the <strong class="source-inline">"test"</strong> string several times in the list returned; the string is accumulating because each subsequent time the function has been called, the <strong class="source-inline">mylist</strong> argument kept its previous value instead of being reset to the empty list. But, with the recommended solution, we see with the result that we get the <span class="No-Break">expected behavior.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor287"/>Accessing a protected member from outside a class</h2>
			<p>Accessing a <a id="_idIndexMarker1001"/>protected member (an attribute prefixed with <strong class="source-inline">_</strong>) of a class from outside that class usually calls for trouble since the creator of that class did not intend this member to be exposed. Someone maintaining the code could change or rename that attribute later down the road, and parts of the code accessing it could result in <span class="No-Break">unexpected behavior.</span></p>
			<p>If you have code that accesses a protected member that way, the recommended practice is to refactor that code so that it is part of the public interface of <span class="No-Break">the class.</span></p>
			<p>To demonstrate this, let’s define a <strong class="source-inline">Book</strong> class with two protected attributes, <strong class="source-inline">_title</strong> and <strong class="source-inline">_author</strong>, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Book:
    def __init__(self, title, author):
        self._title = title
        self._author = author</pre>			<p>Now, let’s create another class, <strong class="source-inline">BetterBook</strong>, with the same attributes and a <strong class="source-inline">presentation_line()</strong> method that accesses the <strong class="source-inline">_title</strong> and <strong class="source-inline">_author</strong> attributes and<a id="_idIndexMarker1002"/> returns a concatenated string based on them. The class definition is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class BetterBook:
    def __init__(self, title, author):
        self._title = title
        self._author = author
    def presentation_line(self):
        return f"{self._title} by {self._author}"</pre>			<p>Finally, in the code for testing both classes, we get and print the presentation line for an instance of each class, accessing the protected members for the first one (instance of <strong class="source-inline">Book</strong>) and calling the <strong class="source-inline">presentation_line()</strong> method for the second one (instance of <strong class="source-inline">BetterBook</strong>), <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    b1 = Book(
        "Mastering Object-Oriented Python",
        "Steven F. Lott",
    )
    print(
        "Bad practice: Direct access of protected members"
    )
    print(f"{b1._title} by {b1._author}")
    b2 = BetterBook(
        "Python Algorithms",
        "Magnus Lie Hetland",
    )
    print(
        "Recommended: Access via the public interface"
    )
    print(b2.presentation_line())</pre>			<p>The complete <a id="_idIndexMarker1003"/>code is in the <strong class="source-inline">ch11/ protected_member_of_class.py</strong> file. Running the <strong class="source-inline">python ch11/ protected_member_of_class.py</strong> command gives the <span class="No-Break">following output:</span></p>
			<pre class="console">
Bad practice: Direct access of protected members
Mastering Object-Oriented Python by Steven F. Lott
Recommended: Access via the public interface
Python Algorithms by Magnus Lie Hetland</pre>			<p>This shows that we get the same result, without any error, in both cases, but using the <strong class="source-inline">presentation_line()</strong> method, as done in the case of the second class, is the best practice. The <strong class="source-inline">_title</strong> and <strong class="source-inline">_author</strong> attributes are protected, so it is not recommended to call them directly. The developer could change those attributes in the future. That is why they must be encapsulated in a <span class="No-Break">public method.</span></p>
			<p>Also, it is good practice to provide an attribute that encapsulates each protected member of the class using the <strong class="source-inline">@property</strong> decorator, as we have seen in the <em class="italic">Techniques for achieving encapsulation</em> section of <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational </em><span class="No-Break"><em class="italic">Design Principles</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor288"/>Maintainability anti-patterns</h1>
			<p>These anti-patterns make your code difficult to<a id="_idIndexMarker1004"/> understand or maintain over time. We are going to discuss several anti-patterns that should be avoided for better quality in your Python application or library’s code base. We will focus on the <span class="No-Break">following points:</span></p>
			<ul>
				<li>Using a <a id="_idIndexMarker1005"/><span class="No-Break">wildcard import</span></li>
				<li><strong class="bold">Look Before You Leap</strong> (<strong class="bold">LBYL</strong>) versus <strong class="bold">Easier to Ask for Forgiveness than </strong><span class="No-Break"><strong class="bold">Permission</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">EAFP</strong></span><span class="No-Break">)</span></li>
				<li>Overusing <a id="_idIndexMarker1006"/>inheritance and <span class="No-Break">tight coupling</span></li>
				<li>Using global variables for sharing data <span class="No-Break">between functions</span></li>
			</ul>
			<p>As mentioned for the previous category of anti-patterns, using tools such as Flake8 as part of your developer workflow can be handy to help find some of those potential issues when they are already present in <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor289"/>Using a wildcard import</h2>
			<p>This way of <a id="_idIndexMarker1007"/>importing (<strong class="source-inline">from mymodule import *</strong>) can clutter the namespace and make it difficult to determine where an imported variable or function came from. Also, the code may end up with bugs because of <span class="No-Break">name collision.</span></p>
			<p>The best practice is to use specific imports or import the module itself to <span class="No-Break">maintain clarity.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor290"/>LBYL versus EAFP</h2>
			<p>LBYL often leads to more <a id="_idIndexMarker1008"/>cluttered code, while EAFP makes use of Python’s handling of exceptions and tends to <span class="No-Break">be cleaner.</span></p>
			<p>For example, we may want to check if a file exists, before opening it, with code such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if os.path.exists(filename):
    with open(filename) as f:
        print(f.text)</pre>			<p>This is<a id="_idIndexMarker1009"/> LBYL, and when new to Python, you would think that it is the right way to treat such situations. But in Python, it is recommended to favor EAFP, where appropriate, for cleaner, more Pythonic code. So, the recommended way for the expected result would give the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
try:
    with open(filename) as f:
        print(f.text)
except FileNotFoundError:
    print("No file there")</pre>			<p>As a demonstration, let’s write a <strong class="source-inline">test_open_file()</strong> function that uses the LBYL approach, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def test_open_file(filename):
    if os.path.exists(filename):
        with open(filename) as f:
            print(f.text)
    else:
        print("No file there")</pre>			<p>Then, we add a function that uses the <span class="No-Break">recommended approach:</span></p>
			<pre class="source-code">
def better_test_open_file(filename):
    try:
        with open(filename) as f:
            print(f.text)
    except FileNotFoundError:
        print("No file there")</pre>			<p>We can then test these functions with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
filename = "no_file.txt"
test_open_file(filename)
better_test_open_file(filename)</pre>			<p>You can check the complete code of the example in the <strong class="source-inline">ch11/lbyl_vs_eafp.py</strong> file, and running it should give the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">No file there</strong>
<strong class="bold">No file there</strong></pre>			<p>This output <a id="_idIndexMarker1010"/>shows us that both approaches give the same outcome, but the <strong class="source-inline">try</strong>/<strong class="source-inline">except</strong> way makes our <span class="No-Break">code cleaner.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor291"/>Overusing inheritance and tight coupling</h2>
			<p>Inheritance is a <a id="_idIndexMarker1011"/>powerful feature of OOP, but overusing it – for example, creating a new class for every slight variation of behavior – can lead to tight coupling between classes. This increases complexity and makes the code less flexible and harder <span class="No-Break">to maintain.</span></p>
			<p>It is not recommended to create a deep inheritance hierarchy such as the following (as a <span class="No-Break">simplified example):</span></p>
			<pre class="source-code">
class GrandParent:
    pass
class Parent(GrandParent):
    pass
class Child(Parent):
    Pass</pre>			<p>The best practice is<a id="_idIndexMarker1012"/> to create smaller, more focused classes and combine them to achieve the desired behavior, as with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
class Parent:
    pass
class Child:
    def __init__(self, parent):
        self.parent = parent</pre>			<p>As you may remember, this is the composition approach, which we discussed in the <em class="italic">Following the Favor Composition over Inheritance principle</em> section of <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Foundational </em><span class="No-Break"><em class="italic">Design Principles</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor292"/>Using global variables for sharing data between functions</h2>
			<p>Global variables <a id="_idIndexMarker1013"/>are variables that are accessible througho<a id="_idTextAnchor293"/>ut the entire program, making them tempting to use for sharing data between functions—for example, configuration settings that are used across multiple modules or shared resources such as <span class="No-Break">database connections.</span></p>
			<p>However, they can lead to bugs where different parts of the application unexpectedly modify global state. Also, they make it harder to scale applications as they can lead to issues in multithreaded environments where multiple threads might attempt to modify the global <span class="No-Break">variable simultaneously.</span></p>
			<p>Here is an example of the <span class="No-Break">non-recommended practice:</span></p>
			<pre class="source-code">
# Global variable
counter = 0
def increment():
    global counter
    counter += 1
def reset():
    global counter
    counter = 0</pre>			<p>Instead of using a global variable, you should pass the needed data as arguments to functions or encapsulate state within a class, which improves the modularity and testability of the code. So, the best-practice equivalent for the counterexample would be <a id="_idIndexMarker1014"/>defining a <strong class="source-inline">Counter</strong> class holding a <strong class="source-inline">counter</strong> attribute, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
class Counter:
    def __init__(self):
        self.counter = 0
    def increment(self):
        self.counter += 1
    def reset(self):
        self.counter = 0</pre>			<p>Next, we add code for testing the <strong class="source-inline">Counter</strong> class <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    c = Counter()
    print(f"Counter value: {c.counter}")
    c.increment()
    print(f"Counter value: {c.counter}")
    c.reset()</pre>			<p>You can<a id="_idIndexMarker1015"/> check the complete code of the example in the  <strong class="source-inline">ch11/instead_of_global_variable.py</strong> file, and running it should give the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">Counter value: 0</strong>
<strong class="bold">Counter value: 1</strong></pre>			<p>This shows how using a class instead of global variables is effective and can be scalable, thus the <span class="No-Break">recommended practice.</span></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor294"/>Performance anti-patterns</h1>
			<p>These anti-patterns<a id="_idIndexMarker1016"/> lead to inefficiencies that can degrade performance, especially noticeable in large-scale applications or data-intensive tasks. We will focus on the following <span class="No-Break">such anti-patterns:</span></p>
			<ul>
				<li>Not using <strong class="source-inline">.join()</strong> to concatenate strings in <span class="No-Break">a loop</span></li>
				<li>Using global variables <span class="No-Break">for caching</span></li>
			</ul>
			<p><span class="No-Break">Let’s start.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor295"/>Not using .join() to concatenate strings in a loop</h2>
			<p>Concatenating <a id="_idIndexMarker1017"/>strings with <strong class="source-inline">+</strong> or <strong class="source-inline">+=</strong> in a loop creates a new string object each time, which is inefficient. The best solution is to use the <strong class="source-inline">.join()</strong> method on strings, which is designed for efficiency when concatenating strings from a sequence <span class="No-Break">or iterable.</span></p>
			<p>Let’s create a <strong class="source-inline">concatenate()</strong> function where we use <strong class="source-inline">+=</strong> for concatenating items from a list of strings, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def concatenate(string_list):
    result = ""
    for item in string_list:
        result += item
    return result</pre>			<p>Then, let’s create a <strong class="source-inline">better_concatenate()</strong> function for the same result, but using the <strong class="source-inline">str.join()</strong> method, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def better_concatenate(string_list):
    result = "".join(string_list)
    return result</pre>			<p>We can then test both functions using <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    string_list = ["Abc", "Def", "Ghi"]
    print(concatenate(string_list))
    print(better_concatenate(string_list))</pre>			<p>Running the code (in the <strong class="source-inline">ch11/concatenate_strings_in_loop.py</strong> file) gives the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">AbcDefGhi</strong>
<strong class="bold">AbcDefGhi</strong></pre>			<p>This confirms that<a id="_idIndexMarker1018"/> both techniques produce the same result, though using <strong class="source-inline">.join()</strong> is the recommended practice for <span class="No-Break">performance reasons.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor296"/>Using global variables for caching</h2>
			<p>Using global variables <a id="_idIndexMarker1019"/>for caching can seem like a quick and easy solution but often leads to poor maintainability, potential data consistency issues, and difficulties in managing the cache life cycle effectively. A more robust approach involves using specialized caching libraries designed to handle these aspects <span class="No-Break">more efficiently.</span></p>
			<p>In this example (in the <strong class="source-inline">ch11/caching/using_global_var.py</strong> file), a global dictionary is used to cache results from a function that simulates a time-consuming operation (for example, a database query) done in the <strong class="source-inline">perform_expensive_operation()</strong> function. The <a id="_idIndexMarker1020"/>complete code for this demonstration is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import time
import random
# Global variable as cache
_cache = {}
def get_data(query):
    if query in _cache:
        return _cache[query]
    else:
        result = perform_expensive_operation(query)
        _cache[query] = result
        return result
def perform_expensive_operation(user_id):
    time.sleep(random.uniform(0.5, 2.0))
    user_data = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"},
        3: {"name": "Charlie", "email": "charlie@example.com"},
    }
    result = user_data.get(user_id, {"error": "User not found"})
    return result
if __name__ == "__main__":
    print(get_data(1))
    print(get_data(1))</pre>			<p>Testing the code by running the <strong class="source-inline">python ch11/caching/using_global_var.py</strong> command gives the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
<strong class="bold">{'name': 'Alice', 'email': 'alice@example.com'}</strong>
<strong class="bold">{'name': 'Alice', 'email': 'alice@example.com'}</strong></pre>			<p>This works as<a id="_idIndexMarker1021"/> expected, but there is a better approach. We can use a specialized caching library or Python’s built-in <strong class="source-inline">functools.lru_cache()</strong> function. The <strong class="source-inline">lru_cache</strong> decorator provides<a id="_idIndexMarker1022"/> a <strong class="bold">least recently used</strong> (<strong class="bold">LRU</strong>) cache, automatically managing the size and lifetime of cache entries. Also, it is thread-safe, which helps prevent issues that can arise in a multithreaded environment when multiple threads access or modify the cache simultaneously. Finally, libraries or tools such as <strong class="source-inline">lru_cache</strong> are optimized for performance, using efficient data structures and algorithms to manage <span class="No-Break">the cache.</span></p>
			<p>Here’s how you can implement the functionality of caching results from a time-consuming function using <strong class="source-inline">functools.lru_cache</strong>. The complete code (in the <strong class="source-inline">ch11/caching/using_lru_cache.py</strong> file) is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import random
import time
from functools import lru_cache
@lru_cache(maxsize=100)
def get_data(user_id):
    return perform_expensive_operation(user_id)
def perform_expensive_operation(user_id):
    time.sleep(random.uniform(0.5, 2.0))
    user_data = {
        1: {"name": "Alice", "email": "alice@example.com"},
        2: {"name": "Bob", "email": "bob@example.com"},
        3: {"name": "Charlie", "email": "charlie@example.com"},
    }
    result = user_data.get(user_id, {"error": "User not found"})
    return result
if __name__ == "__main__":
    print(get_data(1))
    print(get_data(1))
    print(get_data(2))
    print(get_data(99))</pre>			<p>To test this<a id="_idIndexMarker1023"/> code, run the <strong class="source-inline">python ch11/caching/using_lru_cache.py</strong>  command. You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
{'name': 'Alice', 'email': 'alice@example.com'}
{'name': 'Alice', 'email': 'alice@example.com'}
{'name': 'Bob', 'email': 'bob@example.com'}
{'error': 'User not found'}</pre>			<p>As we can see, this approach not only enhances the robustness of the caching mechanism but also improves code readability <span class="No-Break">and maintainability.</span></p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor297"/>Summary</h1>
			<p>Understanding and avoiding common Python anti-patterns will help you write cleaner, more efficient, and <span class="No-Break">maintainable code.</span></p>
			<p>First, we presented common Python code style violations. Then we discussed several anti-patterns that are related to correctness and can lead to bugs. Next, we covered practices that, beyond the code style itself, are not good for code readability and maintainability. Finally, we saw a couple of anti-patterns that one should avoid for writing code that has <span class="No-Break">good performance.</span></p>
			<p>Always remember – the best code is not just about making it work but also about making it work well. Even more, ideally, it should be easy <span class="No-Break">to maintain.</span></p>
			<p>We finally reached the end of this book. It was quite a journey. We started with the main design principles, then moved on to cover the most popular design patterns in the way they can be applied to Python, and finally touched upon Python anti-patterns. That’s a lot! The ideas and examples we discussed help us to think about different implementation options or techniques to choose from whenever we have a use case. Whatever the solution you choose, keep in mind that Python favors simplicity, try to use patterns and techniques that are considered Pythonic, and avoid <span class="No-Break">Python’s anti-patterns.</span></p>
		</div>
	</body></html>