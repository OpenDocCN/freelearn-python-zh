- en: Metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed asynchronous I/O and coroutines. In this
    chapter, we turn our attention to metaprogramming and programmable syntax. We'll
    discuss various ways that Python allows us to control or alter the meaning of
    syntactic elements and use these features beneficially.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at another programmable syntax feature of Python that meshes nicely
    with function decorators. We'll also discuss class decorators and how they're
    similar to, and different from, function decorators. Then we'll see a different
    way of programmatically modifying classes using metaclasses. We'll move on to
    a less esoteric topic and discuss context managers. Finally, we'll look at one
    more way of programming the semantics of basic Python operations when we look
    at descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming is a blanket term for techniques where programs use program
    code or data structures constructed directly from program code as data to be manipulated.
    Python has a number of different features that can be thought of as metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using function decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descriptors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using function decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at one of the most ubiquitous **function
    decorators**. We'll see how to construct a decorator, how to use it, and how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic definition of a decorator is simple. It''s just a function that takes
    another function as its input, does something with it, and then returns the result
    of its operations, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51381066-7461-4764-b3a1-13cf3f4d4a70.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The return value replaces the original input function, so the changes a decorator
    can make are potentially quite drastic. A decorator that doesn't change anything
    at all is a function that accepts one parameter and immediately returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @ syntax in a function decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has a special syntax for applying a decorator to a function, using the
    `@` syntax. With this syntax, we just write an `@` symbol, followed by an expression
    that evaluates to a decorator function. We put that on the line right before the
    definition of the function we want to decorate, as shown in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e18b84c-bb01-4eef-9114-7ae309e8ab52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This syntax means that as soon as we''re done defining the function, we call
    the decorator function on it and then assign the return value of the decorator
    to the variable that would have contained the function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d716911d-7c64-49ce-9e32-5e8b56b94478.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Global decorator - @staticmethod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python includes a few decorators in the global namespace and an expanding list
    of them in the standard library. The most commonly used global decorator is `@staticmethod`.
    It makes the class member function callable through the class, rather than an
    instance, just like `@staticmethod` decorators in other languages. The following
    screenshot illustrates the code example for `@staticmethod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d82efa3-3883-4ea2-8aa9-2404de41e4e5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s also possible to use multiple `@` lines before `def`; with this, multiple
    decorators will be invoked. The decorator that''s closest to `def` will be called
    first, and then its return value will be passed to the next closest decorator,
    and so on. Eventually, the return value of the topmost decorator will be assigned
    to the function''s name in the containing scope, as shown in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67e98fdd-2068-47b4-ab75-1ec9e9144f8b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common uses of decorators—in fact, the reason they're called
    decorators—is to add attributes to function objects. These attributes can be used
    by code in other parts of the program to distinguish decorated functions from
    each other and from under undecorated functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes is easy. Inside the decorator, assign an attribute to the
    function, just like we would for any other object, and then return it. Then, elsewhere
    in the code, check for the attribute and respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: That's all well and good and often quite useful, but we could do a lot more
    with decorators. For example, we can enclose the function in a wrapper that performs
    some computation before or after calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Enclosing the function in a wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To enclose a function in a wrapper, first we want the function to find the wrapper
    inside a decorator (refer to the following code example). If you haven't seen
    this before, it is exactly how it looks—the definition of a `wrapper` function
    actually lies inside of `@ints_only`. So when `@ints_only` is called, it defines
    and then returns the `wrapper` function.
  prefs: []
  type: TYPE_NORMAL
- en: Each time `@ints_only` is called, it defines a new `wrapper` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is defined inside another function, the containing function''s
    local variables remain available to the inner function. Refer to the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75ea39d1-3bec-4a89-a827-2ff4b3cf394c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding case, the `wrapper` does some manipulation of the function
    arguments and then calls the wrapped function and returns its results. We imported
    and used the decorator called `@wraps` in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: The `@wraps` decorator's job is pretty straightforward; it makes the wrapper
    look like a wrapped function for tools such as `pydoc`. However, `@wraps` takes
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work if the decorator always accepts just one parameter and that's
    the function it's being applied to? Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: The @wraps decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key is that the `@` symbol isn't followed by the name of a decorator per
    se; it's followed by an expression that evaluates to a decorator. So, wraps isn't
    actually a decorator. Strictly speaking, it's a function that returns the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: When Python evaluates the function call expression, `@wraps` returns a decorator
    function, which is then applied to our wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: The only function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we were to modify our `@ints_only` decorator so that we could specify an
    arbitrary function that could be applied to all the parameters, it would look
    like the preceding example. So now we have a function called `only`, which returns
    a decorator, which in turn returns a wrapper. This wrapper calls the original
    function.
  prefs: []
  type: TYPE_NORMAL
- en: That might look terribly inefficient, but in fact the only overhead comes from
    invoking the wrapper. Each time we call the function, the outer two layers of
    code only run once when the function is defined. So that's how you use function
    decorators and taste the sort of things we can use them for.
  prefs: []
  type: TYPE_NORMAL
- en: Function annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a look at how to associate metadata with functions
    beyond docstrings, which we discussed in [Chapter 4](f119f22a-e6c5-40aa-993a-f77c46c6e931.xhtml),
    *Basic Best Practices*. In the previous section, one of our examples was a decorator
    that automatically passed all our decorated function arguments through an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: That's pretty cool, but what if we want to handle each parameter differently?
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we could pass a whole bunch of adapters to the wrapper, but it becomes
    ugly and clumsy as we start dealing with functions that accept more parameters.
    What we'd really like to do is attach metadata directly to a function's parameters.
    Fortunately, that's exactly what function annotations are for.
  prefs: []
  type: TYPE_NORMAL
- en: Function annotation syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code example shows off Python''s function annotation syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4034570-ef3d-48c6-8bbb-62690b438bce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To associate a value with a parameter, we put a colon (`:`) after the parameter
    name and then write an expression. This expression will be evaluated when the
    function is defined and the result stored along with a parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: We can also annotate the return value of a function by writing a `->` arrow
    symbol after the function's parameter list and then an expression, which will
    also be evaluated when the function is defined. The result is stored along with
    the word `return`. Because `return` is a keyword, there is no chance that it will
    collide with a parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing annotation data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the annotations are stored in a dictionary called `__annotations__`, which
    is an attribute of the function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/575c82bf-0238-4b5f-bf6d-bf6a98862028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the preceding code example, annotations are not type declarations,
    though they could certainly be used for that purpose and they resemble the typing
    syntax used in some other languages, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4036a092-3ec6-4849-82ad-6fe8fcaaf69f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: They are arbitrary expressions, which means that arbitrary values can be stored
    in the `__annotations__` dictionary. They don't add any meaning to Python itself,
    except that it should store the values. That said, defining parameter and return
    types is a common use of function annotations.
  prefs: []
  type: TYPE_NORMAL
- en: The @no_type_check decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you find yourselves using a tool that assumes annotations are type declarations
    but you want to use them for some other purpose, use the standard `@no_type_check`
    decorator to exempt your function from such processing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc411a42-63d4-4823-9c30-000dc64896c5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Normally, this isn't needed because most tools that use annotations have a way
    of recognizing the ones meant for them. The decorator is for protecting corner
    cases where things are ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations as input to function decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations combine well with decorators because annotation values make a good
    way to provide input to a decorator, and decorator-generated wrappers are a good
    place to put code that gives meaning to annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s rewrite the decorator example from the previous section.
    We''ll switch to only accepting keyword arguments, just to keep the example relatively
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b420257-af28-4f46-a3de-ecbcf361539f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the `adapted` decorator encloses the function in a `wrapper`. This `wrapper`
    only accepts keyword arguments, which means that even, if the original function
    could accept positional arguments, they have to be specified by name.
  prefs: []
  type: TYPE_NORMAL
- en: Once the function is wrapped, `wrapper` also looks for adapters in the function's
    parameter annotations and applies them before passing the arguments to the real
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Once the function returns, the wrapper checks for a return value adapter; if
    it finds one, it applies it to the return value before finally returning it.
  prefs: []
  type: TYPE_NORMAL
- en: When we consider the implications of what's happening here, they're pretty impressive.
    We've actually modified what it means to pass a parameter to a function or return
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at another example (refer to the following example). Sometimes, one
    or more of a method's parameters don't require any processing, except assigning
    them to an attribute of self. Can we use decorators and annotations to make this
    happen automatically? Of course we can.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc0effef-5ecd-4373-b1bd-e5a849623f27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's say that if a parameter is annotated with a string, the value assigned
    to that parameter will be assigned to an attribute of self, using the string as
    the name. And if the parameter is annotated with true, the attribute will have
    the same name as the parameter. If there's no annotation or, if it's not a string
    or true, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Again, for simplicity's sake, let's limit ourselves to keyword arguments. As
    you can see in the preceding example, annotations simplify all sorts of code base
    manipulations of code. Here, we're basically using the same techniques as in the
    previous example but we're doing something entirely different with them.
  prefs: []
  type: TYPE_NORMAL
- en: We've been looking at decorators as the primary consumers of function annotations,
    but that's not necessarily the case. Any code that uses function objects might
    be written to benefit from annotations. This means, anywhere we pass a function
    as a callback, we could potentially use function annotation data to make the code
    smarter about what it does with the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the possibilities are presented in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers could be annotated with the names of the values the handler wants
    to receive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection could be automated in a similar way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraint-based systems could be provided with the constraints that could be
    applied to each parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probabilistic reasoning systems could be annotated with prior probability distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters could be annotated with the proper user interface element to display
    in order to have the user input that parameter's value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting the package signature function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we wrap up this section, I''d like to point out one thing that may be
    helpful down the road. Our example decorators that worked with annotations were
    all limited to keyword arguments for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03be0ba7-3f74-4b3b-8b16-a5d4821b8ace.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, if you find yourself wanting to do similar things and also handle all
    sorts of parameters at the same time, the `inspect` package's `signature` function
    will simplify the process significantly.
  prefs: []
  type: TYPE_NORMAL
- en: So, function annotations are a great way of adding metadata to functions; however,
    they might affect the handling of functions later in all sorts of ways.
  prefs: []
  type: TYPE_NORMAL
- en: Class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at class decorators, which are conceptually similar
    to function decorators but open different doors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Class decorators work in the same basic way that function decorators do. A
    class decorator receives the class as its only parameter, and whatever it returns
    replaces that class. This is illustrated in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d485a8e2-ce84-4f26-9116-164f4eb61116.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The return value doesn't have to be the same class or even a class at all, but
    it should be something that is meaningful. When it's bound to the class's name,
    it's rarely useful for a decorator to return none.
  prefs: []
  type: TYPE_NORMAL
- en: Also, like a function decorator, a class decorator can modify the attributes
    of the class or enclose the whole class in wrapper code. However, modifying the
    attributes of the class is effectively the same as modifying the class of the
    source code. This means that unlike functions, a class decorator can actually
    alter the structure of the decorated code, not just wrap it.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying class attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modifying class attributes is straightforward; we just use the built-in `getattr`,
    `setattr`, and `delattr` functions, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d0996ef-23ea-4594-91de-cdf706e31fdb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we see a simple class decorator that makes the attributes
    of the decorated class readable through the `[]` syntax; at the same time, it
    makes sure the class doesn't allow you to set or delete values through the `[]`
    syntax. While rewriting classes via decorators can be a powerful technique, it's
    not a complicated or surprising task, so there's nothing much to say about it.
  prefs: []
  type: TYPE_NORMAL
- en: We can also wrap up classes in their entirety. One common use of this technique
    is that it helps replace a class with a `factory` function. Using a `factory`
    function as an interface to create class instances lets us choose when to return
    an existing object, if there's one interface we think is more appropriate, rather
    than actually creating a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: The factory function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calling a `factory` function means *give me the right object for these parameters,
    rather than giving me a new object for these parameters*. Let's take a look at
    an example class decorator that replaces the class object with a factory function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instances of this class, we''ll assume that any two instances that were
    created with the same parameters should actually be the same object, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ee20857-154c-46f2-b84d-ac9ba4ced7ce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we used `WeakValueDictionary` to keep track of the
    existing instances of the class and what parameters that were constructed with.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't have anything to do with class decorators per se; instead, we did
    it because we didn't want the cache to prevent the instances from being garbage
    collected. That's a good practice!
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we make a `factory` function, it keeps track of the instances it creates.
    Another bit of good practice that we demonstrated in this example is that we decide
    the class itself as an attribute of the `factory` function. This means that the
    code outside of the `factory` function can still access the class object if it
    really needs to.
  prefs: []
  type: TYPE_NORMAL
- en: The factory_constructed function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s take a look at our factory-making decorator in action. Refer to
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/124cdda1-8000-4723-bbfb-c86d03b81482.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the thing named `Unique` is in fact the `factory` function that
    was created for the `Unique` class, rather than the `Unique` class itself. The
    actual class ends up being named `Unique.type`. Also, notice that `u1` and `u3`
    are not just equal but actually the same object; meanwhile, `u2`, which was created
    with different arguments, is different.
  prefs: []
  type: TYPE_NORMAL
- en: Class definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're going to take a look at something really wild. The syntax we use for
    defining classes is pretty generic; it could be used to represent all sorts of
    different data structures. So, why not use class decorators to transform class
    definitions into objects of various types?
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, we can achieve a sort of sideways decorative programming paradigm.
    For our example (the one that will follow), let''s say we want to connect to a
    sqlite database and create some tables in it if they don''t already exist. We
    can make Python''s class syntax work for us as a convenient way of expressing
    this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f19db3ba-1eb4-4ecb-a14d-5355650eebb1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want the usage to look something like this code example, where the class
    structure and attributes provide the information that's needed to construct and
    configure a database connection for us. The end result should be a `connection`
    object, which we can use to issue queries according to the Python Database API.
  prefs: []
  type: TYPE_NORMAL
- en: There are a great many details that are ignored or handled simplistically by
    this example, but it captures the general idea. The class objects that Python
    creates automatically, when it's evaluating these statements, are used to provide
    structured data input to the decorator called `@database` and then discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example shows the `@database` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e90cc3b4-abb2-4b91-9061-869a21cded79.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `@database` decorator returns an open Python Database API connection object,
    not a class of any sort.
  prefs: []
  type: TYPE_NORMAL
- en: Metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at metaclasses, which affect the creation of class
    objects right from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Like class decorators, metaclasses are a tool we can use to adjust the basic
    meaning of a class. In concept though, they're very different. A class decorator
    takes an already created class and transforms it in some way. A metaclass, on
    the other hand, can affect how a class is created, how it behaves, and even how
    classes that inherit from the modified class are created and behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand metaclasses, first we have to grasp the idea that classes are
    objects, and more than that, they are instances of another class called `type`.
    Whenever we create a new class, we create an instance of `type`, unless the class
    has a metaclass, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abd062ca-26bf-4088-ac38-43c25db46e64.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the class we're creating as a metaclass is specified or inherits a metaclass
    from its ancestors, then the new class is an instance of the metaclass rather
    than a direct instance of `type`.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds like we could change the behavior of a class completely by giving
    it an unusual metaclass, but actually all metaclasses have to resemble `type`
    or Python wouldn't be able to use them properly. Most of the time, metaclasses
    are actually subclasses of `type`, which makes things simple.
  prefs: []
  type: TYPE_NORMAL
- en: What can we do with a metaclass?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we can run code before the code inside the `class` block is evaluated
    for each class, which is an instance of the metaclass. We do this by having the
    metaclass set as a `__prepare__` method, which should be a class method or a static
    method because it will be called before the instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: The __prepare__method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `__prepare__` method is passed with the name of the new class and its list
    of parent classes as well as any keyword arguments supplied by the user. It can
    do whatever we want it to, but it should also return a dictionary or similar object
    that could be used to hold the class's attributes (refer to the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: We can preassign values to the attribute dictionary from inside of `__prepare__`,
    so we can actually assign attributes to the class before it even exists. That
    brings us to the second thing that metaclasses can easily control-the **class's
    namespace**.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, we returned a `dict()` instance from `__prepare__`,
    so instances of this metaclass use a normal dictionary to store their attributes
    while their code is being evaluated; however, we can return any dictionary-like
    object from `__prepare__`. For example, we can return `OrderedDict` if we want
    to keep track of the order in which attributes were created or `DefaultDict` if
    we want all the attributes to have a default value.
  prefs: []
  type: TYPE_NORMAL
- en: We could even use `WeakValueDictionary` if, for some reason, we want the class
    to not protect its attributes from being garbage collected while it is evaluated.
    Of course, `WeakValueDictionary` is a just dictionary-like class that exists in
    the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: We can also return a custom dictionary-like class from `__prepare__`, which
    could conceivably do almost anything. If we want a class that ignores the case
    of attribute names while its code is being evaluated, we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: The __new__ method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a reason why I keep saying *while the code is being evaluated*. After
    `__prepare__` is called, the code inside the class block is run and it uses the
    dictionary that was returned from `__prepare__` as its namespace, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eeef9e1d-33cc-4cde-8ea3-70d5d6abfb65.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, after that, the metaclass's `__new__` method is called. One of the
    things `__new__` needs to do is call `type.__new__` to actually allocate and initialize
    a chunk of memory to contain the class data, and one of the things `type.__new__`
    does is convert whatever we pass as a namespace for the object into a normal `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if we want to retain special information that our `namespace`
    object knows, we need to store it somewhere where we can find it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make whatever changes we want to the internals of the class, shown in
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f93207c8-a624-428f-bcf3-98414aacfb10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we've created the class object in the `__new__` method of the metaclass,
    we can programmatically add, remove, replace, or wrap the class contents, much
    as we could in a class decorator. We can also return something that isn't actually
    a class object at all, just as we could with a class decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The difference, aside from a bit of extra typing, is that the subclasses of
    a class that has a metaclass will also inherit that metaclass, while class decorators
    are not inherited.
  prefs: []
  type: TYPE_NORMAL
- en: This means that using a metaclass, we can make our unusual behaviors inheritable.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you learned that any class that descends from the class where
    the metaclass was originally applied can find all the other classes that also
    descend from that ancestor.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll look at what is maybe Python's most-used programmable
    semantic element—context managers.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers are pieces of code that plug into Python's `with` statement.
    A `with` statement contains a block of code, and the context manager is able to
    run its own code, both before and after that block is executed, along with the
    after code guaranteed to run no matter what happens in the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python standard library makes quite a lot of use of context managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`open` files can be used as context managers, which guarantees that the file
    will be closed at the end of the block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/02bd6e0c-88b2-4e73-83ff-6dc09dfccef1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`lock` objects could be used as context managers, in which case they acquire
    the lock before the block and release it when the block is finished executing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c5a6f978-1fbe-4ee0-a53e-f02daaf68173.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'SQLite database connections can be used as context managers, allowing them
    to automatically commit or roll back the transaction when the block finishes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8fa45d31-5e26-4665-9af5-93e6d3388439.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are other examples. We can already see in the preceding examples how useful
    context managers can be. They simplify the code by combining setup and cleanup,
    and they improve the code by guaranteeing that they will run the cleanup code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a context manager as a generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So how can we write our own context managers? There are two ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest is to use the `@contextlib.contextmanager` decorator on a generator
    function, as we see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e80dcba4-2c4f-4603-9052-6c36be7d0e5b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we create a context manager this way, we can write it as one continuous
    piece of code. We can think of the `yield` statement as a proxy for the whole
    code block that the `with` statement contains.
  prefs: []
  type: TYPE_NORMAL
- en: If this block raises an exception, it will look toward our context manager code
    as if the `yield` statement was responsible for raising that exception, so we
    can wrap it in a `try` statement to deal with any exceptions that might occur.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the `as` clause of the `with` statement when we used file opening as
    an example of a context manager (refer to the code example of the `open` file);
    it lets us find a value returned from the context manager to a variable accessible
    within the with block. If we yield a value from our context manager code, that
    value will be the one assigned through `as`.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we yield a function that prints the word `during`
    so that the entire result of our `with` statement is that it prints `before`,
    `during`, and `after`, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: Adding context manager behavior to a class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also write context managers by adding `__enter__` and `__exit__` methods
    to objects. Any object that properly implements these methods can be used as a
    context manager, which is how objects such as open files and database connections
    are able to work extra as context managers.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous-coroutine-based context managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example in which we create a specialized version of a dictionary,
    which could serve as a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ad893e2-79d5-4b4b-9352-dfdf85857900.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Within the scope of the `with` block, we can read and write data through the
    object that we returned from `__enter__`, but these changes will only be applied
    to the main dictionary. If the block exits without raising an exception, the return
    value of the inner method will be used by the `with` statement for the value to
    be assigned through the `as` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the following code example, the variable `trans` contains the `ChainMap`
    instance. `ChainMap` objects are dictionaries that can have a parent dictionary.
    If `'a'` looking in `ChainMap` fails, it tries to look up the same key in its
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e01cf9b-a024-440a-8da5-40e714ce565f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `__exit__` method needs to accept parameters that specify the types `exc_type`,
    `exc_val`, and `tb`, if an exception is raised in the `with` block. If no exception
    is raised, all these parameters will contain `None`. If an exception is raised,
    we would need to decide whether and how the context manager will handle them.
  prefs: []
  type: TYPE_NORMAL
- en: In our preceding example, we decided to apply the changes to the main dictionary
    based on whether or not an exception was raised; otherwise, we would have ignored
    the exception. If we want Python to consider the exception to be handled, we could
    return `true` from the `__exit__` method.
  prefs: []
  type: TYPE_NORMAL
- en: This would be functionally equivalent to catching the function with a `try-except`
    statement. There's another variation of the class-based context manager, which
    supports asynchronous-coroutine-based context management.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an asynchronous-coroutine-based context manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the asynchronous protocol, the `__enter__` and `__exit__` methods are replaced
    by `__aenter__` and `__aexit__` coroutine methods and the context manager is invoked
    by an `async with` statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4c0fb06-e0ef-4cca-9f32-035cf276306f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This small change buys us the ability to have the `__enter__` and `__exit__`
    methods invoke other coroutines, wait for data to come in from the network, and
    behave nicely in an `asyncio`-based program.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a look at one last way of altering the semantics
    of a Python-based syntax, using descriptors. Reading and writing variables is
    one of the most fundamental aspects of programming. Python's descriptors let us
    alter how it works.
  prefs: []
  type: TYPE_NORMAL
- en: A descriptor is an object that is stored in a class and controls what it means
    to get, set, and delete a specific single attribute for instances of that class.
    If we want that sort of control over multiple attributes, we just add a descriptor
    to the class for each attribute we want to control.
  prefs: []
  type: TYPE_NORMAL
- en: Using @property to create a descriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python''s built-in `@property` decorator provides a simple way to create a
    descriptor. Let''s consider an example (refer to the following code example) to
    illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97a25b0f-b511-4599-acea-cd43681b6189.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first `prop` method we wrote in the preceding code example tells Python
    how to figure out the value of an attribute called `prop`, which in this case
    just means fetching it from another attribute and printing the value.
  prefs: []
  type: TYPE_NORMAL
- en: The latter two `prop` methods are decorated to turn them into `setter` and `deleter`
    for the `prop` attribute. This means that assigning a value to a prop actually
    means calling the `setter` method, and deleting a prop attribute actually means
    calling the `deleter` method.
  prefs: []
  type: TYPE_NORMAL
- en: Both the methods are optional for properties. Leaving them out makes the attribute
    that the property describes into a read-only attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Writing descriptors as classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properties simplify the construction of descriptors for a common case, but there
    are use cases where we need a descriptor that the property can't handle well.
    For example, what if we were planning on making a class that represented remote
    data and we wanted its attributes to push and pull data from a remote source?
    We could do this with properties, but we'd end up writing very similar code over
    and over as we implement each attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be better to have a `RemoteResource` descriptor class and just add
    a bunch of instances to our local stub class. Let''s go ahead and do that as an
    example using the `RemoteResource` descriptor; refer to the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b509c9e9-e28e-492c-9287-497d8475e376.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Actually, interacting with the network requires a fair amount of code, so it's
    a good thing we can avoid repeating it over and over.
  prefs: []
  type: TYPE_NORMAL
- en: The `RemoteResource` class we have in the preceding example has `__get__`, `__set__`,
    and `__delete__` methods, which determine what happens when an attribute that
    is controlled by an instance in this class is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The `__get__` method, perhaps surprisingly, takes two parameters-the `instance`
    through which the attribute's being accessed and the `class` through which the
    attribute is being accessed. It's like this so we can handle both `instance` attribute
    access and `class` attribute access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When accessing a `class` attribute, the `instance` parameter is `None`. In our
    case, we just returned the descriptor in case somebody tries to access the attribute
    as a class member instead of an instance member, which is a reasonable default
    in a lot of cases.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__set__` method is passed as an instance and value, and it conceptually
    represents setting the control attribute of that instance to the value. Unlike
    `__get__`, it doesn't have support for setting a `class` attribute, so the instance
    will never be `None` and we don't need `class_parameter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__delete__` method is just passed as an instance and represents removing
    the control attribute from that instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of the descriptor methods are told which attribute they represent. The
    assumption is that their `self` parameter will specify that one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our code (in the preceding code example), we''ve chosen to pass the necessary
    information to the descriptor''s constructor and store it as an attribute of self.
    But, in other circumstances, we might use `self` or `selfs ID` as a key in a dictionary
    to store the per-instance state of the descriptor or use the instance as a key
    in a dictionary stored in `self` as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can't just store per-instance data as attributes of `self`, though. Descriptors
    are attributes of the class, not the instance, so their self values are shared
    by all the instances of the class that contains them. Either way, we can control
    what it means to get, set, or delete an instance attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the `RemoteResource` class, creating classes that have remote attributes
    becomes easy, as demonstrated by the `Record` class shown in the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw several other ways of altering the meaning and execution
    of Python code, allowing us to conform the language to our specialized needs.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how function decorators use functions as input data for manipulation.
    We took a look at function annotations and particularly how they interact with
    function decorators. We saw how class decorators work exactly as function decorators
    do, but because they operate on classes, the possibilities are very different.
    We saw how to modify classes, wrap them, or even replace them using decorators.
    We discussed how to use a metaclass to affect the construction of a class object
    and how to make unusual behavior inheritable by making it part of a class's metaclass.
    We looked at context manager, both synchronous and asynchronous. We saw how context
    managers work and learned how to make our own for use in either synchronous or
    asynchronous code. We saw how to create simple descriptors using the `property`
    function and more complex descriptors as classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at automated unit testing—testing a set of techniques
    that could dramatically improve the process of writing a program.
  prefs: []
  type: TYPE_NORMAL
