<html><head></head><body>
		<div><h1 id="_idParaDest-278" class="chapter-number"><a id="_idTextAnchor352"/>16</h1>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor353"/>Performance, Optimization, and Security</h1>
			<p>In the previous chapters of the book, we have created a full stack application from scratch, starting with building and creating a REST API using Django and Django REST Framework and then creating a web interface with React to communicate with the API we created. We have also deployed <a id="_idTextAnchor354"/>applications on services such as AWS EC2 and AWS S3. However, we need to further investigate some important aspects of having an application deployed on the internet, such as performance checks, query optimization, <a id="_idTextAnchor355"/>frontend optimization, and finally, security aspects.</p>
			<p>In this chapter, we will learn how to create a performant API with fewer SQL queries and faster API responses, how to serve the API and the React frontend over HTTPS using AWS CloudFront, and how to log out users using the API. In this chapter, we will cover the following points:</p>
			<ul>
				<li>Revoking JWT tokens</li>
				<li>Adding caching</li>
				<li>Optimizing the deployment of a React application</li>
				<li>Securing deployed applications with HTTPS with AWS <a id="_idTextAnchor356"/>CloudFront</li>
			</ul>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor357"/>Technical requirements</h1>
			<p>For this chapter, you need to have an active AWS account with access to services such as S3, EC2, and <a id="_idTextAnchor358"/>CloudFront. You can also find the code for this chapter at: <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16</a>.</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor359"/>Revoking JWT tokens</h1>
			<p>In this book, we have implemented an authentication system using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>), and because it is a stateless authentication system, most of the authentication flow is handled by the <a id="_idIndexMarker861"/>frontend. If we want to log the user out of the Postagram React application, we<a id="_idTextAnchor360"/> must clear the tokens from the local storage of the browser, and the user is automatically redirected to the login page. But even if the tokens are deleted from the browser, they are still active.</p>
			<p>The refresh tokens have a longer life period, so if a hacker gets their hands on a refresh token, they can still request access tokens and make HTTP requests using someone else’s identity. To avoid that, we will add a logout feature to invalidate access and refresh tokens from the server side.</p>
			<p>The package used to add JWT authentication on the Django REST API (<code>djangorestframework-simplejwt</code>) supports blacklisting tokens, and that is the perfect feature we need here. Let’s set up the required configurations for the logout feature, and let’s add the feature to the Django REST API.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor361"/>Adding a logout endpoint</h2>
			<p>In this section, we will write<a id="_idIndexMarker862"/> some code on the Django application to add an endpoint for logout:</p>
			<ol>
				<li>In the <code>settings.py</code> file of the project, add the following entry to the <code>INSTALLED_APPS</code> list:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
"corsheaders",
"rest_framework_simplejwt.token_blacklist",
...</pre>
			<ol>
				<li value="2">After that, create a file called <code>logout.py</code> in the <code>core/auth/viewsets</code> directory. This file will contain the code for the <code>viewsets</code> and the logic to blacklist a token.</li>
				<li>In this file, add the required imports and define the <code>LogoutViewSet</code> class:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/logout.py</p>
			<pre class="source-code">
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from rest_framework import viewsets, status, permissions
from rest_framework.exceptions import ValidationError
from rest_framework.response import Response
class LogoutViewSet(viewsets.ViewSet):
   authentication_classes = ()
   permission_classes = (permissions.IsAuthenticated,)
   http_method_names = ["post"]</pre>
			<p>The logout endpoint will only accept <code>POST</code> requests, as the client will be required to pass a refresh token within the body of the <code>POST</code> request. We also specify that only authenticated users have permission to access this endpoint.</p>
			<ol>
				<li value="4">Let’s write the <code>create</code> method <a id="_idIndexMarker863"/>of the <code>LogoutViewSet</code> class:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/logout.py</p>
			<pre class="source-code">
...
class LogoutViewSet(viewsets.ViewSet):
...
   def create(self, request, *args, **kwargs):
       refresh = request.data.get("refresh")
       if refresh is None:
           raise ValidationError({"detail":
             "A refresh token is required."})
       try:
           token = RefreshToken(request.data.get(
             "refresh"))
           token.blacklist()
           return Response(
             status=status.HTTP_204_NO_CONTENT)
       except TokenError:
           raise ValidationError({"detail":
             "The refresh token is invalid."})</pre>
			<p>In the preceding code, we ensure that the refresh token is present in the body of the request. Otherwise, we <a id="_idIndexMarker864"/>raise an error. Once the verification is done, we encapsulate the blacklisting logic in a <code>try/except</code> block:</p>
			<ul>
				<li>If the token is valid, then the token<a id="_idTextAnchor362"/> is blacklisted, and we return a response with a <code>204 HTTP</code> status code.</li>
				<li>If there is an error related to the token, then the token<a id="_idTextAnchor363"/> is invalid, and we return a validation error.</li>
			</ul>
			<ol>
				<li value="5">Let’s not forget to add the newly created <code>ViewSet</code> in the <code>routers.py</code> f<a id="_idTextAnchor364"/>ile and register a new route:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
...
from core.auth.viewsets import (
   RegisterViewSet,
   LoginViewSet,
   RefreshViewSet,
   LogoutViewSet,
)
...
router.register(r"auth/logout", LogoutViewSet, basename="auth-logout")</pre>
			<ol>
				<li value="6">Great! To follow best practices for building software, we must add a test for the newly added<a id="_idIndexMarker865"/> route in the <code>core/auth/tests.py</code> file:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/tests.py</p>
			<pre class="source-code">
...
def test_logout(self, client, user):
   data = {"username": user.username,
           "password": "test_password"}
   response = client.post(self.endpoint + "login/",
                          data)
   assert response.status_code == status.HTTP_200_OK
   client.force_authenticate(user=user)
   data_refresh = {"refresh":
     response.data["refresh"]}
   response = client.post(self.endpoint + "logout/",
     data_refresh)
   assert response.status_code ==
     status.HTTP_204_NO_CONTENT</pre>
			<p>In the preceding code, we log in to retrieve a refresh token and force the authentication for the user so we can access the logout endpoint. After that, we ensure that we have returned the right status code when the logout is successful.</p>
			<ol>
				<li value="7">Run the tests using the <code>pytest</code> command. If you are using Docker, then you can run the tests using this command:<pre class="source-code">
<strong class="bold"> docker-compose exec -T api pytest</strong></pre></li>
			</ol>
			<p>With the logout endpoint<a id="_idIndexMarker866"/> ready, we can now make some modifications to the authentication logic (mostly the logout logic) in the React application.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor365"/>Handling the logout with React</h2>
			<p>We have already handled the<a id="_idIndexMarker867"/> logout on the React application to a certain extent by just deleting the tokens from the local storage. There is nothing big to modify here, we will just add a function to make a request to the API, and if this request is successful, we will delete the tokens and the user from the local storage of the browser. The current logout logic on the React application is handled in the <code>NavigationBar</code> component:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/NavBar.jsx</p>
			<pre class="source-code">
...
             &lt;NavDropdown.Item
               onClick={userActions.logout}&gt;
               Logout
             &lt;/NavDropdown.Item&gt;
...</pre>
			<p>Inside the <code>useActions</code> Hook<a id="_idIndexMarker868"/> function, let’s tweak the <code>logout</code> method to make an API call before deleting the user:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/hooks/user.actions.js</p>
			<pre class="source-code">
...
 // Logout the user
 function logout() {
   return axiosService
     .post(`${baseURL}/auth/logout/`,
           { refresh: getRefreshToken() })
     .then(() =&gt; {
       localStorage.removeItem("auth");
       navigate("/login");
     });
 }</pre>
			<p>Once it is done, let’s create a function in the <code>NavigationBar</code> component to handle the cases when there is an error from the API. We will display a toast HTML bloc on the page with the error message:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/NavBar.jsx</p>
			<pre class="source-code">
import React, { useContext } from "react";
import { Context } from "./Layout";
...
function NavigationBar() {
 const { setToaster } = useContext(Context);
 const userActions = useUserActions();
 const user = getUser();
 const handleLogout = () =&gt; {
   userActions.logout().catch((e) =&gt;
     setToaster({
       type: "danger",
       message: "Logout failed",
       show: true,
       title: e.data?.detail | "An error occurred.",
     })
   );
 };
...</pre>
			<p>Great! Our full stack <a id="_idIndexMarker869"/>application now supports logout. In the next section, we will discuss a recurrent topic when deploying a project online, caching<a id="_idTextAnchor366"/>.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor367"/>Adding caching</h1>
			<p>In software <a id="_idIndexMarker870"/>computing, caching is the process of storing copies of files in a cache so they can be accessed more quickly. A <strong class="bold">cache</strong> is a<a id="_idIndexMarker871"/> temporary storage location that stores data, files, and information concerning software that is regularly requested.</p>
			<p>A great example and explanation <a id="_idTextAnchor368"/>of caching comes from Peter Chester, who asked the audience at one of his speeches: <em class="italic">“What’s 3,485,250 divided by 23,235?” Everyone fell si<a id="_idTextAnchor369"/>lent for a moment, but someone pulled a calculator and yelled out the answer “150!”</em>. Then, Peter Chester asked the same question again, and this time, everyone was able to answer the question immediately.</p>
			<p>This is a great demo of the concept of caching: <em class="italic">The computation is only done once by the machine and then saved in quick memory for </em><em class="italic">faster access</em>.</p>
			<p>It is a concept used widely by companies and primarly social media websites where millions of users access the same posts, videos, and files. It would be very primitive to hit the database whenever millions of people want to access the same information. For example, if a tweet is gaining traction on Twitter, it is automatically moved to cache storage for qui<a id="_idTextAnchor370"/>ck access. And, if you have an influencer such as Kim Kardashian posting a picture on Instagram, you<a id="_idIndexMarker872"/> should expect a lot of requests for this picture. Thus caching can be useful here to avoid thousands of queries on the database.</p>
			<p>To recapitulate, caching brings the following benefits:</p>
			<ul>
				<li>Reduced load time</li>
				<li>Reduced bandwidth usage</li>
				<li>Reduced SQL queries on databases</li>
				<li>Reduced downtime</li>
			</ul>
			<p>Now that we have an idea about caching and its benefits, we can implement the concept using Django and even Docker. But before that, let’s quickly discuss the complexity caching brings to your application.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor371"/>The cons of caching</h2>
			<p>You already know the <a id="_idIndexMarker873"/>advantages of using caching, mostly if your application is scaling or you want to improve load time and reduce costs. However, caching introduces some complexity to your system (it can also depend on the type of application you are developing). If your application is based on news or feeds, you might be in trouble, as you will need to define a good architecture for caching.</p>
			<p>On the one hand, you have the chance to reduce load times by showing your users the same content for a period, but at the same time, your users might miss updates and maybe some important updates. Here, cache invalidation comes to the rescue.</p>
			<p>Cache invalidation is the process of declaring cached content as inval<a id="_idTextAnchor372"/>id or stale. The content is invalidated, as it <a id="_idTextAnchor373"/>is no longer marked as being the most up-to-date version of a file. There are some <a id="_idIndexMarker874"/>methods available to invalidate a cache, as follows:</p>
			<ul>
				<li><strong class="bold">Purge (flush)</strong>: Cache purging instantly<a id="_idIndexMarker875"/> removes the content from the cache. When the content is requested again, it is stored in the memory cache before returning it to the client.</li>
				<li><strong class="bold">Refresh</strong>: A cache refresh consists of refreshing<a id="_idIndexMarker876"/> the same content from the server and replacing the content stored in the cache with the new version fetched from the server. This is <a id="_idIndexMarker877"/>done in the React application using <strong class="bold">state-while-revalidate</strong> (<strong class="bold">SWR</strong>). Each time a post is created, we call a refresh function to fetch data again from the server.</li>
				<li><strong class="bold">Ban</strong>: A cache ban does not remove <a id="_idIndexMarker878"/>content from the cache immediately. Rather, the content is marked as blacklisted. Then, when the client makes a request, it is matched with the blacklist content, and if a match is found, new content is fetched again and updated in the memory cache before returning to the client.</li>
			</ul>
			<p>With the cons of caching and how to invalidate the cache understood, you are well equipped to add caching to the Django application. In the next section, let’s add caching to the Django API of Postagram.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor374"/>Adding caching to the Django API</h2>
			<p>In the previous paragraphs, we have explored caching, its advantages, and the cons of the concept. Now, it’s time<a id="_idIndexMarker879"/> to implement caching within our D<a id="_idTextAnchor375"/>jango application. Django provides useful support for caching, which makes the configuration of cac<a id="_idTextAnchor376"/>hing within <a id="_idIndexMarker880"/>Django straightforward. Let’s start by making the required configurations depending on your environment.</p>
			<h3>Configuring Django for caching</h3>
			<p>Using caching within Django <a id="_idIndexMarker881"/>requires configuring a memory cache. For the quickest read and write access, it is better to use a different data storage solution from SQL databases as SQL databases are known to<a id="_idIndexMarker882"/> be slower than memory databases (again, it depends on your needs). In this book, we will use Redis. Redis is an open source, in-memory data store used as a database, cache, streaming engine, and message broker.</p>
			<p>We’ll review the configurations you need to make to start using Redis in your Django project, whether you are using Docker or not. However, for the deployment, we’ll use Docker f<a id="_idTextAnchor377"/>or configuring Redis.</p>
			<p>So, if you are not going to use Docker, you can<a id="_idIndexMarker883"/> install Redis using the following link: <a href="https://redis.io/download/">https://redis.io/download/</a>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are working in a Linux environment, you can check whether the service is running using the <code>sudo service redis-server status</code> command. If the service is not active, use the <code>sudo service redis-server start</code> command to start the Redis server. If you are using Windows, you will need to install or enable WSL2. You can read more at: <a href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/">https://redis.io/docs/getting-started/installation/install-redis-on-windows/</a>.</p>
			<p>After th<a id="_idTextAnchor378"/>e installation on your machine, you can configure caching in Django using the <code>CACHES</code> setting in the <code>settings.py</code> file of the Django project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS':
              'django_redis.client.DefaultClient',
        }
    }
}</pre>
			<p>This configuration will require the installation of a Python package called <code>django-redis</code>. Install it by running<a id="_idIndexMarker884"/> the following command:</p>
			<pre class="console">
pip install django-redis</pre>
			<p>If you are working with Docker, you<a id="_idIndexMarker885"/> just need to add the following configurations:</p>
			<ol>
				<li value="1"> Add the <code>django-redis</code> package to the <code>requirements.txt</code> file:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">requirements.txt</p>
			<pre class="source-code">
django-redis==5.2.0</pre>
			<ol>
				<li value="2">Add the <code>docker-compose.yaml</code> configuration. We will add a new image in the Docker configuration to make sure that the Django application requires <code>redis-server</code> to be ready before the API service starts running:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">docker-compose.yaml</p>
			<pre class="source-code">
services:
 redis:
   image: redis:alpine
…
api:
...
 depends_on:
  - db
  - redis
...</pre>
			<ol>
				<li value="3">Great! Add the following <a id="_idIndexMarker886"/>custom backend in the <code>settings.py</code> file of the Django project:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
CACHES = {
   "default": {
       "BACKEND": "django_redis.cache.RedisCache",
       "LOCATION": "redis://redis:6379",
       "OPTIONS": {
           "CLIENT_CLASS":
             "django_redis.client.DefaultClient",
       },
   }
}</pre>
			<p>You will notice here that we are using <code>redis</code> as the host instead of <code>127.0.0.1</code>. This is because, with Docker, yo<a id="_idTextAnchor379"/>u can use the name of the service as a host. This is a better<a id="_idIndexMarker887"/> solution; otherwise, you will have to configure a static IP address for the services.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you want to learn more about assigning a static IP address to your containers with Docker, you can read the following resource: <a href="https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/">https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/</a>.</p>
			<p>Great! Now that we have configured Django for caching, let’s build the caching system for the Postagram application.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor380"/>Using caching on the endpoints</h2>
			<p>Caching depends a lot on the<a id="_idIndexMarker888"/> business requirements for how much time you want to cache the data. Well, Django provides many levels for caching:</p>
			<ul>
				<li><strong class="bold">Per-site cache</strong>: This enables you to<a id="_idIndexMarker889"/> cache your entire website.</li>
				<li><strong class="bold">Template fragment cache</strong>: This enables <a id="_idIndexMarker890"/>you to cache some components of the website. For example, you can decide to only cache the footer.</li>
				<li><strong class="bold">Per-view cache</strong>: This enables you to<a id="_idIndexMarker891"/> cache the output of individual views.</li>
				<li><strong class="bold">Low-level cache</strong>: Django provides an API you can use for interacting directly with the cache. It is useful if you <a id="_idIndexMarker892"/>want to produce a certain behavior based on a set of actions. For example, in this book, if a post is updated or deleted, we will update the cache.</li>
			</ul>
			<p>Now that we have a better idea about the levels of caching Django provides, let’s define the caching requirements for the Postagram API.</p>
			<p>Our requirement is if there is a delete or an update on a comment or a post, the cache is updated. Otherwise, we return the same information in the cache to the user.</p>
			<p>This can be achieved in many ways. We can use Django signals or directly add custom methods to the manager of the model’s <code>Post</code> and <code>Comment</code> classes. Let’s go with the latter. We will surcharge the <code>save</code> and <code>delete</code> methods of the <code>AbstractModel</code> class, so if there is an update on a <code>Post</code> or <code>Comment</code> object, we update the cache.</p>
			<p>Inside the <code>core/abstract/models.py</code> file, add the following method on top of the file after the imports:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/models.py</p>
			<pre class="source-code">
from django.core.cache import cache
...
def _delete_cached_objects(app_label):
   if app_label == "core_post":
       cache.delete("post_objects")
   elif app_label == "core_comment":
       cache.delete("comment_objects")
   else:
       raise NotImplementedError</pre>
			<p>The function in the preceding code takes an application label, and according to the value of this <code>app_label</code>, we invalidate the corresponding cache. For the moment, we only support caching for posts and comments. Notice how the name of the function is prefixed with a <a id="_idTextAnchor381"/><code>_</code>. It is a coding convention to specify that this method is private and should not be used outside the file where<a id="_idIndexMarker893"/> it is declared.</p>
			<p>Inside the <code>AbstractModel</code> class, we can surcharge the <code>save</code> method. Before the <code>save</code> method is executed, we invalidate the cache. It means that on operations such as <code>create</code> and <code>update</code>, the cache will be reset:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/models.py</p>
			<pre class="source-code">
class AbstractModel(models.Model):
...
   def save(
       self, force_insert=False, force_update=False,
       using=None, update_fields=None
   ):
       app_label = self._meta.app_label
       if app_label in ["core_post", "core_comment"]:
           _delete_cached_objects(app_label)
       return super(AbstractModel, self).save(
           force_insert=force_insert,
           force_update=force_update,
           using=using,
           update_fields=update_fields,
       )</pre>
			<p>In the preceding code,<a id="_idTextAnchor382"/> we retrieve <code>app_label</code> from the <code>_meta</code> attribute on the model. If it corresponds <a id="_idIndexMarker894"/>to either <code>core_post</code> or <code>core_comment</code>, we invalidate the cache, and the rest of the instructions can proceed. Let’s do the same for the <code>delete</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Core/abstract/models.py</p>
			<pre class="source-code">
class AbstractModel(models.Model):
…
   def delete(self, using=None, keep_parents=False):
       app_label = self._meta.app_label
       if app_label i" ["core_p"st", "core_comm"nt"]:
           _delete_cached_objects(app_label)
       return super(AbstractModel, self).delete(
         using=using, keep_parents=keep_parents)</pre>
			<p>Great. The cache invalidation logic has been implemented on the models. Let’s add the logic for cache data retrieving on the viewsets of the <code>core_post</code> application and the <code>core_comment</code> application.</p>
			<h3>Retrieving data from the cache</h3>
			<p>The cache invalidation is ready, so we <a id="_idIndexMarker895"/>can freely retrieve data from the cache on the endpoints for the posts and the comments. Let’s start with <code>PostViewSet</code> as the portion of code that will be written on <code>PostViewSet</code> and <code>CommentViewSet</code> will be the same. As a small exercise, you can write the logic for retrieving the cache for the comments.</p>
			<p>Inside the <code>PostViewSet</code> class, we will <a id="_idIndexMarker896"/>rewrite the <code>list()</code> method. On the <strong class="bold">Django REST framework</strong> (<strong class="bold">DRF</strong>) open source <a id="_idIndexMarker897"/>repository, the code looks like this:</p>
			<pre class="source-code">
"""List a queryset"""
def list(self, request, *args, **kwargs):
   queryset = self.filter_queryset(self.get_queryset())
   page = self.paginate_queryset(queryset)
   if page is not None:
       serializer = self.get_serializer(page, many=True)
       return self.get_paginated_response(serializer.data)
   serializer = self.get_serializer(queryset, many=True)
   return Response(serializer.data)</pre>
			<p>In the preceding code, a <code>queryset</code> call is made to retrieve the data, and then this <code>queryset</code> call is paginated, serialized, and returned inside a <code>Response</code> object. Let’s tweak the method a little bit:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
class PostViewSet(AbstractViewSet):
...
   def list(self, request, *args, **kwargs):
       post_objects = cache.get("post_objects")
       if post_objects is None:
           post_objects =
             self.filter_queryset(self.get_queryset())
           cache.set("post_objects", post_objects)
       page = self.paginate_queryset(post_objects)
       if page is not None:
           serializer = self.get_serializer(page,
                                            many=True)
           return self.get_paginated_response(
             serializer.data)
       serializer = self.get_serializer(post_objects,
                                        many=True)
       return Response(serializer.data)</pre>
			<p>In the preceding code, instead of doing a lookup on the database directly, we check the cache. If <code>post_objects</code> is <code>None</code> when making a query to the database, save <code>queryset</code> in the cache and finally proceed to return the cache objects to the user.</p>
			<p>As you can see, the <a id="_idIndexMarker898"/>process is very simple. You just need to have a robust caching strategy. You can do the same for <code>CommentViewSet</code> as an exercise. You can check the code at this link to compare your results: <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py">https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py</a>.</p>
			<p>In this section, we have explored<a id="_idTextAnchor383"/> the benefits of caching, and we have implemented caching in the Django application. In the next section, we will see how to optimize the React build using tools <a id="_idIndexMarker899"/>such as <code>webpack</code>.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor384"/>Optimizing the React application build</h1>
			<p>In the previous chapter, we successfully built the React application and made the deployment on AWS S3. However, we could have done better in terms of optimization and performance. In this section, we<a id="_idIndexMarker900"/> will use the famous webpack module builder to optimize the React build of Postagram.</p>
			<p>There are a lot of advantages<a id="_idIndexMarker901"/> of using webpack in React:</p>
			<ul>
				<li><strong class="bold">It speeds up development and build times</strong>: Using webpack in development enhances the speed of fast reload of React.</li>
				<li><strong class="bold">It provides minification</strong>: Webpack automatically minimizes the code wi<a id="_idTextAnchor385"/>thout changing the functionalities. This results in a faster load on the browser side.</li>
				<li><strong class="bold">Code splitting</strong>: Webpack converts JavaScript files into modules.</li>
				<li><strong class="bold">It eliminates dead assets</strong>: Webpack only <a id="_idTextAnchor386"/>builds the images and CSS that your code uses and needs.</li>
			</ul>
			<p>Let’s start by integrating webpack into the project.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor387"/>Integrating webpack</h2>
			<p>Follow these steps to integrate <a id="_idIndexMarker902"/>webpack into your project:</p>
			<ol>
				<li value="1">Inside the React project, run the following command to add the <code>webpack</code> and <code>webpack-cli</code> packages:<pre class="source-code">
<strong class="bold">yarn add -D webpack webpack-cli</strong></pre></li>
				<li>Once the installation is done, modify the <code>package.json</code> scripts:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
			<pre class="source-code">
...
"scripts": {
    "start": "react-scripts start",
<strong class="bold">    "build": "webpack --mode production",</strong>
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
...</pre>
			<p>Also, we need to <a id="_idIndexMarker903"/>install Babel, which is a JavaScript compiler that converts next-generation JavaScript code into browser-compatible JavaScript.</p>
			<ol>
				<li value="3">In the React project, Babel will convert the React components, the ES6 variables, and JSX code to regular JavaScript so old browsers can render the components correctly:<pre class="source-code">
<strong class="bold">yarn add -D @babel/core babel-loader @babel/preset-env @babel/preset-react</strong></pre></li>
			</ol>
			<p><code>babel-loader</code> is the webpack loader for Babel, <code>babel/preset-env</code> compiles with JavaScript to ES5, and <code>babel/preset-react</code> is for compiling JSX to JS.</p>
			<ol>
				<li value="4">Then create a new file called <code>.babelrc</code>:<pre class="source-code">
{</pre><pre class="source-code">
  "presets": ["@babel/preset-env",</pre><pre class="source-code">
              "@babel/preset-react"]</pre><pre class="source-code">
}</pre></li>
				<li>Then create a new file called <code>webpack.config.js</code>. This file will contain the configurations for<a id="_idIndexMarker904"/> webpack. Before writing the con<a id="_idTextAnchor388"/>figuration, add some plugins for optimizing HTML, CSS, and copy files:<pre class="source-code">
<strong class="bold">yarn add -D html-webpack-plugin html-loader copy-webpack-plugin</strong></pre></li>
				<li>And then add the <a id="_idIndexMarker905"/>following configuration on <code>webpack.config.js</code>:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
			<pre class="source-code">
const path = require("path");
const HtmlWebPackPlugin = require("html-webpack-plugin");
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require("webpack");
module.exports = {
 module: {
   rules: [
     {
       test: /\.(js|jsx)$/,
       exclude: /node_modules/,
       use: {
         loader: "babel-loader",
       },
     },
     {
       test: /\.css$/i,
       use: ["style-loader", "css-loader"],
     },
   ],
 },
};</pre>
			<p>The preceding code above tells webpack to send all files in <code>.js</code> and <code>.jsx</code> through <code>babel-loader</code>.</p>
			<ol>
				<li value="7">Let’s add another <a id="_idIndexMarker906"/>configuration called <code>resolve</code> to generate all the possible paths to the module. For example, webpack would then proceed to look up each of those paths until it finds a file:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
			<pre class="source-code">
...
 resolve: {
   modules: [path.resolve(__dirname, "src"),
             "node_modules"],
   extensions: ["", ".js", ".jsx"],
 },
};</pre>
			<ol>
				<li value="8">Let’s add the configuration for the plugins we will use in this project:</li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
			<pre class="source-code">
...
 plugins: [
   new HtmlWebPackPlugin({
     template: "./public/index.html",
     filename: "./index.html",
   }),
   new CopyPlugin({
     patterns: [
       {
         from: "public",
         globOptions: {
           ignore: ["**/*.html"],
         },
       },
     ],
   }),
   new webpack.DefinePlugin({ process: {env: {}} }),
 ],
 output: {
   publicPath: '.',
 },
};</pre>
			<p>In the preceding code, we have<a id="_idIndexMarker907"/> added plugin configurations for the following:</p>
			<ul>
				<li><code>html-loader</code>: This will send the HTML files through <code>html-loader</code></li>
				<li><code>copy</code>: This will copy the content of the public file to the <code>dist</code> file</li>
				<li><code>define</code>: This plugin declares the <code>process</code> object so we can access environment variables in the production environment</li>
			</ul>
			<ol>
				<li value="9">Once it is done, run the <code>build</code> command:<pre class="source-code">
<strong class="bold">yarn build</strong></pre></li>
			</ol>
			<p>Webpack will take control and build the React application in the <code>dist</code> directory:</p>
			<div><div><img src="img/Figure_16.01_B18221.jpg" alt="Figure 16.1 – The content of the dist directory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – The content of the dist directory</p>
			<p>Great! You can push the changes<a id="_idIndexMarker908"/> made to GitHub, and the code will be deployed on AWS S3. To make the testing and build faster, we will change the package <a id="_idTextAnchor389"/>manager from <code>yarn</code> to <code>pnpm</code>. The next section is optional, but it will help you with a faster build for your React application.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor390"/>Using pnpm</h2>
			<p><code>pnpm</code> is a replacement for the <code>npm</code> JavaScript package manager, which is built on top of <code>npm</code>, and is much faster and<a id="_idIndexMarker909"/> more efficient. It provides advantages such as disk space efficiency, improved speed, and better security. The <code>pnpm</code> package manager is the one to use if you want to spend less time building and making cuts to the minutes spent on the GitHub Actions.</p>
			<p>Let’s install <code>pnpm</code> on our machine:</p>
			<pre class="source-code">
<strong class="bold">npm install -g pnpm</strong></pre>
			<p>After that, we can generate a <code>pnpm-lock.yaml</code> file. We can generate this file from another manager’s lock file, in our case, from the <code>yarn.lock</code> file:</p>
			<pre class="source-code">
pnpm import</pre>
			<div><div><img src="img/Figure_16.02_B18221.jpg" alt="Figure 16.2 – Result of pnpm import"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – Result of pnpm import</p>
			<p>A new file will be generated in the <a id="_idIndexMarker910"/>directory of the React project. Then, modify the <code>deploy-frontend.yml</code> file to configure for <code>pnpm</code> usage:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">.github/workflows/deploy-frontend.yml</p>
			<pre class="source-code">
jobs:
 test:
   name: Tests
   runs-on: ubuntu-latest
   defaults:
     run:
       working-directory: ./social-media-react
   steps:
     - uses: actions/checkout@v3
     - uses: pnpm/action-setup@v2.2.4
       with:
         version: 7
     - name: Use Node.js 16
       uses: actions/setup-node@v3
       with:
         node-version: 16
         cache: 'pnpm'
         cache-dependency-path:
           ./social-media-react/pnpm-lock.yaml</pre>
			<p>After that, just replace <code>yarn</code> with <code>pnpm</code> in the <code>deploy-frontend.yml</code> file. You will notice a faster build for<a id="_idIndexMarker911"/> the React application.</p>
			<p>In this section, we have covered pnpm and webpack and how they can boost the performance of the React applic<a id="_idTextAnchor391"/>ation. In the next section, we <a id="_idTextAnchor392"/>will learn how to secure HTTP requests using AWS CloudFront.</p>
			<h1 id="_idParaDest-291">Se<a id="_idTextAnchor393"/>curing deployed applications with HTTPS with AWS CloudFront</h1>
			<p>When we have deployed<a id="_idIndexMarker912"/> the backend and the <a id="_idIndexMarker913"/>frontend on AWS S3, the applications are served through HTTP. Basically<a id="_idTextAnchor394"/>, our full stack application is not secured on<a id="_idIndexMarker914"/> the internet, and we are vulnerable. According to the <strong class="bold">Open Web Application Security Project</strong> (<strong class="bold">OSWAP</strong>) description of Insecure Transport (<a href="https://owasp.org/www-community/vulnerabilities/Insecure_Transport">https://owasp.org/www-community/vulnerabilities/Insecure_Transport</a>), our application is vulnerable to the following attacks:</p>
			<ul>
				<li>Attacks targeting login credentials, session IDs, and other sensitive information</li>
				<li>Bypassing <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) protocol by<a id="_idIndexMarker915"/> entering HTTP instead of HTTPS at the beginning of the URL in the browser</li>
				<li>Sending non-protected URLs of authentication pages to users to trick them into authenticating via HTTP</li>
			</ul>
			<p>AWS EC2 and AWS S3 don’t serve content through<a id="_idTextAnchor395"/> HTTPS by default. But AWS also has a service called CloudFront that can help you serve your applications via HTTPS, plu<a id="_idTextAnchor396"/>s it also makes the content available<a id="_idIndexMarker916"/> globally.</p>
			<p><strong class="bold">AWS CloudFront</strong> is a content <a id="_idIndexMarker917"/>delivery network service, and in the next section, we will configure the AWS S3 bucket hosting the React application wi<a id="_idTextAnchor397"/>th AWS Cloudfront.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor398"/>Configuring the React project with CloudFront</h2>
			<p>Follow these steps to configure our<a id="_idIndexMarker918"/> React pr<a id="_idTextAnchor399"/>oject with <a id="_idIndexMarker919"/>CloudFront:</p>
			<ol>
				<li value="1">On the AWS dashboard, select the <strong class="bold">CloudFront</strong> service in the AWS console and click on <strong class="bold">Create Distribution</strong>.</li>
				<li>Copy the origin of your website hosted on AWS and paste it into the <strong class="bold">Origin domain</strong> name field:</li>
			</ol>
			<div><div><img src="img/Figure_16.03_B18221.jpg" alt="Figure 16.3 – Origin configuration of the CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Origin configuration of the CloudFront distribution</p>
			<ol>
				<li value="3">Next, configure<a id="_idIndexMarker920"/> the default cache<a id="_idIndexMarker921"/> behaviors:</li>
			</ol>
			<div><div><img src="img/Figure_16.04_B18221.jpg" alt="Figure 16.4 – Viewer configuration of the CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Viewer configuration of the CloudFront distribution</p>
			<ol>
				<li value="4">Once the cache <a id="_idIndexMarker922"/>configuration is done, create the<a id="_idIndexMarker923"/> distribution. AWS will take some time to create the distribution and once it is done, click on the distribution <strong class="bold">ID</strong> field to copy the URL:</li>
			</ol>
			<div><div><img src="img/Figure_16.05_B18221.jpg" alt="Figure 16.5 – List of the CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – List of the CloudFront distribution</p>
			<ol>
				<li value="5">Once <strong class="bold">Status</strong> changes to <strong class="bold">Enabled</strong>, click on the distribution <strong class="bold">ID</strong> field to access more details about the distribution and copy the distribution domain name:</li>
			</ol>
			<div><div><img src="img/Figure_16.06_B18221.jpg" alt="Figure 16.6﻿ – Details about the created CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6<a id="_idTextAnchor400"/> – Details about the created CloudFront distribution</p>
			<p>The CloudFront <a id="_idIndexMarker924"/>distribution URL will return the React<a id="_idIndexMarker925"/> application over HTTPS. Great, the React application is secured on the internet and well distributed worldwide. Great! We have<a id="_idTextAnchor401"/> successfully secured our <a id="_idTextAnchor402"/>application over HTTPS using AWS CloudFront. From now, you can build a full stack<a id="_idIndexMarker926"/> application with Django and React, assure code quality with tests and linting, automate <strong class="bold">continuous <a id="_idTextAnchor403"/>integration</strong> and <strong class="bold">continuous delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines usi<a id="_idTextAnchor404"/>ng GitHub Actions and use AWS services such as S3, EC2, and CloudFront to deploy and serve your web application around the world.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor405"/>Summary</h1>
			<p>In this chapter, we have covered some important points about optimizations and s<a id="_idTextAnchor406"/>ecurity. We have implemented a logout endpoint to blacklist tokens, added caching to the Django application using Redis, optimized the backend build using webpack, and secured the full stack application over HTTPS using AWS CloudFront. And that’s the final touch of this book.</p>
			<p>We have covered how to build a powerful and robust full stack application using Django and React. We have covered how to create a project from scratch, build an API secured with JWT tokens,<a id="_idTextAnchor407"/> build a frontend application with React and Bootstrap, and deploy the applications on AWS. We have explored Docker and tools such as GitHub Actions to make the development and deployment process secure, faster, and automated. You can now build and deploy a full stack application using Django and React!</p>
			<p>We are now at the end of this book, and if you are looking for best practices and what to learn next, feel free to go through the <a id="_idTextAnchor408"/><em class="italic">Appendix</em> directly after this chapter.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor409"/>Questions</h1>
			<ol>
				<li value="1">What is AWS Cl<a id="_idTextAnchor410"/>oudFront?</li>
				<li>What are the cache invalidation strategies?</li>
				<li>Why is logging important?</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	

		<div><h1 id="_idParaDest-295"><a id="_idTextAnchor411"/>Appendix</h1>
			<p>Every successful application will eventually need to scale, and this process can cause resource issues and more optimization problems. In this appendix, I will list what you can read to deepen your studies after this book so you can become a better full stack developer.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor412"/>Logging</h2>
			<p>Logging is the action of collecting information about an application as it performs different tasks or events. In the development process of an application, if you have a <a id="_idTextAnchor413"/>bug, you can use <code>print()</code> or <code>console.log()</code> to identify the issues. Even better, with <code>DEBUG</code> as <code>true</code> in Django, you have access to the whole traceback of a <code>500</code> error. Once your project <a id="_idIndexMarker927"/>deployed in production, this is no longer the case. You can implement logging in files using the default logging package provided by Python; Django has full support that you can explore in the official documentation at <a href="https://docs.djangoproject.com/en/4.1/topics/logging/">https://docs.djangoproject.com/en/4.1/topics/logging/</a>. If you are looking to get real-time notifications when you have a <code>500</code> error, you can connect your backend to services such as Sentry, Datadog, or Bugsnag.</p>
			<h2 id="_idParaDest-297">Database queries<a id="_idTextAnchor414"/> optimization</h2>
			<p>The Django ORM is a<a id="_idTextAnchor415"/> very flexible and powerful tool,<a id="_idTextAnchor416"/> and it can be used well or badly. Databases are important in your<a id="_idIndexMarker928"/> full stack applications and the fewer queries you make, the better it is for the high availability of the SQL database. Django provides many methods you can study and explore if you need to optimize database queries. You can read more at <a href="https://docs.djangoproject.com/en/4.1/topics/db/optimization/">https://docs.djangoproject.com/en/4.1/topics/db/optimization/</a>.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor417"/>Security</h2>
			<p>If you are deploying a web <a id="_idIndexMarker929"/>application <a id="_idTextAnchor418"/>on the internet, it’s important to ensure that you have<a id="_idTextAnchor419"/> a secure application. In the beginning, you don’t really need<a id="_idTextAnchor420"/> a lot, but you do need to ensure that your system is secured against the top 10 threats listed by OWASP. You can learn more about this at the following link: <a href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a>.</p>
		</div>
		<div><div></div>
		</div>
	

		<div><h1 id="_idParaDest-299"><a id="_idTextAnchor421"/>Answers</h1>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor422"/>Chapter 1</h1>
			<ol>
				<li>A <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) API is a web architecture and a set of constraints that provide simple interfaces to interact with resources, allowing clients to retrieve or manipulate them using standard HTTP requests.</li>
				<li>Django is a Python web framework that enables the fast development of secure and maintainable websites. It follows the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) architectural pattern and emphasizes reusability and pluggability.</li>
				<li>To create a Django project, you need to have Django installed on your OS. Once you have it installed, you can use the following command to create a new Django project:<p class="L---source" lang="fr-FR" xml:lang="fr-FR"><strong class="bold">django-admin startproject DjangoProject</strong></p></li>
			</ol>
			<p>The preceding command will create a Django project with the name <code>DjangoProject</code></p>
			<ol>
				<li value="4">Migrations are Django’s way of synchronizing changes you make to your models (adding a field, deleting a model, etc.) into your database.</li>
				<li>A virtual environment in Python is a tool to keep the dependencies required by different projects in separate places by creating isolated python virtual environments for them. This is useful in case of different projects and when you want to avoid conflicting dependencies.</li>
			</ol>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor423"/>Chapter 2</h1>
			<ol>
				<li value="1"><strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) is a JSON object meant of representing claims to be transferred between two parties. JWT is often used to authenticate users in REST APIs.</li>
				<li><strong class="bold">Django Rest Framework</strong> (<strong class="bold">DRF</strong>) is a third-party package for Django that makes it easy to build, test, debug, and maintain RESTful APIs written using the Django framework.</li>
				<li>A Django model is a Python class that represents a database table, and it defines the fields and behaviors of the data you’re storing.</li>
				<li>Serializers in DRF are used to convert complex data types, such as Django model instances or QuerySets, into JSON, XML, or other content types. Serializers also provide deserialization, which allows parsed data to be converted back into complex types.</li>
				<li>Viewsets in DRF are classes that provide actions on model-backed resources. Viewsets are built on top of Django’s class-based views and provide actions like <code>list</code>, <code>create</code>, <code>update</code>, and <code>delete</code>.</li>
				<li>DRF routers provide a simple, quick, and consistent way of wiring viewsets to URLs. It allows you to automatically generate the URL conf for your API views.</li>
				<li>A refresh token is a token that is issued by an authentication server and is used to obtain a new access token. Refresh tokens are used to keep the user authenticated indefinitely, by periodically obtaining a new access token.</li>
			</ol>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor424"/>Chapter 3</h1>
			<ol>
				<li value="1">Some common database relationships in relational databases are:<ul><li><strong class="bold">One-to-one</strong>: This relationship is used when one record in a table is related to only one record in another table.</li><li><strong class="bold">One-to-many</strong>: This relationship is used when one record in a table is related to multiple records in another table.</li><li><strong class="bold">Many-to-many</strong>: This relationship is used when multiple records in one table are related to multiple records in another table.</li></ul></li>
				<li>Django REST permissions are used to control access to specific actions on specific viewsets. They can be used to restrict who can view, add, change, or delete data in your REST API.</li>
				<li>In DRF, you can use the <code>LimitOffsetPagination</code> class to paginate the results of an API response. To use this class, you can include it in <code>REST_FRAMEWORK</code> in the <code>settings.py</code> file of your project.</li>
				<li>To use the Django shell, you need to open the command line in the root directory of your Django project, and then run the following command:<p class="L---source" lang="fr-FR" xml:lang="fr-FR"><strong class="bold">python manage.py shell</strong></p></li>
			</ol>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor425"/>Chapter 4</h1>
			<ol>
				<li value="1">A nested route is a URL endpoint that represents a relationship between two or more resources. For example, in a social media application, you might have a route for all posts and another route for a specific post’s comments. The comments route would be nested within the post route, allowing you to access the comments for a specific post.</li>
				<li><code>drf-nested-routers</code> is a package for DRF that allows you to easily create nested routes for your API. It automatically creates the appropriate URLs for related resources and allows you to nest your views within other views.</li>
				<li>The <code>partial</code> attribute on the <code>ModelSerializer</code> can help you determine whether the user is submitting all the fields of the resource on an HTTP request for mutating like <code>PUT</code>, <code>PATCH</code>, or <code>DELETE</code>.</li>
			</ol>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor426"/>Chapter 5</h1>
			<ol>
				<li value="1">Testing is a process of verifying that a system or software behaves in the way that it is expected to. Testing can be done manually or automatically.</li>
				<li>A unit test is a test that verifies the functionality of a small and isolated piece of code, usually a single function or a method.</li>
				<li>The testing pyramid is a concept that describes the balance between different types of tests in a software project. It suggests that most of the tests should be unit tests, which are fast and isolated, followed by a smaller number of integration tests, which test the interactions between different units of code, and a small number of end-to-end tests, which test the entire system.</li>
				<li>Pytest is a popular testing framework for Python that makes it easy to write small, focused unit tests and provides many useful features such as test discovery, test parametrization, fixtures, and powerful and expressive assertion syntax.</li>
				<li>A Pytest fixture is a way to provide data or set up resources that are needed for your tests. Fixtures are defined using the <code>@pytest.fixture</code> decorator and can be passed as arguments to test functions, allowing you to write more expressive and maintainable tests.</li>
			</ol>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor427"/>Chapter 6</h1>
			<ol>
				<li value="1">Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. It allows developers to run JavaScript on the server side to build fast and scalable network applications. Yarn is a package manager for Node.js, like npm but it is faster and more secure and provides a more consistent experience across different environments.</li>
				<li>Frontend development is the process of building the user interface of a software application. In web development, it involves using languages such as <strong class="bold">HTML</strong>, <strong class="bold">CSS</strong>, and <strong class="bold">JavaScript</strong> to create the visual elements, layout, and functionality of a website.</li>
				<li>To install Node.js, you can download the installer package from the official Node.js website (<a href="https://nodejs.org/">https://nodejs.org/</a>) and then run it.</li>
				<li><strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) is a free, open-source code editor developed and maintained by Microsoft. It is a popular choice among developers for its support for multiple languages, debugging, and integrated Git control.</li>
				<li>In VS Code, you can install extensions by clicking on the <strong class="bold">Extensions</strong> icon in the <strong class="bold">Activity Bar</strong> on the side of the editor, or by typing <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">X</em> (<em class="italic">Cmd</em> + <em class="italic">Shift</em> + <em class="italic">X</em> on macOS) to open the <strong class="bold">Extensions</strong> pane. You can then search for and install any installation you need.</li>
				<li>Hot reloading is a feature that allows you to see the changes you make to your code immediately in the browser, without having to manually refresh the page. This makes development faster and more efficient, as you can see the effects of your changes in real-time.</li>
				<li>To create a React application with <code>create-react-app</code>, you first need to have Node.js and yarn installed on your OS. Then, you can use <code>yarn</code> to create a new React application by running the following command in your terminal:<p class="L---source" lang="fr-FR" xml:lang="fr-FR"><strong class="bold">yarn create react-app my-app</strong></p></li>
			</ol>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor428"/>Chapter 7</h1>
			<ol>
				<li value="1"><code>localStorage</code> is an API provided by web browsers that allow developers to store <code>localStorage</code> persists even when the browser is closed, or the computer is restarted.</li>
				<li><code>React-Router</code> is a popular library for client-side routing in React. It allows you to declaratively map your application’s component structure to specific URLs, making it easy to navigate between pages and manage the browser history</li>
				<li>To configure a protected route in React, you can use React-Router’s <code>&lt;Route&gt;</code> component along with a <strong class="bold">higher-order component</strong> (<strong class="bold">HOC</strong>) or a custom Hook that checks if the user is authenticated before rendering the protected component. For example:<pre class="source-code">
function ProtectedRoute({ children }) {</pre><pre class="source-code">
  const user = getUser();</pre><pre class="source-code">
  return user ? &lt;&gt;{children}&lt;/&gt; : &lt;Navigate to=»/login/» /&gt;;</pre><pre class="source-code">
}</pre></li>
				<li>A React Hook is a special function that allows you to use state and other React features in a functional component. Hooks were introduced in React 16.8 to make it easier to write and manage stateful logic in functional components.</li>
				<li>Some examples of React Hooks are:<ul><li><code>useState</code>: allows you to add a state to a functional component.</li><li><code>useEffect</code>: allows you to run side effects such as fetching data or subscribing to an event in a functional component.</li><li><code>useContext</code>: allows you to access the context values from a functional component.</li></ul></li>
				<li>The two rules of React Hooks are:<ul><li>Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions.</li><li>Only call Hooks from React function components. Don’t call Hooks from regular JavaScript functions.</li></ul></li>
			</ol>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor429"/>Chapter 8</h1>
			<ol>
				<li value="1">A modal is a dialog box/pop-up window that is displayed on top of the current page. Modals are used to display content that requires the user’s attention or input, such as forms, images, videos, or alerts.</li>
				<li>In React, a <code>props</code> object.</li>
				<li>The <code>children</code> element in React is a special prop that is used to pass content between elements. It is used to nest UI elements inside of other elements, and it can be accessed using the <code>props.children</code> property inside of the parent component.</li>
				<li>A wireframe is a simplified visual representation of a web page or application, used to communicate the layout, structure, and functionality of a user interface.</li>
				<li>The <code>map</code> method is an array method in JavaScript that is used to iterate over an array and create a new array with the results of a function applied to each element of the original array. It can also be used in JSX to map over an array and create a new set of elements.</li>
				<li>The <code>mutate</code> method on SWR objects allows you to programmatically update the data in the cache, without waiting for the revalidation to happen. The <code>mutate</code> method triggers a re-render on the components that are using the data in the cache, updating the UI to reflect the new data.</li>
			</ol>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor430"/>Chapter 9</h1>
			<ol>
				<li value="1">The <code>useParams</code> Hook is a built-in Hook in React Router that allows you to access the dynamic parameters passed in the URL of a route. It returns an object containing the <strong class="bold">key-value</strong> pairs of the parameters in the parameters.</li>
				<li>In React, you can write a route that can support parameter passing by using the <code>:</code> syntax in the path of the route. For example, you can have <code>post/:postId</code> where <code>postId</code> is an URL parameter.</li>
				<li>The <code>useContext</code> Hook is a built-in hook in React that allows you to access a context value within a functional component. This can be useful for sharing data across multiple components without having to pass props down through multiple levels of the component tree.</li>
			</ol>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor431"/>Chapter 10</h1>
			<ol>
				<li value="1">The <code>FormData</code> object is a built-in JavaScript object that allows you to construct and send <code>multipart/form-data</code> requests. It can be used to upload files or other forms of binary data, as well as to send <code>FormData</code> object can be passed as the body of an <code>XMLHttpRequest</code> or <code>fetch</code> request, and it will automatically set the appropriate <code>Content-Type</code> header.</li>
				<li>In Django, the <code>MEDIA_URL</code> setting is used to specify the URL at which user-uploaded media files will be served.</li>
				<li>The <code>MEDIA_ROOT</code> setting in Django is used to specify the filesystem path where user-uploaded media files will be stored.</li>
			</ol>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor432"/>Chapter 11</h1>
			<ol>
				<li value="1">The <code>render</code> method of the <code>render</code> method can be used to test the behavior and output of a component in a real-world-like environment.</li>
				<li>Jest is a JavaScript testing framework that allows you to write and run unit tests for JavaScript code, including React components.</li>
				<li>The <code>data-testid</code> attribute is a special attribute that allows you to add an identifier to an element for the purpose of testing. This attribute can be used to query the element in a test and make assertions about its state or behavior.</li>
				<li>Some drawbacks of snapshot testing are:<ul><li>Snapshots can become stale over time as the component changes, and they need to be updated manually.</li><li>Snapshot tests can be difficult to understand, as they often show the entire component tree, which can be large and complex.</li></ul></li>
				<li>To trigger user events in a React test suite, you can use React Testing Library <code>fireEvent</code> and <code>userEvent</code> methods.</li>
			</ol>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor433"/>Chapter 12</h1>
			<ol>
				<li value="1">In Git, a branch is a separate line of development that allows one or multiple developers to work on different features or bug fixes simultaneously without interfering with each other’s work. Branches are also used to isolate changes and make it easy to merge them back into the main codebase or branch.</li>
				<li>Git is a <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) that allows developers to track changes in their code over time, collaborate with others, and revert to previous versions if needed. GitHub is a web-based hosting service for Git repositories.</li>
				<li>An HTTP Host header attack is a type of web application attack that exploits a vulnerability in the way some web servers handle the HTTP Host header. The HTTP Host header is used to specify the domain name of the website that the user is trying to access. By manipulating the Host header, an attacker can trick a vulnerable web server into serving content from a different domain, potentially exposing sensitive information, or allowing the attacker to perform actions on the user’s behalf.</li>
				<li>In Django, the <code>SECRET_KEY</code> setting is used to provide a secret key that is used to secure certain aspects of the Django framework, such as session management, password hashing, and the generation of cryptographic signatures. As it is a sensible piece of information, the value should be stored using environment variables.</li>
			</ol>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor434"/>Chapter 13</h1>
			<ol>
				<li value="1">Docker is a platform for developing, shipping, and running applications that uses containerization technology to package an application and its dependencies into a single, portable container that can run on any platform that supports Docker. Containers provide a lightweight, isolated environment for running applications, which makes it easy to move them between development, staging, and production environments.</li>
				<li>Docker Compose is a tool for defining and running multi-container Docker applications. It allows you to use a single <code>docker-compose.yml</code> file to configure and start multiple services (containers) that make up your application. This makes it easy to manage the dependencies and configuration of a complex application.</li>
				<li>The main difference between Docker and Docker Compose is that Docker is a platform for creating, shipping, and running containers, while Docker Compose is a tool for defining and running multi-container applications. Additionally, Docker Compose relies on Docker to create and run the containers.</li>
				<li>Virtualization is a technology that allows you to run multiple operating systems on a single physical machine, by creating virtual machines that emulate the hardware of a physical computer. Each virtual machine runs its operating system, and applications running inside the virtual machines are isolated from each other. Containerization is a technology that allows you to package an application and its dependencies into a single, portable container that can run on any platform. Containers are lightweight, isolated environments that share the host operating system kernel, which makes them faster and more efficient than virtual machines.</li>
				<li>An environment variable is a value that can be passed to an operating system or application at runtime. It allows you to configure system-wide settings or to pass information to an application without hard-coding it in the source code. Environment variables can be used to set configuration options, such as the location of a file or the value of a secret key, and they can be easily changed without modifying the application’s code.</li>
			</ol>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor435"/>Chapter 14</h1>
			<ol>
				<li value="1">The differences between <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>) are:<ul><li>CI is a software development practice in which developers integrate code into a shared repository multiple times a day. Each integration is verified by an automated build and test process to catch errors early.</li><li>CD is an extension of CI that goes a step further and automatically deploys the code changes to production after they pass the automated build and test process. The goal of CD is to make sure that the code is always in a releasable state and to shorten the time between code being written and it being available to end-users.</li></ul></li>
				<li>GitHub Actions is a feature provided by GitHub that allows developers to automate their software development workflows, such as building, testing, and deploying code. These workflows are defined in YAML files and can be triggered by various events such as a push to a branch, a pull request, or a scheduled time. Developers can use GitHub Actions to automate their CI/CD workflows.</li>
				<li>CD is the practice of automatically building, testing, and deploying code changes to different environments after they pass the automated build and test process. It is an extension of CI, and the goal is to ensure that the code changes are always in a releasable state, so that they can be deployed to production at any time.</li>
			</ol>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor436"/>Chapter 15</h1>
			<ol>
				<li value="1"><strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">S3</strong>) is an object storage service provided by <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) that allows you to store and retrieve large amounts of data.</li>
				<li>To create an <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) user on AWS, you can use the AWS Management Console. Here’s an example of how to create an IAM user using the AWS Management Console:<ol><li>Log in to the AWS Management Console</li><li>Open the IAM console.</li><li>In the <strong class="bold">Navigation</strong> pane, choose <strong class="bold">Users</strong> and then choose <strong class="bold">Add user</strong>.</li><li>Type the username and select the <strong class="bold">AWS </strong><strong class="bold">access type</strong>.</li><li>Choose <strong class="bold">Permissions</strong>.</li><li>Choose <strong class="bold">Add user to a group</strong>, create group, or <strong class="bold">Add existing groups</strong> as appropriate.</li><li>Choose <strong class="bold">Tags</strong>.</li><li>Choose <strong class="bold">Review</strong>.</li><li>Choose <strong class="bold">Create user</strong>.</li></ol></li>
				<li>The command used to build a React application is <code>react-scripts build</code>. This command will take all the code and assets in your application and create a production-ready build that can be deployed on a web server.</li>
				<li>In a Node.js or more specifically a React project, environment variables are typically retrieved using the <code>process.env</code> object. For example, you can access the value of an environment variable named <code>VARIABLE</code> using <code>process.env.VARIABLE</code>.</li>
			</ol>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor437"/>Chapter 16</h1>
			<ol>
				<li value="1">Amazon CloudFront is a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>) provided by AWS. It allows you to distribute content, such as web pages, images, videos, and more, to users across the world by caching the content on servers located in various geographic locations. CloudFront can be used to deliver content from a variety of origins, such as an S3 bucket or a custom origin.</li>
				<li>There are several strategies for cache invalidation in Django:<ul><li><strong class="bold">Per-site cache</strong>: This enables you to cache your entire website.</li><li><strong class="bold">Template fragment cache</strong>: This enables you to cache some components of the website. For example, you can decide to only cache the footer.</li><li><strong class="bold">Per-view cache</strong>: This enables you to cache the output of individual views.</li><li><strong class="bold">Low-level cache</strong>: Django provides an API you can use for interacting directly with the cache. It is useful if you want to produce a certain behavior based on a set of actions.</li></ul></li>
				<li>Logging is important because it allows you to track the activity of your system, troubleshoot issues, and gather data for analysis. Logs provide a detailed history of what has happened in your system, including events such as user actions, system failures, and performance metrics. This information can be used to identify trends, detect patterns, and troubleshoot problems.</li>
			</ol>
		</div>
		<div><div></div>
		</div>
	</body></html>