<html><head></head><body>
		<div id="_idContainer181">
			<h1 id="_idParaDest-278" class="chapter-number"><a id="_idTextAnchor352"/>16</h1>
			<h1 id="_idParaDest-279"><a id="_idTextAnchor353"/>Performance, Optimization, and Security</h1>
			<p>In the previous chapters of the book, we have created a full stack application from scratch, starting with building and creating a REST API using Django and Django REST Framework and then creating a web interface with React to communicate with the API we created. We have also deployed <a id="_idTextAnchor354"/>applications on services such as AWS EC2 and AWS S3. However, we need to further investigate some important aspects of having an application deployed on the internet, such as performance checks, query optimization, <a id="_idTextAnchor355"/>frontend optimization, and finally, <span class="No-Break">security aspects.</span></p>
			<p>In this chapter, we will learn how to create a performant API with fewer SQL queries and faster API responses, how to serve the API and the React frontend over HTTPS using AWS CloudFront, and how to log out users using the API. In this chapter, we will cover the <span class="No-Break">following points:</span></p>
			<ul>
				<li>Revoking <span class="No-Break">JWT tokens</span></li>
				<li><span class="No-Break">Adding caching</span></li>
				<li>Optimizing the deployment of a <span class="No-Break">React application</span></li>
				<li>Securing deployed applications with HTTPS with <span class="No-Break">AWS <a id="_idTextAnchor356"/>CloudFront</span></li>
			</ul>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor357"/>Technical requirements</h1>
			<p>For this chapter, you need to have an active AWS account with access to services such as S3, EC2, and <a id="_idTextAnchor358"/>CloudFront. You can also find the code for this chapter <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap16</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor359"/>Revoking JWT tokens</h1>
			<p>In this book, we have implemented an authentication system using <strong class="bold">JSON Web Tokens</strong> (<strong class="bold">JWTs</strong>), and because it is a stateless authentication system, most of the authentication flow is handled by the <a id="_idIndexMarker861"/>frontend. If we want to log the user out of the Postagram React application, we<a id="_idTextAnchor360"/> must clear the tokens from the local storage of the browser, and the user is automatically redirected to the login page. But even if the tokens are deleted from the browser, they are <span class="No-Break">still active.</span></p>
			<p>The refresh tokens have a longer life period, so if a hacker gets their hands on a refresh token, they can still request access tokens and make HTTP requests using someone else’s identity. To avoid that, we will add a logout feature to invalidate access and refresh tokens from the <span class="No-Break">server side.</span></p>
			<p>The package used to add JWT authentication on the Django REST API (<strong class="source-inline">djangorestframework-simplejwt</strong>) supports blacklisting tokens, and that is the perfect feature we need here. Let’s set up the required configurations for the logout feature, and let’s add the feature to the Django <span class="No-Break">REST API.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor361"/>Adding a logout endpoint</h2>
			<p>In this section, we will write<a id="_idIndexMarker862"/> some code on the Django application to add an endpoint <span class="No-Break">for logout:</span></p>
			<ol>
				<li>In the <strong class="source-inline">settings.py</strong> file of the project, add the following entry to the <span class="No-Break"><strong class="source-inline">INSTALLED_APPS</strong></span><span class="No-Break"> list:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
"corsheaders",
"rest_framework_simplejwt.token_blacklist",
...</pre>
			<ol>
				<li value="2">After that, create a file called <strong class="source-inline">logout.py</strong> in the <strong class="source-inline">core/auth/viewsets</strong> directory. This file will contain the code for the <strong class="source-inline">viewsets</strong> and the logic to blacklist <span class="No-Break">a token.</span></li>
				<li>In this file, add the required imports and define the <span class="No-Break"><strong class="source-inline">LogoutViewSet</strong></span><span class="No-Break"> class:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/logout.py</p>
			<pre class="source-code">
from rest_framework_simplejwt.tokens import RefreshToken, TokenError
from rest_framework import viewsets, status, permissions
from rest_framework.exceptions import ValidationError
from rest_framework.response import Response
class LogoutViewSet(viewsets.ViewSet):
   authentication_classes = ()
   permission_classes = (permissions.IsAuthenticated,)
   http_method_names = ["post"]</pre>
			<p>The logout endpoint will only accept <strong class="source-inline">POST</strong> requests, as the client will be required to pass a refresh token within the body of the <strong class="source-inline">POST</strong> request. We also specify that only authenticated users have permission to access <span class="No-Break">this endpoint.</span></p>
			<ol>
				<li value="4">Let’s write the <strong class="source-inline">create</strong> method <a id="_idIndexMarker863"/>of the <span class="No-Break"><strong class="source-inline">LogoutViewSet</strong></span><span class="No-Break"> class:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/viewsets/logout.py</p>
			<pre class="source-code">
...
class LogoutViewSet(viewsets.ViewSet):
...
   def create(self, request, *args, **kwargs):
       refresh = request.data.get("refresh")
       if refresh is None:
           raise ValidationError({"detail":
             "A refresh token is required."})
       try:
           token = RefreshToken(request.data.get(
             "refresh"))
           token.blacklist()
           return Response(
             status=status.HTTP_204_NO_CONTENT)
       except TokenError:
           raise ValidationError({"detail":
             "The refresh token is invalid."})</pre>
			<p>In the preceding code, we ensure that the refresh token is present in the body of the request. Otherwise, we <a id="_idIndexMarker864"/>raise an error. Once the verification is done, we encapsulate the blacklisting logic in a <span class="No-Break"><strong class="source-inline">try/except</strong></span><span class="No-Break"> block:</span></p>
			<ul>
				<li>If the token is valid, then the token<a id="_idTextAnchor362"/> is blacklisted, and we return a response with a <strong class="source-inline">204 HTTP</strong> <span class="No-Break">status code.</span></li>
				<li>If there is an error related to the token, then the token<a id="_idTextAnchor363"/> is invalid, and we return a <span class="No-Break">validation error.</span></li>
			</ul>
			<ol>
				<li value="5">Let’s not forget to add the newly created <strong class="source-inline">ViewSet</strong> in the <strong class="source-inline">routers.py</strong> f<a id="_idTextAnchor364"/>ile and register a <span class="No-Break">new route:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/routers.py</p>
			<pre class="source-code">
...
from core.auth.viewsets import (
   RegisterViewSet,
   LoginViewSet,
   RefreshViewSet,
   LogoutViewSet,
)
...
router.register(r"auth/logout", LogoutViewSet, basename="auth-logout")</pre>
			<ol>
				<li value="6">Great! To follow best practices for building software, we must add a test for the newly added<a id="_idIndexMarker865"/> route in the <span class="No-Break"><strong class="source-inline">core/auth/tests.py</strong></span><span class="No-Break"> file:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/auth/tests.py</p>
			<pre class="source-code">
...
def test_logout(self, client, user):
   data = {"username": user.username,
           "password": "test_password"}
   response = client.post(self.endpoint + "login/",
                          data)
   assert response.status_code == status.HTTP_200_OK
   client.force_authenticate(user=user)
   data_refresh = {"refresh":
     response.data["refresh"]}
   response = client.post(self.endpoint + "logout/",
     data_refresh)
   assert response.status_code ==
     status.HTTP_204_NO_CONTENT</pre>
			<p>In the preceding code, we log in to retrieve a refresh token and force the authentication for the user so we can access the logout endpoint. After that, we ensure that we have returned the right status code when the logout <span class="No-Break">is successful.</span></p>
			<ol>
				<li value="7">Run the tests using the <strong class="source-inline">pytest</strong> command. If you are using Docker, then you can run the tests using <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold"> docker-compose exec -T api pytest</strong></pre></li>
			</ol>
			<p>With the logout endpoint<a id="_idIndexMarker866"/> ready, we can now make some modifications to the authentication logic (mostly the logout logic) in the <span class="No-Break">React application.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor365"/>Handling the logout with React</h2>
			<p>We have already handled the<a id="_idIndexMarker867"/> logout on the React application to a certain extent by just deleting the tokens from the local storage. There is nothing big to modify here, we will just add a function to make a request to the API, and if this request is successful, we will delete the tokens and the user from the local storage of the browser. The current logout logic on the React application is handled in the <span class="No-Break"><strong class="source-inline">NavigationBar</strong></span><span class="No-Break"> component:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/NavBar.jsx</p>
			<pre class="source-code">
...
             &lt;NavDropdown.Item
               onClick={userActions.logout}&gt;
               Logout
             &lt;/NavDropdown.Item&gt;
...</pre>
			<p>Inside the <strong class="source-inline">useActions</strong> Hook<a id="_idIndexMarker868"/> function, let’s tweak the <strong class="source-inline">logout</strong> method to make an API call before deleting <span class="No-Break">the user:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/hooks/user.actions.js</p>
			<pre class="source-code">
...
 // Logout the user
 function logout() {
   return axiosService
     .post(`${baseURL}/auth/logout/`,
           { refresh: getRefreshToken() })
     .then(() =&gt; {
       localStorage.removeItem("auth");
       navigate("/login");
     });
 }</pre>
			<p>Once it is done, let’s create a function in the <strong class="source-inline">NavigationBar</strong> component to handle the cases when there is an error from the API. We will display a toast HTML bloc on the page with the <span class="No-Break">error message:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/NavBar.jsx</p>
			<pre class="source-code">
import React, { useContext } from "react";
import { Context } from "./Layout";
...
function NavigationBar() {
 const { setToaster } = useContext(Context);
 const userActions = useUserActions();
 const user = getUser();
 const handleLogout = () =&gt; {
   userActions.logout().catch((e) =&gt;
     setToaster({
       type: "danger",
       message: "Logout failed",
       show: true,
       title: e.data?.detail | "An error occurred.",
     })
   );
 };
...</pre>
			<p>Great! Our full stack <a id="_idIndexMarker869"/>application now supports logout. In the next section, we will discuss a recurrent topic when deploying a project <span class="No-Break">online, caching<a id="_idTextAnchor366"/>.</span></p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor367"/>Adding caching</h1>
			<p>In software <a id="_idIndexMarker870"/>computing, caching is the process of storing copies of files in a cache so they can be accessed more quickly. A <strong class="bold">cache</strong> is a<a id="_idIndexMarker871"/> temporary storage location that stores data, files, and information concerning software that is <span class="No-Break">regularly requested.</span></p>
			<p>A great example and explanation <a id="_idTextAnchor368"/>of caching comes from Peter Chester, who asked the audience at one of his speeches: <em class="italic">“What’s 3,485,250 divided by 23,235?” Everyone fell si<a id="_idTextAnchor369"/>lent for a moment, but someone pulled a calculator and yelled out the answer “150!”</em>. Then, Peter Chester asked the same question again, and this time, everyone was able to answer the <span class="No-Break">question immediately.</span></p>
			<p>This is a great demo of the concept of caching: <em class="italic">The computation is only done once by the machine and then saved in quick memory for </em><span class="No-Break"><em class="italic">faster access</em></span><span class="No-Break">.</span></p>
			<p>It is a concept used widely by companies and primarly social media websites where millions of users access the same posts, videos, and files. It would be very primitive to hit the database whenever millions of people want to access the same information. For example, if a tweet is gaining traction on Twitter, it is automatically moved to cache storage for qui<a id="_idTextAnchor370"/>ck access. And, if you have an influencer such as Kim Kardashian posting a picture on Instagram, you<a id="_idIndexMarker872"/> should expect a lot of requests for this picture. Thus caching can be useful here to avoid thousands of queries on <span class="No-Break">the database.</span></p>
			<p>To recapitulate, caching brings the <span class="No-Break">following benefits:</span></p>
			<ul>
				<li>Reduced <span class="No-Break">load time</span></li>
				<li>Reduced <span class="No-Break">bandwidth usage</span></li>
				<li>Reduced SQL queries <span class="No-Break">on databases</span></li>
				<li><span class="No-Break">Reduced downtime</span></li>
			</ul>
			<p>Now that we have an idea about caching and its benefits, we can implement the concept using Django and even Docker. But before that, let’s quickly discuss the complexity caching brings to <span class="No-Break">your application.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor371"/>The cons of caching</h2>
			<p>You already know the <a id="_idIndexMarker873"/>advantages of using caching, mostly if your application is scaling or you want to improve load time and reduce costs. However, caching introduces some complexity to your system (it can also depend on the type of application you are developing). If your application is based on news or feeds, you might be in trouble, as you will need to define a good architecture <span class="No-Break">for caching.</span></p>
			<p>On the one hand, you have the chance to reduce load times by showing your users the same content for a period, but at the same time, your users might miss updates and maybe some important updates. Here, cache invalidation comes to <span class="No-Break">the rescue.</span></p>
			<p>Cache invalidation is the process of declaring cached content as inval<a id="_idTextAnchor372"/>id or stale. The content is invalidated, as it <a id="_idTextAnchor373"/>is no longer marked as being the most up-to-date version of a file. There are some <a id="_idIndexMarker874"/>methods available to invalidate a cache, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Purge (flush)</strong>: Cache purging instantly<a id="_idIndexMarker875"/> removes the content from the cache. When the content is requested again, it is stored in the memory cache before returning it to <span class="No-Break">the client.</span></li>
				<li><strong class="bold">Refresh</strong>: A cache refresh consists of refreshing<a id="_idIndexMarker876"/> the same content from the server and replacing the content stored in the cache with the new version fetched from the server. This is <a id="_idIndexMarker877"/>done in the React application using <strong class="bold">state-while-revalidate</strong> (<strong class="bold">SWR</strong>). Each time a post is created, we call a refresh function to fetch data again from <span class="No-Break">the server.</span></li>
				<li><strong class="bold">Ban</strong>: A cache ban does not remove <a id="_idIndexMarker878"/>content from the cache immediately. Rather, the content is marked as blacklisted. Then, when the client makes a request, it is matched with the blacklist content, and if a match is found, new content is fetched again and updated in the memory cache before returning to <span class="No-Break">the client.</span></li>
			</ul>
			<p>With the cons of caching and how to invalidate the cache understood, you are well equipped to add caching to the Django application. In the next section, let’s add caching to the Django API <span class="No-Break">of Postagram.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor374"/>Adding caching to the Django API</h2>
			<p>In the previous paragraphs, we have explored caching, its advantages, and the cons of the concept. Now, it’s time<a id="_idIndexMarker879"/> to implement caching within our D<a id="_idTextAnchor375"/>jango application. Django provides useful support for caching, which makes the configuration of cac<a id="_idTextAnchor376"/>hing within <a id="_idIndexMarker880"/>Django straightforward. Let’s start by making the required configurations depending on <span class="No-Break">your environment.</span></p>
			<h3>Configuring Django for caching</h3>
			<p>Using caching within Django <a id="_idIndexMarker881"/>requires configuring a memory cache. For the quickest read and write access, it is better to use a different data storage solution from SQL databases as SQL databases are known to<a id="_idIndexMarker882"/> be slower than memory databases (again, it depends on your needs). In this book, we will use Redis. Redis is an open source, in-memory data store used as a database, cache, streaming engine, and <span class="No-Break">message broker.</span></p>
			<p>We’ll review the configurations you need to make to start using Redis in your Django project, whether you are using Docker or not. However, for the deployment, we’ll use Docker f<a id="_idTextAnchor377"/>or <span class="No-Break">configuring Redis.</span></p>
			<p>So, if you are not going to use Docker, you can<a id="_idIndexMarker883"/> install Redis using the following <span class="No-Break">link: </span><a href="https://redis.io/download/"><span class="No-Break">https://redis.io/download/</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you are working in a Linux environment, you can check whether the service is running using the <strong class="source-inline">sudo service redis-server status</strong> command. If the service is not active, use the <strong class="source-inline">sudo service redis-server start</strong> command to start the Redis server. If you are using Windows, you will need to install or enable WSL2. You can read more <span class="No-Break">at: </span><a href="https://redis.io/docs/getting-started/installation/install-redis-on-windows/"><span class="No-Break">https://redis.io/docs/getting-started/installation/install-redis-on-windows/</span></a><span class="No-Break">.</span></p>
			<p>After th<a id="_idTextAnchor378"/>e installation on your machine, you can configure caching in Django using the <strong class="source-inline">CACHES</strong> setting in the <strong class="source-inline">settings.py</strong> file of the <span class="No-Break">Django project:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
...
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS':
              'django_redis.client.DefaultClient',
        }
    }
}</pre>
			<p>This configuration will require the installation of a Python package called <strong class="source-inline">django-redis</strong>. Install it by running<a id="_idIndexMarker884"/> the <span class="No-Break">following command:</span></p>
			<pre class="console">
pip install django-redis</pre>
			<p>If you are working with Docker, you<a id="_idIndexMarker885"/> just need to add the <span class="No-Break">following configurations:</span></p>
			<ol>
				<li value="1"> Add the <strong class="source-inline">django-redis</strong> package to the <span class="No-Break"><strong class="source-inline">requirements.txt</strong></span><span class="No-Break"> file:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">requirements.txt</p>
			<pre class="source-code">
django-redis==5.2.0</pre>
			<ol>
				<li value="2">Add the <strong class="source-inline">docker-compose.yaml</strong> configuration. We will add a new image in the Docker configuration to make sure that the Django application requires <strong class="source-inline">redis-server</strong> to be ready before the API service <span class="No-Break">starts running:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">docker-compose.yaml</p>
			<pre class="source-code">
services:
 redis:
   image: redis:alpine
…
api:
...
 depends_on:
  - db
  - redis
...</pre>
			<ol>
				<li value="3">Great! Add the following <a id="_idIndexMarker886"/>custom backend in the <strong class="source-inline">settings.py</strong> file of the <span class="No-Break">Django project:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">CoreRoot/settings.py</p>
			<pre class="source-code">
CACHES = {
   "default": {
       "BACKEND": "django_redis.cache.RedisCache",
       "LOCATION": "redis://redis:6379",
       "OPTIONS": {
           "CLIENT_CLASS":
             "django_redis.client.DefaultClient",
       },
   }
}</pre>
			<p>You will notice here that we are using <strong class="source-inline">redis</strong> as the host instead of <strong class="source-inline">127.0.0.1</strong>. This is because, with Docker, yo<a id="_idTextAnchor379"/>u can use the name of the service as a host. This is a better<a id="_idIndexMarker887"/> solution; otherwise, you will have to configure a static IP address for <span class="No-Break">the services.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">If you want to learn more about assigning a static IP address to your containers with Docker, you can read the following <span class="No-Break">resource: </span><a href="https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/"><span class="No-Break">https://www.howtogeek.com/devops/how-to-assign-a-static-ip-to-a-docker-container/</span></a><span class="No-Break">.</span></p>
			<p>Great! Now that we have configured Django for caching, let’s build the caching system for the <span class="No-Break">Postagram application.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor380"/>Using caching on the endpoints</h2>
			<p>Caching depends a lot on the<a id="_idIndexMarker888"/> business requirements for how much time you want to cache the data. Well, Django provides many levels <span class="No-Break">for caching:</span></p>
			<ul>
				<li><strong class="bold">Per-site cache</strong>: This enables you to<a id="_idIndexMarker889"/> cache your <span class="No-Break">entire website.</span></li>
				<li><strong class="bold">Template fragment cache</strong>: This enables <a id="_idIndexMarker890"/>you to cache some components of the website. For example, you can decide to only cache <span class="No-Break">the footer.</span></li>
				<li><strong class="bold">Per-view cache</strong>: This enables you to<a id="_idIndexMarker891"/> cache the output of <span class="No-Break">individual views.</span></li>
				<li><strong class="bold">Low-level cache</strong>: Django provides an API you can use for interacting directly with the cache. It is useful if you <a id="_idIndexMarker892"/>want to produce a certain behavior based on a set of actions. For example, in this book, if a post is updated or deleted, we will update <span class="No-Break">the cache.</span></li>
			</ul>
			<p>Now that we have a better idea about the levels of caching Django provides, let’s define the caching requirements for the <span class="No-Break">Postagram API.</span></p>
			<p>Our requirement is if there is a delete or an update on a comment or a post, the cache is updated. Otherwise, we return the same information in the cache to <span class="No-Break">the user.</span></p>
			<p>This can be achieved in many ways. We can use Django signals or directly add custom methods to the manager of the model’s <strong class="source-inline">Post</strong> and <strong class="source-inline">Comment</strong> classes. Let’s go with the latter. We will surcharge the <strong class="source-inline">save</strong> and <strong class="source-inline">delete</strong> methods of the <strong class="source-inline">AbstractModel</strong> class, so if there is an update on a <strong class="source-inline">Post</strong> or <strong class="source-inline">Comment</strong> object, we update <span class="No-Break">the cache.</span></p>
			<p>Inside the <strong class="source-inline">core/abstract/models.py</strong> file, add the following method on top of the file after <span class="No-Break">the imports:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/models.py</p>
			<pre class="source-code">
from django.core.cache import cache
...
def _delete_cached_objects(app_label):
   if app_label == "core_post":
       cache.delete("post_objects")
   elif app_label == "core_comment":
       cache.delete("comment_objects")
   else:
       raise NotImplementedError</pre>
			<p>The function in the preceding code takes an application label, and according to the value of this <strong class="source-inline">app_label</strong>, we invalidate the corresponding cache. For the moment, we only support caching for posts and comments. Notice how the name of the function is prefixed with a <a id="_idTextAnchor381"/><strong class="source-inline">_</strong>. It is a coding convention to specify that this method is private and should not be used outside the file where<a id="_idIndexMarker893"/> it <span class="No-Break">is declared.</span></p>
			<p>Inside the <strong class="source-inline">AbstractModel</strong> class, we can surcharge the <strong class="source-inline">save</strong> method. Before the <strong class="source-inline">save</strong> method is executed, we invalidate the cache. It means that on operations such as <strong class="source-inline">create</strong> and <strong class="source-inline">update</strong>, the cache will <span class="No-Break">be reset:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/abstract/models.py</p>
			<pre class="source-code">
class AbstractModel(models.Model):
...
   def save(
       self, force_insert=False, force_update=False,
       using=None, update_fields=None
   ):
       app_label = self._meta.app_label
       if app_label in ["core_post", "core_comment"]:
           _delete_cached_objects(app_label)
       return super(AbstractModel, self).save(
           force_insert=force_insert,
           force_update=force_update,
           using=using,
           update_fields=update_fields,
       )</pre>
			<p>In the preceding code,<a id="_idTextAnchor382"/> we retrieve <strong class="source-inline">app_label</strong> from the <strong class="source-inline">_meta</strong> attribute on the model. If it corresponds <a id="_idIndexMarker894"/>to either <strong class="source-inline">core_post</strong> or <strong class="source-inline">core_comment</strong>, we invalidate the cache, and the rest of the instructions can proceed. Let’s do the same for the <span class="No-Break"><strong class="source-inline">delete</strong></span><span class="No-Break"> method:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Core/abstract/models.py</p>
			<pre class="source-code">
class AbstractModel(models.Model):
…
   def delete(self, using=None, keep_parents=False):
       app_label = self._meta.app_label
       if app_label i" ["core_p"st", "core_comm"nt"]:
           _delete_cached_objects(app_label)
       return super(AbstractModel, self).delete(
         using=using, keep_parents=keep_parents)</pre>
			<p>Great. The cache invalidation logic has been implemented on the models. Let’s add the logic for cache data retrieving on the viewsets of the <strong class="source-inline">core_post</strong> application and the <span class="No-Break"><strong class="source-inline">core_comment</strong></span><span class="No-Break"> application.</span></p>
			<h3>Retrieving data from the cache</h3>
			<p>The cache invalidation is ready, so we <a id="_idIndexMarker895"/>can freely retrieve data from the cache on the endpoints for the posts and the comments. Let’s start with <strong class="source-inline">PostViewSet</strong> as the portion of code that will be written on <strong class="source-inline">PostViewSet</strong> and <strong class="source-inline">CommentViewSet</strong> will be the same. As a small exercise, you can write the logic for retrieving the cache for <span class="No-Break">the comments.</span></p>
			<p>Inside the <strong class="source-inline">PostViewSet</strong> class, we will <a id="_idIndexMarker896"/>rewrite the <strong class="source-inline">list()</strong> method. On the <strong class="bold">Django REST framework</strong> (<strong class="bold">DRF</strong>) open source <a id="_idIndexMarker897"/>repository, the code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
"""List a queryset"""
def list(self, request, *args, **kwargs):
   queryset = self.filter_queryset(self.get_queryset())
   page = self.paginate_queryset(queryset)
   if page is not None:
       serializer = self.get_serializer(page, many=True)
       return self.get_paginated_response(serializer.data)
   serializer = self.get_serializer(queryset, many=True)
   return Response(serializer.data)</pre>
			<p>In the preceding code, a <strong class="source-inline">queryset</strong> call is made to retrieve the data, and then this <strong class="source-inline">queryset</strong> call is paginated, serialized, and returned inside a <strong class="source-inline">Response</strong> object. Let’s tweak the method a <span class="No-Break">little bit:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">core/post/viewsets.py</p>
			<pre class="source-code">
class PostViewSet(AbstractViewSet):
...
   def list(self, request, *args, **kwargs):
       post_objects = cache.get("post_objects")
       if post_objects is None:
           post_objects =
             self.filter_queryset(self.get_queryset())
           cache.set("post_objects", post_objects)
       page = self.paginate_queryset(post_objects)
       if page is not None:
           serializer = self.get_serializer(page,
                                            many=True)
           return self.get_paginated_response(
             serializer.data)
       serializer = self.get_serializer(post_objects,
                                        many=True)
       return Response(serializer.data)</pre>
			<p>In the preceding code, instead of doing a lookup on the database directly, we check the cache. If <strong class="source-inline">post_objects</strong> is <strong class="source-inline">None</strong> when making a query to the database, save <strong class="source-inline">queryset</strong> in the cache and finally proceed to return the cache objects to <span class="No-Break">the user.</span></p>
			<p>As you can see, the <a id="_idIndexMarker898"/>process is very simple. You just need to have a robust caching strategy. You can do the same for <strong class="source-inline">CommentViewSet</strong> as an exercise. You can check the code at this link to compare your <span class="No-Break">results: </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/chap16/core/comment/viewsets.py</span></a><span class="No-Break">.</span></p>
			<p>In this section, we have explored<a id="_idTextAnchor383"/> the benefits of caching, and we have implemented caching in the Django application. In the next section, we will see how to optimize the React build using tools <a id="_idIndexMarker899"/>such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">webpack</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor384"/>Optimizing the React application build</h1>
			<p>In the previous chapter, we successfully built the React application and made the deployment on AWS S3. However, we could have done better in terms of optimization and performance. In this section, we<a id="_idIndexMarker900"/> will use the famous webpack module builder to optimize the React build <span class="No-Break">of Postagram.</span></p>
			<p>There are a lot of advantages<a id="_idIndexMarker901"/> of using webpack <span class="No-Break">in React:</span></p>
			<ul>
				<li><strong class="bold">It speeds up development and build times</strong>: Using webpack in development enhances the speed of fast reload <span class="No-Break">of React.</span></li>
				<li><strong class="bold">It provides minification</strong>: Webpack automatically minimizes the code wi<a id="_idTextAnchor385"/>thout changing the functionalities. This results in a faster load on the <span class="No-Break">browser side.</span></li>
				<li><strong class="bold">Code splitting</strong>: Webpack converts JavaScript files <span class="No-Break">into modules.</span></li>
				<li><strong class="bold">It eliminates dead assets</strong>: Webpack only <a id="_idTextAnchor386"/>builds the images and CSS that your code uses <span class="No-Break">and needs.</span></li>
			</ul>
			<p>Let’s start by integrating webpack into <span class="No-Break">the project.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor387"/>Integrating webpack</h2>
			<p>Follow these steps to integrate <a id="_idIndexMarker902"/>webpack into <span class="No-Break">your project:</span></p>
			<ol>
				<li value="1">Inside the React project, run the following command to add the <strong class="source-inline">webpack</strong> and <span class="No-Break"><strong class="source-inline">webpack-cli</strong></span><span class="No-Break"> packages:</span><pre class="source-code">
<strong class="bold">yarn add -D webpack webpack-cli</strong></pre></li>
				<li>Once the installation is done, modify the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> scripts:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
			<pre class="source-code">
...
"scripts": {
    "start": "react-scripts start",
<strong class="bold">    "build": "webpack --mode production",</strong>
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
...</pre>
			<p>Also, we need to <a id="_idIndexMarker903"/>install Babel, which is a JavaScript compiler that converts next-generation JavaScript code into <span class="No-Break">browser-compatible JavaScript.</span></p>
			<ol>
				<li value="3">In the React project, Babel will convert the React components, the ES6 variables, and JSX code to regular JavaScript so old browsers can render the <span class="No-Break">components correctly:</span><pre class="source-code">
<strong class="bold">yarn add -D @babel/core babel-loader @babel/preset-env @babel/preset-react</strong></pre></li>
			</ol>
			<p><strong class="source-inline">babel-loader</strong> is the webpack loader for Babel, <strong class="source-inline">babel/preset-env</strong> compiles with JavaScript to ES5, and <strong class="source-inline">babel/preset-react</strong> is for compiling JSX <span class="No-Break">to JS.</span></p>
			<ol>
				<li value="4">Then create a new file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">.babelrc</strong></span><span class="No-Break">:</span><pre class="source-code">
{</pre><pre class="source-code">
  "presets": ["@babel/preset-env",</pre><pre class="source-code">
              "@babel/preset-react"]</pre><pre class="source-code">
}</pre></li>
				<li>Then create a new file called <strong class="source-inline">webpack.config.js</strong>. This file will contain the configurations for<a id="_idIndexMarker904"/> webpack. Before writing the con<a id="_idTextAnchor388"/>figuration, add some plugins for optimizing HTML, CSS, and <span class="No-Break">copy files:</span><pre class="source-code">
<strong class="bold">yarn add -D html-webpack-plugin html-loader copy-webpack-plugin</strong></pre></li>
				<li>And then add the <a id="_idIndexMarker905"/>following configuration <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">webpack.config.js</strong></span><span class="No-Break">:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
			<pre class="source-code">
const path = require("path");
const HtmlWebPackPlugin = require("html-webpack-plugin");
const CopyPlugin = require("copy-webpack-plugin");
const webpack = require("webpack");
module.exports = {
 module: {
   rules: [
     {
       test: /\.(js|jsx)$/,
       exclude: /node_modules/,
       use: {
         loader: "babel-loader",
       },
     },
     {
       test: /\.css$/i,
       use: ["style-loader", "css-loader"],
     },
   ],
 },
};</pre>
			<p>The preceding code above tells webpack to send all files in <strong class="source-inline">.js</strong> and <strong class="source-inline">.jsx</strong> <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">babel-loader</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="7">Let’s add another <a id="_idIndexMarker906"/>configuration called <strong class="source-inline">resolve</strong> to generate all the possible paths to the module. For example, webpack would then proceed to look up each of those paths until it finds <span class="No-Break">a file:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
			<pre class="source-code">
...
 resolve: {
   modules: [path.resolve(__dirname, "src"),
             "node_modules"],
   extensions: ["", ".js", ".jsx"],
 },
};</pre>
			<ol>
				<li value="8">Let’s add the configuration for the plugins we will use in <span class="No-Break">this project:</span></li>
			</ol>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">webpack.config.js</p>
			<pre class="source-code">
...
 plugins: [
   new HtmlWebPackPlugin({
     template: "./public/index.html",
     filename: "./index.html",
   }),
   new CopyPlugin({
     patterns: [
       {
         from: "public",
         globOptions: {
           ignore: ["**/*.html"],
         },
       },
     ],
   }),
   new webpack.DefinePlugin({ process: {env: {}} }),
 ],
 output: {
   publicPath: '.',
 },
};</pre>
			<p>In the preceding code, we have<a id="_idIndexMarker907"/> added plugin configurations for <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">html-loader</strong>: This will send the HTML files <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">html-loader</strong></span></li>
				<li><strong class="source-inline">copy</strong>: This will copy the content of the public file to the <span class="No-Break"><strong class="source-inline">dist</strong></span><span class="No-Break"> file</span></li>
				<li><strong class="source-inline">define</strong>: This plugin declares the <strong class="source-inline">process</strong> object so we can access environment variables in the <span class="No-Break">production environment</span></li>
			</ul>
			<ol>
				<li value="9">Once it is done, run the <span class="No-Break"><strong class="source-inline">build</strong></span><span class="No-Break"> command:</span><pre class="source-code">
<strong class="bold">yarn build</strong></pre></li>
			</ol>
			<p>Webpack will take control and build the React application in the <span class="No-Break"><strong class="source-inline">dist</strong></span><span class="No-Break"> directory:</span></p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/Figure_16.01_B18221.jpg" alt="Figure 16.1 – The content of the dist directory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1 – The content of the dist directory</p>
			<p>Great! You can push the changes<a id="_idIndexMarker908"/> made to GitHub, and the code will be deployed on AWS S3. To make the testing and build faster, we will change the package <a id="_idTextAnchor389"/>manager from <strong class="source-inline">yarn</strong> to <strong class="source-inline">pnpm</strong>. The next section is optional, but it will help you with a faster build for your <span class="No-Break">React application.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor390"/>Using pnpm</h2>
			<p><strong class="source-inline">pnpm</strong> is a replacement for the <strong class="source-inline">npm</strong> JavaScript package manager, which is built on top of <strong class="source-inline">npm</strong>, and is much faster and<a id="_idIndexMarker909"/> more efficient. It provides advantages such as disk space efficiency, improved speed, and better security. The <strong class="source-inline">pnpm</strong> package manager is the one to use if you want to spend less time building and making cuts to the minutes spent on the <span class="No-Break">GitHub Actions.</span></p>
			<p>Let’s install <strong class="source-inline">pnpm</strong> on <span class="No-Break">our machine:</span></p>
			<pre class="source-code">
<strong class="bold">npm install -g pnpm</strong></pre>
			<p>After that, we can generate a <strong class="source-inline">pnpm-lock.yaml</strong> file. We can generate this file from another manager’s lock file, in our case, from the <span class="No-Break"><strong class="source-inline">yarn.lock</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
pnpm import</pre>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/Figure_16.02_B18221.jpg" alt="Figure 16.2 – Result of pnpm import"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2 – Result of pnpm import</p>
			<p>A new file will be generated in the <a id="_idIndexMarker910"/>directory of the React project. Then, modify the <strong class="source-inline">deploy-frontend.yml</strong> file to configure for <span class="No-Break"><strong class="source-inline">pnpm</strong></span><span class="No-Break"> usage:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">.github/workflows/deploy-frontend.yml</p>
			<pre class="source-code">
jobs:
 test:
   name: Tests
   runs-on: ubuntu-latest
   defaults:
     run:
       working-directory: ./social-media-react
   steps:
     - uses: actions/checkout@v3
     - uses: pnpm/action-setup@v2.2.4
       with:
         version: 7
     - name: Use Node.js 16
       uses: actions/setup-node@v3
       with:
         node-version: 16
         cache: 'pnpm'
         cache-dependency-path:
           ./social-media-react/pnpm-lock.yaml</pre>
			<p>After that, just replace <strong class="source-inline">yarn</strong> with <strong class="source-inline">pnpm</strong> in the <strong class="source-inline">deploy-frontend.yml</strong> file. You will notice a faster build for<a id="_idIndexMarker911"/> the <span class="No-Break">React application.</span></p>
			<p>In this section, we have covered pnpm and webpack and how they can boost the performance of the React applic<a id="_idTextAnchor391"/>ation. In the next section, we <a id="_idTextAnchor392"/>will learn how to secure HTTP requests using <span class="No-Break">AWS CloudFront.</span></p>
			<h1 id="_idParaDest-291">Se<a id="_idTextAnchor393"/>curing deployed applications with HTTPS with AWS CloudFront</h1>
			<p>When we have deployed<a id="_idIndexMarker912"/> the backend and the <a id="_idIndexMarker913"/>frontend on AWS S3, the applications are served through HTTP. Basically<a id="_idTextAnchor394"/>, our full stack application is not secured on<a id="_idIndexMarker914"/> the internet, and we are vulnerable. According to the <strong class="bold">Open Web Application Security Project</strong> (<strong class="bold">OSWAP</strong>) description of Insecure Transport (<a href="https://owasp.org/www-community/vulnerabilities/Insecure_Transport">https://owasp.org/www-community/vulnerabilities/Insecure_Transport</a>), our application is vulnerable to the <span class="No-Break">following attacks:</span></p>
			<ul>
				<li>Attacks targeting login credentials, session IDs, and other <span class="No-Break">sensitive information</span></li>
				<li>Bypassing <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) protocol by<a id="_idIndexMarker915"/> entering HTTP instead of HTTPS at the beginning of the URL in <span class="No-Break">the browser</span></li>
				<li>Sending non-protected URLs of authentication pages to users to trick them into authenticating <span class="No-Break">via HTTP</span></li>
			</ul>
			<p>AWS EC2 and AWS S3 don’t serve content through<a id="_idTextAnchor395"/> HTTPS by default. But AWS also has a service called CloudFront that can help you serve your applications via HTTPS, plu<a id="_idTextAnchor396"/>s it also makes the content <span class="No-Break">available</span><span class="No-Break"><a id="_idIndexMarker916"/></span><span class="No-Break"> globally.</span></p>
			<p><strong class="bold">AWS CloudFront</strong> is a content <a id="_idIndexMarker917"/>delivery network service, and in the next section, we will configure the AWS S3 bucket hosting the React application wi<a id="_idTextAnchor397"/>th <span class="No-Break">AWS Cloudfront.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor398"/>Configuring the React project with CloudFront</h2>
			<p>Follow these steps to configure our<a id="_idIndexMarker918"/> React pr<a id="_idTextAnchor399"/>oject <span class="No-Break">with </span><span class="No-Break"><a id="_idIndexMarker919"/></span><span class="No-Break">CloudFront:</span></p>
			<ol>
				<li value="1">On the AWS dashboard, select the <strong class="bold">CloudFront</strong> service in the AWS console and click on <span class="No-Break"><strong class="bold">Create Distribution</strong></span><span class="No-Break">.</span></li>
				<li>Copy the origin of your website hosted on AWS and paste it into the <strong class="bold">Origin domain</strong> <span class="No-Break">name field:</span></li>
			</ol>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/Figure_16.03_B18221.jpg" alt="Figure 16.3 – Origin configuration of the CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3 – Origin configuration of the CloudFront distribution</p>
			<ol>
				<li value="3">Next, configure<a id="_idIndexMarker920"/> the default <span class="No-Break">cache</span><span class="No-Break"><a id="_idIndexMarker921"/></span><span class="No-Break"> behaviors:</span></li>
			</ol>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/Figure_16.04_B18221.jpg" alt="Figure 16.4 – Viewer configuration of the CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4 – Viewer configuration of the CloudFront distribution</p>
			<ol>
				<li value="4">Once the cache <a id="_idIndexMarker922"/>configuration is done, create the<a id="_idIndexMarker923"/> distribution. AWS will take some time to create the distribution and once it is done, click on the distribution <strong class="bold">ID</strong> field to copy <span class="No-Break">the URL:</span></li>
			</ol>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/Figure_16.05_B18221.jpg" alt="Figure 16.5 – List of the CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5 – List of the CloudFront distribution</p>
			<ol>
				<li value="5">Once <strong class="bold">Status</strong> changes to <strong class="bold">Enabled</strong>, click on the distribution <strong class="bold">ID</strong> field to access more details about the distribution and copy the distribution <span class="No-Break">domain name:</span></li>
			</ol>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/Figure_16.06_B18221.jpg" alt="Figure 16.6﻿ – Details about the created CloudFront distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6<a id="_idTextAnchor400"/> – Details about the created CloudFront distribution</p>
			<p>The CloudFront <a id="_idIndexMarker924"/>distribution URL will return the React<a id="_idIndexMarker925"/> application over HTTPS. Great, the React application is secured on the internet and well distributed worldwide. Great! We have<a id="_idTextAnchor401"/> successfully secured our <a id="_idTextAnchor402"/>application over HTTPS using AWS CloudFront. From now, you can build a full stack<a id="_idIndexMarker926"/> application with Django and React, assure code quality with tests and linting, automate <strong class="bold">continuous <a id="_idTextAnchor403"/>integration</strong> and <strong class="bold">continuous delivery</strong> (<strong class="bold">CI/CD</strong>) pipelines usi<a id="_idTextAnchor404"/>ng GitHub Actions and use AWS services such as S3, EC2, and CloudFront to deploy and serve your web application around <span class="No-Break">the world.</span></p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor405"/>Summary</h1>
			<p>In this chapter, we have covered some important points about optimizations and s<a id="_idTextAnchor406"/>ecurity. We have implemented a logout endpoint to blacklist tokens, added caching to the Django application using Redis, optimized the backend build using webpack, and secured the full stack application over HTTPS using AWS CloudFront. And that’s the final touch of <span class="No-Break">this book.</span></p>
			<p>We have covered how to build a powerful and robust full stack application using Django and React. We have covered how to create a project from scratch, build an API secured with JWT tokens,<a id="_idTextAnchor407"/> build a frontend application with React and Bootstrap, and deploy the applications on AWS. We have explored Docker and tools such as GitHub Actions to make the development and deployment process secure, faster, and automated. You can now build and deploy a full stack application using Django <span class="No-Break">and React!</span></p>
			<p>We are now at the end of this book, and if you are looking for best practices and what to learn next, feel free to go through the <a id="_idTextAnchor408"/><em class="italic">Appendix</em> directly after <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor409"/>Questions</h1>
			<ol>
				<li value="1">What is <span class="No-Break">AWS Cl<a id="_idTextAnchor410"/>oudFront?</span></li>
				<li>What are the cache <span class="No-Break">invalidation strategies?</span></li>
				<li>Why is <span class="No-Break">logging important?</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer182" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer183">
			<h1 id="_idParaDest-295"><a id="_idTextAnchor411"/>Appendix</h1>
			<p>Every successful application will eventually need to scale, and this process can cause resource issues and more optimization problems. In this appendix, I will list what you can read to deepen your studies after this book so you can become a better full <span class="No-Break">stack developer.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor412"/>Logging</h2>
			<p>Logging is the action of collecting information about an application as it performs different tasks or events. In the development process of an application, if you have a <a id="_idTextAnchor413"/>bug, you can use <strong class="source-inline">print()</strong> or <strong class="source-inline">console.log()</strong> to identify the issues. Even better, with <strong class="source-inline">DEBUG</strong> as <strong class="source-inline">true</strong> in Django, you have access to the whole traceback of a <strong class="source-inline">500</strong> error. Once your project <a id="_idIndexMarker927"/>deployed in production, this is no longer the case. You can implement logging in files using the default logging package provided by Python; Django has full support that you can explore in the official documentation at <a href="https://docs.djangoproject.com/en/4.1/topics/logging/">https://docs.djangoproject.com/en/4.1/topics/logging/</a>. If you are looking to get real-time notifications when you have a <strong class="source-inline">500</strong> error, you can connect your backend to services such as Sentry, Datadog, <span class="No-Break">or Bugsnag.</span></p>
			<h2 id="_idParaDest-297">Database queries<a id="_idTextAnchor414"/> optimization</h2>
			<p>The Django ORM is a<a id="_idTextAnchor415"/> very flexible and powerful tool,<a id="_idTextAnchor416"/> and it can be used well or badly. Databases are important in your<a id="_idIndexMarker928"/> full stack applications and the fewer queries you make, the better it is for the high availability of the SQL database. Django provides many methods you can study and explore if you need to optimize database queries. You can read more <span class="No-Break">at </span><a href="https://docs.djangoproject.com/en/4.1/topics/db/optimization/"><span class="No-Break">https://docs.djangoproject.com/en/4.1/topics/db/optimization/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor417"/>Security</h2>
			<p>If you are deploying a web <a id="_idIndexMarker929"/>application <a id="_idTextAnchor418"/>on the internet, it’s important to ensure that you have<a id="_idTextAnchor419"/> a secure application. In the beginning, you don’t really need<a id="_idTextAnchor420"/> a lot, but you do need to ensure that your system is secured against the top 10 threats listed by OWASP. You can learn more about this at the following <span class="No-Break">link: </span><a href="https://owasp.org/www-project-top-ten/"><span class="No-Break">https://owasp.org/www-project-top-ten/</span></a><span class="No-Break">.</span></p>
		</div>
		<div>
			<div id="_idContainer184" class="IMG---Figure">
			</div>
		</div>
	

		<div id="_idContainer185">
			<h1 id="_idParaDest-299"><a id="_idTextAnchor421"/>Answers</h1>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor422"/>Chapter 1</h1>
			<ol>
				<li>A <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) API is a web architecture and a set of constraints that provide simple interfaces to interact with resources, allowing clients to retrieve or manipulate them using standard <span class="No-Break">HTTP requests.</span></li>
				<li>Django is a Python web framework that enables the fast development of secure and maintainable websites. It follows the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) architectural pattern and emphasizes reusability <span class="No-Break">and pluggability.</span></li>
				<li>To create a Django project, you need to have Django installed on your OS. Once you have it installed, you can use the following command to create a new <span class="No-Break">Django project:</span><p class="L---source" lang="fr-FR" xml:lang="fr-FR"><strong class="bold">django-admin startproject DjangoProject</strong></p></li>
			</ol>
			<p>The preceding command will create a Django project with the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">DjangoProject</strong></span></p>
			<ol>
				<li value="4">Migrations are Django’s way of synchronizing changes you make to your models (adding a field, deleting a model, etc.) into <span class="No-Break">your database.</span></li>
				<li>A virtual environment in Python is a tool to keep the dependencies required by different projects in separate places by creating isolated python virtual environments for them. This is useful in case of different projects and when you want to avoid <span class="No-Break">conflicting dependencies.</span></li>
			</ol>
			<h1 id="_idParaDest-301"><a id="_idTextAnchor423"/>Chapter 2</h1>
			<ol>
				<li value="1"><strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) is a JSON object meant of representing claims to be transferred between two parties. JWT is often used to authenticate users in <span class="No-Break">REST APIs.</span></li>
				<li><strong class="bold">Django Rest Framework</strong> (<strong class="bold">DRF</strong>) is a third-party package for Django that makes it easy to build, test, debug, and maintain RESTful APIs written using the <span class="No-Break">Django framework.</span></li>
				<li>A Django model is a Python class that represents a database table, and it defines the fields and behaviors of the data <span class="No-Break">you’re storing.</span></li>
				<li>Serializers in DRF are used to convert complex data types, such as Django model instances or QuerySets, into JSON, XML, or other content types. Serializers also provide deserialization, which allows parsed data to be converted back into <span class="No-Break">complex types.</span></li>
				<li>Viewsets in DRF are classes that provide actions on model-backed resources. Viewsets are built on top of Django’s class-based views and provide actions like <strong class="source-inline">list</strong>, <strong class="source-inline">create</strong>, <strong class="source-inline">update</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">delete</strong></span><span class="No-Break">.</span></li>
				<li>DRF routers provide a simple, quick, and consistent way of wiring viewsets to URLs. It allows you to automatically generate the URL conf for your <span class="No-Break">API views.</span></li>
				<li>A refresh token is a token that is issued by an authentication server and is used to obtain a new access token. Refresh tokens are used to keep the user authenticated indefinitely, by periodically obtaining a new <span class="No-Break">access token.</span></li>
			</ol>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor424"/>Chapter 3</h1>
			<ol>
				<li value="1">Some common database relationships in relational <span class="No-Break">databases are:</span><ul><li><strong class="bold">One-to-one</strong>: This relationship is used when one record in a table is related to only one record in <span class="No-Break">another table.</span></li><li><strong class="bold">One-to-many</strong>: This relationship is used when one record in a table is related to multiple records in <span class="No-Break">another table.</span></li><li><strong class="bold">Many-to-many</strong>: This relationship is used when multiple records in one table are related to multiple records in <span class="No-Break">another table.</span></li></ul></li>
				<li>Django REST permissions are used to control access to specific actions on specific viewsets. They can be used to restrict who can view, add, change, or delete data in your <span class="No-Break">REST API.</span></li>
				<li>In DRF, you can use the <strong class="source-inline">LimitOffsetPagination</strong> class to paginate the results of an API response. To use this class, you can include it in <strong class="source-inline">REST_FRAMEWORK</strong> in the <strong class="source-inline">settings.py</strong> file of <span class="No-Break">your project.</span></li>
				<li>To use the Django shell, you need to open the command line in the root directory of your Django project, and then run the <span class="No-Break">following command:</span><p class="L---source" lang="fr-FR" xml:lang="fr-FR"><strong class="bold">python manage.py shell</strong></p></li>
			</ol>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor425"/>Chapter 4</h1>
			<ol>
				<li value="1">A nested route is a URL endpoint that represents a relationship between two or more resources. For example, in a social media application, you might have a route for all posts and another route for a specific post’s comments. The comments route would be nested within the post route, allowing you to access the comments for a <span class="No-Break">specific post.</span></li>
				<li><strong class="source-inline">drf-nested-routers</strong> is a package for DRF that allows you to easily create nested routes for your API. It automatically creates the appropriate URLs for related resources and allows you to nest your views within <span class="No-Break">other views.</span></li>
				<li>The <strong class="source-inline">partial</strong> attribute on the <strong class="source-inline">ModelSerializer</strong> can help you determine whether the user is submitting all the fields of the resource on an HTTP request for mutating like <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor426"/>Chapter 5</h1>
			<ol>
				<li value="1">Testing is a process of verifying that a system or software behaves in the way that it is expected to. Testing can be done manually <span class="No-Break">or automatically.</span></li>
				<li>A unit test is a test that verifies the functionality of a small and isolated piece of code, usually a single function or <span class="No-Break">a method.</span></li>
				<li>The testing pyramid is a concept that describes the balance between different types of tests in a software project. It suggests that most of the tests should be unit tests, which are fast and isolated, followed by a smaller number of integration tests, which test the interactions between different units of code, and a small number of end-to-end tests, which test the <span class="No-Break">entire system.</span></li>
				<li>Pytest is a popular testing framework for Python that makes it easy to write small, focused unit tests and provides many useful features such as test discovery, test parametrization, fixtures, and powerful and expressive <span class="No-Break">assertion syntax.</span></li>
				<li>A Pytest fixture is a way to provide data or set up resources that are needed for your tests. Fixtures are defined using the <strong class="source-inline">@pytest.fixture</strong> decorator and can be passed as arguments to test functions, allowing you to write more expressive and <span class="No-Break">maintainable tests.</span></li>
			</ol>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor427"/>Chapter 6</h1>
			<ol>
				<li value="1">Node.js is a JavaScript runtime built on Chrome’s V8 JavaScript engine. It allows developers to run JavaScript on the server side to build fast and scalable network applications. Yarn is a package manager for Node.js, like npm but it is faster and more secure and provides a more consistent experience across <span class="No-Break">different environments.</span></li>
				<li>Frontend development is the process of building the user interface of a software application. In web development, it involves using languages such as <strong class="bold">HTML</strong>, <strong class="bold">CSS</strong>, and <strong class="bold">JavaScript</strong> to create the visual elements, layout, and functionality of <span class="No-Break">a website.</span></li>
				<li>To install Node.js, you can download the installer package from the official Node.js website (<a href="https://nodejs.org/">https://nodejs.org/</a>) and then <span class="No-Break">run it.</span></li>
				<li><strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) is a free, open-source code editor developed and maintained by Microsoft. It is a popular choice among developers for its support for multiple languages, debugging, and integrated <span class="No-Break">Git control.</span></li>
				<li>In VS Code, you can install extensions by clicking on the <strong class="bold">Extensions</strong> icon in the <strong class="bold">Activity Bar</strong> on the side of the editor, or by typing <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">X</em> (<em class="italic">Cmd</em> + <em class="italic">Shift</em> + <em class="italic">X</em> on macOS) to open the <strong class="bold">Extensions</strong> pane. You can then search for and install any installation <span class="No-Break">you need.</span></li>
				<li>Hot reloading is a feature that allows you to see the changes you make to your code immediately in the browser, without having to manually refresh the page. This makes development faster and more efficient, as you can see the effects of your changes <span class="No-Break">in real-time.</span></li>
				<li>To create a React application with <strong class="source-inline">create-react-app</strong>, you first need to have Node.js and yarn installed on your OS. Then, you can use <strong class="source-inline">yarn</strong> to create a new React application by running the following command in <span class="No-Break">your terminal:</span><p class="L---source" lang="fr-FR" xml:lang="fr-FR"><strong class="bold">yarn create react-app my-app</strong></p></li>
			</ol>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor428"/>Chapter 7</h1>
			<ol>
				<li value="1"><strong class="source-inline">localStorage</strong> is an API provided by web browsers that allow developers to store <strong class="bold">key-value</strong> pairs of data locally on the client side. The data stored in <strong class="source-inline">localStorage</strong> persists even when the browser is closed, or the computer <span class="No-Break">is restarted.</span></li>
				<li><strong class="source-inline">React-Router</strong> is a popular library for client-side routing in React. It allows you to declaratively map your application’s component structure to specific URLs, making it easy to navigate between pages and manage the <span class="No-Break">browser history</span></li>
				<li>To configure a protected route in React, you can use React-Router’s <strong class="source-inline">&lt;Route&gt;</strong> component along with a <strong class="bold">higher-order component</strong> (<strong class="bold">HOC</strong>) or a custom Hook that checks if the user is authenticated before rendering the protected component. <span class="No-Break">For example:</span><pre class="source-code">
function ProtectedRoute({ children }) {</pre><pre class="source-code">
  const user = getUser();</pre><pre class="source-code">
  return user ? &lt;&gt;{children}&lt;/&gt; : &lt;Navigate to=»/login/» /&gt;;</pre><pre class="source-code">
}</pre></li>
				<li>A React Hook is a special function that allows you to use state and other React features in a functional component. Hooks were introduced in React 16.8 to make it easier to write and manage stateful logic in <span class="No-Break">functional components.</span></li>
				<li>Some examples of React <span class="No-Break">Hooks are:</span><ul><li><strong class="source-inline">useState</strong>: allows you to add a state to a <span class="No-Break">functional component.</span></li><li><strong class="source-inline">useEffect</strong>: allows you to run side effects such as fetching data or subscribing to an event in a <span class="No-Break">functional component.</span></li><li><strong class="source-inline">useContext</strong>: allows you to access the context values from a <span class="No-Break">functional component.</span></li></ul></li>
				<li>The two rules of React <span class="No-Break">Hooks are:</span><ul><li>Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or <span class="No-Break">nested functions.</span></li><li>Only call Hooks from React function components. Don’t call Hooks from regular <span class="No-Break">JavaScript functions.</span></li></ul></li>
			</ol>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor429"/>Chapter 8</h1>
			<ol>
				<li value="1">A modal is a dialog box/pop-up window that is displayed on top of the current page. Modals are used to display content that requires the user’s attention or input, such as forms, images, videos, <span class="No-Break">or alerts.</span></li>
				<li>In React, a <strong class="bold">prop</strong> (short for <strong class="bold">property</strong>) is a way to pass data from a parent component to a child component. Props are passed as attributes on a JSX element, and they can be accessed inside the child component using the <span class="No-Break"><strong class="source-inline">props</strong></span><span class="No-Break"> object.</span></li>
				<li>The <strong class="source-inline">children</strong> element in React is a special prop that is used to pass content between elements. It is used to nest UI elements inside of other elements, and it can be accessed using the <strong class="source-inline">props.children</strong> property inside of the <span class="No-Break">parent component.</span></li>
				<li>A wireframe is a simplified visual representation of a web page or application, used to communicate the layout, structure, and functionality of a <span class="No-Break">user interface.</span></li>
				<li>The <strong class="source-inline">map</strong> method is an array method in JavaScript that is used to iterate over an array and create a new array with the results of a function applied to each element of the original array. It can also be used in JSX to map over an array and create a new set <span class="No-Break">of elements.</span></li>
				<li>The <strong class="source-inline">mutate</strong> method on SWR objects allows you to programmatically update the data in the cache, without waiting for the revalidation to happen. The <strong class="source-inline">mutate</strong> method triggers a re-render on the components that are using the data in the cache, updating the UI to reflect the <span class="No-Break">new data.</span></li>
			</ol>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor430"/>Chapter 9</h1>
			<ol>
				<li value="1">The <strong class="source-inline">useParams</strong> Hook is a built-in Hook in React Router that allows you to access the dynamic parameters passed in the URL of a route. It returns an object containing the <strong class="bold">key-value</strong> pairs of the parameters in <span class="No-Break">the parameters.</span></li>
				<li>In React, you can write a route that can support parameter passing by using the <strong class="source-inline">:</strong> syntax in the path of the route. For example, you can have <strong class="source-inline">post/:postId</strong> where <strong class="source-inline">postId</strong> is an <span class="No-Break">URL parameter.</span></li>
				<li>The <strong class="source-inline">useContext</strong> Hook is a built-in hook in React that allows you to access a context value within a functional component. This can be useful for sharing data across multiple components without having to pass props down through multiple levels of the <span class="No-Break">component tree.</span></li>
			</ol>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor431"/>Chapter 10</h1>
			<ol>
				<li value="1">The <strong class="source-inline">FormData</strong> object is a built-in JavaScript object that allows you to construct and send <strong class="source-inline">multipart/form-data</strong> requests. It can be used to upload files or other forms of binary data, as well as to send <strong class="bold">key-value</strong> pairs of data. The <strong class="source-inline">FormData</strong> object can be passed as the body of an <strong class="source-inline">XMLHttpRequest</strong> or <strong class="source-inline">fetch</strong> request, and it will automatically set the appropriate <span class="No-Break"><strong class="source-inline">Content-Type</strong></span><span class="No-Break"> header.</span></li>
				<li>In Django, the <strong class="source-inline">MEDIA_URL</strong> setting is used to specify the URL at which user-uploaded media files will <span class="No-Break">be served.</span></li>
				<li>The <strong class="source-inline">MEDIA_ROOT</strong> setting in Django is used to specify the filesystem path where user-uploaded media files will <span class="No-Break">be stored.</span></li>
			</ol>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor432"/>Chapter 11</h1>
			<ol>
				<li value="1">The <strong class="source-inline">render</strong> method of the <strong class="bold">React Testing Library</strong> (<strong class="bold">RTL</strong>) is a utility function that allows you to render a component and its children as a tree of DOM nodes. The <strong class="source-inline">render</strong> method can be used to test the behavior and output of a component in a <span class="No-Break">real-world-like environment.</span></li>
				<li>Jest is a JavaScript testing framework that allows you to write and run unit tests for JavaScript code, including <span class="No-Break">React components.</span></li>
				<li>The <strong class="source-inline">data-testid</strong> attribute is a special attribute that allows you to add an identifier to an element for the purpose of testing. This attribute can be used to query the element in a test and make assertions about its state <span class="No-Break">or behavior.</span></li>
				<li>Some drawbacks of snapshot <span class="No-Break">testing are:</span><ul><li>Snapshots can become stale over time as the component changes, and they need to be <span class="No-Break">updated manually.</span></li><li>Snapshot tests can be difficult to understand, as they often show the entire component tree, which can be large <span class="No-Break">and complex.</span></li></ul></li>
				<li>To trigger user events in a React test suite, you can use React Testing Library <strong class="source-inline">fireEvent</strong> and <span class="No-Break"><strong class="source-inline">userEvent</strong></span><span class="No-Break"> methods.</span></li>
			</ol>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor433"/>Chapter 12</h1>
			<ol>
				<li value="1">In Git, a branch is a separate line of development that allows one or multiple developers to work on different features or bug fixes simultaneously without interfering with each other’s work. Branches are also used to isolate changes and make it easy to merge them back into the main codebase <span class="No-Break">or branch.</span></li>
				<li>Git is a <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) that allows developers to track changes in their code over time, collaborate with others, and revert to previous versions if needed. GitHub is a web-based hosting service for <span class="No-Break">Git repositories.</span></li>
				<li>An HTTP Host header attack is a type of web application attack that exploits a vulnerability in the way some web servers handle the HTTP Host header. The HTTP Host header is used to specify the domain name of the website that the user is trying to access. By manipulating the Host header, an attacker can trick a vulnerable web server into serving content from a different domain, potentially exposing sensitive information, or allowing the attacker to perform actions on the <span class="No-Break">user’s behalf.</span></li>
				<li>In Django, the <strong class="source-inline">SECRET_KEY</strong> setting is used to provide a secret key that is used to secure certain aspects of the Django framework, such as session management, password hashing, and the generation of cryptographic signatures. As it is a sensible piece of information, the value should be stored using <span class="No-Break">environment variables.</span></li>
			</ol>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor434"/>Chapter 13</h1>
			<ol>
				<li value="1">Docker is a platform for developing, shipping, and running applications that uses containerization technology to package an application and its dependencies into a single, portable container that can run on any platform that supports Docker. Containers provide a lightweight, isolated environment for running applications, which makes it easy to move them between development, staging, and <span class="No-Break">production environments.</span></li>
				<li>Docker Compose is a tool for defining and running multi-container Docker applications. It allows you to use a single <strong class="source-inline">docker-compose.yml</strong> file to configure and start multiple services (containers) that make up your application. This makes it easy to manage the dependencies and configuration of a <span class="No-Break">complex application.</span></li>
				<li>The main difference between Docker and Docker Compose is that Docker is a platform for creating, shipping, and running containers, while Docker Compose is a tool for defining and running multi-container applications. Additionally, Docker Compose relies on Docker to create and run <span class="No-Break">the containers.</span></li>
				<li>Virtualization is a technology that allows you to run multiple operating systems on a single physical machine, by creating virtual machines that emulate the hardware of a physical computer. Each virtual machine runs its operating system, and applications running inside the virtual machines are isolated from each other. Containerization is a technology that allows you to package an application and its dependencies into a single, portable container that can run on any platform. Containers are lightweight, isolated environments that share the host operating system kernel, which makes them faster and more efficient than <span class="No-Break">virtual machines.</span></li>
				<li>An environment variable is a value that can be passed to an operating system or application at runtime. It allows you to configure system-wide settings or to pass information to an application without hard-coding it in the source code. Environment variables can be used to set configuration options, such as the location of a file or the value of a secret key, and they can be easily changed without modifying the <span class="No-Break">application’s code.</span></li>
			</ol>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor435"/>Chapter 14</h1>
			<ol>
				<li value="1">The differences between <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">Continuous Deployment</strong> (<span class="No-Break"><strong class="bold">CD</strong></span><span class="No-Break">) are:</span><ul><li>CI is a software development practice in which developers integrate code into a shared repository multiple times a day. Each integration is verified by an automated build and test process to catch <span class="No-Break">errors early.</span></li><li>CD is an extension of CI that goes a step further and automatically deploys the code changes to production after they pass the automated build and test process. The goal of CD is to make sure that the code is always in a releasable state and to shorten the time between code being written and it being available <span class="No-Break">to end-users.</span></li></ul></li>
				<li>GitHub Actions is a feature provided by GitHub that allows developers to automate their software development workflows, such as building, testing, and deploying code. These workflows are defined in YAML files and can be triggered by various events such as a push to a branch, a pull request, or a scheduled time. Developers can use GitHub Actions to automate their <span class="No-Break">CI/CD workflows.</span></li>
				<li>CD is the practice of automatically building, testing, and deploying code changes to different environments after they pass the automated build and test process. It is an extension of CI, and the goal is to ensure that the code changes are always in a releasable state, so that they can be deployed to production at <span class="No-Break">any time.</span></li>
			</ol>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor436"/>Chapter 15</h1>
			<ol>
				<li value="1"><strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">S3</strong>) is an object storage service provided by <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) that allows you to store and retrieve large amounts <span class="No-Break">of data.</span></li>
				<li>To create an <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) user on AWS, you can use the AWS Management Console. Here’s an example of how to create an IAM user using the AWS <span class="No-Break">Management Console:</span><ol><li>Log in to the AWS <span class="No-Break">Management Console</span></li><li>Open the <span class="No-Break">IAM console.</span></li><li>In the <strong class="bold">Navigation</strong> pane, choose <strong class="bold">Users</strong> and then choose <span class="No-Break"><strong class="bold">Add user</strong></span><span class="No-Break">.</span></li><li>Type the username and select the <strong class="bold">AWS </strong><span class="No-Break"><strong class="bold">access type</strong></span><span class="No-Break">.</span></li><li><span class="No-Break">Choose </span><span class="No-Break"><strong class="bold">Permissions</strong></span><span class="No-Break">.</span></li><li>Choose <strong class="bold">Add user to a group</strong>, create group, or <strong class="bold">Add existing groups</strong> <span class="No-Break">as appropriate.</span></li><li><span class="No-Break">Choose </span><span class="No-Break"><strong class="bold">Tags</strong></span><span class="No-Break">.</span></li><li><span class="No-Break">Choose </span><span class="No-Break"><strong class="bold">Review</strong></span><span class="No-Break">.</span></li><li>Choose <span class="No-Break"><strong class="bold">Create user</strong></span><span class="No-Break">.</span></li></ol></li>
				<li>The command used to build a React application is <strong class="source-inline">react-scripts build</strong>. This command will take all the code and assets in your application and create a production-ready build that can be deployed on a <span class="No-Break">web server.</span></li>
				<li>In a Node.js or more specifically a React project, environment variables are typically retrieved using the <strong class="source-inline">process.env</strong> object. For example, you can access the value of an environment variable named <strong class="source-inline">VARIABLE</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">process.env.VARIABLE</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor437"/>Chapter 16</h1>
			<ol>
				<li value="1">Amazon CloudFront is a <strong class="bold">content delivery network</strong> (<strong class="bold">CDN</strong>) provided by AWS. It allows you to distribute content, such as web pages, images, videos, and more, to users across the world by caching the content on servers located in various geographic locations. CloudFront can be used to deliver content from a variety of origins, such as an S3 bucket or a <span class="No-Break">custom origin.</span></li>
				<li>There are several strategies for cache invalidation <span class="No-Break">in Django:</span><ul><li><strong class="bold">Per-site cache</strong>: This enables you to cache your <span class="No-Break">entire website.</span></li><li><strong class="bold">Template fragment cache</strong>: This enables you to cache some components of the website. For example, you can decide to only cache <span class="No-Break">the footer.</span></li><li><strong class="bold">Per-view cache</strong>: This enables you to cache the output of <span class="No-Break">individual views.</span></li><li><strong class="bold">Low-level cache</strong>: Django provides an API you can use for interacting directly with the cache. It is useful if you want to produce a certain behavior based on a set <span class="No-Break">of actions.</span></li></ul></li>
				<li>Logging is important because it allows you to track the activity of your system, troubleshoot issues, and gather data for analysis. Logs provide a detailed history of what has happened in your system, including events such as user actions, system failures, and performance metrics. This information can be used to identify trends, detect patterns, and <span class="No-Break">troubleshoot problems.</span></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer186" class="IMG---Figure">
			</div>
		</div>
	</body></html>