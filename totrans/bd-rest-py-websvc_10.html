<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0; Working with Asynchronous Code, Testing, and Deploying an API with Tornado"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10.  Working with Asynchronous Code, Testing, and Deploying an API with Tornado </h1></div></div></div><p>In this chapter, we will take advantage of the non-blocking features combined with asynchronous operations in Tornado in a new version for the API we built in the previous chapter. We will configure, write, and execute unit tests and learn a few things related to deployment. We will cover  the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding synchronous and asynchronous execution</li><li class="listitem" style="list-style-type: disc">Working with asynchronous code</li><li class="listitem" style="list-style-type: disc">Refactoring code to take advantage of asynchronous decorators</li><li class="listitem" style="list-style-type: disc">Mapping URL patterns to asynchronous and non-blocking request handlers</li><li class="listitem" style="list-style-type: disc">Making HTTP requests to the Tornado non-blocking API</li><li class="listitem" style="list-style-type: disc">Setting up unit tests</li><li class="listitem" style="list-style-type: disc">Writing a first round of unit tests</li><li class="listitem" style="list-style-type: disc">Running unit tests with <code class="literal">nose2</code> and checking testing coverage</li><li class="listitem" style="list-style-type: disc">Improving testing coverage</li></ul></div><div class="section" title="Understanding synchronous and asynchronous execution"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec112"/>Understanding synchronous and asynchronous execution</h1></div></div></div><p>In our current version of the API, each HTTP request is blocking, as happened with Django and Flask. Thus, whenever the Tornado HTTP server receives an HTTP request, it doesn't start working on any other HTTP request in the incoming queue until the server sends the response for the first HTTP request it received. The methods we coded in the request handlers are working with a synchronous execution and they don't take advantage of the non-blocking features included in Tornado when combined with asynchronous executions.</p><p>In order to set the brightness level for both the blue and white LEDs, we have to make two HTTP PATCH requests. We will make them to understand how our current version of the API processes two incoming requests.</p><p>Open two Cygwin terminals in Windows or two Terminals in macOS or Linux, and write the following command in the first one. We will compose and send an HTTP request to set the brightness level for the blue <code class="literal">LED</code> to <code class="literal">255</code>. Write the line in the first window, but don't press <span class="emphasis"><em>Enter</em></span> yet, as we will try to launch two commands at almost the same time in two windows:</p><pre class="programlisting">
<span class="strong"><strong>http PATCH :8888/leds/1 brightness_level=255</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX PATCH -H "Content-Type: application/json" -d
   '{"brightness_level":255}' :8888/leds/1</strong></span>
</pre><p>Now, go to the second window and write the following command. We will compose and send an HTTP request to set the brightness level for the white LED to 255. Write the line in the second window, but don't press <span class="emphasis"><em>Enter</em></span> yet, as we will try to launch two commands at almost the same time in two windows:</p><pre class="programlisting">
<span class="strong"><strong>http PATCH :8888/leds/2 brightness_level=255</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX PATCH -H "Content-Type: application/json" -d
   '{"brightness_level":255}' :8888/leds/2</strong></span>
</pre><p>Now, go to the first window, press <span class="emphasis"><em>
<span class="strong"><strong>Enter</strong></span>
</em></span>. Then, go to the second window and quickly press <span class="emphasis"><em>Enter</em></span>. You will see the following line in the window that is running the Tornado HTTP server:</p><pre class="programlisting">
<span class="strong"><strong>I've started setting the Blue LED's brightness level</strong></span>
</pre><p>Then, you will see the following lines that show the results of executing the print statements that describe when the code finished and then started setting the brightness level for the LEDs:</p><pre class="programlisting">
<span class="strong"><strong>I've finished setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've started setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the White LED's brightness level</strong></span>
</pre><p>It was necessary to wait for the request that changed the brightness level for the blue LED to finish before the server could process the HTTP that changes the brightness level for the white LED. The following screenshot shows three windows on Windows. The window on the left-hand side is running the Tornado HTTP server and displays the messages printed in the methods that process the HTTP requests. The window at the upper-right corner is running the <code class="literal">http</code> command to generate the HTTP request that changes the brightness level for the blue LED. The window at the lower-right corner is running the <code class="literal">http</code> command to generate the HTTP request that changes the brightness level for the white LED. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests and how the synchronous execution is working on the current version of the API:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_001.jpg" alt="Understanding synchronous and asynchronous execution"/></div><p>
</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip67"/>Tip</h3><p>Remember that the different methods we coded in the request handler classes end up calling <code class="literal">time.sleep</code> to simulate it takes some time for the operations to complete their execution.</p></div></div><p>As each operation takes some time and blocks the possibility to process other incoming HTTP requests, we will create a new version of this API that will use asynchronous execution, and we will understand the advantages of Tornado's non-blocking features. This way, it will be possible to change the brightness level for the white LED while the other request is to change the brightness level for the blue LED. Tornado will be able to start processing requests while the I/O operations with the drone take some time to complete.</p></div></div>
<div class="section" title="Refactoring code to take advantage of asynchronous decorators"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec113"/>Refactoring code to take advantage of asynchronous decorators</h1></div></div></div><p>It is extremely difficult to read and understand code split into different methods, such as the asynchronous code that requires working with callbacks that are executed once the asynchronous execution finishes. Luckily, Tornado provides a generator-based interface that enables us to write asynchronous code in request handlers in a single generator. We can avoid splitting our methods into multiple methods with callbacks by using the <code class="literal">tornado.gen</code> generator-based interface that Tornado provides to make it easier to work in an asynchronous environment.</p><p>The recommended way to write asynchronous code in Tornado is to use coroutines. Thus, we will refactor our existing code to use the <code class="literal">@tornado.gen.coroutine</code> decorator for asynchronous generators in the required methods that process the different HTTP requests in the subclasses of <code class="literal">tornado.web.RequestHandler</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip68"/>Tip</h3><p>Instead of working with a chain of callbacks, coroutines use the Python <code class="literal">yield</code> keyword to suspend and resume execution. By using coroutines, our code is going to be as simple to understand and maintain as if we were writing synchronous code.</p></div></div><p>We will use an instance of the <code class="literal">concurrent.futures.ThreadPoolExecutor</code> class that provides us with a high-level interface for asynchronously executing callables. The asynchronous execution will be performed with threads. We will also use the <code class="literal">@tornado.concurrent.run_on_executor</code> decorator to run a synchronous method asynchronously on an executor. In this case, the methods provided by the different components of our drone to get and set data have a synchronous execution. We want them to run with an asynchronous execution.</p><p>Create a new <code class="literal">async_api.py</code> file. The following lines show all the necessary imports for the classes that we will create and the code that creates an instance of the <code class="literal">concurrent.futures.ThreadPoolExecutor</code> class named <code class="literal">thread_pool</code>. We will use this instance in the different methods that we will refactor to make asynchronous calls. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_01</code> folder:</p><pre class="programlisting">import status 
from datetime import date 
from tornado import web, escape, ioloop, httpclient, gen 
from concurrent.futures import ThreadPoolExecutor 
from tornado.concurrent import run_on_executor 
from drone import Altimeter, Drone, Hexacopter, LightEmittingDiode 
 
 
thread_pool = ThreadPoolExecutor() 
drone = Drone() 
</pre><p>Now, we will create an <code class="literal">AsyncHexacopterHandler</code> class that we will use to handle requests for the hexacopter resource with an asynchronous execution. The lines that are new or changed compared with the synchronous version of this handler named <code class="literal">HexacopterHandler</code> are highlighted. Open the previously created <code class="literal">async_pi.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_01</code> folder:</p><pre class="programlisting">class AsyncHexacopterHandler(web.RequestHandler): 
    SUPPORTED_METHODS = ("GET", "PATCH") 
    HEXACOPTER_ID = 1 
   <span class="strong"><strong> _thread_pool = thread_pool</strong></span>
<span class="strong"><strong>   @gen.coroutine</strong></span> 
    def get(self, id): 
        if int(id) is not self.__class__.HEXACOPTER_ID: 
            self.set_status(status.HTTP_404_NOT_FOUND) 
          <span class="strong"><strong>  self.finish()</strong></span> 
            return 
        print("I've started retrieving hexacopter's status") 
       <span class="strong"><strong> hexacopter_status = yield self.retrieve_hexacopter_status()</strong></span> 
        print("I've finished retrieving hexacopter's status") 
        response = {  
            'speed': hexacopter_status.motor_speed, 
            'turned_on': hexacopter_status.turned_on, 
            } 
        self.set_status(status.HTTP_200_OK) 
        self.write(response) 
     <span class="strong"><strong>   self.finish()</strong></span>
<span class="strong"><strong> @run_on_executor(executor="_thread_pool") 
    def retrieve_hexacopter_status(self): 
        return drone.hexacopter.get_hexacopter_status()</strong></span>
<span class="strong"><strong> @gen.coroutine</strong></span> 
    def patch(self, id): 
        if int(id) is not self.__class__.HEXACOPTER_ID: 
            self.set_status(status.HTTP_404_NOT_FOUND) 
          <span class="strong"><strong>  self.finish()</strong></span> 
            return 
        request_data = escape.json_decode(self.request.body)  
        if ('motor_speed' not in request_data.keys()) or \ 
            (request_data['motor_speed'] is None): 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
           <span class="strong"><strong> self.finish()</strong></span> 
            return 
        try: 
            motor_speed = int(request_data['motor_speed']) 
            print("I've started setting the hexacopter's motor speed") 
           <span class="strong"><strong> hexacopter_status = yield
            self.set_hexacopter_motor_speed(motor_speed)</strong></span> 
            print("I've finished setting the hexacopter's motor speed") 
            response = {  
                'speed': hexacopter_status.motor_speed, 
                'turned_on': hexacopter_status.turned_on, 
                } 
            self.set_status(status.HTTP_200_OK) 
            self.write(response) 
         <span class="strong"><strong>   self.finish()</strong></span> 
        except ValueError as e: 
            print("I've failed setting the hexacopter's motor speed") 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
            response = { 
                'error': e.args[0] 
                } 
            self.write(response) 
           <span class="strong"><strong> self.finish()</strong></span>
<span class="strong"><strong> @run_on_executor(executor="_thread_pool") 
    def set_hexacopter_motor_speed(self, motor_speed): 
        return drone.hexacopter.set_motor_speed(motor_speed)</strong></span>
</pre><p>The <code class="literal">AsyncHexacopterHandler</code> class declares a <code class="literal">_thread_pool</code> class attribute that saves a reference to the previously created <code class="literal">concurrent.futures.ThreadPoolExecutor</code> instance. The class declares two methods with the <code class="literal">@run_on_executor(executor="_thread_pool")</code> decorator that makes the synchronous method run asynchronously with the <code class="literal">concurrent.futures.ThreadPoolExecutor</code> instance whose reference is saved in the <code class="literal">_thread_pool</code> class attribute. The following are the two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">retrieve_hexacopter_status</code>: This method returns the results of calling the <code class="literal">drone.hexacopter.get_hexacopter_status</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">set_hexacopter_motor_speed</code>: This method receives the <code class="literal">motor_speed</code> argument and returns the results of calling the <code class="literal">drone.hexacopter.set_motor_speed</code> method with the received <code class="literal">motor_speed</code> as an argument.</li></ul></div><p>We added the <code class="literal">@gen.coroutine</code> decorator to both the <code class="literal">get</code> and <code class="literal">patch</code> methods. We added a call to <code class="literal">self.finish</code> whenever we wanted to finish the HTTP request. It is our responsibility to call this method to finish the response and end the HTTP request when we use the <code class="literal">@gen.coroutine</code> decorator.</p><p>The <code class="literal">get</code> method uses the following line to retrieve the hexacopter status with a non-blocking and asynchronous execution:</p><pre class="programlisting">hexacopter_status = yield self.retrieve_hexacopter_status() 
</pre><p>The code uses the <code class="literal">yield</code> keyword to retrieve <code class="literal">HexacopterStatus</code> from the <code class="literal">Future</code> returned by <code class="literal">self.retrieve_hexacopter_status</code> that runs with an asynchronous execution. A <code class="literal">Future</code> encapsulates the asynchronous execution of a callable. In this case, <code class="literal">Future</code> encapsulates the asynchronous execution of the <code class="literal">self.retrieve_hexacopter_status</code> method. The next lines didn't require changes, and we only had to add a call to <code class="literal">self.finish</code> as the last line after we write the response.</p><p>The <code class="literal">get</code> method uses the following line to retrieve the hexacopter status with a non-blocking and asynchronous execution:</p><pre class="programlisting">hexacopter_status = yield self.retrieve_hexacopter_status() 
</pre><p>The code uses the <code class="literal">yield</code> keyword to retrieve the <code class="literal">HexacopterStatus</code> from the <code class="literal">Future</code> returned by the <code class="literal">self.retrieve_hexacopter_status</code> that runs with an asynchronous execution.</p><p>The <code class="literal">patch</code> method uses the following line to set the hexacopter's motor speed with a non-blocking and asynchronous execution:</p><pre class="programlisting">hexacopter_status = yield self.set_hexacopter_motor_speed(motor_speed) 
</pre><p>The code uses the <code class="literal">yield</code> keyword to retrieve the <code class="literal">HexacopterStatus</code> from the <code class="literal">Future</code> returned by the <code class="literal">self.set_hexacopter_motor_speed</code> that runs with an asynchronous execution. The next lines didn't require changes, and we only had to add a call to <code class="literal">self.finish</code> as the last line after we write the response.</p><p>Now, we will create an <code class="literal">AsyncLedHandler</code> class that we will use to represent the LED resources and process requests with an asynchronous execution. The lines that are new or changed compared with the synchronous version of this handler named <code class="literal">LedHandler</code> are highlighted. Open the previously created <code class="literal">async_pi.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_01</code> folder:</p><pre class="programlisting">class AsyncLedHandler(web.RequestHandler): 
    SUPPORTED_METHODS = ("GET", "PATCH") 
 <span class="strong"><strong>   _thread_pool = thread_pool</strong></span>
<span class="strong"><strong>   @gen.coroutine</strong></span> 
    def get(self, id): 
        int_id = int(id) 
        if int_id not in drone.leds.keys(): 
            self.set_status(status.HTTP_404_NOT_FOUND) 
           <span class="strong"><strong> self.finish()</strong></span> 
            return 
        led = drone.leds[int_id] 
        print("I've started retrieving {0}'s status".format(led.description)) 
       <span class="strong"><strong> brightness_level = yield</strong></span>
<span class="strong"><strong>        self.retrieve_led_brightness_level(led)</strong></span> 
        print("I've finished retrieving {0}'s status".format(led.description)) 
        response = { 
            'id': led.identifier, 
            'description': led.description, 
            'brightness_level': brightness_level 
            } 
        self.set_status(status.HTTP_200_OK) 
        self.write(response) 
        self.finish() 
 
    <span class="strong"><strong>@run_on_executor(executor="_thread_pool") 
    def retrieve_led_brightness_level(self, led): 
        return led.get_brightness_level()</strong></span>
<span class="strong"><strong>  @gen.coroutine</strong></span> 
    def patch(self, id): 
        int_id = int(id) 
        if int_id not in drone.leds.keys(): 
            self.set_status(status.HTTP_404_NOT_FOUND) 
            self.finish() 
            return 
        led = drone.leds[int_id] 
        request_data = escape.json_decode(self.request.body)  
        if ('brightness_level' not in request_data.keys()) or \ 
            (request_data['brightness_level'] is None): 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
           <span class="strong"><strong> self.finish()</strong></span> 
            return 
        try: 
            brightness_level = int(request_data['brightness_level']) 
            print("I've started setting the {0}'s brightness
            level".format(led.description)) 
            <span class="strong"><strong>yield self.set_led_brightness_level(led, brightness_level)</strong></span> 
            print("I've finished setting the {0}'s brightness
            level".format(led.description)) 
            response = { 
                'id': led.identifier, 
                'description': led.description, 
                'brightness_level': brightness_level 
                } 
            self.set_status(status.HTTP_200_OK) 
            self.write(response) 
          <span class="strong"><strong>  self.finish()</strong></span> 
        except ValueError as e: 
            print("I've failed setting the {0}'s brightness level".format(led.description)) 
            self.set_status(status.HTTP_400_BAD_REQUEST) 
            response = { 
                'error': e.args[0] 
                } 
            self.write(response) 
         <span class="strong"><strong>   self.finish()</strong></span>
<span class="strong"><strong>  @run_on_executor(executor="_thread_pool") 
    def set_led_brightness_level(self, led, brightness_level): 
        return led.set_brightness_level(brightness_level)</strong></span>
</pre><p>The <code class="literal">AsyncLedHandler</code> class declares a <code class="literal">_thread_pool</code> class attribute that saves a reference to the previously created <code class="literal">concurrent.futures.ThreadPoolExecutor</code> instance. The class declares two methods with the <code class="literal">@run_on_executor(executor="_thread_pool")</code> decorator that makes the synchronous method run asynchronously with the <code class="literal">concurrent.futures.ThreadPoolExecutor</code> instance whose reference is saved in the <code class="literal">_thread_pool</code> class attribute. The following are the two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">retrieve_led_brightness_level</code>: This method receives a <code class="literal">LightEmittingDiode</code> instance in the <code class="literal">led</code> argument and returns the results of calling the <code class="literal">led.get_brightness_level</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">set_led_brightness_level</code>: This method receives a <code class="literal">LightEmittingDiode</code> instance in the <code class="literal">led</code> argument and the <code class="literal">brightness_level</code> argument. The code returns the results of calling the <code class="literal">led.set_brightness_level</code> method with the received <code class="literal">brightness_level</code> as an argument.</li></ul></div><p>We added the <code class="literal">@gen.coroutine</code> decorator to both the <code class="literal">get</code> and <code class="literal">patch</code> methods. In addition, we added a call to <code class="literal">self.finish</code> whenever we wanted to finish the HTTP request.</p><p>The <code class="literal">get</code> method uses the following line to retrieve the LED's brightness level with a non-blocking and asynchronous execution:</p><pre class="programlisting">brightness_level = yield self.retrieve_led_brightness_level(led) 
</pre><p>The code uses the <code class="literal">yield</code> keyword to retrieve the <code class="literal">int</code> from <code class="literal">Future</code> returned by <code class="literal">self.retrieve_led_brightness_level</code> that runs with an asynchronous execution. The next lines didn't require changes, and we only had to add a call to <code class="literal">self.finish</code> as the last line after we write the response.</p><p>The <code class="literal">patch</code> method uses the following line to retrieve the hexacopter status with a non-blocking and asynchronous execution:</p><pre class="programlisting">hexacopter_status = yield self.retrieve_hexacopter_status() 
</pre><p>The code uses the <code class="literal">yield</code> keyword to retrieve <code class="literal">HexacopterStatus</code> from <code class="literal">Future</code> returned by <code class="literal">self.retrieve_hexacopter_status</code> that runs with an asynchronous execution.</p><p>The <code class="literal">patch</code> method uses the following line to set the LED's brightness level with a non-blocking and asynchronous execution:</p><pre class="programlisting">yield self.set_led_brightness_level(led, brightness_level) 
</pre><p>The code uses the <code class="literal">yield</code> keyword to call <code class="literal">self.set_led_brightness_level</code> with an asynchronous execution. The next lines didn't require changes, and we only had to add a call to <code class="literal">self.finish</code> as the last line after we write the response.</p><p>Now, we will create an <code class="literal">AsyncAltimeterHandler</code> class that we will use to represent the altimeter resource and process the <code class="literal">get</code> request with an asynchronous execution. The lines that are new or changed compared with the synchronous version of this handler named <code class="literal">AltimeterHandler</code>, are highlighted. Open the previously created <code class="literal">async_pi.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_01</code> folder.</p><pre class="programlisting">class AsyncAltimeterHandler(web.RequestHandler): 
    SUPPORTED_METHODS = ("GET") 
    ALTIMETER_ID = 1 
  <span class="strong"><strong>  _thread_pool = thread_pool</strong></span> 
 
    @gen.coroutine 
    def get(self, id): 
        if int(id) is not self.__class__.ALTIMETER_ID: 
            self.set_status(status.HTTP_404_NOT_FOUND) 
           <span class="strong"><strong> self.finish()</strong></span> 
            return 
        print("I've started retrieving the altitude") 
      <span class="strong"><strong>  altitude = yield self.retrieve_altitude()</strong></span> 
        print("I've finished retrieving the altitude") 
        response = {  
            'altitude': altitude 
            } 
        self.set_status(status.HTTP_200_OK) 
        self.write(response) 
       <span class="strong"><strong> self.finish()</strong></span>
<span class="strong"><strong>@run_on_executor(executor="_thread_pool") 
    def retrieve_altitude(self): 
        return drone.altimeter.get_altitude()</strong></span>
</pre><p>The <code class="literal">AsyncAltimeterHandler</code> class declares a <code class="literal">_thread_pool</code> class attribute that saves a reference to the previously created <code class="literal">concurrent.futures.ThreadPoolExecutor</code> instance. The class declares the <code class="literal">retrieve_altitude</code> method with the <code class="literal">@run_on_executor(executor="_thread_pool")</code> decorator that makes the synchronous method run asynchronously with the <code class="literal">concurrent.futures.ThreadPoolExecutor</code> instance whose reference is saved in the <code class="literal">_thread_pool</code> class attribute. The <code class="literal">retrieve_altitude</code> method returns the results of calling the <code class="literal">drone.altimeter.get_altitude</code> method.</p><p>We added the <code class="literal">@gen.coroutine</code> decorator to the <code class="literal">get</code> method. In addition, we added a call to <code class="literal">self.finish</code> whenever we wanted to finish the HTTP request.</p><p>The <code class="literal">get</code> method uses the following line to retrieve the altimeter's altitude value with a non-blocking and asynchronous execution:</p><pre class="programlisting">altitude = yield self.retrieve_altitude() 
</pre><p>The code uses the <code class="literal">yield</code> keyword to retrieve the <code class="literal">int</code> from <code class="literal">Future</code> returned by <code class="literal">self.retrieve_altitude</code> that runs with an asynchronous execution. The next lines didn't require changes, and we only had to add a call to <code class="literal">self.finish</code> as the last line after we write the response.</p></div>
<div class="section" title="Mapping URL patterns to asynchronous request handlers"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec114"/>Mapping URL patterns to asynchronous request handlers</h1></div></div></div><p>We must map URL patterns to our previously coded subclasses of <code class="literal">tornado.web.RequestHandler</code> that provide us asynchronous methods for our request handlers. The following lines create the main entry point for the application, initialize it with the URL patterns for the API, and start listening for requests. Open the previously created <code class="literal">async_api.py</code> file and add the following lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_01</code> folder:</p><pre class="programlisting">application = web.Application([ 
    (r"/hexacopters/([0-9]+)", AsyncHexacopterHandler), 
    (r"/leds/([0-9]+)", AsyncLedHandler), 
    (r"/altimeters/([0-9]+)", AsyncAltimeterHandler), 
],debug=True) 
 
 
if __name__ == "__main__": 
    port = 8888 
    print("Listening at port {0}".format(port)) 
    application.listen(port) 
    ioloop.IOLoop.instance().start() 
</pre><p>The code creates an instance of <code class="literal">tornado.web.Application</code> named <code class="literal">application</code> with the collection of request handlers that make up the Web application. We just changed the name of the handlers with the new names that have the <code class="literal">Async</code> prefix.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip69"/>Tip</h3><p>As with any other Web framework, you should never enable debugging in a production environment.</p></div></div></div>
<div class="section" title="Making HTTP requests to the Tornado non-blocking API"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec115"/>Making HTTP requests to the Tornado non-blocking API</h1></div></div></div><p>Now, we can run the <code class="literal">async_api.py</code> script that launches Tornados's development server to compose and send HTTP requests to our new version of the Web API that uses the non-blocking features of Tornado combined with asynchronous execution. Execute the following command:</p><pre class="programlisting">
<span class="strong"><strong>python async_api.py</strong></span>
</pre><p>The following lines show the output after we execute the previous command. The Tornado HTTP development server is listening at port <code class="literal">8888</code>:</p><pre class="programlisting">
<span class="strong"><strong>Listening at port 8888</strong></span>
</pre><p>With the previous command, we will start the Tornado HTTP server and it will listen on every interface on port <code class="literal">8888</code>. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we don't need any additional configurations.</p><p>In our new version of the API, each HTTP request is non-blocking. Thus, whenever the Tornado HTTP server receives an HTTP request and makes an asynchronous call, it is able to start working on any other HTTP request in the incoming queue before the server sends the response for the first HTTP request it received. The methods we coded in the request handlers are working with an asynchronous execution and they take advantage of the non-blocking features included in Tornado, combined with asynchronous executions.</p><p>In order to set the brightness level for both the blue and white LEDs, we have to make two HTTP <code class="literal">PATCH</code> requests. We will make them to understand how our new version of the API processes two incoming requests.</p><p>Open two Cygwin terminals in Windows, or two Terminals in macOS or Linux, and write the following command in the first one. We will compose and send an HTTP request to set the brightness level for the blue LED to <code class="literal">255</code>. Write the line in the first window but don't press <span class="emphasis"><em>Enter</em></span> yet, as we will try to launch two commands at almost the same time in two windows:</p><pre class="programlisting">
<span class="strong"><strong>http PATCH :8888/leds/1 brightness_level=255</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX PATCH -H "Content-Type: application/json" -d 
    '{"brightness_level":255}' :8888/leds/1</strong></span>
</pre><p>Now, go to the second window and write the following command. We will compose and send an HTTP request to set the brightness level for the white LED to <code class="literal">255</code>. Write the line in the second window but don't press <span class="emphasis"><em>Enter</em></span> yet, as we will try to launch two commands at almost the same time in two windows:</p><pre class="programlisting">
<span class="strong"><strong>http PATCH :8888/leds/2 brightness_level=255</strong></span>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<span class="strong"><strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"brightness_level":255}' :8888/leds/2</strong></span>
</pre><p>Now, go to the first window, press <span class="emphasis"><em>
<span class="strong"><strong>Enter</strong></span>
</em></span>. Then, go to the second window and quickly press <span class="emphasis"><em>Enter</em></span>. You will see the following lines in the window that is running the Tornado HTTP server:</p><pre class="programlisting">
<span class="strong"><strong>I've started setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've started setting the White LED's brightness level</strong></span>
</pre><p>Then, you will see the following lines that show the results of executing the print statements that describe when the code finished setting the brightness level for the LEDs:</p><pre class="programlisting">
<span class="strong"><strong>I've finished setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the White LED's brightness level</strong></span>
</pre><p>The server could start processing the request that changes the brightness level for the white LED before the request that changes the brightness level of the blue LED finishes its execution. The following screenshot shows three windows on Windows. The window on the left-hand side is running the Tornado HTTP server and displays the messages printed in the methods that process the HTTP requests. The window on the upper-right corner is running the <code class="literal">http</code> command to generate the HTTP request that changes the brightness level for the blue LED. The window at the lower-right corner is running the <code class="literal">http</code> command to generate the HTTP request that changes the brightness level for the white LED. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests and check how the asynchronous execution is working on the new version of the API:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_002.jpg" alt="Making HTTP requests to the Tornado non-blocking API"/></div><p>
</p><p>Each operation takes some time but doesn't block the possibility to process other incoming HTTP requests thanks to the changes we made to the API to take advantage of the asynchronous execution. This way, it is possible to change the brightness level for the white LED while the other request is to change the brightness level for the blue LED. Tornado is able to start processing requests while the I/O operations with the drone take some time to complete.</p></div>
<div class="section" title="Setting up unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec116"/>Setting up unit tests</h1></div></div></div><p>We will use <code class="literal">nose2</code> to make it easier to discover and run unit tests. We will measure test coverage, and therefore, we will install the necessary package to allow us to run coverage with <code class="literal">nose2</code>. First, we will install the <code class="literal">nose2</code> and <code class="literal">cov-core</code> packages in our virtual environment. The <code class="literal">cov-core</code> package will allow us to measure test coverage with <code class="literal">nose2</code>.</p><p>Make sure you quit the Tornado's HTTP server. Remember that you just need to press <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>C</strong></span>
</em></span> in the Terminal or command-prompt window in which it is running. We just need to run the following command to install the <code class="literal">nose2</code> package that will also install the <code class="literal">six</code> dependency:</p><pre class="programlisting">
<span class="strong"><strong>pip install nose2</strong></span>
</pre><p>The last lines for the output will indicate that the <code class="literal">nose2</code> package has been successfully installed:</p><pre class="programlisting">    
    Collecting nose2
    Collecting six&gt;=1.1 (from nose2)
      Downloading six-1.10.0-py2.py3-none-any.whl
    Installing collected packages: six, nose2
    Successfully installed nose2-0.6.5 six-1.10.0
</pre><p>We just need to run the following command to install the <code class="literal">cov-core</code> package that will also install the <code class="literal">coverage</code> dependency:</p><pre class="programlisting">
<span class="strong"><strong>pip install cov-core</strong></span>
</pre><p>The last lines for the output will indicate that the <code class="literal">django-nose</code> package has been successfully installed:</p><pre class="programlisting">
<span class="strong"><strong>Collecting cov-core</strong></span>
<span class="strong"><strong>Collecting coverage&gt;=3.6 (from cov-core)</strong></span>
<span class="strong"><strong>Installing collected packages: coverage, cov-core</strong></span>
<span class="strong"><strong>Successfully installed cov-core-1.15.0 coverage-4.2</strong></span>
</pre><p>Open the previously created <code class="literal">async_api.py</code> file and remove the lines that create the <code class="literal">web.Application</code> instance named application and the <code class="literal">__main__</code> method. After you remove these lines, add the next lines. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_02</code> folder:</p><pre class="programlisting">class Application(web.Application): 
    def __init__(self, **kwargs): 
        handlers = [ 
            (r"/hexacopters/([0-9]+)", AsyncHexacopterHandler), 
            (r"/leds/([0-9]+)", AsyncLedHandler), 
            (r"/altimeters/([0-9]+)", AsyncAltimeterHandler), 
        ] 
        super(Application, self).__init__(handlers, **kwargs) 
 
 
if __name__ == "__main__": 
    application = Application() 
    application.listen(8888) 
    tornado_ioloop = ioloop.IOLoop.instance() 
    ioloop.PeriodicCallback(lambda: None, 500, tornado_ioloop).start() 
    tornado_ioloop.start() 
</pre><p>The code declares an <code class="literal">Application</code> class, specifically, a subclass of <code class="literal">tornado.web.Application</code> that overrides the inherited constructor, that is, the <code class="literal">__init__</code> method. The constructor declares the <code class="literal">handlers</code> list that maps URL patterns to asynchronous request handlers and then calls the inherited constructor with the list as one of its arguments. We create the class to make it possible for the tests to use this class.</p><p>Then, the main method creates an instance of the Application class, registers a periodic callback that will be executed every <code class="literal">500</code> milliseconds by the <code class="literal">IOLoop</code> to make it possible to use <span class="emphasis"><em>
<span class="strong"><strong>Ctrl</strong></span>
</em></span> + <span class="emphasis"><em>
<span class="strong"><strong>C</strong></span>
</em></span> to stop the HTTP server, and finally calls the <code class="literal">start</code> method. The <code class="literal">async_api.py</code> script is going to continue working in the same way. The main difference is that we can reuse the <code class="literal">Application</code> class in our tests.</p><p>Finally, create a new text file named <code class="literal">.coveragerc</code> within the virtual environment's root folder with the following content. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_02</code> folder:</p><pre class="programlisting">[run] 
include = async_api.py, drone.py 
</pre><p>This way, the <code class="literal">coverage</code> utility will only consider the code in the <code class="literal">async_api.py</code> and <code class="literal">drone.py</code> files when providing us with the test coverage report. We will have a more accurate test coverage report with this settings file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip70"/>Tip</h3><p>In this case, we won't be using configuration files for each environment. However, in more complex applications, you will definitely want to use configuration files.</p></div></div></div>
<div class="section" title="Writing a first round of unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec117"/>Writing a first round of unit tests</h1></div></div></div><p>Now, we will write a first round of unit tests. Specifically, we will write unit tests related to the LED resources. Create a new <code class="literal">tests</code> subfolder within the virtual environment's root folder. Then, create a new <code class="literal">test_hexacopter.py</code> file within the new <code class="literal">tests</code> subfolder. Add the following lines that declare many <code class="literal">import</code> statements and the <code class="literal">TextHexacopter</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_02</code> folder:</p><pre class="programlisting">import unittest 
import status 
import json 
from tornado import ioloop, escape 
from tornado.testing import AsyncHTTPTestCase, gen_test, gen 
from async_api import Application 
 
 
class TestHexacopter(AsyncHTTPTestCase): 
    def get_app(self): 
        self.app = Application(debug=False) 
        return self.app 
 
    def test_set_and_get_led_brightness_level(self): 
        """ 
        Ensure we can set and get the brightness levels for both LEDs 
        """ 
        patch_args_led_1 = {'brightness_level': 128} 
        patch_args_led_2 = {'brightness_level': 250} 
        patch_response_led_1 = self.fetch( 
            '/leds/1',  
            method='PATCH',  
            body=json.dumps(patch_args_led_1)) 
        patch_response_led_2 = self.fetch( 
            '/leds/2',  
            method='PATCH',  
            body=json.dumps(patch_args_led_2)) 
        self.assertEqual(patch_response_led_1.code, status.HTTP_200_OK) 
        self.assertEqual(patch_response_led_2.code, status.HTTP_200_OK) 
        get_response_led_1 = self.fetch( 
            '/leds/1', 
            method='GET') 
        get_response_led_2 = self.fetch( 
            '/leds/2', 
            method='GET') 
        self.assertEqual(get_response_led_1.code, status.HTTP_200_OK) 
        self.assertEqual(get_response_led_2.code, status.HTTP_200_OK) 
        get_response_led_1_data = escape.json_decode(get_response_led_1.body) 
        get_response_led_2_data = escape.json_decode(get_response_led_2.body) 
        self.assertTrue('brightness_level' in get_response_led_1_data.keys()) 
        self.assertTrue('brightness_level' in get_response_led_2_data.keys()) 
        self.assertEqual(get_response_led_1_data['brightness_level'],  
                         patch_args_led_1['brightness_level']) 
        self.assertEqual(get_response_led_2_data['brightness_level'],  
                         patch_args_led_2['brightness_level']) 
</pre><p>The <code class="literal">TestHexacopter</code> class is a subclass of <code class="literal">tornado.testing.AsyncHTTPTestCase</code>, that is, a test case that starts up a Tornado HTTP Server. The class overrides the <code class="literal">get_app</code> method that returns the <code class="literal">tornado.web.Application</code> instance that we want to test. In this case, we return an instance of the <code class="literal">Application</code> class declared in the <code class="literal">async_api</code> module, with the <code class="literal">debug</code> argument set to <code class="literal">False</code>.</p><p>The <code class="literal">test_set_and_get_led_brightness_level</code> method tests whether we can set and get the brightness levels for both the white and blue LED. The code composes and sends two HTTP <code class="literal">PATCH</code> methods to set new brightness level values for the LEDs whose IDs are equal to <code class="literal">1</code> and <code class="literal">2</code>. The code sets a different brightness level for each LED.</p><p>The code calls the self.fetch method to compose and send the HTTP <code class="literal">PATCH</code> request and calls <code class="literal">json.dumps</code> with the dictionary to be sent to the body as an argument. Then, the code uses <code class="literal">self.fetch</code> again to compose and send two HTTP <code class="literal">GET</code> methods to retrieve the brightness level values for the LEDs whose brightness values have been modified. The code uses <code class="literal">tornado.escape.json_decode</code> to convert the bytes in the response body to a Python dictionary. The method uses <code class="literal">assertEqual</code> and <code class="literal">assertTrue</code> to check for the following expected results:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">status_code</code> for the two HTTP <code class="literal">PATCH</code> responses is HTTP 200 OK (<code class="literal">status.HTTP_200_OK</code>)</li><li class="listitem" style="list-style-type: disc">The <code class="literal">status_code</code> for the two HTTP <code class="literal">GET</code> responses is HTTP 200 OK (<code class="literal">status.HTTP_200_OK</code>)</li><li class="listitem" style="list-style-type: disc">The response body for the two HTTP <code class="literal">GET</code> responses include a key named <code class="literal">brigthness_level</code></li><li class="listitem" style="list-style-type: disc">The value for the <code class="literal">brightness_level</code> key in the HTTP <code class="literal">GET</code> responses are equal to the brightness level set to each LED</li></ul></div></div>
<div class="section" title="Running unit tests with nose2 and checking testing coverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec118"/>Running unit tests with nose2 and checking testing coverage</h1></div></div></div><p>Now, run the following command to create all the necessary tables in our test database and use the nose2 test running to execute all the tests we created. The test runner will execute all the methods for our <code class="literal">TestHexacopter</code> class that start with the <code class="literal">test_</code> prefix and will display the results. In this case, we just have one method that matches the criteria, but we will add more later.</p><p>Run the following command within the same virtual environment we have been using. We will use the <code class="literal">-v</code> option to instruct nose2 to print test case names and statuses. The <code class="literal">--with-coverage</code> option turns on test coverage reporting generation:</p><pre class="programlisting">
<span class="strong"><strong>nose2 -v --with-coverage</strong></span>
</pre><p>The following lines show the sample output. Notice that the numbers shown in the report might have small differences if our code includes additional lines or comments:</p><pre class="programlisting">
<span class="strong"><strong>test_set_and_get_led_brightness_level (test_hexacopter.TestHexacopter) ... </strong></span>
<span class="strong"><strong>I've started setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've started setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've started retrieving Blue LED's status</strong></span>
<span class="strong"><strong>I've finished retrieving Blue LED's status</strong></span>
<span class="strong"><strong>I've started retrieving White LED's status</strong></span>
<span class="strong"><strong>I've finished retrieving White LED's status</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>----------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 1 test in 1.311s</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>----------- coverage: platform win32, python 3.5.2-final-0 -----</strong></span>
<span class="strong"><strong>Name           Stmts   Miss  Cover</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>async_api.py     129     69    47%</strong></span>
<span class="strong"><strong>drone.py          57     18    68%</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>TOTAL            186     87    53%</strong></span>
</pre><p>By default, <code class="literal">nose2</code> looks for modules whose names start with the <code class="literal">test</code> prefix. In this case, the only module that matches the criteria is the <code class="literal">test_hexacopter</code> module. In the modules that match the criteria, <code class="literal">nose2</code> loads tests from all the subclasses of <code class="literal">unittest.TestCase</code> and the functions whose names start with the <code class="literal">test</code> prefix. The <code class="literal">tornado.testing.AsyncHTTPTestCase</code> includes <code class="literal">unittest.TestCase</code> as one of its superclasses in the class hierarchy.</p><p>The output provided details indicating that the test runner discovered and executed one test and it passed. The output displays the method name and the class name for each method in the <code class="literal">TestHexacopter</code> class that started with the <code class="literal">test_</code> prefix and represented a test to be executed.</p><p>We definitely have a very low coverage for <code class="literal">async_api.py</code> and <code class="literal">drone.py</code> based on the measurements shown in the report. In fact, we just wrote one test related to LEDs, and therefore, it makes sense that the coverage has to be improved. We didn't create tests related to other hexacopter resources.</p><p>We can run the <code class="literal">coverage</code> command with the <code class="literal">-m</code> command-line option to display the line numbers of the missing statements in a new <code class="literal">Missing</code> column:</p><pre class="programlisting">
<span class="strong"><strong>coverage report -m</strong></span>
</pre><p>The command will use the information from the last execution and will display the missing statements. The next lines show a sample output that corresponds to the previous execution of the unit tests. Notice that the numbers shown in the report might have small differences if our code includes additional lines or comments:</p><pre class="programlisting">
<span class="strong"><strong>Name           Stmts   Miss  Cover   Missing</strong></span>
<span class="strong"><strong>--------------------------------------------</strong></span>
<span class="strong"><strong>async_api.py     129     69    47%   137-150, 154, 158-187, 191, 202-204, 226-228, 233-235, 249-256, 270-282, 286, 311-315</strong></span>
<span class="strong"><strong>drone.py          57     18    68%   11-12, 24, 27-34, 37, 40-41, 59, 61, 68-69</strong></span>
<span class="strong"><strong>--------------------------------------------</strong></span>
<span class="strong"><strong>TOTAL            186     87    53%</strong></span>
</pre><p>Now, run the following command to get annotated HTML listings detailing missed lines:</p><pre class="programlisting">
<span class="strong"><strong>coverage html</strong></span>
</pre><p>Open the <code class="literal">index.html</code> HTML file generated in the <code class="literal">htmlcov</code> folder with your Web browser. The following screenshot shows an example report that coverage generated in HTML format:</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_003.jpg" alt="Running unit tests with nose2 and checking testing coverage"/></div><p>
</p><p>Click or tap on <code class="literal">drony.py</code> and the Web browser will render a Web page that displays the statements that were run, the missing ones, and the excluded ones, with different colors. We can click or tap on the <span class="strong"><strong>run</strong></span>, <span class="strong"><strong>missing</strong></span>, and <span class="strong"><strong>excluded</strong></span> buttons to show or hide the background color that represents the status for each line of code. By default, the missing lines of code will be displayed with a pink background. Thus, we must write unit tests that target these lines of code to improve our test coverage.</p><p>
</p><div class="mediaobject"><img src="graphics/image_10_004.jpg" alt="Running unit tests with nose2 and checking testing coverage"/></div><p>
</p></div>
<div class="section" title="Improving testing coverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec119"/>Improving testing coverage</h1></div></div></div><p>Now, we will write additional unit tests to improve the testing coverage. Specifically, we will write unit tests related to the hexacopter motor and the altimeter. Open the existing <code class="literal">test_hexacopter.py</code> file and insert the following lines after the last line. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_03</code> folder:</p><pre class="programlisting">    def test_set_and_get_hexacopter_motor_speed(self): 
        """ 
        Ensure we can set and get the hexacopter's motor speed 
        """ 
        patch_args = {'motor_speed': 700} 
        patch_response = self.fetch( 
            '/hexacopters/1',  
            method='PATCH',  
            body=json.dumps(patch_args)) 
        self.assertEqual(patch_response.code, status.HTTP_200_OK) 
        get_response = self.fetch( 
            '/hexacopters/1', 
            method='GET') 
        self.assertEqual(get_response.code, status.HTTP_200_OK) 
        get_response_data = escape.json_decode(get_response.body) 
        self.assertTrue('speed' in get_response_data.keys()) 
        self.assertTrue('turned_on' in get_response_data.keys()) 
        self.assertEqual(get_response_data['speed'],  
                         patch_args['motor_speed']) 
        self.assertEqual(get_response_data['turned_on'],  
                         True) 
 
    def test_get_altimeter_altitude(self): 
        """ 
        Ensure we can get the altimeter's altitude 
        """ 
        get_response = self.fetch( 
            '/altimeters/1', 
            method='GET') 
        self.assertEqual(get_response.code, status.HTTP_200_OK) 
        get_response_data = escape.json_decode(get_response.body) 
        self.assertTrue('altitude' in get_response_data.keys()) 
        self.assertGreaterEqual(get_response_data['altitude'],  
                         0) 
        self.assertLessEqual(get_response_data['altitude'],  
                         3000) 
</pre><p>The previous code added the following two methods to the <code class="literal">TestHexacopter</code> class whose names start with the <code class="literal">test_</code> prefix:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_set_and_get_hexacopter_motor_speed</code>: This tests whether we can set and get the hexacopter's motor speed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_get_altimeter_altitude</code>: This tests whether we can retrieve the altitude value from the altimeter.</li></ul></div><p>We just coded a few tests related to the hexacopter and the altimeter in order to improve test coverage and notice the impact on the test coverage report.</p><p>Now, run the following command within the same virtual environment we have been using:</p><pre class="programlisting">
<span class="strong"><strong>nose2 -v --with-coverage</strong></span>
</pre><p>The following lines show the sample output. Notice that the numbers shown in the report might have small differences if our code includes additional lines or comments:</p><pre class="programlisting">
<span class="strong"><strong>test_get_altimeter_altitude (test_hexacopter.TestHexacopter) ... </strong></span>
<span class="strong"><strong>I've started retrieving the altitude</strong></span>
<span class="strong"><strong>I've finished retrieving the altitude</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_and_get_hexacopter_motor_speed (test_hexacopter.TestHexacopter) ... I've started setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've finished setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've started retrieving hexacopter's status</strong></span>
<span class="strong"><strong>I've finished retrieving hexacopter's status</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_and_get_led_brightness_level (test_hexacopter.TestHexacopter) ... I've started setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've started setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've started retrieving Blue LED's status</strong></span>
<span class="strong"><strong>I've finished retrieving Blue LED's status</strong></span>
<span class="strong"><strong>I've started retrieving White LED's status</strong></span>
<span class="strong"><strong>I've finished retrieving White LED's status</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>--------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 3 tests in 2.282s</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>----------- coverage: platform win32, python 3.5.2-final-0 ---</strong></span>
<span class="strong"><strong>Name           Stmts   Miss  Cover</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>async_api.py     129     38    71%</strong></span>
<span class="strong"><strong>drone.py          57      4    93%</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>TOTAL            186     42    77%</strong></span>
</pre><p>The output provided details indicating that the test runner executed <code class="literal">3</code> tests and all of them passed. The test code coverage measurement report provided by the <code class="literal">coverage</code> package increased the <code class="literal">Cover</code> percentage of the <code class="literal">async_api.py</code> module from <code class="literal">47%</code> in the previous run to <code class="literal">71%</code>. In addition, the percentage of the <code class="literal">drone.py</code> module increased from <code class="literal">68%</code> to <code class="literal">93%</code> because we wrote tests that worked with all the components for the drone. The new additional tests we wrote executed additional code in the two modules, and therefore, there is an impact in the coverage report.</p><p>If we take a look at the missing statements, we will notice that we aren't testing scenarios where validations fail. Now, we will write additional unit tests to improve the testing coverage further. Specifically, we will write unit tests to make sure that we cannot set invalid brightness levels for the LEDs, we cannot set invalid motor speeds for the hexacopter, and we receive an HTTP 404 Not Found status code when we try to access a resource that doesn't exist. Open the existing <code class="literal">test_hexacopter.py</code> file and insert the following lines after the last line. The code file for the sample is included in the <code class="literal">restful_python_chapter_10_04</code> folder:</p><pre class="programlisting">    def test_set_invalid_brightness_level(self): 
        """ 
        Ensure we cannot set an invalid brightness level for a LED 
        """ 
        patch_args_led_1 = {'brightness_level': 256} 
        patch_response_led_1 = self.fetch( 
            '/leds/1',  
            method='PATCH',  
            body=json.dumps(patch_args_led_1)) 
        self.assertEqual(patch_response_led_1.code, status.HTTP_400_BAD_REQUEST) 
        patch_args_led_2 = {'brightness_level': -256} 
        patch_response_led_2 = self.fetch( 
            '/leds/2',  
            method='PATCH',  
            body=json.dumps(patch_args_led_2)) 
        self.assertEqual(patch_response_led_2.code, status.HTTP_400_BAD_REQUEST) 
        patch_response_led_3 = self.fetch( 
            '/leds/2',  
            method='PATCH',  
            body=json.dumps({})) 
        self.assertEqual(patch_response_led_3.code, status.HTTP_400_BAD_REQUEST) 
 
    def test_set_brightness_level_invalid_led_id(self): 
        """ 
        Ensure we cannot set the brightness level for an invalid LED id 
        """ 
        patch_args_led_1 = {'brightness_level': 128} 
        patch_response_led_1 = self.fetch( 
            '/leds/100',  
            method='PATCH',  
            body=json.dumps(patch_args_led_1)) 
        self.assertEqual(patch_response_led_1.code, status.HTTP_404_NOT_FOUND) 
 
    def test_get_brightness_level_invalid_led_id(self): 
        """ 
        Ensure we cannot get the brightness level for an invalid LED id 
        """ 
        patch_response_led_1 = self.fetch( 
            '/leds/100',  
            method='GET') 
        self.assertEqual(patch_response_led_1.code, status.HTTP_404_NOT_FOUND) 
 
    def test_set_invalid_motor_speed(self): 
        """ 
        Ensure we cannot set an invalid motor speed for the hexacopter 
        """ 
        patch_args_hexacopter_1 = {'motor_speed': 89000} 
        patch_response_hexacopter_1 = self.fetch( 
            '/hexacopters/1',  
            method='PATCH',  
            body=json.dumps(patch_args_hexacopter_1)) 
        self.assertEqual(patch_response_hexacopter_1.code,
        status.HTTP_400_BAD_REQUEST) 
        patch_args_hexacopter_2 = {'motor_speed': -78600} 
        patch_response_hexacopter_2 = self.fetch( 
            '/hexacopters/1',  
            method='PATCH',  
            body=json.dumps(patch_args_hexacopter_2)) 
        self.assertEqual(patch_response_hexacopter_2.code,
        status.HTTP_400_BAD_REQUEST) 
        patch_response_hexacopter_3 = self.fetch( 
            '/hexacopters/1',  
            method='PATCH',  
            body=json.dumps({})) 
        self.assertEqual(patch_response_hexacopter_3.code,
        status.HTTP_400_BAD_REQUEST) 
 
    def test_set_motor_speed_invalid_hexacopter_id(self): 
        """ 
        Ensure we cannot set the motor speed for an invalid hexacopter id 
        """ 
        patch_args_hexacopter_1 = {'motor_speed': 128} 
        patch_response_hexacopter_1 = self.fetch( 
            '/hexacopters/100',  
            method='PATCH',  
            body=json.dumps(patch_args_hexacopter_1)) 
        self.assertEqual(patch_response_hexacopter_1.code,
        status.HTTP_404_NOT_FOUND) 
 
    def test_get_motor_speed_invalid_hexacopter_id(self): 
        """ 
        Ensure we cannot get the motor speed for an invalid hexacopter id 
        """ 
        patch_response_hexacopter_1 = self.fetch( 
            '/hexacopters/5',  
            method='GET') 
        self.assertEqual(patch_response_hexacopter_1.code,
        status.HTTP_404_NOT_FOUND) 
 
    def test_get_altimeter_altitude_invalid_altimeter_id(self): 
        """ 
        Ensure we cannot get the altimeter's altitude for an invalid altimeter id 
        """ 
        get_response = self.fetch( 
            '/altimeters/5', 
            method='GET') 
        self.assertEqual(get_response.code, status.HTTP_404_NOT_FOUND) 
</pre><p>The previous code added the following seven methods to the <code class="literal">TestHexacopter</code> class whose names start with the <code class="literal">test_</code> prefix:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">test_set_invalid_brightness_level</code>: This makes sure that we cannot set an invalid brightness level for an LED through an HTTP <code class="literal">PATCH</code> request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_set_brightness_level_invalid_led_id</code>: This makes sure that we cannot set the brightness level for an invalid LED ID through an HTTP <code class="literal">PATCH</code> request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_get_brightness_level_invalid_led_id</code>: This makes sure that we cannot get the brightness level for an invalid LED ID.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_set_invalid_motor_speed</code>: This makes sure that we cannot set an invalid motor seed for the hexacopter through an HTTP <code class="literal">PATCH</code> request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_set_motor_speed_invalid_hexacopter_id</code>: This makes sure that we cannot set the motor speed for an invalid hexacopter ID through an HTTP <code class="literal">PATCH</code> request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_get_motor_speed_invalid_hexacopter_id</code>: This makes sure that we cannot get the motor speed for an invalid hexacopter ID.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test_get_altimeter_altitude_invalid_altimeter_id</code>: This makes sure that we cannot get the altitude value for an invalid altimeter ID.</li></ul></div><p>We coded many tests that will make sure that all the validations work as expected. Now, run the following command within the same virtual environment we have been using:</p><pre class="programlisting">
<span class="strong"><strong>nose2 -v --with-coverage</strong></span>
</pre><p>The following lines show the sample output. Notice that the numbers shown in the report might have small differences if our code includes additional lines or comments:</p><pre class="programlisting">
<span class="strong"><strong>I've finished retrieving the altitude</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_get_altimeter_altitude_invalid_altimeter_id (test_hexacopter.TestHexacopter) ... WARNING:tornado.access:404 GET /altimeters/5 (127.0.0.1) 1.00ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_get_brightness_level_invalid_led_id (test_hexacopter.TestHexacopter) ... WARNING:tornado.access:404 GET /leds/100 (127.0.0.1) 2.01ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_get_motor_speed_invalid_hexacopter_id (test_hexacopter.TestHexacopter) ... WARNING:tornado.access:404 GET /hexacopters/5 (127.0.0.1) 2.01ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_and_get_hexacopter_motor_speed (test_hexacopter.TestHexacopter) ... I've started setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've finished setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've started retrieving hexacopter's status</strong></span>
<span class="strong"><strong>I've finished retrieving hexacopter's status</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_and_get_led_brightness_level (test_hexacopter.TestHexacopter) ... I've started setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've started setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've finished setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've started retrieving Blue LED's status</strong></span>
<span class="strong"><strong>I've finished retrieving Blue LED's status</strong></span>
<span class="strong"><strong>I've started retrieving White LED's status</strong></span>
<span class="strong"><strong>I've finished retrieving White LED's status</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_brightness_level_invalid_led_id (test_hexacopter.TestHexacopter) ... WARNING:tornado.access:404 PATCH /leds/100 (127.0.0.1) 1.01ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_invalid_brightness_level (test_hexacopter.TestHexacopter) ... I've started setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>I've failed setting the Blue LED's brightness level</strong></span>
<span class="strong"><strong>WARNING:tornado.access:400 PATCH /leds/1 (127.0.0.1) 13.51ms</strong></span>
<span class="strong"><strong>I've started setting the White LED's brightness level</strong></span>
<span class="strong"><strong>I've failed setting the White LED's brightness level</strong></span>
<span class="strong"><strong>WARNING:tornado.access:400 PATCH /leds/2 (127.0.0.1) 10.03ms</strong></span>
<span class="strong"><strong>WARNING:tornado.access:400 PATCH /leds/2 (127.0.0.1) 2.01ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_invalid_motor_speed (test_hexacopter.TestHexacopter) ... I've started setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've failed setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>WARNING:tornado.access:400 PATCH /hexacopters/1 (127.0.0.1) 19.27ms</strong></span>
<span class="strong"><strong>I've started setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>I've failed setting the hexacopter's motor speed</strong></span>
<span class="strong"><strong>WARNING:tornado.access:400 PATCH /hexacopters/1 (127.0.0.1) 9.04ms</strong></span>
<span class="strong"><strong>WARNING:tornado.access:400 PATCH /hexacopters/1 (127.0.0.1) 1.00ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>test_set_motor_speed_invalid_hexacopter_id (test_hexacopter.TestHexacopter) ... WARNING:tornado.access:404 PATCH /hexacopters/100 (127.0.0.1) 1.00ms</strong></span>
<span class="strong"><strong>ok</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 10 tests in 5.905s</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>----------- coverage: platform win32, python 3.5.2-final-0 -----------</strong></span>
<span class="strong"><strong>Name           Stmts   Miss  Cover</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>async_api.py     129      5    96%</strong></span>
<span class="strong"><strong>drone.py          57      0   100%</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>TOTAL            186      5    97%</strong></span>
</pre><p>The output provided details indicating that the test runner executed <code class="literal">10</code> tests and all of them passed. The test code coverage measurement report provided by the <code class="literal">coverage</code> package increased the <code class="literal">Cover</code> percentage of the <code class="literal">async_api.py</code> module from <code class="literal">71%</code> in the previous run to <code class="literal">97%</code>. In addition, the percentage of the <code class="literal">drone.py</code> module increased from <code class="literal">93%</code> to <code class="literal">100%</code>. If we check the coverage report, we will notice that the only statements that aren't executed are the statements included in the main method for the async_api.py module because they aren't part of the tests. Thus, we can say that we have <code class="literal">100%</code> coverage.</p><p>Now that we have a great test coverage, we can generate the <code class="literal">requirements.txt</code> file that lists the application dependencies together with their versions. This way, any platform in which we decide to deploy the RESTful API will be able to easily install all the necessary dependencies listed in the file.</p><p>Run the following <code class="literal">pip freeze</code> to generate the <code class="literal">requirements.txt</code> file:</p><pre class="programlisting">
<span class="strong"><strong>pip freeze &gt; requirements.txt</strong></span>
</pre><p>The following lines show the content of a sample generated <code class="literal">requirements.txt</code> file. However, bear in mind that many packages increase their version number quickly and you might see different versions in your configuration:</p><pre class="programlisting">
<span class="strong"><strong>cov-core==1.15.0</strong></span>
<span class="strong"><strong>coverage==4.2</strong></span>
<span class="strong"><strong>nose2==0.6.5</strong></span>
<span class="strong"><strong>six==1.10.0</strong></span>
<span class="strong"><strong>tornado==4.4.1</strong></span>
</pre></div>
<div class="section" title="Other Python Web frameworks for building RESTful APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec120"/>Other Python Web frameworks for building RESTful APIs</h1></div></div></div><p>We built RESTful Web Services with Django, Flask, and Tornado. However, Python has many other Web frameworks that are also suitable for building RESTful APIs. Everything we learned throughout the book about designing, building, testing, and deploying a RESTful API is also applicable to any other Python Web framework we decide to use. The following list enumerates additional frameworks and their main Web page:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pyramid</strong></span>: <a class="ulink" href="http://www.pylonsproject.org/">http://www.pylonsproject.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bottle</strong></span>: <a class="ulink" href="http://bottlepy.org/">http://bottlepy.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Falcon</strong></span>: <a class="ulink" href="https://falconframework.org/">https://falconframework.org/</a></li></ul></div><p>As always happens with any Python Web framework, there are additional packages that might simplify our most common tasks. For example, it is possible to use Ramses in combination with Pyramid to create RESTful APIs by working with <span class="strong"><strong>RAML</strong></span> (<span class="strong"><strong>RESTful API Modeling Language</strong></span>), whose specification is available at <a class="ulink" href="http://github.com/raml-org/raml-spec">http://github.com/raml-org/raml-spec</a>. You can read more details about Ramses at <a class="ulink" href="http://ramses.readthedocs.io/en/stable/getting_started.html">http://ramses.readthedocs.io/en/stable/getting_started.html</a>.</p></div>
<div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec121"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">concurrent.futures.ThreadPoolExecutor</code> class provides us:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A high-level interface for synchronously executing callables.</li><li class="listitem">A high-level interface for asynchronously executing callables.</li><li class="listitem">A high-level interface for composing HTTP requests.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">@tornado.concurrent.run_on_executor</code> decorator allows us to:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run an asynchronous method synchronously on an executor.</li><li class="listitem">Run an asynchronous method on an executor without generating a Future.</li><li class="listitem">Run a synchronous method asynchronously on an executor.</li></ol></div><p>
</p></li><li class="listitem">The recommended way to write asynchronous code in Tornado is to use:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Coroutines.</li><li class="listitem">Chained callbacks.</li><li class="listitem">Subroutines.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">tornado.Testing.AsyncHTTPTestCase</code> class represents:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A test case that starts up a Flask HTTP Server.</li><li class="listitem">A test case that starts up a Tornado HTTP Server.</li><li class="listitem">A test case that doesn't start up any HTTP Server.</li></ol></div><p>
</p></li><li class="listitem">If we want to convert the bytes in a JSON response body to a Python dictionary, we can use the following function:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">tornado.escape.json_decode</code></li><li class="listitem"><code class="literal">tornado.escape.byte_decode</code></li><li class="listitem"><code class="literal">tornado.escape.response_body_decode</code></li></ol></div><p>
</p></li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec122"/>Summary</h1></div></div></div><p>In this chapter, we understood the difference between synchronous and asynchronous execution. We created a new version of the RESTful API that takes advantage of the non-blocking features in Tornado combined with asynchronous execution. We improved scalability for our existing API and we made it possible to start executing other requests while waiting for the slow I/O operations with sensors and actuators. We avoided splitting our methods into multiple methods with callbacks by using the <code class="literal">tornado.gen</code> generator-based interface that Tornado provides to make it easier to work in an asynchronous environment.</p><p>Then, we set up a testing environment. We installed nose2 to make it easy to discover and execute unit tests. We wrote a first round of unit tests, measured test coverage, and then we wrote additional unit tests to improve test coverage. We created all the necessary tests to have a complete coverage of all the lines of code.</p><p>We built RESTful Web Services with Django, Flask, and Tornado. We have chosen the most appropriate framework for each case. We learned to design a RESTful API from scratch and to run all the necessary tests to make sure that our API works without issues as we release new versions. Now, we are ready to create RESTful APIs with any of the Web frameworks with whom we have been working throughout this book.</p></div></body></html>