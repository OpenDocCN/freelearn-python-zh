["```py\n32T3K 765\nT55J5 684\nKK677 28\nKTJJT 220\nQQQJA 483 \n```", "```py\n# day7.py\nfrom collections import Counter\nfrom functools import cmp_to_key\nfrom util import get_input\nclass Solver:\n    strengths: str = \"\"\n    def __init__(self) -> None:\n        self.ins: list[str] = get_input(\"input7.txt\")\n    def solve(self) -> int:\n        hands = dict(self.parse_line(line) for line in self.ins)\n        sorted_hands = sorted(\n            hands.keys(), key=cmp_to_key(self.cmp)\n        )\n        return sum(\n            rank * hands[hand]\n            for rank, hand in enumerate(sorted_hands, start=1)\n        )\n    def parse_line(self, line: str) -> tuple[str, int]:\n        hand, bid = line.split()\n        return hand, int(bid) \n```", "```py\n# day7.py\n…\nclass Solver:\n    …\n    def type(self, hand: str) -> list[int]:\n        raise NotImplementedError\n    def cmp(self, hand1: str, hand2: str) -> int:\n        \"\"\"-1 if hand1 < hand2 else 1, or 0 if hand1 == hand2\"\"\"\n        type1 = self.type(hand1)\n        type2 = self.type(hand2)\n        if type1 == type2:\n            for card1, card2 in zip(hand1, hand2):\n                strength1 = self.strengths.index(card1)\n                strength2 = self.strengths.index(card2)\n                if strength1 == strength2:\n                    continue\n                return -1 if strength1 < strength2 else 1\n            return 0\n        return -1 if type1 < type2 else 1 \n```", "```py\n# day7.py\n…\nclass PartOne(Solver):\n    strengths: str = \"23456789TJQKA\"\n    def type(self, hand: str) -> list[int]:\n        return [count for _, count in Counter(hand).most_common()] \n```", "```py\ntype(\"KK444\") = [3, 2]\ntype(\"QQQ6Q\") = [4, 1]\ntype(\"5JA22\") = [2, 1, 1, 1]\ntype(\"7A264\") = [1, 1, 1, 1, 1]\ntype(\"TTKTT\") = [4, 1] \n```", "```py\n# day7.py\npart_one = PartOne()\nprint(part_one.solve()) \n```", "```py\n32T3K 765\nT55J5 684\nKK677 28\nKTJJT 220\nQQQJA 483 \n```", "```py\n# day7.py\n…\nclass PartTwo(Solver):\n    strengths: str = \"J23456789TQKA\"\n    def type(self, hand: str) -> list[int]:\n        card_counts = Counter(hand.replace(\"J\", \"\")).most_common()\n        h = [count for _, count in card_counts]\n        return [h[0] + hand.count(\"J\"), *h[1:]] if h else [5]\npart_two = PartTwo()\nprint(part_two.solve()) \n```", "```py\n...#......\n.......#..\n#.........\n..........\n......#...\n.#........\n.........#\n..........\n.......#..\n#...#..... \n```", "```py\n....#........\n.........#...\n#............\n.............\n.............\n........#....\n.#...........\n............#\n.............\n.............\n.........#...\n#....#....... \n```", "```py\n....1........\n.........2...\n3............\n.............\n.............\n........4....\n.5...........\n.xx.........6\n..xx.........\n...xx........\n....xx...7...\n8....9....... \n```", "```py\n# day11.py\nfrom itertools import combinations\nfrom typing import NamedTuple, Self\nfrom util import get_input\nuniverse = get_input(\"input11.txt\")\nclass Galaxy(NamedTuple):\n    x: int\n    y: int\n    @classmethod\n    def expand(\n        cls, galaxy: Self, xfactor: int, yfactor: int\n    ) -> Self:\n        return cls(galaxy.x + xfactor, galaxy.y + yfactor)\n    @classmethod\n    def manhattan(cls, a: Self, b: Self) -> int:\n        return abs(a.x - b.x) + abs(a.y - b.y)\nclass ExpansionCoeff(NamedTuple):\n    x: int = 0\n    y: int = 0 \n```", "```py\n# day11.py\n…\ndef coords_to_expand(universe: list[str]) -> list[int]:\n    return [\n        coord\n        for coord, row in enumerate(universe)\n        if set(row) == {\".\"}\n    ]\ndef expand_universe(universe: list[str], coeff: int) -> set:\n    galaxies = parse(universe)\n    rows_to_expand = coords_to_expand(universe)\n    galaxies = expand_dimension(\n        galaxies, rows_to_expand, ExpansionCoeff(y=coeff - 1)\n    )\n    **transposed_universe = [****\"\"****.join(col)** **for** **col** **in****zip****(*universe)]**\n    cols_to_expand = coords_to_expand(transposed_universe)\n    return expand_dimension(\n        galaxies, cols_to_expand, ExpansionCoeff(x=coeff - 1)\n    )\ndef parse(ins: list[str]) -> set:\n    return {\n        Galaxy(x, y)\n        for y, row in enumerate(ins)\n        for x, val in enumerate(row)\n        if val == \"#\"\n    }\ndef solve(universe: list[str], coeff) -> int:\n    expanded_universe = expand_universe(universe, coeff)\n    return sum(\n        Galaxy.manhattan(g1, g2)\n        for g1, g2 in combinations(expanded_universe, 2)\n    ) \n```", "```py\n# day11.py\n…\ndef expand_dimension(\n    galaxies: set,\n    coords_to_expand: list[int],\n    expansion_coeff: ExpansionCoeff,\n) -> set:\n    dimension = \"x\" if expansion_coeff.y == 0 else \"y\"\n    for coord in reversed(coords_to_expand):\n        new_galaxies = set()\n        for galaxy in galaxies:\n            if getattr(galaxy, dimension) >= coord:\n                galaxy = Galaxy.expand(galaxy, *expansion_coeff)\n            new_galaxies.add(galaxy)\n        galaxies = new_galaxies\n    return new_galaxies \n```", "```py\n# day11.py\nprint(solve(universe, coeff=2)) \n```", "```py\n# day11.py\nprint(solve(universe, coeff=int(1e6))) \n```"]