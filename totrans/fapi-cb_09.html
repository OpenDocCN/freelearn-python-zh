<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-292"><a id="_idTextAnchor295"/>9</h1>
<h1 id="_idParaDest-293"><a id="_idTextAnchor296"/>Working with WebSocket</h1>
<p>Real-time communication has become increasingly important in modern web applications, enabling interactive features such as chat, notifications, and live updates. In this chapter, we’ll explore the exciting world of WebSockets and how to leverage them effectively in FastAPI applications. From setting up WebSocket connections to implementing advanced features such as chat functionality and error handling, this chapter provides a comprehensive guide to building responsive, real-time communication features. By the end of the chapter, you will have the skills to create WebSockets and facilitate real-time communication in FastAPI applications, enabling interactive functionalities and dynamic user experiences.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Setting up Websockets in FastAPI</li>
<li>Sending and receiving messages over WebSockets</li>
<li>Handling WebSocket connections and disconnections</li>
<li>Handling WebSocket errors and exceptions</li>
<li>Implementing chat functionality with WebSocket</li>
<li>Optimizing WebSocket performance</li>
<li>Securing WebSocket connections with OAuth2</li>
</ul>
<h1 id="_idParaDest-294"><a id="_idTextAnchor297"/>Technical requirements</h1>
<p>To follow along with the WebSockets recipes, make sure you have the following essentials in your setup:</p>
<ul>
<li><strong class="bold">Python</strong>: Install a Python version higher than 3.9 in your environment.</li>
<li><strong class="bold">FastAPI</strong>: This should be installed with all the required dependencies. If you haven’t done it in the previous chapters, you can simply do it from your terminal:<pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> </ul>
<p>The code used in the chapter is hosted on GitHub at <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09</a>.</p>
<p>It is recommended to set up a virtual environment for the project in the project root folder to efficiently manage dependencies and maintain project isolation.</p>
<p>Within your virtual environment, you can install all the dependencies at once by using the <code>requirements.txt</code> file provided in the GitHub repository in the project folder:</p>
<pre class="console">
$ pip install –r requirements.txt</pre> <p>Since the interactive Swagger documentation is limited at the time of writing, basic mastering of <strong class="bold">Postman</strong> or any other testing API is beneficial to test our API.</p>
<p>Having basic knowledge of how <strong class="bold">WebSockets</strong> work can be beneficial, although it’s not necessary since the recipes will guide you through.</p>
<p>For the <em class="italic">Implementing chat functionality with WebSockets</em> recipe, we will write some basic <strong class="bold">HTML</strong>, including some <strong class="bold">Javascript</strong> code.</p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor298"/>Setting up WebSockets in FastAPI</h1>
<p>WebSockets provide a powerful mechanism<a id="_idIndexMarker580"/> for establishing full-duplex communication channels between clients and servers, allowing real-time data exchange. In this recipe, you’ll learn how to establish a connection with WebSocket<a id="_idIndexMarker581"/> functionality in your FastAPI applications to enable interactive and responsive communication.</p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor299"/>Getting ready</h2>
<p>Before diving into the recipe, ensure you have all the required packages in your environment. You can install them from the <code>requirements.txt</code> file provided in the GitHub repository or install it manually with <code>pip</code>:</p>
<pre class="console">
$ pip install fastapi[all] websockets</pre> <p>Since the swagger documentation does not support WebSocket, we will use an external tool to test the WebSocket connection, such as Postman.</p>
<p>You can find instructions on how to install it on the website: <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a>.</p>
<p>The free community version will <a id="_idIndexMarker582"/>be enough to test the recipes.</p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor300"/>How to do it…</h2>
<p>Create the project root folder called <code>chat_platform</code>. we<a id="_idIndexMarker583"/> can create our <code>app</code> folder containing the <code>main.py</code> module. Let's build our simple application with a WebSocket endpoint as follows.</p>
<ol>
<li>We can start by creating our server in the <code>main.py</code> module:<pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre></li> <li>Then we can create the WebSocket endpoint to connect the client to the chat room:<pre class="source-code">
from fastapi import WebSocket
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    await websocket.close()</pre><p class="list-inset">The endpoint establishes the connection with the client, sends a welcome message, and closes the connection. This is the most basic configuration of a WebSocket endpoint.</p></li> </ol>
<p>That's it. To test it, spin up the server from the command line:</p>
<pre class="console">
<code>ws://localhost:8000/ws</code> and <a id="_idIndexMarker585"/>click on <strong class="bold">Connect</strong>.</p>
<p>In the <strong class="bold">Response</strong> panel, right<a id="_idIndexMarker586"/> below the URL form, you should see the list of events that happened during the connection. In particular, look for the message received by the server:</p>
<pre class="console">
<strong class="bold">Welcome to the chat room! 12:37:19</strong></pre> <p>That means that the WebSocket endpoint has been created and works properly.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor301"/>How it works…</h2>
<p>The <code>websocket</code> parameter in the WebSocket endpoint represents an individual WebSocket connection. By awaiting <code>websocket.accept()</code>, the server establishes the connection with the client (technically called an <code>websocket.send_text()</code> sends a message to the<a id="_idIndexMarker587"/> client. Finally, <code>websocket.close()</code> closes the connection.</p>
<p>The three events are listed in<a id="_idIndexMarker588"/> the <strong class="bold">Response</strong> panel of Postman.</p>
<p>Although not very useful from a practical point of view, this configuration is the bare minimum setup for a WebSocket connection. In the next recipe, we will see how to exchange messages between the client and the server through a WebSocket endpoint.</p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor302"/>See also</h2>
<p>You can check how to create a WebSocket endpoint on the FastAPI official documentation page:</p>
<ul>
<li><em class="italic">FastAPI </em><em class="italic">WebSockets</em>: <a href="https://fastapi.tiangolo.com/advanced/websockets/">https://fastapi.tiangolo.com/advanced/websockets/</a></li>
</ul>
<p>At the time of writing, the Swagger documentation does not support WebSocket endpoints. If you spin up the<a id="_idIndexMarker589"/> server and open Swagger at <code>http://localhost:8000/docs</code>, you<a id="_idIndexMarker590"/> won’t see the endpoint we have just created. A discussion is ongoing on the FastAPI GitHub repository – you can follow it at the following URL:</p>
<ul>
<li><em class="italic">FastAPI WebSocket Endpoints Documentation </em><em class="italic">Discussion</em>: <a href="https://github.com/tiangolo/fastapi/discussions/7713">https://github.com/tiangolo/fastapi/discussions/7713</a></li>
</ul>
<h1 id="_idParaDest-300"><a id="_idTextAnchor303"/>Sending and receiving messages over WebSockets</h1>
<p>WebSocket connections enable bidirectional communication between clients and servers, allowing the real-time exchange <a id="_idIndexMarker591"/>of messages. This recipe will bring us one step closer to creating our chat application by showing how to enable the FastAPI application to receive messages over WebSockets and print them to the terminal output.</p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor304"/>Getting ready</h2>
<p>Before starting the recipe, make sure you know how to set up a <strong class="bold">WebSocket</strong> connection in <strong class="bold">FastAPI</strong>, as explained in the previous recipe. Also, you will need a tool to test WebSockets, such as <strong class="bold">Postman</strong>, on your machine.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor305"/>How to do it…</h2>
<p>We will enable our chatroom endpoint to receive messages from the client to print them to the standard output.</p>
<p>Let’s start by defining the logger. We will use the logger from the <code>uvicorn</code> package (as we did in other recipes – see, for example, <em class="italic">Creating custom middlewares</em> in <a href="B21025_08.xhtml#_idTextAnchor262"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Features and Best Practices</em>), which is the one used by FastAPI as well. In <code>main.py</code>, let’s write the following:</p>
<pre class="source-code">
import logging
logger = logging.getLogger("uvicorn")</pre> <p>Now let’s modify the <code>ws_endpoint</code> function endpoint:</p>
<pre class="source-code">
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
<strong class="bold">    while True:</strong>
<strong class="bold">        data = await websocket.receive_text()</strong>
<strong class="bold">        logger.info(f"Message received: {data}")</strong>
<code>websocket.close()</code> call from the previous recipe and used an infinite <code>while</code> loop. This allows the server side to continuously receive the message from the client and print it to the console without closing the connection. In this case, the connection can be closed only by the client.</p>
<p>This is all you need to read<a id="_idIndexMarker592"/> messages from the client and send it to the terminal output.</p>
<p>The server initiates a connection request when the client call the endpoint. With the <code>websocket.receive_text()</code> function, the server opens the connection and it is ready to receive the message from the client. The message is stored into the <code>data</code> variable and it is printed to terminal output. Then the server sends a confirmation message to the client.</p>
<p>Let’s test it. Spin up the server by running <code>uvicorn app.main:app</code> from the command line and open Postman. Then apply the following steps.</p>
<ol>
<li>Create a new WebSocket request, and connect to the <code>ws://localhost:8000/ws</code> address.<p class="list-inset">Once the connection is established, you will see on the terminal output the message:</p><pre class="source-code">
<code>Hello </code><code>FastAPI application</code>.<p class="list-inset">On the output terminal you will the following message:</pre><pre class="source-code">
<strong class="bold">INFO: Message received: Hello FastAPI application</strong></pre><p class="list-inset">While in the messages <a id="_idIndexMarker593"/>section of the client request you will see the new message:</p><pre class="source-code"><strong class="bold">Message received! 14:46:20</strong></pre></li> <li>You can then close the connection from the client by clicking on the <strong class="bold">Disconnect</strong> button to the right of the WebSocket <strong class="bold">URL</strong> field.</li>
</ol>
<p>By enabling the server to receive messages from the client, you have just enabled bidirectional communication between the client and server through a WebSocket.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor306"/>See also</h2>
<p>The <code>Fastapi.WebSocket</code> instance is, in reality, a <code>starlette.WebSocket</code> class from the <code>send_json</code> or <code>receive_json</code> methods).</p>
<p>Check more on the official Starlette documentation page:</p>
<ul>
<li><em class="italic">Starlette </em><em class="italic">Websockets</em>: <a href="https://www.starlette.io/websockets/">https://www.starlette.io/websockets/</a></li>
</ul>
<h1 id="_idParaDest-304"><a id="_idTextAnchor307"/>Handling WebSocket connections and disconnections</h1>
<p>When a client establishes a WebSocket connection with a <strong class="bold">FastAPI</strong> server, it’s crucial to handle the lifecycle of these connections appropriately. This includes accepting incoming connections, maintaining active connections, and handling disconnections gracefully to ensure smooth<a id="_idIndexMarker595"/> communication between the client and server. In this recipe, we’ll explore how to effectively manage WebSocket connections and<a id="_idIndexMarker596"/> gracefully handle disconnections.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor308"/>Getting ready</h2>
<p>To follow the recipe, you will need to have <strong class="bold">Postman</strong> or any other tool to test WebSocket connections. Also, you need to already have a WebSocket endpoint implemented in your application. Check the previous two recipes if that is not the case.</p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor309"/>How to do it…</h2>
<p>We will see how to manage the following two situations:</p>
<ul>
<li>Client-side disconnection</li>
<li>Server-side disconnection</li>
</ul>
<p>Let’s have a look at each of these situations in detail.</p>
<h3>Client-side disconnection</h3>
<p>You might have noticed in the <em class="italic">Sending and receiving messages over WebSockets</em> recipe that if the connection is closed <a id="_idIndexMarker597"/>from the client (e.g., from Postman) on the<a id="_idIndexMarker598"/> server console, a <code>WebSocketDisconnect</code> exception propagates, uncaptured.</p>
<p>This is because the disconnection from the client side should be properly handled in a <code>try-except</code> block.</p>
<p>Let’s adjust the endpoint to take this into account. In the <code>main.py</code> module, we modify the <code>/ws</code><code> </code>endpoint as follows:</p>
<pre class="source-code">
from fastapi.websockets import WebSocketDisconnect
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
<strong class="bold">    try:</strong>
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
<strong class="bold">    except WebSocketDisconnect:</strong>
<strong class="bold">        logger.warning(</strong>
<strong class="bold">            "Connection closed by the client"</strong>
<code>/ws</code>, and then disconnect, you won’t see the error <a id="_idIndexMarker599"/>propagation anymore.</p>
<h3>Server-side disconnection</h3>
<p>In this situation, the connection is closed <a id="_idIndexMarker600"/>by the server. Suppose the server will close the connection based on a specific message such as the <code>"disconnect"</code> text string, for example.</p>
<p>Let’s implement it in the <code>/</code><code>ws</code> endpoint:</p>
<pre class="source-code">
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    while True:
        data = await websocket.receive_text()
        logger.info(f"Message received: {data}")
<strong class="bold">        if data == "disconnect":</strong>
<strong class="bold">            logger.warn("Disconnecting...")</strong>
<strong class="bold">            await websocket.close()</strong>
<code>data</code> string content to then call the <code>websocket.close</code> method and exit the <code>while</code> loop.</p>
<p>If you run the server, try to <a id="_idIndexMarker601"/>connect to the WebSocket <code>/ws</code> endpoint, and send the <code>"disconnect"</code> string as a message, the connection will be closed by the server.</p>
<p>You have seen how to manage disconnection and connection handshakes for a WebSocket endpoint, however, we still need to manage the right status code and messages for each. Let’s check this in the following recipe.</p>
<h1 id="_idParaDest-307"><a id="_idTextAnchor310"/>Handling WebSocket errors and exceptions</h1>
<p>WebSocket connections are susceptible to various errors and exceptions that can occur during the lifecycle of a connection. Common issues include connection failures, message parsing errors, and unexpected<a id="_idIndexMarker602"/> disconnections. Properly handling errors and correctly communicating with the client is essential to maintaining a responsive and resilient WebSocket-based application. In this recipe, we’ll explore how to handle WebSocket errors and exceptions effectively in FastAPI applications.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor311"/>Getting ready</h2>
<p>The recipe will show how to manage WebSocket errors that can happen for a specific endpoint. We will showcase how to improve the <code>/ws</code> endpoint defined in the <em class="italic">Handling WebSocket connections and </em><em class="italic">disconnections</em> recipe.</p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor312"/>How to do it…</h2>
<p>The way the <code>/ws</code> endpoint is coded in the previous recipe returns the same response code and message when the server closes the connection. Just like for HTTP responses, FastAPI allows you to personalize the response to return a more meaningful message to the client.</p>
<p>Let’s see how to do it. You can use a solution like the following:</p>
<pre class="source-code">
<strong class="bold">from fastapi import status</strong>
@app.websocket("/ws")
async def chatroom(websocket: WebSocket):
    if not websocket.headers.get("Authorization"):
        return await websocket.close()
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
<strong class="bold">            if data == "disconnect":</strong>
<strong class="bold">                logger.warn("Disconnecting...")</strong>
<strong class="bold">                return await websocket.close(</strong>
<strong class="bold">                    code=status.WS_1000_NORMAL_CLOSURE,</strong>
<strong class="bold">                    reason="Disconnecting...",</strong>
<strong class="bold">                )</strong>
    except WebSocketDisconnect:
        logger.warn("Connection closed by the client")</pre> <p>We have specified to the <code>websocket.close</code> method a status code and reason that will be transmitted to the <a id="_idIndexMarker603"/>client.</p>
<p>If we now spin up the server and send the disconnect message from the client, you will see a disconnection log message in the response window, like this:</p>
<pre class="console">
Disconnected from localhost:8000/ws 14:09:08
1000 Normal Closure:  Disconnecting...</pre> <p>This is all you need to gracefully disconnect your WebSocket connection.</p>
<h3>Alternative solution</h3>
<p>Similarly to how an <code>HTTPException</code> instance is rendered for HTTP requests (see the <em class="italic">Handling errors and exceptions</em> recipe in <a href="B21025_01.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">First Steps with FastAPI</em>), FastAPI also enables the use of <code>WebSocketException</code> for WebSocket connections, which is rendered automatically as a response.</p>
<p>To better understand, imagine we want to disconnect the client if they write something that isn’t allowed – for<a id="_idIndexMarker604"/> example, the <code>"bad message"</code> text string. Let’s modify the chatroom endpoint:</p>
<pre class="source-code">
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
            if data == "disconnect":
                logger.warn("Disconnecting...")
                return await websocket.close(
                    code=status.WS_1000_NORMAL_CLOSURE,
                    reason="Disconnecting...",
                )
<strong class="bold">            if "bad message" in data:</strong>
<strong class="bold">                raise WebSocketException(</strong>
<strong class="bold">                    code=status.WS_1008_POLICY_VIOLATION,</strong>
<strong class="bold">                    reason="Inappropriate message"</strong>
<strong class="bold">                )</strong>
    except WebSocketDisconnect:
        logger.warn("Connection closed by the client")</pre> <p>If you spin up the server and try to send whatever message contains the <code>"bad message"</code> string, the client will be disconnected. Furthermore, on the <strong class="bold">Response</strong> panel section of Postman of your WebSocket connection you will see the following log message:</p>
<pre class="console">
Disconnected from localhost:8000/ws 14:51:40
1008 Policy Violation: Inappropriate message</pre> <p>You have just seen how to<a id="_idIndexMarker605"/> communicate WebSocket errors to the client by raising the appropriate exception. You can use this strategy for a variety of errors that can arise while running the application and have to be correctly communicated to the API consumer.</p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor313"/>See also</h2>
<p>WebSocket is a relatively new protocol compared to HTTP, so it is still evolving with time. Although status codes are not extensively used, like for HTTP, you can find definitions of WebSockets codes at the following links:</p>
<ul>
<li><em class="italic">WebSocket Close Code Number </em><em class="italic">Registry</em>: <a href="https://www.iana.org/assignments/websocket/websocket.xml#close-code-number">https://www.iana.org/assignments/websocket/websocket.xml#close-code-number</a></li>
</ul>
<p>You can also find a list of the compatibility of WebSocket events for browsers on the following page:</p>
<ul>
<li><em class="italic">WebSocket </em><em class="italic">CloseEvent</em>: <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent">https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</a></li>
</ul>
<p>Furthermore, the <code>WebSocketException</code> class in FastAPI is documented at the official documentation link:</p>
<ul>
<li><em class="italic">FastAPI WebSocketExcpetion API </em><em class="italic">documentation</em>: <a href="https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException">https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException</a></li>
</ul>
<h1 id="_idParaDest-311"><a id="_idTextAnchor314"/>Implementing chat functionality with WebSockets</h1>
<p>Real-time chat functionality is<a id="_idIndexMarker606"/> a common feature in many modern web applications, enabling users to communicate instantly with each other. In this recipe, we’ll <a id="_idIndexMarker607"/>explore how to implement chat functionality using WebSockets in FastAPI applications.</p>
<p>By leveraging WebSockets, we will create a bidirectional communication channel between the server and multiple clients, allowing messages to be sent and received in real time.</p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor315"/>Getting ready</h2>
<p>To follow the recipe, you need to have a good understanding of WebSockets and know how to build a WebSocket endpoint using FastAPI.</p>
<p>Additionally, having some basic knowledge of HTML and JavaScript can help create simple web pages for the application. The recipe we’ll be using is the foundation of our chat application.</p>
<p>Also, we will use the <code>jinja2</code> package to apply basic templating for the HTML page. Make sure to have it in your environment. If you didn’t install packages with <code>requirements.txt</code>, install <code>jinja2</code> with <code>pip</code>:</p>
<pre class="console">
$ pip install jinja2</pre> <p>Once the installation is complete, we are ready to start with the recipe.</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor316"/>How to do it…</h2>
<p>To build the application, we will need to build three core pieces – the WebSocket connections manager, the WebSocket endpoint, and the chat HTML page:</p>
<ol>
<li>Let’s start by building the connection manager. The role of the connection manager is to keep track of open WebSocket connections and broadcast messages to active ones. Let’s define the <code>ConnectionManager</code> class in a dedicated <code>ws_manager.py</code> module under the <code>app</code> folder:<pre class="source-code">
import asyncio
from fastapi import WebSocket
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    async def send_personal_message(
        self, message: dict, websocket: WebSocket
    ):
        await websocket.send_json(message)
    async def broadcast(
        self, message: json, exclude: WebSocket = None
    ):
        tasks = [
            connection.send_json(message)
            for connection in self.active_connections
            if connection != exclude
        ]
        await asyncio.gather(*tasks)</pre><p class="list-inset">The <code>async def connect</code> method will be responsible for the handshake and adding the WebSocket to the list of active ones. The <code>def disconnect</code> method will remove the WebSocket from the list of active connections. The <code>async def send_personal_message</code> method will send a message to a specific WebSocket. Finally, <code>async def broadcast</code> will send the message to all the active <a id="_idIndexMarker608"/>connections except one, if<a id="_idIndexMarker609"/> specified.</p><p class="list-inset">The connection manager will then be used in the chat WebSocket endpoint.</p></li> <li>Let’s create the WebSocket endpoint in a separate module called <code>chat.py</code>. Let’s initialize the connection manager:<pre class="source-code">
from app.ws_manager import ConnectionManager
conn_manager = ConnectionManager()</pre><p class="list-inset">Then we define the router:</p><pre class="source-code">from fastapi import APIRouter
router = APIRouter()</pre><p class="list-inset">And finally, we can define the WebSocket endpoint:</p><pre class="source-code">from fastapi import WebSocket, WebSocketDisconnect
@router.websocket("/chatroom/{username}")
async def chatroom_endpoint(
    websocket: WebSocket, username: str
):
    await conn_manager.connect(websocket)
    await conn_manager.broadcast(
        f"{username} joined the chat",
        exclude=websocket,
    )
    try:
        while True:
            data = await websocket.receive_text()
            await conn_manager.broadcast(
                {"sender": username, "message": data},
                exclude=websocket,
            )
            await conn_manager.send_personal_message(
                {"sender": "You", "message": data},
                websocket,
            )
    except WebSocketDisconnect:
        conn_manager.disconnect(websocket)
        await connection_manager.broadcast(
            {
                "sender": "system",
                "message": f"Client #{username} "
                "left the chat",
            }
        )</pre></li> <li>After a new client joins a chat, the connection manager sends a message to all chat participants to notify them <a id="_idIndexMarker610"/>of the new arrival. The endpoint uses the <code>username</code> path parameter <a id="_idIndexMarker611"/>to retrieve the client’s name. Don’t forget to add the router to the FastAPI object in the <code>main.py</code> file:<pre class="source-code">
<strong class="bold">from app.chat import router as chat_router</strong>
# rest of the code
app = FastAPI()
<code>chatroom.xhtml</code> should be stored in a <code>templates</code> folder in the project root. We will keep the page simple with the JavaScript tag embedded.</p><p class="list-inset">The HTML part will look like this:</p><pre class="source-code">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Chat&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;WebSocket Chat&lt;/h1&gt;
    &lt;h2&gt;Your ID: &lt;span id="ws-id"&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;form action="" onsubmit="sendMessage(event)"&gt;
      &lt;input
        type="text"
        id="messageText"
        autocomplete="off"
      /&gt;
      &lt;button&gt;Send&lt;/button&gt;
    &lt;/form&gt;
    &lt;ul id="messages"&gt;&lt;/ul&gt;
    &lt;script&gt;
        &lt;!—content of js script --&gt;
    &lt;script/&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p class="list-inset">The <code>&lt;script&gt;</code> tag will contain the Javascript code that will connect to the WebSocket <code>/chatroom/{username}</code> endpoint <a id="_idIndexMarker613"/>with the client name as a parameter, send the message from the<a id="_idIndexMarker614"/> client page, receive messages from the server, and render the message text on the page in the messages list section.</p><p class="list-inset">You can find an example in the GitHub repository, in the <code>templates/chatroom.xhtml</code> file. Feel free to make your own version or download it.</p></li> <li>To conclude, we need to <a id="_idIndexMarker615"/>build the endpoint that returns the HTML page. We can build it in the same <code>chat.py</code> module:<pre class="source-code">
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from app.ws_manager import ConnectionManager
conn_manager = ConnectionManager()
templates = Jinja2Templates(directory="templates")
@router.get("/chatroom/{username}")
async def chatroom_page_endpoint(
    request: Request, username: str
) -&gt; HTMLResponse:
    return templates.TemplateResponse(
        request=request,
        name="chatroom.xhtml",
        context={"username": username},
    )</pre></li> </ol>
<p>The endpoint will take as a path parameter the username of the client that will show in the chat conversation.</p>
<p>You have set up a basic chat<a id="_idIndexMarker616"/> room within your FastAPI application with the WebSockets protocol. You only have to spin up the server with <code>uvicorn app.main:app</code> and connect to <code>http://localhost:8000/chatroom/your-username</code> from your browser. Then, from another page, connect to the same address with a different username and start exchanging messages between the<a id="_idIndexMarker617"/> two browsers.</p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor317"/>How it works…</h2>
<p>When connecting to the <code>GET /chatroom/{username}</code> endpoint address (<code>http://localhost:8000/chatroom/{username}</code>), the server will use the username to render the HTML page customized to the username.</p>
<p>The HTML will contain the code to<a id="_idIndexMarker618"/> make the connection to the <code>/chatroom</code> WebSocket endpoint and create a new WebSocket connection for each user.</p>
<p>The endpoint will then use the <code>ConnectionManager()</code> connection manager object to exchange messages between all clients through the HTML page.</p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor318"/>See also</h2>
<p>We have used a basic feature of the Jinja2 templating library. However, you can free your creativity and discover the potential of this package by looking at the documentation:</p>
<ul>
<li><em class="italic">Jinja2 </em><em class="italic">Documentation</em>: <a href="https://jinja.palletsprojects.com/en/3.1.x/">https://jinja.palletsprojects.com/en/3.1.x/</a></li>
</ul>
<h1 id="_idParaDest-316"><a id="_idTextAnchor319"/>Optimizing WebSocket performance</h1>
<p>WebSocket connections provide a powerful mechanism for real-time communication between clients and servers. To ensure the optimal performance and scalability of WebSocket applications, it’s essential to implement effective optimization techniques and a way to measure them. In this<a id="_idIndexMarker619"/> recipe, we will see how to benchmark WebSocket endpoints to test the number of connections supported by the connection and suggest practical tips and techniques to optimize WebSocket performance in your FastAPI applications.</p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor320"/>Getting ready</h2>
<p>Besides knowledge of how to set up a WebSocket endpoint, we will use the <em class="italic">Implementing chat functionality with WebSockets</em> recipe to benchmark the traffic supported. You can also follow the recipe by applying the strategy to your application.</p>
<p>Whether you apply it to your application or the chat functionality, it can be useful to include some message logs to be printed during the endpoint execution.</p>
<p>For example, for the WebSocket <code>/chatroom/{username}</code> endpoint, you can add a log after each message broadcast as <a id="_idIndexMarker620"/>follows:</p>
<pre class="source-code">
<strong class="bold">import logging</strong>
<strong class="bold">logger = logging.getLogger("uvicorn")</strong>
@router.websocket("/chatroom/{username}")
async def chatroom_endpoint(
    websocket: WebSocket, username: str
):
    await conn_manager.connect(websocket)
    await conn_manager.broadcast(
        # method's parameters
    )
<strong class="bold">    logger.info(f"{username} joined the chat")</strong>
    try:
        while True:
            data = await websocket.receive_text()
            await conn_manager.broadcast(
                # method's parameters
            )
            await conn_manager.send_personal_message(
                # method's parameters
            )
<strong class="bold">            logger.info(</strong>
<strong class="bold">                f"{username} says: {data}"</strong>
<strong class="bold">            )</strong>
    except WebSocketDisconnect:
        conn_manager.disconnect(websocket)
        await conn_manager.broadcast(
            # method's paramters
        )
<strong class="bold">        logger.info(f"{username} left the chat")</strong></pre> <p>We are now ready to create a <a id="_idIndexMarker621"/>benchmark script to test our chat functionality.</p>
<h2 id="_idParaDest-318"><a id="_idTextAnchor321"/>How to do it…</h2>
<p>Let’s create the script file under the root folder and call it <code>benchmark_websocket.py</code>. A typical benchmark script should do the following tasks:</p>
<ul>
<li>Define a function to run the FastAPI server</li>
<li>Define another function to connect <em class="italic">n</em> number of clients of the WebSocket endpoint and exchange a certain number of messages</li>
<li>Wrap up the previous steps by running the server in a separate process and running the clients</li>
</ul>
<p>Here are the steps to create the script:</p>
<ol>
<li>Let’s start by defining a function to run our server:<pre class="source-code">
import uvicorn
from app.main import app
def run_server():
    uvicorn.run(app)</pre><p class="list-inset">The <code>run_server</code> function is an alternative to the command-line <code>uvicorn app.main:app</code> command <a id="_idIndexMarker622"/>we are used to running from the terminal.</p></li> <li>Now let’s define a function that will create a certain number of clients that will connect to the WebSocket endpoint and exchange some messages:<pre class="source-code">
import asyncio
from websockets import connect
async def connect_client(
    n: int, n_messages: int = 3
):
    async with connect(
        f"ws://localhost:8000/chatroom/user{n}",
    ) as client:
        for _ in range(n_messages):
            await client.send(
                f"Hello World from user{n}"
            )
            await asyncio.sleep(n * 0.1)
        await asyncio.sleep(2)</pre><p class="list-inset"> To simulate concurrent connection patterns, we use an <code>async def</code> function. This will enable us to evaluate the server’s performance under the high load of simultaneous requests to the endpoint.</p><p class="list-inset">Furthermore, we added some asynchronous sleeping time (<code>asyncio.sleep</code>) between messages to simulate the human behavior of the chat’s client.</p></li> <li>Then, we can execute all the<a id="_idIndexMarker623"/> previous functions in a single overall <code>async def main</code> function as follows:<pre class="source-code">
import multiprocessing
async def main(n_clients: int = 10):
    p = multiprocessing.Process(target=run_server)
    p.start()
    await asyncio.sleep(1)
    connections = [
        connect_client(n) for n in range(n_clients)
    ]
    await asyncio.gather(*connections)
    await asyncio.sleep(1)
    p.terminate()</pre><p class="list-inset">The function creates a process to spin up the server, start it, wait some time to finish the startup, and simultaneously run all the clients to call the server.</p></li> <li>Finally, to make it run, we need to pass it to the event loop if it is run as a script. We can do it like this:<pre class="source-code">
if __name__ == "__main__":
    asyncio.run(main())</pre></li> </ol>
<p>To run the script, simply run it as <a id="_idIndexMarker624"/>a Python script from the command line:</p>
<pre class="console">
<code>n_clients</code>, you will probably see all the messages flowing on the terminal. However, by increasing <code>n_clients</code>, depending on your machine, at some point, the script will not be able to run anymore and you will see socket connection errors popping up. That means that you passed the limit to support new connections with your endpoint.</p>
<p>What we did is the core of a basic script to benchmark. You can further expand the script based on your needs by adding timing or parametrization to have a broader view of your application’s capabilities.</p>
<p>You can also do the same by using dedicated test frameworks, similar to what we did in the <em class="italic">Performance testing for </em><em class="italic">high traffic</em><em class="italic"> applications</em> recipe in <a href="B21025_05.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Testing and Debugging FastAPI Applications</em>, for HTTP traffic.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor322"/>There’s more…</h2>
<p>Benchmarking your WebSocket is only the first step to optimize your application performance. Here is a checklist of<a id="_idIndexMarker625"/> actions that you can take to improve your application performance and reduce errors:</p>
<ul>
<li><code>TestClient</code> also supports WebSocket connections, so use it to ensure that the behavior of the endpoint is the one expected and does not change during the development process.</li>
<li><code>try/except</code> blocks to handle specific error conditions. Also, when possible, use <code>async for</code> over <code>while True</code> when managing message exchanges. This will automatically capture and treat disconnection errors.</li>
<li><strong class="bold">Use connection pool managers</strong>: Connection pool managers improve performance and code <a id="_idIndexMarker626"/>maintainability when handling multiple clients, such as in chat applications.</li>
</ul>
<h2 id="_idParaDest-320"><a id="_idTextAnchor323"/>See also</h2>
<p>You can see more on unit testing WebSockets with FastAPI in the official documentation:</p>
<ul>
<li><em class="italic">Testing WebSockets in </em><em class="italic">FastAPI</em>: <a href="https://fastapi.tiangolo.com/advanced/testing-websockets/">https://fastapi.tiangolo.com/advanced/testing-websockets/</a></li>
</ul>
<h1 id="_idParaDest-321"><a id="_idTextAnchor324"/>Securing WebSocket connections with OAuth2</h1>
<p>Securing WebSocket connections is<a id="_idIndexMarker627"/> paramount to safeguarding the privacy and security of user interactions in real-time applications. By implementing authentication and access control mechanisms, developers can <a id="_idIndexMarker628"/>mitigate risks associated with unauthorized access, eavesdropping, and data tampering. In this recipe, we will see how to create a secure WebSocket connection endpoint with OAuth2 token authorization in your FastAPI applications.</p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor325"/>Getting ready</h2>
<p>To follow the recipe, you should already know how to set up a basic WebSocket endpoint – explained in the <em class="italic">Setting up WebSockets in FastAPI</em> recipe in this chapter.</p>
<p>Furthermore, we are going to use <strong class="bold">OAuth2</strong> with a <a id="_idIndexMarker629"/>password and a bearer token. We will apply the same strategy we used to secure HTTP endpoints in the <em class="italic">Securing your API with OAuth2</em> recipe in <a href="B21025_03.xhtml#_idTextAnchor091"><em class="italic">Chapter 3</em></a>, <em class="italic">Building RESTful APIs with FastAPI</em>. Feel free to have a look before starting the recipe.</p>
<p>Before starting the recipe, let’s create a simple WebSocket endpoint, <code>/secured-ws</code>, in the <code>main.py</code> module:</p>
<pre class="source-code">
@app.websocket("/secured-ws")
async def secured_websocket(
    websocket: WebSocket,
    username: str
):
    await websocket.accept()
    await websocket.send_text(f"Welcome {username}!")
    async for data in websocket.iter_text():
        await websocket.send_text(
            f"You wrote: {data}"
        )</pre> <p>The endpoint will accept any connection with a parameter to specify the username. Then it will send a welcome <a id="_idIndexMarker630"/>message to the client and return each message received to the client.</p>
<p>The endpoint is insecure since it does not have any protection and can be easily reached. Let’s dive into the recipe to see how to protect it with OAuth2 authentication.</p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor326"/>How to do it…</h2>
<p>At the time of writing, there is no support for the <code>OAuth2PasswordBearer</code> class for WebSocket in FastAPI. This means that checking the bearer token in the headers for WebSocket is not as straightforward as it is<a id="_idIndexMarker631"/> for HTTP calls. However, we can create a WebSocket-specific class that is derived from the one used by HTTP to achieve the same functionality as follows.</p>
<ol>
<li>Let’s do it in a dedicated module under the <code>app</code> folder called <code>ws_password_bearer.py</code>:<pre class="source-code">
from fastapi import (
    WebSocket,
    WebSocketException,
    status,
)
from fastapi.security import OAuth2PasswordBearer
class OAuth2WebSocketPasswordBearer(
    OAuth2PasswordBearer
):
    async def __call__(
        self, websocket: WebSocket
    ) -&gt; str:
        authorization: str = websocket.headers.get(
            "authorization"
        )
        if not authorization:
            raise WebSocketException(
                code=status.HTTP_401_UNAUTHORIZED,
                reason="Not authenticated",
            )
        scheme, param = authorization.split()
        if scheme.lower() != "bearer":
            raise WebSocketException(
                code=status.HTTP_403_FORBIDDEN,
                reason=(
                    "Invalid authentication "
                    "credentials"
                ),
            )
        return param</pre><p class="list-inset">We will use it to create a <code>get_username_from_token</code> function to retrieve the username from<a id="_idIndexMarker632"/> the token. You can create the function in a<a id="_idIndexMarker633"/> dedicated module – <code>security.py</code>.</p></li> <li>Let’s define the <code>oauth2_scheme_for_ws</code> object:<pre class="source-code">
from app.ws_password_bearer import (
    OAuth2WebSocketPasswordBearer,
)
oauth2_scheme_for_ws = OAuth2WebSocketPasswordBearer(
    tokenUrl="/token"
)</pre></li> <li>The <code>tokenUrl</code> argument specifies the callback endpoint to call to retrieve the token. This endpoint should be built according to the token resolution you use. After that, we can create a function that retrieves the username from the token:<pre class="source-code">
def get_username_from_token(
    token: str = Depends(oauth2_scheme_for_ws),
) -&gt; str:
    user = fake_token_resolver(token)
    if not user:
        raise WebSocketException(
            code=status.HTTP_401_UNAUTHORIZED,
            reason=(
                "Invalid authentication credentials"
            )
        )
    return user.username</pre><p class="list-inset">The purpose of the <code>fake_token_resolver</code> function is <a id="_idIndexMarker634"/>to simulate the process of resolving a token. This function<a id="_idIndexMarker635"/> can be found in the <code>security.py</code> file in the GitHub repository of the chapter. Furthermore, the example contains only two users, <code>johndoe</code> and <code>janedoe</code>, who can be used later for testing. Also, the <code>security.py</code> module from the GitHub repository contains the <code>POST /token</code> endpoint to be used to retrieve the token.</p><p class="list-inset">However, it is important to <a id="_idIndexMarker636"/>mention that this function does not provide any actual security and it is only used for example purposes. In a production environment, it is recommended to use a <code>/secured-ws</code>, in the <code>main.py</code> module:<pre class="source-code">
<strong class="bold">from import Annotated</strong>
<strong class="bold">from fastapi import Depends</strong>
<strong class="bold">from app.security import get_username_from_token</strong>
@app.websocket("/secured-ws")
async def secured_websocket(
    websocket: WebSocket,
    username: Annotated[
<strong class="bold">        get_username_from_token, Depends()</strong>
    ]
):
    # rest of the endpoint</pre></li> </ol>
<p>This is all you need to build a secured WebSocket endpoint.</p>
<p>To test it, spin up the server<a id="_idIndexMarker638"/> from the terminal by running the following:</p>
<pre class="console">
$ uvicorn app.main:app</pre> <p>When attempting to connect to the WebSocket endpoint using Postman or another tool to the address <code>ws://localhost:8000/secured-ws</code>, an authorization error will occur, and the connection will be rejected before the handshake.</p>
<p>To allow the connection, we need to retrieve the token and pass it through the headers of the WebSocket request in <code>tokenized</code> string to the username. For example, for <code>johndoe</code>, the token would be <code>tokenizedjohndoe</code>.</p>
<p>Let’s pass it through the header. In Postman, you can pass the bearer token to the WebSocket request in the <code>Authorization</code> and value that will be <code>bearer tokenizedjohndoe</code>.</p>
<p>Now, if you try to connect, it should connect and you will be able to exchange messages with the endpoint.</p>
<p>You have just secured a WebSocket endpoint in FastAPI. By implementing OAuth2 authorization, you can enhance the security posture of your FastAPI applications and safeguard WebSocket communication against potential threats and vulnerabilities.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">Try to build a secure chat functionality where users need to log in to participate in the chat.</p>
<p class="callout">Tips: The endpoint that returns the HTML page should check for the bearer token in the cookies. If the cookie is not found or the bearer token is not valid, it should redirect the client to a login page that puts the token in the browser’s cookies.</p>
<p class="callout">You can use the <code>response.RedirectResponse</code> class from the <code>fastapi</code> package to handle redirections. The usage is quite straightforward and you can have a look at the documentation page at the link:</p>
<p class="callout"><a href="https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse">https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse</a>.</p>
<h2 id="_idParaDest-324"><a id="_idTextAnchor327"/>See also</h2>
<p>Integrating <code>OAuth2PasswordBearer</code>-like class is a current topic<a id="_idIndexMarker640"/> of interest, and it is expected to<a id="_idIndexMarker641"/> evolve quickly over time. You can follow the ongoing discussion in the FastAPI GitHub repository:</p>
<ul>
<li><em class="italic">OAuth2PasswordBearer with WebSocket </em><em class="italic">Discussion</em>: <a href="https://github.com/tiangolo/fastapi/discussions/8983">https://github.com/tiangolo/fastapi/discussions/8983</a></li>
</ul>
</div>
</div></body></html>