<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer013">
<h1 class="chapter-number" id="_idParaDest-292"><a id="_idTextAnchor295"/>9</h1>
<h1 id="_idParaDest-293"><a id="_idTextAnchor296"/>Working with WebSocket</h1>
<p>Real-time communication has become increasingly important in modern web applications, enabling interactive features such as chat, notifications, and live updates. In this chapter, we’ll explore the exciting world of WebSockets and how to leverage them effectively in FastAPI applications. From setting up WebSocket connections to implementing advanced features such as chat functionality and error handling, this chapter provides a comprehensive guide to building responsive, real-time communication features. By the end of the chapter, you will have the skills to create WebSockets and facilitate real-time communication in FastAPI applications, enabling interactive functionalities and dynamic <span class="No-Break">user experiences.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Setting up Websockets <span class="No-Break">in FastAPI</span></li>
<li>Sending and receiving messages <span class="No-Break">over WebSockets</span></li>
<li>Handling WebSocket connections <span class="No-Break">and disconnections</span></li>
<li>Handling WebSocket errors <span class="No-Break">and exceptions</span></li>
<li>Implementing chat functionality <span class="No-Break">with WebSocket</span></li>
<li>Optimizing <span class="No-Break">WebSocket performance</span></li>
<li>Securing WebSocket connections <span class="No-Break">with OAuth2</span></li>
</ul>
<h1 id="_idParaDest-294"><a id="_idTextAnchor297"/>Technical requirements</h1>
<p>To follow along with the WebSockets recipes, make sure you have the following essentials in <span class="No-Break">your setup:</span></p>
<ul>
<li><strong class="bold">Python</strong>: Install a Python version higher than 3.9 in <span class="No-Break">your environment.</span></li>
<li><strong class="bold">FastAPI</strong>: This should be installed with all the required dependencies. If you haven’t done it in the previous chapters, you can simply do it from <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> </ul>
<p>The code used in the chapter is hosted on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter09</span></a><span class="No-Break">.</span></p>
<p>It is recommended to set up a virtual environment for the project in the project root folder to efficiently manage dependencies and maintain <span class="No-Break">project isolation.</span></p>
<p>Within your virtual environment, you can install all the dependencies at once by using the <strong class="source-inline">requirements.txt</strong> file provided in the GitHub repository in the <span class="No-Break">project folder:</span></p>
<pre class="console">
$ pip install –r requirements.txt</pre> <p>Since the interactive Swagger documentation is limited at the time of writing, basic mastering of <strong class="bold">Postman</strong> or any other testing API is beneficial to test <span class="No-Break">our API.</span></p>
<p>Having basic knowledge of how <strong class="bold">WebSockets</strong> work can be beneficial, although it’s not necessary since the recipes will guide <span class="No-Break">you through.</span></p>
<p>For the <em class="italic">Implementing chat functionality with WebSockets</em> recipe, we will write some basic <strong class="bold">HTML</strong>, including some <span class="No-Break"><strong class="bold">Javascript</strong></span><span class="No-Break"> code.</span></p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor298"/>Setting up WebSockets in FastAPI</h1>
<p>WebSockets provide a powerful mechanism<a id="_idIndexMarker580"/> for establishing full-duplex communication channels between clients and servers, allowing real-time data exchange. In this recipe, you’ll learn how to establish a connection with WebSocket<a id="_idIndexMarker581"/> functionality in your FastAPI applications to enable interactive and <span class="No-Break">responsive communication.</span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor299"/>Getting ready</h2>
<p>Before diving into the recipe, ensure you have all the required packages in your environment. You can install them from the <strong class="source-inline">requirements.txt</strong> file provided in the GitHub repository or install it manually <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ pip install fastapi[all] websockets</pre> <p>Since the swagger documentation does not support WebSocket, we will use an external tool to test the WebSocket connection, such <span class="No-Break">as Postman.</span></p>
<p>You can find instructions on how to install it on the website: <a href="https://www.postman.com/downloads/"><span class="No-Break">https://www.postman.com/downloads/</span></a><span class="No-Break">.</span></p>
<p>The free community version will <a id="_idIndexMarker582"/>be enough to test <span class="No-Break">the recipes.</span></p>
<h2 id="_idParaDest-297"><a id="_idTextAnchor300"/>How to do it…</h2>
<p>Create the project root folder called <strong class="source-inline">chat_platform</strong>. we<a id="_idIndexMarker583"/> can create our <strong class="source-inline">app</strong> folder containing the <strong class="source-inline">main.py</strong> module. Let's build our simple application with a WebSocket endpoint <span class="No-Break">as follows.</span></p>
<ol>
<li>We can start by creating our server in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
from fastapi import FastAPI
app = FastAPI()</pre></li> <li>Then we can create the WebSocket endpoint to connect the client to the <span class="No-Break">chat room:</span><pre class="source-code">
from fastapi import WebSocket
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    await websocket.close()</pre><p class="list-inset">The endpoint establishes the connection with the client, sends a welcome message, and closes the connection. This is the most basic configuration of a <span class="No-Break">WebSocket endpoint.</span></p></li> </ol>
<p>That's it. To test it, spin up the server from the <span class="No-Break">command line:</span></p>
<pre class="console">
<strong class="bold">$ uvicorn app.main:app</strong></pre> <p>Then open Postman and create a <a id="_idIndexMarker584"/>new WebSocket request. Specify the server URL as <strong class="source-inline">ws://localhost:8000/ws</strong> and <a id="_idIndexMarker585"/>click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Connect</strong></span><span class="No-Break">.</span></p>
<p>In the <strong class="bold">Response</strong> panel, right<a id="_idIndexMarker586"/> below the URL form, you should see the list of events that happened during the connection. In particular, look for the message received by <span class="No-Break">the server:</span></p>
<pre class="console">
<strong class="bold">Welcome to the chat room! 12:37:19</strong></pre> <p>That means that the WebSocket endpoint has been created and <span class="No-Break">works properly.</span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor301"/>How it works…</h2>
<p>The <strong class="source-inline">websocket</strong> parameter in the WebSocket endpoint represents an individual WebSocket connection. By awaiting <strong class="source-inline">websocket.accept()</strong>, the server establishes the connection with the client (technically called an <strong class="bold">HTTP handshake</strong>). Then, <strong class="source-inline">websocket.send_text()</strong> sends a message to the<a id="_idIndexMarker587"/> client. Finally, <strong class="source-inline">websocket.close()</strong> closes <span class="No-Break">the connection.</span></p>
<p>The three events are listed in<a id="_idIndexMarker588"/> the <strong class="bold">Response</strong> panel <span class="No-Break">of Postman.</span></p>
<p>Although not very useful from a practical point of view, this configuration is the bare minimum setup for a WebSocket connection. In the next recipe, we will see how to exchange messages between the client and the server through a <span class="No-Break">WebSocket endpoint.</span></p>
<h2 id="_idParaDest-299"><a id="_idTextAnchor302"/>See also</h2>
<p>You can check how to create a WebSocket endpoint on the FastAPI official <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">FastAPI </em><span class="No-Break"><em class="italic">WebSockets</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/websockets/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/websockets/</span></a></li>
</ul>
<p>At the time of writing, the Swagger documentation does not support WebSocket endpoints. If you spin up the<a id="_idIndexMarker589"/> server and open Swagger at <strong class="source-inline">http://localhost:8000/docs</strong>, you<a id="_idIndexMarker590"/> won’t see the endpoint we have just created. A discussion is ongoing on the FastAPI GitHub repository – you can follow it at the <span class="No-Break">following URL:</span></p>
<ul>
<li><em class="italic">FastAPI WebSocket Endpoints Documentation </em><span class="No-Break"><em class="italic">Discussion</em></span><span class="No-Break">: </span><a href="https://github.com/tiangolo/fastapi/discussions/7713"><span class="No-Break">https://github.com/tiangolo/fastapi/discussions/7713</span></a></li>
</ul>
<h1 id="_idParaDest-300"><a id="_idTextAnchor303"/>Sending and receiving messages over WebSockets</h1>
<p>WebSocket connections enable bidirectional communication between clients and servers, allowing the real-time exchange <a id="_idIndexMarker591"/>of messages. This recipe will bring us one step closer to creating our chat application by showing how to enable the FastAPI application to receive messages over WebSockets and print them to the <span class="No-Break">terminal output.</span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor304"/>Getting ready</h2>
<p>Before starting the recipe, make sure you know how to set up a <strong class="bold">WebSocket</strong> connection in <strong class="bold">FastAPI</strong>, as explained in the previous recipe. Also, you will need a tool to test WebSockets, such as <strong class="bold">Postman</strong>, on <span class="No-Break">your machine.</span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor305"/>How to do it…</h2>
<p>We will enable our chatroom endpoint to receive messages from the client to print them to the <span class="No-Break">standard output.</span></p>
<p>Let’s start by defining the logger. We will use the logger from the <strong class="source-inline">uvicorn</strong> package (as we did in other recipes – see, for example, <em class="italic">Creating custom middlewares</em> in <a href="B21025_08.xhtml#_idTextAnchor262"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Advanced Features and Best Practices</em>), which is the one used by FastAPI as well. In <strong class="source-inline">main.py</strong>, let’s write <span class="No-Break">the following:</span></p>
<pre class="source-code">
import logging
logger = logging.getLogger("uvicorn")</pre> <p>Now let’s modify the <strong class="source-inline">ws_endpoint</strong> <span class="No-Break">function endpoint:</span></p>
<pre class="source-code">
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
<strong class="bold">    while True:</strong>
<strong class="bold">        data = await websocket.receive_text()</strong>
<strong class="bold">        logger.info(f"Message received: {data}")</strong>
<strong class="bold">        await websocket.send_text("Message received!")</strong></pre> <p>You might have noticed that we have removed <strong class="source-inline">websocket.close()</strong> call from the previous recipe and used an infinite <strong class="source-inline">while</strong> loop. This allows the server side to continuously receive the message from the client and print it to the console without closing the connection. In this case, the connection can be closed only by <span class="No-Break">the client.</span></p>
<p>This is all you need to read<a id="_idIndexMarker592"/> messages from the client and send it to the <span class="No-Break">terminal output.</span></p>
<p>The server initiates a connection request when the client call the endpoint. With the <strong class="source-inline">websocket.receive_text()</strong> function, the server opens the connection and it is ready to receive the message from the client. The message is stored into the <strong class="source-inline">data</strong> variable and it is printed to terminal output. Then the server sends a confirmation message to <span class="No-Break">the client.</span></p>
<p>Let’s test it. Spin up the server by running <strong class="source-inline">uvicorn app.main:app</strong> from the command line and open Postman. Then apply the <span class="No-Break">following steps.</span></p>
<ol>
<li>Create a new WebSocket request, and connect to the <span class="No-Break"><strong class="source-inline">ws://localhost:8000/ws</strong></span><span class="No-Break"> address.</span><p class="list-inset">Once the connection is established, you will see on the terminal output <span class="No-Break">the message:</span></p><pre class="source-code">
<strong class="bold">INFO: connection open</strong></pre><p class="list-inset">In the response messages of the request you <span class="No-Break">will see:</span></p><pre class="source-code"><strong class="bold">Welcome to the chat room! 14:45:19</strong></pre></li> <li>From Postman, you can start sending messages through the <strong class="bold">Message</strong> panel below the <strong class="bold">URL</strong> field input. For the example try to the send the following message: <strong class="source-inline">Hello </strong><span class="No-Break"><strong class="source-inline">FastAPI application</strong></span><span class="No-Break">.</span><p class="list-inset">On the output terminal you will the <span class="No-Break">following message:</span></p><pre class="source-code">
<strong class="bold">INFO: Message received: Hello FastAPI application</strong></pre><p class="list-inset">While in the messages <a id="_idIndexMarker593"/>section of the client request you will see the <span class="No-Break">new message:</span></p><pre class="source-code"><strong class="bold">Message received! 14:46:20</strong></pre></li> <li>You can then close the connection from the client by clicking on the <strong class="bold">Disconnect</strong> button to the right of the WebSocket <span class="No-Break"><strong class="bold">URL</strong></span><span class="No-Break"> field.</span></li>
</ol>
<p>By enabling the server to receive messages from the client, you have just enabled bidirectional communication between the client and server through <span class="No-Break">a WebSocket.</span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor306"/>See also</h2>
<p>The <strong class="source-inline">Fastapi.WebSocket</strong> instance is, in reality, a <strong class="source-inline">starlette.WebSocket</strong> class from the <strong class="bold">Starlette</strong> library. You can do <a id="_idIndexMarker594"/>more, such as validating messages as JSON or binary, by using the dedicated methods (the <strong class="source-inline">send_json</strong> or <span class="No-Break"><strong class="source-inline">receive_json</strong></span><span class="No-Break"> methods).</span></p>
<p>Check more on the official Starlette <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Starlette </em><span class="No-Break"><em class="italic">Websockets</em></span><span class="No-Break">: </span><a href="https://www.starlette.io/websockets/"><span class="No-Break">https://www.starlette.io/websockets/</span></a></li>
</ul>
<h1 id="_idParaDest-304"><a id="_idTextAnchor307"/>Handling WebSocket connections and disconnections</h1>
<p>When a client establishes a WebSocket connection with a <strong class="bold">FastAPI</strong> server, it’s crucial to handle the lifecycle of these connections appropriately. This includes accepting incoming connections, maintaining active connections, and handling disconnections gracefully to ensure smooth<a id="_idIndexMarker595"/> communication between the client and server. In this recipe, we’ll explore how to effectively manage WebSocket connections and<a id="_idIndexMarker596"/> gracefully <span class="No-Break">handle disconnections.</span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor308"/>Getting ready</h2>
<p>To follow the recipe, you will need to have <strong class="bold">Postman</strong> or any other tool to test WebSocket connections. Also, you need to already have a WebSocket endpoint implemented in your application. Check the previous two recipes if that is not <span class="No-Break">the case.</span></p>
<h2 id="_idParaDest-306"><a id="_idTextAnchor309"/>How to do it…</h2>
<p>We will see how to manage the following <span class="No-Break">two situations:</span></p>
<ul>
<li><span class="No-Break">Client-side disconnection</span></li>
<li><span class="No-Break">Server-side disconnection</span></li>
</ul>
<p>Let’s have a look at each of these situations <span class="No-Break">in detail.</span></p>
<h3>Client-side disconnection</h3>
<p>You might have noticed in the <em class="italic">Sending and receiving messages over WebSockets</em> recipe that if the connection is closed <a id="_idIndexMarker597"/>from the client (e.g., from Postman) on the<a id="_idIndexMarker598"/> server console, a <strong class="source-inline">WebSocketDisconnect</strong> exception <span class="No-Break">propagates, uncaptured.</span></p>
<p>This is because the disconnection from the client side should be properly handled in a <span class="No-Break"><strong class="source-inline">try-except</strong></span><span class="No-Break"> block.</span></p>
<p>Let’s adjust the endpoint to take this into account. In the <strong class="source-inline">main.py</strong> module, we modify the <strong class="source-inline">/ws</strong><strong class="source-inline"> </strong>endpoint <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from fastapi.websockets import WebSocketDisconnect
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
<strong class="bold">    try:</strong>
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
<strong class="bold">    except WebSocketDisconnect:</strong>
<strong class="bold">        logger.warning(</strong>
<strong class="bold">            "Connection closed by the client"</strong>
<strong class="bold">        )</strong></pre> <p>If you rerun the server, connect to the WebSocket endpoint, <strong class="source-inline">/ws</strong>, and then disconnect, you won’t see the error <a id="_idIndexMarker599"/><span class="No-Break">propagation anymore.</span></p>
<h3>Server-side disconnection</h3>
<p>In this situation, the connection is closed <a id="_idIndexMarker600"/>by the server. Suppose the server will close the connection based on a specific message such as the <strong class="source-inline">"disconnect"</strong> text string, <span class="No-Break">for example.</span></p>
<p>Let’s implement it in the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">ws</strong></span><span class="No-Break"> endpoint:</span></p>
<pre class="source-code">
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    while True:
        data = await websocket.receive_text()
        logger.info(f"Message received: {data}")
<strong class="bold">        if data == "disconnect":</strong>
<strong class="bold">            logger.warn("Disconnecting...")</strong>
<strong class="bold">            await websocket.close()</strong>
<strong class="bold">            break</strong></pre> <p>All we need is the checking condition of the <strong class="source-inline">data</strong> string content to then call the <strong class="source-inline">websocket.close</strong> method and exit the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> loop.</span></p>
<p>If you run the server, try to <a id="_idIndexMarker601"/>connect to the WebSocket <strong class="source-inline">/ws</strong> endpoint, and send the <strong class="source-inline">"disconnect"</strong> string as a message, the connection will be closed by <span class="No-Break">the server.</span></p>
<p>You have seen how to manage disconnection and connection handshakes for a WebSocket endpoint, however, we still need to manage the right status code and messages for each. Let’s check this in the <span class="No-Break">following recipe.</span></p>
<h1 id="_idParaDest-307"><a id="_idTextAnchor310"/>Handling WebSocket errors and exceptions</h1>
<p>WebSocket connections are susceptible to various errors and exceptions that can occur during the lifecycle of a connection. Common issues include connection failures, message parsing errors, and unexpected<a id="_idIndexMarker602"/> disconnections. Properly handling errors and correctly communicating with the client is essential to maintaining a responsive and resilient WebSocket-based application. In this recipe, we’ll explore how to handle WebSocket errors and exceptions effectively in <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor311"/>Getting ready</h2>
<p>The recipe will show how to manage WebSocket errors that can happen for a specific endpoint. We will showcase how to improve the <strong class="source-inline">/ws</strong> endpoint defined in the <em class="italic">Handling WebSocket connections and </em><span class="No-Break"><em class="italic">disconnections</em></span><span class="No-Break"> recipe.</span></p>
<h2 id="_idParaDest-309"><a id="_idTextAnchor312"/>How to do it…</h2>
<p>The way the <strong class="source-inline">/ws</strong> endpoint is coded in the previous recipe returns the same response code and message when the server closes the connection. Just like for HTTP responses, FastAPI allows you to personalize the response to return a more meaningful message to <span class="No-Break">the client.</span></p>
<p>Let’s see how to do it. You can use a solution like <span class="No-Break">the following:</span></p>
<pre class="source-code">
<strong class="bold">from fastapi import status</strong>
@app.websocket("/ws")
async def chatroom(websocket: WebSocket):
    if not websocket.headers.get("Authorization"):
        return await websocket.close()
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
<strong class="bold">            if data == "disconnect":</strong>
<strong class="bold">                logger.warn("Disconnecting...")</strong>
<strong class="bold">                return await websocket.close(</strong>
<strong class="bold">                    code=status.WS_1000_NORMAL_CLOSURE,</strong>
<strong class="bold">                    reason="Disconnecting...",</strong>
<strong class="bold">                )</strong>
    except WebSocketDisconnect:
        logger.warn("Connection closed by the client")</pre> <p>We have specified to the <strong class="source-inline">websocket.close</strong> method a status code and reason that will be transmitted to <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker603"/></span><span class="No-Break">client.</span></p>
<p>If we now spin up the server and send the disconnect message from the client, you will see a disconnection log message in the response window, <span class="No-Break">like this:</span></p>
<pre class="console">
Disconnected from localhost:8000/ws 14:09:08
1000 Normal Closure:  Disconnecting...</pre> <p>This is all you need to gracefully disconnect your <span class="No-Break">WebSocket connection.</span></p>
<h3>Alternative solution</h3>
<p>Similarly to how an <strong class="source-inline">HTTPException</strong> instance is rendered for HTTP requests (see the <em class="italic">Handling errors and exceptions</em> recipe in <a href="B21025_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">First Steps with FastAPI</em>), FastAPI also enables the use of <strong class="source-inline">WebSocketException</strong> for WebSocket connections, which is rendered automatically as <span class="No-Break">a response.</span></p>
<p>To better understand, imagine we want to disconnect the client if they write something that isn’t allowed – for<a id="_idIndexMarker604"/> example, the <strong class="source-inline">"bad message"</strong> text string. Let’s modify the <span class="No-Break">chatroom endpoint:</span></p>
<pre class="source-code">
@app.websocket("/ws")
async def ws_endpoint(websocket: WebSocket):
    await websocket.accept()
    await websocket.send_text(
        "Welcome to the chat room!"
    )
    try:
        while True:
            data = await websocket.receive_text()
            logger.info(f"Message received: {data}")
            if data == "disconnect":
                logger.warn("Disconnecting...")
                return await websocket.close(
                    code=status.WS_1000_NORMAL_CLOSURE,
                    reason="Disconnecting...",
                )
<strong class="bold">            if "bad message" in data:</strong>
<strong class="bold">                raise WebSocketException(</strong>
<strong class="bold">                    code=status.WS_1008_POLICY_VIOLATION,</strong>
<strong class="bold">                    reason="Inappropriate message"</strong>
<strong class="bold">                )</strong>
    except WebSocketDisconnect:
        logger.warn("Connection closed by the client")</pre> <p>If you spin up the server and try to send whatever message contains the <strong class="source-inline">"bad message"</strong> string, the client will be disconnected. Furthermore, on the <strong class="bold">Response</strong> panel section of Postman of your WebSocket connection you will see the following <span class="No-Break">log message:</span></p>
<pre class="console">
Disconnected from localhost:8000/ws 14:51:40
1008 Policy Violation: Inappropriate message</pre> <p>You have just seen how to<a id="_idIndexMarker605"/> communicate WebSocket errors to the client by raising the appropriate exception. You can use this strategy for a variety of errors that can arise while running the application and have to be correctly communicated to the <span class="No-Break">API consumer.</span></p>
<h2 id="_idParaDest-310"><a id="_idTextAnchor313"/>See also</h2>
<p>WebSocket is a relatively new protocol compared to HTTP, so it is still evolving with time. Although status codes are not extensively used, like for HTTP, you can find definitions of WebSockets codes at the <span class="No-Break">following links:</span></p>
<ul>
<li><em class="italic">WebSocket Close Code Number </em><span class="No-Break"><em class="italic">Registry</em></span><span class="No-Break">: </span><a href="https://www.iana.org/assignments/websocket/websocket.xml#close-code-number"><span class="No-Break">https://www.iana.org/assignments/websocket/websocket.xml#close-code-number</span></a></li>
</ul>
<p>You can also find a list of the compatibility of WebSocket events for browsers on the <span class="No-Break">following page:</span></p>
<ul>
<li><em class="italic">WebSocket </em><span class="No-Break"><em class="italic">CloseEvent</em></span><span class="No-Break">: </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent</span></a></li>
</ul>
<p>Furthermore, the <strong class="source-inline">WebSocketException</strong> class in FastAPI is documented at the official <span class="No-Break">documentation link:</span></p>
<ul>
<li><em class="italic">FastAPI WebSocketExcpetion API </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException"><span class="No-Break">https://fastapi.tiangolo.com/reference/exceptions/#fastapi.WebSocketException</span></a></li>
</ul>
<h1 id="_idParaDest-311"><a id="_idTextAnchor314"/>Implementing chat functionality with WebSockets</h1>
<p>Real-time chat functionality is<a id="_idIndexMarker606"/> a common feature in many modern web applications, enabling users to communicate instantly with each other. In this recipe, we’ll <a id="_idIndexMarker607"/>explore how to implement chat functionality using WebSockets in <span class="No-Break">FastAPI applications.</span></p>
<p>By leveraging WebSockets, we will create a bidirectional communication channel between the server and multiple clients, allowing messages to be sent and received in <span class="No-Break">real time.</span></p>
<h2 id="_idParaDest-312"><a id="_idTextAnchor315"/>Getting ready</h2>
<p>To follow the recipe, you need to have a good understanding of WebSockets and know how to build a WebSocket endpoint <span class="No-Break">using FastAPI.</span></p>
<p>Additionally, having some basic knowledge of HTML and JavaScript can help create simple web pages for the application. The recipe we’ll be using is the foundation of our <span class="No-Break">chat application.</span></p>
<p>Also, we will use the <strong class="source-inline">jinja2</strong> package to apply basic templating for the HTML page. Make sure to have it in your environment. If you didn’t install packages with <strong class="source-inline">requirements.txt</strong>, install <strong class="source-inline">jinja2</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">pip</strong></span><span class="No-Break">:</span></p>
<pre class="console">
$ pip install jinja2</pre> <p>Once the installation is complete, we are ready to start with <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor316"/>How to do it…</h2>
<p>To build the application, we will need to build three core pieces – the WebSocket connections manager, the WebSocket endpoint, and the chat <span class="No-Break">HTML page:</span></p>
<ol>
<li>Let’s start by building the connection manager. The role of the connection manager is to keep track of open WebSocket connections and broadcast messages to active ones. Let’s define the <strong class="source-inline">ConnectionManager</strong> class in a dedicated <strong class="source-inline">ws_manager.py</strong> module under the <span class="No-Break"><strong class="source-inline">app</strong></span><span class="No-Break"> folder:</span><pre class="source-code">
import asyncio
from fastapi import WebSocket
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    async def send_personal_message(
        self, message: dict, websocket: WebSocket
    ):
        await websocket.send_json(message)
    async def broadcast(
        self, message: json, exclude: WebSocket = None
    ):
        tasks = [
            connection.send_json(message)
            for connection in self.active_connections
            if connection != exclude
        ]
        await asyncio.gather(*tasks)</pre><p class="list-inset">The <strong class="source-inline">async def connect</strong> method will be responsible for the handshake and adding the WebSocket to the list of active ones. The <strong class="source-inline">def disconnect</strong> method will remove the WebSocket from the list of active connections. The <strong class="source-inline">async def send_personal_message</strong> method will send a message to a specific WebSocket. Finally, <strong class="source-inline">async def broadcast</strong> will send the message to all the active <a id="_idIndexMarker608"/>connections except one, <span class="No-Break">if</span><span class="No-Break"><a id="_idIndexMarker609"/></span><span class="No-Break"> specified.</span></p><p class="list-inset">The connection manager will then be used in the chat <span class="No-Break">WebSocket endpoint.</span></p></li> <li>Let’s create the WebSocket endpoint in a separate module called <strong class="source-inline">chat.py</strong>. Let’s initialize the <span class="No-Break">connection manager:</span><pre class="source-code">
from app.ws_manager import ConnectionManager
conn_manager = ConnectionManager()</pre><p class="list-inset">Then we define <span class="No-Break">the router:</span></p><pre class="source-code">from fastapi import APIRouter
router = APIRouter()</pre><p class="list-inset">And finally, we can define the <span class="No-Break">WebSocket endpoint:</span></p><pre class="source-code">from fastapi import WebSocket, WebSocketDisconnect
@router.websocket("/chatroom/{username}")
async def chatroom_endpoint(
    websocket: WebSocket, username: str
):
    await conn_manager.connect(websocket)
    await conn_manager.broadcast(
        f"{username} joined the chat",
        exclude=websocket,
    )
    try:
        while True:
            data = await websocket.receive_text()
            await conn_manager.broadcast(
                {"sender": username, "message": data},
                exclude=websocket,
            )
            await conn_manager.send_personal_message(
                {"sender": "You", "message": data},
                websocket,
            )
    except WebSocketDisconnect:
        conn_manager.disconnect(websocket)
        await connection_manager.broadcast(
            {
                "sender": "system",
                "message": f"Client #{username} "
                "left the chat",
            }
        )</pre></li> <li>After a new client joins a chat, the connection manager sends a message to all chat participants to notify them <a id="_idIndexMarker610"/>of the new arrival. The endpoint uses the <strong class="source-inline">username</strong> path parameter <a id="_idIndexMarker611"/>to retrieve the client’s name. Don’t forget to add the router to the FastAPI object in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> file:</span><pre class="source-code">
<strong class="bold">from app.chat import router as chat_router</strong>
# rest of the code
app = FastAPI()
<strong class="bold">app.include_router(chat_router)</strong></pre><p class="list-inset">Once the WebSocket endpoint is ready, we can create the endpoint to return the HTML <span class="No-Break">chat page.</span></p></li> <li>The page endpoint will return an HTML page <a id="_idIndexMarker612"/>rendered <span class="No-Break">with </span><span class="No-Break"><strong class="bold">Jinja2</strong></span><span class="No-Break">.</span><p class="list-inset">The HTML chat page named <strong class="source-inline">chatroom.xhtml</strong> should be stored in a <strong class="source-inline">templates</strong> folder in the project root. We will keep the page simple with the JavaScript <span class="No-Break">tag embedded.</span></p><p class="list-inset">The HTML part will look <span class="No-Break">like this:</span></p><pre class="source-code">
&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Chat&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;WebSocket Chat&lt;/h1&gt;
    &lt;h2&gt;Your ID: &lt;span id="ws-id"&gt;&lt;/span&gt;&lt;/h2&gt;
    &lt;form action="" onsubmit="sendMessage(event)"&gt;
      &lt;input
        type="text"
        id="messageText"
        autocomplete="off"
      /&gt;
      &lt;button&gt;Send&lt;/button&gt;
    &lt;/form&gt;
    &lt;ul id="messages"&gt;&lt;/ul&gt;
    &lt;script&gt;
        &lt;!—content of js script --&gt;
    &lt;script/&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p class="list-inset">The <strong class="source-inline">&lt;script&gt;</strong> tag will contain the Javascript code that will connect to the WebSocket <strong class="source-inline">/chatroom/{username}</strong> endpoint <a id="_idIndexMarker613"/>with the client name as a parameter, send the message from the<a id="_idIndexMarker614"/> client page, receive messages from the server, and render the message text on the page in the messages <span class="No-Break">list section.</span></p><p class="list-inset">You can find an example in the GitHub repository, in the <strong class="source-inline">templates/chatroom.xhtml</strong> file. Feel free to make your own version or <span class="No-Break">download it.</span></p></li> <li>To conclude, we need to <a id="_idIndexMarker615"/>build the endpoint that returns the HTML page. We can build it in the same <span class="No-Break"><strong class="source-inline">chat.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from app.ws_manager import ConnectionManager
conn_manager = ConnectionManager()
templates = Jinja2Templates(directory="templates")
@router.get("/chatroom/{username}")
async def chatroom_page_endpoint(
    request: Request, username: str
) -&gt; HTMLResponse:
    return templates.TemplateResponse(
        request=request,
        name="chatroom.xhtml",
        context={"username": username},
    )</pre></li> </ol>
<p>The endpoint will take as a path parameter the username of the client that will show in the <span class="No-Break">chat conversation.</span></p>
<p>You have set up a basic chat<a id="_idIndexMarker616"/> room within your FastAPI application with the WebSockets protocol. You only have to spin up the server with <strong class="source-inline">uvicorn app.main:app</strong> and connect to <strong class="source-inline">http://localhost:8000/chatroom/your-username</strong> from your browser. Then, from another page, connect to the same address with a different username and start exchanging messages between the<a id="_idIndexMarker617"/> <span class="No-Break">two browsers.</span></p>
<h2 id="_idParaDest-314"><a id="_idTextAnchor317"/>How it works…</h2>
<p>When connecting to the <strong class="source-inline">GET /chatroom/{username}</strong> endpoint address (<strong class="source-inline">http://localhost:8000/chatroom/{username}</strong>), the server will use the username to render the HTML page customized to <span class="No-Break">the username.</span></p>
<p>The HTML will contain the code to<a id="_idIndexMarker618"/> make the connection to the <strong class="source-inline">/chatroom</strong> WebSocket endpoint and create a new WebSocket connection for <span class="No-Break">each user.</span></p>
<p>The endpoint will then use the <strong class="source-inline">ConnectionManager()</strong> connection manager object to exchange messages between all clients through the <span class="No-Break">HTML page.</span></p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor318"/>See also</h2>
<p>We have used a basic feature of the Jinja2 templating library. However, you can free your creativity and discover the potential of this package by looking at <span class="No-Break">the documentation:</span></p>
<ul>
<li><em class="italic">Jinja2 </em><span class="No-Break"><em class="italic">Documentation</em></span><span class="No-Break">: </span><a href="https://jinja.palletsprojects.com/en/3.1.x/"><span class="No-Break">https://jinja.palletsprojects.com/en/3.1.x/</span></a></li>
</ul>
<h1 id="_idParaDest-316"><a id="_idTextAnchor319"/>Optimizing WebSocket performance</h1>
<p>WebSocket connections provide a powerful mechanism for real-time communication between clients and servers. To ensure the optimal performance and scalability of WebSocket applications, it’s essential to implement effective optimization techniques and a way to measure them. In this<a id="_idIndexMarker619"/> recipe, we will see how to benchmark WebSocket endpoints to test the number of connections supported by the connection and suggest practical tips and techniques to optimize WebSocket performance in your <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor320"/>Getting ready</h2>
<p>Besides knowledge of how to set up a WebSocket endpoint, we will use the <em class="italic">Implementing chat functionality with WebSockets</em> recipe to benchmark the traffic supported. You can also follow the recipe by applying the strategy to <span class="No-Break">your application.</span></p>
<p>Whether you apply it to your application or the chat functionality, it can be useful to include some message logs to be printed during the <span class="No-Break">endpoint execution.</span></p>
<p>For example, for the WebSocket <strong class="source-inline">/chatroom/{username}</strong> endpoint, you can add a log after each message broadcast <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker620"/></span><span class="No-Break">follows:</span></p>
<pre class="source-code">
<strong class="bold">import logging</strong>
<strong class="bold">logger = logging.getLogger("uvicorn")</strong>
@router.websocket("/chatroom/{username}")
async def chatroom_endpoint(
    websocket: WebSocket, username: str
):
    await conn_manager.connect(websocket)
    await conn_manager.broadcast(
        # method's parameters
    )
<strong class="bold">    logger.info(f"{username} joined the chat")</strong>
    try:
        while True:
            data = await websocket.receive_text()
            await conn_manager.broadcast(
                # method's parameters
            )
            await conn_manager.send_personal_message(
                # method's parameters
            )
<strong class="bold">            logger.info(</strong>
<strong class="bold">                f"{username} says: {data}"</strong>
<strong class="bold">            )</strong>
    except WebSocketDisconnect:
        conn_manager.disconnect(websocket)
        await conn_manager.broadcast(
            # method's paramters
        )
<strong class="bold">        logger.info(f"{username} left the chat")</strong></pre> <p>We are now ready to create a <a id="_idIndexMarker621"/>benchmark script to test our <span class="No-Break">chat functionality.</span></p>
<h2 id="_idParaDest-318"><a id="_idTextAnchor321"/>How to do it…</h2>
<p>Let’s create the script file under the root folder and call it <strong class="source-inline">benchmark_websocket.py</strong>. A typical benchmark script should do the <span class="No-Break">following tasks:</span></p>
<ul>
<li>Define a function to run the <span class="No-Break">FastAPI server</span></li>
<li>Define another function to connect <em class="italic">n</em> number of clients of the WebSocket endpoint and exchange a certain number <span class="No-Break">of messages</span></li>
<li>Wrap up the previous steps by running the server in a separate process and running <span class="No-Break">the clients</span></li>
</ul>
<p>Here are the steps to create <span class="No-Break">the script:</span></p>
<ol>
<li>Let’s start by defining a function to run <span class="No-Break">our server:</span><pre class="source-code">
import uvicorn
from app.main import app
def run_server():
    uvicorn.run(app)</pre><p class="list-inset">The <strong class="source-inline">run_server</strong> function is an alternative to the command-line <strong class="source-inline">uvicorn app.main:app</strong> command <a id="_idIndexMarker622"/>we are used to running from <span class="No-Break">the terminal.</span></p></li> <li>Now let’s define a function that will create a certain number of clients that will connect to the WebSocket endpoint and exchange <span class="No-Break">some messages:</span><pre class="source-code">
import asyncio
from websockets import connect
async def connect_client(
    n: int, n_messages: int = 3
):
    async with connect(
        f"ws://localhost:8000/chatroom/user{n}",
    ) as client:
        for _ in range(n_messages):
            await client.send(
                f"Hello World from user{n}"
            )
            await asyncio.sleep(n * 0.1)
        await asyncio.sleep(2)</pre><p class="list-inset"> To simulate concurrent connection patterns, we use an <strong class="source-inline">async def</strong> function. This will enable us to evaluate the server’s performance under the high load of simultaneous requests to <span class="No-Break">the endpoint.</span></p><p class="list-inset">Furthermore, we added some asynchronous sleeping time (<strong class="source-inline">asyncio.sleep</strong>) between messages to simulate the human behavior of the <span class="No-Break">chat’s client.</span></p></li> <li>Then, we can execute all the<a id="_idIndexMarker623"/> previous functions in a single overall <strong class="source-inline">async def main</strong> function <span class="No-Break">as follows:</span><pre class="source-code">
import multiprocessing
async def main(n_clients: int = 10):
    p = multiprocessing.Process(target=run_server)
    p.start()
    await asyncio.sleep(1)
    connections = [
        connect_client(n) for n in range(n_clients)
    ]
    await asyncio.gather(*connections)
    await asyncio.sleep(1)
    p.terminate()</pre><p class="list-inset">The function creates a process to spin up the server, start it, wait some time to finish the startup, and simultaneously run all the clients to call <span class="No-Break">the server.</span></p></li> <li>Finally, to make it run, we need to pass it to the event loop if it is run as a script. We can do it <span class="No-Break">like this:</span><pre class="source-code">
if __name__ == "__main__":
    asyncio.run(main())</pre></li> </ol>
<p>To run the script, simply run it as <a id="_idIndexMarker624"/>a Python script from the <span class="No-Break">command line:</span></p>
<pre class="console">
<strong class="bold">$ python benchmark_websocket.py</strong></pre> <p>If you leave the default value for the parameter <strong class="source-inline">n_clients</strong>, you will probably see all the messages flowing on the terminal. However, by increasing <strong class="source-inline">n_clients</strong>, depending on your machine, at some point, the script will not be able to run anymore and you will see socket connection errors popping up. That means that you passed the limit to support new connections with <span class="No-Break">your endpoint.</span></p>
<p>What we did is the core of a basic script to benchmark. You can further expand the script based on your needs by adding timing or parametrization to have a broader view of your <span class="No-Break">application’s capabilities.</span></p>
<p>You can also do the same by using dedicated test frameworks, similar to what we did in the <em class="italic">Performance testing for </em><em class="italic">high traffic</em><em class="italic"> applications</em> recipe in <a href="B21025_05.xhtml#_idTextAnchor157"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Testing and Debugging FastAPI Applications</em>, for <span class="No-Break">HTTP traffic.</span></p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor322"/>There’s more…</h2>
<p>Benchmarking your WebSocket is only the first step to optimize your application performance. Here is a checklist of<a id="_idIndexMarker625"/> actions that you can take to improve your application performance and <span class="No-Break">reduce errors:</span></p>
<ul>
<li><strong class="bold">Make unit tests for WebSockets with TestClient</strong>: FastAPI’s <strong class="source-inline">TestClient</strong> also supports WebSocket connections, so use it to ensure that the behavior of the endpoint is the one expected and does not change during the <span class="No-Break">development process.</span></li>
<li><strong class="bold">Handle errors gracefully</strong>: Implement error handling mechanisms to gracefully manage exceptions and errors encountered during WebSocket communication. Use <strong class="source-inline">try/except</strong> blocks to handle specific error conditions. Also, when possible, use <strong class="source-inline">async for</strong> over <strong class="source-inline">while True</strong> when managing message exchanges. This will automatically capture and treat <span class="No-Break">disconnection errors.</span></li>
<li><strong class="bold">Use connection pool managers</strong>: Connection pool managers improve performance and code <a id="_idIndexMarker626"/>maintainability when handling multiple clients, such as in <span class="No-Break">chat applications.</span></li>
</ul>
<h2 id="_idParaDest-320"><a id="_idTextAnchor323"/>See also</h2>
<p>You can see more on unit testing WebSockets with FastAPI in the <span class="No-Break">official documentation:</span></p>
<ul>
<li><em class="italic">Testing WebSockets in </em><span class="No-Break"><em class="italic">FastAPI</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/testing-websockets/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/testing-websockets/</span></a></li>
</ul>
<h1 id="_idParaDest-321"><a id="_idTextAnchor324"/>Securing WebSocket connections with OAuth2</h1>
<p>Securing WebSocket connections is<a id="_idIndexMarker627"/> paramount to safeguarding the privacy and security of user interactions in real-time applications. By implementing authentication and access control mechanisms, developers can <a id="_idIndexMarker628"/>mitigate risks associated with unauthorized access, eavesdropping, and data tampering. In this recipe, we will see how to create a secure WebSocket connection endpoint with OAuth2 token authorization in your <span class="No-Break">FastAPI applications.</span></p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor325"/>Getting ready</h2>
<p>To follow the recipe, you should already know how to set up a basic WebSocket endpoint – explained in the <em class="italic">Setting up WebSockets in FastAPI</em> recipe in <span class="No-Break">this chapter.</span></p>
<p>Furthermore, we are going to use <strong class="bold">OAuth2</strong> with a <a id="_idIndexMarker629"/>password and a bearer token. We will apply the same strategy we used to secure HTTP endpoints in the <em class="italic">Securing your API with OAuth2</em> recipe in <a href="B21025_03.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Building RESTful APIs with FastAPI</em>. Feel free to have a look before starting <span class="No-Break">the recipe.</span></p>
<p>Before starting the recipe, let’s create a simple WebSocket endpoint, <strong class="source-inline">/secured-ws</strong>, in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span></p>
<pre class="source-code">
@app.websocket("/secured-ws")
async def secured_websocket(
    websocket: WebSocket,
    username: str
):
    await websocket.accept()
    await websocket.send_text(f"Welcome {username}!")
    async for data in websocket.iter_text():
        await websocket.send_text(
            f"You wrote: {data}"
        )</pre> <p>The endpoint will accept any connection with a parameter to specify the username. Then it will send a welcome <a id="_idIndexMarker630"/>message to the client and return each message received to <span class="No-Break">the client.</span></p>
<p>The endpoint is insecure since it does not have any protection and can be easily reached. Let’s dive into the recipe to see how to protect it with <span class="No-Break">OAuth2 authentication.</span></p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor326"/>How to do it…</h2>
<p>At the time of writing, there is no support for the <strong class="source-inline">OAuth2PasswordBearer</strong> class for WebSocket in FastAPI. This means that checking the bearer token in the headers for WebSocket is not as straightforward as it is<a id="_idIndexMarker631"/> for HTTP calls. However, we can create a WebSocket-specific class that is derived from the one used by HTTP to achieve the same functionality <span class="No-Break">as follows.</span></p>
<ol>
<li>Let’s do it in a dedicated module under the <strong class="source-inline">app</strong> folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">ws_password_bearer.py</strong></span><span class="No-Break">:</span><pre class="source-code">
from fastapi import (
    WebSocket,
    WebSocketException,
    status,
)
from fastapi.security import OAuth2PasswordBearer
class OAuth2WebSocketPasswordBearer(
    OAuth2PasswordBearer
):
    async def __call__(
        self, websocket: WebSocket
    ) -&gt; str:
        authorization: str = websocket.headers.get(
            "authorization"
        )
        if not authorization:
            raise WebSocketException(
                code=status.HTTP_401_UNAUTHORIZED,
                reason="Not authenticated",
            )
        scheme, param = authorization.split()
        if scheme.lower() != "bearer":
            raise WebSocketException(
                code=status.HTTP_403_FORBIDDEN,
                reason=(
                    "Invalid authentication "
                    "credentials"
                ),
            )
        return param</pre><p class="list-inset">We will use it to create a <strong class="source-inline">get_username_from_token</strong> function to retrieve the username from<a id="_idIndexMarker632"/> the token. You can create the function in a<a id="_idIndexMarker633"/> dedicated module – <span class="No-Break"><strong class="source-inline">security.py</strong></span><span class="No-Break">.</span></p></li> <li>Let’s define the <span class="No-Break"><strong class="source-inline">oauth2_scheme_for_ws</strong></span><span class="No-Break"> object:</span><pre class="source-code">
from app.ws_password_bearer import (
    OAuth2WebSocketPasswordBearer,
)
oauth2_scheme_for_ws = OAuth2WebSocketPasswordBearer(
    tokenUrl="/token"
)</pre></li> <li>The <strong class="source-inline">tokenUrl</strong> argument specifies the callback endpoint to call to retrieve the token. This endpoint should be built according to the token resolution you use. After that, we can create a function that retrieves the username from <span class="No-Break">the token:</span><pre class="source-code">
def get_username_from_token(
    token: str = Depends(oauth2_scheme_for_ws),
) -&gt; str:
    user = fake_token_resolver(token)
    if not user:
        raise WebSocketException(
            code=status.HTTP_401_UNAUTHORIZED,
            reason=(
                "Invalid authentication credentials"
            )
        )
    return user.username</pre><p class="list-inset">The purpose of the <strong class="source-inline">fake_token_resolver</strong> function is <a id="_idIndexMarker634"/>to simulate the process of resolving a token. This function<a id="_idIndexMarker635"/> can be found in the <strong class="source-inline">security.py</strong> file in the GitHub repository of the chapter. Furthermore, the example contains only two users, <strong class="source-inline">johndoe</strong> and <strong class="source-inline">janedoe</strong>, who can be used later for testing. Also, the <strong class="source-inline">security.py</strong> module from the GitHub repository contains the <strong class="source-inline">POST /token</strong> endpoint to be used to retrieve <span class="No-Break">the token.</span></p><p class="list-inset">However, it is important to <a id="_idIndexMarker636"/>mention that this function does not provide any actual security and it is only used for example purposes. In a production environment, it is recommended to use a <strong class="bold">JWT Authorization</strong> token or<a id="_idIndexMarker637"/> an external provider for token resolution (see the <em class="italic">Working with OAuth2 and JWT for authentication</em> and <em class="italic">Using third-party authentication</em> recipes – both in <a href="B21025_04.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Authentication </em><span class="No-Break"><em class="italic">and Authorization</em></span><span class="No-Break">).</span></p></li> <li>Now let’s use it to secure our WebSocket endpoint, <strong class="source-inline">/secured-ws</strong>, in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
<strong class="bold">from import Annotated</strong>
<strong class="bold">from fastapi import Depends</strong>
<strong class="bold">from app.security import get_username_from_token</strong>
@app.websocket("/secured-ws")
async def secured_websocket(
    websocket: WebSocket,
    username: Annotated[
<strong class="bold">        get_username_from_token, Depends()</strong>
    ]
):
    # rest of the endpoint</pre></li> </ol>
<p>This is all you need to build a secured <span class="No-Break">WebSocket endpoint.</span></p>
<p>To test it, spin up the server<a id="_idIndexMarker638"/> from the terminal by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ uvicorn app.main:app</pre> <p>When attempting to connect to the WebSocket endpoint using Postman or another tool to the address <strong class="source-inline">ws://localhost:8000/secured-ws</strong>, an authorization error will occur, and the connection will be rejected before <span class="No-Break">the handshake.</span></p>
<p>To allow the connection, we need to retrieve the token and pass it through the headers of the WebSocket request in <strong class="bold">Postman</strong>. You can retrieve the token from the dedicated endpoint or, if you use the fake token generator<a id="_idIndexMarker639"/> from the GitHub repository, you simply append the <strong class="source-inline">tokenized</strong> string to the username. For example, for <strong class="source-inline">johndoe</strong>, the token would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">tokenizedjohndoe</strong></span><span class="No-Break">.</span></p>
<p>Let’s pass it through the header. In Postman, you can pass the bearer token to the WebSocket request in the <strong class="bold">Headers</strong> tab by adding a new header. The header will have a key called <strong class="source-inline">Authorization</strong> and value that will be <span class="No-Break"><strong class="source-inline">bearer tokenizedjohndoe</strong></span><span class="No-Break">.</span></p>
<p>Now, if you try to connect, it should connect and you will be able to exchange messages with <span class="No-Break">the endpoint.</span></p>
<p>You have just secured a WebSocket endpoint in FastAPI. By implementing OAuth2 authorization, you can enhance the security posture of your FastAPI applications and safeguard WebSocket communication against potential threats <span class="No-Break">and vulnerabilities.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">Try to build a secure chat functionality where users need to log in to participate in <span class="No-Break">the chat.</span></p>
<p class="callout">Tips: The endpoint that returns the HTML page should check for the bearer token in the cookies. If the cookie is not found or the bearer token is not valid, it should redirect the client to a login page that puts the token in the <span class="No-Break">browser’s cookies.</span></p>
<p class="callout">You can use the <strong class="source-inline">response.RedirectResponse</strong> class from the <strong class="source-inline">fastapi</strong> package to handle redirections. The usage is quite straightforward and you can have a look at the documentation page at <span class="No-Break">the link:</span></p>
<p class="callout"><a href="https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse"><span class="No-Break">https://fastapi.tiangolo.com/advanced/custom-response/#redirectresponse</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-324"><a id="_idTextAnchor327"/>See also</h2>
<p>Integrating <strong class="bold">OAuth2</strong> into WebSockets in FastAPI with an <strong class="source-inline">OAuth2PasswordBearer</strong>-like class is a current topic<a id="_idIndexMarker640"/> of interest, and it is expected to<a id="_idIndexMarker641"/> evolve quickly over time. You can follow the ongoing discussion in the FastAPI <span class="No-Break">GitHub repository:</span></p>
<ul>
<li><em class="italic">OAuth2PasswordBearer with WebSocket </em><span class="No-Break"><em class="italic">Discussion</em></span><span class="No-Break">: </span><a href="https://github.com/tiangolo/fastapi/discussions/8983"><span class="No-Break">https://github.com/tiangolo/fastapi/discussions/8983</span></a></li>
</ul>
</div>
</div></body></html>