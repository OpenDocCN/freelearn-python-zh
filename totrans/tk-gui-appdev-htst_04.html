<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Game of Chess</h1></div></div></div><p>Let's now build a game of chess in Tkinter. You do not need to be a master at chess to build this game. If you have ever played chess and you know the basic rules that govern the chess pieces, you are ready to write this program.</p><p>If you have never played chess and do not know the basic rules, you would better start by reading those rules from the Internet before you start programming this application.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Mission Briefing</h1></div></div></div><p>In its final form <a id="id343" class="indexterm"/>our chess game would look like the following screenshot:</p><div><img src="img/7941_04_01.jpg" alt="Mission Briefing"/></div><p>Our chess game would enforce all standard rules applicable to the game of chess. Some advanced rules and features are left as an exercise for you to complete.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec76"/>Why Is It Awesome?</h2></div></div></div><p>In the process <a id="id344" class="indexterm"/>of building our chess application, we get introduced to the Tkinter Canvas widget, which is considered one of the most powerful and versatile features of Tkinter.</p><p>As you will see in the course of this project, the Canvas widget is a really powerful tool for a GUI programmer. It can be used to sketch compound objects using lines, rectangles, ovals, and polygons. It will also let you position images on the canvas with great accuracy.</p><p>In addition, the Canvas widget will let you place any other widget (such as labels, buttons, scale, and other widgets) on itself. This makes it an ideal container for accommodating widgets for a variety of different GUI programs.</p><p>In addition to learning about the Canvas widget, you will also get an insight on how to structure your data using Python built-in types. You will also be introduced to the concepts involved in selecting pertinent objects and structuring them into classes and modules at the right granularity.</p><p>As the application develops, we are also introduced to several other Python modules that you will often use in a variety of application development projects.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec77"/>Your Hotshot Objectives</h2></div></div></div><p>The following are the <a id="id345" class="indexterm"/>key objectives for this project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to structure a program into its model and view components</li><li class="listitem" style="list-style-type: disc">How to represent a problem domain in a desired notation</li><li class="listitem" style="list-style-type: disc">Peeking into the versatility and power of the Tkinter Canvas widget</li><li class="listitem" style="list-style-type: disc">Basic usage of canvas coordinates, object IDs and tags</li><li class="listitem" style="list-style-type: disc">How to work with newer image formats not supported by the Tkinter photo image class</li><li class="listitem" style="list-style-type: disc">Typical interaction of logic and presentation layers in a GUI program</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec78"/>Mission Checklist</h2></div></div></div><p>We will<a id="id346" class="indexterm"/> need to process PNG images in our program. The Tkinter photo image class and other standard libraries of Python do not support PNG processing. We will use the <a id="id347" class="indexterm"/>
<strong>Python Imaging Library</strong> (<strong>PIL</strong>) to render PNG files.</p><p>To install the PIL package visit:</p><p>
<a class="ulink" href="http://www.pythonware.com/products/pil/">http://www.pythonware.com/products/pil/</a>
</p><p>If you are working on windows x64 (64 bit)or MacOSX machine, you may instead need to install and work with Pillow, which is a replacement for the PIL, from:</p><p>
<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow">http://www.lfd.uci.edu/~gohlke/pythonlibs/#pillow</a>
</p><p>After you have installed the package, go to your Python interactive prompt and type:</p><p>
<code class="literal">&gt;&gt;from PIL import ImageTk</code>
</p><p>If this executes without any error message, you are ready to make the chess application.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Structuring our program</h1></div></div></div><p>All our previous projects have been structured as a single file. However, as programs grow in complexity,<a id="id348" class="indexterm"/> we need to break our programs into modules and class structures.</p><p>Development of large applications generally starts with recording the <strong>software requirement specifications</strong> (<strong>SRS</strong>).<a id="id349" class="indexterm"/> This is generally followed by a graphical representation of constructs, such as class, composition, inheritance, and information hiding using several modeling tools. These tools can be flow charts, <a id="id350" class="indexterm"/>
<strong>unified modeling language</strong> (<strong>UML</strong>), data flow diagrams, Venn diagrams (for database modeling), and several other tools.</p><p>These tools are very useful when the problem domain is not very clear. However, if you have ever played the game of chess, you are very well acquainted with the problem domain. Furthermore, our chess program may be classified as a medium-sized program spanning a few hundred lines of code. Let us, therefore, bypass these visual tools and get to the actual program design.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec79"/>Prepare for Lift Off</h2></div></div></div><p>In this iteration, we decide an overall structure for our program.</p><p>In the true spirit of object-oriented programming (OOP), let's first list the kind of objects that we would encounter in our program. An intuitive look at a chessboard tells us that we have two sets of objects to handle:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Chessboard</strong>: It is an 8 x 8 square board with alternatively colored squares</li><li class="listitem" style="list-style-type: disc"><strong>Chess pieces</strong>: They are the king, queen, bishop, knight, rook, and pawns</li></ul></div><p>As we proceed, we may or may not come across other objects. But we are sure to come across these two kinds of objects. So, without much further delay, let us create two files named <code class="literal">chessboard.py</code> and <code class="literal">pieces.py</code> in our project folder. (See <em>code folder 4.01</em>)</p><p>We will <a id="id351" class="indexterm"/>use these two files to define the respective classes to keep the logic associated with these two objects. Note that these files will not display the board or its pieces; it will instead keep all logic related to board and pieces. In programming parlance, this is broadly referred to as the <strong>model</strong>.<a id="id352" class="indexterm"/>
</p><p>The actual display of board and pieces will be kept in a separate file, which will handle all views related to the program.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>The rule of separating logic from presentation should be applied not only for deciding your file structure, but also when defining methods within your files.</p><p>Every time you write a method, try to separate its presentation from the logic. If you find a method mixing logic and presentation, refactor your code to separate the two. Avoid coupling the presentation and logic into the same method.</p></div></div><p>It is a good idea to keep the presentation layer (view) separate from logic (model). So, we will create a new file named <code class="literal">gui.py</code> to code all visible components of the program, including all our widgets. This file will be primarily responsible for generating the view.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>In addition to the model and view files, many programs also keep a separate controller file to decouple behavioral aspects of a program from the logic (model) and presentation (view). This kind of structural segregation is named the <strong>model-view-controller</strong> (<strong>MVC</strong>) <a id="id353" class="indexterm"/>style of programming.</p><p>However, our chess program has just one event to handle: mouse click for moving chess pieces. Creating a separate controller for just one event can make the program more complex than it should be.</p><p>Given this limitation, we will handle the presentation (view) and event handling (controller) from a single class named <code class="literal">GUI</code>.</p></div></div><p>Now that we have our file structure ready, let us start our coding. To begin, let's code the <code class="literal">GUI </code>class for our chessboard, as shown in the following screenshot. Because this pertains to the view section, let's put this code in the <code class="literal">gui.py</code> file.</p><div><img src="img/7941_04_02.jpg" alt="Prepare for Lift Off"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec80"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Step 1 – creating the GUI class</h3></div></div></div><p>We <a id="id354" class="indexterm"/>first create a <code class="literal">GUI</code> class and assign attributes such as rows, columns, colors of squares, and the dimension of each square in pixels. We initialize our <code class="literal">GUI</code> class to create the canvas on which we will draw our chessboard, as follows (see <em>code 4.01 gui.py</em>):</p><div><pre class="programlisting">from Tkinter import *
class GUI():
  rows = 8
  columns = 8
  color1 = "#DDB88C"
  color2 = "#A66D4F"
  dim_square = 64
  def __init__(self, parent):
       self.parent = parent
       canvas_width = self.columns * self.dim_square
       canvas_height = self.rows * self.dim_square
       self.canvas = Canvas(parent, width=canvas_width, height=canvas_height, background="grey")
       self.canvas.pack(padx=8, pady=8)
<strong>       self.draw_board()</strong>
</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a class, <code class="literal">GUI</code>, to handle the rendering of our view files. The <code class="literal">init</code> method of the <code class="literal">GUI</code> class is called immediately on object instantiation. The <code class="literal">init</code> method sets up a Canvas widget of the required size. This canvas will act as our container for all objects, such as chess square areas and eventually the chess pieces.</li><li class="listitem" style="list-style-type: disc">We have used the Canvas widget as a container, because it provides us the ability to handle tasks based on precise location coordinates of events, such as click of the mouse button.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">init</code> method then calls the <code class="literal">draw_board()</code> method, which is responsible for creating square blocks of alternating colors similar to a chessboard.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Step 2 – creating the chessboard</h3></div></div></div><p>Now, we<a id="id355" class="indexterm"/> draw the squares on the chessboard using the <code class="literal">canvas.create_rectangle</code> method, filling it alternating between the two colors we defined earlier.</p><div><pre class="programlisting">def draw_board(self):
     color = self.color2
     for r in range(self.rows):
       color = self.color1 if color == self.color2 
	   else self.color2 # alternating between two colors
       for c in range(self.columns):
             x1 = (c * self.dim_square)
             y1 = ((7-r) * self.dim_square)
             x2 = x1 + self.dim_square
             y2 = y1 + self.dim_square
             self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, tags="area")
             color = self.color1 if color == self.color2 else self.color2</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To draw squares on the board we use the <code class="literal">canvas.create_rectangle()</code> method, which draws a rectangle given the x, y coordinates for the two diagonally opposite corners of the rectangle (coordinates of upper-left and lower-right edges).</li><li class="listitem" style="list-style-type: disc">We will need to target the board. We, therefore, add a tag named <code class="literal">area</code> to each of the squares created on the board. This is similar to tagging of the text widget, as we had done in our text editor program.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec15"/>Step 3 – creating Tkinter mainloop</h3></div></div></div><p>Now, we will create Tkinter mainloop as follows:</p><div><pre class="programlisting">def main():
     root = Tk()
     root.title("Chess")
     gui = GUI(root)
     root.mainloop()
if __name__ == "__main__":
     main()</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Outside<a id="id356" class="indexterm"/> the class, we have a main method that sets the Toplevel window, starts Tkinter mainloop, instantiates a <code class="literal">GUI</code> object, and calls the <code class="literal">drawboard()</code> method.</li></ul></div><div><div><h3 class="title"><a id="note28"/>Note</h3><p>The Tkinter Canvas widget lets you draw line, oval, rectangle, arc, and polygon shapes at a given coordinate specified location. You can also specify various configuration options, such as fill, outline, width, and several others for each of these shapes.</p><p>In addition, the Canvas widget has a huge list of methods and configurable options. For a complete list of canvas-related options, type the following into Python interactive shell:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import Tkinter</strong>
<strong>&gt;&gt;&gt; help(Tkinter.Canvas) </strong>
</pre></div><p>You can also access the documentation of Tkinter in your core Python installation directory. The documentation is located at <code class="literal">path\to\python\installation\Doc\Python273</code>.</p><p>This is a compiled HTML help file. Within the help file, search for Tkinter, and you get a comprehensive reference with details of all widgets.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec81"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes our first iteration. In this iteration, we decided the class structure for our chess program. We created a <code class="literal">GUI</code> class and added attributes we would normally expect a chessboard to have.</p><p>We also got our first taste of the Canvas widget. We created a blank canvas, and then added square areas using the <code class="literal">canvas.create_rectangle</code> method to create our chessboard.</p><p>We also created out Tkinter mainloop and created an object out of the <code class="literal">GUI</code> class from within our mainloop. Now, if you run <code class="literal">code 4.01 gui.py</code>, you will see a chessboard.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec82"/>Classified Intel</h2></div></div></div><p>The Canvas<a id="id357" class="indexterm"/> widget comes with a rich set of methods and configurable options. However, there are three important things to note about the Canvas widget:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It uses <a id="id358" class="indexterm"/>a coordinate system to specify position of objects on the widget. Coordinates are measured in pixels. The top-left corner of the canvas has coordinates (0,0).</li><li class="listitem" style="list-style-type: disc">It offers methods to add images and to draw basic shapes, such as line, arc, ovals, and polygons.</li><li class="listitem" style="list-style-type: disc">The objects drawn on the Canvas widget are usually handled through assigning them an ID or tag.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Structuring chessboard-and-pieces-related data</h1></div></div></div><p>In our drum program, we had decided on a notation to describe a set of beat patterns. We could then<a id="id359" class="indexterm"/> store (pickle) that beat pattern notation and reproduce (unpickle) it later. The chess program is no different. It too needs a suitable notation for describing chess pieces and for locating their positions on the board.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec83"/>Prepare for Lift Off</h2></div></div></div><p>We can<a id="id360" class="indexterm"/> define our own notation for representing chess piece and their positions, but it turns out that there already exists a globally accepted, simple, compact, and standard notation for representing a chessboard. The notation is called <strong>Forsyth-Edwards notation</strong> (<strong>FEN</strong>)<a id="id361" class="indexterm"/> available at <a class="ulink" href="http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation">http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation</a>.</p><p>We might have decided to define our notation, but we preferred not to reinvent the wheel here.</p><p>The FEN record for starting position of a chess game is written as:</p><p>
<code class="literal">rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1</code>
</p><p>The key things to note about the notation are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The notation displays six records for a chess game. Each record is separated by a blank space.</li><li class="listitem" style="list-style-type: disc">The first record shows the positions of pieces on a chessboard. Each row of the <a id="id362" class="indexterm"/>chessboard (rank) is represented in a section demarcated by the <code class="literal">/</code> symbol.</li><li class="listitem" style="list-style-type: disc">Within the first record, each piece is identified by a single letter (pawn = <code class="literal">p</code>, knight = <code class="literal">n</code>, bishop = <code class="literal">b</code>, rook = <code class="literal">r</code>, queen = <code class="literal">q</code> and king = <code class="literal">k</code>).</li><li class="listitem" style="list-style-type: disc">White pieces are represented using uppercase letters (<code class="literal">PNBRQK</code>),  but black pieces are represented by lowercase letters (<code class="literal">pnbrqk</code>).</li><li class="listitem" style="list-style-type: disc">Squares with no pieces on it are represented using digits <code class="literal">1</code> through <code class="literal">8</code> (the number of blank squares).</li><li class="listitem" style="list-style-type: disc">The second record denotes the turn of a player. Letter <code class="literal">w</code> denotes white turn, and letter <code class="literal">b</code> denotes black turn.</li><li class="listitem" style="list-style-type: disc">The third record <code class="literal">KQkq </code>indicates whether or not castling feature is available. If neither castle, this is <code class="literal">-</code>. Otherwise, this has one or more letters: <code class="literal">K</code> (white can castle kingside), <code class="literal">Q</code> (white can castle queenside), <code class="literal">k</code> (black can castle kingside), and/or <code class="literal">q</code> (black can castle queenside).</li><li class="listitem" style="list-style-type: disc">The fourth record<code class="literal">_</code>captures En passant details for the game. We will not be implementing castling and En passant features in our game, so we can safely disregard these two records for now.</li><li class="listitem" style="list-style-type: disc">The fifth record keeps track of half-move clock for the game. The half-move clock keeps track of number of turns played since the last pawn advance or last capture. This is used to determine if a draw can be claimed under the fifty-move rule.</li><li class="listitem" style="list-style-type: disc">The sixth record tracks the full-move number, which is incremented by 1 after each move of black. This is used to track the overall length for which a game was played.</li></ul></div><p>The notation as previously stated can be represented pictorially along x and y axis as follows:</p><div><img src="img/7941_04_03.jpg" alt="Prepare for Lift Off"/></div><p>Using this notation, we can accurately represent any particular square on the chessboard.</p><p>The color <a id="id363" class="indexterm"/>of piece depends on whether the alphabet is in small letters (black) or capital letters (white).</p><p>Thus <strong>A1</strong> denotes the bottom and left-most square on the chessboard. Currently, it is occupied by a white rook. The <strong>C3</strong> position is currently empty, and <strong>E8 </strong>has black king and <strong>A8</strong> has a black rook.</p><p>Following these rules, here is how the FEN notation would change after the following indicative turns played (<a class="ulink" href="http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation">http://en.wikipedia.org/wiki/Forsyth-Edwards_Notation</a>):</p><p>After first move, <code class="literal">P</code> to <code class="literal">e4</code>:</p><p>
<code class="literal">rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1</code>
</p><p>After second move, <code class="literal">p</code> to <code class="literal">c5</code>:</p><p>
<code class="literal">rnbqkbnr/pp1ppppp/8/2p5/4P3/8/PPPP1PPP/RNBQKBNR w KQkq c6 0 2</code>
</p><p>After third move, <code class="literal">N</code> to <code class="literal">f3</code>:</p><p>
<code class="literal">rnbqkbnr/pp1ppppp/8/2p5/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2</code>
</p><p>All our chessboard and piece related logic will use the preceding notation. It is, therefore, very important that we fully understand this notation before we proceed to code our game.</p><p>Now that we are clear about the preceding notation, let's apply the notation to represent our chessboard. The key idea here is that, given a FEN notation, we should be able to represent it on the board.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec84"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec16"/>Step 1 – creating a Piece superclass</h3></div></div></div><p>Let's <a id="id364" class="indexterm"/>now first code the model code for <code class="literal">pieces.py</code> (see <em>code 4.02 pieces.py</em>) by creating a <code class="literal">Piece</code> super class as follows:</p><div><pre class="programlisting">class Piece():
  def __init__(self, color):
     if color == 'black':
        self.shortname = self.shortname.lower()
     elif color == 'white':
        self.shortname = self.shortname.upper()
     self.color = color

  def ref(self, board):
   ''' Get a reference of chessboard instance'''
     self.board = board</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We define a class, <code class="literal">Piece ()</code>. It's <code class="literal">__init__</code> method, which takes a color as an argument. In accordance with our FEN notation, it changes the shortname to lowercase letter for black and uppercase letter for white. The color handling is done in the superclass, <code class="literal">Piece</code>, because it is a common feature for all chess pieces.</li><li class="listitem" style="list-style-type: disc">We also define a method named <code class="literal">ref</code>. Its only purpose is to get an instance of the chessboard into the object namespace for the board and pieces to interact. We need this method, because our pieces will ultimately be interacting with the chessboard. Accordingly, we need a reference of the chessboard instance within the <code class="literal">Piece</code> class.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Step 2 – creating individual child classes for all pieces</h3></div></div></div><p>We can create individual child classes for all pieces as follows:</p><div><pre class="programlisting">class King(Piece):    shortname = 'k'
class Queen(Piece):    shortname = 'q'
class Rook(Piece):    shortname = 'r'
class Knight(Piece):    shortname = 'n'
class Bishop(Piece):    shortname = 'b'
class Pawn(Piece):   shortname = 'p'</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We define classes for each of the pieces found on a chessboard. So, we have classes named <code class="literal">King</code>, <code class="literal">Queen</code>, <code class="literal">Rook</code>, <code class="literal">Knight</code>, <code class="literal">Bishop</code>, and <code class="literal">Pawn</code>. These classes are derived from the <code class="literal">Piece</code> super class.</li><li class="listitem" style="list-style-type: disc">For now, these child classes merely define the shortname associated with them. We will later expand these child classes to define and enforce rules for movement of each of these pieces.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec18"/>Step 3 – defining a method to return the piece instance</h3></div></div></div><p>We will define a method to return the piece instance as follows: </p><div><pre class="programlisting">import sys
SHORT_NAME = {'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'P':'Pawn'}
def create_piece(piece, color='white'):
     if piece in (None, ''): return
     if piece.isupper(): color = 'white'
     else: color = 'black'
     piece = SHORT_NAME[piece.upper()]
     module = sys.modules[__name__]
     return module.__dict__[piece](color)</pre></div><p>The <a id="id365" class="indexterm"/>description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code defines a dictionary with pieces shortname and full name as key-value pair.</li><li class="listitem" style="list-style-type: disc">We then define a method piece which takes a piece shortname and returns the corresponding piece instance.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec19"/>Step 4 – creating the Board class </h3></div></div></div><p>Now that we have a basic model ready for pieces, let's code the model to deal with their placement on the chessboard. We code this in <code class="literal">chessboard.py</code>.(see <em>code 4.02 chessboard.py</em>) by creating a <code class="literal">Board</code> class as follows:</p><div><pre class="programlisting">import pieces
import re
START_PATTERN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w 0 1'
class Board(dict):
     y_axis = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')
     x_axis = (1,2,3,4,5,6,7,8)
     def __init__(self, patt = None):
        self.process_notation(START_PATTERN)</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our code begins with defining the starting pattern as per the FEN notation discussed earlier. We do not include the castle and En passant related notation, because we will not be coding that in our program.</li><li class="listitem" style="list-style-type: disc">We then define our <code class="literal">Board</code> class as a subclass of built-in <code class="literal">dict</code> type. This is because we will store the pattern as a dictionary.</li><li class="listitem" style="list-style-type: disc">We<a id="id366" class="indexterm"/> then define <code class="literal">x_axis</code> and <code class="literal">y_axis</code> for our chessboard as nonimmutable tuples.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">__init__</code> method of our class simply calls the <code class="literal">process_notation</code> method of the class.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec20"/>Step 5 – displaying pieces on board for a given FEN notation</h3></div></div></div><p>Pieces on <code class="literal">Board</code> for a given FEN notation can be displayed as follows:</p><div><pre class="programlisting">def process_notation(self, patt):
   self.clear()
   patt = patt.split('')
      # expand_whitespaces blanks

def expand_whitespaces(match): return '' * int(match.group(0))
   patt[0] = re.compile(r'\d').sub(expand_whitespaces, patt[0])
   for x, row in enumerate(patt[0].split('/')):
     for y, alphabet in enumerate(row):
        if alphabet == '': continue
        xycoord = self.alpha_notation((7-x,y))
        self[xycoord] = pieces.piece(alphabet)
        self[xycoord].ref(self)
     if patt[1] == 'w': self.player_turn = 'white'
     else: self.player_turn = 'black'</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The job of the <code class="literal">process_notation</code> method is to first expand the blank spaces represented by integers into actual spaces. It uses Python built-in regular expression module (<code class="literal">re</code>) to expand white spaces in a given FEN notation.</li><li class="listitem" style="list-style-type: disc">The code, <code class="literal">expand_whitespaces</code>, does something that might be tricky for Python beginners. It replaces each digit by the corresponding number of whitespaces, so you can later assume that a whitespace is an empty square. It then converts the FEN notation into a string corresponding to x and y alphanumeric coordinate for every piece. For doing this, it calls another method named <code class="literal">alpha_notation</code>, which is defined in step 7.</li><li class="listitem" style="list-style-type: disc">The final two lines keep a track of turns taken by the players.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec21"/>Step 6 – checking if a given coordinate is on the board</h3></div></div></div><p>Finally, let's end this iteration by defining a method to check if a given coordinate is on the board, as follows (see <em>code 4.02 chessboard.py</em>):</p><div><pre class="programlisting">def is_on_board(self, coord):
     ifcoord[1] &lt; 0 or coord[1] &gt; 7 or coord[0] &lt; 0 or coord[0] &gt;7:
        return False
     else: return True</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec22"/>Step 7 – generating alphabetic and numeric notation</h3></div></div></div><p>We <a id="id367" class="indexterm"/>need a way to convert the x and y coordinates for a piece to its alphabetic equivalent notation for example, A1, D5, E3, and so on. We accordingly define the <code class="literal">alpha_notation</code> method as follows:</p><div><pre class="programlisting">def alpha_notation(self,xycoord):
     if not self.is_on_board(xycoord): return
     return self.y_axis[xycoord[1]] + str(self.x_axis[xycoord[0]])</pre></div><p>Similarly, we define a method that takes in an x,y coordinate as input and returns its equivalent numerical notation, as follows:</p><div><pre class="programlisting">def num_notation(self, xycoord):
     return int(xycoord[1])-1, self.y_axis.index(xycoord[0])</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec23"/>Step 8 – checking places occupied on the board</h3></div></div></div><p>Before every move, we will need to check all the places occupied by all the pieces of a given color. This is required not only to calculate valid moves, but to also ensure that move by some other piece does not cause a check on the king.</p><p>Accordingly, let's define a method to return a list of coordinates occupied by a given color (see <em>code 4.02 chessboard.py</em>) as follows:</p><div><pre class="programlisting">def occupied(self, color):
     result = []
     for coord in self:
        if self[coord].color == color:
           result.append(coord)
           return result</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec24"/>Step 9 – handling errors and exceptions</h3></div></div></div><p>For handling errors and exceptions, we define a custom exception class named <code class="literal">ChessError</code>, and all other exceptions will later be subclassed to it, as follows:</p><div><pre class="programlisting">classChessError(Exception): pass</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec85"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>In this iteration,<a id="id368" class="indexterm"/> we created a basic <code class="literal">Piece</code> class and dummy child classes for each of the pieces found on the chessboard. The individual piece classes inherit from the parent <code class="literal">Piece</code> class. We handle color identification in the parent class because it is something we need to do for all child classes.</p><p>We then defined our <code class="literal">Board</code> class and added some methods that we will surely need every time we want to move a piece on the board.</p><p>We are yet to display those pieces on the board. We do that in the next iteration.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Adding pieces on the board</h1></div></div></div><p>We now have a code that converts the FEN notation to its expanded coordinate-based representation. <a id="id369" class="indexterm"/>Now, let's code to actually display chess pieces on the board, based on a given FEN notation, as shown in the following screenshot:</p><div><img src="img/7941_04_04.jpg" alt="Adding pieces on the board"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec86"/>Prepare for Lift Off</h2></div></div></div><p>We will use<a id="id370" class="indexterm"/> PNG images for displaying pieces on the board. We have provided PNG images for each piece in a folder named <code class="literal">pieces_image</code>. The images have been named by appending the shortname of each piece followed by the color of the piece. For instance, black queen is saved as <code class="literal">qblack.png</code>, and white knight is saved as <code class="literal">nwhite.png</code>.</p><p>We have chosen PNG over GIF because unlike GIF, PNG allows for alpha channels (variable transparency), automatic gamma correction on different platforms, and color correction.</p><p>However, the <code class="literal">TkinterPhotoImage </code>class does not support the PNG format. We, therefore, use the PIL to process PNG files.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>Currently, the <code class="literal">TkinterPhotoImage</code> class supports images in GIF, PPM, XBM, and PGM formats only. None of these formats are in vogue currently. Unfortunately, support for new formats can only be added if the Tcl/Tk starts supporting those formats.</p><p>Up till then, you may find it handy to use the PIL, which supports most of the popular image formats including PNG, JPEG, GIF, TIFF, and BMP.</p><p>In addition to displaying images in Tkinter, the PIL module can also be used for image processing, such as size transformations, format conversions, thumbnail creation, and several other image manipulation requirements.</p></div></div><p>We will add code for displaying chess pieces in our view file, <code class="literal">gui.py</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec87"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec25"/>Step 1 – importing PIL</h3></div></div></div><p>Because we will use the PIL module to display PNG images for our pieces, we start by importing <code class="literal">ImageTk</code> from the PIL module as follows:</p><div><pre class="programlisting">from PIL import ImageTk</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec26"/>Step 2 – defining method to draw pieces on chessboard</h3></div></div></div><p>The code for adding pieces on the board is as follows (see <em>code 4.03: gui.py</em>):</p><div><pre class="programlisting">def draw_pieces(self): 
   self.canvas.delete("occupied")
   for xycoord, piece in self.chessboard.iteritems():
     x,y = self.chessboard.num_notation(xycoord)
     if piece is not None:
        filename = "../pieces_image/%s%s.png" % (piece.shortname.lower(), piece.color)
        piecename = "%s%s%s" % (piece.shortname, x, y)
        if (filename not in self.images):
           self.images[filename] = ImageTk.PhotoImage(file=filename)
        self.canvas.create_image(0,0, image=self.images[filename], tags=(piecename, "occupied"), anchor="c")
        x0 = (y * self.dim_square) + int(self.dim_square/2)
        y0 = ((7-x) * self.dim_square) + int(self.dim_square/2)
        self.canvas.coords(piecename, x0, y0)</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We begin by importing <code class="literal">ImageTk</code> from the PIL module. We need this to handle PNG images.</li><li class="listitem" style="list-style-type: disc">We<a id="id371" class="indexterm"/> define our <code class="literal">draw_pieces()</code> method,<a id="id372" class="indexterm"/> whose role is to draw the pieces on a board for a given FEN notation. Because the FEN notation is available to all class methods, we need not pass it as an argument.</li><li class="listitem" style="list-style-type: disc">Recall that we have created an instance of the chessboard which produces a dictionary comprising of the coordinate-based location of a piece and the corresponding piece instance as the key-value pair.</li><li class="listitem" style="list-style-type: disc">We loop through the dictionary using <code class="literal">iteritems()</code>, and break down the x and y coordinate string into corresponding x-and-y-based number notation.</li><li class="listitem" style="list-style-type: disc">If there exists a piece for a given coordinate, we add it to the Canvas widget using <code class="literal">canvas.create_image()</code>.</li><li class="listitem" style="list-style-type: disc">One of the most important things to note here is that we have added two tags to each of the pieces: the name of the piece and a static string name <code class="literal">occupied</code>. Tags are the most important tool that you can use to operate on objects within the Canvas widget.</li><li class="listitem" style="list-style-type: disc">The next two lines create the x, y coordinate for a given board size.</li><li class="listitem" style="list-style-type: disc">The final line of the method uses <code class="literal">self.canvas.coords</code> to place the piece at the calculated coordinate.</li><li class="listitem" style="list-style-type: disc">Finally, we need to call our newly defined method. We do that from our <code class="literal">show()</code> method to invoke the pieces.</li></ul></div><div><div><h3 class="title"><a id="note30"/>Note</h3><p>Let's wrap<a id="id373" class="indexterm"/> this iteration by analyzing the two canvas-related methods used here.</p><p>
<strong>canvas.create_image(x, y, *options)</strong>:<a id="id374" class="indexterm"/> The <code class="literal">create_image</code> method takes two arguments that specify x and y coordinates for positioning the image. After the coordinates, you may specify any number of option-value pairs. In our example, we have used the <code class="literal">anchor="c"</code> option to keep the image in the center.</p><p>
<strong>canvas.coords(tag/id, x0, y0, x1, y1, ..., xn, yn)</strong>:<a id="id375" class="indexterm"/> The <code class="literal">coords()</code> method decides or modifies the coordinates for items attached to a given tag or ID. If coordinates are not specified, it returns a tuple specifying the coordinates of the item referenced by given tag or ID. If coordinates are specified, then they replace the current coordinates for the named item. If the tag or ID is attached to multiple items, only the first item is used.</p></div></div><p>We will learn about the Canvas widget in greater detail as we progress. However, you may find it useful to look at the interactive help for the Canvas widget, or a list of available methods and configurable options.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec88"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>Our code can now take a FEN notation and display the images for corresponding pieces on the chessboard. If you modify the FEN notation, the pieces on the chessboard will change their places accordingly.</p><p>In the process, we got acquainted with the basic features of the Canvas widget. We also saw two canvas-related methods to create image and to change the coordinates.</p><p>Finally, we saw how to overcome a Tkinter limitation on image handling by using the PIL module to handle formats not supported by Tkinter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Enforcing rules for pieces' movement</h1></div></div></div><p>Before we get these<a id="id376" class="indexterm"/> chess pieces to move on click of mouse, we need to know how many squares a given piece can move. We need to enforce rules for each of the chess pieces.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec89"/>Prepare for Lift Off</h2></div></div></div><p>Before we start coding the rules, let's quickly recap the rules of chess:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">King <a id="id377" class="indexterm"/>can move only one square in any direction: up, down, to the sides, and diagonally.</li><li class="listitem" style="list-style-type: disc">Queen can move in any one straight direction: forward, backward, sideways, or diagonally; as far as possible as long as she does not move through any of her own pieces.</li><li class="listitem" style="list-style-type: disc">Rook can move as far as it wants, but only forward, backward, and to the sides</li><li class="listitem" style="list-style-type: disc">Bishop can move as far as it wants, but only diagonally.</li><li class="listitem" style="list-style-type: disc">Knights are different from others. They must move two squares in one direction, and then one more move at a 90 degree angle, following the shape of <em>L</em>. Knights are also the only pieces that can jump over other pieces.</li><li class="listitem" style="list-style-type: disc">Pawns move forward, but capture diagonally. Pawns can only move forward one square at a time, except for their very first move where they can move forward two squares. Pawns can only capture one square diagonally in front of them.</li></ul></div><p>The bottom line here is that we need to track three common things for each of the piece:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Its current position</li><li class="listitem" style="list-style-type: disc">Allowed directions for movement</li><li class="listitem" style="list-style-type: disc">Distance that a piece can move</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec90"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec27"/>Step 1 – tracking moves available for all pieces from Pieces superclass</h3></div></div></div><p>Because the preceding things can be tracked at a central place, let's define a method named <code class="literal">moves_available</code> in our superclass, <code class="literal">Pieces</code> (see <em>code 4.04: pieces.py</em>), for tracking moves available for all pieces as follows:</p><div><pre class="programlisting">    def moves_available(self, pos, diagonal, orthogonal, distance):
        board = self.board
        allowed_moves = []
        orth  = ((-1,0),(0,-1),(0,1),(1,0))
        diag  = ((-1,-1),(-1,1),(1,-1),(1,1))
        piece = self
        beginningpos = board.num_notation(pos.upper())
        if orthogonal and diagonal:
            directions = diag+orth
        elif diagonal:
            directions = diag
        elif orthogonal:
            directions = orth

        for x,y in directions:
            collision = False
            for step in range(1, distance+1):
                if collision: break
                dest = beginningpos[0]+step*x, beginningpos[1]+step*y
                if self.board.alpha_notation(dest) not in board.occupied('white') + board.occupied('black'):
                    allowed_moves.append(dest)
                elif self.board.alpha_notation(dest) in board.occupied(piece.color):
                    collision = True
                else:
                    allowed_moves.append(dest)
                    collision = True
        allowed_moves = filter(board.is_on_board, allowed_moves)
        return map(board.alpha_notation, allowed_moves)</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id378" class="indexterm"/> method accepts four arguments: the current position of a piece, two Boolean values representing whether or not diagonal and orthogonal movements are allowed for a piece, and the number of squares a piece can move at one time.</li><li class="listitem" style="list-style-type: disc">Depending upon these arguments, the method collects all allowed moves for a given piece in a list, <code class="literal">allowed_moves</code>.</li><li class="listitem" style="list-style-type: disc">Having collected all directions of movements, the code iterates through all locations to detect any possible collision. If collision is detected, it breaks out of the loop, else it appends the coordinate to <code class="literal">allowed_moveslist</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">collision = True</code> is our way to break out of the loop. We need to break out of the loop in two cases: when the destination is occupied, and when it is not occupied, and we have already appended that position into our list of possible moves.</li><li class="listitem" style="list-style-type: disc">The second last line filters out those moves that fall out of the board, and the last line returns the equivalent board notations for all allowed moves.</li></ul></div><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Having defined our <code class="literal">moves_available </code>method, we now simply need to call it from different pieces class.(see <em>code 4.04: pieces.py</em>).</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec28"/>Step 2 – rules for the king, queen, rook and bishop class</h3></div></div></div><p>King, queen,<a id="id379" class="indexterm"/> rook, and bishop pieces on the chessboard have relatively simple rules governing them. These pieces can capture only in the direction in which they move.</p><p>Moreover, they move in either orthogonal, diagonal, or a combination of these two directions. We have already coded <code class="literal">moves_available</code> in our superclass to handle these directions.</p><p>Accordingly, deciding their available moves is just a matter of passing the right arguments to our <code class="literal">moves_available</code> method.</p><div><pre class="programlisting">class King(Piece):
   shortname = 'k'
   def moves_available(self,pos):
     return super(King, self).moves_available(pos.upper(), True, True, 1)
class Queen(Piece):
   shortname = 'q'
   def moves_available(self,pos):
     return super(Queen,self).moves_available(pos.upper(), True, True, 8)
class Rook(Piece):
   shortname = 'r'
   def moves_available(self,pos):
     return super(Rook, self).moves_available(pos.upper(), False, True, 8)
class Bishop(Piece):
   shortname = 'b'
   def moves_available(self,pos):
     return super(Bishop,self).moves_available(pos.upper(), True, False, 8)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec29"/>Step 3 – rules for knight</h3></div></div></div><p>Knight is a different<a id="id380" class="indexterm"/> beast because it does not move orthogonally or diagonally. It can also jump over pieces.</p><p>Let's, therefore override the <code class="literal">moves_available</code> method from our <code class="literal">Knight</code> class.</p><p>The <code class="literal">Knight</code> class is defined as follows (see <em>code 4.04: pieces.py</em>):</p><div><pre class="programlisting">class Knight(Piece):
   shortname = 'n'
   def moves_available(self,pos):
     board = self.board
     allowed_moves = []
     beginningpos = board.num_notation(pos.upper())
     piece = board.get(pos.upper())
     changes=((-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1))
     for x,y in changes:
        dest = beginningpos[0]+x, beginningpos[1]+y
        if(board.alpha_notation(dest) not in board.occupied(piece.color)):
           allowed_moves.append(dest)
        allowed_moves = filter(board.is_on_board, allowed_moves)
     return map(board.alpha_notation, allowed_moves)</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The method is quite similar to our previous super class method. However, unlike the super class method, the changes are represented to capture moves two squares in one direction, and then one more move at a 90 degree angle.</li><li class="listitem" style="list-style-type: disc">Similarly, unlike the super class, we do not need to track collisions, because knights can jump over other pieces.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec30"/>Step 4 – rules for pawn</h3></div></div></div><p>Pawn too has a unique movement, in that it moves forward, but captures diagonally.</p><p>Let's similarly override the <code class="literal">moves_available</code> class from within the <code class="literal">Pawn</code> class as follows (see <em>code 4.04: pieces.py</em>):</p><div><pre class="programlisting">class Pawn(Piece):
    shortname = 'p'
    def moves_available(self, pos):
        board = self.board        
        piece = self
        if self.color == 'white':
            startpos, direction, enemy = 1, 1, 'black'
        else:
            startpos, direction, enemy = 6, -1, 'white'
        allowed_moves = []
        prohibited = board.occupied('white') + board.occupied('black')
        beginningpos   = board.num_notation(pos.upper())
        forward = beginningpos[0] + direction, beginningpos[1]
        # Can a piece move forward?
        if board.alpha_notation(forward) not in prohibited:
            allowed_moves.append(forward)
            if beginningpos[0] == startpos:
                # If pawn in starting pos allow a double move
                double_forward = (forward[0] + direction, forward[1])
                if board.alpha_notation(double_forward) not in prohibited:
                    allowed_moves.append(double_forward)
        # Check for Capturing Moves Available
        for a in range(-1, 2, 2):
            attack = beginningpos[0] + direction, beginningpos[1] + a
            if board.letter_notation(attack) in board.occupied(enemy):
                allowed_moves.append(attack)
        allowed_moves = filter(board.is_on_board, allowed_moves)
        return map(board.alpha_notation, allowed_moves)</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We first<a id="id381" class="indexterm"/> assign variables <code class="literal">startpos</code>, <code class="literal">direction</code>, and <code class="literal">enemy </code>depending on whether the pawn is black or white.</li><li class="listitem" style="list-style-type: disc">Similar to our previous <code class="literal">moves_allowed</code> methods, this method also collects all allowed moves in a blank list, <code class="literal">allowed_moves</code>.</li><li class="listitem" style="list-style-type: disc">We then collect a list of all prohibited moves by concatenating two lists of squares occupied by all black and white pieces.</li><li class="listitem" style="list-style-type: disc">We define a list, <code class="literal">forward</code>, which holds the position of the one square immediately ahead of the current position of pawn.</li><li class="listitem" style="list-style-type: disc">A pawn cannot move forward if there is a piece in front of it. If the forward position is not prohibited, the position is appended to our <code class="literal">allowed_moves</code> list.</li><li class="listitem" style="list-style-type: disc">A pawn can move two places forward from its starting position. We check to see if the current position is the starting position, and if true, we append the double move to our <code class="literal">allowed_moves</code> list.</li><li class="listitem" style="list-style-type: disc">A pawn can capture only diagonally adjacent pieces in front of it. We, therefore, assign a variable attack to track the diagonally adjacent positions on the board. If the diagonally adjacent square is occupied by an enemy, that position qualifies to be appended to our list, <code class="literal">allowed_moves</code>.</li><li class="listitem" style="list-style-type: disc">We then filter our list to remove all positions which may fall off the board.</li><li class="listitem" style="list-style-type: disc">The last<a id="id382" class="indexterm"/> line returns all allowed moves as a list of corresponding letter notations, as we had done in all our previous definitions.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec91"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>In this iteration, we coded the logic for enforcing rules related to movement of chess pieces on the board.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>The chessboard logic</h1></div></div></div><p>Before we allow chess pieces to move on click of the mouse button, we must have a record of all possible movement options on the board. At every move, we also need to check that it is a legitimate turn for a given player, and that the proposed move should not cause a check on the king.</p><p>Now a check may <a id="id383" class="indexterm"/>occur on the king, not only from a piece that was moved, but from any other piece on the board as a consequence of such movement. Thus, after every move, we need to calculate the possible moves for all the pieces of the opponent.</p><p>Accordingly we will need two methods to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keep track of all available moves for a player</li><li class="listitem" style="list-style-type: disc">Verify if there is a check on the king</li></ul></div><p>Let's add the code for the preceding methods into our <code class="literal">Board</code> class. (See <em>code 4.05: chessboard.py</em>)</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec92"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec31"/>Step 1: Tracking all Available Moves</h3></div></div></div><p>The code for keeping track of all available moves for a player is as follows:</p><div><pre class="programlisting">def all_moves_available(self, color):
   result = []
   for coord in self.keys():
     if (self[coord] is not None) and self[coord].color == color:
        moves = self[coord].moves_available(coord)
        if moves: result += moves
   return result</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have already coded our <code class="literal">moves_available</code> method<a id="id384" class="indexterm"/> in the previous iteration. This method simply iterates through every item in the dictionary and appends the <code class="literal">moves_available</code> result for each piece of a given color in a list named <code class="literal">result</code>.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec32"/>Step 2: Getting Current Position of King</h3></div></div></div><p>Before we code the method to verify if a king is in check, we first need to know the exact position of the king. Let's define a method to get the current position of the king, as follows (see <em>code 4.05: chessboard.py</em>):</p><div><pre class="programlisting">def position_of_king(self, color):
   for pos in self.keys():
     if is instance(self[pos], pieces.King) and self[pos].color == color:
        return pos</pre></div><p>The preceding code simply iterates through all items in the dictionary. If a given position is an instance of the <code class="literal">King</code> class, it simply returns its position.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec33"/>Step 3: Verifying if King is under Check</h3></div></div></div><p>Finally, we define a method to verify if the king is under check from the opponent as follows:</p><div><pre class="programlisting">def king_in_check(self, color):
   kingpos =  self.position_of_king(color)
   opponent = ('black' if color =='white' else 'white')
   for pieces in self.iteritems():
     if kingpos in self.all_moves_available(opponent):
        return True
     else:
        return False</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We<a id="id385" class="indexterm"/> first obtain the current position of the king, and the color of the opponent.</li><li class="listitem" style="list-style-type: disc">We then iterate through all possible moves for all pieces of the opponent. If the position of the king coincides with any position from all possible moves, the king is under check, and we return <code class="literal">True</code>, else we return <code class="literal">False</code>.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec93"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes our objectives for the iteration. We are now in a position to check for all available moves for a player at a given point in the game. We can also verify if a king is under check from the opponent team.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Making the chess functional</h1></div></div></div><p>Now that we<a id="id386" class="indexterm"/> have all pieces and board-related validation rules in place, let's now add life to our chess. In this iteration, we will make our chess game fully functional.</p><p>In a game between two players, our chessboard would be like one shown in the following screenshot:</p><div><img src="img/7941_04_05.jpg" alt="Making the chess functional"/></div><p>The objective for this iteration is to move pieces on click of the left mouse button. When a player clicks on a piece, our code should first check if it is a legitimate turn for that piece.</p><p>On the first click,<a id="id387" class="indexterm"/> the piece to be moved is selected, and all allowed moves for that piece are highlighted on the board. The second click should happen on the destination square. If the second click is done on a valid destination square, the piece should move from the source square to the destination square.</p><p>We also need to code the events of capturing of pieces and check on king. Other attributes to be tracked include list of captured pieces, halfmove clock count, fullmove number count, and history of all previous moves.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec94"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec34"/>Step 1 – updating the board for change in FEN notation</h3></div></div></div><p>So far, we have the ability to take the original FEN notation and display it on board. However, we need a way that takes any FEN notation and updates the display on the board. We define a new method named <code class="literal">show()</code> to do this, as follows:</p><div><pre class="programlisting">def show(self, pat):
        self.clear()
        pat = pat.split(' ')
        def expand(match): return ' ' * int(match.group(0))
        pat[0] = re.compile(r'\d').sub(expand, pat[0])
        for x, row in enumerate(pat[0].split('/')):
            for y, letter in enumerate(row):
                if letter == ' ': continue
                coord = self.alpha_notation((7-x,y))
                self[coord] = pieces.create_piece(letter)
                self[coord].place(self)
        if pat[1] == 'w': self.player_turn = 'white'
        else: self.player_turn = 'black'
        self.halfmove_clock = int(pat[2])
        self.fullmove_number = int(pat[3])</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec35"/>Step 2 – binding mouse click event</h3></div></div></div><p>The pieces need to move on click of the mouse. So, we need to track the mouse click event. We only need to track mouse clicks on the Canvas widget. Let us, therefore, add an event handler to our <code class="literal">GUI</code> class immediately after the code that created the Canvas widget in the <code class="literal">init</code> method as follows (see <em>code 4.06: gui.py, __init__ method</em>):</p><div><pre class="programlisting">self.canvas.bind("&lt;Button-1&gt;", self.square_clicked)</pre></div><p>This will bind the left mouse click event to a new method, <code class="literal">square_clicked</code>. However, before we sit down and define this method, let's pause and think about the attributes we need to keep tracking our program.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec36"/>Step 3 – adding attribute to track selected piece and remaining pieces</h3></div></div></div><p>First of all, we need to track all pieces remaining on the board after every move. So we will create a dictionary pieces to keep track of this. We also need to track the name of the piece selected by the mouse click. We store that in an attribute, <code class="literal">selected_piece</code>. When a player clicks on a piece, we need to highlight all valid moves for that piece. We store all valid moves for that piece in a list named <code class="literal">focused</code>. Let's define these three attributes in our <code class="literal">GUI</code> class before defining any of the methods. We modify our <code class="literal">GUI</code> class to include these attributes as follows:</p><div><pre class="programlisting">class GUI:
   pieces = {}
   selected_piece = None
   focused = None
   #other attributes from previous iterations</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec37"/>Step 4 – identifying square clicked</h3></div></div></div><p>We will code our <code class="literal">square_clicked</code> method that gets called from the event handler we defined earlier.</p><p>The desired functionality of this method is twofold. We should be able to locate the coordinate of a piece being clicked. The first click should select a given piece. The second click should move the piece from<a id="id388" class="indexterm"/> the source square to the destination square.</p><p>The method is defined as follows(see <em>code 4.06: gui.py</em>):</p><div><pre class="programlisting">def square_clicked(self, event):
   col_size = row_size = self.dim_square
   selected_column = event.x / col_size
   selected_row = 7 - (event.y / row_size)
   pos = self.chessboard.alpha_notation((selected_row, selected_column))
   try:
     piece = self.chessboard[pos]
   except:
     pass
   if self.selected_piece:
      self.shift(self.selected_piece[1], pos)
      self.selected_piece = None
      self.focused = None
      self.pieces = {}
      self.draw_board()
      self.draw_pieces()
   self.focus(pos)
   self.draw_board()</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first part of code calculates the coordinates for the piece clicked. Based on the calculated coordinates, it stores the corresponding letter notation in a variable named <code class="literal">pos</code>.</li><li class="listitem" style="list-style-type: disc">It then tries to assign the variable piece to the corresponding piece instance. If there is no piece instance on the clicked square, it simply ignores the click.</li><li class="listitem" style="list-style-type: disc">The second part of the method checks if this is the second click intended to move a piece to a destination square. If this is the second click, it calls the <code class="literal">shift</code> method, passing in the source and destination coordinates as its two arguments.</li><li class="listitem" style="list-style-type: disc">If shift succeeds, it sets back all previously set attributes to their original empty values and calls our <code class="literal">draw_board</code> and <code class="literal">draw_pieces</code> method to redraw the board and pieces.</li><li class="listitem" style="list-style-type: disc">If this is the first click, it calls a method named <code class="literal">focus </code>to highlight all available moves for the first click, followed by a call to draw the fresh board.</li></ul></div><p>While<a id="id389" class="indexterm"/> coding the desired functionality for the <code class="literal">square_clicked</code> method, we called several new methods from within it. We need to define those new methods.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec38"/>Step 5 – getting the source and destination position</h3></div></div></div><p>We have called the <code class="literal">shift</code> method from the<a id="id390" class="indexterm"/> <code class="literal">square_clicked</code> method. The following shift code implemented is simply responsible for collecting the necessary arguments required for the shift operation.</p><p>In the spirit of keeping logic separate from presentation, we do not process shift-related rules in this view class. Instead, we delegate the <code class="literal">shift</code> method work from the <code class="literal">GUI</code> to <code class="literal">Board</code> class. Once the logic or validation for shift has been implemented, the visible part of the shift of pieces again takes place in the <code class="literal">draw_board</code> method of our <code class="literal">GUI</code> class.</p><p>Although this may seem like overkill at first, structuring logic and presentation in different layers is very important for code reuse, scalability, and maintainability.</p><p>The code is as follows:</p><div><pre class="programlisting">def shift(self, p1, p2):
   piece = self.chessboard[p1]
   try:
     dest_piece = self.chessboard[p2]
   except:
     dest_piece = None
   if dest_piece is None or dest_piece.color != piece.color:
     try:
        self.chessboard.shift(p1, p2)
     except:
        pass</pre></div><p>The code first checks if there exists a piece on the destination. If a piece does not exist at the destination square, it calls on a method, <code class="literal">shift</code>, from <code class="literal">chessboard.py</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>Step 6 – collecting list of moves to highlight</h3></div></div></div><p>We have also called the focus method from <code class="literal">square_clicked</code> method. The purpose of this <a id="id391" class="indexterm"/>method is to collect all possible moves for a given piece in a list named <code class="literal">focused</code>. The actual focusing of available moves takes place in the <code class="literal">draw_board</code> method of our GUI class.</p><p>The code is as follows (see code 4.06: gui.py):</p><div><pre class="programlisting">def focus(self, pos):
   try:
     piece = self.chessboard[pos]
   except:
     piece=None
   if piece is not None and (piece.color == self.chessboard.player_turn):
     self.selected_piece = (self.chessboard[pos], pos)
     self.focused = map(self.chessboard.num_notation, (self.chessboard[pos].moves_available(pos)))</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>Step 7 – modifying draw_board to highlight allowed moves</h3></div></div></div><p>In the <code class="literal">square_clicked</code> method, we called the <code class="literal">draw_board</code> method to take care of redrawing or changing the coordinates for our pieces. Our current <code class="literal">draw_board</code> method is not equipped to handle this, because we had designed it in the first iteration only to provide us with a blank board. Let's first modify our <code class="literal">draw_board</code> method to handle this, as follows (see <em>code 4.06: gui.py</em>):</p><div><pre class="programlisting">highlightcolor ="khaki"
def draw_board(self):
    color = self.color2
    for row in range(self.rows):
     color = self.color1 if color == self.color2 else self.color2
     for col in range(self.columns):
        x1 = (col * self.dim_square)
        y1 = ((7-row) * self.dim_square)
        x2 = x1 + self.dim_square
        y2 = y1 + self.dim_square
<strong>        if(self.focused is not None and (row, col) in self.focused):</strong>
<strong>        self.canvas.create_rectangle(x1, y1, x2, y2, fill=self.highlightcolor, tags="area")</strong>
        else:
           self.canvas.create_rectangle(x1, y1, x2, y2, fill=color, tags="area")
           color = self.color1 if color == self.color2 else self.color2
<strong>   for name in self.pieces:</strong>
<strong>     self.pieces[name] = (self.pieces[name][0], self.pieces[name][1])</strong>
<strong>     x0 = (self.pieces[name][1] * self.dim_square) + int(self.dim_square/2)</strong>
<strong>     y0 = ((7-self.pieces[name][0]) * self.dim_square) + int(self.dim_square/2)</strong>
<strong>     self.canvas.coords(name, x0, y0)</strong>
<strong>   self.canvas.tag_raise("occupied")</strong>
<strong>   self.canvas.tag_lower("area")</strong>
</pre></div><p>The<a id="id392" class="indexterm"/> description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The additions made to our existing <code class="literal">draw_board</code> method are highlighted in the preceding code. We first define an attribute named <code class="literal">highlightcolor</code>, and assign it a color.</li><li class="listitem" style="list-style-type: disc">In essence, the code has been modified to handle the clicks. The first section of highlighted code fills a different color to highlight all available moves.</li><li class="listitem" style="list-style-type: disc">The second section of highlighted code changes the coordinates of the piece instance to be located on new coordinates. Note the use of <code class="literal">canvas.coords(name, x0, y0)</code> to change the coordinates.</li><li class="listitem" style="list-style-type: disc">The last two lines change the precedence of options specified by tags.</li></ul></div><div><div><h3 class="title"><a id="note32"/>Note</h3><p>If an object on the canvas is tagged to multiple tags, options defined for tags at the top of the stack have higher precedence. You can, however, change the precedence of tags by using <code class="literal">tag_raise(name)</code> or <code class="literal">tag_lower(name)</code>.</p><p>For a complete list of canvas-related options, refer to interactive help for the Canvas widget using <code class="literal">help(Tkinter.Canvas)</code> in the command line.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>Step 8 – defining attributes to keep game statistics</h3></div></div></div><p>As a consequence of adding mobility to our pieces, we need to add the following<a id="id393" class="indexterm"/> new attributes to our <code class="literal">Board</code> class to keep game statistics, as follows (see <em>code 4.06: chessboard.py</em>):</p><div><pre class="programlisting">Class Board(dict):
   #other attributes from previous iteration
   captured_pieces = { 'white': [], 'black': [] }
   player_turn = None
   halfmove_clock = 0
   fullmove_number = 1
   history = []</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Step 9 – preshift validations</h3></div></div></div><p>For that, we will code the <code class="literal">shift</code> method of our <code class="literal">Board</code> class, as follows (see <em>code 4.06: chessboard.py</em>):</p><div><pre class="programlisting">    def shift(self, p1, p2):
        p1, p2 = p1.upper(), p2.upper()
        piece = self[p1]
        try:
            dest  = self[p2]
        except:
            dest = None
        if self.player_turn != piece.color:
            raise NotYourTurn("Not " + piece.color + "'s turn!")
        enemy = ('white' if piece.color == 'black' else 'black' )
        moves_available = piece.moves_available(p1)
        if p2 not in moves_available:
            raise InvalidMove
        if self.all_moves_available(enemy):
            if self.is_in_check_after_move(p1,p2):
                raise Check
        if not moves_available and self.king_in_check(piece.color):
            raise CheckMate
        elif not moves_available:
            raise Draw
        else:
            self.move(p1, p2)
            self.complete_move(piece, dest, p1,p2)</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The code first checks if there exists a piece on the destination.</li><li class="listitem" style="list-style-type: disc">It then checks if it is a valid turn for the player. If not, it raises an exception.</li><li class="listitem" style="list-style-type: disc">It then checks if the move is proposed to occur to a valid location. If a player attempts to move a piece to an invalid location, it raises a corresponding exception.</li><li class="listitem" style="list-style-type: disc">It then<a id="id394" class="indexterm"/> checks if there is a check on the king. To do that, it calls a method named <code class="literal">is_in_check_after_move</code>, which is defined as follows:<div><pre class="programlisting">def is_in_check_after_move(self, p1, p2):
    temp = deepcopy(self)
    temp.unvalidated_move(p1,p2)
    returntemp.king_in_check(self[p1].color)</pre></div></li><li class="listitem" style="list-style-type: disc">This method creates a deep temporary copy of the object and tries to move the piece on the temporary copy. As a note, shallow copy of a collection is a copy of the collection structure, not the elements. When you do a shallow copy, the two collections now share the individual elements, so a modification at one place affects the other as well. In contrast, deep copies makes copy of everything, the structure as well as the elements. We need to create a deep copy of the board, because we want to check if the king makes a valid move before it actually moves and we want to do that without modifying the original object state in any way.</li><li class="listitem" style="list-style-type: disc">After executing the move on the temporary copy, it checks if the king is in check to return <code class="literal">True</code> or <code class="literal">False</code>. If the king is in check on the temporary board, it raises an exception, not allowing such a move on our actual board.</li><li class="listitem" style="list-style-type: disc">Similarly, it checks for possible occurrence of checkmate or draw and raises exceptions accordingly.</li><li class="listitem" style="list-style-type: disc">If no exceptions are made, it finally calls a method named <code class="literal">move</code>, which actually executes the move.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Step 10 – actual movement of pieces</h3></div></div></div><p>Actual movement of pieces can be coded as follows:</p><div><pre class="programlisting">def move(self, p1, p2):
   piece = self[p1]
   try:
     dest = self[p2]
   except:
     pass

   del self[p1]
   self[p2] = piece</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Step 11 – Post movement updates</h3></div></div></div><p>After the move has actually been executed, it calls another method named <code class="literal">complete_move</code>, which updates game statistics as follows:</p><div><pre class="programlisting">    def complete_move(self, piece, dest, p1, p2):
        enemy = ('white' if piece.color == 'black' else 'black' )
        if piece.color == 'black':
            self.fullmove_number += 1
        self.halfmove_clock +=1
        self.player_turn = enemy
        abbr = piece.shortname
        if abbr == 'P':
            abbr = ''
            self.halfmove_clock = 0
        if dest is None:
            movetext = abbr +  p2.lower()
        else:
            movetext = abbr + 'x' + p2.lower()
            self.halfmove_clock = 0
        self.history.append(movetext)</pre></div><p>The <a id="id395" class="indexterm"/>preceding method does the following tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Keeps track of statistics, such as number of moves, halfmove clock</li><li class="listitem" style="list-style-type: disc">Changes the player's turn</li><li class="listitem" style="list-style-type: disc">Checks if a pawn has been moved so as to reset the halfmove clock</li><li class="listitem" style="list-style-type: disc">And finally, appends the last move to our history list</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>Step 12 – classes to handle exceptions and errors</h3></div></div></div><p>Finally, we add the following empty classes for various exceptions raised by us:</p><div><pre class="programlisting">class Check(ChessError): pass
classInvalidMove(ChessError): pass
classCheckMate(ChessError): pass
class Draw(ChessError): pass
classNotYourTurn(ChessError): pass</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec95"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>Let's summarize<a id="id396" class="indexterm"/> things that we did in this iteration</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We started by binding a mouse click event to a method named <code class="literal">square_clicked</code>.</li><li class="listitem" style="list-style-type: disc">We added attributes to track selected piece and remaining pieces on the board.</li><li class="listitem" style="list-style-type: disc">We then identified the square clicked, followed by collecting the source and destination position.</li><li class="listitem" style="list-style-type: disc">We also collected a list of all possible moves for the selected piece, and then highlighted them.</li><li class="listitem" style="list-style-type: disc">We then defined attributes to keep vital game statistics.</li><li class="listitem" style="list-style-type: disc">We then did some preshift validations, followed by actual movement of pieces on the board.</li><li class="listitem" style="list-style-type: disc">After a piece had been moved, we updated statistics about the game.</li><li class="listitem" style="list-style-type: disc">We had defined several exceptions in this iteration. We simply defined empty classes to handle them silently. </li></ul></div><p>Our chess game is now functional. Two players can now play a game of chess on our application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Adding menu and an info frame</h1></div></div></div><p>Though our game is fully functional, let's add two small features to it.</p><p>Let's add a <a id="id397" class="indexterm"/>top menu item by navigating to <strong>File</strong> | <strong>New Game</strong>. When clicked, it should reset the board to a new game.</p><p>Additionally, <a id="id398" class="indexterm"/>let's add a small frame at the bottom to display game-related information, such as the last move, next turn, check, draw, and checkmate.</p><div><img src="img/7941_04_06.jpg" alt="Adding menu and an info frame"/></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec96"/>Engage Thrusters</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>Step 1 – creating top menu</h3></div></div></div><p>Our<a id="id399" class="indexterm"/> Canvas widget was set up in the the <code class="literal">__init__</code> method of our <code class="literal">GUI</code> class.</p><p>Let's modify it to include the top menu, as follows (see <em>code 4.06: gui.py</em>):</p><div><pre class="programlisting">def __init__(self, parent, chessboard):
   self.chessboard = chessboard
   self.parent = parent
<strong>   self.menubar = Menu(parent)</strong>
<strong>   self.filemenu = Menu(self.menubar, tearoff=0)</strong>
<strong>   self.filemenu.add_command(label="New Game", command=self.new_game)</strong>
<strong>   self.menubar.add_cascade(label="File", menu=self.filemenu)</strong>
<strong>   self.parent.config(menu=self.menubar)</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Step 2 – adding the bottom frame to display game statistics</h3></div></div></div><p>Let's also<a id="id400" class="indexterm"/> add a bottom frame to display game statistics to the same <code class="literal">__init__</code> method, as follows:</p><div><pre class="programlisting">self.btmfrm = Frame(parent, height=64)
self.info_label = Label(self.btmfrm, text="   White to Start the Game  ", fg=self.color2)
self.info_label.pack(side=RIGHT, padx=8, pady=5)
self.btmfrm.pack(fill="x", side=BOTTOM)</pre></div><p>The modification to existing init method is highlighted. The code is self-explanatory. We have done similar things in all our previous projects.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Step 3 – starting a new game from File | New game menu</h3></div></div></div><p>The <strong>File</strong> | <strong>New game </strong>menu item calls on our method, <code class="literal">new_game()</code>. The code for <code class="literal">new_game()</code> is as follows (see <em>code 4.06: gui.py</em>):</p><div><pre class="programlisting">def new_game(self):
    self.chessboard.show(chessboard.START_PATTERN)
    self.draw_board()
    self.draw_pieces()
    self.info_label.config(text="White to Start the Game", fg='red')</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Step 4 – updating bottom label after every move</h3></div></div></div><p>Finally, after every move, we want to update the label with details of the move and information about the next players turn. We also want to update the frame <a id="id401" class="indexterm"/>to display any error or exception that may have occurred during the move attempt. We accordingly modify the <code class="literal">shift</code> method of our <code class="literal">GUI</code> class to do this update for us as follows:</p><div><pre class="programlisting">def shift(self, p1, p2):
   piece = self.chessboard[p1]
   try:
     dest_piece = self.chessboard[p2]
   except:
     dest_piece = None
   if dest_piece is None or dest_piece.color != piece.color:
     try:
        self.chessboard.shift(p1,p2)
<strong>     exceptchessboard.ChessError as error:</strong>
<strong>        self.info_label["text"] = error.__class__.__name__</strong>
<strong>     else:</strong>
<strong>        turn = ('white' if piece.color == 'black' else 'black')</strong>
<strong>     self.info_label["text"] = '' + piece.color.capitalize() +"  :  "+ p1 + p2 + '' + turn.capitalize() + '\'s turn'</strong>
</pre></div><p>The description of the code is listed as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id402" class="indexterm"/> modifications to our <code class="literal">shift</code> method<a id="id403" class="indexterm"/> are highlighted. We have simply included the <code class="literal">shift</code> method of our <code class="literal">Board </code>class in a try except block. If the shift is successful, the Label widget is updated to show the current move and the next players turn.</li><li class="listitem" style="list-style-type: disc">If the shift is not successful, either because of invalid move or a check on the king, the corresponding error class name is displayed in the label with <code class="literal">error.__class__.__name__</code>.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec97"/>Objective Complete – Mini Debriefing</h2></div></div></div><p>This completes our goal for the iteration. The application now displays some useful information to the players during the course of a chess game.</p><p>We also added a <strong>File</strong> | <strong>New menu</strong> item, which can be used to reset the board to starting position.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Mission Accomplished</h1></div></div></div><p>We now come to the end of the project.</p><p>So what is it that we have achieved here? Let's list all the key learning from this project:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to structure a program into its model and view components</li><li class="listitem" style="list-style-type: disc">How to represent a problem domain in a desired notation</li><li class="listitem" style="list-style-type: disc">Peek into the versatility and power of the Tkinter Canvas widget</li><li class="listitem" style="list-style-type: disc">Basic usage of Canvas coordinates, object IDs and tags</li><li class="listitem" style="list-style-type: disc">How to work with newer image formats</li><li class="listitem" style="list-style-type: disc">Typical interaction of logic and presentation layers in a GUI program</li></ul></div><p>Next project onwards, we take a look at different Tkinter widgets in greater detail.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>A Hotshot Challenge</h1></div></div></div><p>Here are the two hotshot challenges for you:</p><div><ol class="orderedlist arabic"><li class="listitem">Add <a id="id404" class="indexterm"/>and implement the following menu items:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>File</strong> | <strong>Save</strong>: Save a game state</li><li class="listitem" style="list-style-type: disc"><strong>File</strong> | <strong>Open</strong>: Loads a previously saved game</li><li class="listitem" style="list-style-type: disc"><strong>Edit</strong>| <strong>Undo</strong>: To let the players undo the turns played</li><li class="listitem" style="list-style-type: disc"><strong>Edit</strong> |<strong>Redo</strong>: To let the players redo any previous undo</li><li class="listitem" style="list-style-type: disc"><strong>View</strong> | <strong>Moves History</strong>: Opens a new Toplevel window to display the history of the game</li><li class="listitem" style="list-style-type: disc"><strong>About</strong>| <strong>About</strong>: Displays information about the game</li></ul></div></li><li class="listitem">Implement castling and En passant features in the game.</li></ol></div></div></body></html>