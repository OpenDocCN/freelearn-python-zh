["```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 2\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n# See more: http://docs.python.org/2/library/socketserver.html\n\nimport os\nimport socket\nimport threading\nimport SocketServer\n\nSERVER_HOST = 'localhost'\nSERVER_PORT = 0 # tells the kernel to pick up a port dynamically\nBUF_SIZE = 1024\nECHO_MSG = 'Hello echo server!'\n\nclass ForkedClient():\n    \"\"\" A client to test forking server\"\"\"    \n    def __init__(self, ip, port):\n        # Create a socket\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        # Connect to the server\n\t     self.sock.connect((ip, port))\n\n    def run(self):\n        \"\"\" Client playing with the server\"\"\"\n        # Send the data to server\n        current_process_id = os.getpid()\n        print 'PID %s Sending echo message to the server : \"%s\"' % (current_process_id, ECHO_MSG)\n        sent_data_length = self.sock.send(ECHO_MSG)\n        print \"Sent: %d characters, so far...\" %sent_data_length\n\n        # Display server response\n        response = self.sock.recv(BUF_SIZE)\n        print \"PID %s received: %s\" % (current_process_id, response[5:])\n\n    def shutdown(self):\n        \"\"\" Cleanup the client socket \"\"\"\n        self.sock.close()\n\nclass ForkingServerRequestHandler(SocketServer.BaseRequestHandler):\n\n    def handle(self):        \n        # Send the echo back to the client\n        data = self.request.recv(BUF_SIZE)\n        current_process_id = os.getpid()\n        response = '%s: %s' % (current_process_id, data)\n        print \"Server sending response [current_process_id: data] = [%s]\" %response\n        self.request.send(response)\n        return\n\nclass ForkingServer(SocketServer.ForkingMixIn,\n                    SocketServer.TCPServer,\n                    ):\n    \"\"\"Nothing to add here, inherited everything necessary from parents\"\"\"\n    pass\n\ndef main():\n    # Launch the server\n    server = ForkingServer((SERVER_HOST, SERVER_PORT), ForkingServerRequestHandler)\n    ip, port = server.server_address # Retrieve the port number\n    server_thread = threading.Thread(target=server.serve_forever)\n    server_thread.setDaemon(True) # don't hang on exit\n    server_thread.start()\n    print 'Server loop running PID: %s' %os.getpid()\n\n    # Launch the client(s)\n    client1 =  ForkedClient(ip, port)\n    client1.run()\n\n    client2 =  ForkedClient(ip, port)\n    client2.run()\n\n    # Clean them up\n    server.shutdown()\n    client1.shutdown()\n    client2.shutdown()\n    server.socket.close()\n\nif __name__ == '__main__':\n    main()\n```", "```py\n$ python 2_1_forking_mixin_socket_server.py\nServer loop running PID: 12608\nPID 12608 Sending echo message to the server : \"Hello echo server!\"\nSent: 18 characters, so far...\nServer sending response [current_process_id: data] = [12610: Hello echo server!]\nPID 12608 received: : Hello echo server!\nPID 12608 Sending echo message to the server : \"Hello echo server!\"\nSent: 18 characters, so far...\nServer sending response [current_process_id: data] = [12611: Hello echo server!]\nPID 12608 received: : Hello echo server!\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 2\n# This program is optimized for Python 2.7\n# It may run on any other version with/without modifications.\nimport os\nimport socket\nimport threading\nimport SocketServer\nSERVER_HOST = 'localhost'\nSERVER_PORT = 0 # tells the kernel to pick up a port dynamically\nBUF_SIZE = 1024\n\ndef client(ip, port, message):\n    \"\"\" A client to test threading mixin server\"\"\"    \n    # Connect to the server\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    try:\n        sock.sendall(message)\n        response = sock.recv(BUF_SIZE)\n        print \"Client received: %s\" %response\n    finally:\n        sock.close()\n\nclass ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler):\n    \"\"\" An example of threaded TCP request handler \"\"\"\n    def handle(self):\n        data = self.request.recv(1024)\n        current_thread = threading.current_thread()\n        response = \"%s: %s\" %(current_thread.name, data)\n        self.request.sendall(response)\n\nclass ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n    \"\"\"Nothing to add here, inherited everything necessary from parents\"\"\"\n    pass\nif __name__ == \"__main__\":\n    # Run server\n    server = ThreadedTCPServer((SERVER_HOST, SERVER_PORT), ThreadedTCPRequestHandler)\n    ip, port = server.server_address # retrieve ip address\n    # Start a thread with the server -- one  thread per request\n    server_thread = threading.Thread(target=server.serve_forever)\n    # Exit the server thread when the main thread exits\n    server_thread.daemon = True\n    server_thread.start()\n    print \"Server loop running on thread: %s\"  %server_thread.name\n    # Run clients\n    client(ip, port, \"Hello from client 1\")\n    client(ip, port, \"Hello from client 2\")\n    client(ip, port, \"Hello from client 3\")\n    # Server cleanup\n    server.shutdown()\n```", "```py\n$ python 2_2_threading_mixin_socket_server.py\nServer loop running on thread: Thread-1\nClient received: Thread-2: Hello from client 1\nClient received: Thread-3: Hello from client 2\nClient received: Thread-4: Hello from client 3\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 2\n# This program is optimized for Python 2.7\n# It may run on any other version with/without modifications\nimport select\nimport socket\nimport sys\nimport signal\nimport cPickle\nimport struct\nimport argparse\n\nSERVER_HOST = 'localhost'\nCHAT_SERVER_NAME = 'server'\n\n# Some utilities\ndef send(channel, *args):\n    buffer = cPickle.dumps(args)\n    value = socket.htonl(len(buffer))\n    size = struct.pack(\"L\",value)\n    channel.send(size)\n    channel.send(buffer)\n\ndef receive(channel):\n    size = struct.calcsize(\"L\")\n    size = channel.recv(size)\n    try:\n        size = socket.ntohl(struct.unpack(\"L\", size)[0])\n    except struct.error, e:\n        return ''\n    buf = \"\"\n    while len(buf) < size:\n        buf = channel.recv(size - len(buf))\n    return cPickle.loads(buf)[0]\n```", "```py\nclass ChatServer(object):\n    \"\"\" An example chat server using select \"\"\"\n def __init__(self, port, backlog=5):\n   self.clients = 0\n   self.clientmap = {}\n   self.outputs = [] # list output sockets\n   self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n   # Enable re-using socket address\n   self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n   self.server.bind((SERVER_HOST, port))\n   print 'Server listening to port: %s ...' %port\n   self.server.listen(backlog)\n   # Catch keyboard interrupts\n   signal.signal(signal.SIGINT, self.sighandler)\n\n    def sighandler(self, signum, frame):\n        \"\"\" Clean up client outputs\"\"\"\n        # Close the server\n        print 'Shutting down server...'\n        # Close existing client sockets\n        for output in self.outputs:\n            output.close()            \n        self.server.close()\n\n    def get_client_name(self, client):\n        \"\"\" Return the name of the client \"\"\"\n        info = self.clientmap[client]\n        host, name = info[0][0], info[1]\n        return '@'.join((name, host))\n```", "```py\n    def run(self):\n        inputs = [self.server, sys.stdin]\n        self.outputs = []\n        running = True\n        while running:\n         try:\n          readable, writeable, exceptional = \\\n          select.select(inputs, self.outputs, [])\n            except select.error, e:\n                break\n            for sock in readable:\n                if sock == self.server:\n                    # handle the server socket\n                    client, address = self.server.accept()\n                    print \"Chat server: got connection %d from %s\" %\\                     (client.fileno(), address)\n                    # Read the login name\n                    cname = receive(client).split('NAME: ')[1]\n                    # Compute client name and send back\n                    self.clients += 1\n                    send(client, 'CLIENT: ' + str(address[0]))\n                    inputs.append(client)\n                    self.clientmap[client] = (address, cname)\n                    # Send joining information to other clients\n                    msg = \"\\n(Connected: New client (%d) from %s)\" %\\                   (self.clients, self.get_client_name(client))\n                    for output in self.outputs:\n                        send(output, msg)\n                    self.outputs.append(client)\n                elif sock == sys.stdin:\n                    # handle standard input\n                    junk = sys.stdin.readline()\n                    running = False\n                else:\n                    # handle all other sockets\n                    try:\n                        data = receive(sock)\n                        if data:\n                            # Send as new client's message...\n                            msg = '\\n#[' + self.get_client_name(sock)\\\n                                   + ']>>' + data\n                            # Send data to all except ourself\n                            for output in self.outputs:\n                                if output != sock:\n                                    send(output, msg)\n                        else:\n                            print \"Chat server: %d hung up\" % \\\n                            sock.fileno()\n                            self.clients -= 1\n                            sock.close()\n                            inputs.remove(sock)\n                            self.outputs.remove(sock)\n                            # Sending client leaving info to others\n                            msg = \"\\n(Now hung up: Client from %s)\" %\\                             self.get_client_name(sock)\n                            for output in self.outputs:\n                                send(output, msg)\n                    except socket.error, e:\n                        # Remove\n                        inputs.remove(sock)\n                        self.outputs.remove(sock)\n        self.server.close()\n```", "```py\nclass ChatClient(object):\n    \"\"\" A command line chat client using select \"\"\"\n\n    def __init__(self, name, port, host=SERVER_HOST):\n        self.name = name\n        self.connected = False\n        self.host = host\n        self.port = port\n        # Initial prompt\n        self.prompt='[' + '@'.join((name, socket.gethostname().split('.')[0])) + ']> '\n        # Connect to server at port\n        try:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            self.sock.connect((host, self.port))\n            print \"Now connected to chat server@ port %d\" % self.port\n            self.connected = True\n            # Send my name...\n            send(self.sock,'NAME: ' + self.name)\n            data = receive(self.sock)\n            # Contains client address, set it\n            addr = data.split('CLIENT: ')[1]\n            self.prompt = '[' + '@'.join((self.name, addr)) + ']> '\n        except socket.error, e:\n            print \"Failed to connect to chat server @ port %d\" % self.port\n            sys.exit(1)\n\n    def run(self):\n        \"\"\" Chat client main loop \"\"\"\n        while self.connected:\n            try:\n                sys.stdout.write(self.prompt)\n                sys.stdout.flush()\n                # Wait for input from stdin and socket\n                readable, writeable,exceptional = select.select([0, self.sock], [],[])\n                for sock in readable:\n                    if sock == 0:\n                        data = sys.stdin.readline().strip()\n                        if data: send(self.sock, data)\n                    elif sock == self.sock:\n                        data = receive(self.sock)\n                        if not data:\n                            print 'Client shutting down.'\n                            self.connected = False\n                            break\n                        else:\n                            sys.stdout.write(data + '\\n')\n                            sys.stdout.flush()\n\n            except KeyboardInterrupt:\n                print \" Client interrupted. \"\"\"\n                self.sock.close()\n                break\n```", "```py\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Socket Server Example with Select')\n    parser.add_argument('--name', action=\"store\", dest=\"name\", required=True)\n    parser.add_argument('--port', action=\"store\", dest=\"port\", type=int, required=True)\n    given_args = parser.parse_args()\n    port = given_args.port\n    name = given_args.name\n    if name == CHAT_SERVER_NAME:\n        server = ChatServer(port)\n        server.run()\n    else:\n        client = ChatClient(name=name, port=port)\n        client.run()\n```", "```py\n$ python 2_3_chat_server_with_select.py --name=server --port=8800\nServer listening to port: 8800 ...\nChat server: got connection 4 from ('127.0.0.1', 56565)\nChat server: got connection 5 from ('127.0.0.1', 56566)\n\n```", "```py\n$ python 2_3_chat_server_with_select.py --name=client1 --port=8800\nNow connected to chat server@ port 8800\n[client1@127.0.0.1]>\n(Connected: New client (2) from client2@127.0.0.1)\n[client1@127.0.0.1]> Hello from client 1\n[client1@127.0.0.1]>\n#[client2@127.0.0.1]>>hello from client 2\n\n```", "```py\n$ python 2_3_chat_server_with_select.py --name=client2 --port=8800\nNow connected to chat server@ port 8800\n[client2@127.0.0.1]>\n#[client1@127.0.0.1]>>Hello from client 1\n[client2@127.0.0.1]> hello from client 2\n[client2@127.0.0.1]\n\n```", "```py\nListing 2.4 Simple web server using select.epoll\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 2\n# This program is optimized for Python 2.7\n# It may run on any other version with/without modifications.\nimport socket\nimport select\nimport argparse\nSERVER_HOST = 'localhost'\nEOL1 = b'\\n\\n'\nEOL2 = b'\\n\\r\\n'\nSERVER_RESPONSE  = b\"\"\"HTTP/1.1 200 OK\\r\\nDate: Mon, 1 Apr 2013 01:01:01 GMT\\r\\nContent-Type: text/plain\\r\\nContent-Length: 25\\r\\n\\r\\n\nHello from Epoll Server!\"\"\"\n\nclass EpollServer(object):\n    \"\"\" A socket server using Epoll\"\"\"\n    def __init__(self, host=SERVER_HOST, port=0):\n      self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n      self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n      self.sock.bind((host, port))\n      self.sock.listen(1)\n      self.sock.setblocking(0)\n      self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n      print \"Started Epoll Server\"\n      self.epoll = select.epoll()\n      self.epoll.register(self.sock.fileno(), select.EPOLLIN)\n\n def run(self):\n  \"\"\"Executes epoll server operation\"\"\"\n  try:\n     connections = {}; requests = {}; responses = {}\n     while True:\n   events = self.epoll.poll(1)\n   for fileno, event in events:\n     if fileno == self.sock.fileno():\n       connection, address = self.sock.accept()\n       connection.setblocking(0)\n       self.epoll.register(connection.fileno(), select.EPOLLIN)\n       connections[connection.fileno()] = connection\n       requests[connection.fileno()] = b''\n       responses[connection.fileno()] = SERVER_RESPONSE\n     elif event & select.EPOLLIN:\n       requests[fileno] += connections[fileno].recv(1024)\n       if EOL1 in requests[fileno] or EOL2 in requests[fileno]:\n             self.epoll.modify(fileno, select.EPOLLOUT)\n             print('-'*40 + '\\n' + requests[fileno].decode()[:-2])\n      elif event & select.EPOLLOUT:\n         byteswritten = connections[fileno].send(responses[fileno])\n         responses[fileno] = responses[fileno][byteswritten:]\n         if len(responses[fileno]) == 0:\n             self.epoll.modify(fileno, 0)\n             connections[fileno].shutdown(socket.SHUT_RDWR)\n         elif event & select.EPOLLHUP:\n              self.epoll.unregister(fileno)\n              connections[fileno].close()\n              del connections[fileno]\n finally:\n   self.epoll.unregister(self.sock.fileno())\n   self.epoll.close()\n   self.sock.close()\n\nif __name__ == '__main__':\n parser = argparse.ArgumentParser(description='Socket Server Example with Epoll')\n parser.add_argument('--port', action=\"store\", dest=\"port\", type=int, required=True)\n    given_args = parser.parse_args()\n    port = given_args.port\n    server = EpollServer(host=SERVER_HOST, port=port)\n    server.run()\n```", "```py\n$ python 2_4_simple_web_server_with_epoll.py --port=8800\nStarted Epoll Server\n----------------------------------------\nGET / HTTP/1.1\nHost: localhost:8800\nConnection: keep-alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nUser-Agent: Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31\nDNT: 1\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: en-GB,en-US;q=0.8,en;q=0.6\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3\nCookie: MoodleSession=69149dqnvhett7br3qebsrcmh1; MOODLEID1_=%257F%25BA%2B%2540V\n\n----------------------------------------\nGET /favicon.ico HTTP/1.1\nHost: localhost:8800\nConnection: keep-alive\nAccept: */*\nDNT: 1\nUser-Agent: Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: en-GB,en-US;q=0.8,en;q=0.6\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3\n\n```", "```py\nHello from Epoll Server!\n\n```", "```py\n#!/usr/bin/env python\n# Python Network Programming Cookbook -- Chapter - 2\n# This program is optimized for Python 2.7.\n# It may run on any other version with/without modifications.\n# You also need diesel library 3.0 or any later version\n\nimport diesel\nimport argparse\n\nclass EchoServer(object):\n    \"\"\" An echo server using diesel\"\"\"\n\n    def handler(self, remote_addr):\n        \"\"\"Runs the echo server\"\"\"\n        host, port = remote_addr[0], remote_addr[1]\n        print \"Echo client connected from: %s:%d\" %(host, port)\n\n        while True:\n            try:\n                message = diesel.until_eol()\n                your_message = ': '.join(['You said', message])\n                diesel.send(your_message)\n            except Exception, e:\n                print \"Exception:\",e\n\ndef main(server_port):\n    app = diesel.Application()\n    server = EchoServer()    \n    app.add_service(diesel.Service(server.handler, server_port))\n    app.run()\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Echo server example with Diesel')\n    parser.add_argument('--port', action=\"store\", dest=\"port\", type=int, required=True)\n    given_args = parser.parse_args()\n    port = given_args.port\n    main(port)\n```", "```py\n$ python 2_5_echo_server_with_diesel.py --port=8800\n[2013/04/08 11:48:32] {diesel} WARNING:Starting diesel <hand-rolled select.epoll>\nEcho client connected from: 127.0.0.1:56603\n\n```", "```py\n$ telnet localhost 8800\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nHello Diesel server ?\nYou said: Hello Diesel server ?\n\n```"]