["```py\ndef add(a: int, b: int) -> int: \n    if a == 0: \n        return b \n    else: \n        return add(a - 1, b + 1)\n```", "```py\ndef fact(n: int) -> int: \n    if n == 0: \n        return 1 \n    else: \n        return n*fact(n-1)\n```", "```py\ndef facti(n: int) -> int: \n    if n == 0: \n        return 1 \n    f = 1 \n    for i in range(2, n+1): \n        f = f * i \n    return f\n```", "```py\ndef fastexp(a: float, n: int) -> float: \n    if n == 0: \n        return 1 \n    elif n % 2 == 1: \n        return a * fastexp(a, n - 1) \n    else: \n        t = fastexp(a, n // 2) \n        return t * t\n```", "```py\ndef fib(n: int) -> int: \n    if n == 0: return 0 \n    if n == 1: return 1 \n    return fib(n-1) + fib(n-2)\n```", "```py\ndef fibi(n: int) -> int: \n    if n == 0: return 0 \n    if n == 1: return 1 \n    f_n2, f_n1 = 1, 1 \n    for _ in range(2, n): \n        f_n2, f_n1 = f_n1, f_n2 + f_n1 \n    return f_n1\n```", "```py\nfrom collections.abc import Callable, Sequence \nfrom typing import Any, TypeVar \n\nMapD = TypeVar(\"MapD\") \nMapR = TypeVar(\"MapR\") \n\ndef mapr( \n        f: Callable[[MapD], MapR], \n        collection: Sequence[MapD] \n) -> list[MapR]: \n    if len(collection) == 0: return [] \n    return mapr(f, collection[:-1]) + [f(collection[-1])]\n```", "```py\nfrom collections.abc import Callable, Iterable, Iterator \nfrom typing import Any, TypeVar \n\nDomT = TypeVar(\"DomT\") \nRngT = TypeVar(\"RngT\") \n\ndef mapf( \n        f: Callable[[DomT], RngT], \n        C: Iterable[DomT] \n) -> Iterator[RngT]: \n    return (f(x) for x in C)\n```", "```py\ndef mapg( \n        f: Callable[[DomT], RngT], \n        C: Iterable[DomT] \n) -> Iterator[RngT]: \n    for x in C: \n        yield f(x)\n```", "```py\n>>> list(mapg(lambda x: 2 ** x, [0, 1, 2, 3, 4])) \n[1, 2, 4, 8, 16]\n```", "```py\ndef fastexp_w(a: float, n: int) -> float: \n    if n == 0: \n        return 1 \n    else: \n        q, r = divmod(n, 2) \n        if r == 1: \n            return a * fastexp_w(a, n - 1) \n        else: \n            return (t := fastexp_w(a, q)) * t\n```", "```py\nfrom collections.abc import Sequence \n\ndef prodrc(collection: Sequence[float]) -> float: \n    if len(collection) == 0: return 1 \n    return collection[0] * prodrc(collection[1:])\n```", "```py\nfrom collections.abc import Iterator \n\ndef prodri(items: Iterator[float]) -> float: \n    try: \n        head = next(items) \n    except StopIteration: \n        return 1 \n    return head * prodri(items)\n```", "```py\n>>> prodri(iter([1,2,3,4,5,6,7])) \n5040\n```", "```py\nfrom collections.abc import Iterable \n\ndef prodi(items: Iterable[float]) -> float: \n    p: float = 1 \n    for n in items: \n        p *= n \n    return p\n```", "```py\nfrom collections import deque \nfrom pathlib import Path \n\ndef all_print(start: Path) -> int: \n    count = 0 \n    pending: deque[Path] = deque([start]) \n    while pending: \n        dir_path = pending.pop() \n        for path in dir_path.iterdir(): \n            if path.is_file(): \n                if path.suffix == ’.py’: \n                    count += path.read_text().count(\"print\") \n            elif path.is_dir(): \n                if not path.stem.startswith(’.’): \n                    pending.append(path) \n            else:  # Ignore other filesystem objects \n                pass \n    return count\n```", "```py\n(((37.5490162, -76.330295), (37.840832, -76.273834), 17.7246), \n((37.840832, -76.273834), (38.331501, -76.459503), 30.7382), \n((38.331501, -76.459503), (38.845501, -76.537331), 31.0756), \n... \n((38.330166, -76.458504), (38.976334, -76.473503), 38.8019))\n```", "```py\nquantized = (5 * (dist // 5) for start, stop, dist in trip)\n```", "```py\nquantized = (5 * (dist // 5) for _, _, dist in trip)\n```", "```py\n# See Chapter 4 for ways to parse \"file:./Winter%202012-2013.kml\" \n# We want to build a trip variable with the sequence of tuples \n\n>>> from collections import Counter \n\n>>> quantized = (5 * (dist // 5) for start, stop, dist in trip) \n>>> summary = Counter(quantized)\n```", "```py\n>>> summary.most_common()\n[(30.0, 15), (15.0, 9), ...]\n\n```", "```py\n(35.0, 5), (5.0, 5), (10.0, 5), (20.0, 5), (25.0, 5)\n```", "```py\nfrom collections.abc import Iterable \nfrom typing import Any, TypeVar, Protocol, TypeAlias \n\nclass Comparable(Protocol): \n    def __lt__(self, __other: Any) -> bool: ... \n    def __gt__(self, __other: Any) -> bool: ... \nSupportsRichComparisonT = TypeVar(\"SupportsRichComparisonT\", bound=Comparable) \n\nLeg: TypeAlias = tuple[Any, Any, float] \n\ndef group_sort(trip: Iterable[Leg]) -> dict[int, int]: \n\n    def group( \n            data: Iterable[SupportsRichComparisonT] \n    ) -> Iterable[tuple[SupportsRichComparisonT, int]]: \n        sorted_data = iter(sorted(data)) \n        previous, count = next(sorted_data), 1 \n        for d in sorted_data: \n            if d == previous: \n                count += 1 \n            else: \n                yield previous, count \n                previous, count = d, 1 \n        yield previous, count \n\n    quantized = (int(5 * (dist // 5)) for beg, end, dist in trip) \n    return dict(group(quantized))\n```", "```py\n>>> C = [1,2,3,4,5] \n>>> head, *tail = C \n>>> head \n1 \n>>> tail \n[2, 3, 4, 5]\n```", "```py\nfrom collections import defaultdict \nfrom collections.abc import Callable, Sequence, Hashable \nfrom typing import TypeVar \n\nSeqItemT = TypeVar(\"SeqItemT\") \nItemKeyT = TypeVar(\"ItemKeyT\", bound=Hashable) \n\ndef group_by( \n        key: Callable[[SeqItemT], ItemKeyT], \n        data: Sequence[SeqItemT] \n) -> dict[ItemKeyT, list[SeqItemT]]: \n\n    def group_into( \n            key: Callable[[SeqItemT], ItemKeyT], \n            collection: Sequence[SeqItemT], \n            group_dict: dict[ItemKeyT, list[SeqItemT]] \n    ) -> dict[ItemKeyT, list[SeqItemT]]: \n        if len(collection) == 0: \n            return group_dict \n        head, *tail = collection \n        group_dict[key(head)].append(head) \n        return group_into(key, tail, group_dict) \n\n    return group_into(key, data, defaultdict(list))\n```", "```py\n# Bad use of a mutable default value \n\ndef group_by(key, data, dictionary=defaultdict(list)):\n```", "```py\n>>> binned_distance = lambda leg: 5 * (leg[2] // 5) \n>>> by_distance = group_by(binned_distance, trip)\n```", "```py\n>>> import pprint \n>>> for distance in sorted(by_distance): \n...     print(distance) \n...     pprint.pprint(by_distance[distance])\n```", "```py\n0.0 \n[((35.505665, -76.653664), (35.508335, -76.654999), 0.1731), \n ((35.028175, -76.682495), (35.031334, -76.682663), 0.1898), \n ((25.4095, -77.910164), (25.425833, -77.832664), 4.3155), \n ((25.0765, -77.308167), (25.080334, -77.334), 1.4235)] \n5.0 \n[((38.845501, -76.537331), (38.992832, -76.451332), 9.7151), \n ((34.972332, -76.585167), (35.028175, -76.682495), 5.8441), \n ((30.717167, -81.552498), (30.766333, -81.471832), 5.103), \n ((25.471333, -78.408165), (25.504833, -78.232834), 9.7128), \n ((23.9555, -76.31633), (24.099667, -76.401833), 9.844)] \n... \n125.0 \n[((27.154167, -80.195663), (29.195168, -81.002998), 129.7748)]\n```", "```py\nfrom collections import defaultdict \nfrom collections.abc import Callable, Hashable, Iterable \nfrom typing import TypeVar \n\nSeqT = TypeVar(\"SeqT\") \nKeyT = TypeVar(\"KeyT\", bound=Hashable) \n\ndef partition( \n        key: Callable[[SeqT], KeyT], \n        data: Iterable[SeqT] \n) -> dict[KeyT, list[SeqT]]: \n    group_dict = defaultdict(list) \n    for head in data: \n        group_dict[key(head)].append(head) \n        #--------------------------------- \n    return group_dict\n```", "```py\n# Legs are (start, end, distance) tuples \n\nstart = lambda s, e, d: s \n\nend = lambda s, e, d: e \n\ndist = lambda s, e, d: d \n\n# start and end of a Leg are (lat, lon) tuples \n\nlatitude = lambda lat, lon: lat \n\nlongitude = lambda lat, lon: lon\n```", "```py\n>>> point = ((35.505665, -76.653664), (35.508335, -76.654999), 0.1731) \n>>> start(*point) \n(35.505665, -76.653664) \n\n>>> end(*point) \n(35.508335, -76.654999) \n\n>>> dist(*point) \n0.1731 \n\n>>> latitude(*start(*point)) \n35.505665\n```", "```py\n>>> binned_distance = lambda leg: 5 * (leg[2] // 5) \n>>> by_distance = partition(binned_distance, trip) \n>>> for distance in sorted(by_distance): \n...     print( \n...         distance, \n...         max(by_distance[distance], \n...         key=lambda pt: latitude(*start(*pt))) \n...     )\n```", "```py\n0.0 ((35.505665, -76.653664), (35.508335, -76.654999), 0.1731) \n5.0 ((38.845501, -76.537331), (38.992832, -76.451332), 9.7151) \n10.0 ((36.444168, -76.3265), (36.297501, -76.217834), 10.2537) \n... \n125.0 ((27.154167, -80.195663), (29.195168, -81.002998), 129.7748)\n```", "```py\nfrom collections.abc import Sequence \n\ndef sum_x0(data: Sequence[float]) -> float: \n    return sum(1 for x in data)  # or len(data) \n\ndef sum_x1(data: Sequence[float]) -> float: \n    return sum(x for x in data)  # or sum(data) \n\ndef sum_x2(data: Sequence[float]) -> float: \n    return sum(x*x for x in data)\n```", "```py\nfrom collections.abc import Callable, Iterable \nfrom typing import Any \n\ndef sum_f( \n        function: Callable[[Any], float], \n        data: Iterable[float] \n) -> float: \n    return sum(function(x) for x in data)\n```", "```py\n>>> data = [7.46, 6.77, 12.74, 7.11, 7.81, \n...     8.84, 6.08, 5.39, 8.15, 6.42, 5.73] \n\n>>> N = sum_f(lambda x: 1, data)  # x**0 \n>>> N \n11 \n>>> S = sum_f(lambda x: x, data)  # x**1 \n>>> round(S, 2) \n82.5 \n>>> S2 = sum_f(lambda x: x*x, data)  # x**2 \n>>> round(S2, 4) \n659.9762\n```", "```py\nfrom collections.abc import Callable, Iterable \n\ndef sum_filter_f( \n        filter_f: Callable[[float], bool], \n        function: Callable[[float], float], \n        data: Iterable[float] \n) -> float: \n    return sum(function(x) for x in data if filter_f(x))\n```", "```py\nvalid = lambda x: x is not None \n\ndef mean_f(predicate: Callable[[Any], bool], data: Sequence[float]) -> float: \n    count_ = lambda x: 1 \n    sum_ = lambda x: x \n    N = sum_filter_f(valid, count_, data) \n    S = sum_filter_f(valid, sum_, data) \n    return S / N\n```", "```py\nfrom collections.abc import Iterator \nfrom enum import Enum \nimport re \n\nclass Token(Enum): \n    SPACE = 1 \n    PARA = 2 \n    EOF = 3 \n\ndef lexical_scan(some_source: str) -> Iterator[tuple[Token, str]]: \n    previous_end = 0 \n    separator_pat = re.compile(r\"\\n\\s*\\n\", re.M|re.S) \n    for sep in separator_pat.finditer(some_source): \n        start, end = sep.span() \n        yield Token.PARA, some_source[previous_end: start] \n        yield Token.SPACE, some_source[start: end] \n        previous_end = end \n    yield Token.PARA, some_source[previous_end:] \n    yield Token.EOF, \"\"\n```", "```py\nfrom collections.abc import Iterator \nfrom typing import TextIO, cast \n\ndef comma_split(text: str) -> list[str]: \n    return text.split(\",\") \n\ndef row_iter_kml(file_obj: TextIO) -> Iterator[list[str]]: \n    ns_map = { \n        \"ns0\": \"http://www.opengis.net/kml/2.2\", \n        \"ns1\": \"http://www.google.com/kml/ext/2.2\"} \n    xpath = ( \n        \"./ns0:Document/ns0:Folder/\" \n        \"ns0:Placemark/ns0:Point/ns0:coordinates\") \n    doc = XML.parse(file_obj) \n    return ( \n        comma_split(cast(str, coordinates.text)) \n        for coordinates in doc.findall(xpath, ns_map) \n    )\n```", "```py\nfrom collections.abc import Iterator \n\ndef pick_lat_lon( \n        lon: str, lat: str, alt: str \n) -> tuple[str, str]: \n    return lat, lon \n\ndef float_lat_lon( \n        row_iter: Iterator[list[str]] \n) -> Iterator[tuple[float, float]]: \n    lat_lon_iter = ( \n        pick_lat_lon(*row) \n        for row in row_iter \n    ) \n    return ( \n        (float(lat), float(lon)) \n        for lat, lon in lat_lon_iter \n    )\n```", "```py\n<Placemark><Point> \n<coordinates>-76.33029518659048, 37.54901619777347,0</coordinates> \n</Point></Placemark>\n```", "```py\n>>> import urllib.request \n>>> source_url = \"file:./Winter%202012-2013.kml\" \n>>> with urllib.request.urlopen(source_url) as source: \n...      flat = list(float_lat_lon(row_iter_kml(source)))\n```", "```py\n>>> from pprint import pprint \n>>> pprint(flat)  # doctest: +ELLIPSIS \n[(37.54901619777347, -76.33029518659048), \n ... \n (38.976334, -76.473503)]\n```", "```py\nAnscombe’s quartet \nI II III IV \nx y x y x y x y \n10.0 8.04 10.0 9.14 10.0 7.46 8.0 6.58 \n8.0 6.95 8.0 8.14 8.0 6.77 8.0 5.76 \n... \n5.0 5.68 5.0 4.74 5.0 5.73 8.0 6.89\n```", "```py\nfrom collections.abc import Iterator \nimport csv \nfrom typing import TextIO \n\ndef row_iter_csv(source: TextIO) -> Iterator[list[str]]: \n    rdr = csv.reader(source, delimiter=\"\\t\") \n    return rdr\n```", "```py\nfrom typing import cast \n\ndef float_none(data: str) -> float | None: \n    try: \n        data_f = float(data) \n        return data_f \n    except ValueError: \n        return None\n```", "```py\nfrom collections.abc import Callable \nfrom typing import TypeAlias \n\nR_Float: TypeAlias = list[float | None] \n\nfloat_row: Callable[[list[str]], R_Float] = \\ \n    lambda row: list(map(float_none, row))\n```", "```py\nall_numeric: Callable[[R_Float], bool] = \\ \n    lambda row: all(row) and len(row) == 8\n```", "```py\nGIMP Palette \nName: Crayola \nColumns: 16 \n# \n239 222 205 Almond \n205 149 117 Antique Brass\n```", "```py\nfrom collections.abc import Iterator \nfrom typing import TextIO, TypeAlias \n\nHead_Body: TypeAlias = tuple[tuple[str, str], Iterator[list[str]]] \n\ndef row_iter_gpl(file_obj: TextIO) -> Head_Body: \n    header_pat = re.compile( \n        r\"GIMP Palette\\nName:\\s*(.*?)\\nColumns:\\s*(.*?)\\n#\\n\", \n        re.M) \n\n    def read_head(file_obj: TextIO) -> tuple[tuple[str, str], TextIO]: \n        if match := header_pat.match( \n            \"\".join(file_obj.readline() for _ in range(4)) \n        ): \n            return (match.group(1), match.group(2)), file_obj \n        else: \n            raise ValueError(\"invalid header\") \n\n    def read_tail( \n            headers: tuple[str, str], \n            file_obj: TextIO) -> Head_Body: \n        return ( \n            headers, \n            (next_line.split() for next_line in file_obj) \n        ) \n\n    return read_tail(*read_head(file_obj))\n```", "```py\nfrom collections.abc import Iterator \nfrom typing import NamedTuple \n\nclass Color(NamedTuple): \n    red: int \n    blue: int \n    green: int \n    name: str \n\ndef color_palette( \n        headers: tuple[str, str], \n        row_iter: Iterator[list[str]] \n) -> tuple[str, str, tuple[Color, ...]]: \n    name, columns = headers \n    colors = tuple( \n        Color(int(r), int(g), int(b), \" \".join(name)) \n        for r, g, b, *name in row_iter \n    ) \n    return name, columns, colors\n```", "```py\n>>> from pathlib import Path \n>>> source_path = Path(\"crayola.gpl\") \n>>> with source_path.open() as source: \n...     name, cols, colors = color_palette( \n...         *row_iter_gpl(source) \n...     ) \n>>> name \n’Crayola’ \n>>> cols \n’16’ \n>>> len(colors) \n133\n```"]