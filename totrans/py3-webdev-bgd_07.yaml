- en: Chapter 7. Refactoring Code for Reuse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。重构代码以实现重用
- en: After doing a substantial bit of work, it is often a good idea to take a step
    back and look critically at your work to see if things could have been done better.
    Quite often, the insight gained in the development process can be used to good
    effect in any new code or even to refactor existing code if the benefits are so
    substantial that they warrant the extra work.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在做了一段时间的大量工作之后，退一步批判性地审视你的工作，看看是否可以做得更好，通常是一个好主意。通常，在开发过程中获得的见解可以很好地应用于任何新的代码，甚至如果好处如此之大以至于值得额外的工作，还可以用于重构现有代码。
- en: Often, such a critical reappraisal is motivated by observed shortcomings in
    the application, like poor performance, or by noting that requested changes take
    more time than we like because the code is designed in a less than optimal way.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，这种关键的重新评估是由观察到的应用程序的不足之处所激发的，比如性能不佳，或者注意到请求的更改所需的时间比我们希望的要多，因为代码的设计不是最优的。
- en: Now that we have designed and implemented several applications in the last few
    chapters based on a simple entity/relation framework, it is time to have that
    critical look and see if there is room for improvement.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经在上一章中基于简单的实体/关系框架设计和实现了几个应用程序，现在是时候进行批判性的审视，看看是否有改进的空间。
- en: Time for action taking a critical look
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动，进行批判性的审视
- en: 'Examine each major piece of code (often a Python module that you implemented)
    and ask yourself the following questions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每一块主要的代码（通常是您实现的Python模块），并问自己以下问题：
- en: Could I reuse it without changes?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我能否在不做任何修改的情况下重用它？
- en: How much extra code was needed to actually use the module?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际使用该模块需要多少额外的代码？
- en: Did you really understand the documentation (even if you wrote it yourself)?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你真的理解了文档（即使是你自己写的）吗？
- en: How much of the code is duplicated?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中有多少是重复的？
- en: How easy is it to add new functionality?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新功能有多容易？
- en: How well did it perform?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的表现如何？
- en: 'When we ask these questions about the entity and relation modules we developed,
    we see that:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对我们开发的实体和关系模块提出这些问题时，我们发现：
- en: It was quite easy to reuse the modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新使用这些模块非常容易
- en: But they do require quite a bit of extra code, for example, to initialize tables
    and threads
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但它们确实需要相当多的额外代码，例如，初始化表和线程
- en: Also, we deliberately wrote specific modules to deal with domain-specific code,
    like input validation, but it is worth examining this code to see if we can discover
    patterns and enhance our framework to better support these patterns. One example
    is that we frequently require auto completion so it is worth looking at how this
    is implemented.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们故意编写了特定的模块来处理特定领域的代码，如输入验证，但值得检查此代码，看看我们是否可以发现模式并增强我们的框架以更好地支持这些模式。一个例子是我们经常需要自动完成，因此值得看看这是如何实现的。
- en: Performance-wise, we saw in the books application that we have hardly addressed
    the way in which large lists of books are browsed and this certainly needs attention
    if we wish to reuse our framework in settings that deal with large lists.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍应用程序中，我们在性能方面几乎没有解决大量书籍的浏览方式，这确实需要关注，如果我们希望在我们的框架中重用，特别是在处理大量列表的环境中。
- en: What just happened?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Now that we have pointed out several areas where our framework modules might
    be improved, it is time to consider if it is worth the effort.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指出了几个可能改进我们的框架模块的领域，现在是时候考虑这是否值得付出努力。
- en: Framework modules are intended to be reused by many applications, so a redesign
    that will allow the modules to be used with less additional code is a good idea,
    as less code means less maintenance. Of course, rewriting may mean that existing
    applications need to be rewritten if they want to use these new versions, but
    that is the price to pay for better maintenance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 框架模块旨在被许多应用程序重用，所以一个允许模块以更少的额外代码使用的设计重制是一个好主意，因为代码越少意味着维护越少。当然，重写可能意味着如果现有应用程序想要使用这些新版本，它们可能需要重写，但这是为了更好的维护而付出的代价。
- en: Refactoring existing functionality is often less problematic, but benefits greatly
    from a good test framework to check if the new implementation still behaves as
    expected. Likewise, adding completely new functionality is likely to be even less
    of a problem, as existing applications do not yet use this functionality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 重构现有功能通常问题不大，但得益于良好的测试框架来检查新的实现是否仍然按预期行为，会带来很大的好处。同样，添加全新的功能可能问题更少，因为现有应用程序还没有使用这个功能。
- en: Because, in our case, we judge the advantages to outweigh the disadvantages,
    we will rework the entity/relation framework in the next section. We will not
    only focus on using less code, but also on making the definition of the new Entity
    and Relation classes easier to read. This will provide for a more intuitive use
    of these classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在我们的情况下，我们认为优势大于劣势，所以我们将重新工作实体/关系框架。我们不仅将关注使用更少的代码，而且还将关注使新的实体和关系类的定义更容易阅读。这将提供更直观地使用这些类。
- en: We will also devote a section to developing functionality to browse through
    lists of entities in a way that scales well, even if the lists are large and need
    to be sorted or filtered.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将专门设置一个部分来开发浏览实体列表的功能，即使列表很大且需要排序或过滤，这种方式也能很好地扩展。
- en: Refactoring
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: The first area that we will refactor is the way we can use the `Entity` class.
    Our goal is to enable a more intuitive use, without the need for explicit initialization
    of the database connections. To get a feeling for what is possible, let us first
    look at an example of how we would use the refactored `entity` module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先重构的是我们如何使用`Entity`类的方式。我们的目标是实现更直观的使用，无需显式初始化数据库连接。为了了解可能实现的功能，让我们首先看看我们如何使用重构的`entity`模块的例子。
- en: 'Time for action defining new entities: how it should look'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义新实体的时间：它应该看起来是什么样子
- en: 'Type in and run the following code (also available as `testentity.py)`. It
    will use the refactored `entity` module to define a `MyEntity` class and work
    with some instances of this class. We will create, list, and update instances
    and even see an update fail because we try to assign a value that will not pass
    a validation for an attribute:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码（也可作为`testentity.py`使用）。它将使用重构的`entity`模块来定义一个`MyEntity`类，并处理这个类的几个实例。我们将创建、列出和更新实例，甚至可以看到更新失败，因为我们尝试分配一个无法通过属性验证的值：
- en: '**Chapter7/testentity.py**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/testentity.py**'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output produced by the print functions should look similar to the lines
    listed next, including the raised exception caused by an invalid update attempt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 打印函数产生的输出应该看起来类似于以下列出的行，包括由无效更新尝试引发的异常：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What just happened?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The first thing we note is that there is no explicit initialization of any database,
    nor is there any code to explicitly initialize any threads. All that is needed
    is to subclass the entity class from the `AbstractEntity` class provided in the
    entity module and define a database class variable that points to a file to be
    used as a database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到，没有显式初始化任何数据库，也没有任何代码显式初始化任何线程。所需的一切只是从`entity`模块提供的`AbstractEntity`类中派生实体类，并定义一个指向用作数据库的文件的数据库类变量。
- en: The next thing is that although we define a specific class (MyEntity, in this
    example) in a similar way as before by defining it as a subclass of Entity, we
    now specify any attributes by defining class variables that are assigned `Attribute`
    instances. In the example, we do this for just a single attribute `a` (highlighted).
    The `Attribute` instance encapsulates a lot of knowledge about constraints, and
    allows for the definition of a default value and a validation function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尽管我们以与之前类似的方式定义了一个特定的类（在这个例子中是MyEntity），我们现在通过定义类变量来指定任何属性，这些变量被分配了`Attribute`实例。在示例中，我们只为单个属性`a`（突出显示）这样做。`Attribute`实例封装了关于约束的大量知识，并允许定义默认值和验证函数。
- en: Creating an instance isn't any different, but as the second `list()` example
    shows, this implementation allows for filtering so there is no need to retrieve
    all instance IDs, instantiate them as true objects and compare their attributes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实例并没有什么不同，但正如第二个`list()`示例所示，这种实现允许过滤，因此不需要检索所有实例ID，将它们实例化为真正的对象并比较它们的属性。
- en: The final assignment to the `a` attribute shows the validation feature in action.
    It raises an `AttributeError` exception because trying to assign a value of 9
    to it triggers our validation function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对`a`属性的最终赋值展示了验证功能的作用。它引发了一个`AttributeError`异常，因为尝试将9赋值给它触发了我们的验证函数。
- en: These new and less cumbersome semantics are largely due to what can be achieved
    by using metaclasses, a concept we explore in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新且不那么繁琐的语义主要归功于使用元类所能实现的功能，我们将在下一节中探讨这个概念。
- en: Metaclasses
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元类
- en: 'Although the Python documentation warns that using metaclasses will make your
    head explode (read, for example, `http://www.python.org/doc/newstyle/)`, they
    are not that dangerous: they may cause headaches, but these will mostly fade away
    after some experimenting and re-reading of the documentation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python文档警告说使用元类会让你的头爆炸（例如，阅读`http://www.python.org/doc/newstyle/`），但它们并不那么危险：它们可能会引起头痛，但这些头痛在实验和重新阅读文档之后大多会消失。
- en: Metaclasses allow you to inspect and alter the definition of a class just before
    this definition is made final and becomes available to the programmer. This is
    possible because, in Python, even classes are objects; specifically, they are
    instances of a metaclass. When we instantiate an object, we can control the way
    this instance is initialized by defining the `__init__()` and `__new__()` methods.
    Likewise, we can control the way a class is initialized by defining suitable `__init__()`
    and `__new__()` methods in its metaclass.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 元类允许你在定义最终成为程序员可用的类定义之前检查和修改类的定义。这是可能的，因为在Python中，类本身也是对象；具体来说，它们是元类的实例。当我们实例化一个对象时，我们可以通过定义`__init__()`和`__new__()`方法来控制这个实例的初始化方式。同样，我们也可以通过在其元类中定义合适的`__init__()`和`__new__()`方法来控制类的初始化方式。
- en: Just as all classes are ultimately subclasses of the `object` class, all metaclasses
    derive from the `type` metaclass. This means that if we want our class to be an
    instance of a different type of metaclass, we have to subclass `type` and define
    our class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所有类最终都是`object`类的子类一样，所有元类都源自`type`元类。这意味着，如果我们想让我们的类成为不同类型的元类的实例，我们必须继承`type`并定义我们的类。
- en: After reading the previous paragraphs, you may still fear your head may explode,
    but like most things, an example is much simpler to understand.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前面的段落之后，你可能仍然担心你的头可能会爆炸，但像大多数事情一样，一个例子要简单得多。
- en: Time for action using metaclasses
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元类进行操作的时间
- en: Say we want to be able to verify that classes we define always have an `__info__()`
    method. We can accomplish that by defining a suitable metaclass and defining any
    new class that should be checked with a reference to this metaclass. Look at the
    following example code (also available as `metaclassexample.py):`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要验证我们定义的类总是有一个`__info__()`方法。我们可以通过定义一个合适的元类，并使用对该元类的引用来检查任何新定义的类来实现这一点。看看下面的示例代码（也作为`metaclassexample.py`可用）：`
- en: '**Chapter7/metaclassexample.py**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter7/metaclassexample.py**'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will raise an exception for the `incorrect` class, but not for the `correct`
    class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对`incorrect`类引发异常，但不会对`correct`类引发异常。
- en: What just happened?
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: As you can see, the `__new__()` method of a metaclass receives a number of important
    parameters. First, the metaclass itself and the `classname` of the class that
    is being defined, a (possibly empty) list of `baseclasses`, and finally the class
    dictionary. That last argument is very important.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，元类的`__new__()`方法接收一些重要的参数。首先，元类本身和正在定义的类的`classname`，一个（可能为空）的`baseclasses`列表，最后是类字典。最后一个参数非常重要。
- en: As we define a class with a class statement, all methods and class variables
    we define here end up in a dictionary. Once this class is completely defined,
    this dictionary will be available as the `__dict__` attribute of the class. This
    is the dictionary that is passed to the `__new__()` method of the metaclass and
    we can examine and alter this dictionary at will.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用类定义语句定义一个类时，我们在这里定义的所有方法和类变量最终都会出现在一个字典中。一旦这个类完全定义，这个字典将作为类的`__dict__`属性可用。这是传递给元类的`__new__()`方法的字典，我们可以随意检查和修改这个字典。
- en: In this example, we simply check whether there exists a key called `__info__`
    in this class dictionary and raise an exception if it doesn't. (We do not really
    check that it is a method but this is possible too of course). If everything went
    well, we call the `__new__()` method of `type` (the mother of all metaclasses)
    as that method will take care of making the class definition available in the
    current scope.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是检查这个类字典中是否存在一个名为`__info__`的键，如果不存在则引发异常。（我们并不真正检查它是否是一个方法，但这当然也是可能的）。如果一切顺利，我们调用`type`（所有元类的母亲）的`__new__()`方法，因为这个方法将负责在当前作用域中使类定义可用。
- en: There is an extra trick involved, however. The `withinfo` class is abstract
    in the sense that it defines the need for an `__info__()` method by referring
    to the `hasinfo` metaclass, but it does not define one itself. However, because
    it refers to the `hasinfo` metaclass, an exception would be raised because its
    own class dictionary is checked in the same way as its subclasses. To prevent
    this, we only check for the occurrence of the `__info__()` method if a class is
    a subclass, that is, when the list of base classes (available in the `baseclasses`
    parameter) is not empty.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个额外的技巧。`withinfo`类在抽象意义上定义了需要`__info__()`方法，因为它引用了`hasinfo`元类，但它本身并没有定义它。然而，因为它引用了`hasinfo`元类，所以会引发异常，因为它的类字典是以与子类相同的方式检查的。为了防止这种情况，我们只有在类是子类的情况下才检查`__info__()`方法的存在，也就是说，当基类列表（在`baseclasses`参数中可用）不为空时。
- en: Checking for mandatory methods is nice, but with so much information available,
    much more can be done. In the next section, we use this power to ensure that the
    definition of a new class will take care of creating suitable tables in a database
    backend as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 检查必需的方法是好的，但有了这么多信息，可以做更多的事情。在下一节中，我们利用这种能力来确保新类的定义将负责在数据库后端创建合适的表。
- en: MetaEntity and AbstractEntity classes
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MetaEntity和AbstractEntity类
- en: Besides creating a database table, if necessary, the metaclass that we will
    define will also examine the `Attribute` instance assigned to any class variable
    to build dictionaries of display names and validation functions. This way, subclasses
    can easily check if a column has such an attribute by using the column name as
    a key, thus obviating the need to check all class variables themselves again and
    again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建数据库表之外，如果需要，我们将定义的元类还将检查分配给任何类变量的`Attribute`实例，以构建显示名称和验证函数的字典。这样，子类可以很容易地通过使用列名作为键来检查是否存在这样的属性，从而避免了再次检查所有类变量的需要。
- en: '![MetaEntity and AbstractEntity classes](img/3746OS_07_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![MetaEntity和AbstractEntity类](img/3746OS_07_03.jpg)'
- en: Time for action implementing the MetaEntity and AbstractEntity classes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现MetaEntity和AbstractEntity类的时间
- en: 'Let''s see how this is done:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的：
- en: '**Chapter7/entity.py**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter7/entity.py**'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Attribute` class is mainly a vehicle to store information about attributes
    in a structured way. We could have used strings and parsed them, but by using
    an `Attribute` class, it is possible to explicitly recognize class variables that
    are meant to be attributes that are stored as database columns. That way, we can
    still define class variables that have a different purpose. Also, writing a parser
    is a lot of work, while checking parameters is a lot easier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attribute`类主要是用来以结构化的方式存储关于属性的信息的载体。我们本可以使用字符串并解析它们，但通过使用`Attribute`类，可以明确识别出作为数据库列存储的属性类变量。这样，我们仍然可以定义具有不同目的的类变量。此外，编写解析器是一项大量工作，而检查参数则容易得多。'
- en: 'The highlighted code shows that most parameters are used to create a string
    that can be used as a column definition that is part of a create table statement.
    The other parameters (displayname and `validate)` are just stored as is for future
    reference:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码显示，大多数参数都用于创建一个字符串，该字符串可以用作创建表语句的一部分的列定义。其他参数（displayname和`validate`）则直接存储以供将来参考：
- en: '**Chapter7/entity.py**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter7/entity.py**'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The metaclass we will use to synchronize the creation of database tables and
    the creation of entity classes is called `MetaEntity`. Its `__new__()` method
    is where all the action takes place, but there is one important additional method:
    `__prepare__()`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的元类来同步数据库表的创建和实体类的创建被称为`MetaEntity`。它的`__new__()`方法是所有动作发生的地方，但还有一个重要的附加方法：`__prepare__()`。
- en: The `__prepare__()` method is called to provide an object that can be used as
    a class dictionary. The default, as provided by the `type` class, just returns
    a regular Python `dict` object. Here we return an ordered dictionary, a dictionary
    that will remember the order of its keys as they are entered. This will enable
    us to use the order in which class variables are declared, for example, to use
    this as the default order to display columns. Without an ordered dictionary, we
    wouldn't have any control and would have to supply separate information.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`__prepare__()`方法以提供一个可以用作类字典的对象。默认情况下，由`type`类提供，只是返回一个常规Python `dict`对象。这里我们返回一个有序字典，这是一个将记住其键的输入顺序的字典。这将使我们能够使用类变量声明的顺序，例如，将其用作显示列的默认顺序。如果没有有序字典，我们就无法控制，并且必须提供单独的信息。
- en: The `__new__()` method first checks if we are a subclass of `MetaEntity` by
    checking whether the list of base classes is non zero (highlighted) as `MetaEntity`
    itself does not have a database backend.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法首先检查我们是否是`MetaEntity`的子类，通过检查基类列表是否非零（突出显示），因为`MetaEntity`本身没有数据库后端。'
- en: Then it checks if the database class variable is defined. If not, we are a specific
    entity that has a database backend and we try to locate the database class variable
    in one of our super classes. If we find it, we store it locally; if not, we raise
    an exception because we cannot function without a reference to a database.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它检查数据库类变量是否已定义。如果没有，我们是一个具有数据库后端的特定实体，我们尝试在我们的超类中定位数据库类变量。如果我们找到了它，我们将其本地存储；如果没有找到，我们抛出异常，因为我们无法在没有数据库引用的情况下运行。
- en: The `AbstractEntity` class will have a `_local` class variable defined that
    holds a reference to thread local storage, and subclasses will have their own
    `_local` variable that points to the same thread local storage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractEntity`类将定义一个`_local`类变量，它包含对线程局部存储的引用，子类将有自己的`_local`变量，它指向相同的线程局部存储。'
- en: The next step is to gather all sorts of information from all the class variables
    that refer to `Attribute` instances. First we collect a list of column names (highlighted).
    Remember that because we caused the class dictionary to be an ordered dictionary,
    these column names will be in the order they were defined.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从所有引用`Attribute`实例的类变量中收集各种信息。首先我们收集一个列名称列表（突出显示）。记住，因为我们使类字典成为一个有序字典，所以这些列名称将是它们定义的顺序。
- en: Likewise, we define a list of display names. If any attribute does not have
    a `displayname` attribute, its display name will be identical to its column name.
    We also construct a dictionary of validators, that is, a dictionary indexed by
    column name that holds a function to validate any value before it is assigned
    to a column.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义了一个显示名称列表。如果任何属性没有`displayname`属性，其显示名称将与列名称相同。我们还构建了一个验证器字典，即按列名称索引的字典，它包含一个在将值分配给列之前验证任何值的函数。
- en: Every entity will have an `id` attribute (and a corresponding column in the
    database table) that is created automatically without it being explicitly defined.
    Therefore, we add its `displayname` separately and construct a special Attribute
    instance (highlighted).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体都将有一个`id`属性（以及数据库表中的对应列），它将自动创建，无需显式定义。因此，我们单独添加其`displayname`，并构建一个特殊的属性实例（突出显示）。
- en: This `coldef` attribute of this special `Attribute` together with the `coldef`
    attributes of the other `Attribute` instances will then be used to compose an
    SQL statement that will create a table with the proper column definitions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊`Attribute`的`coldef`属性以及其他`Attribute`实例的`coldef`属性将用于组成一个SQL语句，该语句将创建具有正确列定义的表。
- en: Finally, we pass the altered and augmented class dictionary together with the
    original list of base classes and the class name to the `__new__()` method of
    the type class which will take care of the actual construction of the class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改后的类字典、原始基类列表和类名一起传递给类型类的`__new__()`方法，该方法将负责实际的类构造。
- en: 'The rest of the functionality of any `Entity` is not implemented by its metaclass,
    but in the regular way, that is, by providing methods in the class that all entities
    should derive from: `AbstractEntity:`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`Entity`的其余功能不是由其元类实现的，而是以常规方式实现的，即在类中提供所有实体都应该继承的方法：`AbstractEntity：`
- en: '**Chapter7/entity.py**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/entity.py**'
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What just happened
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么
- en: '`AbstractEntity` provides a number of methods to provide CRUD functionality:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractEntity`提供了一些方法来提供CRUD功能：'
- en: A constructor to refer to the existing entities in the database or to create
    new ones
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，用于引用数据库中的现有实体或创建新的实体
- en: '`list()` and `listids()`, to find instances that match certain criteria'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list()`和`listids()`，用于查找符合某些标准的实例'
- en: '`update()`, to synchronize changed attributes of an entity with the database'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()`，用于同步实体的更改属性与数据库'
- en: '`delete()`, to delete an entity from the database'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`，用于从数据库中删除实体'
- en: It also defines the 'special' Python methods `__str__(), __repr__()`, and `__setattr__()`
    to render an entity in a legible way and to validate the assignment of a value
    to an attribute.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它还定义了特殊的Python方法`__str__(), __repr__()`, 和`__setattr__()`，以便以可读的方式呈现实体并验证对属性的赋值。
- en: Obviously, `AbstractEntity` refers to the `MetaEntity` metaclass (highlighted).
    It also defines a `_local` class variable that refers to thread local storage.
    The `MetaEntity` class will make sure this reference (but not its contents) are
    copied to all subclasses for fast access. By defining it here, we will make sure
    that all subclasses refer to the same thread local storage, and more importantly,
    will use the same connection to the database for each thread instead of using
    a separate database connection for each different entity.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`AbstractEntity`指的是`MetaEntity`元类（突出显示）。它还定义了一个`_local`类变量，该变量引用线程局部存储。`MetaEntity`类将确保这个引用（但不包括其内容）被复制到所有子类以实现快速访问。通过在这里定义它，我们将确保所有子类都引用相同的线程局部存储，更重要的是，每个线程将使用相同的数据库连接，而不是为每个不同的实体使用单独的数据库连接。
- en: The `listids()` class method will return a list of IDs of entities that match
    the criteria in its `pattern` argument or the IDs of all the entities if no criteria
    were given. It will use the `sortorder` argument to return the list of IDs in
    the required order. Both `sortorder` and `pattern` are a list of tuples, each
    tuple having the column name as its first item. The second item will be a string
    to match against for the `pattern` argument or either `asc` or `desc` for the
    `sortorder` argument, signifying an ascending or descending sort respectively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`listids()`类方法将返回符合其`pattern`参数中指定标准的实体ID列表，或者在没有给出标准时返回所有实体的ID。它将使用`sortorder`参数来按所需顺序返回ID列表。`sortorder`和`pattern`都是一个元组列表，每个元组的第一项是列名。第二项将是用于与`pattern`参数匹配的字符串，或者对于`sortorder`参数是`asc`或`desc`，分别表示升序或降序排序。'
- en: The SQL statement to retrieve any matching IDs is constructed by first creating
    the `select` part (highlighted), as this will be the same irrespective of any
    additional restrictions. Next, we check if there are any `pattern` components
    specified, and if so, add a `where` clause with matching parts for each `pattern`
    item. The matches we specify use the SQL `like` operator, which is normally only
    defined for strings, but SQLite will convert any argument to a string if we use
    the like operator. Using the like operator will allow us to use SQL wildcards
    (for example, `%` ).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 构建检索任何匹配ID的SQL语句时，首先创建`select`部分（突出显示），因为这将不受任何附加限制的影响。接下来，我们检查是否有任何`pattern`组件被指定，如果有，则为每个`pattern`项添加一个`where`子句。我们指定的匹配使用SQL的`like`运算符，这通常仅定义在字符串上，但如果我们使用like运算符，SQLite会将任何参数转换为字符串。使用like运算符将允许我们使用SQL通配符（例如，`%`）。
- en: The next stage is to check if there were any sort order items specified in the
    `sortorder` argument. If not, we use the default sort order stored in the `sortorder`
    class variable (which in our current implementation will still be `None)`. If
    there are items specified, we add an order by clause and add specifications for
    each sort item. A typical SQL statement will look something like `select id from
    atable where col1 like ? and col2 like ? order by col1 asc`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是检查是否在`sortorder`参数中指定了任何排序项。如果没有，我们使用`sortorder`类变量中存储的默认排序顺序（在我们的当前实现中仍然将是`None`）。如果有指定了项，我们将添加一个按顺序子句并为每个排序项添加指定。一个典型的SQL语句可能看起来像`select
    id from atable where col1 like ? and col2 like ? order by col1 asc`。
- en: Finally, we use the `_connect()` method (that was added by the metaclass) to
    retrieve a database connection (and establish one, if needed) that we can use
    to execute the SQL query with and retrieve the list of IDs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用由元类添加的`_connect()`方法来检索一个数据库连接（如果需要，则建立连接），我们可以使用它来执行SQL查询并检索ID列表。
- en: The `list()` method bears a close resemblance to the `listids()` method and
    takes the same arguments. It will, however, return a list of entity instances
    rather than a list of just the IDs by calling the entity's constructor with each
    ID as an argument. This is convenient if that was what we wanted to do with those
    IDs anyway, but a list of IDs is often easier to manipulate. We therefore provide
    both methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`方法与`listids()`方法非常相似，并接受相同的参数。然而，它将通过使用每个ID作为参数调用实体的构造函数，返回实体实例的列表，而不是仅返回ID列表。如果这些ID本身就是我们想要处理的，这将很方便，但通常ID列表更容易操作。因此，我们提供了这两种方法。'
- en: Being able to retrieve lists of entities is nice, but we must also have a means
    to create a new instance and to retrieve all information associated with a record
    with a known ID. That is where the entity's constructor, in the form of the `__init__()`
    method, comes in.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 能够检索实体列表是件好事，但我们还必须有一种方法来创建一个新的实例，并检索与已知ID记录相关联的所有信息。这就是实体构造函数，即`__init__()`方法的作用所在。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, `__init__()` isn't a constructor but a method that initializes
    an instance after it is constructed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`__init__()`不是一个构造函数，而是一个在实例构建后初始化实例的方法。
- en: If a single ID keyword argument is passed to `__init__()` (highlighted), all
    columns of the record matching that ID are retrieved and the corresponding arguments
    (that is, attributes with the same name as a column) are set using the `setattr()`
    built-in function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向`__init__()`传递单个ID关键字参数（突出显示），将检索与该ID匹配的记录的所有列，并使用`setattr()`内置函数设置相应的参数（即与列名称相同的属性）。
- en: If more than one keyword argument is passed to `__init__()`, each should be
    the name of a defined column. If not, an exception is raised. Otherwise, the keywords
    and their values are used to construct an insert statement. If there are more
    columns defined than there are keywords given, this will result in default values
    to be inserted. The default is usually `NULL` unless a `default` argument was
    specified for the column when the `Entity` was defined. If `NULL` is the default
    and the column has a `non null` constraint, an exception will be raised.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向`__init__()`传递了多个关键字参数，则每个参数应该是已定义列的名称。如果不是，将引发异常。否则，使用关键字及其值来构造插入语句。如果定义的列数多于提供的关键字数，这将导致插入默认值。默认值通常是`NULL`，除非在定义`Entity`时为该列指定了`default`参数。如果`NULL`是默认值且列有`non
    null`约束，将引发异常。
- en: Because ID columns are defined as `autoincrement` columns and we do not specify
    an explicit ID value, the ID value will be equal to the `rowid`, a value we retrieve
    as the `lastrowid` attribute of the cursor object (highlighted).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因为ID列被定义为`autoincrement`列，我们没有指定显式的ID值，所以ID值将等于`rowid`，这是我们作为游标对象的`lastrowid`属性检索的值（突出显示）。
- en: Have a go hero retrieving instances in a single step
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一次性检索实例的英雄
- en: Retrieving a list of IDs first and then instantiating entities means that we
    have to retrieve all attributes of each entity with a separate SQL statement.
    This might have a negative impact on performance if the list of entities is large.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检索ID列表，然后实例化实体意味着我们必须使用单独的SQL语句检索每个实体的所有属性。如果实体列表很大，这可能会对性能产生负面影响。
- en: Create a variant of the `list()` method that will not convert the selected IDs
    to entity instances one-by one, but will use a single select statement to retrieve
    all attributes and use those to instantiate entities.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`list()`方法的变体，它不会逐个将选定的ID转换为实体实例，而是使用单个选择语句检索所有属性，并使用这些属性来实例化实体。
- en: Relations
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系
- en: Defining relations between entities should be just as hassle free as defining
    the entities themselves, and with the power of metaclasses in our hands, we can
    use the same concepts. But let's first have a look at how we would use such an
    implementation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 定义实体之间的关系应该与定义实体本身一样方便，而且有了元类的力量，我们可以使用相同的概念。但让我们首先看看我们如何使用这样的实现。
- en: 'Time for action defining new relations: how it should look'
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义新关系的行动时间：它应该看起来如何
- en: The following sample code shows how we would use a `Relation` class (also available
    in `relation.py):`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了如何使用`Relation`类（也在`relation.py`中可用）：`
- en: '**Chapter7/relation.py**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter7/relation.py**'
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What just happened?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'After defining a few entities, defining the relation between those entities
    follows the same pattern: we define a `Relation` class that is a subclass of `AbstractRelation`
    to establish a reference to a database that will be used.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了一些实体之后，定义这些实体之间的关系遵循相同的模式：我们定义一个 `Relation` 类，它是 `AbstractRelation` 的子类，以建立对将使用的数据库的引用。
- en: Then we define an actual relation between two entities by subclassing `Relation`
    and defining two class variables, `a` and `b` that refer to the `Entity` classes
    that form each half of the relation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过子类化 `Relation` 并定义两个类变量 `a` 和 `b` 来定义两个实体之间的实际关系，这两个变量分别引用构成关系每一半的 `Entity`
    类。
- en: If we instantiate a few entities, we may then define a few relations between
    these instances by using the `add()` method and retrieve related entities with
    the `get()` method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实例化了一些实体，我们可以通过使用 `add()` 方法在这些实例之间定义一些关系，并通过 `get()` 方法检索相关实体。
- en: Note that those methods are called on the `Entity` instances, allowing for a
    much more natural idiom than the use of class methods in the `Relation` class.
    These `add()` and `get()` methods were added to those entity classes by the `MetaRelation`
    metaclass, and in the next section, we will see how this is accomplished.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些方法是在 `Entity` 实例上调用的，这比在 `Relation` 类中使用类方法要自然得多。这些 `add()` 和 `get()` 方法是由
    `MetaRelation` 元类添加到这些实体类中的，在下一节中，我们将看到这是如何实现的。
- en: 'The class diagram for relation classes looks nearly identical to the one for
    entities:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关系类的类图几乎与实体类的类图相同：
- en: '![What just happened?](img/3746OS_07_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/3746OS_07_04.jpg)'
- en: Implementing the MetaRelation and AbstractRelation classes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 MetaRelation 和 AbstractRelation 类
- en: 'The implementation of the `AbstractRelation` class is very minimalistic because
    it is only used to create some thread local storage and establish a relation with
    the `MetaRelation` metaclass:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractRelation` 类的实现非常简约，因为它仅用于创建一些线程局部存储并与 `MetaRelation` 元类建立关系：'
- en: '**Chapter7/relation.py**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter7/relation.py**'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: No methods are specified since the metaclass will take care of adding suitable
    methods to the entity class that are a part of this relationship.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定任何方法，因为元类将负责向实体类添加适合此关系的方法。
- en: 'The `MetaRelation` class has two goals: creating a database table that will
    hold records for each individual relation and adding methods to the entity classes
    involved, so that relations can be created, removed, and queried:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaRelation` 类有两个目标：创建一个数据库表，该表将保存每个单独关系的记录，并向涉及的实体类添加方法，以便可以创建、删除和查询关系：'
- en: '**Chapter7/relation.py**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter7/relation.py**'
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As was the case for the `MetaEntity` class, `MetaRelation` performs its magic
    through its `__new__()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `MetaEntity` 类的情况一样，`MetaRelation` 通过其 `__new__()` 方法执行其魔法。
- en: First, we check if we are creating a subclass of `AbstractRelation` by checking
    the length of the `baseclasses` parameter (remember that `MetaRelation` is defined
    as a metaclass for `AbstractRelation`, meaning that not only its subclasses, but
    also `AbstractRelation` itself will be processed by the metaclass machinery, something
    that is not really needed here).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否正在创建 `AbstractRelation` 的子类，通过检查 `baseclasses` 参数的长度（记住 `MetaRelation`
    被定义为 `AbstractRelation` 的元类，这意味着不仅其子类，而且 `AbstractRelation` 本身也将由元类机制处理，这在实际中并不是必需的）。
- en: If it is a subclass, we copy the database and thread local storage references
    to the class dictionary for quick access.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是子类，我们将数据库和线程局部存储引用复制到类字典中，以便快速访问。
- en: If there was no `database` attribute specified, we know the class being defined
    is a subclass of `Relation`, that is, a specific relation class and mark this
    in the `relationdefinition` variable (highlighted).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定 `database` 属性，我们知道正在定义的类是 `Relation` 的子类，即一个特定的关系类，并在 `relationdefinition`
    变量中标记这一点（突出显示）。
- en: If we are dealing with a concrete definition of a relation, we will have to
    work out which entities are involved. This is done by checking the class dictionary
    for attributes named `a` and `b`, that should be subclasses of `AbstractEntity`
    (highlighted). These are both halves of the relation and their names are used
    to create a bridging table if not already present.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是关系的一个具体定义，我们必须找出涉及哪些实体。这是通过检查类字典中名为 `a` 和 `b` 的属性来完成的，这些属性应该是 `AbstractEntity`
    的子类（突出显示）。这两个都是关系的两半，它们的名称用于创建一个桥接表，如果尚未存在的话。
- en: 'If we were to define a relation like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个像这样的关系：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The SQL statement generated would be:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 SQL 语句将是：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each column references the primary key in the corresponding table (because we
    did specify just the table in the references clause) and the `on delete cascade`
    constraint will make sure that if an entity is deleted, the relation is deleted
    as well. The final `unique` constraint will make sure that if there is a relation
    between specific instances, there will be only one record reflecting this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每一列都引用了相应表的主键（因为我们只指定了在引用子句中的表），`on delete cascade`约束将确保如果一个实体被删除，关系也会被删除。最后的`unique`约束将确保如果存在特定实例之间的关系，将只有一个记录反映这一点。
- en: Adding new methods to existing classes
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向现有类添加新方法
- en: The final part of the `__new__()` method deals with inserting methods in the
    entity classes that are involved in this relation. Adding methods to other classes
    may sound like magic, but in Python, classes themselves are objects too and have
    class dictionaries that hold the attributes of a class. Methods are just attributes
    that happen to have a value that is a function definition.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法的最后一部分处理在涉及此关系的实体类中插入方法。向其他类添加方法可能听起来像魔法，但在Python中，类本身也是对象，并且有包含类属性值的类字典。方法只是恰好具有函数定义值的属性。'
- en: We can, therefore, add a new method at runtime to any class by assigning a reference
    to a suitable function to a class attribute. The `MetaEntity` class only altered
    the class dictionary of an `Entity` before it was created. The `MetaRelation`
    class goes one step further and not only alters the class dictionary of the `Relation`
    class, but also those of the `Entity` classes involved.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在运行时向任何类添加新方法，只需将一个对合适函数的引用赋给类的属性。`MetaEntity`类在创建之前只修改了`Entity`类的类字典。`MetaRelation`类更进一步，不仅修改了`Relation`类的类字典，还修改了涉及的`Entity`类的类字典。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Altering class definitions at runtime is not limited to metaclasses, but should
    be used sparingly because we expect classes to behave consistently anywhere in
    the code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时更改类定义不仅限于元类，但应该谨慎使用，因为我们期望类在代码的任何地方都能保持一致的行为。
- en: If we have two classes, `A` and `B`, we want to make sure each has its own complement
    of get and add methods. That is, we want to make sure the `A` class has `getB()`
    and `addB()` methods and the `B` class has `getA()` and `addA()`. We, therefore,
    define generic `getclass()` and `addclass()` functions and assign those with tailored
    lambda functions to the named attributes in the class concerned (highlighted).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个类，`A`和`B`，我们想确保每个类都有自己的get和add方法。也就是说，我们想确保`A`类有`getB()`和`addB()`方法，而`B`类有`getA()`和`addA()`方法。因此，我们定义了通用的`getclass()`和`addclass()`函数，并将这些函数与定制lambda函数一起分配给相关类中的命名属性（高亮显示）。
- en: 'If we assume again that the entity classes are called `A` and `B` and our relation
    is called `AB`, the assignment:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次假设实体类被称为`A`和`B`，我们的关系被称为`AB`，那么这个赋值：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'will mean that the A class will now have a method called `getB` and if that
    method is called on an instance of `A` (like `a1.getB())` it will result in a
    call to `getclass` like:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着A类将现在有一个名为`getB`的方法，如果在这个`A`类的实例（如`a1.getB()`）上调用该方法，它将导致对`getclass`的调用，如下所示：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also create (or redefine) a `get()` method that when given a class as an
    argument will find the corresponding `getXXX` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建（或重新定义）了一个`get()`方法，当给定一个类作为参数时，将找到相应的`getXXX`方法。
- en: 'The `getclass()` method is defined as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`getclass()`方法定义如下：'
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, it constructs an SQL statement. If `getclass()` was invoked like `getclass(a1,B,''AB'')`,
    this statement might look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它构建一个SQL语句。如果`getclass()`被调用为`getclass(a1,B,'AB')`，这个语句可能看起来像这样：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then it executes this statement with `self.id` as the argument. The resulting
    list of IDs is returned as a list of instances.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它使用`self.id`作为参数执行这个语句。返回的结果是一个包含实例ID的列表。
- en: The add functionality follows the same pattern, so we only take a quick look
    at the `addclass()` function. It first checks if the entity we are trying to add
    is of the required class. Note that if we make a call like `a1.addB(b1)`, it will
    refer to a function inserted by the `MetaRelation` class that will then be called
    like `addclass(a1,b1,B,'AB')`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 添加功能遵循相同的模式，所以我们只需快速查看`addclass()`函数。它首先检查我们试图添加的实体是否属于所需的类。注意，如果我们调用`a1.addB(b1)`这样的函数，它将引用由`MetaRelation`类插入的函数，然后将以`addclass(a1,b1,B,'AB')`的方式调用。
- en: 'The SQL statement that is subsequently constructed may look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随后构建的SQL语句可能看起来像这样：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because of the unique constraint we specified earlier, a second insert that
    specifies the same specific relation may fail in which case we replace the record
    (that is effectively ignoring the failure). This way, we may call `add()` twice
    with the same arguments, yet still end up with just a single record of the relation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前指定的唯一约束，如果第二个插入操作指定了相同的特定关系，可能会失败，在这种情况下，我们将替换记录（这实际上忽略了失败）。这样，我们可以在具有相同参数的情况下调用`add()`两次，但最终仍然只有一个关系记录。
- en: Browsing lists of entities
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览实体列表
- en: One of the most important tools for a user to interact with a collection of
    entities is a table. A table provides a logical interface to page through lists
    of data and present relevant attributes in columns. Other features often found
    in such a table interface are the options to sort on one or more attributes and
    to drill down, that is, to show only those entities that have some specific value
    for an attribute.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与一组实体进行交互的最重要工具之一是表格。表格提供了一种逻辑接口，用于翻页浏览数据列表，并在列中展示相关属性。此类表格界面通常还包含排序选项，即根据一个或多个属性进行排序，以及钻取功能，即仅显示具有特定属性值的实体。
- en: Time for action using a table-based Entity browser
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于表格的实体浏览器进行操作的时间
- en: 'Run `browse.py` and point your browser to `http://localhost:8080`. A small
    sample application is started that shows lists of random data, as can be seen
    in the following image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`browse.py`并将您的浏览器指向`http://localhost:8080`。启动了一个小型示例应用程序，显示了随机数据列表，如下面的图像所示：
- en: '![Time for action using a table-based Entity browser](img/3647_07_01.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于表格的实体浏览器进行操作的时间](img/3647_07_01.jpg)'
- en: This rather Spartan looking interface may lack most visual adornments, but it
    is fully functional nevertheless. You may page through the list of data by clicking
    the appropriate buttons in the button bar at the bottom, change the sort order
    of the list by clicking one or more times on a header (which will cycle through
    ascending, descending, or no sort at all, however, without any visual feedback
    at the moment) or reduce the list of items shown by clicking on a value in a column,
    that will result in a list of items that share the same value in this column.
    All items may be shown again by clicking the **Clear** button.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来相当简朴的界面可能缺少大多数视觉装饰，但它仍然完全功能。您可以通过点击底部的按钮栏中的相应按钮来翻页浏览数据列表，通过点击一个或多个标题来更改列表的排序顺序（这将循环通过升序、降序或完全不排序，但目前没有任何视觉反馈）或通过点击列中的一个值来减少显示的项目列表，这将导致显示具有此列相同值的项的列表。通过点击**清除**按钮，可以再次显示所有项目。
- en: What just happened?
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `browse` module (which is available as `browse.py)` contains more than the
    sample application. It also defines a reusable `Browse` class that can be initialized
    with a reference to an `Entity` and used as a CherryPy application. The `Browse`
    class can also be given arguments that specify which, if any, columns should be
    shown.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`browse`模块（作为`browse.py`提供）包含的不仅仅是示例应用程序。它还定义了一个可重用的`Browse`类，可以用对`Entity`的引用进行初始化，并用作CherryPy应用程序。`Browse`类还可以接受参数，指定是否以及哪些列应该显示。'
- en: 'Its intended use is best illustrated by taking a look at the sample application:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它的最佳用途可以通过查看示例应用程序来展示：
- en: '**Chapter7/browse.py**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/browse.py**'
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It initializes an instance of the `Browse` class with a single mandatory argument
    as a subclass of `Entity`, in this case, `Number`. It also takes a `columns` argument
    that takes a list that specifies which attributes to show in the table's columns
    and in which order. It also takes a `sortorder` argument, a list of tuples that
    specifies on which columns to sort and in which direction.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它初始化了一个`Browse`类的实例，该实例以一个必选参数作为`Entity`的子类，在本例中是`Number`。它还接受一个`columns`参数，该参数接受一个列表，指定要在表格列中显示哪些属性及其顺序。它还接受一个`sortorder`参数，该参数是一个元组列表，指定要在哪些列上排序以及排序方向。
- en: This instance of the `Browse` class is then passed to CherryPy's `quickstart()`
    function to deliver the functionality to the client. It would be just as simple
    to mount two different `Browse` instances, each servicing a different `Entity`
    class within a custom root application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此`Browse`类的实例传递给CherryPy的`quickstart()`函数，以向客户端提供功能。同样简单的方法是挂载两个不同的`Browse`实例，每个实例在自定义根应用程序中服务于不同的`Entity`类。
- en: 'How is all this implemented? Let''s first take a look at the `__init__()` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些是如何实现的？让我们首先看看`__init__()`方法：
- en: '**Chapter7/browse.py**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/browse.py**'
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `__init__()` method takes quite a number of arguments and only the `entity`
    argument is mandatory. It should be a subclass of `AbstractEntity` and this is
    checked in the highlighted code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法接受相当多的参数，其中只有`entity`参数是必需的。它应该是`AbstractEntity`的子类，并在高亮代码中进行检查。'
- en: All parameters are stored and initialized to suitable defaults if missing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少参数，所有参数都会被存储并初始化为合适的默认值。
- en: The `columns` argument defaults to a list of all columns defined for the entity,
    and we verify that any column we want to display is actually defined for the entity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`columns`参数默认为为实体定义的所有列的列表，我们验证我们想要显示的任何列实际上都为实体定义了。'
- en: Likewise, we verify that the `sortorder` argument (a list of tuples containing
    the column name and its sort direction) contains no more items than there are
    columns (as it is not sensible to sort more than once on the same column) and
    that the sort directions specified are either `asc` or `desc` (for ascending and
    descending respectively).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们验证`sortorder`参数（一个包含列名及其排序方向的元组列表）包含的项不超过列的数量（因为对同一列进行多次排序是不合理的），并且指定的排序方向是`asc`或`desc`（分别表示升序和降序）。
- en: The `pattern` argument, a list of tuples containing the column name and a value
    to filter on, is treated in a similar manner to see if only defined columns are
    filtered on. Note that it is perfectly valid to filter or sort on a column or
    columns that are themselves not shown. This way, we can display subsets of a large
    dataset without bothering with too many columns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern`参数，一个包含列名和要过滤的值的元组列表，以类似的方式处理，以查看是否只过滤了定义的列。请注意，过滤或排序在自身未显示的列上是完全有效的。这样，我们可以在不担心太多列的情况下显示大型数据集的子集。'
- en: 'The final sanity check is done on the `page` argument which specifies the number
    of rows to show on each page. Very few rows feels awkward and negative values
    are meaningless, so we settle for a lower limit of five rows per page:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的合理性检查是在`page`参数上进行的，该参数指定了每页要显示的行数。行数过少会显得尴尬，而负值没有意义，所以我们决定每页至少显示五行：
- en: '**Chapter7/browse.py**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章 browse.py**'
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Both the initial display of the table as well as paging, sorting, and filtering
    are taken care of by the same `index()` method. To understand all the parameters
    it may take, it might be helpful to look at the HTML markup it produces for our
    sample application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表的初始显示以及分页、排序和过滤都由同一个`index()`方法处理。要了解它可能接受的全部参数，查看它为我们示例应用程序生成的HTML标记可能会有所帮助。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `index()` method of the `Browse` class is not the only place where we encounter
    a fair amount of HTML to be delivered to the client. This might become difficult
    to read and therefore difficult to maintain and using templates might be a better
    solution. A good start point for choosing a template solution that works well
    with CherryPy is [http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage](http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Browse`类的`index()`方法不是唯一一个需要向客户端发送大量HTML的地方。这可能会变得难以阅读，因此也难以维护，使用模板可能是一个更好的解决方案。选择与CherryPy兼容的模板解决方案的好起点是[http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage](http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage)。'
- en: Time for action examining the HTML markup
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查HTML标记的行动时间
- en: 'Let''s have a look at how the HTML markup produced by the `index()` method
    looks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`index()`方法生成的HTML标记是什么样的：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Apart from the actual table, we have a`<form>` element with quite a number of`<button>`
    and`<input>` elements, albeit that most have their type attribute set to hidden.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际的表格之外，我们还有一个包含相当多的`<button>`和`<input>`元素的`<form>`元素，尽管大多数元素的类型属性被设置为隐藏。
- en: The`<form>` element has an action attribute "." (a single dot), which will cause
    all the information in the form to be submitted to the same URL that originated
    this form, so the data will be processed by the same `index()` method we are now
    examining. A submit is triggered when any of the`<button>` elements with a `type`
    attribute equal to `submit` is clicked, in which case, not only the`<input>` elements
    are sent, but also the name of the button that was clicked.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`<form>`元素有一个动作属性 "."（一个单独的点），这将导致表单中的所有信息都提交到生成此表单的同一URL，因此数据将由我们现在正在检查的同一个`index()`方法处理。当点击任何具有`type`属性等于`submit`的`<button>`元素时，将触发提交，在这种情况下，不仅会发送`<input>`元素，还会发送被点击的按钮的名称。'
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that any`<input>` element that has to be sent to the server should have
    a `name` attribute. Omitting the `name` attribute will cause it to be missed out.`<input>`
    elements with `type` equal to `hidden` are sent as well if they have a `name`
    attribute. Hidden`<input>` elements are not displayed, but do play an important
    role in keeping essential information associated with a form together.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何需要发送到服务器的`<input>`元素都应该有一个`name`属性。省略`name`属性会导致它被遗漏。《input>`元素如果`type`等于`hidden`并且有`name`属性，也会被发送。隐藏的`<input>`元素不会显示，但它们在将与表单相关的重要信息保持在一起方面发挥着重要作用。
- en: The first hidden`<input>` element in the form stores the start index of the
    items currently displayed in the table. By adding it as a hidden element, we can
    calculate which items to show when we take action when the **Next** or **Previous**
    button is clicked.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中第一个隐藏的`<input>`元素存储了当前在表中显示的项目起始索引。通过将其作为隐藏元素添加，我们可以在点击**下一页**或**上一页**按钮时计算要显示的项目。
- en: We also want to remember if and how the items are sorted. Therefore, we include
    a number of hidden input elements with a `name` attribute equal to `sortorder`,
    each having a value consisting of a column name and a sort direction separated
    by a comma.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望记住项目是如何排序的。因此，我们包括了一些具有`name`属性等于`sortorder`的隐藏输入元素，每个元素都有一个由逗号分隔的列名和排序方向组成的值。
- en: When a form is submitted, input elements with the same name are added in order
    as arguments to the `action` URL and CherryPy will recognize this pattern and
    convert them to a list of values. In this example, the `index()` method of the
    `Browse` class receives this list as its `sortorder` argument. Any `pattern` values
    are present as hidden`<input>` elements as well and processed in an identical
    way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交时，具有相同名称的输入元素按顺序作为参数添加到`action` URL中，CherryPy将识别此模式并将它们转换为值列表。在这个例子中，`Browse`类的`index()`方法接收这个列表作为其`sortorder`参数。任何`pattern`值也作为隐藏的`<input>`元素存在，并以相同的方式处理。
- en: The form also contains an `info` class`<p>` element, that contains information
    on the number of items and the items actually shown on the current page. The final
    part of the form is a collection of submit buttons.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中还包含一个包含有关项目数量和当前页面上实际显示的项目信息的`info`类`<p>`元素。表单的最后部分是一系列提交按钮。
- en: What just happened?
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The `index()` method may be called with no arguments at all or with any or all
    contents of the form it displays. If the client-side JavaScript code wants to
    call it asynchronously while preventing the browser from caching it, it may even
    pass an `_` (underscore) argument with a random value, which will be ignored.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`方法可以不带任何参数调用，也可以调用它显示的表单的任何或所有内容。如果客户端JavaScript代码想要在防止浏览器缓存的情况下异步调用它，它甚至可以传递一个带有随机值的`_`（下划线）参数，该参数将被忽略。'
- en: The rest of the arguments are relevant and checked for sanity before being acted
    upon.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的参数都是相关的，并且在执行之前会进行检查。
- en: We want the `sortorder` variable to contain a list of tuples, each consisting
    of a column name and a sort direction, but the values of the input elements are
    simply interpreted as strings by CherryPy, so we have to convert this list of
    strings to a list of tuples by splitting those strings on the comma separator.
    We neither check for the validity of the column names, nor for that of the sort
    directions because that will be done by the code doing the actual work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`sortorder`变量包含一个由列名和排序方向组成的元组列表，但CherryPy将输入元素的值简单地解释为字符串，因此我们必须通过在逗号分隔符上分割这些字符串来将这个字符串列表转换为元组列表。我们既不检查列名的有效性，也不检查排序方向的有效性，因为这将由执行实际工作的代码来完成。
- en: The `pattern` variable is treated in a similar way, but because we may want
    to filter on values containing commas, we cannot simply use the `split()` method
    here, but have to pass it a limit of 1 to restrict its splitting to the first
    comma it encounters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`pattern`变量以类似的方式处理，但由于我们可能想要根据包含逗号的价值进行筛选，我们在这里不能简单地使用`split()`方法，而必须传递一个限制为1的参数，以限制其分割到遇到的第一个逗号。'
- en: Next, we pass the `sortorder` and `pattern` variables to the `listids()` class
    method of the entity we stored with this `Browse` instance. It will return a list
    of IDs of instances that match the `pattern` criteria (or all instances if no
    patterns are specified) sorted in the correct order. Note that since the number
    of instances might be huge, we do not use the `list()` method here because converting
    all IDs to entity instances at once might render the application unresponsive.
    We will just convert those IDs to instances that we will actually show on the
    page, based on the start and page variables.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`sortorder`和`pattern`变量传递给与这个`Browse`实例一起存储的实体的`listids()`类方法。它将返回匹配`pattern`标准（如果没有指定模式，则为所有实例）的实例ID列表，并按正确顺序排序。请注意，由于实例的数量可能很大，我们在这里不使用`list()`方法，因为一次性将所有ID转换为实体实例可能会使应用程序无响应。我们将根据起始和页面变量将那些ID转换为我们将实际在页面上显示的实例。
- en: To calculate the new start index, we will have to check if we act upon one of
    the paging buttons (highlighted) and add or subtract a page length if we are acting
    on a click on the **Next** or **Previous** button. We set the start index to 0
    if the **First** button was clicked. If the **Last** button was clicked, we set
    the start index to the number of items minus the length of the page. If any of
    these calculations result in a start index that is less than zero, we set it to
    zero.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算新的起始索引，我们必须检查我们是否正在操作分页按钮之一（突出显示），如果我们在**下一页**或**上一页**按钮上点击，则添加或减去页面长度。如果点击了**第一页**按钮，我们将起始索引设置为0。如果点击了**最后一页**按钮，我们将起始索引设置为项目总数减去页面长度。如果这些计算中的任何一个导致起始索引小于零，我们将它设置为0。
- en: The next step is to produce the actual output, yielding one line at a time,
    beginning with the`<table>` element. Our table consists of a head and a body,
    the head consisting of a single row of`<th>` elements, each containing either
    the display name of the column we are showing if it represents an attribute of
    the entity, or the name of the class if it represents a related entity. Any sort
    order associated with this column is represented in its `class` attribute, so
    we may use CSS to make this visible to the user.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成实际输出，每次生成一行，从`<table>`元素开始。我们的表格由一个头部和一个主体组成，头部由一个包含`<th>`元素的单一行组成，每个`<th>`元素包含我们展示的列的显示名称，如果它代表实体的属性，或者如果它代表相关实体，则包含类的名称。与该列关联的任何排序顺序都表示在其`class`属性中，因此我们可以使用CSS使其对用户可见。
- en: To display the rows in the body of the table, we convert the relevant IDs in
    the selection to actual entities (highlighted) and generate`<td>` elements for
    each attribute. If the column refers to related entities, their primary attributes
    are displayed, each related entity encapsulated in its own`<span>` element. The
    latter will enable us to associate relevant actions with each individual item
    shown, for example, displaying it in full when it is clicked.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示表格主体的行，我们将选择中的相关ID转换为实际实体（突出显示）并为每个属性生成`<td>`元素。如果列引用相关实体，则显示它们的属性，每个相关实体都封装在其自己的`<span>`元素中。后者将使我们能够将相关操作与每个单独的项目相关联，例如，当它被点击时显示完整内容。
- en: The final long list of `yield` statements is used to produce the form with its
    many hidden input elements, each recording the arguments that were passed to the
    `index()` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的长列表`yield`语句用于生成带有许多隐藏输入元素的形式，每个输入元素记录传递给`index()`方法的参数。
- en: Caching
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: The bulk of the activity when browsing through lists in a typical application
    is paging forward and backward. If we would need to retrieve the full list of
    entities each time we forward a single page, the application might feel sluggish
    if the list was huge or the sorting and filtering was complicated. It might therefore
    be sensible to implement some sort of caching scheme.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型应用程序中浏览列表的大部分活动是向前和向后翻页。如果我们每次向前翻一页都需要检索实体的完整列表，那么如果列表很大或排序和过滤很复杂，应用程序可能会感觉响应缓慢。因此，实现某种缓存方案可能是明智的。
- en: 'There are a couple of things to consider though:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几个方面需要考虑：
- en: Our CherryPy applications are multithreading, so we should be aware of that,
    especially when storing things in a cache, as we don't want threads to trash the
    shared cache.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的CherryPy应用程序是支持多线程的，因此我们应该意识到这一点，尤其是在将东西存储在缓存中时，因为我们不希望线程破坏共享缓存。
- en: We have to devise some scheme to limit the number of cached items as resources
    are limited.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于资源有限，我们必须制定某种方案来限制缓存的项数。
- en: 'We must overcome the limitations of the statelessness of the HTTP protocol:
    each time the client issues a request. This request should contain all necessary
    information to determine if we have something cached for him available and of
    course we have to understand that each request may be served by a different thread.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须克服HTTP协议无状态的局限性：每次客户端发出请求时。这个请求应该包含所有必要的信息，以确定我们是否为他缓存了可用的内容，当然我们必须理解每个请求可能由不同的线程来处理。
- en: 'These requirements can be satisfied if we change the line in the `index()`
    that retrieves the matching IDs into the following few lines:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改`index()`中检索匹配ID的行，这些要求就可以得到满足：
- en: '**Chapter7/browse.py**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/browse.py**'
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because we will store a unique `cacheid` in a hidden`<input>` element, it will
    be passed as an argument when the form is submitted. We use this `cachid` together
    with the `sortorder` and `pattern` arguments to check whether a previously retrieved
    list of IDs is present in the cache with the `iscached()` method. Passing the
    `sortorder` and `pattern` arguments will enable the `iscached()` method to determine
    if these are changed and invalidate the cache entry.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将在一个隐藏的`<input>`元素中存储一个唯一的`cacheid`，所以在表单提交时，它将被作为参数传递。我们使用这个`cachid`与`sortorder`和`pattern`参数一起，通过`iscached()`方法检查之前检索到的ID列表是否存在于缓存中。传递`sortorder`和`pattern`参数将使`iscached()`方法能够确定这些参数是否已更改，并使缓存条目失效。
- en: '`iscached()` will return the `cacheid` if it exists in the cache or `None`
    if it doesn''t. `iscached()` will also return `None` if the `cacheid` does exist
    but the `sortorder` or `pattern` arguments were changed.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`iscached()`如果缓存中存在`cacheid`，将返回`cacheid`；如果不存在，将返回`None`。如果`cacheid`确实存在，但`sortorder`或`pattern`参数已更改，`iscached()`也将返回`None`。'
- en: Next, we check if the `cacheid` is `None`. This may seem redundant, but if `index()`
    was called for the first time (without arguments, that is) none of the submit
    button arguments would be present and we wouldn't have checked the cache.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`cacheid`是否为`None`。这看起来可能是多余的，但如果`index()`是第一次被调用（即没有参数），则提交按钮的任何参数都不会存在，我们也不会检查缓存。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is intended: if we would, at a later point, revisit this list, we would
    want a fresh set of items, not some old cached ones. After all, the contents of
    the database might have changed.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是故意的：如果我们稍后再次访问这个列表，我们希望得到一组新的项目，而不是一些旧的缓存项目。毕竟，数据库的内容可能已经改变。
- en: If the `cacheid` is `None` we retrieve a fresh list of IDs and store it in the
    cache together with the `sortorder` and `pattern` arguments. The `storeincache()`
    method will return a freshly minted `cacheid` for us to store in the hidden`<input>`
    element.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cacheid`是`None`，我们将检索一个新的ID列表并将其与`sortorder`和`pattern`参数一起存储在缓存中。`storeincache()`方法将为我们返回一个新的`cacheid`，以便我们存储在隐藏的`<input>`元素中。
- en: If the `cacheid` was not `None`, we use the `getfromcache()` method to retrieve
    the list of IDs from the cache. We check the returned value because between our
    checking for the existence of the key in the cache and retrieving the associated
    data, the cache might have been purged, in which case, we still call the `listids()`
    method.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cacheid`不是`None`，我们使用`getfromcache()`方法从缓存中检索ID列表。我们检查返回的值，因为在我们检查缓存中键的存在和检索相关数据之间，缓存可能已经被清除，在这种情况下，我们仍然调用`listids()`方法。
- en: 'The implementation of the `iscached(), getfromcache()`, and `storeincache()`
    method takes care of all the thread safety issues:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`iscached()`、`getfromcache()`和`storeincache()`方法的实现负责处理所有线程安全问题：'
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All methods use the `chash()` method to create a unique key from the `cacheid`
    and the `sortorder` and `pattern` arguments. `iscached()` waits until it acquires
    a lock to check if this unique value is present in the cache. If it is, it updates
    the associated value, a tuple consisting of a timestamp and a list of IDs. By
    updating this timestamp here, we reduce the chance that this item is purged from
    the cache between the check for existence and the actual retrieval.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法都使用`chash()`方法从`cacheid`和`sortorder`以及`pattern`参数创建一个唯一的键。`iscached()`等待获取锁以检查这个唯一值是否存在于缓存中。如果存在，它将更新相关值，一个由时间戳和ID列表组成的元组。通过在这里更新这个时间戳，我们减少了在检查存在性和实际检索之间，这个项目可能被从缓存中清除的机会。
- en: The `getfromcache()` method creates a unique key with the `chash()` method in
    the same way `iscached()` did and waits to acquire the lock before it uses the
    key to retrieve the value from the cache. If this fails, a `KeyError` will be
    raised that will be caught, causing the `None` value to be returned as that was
    what the IDs variable was initialized to.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`getfromcache()`方法使用与`iscached()`相同的方式通过`chash()`方法创建一个唯一的键，并在使用该键从缓存中检索值之前等待获取锁。如果这失败了，将会引发一个`KeyError`，这将会被捕获，导致返回`None`值，因为这是IDs变量初始化时的值。'
- en: The `storeincache()` method first creates a new `cacheid` using one of the `uuid()`
    functions from Python's `uuid` module, essentially creating a random string of
    hexadecimal characters. Together with the `sortorder` and `pattern` arguments,
    this new `cacheid` is used to generate a unique key.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`storeincache()`方法首先使用Python的`uuid`模块中的一个`uuid()`函数创建一个新的`cacheid`，本质上创建了一个随机的十六进制字符字符串。结合`sortorder`和`pattern`参数，这个新的`cacheid`被用来生成一个唯一的键。'
- en: Before we store the list of IDs in the cache, we check whether there is any
    space left by comparing the number of keys in the cache to the maximum length
    we are prepared to accept. If there isn't any room left, we make room by calling
    the `cleancache()` method that will remove any entries that are too old. We then
    store the IDs together with a time stamp after acquiring a lock and return the
    `cacheid` just generated.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将ID列表存储到缓存之前，我们会通过比较缓存中的键数与我们准备接受的最大长度来检查是否有剩余空间。如果没有剩余空间，我们会通过调用`cleancache()`方法来腾出空间，该方法会删除任何过旧的条目。然后我们在获取锁之后将ID与时间戳一起存储，并返回刚刚生成的`cacheid`。
- en: The final cog in our caching machinery is the `cleancache()` method. After requiring
    a lock, a reverse map is built, mapping timestamps to keys. If this map holds
    any items, we use it to locate any key that is older than an hour. Those are deleted
    after acquiring a lock.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缓存机制中的最后一个齿轮是`cleancache()`方法。在获取锁之后，会构建一个反向映射，将时间戳映射到键上。如果这个映射包含任何项，我们就用它来定位任何超过一小时的旧键。这些键在获取锁后会删除。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The whole business with acquiring a lock and releasing it as quick as possible
    instead of acquiring the lock and doing all the cache-related business in one
    go ensures that other threads accessing the cache do not have to wait very long,
    which keeps the whole application responsive.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽快获取锁并释放，而不是一次性获取锁并执行所有与缓存相关的业务，确保访问缓存的其它线程不需要等待很长时间，这保持了整个应用程序的响应性。
- en: If the age of an entry is less than an hour, we keep notes to see which of the
    remaining ones is the oldest to remove that one at the end. This way, we ensure
    that we always retire at least one entry, even if there aren't any really old
    ones.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条目的年龄小于一小时，我们会记录下来，看看剩下的哪个是最老的，以便在最后删除它。这样，我们确保我们总是至少退休一个条目，即使没有特别旧的条目。
- en: The books application revisited
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次审视书籍应用程序
- en: With that much versatile code available, constructing a new lean and mean version
    of our books application becomes very straightforward.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这么多灵活的代码之后，构建我们书籍应用程序的新版简洁版本变得非常直接。
- en: Time for action creating a books application, take two
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建书籍应用程序的时间，再来一次
- en: Run the code in `books2.py` and point your web browser to [http://localhost:8080](http://localhost:8080).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`books2.py`中的代码，并将您的网络浏览器指向[http://localhost:8080](http://localhost:8080)。
- en: 'After logging in (a default username/password combination of admin/admin will
    be present), you will be presented with a list of entities to browse (books and
    authors) and after clicking on **Books**, a screen will present itself that closely
    resembles the general Browse application (the page still has a Spartan look because
    no CSS is added at this point):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '登录后（将出现默认的用户名/密码组合admin/admin），您将看到一个可以浏览的实体列表（书籍和作者），点击**书籍**后，将出现一个屏幕，其外观与一般的浏览应用程序非常相似（页面仍然看起来很简朴，因为此时还没有添加CSS）:'
- en: '![Time for action creating a books application, take two](img/3647_07_02.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![创建书籍应用程序的时间，再来一次](img/3647_07_02.jpg)'
- en: Thanks to some JavaScript goodness, our browse screen is embedded in the page
    instead of functioning standalone, yet all functionality is retained, including
    skipping forward and backward as well as sorting. New books or authors may be
    added by clicking the **Add new** button.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了JavaScript的强大功能，我们的浏览屏幕被嵌入到页面中，而不是独立运行，但所有功能都得到了保留，包括向前和向后跳转以及排序。可以通过点击**添加新**按钮添加新的书籍或作者。
- en: What just happened?
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'When we take a look at the code in `books2.py`, we see that its main part consists
    of definitions of entities, relations, and specific `Browse` entities that are
    combined together to form a CherryPy application:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`books2.py`中的代码时，我们看到其主要部分由实体、关系和特定的`Browse`实体定义组成，这些实体组合在一起形成CherryPy应用程序：
- en: '**Chapter7/books2.py**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/books2.py**'
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After importing the modules we need, we define `User, Book`, and `Author` entities
    and an `OwnerShip` class, to define the relation between a book and a user. Likewise,
    we define a `Writer` class that defines the relation between a book and its author(s).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所需的模块后，我们定义`User`、`Book`和`Author`实体以及一个`OwnerShip`类，以定义书籍与用户之间的关系。同样，我们定义一个`Writer`类，用于定义书籍与其作者之间的关系。
- en: The next step is to create an instance of a `LogonDB` class (highlighted) that
    will be used in many parts of our CherryPy application to verify that the user
    is authenticated.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个`LogonDB`类的实例（突出显示），它将在我们的CherryPy应用程序的许多部分中使用，以验证用户是否已认证。
- en: The bulk of the CherryPy application consists of two `Browse` classes, one for
    books and one for authors. Each class has display, edit, and add class variables
    that point to further branches of our application that are served by `Display`
    instances.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: CherryPy应用程序的主体由两个`Browse`类组成，一个用于书籍，另一个用于作者。每个类都有显示、编辑和添加类变量，这些变量指向由`Display`实例提供服务的我们应用程序的进一步分支。
- en: The `Root` class we define ties all of this together. It refers to the `LogonDb`
    instance created earlier in its `logon` class variable, and its `books` and `authors`
    class variables point to the previously defined `Browse` instances. It also defines
    an `index()` method that merely presents a logon screen if the user is not yet
    authenticated and if he/she is, redirects the user to the entities page. The `entities()`
    method which serves this page makes sure there is a corresponding user in the
    database (highlighted) and presents a base page consisting of a navigation `div`
    and a content `div` that will be filled when one of the links in the navigation
    section is clicked, and some JavaScript to tie everything together.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的`Root`类将所有这些内容串联起来。它引用其`logon`类变量中创建的`LogonDb`实例，其`books`和`authors`类变量指向先前定义的`Browse`实例。它还定义了一个`index()`方法，如果用户尚未认证，则仅显示登录界面；如果已认证，则将用户重定向到实体页面。为该页面提供服务的是`entities()`方法，确保数据库中存在相应的用户（突出显示），并展示一个包含导航`div`和内容`div`的基本页面，当点击导航部分中的链接之一时，这些`div`将被填充，并有一些JavaScript代码将所有内容串联起来。
- en: 'Before we examine the JavaScript, it might be good to take a look at the illustration
    to see how the application tree looks:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查JavaScript之前，看看这个插图可能会有助于了解应用程序树的结构：
- en: '| Path | Method |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 路径 | 方法 |'
- en: '| --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/` | `Root.index()` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `Root.index()` |'
- en: '| `/entities` | `Root.entities()` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `/entities` | `Root.entities()` |'
- en: '| `/logon` | `LogonDB.index()` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `/logon` | `LogonDB.index()` |'
- en: '| `/books` | `BooksBrowser.index()` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `/books` | `BooksBrowser.index()` |'
- en: '| `/add` | `Display().index()` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `/add` | `Display().index()` |'
- en: '| `/edit` | `Display().index()` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `/edit` | `Display().index()` |'
- en: '| `/display` | `Display().index()` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `/display` | `Display().index()` |'
- en: '| `/authors` | `AuthorBrowser.index()` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `/authors` | `AuthorBrowser.index()` |'
- en: '| `/add` | `Display().index()` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `/add` | `Display().index()` |'
- en: '| `/edit` | `Display().index()` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `/edit` | `Display().index()` |'
- en: '| `/display` | `Display().index()` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `/display` | `Display().index()` |'
- en: (Note that the `edit, add`, and `display` branches are each serviced by a different
    instance of `Display)`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，`编辑、添加`和`显示`分支分别由`Display`的不同实例提供服务）。
- en: 'Earlier, we saw that the `Browse` class we created was able to function standalone:
    clicking on any of the buttons referred to the same URL that served up the form
    in the first place. This setup makes it possible to use different `Browse` instances
    in different parts of an application tree, but here we want to replace a part
    of a page with the form produced by the `Browse` instance using an AJAX call.
    The problem then is that submitting a form without an `action` attribute will
    result in a request to the current URL, that is, the one referring to the page
    the form is embedded in, not the one that produces the form.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到我们创建的`Browse`类能够独立运行：点击任何按钮都会引用最初提供表单的相同URL。这种设置使得在应用程序树的不同部分使用不同的`Browse`实例成为可能，但在这里我们希望通过AJAX调用用`Browse`实例生成的表单替换页面的一部分。问题在于，如果没有`action`属性，提交表单将导致对当前URL的请求，即表单嵌入的页面所引用的URL，而不是生成表单的URL。
- en: 'Fortunately, we can use jQuery to solve this problem by altering the `action`
    attributes of the freshly loaded forms to point to the URL that served those forms:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过更改新加载表单的 `action` 属性来指向提供这些表单的 URL，以使用 jQuery 解决这个问题：
- en: '**Chapter7/books2.py**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**第7章/books2.py**'
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is accomplished by adding a click event handler to the links in the navigation
    area. That will not only prevent the default action but load the HTML produced
    by the URL referred to by the `href` attribute and pass a callback function that
    will alter the action attributes of any freshly loaded`<form>` elements (highlighted).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过向导航区域中的链接添加点击事件处理程序来实现的。这不仅会阻止默认操作，还会加载由 `href` 属性引用的 URL 生成的 HTML，并传递一个回调函数，该函数将改变任何新加载的
    `<form>` 元素的操作属性（突出显示）。
- en: The `shiftforms()` function first prepends the original `href` contents to the
    `action` attributes and then binds a click handler to each button or input element
    with a `type` attribute equal to submit.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`shiftforms()` 函数首先将原始的 `href` 内容添加到 `action` 属性中，然后为每个具有等于提交的 `type` 属性的按钮或输入元素绑定一个点击处理程序。'
- en: It would not be sufficient to add a submit handler to the form, because we don't
    want to let the`<form>` perform its default action. When a form is submitted,
    the contents of the page are replaced and this is not what we want. Instead, we
    want to replace the contents of the content `div` so we have to `load()` the URL
    from the form's `action` attribute ourselves.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 仅向表单添加提交处理程序是不够的，因为我们不希望 `<form>` 执行其默认操作。当表单提交时，页面内容会被替换，这不是我们想要的。相反，我们想要替换内容
    `div` 的内容，因此我们必须自己 `load()` 表单的 `action` 属性中的 URL。
- en: This also means that we have to serialize the contents of the form to add as
    parameters to this URL, but jQuery's `serialize()` function will not serialize
    submit buttons. We, therefore, end up with adding a click handler to submit buttons
    in order to be able to determine the submit button that was clicked, so we can
    construct a complete list of parameters, including the name and value of the submit
    button.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们必须将表单的内容序列化以添加为 URL 的参数，但 jQuery 的 `serialize()` 函数不会序列化提交按钮。因此，我们最终需要为提交按钮添加点击处理程序，以便能够确定被点击的提交按钮，这样我们就可以构建一个完整的参数列表，包括提交按钮的名称和值。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We took a critical look at the framework we developed so far, and made improvements
    to the framework to make it more versatile and simpler to use for a developer.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对迄今为止开发的框架进行了批判性的审视，并对框架进行了改进，使其更具可扩展性和易于开发者使用。
- en: 'Specifically, we covered:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to do away with explicit database and thread initialization.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免显式数据库和线程初始化。
- en: How to wield the awesome power of Python metaclasses to synchronize the creation
    of Python classes and their corresponding database tables.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运用 Python 元类的强大功能来同步 Python 类及其对应的数据库表的创建。
- en: How to use those same metaclasses to alter the definitions of existing classes
    to create a much more intuitive interface when dealing with relations.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用相同的元类来改变现有类的定义，以便在处理关系时创建一个更直观的接口。
- en: How to implement a `Browse` class to navigate through large collections of entities
    in an efficient way using caches.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一个 `Browse` 类，以高效的方式使用缓存在大型实体集合中导航。
- en: How to rewrite the books application in a much simpler way with this reworked
    framework.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用这个重构的框架以更简单的方式重写书籍应用。
- en: We have still glossed over several issues, including how to display and edit
    instances. In the last three chapters, we will develop a Customer Relationship
    Management application and fill in the final bits, including controlling how to
    restrict some actions to specific persons and how to allow for end user customization
    of the application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然忽略了几个问题，包括如何显示和编辑实例。在最后三章中，我们将开发一个客户关系管理应用，并填补最后的细节，包括如何限制某些操作给特定人员以及如何允许最终用户自定义应用。
