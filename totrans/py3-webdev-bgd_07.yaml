- en: Chapter 7. Refactoring Code for Reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After doing a substantial bit of work, it is often a good idea to take a step
    back and look critically at your work to see if things could have been done better.
    Quite often, the insight gained in the development process can be used to good
    effect in any new code or even to refactor existing code if the benefits are so
    substantial that they warrant the extra work.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Often, such a critical reappraisal is motivated by observed shortcomings in
    the application, like poor performance, or by noting that requested changes take
    more time than we like because the code is designed in a less than optimal way.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have designed and implemented several applications in the last few
    chapters based on a simple entity/relation framework, it is time to have that
    critical look and see if there is room for improvement.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Time for action taking a critical look
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examine each major piece of code (often a Python module that you implemented)
    and ask yourself the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Could I reuse it without changes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much extra code was needed to actually use the module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you really understand the documentation (even if you wrote it yourself)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much of the code is duplicated?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How easy is it to add new functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well did it perform?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we ask these questions about the entity and relation modules we developed,
    we see that:'
  prefs: []
  type: TYPE_NORMAL
- en: It was quite easy to reuse the modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But they do require quite a bit of extra code, for example, to initialize tables
    and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we deliberately wrote specific modules to deal with domain-specific code,
    like input validation, but it is worth examining this code to see if we can discover
    patterns and enhance our framework to better support these patterns. One example
    is that we frequently require auto completion so it is worth looking at how this
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Performance-wise, we saw in the books application that we have hardly addressed
    the way in which large lists of books are browsed and this certainly needs attention
    if we wish to reuse our framework in settings that deal with large lists.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have pointed out several areas where our framework modules might
    be improved, it is time to consider if it is worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Framework modules are intended to be reused by many applications, so a redesign
    that will allow the modules to be used with less additional code is a good idea,
    as less code means less maintenance. Of course, rewriting may mean that existing
    applications need to be rewritten if they want to use these new versions, but
    that is the price to pay for better maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring existing functionality is often less problematic, but benefits greatly
    from a good test framework to check if the new implementation still behaves as
    expected. Likewise, adding completely new functionality is likely to be even less
    of a problem, as existing applications do not yet use this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Because, in our case, we judge the advantages to outweigh the disadvantages,
    we will rework the entity/relation framework in the next section. We will not
    only focus on using less code, but also on making the definition of the new Entity
    and Relation classes easier to read. This will provide for a more intuitive use
    of these classes.
  prefs: []
  type: TYPE_NORMAL
- en: We will also devote a section to developing functionality to browse through
    lists of entities in a way that scales well, even if the lists are large and need
    to be sorted or filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first area that we will refactor is the way we can use the `Entity` class.
    Our goal is to enable a more intuitive use, without the need for explicit initialization
    of the database connections. To get a feeling for what is possible, let us first
    look at an example of how we would use the refactored `entity` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for action defining new entities: how it should look'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type in and run the following code (also available as `testentity.py)`. It
    will use the refactored `entity` module to define a `MyEntity` class and work
    with some instances of this class. We will create, list, and update instances
    and even see an update fail because we try to assign a value that will not pass
    a validation for an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/testentity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output produced by the print functions should look similar to the lines
    listed next, including the raised exception caused by an invalid update attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we note is that there is no explicit initialization of any database,
    nor is there any code to explicitly initialize any threads. All that is needed
    is to subclass the entity class from the `AbstractEntity` class provided in the
    entity module and define a database class variable that points to a file to be
    used as a database.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing is that although we define a specific class (MyEntity, in this
    example) in a similar way as before by defining it as a subclass of Entity, we
    now specify any attributes by defining class variables that are assigned `Attribute`
    instances. In the example, we do this for just a single attribute `a` (highlighted).
    The `Attribute` instance encapsulates a lot of knowledge about constraints, and
    allows for the definition of a default value and a validation function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an instance isn't any different, but as the second `list()` example
    shows, this implementation allows for filtering so there is no need to retrieve
    all instance IDs, instantiate them as true objects and compare their attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The final assignment to the `a` attribute shows the validation feature in action.
    It raises an `AttributeError` exception because trying to assign a value of 9
    to it triggers our validation function.
  prefs: []
  type: TYPE_NORMAL
- en: These new and less cumbersome semantics are largely due to what can be achieved
    by using metaclasses, a concept we explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Metaclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the Python documentation warns that using metaclasses will make your
    head explode (read, for example, `http://www.python.org/doc/newstyle/)`, they
    are not that dangerous: they may cause headaches, but these will mostly fade away
    after some experimenting and re-reading of the documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Metaclasses allow you to inspect and alter the definition of a class just before
    this definition is made final and becomes available to the programmer. This is
    possible because, in Python, even classes are objects; specifically, they are
    instances of a metaclass. When we instantiate an object, we can control the way
    this instance is initialized by defining the `__init__()` and `__new__()` methods.
    Likewise, we can control the way a class is initialized by defining suitable `__init__()`
    and `__new__()` methods in its metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: Just as all classes are ultimately subclasses of the `object` class, all metaclasses
    derive from the `type` metaclass. This means that if we want our class to be an
    instance of a different type of metaclass, we have to subclass `type` and define
    our class.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the previous paragraphs, you may still fear your head may explode,
    but like most things, an example is much simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action using metaclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we want to be able to verify that classes we define always have an `__info__()`
    method. We can accomplish that by defining a suitable metaclass and defining any
    new class that should be checked with a reference to this metaclass. Look at the
    following example code (also available as `metaclassexample.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/metaclassexample.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will raise an exception for the `incorrect` class, but not for the `correct`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the `__new__()` method of a metaclass receives a number of important
    parameters. First, the metaclass itself and the `classname` of the class that
    is being defined, a (possibly empty) list of `baseclasses`, and finally the class
    dictionary. That last argument is very important.
  prefs: []
  type: TYPE_NORMAL
- en: As we define a class with a class statement, all methods and class variables
    we define here end up in a dictionary. Once this class is completely defined,
    this dictionary will be available as the `__dict__` attribute of the class. This
    is the dictionary that is passed to the `__new__()` method of the metaclass and
    we can examine and alter this dictionary at will.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we simply check whether there exists a key called `__info__`
    in this class dictionary and raise an exception if it doesn't. (We do not really
    check that it is a method but this is possible too of course). If everything went
    well, we call the `__new__()` method of `type` (the mother of all metaclasses)
    as that method will take care of making the class definition available in the
    current scope.
  prefs: []
  type: TYPE_NORMAL
- en: There is an extra trick involved, however. The `withinfo` class is abstract
    in the sense that it defines the need for an `__info__()` method by referring
    to the `hasinfo` metaclass, but it does not define one itself. However, because
    it refers to the `hasinfo` metaclass, an exception would be raised because its
    own class dictionary is checked in the same way as its subclasses. To prevent
    this, we only check for the occurrence of the `__info__()` method if a class is
    a subclass, that is, when the list of base classes (available in the `baseclasses`
    parameter) is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for mandatory methods is nice, but with so much information available,
    much more can be done. In the next section, we use this power to ensure that the
    definition of a new class will take care of creating suitable tables in a database
    backend as well.
  prefs: []
  type: TYPE_NORMAL
- en: MetaEntity and AbstractEntity classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides creating a database table, if necessary, the metaclass that we will
    define will also examine the `Attribute` instance assigned to any class variable
    to build dictionaries of display names and validation functions. This way, subclasses
    can easily check if a column has such an attribute by using the column name as
    a key, thus obviating the need to check all class variables themselves again and
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '![MetaEntity and AbstractEntity classes](img/3746OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action implementing the MetaEntity and AbstractEntity classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Attribute` class is mainly a vehicle to store information about attributes
    in a structured way. We could have used strings and parsed them, but by using
    an `Attribute` class, it is possible to explicitly recognize class variables that
    are meant to be attributes that are stored as database columns. That way, we can
    still define class variables that have a different purpose. Also, writing a parser
    is a lot of work, while checking parameters is a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted code shows that most parameters are used to create a string
    that can be used as a column definition that is part of a create table statement.
    The other parameters (displayname and `validate)` are just stored as is for future
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The metaclass we will use to synchronize the creation of database tables and
    the creation of entity classes is called `MetaEntity`. Its `__new__()` method
    is where all the action takes place, but there is one important additional method:
    `__prepare__()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `__prepare__()` method is called to provide an object that can be used as
    a class dictionary. The default, as provided by the `type` class, just returns
    a regular Python `dict` object. Here we return an ordered dictionary, a dictionary
    that will remember the order of its keys as they are entered. This will enable
    us to use the order in which class variables are declared, for example, to use
    this as the default order to display columns. Without an ordered dictionary, we
    wouldn't have any control and would have to supply separate information.
  prefs: []
  type: TYPE_NORMAL
- en: The `__new__()` method first checks if we are a subclass of `MetaEntity` by
    checking whether the list of base classes is non zero (highlighted) as `MetaEntity`
    itself does not have a database backend.
  prefs: []
  type: TYPE_NORMAL
- en: Then it checks if the database class variable is defined. If not, we are a specific
    entity that has a database backend and we try to locate the database class variable
    in one of our super classes. If we find it, we store it locally; if not, we raise
    an exception because we cannot function without a reference to a database.
  prefs: []
  type: TYPE_NORMAL
- en: The `AbstractEntity` class will have a `_local` class variable defined that
    holds a reference to thread local storage, and subclasses will have their own
    `_local` variable that points to the same thread local storage.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to gather all sorts of information from all the class variables
    that refer to `Attribute` instances. First we collect a list of column names (highlighted).
    Remember that because we caused the class dictionary to be an ordered dictionary,
    these column names will be in the order they were defined.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, we define a list of display names. If any attribute does not have
    a `displayname` attribute, its display name will be identical to its column name.
    We also construct a dictionary of validators, that is, a dictionary indexed by
    column name that holds a function to validate any value before it is assigned
    to a column.
  prefs: []
  type: TYPE_NORMAL
- en: Every entity will have an `id` attribute (and a corresponding column in the
    database table) that is created automatically without it being explicitly defined.
    Therefore, we add its `displayname` separately and construct a special Attribute
    instance (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: This `coldef` attribute of this special `Attribute` together with the `coldef`
    attributes of the other `Attribute` instances will then be used to compose an
    SQL statement that will create a table with the proper column definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we pass the altered and augmented class dictionary together with the
    original list of base classes and the class name to the `__new__()` method of
    the type class which will take care of the actual construction of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the functionality of any `Entity` is not implemented by its metaclass,
    but in the regular way, that is, by providing methods in the class that all entities
    should derive from: `AbstractEntity:`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What just happened
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AbstractEntity` provides a number of methods to provide CRUD functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor to refer to the existing entities in the database or to create
    new ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list()` and `listids()`, to find instances that match certain criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`, to synchronize changed attributes of an entity with the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete()`, to delete an entity from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also defines the 'special' Python methods `__str__(), __repr__()`, and `__setattr__()`
    to render an entity in a legible way and to validate the assignment of a value
    to an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, `AbstractEntity` refers to the `MetaEntity` metaclass (highlighted).
    It also defines a `_local` class variable that refers to thread local storage.
    The `MetaEntity` class will make sure this reference (but not its contents) are
    copied to all subclasses for fast access. By defining it here, we will make sure
    that all subclasses refer to the same thread local storage, and more importantly,
    will use the same connection to the database for each thread instead of using
    a separate database connection for each different entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `listids()` class method will return a list of IDs of entities that match
    the criteria in its `pattern` argument or the IDs of all the entities if no criteria
    were given. It will use the `sortorder` argument to return the list of IDs in
    the required order. Both `sortorder` and `pattern` are a list of tuples, each
    tuple having the column name as its first item. The second item will be a string
    to match against for the `pattern` argument or either `asc` or `desc` for the
    `sortorder` argument, signifying an ascending or descending sort respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL statement to retrieve any matching IDs is constructed by first creating
    the `select` part (highlighted), as this will be the same irrespective of any
    additional restrictions. Next, we check if there are any `pattern` components
    specified, and if so, add a `where` clause with matching parts for each `pattern`
    item. The matches we specify use the SQL `like` operator, which is normally only
    defined for strings, but SQLite will convert any argument to a string if we use
    the like operator. Using the like operator will allow us to use SQL wildcards
    (for example, `%` ).
  prefs: []
  type: TYPE_NORMAL
- en: The next stage is to check if there were any sort order items specified in the
    `sortorder` argument. If not, we use the default sort order stored in the `sortorder`
    class variable (which in our current implementation will still be `None)`. If
    there are items specified, we add an order by clause and add specifications for
    each sort item. A typical SQL statement will look something like `select id from
    atable where col1 like ? and col2 like ? order by col1 asc`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `_connect()` method (that was added by the metaclass) to
    retrieve a database connection (and establish one, if needed) that we can use
    to execute the SQL query with and retrieve the list of IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The `list()` method bears a close resemblance to the `listids()` method and
    takes the same arguments. It will, however, return a list of entity instances
    rather than a list of just the IDs by calling the entity's constructor with each
    ID as an argument. This is convenient if that was what we wanted to do with those
    IDs anyway, but a list of IDs is often easier to manipulate. We therefore provide
    both methods.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to retrieve lists of entities is nice, but we must also have a means
    to create a new instance and to retrieve all information associated with a record
    with a known ID. That is where the entity's constructor, in the form of the `__init__()`
    method, comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking, `__init__()` isn't a constructor but a method that initializes
    an instance after it is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: If a single ID keyword argument is passed to `__init__()` (highlighted), all
    columns of the record matching that ID are retrieved and the corresponding arguments
    (that is, attributes with the same name as a column) are set using the `setattr()`
    built-in function.
  prefs: []
  type: TYPE_NORMAL
- en: If more than one keyword argument is passed to `__init__()`, each should be
    the name of a defined column. If not, an exception is raised. Otherwise, the keywords
    and their values are used to construct an insert statement. If there are more
    columns defined than there are keywords given, this will result in default values
    to be inserted. The default is usually `NULL` unless a `default` argument was
    specified for the column when the `Entity` was defined. If `NULL` is the default
    and the column has a `non null` constraint, an exception will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Because ID columns are defined as `autoincrement` columns and we do not specify
    an explicit ID value, the ID value will be equal to the `rowid`, a value we retrieve
    as the `lastrowid` attribute of the cursor object (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero retrieving instances in a single step
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrieving a list of IDs first and then instantiating entities means that we
    have to retrieve all attributes of each entity with a separate SQL statement.
    This might have a negative impact on performance if the list of entities is large.
  prefs: []
  type: TYPE_NORMAL
- en: Create a variant of the `list()` method that will not convert the selected IDs
    to entity instances one-by one, but will use a single select statement to retrieve
    all attributes and use those to instantiate entities.
  prefs: []
  type: TYPE_NORMAL
- en: Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining relations between entities should be just as hassle free as defining
    the entities themselves, and with the power of metaclasses in our hands, we can
    use the same concepts. But let's first have a look at how we would use such an
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for action defining new relations: how it should look'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sample code shows how we would use a `Relation` class (also available
    in `relation.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining a few entities, defining the relation between those entities
    follows the same pattern: we define a `Relation` class that is a subclass of `AbstractRelation`
    to establish a reference to a database that will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we define an actual relation between two entities by subclassing `Relation`
    and defining two class variables, `a` and `b` that refer to the `Entity` classes
    that form each half of the relation.
  prefs: []
  type: TYPE_NORMAL
- en: If we instantiate a few entities, we may then define a few relations between
    these instances by using the `add()` method and retrieve related entities with
    the `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note that those methods are called on the `Entity` instances, allowing for a
    much more natural idiom than the use of class methods in the `Relation` class.
    These `add()` and `get()` methods were added to those entity classes by the `MetaRelation`
    metaclass, and in the next section, we will see how this is accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram for relation classes looks nearly identical to the one for
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/3746OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the MetaRelation and AbstractRelation classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the `AbstractRelation` class is very minimalistic because
    it is only used to create some thread local storage and establish a relation with
    the `MetaRelation` metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: No methods are specified since the metaclass will take care of adding suitable
    methods to the entity class that are a part of this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MetaRelation` class has two goals: creating a database table that will
    hold records for each individual relation and adding methods to the entity classes
    involved, so that relations can be created, removed, and queried:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As was the case for the `MetaEntity` class, `MetaRelation` performs its magic
    through its `__new__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we check if we are creating a subclass of `AbstractRelation` by checking
    the length of the `baseclasses` parameter (remember that `MetaRelation` is defined
    as a metaclass for `AbstractRelation`, meaning that not only its subclasses, but
    also `AbstractRelation` itself will be processed by the metaclass machinery, something
    that is not really needed here).
  prefs: []
  type: TYPE_NORMAL
- en: If it is a subclass, we copy the database and thread local storage references
    to the class dictionary for quick access.
  prefs: []
  type: TYPE_NORMAL
- en: If there was no `database` attribute specified, we know the class being defined
    is a subclass of `Relation`, that is, a specific relation class and mark this
    in the `relationdefinition` variable (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: If we are dealing with a concrete definition of a relation, we will have to
    work out which entities are involved. This is done by checking the class dictionary
    for attributes named `a` and `b`, that should be subclasses of `AbstractEntity`
    (highlighted). These are both halves of the relation and their names are used
    to create a bridging table if not already present.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to define a relation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL statement generated would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each column references the primary key in the corresponding table (because we
    did specify just the table in the references clause) and the `on delete cascade`
    constraint will make sure that if an entity is deleted, the relation is deleted
    as well. The final `unique` constraint will make sure that if there is a relation
    between specific instances, there will be only one record reflecting this.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new methods to existing classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final part of the `__new__()` method deals with inserting methods in the
    entity classes that are involved in this relation. Adding methods to other classes
    may sound like magic, but in Python, classes themselves are objects too and have
    class dictionaries that hold the attributes of a class. Methods are just attributes
    that happen to have a value that is a function definition.
  prefs: []
  type: TYPE_NORMAL
- en: We can, therefore, add a new method at runtime to any class by assigning a reference
    to a suitable function to a class attribute. The `MetaEntity` class only altered
    the class dictionary of an `Entity` before it was created. The `MetaRelation`
    class goes one step further and not only alters the class dictionary of the `Relation`
    class, but also those of the `Entity` classes involved.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Altering class definitions at runtime is not limited to metaclasses, but should
    be used sparingly because we expect classes to behave consistently anywhere in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: If we have two classes, `A` and `B`, we want to make sure each has its own complement
    of get and add methods. That is, we want to make sure the `A` class has `getB()`
    and `addB()` methods and the `B` class has `getA()` and `addA()`. We, therefore,
    define generic `getclass()` and `addclass()` functions and assign those with tailored
    lambda functions to the named attributes in the class concerned (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assume again that the entity classes are called `A` and `B` and our relation
    is called `AB`, the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'will mean that the A class will now have a method called `getB` and if that
    method is called on an instance of `A` (like `a1.getB())` it will result in a
    call to `getclass` like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We also create (or redefine) a `get()` method that when given a class as an
    argument will find the corresponding `getXXX` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getclass()` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it constructs an SQL statement. If `getclass()` was invoked like `getclass(a1,B,''AB'')`,
    this statement might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then it executes this statement with `self.id` as the argument. The resulting
    list of IDs is returned as a list of instances.
  prefs: []
  type: TYPE_NORMAL
- en: The add functionality follows the same pattern, so we only take a quick look
    at the `addclass()` function. It first checks if the entity we are trying to add
    is of the required class. Note that if we make a call like `a1.addB(b1)`, it will
    refer to a function inserted by the `MetaRelation` class that will then be called
    like `addclass(a1,b1,B,'AB')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL statement that is subsequently constructed may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Because of the unique constraint we specified earlier, a second insert that
    specifies the same specific relation may fail in which case we replace the record
    (that is effectively ignoring the failure). This way, we may call `add()` twice
    with the same arguments, yet still end up with just a single record of the relation.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing lists of entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important tools for a user to interact with a collection of
    entities is a table. A table provides a logical interface to page through lists
    of data and present relevant attributes in columns. Other features often found
    in such a table interface are the options to sort on one or more attributes and
    to drill down, that is, to show only those entities that have some specific value
    for an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action using a table-based Entity browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run `browse.py` and point your browser to `http://localhost:8080`. A small
    sample application is started that shows lists of random data, as can be seen
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action using a table-based Entity browser](img/3647_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This rather Spartan looking interface may lack most visual adornments, but it
    is fully functional nevertheless. You may page through the list of data by clicking
    the appropriate buttons in the button bar at the bottom, change the sort order
    of the list by clicking one or more times on a header (which will cycle through
    ascending, descending, or no sort at all, however, without any visual feedback
    at the moment) or reduce the list of items shown by clicking on a value in a column,
    that will result in a list of items that share the same value in this column.
    All items may be shown again by clicking the **Clear** button.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `browse` module (which is available as `browse.py)` contains more than the
    sample application. It also defines a reusable `Browse` class that can be initialized
    with a reference to an `Entity` and used as a CherryPy application. The `Browse`
    class can also be given arguments that specify which, if any, columns should be
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its intended use is best illustrated by taking a look at the sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/browse.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It initializes an instance of the `Browse` class with a single mandatory argument
    as a subclass of `Entity`, in this case, `Number`. It also takes a `columns` argument
    that takes a list that specifies which attributes to show in the table's columns
    and in which order. It also takes a `sortorder` argument, a list of tuples that
    specifies on which columns to sort and in which direction.
  prefs: []
  type: TYPE_NORMAL
- en: This instance of the `Browse` class is then passed to CherryPy's `quickstart()`
    function to deliver the functionality to the client. It would be just as simple
    to mount two different `Browse` instances, each servicing a different `Entity`
    class within a custom root application.
  prefs: []
  type: TYPE_NORMAL
- en: 'How is all this implemented? Let''s first take a look at the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/browse.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` method takes quite a number of arguments and only the `entity`
    argument is mandatory. It should be a subclass of `AbstractEntity` and this is
    checked in the highlighted code.
  prefs: []
  type: TYPE_NORMAL
- en: All parameters are stored and initialized to suitable defaults if missing.
  prefs: []
  type: TYPE_NORMAL
- en: The `columns` argument defaults to a list of all columns defined for the entity,
    and we verify that any column we want to display is actually defined for the entity.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, we verify that the `sortorder` argument (a list of tuples containing
    the column name and its sort direction) contains no more items than there are
    columns (as it is not sensible to sort more than once on the same column) and
    that the sort directions specified are either `asc` or `desc` (for ascending and
    descending respectively).
  prefs: []
  type: TYPE_NORMAL
- en: The `pattern` argument, a list of tuples containing the column name and a value
    to filter on, is treated in a similar manner to see if only defined columns are
    filtered on. Note that it is perfectly valid to filter or sort on a column or
    columns that are themselves not shown. This way, we can display subsets of a large
    dataset without bothering with too many columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final sanity check is done on the `page` argument which specifies the number
    of rows to show on each page. Very few rows feels awkward and negative values
    are meaningless, so we settle for a lower limit of five rows per page:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/browse.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both the initial display of the table as well as paging, sorting, and filtering
    are taken care of by the same `index()` method. To understand all the parameters
    it may take, it might be helpful to look at the HTML markup it produces for our
    sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `index()` method of the `Browse` class is not the only place where we encounter
    a fair amount of HTML to be delivered to the client. This might become difficult
    to read and therefore difficult to maintain and using templates might be a better
    solution. A good start point for choosing a template solution that works well
    with CherryPy is [http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage](http://www.cherrypy.org/wiki/ChoosingATemplatingLanguage).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action examining the HTML markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at how the HTML markup produced by the `index()` method
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the actual table, we have a`<form>` element with quite a number of`<button>`
    and`<input>` elements, albeit that most have their type attribute set to hidden.
  prefs: []
  type: TYPE_NORMAL
- en: The`<form>` element has an action attribute "." (a single dot), which will cause
    all the information in the form to be submitted to the same URL that originated
    this form, so the data will be processed by the same `index()` method we are now
    examining. A submit is triggered when any of the`<button>` elements with a `type`
    attribute equal to `submit` is clicked, in which case, not only the`<input>` elements
    are sent, but also the name of the button that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that any`<input>` element that has to be sent to the server should have
    a `name` attribute. Omitting the `name` attribute will cause it to be missed out.`<input>`
    elements with `type` equal to `hidden` are sent as well if they have a `name`
    attribute. Hidden`<input>` elements are not displayed, but do play an important
    role in keeping essential information associated with a form together.
  prefs: []
  type: TYPE_NORMAL
- en: The first hidden`<input>` element in the form stores the start index of the
    items currently displayed in the table. By adding it as a hidden element, we can
    calculate which items to show when we take action when the **Next** or **Previous**
    button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: We also want to remember if and how the items are sorted. Therefore, we include
    a number of hidden input elements with a `name` attribute equal to `sortorder`,
    each having a value consisting of a column name and a sort direction separated
    by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: When a form is submitted, input elements with the same name are added in order
    as arguments to the `action` URL and CherryPy will recognize this pattern and
    convert them to a list of values. In this example, the `index()` method of the
    `Browse` class receives this list as its `sortorder` argument. Any `pattern` values
    are present as hidden`<input>` elements as well and processed in an identical
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The form also contains an `info` class`<p>` element, that contains information
    on the number of items and the items actually shown on the current page. The final
    part of the form is a collection of submit buttons.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `index()` method may be called with no arguments at all or with any or all
    contents of the form it displays. If the client-side JavaScript code wants to
    call it asynchronously while preventing the browser from caching it, it may even
    pass an `_` (underscore) argument with a random value, which will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the arguments are relevant and checked for sanity before being acted
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: We want the `sortorder` variable to contain a list of tuples, each consisting
    of a column name and a sort direction, but the values of the input elements are
    simply interpreted as strings by CherryPy, so we have to convert this list of
    strings to a list of tuples by splitting those strings on the comma separator.
    We neither check for the validity of the column names, nor for that of the sort
    directions because that will be done by the code doing the actual work.
  prefs: []
  type: TYPE_NORMAL
- en: The `pattern` variable is treated in a similar way, but because we may want
    to filter on values containing commas, we cannot simply use the `split()` method
    here, but have to pass it a limit of 1 to restrict its splitting to the first
    comma it encounters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we pass the `sortorder` and `pattern` variables to the `listids()` class
    method of the entity we stored with this `Browse` instance. It will return a list
    of IDs of instances that match the `pattern` criteria (or all instances if no
    patterns are specified) sorted in the correct order. Note that since the number
    of instances might be huge, we do not use the `list()` method here because converting
    all IDs to entity instances at once might render the application unresponsive.
    We will just convert those IDs to instances that we will actually show on the
    page, based on the start and page variables.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the new start index, we will have to check if we act upon one of
    the paging buttons (highlighted) and add or subtract a page length if we are acting
    on a click on the **Next** or **Previous** button. We set the start index to 0
    if the **First** button was clicked. If the **Last** button was clicked, we set
    the start index to the number of items minus the length of the page. If any of
    these calculations result in a start index that is less than zero, we set it to
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to produce the actual output, yielding one line at a time,
    beginning with the`<table>` element. Our table consists of a head and a body,
    the head consisting of a single row of`<th>` elements, each containing either
    the display name of the column we are showing if it represents an attribute of
    the entity, or the name of the class if it represents a related entity. Any sort
    order associated with this column is represented in its `class` attribute, so
    we may use CSS to make this visible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To display the rows in the body of the table, we convert the relevant IDs in
    the selection to actual entities (highlighted) and generate`<td>` elements for
    each attribute. If the column refers to related entities, their primary attributes
    are displayed, each related entity encapsulated in its own`<span>` element. The
    latter will enable us to associate relevant actions with each individual item
    shown, for example, displaying it in full when it is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The final long list of `yield` statements is used to produce the form with its
    many hidden input elements, each recording the arguments that were passed to the
    `index()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bulk of the activity when browsing through lists in a typical application
    is paging forward and backward. If we would need to retrieve the full list of
    entities each time we forward a single page, the application might feel sluggish
    if the list was huge or the sorting and filtering was complicated. It might therefore
    be sensible to implement some sort of caching scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things to consider though:'
  prefs: []
  type: TYPE_NORMAL
- en: Our CherryPy applications are multithreading, so we should be aware of that,
    especially when storing things in a cache, as we don't want threads to trash the
    shared cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to devise some scheme to limit the number of cached items as resources
    are limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must overcome the limitations of the statelessness of the HTTP protocol:
    each time the client issues a request. This request should contain all necessary
    information to determine if we have something cached for him available and of
    course we have to understand that each request may be served by a different thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These requirements can be satisfied if we change the line in the `index()`
    that retrieves the matching IDs into the following few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/browse.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because we will store a unique `cacheid` in a hidden`<input>` element, it will
    be passed as an argument when the form is submitted. We use this `cachid` together
    with the `sortorder` and `pattern` arguments to check whether a previously retrieved
    list of IDs is present in the cache with the `iscached()` method. Passing the
    `sortorder` and `pattern` arguments will enable the `iscached()` method to determine
    if these are changed and invalidate the cache entry.
  prefs: []
  type: TYPE_NORMAL
- en: '`iscached()` will return the `cacheid` if it exists in the cache or `None`
    if it doesn''t. `iscached()` will also return `None` if the `cacheid` does exist
    but the `sortorder` or `pattern` arguments were changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check if the `cacheid` is `None`. This may seem redundant, but if `index()`
    was called for the first time (without arguments, that is) none of the submit
    button arguments would be present and we wouldn't have checked the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is intended: if we would, at a later point, revisit this list, we would
    want a fresh set of items, not some old cached ones. After all, the contents of
    the database might have changed.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `cacheid` is `None` we retrieve a fresh list of IDs and store it in the
    cache together with the `sortorder` and `pattern` arguments. The `storeincache()`
    method will return a freshly minted `cacheid` for us to store in the hidden`<input>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: If the `cacheid` was not `None`, we use the `getfromcache()` method to retrieve
    the list of IDs from the cache. We check the returned value because between our
    checking for the existence of the key in the cache and retrieving the associated
    data, the cache might have been purged, in which case, we still call the `listids()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the `iscached(), getfromcache()`, and `storeincache()`
    method takes care of all the thread safety issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All methods use the `chash()` method to create a unique key from the `cacheid`
    and the `sortorder` and `pattern` arguments. `iscached()` waits until it acquires
    a lock to check if this unique value is present in the cache. If it is, it updates
    the associated value, a tuple consisting of a timestamp and a list of IDs. By
    updating this timestamp here, we reduce the chance that this item is purged from
    the cache between the check for existence and the actual retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: The `getfromcache()` method creates a unique key with the `chash()` method in
    the same way `iscached()` did and waits to acquire the lock before it uses the
    key to retrieve the value from the cache. If this fails, a `KeyError` will be
    raised that will be caught, causing the `None` value to be returned as that was
    what the IDs variable was initialized to.
  prefs: []
  type: TYPE_NORMAL
- en: The `storeincache()` method first creates a new `cacheid` using one of the `uuid()`
    functions from Python's `uuid` module, essentially creating a random string of
    hexadecimal characters. Together with the `sortorder` and `pattern` arguments,
    this new `cacheid` is used to generate a unique key.
  prefs: []
  type: TYPE_NORMAL
- en: Before we store the list of IDs in the cache, we check whether there is any
    space left by comparing the number of keys in the cache to the maximum length
    we are prepared to accept. If there isn't any room left, we make room by calling
    the `cleancache()` method that will remove any entries that are too old. We then
    store the IDs together with a time stamp after acquiring a lock and return the
    `cacheid` just generated.
  prefs: []
  type: TYPE_NORMAL
- en: The final cog in our caching machinery is the `cleancache()` method. After requiring
    a lock, a reverse map is built, mapping timestamps to keys. If this map holds
    any items, we use it to locate any key that is older than an hour. Those are deleted
    after acquiring a lock.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The whole business with acquiring a lock and releasing it as quick as possible
    instead of acquiring the lock and doing all the cache-related business in one
    go ensures that other threads accessing the cache do not have to wait very long,
    which keeps the whole application responsive.
  prefs: []
  type: TYPE_NORMAL
- en: If the age of an entry is less than an hour, we keep notes to see which of the
    remaining ones is the oldest to remove that one at the end. This way, we ensure
    that we always retire at least one entry, even if there aren't any really old
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: The books application revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that much versatile code available, constructing a new lean and mean version
    of our books application becomes very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action creating a books application, take two
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Run the code in `books2.py` and point your web browser to [http://localhost:8080](http://localhost:8080).
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in (a default username/password combination of admin/admin will
    be present), you will be presented with a list of entities to browse (books and
    authors) and after clicking on **Books**, a screen will present itself that closely
    resembles the general Browse application (the page still has a Spartan look because
    no CSS is added at this point):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action creating a books application, take two](img/3647_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thanks to some JavaScript goodness, our browse screen is embedded in the page
    instead of functioning standalone, yet all functionality is retained, including
    skipping forward and backward as well as sorting. New books or authors may be
    added by clicking the **Add new** button.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we take a look at the code in `books2.py`, we see that its main part consists
    of definitions of entities, relations, and specific `Browse` entities that are
    combined together to form a CherryPy application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/books2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After importing the modules we need, we define `User, Book`, and `Author` entities
    and an `OwnerShip` class, to define the relation between a book and a user. Likewise,
    we define a `Writer` class that defines the relation between a book and its author(s).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create an instance of a `LogonDB` class (highlighted) that
    will be used in many parts of our CherryPy application to verify that the user
    is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the CherryPy application consists of two `Browse` classes, one for
    books and one for authors. Each class has display, edit, and add class variables
    that point to further branches of our application that are served by `Display`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: The `Root` class we define ties all of this together. It refers to the `LogonDb`
    instance created earlier in its `logon` class variable, and its `books` and `authors`
    class variables point to the previously defined `Browse` instances. It also defines
    an `index()` method that merely presents a logon screen if the user is not yet
    authenticated and if he/she is, redirects the user to the entities page. The `entities()`
    method which serves this page makes sure there is a corresponding user in the
    database (highlighted) and presents a base page consisting of a navigation `div`
    and a content `div` that will be filled when one of the links in the navigation
    section is clicked, and some JavaScript to tie everything together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we examine the JavaScript, it might be good to take a look at the illustration
    to see how the application tree looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Path | Method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | `Root.index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/entities` | `Root.entities()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/logon` | `LogonDB.index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/books` | `BooksBrowser.index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/add` | `Display().index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/edit` | `Display().index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/display` | `Display().index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/authors` | `AuthorBrowser.index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/add` | `Display().index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/edit` | `Display().index()` |'
  prefs: []
  type: TYPE_TB
- en: '| `/display` | `Display().index()` |'
  prefs: []
  type: TYPE_TB
- en: (Note that the `edit, add`, and `display` branches are each serviced by a different
    instance of `Display)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we saw that the `Browse` class we created was able to function standalone:
    clicking on any of the buttons referred to the same URL that served up the form
    in the first place. This setup makes it possible to use different `Browse` instances
    in different parts of an application tree, but here we want to replace a part
    of a page with the form produced by the `Browse` instance using an AJAX call.
    The problem then is that submitting a form without an `action` attribute will
    result in a request to the current URL, that is, the one referring to the page
    the form is embedded in, not the one that produces the form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can use jQuery to solve this problem by altering the `action`
    attributes of the freshly loaded forms to point to the URL that served those forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter7/books2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is accomplished by adding a click event handler to the links in the navigation
    area. That will not only prevent the default action but load the HTML produced
    by the URL referred to by the `href` attribute and pass a callback function that
    will alter the action attributes of any freshly loaded`<form>` elements (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: The `shiftforms()` function first prepends the original `href` contents to the
    `action` attributes and then binds a click handler to each button or input element
    with a `type` attribute equal to submit.
  prefs: []
  type: TYPE_NORMAL
- en: It would not be sufficient to add a submit handler to the form, because we don't
    want to let the`<form>` perform its default action. When a form is submitted,
    the contents of the page are replaced and this is not what we want. Instead, we
    want to replace the contents of the content `div` so we have to `load()` the URL
    from the form's `action` attribute ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that we have to serialize the contents of the form to add as
    parameters to this URL, but jQuery's `serialize()` function will not serialize
    submit buttons. We, therefore, end up with adding a click handler to submit buttons
    in order to be able to determine the submit button that was clicked, so we can
    construct a complete list of parameters, including the name and value of the submit
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took a critical look at the framework we developed so far, and made improvements
    to the framework to make it more versatile and simpler to use for a developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do away with explicit database and thread initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to wield the awesome power of Python metaclasses to synchronize the creation
    of Python classes and their corresponding database tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use those same metaclasses to alter the definitions of existing classes
    to create a much more intuitive interface when dealing with relations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a `Browse` class to navigate through large collections of entities
    in an efficient way using caches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to rewrite the books application in a much simpler way with this reworked
    framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have still glossed over several issues, including how to display and edit
    instances. In the last three chapters, we will develop a Customer Relationship
    Management application and fill in the final bits, including controlling how to
    restrict some actions to specific persons and how to allow for end user customization
    of the application.
  prefs: []
  type: TYPE_NORMAL
