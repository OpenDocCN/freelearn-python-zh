- en: Chapter 6. The Observer Pattern – Keeping Objects in the Know
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。观察者模式——保持对象知情
- en: In the previous chapter, we started with a brief introduction to Proxy and went
    ahead to discuss the Proxy design pattern. We understood the concept of the Proxy
    pattern with a UML diagram and also learned how it's applied in the real world
    with the help of Python implementations. You learned about the ups and downs of
    the Proxy pattern with the FAQ section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从对代理的简要介绍开始，然后讨论了代理设计模式。我们通过UML图理解了代理模式的概念，并学习了如何借助Python实现将其应用于现实世界。你在FAQ部分学习了代理模式的优缺点。
- en: In this chapter, we will talk about the third type of design pattern—the behavioral
    design pattern. We will be introduced to the Observer design pattern, which falls
    under the hood of Behavioral patterns. We will discuss how the Observer design
    pattern is used in software application development. We will work with a sample
    use case and implement it in Python v3.5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论第三种设计模式——行为设计模式。我们将介绍观察者设计模式，它属于行为模式范畴。我们将讨论观察者设计模式在软件开发中的应用。我们将使用一个示例用例并在Python
    3.5中实现它。
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下主题：
- en: An introduction to behavioral design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式的介绍
- en: The Observer pattern and its UML diagram
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式及其UML图
- en: A real-world use case with the Python v3.5 code implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Python 3.5代码实现的现实世界用例
- en: The power of loose coupling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合的力量
- en: Frequently asked questions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: At the end of the chapter, we will summarize the entire discussion—consider
    this a takeaway.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将总结整个讨论——请将此视为要点。
- en: Introducing Behavioral patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍行为模式
- en: In the previous chapters of the book, you learned about creational patterns
    (Singleton) and structural patterns (Façade). In this section, we will get a brief
    idea of Behavioral patterns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，你学习了创建模式（单例）和结构模式（外观）。在本节中，我们将简要了解行为模式。
- en: Creational patterns work on the basis of how objects can be created. They isolate
    the details of object creation. Code is independent of the type of object to be
    created. Structural patterns design the structure of objects and classes so that
    they can work together to achieve larger results. Their main focus is on simplifying
    the structure and identifying relationships between classes and objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模式基于对象如何被创建。它们隔离了对象创建的细节。代码与要创建的对象类型无关。结构模式设计对象和类的结构，以便它们可以一起工作以实现更大的结果。它们的主要重点是简化结构并识别类与对象之间的关系。
- en: Behavioral patterns, as the name suggests, focus on the responsibilities that
    an object has. They deal with the interaction among objects to achieve larger
    functionality. Behavioral patterns suggest that while the objects should be able
    to interact with each other, they should still be loosely coupled. We will learn
    about the principle of loose coupling later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，行为模式关注对象所具有的职责。它们处理对象之间的交互以实现更大的功能。行为模式建议，虽然对象应该能够相互交互，但它们仍然应该是松散耦合的。我们将在本章后面学习松散耦合的原则。
- en: The Observer design pattern is one of the simplest Behavioral patterns. So,
    let's gear up and understand more about them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式是行为模式中最简单的一种。因此，让我们做好准备，更深入地了解它们。
- en: Understanding the Observer design pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解观察者设计模式
- en: In the Observer design pattern, an object (Subject) maintains a list of dependents
    (Observers) so that the Subject can notify all the Observers about the changes
    that it undergoes using any of the methods defined by the Observer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者设计模式中，一个对象（主题）维护一个依赖者（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所经历的变化。
- en: In the world of distributed applications, multiple services interact with each
    other to perform a larger operation that a user wants to achieve. Services can
    perform multiple operations, but the operation they perform is directly or heavily
    dependent on the state of the objects of the service that it interacts with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式应用的世界中，多个服务相互交互以执行用户想要实现的大操作。服务可以执行多个操作，但它们执行的操作直接或严重依赖于与之交互的服务对象的状态。
- en: Consider a use case for user registration where the user service is responsible
    for user operations on the website. Let's say that we have another service called
    e-mail service that observes the state of the user and sends e-mails to the user.
    For example, if the user has just signed up, the user service will call a method
    of the e-mail service that will send an e-mail to the user for account verification.
    If the account is verified but has fewer credits, the e-mail service will monitor
    the user service and send an e-mail alert for low credits to the user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用户注册的使用场景，其中用户服务负责网站上的用户操作。假设我们还有一个名为电子邮件服务的其他服务，该服务观察用户状态并向用户发送电子邮件。例如，如果用户刚刚注册，用户服务将调用电子邮件服务的一个方法，向用户发送账户验证的电子邮件。如果账户已验证但信用额度较少，电子邮件服务将监控用户服务并向用户发送低信用额的电子邮件警报。
- en: Thus, if there's a core service in the application on which many other services
    are dependent, the core service becomes the Subject that has to be observed/monitored
    by the Observer for changes. The Observer should, in turn, make changes to the
    state of its own objects or take certain actions based on the changes that happen
    in the Subject. The above scenario, where the dependent service monitor's state
    changes in the core service, presents a classical case for the Observer design
    pattern.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果应用程序中有一个核心服务，许多其他服务都依赖于它，那么这个核心服务就成为了需要被观察者观察/监控以进行变更的主题。观察者反过来应该根据主题发生的变更对其自身对象的状态进行更改或采取某些行动。上述场景，即依赖服务监控核心服务状态变更，是观察者设计模式的经典案例。
- en: In the case of a broadcast or publish/subscribe system, you'll find the usage
    of the Observer design pattern. Consider the example of a blog. Let's suppose
    that you're a tech enthusiast who loves to read about the latest articles on Python
    on this blog. What will you do? You subscribe to the blog. Like you, there would
    be multiple subscribers that are also registered with the blog. So, whenever there
    is a new blog, you get notified, or if there is a change on the published blog,
    you are also made aware of the edits. The way in which you're notified of the
    change can be an e-mail. Now if you apply this scenario to the Observer pattern,
    the blog is the Subject that maintains the list of subscribers or Observers. So
    when a new entry is added to the blog, all Observers are notified via e-mail or
    any other notification mechanism as defined by the Observer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在广播或发布/订阅系统中，你会找到观察者设计模式的使用。考虑一个博客的例子。假设你是一个技术爱好者，喜欢阅读这个博客上关于Python的最新文章。你会怎么做？你会订阅这个博客。像你一样，还有多个订阅者也注册了这个博客。所以，每当有新的博客文章时，你会收到通知，或者如果已发布的博客有变更，你也会被告知编辑。你收到变更通知的方式可以是电子邮件。现在，如果你将这个场景应用到观察者模式中，博客就是维护订阅者或观察者列表的主题。所以，当博客中添加新条目时，所有观察者都会通过电子邮件或其他通知机制（如观察者定义的）收到通知。
- en: 'The main intentions of the Observer pattern are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的主要意图如下：
- en: It defines a one-to-many dependency between objects so that any change in one
    object will be notified to the other dependent objects automatically
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了对象之间的一对多依赖关系，以便任何对象的变更都会自动通知其他依赖对象
- en: It encapsulates the core component of the Subject
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它封装了主题的核心组件
- en: 'The Observer pattern is used in the following multiple scenarios:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式在以下多个场景中使用：
- en: Implementation of the Event service in distributed systems
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统中事件服务的实现
- en: A framework for a news agency
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新闻机构的框架
- en: The stock market also represents a great case for the Observer pattern
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股市也是观察者模式的一个很好的案例
- en: 'The following Python code implements the Observer design pattern:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码实现了观察者设计模式：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![Understanding the Observer design pattern](img/00020.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![理解观察者设计模式](img/00020.jpeg)'
- en: A UML class diagram for the Observer pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式的UML类图
- en: Let's now understand more about the Observer pattern with the help of the following
    UML diagram.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们借助以下UML图来更深入地了解观察者模式。
- en: 'As we discussed in the previous paragraph, the Observer pattern has two main
    actors: the `Subject` and `Observer`. Let''s put these in a UML diagram and see
    how the classes look:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一段所述，观察者模式有两个主要角色：`Subject`和`Observer`。让我们将这些放入UML图中，看看类是如何表现的：
- en: '![A UML class diagram for the Observer pattern](img/00021.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式的UML类图](img/00021.jpeg)'
- en: 'As we look at the UML diagram, you''ll realize that there are three main participants
    in this pattern:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 UML 图时，你会意识到这个模式中有三个主要参与者：
- en: '`Subject`: The `Subject` class is aware of the `Observer`. The `Subject` class
    has methods such as `register()` and `deregister()` that are used by `Observers`
    to register themselves with the `Subject` class. A `Subject`, thus can handle
    multiple `Observers`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject`：`Subject` 类了解 `Observer`。`Subject` 类具有 `register()` 和 `deregister()`
    等方法，这些方法由 `Observers` 用于将自己注册到 `Subject` 类。因此，`Subject` 可以处理多个 `Observers`。'
- en: '`Observer`: It defines an interface for objects that are observing the Subject.
    It defines methods that need to be implemented by the `Observer` to get notified
    of changes in the Subject.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`：它定义了一个接口，供观察 `Subject` 的对象使用。它定义了 `Observer` 需要实现的方法，以便在 `Subject`
    发生变化时得到通知。'
- en: '`ConcreteObserver`: It stores the state that should be consistent with that
    of the `Subject''s` state. It implements the `Observer` interface to keep the
    state consistent with changes in the Subject.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteObserver`：它存储应与 `Subject` 的状态一致的状态。它通过实现 `Observer` 接口来保持状态与 `Subject`
    的变化一致。'
- en: The flow is straightforward. `ConcreteObservers` register themselves with the
    Subject by implementing the interface provided by the `Observer`. Whenever there
    is a change in state, the Subject notifies all `ConcreteObservers` with the notify
    method provided by the `Observers`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 流程很简单。`ConcreteObservers` 通过实现 `Observer` 提供的接口来将自己注册到主体。每当状态发生变化时，主体通过 `Observers`
    提供的 `notify` 方法通知所有 `ConcreteObservers`。
- en: The Observer pattern in the real world
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际世界中的观察者模式
- en: We will take up a news agency case to demonstrate the real-world scenario for
    the Observer pattern. News agencies typically gather news from various locations
    and publish them to the subscribers. Let's look at the design considerations for
    this use case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用一个新闻机构的案例来展示观察者模式在实际世界中的应用场景。新闻机构通常从各个地点收集新闻，并将其发布给订阅者。让我们看看这个用例的设计考虑因素。
- en: With information being sent/received in real time, a news agency should be able
    to publish the news as soon as possible to its subscribers. Additionally, because
    of the advancements in the technology industry, it's not just the newspapers,
    but also the subscribers that can be of different types such as an e-mail, mobile,
    SMS, or voice call. We should also be able to add any other type of subscriber
    in the future and budgeting for any new technology.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信息是实时发送/接收的，新闻机构应该能够尽快将其新闻发布给订阅者。此外，由于技术行业的进步，不仅报纸，订阅者也可以是不同类型，如电子邮件、手机、短信或语音通话。我们还应该能够添加任何其他类型的订阅者，并为任何新技术预留预算。
- en: 'Let''s develop an application in Python v3.5 and implement the preceding use
    case. We will start with the Subject, which is the news publisher:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 3.5 中开发一个应用程序并实现前面的用例。我们将从主体，即新闻发布者开始：
- en: Subject behavior is represented by the `NewsPublisher` class
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体行为由 `NewsPublisher` 类表示。
- en: '`NewsPublisher` provides you with an interface so that subscribers can work
    with it'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewsPublisher` 提供了一个接口，使订阅者可以与之交互。'
- en: The `attach()` method is used by the `Observer` to register with `NewsPublisher`
    and the `detach()` method helps in deregistering the `Observer`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attach()` 方法由 `Observer` 用于注册到 `NewsPublisher`，而 `detach()` 方法有助于注销 `Observer`。'
- en: The `subscriber()` method returns the list of all the subscribers that have
    already registered with the `Subject`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber()` 方法返回已经注册到 `Subject` 的所有订阅者的列表。'
- en: The `notifySubscriber()` method iterates over all the subscribers that have
    registered with `NewsPublisher`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notifySubscriber()` 方法遍历所有已注册到 `NewsPublisher` 的订阅者。'
- en: The `addNews()` method is used by the publisher to create new news and `getNews()`
    is used to return the latest news, which is then notified to the `Observer`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者使用 `addNews()` 方法创建新的新闻，而 `getNews()` 用于返回最新的新闻，然后通过 `Observer` 通知。
- en: 'Let''s first look at the `NewsPublisher` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `NewsPublisher` 类：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s talk about the `Observer` interface now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈 `Observer` 接口：
- en: In this example, `Subscriber` represents the `Observer`. It is an abstract base
    class and represents any other `ConcreteObserver`.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`Subscriber` 代表 `Observer`。它是一个抽象基类，代表任何其他 `ConcreteObserver`。
- en: '`Subscriber` has the `update()` method that needs to be implemented by `ConcreteObservers`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber` 有一个 `update()` 方法，需要由 `ConcreteObservers` 实现。'
- en: The `update()` method is implemented by `ConcreteObserver` so that they get
    notified by the `Subject` (`NewsPublishers`) about any news getting published.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update()` 方法由 `ConcreteObserver` 实现，以便它们能够从 `Subject` (`NewsPublishers`) 接收任何新闻发布的通知。'
- en: 'Lets us now look at the code for the `Subscriber` abstract class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `Subscriber` 抽象类的代码：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also developed certain classes that represent `ConcreteObserver`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还开发了一些代表 `ConcreteObserver` 的类：
- en: 'In this case, we have two main observers: `EmailSubscriber` and `SMSSubscriber`
    that implement the subscriber interface'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个主要的观察者：实现了订阅者接口的 `EmailSubscriber` 和 `SMSSubscriber`。
- en: In addition to these two, we have another Observer, `AnyOtherObserver`, that
    demonstrates the loose coupling of `Observers` with the `Subject`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了这两个之外，我们还有一个名为 `AnyOtherObserver` 的其他观察者，它展示了 `Observers` 与 `Subject` 的松耦合。
- en: The `__init__()` method of each of these `ConcreteObservers` registers them
    with `NewsPublisher` with the `attach()` method
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `ConcreteObserver` 的 `__init__()` 方法使用 `attach()` 方法将其注册到 `NewsPublisher`。
- en: The `update()` method of `ConcreteObserver` is used internally by `NewsPublisher`
    to notify about the news additions
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteObserver` 的 `update()` 方法由 `NewsPublisher` 内部使用来通知新闻的增加。'
- en: 'Here''s how the `SMSSubscriber` class is implemented:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现 `SMSSubscriber` 类的示例：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that all the required subscribers have been implemented, lets look at the
    `NewsPublisher` and `SMSSubscribers` class in action:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有必需的订阅者都已实现，让我们看看 `NewsPublisher` 和 `SMSSubscribers` 类的实际应用：
- en: The client creates an object for `NewsPublisher` that is used by `ConcreteObservers`
    for various operations.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端创建一个 `NewsPublisher` 对象，该对象被 `ConcreteObservers` 用于各种操作。
- en: '`SMSSubscriber`, `EmailSubscriber`, and `AnyOtherSubscriber` classes are initialized
    with publisher objects.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SMSSubscriber`、`EmailSubscriber` 和 `AnyOtherSubscriber` 类使用发布者对象进行初始化。'
- en: In Python, when we create objects, the `__init__()` method gets called. In the
    `ConcreteObserver` class, the `__init__()` method internally uses the `attach()`
    method of `NewsPublisher` to register itself for news updates.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 中，当我们创建对象时，会调用 `__init__()` 方法。在 `ConcreteObserver` 类中，`__init__()`
    方法内部使用 `NewsPublisher` 的 `attach()` 方法来注册自己以接收新闻更新。
- en: We then print the list of all the subscribers (`ConcreteObservers`) that got
    registered with the `Subject`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们打印出所有已注册到 `Subject` 的订阅者（`ConcreteObservers`）的列表。
- en: The object of `NewsPublisher (news_publisher)` is then used to create new news
    with the `addNews()` method.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `addNews()` 方法通过 `NewsPublisher`（news_publisher）对象创建新的新闻。
- en: The `notifySubscribers()` method of `NewsPublisher` is used to notify all subscribers
    of the news addition. The `notifySubscribers()` method internally calls the `update()`
    method implemented by `ConcreteObservers` so that they get the latest news.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewsPublisher` 的 `notifySubscribers()` 方法用于通知所有订阅者新闻的增加。`notifySubscribers()`
    方法内部调用 `ConcreteObserver` 实现的 `update()` 方法，以便它们获取最新的新闻。'
- en: '`NewsPublisher` also has the `detach()` method that removes the subscriber
    from the list of registered subscribers.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewsPublisher` 还有一个 `detach()` 方法，用于从已注册订阅者列表中删除订阅者。'
- en: 'The following code implementation represents the interactions between the `Subject`
    and `Observers`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现表示了 `Subject` 和 `Observers` 之间的交互：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![The Observer pattern in the real world](img/00022.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界中的观察者模式](img/00022.jpeg)'
- en: The Observer pattern methods
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式的方法
- en: There are two different ways of notifying the `Observer` of the changes that
    happen in the `Subject`. They can be classified as push or pull models.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通知 `Observer` 关于 `Subject` 中发生的变化有两种不同的方式。它们可以被归类为推送或拉模型。
- en: The pull model
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉模型
- en: 'In the pull model, `Observers` play an active role as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉模型中，`Observers` 扮演着以下积极的角色：
- en: The `Subject` broadcasts to all the registered `Observers` when there is any
    change
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有任何变化时，`Subject` 向所有已注册的 `Observers` 广播。
- en: The `Observer` is responsible for getting the changes or pulling data from the
    subscriber when there is an amendment
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有变更时，`Observer` 负责获取变更或从订阅者那里拉取数据。
- en: The pull model is ineffective as it involves two steps—the first step where
    the `Subject` notifies the `Observer` and the second step where the `Observer`
    pulls the required data from the Subject
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉模型是无效的，因为它涉及两个步骤——第一步是 `Subject` 通知 `Observer`，第二步是 `Observer` 从 `Subject`
    中拉取所需的数据。
- en: The push model
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送模型
- en: 'In the push model, the `Subject` is the one that plays a dominant role as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送模型中，`Subject` 扮演着主导角色如下：
- en: Unlike the pull model, the changes are pushed by the `Subject` to the `Observer`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与拉模型不同，更改是由`Subject`推送到`Observer`的。
- en: In this model, the Subject can send detailed information to the `Observer` (even
    though it may not be needed). This can result in sluggish response times when
    a large amount of data is sent by the `Subject` but is never actually used by
    the `Observer`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个模型中，`Subject`可以向`Observer`发送详细的信息（即使可能不需要）。当`Subject`发送大量数据时，这可能会导致响应时间缓慢，但这些数据实际上从未被`Observer`使用。
- en: Only the required data is sent from the `Subject` so that the performance is
    better.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只从`Subject`发送所需的数据，从而提高性能。
- en: Loose coupling and the Observer pattern
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合与观察者模式
- en: Loose coupling is an important design principle that should be used in software
    applications. The main purpose of loose coupling is to strive for loosely-coupled
    designs between objects that interact with each other. Coupling refers to the
    degree of knowledge that one object has about the other object that it interacts
    with.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合是一个重要的设计原则，应该在软件应用中使用。松散耦合的主要目的是努力在相互交互的对象之间实现松散耦合的设计。耦合指的是一个对象对其交互对象所具有的知识程度。
- en: Loosely-coupled designs allow us to build flexible object-oriented systems that
    can handle changes because they reduce the dependency between multiple objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合的设计使我们能够构建灵活的面向对象系统，可以处理变化，因为它们减少了多个对象之间的依赖性。
- en: 'The loose coupling architecture ensures following features:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合架构确保以下特性：
- en: It reduces the risk that a change made within one element might create an unanticipated
    impact on the other elements
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它降低了在一个元素内部做出的更改可能对其他元素产生未预期影响的风险
- en: It simplifies testing, maintenance, and troubleshooting problems
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简化了测试、维护和故障排除问题
- en: The system can be easily broken down into definable elements
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统可以轻松地分解为可定义的元素
- en: 'The Observer pattern provides you with an object design where the `Subject`
    and `Observer` are loosely coupled. The following points will explain this better:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式为你提供了一个对象设计，其中`Subject`和`Observer`是松散耦合的。以下要点将更好地解释这一点：
- en: The only thing that the `Subject` knows about an `Observer` is that it implements
    a certain interface. It need not know the `ConcreteObserver` class.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject`对`Observer`的唯一了解是它实现了一个特定的接口。它不需要知道`ConcreteObserver`类。'
- en: Any new `Observer` can be added at any point in time (as we saw in the sample
    example earlier in this chapter).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何新的`Observer`都可以在任何时候添加（正如我们在本章前面的示例中所看到的）。
- en: The `Subject` need not be modified at all to add any new `Observer`. In the
    example, we saw that `AnyOtherObserver` can be added/removed without any changes
    in the `Subject`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加任何新的`Observer`不需要修改`Subject`。在示例中，我们看到`AnyOtherObserver`可以添加/删除，而无需对`Subject`进行任何更改。
- en: Subjects or `Observers` are not tied up and can be used independently of each
    other. So the `Observer` can be reused anywhere else, if needed.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject`或`Observer`之间没有绑定，可以独立使用。因此，如果需要，`Observer`可以在任何其他地方重用。'
- en: Changes in the `Subject` or `Observer` will not affect each other. As both are
    independent or loosely coupled, they are free to make their own changes.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subject`或`Observer`的变化不会相互影响。由于两者都是独立的或松散耦合的，它们可以自由地进行自己的更改。'
- en: The Observer pattern – advantages and disadvantages
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式 - 优点和缺点
- en: 'The Observer pattern provides you with the following advantages:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式为你提供了以下优点：
- en: It supports the principle of loose coupling between objects that interact with
    each other
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持对象之间松散耦合的原则
- en: It allows sending data to other objects effectively without any change in the
    `Subject` or `Observer` classes
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许在`Subject`或`Observer`类不发生变化的情况下，有效地将数据发送到其他对象
- en: '`Observers` can be added/removed at any point in time'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observers`可以在任何时间添加/删除'
- en: 'The following are the disadvantages of the Observer pattern:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列举了观察者模式的缺点：
- en: The Observer interface has to be implemented by `ConcreteObserver`, which involves
    inheritance. There is no option for composition, as the Observer interface can
    be instantiated.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteObserver`必须实现观察者接口，这涉及到继承。没有组合的选项，因为观察者接口可以被实例化。'
- en: If not correctly implemented, the `Observer` can add complexity and lead to
    inadvertent performance issues.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有正确实现，`Observer`可能会增加复杂性并导致意外的性能问题。
- en: In software application, notifications can, at times, be undependable and result
    in race conditions or inconsistency.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在软件应用中，通知有时可能不可靠，导致竞争条件或不一致性。
- en: Frequently asked questions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q1\. Can there be many `Subjects` and `Observers`?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 是否可以有多个主题（Subjects）和观察者（Observers）？
- en: 'A: There can be a case for a software application to have multiple `Subjects`
    and Observers. For this to work, `Observers` need to be notified of changes in
    the `Subjects` and which `Subject` underwent a change.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: A：对于软件应用来说，存在一个情况是拥有多个主题（Subjects）和观察者。为了使这可行，观察者需要被通知主题（Subjects）的变化以及哪个主题发生了变化。
- en: Q2\. Who is responsible for triggering the update?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 谁负责触发更新？
- en: 'A: As you learned earlier, the Observer pattern can work in both push and pull
    models. Typically, the Subject triggers the update method when there are changes,
    but sometimes based on the application need, the **Observer** can also trigger
    notifications. However, care needs to be taken that the frequency should not be
    too high, otherwise it can lead to performance degradation, especially when the
    updates to the Subject are less frequent.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: A：正如你之前所学的，观察者模式可以在推送和拉取模型中工作。通常，当有变化时，主题（Subject）会触发更新方法，但有时根据应用需求，**观察者（Observer）**也可以触发通知。然而，需要注意频率不应过高，否则可能会导致性能下降，尤其是在主题更新频率较低时。
- en: Q3\. Can the `Subject` or `Observer` be used for access for any other use case?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 主题（Subject）或观察者能否用于其他用例的访问？
- en: 'A: Yes, that''s the power of loose coupling that is manifested in the Observer
    pattern. The `Subject`/`Observer` can both be independently used.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: A：是的，这就是观察者模式中体现的松耦合的力量。主题（Subject）/观察者都可以独立使用。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began the chapter by understanding the behavioral design patterns. We understood
    the basis of the Observer pattern and how it is effectively used in software architecture.
    We looked at how Observer design patterns are used to notify the `Observer` of
    the changes happening in the `Subject`. They manage the interaction between objects
    and manage one-to-many dependencies on the objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解行为设计模式开始本章。我们了解了观察者模式的基础以及它在软件架构中的有效应用。我们探讨了如何使用观察者设计模式来通知主题（Subject）的变化。它们管理对象之间的交互，并管理对象的一对多依赖关系。
- en: You also learned the pattern with a UML diagram and sample code implementation
    in Python v3.5.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了使用UML图和Python 3.5的示例代码实现该模式。
- en: 'Observer patterns are implemented in two different ways: push and pull models.
    You learned about each of these and discussed their implementation and performance
    impact.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式有两种不同的实现方式：推送和拉取模型。你学习了这些模式，并讨论了它们的实现和性能影响。
- en: We understood the principle of loose coupling in software design and how the
    Observer pattern leverages this principle in application development.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解了软件设计中的松耦合原则，以及观察者模式如何利用这一原则进行应用开发。
- en: We also covered a section on FAQs that would help you get more ideas about the
    pattern and its possible advantages/disadvantages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了一个关于常见问题解答（FAQs）的部分，这将帮助你获得更多关于该模式及其可能的优势/劣势的想法。
- en: At the end of this chapter, we're now geared up to learn more Behavioral patterns
    in the chapters to come.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们现在准备在接下来的章节中学习更多的行为模式。
