- en: Chapter 6. The Observer Pattern – Keeping Objects in the Know
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started with a brief introduction to Proxy and went
    ahead to discuss the Proxy design pattern. We understood the concept of the Proxy
    pattern with a UML diagram and also learned how it's applied in the real world
    with the help of Python implementations. You learned about the ups and downs of
    the Proxy pattern with the FAQ section.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about the third type of design pattern—the behavioral
    design pattern. We will be introduced to the Observer design pattern, which falls
    under the hood of Behavioral patterns. We will discuss how the Observer design
    pattern is used in software application development. We will work with a sample
    use case and implement it in Python v3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to behavioral design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern and its UML diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-world use case with the Python v3.5 code implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The power of loose coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the chapter, we will summarize the entire discussion—consider
    this a takeaway.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Behavioral patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters of the book, you learned about creational patterns
    (Singleton) and structural patterns (Façade). In this section, we will get a brief
    idea of Behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns work on the basis of how objects can be created. They isolate
    the details of object creation. Code is independent of the type of object to be
    created. Structural patterns design the structure of objects and classes so that
    they can work together to achieve larger results. Their main focus is on simplifying
    the structure and identifying relationships between classes and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns, as the name suggests, focus on the responsibilities that
    an object has. They deal with the interaction among objects to achieve larger
    functionality. Behavioral patterns suggest that while the objects should be able
    to interact with each other, they should still be loosely coupled. We will learn
    about the principle of loose coupling later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer design pattern is one of the simplest Behavioral patterns. So,
    let's gear up and understand more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Observer design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Observer design pattern, an object (Subject) maintains a list of dependents
    (Observers) so that the Subject can notify all the Observers about the changes
    that it undergoes using any of the methods defined by the Observer.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of distributed applications, multiple services interact with each
    other to perform a larger operation that a user wants to achieve. Services can
    perform multiple operations, but the operation they perform is directly or heavily
    dependent on the state of the objects of the service that it interacts with.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a use case for user registration where the user service is responsible
    for user operations on the website. Let's say that we have another service called
    e-mail service that observes the state of the user and sends e-mails to the user.
    For example, if the user has just signed up, the user service will call a method
    of the e-mail service that will send an e-mail to the user for account verification.
    If the account is verified but has fewer credits, the e-mail service will monitor
    the user service and send an e-mail alert for low credits to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if there's a core service in the application on which many other services
    are dependent, the core service becomes the Subject that has to be observed/monitored
    by the Observer for changes. The Observer should, in turn, make changes to the
    state of its own objects or take certain actions based on the changes that happen
    in the Subject. The above scenario, where the dependent service monitor's state
    changes in the core service, presents a classical case for the Observer design
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a broadcast or publish/subscribe system, you'll find the usage
    of the Observer design pattern. Consider the example of a blog. Let's suppose
    that you're a tech enthusiast who loves to read about the latest articles on Python
    on this blog. What will you do? You subscribe to the blog. Like you, there would
    be multiple subscribers that are also registered with the blog. So, whenever there
    is a new blog, you get notified, or if there is a change on the published blog,
    you are also made aware of the edits. The way in which you're notified of the
    change can be an e-mail. Now if you apply this scenario to the Observer pattern,
    the blog is the Subject that maintains the list of subscribers or Observers. So
    when a new entry is added to the blog, all Observers are notified via e-mail or
    any other notification mechanism as defined by the Observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main intentions of the Observer pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a one-to-many dependency between objects so that any change in one
    object will be notified to the other dependent objects automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It encapsulates the core component of the Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Observer pattern is used in the following multiple scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the Event service in distributed systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A framework for a news agency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The stock market also represents a great case for the Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following Python code implements the Observer design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Observer design pattern](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A UML class diagram for the Observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now understand more about the Observer pattern with the help of the following
    UML diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the previous paragraph, the Observer pattern has two main
    actors: the `Subject` and `Observer`. Let''s put these in a UML diagram and see
    how the classes look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A UML class diagram for the Observer pattern](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we look at the UML diagram, you''ll realize that there are three main participants
    in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subject`: The `Subject` class is aware of the `Observer`. The `Subject` class
    has methods such as `register()` and `deregister()` that are used by `Observers`
    to register themselves with the `Subject` class. A `Subject`, thus can handle
    multiple `Observers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observer`: It defines an interface for objects that are observing the Subject.
    It defines methods that need to be implemented by the `Observer` to get notified
    of changes in the Subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteObserver`: It stores the state that should be consistent with that
    of the `Subject''s` state. It implements the `Observer` interface to keep the
    state consistent with changes in the Subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flow is straightforward. `ConcreteObservers` register themselves with the
    Subject by implementing the interface provided by the `Observer`. Whenever there
    is a change in state, the Subject notifies all `ConcreteObservers` with the notify
    method provided by the `Observers`.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take up a news agency case to demonstrate the real-world scenario for
    the Observer pattern. News agencies typically gather news from various locations
    and publish them to the subscribers. Let's look at the design considerations for
    this use case.
  prefs: []
  type: TYPE_NORMAL
- en: With information being sent/received in real time, a news agency should be able
    to publish the news as soon as possible to its subscribers. Additionally, because
    of the advancements in the technology industry, it's not just the newspapers,
    but also the subscribers that can be of different types such as an e-mail, mobile,
    SMS, or voice call. We should also be able to add any other type of subscriber
    in the future and budgeting for any new technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s develop an application in Python v3.5 and implement the preceding use
    case. We will start with the Subject, which is the news publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: Subject behavior is represented by the `NewsPublisher` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewsPublisher` provides you with an interface so that subscribers can work
    with it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `attach()` method is used by the `Observer` to register with `NewsPublisher`
    and the `detach()` method helps in deregistering the `Observer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subscriber()` method returns the list of all the subscribers that have
    already registered with the `Subject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `notifySubscriber()` method iterates over all the subscribers that have
    registered with `NewsPublisher`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addNews()` method is used by the publisher to create new news and `getNews()`
    is used to return the latest news, which is then notified to the `Observer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first look at the `NewsPublisher` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk about the `Observer` interface now:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `Subscriber` represents the `Observer`. It is an abstract base
    class and represents any other `ConcreteObserver`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subscriber` has the `update()` method that needs to be implemented by `ConcreteObservers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update()` method is implemented by `ConcreteObserver` so that they get
    notified by the `Subject` (`NewsPublishers`) about any news getting published.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lets us now look at the code for the `Subscriber` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We also developed certain classes that represent `ConcreteObserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have two main observers: `EmailSubscriber` and `SMSSubscriber`
    that implement the subscriber interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these two, we have another Observer, `AnyOtherObserver`, that
    demonstrates the loose coupling of `Observers` with the `Subject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__()` method of each of these `ConcreteObservers` registers them
    with `NewsPublisher` with the `attach()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update()` method of `ConcreteObserver` is used internally by `NewsPublisher`
    to notify about the news additions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how the `SMSSubscriber` class is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the required subscribers have been implemented, lets look at the
    `NewsPublisher` and `SMSSubscribers` class in action:'
  prefs: []
  type: TYPE_NORMAL
- en: The client creates an object for `NewsPublisher` that is used by `ConcreteObservers`
    for various operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SMSSubscriber`, `EmailSubscriber`, and `AnyOtherSubscriber` classes are initialized
    with publisher objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, when we create objects, the `__init__()` method gets called. In the
    `ConcreteObserver` class, the `__init__()` method internally uses the `attach()`
    method of `NewsPublisher` to register itself for news updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then print the list of all the subscribers (`ConcreteObservers`) that got
    registered with the `Subject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object of `NewsPublisher (news_publisher)` is then used to create new news
    with the `addNews()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `notifySubscribers()` method of `NewsPublisher` is used to notify all subscribers
    of the news addition. The `notifySubscribers()` method internally calls the `update()`
    method implemented by `ConcreteObservers` so that they get the latest news.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewsPublisher` also has the `detach()` method that removes the subscriber
    from the list of registered subscribers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code implementation represents the interactions between the `Subject`
    and `Observers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Observer pattern in the real world](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Observer pattern methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two different ways of notifying the `Observer` of the changes that
    happen in the `Subject`. They can be classified as push or pull models.
  prefs: []
  type: TYPE_NORMAL
- en: The pull model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the pull model, `Observers` play an active role as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Subject` broadcasts to all the registered `Observers` when there is any
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Observer` is responsible for getting the changes or pulling data from the
    subscriber when there is an amendment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pull model is ineffective as it involves two steps—the first step where
    the `Subject` notifies the `Observer` and the second step where the `Observer`
    pulls the required data from the Subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The push model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the push model, the `Subject` is the one that plays a dominant role as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the pull model, the changes are pushed by the `Subject` to the `Observer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this model, the Subject can send detailed information to the `Observer` (even
    though it may not be needed). This can result in sluggish response times when
    a large amount of data is sent by the `Subject` but is never actually used by
    the `Observer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the required data is sent from the `Subject` so that the performance is
    better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loose coupling and the Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loose coupling is an important design principle that should be used in software
    applications. The main purpose of loose coupling is to strive for loosely-coupled
    designs between objects that interact with each other. Coupling refers to the
    degree of knowledge that one object has about the other object that it interacts
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Loosely-coupled designs allow us to build flexible object-oriented systems that
    can handle changes because they reduce the dependency between multiple objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loose coupling architecture ensures following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces the risk that a change made within one element might create an unanticipated
    impact on the other elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It simplifies testing, maintenance, and troubleshooting problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system can be easily broken down into definable elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Observer pattern provides you with an object design where the `Subject`
    and `Observer` are loosely coupled. The following points will explain this better:'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that the `Subject` knows about an `Observer` is that it implements
    a certain interface. It need not know the `ConcreteObserver` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new `Observer` can be added at any point in time (as we saw in the sample
    example earlier in this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Subject` need not be modified at all to add any new `Observer`. In the
    example, we saw that `AnyOtherObserver` can be added/removed without any changes
    in the `Subject`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subjects or `Observers` are not tied up and can be used independently of each
    other. So the `Observer` can be reused anywhere else, if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in the `Subject` or `Observer` will not affect each other. As both are
    independent or loosely coupled, they are free to make their own changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern – advantages and disadvantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Observer pattern provides you with the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports the principle of loose coupling between objects that interact with
    each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows sending data to other objects effectively without any change in the
    `Subject` or `Observer` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observers` can be added/removed at any point in time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the disadvantages of the Observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The Observer interface has to be implemented by `ConcreteObserver`, which involves
    inheritance. There is no option for composition, as the Observer interface can
    be instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not correctly implemented, the `Observer` can add complexity and lead to
    inadvertent performance issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In software application, notifications can, at times, be undependable and result
    in race conditions or inconsistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q1\. Can there be many `Subjects` and `Observers`?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: There can be a case for a software application to have multiple `Subjects`
    and Observers. For this to work, `Observers` need to be notified of changes in
    the `Subjects` and which `Subject` underwent a change.'
  prefs: []
  type: TYPE_NORMAL
- en: Q2\. Who is responsible for triggering the update?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: As you learned earlier, the Observer pattern can work in both push and pull
    models. Typically, the Subject triggers the update method when there are changes,
    but sometimes based on the application need, the **Observer** can also trigger
    notifications. However, care needs to be taken that the frequency should not be
    too high, otherwise it can lead to performance degradation, especially when the
    updates to the Subject are less frequent.'
  prefs: []
  type: TYPE_NORMAL
- en: Q3\. Can the `Subject` or `Observer` be used for access for any other use case?
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Yes, that''s the power of loose coupling that is manifested in the Observer
    pattern. The `Subject`/`Observer` can both be independently used.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began the chapter by understanding the behavioral design patterns. We understood
    the basis of the Observer pattern and how it is effectively used in software architecture.
    We looked at how Observer design patterns are used to notify the `Observer` of
    the changes happening in the `Subject`. They manage the interaction between objects
    and manage one-to-many dependencies on the objects.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned the pattern with a UML diagram and sample code implementation
    in Python v3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observer patterns are implemented in two different ways: push and pull models.
    You learned about each of these and discussed their implementation and performance
    impact.'
  prefs: []
  type: TYPE_NORMAL
- en: We understood the principle of loose coupling in software design and how the
    Observer pattern leverages this principle in application development.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered a section on FAQs that would help you get more ideas about the
    pattern and its possible advantages/disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we're now geared up to learn more Behavioral patterns
    in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
