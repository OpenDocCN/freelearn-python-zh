<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 6. Further Reading"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Further Reading</h1></div></div></div><p>So far in this book, we have looked into both the basic and advanced topics of using Cython. But, it does not stop here; there are further topics that <a id="id154" class="indexterm"/>you can explore.</p><div class="section" title="Overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Overview</h1></div></div></div><p>Other topics we will discuss in this chapter are OpenMP support, Cython's preprocessor and other related projects. Consider other implementations of Python such as PyPy or making it work with Python 3. Not only that but what are the Cython alter-natives and related Cython tools that are available. We will look at numba and Parakeet and look at numpy the flag ship usage of Cython.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="OpenMP support"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>OpenMP support</h1></div></div></div><p>OpenMP<a id="id155" class="indexterm"/> is a standard API in the shared-memory parallel computing for languages; it's used in several open source projects such as<a id="id156" class="indexterm"/> ImageMagick (<a class="ulink" href="http://www.imagemagick.org/">http://www.imagemagick.org/</a>) to try and speed up the processing on large image manipulations. Cython has some support for this compiler extension. But, you must be aware that you need to use compilers such as GCC or MSVC, which support OpenMP. Clang/LLVM has no OpenMP support yet. This isn't really a place to explain <a id="id157" class="indexterm"/>when and why to use OpenMP since it is really a vast subject, but you should check out the following website: <a class="ulink" href="http://docs.cython.org/src/userguide/parallelism.html">http://docs.cython.org/src/userguide/parallelism.html</a>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Compile time preprocessor"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Compile time preprocessor</h1></div></div></div><p>At<a id="id158" class="indexterm"/> compile time, similar to C/C++, we have the C-preprocessor to make some decisions on what gets compiled mostly from conditionals, defines, and a mixture of both. In Cython, we can replicate some of this behavior using <code class="literal">IF</code>, <code class="literal">ELIF</code>, <code class="literal">ELSE</code>, and <code class="literal">DEF</code>. This is demonstrated as an example in the following code line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>DEF</strong></span> myConstant = "hello cython"</pre></div><p>We also have access to <code class="literal">os.uname</code> as predefined constants from the Cython compiler:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UNAME_SYSNAME</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UNAME_NODENAME</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UNAME_RELEASE</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UNAME_VERSION</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UNAME_MACHINE</code></li></ul></div><p>We can also run conditional expressions against these as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>IF UNAME_SYSNAME</strong></span> == "Windows":
    include "windows.pyx"
<span class="strong"><strong>ELSE</strong></span>:
    include "unix.pyx"</pre></div><p>You also <a id="id159" class="indexterm"/>have <code class="literal">ELIF</code> to use in conditional expressions. If you compare something as this against some of your headers in C programs, you will see how you can replicate basic C-preprocessor behavior in Cython. This gives you a quick idea of how you can replicate C-preprocessor usage in your headers.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Python 3"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Python 3</h1></div></div></div><p>Porting to <a id="id160" class="indexterm"/>Python 3 can be painful, but reading around the subject shows us that people have had success porting their code to 3.<span class="emphasis"><em>x</em></span> by simply compiling their module with Cython instead of actually porting their code! With Cython, you can specify the output to conform to the Python 3 API via the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cython -3 &lt;options&gt;</strong></span>
</pre></div><p>This will make sure you are outputting Python 3 stuff instead of the default argument of <code class="literal">-2</code>, which generates for the 2.<span class="emphasis"><em>x</em></span> standard.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="PyPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>PyPy</h1></div></div></div><p>PyPy has <a id="id161" class="indexterm"/>become a popular alternative to the standard Python implementation. More importantly, it is now being used by many companies (small and large) in their production environments to boost performance and scalability. How does PyPy differ from normal CPython? While the latter is a traditional interpreter, the former is a full-fledged virtual machine. It maintains a just-in-time compiler backend for runtime optimization on most relevant architectures.</p><p>Getting Cythonized modules to run on PyPy is dependent on their <span class="strong"><strong>cpyext</strong></span> emulation layer. This isn't quite complete and has many inconsistencies. But, if you are brave and up to trying it out, it's going to get better and better with each release.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="AutoPXD"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>AutoPXD</h1></div></div></div><p>When it comes to writing <a id="id162" class="indexterm"/>Cython modules most of your work will comprise of get-ting your pxd declarations correct so that you can manipulate native code correctly. There are several projects attempting to create a compiler <a id="id163" class="indexterm"/>to read C/C++ headers and generate your pxd declarations as output. The main issue is maintaining a fully compliant C and C++ parser. Part of my Google Summer of Code project was to use the Python plugin system as part of GCC to reuse GCC's code for parsing C/C++ code. The plugin could intercept the declarations, types and prototypes. It isn't fully ready for use and there are other similar projects attempting the same issue. More information can be found at <a class="ulink" href="https://github.com/cython/cython/wiki/AutoPxd">https://github.com/cython/cython/wiki/AutoPxd</a>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Pyrex and Cython"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Pyrex and Cython</h1></div></div></div><p>Cython is a derivative of Pyrex.. However <a id="id164" class="indexterm"/>Pyrex is more primitive, <a id="id165" class="indexterm"/>Cython provides us with much more powerful typing and features as well as optimizations and confidence with exception handling.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="SWIG and Cython"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>SWIG and Cython</h1></div></div></div><p>Overall, if you <a id="id166" class="indexterm"/>consider<a id="id167" class="indexterm"/> SWIG (<a class="ulink" href="http://swig.org/">http://swig.org/</a>) as a way to write a native <a id="id168" class="indexterm"/>Python module, you could be fooled to think that Cython and SWIG are similar. SWIG is mainly used to write wrappers for language bindings. For example, if you have some C code as follows:</p><div class="informalexample"><pre class="programlisting">int <span class="strong"><strong>myFunction</strong></span> (int, const char *){ … }</pre></div><p>You can write the SWIG interface file as follows:</p><div class="informalexample"><pre class="programlisting">/* example.i */
%module example
%{
  extern int <span class="strong"><strong>myFunction</strong></span> (int, const char *);
...
%}</pre></div><p>Compile this with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ swig -python example.i</strong></span>
</pre></div><p>You can compile and link the module as you would do for a Cython output since this generates the necessary C code. This is fine if you want a basic module to simply call into C from Python. But Cython provides users with much more.</p><p>Cython is much more<a id="id169" class="indexterm"/> developed and optimized, and it truly understands how to <a id="id170" class="indexterm"/>work with C types and memory management and how to handle exceptions. With SWIG, you cannot manipulate data; you simply call into functions on the C side from Python. In Cython, we can call C from Python and vice versa. The type conversion is just so powerful; not only this, we can also wrap C types into real Python classes to make C data feel Pythonic.</p><p>The XML example from <a class="link" href="ch05.html" title="Chapter 5. Advanced Cython">Chapter 5</a>, <span class="emphasis"><em>Advanced Cython</em></span>, where we were able to drop in the <code class="literal">import</code> replacement? This is possible because of Cython's type conversion, and the API is very Pythonic. Not only can we wrap C types into Pythonic objects, but we also let Cython generate the boilerplate necessary for Python to do this without wrapping things into a class. What's more is that Cython produces a much more optimized code for the user.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Cython and NumPy"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Cython and NumPy</h1></div></div></div><p>NumPy <a id="id171" class="indexterm"/>is a scientific library designed to provide functionality similar to or on par with MATLAB, which is a paid proprietary mathematics package. NumPy has a lot of popularity with Cython <a id="id172" class="indexterm"/>users since you can seek out more performance from your highly computational code using C types. In Cython, you can import this library as follows:</p><div class="informalexample"><pre class="programlisting">import numpy as np
<span class="strong"><strong>cimport numpy as np</strong></span>

np.import_array()</pre></div><p>You can access full Python APIs as follows:</p><div class="informalexample"><pre class="programlisting">np.PyArray_ITER_NOTDONE</pre></div><p>So, you can integrate with iterators at a very native area of the API. This allows NumPy users to get a lot of speed when working with native types via something as follows:</p><div class="informalexample"><pre class="programlisting">cdef double * val = (<span class="strong"><strong>&lt;double*&gt;</strong></span>np.PyArray_MultiIter_DATA(it, 0))[0]</pre></div><p>We can cast the data from the array to <code class="literal">double</code>, and it's a <code class="literal">cdef</code> type in Cython to work with now. For more information and NumPy<a id="id173" class="indexterm"/> tutorials, visit <a class="ulink" href="https://github.com/cython/cython/wiki/tutorials-numpy"> https://github.com/cython/cython/wiki/tutorials-numpy</a>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Numba versus Cython"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Numba versus Cython</h1></div></div></div><p>Numba is another <a id="id174" class="indexterm"/>way to get your Python code to become almost native to your host<a id="id175" class="indexterm"/> system by outputting the code to be run on LLVM seamlessly. Numba makes use of decorators such as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@autojit</strong></span>
def myFunction (): ...</pre></div><p>Numba also integrates with NumPy. On the whole, it sounds great. Unlike Cython, you only apply decorators to pure Python code, and it does everything for you, but you may find that the optimizations will be fewer and not as powerful.</p><p>Numba does not integrate with C/C++ to the extent that Cython does. If you want it to integrate, you need to use <span class="strong"><strong>Foreign Function Interfaces</strong></span> (<span class="strong"><strong>FFI</strong></span>)<a id="id176" class="indexterm"/> to wrap calls. You also need to define structs and work with C types in Python code in a very abstract sense to a point where you don't really have much control as compared with Cython.</p><p>Numba is mostly comprised of decorators, such as <code class="literal">@locals</code>, from Cython. But in the end, all this creates is just-in-time-compiled functions with a proper native function signature. Since you can specify the typing of function calls, this should provide more native speed when calling and returning data from functions. I would argue that the optimizations you will get as compared to Cython will be minimal as you might need a lot of abstractions to talk to the native code; although, calling in a lot of functions might be a faster technique.</p><p>Just for reference, LLVM is a low-level virtual machine; it's a compiler development infrastructure where projects can use it as a JIT compiler. The infrastructure can be extended to run things, such as pure Java byte-code and even Python via Numba. It can be used for almost any purpose with a nice API for development. As opposed to GCC (an ahead-of-time compiler infrastructure), which implements a lot of static analysis ahead of time before code is run, LLVM allows code to change at runtime.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>For more information on Numba<a id="id177" class="indexterm"/> and<a id="id178" class="indexterm"/> LLVM, you can refer to either of the following links:</p><p><a class="ulink" href="http://numba.pydata.org/">http://numba.pydata.org/</a></p><p><a class="ulink" href="http://llvm.org/">http://llvm.org/</a></p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Parakeet and Numba"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Parakeet and Numba</h1></div></div></div><p>Parakeet is <a id="id179" class="indexterm"/>another project that works alongside Numba, adding extremely specific optimizations to the Python code that uses lots of nested loops and parallelism. As with OpenMP, where it's really cool, Numba<a id="id180" class="indexterm"/> too requires using annotations on your code to do all this for the programmer. The downside is that you won't just magically optimize any Python code, the optimization that Parakeet does is on very specific sets of code.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Relevant Links"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Relevant Links</h1></div></div></div><p>Some useful links for referencing are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/cython/cython/wiki/FAQ">https://github.com/cython/cython/wiki/FAQ</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/cython/cython/wiki">https://github.com/cython/cython/wiki</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://cython.org/">http://cython.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/">http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://swig.org/">http://swig.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.numpy.org/">http://www.numpy.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://wiki.cython.org/tutorials/numpy">http://wiki.cython.org/tutorials/numpy</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://en.wikipedia.org/wiki/NumPy">http://en.wikipedia.org/wiki/NumPy</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://llvm.org/">http://llvm.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://numba.pydata.org/">http://numba.pydata.org/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://numba.pydata.org/numba-doc/0.9/interface_c.html">http://numba.pydata.org/numba-doc/0.9/interface_c.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://gcc.gnu.org/">http://gcc.gnu.org/</a></li></ul></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Summary</h1></div></div></div><p>If you've read this far, you should now be familiar with Cython to such an extent that you can embed it with C bindings and even make some of your pure Python code more efficient. I've shown you how to apply Cython against an actual open source project and even how to extend native software with a Twisted Web server! As I kept saying throughout the book, it makes C feel as though there are endless possibilities to control logic or that you can extend the system with the plethora of Python modules available. Thanks for reading.</p></div></div>
</body></html>