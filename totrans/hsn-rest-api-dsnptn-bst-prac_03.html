<html><head></head><body>
        

                            
                    <h1 class="header-title">Essential RESTful API Patterns</h1>
                
            
            
                
<p>This chapter provides both the concepts and code examples of common and fundamental design patterns of the RESTful API so that you can pick up these examples and replicate and power their RESTful API services.</p>
<p>As design patterns provide generic, time-tested, proven, and reusable solutions to familiar yet recurring design problems, API design patterns are essential for software designers to learn and adapt in their RESTful API applications. API design patterns provide a description or templates to solve specific, recurring API design problems that any software architects and API designers would like to adopt in their API designs. Adopting patterns provides much flexibility to developers and helps them focus on business logic implementation and deliver the service with high quality.</p>
<p>As part of this chapter, we will learn the following common yet essential API design patterns, along with a few sample pieces of code as well. However, please note that there is no specific order to the following patterns and each pattern addresses the RESTful constraints. We also need to ensure that these essential patterns are accounted and ingrained as needed for our API designs and implementation patterns:</p>
<ul>
<li>Statelessness</li>
<li>Content negotiation</li>
<li>URI templates</li>
<li>Design for intent</li>
<li>Pagination</li>
<li>Discoverability</li>
<li>Error and exception logging</li>
<li>Unicode</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>As we will take a plunge into the code and samples, and a few pattern implementations in this chapter, the readers are expected to have a Java programming language and understand the basic concepts of Java 1.8. Our examples are implemented with Spring Boot and we have provided instructions to download and run the sample codes anywhere. However, for those who want to execute and test the code samples provided in this chapter, they may need to have the basic and necessary understanding of data formats such as JSON and XML, and also have a basic understanding of a Maven build process and client-server or web services development.</p>
<p>The following is the GitHub link for this chapter: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git">https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git</a>.<a href="https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git"> </a></p>
<p>For the code to run in your computer, you need Java 8, Spring 4 (1.4.4), and Maven 3.x. Please follow the following instructions to get started. The following are the prerequisites for this chapter:</p>
<ul>
<li>Java 1.8</li>
<li>Maven 3.2</li>
<li>Your favorite IDE (optional)</li>
<li>Command-line</li>
<li>Postman</li>
</ul>
<p>To start with, please download or clone the samples from GitHub. There are various online help resources available in case anyone needs help in downloading the samples to their local machines.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beginning with the installations</h1>
                
            
            
                
<p>If you don't have JDK or Maven installed in your environment yet, you may want to install it now by following their respective installation instructions. We need Maven installed on our machines, and we can run the program with IDEs as well. The following instructions cover how to run these samples with Windows command-line, along with the maven command line.</p>
<p>If you need Maven installation instructions, please follow the link and steps defined in the installation document. The Maven installation guide is available at <a href="https://maven.apache.org/install.html">https://maven.apache.org/install.html</a>.</p>
<p>The following section provides instructions on how to run the examples of this chapter, along with screenshots that the author was able to set up and run in his Windows-based laptop:</p>
<ul>
<li>Download the build script from <a href="https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/buildMyExamples.bat">Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/buildMyExamples.bat</a>.</li>
<li>Run the downloaded <kbd>buildMyExample.bat</kbd> script in your Windows Command Prompt and observe your output, which should be similar to what you can see in the following screenshot:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/d40a8af4-84ea-4596-9bd5-16caaf99956e.png" style="width:57.00em;height:42.75em;"/></p>
<ul>
<li>Download the run script from <a href="https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/runMyExamples.bat">Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/runMyExamples.bat</a>. Observe the following screenshot and match it with your Windows command-line output:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/28f94f2a-1a74-4c7c-a51b-2d2bee315512.png" style="width:56.33em;height:40.17em;"/></p>
<ul>
<li>Once your local server has started, you can download the sample Postman collections for this book from the following GitHub link: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json">https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json</a>. Import the collection to your local Postman tool, then run the mentioned examples in this chapter and witness the results in your Postman as you see in the following screenshot:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/41d14f24-6cec-45f9-b738-1bc4dc5363d2.png" style="width:55.42em;height:29.08em;"/></p>
<p>If you need help on installing Postman, you may find this link useful: <a href="https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/">https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/</a>. If you need help importing the Postman collections to your local Postman installation, you may find this link useful: <a href="https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data">https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Beginning with RESTful API patterns – part I</h1>
                
            
            
                
<p>This chapter covers the most common and necessary REST services design patterns to aid API designers and developers in API development in various domains. The design patterns included in this section are as follow:</p>
<ul>
<li>Statelessness</li>
<li>Content negotiation</li>
<li>URI templates</li>
<li>Design for intent</li>
<li>Pagination</li>
<li>Discoverability</li>
<li>Error and exception logging</li>
<li>Unicode</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Statelessness</h1>
                
            
            
                
<p>Statelessness refers to servers being free from application states, that is, the states that are stored at the server side and help to identify the client's requests, client's last interaction details, and their current context information.</p>
<p>The REST architecture enforces the server <em>not</em> to maintain any client states at the server side and insists on statelessness between the server and the calling client. Any API developer certainly does not want to store state information at the application server side. So, the application server should always be designed as state-free (in most cases).</p>
<p>Let's observe a few responsibilities for both the client and server so that we can achieve statelessness:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Client</strong></p>
</td>
<td>
<p><strong>Server</strong></p>
</td>
</tr>
<tr>
<td>
<p>A client should provide all necessary information to the server as part of its request to the server.</p>
</td>
<td>
<p>The server understands the client's request and should include all the necessary information as a response that a client needs to create a session on its side.</p>
</td>
</tr>
<tr>
<td>
<p>Session states should entirely be managed and kept at the client side.</p>
</td>
<td>
<p>The server does not store the client state and doesn't rely on its stored context.</p>
</td>
</tr>
<tr>
<td>
<p>The client is responsible for storing and handling all its states and sends state information to the server whenever it is needed.</p>
</td>
<td>
<p>No session affinity or session stickiness on the server is to be maintained.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>To comply with RESTful constraints, and for the service to be genuinely stateless, the servers don't even store the authentication/authorization information of the client and make clients provide credentials with their request. So, each request is understood separately by the server and there is no impact on the current request due to previous requests from the same clients.</p>
<p>In our chapter code example, we can observe that none of our requests and responses are associated with/carry any state information and they are entirely independent. Even in later sections when we will develop authentication examples, our code will still evolve and maintain statelessness across its life cycle.</p>
<p>For stateless constraints, how do we code? Spring Boot's REST API framework provides out-of-the-box implementation; our responsibility as a developer is to ensure we follow URI constraints and provide the necessary implementation for the URI. In the following code snippet from our example, <kbd>InvestorController.java</kbd>, we have a URI (<kbd>/investors/{investorId}/stocks</kbd> ) defined for fetching the stock of an investor by the investor ID; that's all—we do not have any specific implementation, session validation, and so on:</p>
<pre>@GetMapping(path = "/investors/{investorId}/stocks")<br/>public List&lt;Stock&gt; fetchStocksByInvestorId(@PathVariable String investorId,<br/>  @RequestParam(value = "offset", defaultValue = "0") int offset,<br/>  @RequestParam(value = "limit", defaultValue = "5") int limit) {<br/>    return investorService.fetchStocksByInvestorId(investorId, offset, limit);<br/>}</pre>
<p>As the path element doesn't have any indications of state, and the code expects an <kbd>investorId</kbd> along with a few other parameters, our implementation is fulfilling the stateless constraints. This will be more interesting when we deal with authentication (also with statelessness) in the next chapter.</p>
<p>Let's also observe the necessities and a few advantages of enforcing statelessness in RESTful services through the following table:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Advantages</strong></p>
</td>
<td>
<p><strong> </strong><strong>Details</strong></p>
</td>
</tr>
<tr>
<td>
<p>Scalability</p>
</td>
<td>
<p>Achieve scalability by having server code that's been deployed to multiple servers so that any server can handle any requests as there is no session stickiness/affinity to be maintained by the server. This occurs since the client's requests will have all the necessary information in each request for to the server manage.</p>
</td>
</tr>
<tr>
<td>
<p>Reduced complexity</p>
</td>
<td>
<p>There is reduced complexity as the server can get rid of server-side state synchronization logic and implementations (leads to simplified application design).</p>
</td>
</tr>
<tr>
<td>
<p>Easy cache-ability, so improved performance</p>
</td>
<td>
<p>The intermediate software can cache the results of specific HTTP requests by looking at the client's requests. Also, there are no uncertainties and concerns about the state information of the previous requests.</p>
</td>
</tr>
<tr>
<td>
<p>Traceability</p>
</td>
<td>
<p>The server never loses track of where each client is in the application as the client requests themselves have all the necessary information.</p>
</td>
</tr>
<tr>
<td>
<p>Best use of HTTP/HTTPS</p>
</td>
<td>
<p>As HTTP itself is a stateless protocol. REST implementation becomes seamless with HTTP protocols (it adheres well to REST constraints).</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Content negotiation</h1>
                
            
            
                
<p>The resources in the RESTful APIs need to deal with different type of representations—not just XML or <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>), as different clients may need different representations. In fact, as we build our complex APIS, we may find that XML/JSON is too limiting, and we may need to move to another type of content in an entirely different format (Instagram and Flickr use JPEG and PNG images, while media houses use MP3/MP4), and that's how we get to content negotiation.</p>
<p><strong>Content-negotiation</strong> is a mechanism or process that services and clients can select as their resources representation format for their communication and handshakes during their usual course of communication.</p>
<p>As we saw in <a href="edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml">Chapter 2</a>, <em>Design Strategy, Guidelines, and Best Practices</em>, in the <em>HTTP headers</em> section, the HTTP specification comes up with a set of standard headers, through which the client can get information about a requested resource and carry the messages that indicate its representations.</p>
<p>So, for content negotiation, REST services need to use HTTP headers; that is, when the client makes requests, it includes the accepts header, the list of file types that the client and server can handle with no additional steps to the client requests, the server processes, and replies.</p>
<p>If the response representation selection is determined at the server-side, then it is server-driven negotiation or proactive negotiation using request-headers. If the same selection is at the client side, then it is agent-driven content negotiation or reactive negotiation using distinct a URI. For most practical purposes, server-side negotiations are more complex and lead to make many assumptions about client requirements. So, most of the REST API implementations follow agent-driven content negotiations that rely on the HTTP request headers or resource URI patterns.</p>
<p>Let us look at a quick and live example of content negotiation by going to the following link: <a href="http://www.w3.org/StyleSheets/TR/logo-REC">http://www.w3.org/StyleSheets/TR/logo-REC</a>. Observe that logo-REC is an image file; however, it does not have any file extension (that is, w3.org serving images without a file suffix), and the log-REC is not just one file, but two—<kbd>loge-REC.gif</kbd> and <kbd>logo-REC.png</kbd>. So, with content-negotiation the w3.org server serves two different files. The following screenshot explains a bit more about the request and response headers for the same:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d792f267-caa2-472d-b23c-e5e38478daf2.png"/></p>
<p>Please observe the highlighted pieces from the preceding screenshot. The URL path, <a href="http://www.w3.org/StyleSheets/TR/logo-REC">http://www.w3.org/StyleSheets/TR/logo-REC</a>, does not say any file extension; however, in the response headers, observe the <strong>content-location</strong> and the <strong>content-type</strong> as <kbd>image/png</kbd>. The highlighted rectangles are quick examples of some of the content negotiation. Also please observe reactive negotiation through the request header accept.</p>
<p>Let's get into the details about content negotiation and the way the services/clients use them in the following paragraphs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Content negotiation with HTTP headers</h1>
                
            
            
                
<p>With our earlier example, we have seen that the server understands the content-types of incoming requests and entities with HTTP request header content-types.</p>
<p>In our code example, we have implemented the following content type and, by default <kbd>application/JSON</kbd>, and to represent what content type that the client desired to get, we use <kbd>application/JSON</kbd>  as the Accept header.</p>
<p>Please note that if no Accept header is present in the request, the server will send a pre-configured default representation type. In our example, it is always <kbd>application/JSON</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e8cc437e-5741-4487-91eb-e2c1aa9fda2a.png"/></p>
<p>The preceding screenshot depicts the Content-Type and Accept headers from our examples.</p>
<p>If we want to implement our earlier example of a w3c image within our investor service application  in a similar fashion, all we need to do is add the following dependency to <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt; 
  &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; 
  &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; 
&lt;/dependency&gt; </pre>
<p>Modify the <kbd>@GetMapping</kbd> annotation in the controller class as follows:</p>
<pre>@GetMapping(path="/investors/{investorId}/stocks/{symbol}", produces={MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})</pre>
<p>So, by using the accept request header, the client either gets the response as XML or as JSON. Cool, isn't it?</p>
<p>With Postman, we will get either a XML or JSON response according to the <kbd>application/XML</kbd> or <kbd>application/JSON</kbd> Accept header value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9587bcd8-1b89-49d5-b386-e154834fbaa8.png"/></p>
<p>Two other ways that we can pass the content type information to the server are as follows:</p>
<ul>
<li>Using specific extensions in resource URIs:
<ul>
<li><a href="https://xxx.api.com/v1/students/course.xml">https://xxx.api.com/v1/students/course.xml</a></li>
<li><a href="https://xxx.api.com/v1/students/courses.json">https://xxx.api.com/v1/students/courses.json</a></li>
</ul>
</li>
<li>Using parameters for representing an extension:
<ul>
<li><a href="https://xxx.api.com/v1/students/course?forrmat=xml">https://xxx.api.com/v1/students/course?forrmat=xml</a></li>
<li><a href="https://xxx.api.com/v1/students/courses?forrmat=json">https://xxx.api.com/v1/students/courses?forrmat=json</a></li>
</ul>
</li>
</ul>
<p>The following table provides a quick reference guide of a few other content-negotiation examples as server and client may need to deal with many other aspects of content-negotiation:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Content-Negotiation</strong></p>
</td>
<td>
<p><strong>Implementation</strong></p>
</td>
</tr>
<tr>
<td>
<p>Indicate client preference—allows clients to indicate their capabilities (such as media types and languages)</p>
</td>
<td>
<p><kbd>Accept:application/json,application/xml;q=0.9,*/*;q=0.8</kbd></p>
<p><kbd>(support json or xml, q -&gt; preference order)</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Implement media type—how to decide which media type to use for representation in a response</p>
</td>
<td>
<p>According to the Accept header from the client (Accept: <kbd>application/atom+xml</kbd>), the server can respond with a content-type, that is, <kbd>Content-Type: application/atom+xml</kbd>; <kbd>charset=UTF-8</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Implement character encoding—know what character encoding to use for textual representations in responses</p>
</td>
<td>
<p><kbd>Content-Type: charset=UTF-8</kbd> (use content-type charset)</p>
</td>
</tr>
<tr>
<td>
<p>Support compression—know when to enable the compression of representations</p>
</td>
<td>
<p># Request <kbd>Accept-Encoding: gzip</kbd></p>
<p># Response <kbd>Content-Encoding: gzip Vary: Accept-Encoding</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Send Vary header—know how to use the Vary header to indicate to clients how the server chooses a particular representation</p>
</td>
<td>
<p># Response <kbd>Content-Language: en Vary: Accept-Language</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Handling negotiation failures—know whether to serve a default representation or return an error</p>
</td>
<td>
<p># Request</p>
<p><kbd>Accept: application/json,*/*;q=0.0</kbd> (client cannot process anything other than JSON)</p>
<p># Response</p>
<p><kbd>406 Not Acceptable</kbd> (the server returns an error code as it does not support JSON. <kbd>@GetMapping</kbd> our chapter examples throws this error when the client expects only an XML responses as our example serves the JSON and not XML, except for one—a <kbd>GET</kbd> mapping)</p>
<p>Link: <kbd>&lt;http://www.example.org/errors/mediatypes.html&gt;</kbd>;<kbd>rel="help"</kbd></p>
<p>{<kbd>"message": "This server does not support JSON. See help for alternatives."</kbd>} (additional help)</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">URI templates</h1>
                
            
            
                
<p>As we saw in <a href="ce158181-8265-4afb-b858-348cc775d6d8.xhtml">Chapter 1</a>, <em>Introduction to the Basics of RESTful Architecture,</em> a<em> </em><strong>Uniform Resource</strong> <strong>Identifier</strong> (<strong>URI</strong>) is often used to identify a specific resource within a common space of similar resources. For instance, if we pick up the Star Wars API example from <a href="ce158181-8265-4afb-b858-348cc775d6d8.xhtml">Chapter 1</a>, <em>Introduction to the Basics of RESTful Architecture</em>, the films resource is represented by the URIs <a href="https://swapi.co/api/films/2">https://swapi.co/api/films/2</a>, <a href="https://swapi.co/api/films/3">https://swapi.co/api/films/3</a>, and so on. It is always the case that the client may need to include some additional information in their request, and how the server lets the client include that information about resources in the URIs. Server-side developers require the ability to describe the layout of the URIs that their services will respond to.</p>
<p>The answer to this is URI templates. URI templates provide a way to describe a set of resources as variables. So, let's observe the following table with our more general examples before we move on go to this chapter's code examples:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Resources</strong></p>
</td>
<td>
<p><strong>URI templates</strong></p>
</td>
</tr>
<tr>
<td>
<p>People: <a href="https://swapi.co/api/people/">https://swapi.co/api/people/</a></p>
<p>Planets: <a href="https://swapi.co/api/planets/">https://swapi.co/api/planets/</a></p>
<p>Films: <a href="https://swapi.co/api/films/">https://swapi.co/api/films/</a></p>
<p>Species: <a href="https://swapi.co/api/species/">https://swapi.co/api/species/</a></p>
</td>
<td>
<p><kbd>https://swapi.co/api/{resource_id}/</kbd></p>
</td>
</tr>
<tr>
<td>
<p><a href="https://swapi.co/api/films/2/">https://swapi.co/api/films/2/</a></p>
<p><a href="https://swapi.co/api/films/6/">https://swapi.co/api/films/6/</a></p>
</td>
<td>
<p><kbd>https://swapi.co/api/{resource_id1}/{resource_id2}</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>So, it is clear that if we need to define the URI template for the preceding list with variables or resource identifiers, we need to provide those variables within curly braces.</p>
<p>Now, we will see examples from the code implementation of this chapter which have been picked up from the investor-service controller class:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><kbd>@GetMapping("/investors/{investorId}/stocks")</kbd></p>
<p><kbd>@GetMapping("/investors/{investorId}/stocks/{symbol}")</kbd></p>
</td>
<td>
<p>The client would need to send an investor ID and a stock symbol for <kbd>GET</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@DeleteMapping("/investors/{investorId}/stocks/{symbol}")</kbd></p>
</td>
<td>
<p>The client would need to send an investor ID and a stock symbol for <kbd>Delete</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The<kbd>@PathVariable</kbd> annotation of spring boot does the magic of applying the URI template for the resources that the client needs. Please take note of the following code snippet from our code (<kbd>InvestorController.java</kbd>) as an example:</p>
<pre>........ 
.......... 
public ResponseEntity&lt;Void&gt; updateAStockOfTheInvestorPortfolio( 
    @PathVariable String investorId,  
    @PathVariable String symbol,  
    @RequestBody Stock stockTobeUpdated)  
{ 
          Stock updatedStock = investorService.updateAStockByInvestorIdAndStock(investorId, symbol, stockTobeUpdated); 
.......... 
........ 
 </pre>
<p> </p>
<p class="mce-root"/>
<p> </p>
<p>The <kbd>@PathVariable</kbd> annotation provided by Spring Boot help us implement the URI template pattern in our code seamlessly. As we can see, <kbd>investorId</kbd> and the symbol variables are picked up as parameters by our methods.</p>
<p> </p>
<p> </p>
<p>Please note that there are other REST frameworks that do a good job and provide out-of-the-box URI templating.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Design for intent</h1>
                
            
            
                
<p>Imagine our car getting repaired without even taking it to an automobile service centre. A few years back, Tesla, the car manufacturing company, famously did that when it issued an over-the-air repair to their cars. Tesla's software got updated to detect charging problems and help decrease the charging rates (cascading effect) to avoid overheating and hence avoid engine fires.</p>
<p>Design for intent is a term that's used in structural and automobile fields for parameterized changes, and we will learn how it benefits REST API services as well.</p>
<p>Design for intent is a method that expresses the different relationships between objects so that changes to one object automatically propagates changes to others. In Tesla's case, the decreased number of charging cycles (cascading effect) helped to avoid overheating of the engine.</p>
<p>In a RESTful API world, the API should be developed to ensure they meet the requirements of the use cases, provided and faced by the users, but without exposing the internal business objects. Design for intent is a strategic design pattern that's intended to influence or result in specific and additional user behaviors.</p>
<p>To relate the design for intent implementation within our investor service example, we should provide the mechanism to update the investor's portfolio automatically whenever the new (type) stocks get added to the investor object:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/701f6963-a5cf-45ae-aa21-dd2f7e67d290.png"/></p>
<p>As you can see in the preceding diagram, the intention of the API is to add a new stock; however, it should have a cascading effect on the investor's portfolio as well—maybe a new stock type should get added, the total number of stocks needs to be updated, and so on. This is abstract to the app developer. The same applies when stocks are deleted as well.</p>
<p>Please recollect the granularity of APIs discussion from <a href="edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml">Chapter 2</a>, <em>Design Strategy, Guidelines, and Best Practices</em>, as choosing the right granularity of APIs plays a vital role in the design for intent strategy. In this chapter's example, we have provided a simple update method for adding the stock types to the investor's portfolio, and readers are encouraged to develop more functionalities as part of this pattern ensures having the right granularity (coarse-grained versus fine-grained) of APIs for the update and delete stock types within an investor's portfolio. Consider the following code:</p>
<pre>........ 
public Stock addNewStockToTheInvestorPortfolio(....) { 
  if (......)) { 
      designForIntentCascadePortfolioAdd(investorId); 
      return ......; 
  } 
...... 
} 
......... 
......... 
public boolean deleteStockFromTheInvestorPortfolio(....) { 
  ...... 
  if (....) { 
     .... 
     designForIntentCascadePortfolioDelete(investorId, deletedStatus); 
    return .......; 
      } 
......... 
 
private void designForIntentCascadePortfolioAdd(...) { 
            ..... 
      } 
private void designForIntentCascadePortfolioDelete(...) { 
            ........; 
      } 
} </pre>
<p>The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/74b87bb0-0108-4c6d-adbc-5cc5fb182bca.png"/></p>
<p>The preceding screenshot and code is the sample implementation (code snippets) that we can see in <kbd>InvestorService.java</kbd>. This also shows a console message when the <kbd>Delete</kbd> and <kbd>Add</kbd> APIs are called with the Postman tool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pagination</h1>
                
            
            
                
<p>When a client tries to fetch a list of objects that run into pages, we have to think about how the server can manage to serve the clients with such a massive response without hampering its performance.</p>
<p><strong>Pagination</strong> is a concept that helps in serving only part of the data as a response, however, with information about how to access all the data from the server, page by page, without much load and high computation for the server to serve the whole data.</p>
<p>Should we consider a page (of results) as a resource or just a representation of resources? Considering the page as a representation and not as a resource is what we are going to discuss in this section.</p>
<p>As we decided pagination is a resource representation, we will include the pagination information as part of the URI query, that is, <kbd>xxx.api.com/stocks?page=2</kbd>.</p>
<p>Please note that pagination as part of the URI path is not an option (as we consider that it is not a resource but resource representation), that is, <kbd>xxx.api.com/stocks/page/2</kbd>, as we may not be able to uniquely find the resource between calls.</p>
<p>One problem that we need to solve in the case of pagination for URI queries is encoding, and we can use the standard way of encoding the paging information  to do this.</p>
<p>Before we jump into the code, let's have a look at some better API pagination examples in the industry and a few pagination types as well.</p>
<p>Facebook's API uses offset and limit (<kbd>fields=id</kbd>, <kbd>message&amp; amp;limit=5</kbd>), linkedIn uses start and count (<kbd>.../{service}?start=10&amp;count=10</kbd>), and Twitter uses records per page or count (<kbd>api.twitter.com/2/accounts/abc1/campaigns?cursor=c-3yvu1pzhd3i7&amp;count=50</kbd>).</p>
<p>There are three variants of resource representation ways of pagination, and they are as follows:</p>
<ul>
<li><strong>Offset-based</strong>: When a client needs responses based on page count and page number. For example, <kbd>GET /investor/{id}/stocks?offset=2&amp;limit=5 (returns stocks 2 through 7 )</kbd><em><em>.</em></em></li>
<li><strong>Time-based</strong>: When a client needs responses between a specified timeframe and can have a limit as well as part of the parameter to represent the max number of results per page. For example, <kbd>GET /investor/{id}/stocks?since=xxxxxx&amp;until=yyyyy</kbd> <kbd>(returns stocks between a given dates)</kbd><em>.</em></li>
<li><strong>Cursor-based</strong>: A technique where a pointer (a built-in bookmark with breadcrumbs) reference of the remaining data is served a specific subset of data as a response and is let off. However, the rest of the data is still needed for later requests until the cursor reaches the end of the records. For example, <kbd>GET slack.com/api/users.list?limit=2&amp;token=xoxp-1234-5678-90123</kbd>. The following code explains this:</li>
</ul>
<pre>@GetMapping(path = "/investors/{investorId}/stocks") 
  public List&lt;Stock&gt; fetchStocksByInvestorId( 
      @PathVariable String investorId,  
      @RequestParam 
      (value = "offset", defaultValue = "0") int offset, 
      @RequestParam 
      (value = "limit", defaultValue = "5") int limit) { 
             
  return investorService.fetchStocksByInvestorId(investorId, offset, limit); 
      } </pre>
<p>The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f0047d1f-8cca-42d8-b2cd-97129061ee0e.png"/></p>
<p class="mce-root"/>
<p>The preceding blocks shows offset-based pagination implementation within our investor service code. We will implement and touch upon other pagination methods, along with sorting and filtering in the next chapter when we discuss versioning and other patterns involving a database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Discoverability</h1>
                
            
            
                
<p>As we have discussed in the earlier chapter, API developers are the raison d'être of APIs. Helping them find the right APIs and helping them figure out programmatically whether the site that's being accessed has an API enabled or not will be the most critical responsibility of the API.</p>
<p>The primary step to connect with a site is to find out if the site is API enabled by simple URLs that are be using as user input to help us verify the API's availability. They also help us find out how to access them.</p>
<p>Discoverability of the API is all about the descriptive capability of the server to instruct the client on the usage of the API.</p>
<p>Let's look at the two types of discoverability in the following section and their implementation in our code examples (as screenshots):</p>
<ol>
<li><strong>By valid HTTP methods</strong>: When clients call REST services with invalid HTTP methods, the response of that request should end up in the <kbd>405</kbd> HTTP error code; that is, <kbd>405 Method Not Allowed</kbd>. In addition to the error code, the response header should provide flexibility to the client to find the supported methods that allow headers in its response. The code for this is as follows:</li>
</ol>
<pre style="padding-left: 60px">@DeleteMapping("/investors/{investorId}/stocks/{symbol}") 
public ResponseEntity&lt;Void&gt; deleteAStockFromTheInvestorPortfolio( 
  @PathVariable String investor, 
  @PathVariable String symbol) { 
    if (investorService.deleteStockFromTheInvestorPortfolio(investorId, symbol)) { 
      return ResponseEntity.noContent().build(); 
    } 
    return ResponseEntity.ok(null); 
} </pre>
<p style="padding-left: 60px">The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/db97037f-37e9-4eca-ba46-7b0a3ab7032d.png"/></p>
<ol start="2">
<li><strong>By providing the URI of the newly created resource</strong>: Including the URI as part of the location header as the response to the newly created resource is another method of discoverability. The returned URI as a location will be available through <kbd>GET</kbd>. The code for it is as follows:</li>
</ol>
<pre style="padding-left: 60px">@PostMapping("/investors/{investorId}/stocks") 
public ResponseEntity&lt;Void......) { 
  Stock insertedStock = investorService.addNewSto...; 
  if (insertedStock == null) { 
    return ResponseEntity.noContent().build(); 
  } 
  URI location = ServletUriComponentsBuilder..... 
  return ResponseEntity.created(location).build(); 
} </pre>
<p>The output for the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a65b4b72-7c56-46a8-8bff-b5a1af3e4a06.png"/></p>
<p>Please note that, as our examples are using spring boot, we are leveraging the capabilities of spring boot's seamless and out-of-the-box implementations for discoverability (with <kbd>@GetMapping</kbd>, the servlets URI components builder, and so on).</p>
<p>One more type of discoverability (yet to be standardized, though) can be implemented through valid link headers. While responding to the client's particular resources through <kbd>GET</kbd>, you must provide the client with clues about what they can do next as well; that is, providing a list of all available resources as a list through the link header:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/eacff5f9-49e7-4ca5-ac31-51f758a4e1d1.png"/></p>
<p>As a live example of discoverability, the preceding screenshot depicts one of Google's APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Error and exception logging</h1>
                
            
            
                
<p>As we keep on emphasizing when we discuss the importance of API developers when it comes to the consumption of our services, error handling and exception handling should be taken care of without any compromises. Services are the black boxes to the API developers, and therefore service providing errors and exceptions provide clients with a clear context and visibility to use our APIs.</p>
<p>Let's take some real-world and very popular APIs and how they are handling these errors in a sample error scenario. This is shown in the following table. We will also look at the way we handle these errors and exceptions within our investor service code:</p>
<table border="1" class="MsoTableGrid" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 15.4229%">
<div><strong>APIs</strong></div>
</td>
<td style="width: 7.58706%">
<div><strong>HTTP code</strong></div>
</td>
<td style="width: 59.0796%">
<div><strong>Sample message</strong></div>
</td>
<td style="width: 16.4179%">
<div><strong>Remarks</strong></div>
</td>
</tr>
<tr>
<td style="width: 15.4229%">
<p>Facebook</p>
</td>
<td style="width: 7.58706%">
<div><kbd>200</kbd></div>
</td>
<td style="width: 59.0796%">
<div><kbd>{"type":"OAUTH exception","message":"...."}</kbd></div>
</td>
<td style="width: 16.4179%">
<p>Note that <kbd>200</kbd> indicates success. However, the API decides to send an error message as a response and still provide a success (<kbd>200</kbd>) code for an API call.</p>
</td>
</tr>
<tr>
<td style="width: 15.4229%">
<p>Twilio</p>
</td>
<td style="width: 7.58706%">
<div><kbd>401</kbd></div>
</td>
<td style="width: 59.0796%">
<div><kbd>{"status":401,"message":"Authenticate","code":"...."..}</kbd></div>
</td>
<td style="width: 16.4179%">
<p>Leverages the existing HTTP code as it is.</p>
</td>
</tr>
<tr>
<td style="width: 15.4229%">
<p>InvestorService</p>
</td>
<td style="width: 7.58706%">
<div><kbd>405</kbd></div>
</td>
<td style="width: 59.0796%">
<div><kbd>{"Status":405,"error":"Method Not Allowed"....</kbd></div>
</td>
<td style="width: 16.4179%">
<p>Leverages the existing HTTP code as it is.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>We also have a sample implementation of a custom exception class called <kbd>InvestorNotFoundException</kbd> in our sample repository. The code snippet and output sample (from Postman) is as follows:</p>
<pre>public class InvestorNotFoundException extends RuntimeException{ 
 
      ........ 
      public InvestorNotFoundException(String exception) 
      { 
            super(exception); 
      } 
} </pre>
<p>The output of the preceding code is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c1fe1000-aba7-4237-a270-23baef5c0a6b.png"/></p>
<p>From our earlier examples, we can observe we have done a fair job regarding managing errors and exceptions with existing HTTP standard error codes. However, we can go further by providing more customized errors and messages to the caller; for instance, it would be more proper for the caller to receive a <kbd>404</kbd> error instead of a <kbd>500</kbd> error. Maybe we will implement a few customized error messages in the next chapter while we build some more patterns.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unicode</h1>
                
            
            
                
<p>A simple yet powerful way to make our API support multiple languages is to enable the API to support Unicode.</p>
<p><strong>Unicode</strong> is an encoding standard that support an international character set. It has a unique number for every character across multiple languages including Chinese, Korean, and Arabic and their scripts. The unique number makes almost all characters identifiable and accessible across platforms, programs, and devices.</p>
<p>So, in short, we can simplify our REST API that supports multiple languages by supporting Unicode as part of their headers. The following code depicts this:</p>
<pre>@GetMapping(value="/investors/welcome", produces="text/plain;charset=UTF-8") 
  public String responseProducesConditionCharset() {    return "<img class="fm-editor-equation" src="img/78bea65d-710d-46b3-b9b4-ea8522aed0c1.png" style="width:12.25em;height:1.75em;"/><img class="fm-editor-equation" src="img/6132d1bd-378a-410d-bebc-6027be6bde85.png" style="width:1.25em;height:1.75em;"/> (\"Welcome Investor!\" in Japanese)"; 
} </pre>
<p>The output for it is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/68bf55e0-448a-48e2-a53c-b31382c485bd.png" style="width:35.92em;height:31.58em;"/></p>
<p>The preceding diagram shows the code snippet of the (<kbd>InvestorController.java</kbd>) accept-encoding charset in the header and the Postman results for the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>With a sense of our hands dealing with real code examples of statelessness, content-negotiation practices, URI templates definitions, service design for intent, discoverability, and a type of pagination. Then, we discussed error and exception handling in detail before finally concluded with a Unicode implementation for internationalization (supporting multiple languages with our services).</p>
<p>This chapter should be an excellent start for anyone who wants to get their hands on the RESTful services; not just the basics, but the essential patterns as well. In the next chapter, we will see more advanced pattern implementation and examples to enable our readers to increasingly utilize best practices and implementations.</p>


            

            
        
    </body></html>