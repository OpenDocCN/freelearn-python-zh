- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX and Displaying Lists in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Componentization** is a design paradigm in React application development.
    As a developer and React enthusiast, you will develop tons of useful components.
    You will need a combination of units to provide interfaces the user can interact
    with seamlessly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Syntax Extension** (**JSX**) is an innovative approach to describing
    the **User Interface** (**UI**) for modern web applications. In this chapter,
    we are going to take a clinical dive into why JSX is one of the core requirements
    in developing production-ready React applications. In addition, you will learn
    how to display lists in React.'
  prefs: []
  type: TYPE_NORMAL
- en: We use lists in virtually every web application development project we undertake,
    and knowing how to render lists is a required skill set for web developers. HTML
    and JavaScript, as languages of the web, have been with us from the beginning,
    helping web developers build web applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, in recent times, the demand for complex and highly rich interactive
    web applications has necessitated using JSX as a creative approach for building
    user interface components.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to understand what JSX is about and how it is
    different from HTML. We will use JSX to describe the user interfaces we will be
    building in this chapter. Then, we will examine how we handle event operations
    in React.
  prefs: []
  type: TYPE_NORMAL
- en: As a React developer, you will consume both internal and external API data for
    your user consumption. By the end of this chapter, you will be able to display
    list objects to your users, handle common events in React, and render lists with
    loop functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSX versus HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How JSX abstracts JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handling in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying lists in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting lists in JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping over objects in JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve already been introduced to and seen some JSX. Let’s discuss in more depth
    what JSX means as a new approach to adding HTML to JavaScript when designing user
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: JSX is simply an XML-like syntax extension for JavaScript. JSX allows frontend
    developers to bake HTML elements with JavaScript. The effect of this mix is usually
    an impressive user-friendly interface. As we know, the main purpose of React is
    to provide us with a set of APIs for building user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: With little or no controversy, React has been up to the challenge, becoming
    the leading shining gem in the jungle of frontend JavaScript libraries and frameworks.
    React powers large-scale, production-grade web and mobile applications with an
    improved user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, React is achieving this improved efficiency and performance
    with the same set of tools, languages, and techniques we are already familiar
    with: HTML and JavaScript. React leverages HTML elements and JavaScript functions
    to build reusable UI components. JSX evolved as an approach that allows us to
    mix markup and display logic for building React components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can safely run JavaScript code as a JSX expression. Consider the following
    snippet of a simple React component to see some of the ways you can use JSX in
    React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s examine what is going on with this code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code explains how to use JSX in React:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React from ''react''` is used to bring React into scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export function App()` describes a function component named `App()` that can
    be accessed by other components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const speakerName` variable is declared and assigned a value of `John Holt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following part of the preceding code snippet depicts the JSX part of the
    `component` `App()` code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is a mix of HTML elements (`h2` and `div`) and a JavaScript
    expression inside curly braces (`{speakerName}`). This displays the text `John
    Holt` while `{5 + 5 }` displays the result of the sum of 5 + 5.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever JavaScript expression you have can be put inside a curly brace in JSX
    and it will return the expected valid JavaScript output. However, the browser
    doesn’t know what to do with JSX syntax by default; but with the help of the Babel
    compiler, JSX code is transformed into equivalent JavaScript syntax that the browser
    natively understands.
  prefs: []
  type: TYPE_NORMAL
- en: The JSX transpilation by Babel contributes significantly to factors that make
    React applications so brazenly fast. It doesn’t just transpile JSX codes into
    browser JavaScript; it optimizes as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see how the `<div className='App'>` attribute is used in JSX; the
    naming convention for the class attribute is important. We write it in camelCase
    format – `className` in React. The `className` attribute is assigned a value of
    `App`, which is used in the CSS file to add style to the component.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we need to understand that a high-level connection exists between
    JSX and the **Document Object Model** (**DOM**). The DOM is an object-oriented
    representation of a web document. It is a set of APIs that’s used to manipulate
    web documents that can be loaded on a web browser. A typical web application page
    represents a web document that DOM APIs use to maintain the DOM structure and
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM manipulation is usually done by JavaScript – a scripting language. You
    can use JavaScript objects to create, update, and remove HTML elements. The DOM
    manipulation is the bedrock of interactivity you see with most web applications.
    But React handles DOM differently and at best with some creativity.
  prefs: []
  type: TYPE_NORMAL
- en: The React team has been able to identify the challenges with DOM tree re-rendering
    on every HTML element operation (create, update, and delete), and decided to develop
    a **virtual DOM** (**VDOM**). VDOM is an abstraction of the native browser DOM
    that enables React applications to be fast and efficient and exhibit cross-browser
    compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: React components only re-render the changed node (`h1`, `div`, and `p` – all
    these represent nodes on HTML) of a DOM, rather than causing the entire web document
    to be re-rendered on a single node change.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how JSX and HTML elements are used to design UI components
    and the inherent differences between JSX and HMTL.
  prefs: []
  type: TYPE_NORMAL
- en: JSX versus HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`React.createElement()` under the hood. JSX makes component interface development
    hassle-free while optimizing efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: HTML is the standard language for structuring the web. HTML elements power every
    web page you see on the internet. HTML syntax is easy to understand, and it is
    the language the browser understands natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table clearly states the subtle differences that exist between
    JSX and HTML for better understanding and usage in React applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **HTML** | **JSX** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Native to the browser | HTML elements are native to the browser. | JSX is
    transpiled into JavaScript using Babel before browsers can understand its syntax.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Attribute usage | You have flexibility regarding how you name your HTML attributes,
    though this is mostly in lowercase, such as `onmouseover`, `onclick`, `onsubmit`,
    `onload`, `onfocus`, and so on. | You must follow the camelCase rule in naming
    attributes in JSX and event references such as `onClick`, `onChange`, `onMouseOver`,
    and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| The naming of the `class` and `for` attributes | You must use lowercase `class`
    when naming CSS classes and `for` when naming input labels in HTML. | In JSX,
    you must use `className` (camelCase) and `htmlFor` for input labels. |'
  prefs: []
  type: TYPE_TB
- en: '| Handles JavaScript code | You must use the `<script>...</script>` script
    tag or an external JS file to add JavaScript to HTML. | In JSX, you can write
    JS expressions inside curly braces; for instance, `{ new` `Date().toString }`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Returns a single parent element | In HTML, you are permitted to return HTML
    elements without enclosing them in a single parent; for example:`<div > </``div>``<``p>...</p>``<``ul>...</ul>``<``span>...</span>`.All
    these tags can independently stay on a web page with enclosing tags. | In JSX,
    you must return a single parent element; otherwise, you will get JSX errors; for
    instance:`<div></div>` or a fragment tag, `<> </>`, must enclose all your HTML
    elements:`<``div>``<``p>...</p>``<``ul>...</ul>``</``div`Or`<>``<``p>...</p>``<``ul>...</ul>``</>`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Self-closing tags | In HTML, you can have a self-closing tag without a forward
    slash; for example, `<br>`. | In JSX, you must add a forward slash to any self-closing
    tag; for example, `<``br />`. |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Differences between JSX and HTML
  prefs: []
  type: TYPE_NORMAL
- en: JSX and HTML allow you to structure web content and enable users to interact
    with web application interfaces. As a React developer, you must be conversant
    with the inherent differences between HTML and JSX elements to avoid being red-flagged
    by the JSX compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how JSX allows us to describe a UI with HTML-like tags
    while it leverages the power of JavaScript under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: How JSX abstracts JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, coding React applications without JSX is not recommended, though it
    is possible. For instance, you can write a `React.createElement(component, props,
    ...children)` function to describe a UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can easily describe a button UI in JSX with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing the preceding code without JSX would require you to describe a button
    UI with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Doing this in a large React project could lead to multiple issues, such as having
    to deal with more bugs in your code base and facing a steeper learning curve to
    become a code-savvy developer who could function optimally at writing this low-level
    code to describe a UI. However, with very little to disagree on, you would agree
    that JSX is a better route to toll rather than plain React-modified JavaScript
    at describing a UI component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine how JSX abstracts JavaScript in its data presentation by providing
    a syntactic creamy chocolate on top of a low-level React function: `React.createElement()`.
    This implies how React takes on the burden of converting JSX into JavaScript using
    Babel to make seamless DOM interaction possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/index.js`, update the file with the following snippet to see how you
    can write `React Conference 2024` to a screen without JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, `React.createElement()` is a function call with
    three parameters: `div`, `{}`, and the expected output text of `React` `Conference
    2024`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `div` parameter in the `React.createElement` function represents the type
    of HTML element we are creating. This could be any HTML element or tags (`h1`,
    `p`, `ul`, `li`, and so on). You could even add components as your first parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The empty curly brace parameter, `{}`, represents props. It could be an object
    or null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter represents what we want to see on the screen. This could
    be ordinary text or a child component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `src/app.js`, update the file with the following snippet that explains the
    use of JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows the JSX constructs of the code that displays `React
    Conference 2024` – that is, `<div className='App'>`, `<h1>React Conference 2024</h1>`,
    and `</div>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these look like regular HTML elements, they are JSX expressions. Now,
    reset `index.js` as follows to describe a UI with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code with `npm start`; you will see the text **React Conference 2024**
    on your browser screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Screenshot showing the JSX output](img/Figure_5.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Screenshot showing the JSX output
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, JSX is a useful tool within the React community that allows developers
    to meet the presentational needs of components without a hardcore approach to
    DOM manipulation. It facilitates a smooth UI experience and rich interactivity
    for end users. With this, we have a fast, efficient, and independent wide range
    of browser-compatible web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss event handling in React. Traditional event methods such
    as `onclick`, `onfocus`, `onblur`, and others are closely related to what we have
    in React with some subtle naming differences.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss this and more to see how we can harness the knowledge
    covered in this chapter and add it to the skill set required to build an interactive
    conference web app project for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React’s event system is another powerful feature shipped with React core APIs.
    It is called `SyntheticEvent`. As React developers, we will come across event
    handling daily in React application development projects. Handling events shouldn’t
    be new to you if you are familiar with the basics of JavaScript. You could add
    an event to HTML DOM using the browser-native approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a glimpse at this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`<div id="root"> </div>` indicates the location where the DOM will inject the
    text we will create. The `div` element has an `id` attribute with a value of `root`
    passed into it. This helps the event objects know where text should appear. The
    `document.addEventListener()` method adds an event listener with two parameters:
    `click` and a callback function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we click on a button, we fire an event. The event name is called click
    event. In this scenario, there is a `Post` message to click to fire an event:
    `<p><strong>Click here to see my message.</strong></p>`. Once this message is
    clicked, a callback function, the second parameter, is triggered and causes the
    `getElementById` window method to use the `id` attribute with a value of `root`
    from the `div` element to pass `innerHTML` the newly assigned text – that is,
    `This text is then added to the` `DOM tree!`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, we have various events with a camelCase naming convention: `onClick`,
    `onChange`, `onInput`, `onInvalid`, `onReset`, `onSubmit`, `onFocus`, `onBlur`,
    `onToggle`, and others. You can find a whole list of events in the React documentation
    – **React** **SythenticEvents** (https://reactjs.org/docs/events.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into the following snippet to see how we can handle form events
    in React. This snippet illustrates the `onChange` form event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s closely examine this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import React, {useState} from ''react''` makes the `useState` hook available
    to the `App()` component for state tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `const [username,setUsername]=useState("")` `const name,` **setName]=useState("")**
    and `const [email,setEmail]=useState("")` snippets allow us to have access to
    the states for username, email, and name. With `setUsername`, `setName`, and `setEmail`,
    we can track the new states for the variables. The initial states for all the
    variables are set to empty strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding snippet, `handleSubmit()` is an event handler that accepts
    `e` as the event object. `e.preventDefault` prevents browser default behavior
    on form field submission. There won’t be a page refresh on form submission. `handleSubmit`
    is added to the form as an attribute to execute `alert()`to display the `username`,
    `name`, and `email` states on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the input tags, `<input` `type="text" placeholder="Username"onChange=` **{(e)=>setUsername(e.target.value)}
    />**, the `onChange` event attribute is added to the input element. The `onChange`
    event has a callback function that accepts `e` as a parameter. `setUsername(e.target.values)`
    listens for a change event in the input field. The same `onChange` event callbacks
    are added to input tags for the name and email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `<p>Username: {username}</p>, <p>Name: {name}</p>, <p>Email: {email}</p>`
    snippet displays the current input text in the input form fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the effect of event handling in forms:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Screenshot showing the effects of event handlers on form fields](img/Figure_5.2_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Screenshot showing the effects of event handlers on form fields
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, event handling in React is managed by a cross-browser wrapper
    called `SyntheticEvent`. We pass event handlers as instances to `SyntheticEvent`
    in React applications. It is best practice to prevent the default browser behavior
    by using `preventDefault()`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how to use lists in React applications. A list is a common
    feature in any enterprise web application. Let’s see how React helps us improve
    the user experience with a well-thought-out UI list design.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying lists in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web applications we see around today use list components in describing
    a user interface. In any complex web application project or production-grade application,
    you will see the list feature, often used in data presentation. In React, you
    can use a list to display your component data.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use mocked data to showcase how you can use `map()` to fetch
    a list of data items. We will also discuss the essence of the `key` and `id` attributes
    in React list management. The GitHub repository for this book’s project (https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/tree/main/Chapter-05/06/frontend)
    contains the mocked conference speakers `data` source; you can find `images` in
    the public folders and `css` (`index.css`) inside the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: However, the backend section of this book ([*Chapter 9*](B18554_09.xhtml#_idTextAnchor186),
    *API Development and Documentation*) will explain how we can pull this data from
    an API endpoint developed in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `url` leads you to the speakers page – `http://localhost:3000/speakers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Screenshot showing the list of conference speakers pulled from
    a data source](img/Figure_5.3_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Screenshot showing the list of conference speakers pulled from
    a data source
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the code snippet for showing a list of speakers working with
    a couple of components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src/components`, create `SpeakersCard/SpeakersCard.jsx` and add the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we created a `SpeakersCard` component that accepts
    an object with four properties: `name`, `jobTitle`, `company`, and `profileImg`.
    These properties will be passed to the component as props by the `SpeakersPage`
    component (parent component) that will be created shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: The `SpeakersCard` component’s return statement contains JSX, which represents
    the structure of the rendered output.
  prefs: []
  type: TYPE_NORMAL
- en: We need this `SpeakersCard` component to encapsulate and represent the visual
    appearance and information display for a speaker entity for the conference web
    app. By creating this component, we can reuse it throughout the application whenever
    we need to display information about the speaker.
  prefs: []
  type: TYPE_NORMAL
- en: Now, inside `src/pages`, create `SpeakersPage/SpeakersPage.js`. The `SpeakersPage`
    component will be used to display a list of speakers by rendering the `SpeakersCard`
    component for each speaker in `speakerList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `SpeakersPage.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we import dependencies to make the page functionalities
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import SpeakersCard from ''../../components/SpeakersCard/SpeakersCard''`:
    This code line imports the `SpeakersCard` component from the `SpeakersCard` directory
    within the components directory. The `../../` notation is used to navigate to
    the appropriate directory level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`import speakerList from ''../../data/SpeakerList''`: This code line imports
    the `speakerList` data from the `SpeakerList.js` file located in the data directory.
    You can find the data file in the GitHub repository for this chapter. This data
    contains an array of objects, each representing a speaker with properties such
    as `name`, `jobTitle`, `company`, and `profileImg`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we add `<SpeakersCard ... />`. This code line renders the `SpeakersCard`
    component and passes the necessary props (`name`, `jobTitle`, `company`, and `profileImg`)
    for each speaker from `speakerList`. The `key={speaker.id}` prop is added to each
    `SpeakersCard` component. The `key` prop helps React efficiently update and re-render
    components when the list changes.
  prefs: []
  type: TYPE_NORMAL
- en: '`SpeakersPage` also includes `header`, `breadcrumb navigation`, and `footer`
    components to provide a complete layout for the speakers’ section. The codes for
    the `Header`, `Breadcrumb`, and `Footer` components can be found in this chapter’s
    GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will examine how we can follow React best practices in dealing with
    list items by uniquely identifying the items in a list with a key.
  prefs: []
  type: TYPE_NORMAL
- en: Using key and id in JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **key** in React list items is a unique identifier of the state of items
    in a list. We use a key to track items in the list that have been changed, added,
    or removed. It is usually expected to be a unique item in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the object array we used in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `id` attribute in this array should be a unique number. This allows us to
    track object data states appropriately. We used the `{speaker.id}` ID as the value
    for the key attribute in the preceding `speakersList` example.
  prefs: []
  type: TYPE_NORMAL
- en: We will now delve into nested lists in JSX and learn how to use a nested list
    in React to handle complex data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting lists in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, lists are a critical component of most web applications.
    Lists are often used to structure data and organize information neatly. We are
    familiar with some of the list clichés in web development: *a to-do list*, *a
    task list*, and even *a menu list*. All these lists can become complicated, depending
    on the data structure and how you are expected to present list items to end users.
    Dealing with lists in a React application requires an understanding of how you
    can handle data that comes in the form of an array of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to render nested lists of items in JSX in
    React applications. You are going to see complex nested data structure like this
    and even more coming from your API data sources, so having an understanding of
    nested lists will make React applications that contain complex data easier to
    handle.
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet displays a list of nested web technology stack items
    in a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `App.js` inside `src/App.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what’s happening in this code? We are dealing with a named nested list
    of object data called `webStacksData`, which can be found in the GitHub repository
    for this book:'
  prefs: []
  type: TYPE_NORMAL
- en: The data is imported into scope with `import {webStacksData}` from `"./data/webStacksData";`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also imported the `WebStacks` components into scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `webStacksData.map` function iterates over each item in the `webStacksData`
    array, creating a new `WebStacks` component for each item. The `key` prop is set
    to the `id` property of each item to help React efficiently update the list when
    needed. For each item in the `webStacksData` array, a `WebStacks` component is
    rendered with the `item` prop set to the current `item` from the array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create a component called `WebStacks` to see the inner working of the
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `WebStacks` component takes props items. In the component body function,
    we check to see whether the parent list items exist and whether it has child items.
    We then invoke `map()` to recursively iterate over the list items with valid child
    list items.
  prefs: []
  type: TYPE_NORMAL
- en: This `<li>{item.name}{children}</li>` returns the name of the list items and
    all the children. Next, we are going to see how you can loop through objects in
    React and display the output in JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over objects in JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looping through complex data objects is part of what experienced React developers
    need to know how to handle effortlessly. You will undoubtedly encounter scenarios
    where you will have to work with both simple and nested object data from your
    API endpoints to extract useful data for your application. In this section, we
    are going to understand how to seamlessly iterate over data objects in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, objects are not iterable. You simply can’t loop over the object
    properties with the `for ... of` syntax. `Object.Keys()` is one of the in-built
    standard object methods used to loop over object data in JavaScript. However,
    in ES2017, new object methods were added that can be used to loop over object
    properties: `Object.values()` and `Object.entries()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly examine each of these methods and learn how to use them with object
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the object data to loop over and name it `speakersData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will examine a variety of techniques that are used to efficiently iterate
    over object properties, allowing you to access and manipulate data within objects
    using methods such as `Object.keys()`, `Object.values()`, and `Object.entries()`.
    We will briefly delve into each of these techniques, starting with `Object.keys()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Object.keys()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Object.keys` method returns an array of object’s keys. As you know, objects
    contain key and value pairs, so `Object.keys()` will return arrays of keys/properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pass in our data object as a parameter in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Screenshot showing the effect of using the Objects.keys() method](img/Figure_5.4_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Screenshot showing the effect of using the Objects.keys() method
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the array of keys. You can retrieve the values of the key
    with a loop function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the keys and values of the object data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Screenshot showing object keys and values](img/Figure_5.5_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Screenshot showing object keys and values
  prefs: []
  type: TYPE_NORMAL
- en: Later, you can invoke `map()` to retrieve the values of the keys in a React
    component. This will be explained later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to use `Object.values()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Object.values()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Object.values()` method returns an array of object property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This returns only the properties values without keys, thus making it less useful
    in a use case where keys and values are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Screenshot showing the effect of using the Objects.values()
    method](img/Figure_5.6_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Screenshot showing the effect of using the Objects.values() method
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the last technique we can use to loop over object data.
  prefs: []
  type: TYPE_NORMAL
- en: Using Object.entries()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Object.entries()` method returns an array of object key-value pairs –
    `[key, value]`. Looping over an object with `Object.entries()` is easier with
    the `[key value]` pair. For instance, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of using `Object.entries()` on object
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Screenshot showing the effect of using the Objects.entries()
    method](img/Figure_5.7_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Screenshot showing the effect of using the Objects.entries() method
  prefs: []
  type: TYPE_NORMAL
- en: We can see that 2D arrays are returned with keys and values of object properties.
  prefs: []
  type: TYPE_NORMAL
- en: Example of looping with Object.keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to work with a data object that contains useful speakers’
    information with an object data format. It can be found in this book’s project
    repository on GitHub (https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-05/data/objSpeakersData.js)
    and displays the output in a React component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code iterates over the `speakers` object data and displays the
    output in JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import {simpleSpeakerData} from ''../../data/objSpeakersData''` brings our
    data into scope so that it can be used in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we declare a `Speakers` component, which returns a list of object data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simpleSpeakerData` is passed to `Object.keys(simpleSpeakerData)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()` is then called on the returned keys from `Object.keys()`. This iterates
    over the key arrays that are returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now able to access the individual key and values of the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{simpleSpeakerData[key].name}` points to the name property value of the object
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the output of iterating over complex object data
    in React using JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Screenshot showing object data](img/Figure_5.8_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Screenshot showing object data
  prefs: []
  type: TYPE_NORMAL
- en: Looping over objects in JSX using `Object.keys()`, `Object.values()`, and `Object.entries()`
    is essential and involves iterating through the properties of an object to render
    JSX elements dynamically. This approach allows you to generate lists, tables,
    or other UI components that display data from objects in a structured manner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extensively discussed JSX in React. We delved into explaining
    what JSX is all about as well as the rules guiding the use of JSX in React. Then,
    we discussed the DOM and how VDOM in React abstracts the native browser DOM for
    React developers to build a more efficient, cross-browser user interface. JSX
    improves DOM interaction in React applications and also optimizes the speed for
    elements in React components to render.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined event handling in React and the use of the `SyntheticEvent`
    event wrapper in React in handling event operations in React. We discussed the
    subtle differences between JSX and HTML and the rules guiding the usage in React.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with use cases, we discussed how you can display lists in a React project
    and how `key` and `id` are used in managing list items uniquely. We also looked
    at how you can iterate over objects and display complex nested objects in React.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to handle form operations in depth
    and routing in React web applications.
  prefs: []
  type: TYPE_NORMAL
