- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: JSX and Displaying Lists in React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 和在 React 中显示列表
- en: '**Componentization** is a design paradigm in React application development.
    As a developer and React enthusiast, you will develop tons of useful components.
    You will need a combination of units to provide interfaces the user can interact
    with seamlessly.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件化**是 React 应用程序开发中的设计范式。作为一名开发者和 React 热衷者，你将开发大量有用的组件。你需要一组单元的组合来提供用户可以无缝交互的界面。'
- en: '**JavaScript Syntax Extension** (**JSX**) is an innovative approach to describing
    the **User Interface** (**UI**) for modern web applications. In this chapter,
    we are going to take a clinical dive into why JSX is one of the core requirements
    in developing production-ready React applications. In addition, you will learn
    how to display lists in React.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 语法扩展**（**JSX**）是描述现代网络应用程序用户界面（**UI**）的一种创新方法。在本章中，我们将深入探讨为什么
    JSX 是开发生产就绪的 React 应用程序的核心要求之一。此外，你还将学习如何在 React 中显示列表。'
- en: We use lists in virtually every web application development project we undertake,
    and knowing how to render lists is a required skill set for web developers. HTML
    and JavaScript, as languages of the web, have been with us from the beginning,
    helping web developers build web applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几乎每一个网络应用程序开发项目中都会使用列表，了解如何渲染列表是网络开发者所需技能集的一部分。HTML 和 JavaScript 作为网络的语言，从一开始就伴随着我们，帮助网络开发者构建网络应用程序。
- en: However, in recent times, the demand for complex and highly rich interactive
    web applications has necessitated using JSX as a creative approach for building
    user interface components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在最近一段时间，对复杂且高度丰富的交互式网络应用程序的需求促使使用 JSX 作为构建用户界面组件的一种创新方法。
- en: In this chapter, we are going to understand what JSX is about and how it is
    different from HTML. We will use JSX to describe the user interfaces we will be
    building in this chapter. Then, we will examine how we handle event operations
    in React.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 JSX 是什么以及它与 HTML 的不同之处。我们将使用 JSX 来描述本章中将要构建的用户界面。然后，我们将检查我们在 React
    中如何处理事件操作。
- en: As a React developer, you will consume both internal and external API data for
    your user consumption. By the end of this chapter, you will be able to display
    list objects to your users, handle common events in React, and render lists with
    loop functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 React 开发者，你将为用户消费内部和外部 API 数据。到本章结束时，你将能够向用户显示列表对象，处理 React 中的常见事件，并使用循环函数渲染列表。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is JSX?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 是什么？
- en: JSX versus HTML
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 与 HTML 的比较
- en: How JSX abstracts JavaScript
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 如何抽象 JavaScript
- en: Event handling in React
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 中的事件处理
- en: Displaying lists in React
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中显示列表
- en: Nesting lists in JSX
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX 中的嵌套列表
- en: Looping over objects in JSX
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JSX 中遍历对象
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter05)。
- en: What is JSX?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 是什么？
- en: You’ve already been introduced to and seen some JSX. Let’s discuss in more depth
    what JSX means as a new approach to adding HTML to JavaScript when designing user
    interfaces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经接触并看到了一些 JSX。让我们更深入地讨论 JSX 作为一种新方法，在设计和用户界面时将 HTML 添加到 JavaScript 中意味着什么。
- en: JSX is simply an XML-like syntax extension for JavaScript. JSX allows frontend
    developers to bake HTML elements with JavaScript. The effect of this mix is usually
    an impressive user-friendly interface. As we know, the main purpose of React is
    to provide us with a set of APIs for building user interfaces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 简单来说是一种类似于 XML 的 JavaScript 语法扩展。JSX 允许前端开发者将 HTML 元素与 JavaScript 结合使用。这种混合的效果通常是一个令人印象深刻的用户友好界面。正如我们所知，React
    的主要目的是为我们提供一组用于构建用户界面的 API。
- en: With little or no controversy, React has been up to the challenge, becoming
    the leading shining gem in the jungle of frontend JavaScript libraries and frameworks.
    React powers large-scale, production-grade web and mobile applications with an
    improved user experience.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有争议，React 已经接受了这一挑战，成为前端 JavaScript 库和框架丛林中的领先璀璨宝石。React 通过改进的用户体验，为大规模、生产级别的网络和移动应用程序提供动力。
- en: 'Interestingly, React is achieving this improved efficiency and performance
    with the same set of tools, languages, and techniques we are already familiar
    with: HTML and JavaScript. React leverages HTML elements and JavaScript functions
    to build reusable UI components. JSX evolved as an approach that allows us to
    mix markup and display logic for building React components.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，React 正在使用我们已熟悉的相同工具、语言和技术（HTML 和 JavaScript）来实现这种改进的效率和性能：React 利用 HTML
    元素和 JavaScript 函数来构建可重用的 UI 组件。JSX 作为一个允许我们混合标记和显示逻辑以构建 React 组件的方法而发展起来。
- en: 'You can safely run JavaScript code as a JSX expression. Consider the following
    snippet of a simple React component to see some of the ways you can use JSX in
    React:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地将 JavaScript 代码作为 JSX 表达式运行。考虑以下简单的 React 组件片段，以了解您可以在 React 中使用 JSX 的几种方式：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s examine what is going on with this code snippet.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这段代码片段中正在发生的事情。
- en: 'The preceding code explains how to use JSX in React:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解释了如何在 React 中使用 JSX：
- en: '`import React from ''react''` is used to bring React into scope'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React from ''react''` 用于将 React 引入作用域'
- en: '`export function App()` describes a function component named `App()` that can
    be accessed by other components'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export function App()` 描述了一个名为 `App()` 的函数组件，该组件可以被其他组件访问'
- en: The `const speakerName` variable is declared and assigned a value of `John Holt`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明并赋值了 `const speakerName` 变量，其值为 `John Holt`
- en: 'The following part of the preceding code snippet depicts the JSX part of the
    `component` `App()` code:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下代码片段的前一部分描绘了 `component` `App()` 代码的 JSX 部分：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is a mix of HTML elements (`h2` and `div`) and a JavaScript
    expression inside curly braces (`{speakerName}`). This displays the text `John
    Holt` while `{5 + 5 }` displays the result of the sum of 5 + 5.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 HTML 元素（`h2` 和 `div`）和花括号内的 JavaScript 表达式（`{speakerName}`）的混合。这显示了文本
    `John Holt`，而 `{5 + 5}` 显示了 5 + 5 的和。
- en: Whatever JavaScript expression you have can be put inside a curly brace in JSX
    and it will return the expected valid JavaScript output. However, the browser
    doesn’t know what to do with JSX syntax by default; but with the help of the Babel
    compiler, JSX code is transformed into equivalent JavaScript syntax that the browser
    natively understands.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您有什么 JavaScript 表达式，都可以将其放在 JSX 中的花括号内，它将返回预期的有效 JavaScript 输出。然而，浏览器默认情况下不知道如何处理
    JSX 语法；但借助 Babel 编译器的帮助，JSX 代码被转换成浏览器原生理解的等效 JavaScript 语法。
- en: The JSX transpilation by Babel contributes significantly to factors that make
    React applications so brazenly fast. It doesn’t just transpile JSX codes into
    browser JavaScript; it optimizes as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 的 JSX 转译对使 React 应用程序如此快速的因素做出了重大贡献。它不仅将 JSX 代码转译成浏览器 JavaScript，而且还进行了优化。
- en: You can also see how the `<div className='App'>` attribute is used in JSX; the
    naming convention for the class attribute is important. We write it in camelCase
    format – `className` in React. The `className` attribute is assigned a value of
    `App`, which is used in the CSS file to add style to the component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到 `<div className='App'>` 属性在 JSX 中的使用；类属性的命名约定很重要。我们以驼峰式格式编写它 – React
    中的 `className`。`className` 属性被分配了一个值为 `App` 的值，该值在 CSS 文件中使用，以向组件添加样式。
- en: In addition, we need to understand that a high-level connection exists between
    JSX and the **Document Object Model** (**DOM**). The DOM is an object-oriented
    representation of a web document. It is a set of APIs that’s used to manipulate
    web documents that can be loaded on a web browser. A typical web application page
    represents a web document that DOM APIs use to maintain the DOM structure and
    content.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要理解 JSX 和 **文档对象模型** (**DOM**) 之间存在高级连接。DOM 是一个面向对象的网络文档表示。它是一组用于操作可以在网络浏览器上加载的
    Web 文档的 API。典型的 Web 应用程序页面代表一个 Web 文档，DOM API 使用它来维护 DOM 结构和内容。
- en: The DOM manipulation is usually done by JavaScript – a scripting language. You
    can use JavaScript objects to create, update, and remove HTML elements. The DOM
    manipulation is the bedrock of interactivity you see with most web applications.
    But React handles DOM differently and at best with some creativity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 操作通常由 JavaScript – 一种脚本语言来完成。您可以使用 JavaScript 对象来创建、更新和删除 HTML 元素。DOM 操作是大多数网络应用程序中交互性的基石。但
    React 对 DOM 的处理方式不同，并且具有一些创新性。
- en: The React team has been able to identify the challenges with DOM tree re-rendering
    on every HTML element operation (create, update, and delete), and decided to develop
    a **virtual DOM** (**VDOM**). VDOM is an abstraction of the native browser DOM
    that enables React applications to be fast and efficient and exhibit cross-browser
    compatibility.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: React团队能够识别出在每次HTML元素操作（创建、更新和删除）中对DOM树重新渲染的挑战，并决定开发一个**虚拟DOM**（**VDOM**）。VDOM是原生浏览器DOM的抽象，使得React应用程序能够快速高效，并表现出跨浏览器的兼容性。
- en: React components only re-render the changed node (`h1`, `div`, and `p` – all
    these represent nodes on HTML) of a DOM, rather than causing the entire web document
    to be re-rendered on a single node change.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: React组件只重新渲染DOM中变化的节点（`h1`、`div`和`p` – 所有这些在HTML中代表节点）而不是在单个节点变化时重新渲染整个Web文档。
- en: Next, we will discuss how JSX and HTML elements are used to design UI components
    and the inherent differences between JSX and HMTL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用JSX和HTML元素来设计UI组件，以及JSX和HTML之间的固有差异。
- en: JSX versus HTML
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX与HTML的比较
- en: '`React.createElement()` under the hood. JSX makes component interface development
    hassle-free while optimizing efficiency.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement()`的底层实现。JSX使得组件接口开发变得轻松，同时优化了效率。'
- en: HTML is the standard language for structuring the web. HTML elements power every
    web page you see on the internet. HTML syntax is easy to understand, and it is
    the language the browser understands natively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是构建Web的标准语言。HTML元素为你在互联网上看到的每个网页提供动力。HTML语法易于理解，它是浏览器原生理解的语言。
- en: 'The following table clearly states the subtle differences that exist between
    JSX and HTML for better understanding and usage in React applications:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下表清楚地说明了JSX和HTML之间存在的细微差异，以便更好地理解和在React应用程序中使用：
- en: '|  | **HTML** | **JSX** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  | **HTML** | **JSX** |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Native to the browser | HTML elements are native to the browser. | JSX is
    transpiled into JavaScript using Babel before browsers can understand its syntax.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 原生于浏览器 | HTML元素是浏览器原生的。 | JSX在使用Babel将其转换为JavaScript之前，浏览器才能理解其语法。 |'
- en: '| Attribute usage | You have flexibility regarding how you name your HTML attributes,
    though this is mostly in lowercase, such as `onmouseover`, `onclick`, `onsubmit`,
    `onload`, `onfocus`, and so on. | You must follow the camelCase rule in naming
    attributes in JSX and event references such as `onClick`, `onChange`, `onMouseOver`,
    and so on. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 属性使用 | 你在命名HTML属性方面有灵活性，尽管这通常是小写，如`onmouseover`、`onclick`、`onsubmit`、`onload`、`onfocus`等等。
    | 在JSX中命名属性和事件引用（如`onClick`、`onChange`、`onMouseOver`等）时，你必须遵循驼峰命名法规则。 |'
- en: '| The naming of the `class` and `for` attributes | You must use lowercase `class`
    when naming CSS classes and `for` when naming input labels in HTML. | In JSX,
    you must use `className` (camelCase) and `htmlFor` for input labels. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `class`和`for`属性命名 | 在HTML中命名CSS类时必须使用小写`class`，在命名输入标签时使用`for`。 | 在JSX中，你必须使用`className`（驼峰命名法）和`htmlFor`为输入标签。
    |'
- en: '| Handles JavaScript code | You must use the `<script>...</script>` script
    tag or an external JS file to add JavaScript to HTML. | In JSX, you can write
    JS expressions inside curly braces; for instance, `{ new` `Date().toString }`.
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 处理JavaScript代码 | 你必须使用`<script>...</script>`脚本标签或外部JS文件来向HTML添加JavaScript。
    | 在JSX中，你可以在花括号内编写JS表达式；例如，`{ new Date().toString }`。 |'
- en: '| Returns a single parent element | In HTML, you are permitted to return HTML
    elements without enclosing them in a single parent; for example:`<div > </``div>``<``p>...</p>``<``ul>...</ul>``<``span>...</span>`.All
    these tags can independently stay on a web page with enclosing tags. | In JSX,
    you must return a single parent element; otherwise, you will get JSX errors; for
    instance:`<div></div>` or a fragment tag, `<> </>`, must enclose all your HTML
    elements:`<``div>``<``p>...</p>``<``ul>...</ul>``</``div`Or`<>``<``p>...</p>``<``ul>...</ul>``</>`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 返回单个父元素 | 在HTML中，你可以返回HTML元素而不将其包含在单个父元素中；例如：`<div > </div><p>...</p><ul>...</ul><span>...</span>`。所有这些标签都可以独立地存在于网页上，带有封装标签。
    | 在JSX中，你必须返回一个单个父元素；否则，你会得到JSX错误；例如：`<div></div>`或一个片段标签`<> </>`必须包含你所有的HTML元素：`<div><p>...</p><ul>...</ul></div>`或`<>
    <p>...</p><ul>...</ul> </>` |'
- en: '| Self-closing tags | In HTML, you can have a self-closing tag without a forward
    slash; for example, `<br>`. | In JSX, you must add a forward slash to any self-closing
    tag; for example, `<``br />`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 自闭合标签 | 在HTML中，你可以有一个不带斜杠的自闭合标签；例如，`<br>`。 | 在JSX中，你必须给任何自闭合标签添加一个斜杠；例如，`<br
    />`。 |'
- en: Table 5.1 – Differences between JSX and HTML
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – JSX与HTML之间的差异
- en: JSX and HTML allow you to structure web content and enable users to interact
    with web application interfaces. As a React developer, you must be conversant
    with the inherent differences between HTML and JSX elements to avoid being red-flagged
    by the JSX compiler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSX和HTML允许你结构化网络内容，并使用户能够与网络应用程序界面进行交互。作为一名React开发者，你必须熟悉HTML和JSX元素之间的固有差异，以避免被JSX编译器标记为红旗。
- en: Next, we will discuss how JSX allows us to describe a UI with HTML-like tags
    while it leverages the power of JavaScript under the hood.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论JSX如何允许我们使用类似HTML的标签来描述UI，同时它利用了底层JavaScript的强大功能。
- en: How JSX abstracts JavaScript
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX如何抽象JavaScript
- en: Nowadays, coding React applications without JSX is not recommended, though it
    is possible. For instance, you can write a `React.createElement(component, props,
    ...children)` function to describe a UI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不使用JSX编写React应用程序不被推荐，尽管这是可能的。例如，你可以编写一个`React.createElement(component, props,
    ...children)`函数来描述UI。
- en: 'However, you can easily describe a button UI in JSX with the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用以下代码轻松地在JSX中描述一个按钮UI：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Writing the preceding code without JSX would require you to describe a button
    UI with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用JSX编写前面的代码，你需要使用以下代码来描述一个按钮UI：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Doing this in a large React project could lead to multiple issues, such as having
    to deal with more bugs in your code base and facing a steeper learning curve to
    become a code-savvy developer who could function optimally at writing this low-level
    code to describe a UI. However, with very little to disagree on, you would agree
    that JSX is a better route to toll rather than plain React-modified JavaScript
    at describing a UI component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型React项目中这样做可能会导致多个问题，例如需要处理代码库中的更多错误，并且需要面对更陡峭的学习曲线，以成为能够优化编写此底层代码来描述UI的熟练开发者。然而，尽管意见分歧很少，你可能会同意JSX是描述UI组件的更好途径，而不是使用纯React修改后的JavaScript。
- en: 'Let’s examine how JSX abstracts JavaScript in its data presentation by providing
    a syntactic creamy chocolate on top of a low-level React function: `React.createElement()`.
    This implies how React takes on the burden of converting JSX into JavaScript using
    Babel to make seamless DOM interaction possible.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在低级React函数`React.createElement()`之上提供语法糖来检查JSX如何在其数据表示中抽象JavaScript。这暗示了React如何通过Babel将JSX转换为JavaScript，以实现无缝的DOM交互。
- en: 'In `src/index.js`, update the file with the following snippet to see how you
    can write `React Conference 2024` to a screen without JSX:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/index.js`中，使用以下代码片段更新文件，以了解如何在不使用JSX的情况下将`React Conference 2024`写入屏幕：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code snippet, `React.createElement()` is a function call with
    three parameters: `div`, `{}`, and the expected output text of `React` `Conference
    2024`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`React.createElement()`是一个带有三个参数的函数调用：`div`、`{}`和预期的输出文本`React` `Conference
    2024`：
- en: The `div` parameter in the `React.createElement` function represents the type
    of HTML element we are creating. This could be any HTML element or tags (`h1`,
    `p`, `ul`, `li`, and so on). You could even add components as your first parameter.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`React.createElement`函数中的`div`参数代表我们正在创建的HTML元素的类型。这可以是任何HTML元素或标签（`h1`、`p`、`ul`、`li`等等）。你甚至可以将组件作为第一个参数添加。
- en: The empty curly brace parameter, `{}`, represents props. It could be an object
    or null.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空的括号参数`{}`代表props。它可以是对象或null。
- en: The third parameter represents what we want to see on the screen. This could
    be ordinary text or a child component.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数代表我们希望在屏幕上看到的内容。这可以是普通文本或子组件。
- en: 'In `src/app.js`, update the file with the following snippet that explains the
    use of JSX:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/app.js`中，使用以下代码片段更新文件，以解释JSX的使用：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding snippet shows the JSX constructs of the code that displays `React
    Conference 2024` – that is, `<div className='App'>`, `<h1>React Conference 2024</h1>`,
    and `</div>`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了显示`React Conference 2024`的JSX代码结构，即`<div className='App'>`、`<h1>React
    Conference 2024</h1>`和`</div>`。
- en: 'While these look like regular HTML elements, they are JSX expressions. Now,
    reset `index.js` as follows to describe a UI with JSX:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些看起来像常规的HTML元素，但它们是JSX表达式。现在，按照以下方式重置`index.js`以使用JSX描述UI：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the code with `npm start`; you will see the text **React Conference 2024**
    on your browser screen:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm start`运行代码；你将在浏览器屏幕上看到**React Conference 2024**文本：
- en: '![Figure 5.1 – Screenshot showing the JSX output](img/Figure_5.1_B18554.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 展示JSX输出的截图](img/Figure_5.1_B18554.jpg)'
- en: Figure 5.1 – Screenshot showing the JSX output
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 展示JSX输出的截图
- en: To summarize, JSX is a useful tool within the React community that allows developers
    to meet the presentational needs of components without a hardcore approach to
    DOM manipulation. It facilitates a smooth UI experience and rich interactivity
    for end users. With this, we have a fast, efficient, and independent wide range
    of browser-compatible web applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，JSX是React社区中的一个有用工具，它允许开发者在不进行严格的DOM操作的情况下满足组件的展示需求。它促进了用户界面的流畅体验和丰富的交互性。有了这个，我们就有了一个快速、高效且独立的广泛兼容浏览器的Web应用程序。
- en: Next, we will discuss event handling in React. Traditional event methods such
    as `onclick`, `onfocus`, `onblur`, and others are closely related to what we have
    in React with some subtle naming differences.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论React中的事件处理。传统的事件方法，如`onclick`、`onfocus`、`onblur`等，与React中的一些细微命名差异密切相关。
- en: We are going to discuss this and more to see how we can harness the knowledge
    covered in this chapter and add it to the skill set required to build an interactive
    conference web app project for this book.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这一点以及更多内容，以了解我们如何利用本章涵盖的知识，并将其添加到构建本书互动会议Web应用程序项目所需的技能集中。
- en: Event handling in React
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的事件处理
- en: React’s event system is another powerful feature shipped with React core APIs.
    It is called `SyntheticEvent`. As React developers, we will come across event
    handling daily in React application development projects. Handling events shouldn’t
    be new to you if you are familiar with the basics of JavaScript. You could add
    an event to HTML DOM using the browser-native approach.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: React的事件系统是React核心API提供的一个强大功能。它被称为`SyntheticEvent`。作为React开发者，我们在React应用程序开发项目中会每天遇到事件处理。如果你熟悉JavaScript的基础知识，处理事件对你来说不应该陌生。你可以使用浏览器原生方法向HTML
    DOM添加事件。
- en: 'Let’s have a glimpse at this code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个代码片段：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`<div id="root"> </div>` indicates the location where the DOM will inject the
    text we will create. The `div` element has an `id` attribute with a value of `root`
    passed into it. This helps the event objects know where text should appear. The
    `document.addEventListener()` method adds an event listener with two parameters:
    `click` and a callback function.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div id="root"> </div>`表示DOM将注入我们创建的文本的位置。`div`元素有一个`id`属性，其值为`root`。这有助于事件对象知道文本应该出现在哪里。`document.addEventListener()`方法使用两个参数添加一个事件监听器：`click`和一个回调函数。'
- en: 'When we click on a button, we fire an event. The event name is called click
    event. In this scenario, there is a `Post` message to click to fire an event:
    `<p><strong>Click here to see my message.</strong></p>`. Once this message is
    clicked, a callback function, the second parameter, is triggered and causes the
    `getElementById` window method to use the `id` attribute with a value of `root`
    from the `div` element to pass `innerHTML` the newly assigned text – that is,
    `This text is then added to the` `DOM tree!`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击一个按钮时，我们会触发一个事件。这个事件被称为点击事件。在这种情况下，有一个点击以触发事件的`Post`消息：`<p><strong>点击这里查看我的消息。</strong></p>`。一旦这个消息被点击，回调函数（第二个参数）就会被触发，并导致`getElementById`窗口方法使用`div`元素的`id`属性值`root`来传递`innerHTML`新分配的文本
    – 那就是添加到`DOM树中的文本！`
- en: 'In React, we have various events with a camelCase naming convention: `onClick`,
    `onChange`, `onInput`, `onInvalid`, `onReset`, `onSubmit`, `onFocus`, `onBlur`,
    `onToggle`, and others. You can find a whole list of events in the React documentation
    – **React** **SythenticEvents** (https://reactjs.org/docs/events.html)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，我们有各种遵循驼峰命名约定的事件：`onClick`、`onChange`、`onInput`、`onInvalid`、`onReset`、`onSubmit`、`onFocus`、`onBlur`、`onToggle`等。你可以在React文档中找到整个事件列表
    – **React** **合成事件**（https://reactjs.org/docs/events.html）
- en: 'Let’s dive into the following snippet to see how we can handle form events
    in React. This snippet illustrates the `onChange` form event:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入以下代码片段，看看我们如何在React中处理表单事件。此代码片段展示了`onChange`表单事件：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s closely examine this snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细检查这个片段：
- en: '`import React, {useState} from ''react''` makes the `useState` hook available
    to the `App()` component for state tracking.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import React, {useState} from ''react''`使`useState`钩子在`App()`组件中可用于状态跟踪。'
- en: The `const [username,setUsername]=useState("")` `const name,` **setName]=useState("")**
    and `const [email,setEmail]=useState("")` snippets allow us to have access to
    the states for username, email, and name. With `setUsername`, `setName`, and `setEmail`,
    we can track the new states for the variables. The initial states for all the
    variables are set to empty strings.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const [username,setUsername]=useState("")` `const name,` **setName]=useState("")**
    和 `const [email,setEmail]=useState("")` 这段代码片段使我们能够访问用户名、邮箱和姓名的状态。通过 `setUsername`、`setName`
    和 `setEmail`，我们可以跟踪变量的新状态。所有变量的初始状态都设置为空字符串。'
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding snippet, `handleSubmit()` is an event handler that accepts
    `e` as the event object. `e.preventDefault` prevents browser default behavior
    on form field submission. There won’t be a page refresh on form submission. `handleSubmit`
    is added to the form as an attribute to execute `alert()`to display the `username`,
    `name`, and `email` states on the screen.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`handleSubmit()` 是一个接受 `e` 作为事件对象的处理器。`e.preventDefault` 阻止表单字段提交时的浏览器默认行为。表单提交时不会刷新页面。`handleSubmit`
    被添加到表单中作为属性以执行 `alert()`，在屏幕上显示 `username`、`name` 和 `email` 的状态。
- en: In the input tags, `<input` `type="text" placeholder="Username"onChange=` **{(e)=>setUsername(e.target.value)}
    />**, the `onChange` event attribute is added to the input element. The `onChange`
    event has a callback function that accepts `e` as a parameter. `setUsername(e.target.values)`
    listens for a change event in the input field. The same `onChange` event callbacks
    are added to input tags for the name and email.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入标签 `<input type="text" placeholder="用户名"onChange={`(e)=>setUsername(e.target.value)}
    />` 中，向输入元素添加了 `onChange` 事件属性。`onChange` 事件有一个接受 `e` 作为参数的回调函数。`setUsername(e.target.values)`
    监听输入字段中的变化事件。同样，为姓名和邮箱的输入标签添加了相同的 `onChange` 事件回调。
- en: 'The `<p>Username: {username}</p>, <p>Name: {name}</p>, <p>Email: {email}</p>`
    snippet displays the current input text in the input form fields.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<p>用户名: {username}</p>，<p>姓名: {name}</p>，<p>邮箱: {email}</p>` 这段代码片段显示了输入表单字段中的当前输入文本。'
- en: 'The following screenshot shows the effect of event handling in forms:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了表单中事件处理的效果：
- en: '![Figure 5.2 – Screenshot showing the effects of event handlers on form fields](img/Figure_5.2_B18554.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 屏幕截图显示事件处理器对表单字段的影响](img/Figure_5.2_B18554.jpg)'
- en: Figure 5.2 – Screenshot showing the effects of event handlers on form fields
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 屏幕截图显示事件处理器对表单字段的影响
- en: To summarize, event handling in React is managed by a cross-browser wrapper
    called `SyntheticEvent`. We pass event handlers as instances to `SyntheticEvent`
    in React applications. It is best practice to prevent the default browser behavior
    by using `preventDefault()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，React中的事件处理由一个跨浏览器的包装器 `SyntheticEvent` 管理。我们在React应用程序中将事件处理器作为实例传递给 `SyntheticEvent`。最佳实践是使用
    `preventDefault()` 来防止默认的浏览器行为。
- en: Next, we will discuss how to use lists in React applications. A list is a common
    feature in any enterprise web application. Let’s see how React helps us improve
    the user experience with a well-thought-out UI list design.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在React应用程序中使用列表。列表是任何企业级网络应用程序中的常见功能。让我们看看React如何通过精心设计的UI列表来提升用户体验。
- en: Displaying lists in React
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中显示列表
- en: Most web applications we see around today use list components in describing
    a user interface. In any complex web application project or production-grade application,
    you will see the list feature, often used in data presentation. In React, you
    can use a list to display your component data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天看到的绝大多数网络应用程序在描述用户界面时都会使用列表组件。在任何复杂的网络应用程序项目或生产级应用程序中，你都会看到列表功能，通常用于数据展示。在React中，你可以使用列表来展示你的组件数据。
- en: We are going to use mocked data to showcase how you can use `map()` to fetch
    a list of data items. We will also discuss the essence of the `key` and `id` attributes
    in React list management. The GitHub repository for this book’s project (https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/tree/main/Chapter-05/06/frontend)
    contains the mocked conference speakers `data` source; you can find `images` in
    the public folders and `css` (`index.css`) inside the `src` folder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用模拟数据来展示如何使用 `map()` 获取数据项列表。我们还将讨论React列表管理中 `key` 和 `id` 属性的本质。本书项目的GitHub仓库（https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/tree/main/Chapter-05/06/frontend）包含模拟的会议演讲者
    `data` 源；你可以在公共文件夹中找到 `images`，在 `src` 文件夹内找到 `css` (`index.css`)。
- en: However, the backend section of this book ([*Chapter 9*](B18554_09.xhtml#_idTextAnchor186),
    *API Development and Documentation*) will explain how we can pull this data from
    an API endpoint developed in Flask.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书的后端部分（[*第 9 章*](B18554_09.xhtml#_idTextAnchor186)，*API 开发和文档*)将解释我们如何从
    Flask 开发的 API 端点中拉取这些数据。
- en: 'This `url` leads you to the speakers page – `http://localhost:3000/speakers`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `url` 将您带到演讲者页面 – `http://localhost:3000/speakers`：
- en: '![Figure 5.3 – Screenshot showing the list of conference speakers pulled from
    a data source](img/Figure_5.3_B18554.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 屏幕截图显示从数据源拉取的会议演讲者列表](img/Figure_5.3_B18554.jpg)'
- en: Figure 5.3 – Screenshot showing the list of conference speakers pulled from
    a data source
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 屏幕截图显示从数据源拉取的会议演讲者列表
- en: 'Let’s examine the code snippet for showing a list of speakers working with
    a couple of components:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查显示演讲者列表的代码片段，使用几个组件：
- en: 'Inside `src/components`, create `SpeakersCard/SpeakersCard.jsx` and add the
    following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/components` 目录内创建 `SpeakersCard/SpeakersCard.jsx` 并添加以下代码片段：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding snippet, we created a `SpeakersCard` component that accepts
    an object with four properties: `name`, `jobTitle`, `company`, and `profileImg`.
    These properties will be passed to the component as props by the `SpeakersPage`
    component (parent component) that will be created shortly.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个 `SpeakersCard` 组件，该组件接受一个包含四个属性的对象：`name`、`jobTitle`、`company`
    和 `profileImg`。这些属性将通过即将创建的 `SpeakersPage` 组件（父组件）作为 props 传递给组件。
- en: The `SpeakersCard` component’s return statement contains JSX, which represents
    the structure of the rendered output.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeakersCard` 组件的返回语句包含 JSX，它表示渲染输出的结构。'
- en: We need this `SpeakersCard` component to encapsulate and represent the visual
    appearance and information display for a speaker entity for the conference web
    app. By creating this component, we can reuse it throughout the application whenever
    we need to display information about the speaker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个 `SpeakersCard` 组件来封装和表示会议网页应用中演讲者实体的视觉外观和信息显示。通过创建这个组件，我们可以在需要显示演讲者信息时，在整个应用程序中重用它。
- en: Now, inside `src/pages`, create `SpeakersPage/SpeakersPage.js`. The `SpeakersPage`
    component will be used to display a list of speakers by rendering the `SpeakersCard`
    component for each speaker in `speakerList`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `src/pages` 目录内创建 `SpeakersPage/SpeakersPage.js`。`SpeakersPage` 组件将用于通过为
    `speakerList` 中的每个演讲者渲染 `SpeakersCard` 组件来显示演讲者列表。
- en: 'Add the following code to `SpeakersPage.js`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `SpeakersPage.js`：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding snippet, we import dependencies to make the page functionalities
    work:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们导入依赖项以使页面功能正常工作：
- en: '`import SpeakersCard from ''../../components/SpeakersCard/SpeakersCard''`:
    This code line imports the `SpeakersCard` component from the `SpeakersCard` directory
    within the components directory. The `../../` notation is used to navigate to
    the appropriate directory level.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import SpeakersCard from ''../../components/SpeakersCard/SpeakersCard''`：此代码行从组件目录中的
    `SpeakersCard` 目录导入 `SpeakersCard` 组件。使用 `../../` 符号导航到适当的目录级别。'
- en: '`import speakerList from ''../../data/SpeakerList''`: This code line imports
    the `speakerList` data from the `SpeakerList.js` file located in the data directory.
    You can find the data file in the GitHub repository for this chapter. This data
    contains an array of objects, each representing a speaker with properties such
    as `name`, `jobTitle`, `company`, and `profileImg`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import speakerList from ''../../data/SpeakerList''`：此代码行从位于数据目录中的 `SpeakerList.js`
    文件导入 `speakerList` 数据。您可以在本章的 GitHub 仓库中找到数据文件。此数据包含一个对象数组，每个对象代表一个演讲者，具有 `name`、`jobTitle`、`company`
    和 `profileImg` 等属性。'
- en: Then, we add `<SpeakersCard ... />`. This code line renders the `SpeakersCard`
    component and passes the necessary props (`name`, `jobTitle`, `company`, and `profileImg`)
    for each speaker from `speakerList`. The `key={speaker.id}` prop is added to each
    `SpeakersCard` component. The `key` prop helps React efficiently update and re-render
    components when the list changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加 `<SpeakersCard ... />`。此代码行渲染 `SpeakersCard` 组件，并将每个演讲者从 `speakerList`
    中的必要 props (`name`、`jobTitle`、`company` 和 `profileImg`) 传递。每个 `SpeakersCard` 组件都添加了
    `key={speaker.id}` props。`key` props 帮助 React 在列表更改时高效地更新和重新渲染组件。
- en: '`SpeakersPage` also includes `header`, `breadcrumb navigation`, and `footer`
    components to provide a complete layout for the speakers’ section. The codes for
    the `Header`, `Breadcrumb`, and `Footer` components can be found in this chapter’s
    GitHub repository.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpeakersPage` 还包括 `header`、`面包屑导航` 和 `footer` 组件，为演讲者部分提供完整的布局。`Header`、`Breadcrumb`
    和 `Footer` 组件的代码可以在本章的 GitHub 仓库中找到。'
- en: Next, we will examine how we can follow React best practices in dealing with
    list items by uniquely identifying the items in a list with a key.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查如何通过使用键唯一标识列表中的项目来遵循 React 的最佳实践处理列表项。
- en: Using key and id in JSX
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 JSX 中使用键和 id
- en: The **key** in React list items is a unique identifier of the state of items
    in a list. We use a key to track items in the list that have been changed, added,
    or removed. It is usually expected to be a unique item in a list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: React 列表项中的 **key** 是列表中项目状态的唯一标识符。我们使用键来跟踪列表中已更改、已添加或已删除的项目。通常期望它是一个列表中的唯一项。
- en: 'Take a look at the object array we used in the preceding example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们前面示例中使用到的对象数组：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `id` attribute in this array should be a unique number. This allows us to
    track object data states appropriately. We used the `{speaker.id}` ID as the value
    for the key attribute in the preceding `speakersList` example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此数组中的 `id` 属性应该是一个唯一的数字。这使我们能够适当地跟踪对象数据状态。我们在前面的 `speakersList` 示例中使用了 `{speaker.id}`
    ID 作为 `key` 属性的值。
- en: We will now delve into nested lists in JSX and learn how to use a nested list
    in React to handle complex data structures.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入 JSX 中的嵌套列表，并学习如何在 React 中使用嵌套列表来处理复杂的数据结构。
- en: Nesting lists in JSX
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 中的嵌套列表
- en: 'As mentioned earlier, lists are a critical component of most web applications.
    Lists are often used to structure data and organize information neatly. We are
    familiar with some of the list clichés in web development: *a to-do list*, *a
    task list*, and even *a menu list*. All these lists can become complicated, depending
    on the data structure and how you are expected to present list items to end users.
    Dealing with lists in a React application requires an understanding of how you
    can handle data that comes in the form of an array of objects.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，列表是大多数 Web 应用程序的关键组件。列表通常用于结构化数据和整齐地组织信息。我们对 Web 开发中的一些列表陈词滥调很熟悉：*待办事项列表*、*任务列表*，甚至是
    *菜单列表*。所有这些列表都可能变得复杂，这取决于数据结构和您期望如何向最终用户展示列表项。在 React 应用程序中处理列表需要理解如何处理以对象数组形式出现的数据。
- en: In this section, we will learn how to render nested lists of items in JSX in
    React applications. You are going to see complex nested data structure like this
    and even more coming from your API data sources, so having an understanding of
    nested lists will make React applications that contain complex data easier to
    handle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在 React 应用程序中渲染 JSX 中的嵌套项目列表。您将看到这样的复杂嵌套数据结构，以及更多来自您的 API 数据源的结构，因此了解嵌套列表将使包含复杂数据的
    React 应用程序更容易处理。
- en: The following code snippet displays a list of nested web technology stack items
    in a component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个组件中嵌套的 Web 技术栈项目列表。
- en: 'Edit `App.js` inside `src/App.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/App.js` 内编辑 `App.js`：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, what’s happening in this code? We are dealing with a named nested list
    of object data called `webStacksData`, which can be found in the GitHub repository
    for this book:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这段代码中发生了什么？我们正在处理一个名为 `webStacksData` 的命名嵌套对象数据列表，该列表可以在本书的 GitHub 仓库中找到：
- en: The data is imported into scope with `import {webStacksData}` from `"./data/webStacksData";`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据通过 `import {webStacksData}` from `"./data/webStacksData";` 引入作用域。
- en: We also imported the `WebStacks` components into scope.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还引入了 `WebStacks` 组件到作用域中。
- en: The `webStacksData.map` function iterates over each item in the `webStacksData`
    array, creating a new `WebStacks` component for each item. The `key` prop is set
    to the `id` property of each item to help React efficiently update the list when
    needed. For each item in the `webStacksData` array, a `WebStacks` component is
    rendered with the `item` prop set to the current `item` from the array.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webStacksData.map` 函数遍历 `webStacksData` 数组中的每个项目，为每个项目创建一个新的 `WebStacks` 组件。`key`
    属性设置为每个项目的 `id` 属性，以帮助 React 在需要时高效地更新列表。对于 `webStacksData` 数组中的每个项目，都会渲染一个 `WebStacks`
    组件，并将 `item` 属性设置为来自数组的当前 `item`。'
- en: 'Let’s create a component called `WebStacks` to see the inner working of the
    component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `WebStacks` 的组件来查看组件的内部工作原理：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `WebStacks` component takes props items. In the component body function,
    we check to see whether the parent list items exist and whether it has child items.
    We then invoke `map()` to recursively iterate over the list items with valid child
    list items.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This `<li>{item.name}{children}</li>` returns the name of the list items and
    all the children. Next, we are going to see how you can loop through objects in
    React and display the output in JSX.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Looping over objects in JSX
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looping through complex data objects is part of what experienced React developers
    need to know how to handle effortlessly. You will undoubtedly encounter scenarios
    where you will have to work with both simple and nested object data from your
    API endpoints to extract useful data for your application. In this section, we
    are going to understand how to seamlessly iterate over data objects in an application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, objects are not iterable. You simply can’t loop over the object
    properties with the `for ... of` syntax. `Object.Keys()` is one of the in-built
    standard object methods used to loop over object data in JavaScript. However,
    in ES2017, new object methods were added that can be used to loop over object
    properties: `Object.values()` and `Object.entries()`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly examine each of these methods and learn how to use them with object
    data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the object data to loop over and name it `speakersData`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we will examine a variety of techniques that are used to efficiently iterate
    over object properties, allowing you to access and manipulate data within objects
    using methods such as `Object.keys()`, `Object.values()`, and `Object.entries()`.
    We will briefly delve into each of these techniques, starting with `Object.keys()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Using Object.keys()
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Object.keys` method returns an array of object’s keys. As you know, objects
    contain key and value pairs, so `Object.keys()` will return arrays of keys/properties.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pass in our data object as a parameter in the following code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will get the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Screenshot showing the effect of using the Objects.keys() method](img/Figure_5.4_B18554.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Screenshot showing the effect of using the Objects.keys() method
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the array of keys. You can retrieve the values of the key
    with a loop function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following screenshot shows the keys and values of the object data:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Screenshot showing object keys and values](img/Figure_5.5_B18554.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Screenshot showing object keys and values
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Later, you can invoke `map()` to retrieve the values of the keys in a React
    component. This will be explained later in this section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to use `Object.values()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Using Object.values()
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Object.values()` method returns an array of object property values:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This returns only the properties values without keys, thus making it less useful
    in a use case where keys and values are needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Screenshot showing the effect of using the Objects.values()
    method](img/Figure_5.6_B18554.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Screenshot showing the effect of using the Objects.values() method
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the last technique we can use to loop over object data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Using Object.entries()
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Object.entries()` method returns an array of object key-value pairs –
    `[key, value]`. Looping over an object with `Object.entries()` is easier with
    the `[key value]` pair. For instance, consider the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following screenshot shows the output of using `Object.entries()` on object
    data:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Screenshot showing the effect of using the Objects.entries()
    method](img/Figure_5.7_B18554.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Screenshot showing the effect of using the Objects.entries() method
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: We can see that 2D arrays are returned with keys and values of object properties.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Example of looping with Object.keys
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to work with a data object that contains useful speakers’
    information with an object data format. It can be found in this book’s project
    repository on GitHub (https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-05/data/objSpeakersData.js)
    and displays the output in a React component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code iterates over the `speakers` object data and displays the
    output in JSX:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code is explained as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`import {simpleSpeakerData} from ''../../data/objSpeakersData''` brings our
    data into scope so that it can be used in the code.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we declare a `Speakers` component, which returns a list of object data.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simpleSpeakerData` is passed to `Object.keys(simpleSpeakerData)`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()` is then called on the returned keys from `Object.keys()`. This iterates
    over the key arrays that are returned.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now able to access the individual key and values of the object.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{simpleSpeakerData[key].name}` points to the name property value of the object
    data.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the output of iterating over complex object data
    in React using JSX:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Screenshot showing object data](img/Figure_5.8_B18554.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Screenshot showing object data
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Looping over objects in JSX using `Object.keys()`, `Object.values()`, and `Object.entries()`
    is essential and involves iterating through the properties of an object to render
    JSX elements dynamically. This approach allows you to generate lists, tables,
    or other UI components that display data from objects in a structured manner.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extensively discussed JSX in React. We delved into explaining
    what JSX is all about as well as the rules guiding the use of JSX in React. Then,
    we discussed the DOM and how VDOM in React abstracts the native browser DOM for
    React developers to build a more efficient, cross-browser user interface. JSX
    improves DOM interaction in React applications and also optimizes the speed for
    elements in React components to render.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We also examined event handling in React and the use of the `SyntheticEvent`
    event wrapper in React in handling event operations in React. We discussed the
    subtle differences between JSX and HTML and the rules guiding the usage in React.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了 React 中的事件处理以及如何使用 `SyntheticEvent` 事件包装器来处理 React 中的事件操作。我们讨论了 JSX 和
    HTML 之间的细微差别以及指导 React 中使用的规则。
- en: Finally, with use cases, we discussed how you can display lists in a React project
    and how `key` and `id` are used in managing list items uniquely. We also looked
    at how you can iterate over objects and display complex nested objects in React.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过实际案例讨论了如何在 React 项目中显示列表，以及如何使用 `key` 和 `id` 来唯一管理列表项。我们还探讨了如何在 React
    中遍历对象以及显示复杂的嵌套对象。
- en: In the next chapter, we will discuss how to handle form operations in depth
    and routing in React web applications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入讨论如何在 React 网络应用程序中处理表单操作和路由。
