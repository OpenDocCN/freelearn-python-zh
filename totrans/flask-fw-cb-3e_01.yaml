- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Flask Configurations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask 配置
- en: This introductory chapter will help us understand the different ways **Flask**
    can be configured to suit the various needs of a project. Flask is “*The Python
    micro framework for building web applications*” (pallets/Flask, [https://github.com/pallets/flask](https://github.com/pallets/flask)).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这章入门指南将帮助我们了解 Flask 可以以不同的方式配置，以满足项目的各种需求。Flask 是 “*The Python micro framework
    for building web applications*” (pallets/Flask, [https://github.com/pallets/flask](https://github.com/pallets/flask))。
- en: So, why is Flask called a **microframework**? Does this mean Flask lacks functionality,
    or that it’s mandatory for the complete code of your web application to be contained
    in a single file? Not really! The term microframework simply refers to the fact
    that Flask aims to keep the core of its framework small but highly extensible.
    This makes writing applications or extensions both easy and flexible and gives
    developers the power to choose the configurations they want for their application
    without imposing any restrictions on the choice of database, templating engine,
    admin interface, and so on. In this chapter, you will learn several ways to set
    up and configure Flask.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 Flask 被称为 **microframework**？这难道意味着 Flask 缺乏功能，或者意味着您的网络应用程序的完整代码必须包含在一个文件中？并非如此！microframework
    这个术语仅仅指的是 Flask 旨在保持其框架核心小而高度可扩展。这使得编写应用程序或扩展既容易又灵活，并赋予开发者选择他们希望为应用程序使用的配置的能力，而不对数据库、模板引擎、管理界面等选择施加任何限制。在本章中，您将学习几种设置和配置
    Flask 的方法。
- en: Important information
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: This whole book uses *Python 3* as the default version of Python. Python 2 lost
    its support on December 31, 2019, and is therefore not supported in this book.
    It is recommended that you use Python 3 while learning from this book, as many
    of the recipes might not work on Python 2.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书整个使用 *Python 3* 作为 Python 的默认版本。Python 2 在 2019 年 12 月 31 日停止了支持，因此本书不支持
    Python 2。建议您在学习本书时使用 Python 3，因为许多配方可能在 Python 2 上无法工作。
- en: Likewise, while writing this book, Flask 2.2.x was the latest version. Although
    a lot of code in this book can work on earlier versions of Flask, it is recommended
    that you use versions 2.2.x and above.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在编写本书时，Flask 2.2.x 是最新版本。尽管本书中的许多代码可以在 Flask 的早期版本上运行，但建议您使用 2.2.x 及以上版本。
- en: 'Getting started with Flask takes just a couple of minutes. Setting up a simple
    *Hello World* application is as easy as pie. Simply create a file, such as `app.py,`
    in any location on your computer that can access `python` or `python3` that contains
    the following script:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Flask 只需几分钟。设置一个简单的 *Hello World* 应用程序就像做饼一样简单。只需在您的计算机上任何可以访问 `python`
    或 `python3` 的位置创建一个文件，例如 `app.py`，然后包含以下脚本：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, Flask needs to be installed; this can be done via `pip` or `pip3`. You
    may have to use `sudo` on a Unix-based machine if you run into access issues:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要安装 Flask；这可以通过 `pip` 或 `pip3` 完成。如果您遇到访问问题，可能需要在基于 Unix 的机器上使用 `sudo`：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: The code and Flask installation example here is just intended to demonstrate
    the ease with which Flask can be used. To set up a proper development environment,
    follow the recipes in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的代码和 Flask 安装示例只是为了展示 Flask 可以多么容易地使用。要设置适当的开发生态，请遵循本章中的配方。
- en: 'The preceding snippet is a complete Flask-based web application. Here, an instance
    of the imported `Flask` class is a `app` in this code becomes our WSGI application,
    and as this is a standalone module, we set the `__name__` string to `''__main__''`.
    If we save this in a file called `app.py`, then the application can simply be
    run using the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个完整的基于 Flask 的网络应用程序。在这里，导入的 `Flask` 类的实例在这个代码中成为 `app`，它成为我们的 WSGI
    应用程序，并且由于这是一个独立模块，我们将 `__name__` 字符串设置为 `'__main__'`。如果我们将其保存为名为 `app.py` 的文件，那么应用程序可以通过以下命令简单地运行：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if we head over to our browser and type `http://127.0.0.1:5000/`, we can
    see our application running.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开浏览器并输入 `http://127.0.0.1:5000/`，我们就可以看到我们的应用程序正在运行。
- en: 'Alternatively, the application can be run by using `flask run` or Python’s
    `-m` switch with Flask. While following this approach, the last two lines of `app.py`
    can be skipped. Note that the following commands work only if there is a file
    named `app.py` or `wsgi.py` in the current directory. If not, then the file containing
    the `app` object should be exported as an environment variable, namely `FLASK_APP`.
    As a best practice, this should be done in either case:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过使用 `flask run` 或 Python 的 `-m` 开关与 Flask 来运行应用程序。在遵循此方法时，可以跳过 `app.py`
    的最后两行。请注意，以下命令仅在当前目录中存在名为 `app.py` 或 `wsgi.py` 的文件时才有效。如果没有，则包含 `app` 对象的文件应作为环境变量导出，即
    `FLASK_APP`。作为最佳实践，在两种情况下都应这样做：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, if you decide to use the `-m` switch, it will look as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你决定使用 `-m` 开关，它将如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Never save your application file as `flask.py`; if you do, it will conflict
    with Flask itself while importing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将你的应用程序文件保存为 `flask.py`；如果你这样做，在导入时它将与 Flask 本身冲突。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Setting up our environment with `virtualenv`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `virtualenv` 设置我们的环境
- en: Handling basic configurations
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基本配置
- en: Configuring class-based settings
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置基于类的设置
- en: Organizing static files
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织静态文件
- en: Being deployment-specific with the `instance` folder
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `instance` 文件夹进行特定于部署的操作
- en: Compositions of views and models
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图和模型的组合
- en: Creating a modular web app with blueprints
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝图创建模块化 Web 应用程序
- en: Making a Flask app installable using `setuptools`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `setuptools` 使 Flask 应用程序可安装
- en: Technical requirements
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Working with Flask and **Python** in general is pretty easy and does not require
    a lot of dependencies and configurations. For most of the chapters in this book,
    all the required packages shall be mentioned in the relevant recipes. I will mention
    more specific requirements in relevant chapters. In general, you will need the
    following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，与 Flask 和 **Python** 一起工作相当简单，不需要很多依赖项和配置。在本书的大部分章节中，所有必需的软件包都将在相关食谱中提及。我将在相关章节中提及更具体的要求。一般来说，您需要以下内容：
- en: A decent computer, preferably with a *UNIX*-based OS such as *Linux* or *macOS*.
    You can also use Windows, which would require some additional setup, but that
    is out of the scope of this book.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台不错的计算机，最好是基于 *UNIX* 的操作系统，如 *Linux* 或 *macOS*。您也可以使用 Windows，但这需要一些额外的设置，但这本书的范围之外。
- en: A code editor of choice as the IDE. I use *Vim* and *Visual Studio Code* but
    anything will work, so long as it supports *Python*.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个代码编辑器作为 IDE。我使用 *Vim* 和 *Visual Studio Code*，但任何支持 *Python* 的编辑器都可以，只要它支持即可。
- en: A good internet connection as you will be downloading the packages and their
    dependencies.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个良好的互联网连接，因为您将下载软件包及其依赖项。
- en: All the code is freely available on GitHub at [https://github.com/PacktPublishing/Flask-Framework-Cookbook-Third-Edition](https://github.com/PacktPublishing/Flask-Framework-Cookbook-Third-Edition).
    This repository on GitHub contains the code for all the chapters in this book,
    segregated into corresponding folders.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码均可在 GitHub 上免费获取，网址为 [https://github.com/PacktPublishing/Flask-Framework-Cookbook-Third-Edition](https://github.com/PacktPublishing/Flask-Framework-Cookbook-Third-Edition)。此
    GitHub 仓库包含本书所有章节的代码，分别存放在相应的文件夹中。
- en: Setting up a virtual environment
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置虚拟环境
- en: Flask can be simply installed using `pip`/`pip3` or `easy_install` globally,
    but it’s preferable to set up an application environment using `venv` manages
    this in separate environments and does not let the incorrect version of any library
    affect any application. In this recipe, we will learn how to create and manage
    these environments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 可以简单地使用 `pip`/`pip3` 或 `easy_install` 在全局范围内安装，但最好使用 `venv` 设置应用程序环境，它将管理在单独的环境中，并且不会让任何库的不正确版本影响任何应用程序。在本食谱中，我们将学习如何创建和管理这些环境。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`venv` module to create virtual environments. So, simply create a new environment
    called `my_flask_env` (or any other name of your choice) inside the folder of
    your choice where you want your development environment to live. This will create
    a new folder with the same name, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `venv` 模块创建虚拟环境。因此，只需在您选择的文件夹中创建一个名为 `my_flask_env`（或您选择的任何其他名称）的新环境即可，您希望您的开发环境所在的位置。这将创建一个具有相同名称的新文件夹，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the following commands from inside the `my_flask_env` folder:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `my_flask_env` 文件夹内部运行以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will activate our environment and install `flask` inside it. Now, we can
    do anything with our application within this environment, without affecting any
    other Python environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将激活我们的环境并在其中安装`flask`。现在，我们可以在该环境中对应用程序进行任何操作，而不会影响任何其他Python环境。
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'So far, we have used `pip3 install flask` multiple times. As its name suggests,
    the command refers to the installation of Flask, just like any Python package.
    If we look a bit deeper into the process of installing Flask via `pip3`, we will
    see that several packages are installed. The following is an outline of the package
    installation process of Flask:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经多次使用`pip3 install flask`。正如其名所示，该命令指的是安装Flask，就像安装任何Python包一样。如果我们稍微深入到通过`pip3`安装Flask的过程，我们会看到安装了几个包。以下是Flask包安装过程的概述：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we look carefully at the preceding snippet, we will see that multiple packages
    have been installed. Of these, five packages, namely, `Werkzeug`, `Jinja2`, `click`,
    `itsdangerous`, and `markupsafe`, are the packages on which Flask depends, and
    it will not work if any of them are missing. Others are sub-dependencies that
    are needed for the dependencies of Flask to work.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看前面的代码片段，我们会看到已经安装了多个包。在这些包中，有五个包，即`Werkzeug`、`Jinja2`、`click`、`itsdangerous`和`markupsafe`，是Flask所依赖的包，如果其中任何一个缺失，Flask将无法工作。其他的是Flask依赖项所需的子依赖项。
- en: There’s more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Before `venv` was introduced in *Python 3.3*, `virtualenv` was the standard
    library used to create and manage virtual environments. `venv` is a subset of
    `virtualenv` and misses out on the advanced features that `virtualenv` provides.
    For the sake of simplicity and to stay in the context of this book, I will use
    `venv`, but you are free to explore `virtualenv` and `virtualenvwrapper`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在`venv`在*Python 3.3*中引入之前，`virtualenv`是用于创建和管理虚拟环境的标准库。`venv`是`virtualenv`的一个子集，并缺少`virtualenv`提供的某些高级功能。为了简化并保持本书的上下文，我将使用`venv`，但你也可以自由探索`virtualenv`和`virtualenvwrapper`。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'The references relating to this section are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的相关参考资料如下：
- en: '[https://pypi.python.org/pypi/Flask](https://pypi.python.org/pypi/Flask)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi/Flask](https://pypi.python.org/pypi/Flask)'
- en: '[https://pypi.python.org/pypi/Werkzeug](https://pypi.python.org/pypi/Werkzeug)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi/Werkzeug](https://pypi.python.org/pypi/Werkzeug)'
- en: '[https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2)'
- en: '[https://pypi.python.org/pypi/itsdangerous](https://pypi.python.org/pypi/itsdangerous)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi/itsdangerous](https://pypi.python.org/pypi/itsdangerous)'
- en: '[https://pypi.python.org/pypi/MarkupSafe](https://pypi.python.org/pypi/MarkupSafe)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi/MarkupSafe](https://pypi.python.org/pypi/MarkupSafe)'
- en: '[https://pypi.python.org/pypi/click](https://pypi.python.org/pypi/click)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pypi.python.org/pypi/click](https://pypi.python.org/pypi/click)'
- en: Read more about `virtualenv` and `virtualenvwrapper` at [https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/)
    and [https://pypi.org/project/virtualenvwrapper/](https://pypi.org/project/virtualenvwrapper/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`virtualenv`和`virtualenvwrapper`的信息，请参阅[https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/)和[https://pypi.org/project/virtualenvwrapper/](https://pypi.org/project/virtualenvwrapper/)。
- en: Handling basic configurations
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理基本配置
- en: One of the beauties of Flask is that it is very easy to configure a Flask application
    according to the needs of the project. In this recipe, we will try to understand
    the different ways in which a Flask application can be configured, including how
    to load a configuration from environment variables, Python files, or even a `config`
    object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flask的一个优点是它很容易根据项目的需求配置Flask应用程序。在这个菜谱中，我们将尝试了解Flask应用程序可以以哪些不同的方式配置，包括如何从环境变量、Python文件或甚至`config`对象中加载配置。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In Flask, configuration variables are stored on a dictionary-like attribute
    named `config` of the `Flask` object. The `config` attribute is a subclass of
    the Python dictionary, and we can modify it just like any dictionary.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask中，配置变量存储在名为`config`的字典样式的`Flask`对象属性中。`config`属性是Python字典的子类，我们可以像任何字典一样修改它。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To run our application in debug mode, for instance, we can write the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要以调试模式运行我们的应用程序，例如，我们可以编写以下代码：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `debug` Boolean can also be set at the Flask `object` level rather than
    at the `config` level, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`布尔值也可以在Flask`对象`级别而不是在`config`级别设置，如下所示：'
- en: '`app.debug =` `True`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.debug =` `True`'
- en: 'Alternatively, we can pass `debug` as a named argument to `app.run`, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将`debug`作为命名参数传递给`app.run`，如下所示：
- en: '`app.run(debug=True)`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.run(debug=True)`'
- en: 'In new versions of Flask, the debug mode can also be set on an environment
    variable, `FLASK_DEBUG=1`. Then, we can run the app using `flask run` or Python’s
    `-``m` switch:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask的新版本中，调试模式也可以通过环境变量设置，`FLASK_DEBUG=1`。然后，我们可以使用`flask run`或Python的`-m`开关来运行应用程序：
- en: '`$` `export FLASK_DEBUG=1`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` `export FLASK_DEBUG=1`'
- en: Enabling debug mode will make the server reload itself in the event of any code
    changes, and it also provides the very helpful *Werkzeug* debugger when something
    goes wrong.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 启用调试模式会在代码发生任何更改时自动重新加载服务器，并且在出现问题时还提供了非常有用的*Werkzeug*调试器。
- en: There are a bunch of configuration values provided by Flask. We will come across
    them in relevant recipes throughout this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Flask提供了许多配置值。在本章的相关食谱中，我们将遇到它们。
- en: 'As an application becomes larger, there is a need to manage the application’s
    configuration in a separate file, as shown in the following example. In most operating
    systems and development environments that you use, it is unlikely that this file
    will be a part of the version control system. Thus, Flask provides us with multiple
    ways to fetch configurations. The most frequently used methods are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增大，需要将应用程序的配置管理在一个单独的文件中，如下例所示。在您使用的多数操作系统和开发环境中，这个文件不太可能是版本控制系统的一部分。因此，Flask为我们提供了多种获取配置的方法。最常用的方法如下：
- en: 'From a Python configuration file (`*.cfg`), where the configuration can be
    fetched using the following statement:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python配置文件（`*.cfg`），其中配置可以通过以下语句获取：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From an object, where the configuration can be fetched using the following
    statement:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个对象，其中配置可以通过以下语句获取：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, to load from the same file from which this command is run, we
    can use the following statement:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，要从运行此命令的同一文件中加载，我们可以使用以下语句：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From an environment variable, the configuration can be fetched using the following
    statement:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从环境变量，配置可以通过以下语句获取：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'New in Flask version *2.0* is a capability to load from generic configuration
    file formats such as **JSON** or **TOML**:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask版本*2.0*新增了从通用配置文件格式（如**JSON**或**TOML**）加载的能力：
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Flask is designed to only pick up configuration variables that are written in
    uppercase. This allows us to define any local variables in our configuration files
    and objects and leave the rest to Flask.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Flask设计为仅拾取以大写字母编写的配置变量。这允许我们在配置文件和对象中定义任何局部变量，其余的由Flask处理。
- en: 'The best practice when using configurations is to have a bunch of default settings
    in `app.py`, or via any object in the application itself, and then override the
    same by loading it from the configuration file. So, the code will look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置的最佳实践是在`app.py`中或通过应用程序中的任何对象设置一些默认设置，然后通过从配置文件中加载来覆盖它们。因此，代码将如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Configuring using class-based settings
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于类的设置进行配置
- en: An effective way of laying out configurations for different deployment modes,
    such as production, testing, staging, and so on, can be cleanly done using the
    inheritance pattern of classes. As your project gets bigger, you can have different
    deployment modes, and each mode can have several different configuration settings
    or some settings that will remain the same. In this recipe, we will learn how
    to use class-based settings to achieve such a pattern.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的部署模式，如生产、测试、预发布等，使用类的继承模式来布局配置是一种有效的方法。随着项目的增大，您可以有不同部署模式，每种模式可以有不同的配置设置，或者有一些设置将保持不变。在本食谱中，我们将学习如何使用基于类的设置来实现这种模式。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We can have a base class with default settings; then, other classes can simply
    inherit from the base class and override or add deployment-specific configuration
    variables to it, as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个具有默认设置的基类；然后，其他类可以简单地从基类继承，并覆盖或添加特定于部署的配置变量，如下例所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important information
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: In a production configuration, the secret key is generally stored in a separate
    file because, for security reasons, it should not be a part of your version control
    system. This should be kept in the local filesystem on the machine itself, whether
    it is your machine or a server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产配置中，密钥通常存储在一个单独的文件中，因为出于安全原因，它不应成为版本控制系统的一部分。这应该在机器的本地文件系统中保留，无论是你的机器还是服务器。
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, we can use any of the preceding classes while loading the application’s
    configuration via `from_object()`. Let’s say that we save the preceding class-based
    configuration in a file named `configuration.py`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在通过`from_object()`加载应用程序配置时使用任何前面的类。假设我们将前面的基于类的配置保存在一个名为`configuration.py`的文件中，如下所示：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Overall, this makes managing configurations for different deployment environments
    more flexible and easier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，这使得管理不同部署环境下的配置更加灵活和容易。
- en: Organizing static files
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织静态文件
- en: Organizing static files such as JavaScript, stylesheets, images, and so on efficiently
    is always a matter of concern for all web frameworks. In this recipe, we’ll learn
    how to achieve this in Flask.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地组织静态文件，如JavaScript、样式表、图像等，一直是所有Web框架关注的焦点。在本教程中，我们将学习如何在Flask中实现这一点。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Flask recommends a specific way of organizing static files in an application,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Flask推荐一种特定的方式来组织应用程序中的静态文件，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While rendering this in templates (say, the `logo.png` file), we can refer
    to the static files using the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中渲染时（比如，`logo.png`文件），我们可以使用以下代码引用静态文件：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If a folder named `static` exists at the application’s root level – that is,
    at the same level as `app.py` – then Flask will automatically read the contents
    of the folder without any extra configuration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序的根级别存在一个名为`static`的文件夹——即与`app.py`在同一级别——那么Flask将自动读取该文件夹的内容，无需任何额外配置。
- en: There’s more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Alternatively, we can provide a parameter named `static_folder` to the application
    object while defining the application in `app.py`, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在定义`app.py`中的应用程序时提供一个名为`static_folder`的参数，如下所示：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding line of code, `static` refers to the value of `static_folder`
    on the application object. This can be modified as follows by providing a URL
    prefix by supplying `static_url_path`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，`static`指的是应用程序对象上的`static_folder`的值。这可以通过提供URL前缀来修改，如下所示：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, to render the static file, we can use the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要渲染静态文件，我们可以使用以下代码：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is always a good practice to use `url_for` to create URLs for static files
    rather than explicitly defining them, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用`url_for`为静态文件创建URL，而不是显式定义它们，这是一个好习惯，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Being deployment-specific with the instance folder
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实例文件夹进行部署特定操作
- en: Flask provides yet another method for configuration, where we can efficiently
    manage deployment-specific parts. Instance folders allow us to segregate deployment-specific
    files from our version-controlled application. We know that configuration files
    can be separate for different deployment environments, such as development and
    production, but there are also many more files, such as database files, session
    files, cache files, and other runtime files. In this recipe, we will create an
    instance folder that will act like a holder container for such kinds of files.
    By design, the instance folder will not be a part of the version control system.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Flask还提供了一个用于配置的另一种方法，我们可以通过它有效地管理部署特定的部分。实例文件夹允许我们将部署特定的文件从受版本控制的应用程序中分离出来。我们知道配置文件可以针对不同的部署环境分开，例如开发和生产，但还有许多其他文件，如数据库文件、会话文件、缓存文件和其他运行时文件。在本教程中，我们将创建一个实例文件夹，它将充当此类文件的容器。按照设计，实例文件夹不会成为版本控制系统的一部分。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'By default, the instance folder is picked up from the application automatically
    if we have a folder named `instance` in our application at the application level,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们在应用程序级别有一个名为`instance`的文件夹，应用程序会自动选择实例文件夹，如下所示：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also explicitly define the absolute path of the instance folder by using
    the `instance_path` parameter on our application object, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在应用程序对象上使用`instance_path`参数显式定义实例文件夹的绝对路径，如下所示：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To load the configuration file from the instance folder, we can use the `instance_relative_config`
    parameter on the application object, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要从实例文件夹中加载配置文件，我们可以在应用程序对象上使用 `instance_relative_config` 参数，如下所示：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This tells the application to load the configuration file from the instance
    folder. The following example shows how to configure this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉应用程序从实例文件夹中加载配置文件。以下示例显示了如何配置此操作：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding code, first, the instance folder is loaded from the given
    path; then, the configuration file is loaded from the `config.cfg` file in the
    given instance folder. Here, `silent=True` is optional and is used to suppress
    the error if `config.cfg` is not found in the instance folder. If `silent=True`
    is not given and the file is not found, then the application will fail, giving
    the following error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先从给定的路径加载实例文件夹；然后从给定的实例文件夹中的 `config.cfg` 文件加载配置文件。在这里，`silent=True`
    是可选的，用于抑制如果实例文件夹中没有找到 `config.cfg` 时出现的错误。如果没有提供 `silent=True` 并且文件未找到，则应用程序将失败，并给出以下错误：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Information
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It might seem that loading the configuration from the instance folder using
    `instance_relative_config` is redundant work and could be moved to one of the
    configuration methods itself. However, the beauty of this process lies in the
    fact that the instance folder concept is completely independent of configuration,
    and `instance_relative_config` just complements the configuration object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来使用 `instance_relative_config` 从实例文件夹加载配置是重复的工作，并且可以将其移动到配置方法之一。然而，这个过程的美妙之处在于实例文件夹的概念与配置完全独立，而
    `instance_relative_config` 只是补充了配置对象。
- en: Composition of views and models
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图和模型的组合
- en: As our application becomes bigger, we might want to structure it in a modular
    manner. In this recipe, we will do this by restructuring our *Hello* *World* application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序变得更大，我们可能希望以模块化的方式对其进行结构化。在这个菜谱中，我们将通过重构我们的 *Hello* *World* 应用程序来实现这一点。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: First, create a new folder in the application and move all the files inside
    this new folder. Then, create `__init__.py` in the folders, which are to be used
    as modules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在应用程序中创建一个新的文件夹，并将所有文件移动到这个新文件夹中。然后，在这些文件夹中创建 `__init__.py`，这些文件夹将被用作模块。
- en: After that, create a new file called `run.py` in the topmost folder. As its
    name implies, this file will be used to run the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在顶级文件夹中创建一个名为 `run.py` 的新文件。正如其名所示，此文件将用于运行应用程序。
- en: Finally, create separate folders to act as modules.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建单独的文件夹来充当模块。
- en: 'Refer to the following file structure to get a better understanding:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下文件结构以获得更好的理解：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s see how each of the preceding files will look.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的每个文件将如何看起来。
- en: 'The `flask_app/run.py` file will look something like the following lines of
    code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask_app/run.py` 文件将类似于以下代码行：'
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `flask_app/my_app/__init__.py` file will look something like the following
    lines of code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask_app/my_app/__init__.py` 文件将类似于以下代码行：'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we have an empty file just to make the enclosing folder a Python package,
    `flask_app/my_app/hello/__init__.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个空文件，只是为了使封装文件夹成为一个 Python 包，`flask_app/my_app/hello/__init__.py`：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The models file, `flask_app/my_app/hello/models.py`, has a non-persistent key-value
    store, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模型文件，`flask_app/my_app/hello/models.py`，有一个非持久的键值存储，如下所示：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, the following is the views file, `flask_app/my_app/hello/views.py`.
    Here, we fetch the message corresponding to the requested key and can also create
    or update a message:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是一个视图文件，`flask_app/my_app/hello/views.py`。在这里，我们获取与请求的键对应的消息，也可以创建或更新一个消息：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have a circular import between `my_app/__init__.py` and `my_app/hello/views.py`,
    where, in the former, we import `views` from the latter, and in the latter, we
    import `app` from the former. Although this makes the two modules dependent on
    each other, there is no issue, as we won’t be using views in `my_app/__init__.py`.
    Note that it is best to import the views at the bottom of the file so that they
    are not used in this file. This ensures that when you refer to the `app` object
    inside the view, it does not lead to null-pointer exceptions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有一个循环导入，在 `my_app/__init__.py` 和 `my_app/hello/views.py` 之间，在前者中，我们从后者导入
    `views`，在后者中，我们从前者导入 `app`。尽管这使得两个模块相互依赖，但没有任何问题，因为我们不会在 `my_app/__init__.py`
    中使用视图。请注意，最好在文件的底部导入视图，这样它们就不会在这个文件中使用。这确保了当你在视图中引用 `app` 对象时，不会导致空指针异常。
- en: In this recipe, we used a very simple non-persistent in-memory key-value store
    to demonstrate the model’s layout structure. We could have written the dictionary
    for the `MESSAGES` hash map in `views.py` itself, but it is best practice to keep
    the model and view layers separate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用一个非常简单的非持久内存中的键值存储来演示模型的布局结构。我们可以在 `views.py` 中直接编写 `MESSAGES` 哈希表的字典，但最佳实践是将模型和视图层分开。
- en: 'So, we can run this app using just `run.py`, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以仅使用 `run.py` 来运行此应用程序，如下所示：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note the preceding `WARNING` in the block. This warning occurs because we did
    not specify the application environment, and by default, `production` is assumed.
    To run the application in the `development` environment, modify the `run.py` file
    with the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意块中的前一个 `WARNING`。这个警告发生是因为我们没有指定应用程序环境，默认情况下假设为 `production`。要在 `development`
    环境中运行应用程序，请使用以下内容修改 `run.py` 文件：
- en: '`from my_app` `import app`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`from my_app import app`'
- en: '`app.env="development"`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.env="development"`'
- en: '`app.run(debug=True)`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.run(debug=True)`'
- en: Information
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The reloader indicates that the application is being run in debug mode and that
    the application will reload whenever a change is made in the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重载指示应用程序正在调试模式下运行，并且每当代码中发生更改时，应用程序将重新加载。
- en: 'As we can see, we have already defined a default message in `MESSAGES`. We
    can view that by opening `http://127.0.0.1:5000/show/default`. To add a new message,
    we can type `http://127.0.0.1:5000/add/great/Flask%20is%20greatgreat!!`. This
    will update the `MESSAGES` key-value store so that it looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经在 `MESSAGES` 中定义了一个默认消息。我们可以通过打开 `http://127.0.0.1:5000/show/default`
    来查看它。要添加一条新消息，我们可以输入 `http://127.0.0.1:5000/add/great/Flask%20is%20greatgreat!!`。这将更新
    `MESSAGES` 键值存储，使其看起来像这样：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, if we open `http://127.0.0.1:5000/show/great` in a browser, we will see
    our message, which would have otherwise appeared as a not found message.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在一个浏览器中打开 `http://127.0.0.1:5000/show/great`，我们将看到我们的消息，否则它将显示为一个未找到的消息。
- en: See also
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, *Creating a modular web app with blueprints*, provides a much
    better way of organizing your Flask applications and is a ready-made solution
    for circular imports.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个配方 *使用蓝图创建模块化Web应用* 提供了一种组织 Flask 应用程序的更好方法，并且是循环导入的现成解决方案。
- en: Creating a modular web app with blueprints
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝图创建模块化Web应用
- en: A **blueprint** is a feature in Flask that helps make large applications modular.
    This keeps application dispatching simple by providing a central place to register
    all components in an application. A blueprint looks like an application object
    but is not an application. It also looks like a pluggable app or a smaller part
    of a bigger app, but it is not. A blueprint is a set of operations that can be
    registered on an application and represents how to construct or build an application.
    Another benefit is that it allows us to create reusable components between multiple
    applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝图** 是 Flask 中的一项功能，有助于使大型应用程序模块化。它通过提供一个中央位置来注册应用程序中的所有组件，从而简化了应用程序的分派。蓝图看起来像一个应用程序对象，但它不是一个应用程序。它也看起来像一个可插入的应用程序或更大应用程序的一个较小部分，但它不是。蓝图是一组可以在应用程序上注册的操作，它代表了如何构建或构建应用程序。另一个好处是，它允许我们在多个应用程序之间创建可重用的组件。'
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll take the application from the previous recipe, *Composition
    of views and models*, as a reference and modify it so that it works using blueprints.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将以前一个配方 *视图和模型的组合* 中的应用程序作为参考，并修改它，使其使用蓝图工作。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The following is an example of a simple *Hello World* application using `Blueprint`.
    It will work like it did in the previous recipe but will be much more modular
    and extensible.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `Blueprint` 的简单 *Hello World* 应用程序的示例。它将像上一个配方中那样工作，但将更加模块化和可扩展。
- en: 'First, we will start with the following `flask_app/my_app/__init__.py` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从以下 `flask_app/my_app/__init__.py` 文件开始：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we will add some code to the views file, `my_app/hello/views.py`, which
    should look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在视图文件 `my_app/hello/views.py` 中添加一些代码，它应该看起来如下：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have now defined a blueprint in the `flask_app/my_app/hello/views.py` file.
    We no longer need the application object in this file, and our complete routing
    is defined on a blueprint named `hello`. Instead of `@app.route`, we use `@hello.route`.
    The same blueprint is imported into `flask_app/my_app/__init__.py` and registered
    on the application object.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`flask_app/my_app/hello/views.py`文件中定义了一个蓝图。我们不再需要这个文件中的应用程序对象，并且我们的完整路由定义在一个名为`hello`的蓝图中。我们使用`@hello.route`而不是`@app.route`。相同的蓝图被导入到`flask_app/my_app/__init__.py`中，并在应用程序对象上注册。
- en: We can create any number of blueprints in our application and complete most
    of the activities that we would usually do, such as providing different template
    paths or different static paths. We can even have different URL prefixes or subdomains
    for our blueprints.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序中创建任意数量的蓝图，并完成我们通常会做的许多活动，例如提供不同的模板路径或不同的静态路径。我们甚至可以为我们的蓝图设置不同的URL前缀或子域名。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This application will work in just the same way as the last application. The
    only difference is in the way the code is organized.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将以与上一个应用程序完全相同的方式运行。唯一的区别在于代码的组织方式。
- en: Making a Flask app installable using setuptools
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setuptools使Flask应用程序可安装
- en: We now have a Flask app, but how do we install it like any `setuptools` can
    be used to create an installable Python package.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个Flask应用程序，但如何像使用`setuptools`创建可安装的Python包一样安装它。
- en: What is a Python package?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Python包？
- en: A Python package can simply be thought of as a program that can be imported
    using Python’s `import` statement in a virtual environment or globally based on
    its installation scope.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简单地将Python包视为一个程序，可以在虚拟环境或基于其安装范围全局使用Python的`import`语句导入。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Installing a Flask app can be easily achieved using the `setuptools` Python
    library. To achieve this, create a file called `setup.py` in your application’s
    folder and configure it to run a setup script for the application. This will take
    care of any dependencies, descriptions, loading test packages, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setuptools` Python库可以轻松地安装Flask应用程序。为了实现这一点，在应用程序文件夹中创建一个名为`setup.py`的文件，并配置它以运行应用程序的设置脚本。这将处理任何依赖项、描述、加载测试包等。
- en: 'The following is an example of a simple `setup.py` script for the *Hello World*
    application from the previous recipe:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的`setup.py`脚本示例，用于之前配方中的*Hello World*应用程序：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the preceding script, most of the configuration is self-explanatory. The
    classifiers are used when the application is made available on **PyPI**. These
    will help other users search the application using the relevant classifiers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，大部分配置都是不言自明的。分类器在应用程序在**PyPI**上提供时使用。这些将帮助其他用户使用相关分类器搜索应用程序。
- en: 'Now, we can run this file with the `install` keyword, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`install`关键字运行此文件，如下所示：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding command will install the application along with all the dependencies
    mentioned in `install_requires` – that is, Flask and all of Flask’s dependencies.
    Now, the app can be used just like any Python package in a Python environment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将安装应用程序以及`install_requires`中提到的所有依赖项——也就是说，Flask及其所有依赖项。现在，该应用程序可以在Python环境中像任何Python包一样使用。
- en: 'To verify the successful installation of your package, import it inside a Python
    environment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证包安装成功，在Python环境中导入它：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The list of valid trove classifiers can be found at [https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有效trove分类器的列表可以在[https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers)找到。
