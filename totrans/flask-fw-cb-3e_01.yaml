- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This introductory chapter will help us understand the different ways **Flask**
    can be configured to suit the various needs of a project. Flask is “*The Python
    micro framework for building web applications*” (pallets/Flask, [https://github.com/pallets/flask](https://github.com/pallets/flask)).
  prefs: []
  type: TYPE_NORMAL
- en: So, why is Flask called a **microframework**? Does this mean Flask lacks functionality,
    or that it’s mandatory for the complete code of your web application to be contained
    in a single file? Not really! The term microframework simply refers to the fact
    that Flask aims to keep the core of its framework small but highly extensible.
    This makes writing applications or extensions both easy and flexible and gives
    developers the power to choose the configurations they want for their application
    without imposing any restrictions on the choice of database, templating engine,
    admin interface, and so on. In this chapter, you will learn several ways to set
    up and configure Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: This whole book uses *Python 3* as the default version of Python. Python 2 lost
    its support on December 31, 2019, and is therefore not supported in this book.
    It is recommended that you use Python 3 while learning from this book, as many
    of the recipes might not work on Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, while writing this book, Flask 2.2.x was the latest version. Although
    a lot of code in this book can work on earlier versions of Flask, it is recommended
    that you use versions 2.2.x and above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting started with Flask takes just a couple of minutes. Setting up a simple
    *Hello World* application is as easy as pie. Simply create a file, such as `app.py,`
    in any location on your computer that can access `python` or `python3` that contains
    the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, Flask needs to be installed; this can be done via `pip` or `pip3`. You
    may have to use `sudo` on a Unix-based machine if you run into access issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The code and Flask installation example here is just intended to demonstrate
    the ease with which Flask can be used. To set up a proper development environment,
    follow the recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding snippet is a complete Flask-based web application. Here, an instance
    of the imported `Flask` class is a `app` in this code becomes our WSGI application,
    and as this is a standalone module, we set the `__name__` string to `''__main__''`.
    If we save this in a file called `app.py`, then the application can simply be
    run using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we head over to our browser and type `http://127.0.0.1:5000/`, we can
    see our application running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the application can be run by using `flask run` or Python’s
    `-m` switch with Flask. While following this approach, the last two lines of `app.py`
    can be skipped. Note that the following commands work only if there is a file
    named `app.py` or `wsgi.py` in the current directory. If not, then the file containing
    the `app` object should be exported as an environment variable, namely `FLASK_APP`.
    As a best practice, this should be done in either case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you decide to use the `-m` switch, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never save your application file as `flask.py`; if you do, it will conflict
    with Flask itself while importing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment with `virtualenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling basic configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring class-based settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being deployment-specific with the `instance` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compositions of views and models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a modular web app with blueprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a Flask app installable using `setuptools`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with Flask and **Python** in general is pretty easy and does not require
    a lot of dependencies and configurations. For most of the chapters in this book,
    all the required packages shall be mentioned in the relevant recipes. I will mention
    more specific requirements in relevant chapters. In general, you will need the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A decent computer, preferably with a *UNIX*-based OS such as *Linux* or *macOS*.
    You can also use Windows, which would require some additional setup, but that
    is out of the scope of this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code editor of choice as the IDE. I use *Vim* and *Visual Studio Code* but
    anything will work, so long as it supports *Python*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good internet connection as you will be downloading the packages and their
    dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code is freely available on GitHub at [https://github.com/PacktPublishing/Flask-Framework-Cookbook-Third-Edition](https://github.com/PacktPublishing/Flask-Framework-Cookbook-Third-Edition).
    This repository on GitHub contains the code for all the chapters in this book,
    segregated into corresponding folders.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask can be simply installed using `pip`/`pip3` or `easy_install` globally,
    but it’s preferable to set up an application environment using `venv` manages
    this in separate environments and does not let the incorrect version of any library
    affect any application. In this recipe, we will learn how to create and manage
    these environments.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`venv` module to create virtual environments. So, simply create a new environment
    called `my_flask_env` (or any other name of your choice) inside the folder of
    your choice where you want your development environment to live. This will create
    a new folder with the same name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands from inside the `my_flask_env` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will activate our environment and install `flask` inside it. Now, we can
    do anything with our application within this environment, without affecting any
    other Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have used `pip3 install flask` multiple times. As its name suggests,
    the command refers to the installation of Flask, just like any Python package.
    If we look a bit deeper into the process of installing Flask via `pip3`, we will
    see that several packages are installed. The following is an outline of the package
    installation process of Flask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we look carefully at the preceding snippet, we will see that multiple packages
    have been installed. Of these, five packages, namely, `Werkzeug`, `Jinja2`, `click`,
    `itsdangerous`, and `markupsafe`, are the packages on which Flask depends, and
    it will not work if any of them are missing. Others are sub-dependencies that
    are needed for the dependencies of Flask to work.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before `venv` was introduced in *Python 3.3*, `virtualenv` was the standard
    library used to create and manage virtual environments. `venv` is a subset of
    `virtualenv` and misses out on the advanced features that `virtualenv` provides.
    For the sake of simplicity and to stay in the context of this book, I will use
    `venv`, but you are free to explore `virtualenv` and `virtualenvwrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The references relating to this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pypi.python.org/pypi/Flask](https://pypi.python.org/pypi/Flask)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pypi.python.org/pypi/Werkzeug](https://pypi.python.org/pypi/Werkzeug)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pypi.python.org/pypi/Jinja2](https://pypi.python.org/pypi/Jinja2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pypi.python.org/pypi/itsdangerous](https://pypi.python.org/pypi/itsdangerous)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pypi.python.org/pypi/MarkupSafe](https://pypi.python.org/pypi/MarkupSafe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pypi.python.org/pypi/click](https://pypi.python.org/pypi/click)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about `virtualenv` and `virtualenvwrapper` at [https://virtualenv.pypa.io/en/latest/](https://virtualenv.pypa.io/en/latest/)
    and [https://pypi.org/project/virtualenvwrapper/](https://pypi.org/project/virtualenvwrapper/).
  prefs: []
  type: TYPE_NORMAL
- en: Handling basic configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the beauties of Flask is that it is very easy to configure a Flask application
    according to the needs of the project. In this recipe, we will try to understand
    the different ways in which a Flask application can be configured, including how
    to load a configuration from environment variables, Python files, or even a `config`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Flask, configuration variables are stored on a dictionary-like attribute
    named `config` of the `Flask` object. The `config` attribute is a subclass of
    the Python dictionary, and we can modify it just like any dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run our application in debug mode, for instance, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `debug` Boolean can also be set at the Flask `object` level rather than
    at the `config` level, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.debug =` `True`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can pass `debug` as a named argument to `app.run`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.run(debug=True)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In new versions of Flask, the debug mode can also be set on an environment
    variable, `FLASK_DEBUG=1`. Then, we can run the app using `flask run` or Python’s
    `-``m` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$` `export FLASK_DEBUG=1`'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling debug mode will make the server reload itself in the event of any code
    changes, and it also provides the very helpful *Werkzeug* debugger when something
    goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of configuration values provided by Flask. We will come across
    them in relevant recipes throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an application becomes larger, there is a need to manage the application’s
    configuration in a separate file, as shown in the following example. In most operating
    systems and development environments that you use, it is unlikely that this file
    will be a part of the version control system. Thus, Flask provides us with multiple
    ways to fetch configurations. The most frequently used methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a Python configuration file (`*.cfg`), where the configuration can be
    fetched using the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From an object, where the configuration can be fetched using the following
    statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, to load from the same file from which this command is run, we
    can use the following statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From an environment variable, the configuration can be fetched using the following
    statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in Flask version *2.0* is a capability to load from generic configuration
    file formats such as **JSON** or **TOML**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask is designed to only pick up configuration variables that are written in
    uppercase. This allows us to define any local variables in our configuration files
    and objects and leave the rest to Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best practice when using configurations is to have a bunch of default settings
    in `app.py`, or via any object in the application itself, and then override the
    same by loading it from the configuration file. So, the code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Configuring using class-based settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An effective way of laying out configurations for different deployment modes,
    such as production, testing, staging, and so on, can be cleanly done using the
    inheritance pattern of classes. As your project gets bigger, you can have different
    deployment modes, and each mode can have several different configuration settings
    or some settings that will remain the same. In this recipe, we will learn how
    to use class-based settings to achieve such a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can have a base class with default settings; then, other classes can simply
    inherit from the base class and override or add deployment-specific configuration
    variables to it, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: In a production configuration, the secret key is generally stored in a separate
    file because, for security reasons, it should not be a part of your version control
    system. This should be kept in the local filesystem on the machine itself, whether
    it is your machine or a server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can use any of the preceding classes while loading the application’s
    configuration via `from_object()`. Let’s say that we save the preceding class-based
    configuration in a file named `configuration.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Overall, this makes managing configurations for different deployment environments
    more flexible and easier.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing static files such as JavaScript, stylesheets, images, and so on efficiently
    is always a matter of concern for all web frameworks. In this recipe, we’ll learn
    how to achieve this in Flask.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask recommends a specific way of organizing static files in an application,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While rendering this in templates (say, the `logo.png` file), we can refer
    to the static files using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a folder named `static` exists at the application’s root level – that is,
    at the same level as `app.py` – then Flask will automatically read the contents
    of the folder without any extra configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, we can provide a parameter named `static_folder` to the application
    object while defining the application in `app.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line of code, `static` refers to the value of `static_folder`
    on the application object. This can be modified as follows by providing a URL
    prefix by supplying `static_url_path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to render the static file, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It is always a good practice to use `url_for` to create URLs for static files
    rather than explicitly defining them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Being deployment-specific with the instance folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask provides yet another method for configuration, where we can efficiently
    manage deployment-specific parts. Instance folders allow us to segregate deployment-specific
    files from our version-controlled application. We know that configuration files
    can be separate for different deployment environments, such as development and
    production, but there are also many more files, such as database files, session
    files, cache files, and other runtime files. In this recipe, we will create an
    instance folder that will act like a holder container for such kinds of files.
    By design, the instance folder will not be a part of the version control system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the instance folder is picked up from the application automatically
    if we have a folder named `instance` in our application at the application level,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also explicitly define the absolute path of the instance folder by using
    the `instance_path` parameter on our application object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To load the configuration file from the instance folder, we can use the `instance_relative_config`
    parameter on the application object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the application to load the configuration file from the instance
    folder. The following example shows how to configure this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding code, first, the instance folder is loaded from the given
    path; then, the configuration file is loaded from the `config.cfg` file in the
    given instance folder. Here, `silent=True` is optional and is used to suppress
    the error if `config.cfg` is not found in the instance folder. If `silent=True`
    is not given and the file is not found, then the application will fail, giving
    the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: It might seem that loading the configuration from the instance folder using
    `instance_relative_config` is redundant work and could be moved to one of the
    configuration methods itself. However, the beauty of this process lies in the
    fact that the instance folder concept is completely independent of configuration,
    and `instance_relative_config` just complements the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: Composition of views and models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our application becomes bigger, we might want to structure it in a modular
    manner. In this recipe, we will do this by restructuring our *Hello* *World* application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a new folder in the application and move all the files inside
    this new folder. Then, create `__init__.py` in the folders, which are to be used
    as modules.
  prefs: []
  type: TYPE_NORMAL
- en: After that, create a new file called `run.py` in the topmost folder. As its
    name implies, this file will be used to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create separate folders to act as modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following file structure to get a better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how each of the preceding files will look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flask_app/run.py` file will look something like the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flask_app/my_app/__init__.py` file will look something like the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have an empty file just to make the enclosing folder a Python package,
    `flask_app/my_app/hello/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The models file, `flask_app/my_app/hello/models.py`, has a non-persistent key-value
    store, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following is the views file, `flask_app/my_app/hello/views.py`.
    Here, we fetch the message corresponding to the requested key and can also create
    or update a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have a circular import between `my_app/__init__.py` and `my_app/hello/views.py`,
    where, in the former, we import `views` from the latter, and in the latter, we
    import `app` from the former. Although this makes the two modules dependent on
    each other, there is no issue, as we won’t be using views in `my_app/__init__.py`.
    Note that it is best to import the views at the bottom of the file so that they
    are not used in this file. This ensures that when you refer to the `app` object
    inside the view, it does not lead to null-pointer exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used a very simple non-persistent in-memory key-value store
    to demonstrate the model’s layout structure. We could have written the dictionary
    for the `MESSAGES` hash map in `views.py` itself, but it is best practice to keep
    the model and view layers separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can run this app using just `run.py`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the preceding `WARNING` in the block. This warning occurs because we did
    not specify the application environment, and by default, `production` is assumed.
    To run the application in the `development` environment, modify the `run.py` file
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`from my_app` `import app`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.env="development"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.run(debug=True)`'
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The reloader indicates that the application is being run in debug mode and that
    the application will reload whenever a change is made in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we have already defined a default message in `MESSAGES`. We
    can view that by opening `http://127.0.0.1:5000/show/default`. To add a new message,
    we can type `http://127.0.0.1:5000/add/great/Flask%20is%20greatgreat!!`. This
    will update the `MESSAGES` key-value store so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we open `http://127.0.0.1:5000/show/great` in a browser, we will see
    our message, which would have otherwise appeared as a not found message.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next recipe, *Creating a modular web app with blueprints*, provides a much
    better way of organizing your Flask applications and is a ready-made solution
    for circular imports.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a modular web app with blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **blueprint** is a feature in Flask that helps make large applications modular.
    This keeps application dispatching simple by providing a central place to register
    all components in an application. A blueprint looks like an application object
    but is not an application. It also looks like a pluggable app or a smaller part
    of a bigger app, but it is not. A blueprint is a set of operations that can be
    registered on an application and represents how to construct or build an application.
    Another benefit is that it allows us to create reusable components between multiple
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll take the application from the previous recipe, *Composition
    of views and models*, as a reference and modify it so that it works using blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is an example of a simple *Hello World* application using `Blueprint`.
    It will work like it did in the previous recipe but will be much more modular
    and extensible.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will start with the following `flask_app/my_app/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add some code to the views file, `my_app/hello/views.py`, which
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We have now defined a blueprint in the `flask_app/my_app/hello/views.py` file.
    We no longer need the application object in this file, and our complete routing
    is defined on a blueprint named `hello`. Instead of `@app.route`, we use `@hello.route`.
    The same blueprint is imported into `flask_app/my_app/__init__.py` and registered
    on the application object.
  prefs: []
  type: TYPE_NORMAL
- en: We can create any number of blueprints in our application and complete most
    of the activities that we would usually do, such as providing different template
    paths or different static paths. We can even have different URL prefixes or subdomains
    for our blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This application will work in just the same way as the last application. The
    only difference is in the way the code is organized.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Flask app installable using setuptools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a Flask app, but how do we install it like any `setuptools` can
    be used to create an installable Python package.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Python package?
  prefs: []
  type: TYPE_NORMAL
- en: A Python package can simply be thought of as a program that can be imported
    using Python’s `import` statement in a virtual environment or globally based on
    its installation scope.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing a Flask app can be easily achieved using the `setuptools` Python
    library. To achieve this, create a file called `setup.py` in your application’s
    folder and configure it to run a setup script for the application. This will take
    care of any dependencies, descriptions, loading test packages, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a simple `setup.py` script for the *Hello World*
    application from the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding script, most of the configuration is self-explanatory. The
    classifiers are used when the application is made available on **PyPI**. These
    will help other users search the application using the relevant classifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run this file with the `install` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install the application along with all the dependencies
    mentioned in `install_requires` – that is, Flask and all of Flask’s dependencies.
    Now, the app can be used just like any Python package in a Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the successful installation of your package, import it inside a Python
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list of valid trove classifiers can be found at [https://pypi.python.org/pypi?%3Aaction=list_classifiers](https://pypi.python.org/pypi?%3Aaction=list_classifiers).
  prefs: []
  type: TYPE_NORMAL
