- en: Testing Object-Oriented Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试面向对象程序
- en: 'Skilled Python programmers agree that testing is one of the most important
    aspects of software development. Even though this chapter is placed near the end
    of the book, it is not an afterthought; everything we have studied so far will
    help us when writing tests. In this chapter, we''ll look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 熟练的 Python 程序员一致认为，测试是软件开发最重要的方面之一。尽管这一章被放置在书的末尾附近，但这并不是一个事后想法；我们迄今为止所学的所有内容都将帮助我们编写测试。在本章中，我们将探讨以下主题：
- en: The importance of unit testing and test-driven development
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试和测试驱动开发的重要性
- en: The standard `unittest` module
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的 `unittest` 模块
- en: The `pytest` automated testing suite
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 自动化测试套件'
- en: The `mock` module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mock` 模块'
- en: Code coverage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Cross-platform testing with `tox`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tox` 进行跨平台测试
- en: Why test?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要测试？
- en: Many programmers already know how important it is to test their code. If you're
    among them, feel free to skim this section. You'll find the next section–where
    we actually see how to create tests in Python–much more scintillating. If you're
    not convinced of the importance of testing, I promise that your code is broken,
    you just don't know it. Read on!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员已经知道测试代码的重要性。如果你是其中之一，请随意浏览这一节。你会发现下一节——我们实际上将看到如何在 Python 中创建测试——要有趣得多。如果你还没有确信测试的重要性，我保证你的代码有缺陷，你只是不知道而已。继续阅读！
- en: Some people argue that testing is more important in Python code because of its
    dynamic nature; compiled languages such as Java and C++ are occasionally thought
    to be somehow *safer* because they enforce type checking at compile time. However,
    Python tests rarely check types. They check values. They make sure that the right
    attributes have been set at the right time or that the sequence has the right
    length, order, and values. These higher-level concepts need to be tested in any
    language. The real reason Python programmers test more than programmers of other
    languages is that it is so easy to test in Python!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为，由于 Python 的动态特性，测试在 Python 代码中更为重要；编译语言，如 Java 和 C++，有时被认为在某种程度上更*安全*，因为它们在编译时强制进行类型检查。然而，Python
    测试很少检查类型。它们检查值。它们确保在正确的时间设置了正确的属性，或者序列具有正确的长度、顺序和值。这些高级概念在任何语言中都需要进行测试。Python
    程序员比其他语言的程序员更多地测试代码的真正原因是，在 Python 中测试变得如此容易！
- en: But why test? Do we really need to test? What if we didn't test? To answer those
    questions, write a tic-tac-toe game from scratch without any testing at all. Don't
    run it until it is completely written, start to finish. Tic-tac-toe is fairly
    simple to implement if you make both players human players (no artificial intelligence).
    You don't even have to try to calculate who the winner is. Now run your program.
    And fix all the errors. How many were there? I recorded eight in my tic-tac-toe
    implementation, and I'm not sure I caught them all. Did you?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么需要测试？我们真的需要测试吗？如果我们不测试会怎样？为了回答这些问题，从头开始编写一个没有进行任何测试的井字棋游戏。不要运行它直到完全编写完成，从头到尾。如果你让两个玩家都是人类玩家（没有人工智能），井字棋的实现相当简单。你甚至不需要尝试计算谁是赢家。现在运行你的程序。并修复所有错误。有多少个？我在我的井字棋实现中记录了八个，我不确定我是否都捕捉到了。你呢？
- en: We need to test our code to make sure it works. Running the program, as we just
    did, and fixing the errors is one crude form of testing. Python's interactive
    interpreter and near-zero compile times makes it easy to write a few lines of
    code and run the program to make sure those lines are doing what is expected.
    But changing a few lines of code can affect parts of the program that we haven't
    realized will be influenced by the changes, and therefore neglect to test those
    parts. Furthermore, as a program grows, the number of paths that the interpreter
    can take through that code also grow, and it quickly becomes impossible to manually
    test all of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试我们的代码以确保它能够正常工作。像我们刚才做的那样运行程序并修复错误是一种粗略的测试形式。Python 的交互式解释器和几乎为零的编译时间使得编写几行代码并运行程序来确保这些代码行正在执行预期操作变得非常容易。但是，更改几行代码可能会影响我们尚未意识到会受到这些更改影响的程序部分，因此我们忽略了这些部分的测试。此外，随着程序的增长，解释器可以通过该代码的路径数量也会增加，很快手动测试所有这些路径就变得不可能了。
- en: To handle this, we write automated tests. These are programs that automatically
    run certain inputs through other programs or parts of programs. We can run these
    test programs in seconds and cover far more potential input situations than one
    programmer would think to test every time they change something.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们编写自动化测试。这些是自动将某些输入通过其他程序或程序的某些部分运行的程序。我们可以在几秒钟内运行这些测试程序，并覆盖比一个程序员在每次更改时想要测试的更多潜在输入情况。
- en: 'There are four main reasons to write tests:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试有四个主要原因：
- en: To ensure that code is working the way the developer thinks it should
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保代码按照开发者的预期工作
- en: To ensure that code continues working when we make changes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保我们在进行更改时代码仍然可以继续工作
- en: To ensure that the developer understood the requirements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保开发者理解了需求
- en: To ensure that the code we are writing has a maintainable interface
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保我们编写的代码有一个可维护的接口
- en: The first point really doesn't justify the time it takes to write a test; we
    can test the code directly in the interactive interpreter in the same time or
    less. But when we have to perform the same sequence of test actions multiple times,
    it takes less time to automate those steps once and then run them whenever necessary.
    It is a good idea to run tests every time we change code, whether it is during
    initial development or maintenance releases. When we have a comprehensive set
    of automated tests, we can run them after code changes and know that we didn't
    inadvertently break anything that was tested.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个点实际上并不能证明编写测试所需的时间是合理的；我们可以在相同的时间或更少的时间内直接在交互式解释器中测试代码。但是，当我们必须多次执行相同的测试动作序列时，自动化这些步骤一次然后随时运行它们会更节省时间。每次我们更改代码时，运行测试都是一个好主意，无论是初始开发还是维护版本。当我们有一套全面的自动化测试时，我们可以在代码更改后运行它们，并知道我们没有无意中破坏任何已测试的内容。
- en: The last two of the preceding points are more interesting. When we write tests
    for code, it helps us design the API, interface, or pattern that code takes. Thus,
    if we misunderstood the requirements, writing a test can help highlight that misunderstanding.
    From the other side, if we're not certain how we want to design a class, we can
    write a test that interacts with that class so we have an idea of the most natural
    way to interface with it. In fact, it is often beneficial to write the tests before
    we write the code we are testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的最后两点更有趣。当我们为代码编写测试时，它有助于我们设计API、接口或代码采用的模式。因此，如果我们对需求理解有误，编写测试可以帮助突出这种误解。从另一方面来看，如果我们不确定如何设计一个类，我们可以编写一个与该类交互的测试，这样我们就有了一个关于如何自然地与之交互的想法。实际上，在编写我们要测试的代码之前编写测试通常是有益的。
- en: Test-driven development
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '*Write tests first* is the mantra of test-driven development. Test-driven development
    takes the *untested code is broken code* concept one step further and suggests
    that only unwritten code should be untested. We don''t write any code until we
    have written the tests that will prove it works. The first time we run a test
    it should fail, since the code hasn''t been written. Then, we write the code that
    ensures the test passes, then write another test for the next segment of code.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*先写测试*是测试驱动开发的座右铭。测试驱动开发将*未经测试的代码是损坏的代码*的概念进一步推进，并建议只有未编写的代码才应该是未经测试的。我们不会编写任何代码，直到我们编写了证明它工作的测试。第一次运行测试时它应该失败，因为代码还没有被编写。然后，我们编写确保测试通过的代码，然后为下一段代码编写另一个测试。'
- en: Test-driven development is fun; it allows us to build little puzzles to solve.
    Then, we implement the code to solve those puzzles. Then, we make a more complicated
    puzzle, and we write code that solves the new puzzle without unsolving the previous
    one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发很有趣；它允许我们构建小谜题来解决。然后，我们实现代码来解决这些谜题。然后，我们制作一个更复杂的谜题，并编写代码来解决新谜题，同时不解决之前的谜题。
- en: 'There are two goals to the test-driven methodology. The first is to ensure
    that tests really get written. It''s so very easy, after we have written code,
    to say:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动方法有两个目标。第一个是确保测试确实被编写了。在我们编写代码之后，很容易就说：
- en: '"Hmm, it seems to work. I don''t have to write any tests for this. It was just
    a small change; nothing could have broken."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗯，看起来好像没问题。我不用为这个写任何测试。这只是一个小改动；不可能有什么东西会出问题。"'
- en: If the test is already written before we write the code, we will know exactly
    when it works (because the test will pass), and we'll know in the future if it
    is ever broken by a change we or someone else has made.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试在编写代码之前就已经编写好了，我们就会确切地知道它何时工作（因为测试会通过），并且我们会在未来知道它是否被我们或其他人所做的更改所破坏。
- en: Secondly, writing tests first forces us to consider exactly how the code will
    be used. It tells us what methods objects need to have and how attributes will
    be accessed. It helps us break up the initial problem into smaller, testable problems,
    and then to recombine the tested solutions into larger, also tested, solutions.
    Writing tests can thus become a part of the design process. Often, when we're
    writing a test for a new object, we discover anomalies in the design that force
    us to consider new aspects of the software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，先编写测试迫使我们仔细考虑代码将如何被使用。它告诉我们对象需要哪些方法以及如何访问属性。它帮助我们将初始问题分解成更小、可测试的问题，然后将经过测试的解决方案重新组合成更大、也经过测试的解决方案。因此，编写测试可以成为设计过程的一部分。通常，当我们为新的对象编写测试时，我们会发现设计中的异常，这迫使我们考虑软件的新方面。
- en: As a concrete example, imagine writing code that uses an object-relational mapper
    to store object properties in a database. It is common to use an automatically
    assigned database ID in such objects. Our code might use this ID for various purposes.
    If we are writing a test for such code, before we write it, we may realize that
    our design is faulty because objects do not have IDs assigned until they have
    been saved to the database. If we want to manipulate an object without saving
    it in our test, it will highlight this problem before we have written code based
    on the faulty premise.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体例子，想象一下编写使用对象关系映射器将对象属性存储在数据库中的代码。在这些对象中使用自动分配的数据库ID是很常见的。我们的代码可能出于各种目的使用这个ID。如果我们为这样的代码编写测试，在编写它之前，我们可能会意识到我们的设计有缺陷，因为对象只有在保存到数据库后才会分配ID。如果我们想在测试中操作一个对象而不保存它，这将在我们基于错误前提编写代码之前突出这个问题。
- en: Testing makes software better. Writing tests before we release the software
    makes it better before the end user sees or purchases the buggy version (I have
    worked for companies that thrive on the *users can test it* philosophy; it's not
    a healthy business model). Writing tests before we write software makes it better
    the first time it is written.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使软件变得更好。在发布软件之前编写测试，可以在最终用户看到或购买有缺陷的版本之前使其变得更好（我曾为那些以“用户可以测试它”为理念的公司工作；这不是一个健康的商业模式）。在编写软件之前编写测试，可以使它第一次编写时就变得更好。
- en: Unit testing
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Let's start our exploration with Python's built-in test library. This library
    provides a common object-oriented interface for **unit tests**. Unit tests focus
    on testing the least amount of code possible in any one test. Each one tests a
    single unit of the total amount of available code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Python内置的测试库开始我们的探索。这个库为**单元测试**提供了一个通用的面向对象接口。单元测试专注于在任何一个测试中测试尽可能少的代码。每个测试都针对可用代码总量中的一个单一单元。
- en: The Python library for this is called, unsurprisingly, `unittest`. It provides
    several tools for creating and running unit tests, the most important being the
    `TestCase` class. This class provides a set of methods that allow us to compare
    values, set up tests, and clean up when they have finished.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python库被称为`unittest`。它提供了一些创建和运行单元测试的工具，其中最重要的是`TestCase`类。这个类提供了一组方法，允许我们比较值、设置测试，并在它们完成后进行清理。
- en: 'When we want to write a set of unit tests for a specific task, we create a
    subclass of `TestCase` and write individual methods to do the actual testing.
    These methods must all start with the name `test`. When this convention is followed,
    the tests automatically run as part of the test process. Normally, the tests set
    some values on an object and then run a method, and use the built-in comparison
    methods to ensure that the right results were calculated. Here''s a very simple
    example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要为特定任务编写一组单元测试时，我们创建一个`TestCase`的子类，并编写单独的方法来进行实际测试。这些方法都必须以`test`开头命名。遵循此约定时，测试将自动作为测试过程的一部分运行。通常，测试会在对象上设置一些值，然后运行一个方法，并使用内置的比较方法来确保计算出了正确的结果。以下是一个非常简单的例子：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code simply subclasses the `TestCase` class and adds a method that calls
    the `TestCase.assertEqual` method. This method will either succeed or raise an
    exception, depending on whether the two parameters are equal. If we run this code,
    the `main` function from `unittest` will give us the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码简单地从`TestCase`类派生，并添加了一个调用`TestCase.assertEqual`方法的方法。此方法将根据两个参数是否相等而成功或引发异常。如果我们运行此代码，`unittest`的`main`函数将给出以下输出：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Did you know that floats and integers can be compared as equal? Let''s add
    a failing test, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道浮点数和整数可以被视为相等吗？让我们添加一个失败的测试，如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output of this code is more sinister, as integers and strings are not
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出更为神秘，因为整数和字符串并不
- en: 'considered equal:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 被视为相等：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The dot on the first line indicates that the first test (the one we wrote before)
    passed successfully; the letter `F` after it shows that the second test failed.
    Then, at the end, it gives us some informative output telling us how and where
    the test failed, along with a summary of the number of failures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行上的点表示第一个测试（我们之前写的）成功通过；它后面的字母`F`表示第二个测试失败。然后，在最后，它给出了有关测试失败方式和位置的一些信息输出，以及失败次数的摘要。
- en: We can have as many test methods on one `TestCase` class as we like. As long
    as the method name begins with `test`, the test runner will execute each one as
    a separate, isolated test. Each test should be completely independent of other
    tests. Results or calculations from a previous test should have no impact on the
    current test. The key to writing good unit tests is keeping each test method as
    short as possible, testing a small unit of code with each test case. If our code
    does not seem to naturally break up into such testable units, it's probably a
    sign that the code needs to be redesigned.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个`TestCase`类上拥有尽可能多的测试方法。只要方法名以`test`开头，测试运行器就会将每个方法作为一个单独的、独立的测试执行。每个测试应该完全独立于其他测试。之前测试的结果或计算不应影响当前测试。编写良好单元测试的关键是尽可能保持每个测试方法简短，每个测试用例测试一小块代码。如果我们的代码似乎不能自然地分解成这样的可测试单元，那么这可能是一个迹象，表明代码需要重新设计。
- en: Assertion methods
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言方法
- en: The general layout of a test case is to set certain variables to known values,
    run one or more functions, methods, or processes, and then *prove* that correct
    expected results were returned or calculated by using `TestCase` assertion methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的一般布局是设置某些变量为已知值，运行一个或多个函数、方法或过程，然后使用`TestCase`断言方法*证明*返回或计算了正确的预期结果。
- en: 'There are a few different assertion methods available to confirm that specific
    results have been achieved. We just saw `assertEqual`, which will cause a test
    failure if the two parameters do not pass an equality check. The inverse, `assertNotEqual`,
    will fail if the two parameters do compare as equal. The `assertTrue` and `assertFalse`
    methods each accept a single expression, and fail if the expression does not pass
    an `if` test. These tests do not check for the Boolean values `True` or `False`.
    Rather, they test the same condition as though an `if` statement were used: `False`,
    `None`, `0`, or an empty list, dictionary, string, set, or tuple would pass a
    call to the `assertFalse` method. Nonzero numbers, containers with values in them,
    or the value `True` would succeed when calling the `assertTrue` method.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的断言方法可用于确认是否达到了特定的结果。我们刚刚看到了`assertEqual`，如果两个参数没有通过相等性检查，它将导致测试失败。其逆操作`assertNotEqual`将在两个参数相等时失败。`assertTrue`和`assertFalse`方法各自接受一个表达式，如果表达式没有通过`if`测试，则失败。这些测试不检查`True`或`False`的布尔值。相反，它们测试的条件与使用`if`语句相同：`False`、`None`、`0`或一个空列表、字典、字符串、集合或元组将通过`assertFalse`方法的调用。非零数字、包含值的容器或`True`值在调用`assertTrue`方法时会成功。
- en: 'There is an `assertRaises` method that can be used to ensure that a specific
    function call raises a specific exception or, optionally, it can be used as a
    context manager to wrap inline code. The test passes if the code inside the `with`
    statement raises the proper exception; otherwise, it fails. The following code
    snippet is an example of both versions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`assertRaises`方法可以用来确保特定的函数调用引发特定的异常，或者，可选地，它可以作为一个上下文管理器来包装内联代码。如果`with`语句内的代码引发了适当的异常，则测试通过；否则，测试失败。以下代码片段是这两个版本的示例：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The context manager allows us to write the code the way we would normally write
    it (by calling functions or executing code directly), rather than having to wrap
    the function call in another function call.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器允许我们以我们通常编写代码的方式（通过调用函数或直接执行代码）编写代码，而不是必须将函数调用包装在另一个函数调用中。
- en: 'There are also several other assertion methods, summarized in the following
    table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有几种其他断言方法，总结在下表中：
- en: '| **Methods** | **Description** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `assertGreater``assertGreaterEqual``assertLess``assertLessEqual` | Accept
    two comparable objects and ensure the named inequality holds. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `assertGreater` `assertGreaterEqual` `assertLess` `assertLessEqual` | 接受两个可比较的对象，并确保命名不等式成立。
    |'
- en: '| `assertIn``assertNotIn` | Ensure an element is (or is not) an element in
    a container object. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `assertIn` `assertNotIn` | 确保一个元素是（或不是）容器对象中的元素。 |'
- en: '| `assertIsNone``assertIsNotNone` | Ensure an element is (or is not) the exact
    `None` value (but not another falsey value). |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `assertIsNone` `assertIsNotNone` | 确保一个元素是（或不是）精确的 `None` 值（但不是另一个假值）。 |'
- en: '| `assertSameElements` | Ensure two container objects have the same elements,
    ignoring the order. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `assertSameElements` | 确保两个容器对象具有相同的元素，忽略顺序。 |'
- en: '| `assertSequenceEqualassertDictEqual``assertSetEqual``assertListEqual``assertTupleEqual`
    | Ensure two containers have the same elements in the same order. If there''s
    a failure, show a code difference comparing the two lists to see where they differ.
    The last four methods also test the type of the list. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `assertSequenceEqual` `assertDictEqual` `assertSetEqual` `assertListEqual`
    `assertTupleEqual` | 确保两个容器具有相同顺序的相同元素。如果出现失败，将显示一个代码差异，比较两个列表以查看它们在哪里不同。最后四种方法还测试列表的类型。
    |'
- en: Each of the assertion methods accepts an optional argument named `msg.` If supplied,
    it is included in the error message if the assertion fails. This can be useful
    for clarifying what was expected or explaining where a bug may have occurred to
    cause the assertion to fail. I rarely use this syntax, however, preferring to
    use descriptive names for the test method instead.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个断言方法都接受一个名为 `msg` 的可选参数。如果提供，如果断言失败，它将包含在错误消息中。这可以用来澄清期望的内容或解释可能导致断言失败的错误可能发生的地方。然而，我很少使用这种语法，更愿意使用描述性的测试方法名称。
- en: Reducing boilerplate and cleaning up
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少样板代码和清理
- en: 'After writing a few small tests, we often find that we have to write the same
    setup code for several related tests. For example, the following `list` subclass
    has three methods for statistical calculations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编写几个小型测试后，我们经常发现我们必须为几个相关的测试编写相同的设置代码。例如，以下 `list` 子类有三个用于统计计算的方法：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Clearly, we''re going to want to test situations with each of these three methods
    that have very similar inputs. We''ll want to see what happens with empty lists,
    with lists containing non-numeric values, or with lists containing a normal dataset,
    for example. We can use the `setUp` method on the `TestCase` class to perform
    initialization for each test. This method accepts no arguments, and allows us
    to do arbitrary setup before each test is run. For example, we can test all three
    methods on identical lists of integers as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们将想要测试这三种方法在具有非常相似输入的情况下的情况。我们想看看空列表、包含非数值的列表或包含正常数据集的列表会发生什么。我们可以使用 `TestCase`
    类的 `setUp` 方法为每个测试执行初始化。此方法不接受任何参数，并允许我们在每个测试运行之前进行任意设置。例如，我们可以如下测试所有三种方法在相同的整数列表上：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we run this example, it indicates that all tests pass. Notice first that
    the `setUp` method is never explicitly called inside the three `test_*` methods.
    The test suite does this on our behalf. More importantly, notice how `test_median`
    alters the list, by adding an additional `4` to it, yet when the subsequent `test_mode`
    is called, the list has returned to the values specified in `setUp`. If it had
    not, there would be two fours in the list, and the `mode` method would have returned
    three values. This demonstrates that `setUp` is called individually before each
    test, ensuring the test class starts with a clean slate. Tests can be executed
    in any order, and the results of one test must never depend on any other tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此示例，它表明所有测试都通过。首先要注意的是，在三个 `test_*` 方法中从未显式调用 `setUp` 方法。测试套件代表我们这样做。更重要的是，注意
    `test_median` 如何通过向其中添加额外的 `4` 来改变列表，但在随后的 `test_mode` 被调用时，列表已返回 `setUp` 中指定的值。如果不是这样，列表中会有两个
    `4`，并且 `mode` 方法将返回三个值。这表明 `setUp` 在每个测试之前单独调用，确保测试类从一个干净的状态开始。测试可以按任何顺序执行，并且一个测试的结果绝不能依赖于任何其他测试。
- en: In addition to the `setUp` method, `TestCase` offers a no-argument `tearDown`
    method, which can be used for cleaning up after each and every test on the class
    has run. This method is useful if cleanup requires anything other than letting
    an object be garbage collected.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`setUp`方法外，`TestCase`还提供了一个无参数的`tearDown`方法，可以在每个测试在类中运行后用于清理。如果清理需要除让对象被垃圾回收之外的其他操作，这个方法很有用。
- en: For example, if we are testing code that does file I/O, our tests may create
    new files as a side effect of testing. The `tearDown` method can remove these
    files and ensure the system is in the same state it was before the tests ran.
    Test cases should never have side effects. In general, we group test methods into
    separate `TestCase` subclasses depending on what setup code they have in common.
    Several tests that require the same or similar setup will be placed in one class,
    while tests that require unrelated setup go in another class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在测试执行文件I/O的代码，我们的测试可能会在测试过程中创建新的文件作为副作用。`tearDown`方法可以删除这些文件并确保系统处于测试运行之前相同的状态。测试用例不应该有任何副作用。通常，我们会根据它们共有的设置代码将测试方法分组到不同的`TestCase`子类中。需要相同或类似设置的几个测试将被放在一个类中，而需要无关设置的测试则放在另一个类中。
- en: Organizing and running tests
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织和运行测试
- en: 'It doesn''t take long for a collection of unit tests to grow very large and
    unwieldy. It can quickly become complicated to load and run all the tests at once.
    This is a primary goal of unit testing: trivially run all tests on our program
    and get a quick *yes or no* answer to the question, *did my recent changes break
    anything?*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试集合很快就会变得非常大且难以管理。一次性加载和运行所有测试可能会变得很复杂。这是单元测试的主要目标：轻松运行程序上的所有测试，并快速得到一个“是”或“否”的答案，回答问题：“我的最近更改是否破坏了任何东西？”
- en: As with normal program code, we should divide our test classes into modules
    and packages that keep them organized. If you name each test module starting with
    the four characters *test*, there's an easy way to find and run them all. Python's
    `discover` module looks for any modules in the current folder or subfolders with
    names that start with `test`. If it finds any `TestCase` objects in these modules,
    the tests are executed. It's a painless way to ensure we don't miss running any
    tests. To use it, ensure your test modules are named `test_<something>.py` and
    then run the `python3``-m``unittest``discover `command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如正常的程序代码一样，我们应该将我们的测试类划分成模块和包，以保持它们的组织。如果你以四个字符*test*命名每个测试模块，那么找到并运行它们会变得很容易。Python的`discover`模块会在当前文件夹或子文件夹中查找任何以`test`开头的模块。如果它在这些模块中找到任何`TestCase`对象，就会执行测试。这是一种确保我们不遗漏任何测试的简单方法。要使用它，确保你的测试模块命名为`test_<something>.py`，然后运行`python3
    -m unittest discover`命令。
- en: Most Python programmers choose to put their tests in a separate package (usually
    named `tests/` alongside their source directory). This is not required, however.
    Sometimes it makes sense to put the test modules for different packages in a subpackage
    next to that package, for example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python程序员选择将他们的测试放在一个单独的包中（通常命名为`tests/`，位于源目录旁边）。然而，这并不是必需的。有时，将不同包的测试模块放在该包旁边的子包中是有意义的，例如。
- en: Ignoring broken tests
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略损坏的测试
- en: Sometimes, a test is known to fail, but we don't want the test suite to report
    the failure. This may be because a broken or unfinished feature has tests written,
    but we aren't currently focusing on improving it. More often, it happens because
    a feature is only available on a certain platform, Python version, or for advanced
    versions of a specific library. Python provides us with a few decorators to mark
    tests as expected to fail or to be skipped under known conditions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个测试已知会失败，但我们不希望测试套件报告失败。这可能是由于一个损坏或未完成的特性已经编写了测试，但我们目前并没有专注于改进它。更常见的情况是，因为一个特性仅在某个平台、Python版本或特定库的高级版本中可用。Python为我们提供了一些装饰器来标记测试为预期失败或在已知条件下跳过。
- en: 'These decorators are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器如下：
- en: '`expectedFailure()`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedFailure()`'
- en: '`skip(reason)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip(reason)`'
- en: '`skipIf(condition, reason)`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipIf(condition, reason)`'
- en: '`skipUnless(condition, reason)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipUnless(condition, reason)`'
- en: 'These are applied using the Python decorator syntax. The first one accepts
    no arguments, and simply tells the test runner not to record the test as a failure
    when it fails. The `skip` method goes one step further and doesn''t even bother
    to run the test. It expects a single string argument describing why the test was
    skipped. The other two decorators accept two arguments, one a Boolean expression
    that indicates whether or not the test should be run, and a similar description.
    In use, these three decorators might be applied as they are in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是通过 Python 装饰器语法应用的。第一个装饰器不接受任何参数，只是简单地告诉测试运行器当测试失败时不要将其记录为失败。`skip` 方法更进一步，甚至都不麻烦去运行测试。它期望一个字符串参数，描述为什么跳过了测试。其他两个装饰器接受两个参数，一个是布尔表达式，指示是否应该运行测试，以及一个类似的描述。在实际使用中，这三个装饰器可能像以下代码中那样应用：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first test fails, but it is reported as an expected failure; the second
    test is never run. The other two tests may or may not be run depending on the
    current Python version and operating system. On my Linux system, running Python
    3.7, the output looks as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试失败了，但它被报告为预期的失败；第二个测试从未运行。其他两个测试是否运行取决于当前的 Python 版本和操作系统。在我的 Linux 系统上，运行
    Python 3.7，输出如下：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `x` on the first line indicates an expected failure; the two `s` characters
    represent skipped tests, and the `F` indicates a real failure, since the conditional
    to `skipUnless` was `True` on my system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的 `x` 表示预期的失败；两个 `s` 字符表示跳过的测试，而 `F` 表示真正的失败，因为在我的系统上 `skipUnless` 的条件是 `True`。
- en: Testing with pytest
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 进行测试
- en: The Python `unittest` module requires a lot of boilerplate code to set up and
    initialize tests. It is based on the very popular JUnit testing framework for
    Java. It even uses the same method names (you may have noticed they don't conform
    to the PEP-8 naming standard, which suggests snake_case rather than CamelCase
    to indicate a method name) and test layout. While this is effective for testing
    in Java, it's not necessarily the best design for Python testing. I actually find
    the `unittest` framework to be an excellent example of overusing object-oriented
    principles.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `unittest` 模块需要大量的样板代码来设置和初始化测试。它基于非常流行的 Java 测试框架 JUnit。它甚至使用了相同的方法名（你可能已经注意到，它们并不符合
    PEP-8 命名标准，该标准建议使用 snake_case 而不是 CamelCase 来表示方法名）和测试布局。虽然这对于 Java 测试来说很有效，但并不一定是
    Python 测试的最佳设计。实际上，我发现 `unittest` 框架是过度使用面向对象原则的一个很好的例子。
- en: Because Python programmers like their code to be elegant and simple, other test
    frameworks have been developed, outside the standard library. Two of the more
    popular ones are `pytest` and `nose`. The former is more robust and has had Python
    3 support for much longer, so we'll discuss it here.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 程序员喜欢他们的代码优雅简洁，因此已经开发了一些其他测试框架，这些框架位于标准库之外。其中两个更受欢迎的是 `pytest` 和 `nose`。前者更健壮，并且对
    Python 3 的支持时间更长，所以我们在这里将讨论它。
- en: Since `pytest` is not part of the standard library, you'll need to download
    and install it yourself. You can get it from the `pytest` home page at [http://pytest.org/](http://pytest.org/).
    The website has comprehensive installation instructions for a variety of interpreters
    and platforms, but you can usually get away with the more common Python package
    installer, pip. Just type `pip install pytest` on your command line and you'll
    be good to go.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `pytest` 不是标准库的一部分，您需要自行下载并安装它。您可以从 `pytest` 的主页 [http://pytest.org/](http://pytest.org/)
    获取它。该网站提供了针对各种解释器和平台的全面安装说明，但通常您可以使用更常见的 Python 软件包安装程序 pip。只需在命令行中输入 `pip install
    pytest` 即可。
- en: '`pytest` has a substantially different layout from the `unittest` module. It
    doesn''t require test cases to be classes. Instead, it takes advantage of the
    fact that Python functions are objects, and allows any properly named function
    to behave like a test. Rather than providing a bunch of custom methods for asserting
    equality, it uses the `assert` statement to verify results. This makes tests more
    readable and maintainable.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 的布局与 `unittest` 模块有显著不同。它不需要测试用例是类。相反，它利用了 Python 函数是对象的事实，并允许任何正确命名的函数表现得像测试。它不是提供大量自定义方法来断言相等性，而是使用
    `assert` 语句来验证结果。这使得测试更易于阅读和维护。'
- en: When we run `pytest`, it starts in the current folder and searches for any modules
    or subpackages with names beginning with the characters `test_`. If any functions
    in this module also start with `test`, they will be executed as individual tests.
    Furthermore, if there are any classes in the module whose name starts with `Test`,
    any methods on that class that start with `test_` will also be executed in the
    test environment.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `pytest` 时，它将在当前文件夹中启动并搜索以字符 `test_` 开头的任何模块或子包。如果此模块中的任何函数也以 `test` 开头，它们将被作为单独的测试执行。此外，如果模块中存在以
    `Test` 开头的类，该类上以 `test_` 开头的方法也将被在测试环境中执行。
- en: 'Using the following code, let''s port the simplest possible `unittest` example
    we wrote earlier to `pytest`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，让我们将之前编写的最简单的 `unittest` 示例移植到 `pytest`：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the exact same test, we've written two lines of more readable code, in comparison
    to the six lines required in our first `unittest` example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完全相同的测试，我们编写了两行更易读的代码，相比之下，我们第一个 `unittest` 示例需要六行代码。
- en: 'However, we are not forbidden from writing class-based tests. Classes can be
    useful for grouping related tests together or for tests that need to access related
    attributes or methods on the class. The following example shows an extended class
    with a passing and a failing test; we''ll see that the error output is more comprehensive
    than that provided by the `unittest` module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并没有被禁止编写基于类的测试。类可以用于将相关的测试分组在一起，或者用于需要访问类上相关属性或方法的测试。以下示例显示了一个包含通过和失败测试的扩展类；我们将看到错误输出比
    `unittest` 模块提供的更全面：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that the class doesn''t have to extend any special objects to be picked
    up as a test (although `pytest` will run standard `unittest TestCases` just fine).
    If we run `pytest <filename>`, the output looks as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类不需要扩展任何特殊对象就可以被识别为测试（尽管 `pytest` 可以很好地运行标准的 `unittest TestCases`）。如果我们运行
    `pytest <filename>`，输出如下：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output starts with some useful information about the platform and interpreter.
    This can be useful for sharing or discussing bugs across disparate systems. The
    third line tells us the name of the file being tested (if there are multiple test
    modules picked up, they will all be displayed), followed by the familiar `.F`
    we saw in the `unittest` module; the `.` character indicates a passing test, while
    the letter `F` demonstrates a failure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以有关平台和解释器的一些有用信息开始。这可以用于在不同系统间共享或讨论错误。第三行告诉我们正在测试的文件名（如果有多个测试模块被选中，它们都将显示），然后是我们在
    `unittest` 模块中看到的熟悉的 `.F`；`.` 字符表示通过测试，而字母 `F` 表示失败。
- en: 'After all tests have run, the error output for each of them is displayed. It
    presents a summary of local variables (there is only one in this example: the
    `self` parameter passed into the function), the source code where the error occurred,
    and a summary of the error message. In addition, if an exception other than an
    `AssertionError` is raised, `pytest` will present us with a complete traceback,
    including source code references.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试运行完毕后，每个测试的错误输出都会显示。它展示了局部变量的摘要（在这个例子中只有一个：传递给函数的 `self` 参数），错误发生的源代码，以及错误信息的摘要。此外，如果抛出了除
    `AssertionError` 之外的异常，`pytest` 将向我们展示完整的回溯，包括源代码引用。
- en: By default, `pytest` suppresses output from `print` statements if the test is
    successful. This is useful for test debugging; when a test is failing, we can
    add `print` statements to the test to check the values of specific variables and
    attributes as the test runs. If the test fails, these values are output to help
    with diagnosis. However, once the test is successful, the `print` statement output
    is not displayed, and they are easily ignored. We don't have to *clean up* output
    by removing `print` statements. If the tests ever fail again, due to future changes,
    the debugging output will be immediately available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果测试成功，`pytest` 会抑制 `print` 语句的输出。这对于测试调试很有用；当测试失败时，我们可以在测试中添加 `print`
    语句来检查特定变量和属性在测试运行时的值。如果测试失败，这些值将被输出以帮助诊断。然而，一旦测试成功，`print` 语句的输出就不会显示，并且很容易被忽略。我们不需要通过删除
    `print` 语句来*清理*输出。如果测试由于未来的更改而再次失败，调试输出将立即可用。
- en: One way to do setup and cleanup
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种进行设置和清理的方式
- en: '`pytest` supports setup and teardown methods similar to those used in `unittest`,
    but it provides even more flexibility. We''ll discuss these briefly, since they
    are familiar, but they are not used as extensively as in the `unittest` module,
    as `pytest` provides us with a powerful fixtures facility, which we''ll discuss
    in the next section.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 支持类似于 `unittest` 中使用的设置和清理方法，但它提供了更多的灵活性。由于这些方法很熟悉，我们将简要讨论它们，但它们在
    `pytest` 模块中的使用并不像在 `unittest` 模块中那么广泛，因为 `pytest` 为我们提供了一个强大的固定设施，我们将在下一节中讨论。'
- en: 'If we are writing class-based tests, we can use two methods called `setup_method`
    and `teardown_method` in the same way that `setUp` and `tearDown` are called in
    `unittest`. They are called before and after each test method in the class to
    perform setup and cleanup duties. There is one difference from the `unittest`
    methods though. Both methods accept an argument: the function object representing
    the method being called.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写基于类的测试，我们可以使用两个方法 `setup_method` 和 `teardown_method`，就像在 `unittest`
    中调用 `setUp` 和 `tearDown` 一样。它们在类中的每个测试方法之前和之后被调用，以执行设置和清理任务。尽管如此，与 `unittest`
    方法有一个不同之处。两种方法都接受一个参数：表示被调用方法的函数对象。
- en: In addition, `pytest` provides other setup and teardown functions to give us
    more control over when setup and cleanup code is executed. The `setup_class` and
    `teardown_class` methods are expected to be class methods; they accept a single
    argument (there is no `self` argument) representing the class in question. These
    methods are only run when the class is initiated rather than on each test run.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`pytest` 提供了其他设置和清理函数，以让我们能够更好地控制设置和清理代码的执行时机。`setup_class` 和 `teardown_class`
    方法预期是类方法；它们接受一个单一参数（没有 `self` 参数），代表相关的类。这些方法只在类被初始化时运行，而不是在每次测试运行时。
- en: Finally, we have the `setup_module` and `teardown_module` functions, which are
    run immediately before and after all tests (in functions or classes) in that module.
    These can be useful for *one time* setup, such as creating a socket or database
    connection that will be used by all tests in the module. Be careful with this
    one, as it can accidentally introduce dependencies between tests if the object
    stores state that isn't correctly cleaned up between tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `setup_module` 和 `teardown_module` 函数，它们在该模块中所有测试（在函数或类中）之前和之后立即运行。这些函数可以用于
    *一次性* 设置，例如创建一个将被模块中所有测试使用的套接字或数据库连接。在使用这个功能时要小心，因为它可能会意外地在测试之间引入依赖关系，如果对象存储的状态在测试之间没有被正确清理的话。
- en: 'That short description doesn''t do a great job of explaining exactly when these
    methods are called, so let''s look at an example that illustrates exactly when
    it happens:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那个简短的描述并没有很好地解释这些方法的确切调用时间，所以让我们看看一个示例，以说明它确实发生的时间：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The sole purpose of the `BaseTest` class is to extract four methods that are
    otherwise identical to the test classes, and use inheritance to reduce the amount
    of duplicate code. So, from the point of view of `pytest`, the two subclasses
    have not only two test methods each, but also two setup and two teardown methods
    (one at the class level, one at the method level).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseTest` 类的唯一目的是提取四个方法，这些方法在其他方面与测试类相同，并使用继承来减少重复代码的数量。因此，从 `pytest` 的角度来看，这两个子类不仅各有两个测试方法，还有两个设置和两个清理方法（一个在类级别，一个在方法级别）。'
- en: 'If we run these tests using `pytest` with the `print` function output suppression
    disabled (by passing the `-s` or `--capture=no` flag), they show us when the various
    functions are called in relation to the tests themselves:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `pytest` 运行这些测试并禁用 `print` 函数输出（通过传递 `-s` 或 `--capture=no` 标志），它们会显示各种函数在测试本身相关时的调用时间：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The setup and teardown methods for the module are executed at the beginning
    and end of the session. Then the lone module-level test function is run. Next,
    the setup method for the first class is executed, followed by the two tests for
    that class. These tests are each individually wrapped in separate `setup_method`
    and `teardown_method` calls. After the tests have executed, the teardown method
    on the class is called. The same sequence happens for the second class, before
    the `teardown_module` method is finally called, exactly once.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的设置和清理方法在会话开始和结束时执行。然后运行唯一的模块级测试函数。接下来，执行第一个类的设置方法，然后是那个类的两个测试。这些测试分别被单独的
    `setup_method` 和 `teardown_method` 调用所包装。测试执行完毕后，将调用类的清理方法。对于第二个类，发生相同的序列，最后最终调用一次
    `teardown_module` 方法。
- en: A completely different way to set up variables
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种完全不同的设置变量的方式
- en: One of the most common uses for the various setup and teardown functions is
    to ensure certain class or module variables are available with a known value before
    each test method is run.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 各种设置和清理函数最常见的一个用途是确保在运行每个测试方法之前，某些类或模块变量具有已知的值。
- en: '`pytest` offers a completely different way of doing this, using what are known
    as **fixtures**. Fixtures are basically named variables that are predefined in
    a test configuration file. This allows us to separate configuration from the execution
    of tests, and allows fixtures to be used across multiple classes and modules.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`提供了一种完全不同的方法来做这件事，使用的是所谓的**测试设置**。测试设置基本上是在测试配置文件中预定义的命名变量。这允许我们将配置与测试执行分开，并允许测试设置在多个类和模块之间使用。'
- en: 'To use them, we add parameters to our test function. The names of the parameters
    are used to look up specific arguments in specially named functions. For example,
    if we wanted to test the `StatsList` class we used while demonstrating `unittest`,
    we would again want to repeatedly test a list of valid integers. But we can write
    our tests as follows instead of using a setup method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它们，我们在测试函数中添加参数。参数的名称用于在特别命名的函数中查找特定参数。例如，如果我们想测试我们在演示`unittest`时使用的`StatsList`类，我们可能还想反复测试一个有效的整数列表。但我们可以像下面这样编写测试，而不是使用设置方法：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each of the three test methods accepts a parameter named `valid_stats`; this
    parameter is created by calling the `valid_stats` function, which was decorated
    with `@pytest.fixture`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 三个测试方法中的每一个都接受一个名为`valid_stats`的参数；这个参数是通过调用装饰了`@pytest.fixture`的`valid_stats`函数创建的。
- en: Fixtures can do a lot more than return basic variables. A `request` object can
    be passed into the fixture factory to provide extremely useful methods and attributes
    to modify the funcarg's behavior. The `module`, `cls`, and `function` attributes
    allow us to see exactly which test is requesting the fixture. The `config` attribute
    allows us to check command-line arguments and a great deal of other configuration
    data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置可以做很多比返回基本变量更多的事情。可以将`request`对象传递给测试设置工厂，以提供修改funcarg行为极其有用的方法和属性。`module`、`cls`和`function`属性允许我们确切地看到哪个测试正在请求测试设置。`config`属性允许我们检查命令行参数和大量其他配置数据。
- en: 'If we implement the fixture as a generator, we can run cleanup code after each
    test is run. This provides the equivalent of a teardown method, except on a per-fixture
    basis. We can use it to clean up files, close connections, empty lists, or reset
    queues. For example, the following code tests the `os.mkdir` functionality by
    creating a temporary directory fixture:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将测试设置实现为一个生成器，我们可以在每个测试运行后运行清理代码。这提供了类似于清理方法的等效功能，但基于每个测试设置。我们可以用它来清理文件、关闭连接、清空列表或重置队列。例如，以下代码通过创建一个临时目录测试设置来测试`os.mkdir`功能：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The fixture creates a new empty temporary directory for files to be created
    in. It yields this for use in the test, but removes that directory (using `shutil.rmtree`,
    which recursively removes a directory and anything inside it) after the test has
    completed. The filesystem is then left in the same state in which it started.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试设置创建一个用于创建文件的新空临时目录。它在测试中使用这个目录，但在测试完成后会删除该目录（使用`shutil.rmtree`，它递归地删除目录及其内部的所有内容）。然后文件系统会保持与开始时相同的状态。
- en: 'We can pass a `scope` parameter to create a fixture that lasts longer than
    one test. This is useful when setting up an expensive operation that can be reused
    by multiple tests, as long as the resource reuse doesn''t break the atomic or
    unit nature of the tests (so that one test does not rely on, and is not impacted
    by, a previous one). For example, if we were to test the following echo server,
    we may want to run only one instance of the server in a separate process, and
    then have multiple tests connect to that instance:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以传递一个`scope`参数来创建一个比一个测试更持久的测试设置。当设置一个可以由多个测试重用的昂贵操作时，这很有用，只要资源重用不会破坏测试的原子性或单元性（这样，一个测试就不会依赖于前一个测试，也不会受到前一个测试的影响）。例如，如果我们想要测试以下回声服务器，我们可能只想在单独的进程中运行一个服务器实例，然后让多个测试连接到该实例：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All this code does is listen on a specific port and wait for input from a client
    socket. When it receives input, it sends the same value back. To test this, we
    can start the server in a separate process and cache the result for use in multiple
    tests. Here''s how the test code might look:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码所做的只是监听特定端口并等待客户端套接字的输入。当它收到输入时，它会发送相同的值回送。为了测试这一点，我们可以在单独的进程中启动服务器并缓存结果以供多个测试使用。以下是测试代码可能的样子：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've created two fixtures here. The first runs the echo server in a separate
    process, and yields the process object, cleaning it up when it's finished. The
    second instantiates a new socket object for each test, and closes the socket when
    the test has completed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了两个 fixture。第一个在一个单独的进程中运行 echo 服务器，并在完成后清理它，产生进程对象。第二个为每个测试实例化一个新的套接字对象，并在测试完成后关闭套接字。
- en: The first fixture is the one we're currently interested in. From the `scope="session"`
    keyword argument passed into the decorator's constructor, `pytest` knows that
    we only want this fixture to be initialized and terminated once for the duration
    of the unit test session.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 fixture 是我们目前感兴趣的。从传递给装饰器构造函数的 `scope="session"` 关键字参数，`pytest` 知道我们只想在这个单元测试会话期间初始化和终止这个
    fixture 一次。
- en: The scope can be one of the strings `class`, `module`, `package`,  or `session`.
    It determines just how long the argument will be cached. We set it to `session` in
    this example, so it is cached for the duration of the entire `pytest` run. The
    process will not be terminated or restarted until all tests have run. The `module` scope,
    of course, caches it only for tests in that module, and the `class` scope treats
    the object more like a normal class setup and teardown.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可以是字符串 `class`、`module`、`package` 或 `session` 之一。它决定了参数将被缓存多长时间。在这个例子中，我们将其设置为
    `session`，因此它将在整个 `pytest` 运行期间被缓存。只有在所有测试都运行完毕后，进程才会被终止或重启。`module` 范围只会为该模块中的测试缓存它，而
    `class` 范围则更像是正常的类设置和销毁。
- en: At the time the third edition of this book went to print, the `package` scope
    was labeled experimental in `pytest`. Be careful with it, and they request that
    you supply bug reports.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当这本书的第三版准备印刷时，`package` 范围在 `pytest` 中被标记为实验性。请小心使用它，并请求您提供错误报告。
- en: Skipping tests with pytest
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 跳过测试
- en: 'As with the `unittest` module, it is frequently necessary to skip tests in
    `pytest`, for a similar variety of reasons: the code being tested hasn''t been
    written yet, the test only runs on certain interpreters or operating systems,
    or the test is time-consuming and should only be run under certain circumstances.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `unittest` 模块一样，在 `pytest` 中跳过测试通常是必要的，原因多种多样：被测试的代码尚未编写，测试只在某些解释器或操作系统上运行，或者测试耗时较长，应在特定情况下运行。
- en: 'We can skip tests at any point in our code, using the `pytest.skip` function.
    It accepts a single argument: a string describing why it has been skipped. This
    function can be called anywhere. If we call it inside a test function, the test
    will be skipped. If we call it at the module level, all the tests in that module
    will be skipped. If we call it inside a fixture, all tests that call that funcarg
    will be skipped.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码的任何位置跳过测试，使用 `pytest.skip` 函数。它接受一个参数：一个字符串，描述为什么它被跳过。这个函数可以在任何地方调用。如果我们在一个测试函数内部调用它，测试将被跳过。如果我们它在模块级别调用，该模块中的所有测试都将被跳过。如果我们它在
    fixture 内部调用，调用该 funcarg 的所有测试都将被跳过。
- en: 'Of course, in all these locations, it is often desirable to skip tests only
    if certain conditions are or are not met. Since we can execute the `skip` function
    at any place in Python code, we can execute it inside an `if` statement. So we
    may write a test that looks as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这些位置，通常我们只想在满足或未满足某些条件时跳过测试。由于我们可以在 Python 代码的任何位置执行 `skip` 函数，我们可以在 `if`
    语句内部执行它。因此，我们可能编写如下所示的测试：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's some pretty silly code, really. There is no Python platform named `fakeos`,
    so this test will skip on all operating systems. It shows how we can skip conditionally,
    and since the `if` statement can check any valid conditional, we have a lot of
    power over when tests are skipped. Often, we check `sys.version_info` to check
    the Python interpreter version, `sys.platform` to check the operating system,
    or `some_library.__version__` to check whether we have a recent enough version
    of a given API.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码真的很愚蠢。没有名为 `fakeos` 的 Python 平台，因此这个测试将在所有操作系统上跳过。它展示了我们如何有条件地跳过测试，并且由于
    `if` 语句可以检查任何有效的条件，我们在跳过测试时拥有很大的权力。通常，我们会检查 `sys.version_info` 来检查 Python 解释器版本，`sys.platform`
    来检查操作系统，或者 `some_library.__version__` 来检查我们是否有给定 API 的最新版本。
- en: 'Since skipping an individual test method or function based on a certain conditional
    is one of the most common uses of test skipping, `pytest` provides a convenience
    decorator that allows us to do this in one line. The decorator accepts a single
    string, which can contain any executable Python code that evaluates to a Boolean
    value. For example, the following test will only run on Python 3 or higher:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于某些条件跳过单个测试方法或函数是测试跳过的最常见用途之一，`pytest` 提供了一个便利的装饰器，允许我们在一行内完成此操作。该装饰器接受一个字符串，该字符串可以包含任何评估为布尔值的可执行
    Python 代码。例如，以下测试仅在 Python 3 或更高版本上运行：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `pytest.mark.xfail` decorator behaves similarly, except that it marks a
    test as expected to fail, similar to `unittest.expectedFailure()`. If the test
    is successful, it will be recorded as a failure. If it fails, it will be reported
    as expected behavior. In the case of `xfail`, the conditional argument is optional.
    If it is not supplied, the test will be marked as expected to fail under all conditions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest.mark.xfail` 装饰器的行为类似，但它的作用是标记一个测试预期会失败，类似于 `unittest.expectedFailure()`。如果测试成功，它将被记录为失败。如果测试失败，它将被报告为预期行为。在
    `xfail` 的情况下，条件参数是可选的。如果没有提供，测试将被标记为在所有条件下预期会失败。'
- en: The `pytest` has a ton of other features besides those described here and the
    developers are constantly adding innovative new ways to make your testing experience
    more enjoyable. They have thorough documentation on their website at [https://docs.pytest.org/](https://docs.pytest.org/).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这里描述的之外，`pytest` 还有许多其他功能，开发者们正在不断添加创新的新方法来使您的测试体验更加愉快。他们在其网站上提供了详尽的文档，网址为
    [https://docs.pytest.org/](https://docs.pytest.org/)。
- en: The `pytest` can find and run tests defined using the standard `unittest` library
    in addition to its own testing infrastructure. This means that if you want to
    migrate from `unittest` to `pytest`, you don't have to rewrite all your old tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 可以找到并运行使用标准 `unittest` 库定义的测试，以及它自己的测试基础设施。这意味着如果您想从 `unittest` 迁移到
    `pytest`，您不必重写所有旧测试。'
- en: Imitating expensive objects
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟昂贵对象
- en: Sometimes, we want to test code that requires an object be supplied that is
    either expensive or difficult to construct. In some cases, this may mean your
    API needs rethinking to have a more testable interface (which typically means
    a more usable interface). But we sometimes find ourselves writing test code that
    has a ton of boilerplate to set up objects that are only incidentally related
    to the code under test.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要测试需要提供昂贵或难以构建的对象的代码。在某些情况下，这可能意味着您的 API 需要重新思考以拥有更可测试的接口（这通常意味着更易用的接口）。但有时我们发现自己在编写大量样板代码来设置与被测试代码偶然相关的对象。
- en: 'For example, imagine we have some code that keeps track of flight statuses
    in an external key-value store (such as `redis` or `memcache`), such that we can
    store the timestamp and the most recent status. A basic version of such code might
    look as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一些代码，用于跟踪外部键值存储（如`redis`或`memcache`）中的航班状态，以便我们可以存储时间戳和最新状态。此类代码的基本版本可能如下所示：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are a lot of things we ought to test for that `change_status` method.
    We should check that it raises the appropriate error if a bad status is passed
    in. We need to ensure that it converts statuses to uppercase. We can see that
    the key and value have the correct formatting when the `set()` method is called
    on the `redis` object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `change_status` 方法，我们有很多事情应该测试。我们应该检查如果传入了一个错误的状态，它是否会引发适当的错误。我们需要确保它将状态转换为大写。当在
    `redis` 对象上调用 `set()` 方法时，我们可以看到键和值具有正确的格式。
- en: One thing we don't have to check in our unit tests, however, is that the `redis`
    object is properly storing the data. This is something that absolutely should
    be tested in integration or application testing, but at the unit test level, we
    can assume that the py-redis developers have tested their code and that this method
    does what we want it to. As a rule, unit tests should be self-contained and shouldn't
    rely on the existence of outside resources, such as a running Redis instance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的单元测试中，我们不需要检查的是 `redis` 对象是否正确存储数据。这是在集成或应用测试中绝对应该测试的事情，但在单元测试级别，我们可以假设
    py-redis 开发者已经测试了他们的代码，并且这个方法做了我们想要它做的事情。一般来说，单元测试应该是自包含的，并且不应该依赖于外部资源的存在，例如运行的
    Redis 实例。
- en: 'Instead, we only need to test that the `set()` method was called the appropriate
    number of times and with the appropriate arguments. We can use `Mock()` objects
    in our tests to replace the troublesome method with an object we can introspect.
    The following example illustrates the use of `Mock`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只需要测试`set()`方法是否被适当次数地调用，并且是否带有适当的参数。我们可以在测试中使用`Mock()`对象来替换有问题的方法，用一个我们可以内省的对象来替换。以下是一个使用`Mock`的示例：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This test, written using `pytest` syntax, asserts that the correct exception
    is raised when an inappropriate argument is passed in. In addition, it creates
    a `Mock` object for the `set` method and makes sure that it is never called. If
    it was, it would mean there was a bug in our exception handling code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试，使用`pytest`语法编写，断言当传递了不适当的参数时，会引发正确的异常。此外，它为`set`方法创建了一个`Mock`对象，并确保它从未被调用。如果它被调用了，那就意味着我们的异常处理代码中存在错误。
- en: Simply replacing the method worked fine in this case, since the object being
    replaced was destroyed in the end. However, we often want to replace a function
    or method only for the duration of a test. For example, if we want to test the
    timestamp formatting in the `Mock` method, we need to know exactly what `datetime.datetime.now()`
    is going to return. However, this value changes from run to run. We need some
    way to pin it to a specific value so we can test it deterministically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，简单地替换方法就足够了，因为被替换的对象最终被销毁了。然而，我们通常只想在测试期间替换一个函数或方法。例如，如果我们想测试`Mock`方法中的时间戳格式化，我们需要确切知道`datetime.datetime.now()`将要返回什么值。然而，这个值每次运行都会变化。我们需要某种方法将其固定到特定值，以便我们可以确定性地测试它。
- en: 'Temporarily setting a library function to a specific value is one of the few
    valid use cases for monkey-patching. The mock library provides a patch context
    manager that allows us to replace attributes on existing libraries with mock objects.
    When the context manager exits, the original attribute is automatically restored
    so as not to impact other test cases. Here''s an example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将库函数临时设置为特定值是猴子补丁的少数几个有效用例之一。模拟库提供了一个上下文管理器，允许我们用模拟对象替换现有库中的属性。当上下文管理器退出时，原始属性会自动恢复，以免影响其他测试用例。以下是一个示例：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we first construct a value called `fake_now`, which
    we will set as the return value of the `datetime.datetime.now` function. We have
    to construct this object before we patch `datetime.datetime`, because otherwise
    we'd be calling the patched `now` function before we constructed it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们首先构建了一个名为`fake_now`的值，我们将将其设置为`datetime.datetime.now`函数的返回值。我们必须在修补`datetime.datetime`之前构建此对象，否则我们会在构建它之前调用修补的`now`函数。
- en: The `with` statement invites the patch to replace the `datetime.datetime` module
    with a mock object, which is returned as the `dt `value. The neat thing about
    mock objects is that any time you access an attribute or method on that object,
    it returns another mock object. Thus, when we access `dt.now`, it gives us a new
    mock object. We set the `return_value` of that object to our `fake_now` object.
    Now, whenever the `datetime.datetime.now` function is called, it will return our
    object instead of a new mock object. But when the interpreter exits the context
    manager, the original `datetime.datetime.now()` functionality is restored.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句允许我们将`datetime.datetime`模块替换为模拟对象，该模拟对象作为`dt`值返回。关于模拟对象的一个好处是，每次你访问该对象的属性或方法时，它都会返回另一个模拟对象。因此，当我们访问`dt.now`时，它给我们一个新的模拟对象。我们将该对象的`return_value`设置为我们的`fake_now`对象。现在，每当调用`datetime.datetime.now`函数时，它将返回我们的对象而不是一个新的模拟对象。但是，当解释器退出上下文管理器时，原始的`datetime.datetime.now()`功能将得到恢复。'
- en: After calling our `change_status` method with known values, we use the `assert_called_once_with`
    function of the `Mock` class to ensure that the `now` function was indeed called
    exactly once with no arguments. We then call it a second time to prove that the
    `redis.set` method was called with arguments that were formatted as we expected
    them to be.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用已知值调用我们的`change_status`方法之后，我们使用`Mock`类的`assert_called_once_with`函数来确保`now`函数确实被无参数地调用了一次。然后我们再次调用它，以证明`redis.set`方法被调用了，并且参数格式与我们预期的相符。
- en: Mocking dates so you can have deterministic test results is a common patching
    scenario. If you are in a situation where you are doing a lot of this, you might
    appreciate the `freezegun` and `pytest-freezegun` projects available in the Python
    Package Index.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟日期以便您可以得到确定性的测试结果是常见的补丁场景。如果您处于这种情况，您可能会欣赏 Python 包索引中可用的 `freezegun` 和 `pytest-freezegun`
    项目。
- en: The previous example is a good indication of how writing tests can guide our
    API design. The `FlightStatusTracker` object looks sensible at first glance; we
    construct a `redis` connection when the object is constructed, and we call into
    it when we need it. When we write tests for this code, however, we discover that
    even if we mock out that `self.redis` variable on a `FlightStatusTracker`, the
    `redis` connection still has to be constructed. This call actually fails if there
    is no Redis server running, and our tests also fail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例很好地说明了编写测试如何指导我们的 API 设计。`FlightStatusTracker` 对象乍一看似乎是合理的；我们在对象构建时构建一个
    `redis` 连接，并在需要时调用它。然而，当我们为这段代码编写测试时，我们发现即使我们在 `FlightStatusTracker` 上模拟了 `self.redis`
    变量，`redis` 连接仍然需要被构建。如果 Redis 服务器没有运行，这个调用实际上会失败，我们的测试也会失败。
- en: 'We could solve this problem by mocking out the `redis.StrictRedis` class to
    return a mock in a `setUp` method. A better idea, however, might be to rethink
    our implementation. Instead of constructing the `redis` instance inside`__init__`,
    perhaps we should allow the user to pass one in, as in the following example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `setUp` 方法中模拟 `redis.StrictRedis` 类来返回一个模拟来解决此问题。然而，更好的想法可能是重新思考我们的实现。而不是在
    `__init__` 内部构建 `redis` 实例，也许我们应该允许用户传入一个，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This allows us to pass a mock in when we are testing, so the `StrictRedis`
    method never gets constructed. Additionally, it allows any client code that talks
    to `FlightStatusTracker` to pass in their own `redis` instance. There are a variety
    of reasons they might want to do this: they may have already constructed one for
    other parts of their code; they may have created an optimized implementation of
    the `redis` API; perhaps they have one that logs metrics to their internal monitoring
    systems. By writing a unit test, we''ve uncovered a use case that makes our API
    more flexible from the start, rather than waiting for clients to demand we support
    their exotic needs.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在测试时传递一个模拟，这样 `StrictRedis` 方法就永远不会被构建。此外，它还允许任何与 `FlightStatusTracker`
    通信的客户端代码传入他们自己的 `redis` 实例。他们可能出于各种原因想要这样做：他们可能已经为代码的其他部分构建了一个实例；他们可能已经创建了一个优化的
    `redis` API 实现；也许他们有一个将指标记录到他们内部监控系统中的实例。通过编写单元测试，我们已经揭示了一个使用案例，这使得我们的 API 从一开始就更加灵活，而不是等待客户端要求我们支持他们的特殊需求。
- en: This has been a brief introduction to the wonders of mocking code. Mocks are
    part of the standard `unittest` library since Python 3.3, but as you see from
    these examples, they can also be used with `pytest` and other libraries. Mocks
    have other more advanced features that you may need to take advantage of as your
    code gets more complicated. For example, you can use the `spec` argument to invite
    a mock to imitate an existing class so that it raises an error if code tries to
    access an attribute that does not exist on the imitated class. You can also construct
    mock methods that return different arguments each time they are called by passing
    a list as the `side_effect` argument. The `side_effect` parameter is quite versatile;
    you can also use it to execute arbitrary functions when the mock is called or
    to raise an exception.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对模拟代码奇妙的简要介绍。自 Python 3.3 以来，模拟是标准 `unittest` 库的一部分，但正如您从这些示例中看到的，它们也可以与 `pytest`
    和其他库一起使用。随着代码变得更加复杂，模拟还有其他更高级的功能，您可能需要利用这些功能。例如，您可以使用 `spec` 参数邀请模拟模仿一个现有的类，这样如果代码尝试访问模仿类上不存在的属性时，就会引发错误。您还可以构造模拟方法，通过将列表作为
    `side_effect` 参数传递，每次调用时返回不同的参数。`side_effect` 参数非常灵活；您还可以在模拟被调用时执行任意函数或引发异常。
- en: In general, we should be quite stingy with mocks. If we find ourselves mocking
    out multiple elements in a given unit test, we may end up testing the mock framework
    rather than our real code. This serves no useful purpose whatsoever; after all,
    mocks are well-tested already! If our code is doing a lot of this, it's probably
    another sign that the API we are testing is poorly designed. Mocks should exist
    at the boundaries between the code under test and the libraries they interface
    with. If this isn't happening, we may need to change the API so that the boundaries
    are redrawn in a different place.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们应该对模拟对象非常吝啬。如果我们发现自己在一个单元测试中模拟了多个元素，我们可能最终测试的是模拟框架而不是我们的真实代码。这没有任何实际用途；毕竟，模拟对象已经过充分测试了！如果我们的代码做了很多这种事情，这可能又是我们正在测试的API设计不佳的另一个迹象。模拟对象应该存在于被测试代码和它们交互的库之间的边界上。如果这种情况没有发生，我们可能需要更改API，以便在另一个地方重新绘制边界。
- en: How much testing is enough?
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多少测试才算足够？
- en: We've already established that untested code is broken code. But how can we
    tell how well our code is tested? How do we know how much of our code is actually
    being tested and how much is broken? The first question is the more important
    one, but it's hard to answer. Even if we know we have tested every line of code
    in our application, we do not know that we have tested it properly. For example,
    if we write a stats test that only checks what happens when we provide a list
    of integers, it may still fail spectacularly if used on a list of floats, strings,
    or self-made objects. The onus of designing complete test suites still lies with
    the programmer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定未测试的代码是损坏的代码。但我们如何知道我们的代码测试得有多好？我们如何知道我们的代码实际被测试了多少，以及有多少是损坏的？第一个问题更重要，但很难回答。即使我们知道我们已经测试了我们应用程序中的每一行代码，我们也不知道我们是否已经正确地测试了它。例如，如果我们编写一个统计测试，它只检查当我们提供一个整数列表时会发生什么，那么如果它被用于一个浮点数列表、字符串或自定义对象，它可能仍然会失败得非常惨烈。设计完整测试套件的责任仍然在于程序员。
- en: The second question–how much of our code is actually being tested–is easy to
    verify. **Code coverage** is an estimate of the number of lines of code that are
    executed by a program. If we know that number and the number of lines that are
    in the program, we can get an estimate of what percentage of the code was really
    tested, or covered. If we additionally have an indicator as to which lines were
    not tested, we can more easily write new tests to ensure those lines are less
    broken.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题——我们的代码实际被测试了多少——很容易验证。**代码覆盖率**是程序执行的代码行数的估计。如果我们知道这个数字以及程序中的行数，我们可以估计出实际测试或覆盖的代码百分比。如果我们还有一个指示哪些行未被测试的指标，我们可以更容易地编写新的测试来确保这些行不太可能出错。
- en: The most popular tool for testing code coverage is called, memorably enough,
    `coverage.py`. It can be installed like most other third-party libraries, using
    the `pip install coverage `command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码覆盖率最流行的工具叫做 `coverage.py`，这个名字足够让人记忆深刻。它可以通过 `pip install coverage` 命令像大多数其他第三方库一样进行安装。
- en: 'We don''t have space to cover all the details of the coverage API, so we''ll
    just look at a few typical examples. If we have a Python script that runs all
    our unit tests for us (for example, using `unittest.main`,  `discover`, `pytest`,
    or a custom test runner), we can use the following command to perform a coverage
    analysis:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有空间涵盖覆盖率API的所有细节，所以我们只看几个典型的例子。如果我们有一个Python脚本为我们运行所有单元测试（例如，使用 `unittest.main`、`discover`、`pytest`
    或自定义测试运行器），我们可以使用以下命令进行覆盖率分析：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command will exit normally, but it creates a file named `.coverage`, which
    holds the data from the run. We can now use the `coverage``report` command to
    get an analysis of the code coverage:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将正常退出，但它会创建一个名为 `.coverage` 的文件，该文件包含运行的数据。现在我们可以使用 `coverage report` 命令来获取代码覆盖率的分析：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting output should be as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出应该如下所示：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This basic report lists the files that were executed (our unit test and a module
    it imported). The number of lines of code in each file, and the number that were
    executed by the test are also listed. The two numbers are then combined to estimate
    the amount of code coverage. If we pass the `-m` option to the `report` command,
    it will additionally add a column that looks as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基本报告列出了已执行的文件（我们的单元测试和它导入的模块）。每个文件中的代码行数以及由测试执行的行数也列出来了。这两个数字随后合并来估计代码覆盖率。如果我们向
    `report` 命令传递 `-m` 选项，它还会额外添加一个如下所示的列：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The ranges of lines listed here identify lines in the `stats` module that were
    not executed during the test run.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的行范围标识了在测试运行期间未执行的`stats`模块中的行。
- en: 'The example we just ran the code coverage tool on uses the same stats module
    we created earlier in the chapter. However, it deliberately uses a single test
    that fails to test a lot of code in the file. Here''s the test:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚运行代码覆盖率工具的示例使用的是我们在本章早期创建的相同`stats`模块。然而，它故意使用一个失败的测试，该测试未能测试文件中的大量代码。以下是测试用例：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code doesn't test the median or mode functions, which correspond to the
    line numbers that the coverage output told us were missing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有测试中值或众数函数，这与覆盖率输出告诉我们的缺失行号相对应。
- en: 'The textual report provides sufficient information, but if we use the `coverage
    html` command, we can get an even more useful interactive HTML report, which we
    can view in a web browser. The web page even highlights which lines in the source
    code were and were not tested. Here''s how it looks:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 文本报告提供了足够的信息，但如果我们使用`coverage html`命令，我们可以得到一个更有用的交互式HTML报告，我们可以在网页浏览器中查看。网页甚至会突出显示哪些源代码行被测试过，哪些没有被测试。以下是它的样子：
- en: '![](img/27269204-aae4-40d5-9455-96a15d846345.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27269204-aae4-40d5-9455-96a15d846345.png)'
- en: We can use the `coverage.py` module with `pytest` as well. We'll need to install
    the `pytest` plugin for code coverage, using `pip install pytest-coverage`. The
    plugin adds several command-line options to `pytest`, the most useful being `--cover-report`,
    which can be set to `html`, `report`, or `annotate` (the latter actually modifies
    the original source code to highlight any lines that were not covered).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`coverage.py`模块与`pytest`一起。我们需要安装`pytest`的代码覆盖率插件，使用`pip install pytest-coverage`。该插件为`pytest`添加了几个命令行选项，其中最有用的是`--cover-report`，可以设置为`html`、`report`或`annotate`（后者实际上修改了原始源代码，以突出显示任何未覆盖的行）。
- en: Unfortunately, if we could somehow run a coverage report on this section of
    the chapter, we'd find that we have not covered most of what there is to know
    about code coverage! It is possible to use the coverage API to manage code coverage
    from within our own programs (or test suites), and `coverage.py` accepts numerous
    configuration options that we haven't touched on. We also haven't discussed the
    difference between statement coverage and branch coverage (the latter is much
    more useful, and the default in recent versions of `coverage.py`), or other styles
    of code coverage.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果我们能以某种方式运行本章这一部分的覆盖率报告，我们会发现我们没有涵盖关于代码覆盖率的大部分知识！我们可以使用覆盖率API从我们的程序（或测试套件）内部管理代码覆盖率，`coverage.py`接受许多我们尚未涉及的配置选项。我们也没有讨论语句覆盖率和分支覆盖率之间的区别（后者更有用，且是`coverage.py`最新版本的默认设置），或其他代码覆盖率风格。
- en: Bear in mind that while 100 percent code coverage is a lofty goal that we should
    all strive for, 100 percent coverage is not enough! Just because a statement was
    tested does not mean that it was tested properly for all possible inputs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管100%的代码覆盖率是一个崇高的目标，我们都应该为之努力，但100%的覆盖率是不够的！仅仅因为一个语句被测试了，并不意味着它对所有可能的输入都进行了适当的测试。
- en: Case study
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: Let's walk through test-driven development by writing a small, tested, cryptography
    application. Don't worry–you won't need to understand the mathematics behind complicated
    modern encryption algorithms such as AES or RSA. Instead, we'll be implementing
    a sixteenth-century algorithm known as the Vigenère cipher. The application simply
    needs to be able to encode and decode a message, given an encoding keyword, using
    this cipher.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个小型、经过测试的加密应用程序来了解测试驱动开发。别担心——你不需要理解复杂现代加密算法（如AES或RSA）背后的数学。相反，我们将实现一个十六世纪的算法，称为维吉尼亚密码。该应用程序只需要能够使用这个密码，给定一个编码关键字，对消息进行编码和解码。
- en: If you want a deep dive into how the RSA algorithm works, I wrote one on my
    blog at [https://dusty.phillips.codes/](https://dusty.phillips.codes/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解RSA算法的工作原理，我在我的博客上写了一篇关于它的文章，链接为[https://dusty.phillips.codes/](https://dusty.phillips.codes/)。
- en: 'First, we need to understand how the cipher works if we apply it manually (without
    a computer). We start with a table like the following one:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解如果我们手动应用（不使用计算机）这个密码，它是如何工作的。我们从一个像以下这样的表格开始：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Given a keyword, TRAIN, we can encode the message ENCODED IN PYTHON as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 给定关键字TRAIN，我们可以将消息ENCODED IN PYTHON编码如下：
- en: 'Repeat the keyword and message together, such that it is easy to map letters
    from one to the other:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将关键字和消息一起重复，以便容易地将一个映射到另一个：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For each letter in the plaintext, find the row that begins with that letter
    in the table.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于明文中的每个字母，在表中找到以该字母开头的行。
- en: Find the column with the letter associated with the keyword letter for the chosen
    plaintext letter.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到与所选明文字母相关的关键词字母的列。
- en: The encoded character is at the intersection of this row and column.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码字符位于该行和该列的交叉处。
- en: For example, the row starting with E intersects the column starting with T at
    character X. So, the first letter in the ciphertext is X. The row starting with
    N intersects the column starting with R at character E, leading to the ciphertext
    XE. C intersects A at C, and O intersects I at W. D and N map to Q, while E and
    T map to X. The full encoded message is XECWQXUIVCRKHWA.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以E开头的行与以T开头的列在字符X处相交。所以，密文中的第一个字母是X。以N开头的行与以R开头的列在字符E处相交，导致密文XE。C与A相交于C，O与I相交于W。D和N映射到Q，而E和T映射到X。完整的编码信息是XECWQXUIVCRKHWA。
- en: Decoding follows the opposite procedure. First, find the row with the character
    for the shared keyword (the T row), then find the location in that row where the
    encoded character (the X) is located. The plaintext character is at the top of
    the column for that row (the E).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 解码遵循相反的程序。首先，找到包含共享关键词（T行）的行，然后找到该行中编码字符（X）的位置。明文字符位于该行的顶部（E）。
- en: Implementing it
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: Our program will need an `encode` method that takes a keyword and plaintext
    and returns the ciphertext, and a `decode` method that accepts a keyword and ciphertext
    and returns the original message.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序需要一个`encode`方法，它接受一个关键词和明文并返回密文，以及一个`decode`方法，它接受一个关键词和密文并返回原始信息。
- en: 'But rather than just writing those methods, let''s follow a test-driven development
    strategy. We''ll be using `pytest` for our unit testing. We need an `encode` method,
    and we know what it has to do; let''s write a test for that method first, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不仅仅要编写这些方法，而是要遵循测试驱动开发策略。我们将使用`pytest`进行单元测试。我们需要一个`encode`方法，我们知道它需要做什么；让我们首先为该方法编写一个测试，如下所示：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This test fails, naturally, because we aren't importing a `VigenereCipher` class
    anywhere. Let's create a new module to hold that class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试自然会失败，因为我们没有在任何地方导入`VigenereCipher`类。让我们创建一个新的模块来存放这个类。
- en: 'Let''s start with the following `VigenereCipher` class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下`VigenereCipher`类开始：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we add a `from``vigenere_cipher``import``VigenereCipher` line to the top
    of our test class and run `pytest`, the preceding test will pass! We've finished
    our first test-driven development cycle.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在测试类的顶部添加一行`from`vigenere_cipher`import`VigenereCipher`并运行`pytest`，前面的测试就会通过！我们已经完成了我们的第一个测试驱动开发周期。
- en: 'This may seem like a ridiculously silly thing to test, but it''s actually verifying
    a lot. The first time I implemented it, I mispelled cipher as *cypher* in the
    class name. Even my basic unit test helped catch a bug. Even so, returning a hardcoded
    string is obviously not the most sensible implementation of a cipher class, so
    let''s add a second test, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个荒谬可笑的测试，但实际上它验证了很多内容。第一次我实现它时，我在类名中将cipher误拼为*cypher*。即使是我的基本单元测试也帮助捕捉到了一个错误。即便如此，返回一个硬编码的字符串显然不是cipher类最明智的实现方式，所以让我们添加第二个测试，如下所示：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Ah, now that test will fail. It looks like we''re going to have to work harder.
    But I just thought of something: what if someone tries to encode a string with
    spaces or lowercase characters? Before we start implementing the encoding, let''s
    add some tests for these cases, so we don''t forget them. The expected behavior
    will be to remove spaces, and to convert lowercase letters to capitals, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，现在这个测试会失败。看起来我们得更加努力了。但我刚刚想到了一件事：如果有人尝试用包含空格或小写字母的字符串进行编码怎么办？在我们开始实现编码之前，让我们为这些情况添加一些测试，这样我们就不会忘记它们。预期的行为将是删除空格，并将小写字母转换为大写字母，如下所示：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we run the new test suite, we find that the new tests pass (they expect the
    same hardcoded string). But they ought to fail later if we forget to account for
    these cases.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行新的测试套件，我们会发现新的测试通过了（它们期望相同的硬编码字符串）。但如果我们忘记考虑这些情况，它们应该会在之后失败。
- en: Now that we have some test cases, let's think about how to implement our encoding
    algorithm. Writing code to use a table like we used in the earlier manual algorithm
    is possible, but seems complicated, considering that each row is just an alphabet
    rotated by an offset number of characters. It turns out (I asked Wikipedia) that
    we can use modular arithmetic to combine the characters instead of doing a table
    lookup.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些测试用例，让我们考虑如何实现我们的编码算法。编写使用类似于我们在早期手动算法中使用的表格的代码是可能的，但考虑到每一行只是通过偏移量字符旋转的字母表，这似乎很复杂。结果（我查了维基百科）是我们可以使用模运算来组合字符，而不是进行表格查找。
- en: 'Given plaintext and keyword characters, if we convert the two letters to their
    numerical values (according to their position in the alphabet, with A being 0
    and Z being 25), add them together, and take the remainder mod 26, we get the
    ciphertext character! This is a straightforward calculation, but since it happens
    on a character-by-character basis, we should probably put it in its own function.
    Before we do that, then, we should write a test for the new function, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 给定明文和关键字字符，如果我们把这两个字母转换成它们的数值（根据它们在字母表中的位置，A是0，Z是25），将它们相加，然后取余数模26，我们得到密文字符！这是一个简单的计算，但由于它是基于字符逐个进行的，我们可能应该把它放在它自己的函数中。在我们这样做之前，我们应该为这个新函数编写一个测试，如下所示：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can write the code to make this function work. In all honesty, I had
    to run the test several times before I got this function completely correct. First,
    I accidentally returned an integer, and then I forgot to shift the character back
    up to the normal ASCII scale from the zero-based scale. Having the test available
    made it easy to test and debug these errors. This is another bonus of test-driven
    development. The final, working version of the code looks like the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写使这个函数工作的代码了。说实话，我不得不多次运行测试，才完全正确地实现了这个函数。首先，我错误地返回了一个整数，然后我忘记将字符从基于零的量表移回到正常的ASCII量表。有测试可用使得测试和调试这些错误变得容易。这是测试驱动开发的一个额外好处。最终的、可工作的代码版本如下所示：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that `combine_characters` is tested, I thought we''d be ready to implement
    our `encode` function. However, the first thing we want inside that function is
    a repeating version of the keyword string that is as long as the plaintext. Let''s
    implement a function for that first. Oops, I mean let''s implement the test first,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然`combine_characters`已经测试过了，我以为我们可以准备实现我们的`encode`函数了。然而，我们想在函数内部做的第一件事是创建一个与明文长度相同的重复关键字字符串。让我们先实现这个功能。哦，不，我的意思是让我们先实现测试，如下所示：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before writing this test, I expected to write `extend_keyword` as a standalone
    function that accepted a keyword and an integer. But as I started drafting the
    test, I realized it made more sense to use it as a helper method on the `VigenereCipher`
    class so it could access the `self.keyword` attribute. This shows how test-driven
    development can help design more sensible APIs. The following is the method implementation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个测试之前，我预计会编写一个`extend_keyword`作为独立函数，它接受一个关键字和一个整数。但随着我开始起草测试，我意识到将其用作`VigenereCipher`类的辅助方法更有意义，这样它就可以访问`self.keyword`属性。这显示了测试驱动开发如何帮助设计更合理的API。以下是这个方法实现：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once again, this took a few runs of the test to get right. I ended up adding
    an amended copy of the test, one with fifteen and one with sixteen letters, to
    make sure it works if the integer division has an even number.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这需要多次运行测试才能正确。我最终添加了一个修改后的测试副本，一个包含十五个字母和一个包含十六个字母的，以确保如果整数除法有一个偶数，它也能正常工作。
- en: 'Now we''re finally ready to write our `encode` method, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好编写我们的`encode`方法了，如下所示：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That looks correct. Our test suite should pass now, right?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是正确的。我们的测试套件现在应该可以通过，对吧？
- en: 'Actually, if we run it, we''ll find that two tests are still failing. The previously
    failing encode test is actually passing, but we totally forgot about the spaces
    and lowercase characters! It is a good thing we wrote those tests to remind us.
    We''ll have to add the following line at the beginning of the method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们运行它，我们会发现还有两个测试没有通过。之前失败的编码测试实际上已经通过了，但我们完全忘记了空格和大小写字母！幸亏我们写了那些测试来提醒我们。我们不得不在方法的开头添加以下行：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we have an idea about a corner case in the middle of implementing something,
    we can create a test describing that idea. We don't even have to implement the
    test; we can just run `assert False` to remind us to implement it later. The failing
    test will never let us forget the corner case and it can't be ignored as easily
    as a ticket in an issue tracker. If it takes a while to get around to fixing the
    implementation, we can mark the test as an expected failure.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在实现某事的过程中有一个关于边缘情况的看法，我们可以创建一个描述该想法的测试。我们甚至不需要实现测试；我们只需运行`assert False`来提醒我们稍后实现它。失败的测试永远不会让我们忘记边缘情况，它不像问题跟踪器中的条目那样容易被忽视。如果我们需要一段时间来解决实现问题，我们可以将测试标记为预期失败。
- en: 'Now all the tests pass successfully. This chapter is pretty long, so we''ll
    condense the examples for decoding. The following are a couple of tests:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的测试都成功通过了。这一章相当长，所以我们将对解码的例子进行压缩。以下是一些测试：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the following is the `separate_character` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将字符分开的`separate_character`函数：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can add the `decode` method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加`decode`方法：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'These methods have a lot of similarity to those used for encoding. The great
    thing about having all these tests written and passing is that we can now go back
    and modify our code, knowing it is still safely passing the tests. For example,
    if we replace our existing `encode` and `decode` methods with the following refactored
    methods, our tests still pass:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与用于编码的方法有很多相似之处。所有这些测试都编写并通过了，这真是太好了，因为现在我们可以回去修改我们的代码，知道它仍然安全地通过了测试。例如，如果我们用以下重构的方法替换我们现有的`encode`和`decode`方法，我们的测试仍然会通过：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is the final benefit of test-driven development, and the most important.
    Once the tests are written, we can improve our code as much as we like and be
    confident that our changes didn''t break anything we have been testing for. Furthermore,
    we know exactly when our refactor is finished: when the tests all pass.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试驱动开发的最大好处，也是最重要的。一旦编写了测试，我们就可以尽可能多地改进我们的代码，并确信我们的更改没有破坏我们一直在测试的内容。此外，我们知道我们的重构何时完成：当所有测试都通过时。
- en: 'Of course, our tests may not comprehensively test everything we need them to;
    maintenance or code refactoring can still cause undiagnosed bugs that don''t show
    up in testing. Automated tests are not foolproof. If bugs do occur, however, it
    is still possible to follow a test-driven plan, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的测试可能并没有全面测试我们所需要的一切；维护或代码重构仍然可能导致未诊断的bug，这些bug在测试中不会出现。自动测试并不是万无一失的。然而，如果确实出现了bug，仍然可以遵循以下测试驱动计划：
- en: Write a test (or multiple tests) that duplicates or *proves* that the bug in
    question is occurring. This will, of course, fail.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试（或多个测试）来复制或*证明*所讨论的bug正在发生。当然，这会失败。
- en: Then write the code to make the tests stop failing. If the tests were comprehensive,
    the bug will be fixed, and we will know if it ever happens again, as soon as we
    run the test suite.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后编写代码使测试停止失败。如果测试是全面的，bug将被修复，我们将在运行测试套件后知道它是否再次发生。
- en: Finally, we can try to determine how well our tests operate on this code. With
    the `pytest` coverage plugin installed, `pytest -coverage-report=report` tells
    us that our test suite has 100 percent code coverage. This is a great statistic,
    but we shouldn't get too cocky about it. Our code hasn't been tested when encoding
    messages that have numbers, and its behavior with such inputs is thus undefined.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以尝试确定我们的测试在这个代码上的运行效果。安装了`pytest`覆盖率插件后，`pytest -coverage-report=report`告诉我们我们的测试套件有100%的代码覆盖率。这是一个很好的统计数据，但我们不应该过于自满。当编码包含数字的消息时，我们的代码还没有被测试，因此其对这些输入的行为是未定义的。
- en: Exercises
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Practice test-driven development. That is your first exercise. It's easier to
    do this if you're starting a new project, but if you have existing code you need
    to work on, you can start by writing tests for each new feature you implement.
    This can become frustrating as you become more enamored with automated tests.
    The old, untested code will start to feel rigid and tightly coupled, and will
    become uncomfortable to maintain; you'll start feeling like changes you make are
    breaking the code and you have no way of knowing, for lack of tests. But if you
    start small, adding tests to the code base improves it over time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 练习测试驱动开发。这是你的第一个练习。如果你开始一个新的项目，这样做会更容易，但如果你需要处理现有的代码，你可以从为每个新实现的功能编写测试开始。随着你对自动化测试越来越着迷，这可能会变得令人沮丧。旧的未测试代码将开始感觉僵硬且紧密耦合，维护起来会不舒服；你开始感觉所做的更改正在破坏代码，而你又无法知道，因为没有测试。但如果你从小处着手，逐渐向代码库添加测试，随着时间的推移，代码质量会得到改善。
- en: So, to get your feet wet with test-driven development, start a fresh project.
    Once you've started to appreciate the benefits (you will) and realize that the
    time spent writing tests is quickly regained in terms of more maintainable code,
    you'll want to start writing tests for existing code. This is when you should
    start doing it, not before. Writing tests for code that we *know* works is boring.
    It is hard to get interested in the project until you realize just how broken
    the code we thought was working really is.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了开始测试驱动开发，开始一个新的项目。一旦你开始欣赏其好处（你会的）并意识到编写测试所花费的时间很快就会在更易于维护的代码中得到回报，你将想要开始为现有代码编写测试。这就是你应该开始这样做的时候，而不是之前。为已知工作的代码编写测试是无聊的。直到你意识到我们以为工作的代码实际上有多糟糕，你才可能对项目产生兴趣。
- en: Try writing the same set of tests using both the built-in `unittest` module
    and `pytest`. Which do you prefer? `unittest` is more similar to test frameworks
    in other languages, while `pytest` is arguably more Pythonic. Both allow us to
    write object-oriented tests and to test object-oriented programs with ease.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用内置的`unittest`模块和`pytest`编写相同的一组测试。你更喜欢哪一个？`unittest`与其他语言的测试框架更相似，而`pytest`则可以说是更Pythonic。两者都允许我们编写面向对象的测试，并轻松地测试面向对象的程序。
- en: We used `pytest` in our case study, but we didn't touch on any features that
    wouldn't have been easily testable using `unittest`. Try adapting the tests to
    use test skipping or fixtures (an instance of `VignereCipher` would be helpful).
    Try the various setup and teardown methods, and compare their use to funcargs.
    Which feels more natural to you?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们使用了`pytest`，但我们没有触及到任何使用`unittest`不容易测试的特性。尝试调整测试以使用跳过测试或固定值（`VignereCipher`的一个实例会有所帮助）。尝试各种设置和清理方法，并将它们与funcargs的使用进行比较。哪一个对你来说更自然？
- en: Try running a coverage report on the tests you've written. Did you miss testing
    any lines of code? Even if you have 100 percent coverage, have you tested all
    the possible inputs? If you're doing test-driven development, 100 percent coverage
    should follow quite naturally, as you will write a test before the code that satisfies
    that test. However, if writing tests for existing code, it is more likely that
    there will be edge conditions that go untested.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行你编写的测试的覆盖率报告。你是否遗漏了测试任何代码行？即使你有100%的覆盖率，你是否测试了所有可能的输入？如果你在做测试驱动开发，100%的覆盖率应该会相当自然地跟随，因为你会在满足测试的代码之前编写测试。然而，如果你在为现有代码编写测试，更有可能存在未被测试的边缘情况。
- en: 'Think carefully about the values that are somehow different, such as the following,
    for example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考那些以某种方式不同的值，例如以下内容：
- en: Empty lists when you expect full ones
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你期望满列表时却得到了空列表
- en: Negative numbers, zero, one, or infinity compared to positive integers
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与正整数相比，负数、零、一或无穷大
- en: Floats that don't round to an exact decimal place
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不四舍五入到精确小数位的浮点数
- en: Strings when you expected numerals
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你期望数字时却得到了字符串
- en: Unicode strings when you expected ASCII
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你期望ASCII字符串时却得到了Unicode字符串
- en: The ubiquitous `None` value when you expected something meaningful
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你期望有意义的内容时却遇到了无处不在的`None`值
- en: If your tests cover such edge cases, your code will be in good shape.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试覆盖了这样的边缘情况，你的代码将处于良好状态。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have finally covered the most important topic in Python programming: automated
    testing. Test-driven development is considered a best practice. The standard library
    `unittest` module provides a great out-of-the-box solution for testing, while
    the `pytest` framework has some more Pythonic syntaxes. Mocks can be used to emulate
    complex classes in our tests. Code coverage gives us an estimate of how much of
    our code is being run by our tests, but it does not tell us that we have tested
    the right things.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于涵盖了Python编程中最重要的话题：自动化测试。测试驱动开发被认为是一种最佳实践。标准库中的`unittest`模块提供了一个出色的开箱即用的测试解决方案，而`pytest`框架则提供了一些更符合Python语法的语法。在测试中，我们可以使用模拟来模拟复杂的类。代码覆盖率可以给我们提供一个估计，即我们的代码中有多少是被我们的测试运行的，但它并不能告诉我们我们已经测试了正确的事情。
- en: 'In the next chapter, we''ll jump into a completely different topic: concurrency.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将跳入一个完全不同的主题：并发。
