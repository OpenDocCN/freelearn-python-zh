- en: Unit Testing of GoPiGo3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After finishing the assembly of the hardware, in this chapter, you will get
    familiar with how GoPiGo3 works using the JupyterLab environment, a friendly interface
    that takes the structure of a notebook composed of human-readable paragraphs followed
    by Python code snippets. You will produce two versions of each test program: the
    JupyterLab notebook and the pure Python script.'
  prefs: []
  type: TYPE_NORMAL
- en: Using these programming tools, you will test each sensor/actuator individually
    and check that they're working properly while learning about the technology behind
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Python programming under the user-friendly environment
    Jupyterlab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing the robot perception: distance sensor, line follower, and 2D'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing the robot actuation: motors and encoders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you follow the practical exercises, you'll learn how the different packages
    (sensors, motors, and so on) build up the whole robot, what is measured with sensors,
    and how to systematically test sensors and actuators at the unit level.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for the first section, *Getting started with Python and Jupyterlab*,
    is included within the image of *DexterOS*, the custom operating system supplied
    by the manufacturer of GoPiGo3\. In [Chapter 1](9bb411d1-934c-4497-aad4-7ad770d3783c.xhtml)*, Assembling
    the Robot*, we explained how to get this image and burn it to an SD card. This
    was explained in the *Quick hardware testing* section in the *Getting started
    with DexterOS* sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter is in the GitHub repository of the book, located at
    [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter2_Unit_Tests. ](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter2_Unit_Tests)At
    the beginning of the *Unit testing of sensors and drives* section, we explain
    how to clone the code locally in the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Python and JupyterLab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JupyterLab** is a very extensive tool in the Python community because it
    lets you write a program as if you were solving a mathematics problem in a school
    class. That is to say, you write the heading, then the problem statement and the
    initial data. After this declaration, you write a paragraph explaining the operation
    that you are going to perform, and then you write the Python line(s) that perform
    such operation in a *code cell*. For every operation you repeat the same steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A human-readable paragraph explaining the next operation, which is formatted
    with the well-known *markdown syntax* [https://commonmark.org/help/](https://commonmark.org/help/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A code cell with the lines of Python that perform the operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 and 2 for every code snippet that perform a single operation.
    The final one will provide the solution to the problem..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s a self-explaining example for reading the distance sensor of GoPiGo3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8c23cb7-4fd9-4da5-84a8-a8c43a474b81.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we are going to explain how to launch JupyterLab for GoPiGo3.
  prefs: []
  type: TYPE_NORMAL
- en: Launching JupyterLab for GoPiGo3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In DexterOS, you have two lessons that explain both Jupyter notebooks and controlling
    the robot with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access them by navigating to `http://mygopigo.com` or `http://10.10.10.10`,
    and click on LEARN, then Lessons in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c4b8cba5-bd1c-4606-8156-2005494a8a57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The JupyterLab environment is then launched, and in the left part of the window
    you will see two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1_Moving_Around.ipynb` is a Jupyter notebook that explains step-by-step how
    to move the robot forward and rotate it. Follow the instructions given in the
    notebook to execute the commands.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2_The_Environment.ipynb` is another example that explains how to deal with
    JupyterLab: run a cell, stop the execution, and so on. If you got stuck in the
    previous notebook, follow this one and return to the first afterward.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s try `1_Moving_Around.ipynb`. The following command makes the robot
    go forward 10 cm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to work in inches, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute both in the same code cell, you will notice a small gap before
    the execution of the second command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s perform a physical test with the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark a sign on the floor in the starting point, drive 10 cm forward and 10
    cm backward and find how precise the motion is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should find that it returns exactly to the starting point. Errors that we
    measured with a micrometer (three times) were +1.29 mm, -0.76 mm, and +2.16 mm.
    Positive means that it passed over the starting point when driving back, and negative
    means that it did not arrive at the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add the distances (10 cm + 10 inches = 35.4 cm) into one forward command,
    and then make another command for moving back the same distance, the errors we
    measured were (again, we did it three times) -0.01 mm, -1.40 mm, and -0.72 mm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the pause caused by using two commands introduces an error
    that is in the order of 1 mm. Using only one command for forward and one for backward
    substantially reduces the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform a similar test for turning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Other useful commands are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the robot, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It is crucial to note that software flow may not be compatible with robot physics.
    Try this sequence and observe what GoPiGo3 does:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that only the last line is executed, which is `my_gopigo.left()`.
    What is actually happening is that the commands execute so quickly (a few milliseconds
    each) that the robot''s inertia does not allow enough time for GoPiGo to move
    forward, backward, or right. Remove the last line to check it: the only command
    you see physically executed is now `my_gopigo.right()`.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most challenging issues when programming a robot is understanding
    its dynamics, because something that may seem to be a software bug may be an unexpected
    physical response of the robot. So, prior to developing the software, you must
    make sure you understand the physics of the problem, including its mass (inertia),
    friction forces, the maximum load on the motors, the power supply limit, and the
    battery level. The list of variables coming from the physical world can be endless,
    and you should apply your knowledge of mechanics and electricity to successfully
    develop functional software.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible solution for this simple case is to specify in the sequence the
    distance or angle you want it to move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To save your work in DexterOS, you have to do it from the `~/.lessons_python`
    folder. This is owned by `pi:users`, while the DexterOS user is `jupyter` (issue
    the `$ whoami` command in a terminal or just see it in the prompt). Go one level
    above in the tree, and create a folder there with any name you wish. Then save
    your changes in that location with File | Save Notebook As....
  prefs: []
  type: TYPE_NORMAL
- en: Hardware testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access these notebooks in DexterOS outside of the LEARN environment, navigate
    to [http://mygopigo.com](http://mygopigo.com/) or `http://10.10.10.10`, and click
    on Code in Python. JupyterLab will be launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6cd7f57-e741-4fdc-85ec-25dbde6eac35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the file manager view on the left side of the screen, you will find these
    two notebooks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of them is `First Ride Around.ipynb`, whichprovides a widget to drive the
    robot with a visual panel:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/bbd195b6-163a-44d5-831d-b2a51b8d2f57.png)'
  prefs: []
  type: TYPE_IMG
- en: The other notebook is `Hardware Testing.ipynb`, which runs specific tests for
    batteries, LEDs, and encoders. What we should expect in terms of GoPiGo3's behavior
    is addressed in the following subsection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing battery, LEDs, and motors/encoders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the notebook and go through each cell to understand what it does.
  prefs: []
  type: TYPE_NORMAL
- en: Battery level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command reads and displays the current battery voltage*.* It
    should be above 9 V for GoPiGo3 to work properly. When the batteries are not charged
    enough, you will lose the Wi-Fi connection with the robot and you will have to
    recharge them or replace them with new batteries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at hardware information and voltage levels.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware information and current voltage levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next block of commands prints information of the manufacturer, hardware
    and firmware versions, and battery levels. The following relates to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Battery voltage* is the same as before. The measurement gives a slightly different
    value, 9.294V, and it is OK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*5V voltage* is that of the power supply to the Raspberry Pi through its GPIO.
    GoPiGo red board has a power regulator that transforms the 9V raw input to a regulated
    5V. If the batteries are properly charged, this value should be very close to
    5V as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will check the LEDs and blinkers.
  prefs: []
  type: TYPE_NORMAL
- en: LEDs and blinkers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two LEDs on top of the board that simulate GoPiGo3''s eyes. By running
    the following block of code, they will change their color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The blinkers are two small red LEDs underneath the red board at the front.
    The following code makes them blink 5 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Check it visually, and be aware that no message appears in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Motors and encoders test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following cell will run for approximately 5 seconds and will report encoder
    readings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And these are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the message at the end telling if the test has passed. Do not
    worry at the moment about understanding the numbers: it is an internal test in
    which GoPiGo3 checks itself and reports whether it passed or failed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s successful, you can go ahead with the following test. GoPiGo3 will
    drive forward for 10 cm and the output value at the end should be approximately
    10. Should this test fail, you can stop the robot by clicking the red **Stop**
    button at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes well, you will obtain this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, should this test fail you can stop the robot by pressing the red **Stop**
    button at the top. After these basic tests, we have enough understanding of GoPiGo3's
    hardware and software to perform the unit testing, which is the main goal of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of sensors and drives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will run some simple scripts in Python by using Jupyter
    Notebooks. From a terminal in your laptop, clone the book repository and go into
    the `Chapter2_Unit_Tests` folder to access the files for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For completeness, we have included the notebooks used in the previous section
    inside the `lessons_GettingStarted` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Quick start with sensors and motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enter the Python environment of your robot, switch on the red board and
    connect to the *GoPiGo* Wi-Fi network from your laptop. Then, visit the following
    URL in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://10.10.10.10/python`'
  prefs: []
  type: TYPE_NORMAL
- en: In JupyterLab, focus on the left-hand side, where the file storage is shown.
    To run any of the examples, you will have to manually upload to the location where
    you want to place it in the robot storage. Create a folder named  `Chapter2_Unit_Tests`and
    upload the required files. We will indicate at the beginning of each exercise
    which file we will use.
  prefs: []
  type: TYPE_NORMAL
- en: Driving around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The files in this sub-section are in the `./Chapter2_Unit_Tests/drivingAround` folder of
    the repository. You can upload them one by one. Afterward, launch a shell session
    in JupyterLab by opening a launcher tab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Terminal icon from the tab, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/19f1b176-6d0b-4600-9925-74a082473008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Execute the scripts from the terminal by changing to their location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first script is `1-easyMotors.py`, and it plays a very simple sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the motors forward for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop the motors for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drive the robot for 50 cm and then stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn right for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn left for 1 second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see the first part of the script in the following code listing, which
    shows the commands to move forward for 1 second, and then stop for another second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is shown here, and it includes the commands to drive forward
    50 cm, then turn right for 1 second, and then turn left for 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The next script is `2-driveSquare.py`, and it does what it says: it draws a
    square on the floor. If we use a `for` loop that makes a 90º rotation after each
    30 cm drive, we get a program with very few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `3-circularMoves.py` Python script makes GoPiGo3 travel a semicircle in
    one direction, and then in the opposite, returning to the starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The program `4-drawEight.py`combines arcs and straight paths to draw an 8 shape
    on the floor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the program `5-accelerateForward.py` illustrates how to accelerate
    the robot. The sequence is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Set an initial speed and an end speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate a step by dividing the interval between them by 20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a loop that increases the speed in the step value in each iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform one iteration every 0.1 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After 2 seconds, GoPiGo3 will reach the end speed and will stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's now test all of the sensors with which we have equipped the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Distance sensor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To communicate with the sensors, we will use the DI-sensors Python library [https://github.com/DexterInd/DI_Sensors](https://github.com/DexterInd/DI_Sensors).
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to revise the port connections. This is what we will review
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Check port connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram should be of great help when connecting sensors to GoPiGo3
    ports, in order to make sure that the hardware is correctly wired:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/112f7869-1ea5-484f-9787-b236220fef92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image courtesy: Dexter Industries: https://gopigo3.readthedocs.io/en/master/_images/gpg3_ports.jpg'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous chapter, you should remember the purpose of each port:'
  prefs: []
  type: TYPE_NORMAL
- en: Ports **AD1** and **AD2** are general-purpose *input/output* ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ports **SERVO1** and **SERVO2** are the servo controller ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **I2C** ports are where you connect *I2C-enabled* devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SERIAL** port is where you can connect *UART-enabled* devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given this description, check that sensors are connected as we described in
    the first chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Distance sensor** should be plugged into **I2C-1**, the I2C port on the
    left side of GoPiGo3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Servo package should be connected to **SERVO1**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Line follower** should be plugged into **I2C-2**, the I2C port on the
    right side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **IMU** sensor should be connected to **AD1** (on the left side).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distance sensor unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you have connected the distance sensor to the **I2C-1** port, be aware
    that GoPiGo3 software libraries will not require you to specify in the script
    which of the two ports you are using. It will be automatically detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files for testing are located in the `./Chapter2_Unit_Tests/DI-distance` folder of
    the repository. You can upload them one by one to DexterOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '`di-distance_cm.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`di-distance-easygopigo_mm.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Afterward, open a shell session in JupyterLab by opening a launcher window
    and selecting the terminal icon from it. Execute the scripts from the terminal
    by moving to their location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first script is `di-distance_cm.py`. It takes a reading at a fixed time
    rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The publishing interval is 0.1 seconds, as specified in the line `sleep(0.1)`.
    The detailed specification of the distance sensor API can be found at [https://di-sensors.readthedocs.io/en/master/api-basic.html#easydistancesensor](https://di-sensors.readthedocs.io/en/master/api-basic.html#easydistancesensor).
    The `my_sensor.read()` method provides the distance in centimeters, but there
    are an other two methods if you prefer to use other units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_sensor.read_mm()` is for millimeters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my_sensor.read_inch()` is for inches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second script, `di-distance-easygopigo_mm.py`, imports the GoPiGo3 library
    as per [https://github.com/DexterInd/GoPiGo3](https://github.com/DexterInd/GoPiGo3),
    which implicitly includes the sensor library, [https://github.com/DexterInd/DI_Sensors](https://github.com/DexterInd/DI_Sensors).
    You can see that it uses the same class methods to take readings. In this case,
    the function that reads the distance in millimeters is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For completeness, we have included in the folder of this chapter the two libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`easysensors.py` for the sensors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easygopigo3.py` for the robots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you inspect the latter, you will see this `import` line at the beginning
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can incorporate the DI sensors you need to increase the perception
    capabilities of your robot. Let's go through an example to better understand the
    libraries provided by Dexter Industries.
  prefs: []
  type: TYPE_NORMAL
- en: GoPiGo3 API library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main class of the robot is `GoPiGo3`, and you can see the class structure
    in the following diagram. The **easysensors** library is imported (inherited)
    by the `EasyGoPiGo3`class, and so has access to all sensor methods. The class
    structure is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64a7a7d3-b3ea-40f2-abe7-c754fa52aa5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image courtesy: Dexter Industries: https://gopigo3.readthedocs.io/en/master/_images/inheritance-e4cb3d2ae1367b2d98aab1a112a1c8e1b7cd9e47.png'
  prefs: []
  type: TYPE_NORMAL
- en: A summarized table with all the functions of the class is available at [https://gopigo3.readthedocs.io/en/master/api-basic/structure.html#functions-short-list](https://gopigo3.readthedocs.io/en/master/api-basic/structure.html#functions-short-list).
    The API library is covered in detail at [https://gopigo3.readthedocs.io/en/master/api-basic/easygopigo3.html](https://gopigo3.readthedocs.io/en/master/api-basic/easygopigo3.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, using the `easygopigo3.py` library, you create an instance of your robot
    and initialize the sensors you need. For example, the distance sensor is initiated
    with this method of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In our script, this is accomplished in three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, you import the `easygopigo3` library. In the second line,
    you instantiate a robot object, and in the third line, you initialize the distance
    sensor. Then you are ready to acquire data from the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In short, if you use the `easygopigo3.py` library, *the top-level object is
    the robot itself*. On the other hand, if you were using the sensors in a custom
    project that doesn't deal with GoPiGo, the top-level object is yet to be created
    unless you already have the corresponding library available. If you don't, it
    is your task to define a class that represents that entity (a weather station,
    for example) and import the DI sensors library. This is the topic of the next
    sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: DI sensors API library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each sensor type has its own class and methods. In the `./Chapter2_Unit_Tests/DI-distance/di-distance_cm.py` script,
    we were using the DI-sensors library. The class structure is shown in the following
    screenshot and explained at [https://di-sensors.readthedocs.io/en/master/structure.html#library-structure](https://di-sensors.readthedocs.io/en/master/structure.html#library-structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f7277c6-10ae-4f61-b525-128cd404e13c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image courtesy: Dexter Industries: https://di-sensors.readthedocs.io/en/master/_images/inheritance-a8243413ad98ddae26cdf121c775ad137c7f2e30.png'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarized tables with methods for all DI sensors are shown at [https://di-sensors.readthedocs.io/en/master/structure.html#functions-short-list](https://di-sensors.readthedocs.io/en/master/structure.html#functions-short-list).
    You will find two alternatives of usage for each sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: The **easy methods** – prepended with the `easy`prefix – are for quick usage
    and provide top-level functionalities. You can see the syntax on the right-hand
    side of the preceding diagram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **advanced methods** without the `easy` prefix are for developer use and
    provide low-level control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The distance sensor is managed with the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In our script,the sensor is initialized as follows::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line, you import the class of the distance sensor. Be aware that
    you need to import just the `EasyDistanceSensor` class from `di_sensors.easy_distance_sensor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the second line, you instantiate the distance sensor object with the `Easy` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then you are ready to acquire data from the sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare with the case of not using the `easy` option. The syntax is similar,
    the only difference being the removal of the `_easy` and `Easy` prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The same scheme will apply to the other sensors we will cover later, specifically,
    the line follower and the IMU.
  prefs: []
  type: TYPE_NORMAL
- en: Servo package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The servo package consists of a **Pulse Width Modulation** (**PWM**) servomotor.
    It is controlled in an open loop by applying a voltage that produces a proportional
    rotation of the motor shaft in a 180° amplitude coverage. In the following image
    there is a small rod that lets us visualize the rotation. In our GoPiGo3 assembly,
    we will see rotating the distance sensor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bff8792a-e5b6-45d2-a7f3-6d260758da89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image courtesy: Dexter Industries: https://www.dexterindustries.com/wp-content/uploads/2017/06/GoPiGo3-Servo-Assembly-11-600x338.jpg'
  prefs: []
  type: TYPE_NORMAL
- en: The servo package is part of the GoPiGo3 API library described in the *Distance
    sensor unit test* section. Its API methods are detailed at [https://gopigo3.readthedocs.io/en/master/api-basic/sensors.html#servo](https://gopigo3.readthedocs.io/en/master/api-basic/sensors.html#servo).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will carry out some unit tests to check that it rotates properly. Since
    we have mounted the distance sensor with the servo package, we can measure the
    distance to obstacles in a 180º field of view by rotating the servo. In the test,
    we will also calibrate the actual field of view your robot will be able to cover.
  prefs: []
  type: TYPE_NORMAL
- en: Servo package unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test consists of placing the distance sensor with respect to the servomotor
    shaft in an angular position that covers the entire front view of GoPiGo3, from
    left to right. All the explanations and code are in a Jupyter notebook located
    at `./Chapter2_Unit_Tests/DI-servo_package/servoCalibration.ipynb`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create the servo object from the `EasyGoPiGo3` class. To do this,
    we need to import the library and instantiate `GoPiGo3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we initiate the servo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We check that we are able to fully rotate the servo. You should have unmounted
    the sensor to prevent collisions with the robot''s chassis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, move the servo to the middle of the interval, 90º, and attach the sensor
    so that it faces forward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Adjust the angle so that the sensor faces exactly forward. In our case, this
    angle is 95°. You should find out what yours is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have checked the reference position, let''s set up the actual limits.
    To do that, find the angles that preclude any interference with the sensor by
    the robot chassis. In our case, these angles are 30º and 160º. Again, you should
    find what yours are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That's all for the setup of the servo package with sensor distance.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced users, there is another API library, **gopigo3**, that provides
    low-level access to the hardware in order for you to take full control of it.
    Although covering such low-level programming is not in the scope of the book,
    you are provided with a Python script, `Servo.py`, that briefly illustrates the
    usage of one of its methods. This script sets the rotation in terms of *counts*
    instead of *rotation angle*. We perform a loop when the counts go from 1000 to
    2001.
  prefs: []
  type: TYPE_NORMAL
- en: This way, you have access to the full resolution of the servomotor, and you
    should have an idea of the size of the rotation steps it can provide.
  prefs: []
  type: TYPE_NORMAL
- en: Line follower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the first chapter, the line follower is composed of six pairs
    of emitter-receivers to sense six aligned points on the floor in order to determine
    how decentered the robot is with respect to the black line it will be following.
  prefs: []
  type: TYPE_NORMAL
- en: The line follower is also part of the GoPiGo3 API library. Its methods are detailed
    at [https://di-sensors.readthedocs.io/en/master/api-basic.html#easylinefollower](https://di-sensors.readthedocs.io/en/master/api-basic.html#easylinefollower).
    The unit test we are going to perform consists of validating that the sensor can
    tell which side of a black line the robot is.
  prefs: []
  type: TYPE_NORMAL
- en: Line follower unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jupyter notebook for the test is `./CH2-uniTests/di-lineFollower/lineFollower_libraries.ipynb`.
    This notebook also shows you both the easy library, `di_sensors.easy_line_follower`,
    and the advanced version, `di_sensors.line_follower`, in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the sensor reports *center*, this is because the robot is well centered
    on the black line, as shown in the next image. This means that the two external
    emitter-receiver pairs report *white*, while the pairs between them report *black*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6db1ce0-ec37-449c-ad10-38d40b8b1ac5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the sensor reports *left*, it means that the line is slightly to the left
    of the robot, as shown in the following photo. This means that the left-most pair
    reports *black*, the central ones *black*, and the rest *white*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22e7c9e2-97d0-4b17-acf4-488e0250178f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the robot ends up completely off the line, all the pairs report *white* and
    the line follower throws *white* overall. The opposite is also true: if all the
    pairs report *black*, it may be because the black line is too wide or the robot
    has been placed on a dark surface.'
  prefs: []
  type: TYPE_NORMAL
- en: Inertial Measurement Unit (IMU)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the supplied IMU, we have the following sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: Magnetometer, three axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gyroscope, three axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer, three axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As explained in the previous chapter, with these three sensors – once their
    calibration setup is complete – it is possible to obtain the absolute orientation
    of the robot in the 3D space, quantified in terms of Euler angles. Additionally,
    we also have the temperature because the DI IMU ships with a temperature sensor.
  prefs: []
  type: TYPE_NORMAL
- en: IMU unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jupyter notebook for the test is `./Chapter2_Unit_Tests/DI-IMU/IMU_reading.ipynb`.
    The corresponding DI sensor API library is documented at [https://di-sensors.readthedocs.io/en/master/examples/imu.html](https://di-sensors.readthedocs.io/en/master/examples/imu.html).
  prefs: []
  type: TYPE_NORMAL
- en: When running the notebook, you can check that the reported Euler angles are
    OK.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pi is an essential perception device for any robot. Take into account that about
    80% of the perception data that the human brain processes comes from vision. In
    this section, we are only going to test that Pi is able to take photos to check
    that it works properly. In *[Chapter 10](https://cdp.packtpub.com/hands_on_ros_for_robotics_programming/wp-admin/post.php?post=33&action=edit), Applying
    Machine Learning in Robotics*, we will use object recognition algorithms on images
    captured by the camera. Hence, the robot will exhibit smarter behavior and will
    be able to recognize colors, shapes, faces, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Pi unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jupyter notebook for the test is `./Chapter2_Unit_Tests/PiCamera/Taking_Photos.ipynb`.
    This simple example takes a photo and creates a histogram, that is, a chart showing
    how many colors and the amount of each color that is present in the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take an image with few colors to make it easier to understand the
    information from the histogram. The following photo, taken with the GoPiGo3 ,
    has the characteristics we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/968ed72c-ad85-41e9-a1f1-d20db6c041f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is accomplished with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we take the photo. Then we convert it to a JPG image format and save
    it, and, finally, we show the result on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we draw the histogram with this simple command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c1d340e-d957-489c-8842-a74eae31dbb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may see that colors are concentrated into three points. The scale of the
    *x* axis goes from 0 (black) to 768 (white). This interval is explained by taking
    into account that 24-bit RGB pixels have values that go up to 768\. Let''s see
    what each vertical line means:'
  prefs: []
  type: TYPE_NORMAL
- en: The line at *x* = 0 represents the zones that are black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line at *x* = 525 represents the more shiny area, which is the light bulb.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it is easy to infer that *x* = 250 corresponds to the lighter areas
    around the monitor, which appear to have a gray tone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this last test, we have validated that our robot has all of its sensors
    and drives working properly and we are ready to proceed to the next step, building
    functional behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: GoPiGo3 projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official GoPiGo3 software hosted on Github at [https://github.com/DexterInd/GoPiGo3](https://github.com/DexterInd/GoPiGo3)
    provides several interesting projects. At this point, we recommend you clone the
    repository and upload some of these projects to the robot running DexterOS. The
    projects are located in this folder of the repository: [https://github.com/DexterInd/GoPiGo3/tree/master/Projects](https://github.com/DexterInd/GoPiGo3/tree/master/Projects).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try, for example, the *Basic Robot Control *project, located at [https://github.com/DexterInd/GoPiGo3/tree/master/Projects/BasicRobotControl](https://github.com/DexterInd/GoPiGo3/tree/master/Projects/BasicRobotControl).
    You have the means to get full control of the drives, LEDs, and blinkers using
    the keys of your wireless keyboard that''s connected to the robot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, you may argue that the method we have used to put new files
    in the robot is tedious. We have used DexterOS so that you be able to start quickly,
    without having to deal with Linux issues.
  prefs: []
  type: TYPE_NORMAL
- en: From the next chapter, we will use Ubuntu 16.04 on your laptop and a full Linux
    desktop, Ubuntu 18.04, inside GoPiGo3 . This will allow the robot to connect to
    the internet, and this will let you clone repositories directly into the robot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have familiarized ourselves with the GoPiGo3 Python environment
    by running simple programs that allow us to test robot sensors and actuators.
    We have checked them one by one in what is formally known as *unit testing*. This
    has served two goals: getting started with Python programming and functionally
    validating your robot hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will leave the robot for one chapter, and we will discuss the core
    software concepts of ROS that we will later use to program GoPiGo3.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have this sequence of Python commands, what will GoPiGo3 do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: A) It will drive 10 cm forward and then turn 90º to the right
  prefs: []
  type: TYPE_NORMAL
- en: B) It will drive 10 cm forward and then turn 90º to the left
  prefs: []
  type: TYPE_NORMAL
- en: '**C**) It will turn 90º'
  prefs: []
  type: TYPE_NORMAL
- en: What is the battery level required for GoPiGo3 to work properly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A**) Slightly above 9V is enough.'
  prefs: []
  type: TYPE_NORMAL
- en: B) 5V, the same that the Raspberry Pi needs.
  prefs: []
  type: TYPE_NORMAL
- en: C) There is no minimum. If the voltage is low, the robot will drive slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Which set of commands will make GoPiGo3 draw a right angle arc 60 cm in diameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `gpg.orbit(90, 60)` **B**) `gpg.orbit(90, 30)` C) `gpg.orbit(180, 30)`
  prefs: []
  type: TYPE_NORMAL
- en: 'What combination of the six sensor signals of the line follower does not correspond
    to GoPiGo3 being to the right of the black line? (w: white, b: black)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A**) b-b-b-b-w'
  prefs: []
  type: TYPE_NORMAL
- en: B) w-b-b-b-w
  prefs: []
  type: TYPE_NORMAL
- en: C) b-b-b-w-w
  prefs: []
  type: TYPE_NORMAL
- en: If you have a histogram of an image that consists of two vertical lines of equal
    height at *x* = 0 and *x* = 768, given that the color range of *x* is from 0 to
    768, what colors are present in the image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Gray, because it is the result of mixing black and white in equal proportions.
  prefs: []
  type: TYPE_NORMAL
- en: '**B**) Half of the image is black and the other half is white.'
  prefs: []
  type: TYPE_NORMAL
- en: C) It is not possible to get a histogram like that.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delve deeper into the technical aspects of GoPiGo3, you have very detailed
    information in the official guides listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Dexter Industries GoPiGo3 Documentation: [https://gopigo3.readthedocs.io](https://gopigo3.readthedocs.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dexter Industries DI-Sensors Documentation: [https://di-sensors.readthedocs.io](https://di-sensors.readthedocs.io)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pi camera documentation: [https://picamera.readthedocs.io/](https://picamera.readthedocs.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
