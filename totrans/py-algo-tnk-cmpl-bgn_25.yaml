- en: Chapter 15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making Questions
  prefs: []
  type: TYPE_NORMAL
- en: 15.1 Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All you have learned so far is the sequence control structure, where statements
    are executed sequentially, in the same order in which they appear in the program.
    However, in serious Python programming, rarely do you want the statements to be
    executed sequentially. Many times you want a block of statements to be executed
    in one situation and an entirely different block of statements to be executed
    in another situation.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2 What is a Boolean Expression?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say that variable x contains a value of 5\. This means that if you ask
    the question “is x greater than 2?” the answer is obviously “Yes”. For a computer,
    these questions are called Boolean expressions. For example, if you write x >
    2, this is a Boolean expression, and the computer must check whether or not the
    expression x > 2 is True or False.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A Boolean expression is an expression that results in a
    Boolean value, that is, either True or False.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Boolean expressions are questions and they should be read
    as “Is something equal to/greater than/less than something else?” and the answer
    is just a “Yes” or a “No” (True or False).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/remember.jpg)A decision control structure can evaluate a Boolean expression
    or a set of Boolean expressions and then decide which block of statements to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.3 How to Write Simple Boolean Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple Boolean expression is written as
  prefs: []
  type: TYPE_NORMAL
- en: Operand1  Comparison_Operator  Operand2
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: ►Operand1 and Operand2 can be values, variables or mathematical expressions
  prefs: []
  type: TYPE_NORMAL
- en: ►Comparison_Operator can be one of those shown in Table 15-1.
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparison Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| == | Equal (not assignment) |'
  prefs: []
  type: TYPE_TB
- en: '| != | Not equal |'
  prefs: []
  type: TYPE_TB
- en: '| > | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| < | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | Greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| <= | Less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: Table 15-1 Comparison Operators in Python
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of Boolean expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: ►x > y. This Boolean expression is a question to the computer and can be read
    as “is x greater than y?”
  prefs: []
  type: TYPE_NORMAL
- en: ►x <= y. This Boolean expression is also a question to the computer and can
    be read as “is x less than or equal to y?”
  prefs: []
  type: TYPE_NORMAL
- en: ►x != 3 * y + 4\. This can be read as “is x not equal to the result of the expression
    3 * y + 4?”
  prefs: []
  type: TYPE_NORMAL
- en: ►s == "Hello". This can be read as “is s equal to the word 'Hello'?” In other
    words, this question can be read as “does s contain the word 'Hello'?”
  prefs: []
  type: TYPE_NORMAL
- en: ►x == 5 . This can be read as “is x equal to 5?”
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)A very common mistake that novice programmers make when
    writing Python programs is to confuse the value assignment operator with the equal
    operator. They frequently make the mistake of writing x = 5 when they actually
    want to say x == 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.3-1 Filling in the Table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fill in the following table with the words “True” or “False” according to the
    values of the variables a, b, and c.
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | c | a == 10 | b <= a | c > 3 * a − b |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | −5 | 7 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 10 | 21 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| −4 | −2 | −9 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: The first two Boolean expressions are straightforward and need no further explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the Boolean expression c > 3 * a − b, be careful with the cases where
    b is negative. For example, in the first line, a is equal to 3 and b is equal
    to −5\. The result of the expression 3 * a - b is 3 * 3 − (−5) = 3 * 3 + 5 = 14\.
    Since the content of variable c (in the first line ) is not greater than 14, the
    result of the Boolean expression c > 3 * a − b is False.
  prefs: []
  type: TYPE_NORMAL
- en: After a little work , the table becomes
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | c | a == 10 | b <= a | c > 3 * a − b |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | −5 | 7 | False | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 10 | 21 | True | True | True |'
  prefs: []
  type: TYPE_TB
- en: '| −4 | −2 | −9 | False | False | True |'
  prefs: []
  type: TYPE_TB
- en: 15.4 Logical Operators and Complex Boolean Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complex Boolean expression can be built of simpler Boolean expressions and
    can be written as
  prefs: []
  type: TYPE_NORMAL
- en: BE1 Logical_Operator BE2
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: ►BE1 and BE2 can be any Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: ►Logical_Operator can be one of those shown in Table 15-2.
  prefs: []
  type: TYPE_NORMAL
- en: '| Logical Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| and | Also known as logical conjunction |'
  prefs: []
  type: TYPE_TB
- en: '| or | Also known as logical disjunction |'
  prefs: []
  type: TYPE_TB
- en: '| not | Also known as negation or logical complement |'
  prefs: []
  type: TYPE_TB
- en: Table 15-2 Logical Operators in Python
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)When you combine simple Boolean expressions with logical
    operators, the whole Boolean expression is called a “complex Boolean expression”.
    For example, the expression x == 3 and y > 5 is a complex Boolean expression.'
  prefs: []
  type: TYPE_NORMAL
- en: The and operator
  prefs: []
  type: TYPE_NORMAL
- en: When you use the and operator between two Boolean expressions (BE1 and BE2),
    it means that the result of the whole complex Boolean expression is True only
    when both (BE1 and BE2 ) Boolean expressions are True.
  prefs: []
  type: TYPE_NORMAL
- en: You can organize this information in something known as a truth table. A truth
    table shows the result of a logical operation between two or more Boolean expressions
    for all their possible combinations of values. The truth table for the and operator
    is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '| BE1 (Boolean Expression 1) | BE2 (Boolean Expression 2) | BE1 and BE2 |'
  prefs: []
  type: TYPE_TB
- en: '| False | False | False |'
  prefs: []
  type: TYPE_TB
- en: '| False | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| True | False | False |'
  prefs: []
  type: TYPE_TB
- en: '| True | True | True |'
  prefs: []
  type: TYPE_TB
- en: Are you still confused? You shouldn't be! It is quite simple! Let's see an example.
    The complex Boolean expression
  prefs: []
  type: TYPE_NORMAL
- en: name == "John" and age > 5
  prefs: []
  type: TYPE_NORMAL
- en: is True only when the variable name contains the word “John” (without the double
    quotes) and variable age contains a value greater than 5\. Both Boolean expressions
    must be True. If at least one of them is False, for example, the variable age
    contains a value of 3, then the whole complex Boolean expression is False.
  prefs: []
  type: TYPE_NORMAL
- en: The or operator
  prefs: []
  type: TYPE_NORMAL
- en: When you use the or operator between two Boolean expressions (BE1 or BE2), it
    means that the result of the whole complex Boolean expression is True when either
    the first (BE1) or the second (BE2) Boolean expression is True (at least one).
  prefs: []
  type: TYPE_NORMAL
- en: The truth table for the or operator is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '| BE1 (Boolean Expression 1) | BE2 (Boolean Expression 2) | BE1 or BE2 |'
  prefs: []
  type: TYPE_TB
- en: '| False | False | False |'
  prefs: []
  type: TYPE_TB
- en: '| False | True | True |'
  prefs: []
  type: TYPE_TB
- en: '| True | False | True |'
  prefs: []
  type: TYPE_TB
- en: '| True | True | True |'
  prefs: []
  type: TYPE_TB
- en: Let's see an example. The complex Boolean expression
  prefs: []
  type: TYPE_NORMAL
- en: name == "John" or name == "George"
  prefs: []
  type: TYPE_NORMAL
- en: is True when the variable name contains the word “John” or the word “George”
    (without the double quotes). At least one Boolean expression must be True. If
    both Boolean expressions are False, for example, the variable name contains the
    word “Maria”, then the whole complex Boolean expression is False.
  prefs: []
  type: TYPE_NORMAL
- en: The not operator
  prefs: []
  type: TYPE_NORMAL
- en: When you use the not operator in front of a Boolean expression (not BE), it
    means that the result of the whole complex Boolean expression is True when the
    Boolean expression BE is False and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: The truth table for the not operator is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '| BE (Boolean Expression) | not BE |'
  prefs: []
  type: TYPE_TB
- en: '| False | True |'
  prefs: []
  type: TYPE_TB
- en: '| True | False |'
  prefs: []
  type: TYPE_TB
- en: For example, the complex Boolean expression
  prefs: []
  type: TYPE_NORMAL
- en: not age > 5
  prefs: []
  type: TYPE_NORMAL
- en: is True when the variable age contains a value less than or equal to 5\. For
    instance, if the variable age contains a value of 6, then the whole complex Boolean
    expression is False.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The logical operator not reverses the result of a Boolean
    expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.4-1 Calculating the Results of Complex Boolean Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calculate the results of the following complex Boolean expressions when variables
    a, b, c, and d contain the values 5, 2, 7, and −3 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: i)(3 * a + b / 47 - c * b / a > 23) and (b != 2)
  prefs: []
  type: TYPE_NORMAL
- en: ii)(a * b - c / 2 + 21 * c / 3) or (a >= 5)
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: Don't be scared! The results can be found very easily. All you need is to recall
    what applies to and and or operators.
  prefs: []
  type: TYPE_NORMAL
- en: i)The result of an and operator is True when both Boolean expressions are True.
    If you take a closer look, the result of the Boolean expression on the right (b
    != 2) is False. So, you don't have to waste your time calculating the result of
    the Boolean expression on the left. The final result is definitely False.
  prefs: []
  type: TYPE_NORMAL
- en: ii)The result of an or operator is True when at least one Boolean expression
    is True. If you take a closer look, the result of the Boolean expression on the
    right (a >= 5) is actually True. So, don't bother calculating the result of the
    Boolean expression on the left. The final result is definitely True.
  prefs: []
  type: TYPE_NORMAL
- en: 15.5 Python's Membership Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, a membership operator evaluates whether or not an operand exists
    in a specified sequence. There are two membership operators, as shown in Table
    15-3.
  prefs: []
  type: TYPE_NORMAL
- en: '| Membership Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| in | It evaluates to True if it finds a value in the specified sequence;
    it evaluates to False otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| not in | It evaluates to True if it does not find a value in the specified
    sequence; it evaluates to False otherwise. |'
  prefs: []
  type: TYPE_TB
- en: Table 15-3 Membership Operators in Python
  prefs: []
  type: TYPE_NORMAL
- en: Next are some examples of Boolean expressions that use membership operators.
  prefs: []
  type: TYPE_NORMAL
- en: ►x in [3, 5, 9]. This can be read as “is x equal to 3, or equal to 5, or equal
    to 9?”
  prefs: []
  type: TYPE_NORMAL
- en: It can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: x == 3 or x == 5 or x == 9
  prefs: []
  type: TYPE_NORMAL
- en: ►3 in [x, y, z]. This can be read as “is 3 equal to x, or equal to y, or equal
    to z?”
  prefs: []
  type: TYPE_NORMAL
- en: It can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: 3 == x or 3 == y or 3 == z
  prefs: []
  type: TYPE_NORMAL
- en: ►s in "ace". This can be read as 'does the content of variable s appear in the
    word “ace”' or in other words, 'is s equal to letter “a”, or equal to letter “c”,
    or equal to letter “e”, or equal to word “ac”, or equal to word “ce”, or equal
    to word “ace”?'
  prefs: []
  type: TYPE_NORMAL
- en: It can be written equivalently as
  prefs: []
  type: TYPE_NORMAL
- en: s == "a" or s == "c" or s == "e" or s == "ac" or s == "ce" or s == "ace"
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)The Boolean expression s in "ace" checks if the string s
    can be found as a consecutive sequence of characters within the string "ace".
    In other words, it looks for s as a continuous substring in "ace". This is why
    it does not check for the substring "ae"; because the letters “a” and “e” are
    not continuous.'
  prefs: []
  type: TYPE_NORMAL
- en: ►s in ["a", "c", "e"]. This can be read as 'is s equal to letter “a”, or equal
    to letter “c” , or equal to letter “e”?'
  prefs: []
  type: TYPE_NORMAL
- en: It can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: s == "a" or s == "c" or s == "e"
  prefs: []
  type: TYPE_NORMAL
- en: ►s not in ["a", "c", "e"]. This can be read as 'is s not equal to letter “a”,
    nor equal to letter “c”, nor equal to letter “e”?'
  prefs: []
  type: TYPE_NORMAL
- en: It can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: not(s == "a" or s == "c" or s == "e")
  prefs: []
  type: TYPE_NORMAL
- en: or as
  prefs: []
  type: TYPE_NORMAL
- en: s != "a" and s != "c" and s != "e"
  prefs: []
  type: TYPE_NORMAL
- en: 15.6 Assigning the Result of a Boolean Expression to a Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that a Boolean expression actually returns a value (True or False), this
    value can be directly assigned to a variable. For example, the statement
  prefs: []
  type: TYPE_NORMAL
- en: a = x > y
  prefs: []
  type: TYPE_NORMAL
- en: assigns a value of True or False to Boolean variable a. It can be read as “If
    the content of variable x is greater than the content of variable y, assign the
    value True to variable a; otherwise, assign the value False”. This next example
    displays the value True on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/my_exercise_header.png) file_15.6'
  prefs: []
  type: TYPE_NORMAL
- en: x, y = 8, 5
  prefs: []
  type: TYPE_NORMAL
- en: a = x > y
  prefs: []
  type: TYPE_NORMAL
- en: print(a)
  prefs: []
  type: TYPE_NORMAL
- en: 15.7 What is the Order of Precedence of Logical Operators?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more complex Boolean expression may use several logical operators like the
    expression shown here
  prefs: []
  type: TYPE_NORMAL
- en: name == "Peter" or age > 10 and not name == "Maria"
  prefs: []
  type: TYPE_NORMAL
- en: So, a reasonable question is “which logical operation is performed first?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical operators in Python follow the same precedence rules that apply to
    the majority of programming languages. The order of precedence is: logical complements
    (not) are performed first, logical conjunctions (and) are performed next, and
    logical disjunctions (or) are performed at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Higher Precedence ![Image](img/arrow_up.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Lower Precedence | Logical Operator |
  prefs: []
  type: TYPE_NORMAL
- en: '| not |'
  prefs: []
  type: TYPE_TB
- en: '| and |'
  prefs: []
  type: TYPE_TB
- en: '| or |'
  prefs: []
  type: TYPE_TB
- en: Table 15-4 The Order of Precedence of Logical Operators
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)You can always use parentheses to change the default precedence.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.7-1 Filling in the Truth Table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fill in the following table with the words “True” or “False” according to the
    values of the variables a, b and c.
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | c | a > 2 or c > b and c > 2 | not(a > 2 or c > b and c > 2) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | −5 | 7 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 10 | 3 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| −4 | −2 | −9 |   |   |'
  prefs: []
  type: TYPE_TB
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the result of complex Boolean expressions you can use the following
    graphical method.
  prefs: []
  type: TYPE_NORMAL
- en: For a = 1, b = −5, c = 7, the final result is True as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/remember.jpg)The and operation has a higher precedence and is performed
    before the or operation.'
  prefs: []
  type: TYPE_NORMAL
- en: For a = 10, b = 10, c = 3, the final result is True as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-02.png)'
  prefs: []
  type: TYPE_IMG
- en: For a = −4, b = −2, c = −9, the final result is False as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The values in the table's fifth column can be calculated very easily because
    the Boolean expression in its column heading is almost identical to the one in
    the fourth column. The only difference is the not operator in front of the expression.
    So, the values in the fifth column can be calculated by simply negating the results
    in the fourth column!
  prefs: []
  type: TYPE_NORMAL
- en: The final truth table is shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | c | a > 2 or c > b and c > 2 | not(a > 2 or c > b and c > 2) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | −5 | 7 | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 10 | 3 | True | False |'
  prefs: []
  type: TYPE_TB
- en: '| −4 | −2 | −9 | False | True |'
  prefs: []
  type: TYPE_TB
- en: Exercise 15.7-2 Converting English Sentences to Boolean Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A head teacher asks the students to raise their hands according to their age.
    He wants to find the students who are
  prefs: []
  type: TYPE_NORMAL
- en: i)between the ages of 9 and 12.
  prefs: []
  type: TYPE_NORMAL
- en: ii)under the age of 8 and over the age of 11.
  prefs: []
  type: TYPE_NORMAL
- en: iii)8, 10, and 12 years old.
  prefs: []
  type: TYPE_NORMAL
- en: iv)between the ages of 6 and 8, and between the ages of 10 and 12.
  prefs: []
  type: TYPE_NORMAL
- en: v)neither 10 nor 12 years old.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: To compose the required Boolean expressions, a variable age is used.
  prefs: []
  type: TYPE_NORMAL
- en: i)The sentence “between the ages of 9 and 12” can be graphically represented
    as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Be careful though! It is valid to write 9 ≤ age ≤ 12 in mathematics, as well
    as in Python where you can write it as
  prefs: []
  type: TYPE_NORMAL
- en: 9 <= age <= 12
  prefs: []
  type: TYPE_NORMAL
- en: In most computer languages, however, this is not a valid Boolean expression.
    What you can do is to split the expression into two parts, as shown here
  prefs: []
  type: TYPE_NORMAL
- en: age >= 9 and age <= 12
  prefs: []
  type: TYPE_NORMAL
- en: This last expression is valid in most computer languages, including Python!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)For your confirmation, you can test this Boolean expression
    for several values inside and outside of the “region of interest” (the range of
    data that you have specified). For example, the result of the expression is False
    for the age values 7, 8, 13, and 17\. On the contrary, for the age values 9, 10,
    11, and 12, the result is True.'
  prefs: []
  type: TYPE_NORMAL
- en: ii)The sentence “under the age of 8 and over the age of 11” can be graphically
    represented as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/notice.jpg)Note the absence of the two circles that you saw in solution
    (i). This means the values 8 and 11 are not included within the two regions of
    interest.'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with the sentence “Under the age of 8 and over the age of 11”. It's
    a trap! Don't make the mistake of writing
  prefs: []
  type: TYPE_NORMAL
- en: age < 8 and age > 11
  prefs: []
  type: TYPE_NORMAL
- en: There is no person on the planet Earth that can be under the age of 8 and over
    the age of 11 concurrently!
  prefs: []
  type: TYPE_NORMAL
- en: The trap is in the word “and”. Try to rephrase the sentence and make it “Children!
    Please raise your hand if you are under the age of 8 or over the age of 11”. Now
    it's better and the correct Boolean expression becomes
  prefs: []
  type: TYPE_NORMAL
- en: age < 8 or age > 11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)For your confirmation, you can test this expression for
    several values inside and outside of the regions of interest. For example, the
    result of the expression is False for the age values 8, 9, 10 and 11\. On the
    contrary, for the age values 6, 7, 12, and 15, the result is True.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, however, don't make the mistake of writing
  prefs: []
  type: TYPE_NORMAL
- en: 8 > age > 11
  prefs: []
  type: TYPE_NORMAL
- en: because, if you split the expression into two parts, it is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: age < 8 and age > 11
  prefs: []
  type: TYPE_NORMAL
- en: which, as already mentioned, is incorrect!
  prefs: []
  type: TYPE_NORMAL
- en: iii)Oops! Another trap in the sentence “8, 10, and 12 years old” with the “and”
    word again! Obviously, the next Boolean expression is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: age == 8 and age == 10 and age == 12
  prefs: []
  type: TYPE_NORMAL
- en: As before, there isn't any student who is 8 and 10 and 12 years old concurrently!
    Once again, the correct Boolean expression must use the or operator.
  prefs: []
  type: TYPE_NORMAL
- en: age == 8 or age == 10 or age == 12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)For your confirmation, you can test this expression for
    several values. For example, the result of the expression is False for the age
    values 7, 9, 11, and 13\. For the age values 8, 10, and 12, the result is True.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this complex Boolean expression can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: age in [8, 10, 12]
  prefs: []
  type: TYPE_NORMAL
- en: iv)The sentence “between the ages of 6 and 8, and between the ages of 10 and
    12” can be graphically represented as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-06.png)'
  prefs: []
  type: TYPE_IMG
- en: and the Boolean expression is
  prefs: []
  type: TYPE_NORMAL
- en: age >= 6 and age <= 8 or age >= 10 and age <= 12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)For your confirmation, the result of the expression is False
    for the age values 5, 9, 13, and 16\. For the age values 6, 7, 8, 10, 11, and
    12, the result is True.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this complex Boolean expression can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: 6 <= age <= 8 or 10 <= age <= 12
  prefs: []
  type: TYPE_NORMAL
- en: v)The Boolean expression for the sentence “neither 10 nor 12 years old” can
    be written as
  prefs: []
  type: TYPE_NORMAL
- en: age != 10 and age != 12
  prefs: []
  type: TYPE_NORMAL
- en: or as
  prefs: []
  type: TYPE_NORMAL
- en: not(age == 10 or age == 12)
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this complex Boolean expression can also be written as
  prefs: []
  type: TYPE_NORMAL
- en: age not in [10, 12]
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)When the arrows of the region of interest point towards
    each other, use the logical operator and. Otherwise, use or when the arrows point
    in opposite directions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](img/chapter15-07.png)'
  prefs: []
  type: TYPE_IMG
- en: 15.8 What is the Order of Precedence of Arithmetic, Comparison, Membership,
    and Logical Operators?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, an expression may contain different type of operators, such as
    the one shown here.
  prefs: []
  type: TYPE_NORMAL
- en: a * b + 2 > 21 or not(c == b / 2) and c > 13
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, arithmetic operations are performed first, comparison and membership
    operations are performed next, and logical operations are performed at the end,
    as shown in the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Higher Precedence ![Image](img/arrow_up.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Lower Precedence | Arithmetic Operators | ** |
  prefs: []
  type: TYPE_NORMAL
- en: '| *, /, //, % |'
  prefs: []
  type: TYPE_TB
- en: '| +, − |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison and Membership Operators | <, <=, >, >=, ==, !=, in, not in |'
  prefs: []
  type: TYPE_TB
- en: '| Logical Operators | not |'
  prefs: []
  type: TYPE_TB
- en: '| and |'
  prefs: []
  type: TYPE_TB
- en: '| or |'
  prefs: []
  type: TYPE_TB
- en: Table 15-5 The Order of Precedence of Arithmetic, Comparison, Membership, and
    Logical Operators
  prefs: []
  type: TYPE_NORMAL
- en: 15.9 How to Negate Boolean Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Negation is the process of reversing the meaning of a Boolean expression. There
    are two approaches used to negate a Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is the easiest one. Just use a not operator in front of the
    original Boolean expression and your negated Boolean expression is ready! For
    example, if the original Boolean expression is
  prefs: []
  type: TYPE_NORMAL
- en: x > 5 and y == 3
  prefs: []
  type: TYPE_NORMAL
- en: the negated Boolean expression becomes
  prefs: []
  type: TYPE_NORMAL
- en: not(x > 5 and y == 3)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the entire expression must be enclosed in parentheses.
    It would be completely incorrect if you had written the expression without parentheses,
    as not x > 5 and y == 3\. In this case the not operator would negate only the
    first Boolean expression, x > 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is a little bit more complex but not difficult to learn.
    All you must do is negate every operator according to the following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Original Operator | Negated Operator |'
  prefs: []
  type: TYPE_TB
- en: '| == | != |'
  prefs: []
  type: TYPE_TB
- en: '| != | == |'
  prefs: []
  type: TYPE_TB
- en: '| > | <= |'
  prefs: []
  type: TYPE_TB
- en: '| < | >= |'
  prefs: []
  type: TYPE_TB
- en: '| <= | > |'
  prefs: []
  type: TYPE_TB
- en: '| >= | < |'
  prefs: []
  type: TYPE_TB
- en: '| in | not in |'
  prefs: []
  type: TYPE_TB
- en: '| not in | in |'
  prefs: []
  type: TYPE_TB
- en: '| and | or |'
  prefs: []
  type: TYPE_TB
- en: '| or | and |'
  prefs: []
  type: TYPE_TB
- en: '| not | not |'
  prefs: []
  type: TYPE_TB
- en: '![](img/notice.jpg)Note that the not operator remains intact.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the original Boolean expression is
  prefs: []
  type: TYPE_NORMAL
- en: x > 5 and y == 3
  prefs: []
  type: TYPE_NORMAL
- en: the negated Boolean expression becomes
  prefs: []
  type: TYPE_NORMAL
- en: x <= 5 or y != 3
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a small detail that you should be careful with. If both and
    and or operators co-exist in a complex Boolean expression, then the expressions
    that use the or operators in the negated Boolean expression must be enclosed in
    parentheses, in order to preserve the initial order of precedence. For example,
    if the original Boolean expression is
  prefs: []
  type: TYPE_NORMAL
- en: x >= 5 and x <= 10 or y == 3
  prefs: []
  type: TYPE_NORMAL
- en: the negated Boolean expression must be
  prefs: []
  type: TYPE_NORMAL
- en: (x < 5 or x > 10) and y != 3
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)If you forget to enclose the expression x < 5 or x > 10
    in parentheses, since the and operator has a higher precedence than the or operator,
    the expression x > 10 and y != 3 is evaluated first, which is wrong of course!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.9-1 Negating Boolean Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Negate the following Boolean expressions using both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: i)b != 4
  prefs: []
  type: TYPE_NORMAL
- en: ii)a * 3 + 2 > 0
  prefs: []
  type: TYPE_NORMAL
- en: iii)not(a == 5 and b >= 7)
  prefs: []
  type: TYPE_NORMAL
- en: iv)a == True
  prefs: []
  type: TYPE_NORMAL
- en: v)b > 7 and not(x > 4)
  prefs: []
  type: TYPE_NORMAL
- en: vi)a == 4 or b != 2
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs: []
  type: TYPE_NORMAL
- en: First approach
  prefs: []
  type: TYPE_NORMAL
- en: i)not(b != 4)
  prefs: []
  type: TYPE_NORMAL
- en: ii)not(a * 3 + 2 > 0)
  prefs: []
  type: TYPE_NORMAL
- en: iii)not(not(a == 5 and b >= 7)), or the equivalent a == 5 and b >= 7
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Two negations result in an affirmative. That is, two not
    operators in a row negate each other.'
  prefs: []
  type: TYPE_NORMAL
- en: iv)not(a == True)
  prefs: []
  type: TYPE_NORMAL
- en: v)not(b > 7 and not(x > 4))
  prefs: []
  type: TYPE_NORMAL
- en: vi)not(a == 4 or b != 2)
  prefs: []
  type: TYPE_NORMAL
- en: Second approach
  prefs: []
  type: TYPE_NORMAL
- en: i)b == 4
  prefs: []
  type: TYPE_NORMAL
- en: ii)a * 3 + 2 <= 0
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that arithmetic operators are not “negated”. Never
    substitute, for example, the plus ( + ) with a minus ( − ) operator!'
  prefs: []
  type: TYPE_NORMAL
- en: iii)not(a != 5 or b < 7)
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/notice.jpg)Note that the not operator remains intact.'
  prefs: []
  type: TYPE_NORMAL
- en: iv)a != True
  prefs: []
  type: TYPE_NORMAL
- en: v)b <= 7 or not(x <= 4)
  prefs: []
  type: TYPE_NORMAL
- en: vi)a != 4 and b == 2
  prefs: []
  type: TYPE_NORMAL
- en: '15.10 Review Questions: True/False'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose true or false for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)A Boolean expression is an expression that always results in one of two values.
  prefs: []
  type: TYPE_NORMAL
- en: 2)A Boolean expression includes at least one logical operator.
  prefs: []
  type: TYPE_NORMAL
- en: 3)In Python, the expression x = 5 tests if the variable x is equal to 5.
  prefs: []
  type: TYPE_NORMAL
- en: 4)The statement a = b == c is not a valid Python statement.
  prefs: []
  type: TYPE_NORMAL
- en: 5)The Boolean expression b < 5 tests if the variable b is 5 or less.
  prefs: []
  type: TYPE_NORMAL
- en: 6)The and operator is also known as a logical disjunction operator.
  prefs: []
  type: TYPE_NORMAL
- en: 7)The or operator is also known as a logical complement operator.
  prefs: []
  type: TYPE_NORMAL
- en: 8)The result of a logical conjunction of two Boolean expressions equals the
    result of the logical disjunction of them, given that both Boolean expressions
    are True.
  prefs: []
  type: TYPE_NORMAL
- en: 9)The result of a logical disjunction of two Boolean expressions is definitely
    True, given that the Boolean expressions have different values.
  prefs: []
  type: TYPE_NORMAL
- en: 10)The expression c == 3 and d > 7 is considered a complex Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: 11)The result of the logical operator or is True when both operands (Boolean
    expressions) are True.
  prefs: []
  type: TYPE_NORMAL
- en: 12)The result of the Boolean expression not(x == 5) is True when the variable
    x contains any value except 5.
  prefs: []
  type: TYPE_NORMAL
- en: 13)The not operator has the highest precedence among logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: 14)The or operator has the lowest precedence among logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: 15)In the Boolean expression (x > y or x == 5) and x <= z, the and operation
    is performed before the or operation.
  prefs: []
  type: TYPE_NORMAL
- en: 16)In the Boolean expression a * b + c > 21 or c == b / 2, the program first
    tests if c is greater than 21.
  prefs: []
  type: TYPE_NORMAL
- en: 17)When a teacher wants to find the students who are under the age of 8 and
    over the age of 11, the corresponding Boolean expression is 8 > age > 11.
  prefs: []
  type: TYPE_NORMAL
- en: 18)The Boolean expression x < 0 and x > 100 is, for any value of x, always False.
  prefs: []
  type: TYPE_NORMAL
- en: 19)The Boolean expression x > 0 or x < 100 is, for any value of x, always True.
  prefs: []
  type: TYPE_NORMAL
- en: 20)The Boolean expression x > 5 is equivalent to not(x < 5).
  prefs: []
  type: TYPE_NORMAL
- en: 21)The Boolean expression not(x > 5 and y == 5) is not equivalent to not(x >
    5) and y == 5.
  prefs: []
  type: TYPE_NORMAL
- en: '22)In William Shakespeare^([[13]](footnotes.html#Endnote_13))''s Hamlet (Act
    3, Scene 1), the main character says “To be, or not to be: that is the question:….
    ” If you write this down as a Boolean expression toBe or not toBe, the result
    of this “Shakesboolean” expression is True for the following code fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: toBe = 1 > 0
  prefs: []
  type: TYPE_NORMAL
- en: thatIsTheQuestion = toBe or not toBe
  prefs: []
  type: TYPE_NORMAL
- en: 23)The Boolean expression not(not(x > 5)) is equivalent to x > 5.
  prefs: []
  type: TYPE_NORMAL
- en: '15.11 Review Questions: Multiple Choice'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select the correct answer for each of the following statements.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Which of the following is not a comparison operator?
  prefs: []
  type: TYPE_NORMAL
- en: a)>=
  prefs: []
  type: TYPE_NORMAL
- en: b)=<
  prefs: []
  type: TYPE_NORMAL
- en: c)<
  prefs: []
  type: TYPE_NORMAL
- en: d)All of the above are comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 2)Which of the following is not a Python logical operator?
  prefs: []
  type: TYPE_NORMAL
- en: a)nor
  prefs: []
  type: TYPE_NORMAL
- en: b)not
  prefs: []
  type: TYPE_NORMAL
- en: c)All of the above are logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: d)None of the above is a logical operator.
  prefs: []
  type: TYPE_NORMAL
- en: 3)If variable x contains a value of 5, what value does the statement y = x %
    2 == 1 assign to variable y?
  prefs: []
  type: TYPE_NORMAL
- en: a)True
  prefs: []
  type: TYPE_NORMAL
- en: b)False
  prefs: []
  type: TYPE_NORMAL
- en: c)1
  prefs: []
  type: TYPE_NORMAL
- en: d)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 4)If variable x contains a value of 5, what value does the statement y = x %
    2 == 0 or int(x / 2.0) == 2 assign to variable y?
  prefs: []
  type: TYPE_NORMAL
- en: a)True
  prefs: []
  type: TYPE_NORMAL
- en: b)False
  prefs: []
  type: TYPE_NORMAL
- en: c)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 5)The temperature in a laboratory room must be between 50 and 80 degrees Fahrenheit.
    Which of the following Boolean expressions tests for this condition?
  prefs: []
  type: TYPE_NORMAL
- en: a)t >= 50 or t <= 80
  prefs: []
  type: TYPE_NORMAL
- en: b)50 >= t >= 80
  prefs: []
  type: TYPE_NORMAL
- en: c)t >= 50 and t <= 80
  prefs: []
  type: TYPE_NORMAL
- en: d)t > 50 or t < 80
  prefs: []
  type: TYPE_NORMAL
- en: e)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 6)Which of the following is equivalent to the Boolean expression t == 3 or t
    > 30?
  prefs: []
  type: TYPE_NORMAL
- en: a)t == 3 and not(t <= 30)
  prefs: []
  type: TYPE_NORMAL
- en: b)t == 3 and not(t < 30)
  prefs: []
  type: TYPE_NORMAL
- en: c)not(t != 3) or not(t < 30)
  prefs: []
  type: TYPE_NORMAL
- en: d)not(t != 3 and t <= 30)
  prefs: []
  type: TYPE_NORMAL
- en: e)none of the above
  prefs: []
  type: TYPE_NORMAL
- en: 15.12 Review Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 1)Match each element from the first column with one or more elements from the
    second column.
  prefs: []
  type: TYPE_NORMAL
- en: '| Description | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| i) Logical operator | a) % |'
  prefs: []
  type: TYPE_TB
- en: '| ii) Arithmetic operator | b) += |'
  prefs: []
  type: TYPE_TB
- en: '| iii) Comparison operator | c) and |'
  prefs: []
  type: TYPE_TB
- en: '| ii) Assignment operator (in general) | d) == |'
  prefs: []
  type: TYPE_TB
- en: '|   | e) or |'
  prefs: []
  type: TYPE_TB
- en: '|   | f) >= |'
  prefs: []
  type: TYPE_TB
- en: '|   | g) not |'
  prefs: []
  type: TYPE_TB
- en: '|   | h) = |'
  prefs: []
  type: TYPE_TB
- en: '|   | i) *= |'
  prefs: []
  type: TYPE_TB
- en: '|   | j) / |'
  prefs: []
  type: TYPE_TB
- en: 2)Fill in the following table with the words “True” or “False” according to
    the values of variables a, b, and c.
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | c | a != 1 | b > a | c / 2 > 2 * a |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | −5 | 8 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 10 | 20 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| −4 | −2 | −9 |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: 3)Fill in the following table with the words “True” or “False” according to
    the values of the Boolean expressions BE1 and BE2.
  prefs: []
  type: TYPE_NORMAL
- en: '| BE1 (Boolean Expression 1) | BE2 (Boolean Expression 2) | BE1 or BE2 | BE1
    and BE2 | not(BE2) |'
  prefs: []
  type: TYPE_TB
- en: '| False | False |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| False | True |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| True | False |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| True | True |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: 4)Fill in the following table with the words “True” or “False” according to
    the values of variables a, b, and c.
  prefs: []
  type: TYPE_NORMAL
- en: '| a | b | c | a > 3 or c > b and c > 1 | a > 3 and c > b or c > 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | −6 | 2 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| −3 | 2 | −4 |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 5 | 5 |   |   |'
  prefs: []
  type: TYPE_TB
- en: 5)For x = 4, y = −2 and flag = True, fill in the following table with the corresponding
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Value |'
  prefs: []
  type: TYPE_TB
- en: '| (x + y) ** 3 |   |'
  prefs: []
  type: TYPE_TB
- en: '| (x + y) / (x ** 2 − 14) |   |'
  prefs: []
  type: TYPE_TB
- en: '| x − 1 == y + 5 |   |'
  prefs: []
  type: TYPE_TB
- en: '| x > 2 and y == 1 |   |'
  prefs: []
  type: TYPE_TB
- en: '| x == 1 or y == −2 and not(flag == False) |   |'
  prefs: []
  type: TYPE_TB
- en: '| not(x >= 3) and (x % 2 > 1) |   |'
  prefs: []
  type: TYPE_TB
- en: 6)Calculate the result of each the following complex Boolean expressions when
    variables a, b, c, and d contain the values 6, −3, 4, and 7 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: i)(3 * a + b / 5 - c * b / a > 4) and (b != -3)
  prefs: []
  type: TYPE_NORMAL
- en: ii)(a * b - c / 2 + 21 * c / 3 != 8) or (a >= 5)
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Start by evaluating the simpler parts of the expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '7)A head teacher asks the students to raise their hands according to their
    age. He wants to find the students who are:'
  prefs: []
  type: TYPE_NORMAL
- en: i)under the age of 12, but not those who are 8 years old.
  prefs: []
  type: TYPE_NORMAL
- en: ii)between the ages of 6 and 9, and also those who are 11 years old.
  prefs: []
  type: TYPE_NORMAL
- en: iii)over the age of 7, but not those who are 10 or 12 years old.
  prefs: []
  type: TYPE_NORMAL
- en: iv)6, 9, and 11 years old.
  prefs: []
  type: TYPE_NORMAL
- en: v)between the ages of 6 and 12, but not those who are 8 years old.
  prefs: []
  type: TYPE_NORMAL
- en: vi)neither 7 nor 10 years old.
  prefs: []
  type: TYPE_NORMAL
- en: To compose the required Boolean expressions, use a variable named age.
  prefs: []
  type: TYPE_NORMAL
- en: 8)Negate the following Boolean expressions without adding the not operator in
    front of the expressions.
  prefs: []
  type: TYPE_NORMAL
- en: i)x == 4 and y != 3
  prefs: []
  type: TYPE_NORMAL
- en: ii)x + 4 <= 0
  prefs: []
  type: TYPE_NORMAL
- en: iii)not(x > 5) or y == 4
  prefs: []
  type: TYPE_NORMAL
- en: iv)x != False
  prefs: []
  type: TYPE_NORMAL
- en: v)not(x >= 4 or z > 4)
  prefs: []
  type: TYPE_NORMAL
- en: vi)x != 2 and x >= −5
  prefs: []
  type: TYPE_NORMAL
- en: 9)As you already know, two negations result in an affirmative. Write the equivalent
    of the following Boolean expressions by negating them twice (applying both methods).
  prefs: []
  type: TYPE_NORMAL
- en: i)x >= 4 and y != 10
  prefs: []
  type: TYPE_NORMAL
- en: ii)x - 2 >= 9
  prefs: []
  type: TYPE_NORMAL
- en: iii)not(x >= 2) or y != 4
  prefs: []
  type: TYPE_NORMAL
- en: iv)x != False or y == 3
  prefs: []
  type: TYPE_NORMAL
- en: v)not(x >= 2 and y >= 2)
  prefs: []
  type: TYPE_NORMAL
- en: vi)x != −2 and x <= 2
  prefs: []
  type: TYPE_NORMAL
