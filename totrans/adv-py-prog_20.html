<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer182">
			<h1 id="_idParaDest-308"><em class="italic"><a id="_idTextAnchor289"/>Chapter 17</em>: The Builder Pattern</h1>
			<p>In the previous chapter, we covered the first two creational patterns—the factory method and abstract factory, both of which offer approaches to improve the way we create objects in nontrivial cases. The builder design pattern, on the other hand, as we'll discuss in this chapter, is useful for managing objects that consist of multiple parts that need to be implemented sequentially. By decoupling the construction of an object and its representation, the builder pattern allows us to reuse a construction multiple times.</p>
			<p>Just as with the previous chapter, we will discuss real-life applications that use this design pattern as well as implementing a hands-on example ourselves.</p>
			<p>In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>Understanding the builder pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementing an ordering application</li>
			</ul>
			<p>By the end of the chapter, we will understand how to use the builder pattern and its practical benefits.</p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor290"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: </p>
			<p><a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17</a></p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor291"/>Understanding the builder pattern</h1>
			<p>Imagine that we want to create an object that is composed of multiple parts and the composition <a id="_idIndexMarker1169"/>needs to be done step by step. The object is not complete unless all its parts are fully created. That's where the <strong class="bold">builder-design pattern</strong> can help us. The builder pattern separates the construction of a complex object from its representation. By keeping the construction separate from the representation, the same construction can be used to create several different representations (<a href="http://j.mp/builderpat">j.mp/builderpat</a>).</p>
			<p>A practical example can help us understand what the purpose of the builder pattern is. Suppose that <a id="_idIndexMarker1170"/>we want to create a <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) page generator. The basic structure (construction part) of an HTML page is always the same: it begins with <strong class="source-inline">&lt;html&gt;</strong> and finishes with <strong class="source-inline">&lt;/html&gt;</strong>; inside the HTML section are the <strong class="source-inline">&lt;head&gt;</strong> and <strong class="source-inline">&lt;/head&gt;</strong> elements; inside the head section are the <strong class="source-inline">&lt;title&gt;</strong> and <strong class="source-inline">&lt;/title&gt;</strong> elements; and so forth. But the representation of the page can differ. Each page has its own title, its own headings, and different <strong class="source-inline">&lt;body&gt;</strong> contents. Moreover, the page is usually built in steps: one function adds the title, another adds the main heading, another the footer, and so on. Only after the whole structure <a id="_idIndexMarker1171"/>of a page is complete can it be shown to the client using a final render function. We can take it even further and extend the HTML generator so that it can generate totally different HTML pages. One page might contain tables, another page might contain image galleries, yet another page contains the contact form, and so on.</p>
			<p>The HTML page-generation problem can be solved using the builder pattern. In this pattern, there are two main participants, outlined as follows:</p>
			<ul>
				<li><strong class="bold">The builder</strong>: The component responsible for creating the various parts of a complex <a id="_idIndexMarker1172"/>object. In this example, these parts are the title, heading, body, and the footer of the page.</li>
				<li><strong class="bold">The director</strong>: The component that controls the building process using a <strong class="source-inline">builder</strong> instance. It <a id="_idIndexMarker1173"/>calls the builder's functions for setting the title, the heading, and so on, and using a different <strong class="source-inline">builder</strong> instance allows us to create a different HTML page without touching any of the code of the director.</li>
			</ul>
			<p>First, let's discuss in the next section some real-life examples where this pattern applies.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor292"/>Real-world examples</h1>
			<p>In our everyday life, the <em class="italic">builder design pattern</em> is used in fast-food restaurants. The same procedure is always used to prepare a burger and the packaging (box and paper bag), even if <a id="_idIndexMarker1174"/>there are many different kinds of burgers (classic, cheeseburger, and more) and different packages (small-sized box, medium-sized box, and so forth). The difference between a classic burger and a cheeseburger is in the representation, and not in the construction procedure. In this case, the <strong class="bold">director</strong> is the cashier who gives the crew instructions about what needs to be prepared, and the <strong class="bold">builder</strong> is the person from the crew that takes care of a specific order.</p>
			<p>We can also find software examples, as follows:</p>
			<ul>
				<li>The HTML example that was mentioned at the beginning of the chapter is actually used by <strong class="source-inline">django-widgy</strong> (<a href="https://wid.gy/">https://wid.gy/</a>), a third-party tree editor for Django <a id="_idIndexMarker1175"/>that can be used as a <strong class="bold">content management system</strong> (<strong class="bold">CMS</strong>). The <strong class="source-inline">django-widgy</strong> editor contains a page builder that can be used for creating HTML pages with different layouts.</li>
				<li>The <strong class="source-inline">django-query-builder</strong> library (<a href="https://github.com/ambitioninc/django-query-builder">https://github.com/ambitioninc/django-query-builder</a>) is another third-party Django library that relies on the builder pattern. This <a id="_idIndexMarker1176"/>library can be used for building <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) queries dynamically, allowing you to control all aspects of a query and create a different range of queries, from simple to very complex ones.</li>
			</ul>
			<p>In the next section, we will see how this design pattern actually works.</p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor293"/>Use cases</h1>
			<p>We use the <a id="_idIndexMarker1177"/>builder pattern when we know that an object must be created in multiple steps, and different representations of the same construction are required. These requirements exist in many applications, such as page generators (for example, the HTML page generator mentioned in this chapter), document converters, and <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) form creators (<a href="http://j.mp/pipbuild">j.mp/pipbuild</a>).</p>
			<p>Some online resources mention that the builder pattern can also be used as a solution to the telescopic constructor problem. The telescopic constructor problem occurs when we are forced to create a new constructor for supporting different ways of creating an object. The problem is that we end up with many constructors and long parameter lists that are hard to manage. An example of the telescopic constructor is listed on the Stack Overflow website (<a href="http://j.mp/sobuilder">j.mp/sobuilder</a>). Fortunately, this problem does not exist in Python, because it can be solved in at least two ways, as outlined here:</p>
			<ul>
				<li>With named parameters that define different behaviors in the constructor of the class (<a href="http://j.mp/sobuipython">j.mp/sobuipython</a>)</li>
				<li>With argument list unpacking, which is similar in spirit to named parameters (<a href="http://j.mp/arglistpy">j.mp/arglistpy</a>)</li>
			</ul>
			<p>These features <a id="_idIndexMarker1178"/>that are specific to Python help us control the behavior of its code easily, thus avoiding the problem we described previously.</p>
			<p>At this point, the distinction between the builder pattern and the factory pattern might not be very clear. The main difference is that the factory pattern creates an object in a single step, whereas the builder pattern creates an object in multiple steps, and almost always through the use of a director. Some targeted implementations of the builder pattern, such as Java's <strong class="source-inline">StringBuilder</strong>, bypass the use of a director, but that's the exception to the rule.</p>
			<p>Another difference is that while the factory pattern returns a created object immediately, in the builder pattern the client code explicitly asks the director to return the final object when it needs it (<a href="http://j.mp/builderpat">j.mp/builderpat</a>).</p>
			<p>The new computer analogy might help you to distinguish between the builder pattern and the factory pattern. Assume that you want to buy a new computer. If you decide to buy a specific, preconfigured computer model—for example, the latest Apple 1.4 <strong class="bold">gigahertz</strong> (<strong class="bold">GHz</strong>) Mac mini—you use the factory pattern. All the hardware specifications are already predefined by the manufacturer, who knows what to do without consulting you. The manufacturer typically receives just a single instruction. Code-wise, this is how it would look (<strong class="source-inline">apple_factory.py</strong>):</p>
			<p class="source-code">MINI14 = '1.4GHz Mac mini'</p>
			<p class="source-code">class AppleFactory:</p>
			<p class="source-code">    class MacMini14:</p>
			<p class="source-code">        def __init__(self):</p>
			<p class="source-code">            self.memory = 4 # in gigabytes</p>
			<p class="source-code">            self.hdd = 500 # in gigabytes</p>
			<p class="source-code">            self.gpu = 'Intel HD Graphics 5000'</p>
			<p class="source-code">        def __str__(self):</p>
			<p class="source-code">            info = (f'Model: {MINI14}',</p>
			<p class="source-code">                    f'Memory: {self.memory}GB',</p>
			<p class="source-code">                    f'Hard Disk: {self.hdd}GB',</p>
			<p class="source-code">                    f'Graphics Card: {self.gpu}')</p>
			<p class="source-code">            return '\n'.join(info)</p>
			<p class="source-code">    def build_computer(self, model):</p>
			<p class="source-code">        if model == MINI14:</p>
			<p class="source-code">            return self.MacMini14()</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            msg = f"I don't know how to build {model}"</p>
			<p class="source-code">            print(msg)</p>
			<p>Now, we add <a id="_idIndexMarker1179"/>the main part of the program—the snippet that uses the <strong class="source-inline">AppleFactory</strong> class. The code is illustrated here:</p>
			<p class="source-code">if __name__ == '__main__':</p>
			<p class="source-code">    afac = AppleFactory()</p>
			<p class="source-code">    mac_mini = afac.build_computer(MINI14)</p>
			<p class="source-code">    print(mac_mini)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice the nested <strong class="source-inline">MacMini14</strong> class. This is a neat way of forbidding the direct instantiation of a class.</p>
			<p>Another option would be to buy a custom PC. In this case, you use the builder pattern. You are the <a id="_idIndexMarker1180"/>director who gives orders to the manufacturer (<strong class="source-inline">builder</strong>) about your ideal computer specifications. Code-wise, this is how it looks (<strong class="source-inline">computer_builder.py</strong>):</p>
			<ol>
				<li>We define a <strong class="source-inline">Computer</strong> class, as follows:<p class="source-code">class Computer:</p><p class="source-code">    def __init__(self, serial_number):</p><p class="source-code">        self.serial = serial_number</p><p class="source-code">        self.memory = None # in gigabytes</p><p class="source-code">        self.hdd = None # in gigabytes</p><p class="source-code">        self.gpu = None</p><p class="source-code">    def __str__(self):</p><p class="source-code">        info = (f'Memory: {self.memory}GB',</p><p class="source-code">                f'Hard Disk: {self.hdd}GB',</p><p class="source-code">                f'Graphics Card: {self.gpu}')</p><p class="source-code">        return '\n'.join(info)</p></li>
				<li>We define a <strong class="source-inline">ComputerBuilder</strong> class, as follows:<p class="source-code">class ComputerBuilder:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        self.computer = Computer('AG23385193')</p><p class="source-code">    def configure_memory(self, amount):</p><p class="source-code">        self.computer.memory = amount</p><p class="source-code">    def configure_hdd(self, amount):</p><p class="source-code">        self.computer.hdd = amount</p><p class="source-code">    def configure_gpu(self, gpu_model):</p><p class="source-code">        self.computer.gpu = gpu_model</p></li>
				<li>We <a id="_idIndexMarker1181"/>define a <strong class="source-inline">HardwareEngineer</strong> class, as follows:<p class="source-code">class HardwareEngineer:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        self.builder = None</p><p class="source-code">    def construct_computer(self, memory, hdd, gpu):</p><p class="source-code">        self.builder = ComputerBuilder()</p><p class="source-code">        steps = (self.builder.configure_memory(memory),</p><p class="source-code">                 self.builder.configure_hdd(hdd),</p><p class="source-code">                 self.builder.configure_gpu(gpu))</p><p class="source-code">        [step for step in steps]</p><p class="source-code">    @property</p><p class="source-code">    def computer(self):</p><p class="source-code">        return self.builder.computer</p></li>
				<li>We end our code with the <strong class="source-inline">main()</strong> function, followed by a trick to call it when the file is called from the command line, as illustrated in the following code snippet:<p class="source-code">def main():</p><p class="source-code">    engineer = HardwareEngineer()</p><p class="source-code">    engineer.construct_computer(hdd=500, </p><p class="source-code">                                memory=8, </p><p class="source-code">                                gpu='GeForce GTX 650 Ti')</p><p class="source-code">    computer = engineer.computer</p><p class="source-code">    print(computer)</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    main()</p></li>
			</ol>
			<p>The basic <a id="_idIndexMarker1182"/>changes are the introduction of a builder (<strong class="source-inline">ComputerBuilder</strong>), a director    (<strong class="source-inline">HardwareEngineer</strong>), and the step-by-step construction of a computer, which now supports different configurations (notice that <strong class="source-inline">memory</strong>, <strong class="source-inline">hdd</strong>, and <strong class="source-inline">gpu</strong> are parameters and are not preconfigured). What do we need to do if we want to support the construction of tablets? Implement this as an exercise.</p>
			<p>You might also want to change the computer's <strong class="source-inline">serial_number</strong> value into something different for each computer because as it is now, this means that all computers will have the same serial number (which is impractical).</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor294"/>Implementing an ordering application</h1>
			<p>Let's see <a id="_idIndexMarker1183"/>how we can use the builder design pattern to make a pizza-ordering application. The pizza example is particularly interesting because a pizza is prepared in steps that should follow a specific order. To add the sauce, you first need to prepare the dough. To add the topping, you first need to add the sauce. And you can't start baking the pizza unless both the sauce and the topping are placed on the dough. Moreover, each pizza usually requires a different baking time, depending on the thickness of its dough and the topping used.</p>
			<p>We start by importing the required modules and declaring a few <strong class="source-inline">Enum</strong> parameters (<a href="http://j.mp/pytenum">j.mp/pytenum</a>) plus a constant that is used many times in the application. The <strong class="source-inline">STEP_DELAY</strong> constant is used to add a time delay between the different steps of preparing a pizza (prepare the dough, add the sauce, and so on), as follows:</p>
			<p class="source-code">from enum import Enum</p>
			<p class="source-code">import time</p>
			<p class="source-code">PizzaProgress = Enum('PizzaProgress', 'queued preparation \</p>
			<p class="source-code">  baking ready')</p>
			<p class="source-code">PizzaDough = Enum('PizzaDough', 'thin thick')</p>
			<p class="source-code">PizzaSauce = Enum('PizzaSauce', 'tomato creme_fraiche')</p>
			<p class="source-code">PizzaTopping = Enum('PizzaTopping', 'mozzarella \</p>
			<p class="source-code">  double_mozzarella bacon ham mushrooms red_onion oregano')</p>
			<p class="source-code">STEP_DELAY = 3 # in seconds for the sake of the example</p>
			<p>Our end <a id="_idIndexMarker1184"/>product is a pizza, which is described by the <strong class="source-inline">Pizza</strong> class. When using the builder pattern, the end product does not have many responsibilities since it is not supposed to be instantiated directly. A builder creates an instance of the end product and makes sure that it is properly prepared. That's why the <strong class="source-inline">Pizza</strong> class is so minimal. It basically initializes all data to sane default values. An exception is the <strong class="source-inline">prepare_dough()</strong> method.</p>
			<p>The <strong class="source-inline">prepare_dough()</strong> method is defined in the <strong class="source-inline">Pizza</strong> class instead of a builder for two reasons—first, to clarify the fact that the end product is typically minimal, which does not mean that you should never assign it any responsibilities; second, to promote code reuse through composition.</p>
			<p>So, we define our <strong class="source-inline">Pizza</strong> class as follows:</p>
			<p class="source-code">class Pizza:</p>
			<p class="source-code">    def __init__(self, name):</p>
			<p class="source-code">        self.name = name</p>
			<p class="source-code">        self.dough = None</p>
			<p class="source-code">        self.sauce = None</p>
			<p class="source-code">        self.topping = []</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return self.name</p>
			<p class="source-code">    def prepare_dough(self, dough):</p>
			<p class="source-code">        self.dough = dough</p>
			<p class="source-code">        print(f'preparing the {self.dough.name} dough of your \</p>
			<p class="source-code">          {self}...')</p>
			<p class="source-code">        time.sleep(STEP_DELAY)</p>
			<p class="source-code">        print(f'done with the {self.dough.name} dough')</p>
			<p>There are two builders: one for creating a margarita pizza (<strong class="source-inline">MargaritaBuilder</strong>) and another for <a id="_idIndexMarker1185"/>creating a creamy bacon pizza (<strong class="source-inline">CreamyBaconBuilder</strong>). Each builder creates a <strong class="source-inline">Pizza</strong> instance and contains methods that follow the pizza-making procedure: <strong class="source-inline">prepare_dough()</strong>, <strong class="source-inline">add_sauce()</strong>, <strong class="source-inline">add_topping()</strong>, and <strong class="source-inline">bake()</strong>. To be precise, <strong class="source-inline">prepare_dough()</strong> is just a wrapper to the <strong class="source-inline">prepare_dough()</strong> method of the <strong class="source-inline">Pizza</strong> class.</p>
			<p>Notice how each builder takes care of all the pizza-specific details. For example, the topping of the margarita pizza is double mozzarella and oregano, while the topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion, and oregano.</p>
			<p>This part of our code is laid out as follows:</p>
			<ol>
				<li value="1">We define a <strong class="source-inline">MargaritaBuilder</strong> class, as follows:<p class="source-code">class MargaritaBuilder:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        self.pizza = Pizza('margarita')</p><p class="source-code">        self.progress = PizzaProgress.queued</p><p class="source-code">        self.baking_time = 5 # in seconds for the sake of </p><p class="source-code">        the example</p><p class="source-code">    def prepare_dough(self):</p><p class="source-code">        self.progress = PizzaProgress.preparation</p><p class="source-code">        self.pizza.prepare_dough(PizzaDough.thin)</p><p class="source-code">    def add_sauce(self):</p><p class="source-code">        print('adding the tomato sauce to your \</p><p class="source-code">          margarita...')</p><p class="source-code">        self.pizza.sauce = PizzaSauce.tomato</p><p class="source-code">        time.sleep(STEP_DELAY)</p><p class="source-code">        print('done with the tomato sauce')</p><p class="source-code">    def add_topping(self):</p><p class="source-code">        topping_desc = 'double mozzarella, oregano'</p><p class="source-code">        topping_items = (PizzaTopping.double_mozzarella,</p><p class="source-code">        PizzaTopping.oregano)</p><p class="source-code">        print(f'adding the topping ({topping_desc}) to \</p><p class="source-code">          your margarita')</p><p class="source-code">        self.pizza.topping.append([t for t in \</p><p class="source-code">          topping_items])</p><p class="source-code">        time.sleep(STEP_DELAY)</p><p class="source-code">        print(f'done with the topping ({topping_desc})')</p><p class="source-code">    def bake(self):</p><p class="source-code">        self.progress = PizzaProgress.baking</p><p class="source-code">        print(f'baking your margarita for \</p><p class="source-code">          {self.baking_time} seconds')</p><p class="source-code">        time.sleep(self.baking_time)</p><p class="source-code">        self.progress = PizzaProgress.ready</p><p class="source-code">        print('your margarita is ready')</p></li>
				<li>We <a id="_idIndexMarker1186"/>define a <strong class="source-inline">CreamyBaconBuilder</strong> class, as follows:<p class="source-code">class CreamyBaconBuilder:</p><p class="source-code">    def __init__(self):</p><p class="source-code">        self.pizza = Pizza('creamy bacon')</p><p class="source-code">        self.progress = PizzaProgress.queued</p><p class="source-code">        self.baking_time = 7 # in seconds for the sake of </p><p class="source-code">        the example</p><p class="source-code">    def prepare_dough(self):</p><p class="source-code">        self.progress = PizzaProgress.preparation</p><p class="source-code">        self.pizza.prepare_dough(PizzaDough.thick)</p><p class="source-code">    def add_sauce(self):</p><p class="source-code">        print('adding the crème fraîche sauce to your \</p><p class="source-code">          creamy bacon')</p><p class="source-code">        self.pizza.sauce = PizzaSauce.creme_fraiche</p><p class="source-code">        time.sleep(STEP_DELAY)</p><p class="source-code">        print('done with the crème fraîche sauce')</p><p class="source-code">    def add_topping(self):</p><p class="source-code">        topping_desc = 'mozzarella, bacon, ham, \</p><p class="source-code">          mushrooms, red onion, oregano'</p><p class="source-code">        topping_items =  (PizzaTopping.mozzarella,</p><p class="source-code">                          PizzaTopping.bacon,</p><p class="source-code">                          PizzaTopping.ham,</p><p class="source-code">                          PizzaTopping.mushrooms,</p><p class="source-code">                          PizzaTopping.red_onion, </p><p class="source-code">                          PizzaTopping.oregano)</p><p class="source-code">        print(f'adding the topping ({topping_desc}) to \</p><p class="source-code">          your creamy bacon')</p><p class="source-code">        self.pizza.topping.append([t for t in \</p><p class="source-code">          topping_items])</p><p class="source-code">        time.sleep(STEP_DELAY)</p><p class="source-code">        print(f'done with the topping ({topping_desc})')</p><p class="source-code">    def bake(self):</p><p class="source-code">        self.progress = PizzaProgress.baking</p><p class="source-code">        print(f'baking your creamy bacon for \</p><p class="source-code">          {self.baking_time} seconds')</p><p class="source-code">        time.sleep(self.baking_time)</p><p class="source-code">        self.progress = PizzaProgress.ready</p><p class="source-code">        print('your creamy bacon is ready')</p></li>
			</ol>
			<p>The director <a id="_idIndexMarker1187"/>in this example is the waiter. The core of the <strong class="source-inline">Waiter</strong> class is the <strong class="source-inline">construct_pizza()</strong> method, which accepts a <strong class="source-inline">builder</strong> as a parameter and executes all the pizza-preparation steps in the right order. Choosing the appropriate builder, which can even be done at runtime, gives us the ability to create different pizza styles without modifying any of the code of the director (<strong class="source-inline">Waiter</strong>). The <strong class="source-inline">Waiter</strong> class also contains the <strong class="source-inline">pizza()</strong> method, which returns the end product (prepared pizza) as a variable to the caller, as follows:</p>
			<p class="source-code">class Waiter:</p>
			<p class="source-code">    def __init__(self):</p>
			<p class="source-code">        self.builder = None</p>
			<p class="source-code">    def construct_pizza(self, builder):</p>
			<p class="source-code">        self.builder = builder</p>
			<p class="source-code">        steps = (builder.prepare_dough, </p>
			<p class="source-code">                 builder.add_sauce, </p>
			<p class="source-code">                 builder.add_topping, </p>
			<p class="source-code">                 builder.bake)</p>
			<p class="source-code">        [step() for step in steps]</p>
			<p class="source-code">    @property</p>
			<p class="source-code">    def pizza(self):</p>
			<p class="source-code">        return self.builder.pizza</p>
			<p>The <strong class="source-inline">validate_style()</strong> function is similar to the <strong class="source-inline">validate_age()</strong> function, as described in <a href="B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276"><em class="italic">Chapter 16</em></a>, <em class="italic">The Factory Pattern</em>. It is used to make sure that the user gives valid input, which <a id="_idIndexMarker1188"/>in this case is a character that is mapped to a pizza builder. The <strong class="source-inline">m</strong> character uses the <strong class="source-inline">MargaritaBuilder</strong> class, and the <strong class="source-inline">c</strong> character uses the <strong class="source-inline">CreamyBaconBuilder</strong> class. These mappings are in the builder parameter. A tuple is returned, with the first element set to <strong class="source-inline">True</strong> if the input is valid or <strong class="source-inline">False</strong> if it is invalid, as follows:</p>
			<p class="source-code">def validate_style(builders):</p>
			<p class="source-code">    try:</p>
			<p class="source-code">        input_msg = 'What pizza would you like, [m]argarita or \</p>
			<p class="source-code">        [c]reamy bacon? '</p>
			<p class="source-code">        pizza_style = input(input_msg)</p>
			<p class="source-code">        builder = builders[pizza_style]()</p>
			<p class="source-code">        valid_input = True</p>
			<p class="source-code">    except KeyError:</p>
			<p class="source-code">        error_msg = 'Sorry, only margarita (key m) and creamy \</p>
			<p class="source-code">        bacon (key c) are available'</p>
			<p class="source-code">        print(error_msg)</p>
			<p class="source-code">        return (False, None)</p>
			<p class="source-code">    return (True, builder)</p>
			<p>The last part is the <strong class="source-inline">main()</strong> function. The <strong class="source-inline">main()</strong> function contains code for instantiating a pizza builder. The pizza builder is then used by the <strong class="source-inline">Waiter</strong> director for preparing the pizza. The <a id="_idIndexMarker1189"/>created pizza can be delivered to the client at any later point. The code is illustrated in the following snippet:</p>
			<p class="source-code">def main():</p>
			<p class="source-code">    builders = dict(m=MargaritaBuilder, c=CreamyBaconBuilder)</p>
			<p class="source-code">    valid_input = False</p>
			<p class="source-code">    while not valid_input:</p>
			<p class="source-code">        valid_input, builder = validate_style(builders)</p>
			<p class="source-code">    print()</p>
			<p class="source-code">    waiter = Waiter()</p>
			<p class="source-code">    waiter.construct_pizza(builder)</p>
			<p class="source-code">    pizza = waiter.pizza</p>
			<p class="source-code">    print()</p>
			<p class="source-code">    print(f'Enjoy your {pizza}!')</p>
			<p>Here is a summary of the implementation (see the complete code in the <strong class="source-inline">builder.py</strong> file):</p>
			<ol>
				<li value="1">We start with a couple of imports we need, for the standard <strong class="source-inline">Enum</strong> class and the <strong class="source-inline">time</strong> module.</li>
				<li>We declare variables for a few constants: <strong class="source-inline">PizzaProgress</strong>, <strong class="source-inline">PizzaDough</strong>, <strong class="source-inline">PizzaSauce</strong>, <strong class="source-inline">PizzaTopping</strong>, and <strong class="source-inline">STEP_DELAY</strong>.</li>
				<li>We define our <strong class="source-inline">Pizza</strong> class.</li>
				<li>We define classes for two builders, <strong class="source-inline">MargaritaBuilder</strong> and <strong class="source-inline">CreamyBaconBuilder</strong>.</li>
				<li>We define our <strong class="source-inline">Waiter</strong> class.</li>
				<li>We add the <strong class="source-inline">validate_style()</strong> function to improve things regarding exception handling.</li>
				<li>Finally, we <a id="_idIndexMarker1190"/>have the <strong class="source-inline">main()</strong> function, followed by the snippet for calling it when the program is run. In the <strong class="source-inline">main</strong> function, the following happens:<ul><li>We make it possible to choose the pizza builder based on the user's input, after validation via the <strong class="source-inline">validate_style()</strong> function.</li><li>The pizza builder is used by the waiter for preparing the pizza.</li><li>The created pizza is then delivered.</li></ul></li>
			</ol>
			<p>Here is the output produced by calling the <strong class="source-inline">python builder.py</strong> command to execute this example program:</p>
			<p class="source-code">What pizza would you like, [m]argarita or [c]reamy bacon? r</p>
			<p class="source-code">Sorry, only margarita (key m) and creamy bacon (key c) are </p>
			<p class="source-code">available</p>
			<p class="source-code">What pizza would you like, [m]argarita or [c]reamy bacon? m</p>
			<p class="source-code">preparing the thin dough of your margarita...</p>
			<p class="source-code">done with the thin dough</p>
			<p class="source-code">adding the tomato sauce to your margarita...</p>
			<p class="source-code">done with the tomato sauce</p>
			<p class="source-code">adding the topping (double mozzarella, oregano) to your </p>
			<p class="source-code">margarita</p>
			<p class="source-code">done with the topping (double mozzarella, oregano)</p>
			<p class="source-code">baking your margarita for 5 seconds</p>
			<p class="source-code">your margarita is ready</p>
			<p class="source-code">Enjoy your margarita!</p>
			<p>But…supporting only two pizza types is a shame. Feel like getting a Hawaiian pizza builder? Consider using inheritance after thinking about the advantages and disadvantages. Check the ingredients of a typical Hawaiian pizza and decide which class you need to extend: <strong class="source-inline">MargaritaBuilder</strong> or <strong class="source-inline">CreamyBaconBuilder</strong>? Perhaps both (<a href="http://j.mp/pymulti">j.mp/pymulti</a>)?</p>
			<p>In his book, <em class="italic">Effective Java (Second Edition)</em>, Joshua Bloch describes an interesting variation <a id="_idIndexMarker1191"/>of the builder pattern where calls to builder methods are chained. This is accomplished by defining the <a id="_idIndexMarker1192"/>builder itself as an inner class and returning itself from each of the setter-like methods on it. The <strong class="source-inline">build()</strong> method returns the final object. This pattern is called the <strong class="bold">fluent builder</strong>. Here's a Python implementation, which was kindly provided by a reviewer of the book:</p>
			<p class="source-code">class Pizza: </p>
			<p class="source-code">    def __init__(self, builder): </p>
			<p class="source-code">        self.garlic = builder.garlic </p>
			<p class="source-code">        self.extra_cheese  = builder.extra_cheese </p>
			<p class="source-code"> </p>
			<p class="source-code">    def __str__(self): </p>
			<p class="source-code">        garlic = 'yes' if self.garlic else 'no' </p>
			<p class="source-code">        cheese = 'yes' if self.extra_cheese else 'no' </p>
			<p class="source-code">        info = (f'Garlic: {garlic}', f'Extra cheese: {cheese}') </p>
			<p class="source-code">        return '\n'.join(info) </p>
			<p class="source-code"> </p>
			<p class="source-code">    class PizzaBuilder: </p>
			<p class="source-code">        def __init__(self): </p>
			<p class="source-code">            self.extra_cheese = False </p>
			<p class="source-code">            self.garlic = False </p>
			<p class="source-code"> </p>
			<p class="source-code">        def add_garlic(self): </p>
			<p class="source-code">            self.garlic = True </p>
			<p class="source-code">            return self </p>
			<p class="source-code"> </p>
			<p class="source-code">        def add_extra_cheese(self): </p>
			<p class="source-code">            self.extra_cheese = True </p>
			<p class="source-code">            return self </p>
			<p class="source-code"> </p>
			<p class="source-code">        def build(self): </p>
			<p class="source-code">            return Pizza(self) </p>
			<p class="source-code"> </p>
			<p class="source-code">if __name__ == '__main__': </p>
			<p class="source-code">    pizza = Pizza.PizzaBuilder().add_garlic().add_extra_ \</p>
			<p class="source-code">      cheese().build() </p>
			<p class="source-code">    print(pizza)</p>
			<p>With this <a id="_idIndexMarker1193"/>fluent builder pattern, we see that we could quickly build the final <strong class="source-inline">Pizza</strong> object by chaining the <strong class="source-inline">add_garlic()</strong>, <strong class="source-inline">add_extra_cheese()</strong>, and <strong class="source-inline">build()</strong> methods on one line of code, which could come in handy in many situations.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor295"/>Summary</h1>
			<p>In this chapter, we have seen how to use the builder design pattern. We use the builder pattern for creating an object in situations where using the factory pattern (either a factory method or an abstract factory) is not a good option. The builder pattern is usually a better candidate than the factory pattern when we want to create a complex object, when different representations of an object are required, or when we want to create an object at one point in time but access it at a later point. </p>
			<p>We saw how the builder pattern is used in fast-food restaurants for preparing meals, and how two third-party Django packages, <strong class="source-inline">django-widgy</strong> and <strong class="source-inline">django-query-builder</strong>, use it for generating HTML pages and dynamic SQL queries, respectively. We focused on the differences between the builder pattern and the factory pattern and provided a preconfigured (factory) and customer (builder) computer order analogy to clarify them. We also looked at how to create a pizza-ordering application with preparation dependencies. Throughout these examples, we have clearly seen the benefits and flexibility of the builder pattern, which will help you better approach future applications that require the design pattern.</p>
			<p>In the next chapter, you will learn about other useful creational patterns.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor296"/>Questions</h1>
			<ol>
				<li value="1">What are the high-level applications of the builder pattern?</li>
				<li>What are some common computer applications that require or benefit from the builder pattern?</li>
				<li>How does the builder pattern create an object and how is that process different from what the factory pattern does?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>