<html><head></head><body>
<div><div><div><h1 id="_idParaDest-308"><em class="italic"><a id="_idTextAnchor289"/>Chapter 17</em>: The Builder Pattern</h1>
			<p>In the previous chapter, we covered the first two creational patterns—the factory method and abstract factory, both of which offer approaches to improve the way we create objects in nontrivial cases. The builder design pattern, on the other hand, as we'll discuss in this chapter, is useful for managing objects that consist of multiple parts that need to be implemented sequentially. By decoupling the construction of an object and its representation, the builder pattern allows us to reuse a construction multiple times.</p>
			<p>Just as with the previous chapter, we will discuss real-life applications that use this design pattern as well as implementing a hands-on example ourselves.</p>
			<p>In this chapter, we will discuss the following topics:</p>
			<ul>
				<li>Understanding the builder pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementing an ordering application</li>
			</ul>
			<p>By the end of the chapter, we will understand how to use the builder pattern and its practical benefits.</p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor290"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: </p>
			<p><a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter17</a></p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor291"/>Understanding the builder pattern</h1>
			<p>Imagine that we want to create an object that is composed of multiple parts and the composition <a id="_idIndexMarker1169"/>needs to be done step by step. The object is not complete unless all its parts are fully created. That's where the <strong class="bold">builder-design pattern</strong> can help us. The builder pattern separates the construction of a complex object from its representation. By keeping the construction separate from the representation, the same construction can be used to create several different representations (<a href="http://j.mp/builderpat">j.mp/builderpat</a>).</p>
			<p>A practical example can help us understand what the purpose of the builder pattern is. Suppose that <a id="_idIndexMarker1170"/>we want to create a <code>&lt;html&gt;</code> and finishes with <code>&lt;/html&gt;</code>; inside the HTML section are the <code>&lt;head&gt;</code> and <code>&lt;/head&gt;</code> elements; inside the head section are the <code>&lt;title&gt;</code> and <code>&lt;/title&gt;</code> elements; and so forth. But the representation of the page can differ. Each page has its own title, its own headings, and different <code>&lt;body&gt;</code> contents. Moreover, the page is usually built in steps: one function adds the title, another adds the main heading, another the footer, and so on. Only after the whole structure <a id="_idIndexMarker1171"/>of a page is complete can it be shown to the client using a final render function. We can take it even further and extend the HTML generator so that it can generate totally different HTML pages. One page might contain tables, another page might contain image galleries, yet another page contains the contact form, and so on.</p>
			<p>The HTML page-generation problem can be solved using the builder pattern. In this pattern, there are two main participants, outlined as follows:</p>
			<ul>
				<li><strong class="bold">The builder</strong>: The component responsible for creating the various parts of a complex <a id="_idIndexMarker1172"/>object. In this example, these parts are the title, heading, body, and the footer of the page.</li>
				<li><code>builder</code> instance. It <a id="_idIndexMarker1173"/>calls the builder's functions for setting the title, the heading, and so on, and using a different <code>builder</code> instance allows us to create a different HTML page without touching any of the code of the director.</li>
			</ul>
			<p>First, let's discuss in the next section some real-life examples where this pattern applies.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor292"/>Real-world examples</h1>
			<p>In our everyday life, the <em class="italic">builder design pattern</em> is used in fast-food restaurants. The same procedure is always used to prepare a burger and the packaging (box and paper bag), even if <a id="_idIndexMarker1174"/>there are many different kinds of burgers (classic, cheeseburger, and more) and different packages (small-sized box, medium-sized box, and so forth). The difference between a classic burger and a cheeseburger is in the representation, and not in the construction procedure. In this case, the <strong class="bold">director</strong> is the cashier who gives the crew instructions about what needs to be prepared, and the <strong class="bold">builder</strong> is the person from the crew that takes care of a specific order.</p>
			<p>We can also find software examples, as follows:</p>
			<ul>
				<li>The HTML example that was mentioned at the beginning of the chapter is actually used by <code>django-widgy</code> (<a href="https://wid.gy/">https://wid.gy/</a>), a third-party tree editor for Django <a id="_idIndexMarker1175"/>that can be used as a <code>django-widgy</code> editor contains a page builder that can be used for creating HTML pages with different layouts.</li>
				<li>The <code>django-query-builder</code> library (<a href="https://github.com/ambitioninc/django-query-builder">https://github.com/ambitioninc/django-query-builder</a>) is another third-party Django library that relies on the builder pattern. This <a id="_idIndexMarker1176"/>library can be used for building <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) queries dynamically, allowing you to control all aspects of a query and create a different range of queries, from simple to very complex ones.</li>
			</ul>
			<p>In the next section, we will see how this design pattern actually works.</p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor293"/>Use cases</h1>
			<p>We use the <a id="_idIndexMarker1177"/>builder pattern when we know that an object must be created in multiple steps, and different representations of the same construction are required. These requirements exist in many applications, such as page generators (for example, the HTML page generator mentioned in this chapter), document converters, and <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) form creators (<a href="http://j.mp/pipbuild">j.mp/pipbuild</a>).</p>
			<p>Some online resources mention that the builder pattern can also be used as a solution to the telescopic constructor problem. The telescopic constructor problem occurs when we are forced to create a new constructor for supporting different ways of creating an object. The problem is that we end up with many constructors and long parameter lists that are hard to manage. An example of the telescopic constructor is listed on the Stack Overflow website (<a href="http://j.mp/sobuilder">j.mp/sobuilder</a>). Fortunately, this problem does not exist in Python, because it can be solved in at least two ways, as outlined here:</p>
			<ul>
				<li>With named parameters that define different behaviors in the constructor of the class (<a href="http://j.mp/sobuipython">j.mp/sobuipython</a>)</li>
				<li>With argument list unpacking, which is similar in spirit to named parameters (<a href="http://j.mp/arglistpy">j.mp/arglistpy</a>)</li>
			</ul>
			<p>These features <a id="_idIndexMarker1178"/>that are specific to Python help us control the behavior of its code easily, thus avoiding the problem we described previously.</p>
			<p>At this point, the distinction between the builder pattern and the factory pattern might not be very clear. The main difference is that the factory pattern creates an object in a single step, whereas the builder pattern creates an object in multiple steps, and almost always through the use of a director. Some targeted implementations of the builder pattern, such as Java's <code>StringBuilder</code>, bypass the use of a director, but that's the exception to the rule.</p>
			<p>Another difference is that while the factory pattern returns a created object immediately, in the builder pattern the client code explicitly asks the director to return the final object when it needs it (<a href="http://j.mp/builderpat">j.mp/builderpat</a>).</p>
			<p>The new computer analogy might help you to distinguish between the builder pattern and the factory pattern. Assume that you want to buy a new computer. If you decide to buy a specific, preconfigured computer model—for example, the latest Apple 1.4 <code>apple_factory.py</code>):</p>
			<pre>MINI14 = '1.4GHz Mac mini'
class AppleFactory:
    class MacMini14:
        def __init__(self):
            self.memory = 4 # in gigabytes
            self.hdd = 500 # in gigabytes
            self.gpu = 'Intel HD Graphics 5000'
        def __str__(self):
            info = (f'Model: {MINI14}',
                    f'Memory: {self.memory}GB',
                    f'Hard Disk: {self.hdd}GB',
                    f'Graphics Card: {self.gpu}')
            return '\n'.join(info)
    def build_computer(self, model):
        if model == MINI14:
            return self.MacMini14()
        else:
            msg = f"I don't know how to build {model}"
            print(msg)</pre>
			<p>Now, we add <a id="_idIndexMarker1179"/>the main part of the program—the snippet that uses the <code>AppleFactory</code> class. The code is illustrated here:</p>
			<pre>if __name__ == '__main__':
    afac = AppleFactory()
    mac_mini = afac.build_computer(MINI14)
    print(mac_mini)</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice the nested <code>MacMini14</code> class. This is a neat way of forbidding the direct instantiation of a class.</p>
			<p>Another option would be to buy a custom PC. In this case, you use the builder pattern. You are the <a id="_idIndexMarker1180"/>director who gives orders to the manufacturer (<code>builder</code>) about your ideal computer specifications. Code-wise, this is how it looks (<code>computer_builder.py</code>):</p>
			<ol>
				<li>We define a <code>Computer</code> class, as follows:<pre>class Computer:
    def __init__(self, serial_number):
        self.serial = serial_number
        self.memory = None # in gigabytes
        self.hdd = None # in gigabytes
        self.gpu = None
    def __str__(self):
        info = (f'Memory: {self.memory}GB',
                f'Hard Disk: {self.hdd}GB',
                f'Graphics Card: {self.gpu}')
        return '\n'.join(info)</pre></li>
				<li>We define a <code>ComputerBuilder</code> class, as follows:<pre>class ComputerBuilder:
    def __init__(self):
        self.computer = Computer('AG23385193')
    def configure_memory(self, amount):
        self.computer.memory = amount
    def configure_hdd(self, amount):
        self.computer.hdd = amount
    def configure_gpu(self, gpu_model):
        self.computer.gpu = gpu_model</pre></li>
				<li>We <a id="_idIndexMarker1181"/>define a <code>HardwareEngineer</code> class, as follows:<pre>class HardwareEngineer:
    def __init__(self):
        self.builder = None
    def construct_computer(self, memory, hdd, gpu):
        self.builder = ComputerBuilder()
        steps = (self.builder.configure_memory(memory),
                 self.builder.configure_hdd(hdd),
                 self.builder.configure_gpu(gpu))
        [step for step in steps]
    @property
    def computer(self):
        return self.builder.computer</pre></li>
				<li>We end our code with the <code>main()</code> function, followed by a trick to call it when the file is called from the command line, as illustrated in the following code snippet:<pre>def main():
    engineer = HardwareEngineer()
    engineer.construct_computer(hdd=500, 
                                memory=8, 
                                gpu='GeForce GTX 650 Ti')
    computer = engineer.computer
    print(computer)
if __name__ == '__main__':
    main()</pre></li>
			</ol>
			<p>The basic <a id="_idIndexMarker1182"/>changes are the introduction of a builder (<code>ComputerBuilder</code>), a director    (<code>HardwareEngineer</code>), and the step-by-step construction of a computer, which now supports different configurations (notice that <code>memory</code>, <code>hdd</code>, and <code>gpu</code> are parameters and are not preconfigured). What do we need to do if we want to support the construction of tablets? Implement this as an exercise.</p>
			<p>You might also want to change the computer's <code>serial_number</code> value into something different for each computer because as it is now, this means that all computers will have the same serial number (which is impractical).</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor294"/>Implementing an ordering application</h1>
			<p>Let's see <a id="_idIndexMarker1183"/>how we can use the builder design pattern to make a pizza-ordering application. The pizza example is particularly interesting because a pizza is prepared in steps that should follow a specific order. To add the sauce, you first need to prepare the dough. To add the topping, you first need to add the sauce. And you can't start baking the pizza unless both the sauce and the topping are placed on the dough. Moreover, each pizza usually requires a different baking time, depending on the thickness of its dough and the topping used.</p>
			<p>We start by importing the required modules and declaring a few <code>Enum</code> parameters (<a href="http://j.mp/pytenum">j.mp/pytenum</a>) plus a constant that is used many times in the application. The <code>STEP_DELAY</code> constant is used to add a time delay between the different steps of preparing a pizza (prepare the dough, add the sauce, and so on), as follows:</p>
			<pre>from enum import Enum
import time
PizzaProgress = Enum('PizzaProgress', 'queued preparation \
  baking ready')
PizzaDough = Enum('PizzaDough', 'thin thick')
PizzaSauce = Enum('PizzaSauce', 'tomato creme_fraiche')
PizzaTopping = Enum('PizzaTopping', 'mozzarella \
  double_mozzarella bacon ham mushrooms red_onion oregano')
STEP_DELAY = 3 # in seconds for the sake of the example</pre>
			<p>Our end <a id="_idIndexMarker1184"/>product is a pizza, which is described by the <code>Pizza</code> class. When using the builder pattern, the end product does not have many responsibilities since it is not supposed to be instantiated directly. A builder creates an instance of the end product and makes sure that it is properly prepared. That's why the <code>Pizza</code> class is so minimal. It basically initializes all data to sane default values. An exception is the <code>prepare_dough()</code> method.</p>
			<p>The <code>prepare_dough()</code> method is defined in the <code>Pizza</code> class instead of a builder for two reasons—first, to clarify the fact that the end product is typically minimal, which does not mean that you should never assign it any responsibilities; second, to promote code reuse through composition.</p>
			<p>So, we define our <code>Pizza</code> class as follows:</p>
			<pre>class Pizza:
    def __init__(self, name):
        self.name = name
        self.dough = None
        self.sauce = None
        self.topping = []
    def __str__(self):
        return self.name
    def prepare_dough(self, dough):
        self.dough = dough
        print(f'preparing the {self.dough.name} dough of your \
          {self}...')
        time.sleep(STEP_DELAY)
        print(f'done with the {self.dough.name} dough')</pre>
			<p>There are two builders: one for creating a margarita pizza (<code>MargaritaBuilder</code>) and another for <a id="_idIndexMarker1185"/>creating a creamy bacon pizza (<code>CreamyBaconBuilder</code>). Each builder creates a <code>Pizza</code> instance and contains methods that follow the pizza-making procedure: <code>prepare_dough()</code>, <code>add_sauce()</code>, <code>add_topping()</code>, and <code>bake()</code>. To be precise, <code>prepare_dough()</code> is just a wrapper to the <code>prepare_dough()</code> method of the <code>Pizza</code> class.</p>
			<p>Notice how each builder takes care of all the pizza-specific details. For example, the topping of the margarita pizza is double mozzarella and oregano, while the topping of the creamy bacon pizza is mozzarella, bacon, ham, mushrooms, red onion, and oregano.</p>
			<p>This part of our code is laid out as follows:</p>
			<ol>
				<li value="1">We define a <code>MargaritaBuilder</code> class, as follows:<pre>class MargaritaBuilder:
    def __init__(self):
        self.pizza = Pizza('margarita')
        self.progress = PizzaProgress.queued
        self.baking_time = 5 # in seconds for the sake of 
        the example
    def prepare_dough(self):
        self.progress = PizzaProgress.preparation
        self.pizza.prepare_dough(PizzaDough.thin)
    def add_sauce(self):
        print('adding the tomato sauce to your \
          margarita...')
        self.pizza.sauce = PizzaSauce.tomato
        time.sleep(STEP_DELAY)
        print('done with the tomato sauce')
    def add_topping(self):
        topping_desc = 'double mozzarella, oregano'
        topping_items = (PizzaTopping.double_mozzarella,
        PizzaTopping.oregano)
        print(f'adding the topping ({topping_desc}) to \
          your margarita')
        self.pizza.topping.append([t for t in \
          topping_items])
        time.sleep(STEP_DELAY)
        print(f'done with the topping ({topping_desc})')
    def bake(self):
        self.progress = PizzaProgress.baking
        print(f'baking your margarita for \
          {self.baking_time} seconds')
        time.sleep(self.baking_time)
        self.progress = PizzaProgress.ready
        print('your margarita is ready')</pre></li>
				<li>We <a id="_idIndexMarker1186"/>define a <code>CreamyBaconBuilder</code> class, as follows:<pre>class CreamyBaconBuilder:
    def __init__(self):
        self.pizza = Pizza('creamy bacon')
        self.progress = PizzaProgress.queued
        self.baking_time = 7 # in seconds for the sake of 
        the example
    def prepare_dough(self):
        self.progress = PizzaProgress.preparation
        self.pizza.prepare_dough(PizzaDough.thick)
    def add_sauce(self):
        print('adding the crème fraîche sauce to your \
          creamy bacon')
        self.pizza.sauce = PizzaSauce.creme_fraiche
        time.sleep(STEP_DELAY)
        print('done with the crème fraîche sauce')
    def add_topping(self):
        topping_desc = 'mozzarella, bacon, ham, \
          mushrooms, red onion, oregano'
        topping_items =  (PizzaTopping.mozzarella,
                          PizzaTopping.bacon,
                          PizzaTopping.ham,
                          PizzaTopping.mushrooms,
                          PizzaTopping.red_onion, 
                          PizzaTopping.oregano)
        print(f'adding the topping ({topping_desc}) to \
          your creamy bacon')
        self.pizza.topping.append([t for t in \
          topping_items])
        time.sleep(STEP_DELAY)
        print(f'done with the topping ({topping_desc})')
    def bake(self):
        self.progress = PizzaProgress.baking
        print(f'baking your creamy bacon for \
          {self.baking_time} seconds')
        time.sleep(self.baking_time)
        self.progress = PizzaProgress.ready
        print('your creamy bacon is ready')</pre></li>
			</ol>
			<p>The director <a id="_idIndexMarker1187"/>in this example is the waiter. The core of the <code>Waiter</code> class is the <code>construct_pizza()</code> method, which accepts a <code>builder</code> as a parameter and executes all the pizza-preparation steps in the right order. Choosing the appropriate builder, which can even be done at runtime, gives us the ability to create different pizza styles without modifying any of the code of the director (<code>Waiter</code>). The <code>Waiter</code> class also contains the <code>pizza()</code> method, which returns the end product (prepared pizza) as a variable to the caller, as follows:</p>
			<pre>class Waiter:
    def __init__(self):
        self.builder = None
    def construct_pizza(self, builder):
        self.builder = builder
        steps = (builder.prepare_dough, 
                 builder.add_sauce, 
                 builder.add_topping, 
                 builder.bake)
        [step() for step in steps]
    @property
    def pizza(self):
        return self.builder.pizza</pre>
			<p>The <code>validate_style()</code> function is similar to the <code>validate_age()</code> function, as described in <a href="B17499_16_Final_SS_ePub.xhtml#_idTextAnchor276"><em class="italic">Chapter 16</em></a>, <em class="italic">The Factory Pattern</em>. It is used to make sure that the user gives valid input, which <a id="_idIndexMarker1188"/>in this case is a character that is mapped to a pizza builder. The <code>m</code> character uses the <code>MargaritaBuilder</code> class, and the <code>c</code> character uses the <code>CreamyBaconBuilder</code> class. These mappings are in the builder parameter. A tuple is returned, with the first element set to <code>True</code> if the input is valid or <code>False</code> if it is invalid, as follows:</p>
			<pre>def validate_style(builders):
    try:
        input_msg = 'What pizza would you like, [m]argarita or \
        [c]reamy bacon? '
        pizza_style = input(input_msg)
        builder = builders[pizza_style]()
        valid_input = True
    except KeyError:
        error_msg = 'Sorry, only margarita (key m) and creamy \
        bacon (key c) are available'
        print(error_msg)
        return (False, None)
    return (True, builder)</pre>
			<p>The last part is the <code>main()</code> function. The <code>main()</code> function contains code for instantiating a pizza builder. The pizza builder is then used by the <code>Waiter</code> director for preparing the pizza. The <a id="_idIndexMarker1189"/>created pizza can be delivered to the client at any later point. The code is illustrated in the following snippet:</p>
			<pre>def main():
    builders = dict(m=MargaritaBuilder, c=CreamyBaconBuilder)
    valid_input = False
    while not valid_input:
        valid_input, builder = validate_style(builders)
    print()
    waiter = Waiter()
    waiter.construct_pizza(builder)
    pizza = waiter.pizza
    print()
    print(f'Enjoy your {pizza}!')</pre>
			<p>Here is a summary of the implementation (see the complete code in the <code>builder.py</code> file):</p>
			<ol>
				<li value="1">We start with a couple of imports we need, for the standard <code>Enum</code> class and the <code>time</code> module.</li>
				<li>We declare variables for a few constants: <code>PizzaProgress</code>, <code>PizzaDough</code>, <code>PizzaSauce</code>, <code>PizzaTopping</code>, and <code>STEP_DELAY</code>.</li>
				<li>We define our <code>Pizza</code> class.</li>
				<li>We define classes for two builders, <code>MargaritaBuilder</code> and <code>CreamyBaconBuilder</code>.</li>
				<li>We define our <code>Waiter</code> class.</li>
				<li>We add the <code>validate_style()</code> function to improve things regarding exception handling.</li>
				<li>Finally, we <a id="_idIndexMarker1190"/>have the <code>main()</code> function, followed by the snippet for calling it when the program is run. In the <code>main</code> function, the following happens:<ul><li>We make it possible to choose the pizza builder based on the user's input, after validation via the <code>validate_style()</code> function.</li><li>The pizza builder is used by the waiter for preparing the pizza.</li><li>The created pizza is then delivered.</li></ul></li>
			</ol>
			<p>Here is the output produced by calling the <code>python builder.py</code> command to execute this example program:</p>
			<pre>What pizza would you like, [m]argarita or [c]reamy bacon? r
Sorry, only margarita (key m) and creamy bacon (key c) are 
available
What pizza would you like, [m]argarita or [c]reamy bacon? m
preparing the thin dough of your margarita...
done with the thin dough
adding the tomato sauce to your margarita...
done with the tomato sauce
adding the topping (double mozzarella, oregano) to your 
margarita
done with the topping (double mozzarella, oregano)
baking your margarita for 5 seconds
your margarita is ready
Enjoy your margarita!</pre>
			<p>But…supporting only two pizza types is a shame. Feel like getting a Hawaiian pizza builder? Consider using inheritance after thinking about the advantages and disadvantages. Check the ingredients of a typical Hawaiian pizza and decide which class you need to extend: <code>MargaritaBuilder</code> or <code>CreamyBaconBuilder</code>? Perhaps both (<a href="http://j.mp/pymulti">j.mp/pymulti</a>)?</p>
			<p>In his book, <em class="italic">Effective Java (Second Edition)</em>, Joshua Bloch describes an interesting variation <a id="_idIndexMarker1191"/>of the builder pattern where calls to builder methods are chained. This is accomplished by defining the <a id="_idIndexMarker1192"/>builder itself as an inner class and returning itself from each of the setter-like methods on it. The <code>build()</code> method returns the final object. This pattern is called the <strong class="bold">fluent builder</strong>. Here's a Python implementation, which was kindly provided by a reviewer of the book:</p>
			<pre>class Pizza: 
    def __init__(self, builder): 
        self.garlic = builder.garlic 
        self.extra_cheese  = builder.extra_cheese 
 
    def __str__(self): 
        garlic = 'yes' if self.garlic else 'no' 
        cheese = 'yes' if self.extra_cheese else 'no' 
        info = (f'Garlic: {garlic}', f'Extra cheese: {cheese}') 
        return '\n'.join(info) 
 
    class PizzaBuilder: 
        def __init__(self): 
            self.extra_cheese = False 
            self.garlic = False 
 
        def add_garlic(self): 
            self.garlic = True 
            return self 
 
        def add_extra_cheese(self): 
            self.extra_cheese = True 
            return self 
 
        def build(self): 
            return Pizza(self) 
 
if __name__ == '__main__': 
    pizza = Pizza.PizzaBuilder().add_garlic().add_extra_ \
      cheese().build() 
    print(pizza)</pre>
			<p>With this <a id="_idIndexMarker1193"/>fluent builder pattern, we see that we could quickly build the final <code>Pizza</code> object by chaining the <code>add_garlic()</code>, <code>add_extra_cheese()</code>, and <code>build()</code> methods on one line of code, which could come in handy in many situations.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor295"/>Summary</h1>
			<p>In this chapter, we have seen how to use the builder design pattern. We use the builder pattern for creating an object in situations where using the factory pattern (either a factory method or an abstract factory) is not a good option. The builder pattern is usually a better candidate than the factory pattern when we want to create a complex object, when different representations of an object are required, or when we want to create an object at one point in time but access it at a later point. </p>
			<p>We saw how the builder pattern is used in fast-food restaurants for preparing meals, and how two third-party Django packages, <code>django-widgy</code> and <code>django-query-builder</code>, use it for generating HTML pages and dynamic SQL queries, respectively. We focused on the differences between the builder pattern and the factory pattern and provided a preconfigured (factory) and customer (builder) computer order analogy to clarify them. We also looked at how to create a pizza-ordering application with preparation dependencies. Throughout these examples, we have clearly seen the benefits and flexibility of the builder pattern, which will help you better approach future applications that require the design pattern.</p>
			<p>In the next chapter, you will learn about other useful creational patterns.</p>
			<h1 id="_idParaDest-315"><a id="_idTextAnchor296"/>Questions</h1>
			<ol>
				<li value="1">What are the high-level applications of the builder pattern?</li>
				<li>What are some common computer applications that require or benefit from the builder pattern?</li>
				<li>How does the builder pattern create an object and how is that process different from what the factory pattern does?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>