<html><head></head><body>
  <div><h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-132" class="chapterTitle">Planning for the Expansion of Our Application</h1>
    <p class="normal">The application is a real hit! After some initial testing and orientation, the data entry staff have been utilizing your new form for a few weeks now. The reduction in errors and data entry time is dramatic, and there's a lot of excited talk about what other problems this program might solve. With even the director joining in on the brainstorming, you have a strong suspicion that you'll be asked to add some new features soon.</p>
    <p class="normal">There's a problem, though: the application is already a script of several hundred lines, and you're worried about its manageability as it grows. You need to take some time to organize your code base in preparation for future expansion.</p>
    <p class="normal">In this chapter, we'll learn about the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">Separating concerns</em>, you'll learn about using the <strong class="keyword">model-view-controller </strong>(<strong class="keyword">MVC</strong>) pattern.</li>
      <li class="bullet">In <em class="italic">Structuring our application directory</em>, you'll learn how to organize your code into a Python package.</li>
      <li class="bullet">In <em class="italic">Splitting our application into multiple files</em>, you'll reorganize the data entry application into an MVC Python package.</li>
      <li class="bullet">In <em class="italic">Using version control software</em>, you'll discover how to use the Git version control system to track your changes.</li>
    </ul>
    <h1 id="_idParaDest-133" class="title">Separating concerns</h1>
    <p class="normal">Proper architectural design is essential for any project that needs to scale. Anyone can prop up some studs and build a garden shed, but a house or skyscraper takes careful planning and engineering. Software is no different; simple scripts can get away with shortcuts such as global variables or manipulating class properties directly, but as the program grows, our code needs to isolate and encapsulate different functionalities in a way that limits the amount of complexity we need to understand at any given moment.</p>
    <p class="normal">We call this<a id="_idIndexMarker442"/> concept <strong class="keyword">separation of concerns</strong>, and it's accomplished through the use of architectural patterns that describe different application components and how they interact.</p>
    <h2 id="_idParaDest-134" class="title">The MVC pattern</h2>
    <p class="normal">Probably the most enduring of <a id="_idIndexMarker443"/>these architectural patterns is the <strong class="keyword">model-view-controller</strong> (<strong class="keyword">MVC</strong>) pattern, which was introduced in the 1970s. While this pattern has evolved and spun off variations over the years, the basic gist remains: keep the data, the presentation of the data, and the application logic in separate, independent components.</p>
    <p class="normal">The roles and relationships of the MVC components are shown in this diagram:</p>
    <figure class="mediaobject"><img src="img/B17578_06_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.1: The roles and relationships of Model, View, and Controller</p>
    <p class="normal">Let's take a deeper look at each of these components and understand them in the context of our current application.</p>
    <h3 id="_idParaDest-135" class="title">What is a model?</h3>
    <p class="normal">The <strong class="keyword">model</strong> in MVC <a id="_idIndexMarker444"/>represents the data. This includes the storage of the data, but also the various ways data can be queried or manipulated. Ideally, the model is not concerned with or affected by how the data will be presented (that is, what GUI widgets will be used, how the<a id="_idIndexMarker445"/> fields will be ordered, and so on), but rather presents a high-level interface that only minimally concerns other components with its inner workings. In theory, if you decided to completely change the user interface of the program (say, from a Tkinter application to a web application), the model should be totally unaffected.</p>
    <p class="normal">Some examples of functionality or information you find in the model include:</p>
    <ul>
      <li class="bullet">Preparation and saving of program data to a persistent medium (data file, database, and so on)</li>
      <li class="bullet">Retrieval of data from a file or database into a format useful to the program</li>
      <li class="bullet">An authoritative list of the fields in a set of data, along with their data types and limits</li>
      <li class="bullet">Validation of data against the data types and limits defined</li>
      <li class="bullet">Calculations on stored data</li>
    </ul>
    <p class="normal">We don't have a model class in our application currently; the data layout is defined in the form class, and the <code class="Code-In-Text--PACKT-">Application.onsave()</code> method is the only code concerned with data persistence so far. To implement MVC in our application, we're going to need to split this logic off into a separate object that will define the data layout and handle all the CSV operations.</p>
    <h3 id="_idParaDest-136" class="title">What is a view?</h3>
    <p class="normal">A <strong class="keyword">view</strong> is an <a id="_idIndexMarker446"/>interface for presenting data and controls to the user. Applications may have many views, often on the same data. Views may or may not have direct access to the <a id="_idIndexMarker447"/>model; if they do, they generally have read-only access, sending write requests through the controller.</p>
    <p class="normal">Some examples of code you find in a view include:</p>
    <ul>
      <li class="bullet">GUI layout and widget definitions</li>
      <li class="bullet">Form automations, such as auto-completion of fields, dynamic toggling of widgets, or display of error dialogs</li>
      <li class="bullet">Formatting of raw data for presentation</li>
    </ul>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">DataRecordForm</code> class is an example of a view: it contains most of the code for our application's user interface. It also contains the <code class="Code-In-Text--PACKT-">_vars</code> dictionary, which currently defines the structure of our data records. This dictionary can stay in the view, because the view does need a way to store the data temporarily before handing it off to the model, but <code class="Code-In-Text--PACKT-">_vars</code> shouldn't be defining our data record from here on out â€” that's the model's job. To implement MVC, we'll need to make the view's concept of the data dependent on the model, not on its own definitions.</p>
    <h3 id="_idParaDest-137" class="title">What is a controller?</h3>
    <p class="normal">The <strong class="keyword">controller</strong> is the "Grand Central Station" for the application. It handles requests from the user and takes <a id="_idIndexMarker448"/>care of routing data between the views and the model. Most variations of MVC change the role (and sometimes the name) of the controller, but the<a id="_idIndexMarker449"/> important thing is that it acts as the intermediary between the view and the model. Our controller object will need to hold references to the views and models used by our application and be responsible for managing interactions between them.</p>
    <p class="normal">Examples of code you find in the controller include:</p>
    <ul>
      <li class="bullet">Startup and shutdown logic for the application</li>
      <li class="bullet">Callbacks for user interface events</li>
      <li class="bullet">Creation of model and view instances</li>
    </ul>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">Application</code> object is currently acting as the controller for our application, though it has some view and model logic in it as well. Unfortunately, the <code class="Code-In-Text--PACKT-">Tk</code> object in Tkinter combines both the central point of control and the <code class="Code-In-Text--PACKT-">root</code> window, so it's not entirely possible to separate the controller from the application's main view. Our <code class="Code-In-Text--PACKT-">Application</code> object will therefore contain a little of both, but in the interest of implementing a more MVC design, we'll need to move some of its presentation logic into the views and some of its data logic into the models. Ideally, though, we want the <code class="Code-In-Text--PACKT-">Application</code> object focused mainly on connecting code between the models and views.</p>
    <h2 id="_idParaDest-138" class="title">Why complicate our design?</h2>
    <p class="normal">Initially, it may seem like a lot of needless overhead to split up the application this way. We'll have to shuttle data around between different objects and ultimately write more code to do exactly the same thing. Why would we do this?</p>
    <p class="normal">Put simply, we're doing it to make expansion manageable. As the application grows, the complexity will also grow. Isolating our components from one another limits the amount of complexity that any one component has to manage; for example, if we wanted to restructure the layout of the Data Record Form, we should not have to worry if doing so will change the structure of the data in the output file.</p>
    <p class="normal">Those two aspects of the program should be independent of one another.</p>
    <p class="normal">It also helps us to be consistent about where we put certain types of logic. For example, having a discrete model object helps us to avoid littering our UI code with ad hoc data queries or file access attempts.</p>
    <p class="normal">The bottom line is, without some guiding architectural strategy, our program is in danger of becoming a hopeless tangle of spaghetti logic. Even without adhering to a strict definition of MVC design, consistently following even a loose MVC pattern will save a lot of headaches as the application becomes more complex.</p>
    <h1 id="_idParaDest-139" class="title">Structuring our application directory</h1>
    <p class="normal">Just as logically breaking our <a id="_idIndexMarker450"/>program into separate concerns helps us manage the logical complexity of each component, physically breaking the code into multiple files helps us keep the complexity of each file manageable. It also reinforces more isolation between components; for example, you can't share global variables between files, and you know that if your <code class="Code-In-Text--PACKT-">models.py</code> file imports <code class="Code-In-Text--PACKT-">tkinter</code>, you're doing something wrong.</p>
    <h2 id="_idParaDest-140" class="title">Basic directory structure</h2>
    <p class="normal">There is no official standard for<a id="_idIndexMarker451"/> laying out a Python application directory, but there are some common conventions that will help us keep things tidy and make it easier to package our software later on. Let's set up our directory structure.</p>
    <p class="normal">To begin, create a directory called <code class="Code-In-Text--PACKT-">ABQ_Data_Entry</code>. This is the root directory of our application, so whenever we <a id="_idIndexMarker452"/>refer to the <strong class="keyword">application root</strong>, this is it.</p>
    <p class="normal">Under the application root, create another directory called <code class="Code-In-Text--PACKT-">abq_data_entry</code>. Notice it's in lowercase. This is going to be a Python package that will contain all the code for the application; it should always be given a fairly unique and descriptive name so that it won't be confused with existing Python packages. Normally, you wouldn't have a different casing between the application root and this main module, but it doesn't hurt anything either; we're doing it here to avoid confusion.</p>
    <div><p class="Tip--PACKT-">Python packages and modules should always be named using all lowercase letters and underscores to separate words. This convention is spelled out in PEP 8, Python's official style guide. See <a href="https://www.python.org/dev/peps/pep-0008">https://www.python.org/dev/peps/pep-0008</a> for more information about PEP 8.</p>
    </div>
    <p class="normal">Next, create a <code class="Code-In-Text--PACKT-">docs</code> folder under<a id="_idIndexMarker453"/> the application root. This folder will be for documentation files about the application.</p>
    <p class="normal">Finally, create two empty files in the application root: <code class="Code-In-Text--PACKT-">README.rst</code> and <code class="Code-In-Text--PACKT-">abq_data_entry.py</code>. Your directory structure should look as follows:</p>
    <figure class="mediaobject"><img src="img/B17578_06_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.2: Directory structure of our application root directory</p>
    <p class="normal">Now, let's put some code in these files.</p>
    <h3 id="_idParaDest-141" class="title">The abq_data_entry.py file</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">abq_data_entry.py</code> file is going to <a id="_idIndexMarker454"/>be the main file that gets executed to <a id="_idIndexMarker455"/>start the program. However, it won't contain the bulk of our program. In fact, it will contain only the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">from abq_data_entry.application import Application
app = Application()
app.mainloop()
</code></pre>
    <p class="normal">Add that code to the file and save it. The only purpose of this file is to import our <code class="Code-In-Text--PACKT-">Application</code> class, make an instance of it, and run it. The remainder of the work will happen inside the <code class="Code-In-Text--PACKT-">abq_data_entry</code> package. We haven't created that yet, so this file won't run just yet. Before we do anything about the application package, let's deal with our documentation.</p>
    <h3 id="_idParaDest-142" class="title">The README.rst file</h3>
    <p class="normal">Since as far back as the 1970s, programs<a id="_idIndexMarker456"/> have included a short text file called <code class="Code-In-Text--PACKT-">README</code>, containing a condensed summary of the program's documentation. For small <a id="_idIndexMarker457"/>programs, it may be the only documentation; for larger programs, it usually contains essential pre-flight instructions for users or administrators.</p>
    <p class="normal">There's no prescribed set of contents for a <code class="Code-In-Text--PACKT-">README</code> file, but as a basic guideline, consider the following sections:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Description</strong>: A brief description of the program and its function. We can reuse the description from our specification, or something like it. This might also contain a brief list of the main features.</li>
      <li class="bullet"><strong class="keyword">Author information</strong>: The names of the authors and copyright date. This is especially important if you plan to share your software, but even for something in-house, it's useful for future maintainers to know who created the software and when.</li>
      <li class="bullet"><strong class="keyword">Requirements</strong>: A list of the software and hardware requirements for the software, if any.</li>
      <li class="bullet"><strong class="keyword">Installation</strong>: Instructions for installing the software, its prerequisites, dependencies, and basic setup.</li>
      <li class="bullet"><strong class="keyword">Configuration</strong>: How to configure the application and what options are available. This is generally aimed at the command-line or configuration file options, not options set interactively in the program.</li>
      <li class="bullet"><strong class="keyword">Usage</strong>: A description of how to launch the application, command-line arguments, and other notes a user would need to know to use the basic functionality of the application.</li>
      <li class="bullet"><strong class="keyword">General notes</strong>: A catch-all for notes or critical information users should be aware of.</li>
      <li class="bullet"><strong class="keyword">Bugs</strong>: A list of known bugs or limitations in the application.</li>
    </ul>
    <p class="normal">Not all of these sections will apply to every program; for example, ABQ Data Entry doesn't currently have any configuration options, so there's no reason to have a configuration section. You might add other sections as well, depending on the situation; for example, publicly distributed software may have an FAQ section for common questions, or open source software might have a Contributing section with instructions on how to submit patches.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">README</code> file is<a id="_idIndexMarker458"/> written in plain ASCII or Unicode text, either <a id="_idIndexMarker459"/>free-form or using a markup language. Since we're doing a Python project, we'll<a id="_idIndexMarker460"/> use <strong class="keyword">reStructuredText</strong>, the official markup for Python documentation (which is why our file uses an <code class="Code-In-Text--PACKT-">rst</code> file extension).</p>
    <div><p class="Information-Box--PACKT-">For more information on reStructuredText, see the <em class="chapterRef">Appendix A</em>, <em class="italic">A Quick Primer on reStructuredText</em>.</p>
    </div>
    <p class="normal">A sample <code class="Code-In-Text--PACKT-">README.rst</code> file is included in the example code in the GitHub repo. Take a moment to look it over; then, we can move on to the <code class="Code-In-Text--PACKT-">docs</code> folder.</p>
    <h3 id="_idParaDest-143" class="title">Populating the docs folder</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">docs</code> folder is where <a id="_idIndexMarker461"/>documentation goes. This can be any kind of documentation: user manuals, program specifications, API references, diagrams, and so on.</p>
    <p class="normal">For now, let's just copy in these things:</p>
    <ul>
      <li class="bullet">The program specification we wrote in the previous chapters</li>
      <li class="bullet">Your interface mockups</li>
      <li class="bullet">A copy of the form used by the technicians</li>
    </ul>
    <p class="normal">At some point, you might need to write a user manual, but for now, the program is simple enough not to need it.</p>
    <h3 id="_idParaDest-144" class="title">Making a Python package</h3>
    <p class="normal">Creating your own<a id="_idIndexMarker462"/> Python package is surprisingly easy. A Python package consists of the following three things:</p>
    <ul>
      <li class="bullet">A directory</li>
      <li class="bullet">A file called <code class="Code-In-Text--PACKT-">__init__.py</code> in the directory</li>
      <li class="bullet">Optionally, one or more Python files in that directory</li>
    </ul>
    <p class="normal">Once you've done this, you can import your package in whole or in part, just like you would import standard library packages, provided your script is in the same parent directory as the package directory.</p>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">__init__.py</code> file in a module is somewhat analogous to what the initializer method is for a class. Code inside it will run whenever the package is imported, and any names created or imported into it are available directly under the package namespace. The Python community generally discourages putting too much code in this file, though; and since no code is actually required, we'll leave this file empty.</p>
    <p class="normal">Let's start building our<a id="_idIndexMarker463"/> application's package. Create the following six empty files under <code class="Code-In-Text--PACKT-">abq_data_entry</code>:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">__init__.py</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">widgets.py</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">views.py</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">models.py</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">application.py</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">constants.py </code></li>
    </ul>
    <p class="normal">Each of those Python files is<a id="_idIndexMarker464"/> called a <strong class="keyword">module</strong>. A module is nothing more than a Python file inside a package directory. Your directory structure should now look like this:</p>
    <figure class="mediaobject"><img src="img/B17578_06_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 6.3: Updated directory structure, including the package directory</p>
    <p class="normal">At this point, you have a <a id="_idIndexMarker465"/>working package, albeit with no actual code in it. To test this, open a Terminal or command-line window, change to your <code class="Code-In-Text--PACKT-">ABQ_Data_Entry</code> directory, and start a Python shell.</p>
    <p class="normal">Now, type the following command:</p>
    <pre class="programlisting code"><code class="hljs-code">from abq_data_entry import application
</code></pre>
    <p class="normal">This should execute without error. Of course, it doesn't do anything, but we'll get to that next.</p>
    <div><p class="Information-Box--PACKT-">Don't confuse the term <em class="italic">package</em> here with the actual distributable Python packages, such as those you download using <code class="Code-In-Text--PACKT-">pip</code>. We will learn how to make distributable Python packages in <em class="chapterRef">Chapter 16</em>, <em class="italic">Packaging with setuptools and cxFreeze</em>. In this context, a package is just a collection of Python modules.</p>
    </div>
    <h1 id="_idParaDest-145" class="title">Splitting our application into multiple files</h1>
    <p class="normal">Now that our<a id="_idIndexMarker466"/> directory structure is in order, we need to start <a id="_idIndexMarker467"/>dissecting our application script and splitting it up into our module files. We'll also need to create our model class.</p>
    <p class="normal">Open up your <code class="Code-In-Text--PACKT-">data_entry_app.py</code> file from <em class="chapterRef">Chapter 5</em>, <em class="italic">Reducing User Error with Validation and Automation</em>, and let's begin!</p>
    <h2 id="_idParaDest-146" class="title">Creating the models module</h2>
    <p class="normal">When your application is all <a id="_idIndexMarker468"/>about data, it's good to begin with the model. Remember that the job of a model is to manage the storage, retrieval, and processing of our application's data, usually with respect to its persistent storage format (in this case, CSV). To accomplish this, our model should contain all the knowledge about our data.</p>
    <p class="normal">Currently, our application has nothing like a model; knowledge about the application's data is scattered the form fields, and the <code class="Code-In-Text--PACKT-">Application</code> object simply takes whatever data the form contains and stuffs it directly into a CSV file when a save operation is requested. Since we aren't yet retrieving or updating information, our application has no actual knowledge about what's inside the CSV file.</p>
    <p class="normal">To move our application to an MVC architecture, we'll need to create a model class that both manages data storage and retrieval, and represents the authoritative source of knowledge about our data. In other words, we have to encode the knowledge contained in our data dictionary here in our model. We don't really know what we'll do with this knowledge yet, but this is where it belongs.</p>
    <p class="normal">There are a few ways we could store this data, such as creating a custom field class or a <code class="Code-In-Text--PACKT-">namedtuple</code> object, but we'll keep it simple for now and just use a dictionary, mapping field names to field metadata.</p>
    <p class="normal">The field metadata will likewise be stored as a dictionary of attributes about the field, which will include:</p>
    <ul>
      <li class="bullet">The type of data stored in the field</li>
      <li class="bullet">Whether or not the field is required</li>
      <li class="bullet">The list of possible values, if applicable</li>
      <li class="bullet">The minimum, maximum, and increment of values, if applicable</li>
    </ul>
    <p class="normal">To store the data type for<a id="_idIndexMarker469"/> each field, we're going to define a set of constants that will let us refer to the different field types in a consistent and explicit way. We'll place this in the <code class="Code-In-Text--PACKT-">constants.py</code> file, so open that file in your editor and add the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/constants.py
from enum import Enum, auto
class FieldTypes(Enum):
  string = auto()
  string_list = auto()
  short_string_list = auto()
  iso_date_string = auto()
  long_string = auto()
  decimal = auto()
  integer = auto()
  boolean = auto()
</code></pre>
    <p class="normal">We've created a class called <code class="Code-In-Text--PACKT-">FieldTypes</code> that simply stores some named integer values, which will describe the different types of data we're going to store. This class is based on Python's <code class="Code-In-Text--PACKT-">Enum</code> class, which is a useful class for defining collections of constants like this. The values of these variables are not at all important, so long as each one is unique; in an <code class="Code-In-Text--PACKT-">Enum</code>, we're really just interested in having a set of variable names that are not equal to one another. </p>
    <p class="normal">We could set them to strings or sequential integers by hand, but the <code class="Code-In-Text--PACKT-">enum</code> module provides the <code class="Code-In-Text--PACKT-">auto()</code> function, which gives each constant of the class a unique integer value automatically. Using this approach better communicates that the values themselves are not significant; only the names matter.</p>
    <p class="normal">Now that we have these constants, let's open <code class="Code-In-Text--PACKT-">models.py</code> and begin creating our model class:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/models.py, at the top
import csv
from pathlib import Path
from datetime import datetime
import os
from .constants import FieldTypes as FT
class CSVModel:
  """CSV file storage"""
</code></pre>
    <p class="normal">We begin by importing the libraries we will need for our model: <code class="Code-In-Text--PACKT-">csv</code>, <code class="Code-In-Text--PACKT-">pathlib</code>, <code class="Code-In-Text--PACKT-">datetime</code>, <code class="Code-In-Text--PACKT-">os</code>, and our new <code class="Code-In-Text--PACKT-">FieldTypes</code> constants. The first three were the libraries we needed for our <code class="Code-In-Text--PACKT-">on_save()</code> method in <code class="Code-In-Text--PACKT-">Application</code>. Now, the model class will be handling most of this functionality. The <code class="Code-In-Text--PACKT-">os</code> module will be used to check file permissions, and the <code class="Code-In-Text--PACKT-">FieldTypes</code> constants will be used to define our model's data dictionary.</p>
    <p class="normal">Notice the way we<a id="_idIndexMarker470"/> import <code class="Code-In-Text--PACKT-">FieldTypes</code>: <code class="Code-In-Text--PACKT-">from .constants import FieldTypes</code>. The dot in front of <code class="Code-In-Text--PACKT-">constants</code> makes this a <strong class="keyword">relative import</strong>. Relative imports<a id="_idIndexMarker471"/> can be used inside a Python package to locate other modules in the same package. In this case, we're in the <code class="Code-In-Text--PACKT-">models</code> module, and we need to access the <code class="Code-In-Text--PACKT-">constants</code> module inside the <code class="Code-In-Text--PACKT-">abq_data_entry</code> package. The single dot represents our current parent module (<code class="Code-In-Text--PACKT-">abq_data_entry</code>), and thus <code class="Code-In-Text--PACKT-">.constants</code> within this file means the <code class="Code-In-Text--PACKT-">constants</code> module of the <code class="Code-In-Text--PACKT-">abq_data_entry</code> package.</p>
    <p class="normal">Relative imports distinguish our custom modules from modules in <code class="Code-In-Text--PACKT-">PYTHONPATH</code>. By using them, we don't have to worry about any third-party or standard library packages conflicting with our module names.</p>
    <p class="normal">Next, we're going to need to create a class member variable that contains a dictionary of all the fields in our model. Each item in the dictionary will contain details about the field: its data type, if it's required, and valid values, ranges, and increments.</p>
    <div><p class="Information-Box--PACKT-">In addition to field attributes, we're also documenting the order of fields for the CSV here. In Python 3.6 and later, dictionaries retain the order they were defined by; if you're using an older version of Python 3, you need to use the <code class="Code-In-Text--PACKT-">OrderedDict</code> class from the <code class="Code-In-Text--PACKT-">collections</code> standard library module to preserve the field order.</p>
    </div>
    <p class="normal">Add this dictionary like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  fields = {
    "Date": {'req': True, 'type': FT.iso_date_string},
    "Time": {'req': True, 'type': FT.string_list,
      'values': ['8:00', '12:00', '16:00', '20:00']},
    "Technician": {'req': True, 'type':  FT.string},
    "Lab": {'req': True, 'type': FT.short_string_list,
      'values': ['A', 'B', 'C']},
    "Plot": {'req': True, 'type': FT.string_list,
      'values': [str(x) for x in range(1, 21)]},
    "Seed Sample":  {'req': True, 'type': FT.string},
    "Humidity": {'req': True, 'type': FT.decimal,
      'min': 0.5, 'max': 52.0, 'inc': .01},
    "Light": {'req': True, 'type': FT.decimal,
      'min': 0, 'max': 100.0, 'inc': .01},
    "Temperature": {'req': True, 'type': FT.decimal,
      'min': 4, 'max': 40, 'inc': .01},
    "Equipment Fault": {'req': False, 'type': FT.boolean},
    "Plants": {'req': True, 'type': FT.integer,       'min': 0, 'max': 20},
    "Blossoms": {
      'req': True, 'type': FT.integer, 'min': 0, 'max': 1000},
    "Fruit": {'req': True, 'type': FT.integer, 
      'min': 0, 'max': 1000},
    "Min Height": {'req': True, 'type': FT.decimal,
      'min': 0, 'max': 1000, 'inc': .01},
    "Max Height": {'req': True, 'type': FT.decimal,
      'min': 0, 'max': 1000, 'inc': .01},
    "Med Height": {'req': True, 'type': FT.decimal,
      'min': 0, 'max': 1000, 'inc': .01},
    "Notes": {'req': False, 'type': FT.long_string}
  }
</code></pre>
    <p class="normal">This list is straight<a id="_idIndexMarker472"/> from our data dictionary, and we've seen these same values already in our <code class="Code-In-Text--PACKT-">DataRecordForm</code> class; but from now on, this dictionary is going to be the authoritative source of this information. Any other class that needs information about a model field will have to retrieve it from this dictionary.</p>
    <p class="normal">Before we start designing our model class's methods, let's take a moment to look at the existing file-save logic in our application and consider which parts belong to the model. The code in our current script looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _on_save(self):
    errors = self.recordform.get_errors()
    if errors:
      self.status.set(
        "Cannot save, error in fields: {}"
        .format(', '.join(errors.keys()))
      )
      return
    datestring = datetime.today().strftime("%Y-%m-%d")
    filename = f"abq_data_record_{datestring}.csv"
    newfile = not Path(filename).exists()
    data = self.recordform.get()
    with open(filename, 'a') as fh:
      csvwriter = csv.DictWriter(fh, fieldnames=data.keys())
      if newfile:
        csvwriter.writeheader()
      csvwriter.writerow(data)
    self._records_saved += 1
    self.status.set(
      f"{self._records_saved} records saved this session"
    )
    self.recordform.reset()
</code></pre>
    <p class="normal">Let's go through this code and<a id="_idIndexMarker473"/> determine what goes into the model and what stays in the <code class="Code-In-Text--PACKT-">Application</code> class:</p>
    <ul>
      <li class="bullet">The first block pulls errors from the <code class="Code-In-Text--PACKT-">DataRecordForm</code> class. Since the model will have no knowledge of the form, this should stay in <code class="Code-In-Text--PACKT-">Application</code>. In fact, the model doesn't even need to know about form errors, since the only action taken is UI-related (that is, displaying the errors).</li>
      <li class="bullet">The next set of lines define the filename we're going to use. Since this is a detail of the file storage, it is clearly the model's concern.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">newfile</code> assignment line determines whether the file exists or not. As an implementation detail of the data storage medium, this is clearly the model's problem, not the application's.</li>
      <li class="bullet">The line <code class="Code-In-Text--PACKT-">data = self.recordform.get()</code> pulls data from the form. Since our model has no knowledge of the form's existence, this needs to stay in <code class="Code-In-Text--PACKT-">Application</code>.</li>
      <li class="bullet">The next block opens the file, creates a <code class="Code-In-Text--PACKT-">csv.DictWriter</code> object, and appends the data. This is definitely the model's concern.</li>
      <li class="bullet">The final block communicates the results of the file-save operation to the user and resets the form. This is all user interface-related, so it does not belong in the model.</li>
    </ul>
    <p class="normal">So, our model will need to determine the filename and take care of writing the data received from the <code class="Code-In-Text--PACKT-">Application</code> object to it, while the application will be responsible for checking the form for errors, retrieving the data from the form, and communicating the results of the save operation to the user.</p>
    <p class="normal">Let's create the initializer method for our model class. Because the <code class="Code-In-Text--PACKT-">CSVModel</code> represents an interface to a specific CSV file, we're going to determine the filename in <code class="Code-In-Text--PACKT-">__init__()</code> and keep it for the lifespan of the model object. The method begins like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in the CSVModel class
  def __init__(self):
    datestring = datetime.today().strftime("%Y-%m-%d")
    filename = "abq_data_record_{}.csv".format(datestring)
    self.file = Path(filename)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__init__()</code> method <a id="_idIndexMarker474"/>begins by determining the <code class="Code-In-Text--PACKT-">filename</code> from the current date and converting it into a <code class="Code-In-Text--PACKT-">Path</code> object, which it stores as an instance variable.</p>
    <p class="normal">Since the instance of the model is tied to the filename and represents our access to that file, it would be a relatively useless model if we did not have permission to append data to the file. Therefore, we will want the initializer to check access to the file and alert us if there is any problem with it before we start entering data into our form.</p>
    <p class="normal">To do that, we need to use the <code class="Code-In-Text--PACKT-">os.access()</code> function, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in CSVModel.__init__()
    file_exists = os.access(self.file, os.F_OK)
    parent_writeable = os.access(self.file.parent, os.W_OK)
    file_writeable = os.access(self.file, os.W_OK)
    if (
      (not file_exists and not parent_writeable) or
      (file_exists and not file_writeable)
    ):
      msg = f'Permission denied accessing file: {filename}'
      raise PermissionError(msg)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">os.access()</code> function takes two arguments: a file path string or <code class="Code-In-Text--PACKT-">Path</code> object, and a constant indicating the mode we want to check. The two constants we'll be using are <code class="Code-In-Text--PACKT-">os.F_OK</code>, which checks if the file exists, and <code class="Code-In-Text--PACKT-">os.W_OK</code>, which checks that we have write permission to it. Note that checking for <code class="Code-In-Text--PACKT-">W_OK</code> will return <code class="Code-In-Text--PACKT-">False</code> if the file doesn't exist (which is a distinct possibility if no data has been saved yet), so we need to check for two possible scenarios:</p>
    <ul>
      <li class="bullet">The file exists, but we cannot write to it</li>
      <li class="bullet">The file does not exist, and we cannot write to its parent directory</li>
    </ul>
    <p class="normal">In either of these cases, we <a id="_idIndexMarker475"/>won't be able to write to the file and should raise an exception. You might wonder why we're raising an exception and not displaying some kind of error (such as in the status bar or by printing to the console). Remember that the model class should not assume anything about the UI or contain any UI code. The appropriate way to handle an error situation in a model is to pass a message back to the controller using an exception, so that the controller can take actions appropriate to our user interface.</p>
    <div><p class="Tip--PACKT-">The idea of raising an exception on purpose often seems strange to beginners; after all, exceptions are something we're trying to avoid, right? This is true in the case of small scripts where we are essentially consumers of existing modules; when writing your own module, however, exceptions are the correct way for your module to communicate problems to the code using its classes and functions. Trying to handle â€“ or worse, silence â€“ bad behavior on the part of external code will, at best, break the modularization of our code; at worst, it will create subtle bugs that are difficult to track down.</p>
    </div>
    <p class="normal">Now that we have our model initialized with a writable filename, we need to create a method to save the data. In the <code class="Code-In-Text--PACKT-">CSVModel</code> class, let's create a public method to store data. Add the following code for the <code class="Code-In-Text--PACKT-">save_record()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># models.py, in the CSVModel class
  def save_record(self, data):
    """Save a dict of data to the CSV file"""
    newfile = not self.file.exists()
    with open(self.file, 'a', newline='') as fh:
      csvwriter = csv.DictWriter(fh, fieldnames=self.fields.keys())
      if newfile:
        csvwriter.writeheader()
      csvwriter.writerow(data)
</code></pre>
    <p class="normal">Since the model does not need to know about form errors and already has a filename established in its initializer, the only argument this method requires is a dictionary of the form data. What remains is to <a id="_idIndexMarker476"/>determine if we are dealing with a new file and to write the data to the CSV.</p>
    <p class="normal">Note that, when writing the field names to a new CSV file, we use the keys of our <code class="Code-In-Text--PACKT-">fields</code> dictionary, rather than relying on the keys in the incoming data. Remember that <code class="Code-In-Text--PACKT-">CSVModel.fields</code> is now the authoritative source of information about application data, so it should determine the headers that are used.</p>
    <p class="normal">Our model class is now complete. Let's get to work on the user interface!</p>
    <h2 id="_idParaDest-147" class="title">Moving the widgets</h2>
    <p class="normal">While we could put all of our<a id="_idIndexMarker477"/> UI-related code in one <code class="Code-In-Text--PACKT-">views</code> module, we have a lot of custom widget classes. It would make sense to put them in their own separate module to limit the complexity of the <code class="Code-In-Text--PACKT-">views</code> module. So, instead, we're going to move all of the code for our widget classes into a <code class="Code-In-Text--PACKT-">widgets.py</code> file. The widget classes we'll move include all the classes that implement reusable GUI components, including compound widgets like <code class="Code-In-Text--PACKT-">LabelInput</code>. If we develop more custom widgets, we'll add them to this file as well.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">widgets.py</code> and copy in all of the code for <code class="Code-In-Text--PACKT-">ValidatedMixin</code>, <code class="Code-In-Text--PACKT-">DateEntry</code>, <code class="Code-In-Text--PACKT-">RequiredEntry</code>, <code class="Code-In-Text--PACKT-">ValidatedCombobox</code>, <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code>, <code class="Code-In-Text--PACKT-">ValidatedRadioGroup</code>, <code class="Code-In-Text--PACKT-">BoundText</code>, and <code class="Code-In-Text--PACKT-">LabelInput</code>. These are all the widget classes we've created so far.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">widgets.py</code> file will, of course, need to import any module dependencies used by the code being copied in. We'll need to look through our code and find what libraries we use and import them. Add the following to the top of the file:</p>
    <pre class="programlisting code"><code class="hljs-code"># top of widgets.py
import tkinter as tk
from tkinter import ttk
from datetime import datetime
from decimal import Decimal, InvalidOperation
</code></pre>
    <p class="normal">Obviously, we need <code class="Code-In-Text--PACKT-">tkinter</code> and <code class="Code-In-Text--PACKT-">ttk</code>; our <code class="Code-In-Text--PACKT-">DateEntry</code> class uses the <code class="Code-In-Text--PACKT-">datetime</code> class from the <code class="Code-In-Text--PACKT-">datetime</code> library, and our <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> class makes use of the <code class="Code-In-Text--PACKT-">Decimal</code> class and <code class="Code-In-Text--PACKT-">InvalidOperation</code> exception from the <code class="Code-In-Text--PACKT-">decimal</code> library. This is all we need in <code class="Code-In-Text--PACKT-">widgets.py</code>.</p>
    <h2 id="_idParaDest-148" class="title">Moving the views</h2>
    <p class="normal">Next, we'll work <a id="_idIndexMarker478"/>on the <code class="Code-In-Text--PACKT-">views.py</code> file. Recall that views are larger GUI components, like our <code class="Code-In-Text--PACKT-">DataRecordForm</code> class. Currently, in fact, it is our only view, but as we create more large GUI components, they will be added here.</p>
    <p class="normal">Open the <code class="Code-In-Text--PACKT-">views.py</code> file and copy in the <code class="Code-In-Text--PACKT-">DataRecordForm</code> class; then, go back to the top to deal with the module imports. Again, we'll need <code class="Code-In-Text--PACKT-">tkinter</code> and <code class="Code-In-Text--PACKT-">ttk</code>, as well as <code class="Code-In-Text--PACKT-">datetime</code>, since our auto-fill logic requires it.</p>
    <p class="normal">Add them to the top of the file, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/views.py, at the top
import tkinter as tk
from tkinter import ttk
from datetime import datetime
</code></pre>
    <p class="normal">We aren't done, though; our actual widgets aren't here anymore, so we'll need to import them, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">from . import widgets as w
</code></pre>
    <p class="normal">Just as we did with the <code class="Code-In-Text--PACKT-">FieldTypes</code> in our <code class="Code-In-Text--PACKT-">models.py</code> file, we've imported our <code class="Code-In-Text--PACKT-">widgets</code> module using a relative import. We've kept the widgets in their own namespace to keep our global namespace clean, but given it a short alias, <code class="Code-In-Text--PACKT-">w</code>, so that our code won't get overly cluttered.</p>
    <p class="normal">This means, though, that we'll need to go through the code and prepend <code class="Code-In-Text--PACKT-">w.</code> to all instances of <code class="Code-In-Text--PACKT-">LabelInput</code>, <code class="Code-In-Text--PACKT-">RequiredEntry</code>, <code class="Code-In-Text--PACKT-">DateEntry</code>, <code class="Code-In-Text--PACKT-">ValidatedCombobox</code>, <code class="Code-In-Text--PACKT-">ValidatedRadioGroup</code>, <code class="Code-In-Text--PACKT-">BoundText</code>, and <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code>. This should be easy enough to do in IDLE or any other text editor using a series of search and replace actions.</p>
    <p class="normal">For example, line 1 of the form should be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <strong class="hljs-slc">w.</strong>LabelInput(
      r_info, "Date", var=self._vars['Date'],
      input_class=w.DateEntry
    ).grid(row=0, column=0)
    <strong class="hljs-slc">w.</strong>LabelInput(
      r_info, "Time", input_class=w.ValidatedCombobox,
      var=self._vars['Time'],
      input_args={"values": ["8:00", "12:00", "16:00", "20:00"]}
    ).grid(row=0, column=1)
    <strong class="hljs-slc">w.</strong>LabelInput(
      r_info, "Technician",  var=self._vars['Technician'],
      input_class=w.RequiredEntry
    ).grid(row=0, column=2)
</code></pre>
    <p class="normal">Before you go through and change that everywhere, though, let's stop and take a moment to refactor some of the redundancy out of this code.</p>
    <h3 id="_idParaDest-149" class="title">Removing redundancy in our view logic</h3>
    <p class="normal">Consider the arguments<a id="_idIndexMarker479"/> we're passing into the <code class="Code-In-Text--PACKT-">LabelInput</code> widgets: they contain a lot of information that is also in our model. Minimums, maximums, increments, and possible values are defined both here and in our model code. Even the type of the input widget we're choosing is related directly to the type of data being stored: numbers get a <code class="Code-In-Text--PACKT-">ValidatedSpinbox</code> widget, dates get a <code class="Code-In-Text--PACKT-">DateEntry</code> widget, and so on. Ideally, our source for information about each field should only be defined in one place, and that place should be the model. If we need to update the model for some reason, our form should synchronize with those changes.</p>
    <p class="normal">Rather than redundantly define these options in the view, we need to give our view access to the field specifications from our model so that the widgets' details can be determined from it. Since our widget instances are being defined inside the <code class="Code-In-Text--PACKT-">LabelInput</code> class, we're going to enhance that class with the ability to automatically work out the input class and arguments from our model's field specification format.</p>
    <p class="normal">To do that, open up the <code class="Code-In-Text--PACKT-">widgets.py</code> file. We'll begin by importing the <code class="Code-In-Text--PACKT-">FieldTypes</code> class, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># at the top of widgets.py
from .constants import FieldTypes as FT
</code></pre>
    <p class="normal">Next, we need to tell the <code class="Code-In-Text--PACKT-">LabelInput</code> class how to translate a field type into a widget class. To do that, locate the <code class="Code-In-Text--PACKT-">LabelInput</code> class and add the following <code class="Code-In-Text--PACKT-">field_types</code> class attribute just above the <code class="Code-In-Text--PACKT-">__init__()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"># widgets.py, inside LabelInput
  field_types = {
    FT.string: RequiredEntry,
    FT.string_list: ValidatedCombobox,
    FT.short_string_list: ValidatedRadioGroup,
    FT.iso_date_string: DateEntry,
    FT.long_string: BoundText,
    FT.decimal: ValidatedSpinbox,
    FT.integer: ValidatedSpinbox,
    FT.boolean: ttk.Checkbutton
  }
</code></pre>
    <p class="normal">This dictionary will act as a key to translate our model's field types into an appropriate widget type.</p>
    <div><p class="Information-Box--PACKT-">Note that all of these widgets need to exist before we can create this dictionary, so be sure to place the <code class="Code-In-Text--PACKT-">LabelInput</code> class definition at the <em class="italic">end</em> of <code class="Code-In-Text--PACKT-">widgets.py</code>, if it's not already there.</p>
    </div>
    <p class="normal">Now, we need to <a id="_idIndexMarker480"/>update <code class="Code-In-Text--PACKT-">LabelInput.__init__()</code> to take a <code class="Code-In-Text--PACKT-">field_spec</code> argument and, if given, use it to define the parameters of the input widget. To begin with, update the argument list of the initializer as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># widgets.py, inside LabelInput
  def __init__(
    self, parent, label, var, input_class=None,
    input_args=None, label_args=None, <strong class="hljs-slc">field_spec=None</strong>,
    disable_var=None, **kwargs
  ):
</code></pre>
    <p class="normal">Although <code class="Code-In-Text--PACKT-">field_spec</code> will largely remove the requirement for the <code class="Code-In-Text--PACKT-">input_class</code> and <code class="Code-In-Text--PACKT-">input_args</code> arguments, we're going to retain them in case we should later need to build a form that is not tied to a model.</p>
    <p class="normal">Inside the initializer method, we'll need to read the field spec and apply the information. Add the following code after the variable setup and before the label setup:</p>
    <pre class="programlisting code"><code class="hljs-code"># widgets.py, inside LabelInput.__init__():
    if field_spec:
      field_type = field_spec.get('type', FT.string)
      input_class = input_class or self.field_types.get(field_type)
      if 'min' in field_spec and 'from_' not in input_args:
        input_args['from_'] = field_spec.get('min')
      if 'max' in field_spec and 'to' not in input_args:
        input_args['to'] = field_spec.get('max')
      if 'inc' in field_spec and 'increment' not in input_args:
        input_args['increment'] = field_spec.get('inc')
      if 'values' in field_spec and 'values' not in input_args:
        input_args['values'] = field_spec.get('values')
</code></pre>
    <p class="normal">The first thing we'll do with the <code class="Code-In-Text--PACKT-">field_spec</code>, if it is supplied, is retrieve the field type. This will be used to look up an appropriate widget using the <code class="Code-In-Text--PACKT-">field_types</code> dictionary. If we want to override this for a particular <code class="Code-In-Text--PACKT-">LabelInput</code> instance, an explicitly passed <code class="Code-In-Text--PACKT-">input_class</code> argument will override the lookup value.</p>
    <p class="normal">Next, we need to set up the field parameters, <code class="Code-In-Text--PACKT-">min</code>, <code class="Code-In-Text--PACKT-">max</code>, <code class="Code-In-Text--PACKT-">inc</code>, and <code class="Code-In-Text--PACKT-">values</code>. For each of these, we check if the key exists in the field specification and make sure the corresponding <code class="Code-In-Text--PACKT-">from_</code>, <code class="Code-In-Text--PACKT-">to</code>, <code class="Code-In-Text--PACKT-">increment</code>, or <code class="Code-In-Text--PACKT-">values</code> argument has not been passed in explicitly using <code class="Code-In-Text--PACKT-">input_args</code>. If so, we'll set up the <code class="Code-In-Text--PACKT-">input_args</code> with the appropriate value. Now that <code class="Code-In-Text--PACKT-">input_class</code> and <code class="Code-In-Text--PACKT-">input_args</code> have been determined from the field specification, the remainder of the initializer method can continue as previously defined.</p>
    <p class="normal">With <code class="Code-In-Text--PACKT-">LabelInput</code> refactored to accept a <code class="Code-In-Text--PACKT-">field_spec</code> argument, we can update our view code to take advantage of this new capability. To do this, our <code class="Code-In-Text--PACKT-">DataRecordForm</code> class will first need access to the <code class="Code-In-Text--PACKT-">model</code> object from which it can obtain the field specifications for the data model.</p>
    <p class="normal">Back in the <code class="Code-In-Text--PACKT-">views.py</code> file, edit<a id="_idIndexMarker481"/> the initializer method for <code class="Code-In-Text--PACKT-">DataRecordForm</code> so that we can pass in a copy of the <code class="Code-In-Text--PACKT-">model</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm class
  def __init__(self, parent, model, *args, **kwargs):
    super().__init__(parent, *args, **kwargs)
    self.model= model
    fields = self.model.fields
</code></pre>
    <p class="normal">We've stored the <code class="Code-In-Text--PACKT-">model</code> itself in an instance variable, and also extracted the <code class="Code-In-Text--PACKT-">fields</code> dictionary into a local variable to cut down the code verbosity as we use this dictionary in the initializer method. Now, we can go through our <code class="Code-In-Text--PACKT-">LabelInput</code> calls and replace the <code class="Code-In-Text--PACKT-">input_args</code> and <code class="Code-In-Text--PACKT-">input_class</code> arguments with a single <code class="Code-In-Text--PACKT-">field_spec</code> argument.</p>
    <p class="normal">With these changes, the first line looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm.__init__()
    w.LabelInput(
      r_info, "Date",
      field_spec=fields['Date'],
      var=self._vars['Date'],
    ).grid(row=0, column=0)
    w.LabelInput(
      r_info, "Time",
      field_spec=fields['Time'],
      var=self._vars['Time'],
    ).grid(row=0, column=1)
    w.LabelInput(
      r_info, "Technician",
      field_spec=fields['Technician'],
      var=self._vars['Technician']
    ).grid(row=0, column=2)
</code></pre>
    <p class="normal">Go ahead and update the <a id="_idIndexMarker482"/>rest of the widgets in the same way, replacing <code class="Code-In-Text--PACKT-">input_class</code> and <code class="Code-In-Text--PACKT-">input_args</code> with the <code class="Code-In-Text--PACKT-">field_spec</code> argument. Note that when you get to the height fields, you'll still need to pass in an <code class="Code-In-Text--PACKT-">input_args</code> dictionary to define the <code class="Code-In-Text--PACKT-">min_var</code>, <code class="Code-In-Text--PACKT-">max_var</code>, and <code class="Code-In-Text--PACKT-">focus_update_var</code> arguments.</p>
    <p class="normal">For example, the following is the Min Height input definition:</p>
    <pre class="programlisting code"><code class="hljs-code">    w.LabelInput(
      p_info, "Min Height (cm)",
      field_spec=fields['Min Height'],
      var=self._vars['Min Height'],
      input_args={
        "max_var": max_height_var,
        "focus_update_var": min_height_var
      })
</code></pre>
    <p class="normal">That does it. Now, any changes to a given field specification can be made solely in the model, and the form will simply do the correct thing.</p>
    <h3 id="_idParaDest-150" class="title">Using custom events to remove tight coupling</h3>
    <p class="normal">Before we<a id="_idIndexMarker483"/> leave the <code class="Code-In-Text--PACKT-">DataRecordForm</code> class, there is one fix we should make to improve the separation of concerns in our application. Currently, the <code class="Code-In-Text--PACKT-">savebutton</code> widget on our form is bound to <code class="Code-In-Text--PACKT-">self.master._on_save()</code>, which refers to the <code class="Code-In-Text--PACKT-">_on_save()</code> method of the <code class="Code-In-Text--PACKT-">Application</code> class. However, the way we have bound this command makes the assumption that <code class="Code-In-Text--PACKT-">self.master</code> (that is, the parent widget of the <code class="Code-In-Text--PACKT-">DataRecordForm</code>) is <code class="Code-In-Text--PACKT-">Application</code>. What would happen if we decided to put our <code class="Code-In-Text--PACKT-">DataRecordForm</code> widget inside a <code class="Code-In-Text--PACKT-">Notebook</code> or <code class="Code-In-Text--PACKT-">Frame</code> widget, rather than directly under the <code class="Code-In-Text--PACKT-">Application</code> object? In that case, <code class="Code-In-Text--PACKT-">self.master</code> would change and the code would break. Since the parent widget is really a layout concern, we would not expect that a change to it would impact the save button callback.</p>
    <p class="normal">A situation like this, where a class depends too much on the architecture of the application outside the class, is <a id="_idIndexMarker484"/>known as <strong class="keyword">tight coupling</strong>, and is something we should work to avoid in our code. Instead, we <a id="_idIndexMarker485"/>want <strong class="keyword">loose coupling</strong> in our code so that changes to one class will not cause unexpected bugs in another.</p>
    <p class="normal">There are a few ways <a id="_idIndexMarker486"/>we could address this issue. We could pass a reference to the callback or the <code class="Code-In-Text--PACKT-">Application</code> class to the view so that it could more explicitly reference the method in question. This would work, but it would still be tighter coupling than we'd ideally like to have.</p>
    <p class="normal">A better approach is to utilize <strong class="keyword">events</strong>. As you<a id="_idIndexMarker487"/> know, Tkinter generates an event whenever the user interacts with the GUI in some way, like clicking a button or making a keystroke. These events can be explicitly bound to a callback function using the <code class="Code-In-Text--PACKT-">bind()</code> method of any Tkinter widget. Tkinter also allows us to generate our own custom events that we can bind just like the built-in ones.</p>
    <p class="normal">Let's implement a callback method in <code class="Code-In-Text--PACKT-">DataRecordForm</code> that will generate a custom event, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _on_save(self):
    self.event_generate('&lt;&lt;SaveRecord&gt;&gt;')
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">event_generate()</code> method can be called on any Tkinter widget to cause it to emit the event specified. In this case, we're calling our event <code class="Code-In-Text--PACKT-">&lt;&lt;SaveRecord&gt;&gt;</code>. All custom event sequences must use double angle brackets to differentiate them from built-in event types. Apart from that, you can call them whatever you wish.</p>
    <p class="normal">Back in the <code class="Code-In-Text--PACKT-">DataRecordForm.__init__()</code> method, we'll update our save button definition to use this method as a callback, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># views.py, in DataRecordForm.__init__()
    self.savebutton = ttk.Button(
      buttons, text="Save", command=self._on_save)
</code></pre>
    <p class="normal">Now, rather than directly executing the <code class="Code-In-Text--PACKT-">Application</code> object's <code class="Code-In-Text--PACKT-">_on_save()</code> method, the button will simply cause <code class="Code-In-Text--PACKT-">DataRecordForm</code> to emit a message that the record-save operation was requested by the user. It will be the <code class="Code-In-Text--PACKT-">Application</code> object's responsibility to deal with that message.</p>
    <div><p class="Information-Box--PACKT-">We'll be utilizing custom events more extensively in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating Menus with Menu and Tkinter Dialogs</em>, when we build our application menu.</p>
    </div>
    <h2 id="_idParaDest-151" class="title">Creating the application file</h2>
    <p class="normal">The last piece we need to<a id="_idIndexMarker488"/> create is our controller and root window class, <code class="Code-In-Text--PACKT-">Application</code>. Open the <code class="Code-In-Text--PACKT-">application.py</code> file and copy in the <code class="Code-In-Text--PACKT-">Application</code> class definition from the old <code class="Code-In-Text--PACKT-">data_entry_app.py</code> file.</p>
    <p class="normal">As before, we need to add the module imports required for this code. At the top of the file, add the following:</p>
    <pre class="programlisting code"><code class="hljs-code"># abq_data_entry/application.py, at the top
import tkinter as tk
from tkinter import ttk
from . import views as v
from . import models as m
</code></pre>
    <p class="normal">Once again, we need <code class="Code-In-Text--PACKT-">tkinter</code> and <code class="Code-In-Text--PACKT-">ttk</code>, of course; we also need the <code class="Code-In-Text--PACKT-">views</code> module for our <code class="Code-In-Text--PACKT-">DataRecordForm</code> and the <code class="Code-In-Text--PACKT-">models</code> module for our <code class="Code-In-Text--PACKT-">CSVModel</code>.</p>
    <p class="normal">Now, we're going to need to make several changes to the <code class="Code-In-Text--PACKT-">Application.__init__()</code> method. To begin with, we'll need to create a model instance that we can pass to the <code class="Code-In-Text--PACKT-">DataRecordForm</code> and to save our data. Create this object near the top of the initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside the Application class
  def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self.model = m.CSVModel()
</code></pre>
    <p class="normal">Next, we need to update the call to <code class="Code-In-Text--PACKT-">DataRecordForm</code>, both to add the namespace and make sure we pass in the model instance, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    self.recordform = v.DataRecordForm(self, self.model)
</code></pre>
    <p class="normal">We will also need to bind our custom event, <code class="Code-In-Text--PACKT-">&lt;&lt;SaveRecord&gt;&gt;</code>, to the <code class="Code-In-Text--PACKT-">Application</code> object's record-save callback. Add the <code class="Code-In-Text--PACKT-">bind</code> command like so:</p>
    <pre class="programlisting code"><code class="hljs-code"># application.py, inside Application.__init__()
    self.recordform = v.DataRecordForm(self, self.model)
    self.recordform.grid(row=1, padx=10, sticky=(tk.W + tk.E))
    self.recordform.bind('&lt;&lt;SaveRecord&gt;&gt;', self._on_save)
</code></pre>
    <p class="normal">Finally, we need to update the code in <code class="Code-In-Text--PACKT-">Application._on_save()</code> to use the model. The new method should look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  def _on_save(self, *_):
    """Handles file-save requests"""
    errors = self.recordform.get_errors()
    if errors:
      self.status.set(
        "Cannot save, error in fields: {}"
        .format(', '.join(errors.keys()))
      )
      return 
    data = self.recordform.get()
    self.model.save_record(data)
    self._records_saved += 1
    self.status.set(
      f"{self._records_saved} records saved this session"
    )
    self.recordform.reset()
</code></pre>
    <p class="normal">As you can see, using our model is pretty seamless; once we have checked for errors and retrieved the data from the form, we just pass it to <code class="Code-In-Text--PACKT-">self.model.save_record()</code>. The <code class="Code-In-Text--PACKT-">Application</code> doesn't have to know any details about how the data is saved.</p>
    <p class="normal">Note that we've <a id="_idIndexMarker489"/>added an argument of <code class="Code-In-Text--PACKT-">*_</code> to the method definition. When we use <code class="Code-In-Text--PACKT-">bind</code> to bind an event to a callback, the callback will receive an <code class="Code-In-Text--PACKT-">event</code> object. We aren't going to be using this <code class="Code-In-Text--PACKT-">event</code> argument, so by Python convention, we'll just roll up any positional arguments into a variable called <code class="Code-In-Text--PACKT-">_</code> (underscore). This way, our callback can handle receiving arguments, but we've indicated we aren't going to use them.</p>
    <h2 id="_idParaDest-152" class="title">Running the application</h2>
    <p class="normal">The application is <a id="_idIndexMarker490"/>now completely migrated to the new data format. To test it, navigate to the application root folder, <code class="Code-In-Text--PACKT-">ABQ_Data_Entry</code>, and execute the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python3 abq_data_entry.py
</code></pre>
    <p class="normal">It should look and act just like <a id="_idIndexMarker491"/>the single script from <em class="chapterRef">Chapter 5</em>, <em class="italic">Reducing User Error with Validation and Automation</em>, and run without errors, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B17578_06_04.png" alt="The application, still looking good!"/></figure>
    <p class="packt_figref">Figure 6.4: The ABQ Data Entry application â€“ still looks the same after MVC refactoring!</p>
    <p class="normal">Success!</p>
    <h1 id="_idParaDest-153" class="title">Using version control software</h1>
    <p class="normal">Our code is <a id="_idIndexMarker492"/>nicely structured for expansion, but there's one more critical item we <a id="_idIndexMarker493"/>should address: <strong class="keyword">version control</strong>. You may <a id="_idIndexMarker494"/>already be familiar with a <strong class="keyword">version control system</strong> (<strong class="keyword">VCS</strong>), sometimes called <strong class="keyword">revision control</strong> or <strong class="keyword">source code management</strong>, but if not, it's an indispensable <a id="_idIndexMarker495"/>tool for dealing with a large and changing code base.</p>
    <p class="normal">When working on an application, we sometimes think we know what needs to be changed, but it turns out we're wrong. Sometimes, we don't know exactly how to code something, and it takes several attempts to find the correct approach. Sometimes, we need to revert to code that was changed a long time ago. Sometimes, we have multiple people working on the same piece of code, and we need to merge their changes together. Version control systems were created to address these issues and more.</p>
    <p class="normal">There are dozens of different version control systems, but most of them follow essentially the same workflow:</p>
    <ul>
      <li class="bullet">You have a <strong class="keyword">working copy</strong> of the code to which you make changes</li>
      <li class="bullet">You periodically select changes and <strong class="keyword">commit</strong> them to a <strong class="keyword">master copy</strong></li>
      <li class="bullet">You can <strong class="keyword">checkout</strong> (that is, retrieve into your working copy) older versions of the code at any point, then later revert back to the master copy</li>
      <li class="bullet">You can create <strong class="keyword">branches</strong> of the code to experiment with different approaches, new features, or large refactors</li>
      <li class="bullet">You can later <strong class="keyword">merge</strong> these branches back into the master copy</li>
    </ul>
    <p class="normal">VCS provides a safety net that gives you the freedom to change your code without the fear that you'll hopelessly ruin it: reverting to a known working state is just a few quick commands away. It also helps us to document changes to our code and collaborate with others if the opportunity arises.</p>
    <p class="normal">There are dozens of version control systems available, but by far the most popular for many years now is <strong class="keyword">Git</strong>. Let's take a look at how to use Git to track changes to our application.</p>
    <h2 id="_idParaDest-154" class="title">A super-quick guide to using Git</h2>
    <p class="normal">Git was<a id="_idIndexMarker496"/> created by Linus Torvalds to be the version control software for the Linux kernel project, and has since grown to be the most popular VC software in the world. It is utilized by source sharing sites like GitHub, Bitbucket, SourceForge, and GitLab. Git is<a id="_idIndexMarker497"/> extremely powerful, and mastering it can take months or years; fortunately, the basics can be grasped in a few minutes.</p>
    <p class="normal">First, you'll need to install <a id="_idIndexMarker498"/>Git; visit <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> for instructions on how to install Git on macOS, Windows, Linux, or other Unix operating systems.</p>
    <h3 id="_idParaDest-155" class="title">Initializing and configuring a Git repository</h3>
    <p class="normal">Once Git is <a id="_idIndexMarker499"/>installed, we need to initialize and configure our project directory as a Git repository. To do this, open a command terminal, navigate to the application's root <a id="_idIndexMarker500"/>directory (<code class="Code-In-Text--PACKT-">ABQ_Data_Entry</code>), and run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git init
</code></pre>
    <p class="normal">This command creates a hidden directory under our project root called <code class="Code-In-Text--PACKT-">.git</code> and initializes it with the basic files that make up the repository. The <code class="Code-In-Text--PACKT-">.git</code> directory will contain all the data and metadata about our saved revisions.</p>
    <p class="normal">Before we add any files to the repository, we need to instruct Git to ignore certain kinds of files. For example, Python creates bytecode (<code class="Code-In-Text--PACKT-">.pyc</code>) files whenever it executes a file, and we don't want to save these as part of our code. To do this, create a file in your project root called <code class="Code-In-Text--PACKT-">.gitignore</code> and put the following lines in it:</p>
    <pre class="programlisting code"><code class="hljs-code">*.pyc
__pycache__/
</code></pre>
    <p class="normal">You can add more directory names, filenames, or wildcard patterns to ignore various file types you don't want to save (for example, some editors create temporary files or backup copies by adding particular characters to a filename).</p>
    <h3 id="_idParaDest-156" class="title">Adding and committing code</h3>
    <p class="normal">Now that our<a id="_idIndexMarker501"/> repository has been initialized, we can add files and directories to our Git repository using the <code class="Code-In-Text--PACKT-">git add</code> command, like so:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git add abq_data_entry
$ git add abq_data_entry.py
$ git add docs
$ git add README.rst
</code></pre>
    <p class="normal">At this point, our files have been <strong class="keyword">staged</strong>, but not yet committed to the repository. Because a single change to an application may require altering several files, Git allows you to stage as many files as you wish to be part of a single commit. Note that we can specify directories rather than individual files; in this case, all the files currently inside the directory will be staged for our next commit.</p>
    <p class="normal">You can check the status of your<a id="_idIndexMarker502"/> repository and the files in it at any time by entering the command <code class="Code-In-Text--PACKT-">git status</code>. Try this now and you should get the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">On branch master
No commits yet
Changes to be committed:
(use "git rm --cached &lt;file&gt;..." to unstage)
new file: README.rst
new file: abq_data_entry.py
new file: abq_data_entry/~__init__.py~
new file: abq_data_entry/application.py
new file: abq_data_entry/models.py
new file: abq_data_entry/views.py
new file: abq_data_entry/widgets.py
new file: docs/Application_layout.png
new file: docs/abq_data_entry_spec.rst
new file: docs/lab-tech-paper-form.png
Untracked files:
(use "git add &lt;file&gt;..." to include in what will be committed)
.gitignore
</code></pre>
    <p class="normal">This shows you that all the files under <code class="Code-In-Text--PACKT-">abq_data_entry/</code> and <code class="Code-In-Text--PACKT-">docs/</code>, as well as the files you specified directly, are staged to be committed to the repository.</p>
    <p class="normal">Let's go ahead and commit the changes with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git commit -m "Initial commit"
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">-m</code> flag here allows you to specify a <strong class="keyword">commit message</strong>, which is stored with the commit. Each time you commit code to the repository, you will be required to write a message. You should always make these messages as meaningful as possible, detailing what changes you made and the rationale behind them.</p>
    <h3 id="_idParaDest-157" class="title">Viewing and using our commits</h3>
    <p class="normal">To view your<a id="_idIndexMarker503"/> repository's history, run the <code class="Code-In-Text--PACKT-">git log</code> command, like so:</p>
    <pre class="programlisting con"><code class="hljs-con">$ git log
commit df48707422875ff545dc30f4395f82ad2d25f103 (HEAD -&gt; master)
Author: Alan Moore &lt;alan@example.com&gt;
Date: Thu Dec 21 18:12:17 2017 -0600
Initial commit
</code></pre>
    <p class="normal">As you can see, the <code class="Code-In-Text--PACKT-">Author</code>, <code class="Code-In-Text--PACKT-">Date</code>, and commit message is displayed for our last commit. If we had more commits, they would be listed here as well, from newest to oldest. The long hexadecimal value you see in the first line of<a id="_idIndexMarker504"/> output is the <strong class="keyword">commit hash</strong>, a unique value that identifies the commit. This value can be used to refer to the commit in other operations.</p>
    <p class="normal">For example, we can use it to <a id="_idIndexMarker505"/>reset our repository to a past state. Try this out by following these steps:</p>
    <ol>
      <li class="numbered">Delete the <code class="Code-In-Text--PACKT-">README.rst</code> file, and verify that it's completely gone.</li>
      <li class="numbered">Run <code class="Code-In-Text--PACKT-">git log</code> to get the hash of your last commit.</li>
      <li class="numbered">Now, enter the command <code class="Code-In-Text--PACKT-">git reset --hard df48707</code>, replacing <code class="Code-In-Text--PACKT-">df48707</code> with the first seven characters of your last commit's hash.</li>
      <li class="numbered">Check your file listing again: the <code class="Code-In-Text--PACKT-">README.rst</code> file should be back.</li>
    </ol>
    <p class="normal">What happened here is that we altered our repository, then told Git to <strong class="keyword">hard reset</strong> the state of the repository to the last commit. If you don't want to reset your repository, you can also use <code class="Code-In-Text--PACKT-">git checkout</code> to switch to an old commit temporarily, or use <code class="Code-In-Text--PACKT-">git branch</code> to create a new branch using a particular commit as the base. As you can see already, this gives us a powerful safety net for experimentation; no matter how much you tinker with the code, any commit is just a command away!</p>
    <p class="normal">Git has many more features that are beyond the scope of this book. If you'd like to learn more, the Git project provides a free online manual at <a href="https://git-scm.com/book">https://git-scm.com/book</a>, where you can learn about advanced features like branching and setting up remote repositories. For now, the important thing is to commit changes as you go, so that you maintain your safety net and document the history of changes.</p>
    <h1 id="_idParaDest-158" class="title">Summary</h1>
    <p class="normal">In this chapter, you learned to prepare your simple script for some serious expansion. You learned how to divide your application's areas of responsibility into separate components using the model-view-controller model. You reimplemented the ABQ application as a Python package, splitting the code into multiple modules to further enforce separation of concerns and provide an organized framework for later expansion. Finally, you set up a Git repository for your code so that you can track all your changes with version control.</p>
    <p class="normal">In the next chapter, we're going to put the convenience of our new project layout to the test by implementing file opening and saving, informational popups, and a main menu. You'll also learn how to provide configurable settings for your application and save them to disk.</p>
  </div>
</body></html>