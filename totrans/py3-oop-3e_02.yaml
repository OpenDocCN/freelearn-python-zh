- en: Objects in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的对象
- en: So, we now have a design in hand and are ready to turn that design into a working
    program! Of course, it doesn't usually happen this way. We'll be seeing examples
    and hints for good software design throughout the book, but our focus is object-oriented
    programming. So, let's have a look at the Python syntax that allows us to create
    object-oriented software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在手头有一个设计方案，准备将其转化为一个可工作的程序！当然，事情通常不会这样发生。本书中我们将看到关于良好软件设计的例子和提示，但我们的重点是面向对象编程。那么，让我们看看Python语法，它允许我们创建面向对象的软件。
- en: 'After completing this chapter, we will understand the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，我们将理解以下内容：
- en: How to create classes and instantiate objects in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Python中创建类和实例化对象
- en: How to add attributes and behaviors to Python objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何给Python对象添加属性和行为
- en: How to organize classes into packages and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将类组织到包和模块中
- en: How to suggest that people don't clobber our data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何建议人们不要破坏我们的数据
- en: Creating Python classes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Python类
- en: We don't have to write much Python code to realize that Python is a very *clean* language.
    When we want to do something, we can just do it, without having to set up a bunch
    of prerequisite code. The ubiquitous *hello world* in Python, as you've likely
    seen, is only one line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要写很多Python代码就能意识到Python是一种非常**干净**的语言。当我们想要做某事时，我们只需去做，无需设置一大堆先决条件代码。Python中无处不在的**hello
    world**，正如你可能看到的，只是一行代码。
- en: 'Similarly, the simplest class in Python 3 looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Python 3中最简单的类看起来是这样的：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There's our first object-oriented program! The class definition starts with
    the `class` keyword. This is followed by a name (of our choice) identifying the
    class, and is terminated with a colon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第一个面向对象程序！类定义以`class`关键字开始。随后是一个名称（我们自行选择），用于标识这个类，并以冒号结束。
- en: The class name must follow standard Python variable naming rules (it must start
    with a letter or underscore, and can only be comprised of letters, underscores,
    or numbers). In addition, the Python style guide (search the web for *PEP 8*)
    recommends that classes should be named using **CapWords** notation (start with
    a capital letter; any subsequent words should also start with a capital).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类名必须遵循标准的Python变量命名规则（它必须以字母或下划线开头，并且只能由字母、下划线或数字组成）。此外，Python风格指南（在网络上搜索*PEP
    8*）建议使用**CapWords**命名法（以大写字母开头；任何后续单词也应以大写字母开头）。
- en: The class definition line is followed by the class contents, indented. As with
    other Python constructs, indentation is used to delimit the classes, rather than
    braces, keywords, or brackets, as many other languages use. Also in line with
    the style guide, use four spaces for indentation unless you have a compelling
    reason not to (such as fitting in with somebody else's code that uses tabs for
    indents).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义行后面跟着类的内容，并缩进。与其他Python构造一样，缩进用于界定类，而不是大括号、关键字或括号，正如许多其他语言所使用的。此外，根据风格指南，除非有充分的理由（例如，与使用制表符缩进的他人代码兼容），否则使用四个空格进行缩进。
- en: Since our first class doesn't actually add any data or behaviors, we simply
    use the `pass` keyword on the second line to indicate that no further action needs
    to be taken.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的第一个类实际上没有添加任何数据或行为，我们只需在第二行使用`pass`关键字来表示不需要采取任何进一步的操作。
- en: 'We might think there isn''t much we can do with this most basic class, but
    it does allow us to instantiate objects of that class. We can load the class into
    the Python 3 interpreter, so we can interactively play with it. To do this, save
    the class definition mentioned earlier in a file named `first_class.py` and then
    run the `python -i first_class.py` command. The `-i` argument tells Python to
    *run the code and then drop to the interactive interpreter*. The following interpreter
    session demonstrates a basic interaction with this class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为我们无法对这个最基本的类做太多事情，但它确实允许我们实例化该类的对象。我们可以将这个类加载到Python 3解释器中，这样我们就可以与之交互。为此，将前面提到的类定义保存到一个名为`first_class.py`的文件中，然后运行`python
    -i first_class.py`命令。`-i`参数告诉Python运行代码然后进入交互式解释器。以下解释器会话演示了与这个类的基本交互：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code instantiates two objects from the new class, named `a` and `b`. Creating
    an instance of a class is a simple matter of typing the class name, followed by
    a pair of parentheses. It looks much like a normal function call, but Python knows
    we're *calling* a class and not a function, so it understands that its job is
    to create a new object. When printed, the two objects tell us which class they
    are and what memory address they live at. Memory addresses aren't used much in
    Python code, but here, they demonstrate that there are two distinct objects involved.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从新类中实例化了两个对象，分别命名为 `a` 和 `b`。创建一个类的实例很简单，只需输入类名，然后跟上一对括号。这看起来就像一个正常的函数调用，但
    Python 知道我们正在调用一个类而不是一个函数，因此它理解自己的任务是创建一个新的对象。当打印时，这两个对象会告诉我们它们属于哪个类以及它们所在的内存地址。在
    Python 代码中，内存地址并不常用，但在这里，它们展示了有两个不同的对象参与其中。
- en: Adding attributes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加属性
- en: Now, we have a basic class, but it's fairly useless. It doesn't contain any
    data, and it doesn't do anything. What do we have to do to assign an attribute
    to a given object?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个基本的类，但它相当无用。它不包含任何数据，也不做任何事情。我们该如何给一个特定的对象分配属性？
- en: 'In fact, we don''t have to do anything special in the class definition. We
    can set arbitrary attributes on an instantiated object using dot notation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不需要在类定义中做任何特别的事情。我们可以使用点表示法在实例化的对象上设置任意属性：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we run this code, the two `print` statements at the end tell us the new
    attribute values on the two objects:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，最后的两个 `print` 语句会告诉我们两个对象上的新属性值：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code creates an empty `Point` class with no data or behaviors. Then, it
    creates two instances of that class and assigns each of those instances `x` and
    `y` coordinates to identify a point in two dimensions. All we need to do to assign
    a value to an attribute on an object is use the `<object>.<attribute> = <value>`
    syntax. This is sometimes referred to as **dot notation**. You have likely encountered
    this same notation before when reading attributes on objects provided by the standard library
    or a third-party library. The value can be anything: a Python primitive, a built-in
    data type, or another object. It can even be a function or another class!'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个空的 `Point` 类，没有数据或行为。然后，它创建了该类的两个实例，并将每个实例的 `x` 和 `y` 坐标分配给它们，以标识二维空间中的一个点。要给对象上的属性赋值，我们只需使用
    `<object>.<attribute> = <value>` 语法。这有时被称为 **点表示法**。你可能在阅读标准库或第三方库提供的对象属性时遇到过这种相同的表示法。值可以是任何东西：Python
    原始数据类型、内置数据类型或另一个对象。甚至可以是一个函数或另一个类！
- en: Making it do something
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让它做点什么
- en: Now, having objects with attributes is great, but object-oriented programming
    is really about the interaction between objects. We're interested in invoking
    actions that cause things to happen to those attributes. We have data; now it's
    time to add behaviors to our classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了具有属性的对象，但面向对象编程真正关注的是对象之间的交互。我们感兴趣的是调用动作，这些动作会导致属性发生变化。我们有了数据；现在是我们给我们的类添加行为的时候了。
- en: 'Let''s model a couple of actions on our `Point` class. We can start with a
    **method** called `reset`, which moves the point to the origin (the origin is
    the place where `x` and `y` are both zero). This is a good introductory action
    because it doesn''t require any parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Point` 类上模拟一些动作。我们可以从一个名为 `reset` 的 **方法** 开始，该方法将点移动到原点（原点是 `x` 和 `y`
    都为零的地方）。这是一个很好的入门动作，因为它不需要任何参数：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `print` statement shows us the two zeros on the attributes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `print` 语句显示了属性上的两个零：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Python, a method is formatted identically to a function. It starts with the
    `def` keyword , followed by a space, and the name of the method. This is followed
    by a set of parentheses containing the parameter list (we'll discuss that `self`
    parameter in just a moment), and terminated with a colon. The next line is indented
    to contain the statements inside the method. These statements can be arbitrary
    Python code operating on the object itself and any parameters passed in, as the
    method sees fit.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，方法的格式与函数完全相同。它以 `def` 关键字开始，后面跟一个空格，然后是方法名。接着是一对括号，包含参数列表（我们将在稍后讨论
    `self` 参数），并以冒号结束。下一行缩进以包含方法内的语句。这些语句可以是任意操作对象本身和任何传入参数的 Python 代码，方法可以自行决定。
- en: Talking to yourself
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自言自语
- en: The one difference, syntactically, between methods and normal functions is that
    all methods have one required argument. This argument is conventionally named
    `self`; I've never seen a Python programmer use any other name for this variable
    (convention is a very powerful thing). There's nothing stopping you, however,
    from calling it `this` or even `Martha`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法和普通函数之间，从语法上讲有一个区别，那就是所有方法都有一个必需的参数。这个参数传统上被命名为`self`；我从未见过任何Python程序员为这个变量使用其他名称（惯例是非常强大的）。然而，你当然可以将其命名为`this`或甚至`Martha`。
- en: The `self` argument to a method is a reference to the object that the method
    is being invoked on. We can access attributes and methods of that object as if
    it were any another object. This is exactly what we do inside the `reset` method
    when we set the `x` and `y` attributes of the `self` object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的`self`参数是对调用该方法的对象的引用。我们可以像访问任何其他对象一样访问该对象的属性和方法。这正是我们在`reset`方法内部设置`self`对象的`x`和`y`属性时所做的事情。
- en: Pay attention to the difference between a **class** and an **object** in this
    discussion. We can think of the **method** as a function attached to a class.
    The **self** parameter is a specific instance of that class. When you call the
    method on two different objects, you are calling the same method twice, but passing
    two different **objects** as the **self** parameter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个讨论中要注意**类**和**对象**之间的区别。我们可以将**方法**视为附加到类上的函数。**self**参数是该类的特定实例。当你对两个不同的对象调用方法时，你实际上是两次调用相同的方法，但传递了两个不同的**对象**作为**self**参数。
- en: Notice that when we call the `p.reset()` method, we do not have to pass the
    `self` argument into it. Python automatically takes care of this part for us.
    It knows we're calling a method on the `p` object, so it automatically passes
    that object to the method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用`p.reset()`方法时，我们不需要将其`self`参数传递给它。Python会自动为我们处理这部分。它知道我们正在调用`p`对象的`reset`方法，因此它会自动将那个对象传递给方法。
- en: 'However, the method really is just a function that happens to be on a class.
    Instead of calling the method on the object, we could invoke the function on the
    class, explicitly passing our object as the `self` argument:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，方法实际上只是一个恰好位于类上的函数。我们可以在类上调用函数，而不是在对象上调用方法，并明确传递我们的对象作为`self`参数：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output is the same as in the previous example because, internally, the exact
    same process has occurred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与上一个例子相同，因为内部发生的正是完全相同的过程。
- en: 'What happens if we forget to include the `self` argument in our class definition?
    Python will bail with an error message, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类定义中忘记包含`self`参数会发生什么？Python会抛出一个错误信息，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The error message is not as clear as it could be (Hey, silly, you forgot the
    `self` argument would be more informative). Just remember that when you see an
    error message that indicates missing arguments, the first thing to check is whether
    you forgot `self` in the method definition.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息并不像它本可以那样清晰（嘿，傻瓜，你忘了`self`参数会更具有信息量）。只需记住，当你看到指示缺少参数的错误信息时，首先要检查的是你是否在方法定义中忘记了`self`。
- en: More arguments
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多参数
- en: 'So, how do we pass multiple arguments to a method? Let''s add a new method
    that allows us to move a point to an arbitrary position, not just to the origin.
    We can also include one that accepts another `Point` object as input and returns
    the distance between them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何向方法传递多个参数呢？让我们添加一个新的方法，允许我们将一个点移动到任意位置，而不仅仅是原点。我们还可以包括一个接受另一个`Point`对象作为输入并返回它们之间距离的方法：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `print` statements at the end give us the following output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的`print`语句给出了以下输出：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A lot has happened here. The class now has three methods. The `move` method
    accepts two arguments, `x` and `y`, and sets the values on the `self` object,
    much like the old `reset` method from the previous example. The old `reset` method
    now calls `move`, since a reset is just a move to a specific known location.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情。现在类有三个方法。`move`方法接受两个参数，`x`和`y`，并将这些值设置在`self`对象上，就像上一个例子中的旧`reset`方法一样。旧的`reset`方法现在调用`move`，因为重置实际上是将对象移动到特定的已知位置。
- en: The `calculate_distance` method uses the not-too-complex Pythagorean theorem
    to calculate the distance between two points. I hope you understand the math (`**2`
    means squared, and `math.sqrt` calculates a square root), but it's not a requirement
    for our current focus, learning how to write methods.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_distance`方法使用不太复杂的勾股定理来计算两点之间的距离。我希望你理解数学（`**2`表示平方，`math.sqrt`计算平方根），但这不是我们当前关注的重点，即学习如何编写方法。'
- en: 'The sample code at the end of the preceding example shows how to call a method
    with arguments: simply include the arguments inside the parentheses, and use the
    same dot notation to access the method. I just picked some random positions to
    test the methods. The test code calls each method and prints the results on the
    console. The `assert` function is a simple test tool; the program will bail if
    the statement after `assert` evaluates to `False` (or zero, empty, or `None`).
    In this case, we use it to ensure that the distance is the same regardless of
    which point called the other point''s `calculate_distance` method.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例末尾的示例代码显示了如何带参数调用一个方法：只需在括号内包含参数，并使用相同的点符号来访问方法。我只是随机选择了一些位置来测试方法。测试代码调用每个方法并在控制台上打印结果。`assert`函数是一个简单的测试工具；如果`assert`后面的语句评估为`False`（或零、空或`None`），程序将退出。在这种情况下，我们使用它来确保距离无论哪个点调用另一个点的`calculate_distance`方法都是相同的。
- en: Initializing the object
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化对象
- en: If we don't explicitly set the `x` and `y` positions on our `Point` object,
    either using `move` or by accessing them directly, we have a broken point with
    no real position. What will happen when we try to access it?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确设置我们的`Point`对象的`x`和`y`位置，无论是使用`move`还是直接访问它们，我们就会得到一个没有实际位置的损坏点。当我们尝试访问它时会发生什么？
- en: 'Well, let''s just try it and see. *Try it and see* is an extremely useful tool
    for Python study. Open up your interactive interpreter and type away. The following
    interactive session shows what happens if we try to access a missing attribute.
    If you saved the previous example as a file or are using the examples distributed
    with the book, you can load it into the Python interpreter with the `python -i
    more_arguments.py` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，让我们试一试看看。*试一试看看*是Python学习的一个极其有用的工具。打开你的交互式解释器并开始输入。以下交互会话显示了如果我们尝试访问一个缺失的属性会发生什么。如果你将前面的示例保存为文件或正在使用与书籍一起分发的示例，你可以使用`python
    -i more_arguments.py`命令将其加载到Python解释器中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Well, at least it threw a useful exception. We'll cover exceptions in detail
    in [Chapter 4](04b8e2ea-599a-4bd0-abf7-4276eab787e0.xhtml), *Expecting the Unexpected*.
    You've probably seen them before (especially the ubiquitous SyntaxError, which
    means you typed something incorrectly!). At this point, simply be aware that it
    means something went wrong.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，至少它抛出了一个有用的异常。我们将在[第4章](04b8e2ea-599a-4bd0-abf7-4276eab787e0.xhtml)中详细讨论异常，*预料之外的事*。你可能之前见过它们（特别是无处不在的SyntaxError，这意味着你输入了错误的东西！）在这个阶段，只需意识到这意味着出了点问题。
- en: The output is useful for debugging. In the interactive interpreter, it tells
    us the error occurred at line 1, which is only partially true (in an interactive
    session, only one line is executed at a time). If we were running a script in
    a file, it would tell us the exact line number, making it easy to find the offending
    code. In addition, it tells us that the error is an `AttributeError`, and gives
    a helpful message telling us what that error means.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出对于调试很有用。在交互式解释器中，它告诉我们错误发生在第1行，这在一定程度上是正确的（在交互会话中，一次只执行一行）。如果我们在一个文件中运行脚本，它会告诉我们确切的行号，这使得找到有问题的代码变得容易。此外，它告诉我们错误是一个`AttributeError`，并给出一个有用的消息，告诉我们这个错误意味着什么。
- en: We can catch and recover from this error, but in this case, it feels like we
    should have specified some sort of default value. Perhaps every new object should
    be `reset()` by default, or maybe it would be nice if we could force the user
    to tell us what those positions should be when they create the object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以捕捉并从这种错误中恢复，但在这个情况下，感觉我们应该指定某种默认值。也许每个新对象都应该默认调用`reset()`，或者也许如果我们可以强制用户在创建对象时告诉我们这些位置应该是什么，那会更好。
- en: Most object-oriented programming languages have the concept of a **constructor**,
    a special method that creates and initializes the object when it is created. Python
    is a little different; it has a constructor *and* an initializer. The constructor
    function is rarely used, unless you're doing something very exotic. So, we'll
    start our discussion with the much more common initialization method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有**构造函数**的概念，这是一个在对象创建时创建和初始化对象的特殊方法。Python有点不同；它有一个构造函数*和*一个初始化器。构造函数函数很少使用，除非你在做非常特别的事情。因此，我们将从更常见的初始化方法开始讨论。
- en: The Python initialization method is the same as any other method, except it
    has a special name, `__init__`. The leading and trailing double underscores mean
    this is a special method that the Python interpreter will treat as a special case.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python的初始化方法与其他方法相同，只是它有一个特殊名称，`__init__`。开头和结尾的双下划线意味着这是一个特殊方法，Python解释器会将其视为特殊情况。
- en: Never name a method of your own with leading and trailing double underscores.
    It may mean nothing to Python today, but there's always the possibility that the
    designers of Python will add a function that has a special purpose with that name
    in the future, and when they do, your code will break.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不要以双下划线开头和结尾为自己的方法命名。在当今的Python中，这可能没有任何意义，但总是有可能Python的设计者将来会添加一个具有该名称的特殊目的函数，并且当这样做时，你的代码将会出错。
- en: 'Let''s add an initialization function on our `Point` class that requires the
    user to supply `x` and `y` coordinates when the `Point` object is instantiated:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Point`类中添加一个初始化函数，该函数要求用户在实例化`Point`对象时提供`x`和`y`坐标：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, our point can never go without a `y` coordinate! If we try to construct
    a point without including the proper initialization parameters, it will fail with
    a `not enough arguments` error similar to the one we received earlier when we
    forgot the `self` argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的点永远不能没有`y`坐标！如果我们尝试构建一个没有包括适当的初始化参数的点，它将失败并显示一个类似于我们之前忘记`self`参数时收到的`not
    enough arguments`错误。
- en: 'If we don''t want to make the two arguments required, we can use the same syntax
    Python functions use to provide default arguments. The keyword argument syntax
    appends an equals sign after each variable name. If the calling object does not
    provide this argument, then the default argument is used instead. The variables
    will still be available to the function, but they will have the values specified
    in the argument list. Here''s an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望这两个参数是必需的，我们可以使用Python函数提供默认参数的相同语法。关键字参数语法在每个变量名后附加一个等号。如果调用对象没有提供此参数，则使用默认参数。这些变量仍然可用于函数，但它们将具有在参数列表中指定的值。以下是一个示例：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the time, we put our initialization statements in an `__init__` function.
    But as mentioned earlier, Python has a constructor in addition to its initialization
    function. You may never need to use the other Python constructor (in well over
    a decade of professional Python coding, I can only think of two cases where I've
    used it, and in one of them, I probably shouldn't have!), but it helps to know
    it exists, so we'll cover it briefly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们将初始化语句放在`__init__`函数中。但如前所述，Python除了初始化函数外还有一个构造函数。你可能永远不需要使用其他Python构造函数（在超过十年的专业Python编码中，我只能想到两个我使用过的情况，其中之一，我可能根本不应该使用它！），但了解它的存在是有帮助的，所以我们将简要介绍它。
- en: The constructor function is called `__new__` as opposed to `__init__`, and accepts
    exactly one argument; the **class** that is being constructed (it is called *before*
    the object is constructed, so there is no `self` argument). It also has to return
    the newly created object. This has interesting possibilities when it comes to
    the complicated art of metaprogramming, but is not very useful in day-to-day Python.
    In practice, you will rarely, if ever, need to use `__new__`. The `__init__` method
    will almost always be sufficient.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数函数被称为`__new__`而不是`__init__`，它接受恰好一个参数；正在构建的**类**（它在对象构建之前被调用，所以没有`self`参数）。它还必须返回新创建的对象。这在复杂的元编程艺术中具有有趣的潜力，但在日常Python中并不很有用。实际上，你很少需要使用`__new__`。`__init__`方法几乎总是足够的。
- en: Explaining yourself
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释自己
- en: Python is an extremely easy-to-read programming language; some might say it
    is self-documenting. However, when carrying out object-oriented programming, it
    is important to write API documentation that clearly summarizes what each object
    and method does. Keeping documentation up to date is difficult; the best way to
    do it is to write it right into our code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种极其易于阅读的编程语言；有些人可能会说它是自文档化的。然而，在进行面向对象编程时，编写清晰地总结每个对象和方法功能的API文档非常重要。保持文档更新是困难的；最好的方法是将其直接写入我们的代码中。
- en: Python supports this through the use of **docstrings**. Each class, function,
    or method header can have a standard Python string as the first line following
    the definition (the line that ends in a colon). This line should be indented the
    same as the code that follows it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通过使用 **docstrings** 来支持这一点。每个类、函数或方法头都可以有一个标准的 Python 字符串作为定义之后的第一个行（即以冒号结束的行）。这一行应该与随后的代码缩进相同。
- en: Docstrings are simply Python strings enclosed with apostrophes (`'`) or quotation
    marks (`"`) characters. Often, docstrings are quite long and span multiple lines
    (the style guide suggests that the line length should not exceed 80 characters),
    which can be formatted as multi-line strings, enclosed in matching triple apostrophe
    (`'''`) or triple quote (`"""`) characters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Docstrings 是用单引号 (`'`) 或双引号 (`"`) 字符包围的 Python 字符串。通常，docstrings 非常长，跨越多行（风格指南建议行长度不应超过
    80 个字符），可以格式化为多行字符串，用匹配的三重单引号 (`'''`) 或三重引号 (`"""`) 字符包围。
- en: A docstring should clearly and concisely summarize the purpose of the class
    or method it is describing. It should explain any parameters whose usage is not
    immediately obvious, and is also a good place to include short examples of how
    to use the API. Any caveats or problems an unsuspecting user of the API should
    be aware of should also be noted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 docstring 应该清楚地简洁地总结所描述的类或方法的目的。它应该解释任何使用不是立即明显的参数，并且也是包含 API 使用短示例的好地方。任何
    API 的不知情用户应该注意的警告或问题也应被记录。
- en: 'To illustrate the use of docstrings, we will end this section with our completely
    documented `Point` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 docstrings 的使用，我们将以我们完全文档化的 `Point` 类结束本节：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Try typing or loading (remember, it's `python -i point.py`) this file into the
    interactive interpreter. Then, enter `help(Point)<enter>` at the Python prompt.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将此文件（记住，它是 `python -i point.py`）输入到交互式解释器中。然后，在 Python 提示符下输入 `help(Point)<enter>`。
- en: 'You should see nicely formatted documentation for the class, as shown in the
    following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到关于类的格式化文档，如下面的截图所示：
- en: '![](img/a74e0195-2712-4811-acc3-fc6a19732222.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a74e0195-2712-4811-acc3-fc6a19732222.png)'
- en: Modules and packages
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: Now we know how to create classes and instantiate objects. You don't need to
    write too many classes (or non-object-oriented code, for that matter) before you
    start to lose track of them. For small programs, we can just put all our classes
    into one file and add a little script at the end of the file to start them interacting.
    However, as our projects grow, it can become difficult to find the one class that
    needs to be edited among the many classes we've defined. This is where **modules**
    come in. Modules are simply Python files, nothing more. The single file in our
    small program is a module. Two Python files are two modules. If we have two files
    in the same folder, we can load a class from one module for use in the other module.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建类和实例化对象。在你开始失去对它们的跟踪之前，你不需要编写太多的类（或者非面向对象的代码）。对于小型程序，我们只需将所有类放入一个文件中，并在文件末尾添加一个小脚本以启动它们之间的交互。然而，随着我们的项目增长，在定义的许多类中找到需要编辑的一个类可能会变得困难。这就是
    **模块** 发挥作用的地方。模块只是 Python 文件，没有更多。我们小型程序中的单个文件是一个模块。两个 Python 文件是两个模块。如果我们有同一文件夹中的两个文件，我们可以在另一个模块中使用来自一个模块的类。
- en: 'For example, if we are building an e-commerce system, we will likely be storing
    a lot of data in a database. We can put all the classes and functions related
    to database access into a separate file (we''ll call it something sensible: `database.py`).
    Then, our other modules (for example, customer models, product information, and
    inventory) can import classes from that module in order to access the database.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在构建一个电子商务系统，我们可能会在数据库中存储大量数据。我们可以将所有与数据库访问相关的类和函数放入一个单独的文件中（我们将它命名为有意义的名称：`database.py`）。然后，我们的其他模块（例如，客户模型、产品信息和库存）可以从中导入类以访问数据库。
- en: The `import` statement is used for importing modules or specific classes or
    functions from modules. We've already seen an example of this in our `Point` class
    in the previous section. We used the `import` statement to get Python's built-in
    `math` module and use its `sqrt` function in the `distance` calculation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句用于导入模块或从模块中导入特定的类或函数。我们已经在上一节中的 `Point` 类中看到了一个例子。我们使用 `import`
    语句来获取 Python 的内置 `math` 模块，并在 `distance` 计算中使用其 `sqrt` 函数。'
- en: Here's a concrete example. Assume we have a module called `database.py`, which
    contains a class called `Database`. A second module called `products.py` is responsible
    for product-related queries. At this point, we don't need to think too much about
    the contents of these files. What we know is that `products.py` needs to instantiate
    the `Database` class from `database.py` so that it can execute queries on the
    product table in the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具体的例子。假设我们有一个名为`database.py`的模块，其中包含一个名为`Database`的类。第二个名为`products.py`的模块负责处理与产品相关的查询。在这个阶段，我们不需要过多考虑这些文件的内容。我们知道的是，`products.py`需要从`database.py`中实例化`Database`类，以便能够在数据库的产品表中执行查询。
- en: 'There are several variations on the `import` statement syntax that can be used
    to access the class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的`import`语句语法变体可以用来访问类：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This version imports the `database` module into the `products` namespace (the
    list of names currently accessible in a module or function), so any class or function
    in the `database` module can be accessed using the `database.<something>` notation.
    Alternatively, we can import just the one class we need using the `from...import`
    syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将`database`模块导入到`products`命名空间（当前在模块或函数中可访问的名称列表）中，因此`database`模块中的任何类或函数都可以使用`database.<something>`的表示法访问。或者，我们可以使用`from...import`语法只导入我们需要的那个类：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If, for some reason, `products` already has a class called `Database`, and
    we don''t want the two names to be confused, we can rename the class when used
    inside the `products` module:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，`products`已经有一个名为`Database`的类，而我们不想这两个名称混淆，我们可以在`products`模块中使用时重命名这个类：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also import multiple items in one statement. If our `database` module
    also contains a `Query` class, we can import both classes using the following
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在一个语句中导入多个项目。如果我们的`database`模块还包含一个`Query`类，我们可以使用以下代码同时导入这两个类：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some sources say that we can import all classes and functions from the `database`
    module using this syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些资料称，我们可以使用这种语法从`database`模块导入所有类和函数：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Don''t do this.** Most experienced Python programmers will tell you that
    you should never use this syntax (a few will tell you there are some very specific
    situations where it is useful, but I disagree). They''ll use obscure justifications
    such as *it clutters up the namespace*, which doesn''t make much sense to beginners.
    One way to learn why to avoid this syntax is to use it and try to understand your
    code two years later. But we can save some time and two years of poorly written
    code with a quick explanation now!'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要这样做**。大多数经验丰富的Python程序员会告诉你永远不应该使用这种语法（有些人会告诉你有一些非常具体的情况这种语法是有用的，但我不同意）。他们会用一些晦涩的理由来辩解，比如*它会使命名空间变得混乱*，这对初学者来说并没有太多意义。学习为什么要避免这种语法的一种方法就是使用它，然后尝试在两年后理解你的代码。但我们可以通过现在快速的解释来节省一些时间和避免两年糟糕的代码！'
- en: When we explicitly import the `database` class at the top of our file using
    `from database import Database`, we can easily see where the `Database` class
    comes from. We might use `db = Database()` 400 lines later in the file, and we
    can quickly look at the imports to see where that `Database` class came from.
    Then, if we need clarification as to how to use the `Database` class, we can visit
    the original file (or import the module in the interactive interpreter and use
    the `help(database.Database)` command). However, if we use the `from database
    import *` syntax, it takes a lot longer to find where that class is located. Code
    maintenance becomes a nightmare.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`from database import Database`在文件顶部显式导入`database`类时，我们可以很容易地看到`Database`类来自哪里。我们可能在文件中的400行后使用`db
    = Database()`，然后我们可以快速查看导入以确定那个`Database`类来自哪里。然后，如果我们需要澄清如何使用`Database`类，我们可以访问原始文件（或在交互式解释器中导入模块并使用`help(database.Database)`命令）。然而，如果我们使用`from
    database import *`语法，找到那个类所在的位置会花费更长的时间。代码维护变得是一场噩梦。
- en: In addition, most code editors are able to provide extra functionality, such
    as reliable code completion, the ability to jump to the definition of a class,
    or inline documentation, if normal imports are used. The `import *` syntax usually
    completely destroys their ability to do this reliably.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数代码编辑器能够提供额外的功能，例如可靠的代码补全、跳转到类的定义或内联文档，如果使用正常的导入语法。`import *`语法通常完全破坏了它们执行这些功能的能力。
- en: Finally, using the `import *` syntax can bring unexpected objects into our local
    namespace. Sure, it will import all the classes and functions defined in the module
    being imported from, but it will also import any classes or modules that were
    themselves imported into that file!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`import *`语法可能会将意外的对象引入我们的本地命名空间。当然，它会导入导入的模块中定义的所有类和函数，但它也会导入任何本身被导入到该文件中的类或模块！
- en: Every name used in a module should come from a well-specified place, whether
    it is defined in that module, or explicitly imported from another module. There
    should be no magic variables that seem to come out of thin air. We should *always*
    be able to immediately identify where the names in our current namespace originated.
    I promise that if you use this evil syntax, you will one day have extremely frustrating
    moments of *where on earth can this class be coming from?*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中使用的每个名称都应该来自一个明确指定的位置，无论是定义在该模块中，还是明确从另一个模块导入。不应该有似乎凭空出现的魔法变量。我们应该始终能够立即识别出我们当前命名空间中名称的来源。我保证，如果你使用这种邪恶的语法，你总有一天会遇到极其令人沮丧的时刻，比如“这个类究竟是从哪里来的？”
- en: For fun, try typing `import this` into your interactive interpreter. It prints
    a nice poem (with a couple of inside jokes you can ignore) summarizing some of
    the idioms that Pythonistas tend to practice. Specific to this discussion, note
    the line *Explicit is better than implicit*. Explicitly importing names into your
    namespace makes your code much easier to navigate than the implicit `import *`
    syntax.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，试着在你的交互式解释器中输入`import this`。它会打印一首优美的诗（其中包含一些可以忽略的内部玩笑），总结了一些Python程序员倾向于实践的习惯用法。针对这次讨论，请注意这一行*明确优于隐晦*。明确将名称导入你的命名空间会使你的代码比隐式的`import
    *`语法更容易导航。
- en: Organizing modules
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块组织
- en: As a project grows into a collection of more and more modules, we may find that
    we want to add another level of abstraction, some kind of nested hierarchy on
    our modules' levels. However, we can't put modules inside modules; one file can
    hold only one file after all, and modules are just files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的增长，成为一个模块集合，我们可能会发现我们想要添加另一个抽象层，在我们的模块级别上的一种嵌套层次结构。然而，我们不能在模块中放置模块；毕竟，一个文件只能包含一个文件，模块只是文件。
- en: Files, however, can go in folders, and so can modules. A **package** is a collection
    of modules in a folder. The name of the package is the name of the folder. We
    need to tell Python that a folder is a package to distinguish it from other folders
    in the directory. To do this, place a (normally empty) file in the folder named
    `__init__.py`. If we forget this file, we won't be able to import modules from
    that folder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文件可以放在文件夹中，模块也是如此。**包**是一个文件夹中模块的集合。包的名称是文件夹的名称。我们需要告诉Python一个文件夹是一个包，以区分目录中的其他文件夹。为此，在文件夹中放置一个（通常是空的）名为`__init__.py`的文件。如果我们忘记这个文件，我们就无法从该文件夹导入模块。
- en: 'Let''s put our modules inside an `ecommerce` package in our working folder,
    which will also contain a `main.py` file to start the program. Let''s additionally
    add another package inside the `ecommerce` package for various payment options.
    The folder hierarchy will look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的模块放在工作文件夹中的`ecommerce`包里，这个文件夹还将包含一个`main.py`文件来启动程序。此外，我们还可以在`ecommerce`包内添加另一个包，用于各种支付选项。文件夹的层次结构将如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When importing modules or classes between packages, we have to be cautious
    about the syntax. In Python 3, there are two ways of importing modules: absolute
    imports and relative imports.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当在包之间导入模块或类时，我们必须小心语法。在Python 3中，有两种导入模块的方式：绝对导入和相对导入。
- en: Absolute imports
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绝对导入
- en: '**Absolute imports** specify the complete path to the module, function, or
    class we want to import. If we need access to the `Product` class inside the `products`
    module, we could use any of these syntaxes to perform an absolute import:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对导入**指定了我们想要导入的模块、函数或类的完整路径。如果我们需要访问`products`模块中的`Product`类，我们可以使用以下任何一种语法进行绝对导入：'
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `import` statements use the period operator to separate packages or modules.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句使用点操作符来分隔包或模块。'
- en: These statements will work from any module. We could instantiate a `Product`
    class using this syntax in `main.py`, in the `database` module, or in either of
    the two payment modules. Indeed, assuming the packages are available to Python,
    it will be able to import them. For example, the packages can also be installed
    in the Python site packages folder, or the `PYTHONPATH` environment variable could
    be customized to dynamically tell Python which folders to search for packages
    and modules it is going to import.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句可以从任何模块中工作。我们可以在`main.py`、`database`模块或两个支付模块中的任何一个中使用这种语法实例化`Product`类。实际上，假设这些包对Python可用，它将能够导入它们。例如，这些包也可以安装在Python站点包文件夹中，或者可以自定义`PYTHONPATH`环境变量，以动态地告诉Python搜索哪些文件夹以查找它将要导入的包和模块。
- en: So, with these choices, which syntax do we choose? It depends on your personal
    taste and the application at hand. If there are dozens of classes and functions
    inside the `products` module that I want to use, I generally import the module
    name using the `from ecommerce import products` syntax, and then access the individual
    classes using `products.Product`. If I only need one or two classes from the `products`
    module, I can import them directly using the `from ecommerce.products import Product`
    syntax. I don't personally use the first syntax very often, unless I have some
    kind of name conflict (for example, I need to access two completely different
    modules called `products` and I need to separate them). Do whatever you think
    makes your code look more elegant.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了这些选择，我们选择哪种语法？这取决于你的个人喜好和手头的应用。如果`products`模块中有几十个类和函数是我想要使用的，我通常使用`from
    ecommerce import products`语法导入模块名称，然后使用`products.Product`访问单个类。如果我只需要从`products`模块中导入一个或两个类，我可以用`from
    ecommerce.products import Product`语法直接导入它们。我个人很少使用第一种语法，除非我有一些名称冲突（例如，我需要访问两个完全不同的名为`products`的模块，并且需要将它们分开）。做你认为可以使你的代码看起来更优雅的事情。
- en: Relative imports
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'When working with related modules inside a package, it seems kind of redundant
    to specify the full path; we know what our parent module is named. This is where
    **relative imports** come in. Relative imports are basically a way of saying find
    a class, function, or module as it is positioned relative to the current module.
    For example, if we are working in the `products` module and we want to import
    the `Database` class from the `database` module next to it, we could use a relative
    import:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当在包内部处理相关模块时，指定完整路径似乎有点多余；我们知道我们的父模块叫什么名字。这就是**相对导入**发挥作用的地方。相对导入基本上是一种找到类、函数或模块的方式，它是相对于当前模块的位置而言的。例如，如果我们正在`products`模块中工作，并且想要从旁边的`database`模块导入`Database`类，我们可以使用相对导入：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The period in front of `database` says *use the database module inside the current
    package*. In this case, the current package is the package containing the `products.py`
    file we are currently editing, that is, the `ecommerce` package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`database`前面的点表示*使用当前包内的数据库模块*。在这种情况下，当前包是我们正在编辑的`products.py`文件所在的包，即`ecommerce`包。'
- en: 'If we were editing the `paypal` module inside the `ecommerce.payments` package,
    we would want, for example, to *use the database package inside the parent package* instead.
    This is easily done with two periods, as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在`ecommerce.payments`包内部编辑`paypal`模块，我们可能希望，例如，*在父包中使用数据库包*。这可以通过两个点轻松完成，如下所示：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use more periods to go further up the hierarchy. Of course, we can also
    go down one side and back up the other. We don''t have a deep enough example hierarchy
    to illustrate this properly, but the following would be a valid import if we had
    an `ecommerce.contact` package containing an `email` module and wanted to import
    the `send_mail` function into our `paypal` module:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的点来进一步向上层结构移动。当然，我们也可以向下移动一边然后再向上移动。我们没有足够深的示例层次结构来正确说明这一点，但如果我们有一个包含`email`模块的`ecommerce.contact`包，并且想要将`send_mail`函数导入我们的`paypal`模块，以下将是一个有效的导入：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This import uses two periods  indicating, *the parent of the payments package*,
    and then uses the normal `package.module` syntax to go back down into the contact
    package.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入使用了两个点，表示*支付包的父包*，然后使用正常的`package.module`语法向下进入联系包。
- en: Finally, we can import code directly from packages, as opposed to just modules
    inside packages. In this example, we have an `ecommerce` package containing two
    modules named `database.py` and `products.py`. The database module contains a
    `db` variable that is accessed from a lot of places. Wouldn't it be convenient
    if this could be imported as `import ecommerce.db` instead of `import ecommerce.database.db`?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以直接从包中导入代码，而不是仅导入包内的模块。在这个例子中，我们有一个名为 `ecommerce` 的包，包含两个名为 `database.py`
    和 `products.py` 的模块。数据库模块包含一个 `db` 变量，它被许多地方访问。如果可以像 `import ecommerce.db` 一样导入，而不是
    `import ecommerce.database.db`，那岂不是更方便？
- en: 'Remember the `__init__.py` file that defines a directory as a package? This
    file can contain any variable or class declarations we like, and they will be
    available as part of the package. In our example, if the `ecommerce/__init__.py`
    file contained the following line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记得定义目录为包的 `__init__.py` 文件吗？这个文件可以包含我们喜欢的任何变量或类声明，它们将作为包的一部分可用。在我们的例子中，如果 `ecommerce/__init__.py`
    文件包含以下行：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We could then access the `db` attribute from `main.py` or any other file using
    the following import:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下导入方式从 `main.py` 或任何其他文件中访问 `db` 属性：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It might help to think of the `__init__.py` file as if it were an `ecommerce.py`
    file, if that file were a module instead of a package. This can also be useful
    if you put all your code in a single module and later decide to break it up into
    a package of modules. The `__init__.py` file for the new package can still be
    the main point of contact for other modules talking to it, but the code can be
    internally organized into several different modules or subpackages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 `__init__.py` 文件想象成如果它是 `ecommerce.py` 文件，那么它将是一个模块而不是包，可能会有所帮助。如果你将所有代码放在一个模块中，后来决定将其拆分成模块包，这也会很有用。新包的
    `__init__.py` 文件仍然可以成为其他模块与之通信的主要接触点，但代码可以内部组织成几个不同的模块或子包。
- en: I recommend not putting much code in an `__init__.py` file, though. Programmers
    do not expect actual logic to happen in this file, and much like with `from x
    import *`, it can trip them up if they are looking for the declaration of a particular
    piece of code and can't find it until they check `__init__.py`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要在 `__init__.py` 文件中放置太多代码。程序员不会期望在这个文件中发生实际逻辑，并且与 `from x import *` 类似，如果他们在寻找特定代码的声明而找不到，直到检查
    `__init__.py`，这可能会让他们感到困惑。
- en: Organizing module content
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织模块内容
- en: 'Inside any one module, we can specify variables, classes, or functions. They
    can be a handy way to store the global state without namespace conflicts. For
    example, we have been importing the `Database` class into various modules and
    then instantiating it, but it might make more sense to have only one `database`
    object globally available from the `database` module. The `database` module might
    look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何单个模块内部，我们可以指定变量、类或函数。它们可以是一个方便的方式来存储全局状态，而不会出现命名空间冲突。例如，我们一直在将 `Database`
    类导入到各个模块中，然后实例化它，但可能更有意义的是，让 `database` 模块全局只有一个 `database` 对象。`database` 模块可能看起来像这样：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we can use any of the import methods we''ve discussed to access the `database`
    object, for example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们讨论过的任何导入方法来访问 `database` 对象，例如：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A problem with the preceding class is that the `database` object is created
    immediately when the module is first imported, which is usually when the program
    starts up. This isn''t always ideal, since connecting to a database can take a
    while, slowing down startup, or the database connection information may not yet
    be available. We could delay creating the database until it is actually needed
    by calling an `initialize_database` function to create a module-level variable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类的问题在于，当模块首次导入时，`database` 对象立即被创建，这通常发生在程序启动时。这并不总是理想的，因为连接到数据库可能需要一段时间，从而减慢启动速度，或者数据库连接信息可能尚未可用。我们可以通过调用一个
    `initialize_database` 函数来延迟创建数据库，直到实际需要时，从而创建一个模块级别的变量：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `global` keyword tells Python that the database variable inside `initialize_database`
    is the module level one we just defined. If we had not specified the variable
    as global, Python would have created a new local variable that would be discarded
    when the method exits, leaving the module-level value unchanged.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`global` 关键字告诉 Python，`initialize_database` 中的数据库变量是我们刚刚定义的模块级别的。如果我们没有指定变量为全局，Python
    将创建一个新的局部变量，该变量在方法退出时将被丢弃，而模块级别的值将保持不变。'
- en: As these two examples illustrate, all module-level code is executed immediately
    at the time it is imported. However, if it is inside a method or function, the
    function will be created, but its internal code will not be executed until the
    function is called. This can be a tricky thing for scripts that perform execution
    (such as the main script in our e-commerce example). Sometimes, we write a program
    that does something useful, and then later find that we want to import a function
    or class from that module into a different program. However, as soon as we import
    it, any code at the module level is immediately executed. If we are not careful,
    we can end up running the first program when we really only meant to access a
    couple of functions inside that module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如这两个示例所示，所有模块级别的代码在导入时都会立即执行。然而，如果它在方法或函数内部，函数将被创建，但其内部代码将不会执行，直到函数被调用。这对于执行脚本的脚本（如我们电子商务示例中的主脚本）来说可能是一个棘手的问题。有时，我们编写了一个有用的程序，然后后来发现我们希望将模块中的函数或类导入到不同的程序中。然而，一旦我们导入它，模块级别的任何代码都会立即执行。如果我们不小心，我们可能会在实际上只想访问该模块中的几个函数时运行第一个程序。
- en: 'To solve this, we should always put our start up code in a function (conventionally,
    called `main`) and only execute that function when we know we are running the
    module as a script, but not when our code is being imported from a different script.
    We can do this by **guarding** the call to `main` inside a conditional statement,
    demonstrated as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们应该始终将启动代码放在一个函数中（传统上称为`main`），并且只有在我们知道正在以脚本方式运行模块时才执行该函数，而不是当我们的代码被从不同的脚本导入时。我们可以通过在条件语句中**保护**对`main`的调用来实现这一点，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Every module has a `__name__` special variable (remember, Python uses double
    underscores for special variables, such as a class's `__init__` method) that specifies
    the name of the module when it was imported. When the module is executed directly
    with `python module.py`, it is never imported, so the `__name__` is arbitrarily
    set to the `"__main__"` string. Make it a policy to wrap all your scripts in an
    `if __name__ == "__main__":` test, just in case you write a function that you
    may want to be imported by other code at some point in the future.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有一个`__name__`特殊变量（记住，Python使用双下划线表示特殊变量，例如类的`__init__`方法），它指定了模块被导入时的名称。当模块直接使用`python
    module.py`执行时，它永远不会被导入，因此`__name__`被任意设置为`"__main__"`字符串。制定一个政策，将所有脚本包裹在`if __name__
    == "__main__":`测试中，以防将来你编写了一个可能希望被其他代码导入的函数。
- en: So, methods go in classes, which go in modules, which go in packages. Is that
    all there is to it?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，方法被放入类中，类被放入模块中，模块被放入包中。这就是全部了吗？
- en: 'Actually, no. This is the typical order of things in a Python program, but
    it''s not the only possible layout. Classes can be defined anywhere. They are
    typically defined at the module level, but they can also be defined inside a function
    or method, like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，不是这样。这是Python程序中事物典型的顺序，但不是唯一的可能布局。类可以定义在任何地方。它们通常在模块级别定义，但也可以在函数或方法内部定义，如下所示：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output would be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `format_string` function accepts a string and optional formatter object,
    and then applies the formatter to that string. If no formatter is supplied, it
    creates a formatter of its own as a local class and instantiates it. Since it
    is created inside the scope of the function, this class cannot be accessed from
    anywhere outside of that function. Similarly, functions can be defined inside
    other functions as well; in general, any Python statement can be executed at any
    time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_string`函数接受一个字符串和可选的格式化对象，然后将格式化器应用于该字符串。如果没有提供格式化器，它将创建一个本地类作为格式化器并实例化它。由于它是在函数的作用域内创建的，因此这个类不能从该函数之外的地方访问。同样，函数也可以在函数内部定义；一般来说，任何Python语句都可以在任何时候执行。'
- en: These inner classes and functions are occasionally useful for one-off items
    that don't require or deserve their own scope at the module level, or only make
    sense inside a single method. However, it is not common to see Python code that
    frequently uses this technique.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内部类和函数偶尔用于一次性项目，这些项目不需要或值得在模块级别拥有自己的作用域，或者只在单个方法内部有意义。然而，在Python代码中频繁使用这种技术并不常见。
- en: Who can access my data?
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁可以访问我的数据？
- en: Most object-oriented programming languages have a concept of **access control**.
    This is related to abstraction. Some attributes and methods on an object are marked
    private, meaning only that object can access them. Others are marked protected,
    meaning only that class and any subclasses have access. The rest are public, meaning
    any other object is allowed to access them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向对象的编程语言都有一个**访问控制**的概念。这与抽象有关。一个对象上的某些属性和方法被标记为私有，意味着只有那个对象可以访问它们。其他的是受保护的，意味着只有那个类及其任何子类可以访问。其余的是公共的，意味着任何其他对象都可以访问它们。
- en: Python doesn't do this. Python doesn't really believe in enforcing laws that
    might someday get in your way. Instead, it provides unenforced guidelines and
    best practices. Technically, all methods and attributes on a class are publicly
    available. If we want to suggest that a method should not be used publicly, we
    can put a note in docstrings indicating that the method is meant for internal
    use only (preferably, with an explanation of how the public-facing API works!).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python不这样做。Python并不真正相信强制执行可能会在未来阻碍你的法律。相反，它提供了未强制执行的指南和最佳实践。技术上，类上的所有方法和属性都是公开可用的。如果我们想建议一个方法不应该公开使用，我们可以在文档字符串中注明该方法仅用于内部使用（最好还附上公共API如何工作的解释！）。
- en: By convention, we should also prefix an internal attribute or method with an
    underscore character, `_`. Python programmers will interpret this as *this is
    an internal variable, think three times before accessing it directly*. But there
    is nothing inside the interpreter to stop them from accessing it if they think
    it is in their best interest to do so. Because, if they think so, why should we
    stop them? We may not have any idea what future uses our classes may be put to.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们还应该用下划线字符`_`作为内部属性或方法的名称前缀。Python程序员会将此解释为“这是一个内部变量，在直接访问之前请三思”。但是，解释器内部没有任何东西可以阻止他们如果他们认为这样做对他们最有利的话去访问它。因为，如果他们认为这样做，我们为什么要阻止他们呢？我们可能根本不知道我们的类将来可能被用于什么目的。
- en: 'There''s another thing you can do to strongly suggest that outside objects
    don''t access a property or method: prefix it with a double underscore, `__`.
    This will perform **name mangling** on the attribute in question. In essence,
    name mangling means that the method can still be called by outside objects if
    they really want to do so, but it requires extra work and is a strong indicator
    that you demand that your attribute remains **private**. Here is an example code
    snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做另一件事来强烈建议外部对象不要访问一个属性或方法：用双下划线`__`作为前缀。这将对该属性执行**名称修改**。本质上，名称修改意味着如果外部对象真的想这样做，它们仍然可以调用该方法，但这需要额外的工作，并且是一个强烈的指示，表明你要求该属性保持**私有**。以下是一个示例代码片段：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we load this class and test it in the interactive interpreter, we can see
    that it hides the plain text string from the outside world:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在交互式解释器中加载这个类并测试它，我们可以看到它隐藏了从外部世界看到的纯文本字符串：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It looks like it works; nobody can access our `plain_string` attribute without
    the passphrase, so it must be safe. Before we get too excited, though, let''s
    see how easy it can be to hack our security:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来好像工作得很好；没有人在没有口令的情况下可以访问我们的`plain_string`属性，所以它应该是安全的。然而，在我们过于兴奋之前，让我们看看要破解我们的安全系统有多容易：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Oh no! Somebody has discovered our secret string. Good thing we checked.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！有人发现了我们的秘密字符串。幸好我们检查了。
- en: This is Python name mangling at work. When we use a double underscore, the property
    is prefixed with `_<classname>`. When methods in the class internally access the
    variable, they are automatically unmangled. When external classes wish to access
    it, they have to do the name mangling themselves. So, name mangling does not guarantee
    privacy; it only strongly recommends it. Most Python programmers will not touch
    a double underscore variable on another object unless they have an extremely compelling
    reason to do so.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python名称修改在起作用。当我们使用双下划线时，属性会被前缀为`_<类名>`。当类内部的方法访问该变量时，它们会自动取消修改。当外部类希望访问它时，它们必须自己进行名称修改。因此，名称修改并不保证隐私；它只是强烈建议。大多数Python程序员不会触摸另一个对象上的双下划线变量，除非他们有极其充分的理由这样做。
- en: However, most Python programmers will not touch a single underscore variable
    without a compelling reason either. Therefore, there are very few good reasons
    to use a name-mangled variable in Python, and doing so can cause grief. For example,
    a name-mangled variable may be useful to an as-yet-unknown subclass, and it would
    have to do the mangling itself. Let other objects access your hidden information
    if they want to. Just let them know, using a single-underscore prefix or some
    clear docstrings, that you think this is not a good idea.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数Python程序员在没有充分理由的情况下不会触碰任何单个下划线变量。因此，在Python中使用名称混淆的变量有很少的好理由，这样做可能会引起麻烦。例如，名称混淆的变量可能对尚未知的子类有用，并且它必须自己进行混淆。如果其他对象想要访问你的隐藏信息，就让它们知道。只需使用单个下划线前缀或一些清晰的文档字符串，表明你认为这不是一个好主意。
- en: Third-party libraries
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方库
- en: 'Python ships with a lovely standard library, which is a collection of packages
    and modules that are available on every machine that runs Python. However, you''ll
    soon find that it doesn''t contain everything you need. When this happens, you
    have two options:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个可爱的标准库，这是一个包含在运行Python的每台机器上的包和模块的集合。然而，你很快会发现它并不包含你需要的所有内容。当这种情况发生时，你有两个选择：
- en: Write a supporting package yourself
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己编写一个支持包
- en: Use somebody else's code
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用他人的代码
- en: 'We won''t be covering the details about turning your packages into libraries,
    but if you have a problem you need to solve and you don''t feel like coding it
    (the best programmers are extremely lazy and prefer to reuse existing, proven
    code, rather than write their own), you can probably find the library you want
    on the **Python Package Index** (**PyPI**) at [http://pypi.python.org/](http://pypi.python.org/).
    Once you''ve identified a package that you want to install, you can use a tool
    called `pip` to install it. However, `pip` does not come with Python, but Python
    3.4 and higher contain a useful tool called `ensurepip`. You can use this command
    to install it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何将你的包转换为库，但如果你有一个需要解决的问题，你不想编写代码（最好的程序员非常懒惰，更喜欢重用现有的、经过验证的代码，而不是自己编写），你可能在[http://pypi.python.org/](http://pypi.python.org/)上的**Python包索引**（**PyPI**）上找到你想要的库。一旦你确定了一个你想要安装的包，你可以使用一个名为`pip`的工具来安装它。然而，`pip`并不包含在Python中，但Python
    3.4及更高版本包含一个有用的工具`ensurepip`。你可以使用以下命令来安装它：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This may fail for you on Linux, macOS, or other Unix systems, in which case,
    you'll need to become a root user to make it work. On most modern Unix systems,
    this can be done with `sudo python -m ensurepip`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Linux、macOS或其他Unix系统上可能会失败，在这种情况下，你需要成为root用户才能使其工作。在大多数现代Unix系统上，这可以通过`sudo
    python -m ensurepip`来完成。
- en: If you are using an older version of Python than Python 3.4, you'll need to
    download and install `pip` yourself, since `ensurepip` isn't available. You can
    do this by following the instructions at: [http://pip.readthedocs.org/](http://pip.readthedocs.org/).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Python 3.4之前的较旧版本的Python，你需要自己下载并安装`pip`，因为`ensurepip`不可用。你可以通过遵循以下说明来完成此操作：[http://pip.readthedocs.org/](http://pip.readthedocs.org/)。
- en: 'Once `pip` is installed and you know the name of the package you want to install,
    you can install it using syntax such as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`pip`安装完成，并且你知道你想要安装的包的名称，你可以使用以下语法安装它：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, if you do this, you'll either be installing the third-party library
    directly into your system Python directory, or, more likely, will get an error
    that you don't have permission to do so. You could force the installation as an
    administrator, but common consensus in the Python community is that you should
    only use system installers to install the third-party library to your system Python
    directory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你这样做，你可能会直接将第三方库安装到你的系统Python目录中，或者更有可能的是，你会得到一个错误，表明你没有权限这样做。你可以作为管理员强制安装，但Python社区中的普遍共识是，你应该只使用系统安装程序将第三方库安装到系统Python目录中。
- en: 'Instead, Python 3.4 (and higher) supplies the `venv` tool. This utility basically
    gives you a mini Python installation called a *virtual environment* in your working
    directory. When you activate the mini Python, commands related to Python will
    work on that directory instead of the system directory. So, when you run `pip`
    or `python`, it won''t touch the system Python at all. Here''s how to use it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Python 3.4（及更高版本）提供了`venv`工具。这个实用工具基本上在你的工作目录中提供了一个名为*虚拟环境*的迷你Python安装。当你激活这个迷你Python时，与Python相关的命令将在该目录上而不是系统目录上工作。因此，当你运行`pip`或`python`时，它根本不会触及系统Python。以下是使用它的方法：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Typically, you'll create a different virtual environment for each Python project
    you work on. You can store your virtual environments anywhere, but I traditionally
    keep mine in the same directory as the rest of my project files (but ignored in
    version control), so first we `cd` into that directory. Then, we run the `venv`
    utility to create a virtual environment named `env`. Finally, we use one of the
    last two lines (depending on the operating system, as indicated in the comments)
    to activate the environment. We'll need to execute this line each time we want
    to use that particular virtualenv, and then use the `deactivate` command when
    we are done working on this project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会为每个你工作的 Python 项目创建一个不同的虚拟环境。你可以将虚拟环境存储在任何地方，但我传统上会将它们保存在与我其他项目文件相同的目录中（但在版本控制中忽略），因此首先我们使用
    `cd` 命令进入该目录。然后，我们运行 `venv` 工具来创建一个名为 `env` 的虚拟环境。最后，我们使用最后两行中的一行（根据注释中的说明，取决于操作系统）来激活环境。每次我们想要使用这个特定的虚拟环境时，都需要执行这一行，然后在完成对这个项目的所有工作后使用
    `deactivate` 命令。
- en: Virtual environments are a terrific way to keep your third-party dependencies
    separate. It is common to have different projects that depend on different versions
    of a particular library (for example, an older website might run on Django 1.8,
    while newer versions run on Django 2.1). Keeping each project in separate virtualenvs
    makes it easy to work in either version of Django. Furthermore, it prevents conflicts
    between system-installed packages and `pip`-installed packages if you try to install
    the same package using different tools.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境是保持第三方依赖项分离的绝佳方式。通常，不同的项目可能依赖于特定库的不同版本（例如，一个较老的网站可能运行在 Django 1.8 上，而新版本则运行在
    Django 2.1 上）。将每个项目放在单独的虚拟环境中，可以轻松地在两种 Django 版本中工作。此外，如果你尝试使用不同的工具安装相同的包，这还可以防止系统安装的包和
    `pip` 安装的包之间的冲突。
- en: There are several third-party tools for managing virtual environments effectively.
    Some of these include `pyenv`, `virtualenvwrapper`, and `conda`. My personal preference
    at the time of writing is `pyenv`, but there is no clear winner here. Do a quick
    web search and see what works for you.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个第三方工具可以有效地管理虚拟环境。其中一些包括 `pyenv`、`virtualenvwrapper` 和 `conda`。在写作本文时，我个人的偏好是
    `pyenv`，但在这里并没有明显的胜者。快速进行网络搜索，看看什么适合你。
- en: Case study
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: To tie it all together, let's build a simple command-line notebook application.
    This is a fairly simple task, so we won't be experimenting with multiple packages.
    We will, however, see common usage of classes, functions, methods, and docstrings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些内容串联起来，让我们构建一个简单的命令行笔记本应用程序。这是一个相当简单的任务，所以我们不会尝试使用多个包。然而，我们将看到类、函数、方法和文档字符串的常见用法。
- en: 'Let''s start with a quick analysis: notes are short memos stored in a notebook.
    Each note should record the day it was written and can have tags added for easy
    querying. It should be possible to modify notes. We also need to be able to search
    for notes. All of these things should be done from the command line.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从快速分析开始：笔记是存储在笔记本中的简短备忘录。每条笔记都应该记录下写作的日期，并且可以添加标签以便于查询。应该能够修改笔记。我们还需要能够搜索笔记。所有这些操作都应该通过命令行完成。
- en: An obvious object is the `Note` object; a less obvious one is a `Notebook` container
    object. Tags and dates also seem to be objects, but we can use dates from Python's
    standard library and a comma-separated string for tags. To avoid complexity, in
    the prototype, we need not define separate classes for these objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的对象是 `Note` 对象；一个不那么明显的是 `Notebook` 容器对象。标签和日期似乎也是对象，但我们可以使用 Python 标准库中的日期和以逗号分隔的字符串作为标签。为了避免复杂性，在原型中，我们不需要为这些对象定义单独的类。
- en: '`Note` objects have attributes for `memo` itself, `tags`, and `creation_date`.
    Each note will also need a unique integer `id` so that users can select them in
    a menu interface. Notes could have a method to modify note content and another
    for tags, or we could just let the notebook access those attributes directly.
    To make searching easier, we should put a `match` method on the `Note` object.
    This method will accept a string and can tell us whether a note matches the string
    without accessing the attributes directly. This way, if we want to modify the
    search parameters (to search tags instead of note contents, for example, or to
    make the search case-insensitive), we only have to do it in one place.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Note`对象具有`memo`本身、`tags`和`creation_date`的属性。每个笔记还需要一个唯一的整数`id`，以便用户可以在菜单界面中选择它们。笔记可以有一个修改笔记内容的方法和另一个修改标签的方法，或者我们可以直接让笔记本访问这些属性。为了使搜索更容易，我们应该在`Note`对象上放置一个`match`方法。此方法将接受一个字符串，并可以告诉我们笔记是否与该字符串匹配，而不直接访问属性。这样，如果我们想修改搜索参数（例如，搜索标签而不是笔记内容，或者使搜索不区分大小写），我们只需在一个地方进行修改。'
- en: The `Notebook` object obviously has the list of notes as an attribute. It will
    also need a search method that returns a list of filtered notes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`Notebook`对象有一个属性列表，它还需要一个搜索方法，该方法返回一个过滤后的笔记列表。
- en: But how do we interact with these objects? We've specified a command-line app,
    which can mean either that we run the program with different options to add or
    edit commands, or we have some kind of menu that allows us to pick different things
    to do to the notebook. We should try to design it such that either interface is
    supported and future interfaces, such as a GUI toolkit or web-based interface,
    could be added in the future.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何与这些对象交互呢？我们指定了一个命令行应用程序，这意味着我们可以通过不同的选项运行程序来添加或编辑命令，或者我们有一个某种类型的菜单，允许我们选择对笔记本执行的不同操作。我们应该尝试设计它，以便支持这两种界面，以及未来可能添加的界面，例如GUI工具包或基于Web的界面。
- en: As a design decision, we'll implement the menu interface now, but will keep
    the command-line options version in mind to ensure we design our `Notebook` class
    with extensibility in mind.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计决策，我们现在将实现菜单界面，但会记住命令行选项版本，以确保我们设计的`Notebook`类具有可扩展性。
- en: If we have two command-line interfaces, each interacting with the `Notebook`
    object, then `Notebook` will need some methods for those interfaces to interact
    with. We need to be able to `add` a new note, and `modify` an existing note by
    `id`, in addition to the `search` method we've already discussed. The interfaces
    will also need to be able to list all notes, but they can do that by accessing
    the `notes` list attribute directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个命令行界面，每个界面都与`Notebook`对象交互，那么`Notebook`将需要一些方法来与这些界面交互。我们需要能够通过`id`添加一个新的笔记，并修改现有的笔记，除了我们已讨论的`search`方法。界面还需要能够列出所有笔记，但它们可以通过直接访问`notes`列表属性来实现。
- en: 'We may be missing a few details, but we have a really good overview of the
    code we need to write. We can summarize all this analysis in a simple class diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遗漏了一些细节，但我们已经对需要编写的代码有一个很好的概述。我们可以将这些分析总结在一个简单的类图中：
- en: '![](img/bd5f4ff6-aaa2-49a3-b133-b89ff97cd02d.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd5f4ff6-aaa2-49a3-b133-b89ff97cd02d.png)'
- en: 'Before writing any code, let''s define the folder structure for this project.
    The menu interface should clearly be in its own module, since it will be an executable
    script, and we may have other executable scripts accessing the notebook in the
    future. The `Notebook` and `Note` objects can live together in one module. These
    modules can both exist in the same top-level directory without having to put them
    in a package. An empty `command_option.py` module can help remind us in the future
    that we were planning to add new user interfaces:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，让我们定义这个项目的文件夹结构。菜单界面应该明显地位于其自己的模块中，因为它将是一个可执行的脚本，我们可能将来会有其他可执行的脚本访问笔记本。`Notebook`和`Note`对象可以生活在同一个模块中。这些模块可以存在于同一个顶级目录中，而无需将它们放入一个包中。一个空的`command_option.py`模块可以帮助我们在未来提醒自己我们计划添加新的用户界面：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s see some code. We start by defining the `Note` class, as it seems
    simplest. The following example presents `Note` in its entirety. Docstrings within
    the example explain how it all fits together, demonstrated as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一些代码。我们首先定义`Note`类，因为它看起来最简单。以下示例展示了`Note`的完整内容。示例中的文档字符串解释了所有这些是如何结合在一起的，如下所示：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before continuing, we should quickly fire up the interactive interpreter and
    test our code so far. Test frequently and often, because things never work the
    way you expect them to. Indeed, when I tested my first version of this example,
    I found out I had forgotten the `self` argument in the `match` function! We''ll
    discuss automated testing in [Chapter 12](ab1b23ea-7665-4745-a2a3-e739252eafb0.xhtml),
    *Testing Object-Oriented Programs*. For now, it suffices to check a few things
    using the interpreter:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该快速启动交互式解释器并测试到目前为止的代码。频繁地测试，因为事情永远不会按照你预期的方向发展。确实，当我测试这个示例的第一个版本时，我发现我在`match`函数中忘记了`self`参数！我们将在[第12章](ab1b23ea-7665-4745-a2a3-e739252eafb0.xhtml)中讨论自动化测试，*面向对象程序的测试*。现在，使用解释器检查几件事情就足够了：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It looks like everything is behaving as expected. Let''s create our notebook
    next:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一切都在按预期运行。让我们创建我们的笔记本：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll clean this up in a minute. First, let''s test it to make sure it works:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一分钟内清理这个。首先，让我们测试它以确保它工作：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It does work. The code is a little messy though; our `modify_tags` and `modify_memo`
    methods are almost identical. That's not good coding practice. Let's see how we
    can improve it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实可以工作。但是代码有点杂乱；我们的`modify_tags`和`modify_memo`方法几乎相同。这不是好的编码实践。让我们看看我们如何可以改进它。
- en: 'Both methods are trying to identify the note with a given ID before doing something
    to that note. So, let''s add a method to locate the note with a specific ID. We''ll
    prefix the method name with an underscore to suggest that the method is for internal
    use only, but, of course, our menu interface can access the method if it wants
    to:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都在对特定ID的笔记进行某些操作之前试图识别该笔记。所以，让我们添加一个方法来定位具有特定ID的笔记。我们将方法名前缀为下划线，以表明该方法仅用于内部使用，但当然，我们的菜单接口可以访问该方法：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This should work for now. Let''s have a look at the menu interface. The interface
    needs to present a menu and allow the user to input choices. Here''s our first
    attempt:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该现在可以工作。让我们看看菜单接口。接口需要显示菜单并允许用户输入选择。这是我们的第一次尝试：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code first imports the notebook objects using an absolute import. Relative
    imports wouldn't work because we haven't placed our code inside a package. The
    `Menu` class's `run` method repeatedly displays a menu and responds to choices
    by calling functions on the notebook. This is done using an idiom that is rather
    peculiar to Python; it is a lightweight version of the command pattern that we
    will discuss in [Chapter 10](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml), *Python
    Design Patterns I*. The choices entered by the user are strings. In the menu's
    `__init__` method, we create a dictionary that maps strings to functions on the
    menu object itself. Then, when the user makes a choice, we retrieve the object
    from the dictionary. The `action` variable actually refers to a specific method,
    and is called by appending empty brackets (since none of the methods require parameters)
    to the variable. Of course, the user might have entered an inappropriate choice,
    so we check if the action really exists before calling it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先使用绝对导入导入笔记本对象。相对导入不会工作，因为我们没有将我们的代码放在一个包内。`Menu`类的`run`方法会重复显示菜单，并通过在笔记本上调用函数来响应用户的选择。这是使用Python中相当独特的一种惯用法完成的；这是一个命令模式的轻量级版本，我们将在[第10章](345fe617-9a90-4c59-9355-e7076759f9a4.xhtml)中讨论，*Python设计模式I*。用户输入的选择是字符串。在菜单的`__init__`方法中，我们创建一个将字符串映射到菜单对象本身的函数的字典。然后，当用户做出选择时，我们从字典中检索对象。`action`变量实际上指向一个特定的方法，通过在变量后附加空括号（因为没有任何方法需要参数）来调用它。当然，用户可能输入了一个不合适的选项，所以在调用它之前，我们需要检查操作是否真的存在。
- en: Each of the various methods request user input and call appropriate methods
    on the `Notebook` object associated with it. For the `search` implementation,
    we notice that after we've filtered the notes, we need to show them to the user,
    so we make the `show_notes` function serve double duty; it accepts an optional
    `notes` parameter. If it's supplied, it displays only the filtered notes, but
    if it's not, it displays all notes. Since the `notes` parameter is optional, `show_notes`
    can still be called with no parameters as an empty menu item.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 各种方法都要求用户输入，并调用与其关联的`Notebook`对象上的适当方法。对于`search`实现，我们注意到在过滤笔记之后，我们需要向用户显示它们，所以我们让`show_notes`函数承担双重任务；它接受一个可选的`notes`参数。如果提供了，它只显示过滤后的笔记，如果没有提供，它显示所有笔记。由于`notes`参数是可选的，`show_notes`仍然可以不带参数作为空菜单项调用。
- en: 'If we test this code, we''ll find that it fails if we try to modify a note.
    There are two bugs, namely:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试此代码，我们会发现如果我们尝试修改笔记，它将失败。有两个错误，即：
- en: The notebook crashes when we enter a note ID that does not exist. We should
    never trust our users to enter correct data!
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们输入一个不存在的笔记ID时，笔记本会崩溃。我们永远不应该相信用户输入正确的数据！
- en: Even if we enter a correct ID, it will crash because the note IDs are integers,
    but our menu is passing a string.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使输入正确的ID，它也会崩溃，因为笔记ID是整数，但我们的菜单传递的是一个字符串。
- en: 'The latter bug can be solved by modifying the `Notebook` class''s `_find_note`
    method to compare the values using strings instead of the integers stored in the
    note, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 后者错误可以通过修改`Notebook`类的`_find_note`方法来解决，使用字符串而不是笔记中存储的整数来比较值，如下所示：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We simply convert both the input (`note_id`) and the note's ID to strings before
    comparing them. We could also convert the input to an integer, but then we'd have
    trouble if the user entered the letter `a` instead of the number `1`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地转换输入（`note_id`）和笔记的ID为字符串，然后再进行比较。我们也可以将输入转换为整数，但如果我们用户输入的是字母`a`而不是数字`1`，我们就会遇到麻烦。
- en: 'The problem with users entering note IDs that don''t exist can be fixed by
    changing the two `modify` methods on the notebook to check whether `_find_note`
    returned a note or not, like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入不存在的笔记ID的问题可以通过将笔记本上的两个`modify`方法更改为检查`_find_note`是否返回笔记来解决，如下所示：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method has been updated to return `True` or `False`, depending on whether
    a note has been found. The menu could use this return value to display an error
    if the user entered an invalid note.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法已更新为根据是否找到笔记返回`True`或`False`。菜单可以使用此返回值在用户输入无效笔记时显示错误。
- en: This code is a bit unwieldy. It would look a bit better if it raised an exception
    instead. We'll cover those in [Chapter 4](04b8e2ea-599a-4bd0-abf7-4276eab787e0.xhtml),
    *Expecting the Unexpected*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点难以控制。如果它抛出一个异常，看起来会更好一些。我们将在[第4章](04b8e2ea-599a-4bd0-abf7-4276eab787e0.xhtml)中介绍这些内容，*预期意外情况*。
- en: Exercises
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write some object-oriented code. The goal is to use the principles and syntax
    you learned in this chapter to ensure you understand the topics we've covered.
    If you've been working on a Python project, go back over it and see whether there
    are some objects you can create and add properties or methods to. If it's large,
    try dividing it into a few modules or even packages and play with the syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一些面向对象的代码。目标是使用你在本章中学到的原则和语法来确保你理解我们涵盖的主题。如果你一直在做Python项目，回顾一下它，看看是否可以创建一些对象并添加属性或方法。如果它很大，尝试将其分成几个模块甚至包，并玩转语法。
- en: If you don't have such a project, try starting a new one. It doesn't have to
    be something you intend to finish; just stub out some basic design parts. You
    don't need to fully implement everything; often, just a `print("this method will
    do something")` is all you need to get the overall design in place. This is called
    **top-down design**, in which you work out the different interactions and describe
    how they should work before actually implementing what they do. The converse,
    **bottom-up design**, implements details first and then ties them all together.
    Both patterns are useful at different times, but for understanding object-oriented
    principles, a top-down workflow is more suitable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样的项目，试着开始一个新的项目。它不一定要是你打算完成的事情；只需草拟一些基本的设计部分。你不需要完全实现一切；通常，只需要一个`print("这个方法将执行某些操作")`就足以确定整体设计。这被称为**自顶向下设计**，在这种设计中，你先确定不同的交互方式，并描述它们应该如何工作，然后再实际实现它们。相反的，**自底向上设计**首先实现细节，然后再将它们全部连接起来。这两种模式在不同的时间都很实用，但为了理解面向对象的原则，自顶向下的工作流程更适合。
- en: 'If you''re having trouble coming up with ideas, try writing a to-do application.
    (Hint: it would be similar to the design of the notebook application, but with
    extra date management methods.) It can keep track of things you want to do each
    day, and allow you to mark them as completed.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想不出点子时，试着编写一个待办事项应用。（提示：它将与笔记本应用的设计类似，但增加了额外的日期管理方法。）它可以跟踪你每天想要做的事情，并允许你标记为已完成。
- en: Now try designing a bigger project. As before, it doesn't have to actually do
    anything, but make sure you experiment with the package and module-importing syntax.
    Add some functions in various modules and try importing them from other modules
    and packages. Use relative and absolute imports. See the difference, and try to
    imagine scenarios where you would want to use each one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试设计一个更大的项目。和之前一样，它实际上不需要做任何事情，但确保你实验一下包和模块导入语法。在各个模块中添加一些函数，并尝试从其他模块和包中导入它们。使用相对和绝对导入。看看区别，并尝试想象你想要使用每种导入方式的情况。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how simple it is to create classes and assign properties
    and methods in Python. Unlike many languages, Python differentiates between a
    constructor and an initializer. It has a relaxed attitude toward access control.
    There are many different levels of scope, including packages, modules, classes,
    and functions. We understood the difference between relative and absolute imports,
    and how to manage third-party packages that don't come with Python.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在Python中创建类以及分配属性和方法是多么简单。与许多语言不同，Python区分了构造函数和初始化器。它对访问控制的态度比较宽松。存在许多不同的作用域级别，包括包、模块、类和函数。我们理解了相对导入和绝对导入之间的区别，以及如何管理不随Python一起提供的第三方包。
- en: In the next chapter, we'll learn how to share implementation using inheritance.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过继承来共享实现。
