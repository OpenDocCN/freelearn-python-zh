<html><head></head><body>
<div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.2.1">Trading Application: What’s Inside?</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Almost any application that implements a trading strategy has a number of more or less standard components. </span><span class="koboSpan" id="kobo.3.2">Let’s first have a quick look at a somewhat generalized architecture of a typical trading application and then go into greater detail on specific points related to the development of a trading strategy </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">using Python.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 1</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Developing Trading Strategies – Why They Are Different</span></em><span class="koboSpan" id="kobo.8.1">, we saw a very generalized diagram of a typical trading application. </span><span class="koboSpan" id="kobo.8.2">Now, we are going to consider its blocks in greater detail. </span><span class="koboSpan" id="kobo.8.3">We will learn how to connect our application to data sources and trading venues, how to retrieve data and check its consistency, and consider important points about trading logic </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">and orders.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">By the end of this chapter, you will understand how to develop the main components of a trading application that is efficient, maintainable, and scalable, and how to avoid typical serious problems that arise due to incorrect market data processing, mistakes in trading logic, and insufficient understanding of the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">trade mechanics.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Have your app talk to the world – the gloomy world of </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">communication protocols</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Retrieving data – garbage in, </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">garbage out</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Trading logic – this is where a small mistake may cost </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">a fortune</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Risk management – your </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">safety belt</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Ordering interfaces – make sure you are </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">understood correctly</span></span></li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.24.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.25.1">You will need Python 3.9 or above to run the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">this chapter.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.27.1">Have your app talk to the world – the gloomy world of communication protocols</span></h1>
<p><span class="koboSpan" id="kobo.28.1">Well, actually, in this section, I could just say, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">“in the world of FX automated trading every setup is unique, so go ask your broker.”</span></em><span class="koboSpan" id="kobo.30.1"> Of course, I am not going to do this but when it </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.31.1">comes to connecting your app to a market maker, </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">electronic communication network</span></strong><span class="koboSpan" id="kobo.33.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.34.1">ECN</span></strong><span class="koboSpan" id="kobo.35.1">), or any other trading venue, always keep in mind what I said at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">As you remember from the previous chapter, the FX market is still the most fragmented one from the trading standpoint; so there should be no surprise that its computerized infrastructure is also very fragmented. </span><span class="koboSpan" id="kobo.37.2">Even though there’s a standard for exchanging financial information, many trading venues use their own dialects, which simply means extra work in cases where you want to use your application with a different broker. </span><span class="koboSpan" id="kobo.37.3">At the same time, many trading venues offer their own APIs and protocols not compatible with anything else so developers never lose their jobs and are perpetually adapting </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">their applications.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Having said all that, let’s start with something that is generally considered the only industry standard for communication used in </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">trading applications.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.41.1">FIX – universal but too flexible</span></h2>
<p><span class="koboSpan" id="kobo.42.1">In my opinion, despite its hard-to-read syntax, </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">financial information exchange</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">FIX</span></strong><span class="koboSpan" id="kobo.46.1">) is the best </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.47.1">choice to start diving into trading communications because its messages can at least be read by a human – thus, debugging and learning our own mistakes will ensure the steepest </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">learning curve.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Unfortunately, FIX is considered a protocol mostly for professional use and is not available out of the box to any trader from any broker. </span><span class="koboSpan" id="kobo.49.2">One of the possible reasons for this discrimination is that FIX allows you to send any instructions and the receiving server checks only syntax but not the meaning of the message. </span><span class="koboSpan" id="kobo.49.3">So, potentially, it may damage not only the trader’s account but even the market itself. </span><span class="koboSpan" id="kobo.49.4">Therefore, most of the biggest market makers, brokers, and banks require professional status from the trader to allow them to </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">use FIX.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">However, there’s good news: many smaller but ambitious FX brokers today offer a lot of formerly institutional-only services to retail traders. </span><span class="koboSpan" id="kobo.51.2">This doesn’t mean that the quality of their business is low: they simply need turnover and it’s clear that automated trading strategies generate it way better than manual traders. </span><span class="koboSpan" id="kobo.51.3">So, in reality, anyone can get access to institutional liquidity from an ECN </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">using FIX.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">Besides that, who knows, maybe one day you will find yourself working with a bank or an investment fund, and then even a general understanding of FIX will help you a lot to further </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">your career.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">So, what is </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">FIX anyway?</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">FIX is an attempt to create a really universal standard that could be used in virtually any situation when you </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.58.1">need to transfer financial-related information. </span><span class="koboSpan" id="kobo.58.2">It is used by banks, brokers, information agencies, and even insurance companies, along with many others. </span><span class="koboSpan" id="kobo.58.3">Of course, such a wide variety of use cases assumes a great degree of flexibility to customize FIX the way you need, and this degree of flexibility paradoxically makes FIX less standard than it aimed </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">to be.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">For example, some trading venues may require various tags (basic elements of the FIX protocol) as mandatory while others don’t. </span><span class="koboSpan" id="kobo.60.2">Some trading venues support limit and stop orders, while others acknowledge only market orders. </span><span class="koboSpan" id="kobo.60.3">So, it will require some refactoring if you want to port your trading app from one broker to another because FIX doesn’t </span><em class="italic"><span class="koboSpan" id="kobo.61.1">require </span></em><span class="koboSpan" id="kobo.62.1">any particular order type to be accepted. </span><span class="koboSpan" id="kobo.62.2">The list may continue but, in essence, the problem is that FIX aims to support </span><em class="italic"><span class="koboSpan" id="kobo.63.1">any </span></em><span class="koboSpan" id="kobo.64.1">market but trading venues use only a </span><em class="italic"><span class="koboSpan" id="kobo.65.1">subset </span></em><span class="koboSpan" id="kobo.66.1">of its tags that are relevant to their market, frequently adapting the standard to </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">their needs.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">I think that it’s best to consider FIX not only as a protocol or API but rather as a special language with a simple syntax that allows you to convey virtually any meaning. </span><span class="koboSpan" id="kobo.68.2">You can also consider it as a framework used to build messages rather than applications and the meaning of the message will depend on the context </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">and environment.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Let’s look at FIX as a protocol in the first place and consider its layers. </span><span class="koboSpan" id="kobo.70.2">It will help you understand the way we work with </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">FIX connections.</span></span></p>
<h3><span class="koboSpan" id="kobo.72.1">Basic connection</span></h3>
<p><span class="koboSpan" id="kobo.73.1">On the transport layer, FIX requires a standard socket connection. </span><span class="koboSpan" id="kobo.73.2">Again, as I mentioned at the beginning </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.74.1">of this section, everything is very individual because various brokers and trading venues may have different requirements for the way clients connect to them. </span><span class="koboSpan" id="kobo.74.2">Normally, you must provide the broker </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.75.1">or the trading venue with an IP address (or range of addresses) to whitelist and connect using a </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Transmission Control Protocol socket</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.78.1">TCP socket</span></strong><span class="koboSpan" id="kobo.79.1">). </span><span class="koboSpan" id="kobo.79.2">Others may require complex authorization mechanisms and even the mandatory use of a VPN. </span><span class="koboSpan" id="kobo.79.3">So, you may want to consult your broker or trading venue </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">for details.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Learning basic low-level networking such as how to establish a socket connection in Python is not the goal of this book, so if you have never done that before I’d recommend </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.82.1">starting with an excellent guide from Real Python (</span><a href="https://realpython.com/python-sockets"><span class="koboSpan" id="kobo.83.1">https://realpython.com/python-sockets</span></a><span class="koboSpan" id="kobo.84.1">), or if you prefer a </span><em class="italic"><span class="koboSpan" id="kobo.85.1">dive or swim</span></em><span class="koboSpan" id="kobo.86.1"> approach based </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.87.1">on language in action with lots of live examples, you can watch this tutorial from Geeks for Geeks (</span><a href="https://www.geeksforgeeks.org/socket-programming-python/"><span class="koboSpan" id="kobo.88.1">https://www.geeksforgeeks.org/socket-programming-python/</span></a><span class="koboSpan" id="kobo.89.1">). </span><span class="koboSpan" id="kobo.89.2">The point is, establishing a socket connection in Python is not rocket science but rather a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">routine procedure.</span></span></p>
<h3><span class="koboSpan" id="kobo.91.1">Tags</span></h3>
<p><span class="koboSpan" id="kobo.92.1">Once a socket connection is established, we’re ready to send and receive some meaningful </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.93.1">information over it. </span><span class="koboSpan" id="kobo.93.2">As with many other protocols, FIX is based on messages. </span><span class="koboSpan" id="kobo.93.3">A FIX message is a plain text (ASCII) string that in turn consists </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.94.1">of blocks (substrings) delimited by a non-printable character 0x01 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">SOH</span></strong><span class="koboSpan" id="kobo.96.1">) without any special ending characters such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">\n</span></strong><span class="koboSpan" id="kobo.98.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">\r</span></strong><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">Each block between delimiters follows a </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">simple syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
TAG=VALUE</span></pre>
<p><span class="koboSpan" id="kobo.103.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">tag</span></strong><span class="koboSpan" id="kobo.105.1"> is a number and its value can be any string that cannot contain the 0x01 character for obvious reasons: it will </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.106.1">be interpreted as a delimiter. </span><span class="koboSpan" id="kobo.106.2">There is one important exception though: in the case that the tag means retrieving data, any value used as data may be an arbitrary sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">of bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">55=EUR/USD</span></strong><span class="koboSpan" id="kobo.110.1"> represents a currency pair, instrument, or symbol (remember, they are all synonyms). </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">40=Limit</span></strong><span class="koboSpan" id="kobo.112.1"> means that the message contains a limit order (see </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.113.1">Chapter 3</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.114.1">, FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.115.1">, for an explanation of types </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">of orders).</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Since the delimiter character 0x01 is non-printable, many authors use special characters to divide tags in a FIX message visually. </span><span class="koboSpan" id="kobo.117.2">I’m sure you’ll agree that it is easier to read a string that is structured </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.119.1">
8=FIX.4.4|9=73|35=A|34=1092|49=TESTSND|52=20220728-07:30:59.643|56=TESTTGT|198=0|108=60|10=133</span></pre>
<p><span class="koboSpan" id="kobo.120.1">Whereas, reading the following string is </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">more difficult:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
8=FIX.4.49=7335=A34=109249=TESTSND52=20220728-07:30:59.64356=TESTTGT198=0108=6010=133</span></pre>
<p><span class="koboSpan" id="kobo.123.1">However, do not </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.124.1">ever use any other delimiter than 0x01 in real </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">FIX messages!</span></span></p>
<h3><span class="koboSpan" id="kobo.126.1">Message structure</span></h3>
<p><span class="koboSpan" id="kobo.127.1">Any FIX message is </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.128.1">composed of the following three </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">logical parts:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.130.1">Standard header</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.131.1">Body</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.132.1">Standard trailer</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.133.1">The standard header always consists of the following three tags sent in this very order and not </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">any other:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">tag 8</span></strong><span class="koboSpan" id="kobo.136.1"> – means that </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.137.1">the message begins and it contains the version of the FIX protocol used by </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">both parties</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">tag 9</span></strong><span class="koboSpan" id="kobo.140.1"> – the message </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">body length</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">tag 35</span></strong><span class="koboSpan" id="kobo.143.1"> – the message type (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">request for quote</span></strong><span class="koboSpan" id="kobo.145.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">order</span></strong><span class="koboSpan" id="kobo.147.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">logon</span></strong><span class="koboSpan" id="kobo.149.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">logout</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.153.1">The standard trailer always ends with tag 10, whose value is the message checksum. </span><span class="koboSpan" id="kobo.153.2">A checksum is a </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.154.1">small piece of data that is returned by a hash function – a function that processes all bits of a meaningful block of data and compresses it according to a special algorithm. </span><span class="koboSpan" id="kobo.154.2">Checksums are used to make sure that a block of data (a message in our case) was delivered without errors. </span><span class="koboSpan" id="kobo.154.3">If you want to learn more about checksums, hash functions, and related matters, I’d recommend starting with an excellent article on Wikipedia (</span><a href="https://en.wikipedia.org/wiki/Checksum"><span class="koboSpan" id="kobo.155.1">https://en.wikipedia.org/wiki/Checksum</span></a><span class="koboSpan" id="kobo.156.1">) that also has references for </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">further reading.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">According to the FIX standard, a tag must have only one occurrence per message. </span><span class="koboSpan" id="kobo.158.2">Messages with multiple occurrences of the same tag will be rejected by the </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">target computer.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Tags must have </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.161.1">a value. </span><span class="koboSpan" id="kobo.161.2">In case no value is specified for any tag, the entire message will be rejected </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">as well.</span></span></p>
<h3><span class="koboSpan" id="kobo.163.1">Sessions</span></h3>
<p><span class="koboSpan" id="kobo.164.1">Working with </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.165.1">FIX is organized in sessions. </span><span class="koboSpan" id="kobo.165.2">A session assumes there are two computers involved: the one that </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.166.1">sends the message (</span><em class="italic"><span class="koboSpan" id="kobo.167.1">sender</span></em><span class="koboSpan" id="kobo.168.1">, the respective tag is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">SenderCompID</span></strong><span class="koboSpan" id="kobo.170.1">) and the </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.171.1">one that receives the message (</span><em class="italic"><span class="koboSpan" id="kobo.172.1">target</span></em><span class="koboSpan" id="kobo.173.1">, the respective tag is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">TargetCompID</span></strong><span class="koboSpan" id="kobo.175.1">). </span><span class="koboSpan" id="kobo.175.2">Normally, the session is initiated by a client </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.176.1">connecting to a server, for example, a trader connecting to the broker or a bank connecting to </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">an ECN.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">A session starts by sending a handshake message from the sender’s computer to the target computer. </span><span class="koboSpan" id="kobo.178.2">In cases where there is a reply from the target computer, this message initiates the session. </span><span class="koboSpan" id="kobo.178.3">This message type (tag 35) is </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Logon (A)</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">A sample handshake message header will look </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
8=FIX.4.4|9=XX|35=A</span></pre>
<p><span class="koboSpan" id="kobo.183.1">In the preceding message, </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">XX</span></strong><span class="koboSpan" id="kobo.185.1"> stands for the entire message length (see an explanation of tag 9 in the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.186.1">Message</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.187.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Now, we have come to the point where my initial thesis (go and ask your broker for details) becomes apparent. </span><span class="koboSpan" id="kobo.188.2">The problem is that, apart from these three mandatory tags and the ending tag 10, all other tags in a logon message are optional. </span><span class="koboSpan" id="kobo.188.3">This means that I cannot tell you what you should include there; nor can any other author – except for your broker because it is they who decide what should be sent and in which sequence. </span><span class="koboSpan" id="kobo.188.4">So, the best way of learning it is by referring to the documentation obtained from the very trading venue to which you want to send </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">your messages.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">Any FIX session ends with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">Logout (5)</span></strong><span class="koboSpan" id="kobo.192.1"> message, which in its minimal form looks </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
8=FIX.4.4|9=5|35=5|10=166</span></pre>
<h3><span class="koboSpan" id="kobo.195.1">Constructing messages</span></h3>
<p><span class="koboSpan" id="kobo.196.1">At this point, I would </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.197.1">like to warn you against making a very common mistake made by many developers of trading strategies. </span><span class="koboSpan" id="kobo.197.2">They think that there’s only a limited set of FIX messages that their application may generate; therefore, they hardcode them as strings and pick the appropriate one when they need to send </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">an order.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Do not do this! </span><span class="koboSpan" id="kobo.199.2">Here are the following reasons why you shouldn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">do this:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.201.1">First, this approach makes your code non-scalable. </span><span class="koboSpan" id="kobo.201.2">In cases where you need to add a new tag for a new order type, you need to re-write the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">entire application.</span></span></li>
<li><span class="koboSpan" id="kobo.203.1">Second, this makes your code non-portable. </span><span class="koboSpan" id="kobo.203.2">In cases where you want to use it with another broker, this broker can require a particular set of tags in a logon message or anywhere else, and again – you will have to re-write </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">your app.</span></span></li>
<li><span class="koboSpan" id="kobo.205.1">Finally, even though you may think that you remember the meaning of every FIX tag by heart, believe me, this is a </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">dangerous self-delusion!</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.207.1">So, the reasonable way of constructing a FIX message in Python would be to build it block by block </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.208.1">using explicit, human-readable names of tags instead of just numbers. </span><span class="koboSpan" id="kobo.208.2">We’re going to use a native Python dictionary for </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">this purpose:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.210.1">Let’s start by forming a basic FIX dictionary that associates tags with their respective names. </span><span class="koboSpan" id="kobo.210.2">We will use names as keys and tag numbers as values because this is the way we want to build </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">our messages:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.212.1">
fixdict = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
fixdict["start"]="8"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
fixdict["body_len"] = "9"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.215.1">
fixdict["checksum"] = "10"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.216.1">
fixdict["msg_type"] = "35"</span></pre></li>
<li><span class="koboSpan" id="kobo.217.1">Now, we need a function that binds tags together in a message. </span><span class="koboSpan" id="kobo.217.2">Don’t forget that messages may differ significantly in the number of included tags so we will want to use one of Python’s most powerful features – </span><em class="italic"><span class="koboSpan" id="kobo.218.1">arbitrary </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.219.1">keyword argument</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
def compose_message(fix_dictionary, **kwargs):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.222.1">
    msg = ""</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.223.1">
    for arg in kwargs:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.224.1">
        msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.225.1">
    return msg</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.226.1">Here, we assume that we pass keyword arguments as pairs of </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">&lt;tag_name&gt;=VALUE</span></strong><span class="koboSpan" id="kobo.228.1"> and then use the dictionary to replace human-readable names with standard FIX </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">tag numbers.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.230.1">Let’s test our code with the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">following instruction:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.232.1">
message = compose_message(fixdict, start="FIX.4.4", body_len="25", msg_type="A", checksum="56")</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.233.1">We will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">following result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.235.1">
8=FIX.4.49=2535=A10=56</span></pre>
<p><span class="koboSpan" id="kobo.236.1">Note </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.237.1">that SOH characters are not visible in this output but if we explicitly request the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">message</span></strong><span class="koboSpan" id="kobo.239.1"> variable, it will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
In[28]: message
Out[28]: '8=FIX.4.4\x019=25\x013
5=A\x0110=56\x01'</span></pre>
<p><span class="koboSpan" id="kobo.242.1">Here, the non-printable character is </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">clearly visible.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">However, it is not reasonable to pass the standard header manually each time we need to compose the message. </span><span class="koboSpan" id="kobo.244.2">So, we need to include it in </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">With the first tag, </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">8</span></strong><span class="koboSpan" id="kobo.248.1">, it’s simple. </span><span class="koboSpan" id="kobo.248.2">We can store the value in a special variable and add it at the last stage of the process of composing a message. </span><span class="koboSpan" id="kobo.248.3">The first tag always contains only the version of the FIX protocol. </span><span class="koboSpan" id="kobo.248.4">But anyway, we should calculate the length of the message body and the checksum and include them (the length and the checksum) in tags </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">9</span></strong><span class="koboSpan" id="kobo.250.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">, respectively.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.253.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.254.1">Do not confuse the message body with the message itself! </span><span class="koboSpan" id="kobo.254.2">Tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">9</span></strong><span class="koboSpan" id="kobo.256.1"> means the length of only the message body, that is, between tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">9</span></strong><span class="koboSpan" id="kobo.258.1"> and tag </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">10</span></strong><span class="koboSpan" id="kobo.260.1">. </span><span class="koboSpan" id="kobo.260.2">In our example, the message body length is </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">5</span></strong><span class="koboSpan" id="kobo.262.1"> (not </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">4</span></strong><span class="koboSpan" id="kobo.264.1"> because the body consists of characters </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">3</span></strong><span class="koboSpan" id="kobo.266.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">5</span></strong><span class="koboSpan" id="kobo.268.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">=</span></strong><span class="koboSpan" id="kobo.270.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">A</span></strong><span class="koboSpan" id="kobo.272.1">, and one </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">non-printable 0x01).</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">The easiest way of implementing the calculation of the body length is restricting provision tags in </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">**kwargs</span></strong><span class="koboSpan" id="kobo.276.1"> to just the message body. </span><span class="koboSpan" id="kobo.276.2">This can be done in a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">of ways:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.278.1">Let’s start by using a list that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">call </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">fix_exceptions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.282.1">
fix_exceptions = ["8", "9", "10"]</span></pre></li>
<li><span class="koboSpan" id="kobo.283.1">We will then add tags to our composing message only when they are not in the list </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">of exceptions:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.285.1">
if fix_dictionary[arg] not in fix_exceptions:</span></pre></li>
<li><span class="koboSpan" id="kobo.286.1">Now, the </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.287.1">new version of our message-composing function will look </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.289.1">
def compose_message(fix_dictionary, fix_exceptions, **kwargs):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
    msg = ""</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.291.1">
    for arg in kwargs:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.292.1">
        if fix_dictionary[arg] not in fix_exceptions:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
            msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
    return msg</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.295.1">If we test it using the preceding parameters, we will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
35=A</span></pre>
<p><span class="koboSpan" id="kobo.298.1">Tags 8, 9, and 10 are now ignored because they are in the list of exceptions. </span><span class="koboSpan" id="kobo.298.2">Since tags related to the standard header and standard trailer are ignored, whatever is not ignored remains in the </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">message body.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.300.1">Great, we can now calculate its length and add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">the message:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.302.1">
msg = fix_dictionary["body_len"] + "=" + str(len(msg)) + msg</span></pre></li>
<li><span class="koboSpan" id="kobo.303.1">Now, let’s add </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">tag </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">8</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.307.1">
msg = fix_dictionary["start"] + "FIX.4.4"</span></pre></li>
<li><span class="koboSpan" id="kobo.308.1">Finally, in the following code we sum all ASCII codes of all characters in the string, then divide this sum by 256 and take the remainder (we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">reduce</span></strong><span class="koboSpan" id="kobo.310.1"> function here, which is part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">functools</span></strong><span class="koboSpan" id="kobo.312.1">, so should be imported as </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">from functools </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">import reduce</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.316.1">
checksum = reduce(lambda x, y: x + y, list(map(ord, msg)) % 256)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.317.1">We will </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.318.1">then add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the message:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
msg += fix_dictionary["checksum"] + "=" + str(checksum)</span></pre>
<p><span class="koboSpan" id="kobo.321.1">Let’s now see the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">upgraded code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
from functools import reduce
fixdict = {}
fixdict["start"]="8"
fixdict["body_len"] = "9"
fixdict["checksum"] = "10"
fixdict["msg_type"] = "35"
exceptions = ["8", "9", "10"]
def compose_message(fix_dictionary, fix_exceptions, **kwargs):
    msg = ""
    for arg in kwargs:
        if fix_dictionary[arg] not in fix_exceptions:
            msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"
    msg = fix_dictionary["body_len"] + "=" + str(len(msg)) + msg
    msg = fix_dictionary["start"] + "=" + "FIX.4.4" + msg
    checksum = reduce(lambda x, y: x + y, list(map(ord, msg))) % 256
    msg += fix_dictionary["checksum"] + "=" + str(checksum)
    return msg</span></pre>
<p><span class="koboSpan" id="kobo.324.1">Now, let’s test it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">following input:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
message = compose_message(fixdict, exceptions, start="wrong version", body_len="10000", msg_type="A", checksum="78909")</span></pre>
<p><span class="koboSpan" id="kobo.327.1">We will still get the </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">correct output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">
8=FIX.4.49=535=A10=178</span></pre>
<p><span class="koboSpan" id="kobo.330.1">Note that all tags found in the list of exceptions are ignored and their ridiculous values are not </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.331.1">included in the message – which is great because otherwise such a message will be rejected (in the best case). </span><span class="koboSpan" id="kobo.331.2">Moreover, now we can safely omit all tags but the body when we call the following function, which will give us exactly the same result </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">as before:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
message = compose_message(fixdict, exceptions, msg_type="5")</span></pre>
<h3><span class="koboSpan" id="kobo.334.1">What to do next</span></h3>
<p><span class="koboSpan" id="kobo.335.1">If you work with FIX, you definitely need a reference that has a comprehensive dictionary of all tags with explanations of their meaning. </span><span class="koboSpan" id="kobo.335.2">One of the best resources is OnixS (they develop SDKs for direct market access, so no wonder FIX plays the central role in their products), which can be found at </span><a href="https://www.onixs.biz/fix-dictionary.html"><span class="koboSpan" id="kobo.336.1">https://www.onixs.biz/fix-dictionary.html</span></a><span class="koboSpan" id="kobo.337.1">. </span><span class="koboSpan" id="kobo.337.2">If you plan to work with FIX professionally, I definitely recommend visiting the official website of the FIX community at </span><a href="https://www.fixtrading.org"><span class="koboSpan" id="kobo.338.1">https://www.fixtrading.org</span></a><span class="koboSpan" id="kobo.339.1"> and checking the </span><em class="italic"><span class="koboSpan" id="kobo.340.1">Standards</span></em><span class="koboSpan" id="kobo.341.1"> section, where you can find information on technical standards, specifications, and a link to </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">FIX GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.343.1">When it comes to professional utilization of FIX, the most important and de facto industry-standard solution is QuickFIX (</span><a href="https://quickfixengine.org"><span class="koboSpan" id="kobo.344.1">https://quickfixengine.org</span></a><span class="koboSpan" id="kobo.345.1">). </span><span class="koboSpan" id="kobo.345.2">It features implementations </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.346.1">of the FIX protocol for many languages, including Python, and simplifies the development of messaging and data retrieval for trading applications by relieving the developer of the burden of low-level composing </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">FIX messages.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">There are also several ready-made FIX implementations for Python, of which Simplefix (</span><a href="https://pypi.org/project/simplefix/"><span class="koboSpan" id="kobo.349.1">https://pypi.org/project/simplefix/</span></a><span class="koboSpan" id="kobo.350.1">) is probably the most straightforward. </span><span class="koboSpan" id="kobo.350.2">It doesn’t implement a </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.351.1">socket connection or any other transport layer functionality, nor does it support logging or ensure message persistence. </span><span class="koboSpan" id="kobo.351.2">It only serves as a convenient wrapper for encoding and decoding FIX messages with </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">easy-to-read functions.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">It’s also worth mentioning another protocol built on top of FIX. </span><span class="koboSpan" id="kobo.353.2">It is called </span><strong class="bold"><span class="koboSpan" id="kobo.354.1">FAST</span></strong><span class="koboSpan" id="kobo.355.1">, which stands for </span><strong class="bold"><span class="koboSpan" id="kobo.356.1">FIX Adapted for STreaming</span></strong><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">In simple terms, this protocol is designed to facilitate fast and </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.358.1">a large volume of messaging without generating excessive processing overhead or latency. </span><span class="koboSpan" id="kobo.358.2">If you’re interested in learning more about FAST, I’d recommend starting with the official documentation (</span><a href="https://www.fixtrading.org/standards/fast/"><span class="koboSpan" id="kobo.359.1">https://www.fixtrading.org/standards/fast/</span></a><span class="koboSpan" id="kobo.360.1">) and </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.361.1">also having a look at a FIX Fast tutorial </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">at </span></span><a href="https://jettekfix.com/education/fix-fast-tutorial/"><span class="No-Break"><span class="koboSpan" id="kobo.363.1">https://jettekfix.com/education/fix-fast-tutorial/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Now that you know </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.366.1">how to compose FIX messages, you just need to fill them with meaning. </span><span class="koboSpan" id="kobo.366.2">That is, you need to add any trading logic that is most likely based on market data, generate orders, transform them into FIX messages, and send them to the broker, an ECN, or elsewhere. </span><span class="koboSpan" id="kobo.366.3">You also need to be able to receive and understand replies to your messages. </span><span class="koboSpan" id="kobo.366.4">For example, your broker may respond with </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">8=8</span></strong><span class="koboSpan" id="kobo.368.1"> in the message body, which means that your order is successfully filled (message type 8 means order execution report and value 8 means </span><em class="italic"><span class="koboSpan" id="kobo.369.1">order filled</span></em><span class="koboSpan" id="kobo.370.1">). </span><span class="koboSpan" id="kobo.370.2">The broker may send you back </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">8=5</span></strong><span class="koboSpan" id="kobo.372.1"> which will mean that your order is rejected and your code should be able to handle situations of </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">this kind.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">What if your broker doesn’t support FIX or doesn’t provide non-professional traders with access to it? </span><span class="koboSpan" id="kobo.374.2">At this point, we, unfortunately, return to my statement at the very beginning of this chapter</span><em class="italic"><span class="koboSpan" id="kobo.375.1">, “in the world of FX automated trading, every setup is unique so go ask your broker.”</span></em><span class="koboSpan" id="kobo.376.1"> As we saw previously, even in a highly standardized FIX protocol, there is still a certain degree of flexibility so it’s always best to read the documentation provided by the very trading venue to which you plan to send orders. </span><span class="koboSpan" id="kobo.376.2">With proprietary protocols, it’s even worse because there is no standard and every broker offers their own API designed the way they think </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">is best.</span></span></p>
<p><span class="koboSpan" id="kobo.378.1">However, the most important thing for you to conclude from this section is that any protocol, any API, and any framework only serves to deliver a certain message, in most cases a trading order, and to receive the reply. </span><span class="koboSpan" id="kobo.378.2">If you design your trading application so that you have independent interfaces between data processing, trading logic, risk management, and ordering modules, you will be able to switch from one protocol to another without rewriting the entire application – and this is what we’re going to learn more about in </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Now that we are more familiar with the means of exchanging information between your application and a trading venue, it’s time to learn </span><em class="italic"><span class="koboSpan" id="kobo.381.1">what </span></em><span class="koboSpan" id="kobo.382.1">we can send and retrieve from there. </span><span class="koboSpan" id="kobo.382.2">Let’s start with </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">market data.</span></span></p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.384.1">Retrieving data – garbage in, garbage out</span></h1>
<p><span class="koboSpan" id="kobo.385.1">The FIX protocol is universal by design and thus can be used not only for </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.386.1">ordering but also for data </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.387.1">retrieval. </span><span class="koboSpan" id="kobo.387.2">However, in most cases, it is not actually used for market data transfer; instead, trading venues provide their own proprietary APIs to retrieve data </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">from there.</span></span></p>
<p><span class="koboSpan" id="kobo.389.1">As always, in this </span><em class="italic"><span class="koboSpan" id="kobo.390.1">gloomy world</span></em><span class="koboSpan" id="kobo.391.1"> of communication protocols, everything is individual and each trading venue offers its own API. </span><span class="koboSpan" id="kobo.391.2">However, in general, all broker APIs are implemented as REST or Websockets. </span><span class="koboSpan" id="kobo.391.3">The former is convenient for occasional requests for quotes, while the latter is best for continuous subscriptions that allow receiving real-time </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">market data.</span></span></p>
<p><span class="koboSpan" id="kobo.393.1">The following examples I provide are taken from the API of LMAX, one of the key ECNs in the FX market. </span><span class="koboSpan" id="kobo.393.2">They are not only great because of their openness to any client, big or small, but also </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.394.1">because they are one of the very few trading venues that publicly disseminate real-time market data – and they do it completely free </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">of charge.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">Before you start working with FX market data you should understand and always remember one </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">important thing:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.398.1">Data in demo environments is always different from that in a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.399.1">live environment.</span></em></span></p>
<p><span class="koboSpan" id="kobo.400.1">This means that if you receive public data or open a demo account with an ECN to receive market data from there, you should be ready to see quotes that are slightly different from the </span><em class="italic"><span class="koboSpan" id="kobo.401.1">real</span></em><span class="koboSpan" id="kobo.402.1"> market. </span><span class="koboSpan" id="kobo.402.2">The good news is that this difference is not significant; in our particular example with LMAX, it is normally 0.1 to 0.5 pips with a probable slight increase in difference closer to the New York bank settlement time (5 P.M. </span><span class="koboSpan" id="kobo.402.3">New York time – see the </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Trading the FX market: what and how</span></em><span class="koboSpan" id="kobo.404.1"> section in </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.405.1">Chapter 3</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.406.1">, FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.407.1">). </span><span class="koboSpan" id="kobo.407.2">So, even this publicly available data is good for most development and even for </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">live trading.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">In cases where you need only a quote here and a quote there from time to time, then mostly LMAX's REST API is the way to go </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">for you.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">As with any regular REST API, it supports a few endpoints that allow retrieving market price data both as the last trade price and as the top of the order book. </span><span class="koboSpan" id="kobo.411.2">It also supports retrieving information about all instruments (symbols) supported by the LMAX </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">demo server.</span></span></p>
<p><span class="koboSpan" id="kobo.413.1">In order to retrieve such a list, let’s execute </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
curl -i -X GET "https://public-data-api.london-demo.lmax.com/v1/instruments"</span></pre>
<p><span class="koboSpan" id="kobo.416.1">The response will deliver us a JSON with the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">available instruments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.418.1">
[{"instrument_id":"eur-usd","symbol":"EUR/USD","security_id":"4001","currency":"USD","unit_of_measure":"EUR","asset_class":"CURRENCY","quantity_increment":"1000.0000","price_increment":"0.000010","ticker_enabled":true},...]</span></pre>
<p><span class="koboSpan" id="kobo.419.1">I removed the remainder of the JSON to keep it compact but the rest is just repetitions of similar records for other instruments. </span><span class="koboSpan" id="kobo.419.2">Let’s parse this answer to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">its components:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">instrument_id</span></strong><span class="koboSpan" id="kobo.422.1">: This is the name of the FX instrument supported by the LMAX demo server in </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.423.1">the correct notation (note that no slashes </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">/</span></strong><span class="koboSpan" id="kobo.425.1"> are allowed in the names, so they are replaced with a </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">dash </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.427.1">-</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">asset_class</span></strong><span class="koboSpan" id="kobo.430.1">: Most </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.431.1">of the instruments traded at this ECN are currencies but there are also </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">contracts for difference</span></strong><span class="koboSpan" id="kobo.433.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.434.1">CFDs</span></strong><span class="koboSpan" id="kobo.435.1">) on metals and energies, so </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">be careful.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">quantity_increment</span></strong><span class="koboSpan" id="kobo.438.1">: This is the minimum </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">quant</span></strong><span class="koboSpan" id="kobo.440.1"> of the order size; an increment of 1,000.000 euros means that you can send an order to buy or sell 1,003,000 euros for just 2,000 EURUSD, but not 1,003,300 or </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">1,100,301 euros.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">price_increment</span></strong><span class="koboSpan" id="kobo.443.1">: This is the minimum price fluctuation. </span><span class="koboSpan" id="kobo.443.2">0.00001 means that the minimum change can be in the fifth digit to the right of the decimal point and the amount </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.444.1">of this change is 1 (so-called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.445.1">fractional pip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">).</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">ticker_enabled</span></strong><span class="koboSpan" id="kobo.448.1">: This means that the symbol is available </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">for ordering.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.450.1">To retrieve the entire order book information for the particular symbol, we can use </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
curl -i -X GET "https://public-data-api.london-demo.lmax.com/v1/orderbook/eur-usd"</span></pre>
<p><span class="koboSpan" id="kobo.453.1">The response will contain the list of bids and asks for the depth allowed by LMAX for demo accounts again in the form of a </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">plain JSON.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">If you want to receive continuous data from the ECN, you may want to use WebSockets instead </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">of REST:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.457.1">First, you will need to install WebSockets, which you can do </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">using pip:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.459.1">
pip install websocket_client</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.460.1">If you use Python with an Anaconda distribution, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
conda install -c conda-forge websocket-client</span></pre>
<ol>
<li value="2"><span class="koboSpan" id="kobo.463.1">First of all, we need to import the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">WebSocket module:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.465.1">
import websocket</span></pre></li>
<li><span class="koboSpan" id="kobo.466.1">Then, set the URL to which we’re going </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">to subscribe:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.468.1">
url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"</span></pre></li>
<li><span class="koboSpan" id="kobo.469.1">Then, create the WebSocket and </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">connect it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.471.1">
ws = websocket.WebSocket()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.472.1">
ws.connect(url)</span></pre></li>
<li><span class="koboSpan" id="kobo.473.1">Then, form </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.474.1">the request as a </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">regular JSON:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.476.1">
req = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]},{"name": "TICKER","instruments":["usd-jpy"]}]}'</span></pre></li>
<li><span class="koboSpan" id="kobo.477.1">Send </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">the request:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.479.1">
ws.send(req)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.480.1">Watch </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">the response:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
print(ws.recv())</span></pre>
<p><span class="koboSpan" id="kobo.483.1">If you did all the steps correctly, you’re going to see something </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.485.1">
{"type":"SUBSCRIPTIONS","channels":[{"name":"ORDER_BOOK","instruments":["eur-usd"]},{"name":"TICKER","instruments":["usd-jpy"]}]}</span></pre>
<p><span class="koboSpan" id="kobo.486.1">This response means that the subscription has been set up and that the subscribed instruments are the euro for the entire order book and the Japanese yen for the last </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">price data.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">As this book is not a tutorial on WebSockets, I recommend reading the very comprehensive tutorial at </span><a href="https://websockets.readthedocs.io/en/stable/intro/index.html"><span class="koboSpan" id="kobo.489.1">https://websockets.readthedocs.io/en/stable/intro/index.html</span></a><span class="koboSpan" id="kobo.490.1"> if you are not familiar with this kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">network connection.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">You can find all </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.493.1">supported REST API endpoints and WebSocket requests in the LMAX official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">at </span></span><a href="https://docs.lmax.com/public-data-api/"><span class="No-Break"><span class="koboSpan" id="kobo.495.1">https://docs.lmax.com/public-data-api/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.496.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.497.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.498.1">Please don’t forget that the preceding examples are for illustrative purposes only. </span><span class="koboSpan" id="kobo.498.2">I would like to keep this book as broker-agnostic as possible so I can’t really recommend any particular broker or an ECN. </span><span class="koboSpan" id="kobo.498.3">The example with LMAX is provided here only because they have one of the most simple and </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">easy-to-use APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">Other brokers and </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.501.1">trading venues may have different APIs that are sometimes more complex but the key principles of subscribing to data remain </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">So, now that we know </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.504.1">how to get data from the trading venue, here comes the most important part: </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">data handling</span></strong><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">All procedures you perform with data in your trading applications must ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">data consistency.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">By data consistency in market data, we assume </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.510.1">If tick A is received prior to tick B, then the timestamp of tick A should precede that of </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">tick B</span></span></li>
<li><span class="koboSpan" id="kobo.512.1">If there is a gap in time between two adjacent ticks that is substantially greater than the average, there must be a clear logical explanation </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">for it</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">If there is a gap in price between two adjacent ticks that is substantially greater than the average, there must be again a clear logical explanation </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">for it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.516.1">Let’s consider each point in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">following sub-sections.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.518.1">Tick sequence</span></h2>
<p><span class="koboSpan" id="kobo.519.1">When you start </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.520.1">working with real market data, you will be impressed by the number of ticks with incorrect timestamps. </span><span class="koboSpan" id="kobo.520.2">There are several explanations for this phenomenon; the most understandable is probably that the number of ticks (and we remember from </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.521.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.522.1"> that a tick is an update in price, either a new bid, a new ask, or a new trade) is so huge that the exchange’s or ECN’s own servers can’t really process all of them in the correct sequence and assign the same timestamps to batches of ticks. </span><span class="koboSpan" id="kobo.522.2">There are also other reasons that are more related to the latency between the exchange’s servers and trading servers or client computers. </span><span class="koboSpan" id="kobo.522.3">Anyway, regardless </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.523.1">of the reason, incorrect timestamps are a real problem and before we start working with data, we always have to perform a check and correct the timestamps if there’s any inconsistency </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">in them.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">There are several techniques that allow fixing the timestamp issue and we will consider them in detail in the very next chapter, which is completely dedicated to processing and storing </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">market data.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.527.1">Time gaps</span></h2>
<p><span class="koboSpan" id="kobo.528.1">Basically, a time gap is a situation </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.529.1">when no market data is received for a considerable amount of time. </span><span class="koboSpan" id="kobo.529.2">Of </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.530.1">course, the question is how to define this </span><em class="italic"><span class="koboSpan" id="kobo.531.1">considerable amount</span></em><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">How much is it? </span><span class="koboSpan" id="kobo.532.3">A second? </span><span class="koboSpan" id="kobo.532.4">A minute? </span><span class="koboSpan" id="kobo.532.5">An hour? </span><span class="koboSpan" id="kobo.532.6">If there’s no market data update in 5 minutes, does it mean that the connection is lost or that there’s simply no activity in </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">the market?</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">If you receive data as live quotes this problem can be solved relatively easily by adding heartbeat messages to your implementation of market </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">data retrieval.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">A </span><em class="italic"><span class="koboSpan" id="kobo.537.1">heartbeat message</span></em><span class="koboSpan" id="kobo.538.1"> is somewhat similar to </span><em class="italic"><span class="koboSpan" id="kobo.539.1">ping</span></em><span class="koboSpan" id="kobo.540.1">: a message with dummy content is sent to the server and the server </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.541.1">just replies with something that means </span><em class="italic"><span class="koboSpan" id="kobo.542.1">“OK, I am still alive and can hear you well.”</span></em><span class="koboSpan" id="kobo.543.1"> Such a message is sent automatically at equal intervals and is a simple yet robust method of checking the health of </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">your connection.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">If you work with FIX, this protocol natively supports heartbeat (message type 0, tag 35=0). </span><span class="koboSpan" id="kobo.545.2">If you work with other APIs – well... </span><span class="koboSpan" id="kobo.545.3">as always in this chapter, you should refer to your broker’s documentation regarding how they implement heartbeat (and what they expect you to use). </span><span class="koboSpan" id="kobo.545.4">If no special heartbeat message is reserved by the broker, you may want to use any neutral request, such as a request for a quote from time to time, and check </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">the response.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">The key advantage of using </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.548.1">a special heartbeat message is that it works any time the server is up. </span><span class="koboSpan" id="kobo.548.2">Even when the market is actually closed and any attempt to receive a market quote fails, heartbeat messages will go through and will be responded to. </span><span class="koboSpan" id="kobo.548.3">So, using heartbeat messages is always the preferred way </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">to go.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.550.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.551.1">If your broker or a trading venue does support heartbeat messages, you may want to refrain from using any other type of request just to make sure the connection is alive. </span><span class="koboSpan" id="kobo.551.2">In certain cases, such an activity can be a reason for a ban with </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">certain ECNs.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">So, with live quotes, the problem of time gaps can be solved relatively easily by adding heartbeat messages. </span><span class="koboSpan" id="kobo.553.2">But </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.554.1">what do we do in cases where we work </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.555.1">with </span><em class="italic"><span class="koboSpan" id="kobo.556.1">historical data,</span></em><span class="koboSpan" id="kobo.557.1"> that is, not the data representing what’s going on in the market now but data indicating what </span><em class="italic"><span class="koboSpan" id="kobo.558.1">was going on </span></em><span class="koboSpan" id="kobo.559.1">in the market some time ago? </span><span class="koboSpan" id="kobo.559.2">In this case, no heartbeat message is recorded into it (at least I am not aware of any single example suggesting otherwise) and if we see two ticks with a pause of 1 hour between them, there is always a question of whether this data </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">is consistent.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">Normally, such a consistency check is performed in </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">two stages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.563.1">First, we identify the time gaps. </span><span class="koboSpan" id="kobo.563.2">The main problem here is how to decide that the pause between ticks is long enough to become suspicious. </span><span class="koboSpan" id="kobo.563.3">We will look into this problem in detail in the next chapter. </span><span class="koboSpan" id="kobo.563.4">For now, let’s just assume that any pause that is greater than the average plus two sigmas (sigma here stands for standard deviation, we consider it in </span><a href="B19145_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.564.1">Chapter 6</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.565.1">, Basics of Fundamental Analysis and its Possible Use in FX Trading</span></em><span class="koboSpan" id="kobo.566.1">) is </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">considered </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.568.1">suspicious</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Next, all </span><em class="italic"><span class="koboSpan" id="kobo.571.1">suspicious</span></em><span class="koboSpan" id="kobo.572.1"> pauses are checked against the list of known situations when market data can indeed be paused. </span><span class="koboSpan" id="kobo.572.2">We exclude all weekends, pauses before and after the bank settlement, and the opening of the bank day for some currencies, and check the rest against a schedule for known events such as releases of important economic news that also may cause interruptions in </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">market quotes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.574.1">If the remaining list of time gap issues is insignificant (let’s assume for clarity that it is at least 10 times as small as the original list), then we believe that overall this data is satisfactory </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.575.1">to work with. </span><span class="koboSpan" id="kobo.575.2">If the amount of unidentified </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.576.1">time gaps is still significant, it would be best to refrain from using </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">this data.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.578.1">Price gaps</span></h2>
<p><span class="koboSpan" id="kobo.579.1">A gap in price is a situation where two adjacent ticks have an abnormal difference in price. </span><span class="koboSpan" id="kobo.579.2">Of course, like </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.580.1">with time gaps, the question is how we define this to be </span><em class="italic"><span class="koboSpan" id="kobo.581.1">abnormal</span></em><span class="koboSpan" id="kobo.582.1">. </span><span class="koboSpan" id="kobo.582.2">Here, we </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.583.1">can use similar techniques as those we used with time gaps. </span><span class="koboSpan" id="kobo.583.2">If the difference in the price of two adjacent ticks is greater than the average plus 2 sigma, then this is a potential </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">price gap.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">In cases of price gaps, we frequently use 3 sigmas and more because the goal is not really to catch every </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.586.1">situation when the price jumps quickly (in the real market this may happen quite often, at least a few times a day) but to isolate and filter out </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.587.1">non-market prices</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">Maybe you remember the illustration of what non-market price looked like in </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.590.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.591.1">? </span><span class="koboSpan" id="kobo.591.2">So, a non-market price is something that lies completely, totally outside of any reasonable range, so we can easily consider 10, 20, and sometimes even 100 sigmas to filter out these </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">erroneous quotes.</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">You may wonder about the source of these non-market prices. </span><span class="koboSpan" id="kobo.593.2">There can be multiple reasons for </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">non-market prices:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.595.1">The most common reason is a so-called </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">fat finger effect</span></strong><span class="koboSpan" id="kobo.597.1">, simply a mistake in the bid or offer </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.598.1">sent to the market. </span><span class="koboSpan" id="kobo.598.2">Typically, it is 10 times greater or 10 times less than the </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.599.1">previous market price because of an extra 0 in the quote or a missing digit. </span><span class="koboSpan" id="kobo.599.2">Trades done at these prices are normally reversed in hindsight, but the quotes are recorded in the data stream and stored as </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">historical data.</span></span></li>
<li><span class="koboSpan" id="kobo.601.1">Some data providers include data not related to trading; for example, I saw a case where the exchange included transfers to an insurance fund as market price data. </span><span class="koboSpan" id="kobo.601.2">Luckily they recorded these </span><em class="italic"><span class="koboSpan" id="kobo.602.1">ticks</span></em><span class="koboSpan" id="kobo.603.1"> at zero price – luckily because it is then very easy to </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">filter out.</span></span></li>
<li><span class="koboSpan" id="kobo.605.1">In rare cases, there </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.606.1">can be glitches in the data provider’s database, software, or hardware – erroneous quotes caused by this reason are the hardest to find </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">and filter.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.608.1">After you have successfully connected to the data source, received data, and filtered it, it’s time to do something meaningful with it: that is, analyze the data and make some trading decisions. </span><span class="koboSpan" id="kobo.608.2">This is what we’re going to consider in the </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">next section.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.610.1">Trading logic – this is where a small mistake may cost a fortune</span></h1>
<p><span class="koboSpan" id="kobo.611.1">Trading logic is obviously the core of the entire trading app. </span><span class="koboSpan" id="kobo.611.2">It is the very component that analyzes the </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.612.1">market data in search of any pre-defined price-time patterns (sometimes other data such as volume and open interest is included, but this data is typically not available for the spot market) and generates orders. </span><span class="koboSpan" id="kobo.612.2">Almost all of the rest of the book will be dedicated to trading logic and various approaches to developing trading algorithms but we can’t really move on without considering one very typical mistake that already costs many traders millions, if not billions, of dollars. </span><span class="koboSpan" id="kobo.612.3">I mean the </span><strong class="bold"><span class="koboSpan" id="kobo.613.1">peek </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.614.1">ahead</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1"> issue.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">The phenomenon of peeking ahead is specific to only the development phase of the project when the trading algorithm is optimized or trained using past market data, which is called historical data. </span><span class="koboSpan" id="kobo.616.2">As you remember from the previous section, historical data is something pre-recorded </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.617.1">either by yourself or a third party such as an exchange, a broker, a data vendor, and so on. </span><span class="koboSpan" id="kobo.617.2">This data may contain ticks or may be compressed down to 1-second or 1-minute snapshots. </span><span class="koboSpan" id="kobo.617.3">Regardless of data compression, all data in a cleaned-up dataset is sorted by timestamp and there is no situation when any </span><em class="italic"><span class="koboSpan" id="kobo.618.1">future </span></em><span class="koboSpan" id="kobo.619.1">data would go before the </span><em class="italic"><span class="koboSpan" id="kobo.620.1">past </span></em><span class="koboSpan" id="kobo.621.1">data – or vice versa, when any past data would be recorded after any future data. </span><span class="koboSpan" id="kobo.621.2">Let’s look at the following example to see what </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">this means:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.623.1">
1/27/2015,13:30:00,1.12947,1.12959,1.12941,1.12941,230,438,888,4,7,12
1/27/2015,13:31:00,1.12953,1.12970,1.12951,1.12965,400,240,650,9,4,14
1/27/2015,13:32:00,1.12944,1.12944,1.12883,1.12883,90,609,749,2,10,13
1/27/2015,13:33:00,1.12876,1.12907,1.12876,1.12894,589,170,909,5,4,12
1/27/2015,13:34:00,1.12902,1.12925,1.12902,1.12925,720,400,1120,9,4,13</span></pre>
<p><span class="koboSpan" id="kobo.624.1">In this example, the timestamps are in the correct order. </span><span class="koboSpan" id="kobo.624.2">This piece of data means that the closing price of the instrument (which can be found in the sixth position of each record) was </span><em class="italic"><span class="koboSpan" id="kobo.625.1">first</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.626.1">1.12941</span></strong><span class="koboSpan" id="kobo.627.1">, </span><em class="italic"><span class="koboSpan" id="kobo.628.1">then</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.629.1">1.12965</span></strong><span class="koboSpan" id="kobo.630.1">, </span><em class="italic"><span class="koboSpan" id="kobo.631.1">then</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.632.1">1.12883</span></strong><span class="koboSpan" id="kobo.633.1">, </span><em class="italic"><span class="koboSpan" id="kobo.634.1">then</span></em> <strong class="source-inline"><span class="koboSpan" id="kobo.635.1">1.12894,</span></strong><span class="koboSpan" id="kobo.636.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.637.1">finally</span></em></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">1.12925</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.640.1">When we develop and test a trading algorithm, we </span><em class="italic"><span class="koboSpan" id="kobo.641.1">simulate </span></em><span class="koboSpan" id="kobo.642.1">trading by processing past data and making a trading decision based on it. </span><span class="koboSpan" id="kobo.642.2">Normally, the simulation engine processes pieces of data from a file, a list, or a pandas DataFrame one by one to simulate what </span><em class="italic"><span class="koboSpan" id="kobo.643.1">would have happened </span></em><span class="koboSpan" id="kobo.644.1">if our algorithm traded </span><em class="italic"><span class="koboSpan" id="kobo.645.1">at that time.</span></em><span class="koboSpan" id="kobo.646.1"> So, we </span><em class="italic"><span class="koboSpan" id="kobo.647.1">must</span></em><span class="koboSpan" id="kobo.648.1"> make sure that at no point our trading algorithm can receive data </span><em class="italic"><span class="koboSpan" id="kobo.649.1">from </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.650.1">the future</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">Let’s again look at the preceding example. </span><span class="koboSpan" id="kobo.652.2">Imagine that we simulated the behavior of our trading </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.653.1">algorithm at 13:32. </span><span class="koboSpan" id="kobo.653.2">All we and the algorithm may know at this step is that the closing price at that time was 1.12883. </span><span class="koboSpan" id="kobo.653.3">We </span><em class="italic"><span class="koboSpan" id="kobo.654.1">cannot </span></em><span class="koboSpan" id="kobo.655.1">know – and the algorithm </span><em class="italic"><span class="koboSpan" id="kobo.656.1">cannot </span></em><span class="koboSpan" id="kobo.657.1">know – that the closing price </span><em class="italic"><span class="koboSpan" id="kobo.658.1">would be</span></em><span class="koboSpan" id="kobo.659.1"> 1.12894 one minute later. </span><span class="koboSpan" id="kobo.659.2">However, if you store prices in a list (or a pandas DataFrame) it is easy to refer to the </span><em class="italic"><span class="koboSpan" id="kobo.660.1">future </span></em><span class="koboSpan" id="kobo.661.1">price just by its index. </span><span class="koboSpan" id="kobo.661.2">So, I could potentially write something such as this (the following example assumes that </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">current_position</span></strong><span class="koboSpan" id="kobo.663.1"> is the pointer which iterates through the dataset and </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">price_data</span></strong><span class="koboSpan" id="kobo.665.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">dataset itself):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
current_position = x
if price_data[x + 1] &gt; price_data[current_position]:
      order.buy(market)
if price_data[x + 1] &lt; price_data[current_position]:
      order.sell(market)</span></pre>
<p><span class="koboSpan" id="kobo.668.1">In this code, we assume that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">buy</span></strong><span class="koboSpan" id="kobo.670.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">sell</span></strong><span class="koboSpan" id="kobo.672.1"> methods generate buy and sell orders respectively. </span><span class="koboSpan" id="kobo.672.2">If we run a simulation using this code, we will have </span><em class="italic"><span class="koboSpan" id="kobo.673.1">100% of winning trades.</span></em><span class="koboSpan" id="kobo.674.1"> Not a single one will lose money because we compare a price </span><em class="italic"><span class="koboSpan" id="kobo.675.1">from the future</span></em><span class="koboSpan" id="kobo.676.1"> (lines 2 and 4) with the real price that exists </span><em class="italic"><span class="koboSpan" id="kobo.677.1">at the moment of simulation</span></em><span class="koboSpan" id="kobo.678.1">. </span><span class="koboSpan" id="kobo.678.2">In our example, it would mean that at 13:32, I </span><em class="italic"><span class="koboSpan" id="kobo.679.1">already know what the price will be at 13:33</span></em><span class="koboSpan" id="kobo.680.1"> and compare it to the current price. </span><span class="koboSpan" id="kobo.680.2">Well, if I really could know that... </span><span class="koboSpan" id="kobo.680.3">Anyway, no one can see the </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.681.1">future and you should make sure your algos are </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">no exception.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.683.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.684.1">Always make sure you refer to prices one by one without peeking ahead. </span><span class="koboSpan" id="kobo.684.2">Use queues or refer to timestamps but always avoid referring to data by </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">the index.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">Alright, we now know, at least at a surface glance, how to communicate with the market, how to retrieve data and make sure it’s consistent, and even how to avoid the greatest mistake that systematic trading strategies developers can make in the trading logic. </span><span class="koboSpan" id="kobo.686.2">Now, we should be able to send trading orders and protect ourselves against numerous </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">adverse situations.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.688.1">Risk management – your safety belt</span></h1>
<p><span class="koboSpan" id="kobo.689.1">After your algorithm has generated a trading signal, it should go past risk management. </span><span class="koboSpan" id="kobo.689.2">While trading logic answers the question </span><em class="italic"><span class="koboSpan" id="kobo.690.1">to trade or not to trade</span></em><span class="koboSpan" id="kobo.691.1">, risk management answers another question: how much should be put </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">at stake?</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">In basic terms, risk management involves analysis of the potential maximum adverse excursion per </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.694.1">trade, account size, leverage and margin as financial components of risk, and macro-economic factors and political events as external and non-market risk. </span><span class="koboSpan" id="kobo.694.2">Just to give you an example, it would be wise to just switch off trading before the Swiss National Bank decision in January 2015 or the presidential elections in the US </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">in 2016.</span></span></p>
<p><span class="koboSpan" id="kobo.696.1">The topic of risk management is really vast and we will go into detail on this later in </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.697.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.698.1">, Types of Orders and Their Simulation in Python</span></em><span class="koboSpan" id="kobo.699.1">, after we have learned more about types of trading strategies </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">and orders.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.701.1">Ordering – make sure you are understood correctly</span></h1>
<p><span class="koboSpan" id="kobo.702.1">Last, but by far not </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.703.1">least, your trading application will have an ordering module. </span><span class="koboSpan" id="kobo.703.2">This module performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">following functions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.705.1">It maintains the connection to the execution server keeping </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">it alive.</span></span></li>
<li><span class="koboSpan" id="kobo.707.1">It transforms trading signals passed by the risk management module into actual orders – using FIX or any </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">proprietary API.</span></span></li>
<li><span class="koboSpan" id="kobo.709.1">It handles all types of responses from the broker or trading venue. </span><span class="koboSpan" id="kobo.709.2">These responses range from just </span><em class="italic"><span class="koboSpan" id="kobo.710.1">OK</span></em><span class="koboSpan" id="kobo.711.1"> to partial fills </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">and rejects.</span></span></li>
<li><span class="koboSpan" id="kobo.713.1">It decides what to do in cases where your order was rejected or </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">filled partially.</span></span></li>
<li><span class="koboSpan" id="kobo.715.1">It resubmits orders, full or in parts, in case it is favored by the </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">trading logic.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.717.1">You may have </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.718.1">noticed that one of the responsibilities of the ordering module is maintaining connections – quite like the data handling module. </span><span class="koboSpan" id="kobo.718.2">Yes, there’s no mistake here, it is absolutely normal that a trading app uses </span><strong class="bold"><span class="koboSpan" id="kobo.719.1">different</span></strong><span class="koboSpan" id="kobo.720.1"> connections for data and for orders. </span><span class="koboSpan" id="kobo.720.2">Moreover, it is very frequent when data is obtained from a data vendor and orders are executed at an exchange or obtained from an exchange and executed with a market maker, and so on – in any possible combination. </span><span class="koboSpan" id="kobo.720.3">So, the ordering module also maintains the connection because this connection is different </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">and separate.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">As with risk management, we will go into the details of ordering along with risk management in </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.723.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.724.1">, Types of Orders and Their Simulation </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">in Python</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1">.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.727.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.728.1">In this chapter, we learned how to connect to a broker or data vendor, retrieve live market data, understand the requirements for the quality of this data, and know all the five core logical blocks of which our future trading application </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">will consist.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">In the next chapter, we will move on to discuss the specifics of how we can efficiently handle </span><em class="italic"><span class="koboSpan" id="kobo.731.1">historical </span></em><span class="koboSpan" id="kobo.732.1">market data because this is exactly what is required for the research and </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">development phase.</span></span></p>
</div>
</body></html>