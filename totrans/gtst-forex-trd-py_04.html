<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor073"/>4</h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/>Trading Application: What’s Inside?</h1>
<p>Almost any application that implements a trading strategy has a number of more or less standard components. Let’s first have a quick look at a somewhat generalized architecture of a typical trading application and then go into greater detail on specific points related to the development of a trading strategy using Python.</p>
<p>In <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a><em class="italic">, Developing Trading Strategies – Why They Are Different</em>, we saw a very generalized diagram of a typical trading application. Now, we are going to consider its blocks in greater detail. We will learn how to connect our application to data sources and trading venues, how to retrieve data and check its consistency, and consider important points about trading logic and orders.</p>
<p>By the end of this chapter, you will understand how to develop the main components of a trading application that is efficient, maintainable, and scalable, and how to avoid typical serious problems that arise due to incorrect market data processing, mistakes in trading logic, and insufficient understanding of the trade mechanics.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Have your app talk to the world – the gloomy world of communication protocols</li>
<li>Retrieving data – garbage in, garbage out</li>
<li>Trading logic – this is where a small mistake may cost a fortune</li>
<li>Risk management – your safety belt</li>
<li>Ordering interfaces – make sure you are understood correctly</li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/>Technical requirements</h1>
<p>You will need Python 3.9 or above to run the code in this chapter.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Have your app talk to the world – the gloomy world of communication protocols</h1>
<p>Well, actually, in this section, I could just say, <em class="italic">“in the world of FX automated trading every setup is unique, so go ask your broker.”</em> Of course, I am not going to do this but when it <a id="_idIndexMarker206"/>comes to connecting your app to a market maker, <strong class="bold">electronic communication network</strong> (<strong class="bold">ECN</strong>), or any other trading venue, always keep in mind what I said at the beginning of this section.</p>
<p>As you remember from the previous chapter, the FX market is still the most fragmented one from the trading standpoint; so there should be no surprise that its computerized infrastructure is also very fragmented. Even though there’s a standard for exchanging financial information, many trading venues use their own dialects, which simply means extra work in cases where you want to use your application with a different broker. At the same time, many trading venues offer their own APIs and protocols not compatible with anything else so developers never lose their jobs and are perpetually adapting their applications.</p>
<p>Having said all that, let’s start with something that is generally considered the only industry standard for communication used in trading applications.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>FIX – universal but too flexible</h2>
<p>In my opinion, despite its hard-to-read syntax, <strong class="bold">financial information exchange</strong> (<strong class="bold">FIX</strong>) is the best <a id="_idIndexMarker207"/>choice to start diving into trading communications because its messages can at least be read by a human – thus, debugging and learning our own mistakes will ensure the steepest learning curve.</p>
<p>Unfortunately, FIX is considered a protocol mostly for professional use and is not available out of the box to any trader from any broker. One of the possible reasons for this discrimination is that FIX allows you to send any instructions and the receiving server checks only syntax but not the meaning of the message. So, potentially, it may damage not only the trader’s account but even the market itself. Therefore, most of the biggest market makers, brokers, and banks require professional status from the trader to allow them to use FIX.</p>
<p>However, there’s good news: many smaller but ambitious FX brokers today offer a lot of formerly institutional-only services to retail traders. This doesn’t mean that the quality of their business is low: they simply need turnover and it’s clear that automated trading strategies generate it way better than manual traders. So, in reality, anyone can get access to institutional liquidity from an ECN using FIX.</p>
<p>Besides that, who knows, maybe one day you will find yourself working with a bank or an investment fund, and then even a general understanding of FIX will help you a lot to further your career.</p>
<p>So, what is FIX anyway?</p>
<p>FIX is an attempt to create a really universal standard that could be used in virtually any situation when you <a id="_idIndexMarker208"/>need to transfer financial-related information. It is used by banks, brokers, information agencies, and even insurance companies, along with many others. Of course, such a wide variety of use cases assumes a great degree of flexibility to customize FIX the way you need, and this degree of flexibility paradoxically makes FIX less standard than it aimed to be.</p>
<p>For example, some trading venues may require various tags (basic elements of the FIX protocol) as mandatory while others don’t. Some trading venues support limit and stop orders, while others acknowledge only market orders. So, it will require some refactoring if you want to port your trading app from one broker to another because FIX doesn’t <em class="italic">require </em>any particular order type to be accepted. The list may continue but, in essence, the problem is that FIX aims to support <em class="italic">any </em>market but trading venues use only a <em class="italic">subset </em>of its tags that are relevant to their market, frequently adapting the standard to their needs.</p>
<p>I think that it’s best to consider FIX not only as a protocol or API but rather as a special language with a simple syntax that allows you to convey virtually any meaning. You can also consider it as a framework used to build messages rather than applications and the meaning of the message will depend on the context and environment.</p>
<p>Let’s look at FIX as a protocol in the first place and consider its layers. It will help you understand the way we work with FIX connections.</p>
<h3>Basic connection</h3>
<p>On the transport layer, FIX requires a standard socket connection. Again, as I mentioned at the beginning <a id="_idIndexMarker209"/>of this section, everything is very individual because various brokers and trading venues may have different requirements for the way clients connect to them. Normally, you must provide the broker <a id="_idIndexMarker210"/>or the trading venue with an IP address (or range of addresses) to whitelist and connect using a <strong class="bold">Transmission Control Protocol socket</strong> (<strong class="bold">TCP socket</strong>). Others may require complex authorization mechanisms and even the mandatory use of a VPN. So, you may want to consult your broker or trading venue for details.</p>
<p>Learning basic low-level networking such as how to establish a socket connection in Python is not the goal of this book, so if you have never done that before I’d recommend <a id="_idIndexMarker211"/>starting with an excellent guide from Real Python (<a href="https://realpython.com/python-sockets">https://realpython.com/python-sockets</a>), or if you prefer a <em class="italic">dive or swim</em> approach based <a id="_idIndexMarker212"/>on language in action with lots of live examples, you can watch this tutorial from Geeks for Geeks (<a href="https://www.geeksforgeeks.org/socket-programming-python/">https://www.geeksforgeeks.org/socket-programming-python/</a>). The point is, establishing a socket connection in Python is not rocket science but rather a simple routine procedure.</p>
<h3>Tags</h3>
<p>Once a socket connection is established, we’re ready to send and receive some meaningful <a id="_idIndexMarker213"/>information over it. As with many other protocols, FIX is based on messages. A FIX message is a plain text (ASCII) string that in turn consists <a id="_idIndexMarker214"/>of blocks (substrings) delimited by a non-printable character 0x01 (<code>SOH</code>) without any special ending characters such as <code>\n</code> or <code>\r</code>. Each block between delimiters follows a simple syntax:</p>
<pre class="source-code">
TAG=VALUE</pre>
<p>A <strong class="bold">tag</strong> is a number and its value can be any string that cannot contain the 0x01 character for obvious reasons: it will <a id="_idIndexMarker215"/>be interpreted as a delimiter. There is one important exception though: in the case that the tag means retrieving data, any value used as data may be an arbitrary sequence of bytes.</p>
<p>For example, <code>55=EUR/USD</code> represents a currency pair, instrument, or symbol (remember, they are all synonyms). <code>40=Limit</code> means that the message contains a limit order (see <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a><em class="italic">, FX Market Overview from a Developer’s Standpoint</em>, for an explanation of types of orders).</p>
<p>Since the delimiter character 0x01 is non-printable, many authors use special characters to divide tags in a FIX message visually. I’m sure you’ll agree that it is easier to read a string that is structured as follows:</p>
<pre class="source-code">
8=FIX.4.4|9=73|35=A|34=1092|49=TESTSND|52=20220728-07:30:59.643|56=TESTTGT|198=0|108=60|10=133</pre>
<p>Whereas, reading the following string is more difficult:</p>
<pre class="source-code">
8=FIX.4.49=7335=A34=109249=TESTSND52=20220728-07:30:59.64356=TESTTGT198=0108=6010=133</pre>
<p>However, do not <a id="_idIndexMarker216"/>ever use any other delimiter than 0x01 in real FIX messages!</p>
<h3>Message structure</h3>
<p>Any FIX message is <a id="_idIndexMarker217"/>composed of the following three logical parts:</p>
<ul>
<li>Standard header</li>
<li>Body</li>
<li>Standard trailer</li>
</ul>
<p>The standard header always consists of the following three tags sent in this very order and not any other:</p>
<ul>
<li><code>tag 8</code> – means that <a id="_idIndexMarker218"/>the message begins and it contains the version of the FIX protocol used by both parties</li>
<li><code>tag 9</code> – the message body length</li>
<li><code>tag 35</code> – the message type (for example, <code>request for quote</code>, <code>order</code>, <code>logon</code>, or <code>logout</code>)</li>
</ul>
<p>The standard trailer always ends with tag 10, whose value is the message checksum. A checksum is a <a id="_idIndexMarker219"/>small piece of data that is returned by a hash function – a function that processes all bits of a meaningful block of data and compresses it according to a special algorithm. Checksums are used to make sure that a block of data (a message in our case) was delivered without errors. If you want to learn more about checksums, hash functions, and related matters, I’d recommend starting with an excellent article on Wikipedia (<a href="https://en.wikipedia.org/wiki/Checksum">https://en.wikipedia.org/wiki/Checksum</a>) that also has references for further reading.</p>
<p>According to the FIX standard, a tag must have only one occurrence per message. Messages with multiple occurrences of the same tag will be rejected by the target computer.</p>
<p>Tags must have <a id="_idIndexMarker220"/>a value. In case no value is specified for any tag, the entire message will be rejected as well.</p>
<h3>Sessions</h3>
<p>Working with <a id="_idIndexMarker221"/>FIX is organized in sessions. A session assumes there are two computers involved: the one that <a id="_idIndexMarker222"/>sends the message (<em class="italic">sender</em>, the respective tag is called <code>SenderCompID</code>) and the <a id="_idIndexMarker223"/>one that receives the message (<em class="italic">target</em>, the respective tag is called <code>TargetCompID</code>). Normally, the session is initiated by a client <a id="_idIndexMarker224"/>connecting to a server, for example, a trader connecting to the broker or a bank connecting to an ECN.</p>
<p>A session starts by sending a handshake message from the sender’s computer to the target computer. In cases where there is a reply from the target computer, this message initiates the session. This message type (tag 35) is <code>Logon (A)</code>. A sample handshake message header will look as follows:</p>
<pre class="source-code">
8=FIX.4.4|9=XX|35=A</pre>
<p>In the preceding message, <code>XX</code> stands for the entire message length (see an explanation of tag 9 in the <em class="italic">Message</em> section).</p>
<p>Now, we have come to the point where my initial thesis (go and ask your broker for details) becomes apparent. The problem is that, apart from these three mandatory tags and the ending tag 10, all other tags in a logon message are optional. This means that I cannot tell you what you should include there; nor can any other author – except for your broker because it is they who decide what should be sent and in which sequence. So, the best way of learning it is by referring to the documentation obtained from the very trading venue to which you want to send your messages.</p>
<p>Any FIX session ends with a <code>Logout (5)</code> message, which in its minimal form looks as follows:</p>
<pre class="source-code">
8=FIX.4.4|9=5|35=5|10=166</pre>
<h3>Constructing messages</h3>
<p>At this point, I would <a id="_idIndexMarker225"/>like to warn you against making a very common mistake made by many developers of trading strategies. They think that there’s only a limited set of FIX messages that their application may generate; therefore, they hardcode them as strings and pick the appropriate one when they need to send an order.</p>
<p>Do not do this! Here are the following reasons why you shouldn’t do this:</p>
<ul>
<li>First, this approach makes your code non-scalable. In cases where you need to add a new tag for a new order type, you need to re-write the entire application.</li>
<li>Second, this makes your code non-portable. In cases where you want to use it with another broker, this broker can require a particular set of tags in a logon message or anywhere else, and again – you will have to re-write your app.</li>
<li>Finally, even though you may think that you remember the meaning of every FIX tag by heart, believe me, this is a dangerous self-delusion!</li>
</ul>
<p>So, the reasonable way of constructing a FIX message in Python would be to build it block by block <a id="_idIndexMarker226"/>using explicit, human-readable names of tags instead of just numbers. We’re going to use a native Python dictionary for this purpose:</p>
<ol>
<li>Let’s start by forming a basic FIX dictionary that associates tags with their respective names. We will use names as keys and tag numbers as values because this is the way we want to build our messages:<pre class="source-code">
fixdict = {}</pre><pre class="source-code">
fixdict["start"]="8"</pre><pre class="source-code">
fixdict["body_len"] = "9"</pre><pre class="source-code">
fixdict["checksum"] = "10"</pre><pre class="source-code">
fixdict["msg_type"] = "35"</pre></li>
<li>Now, we need a function that binds tags together in a message. Don’t forget that messages may differ significantly in the number of included tags so we will want to use one of Python’s most powerful features – <em class="italic">arbitrary </em><em class="italic">keyword argument</em>:<pre class="source-code">
def compose_message(fix_dictionary, **kwargs):</pre><pre class="source-code">
    msg = ""</pre><pre class="source-code">
    for arg in kwargs:</pre><pre class="source-code">
        msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"</pre><pre class="source-code">
    return msg</pre></li>
</ol>
<p>Here, we assume that we pass keyword arguments as pairs of <code>&lt;tag_name&gt;=VALUE</code> and then use the dictionary to replace human-readable names with standard FIX tag numbers.</p>
<ol>
<li value="3">Let’s test our code with the following instruction:<pre class="source-code">
message = compose_message(fixdict, start="FIX.4.4", body_len="25", msg_type="A", checksum="56")</pre></li>
</ol>
<p>We will get the following result:</p>
<pre class="source-code">
8=FIX.4.49=2535=A10=56</pre>
<p>Note <a id="_idIndexMarker227"/>that SOH characters are not visible in this output but if we explicitly request the value of the <code>message</code> variable, it will return the following output:</p>
<pre class="source-code">
In[28]: message
Out[28]: '8=FIX.4.4\x019=25\x013
5=A\x0110=56\x01'</pre>
<p>Here, the non-printable character is clearly visible.</p>
<p>However, it is not reasonable to pass the standard header manually each time we need to compose the message. So, we need to include it in the function.</p>
<p>With the first tag, <code>8</code>, it’s simple. We can store the value in a special variable and add it at the last stage of the process of composing a message. The first tag always contains only the version of the FIX protocol. But anyway, we should calculate the length of the message body and the checksum and include them (the length and the checksum) in tags <code>9</code> and <code>10</code>, respectively.</p>
<p class="callout-heading">Important</p>
<p class="callout">Do not confuse the message body with the message itself! Tag <code>9</code> means the length of only the message body, that is, between tag <code>9</code> and tag <code>10</code>. In our example, the message body length is <code>5</code> (not <code>4</code> because the body consists of characters <code>3</code>, <code>5</code>, <code>=</code>, <code>A</code>, and one non-printable 0x01).</p>
<p>The easiest way of implementing the calculation of the body length is restricting provision tags in <code>**kwargs</code> to just the message body. This can be done in a variety of ways:</p>
<ol>
<li value="1">Let’s start by using a list that we will call <code>fix_exceptions</code>:<pre class="source-code">
fix_exceptions = ["8", "9", "10"]</pre></li>
<li>We will then add tags to our composing message only when they are not in the list of exceptions:<pre class="source-code">
if fix_dictionary[arg] not in fix_exceptions:</pre></li>
<li>Now, the <a id="_idIndexMarker228"/>new version of our message-composing function will look like this:<pre class="source-code">
def compose_message(fix_dictionary, fix_exceptions, **kwargs):</pre><pre class="source-code">
    msg = ""</pre><pre class="source-code">
    for arg in kwargs:</pre><pre class="source-code">
        if fix_dictionary[arg] not in fix_exceptions:</pre><pre class="source-code">
            msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"</pre><pre class="source-code">
    return msg</pre></li>
</ol>
<p>If we test it using the preceding parameters, we will get the following output:</p>
<pre class="source-code">
35=A</pre>
<p>Tags 8, 9, and 10 are now ignored because they are in the list of exceptions. Since tags related to the standard header and standard trailer are ignored, whatever is not ignored remains in the message body.</p>
<ol>
<li value="4">Great, we can now calculate its length and add it to the message:<pre class="source-code">
msg = fix_dictionary["body_len"] + "=" + str(len(msg)) + msg</pre></li>
<li>Now, let’s add tag <code>8</code>:<pre class="source-code">
msg = fix_dictionary["start"] + "FIX.4.4"</pre></li>
<li>Finally, in the following code we sum all ASCII codes of all characters in the string, then divide this sum by 256 and take the remainder (we will use the <code>reduce</code> function here, which is part of <code>functools</code>, so should be imported as <code>from functools </code><code>import reduce</code>):<pre class="source-code">
checksum = reduce(lambda x, y: x + y, list(map(ord, msg)) % 256)</pre></li>
</ol>
<p>We will <a id="_idIndexMarker229"/>then add it to the message:</p>
<pre class="source-code">
msg += fix_dictionary["checksum"] + "=" + str(checksum)</pre>
<p>Let’s now see the entire upgraded code:</p>
<pre class="source-code">
from functools import reduce
fixdict = {}
fixdict["start"]="8"
fixdict["body_len"] = "9"
fixdict["checksum"] = "10"
fixdict["msg_type"] = "35"
exceptions = ["8", "9", "10"]
def compose_message(fix_dictionary, fix_exceptions, **kwargs):
    msg = ""
    for arg in kwargs:
        if fix_dictionary[arg] not in fix_exceptions:
            msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"
    msg = fix_dictionary["body_len"] + "=" + str(len(msg)) + msg
    msg = fix_dictionary["start"] + "=" + "FIX.4.4" + msg
    checksum = reduce(lambda x, y: x + y, list(map(ord, msg))) % 256
    msg += fix_dictionary["checksum"] + "=" + str(checksum)
    return msg</pre>
<p>Now, let’s test it with the following input:</p>
<pre class="source-code">
message = compose_message(fixdict, exceptions, start="wrong version", body_len="10000", msg_type="A", checksum="78909")</pre>
<p>We will still get the correct output:</p>
<pre class="source-code">
8=FIX.4.49=535=A10=178</pre>
<p>Note that all tags found in the list of exceptions are ignored and their ridiculous values are not <a id="_idIndexMarker230"/>included in the message – which is great because otherwise such a message will be rejected (in the best case). Moreover, now we can safely omit all tags but the body when we call the following function, which will give us exactly the same result as before:</p>
<pre class="source-code">
message = compose_message(fixdict, exceptions, msg_type="5")</pre>
<h3>What to do next</h3>
<p>If you work with FIX, you definitely need a reference that has a comprehensive dictionary of all tags with explanations of their meaning. One of the best resources is OnixS (they develop SDKs for direct market access, so no wonder FIX plays the central role in their products), which can be found at <a href="https://www.onixs.biz/fix-dictionary.html">https://www.onixs.biz/fix-dictionary.html</a>. If you plan to work with FIX professionally, I definitely recommend visiting the official website of the FIX community at <a href="https://www.fixtrading.org">https://www.fixtrading.org</a> and checking the <em class="italic">Standards</em> section, where you can find information on technical standards, specifications, and a link to FIX GitHub.</p>
<p>When it comes to professional utilization of FIX, the most important and de facto industry-standard solution is QuickFIX (<a href="https://quickfixengine.org">https://quickfixengine.org</a>). It features implementations <a id="_idIndexMarker231"/>of the FIX protocol for many languages, including Python, and simplifies the development of messaging and data retrieval for trading applications by relieving the developer of the burden of low-level composing FIX messages.</p>
<p>There are also several ready-made FIX implementations for Python, of which Simplefix (<a href="https://pypi.org/project/simplefix/">https://pypi.org/project/simplefix/</a>) is probably the most straightforward. It doesn’t implement a <a id="_idIndexMarker232"/>socket connection or any other transport layer functionality, nor does it support logging or ensure message persistence. It only serves as a convenient wrapper for encoding and decoding FIX messages with easy-to-read functions.</p>
<p>It’s also worth mentioning another protocol built on top of FIX. It is called <strong class="bold">FAST</strong>, which stands for <strong class="bold">FIX Adapted for STreaming</strong>. In simple terms, this protocol is designed to facilitate fast and <a id="_idIndexMarker233"/>a large volume of messaging without generating excessive processing overhead or latency. If you’re interested in learning more about FAST, I’d recommend starting with the official documentation (<a href="https://www.fixtrading.org/standards/fast/">https://www.fixtrading.org/standards/fast/</a>) and <a id="_idIndexMarker234"/>also having a look at a FIX Fast tutorial at <a href="https://jettekfix.com/education/fix-fast-tutorial/">https://jettekfix.com/education/fix-fast-tutorial/</a>.</p>
<p>Now that you know <a id="_idIndexMarker235"/>how to compose FIX messages, you just need to fill them with meaning. That is, you need to add any trading logic that is most likely based on market data, generate orders, transform them into FIX messages, and send them to the broker, an ECN, or elsewhere. You also need to be able to receive and understand replies to your messages. For example, your broker may respond with <code>8=8</code> in the message body, which means that your order is successfully filled (message type 8 means order execution report and value 8 means <em class="italic">order filled</em>). The broker may send you back <code>8=5</code> which will mean that your order is rejected and your code should be able to handle situations of this kind.</p>
<p>What if your broker doesn’t support FIX or doesn’t provide non-professional traders with access to it? At this point, we, unfortunately, return to my statement at the very beginning of this chapter<em class="italic">, “in the world of FX automated trading, every setup is unique so go ask your broker.”</em> As we saw previously, even in a highly standardized FIX protocol, there is still a certain degree of flexibility so it’s always best to read the documentation provided by the very trading venue to which you plan to send orders. With proprietary protocols, it’s even worse because there is no standard and every broker offers their own API designed the way they think is best.</p>
<p>However, the most important thing for you to conclude from this section is that any protocol, any API, and any framework only serves to deliver a certain message, in most cases a trading order, and to receive the reply. If you design your trading application so that you have independent interfaces between data processing, trading logic, risk management, and ordering modules, you will be able to switch from one protocol to another without rewriting the entire application – and this is what we’re going to learn more about in this book.</p>
<p>Now that we are more familiar with the means of exchanging information between your application and a trading venue, it’s time to learn <em class="italic">what </em>we can send and retrieve from there. Let’s start with market data.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Retrieving data – garbage in, garbage out</h1>
<p>The FIX protocol is universal by design and thus can be used not only for <a id="_idIndexMarker236"/>ordering but also for data <a id="_idIndexMarker237"/>retrieval. However, in most cases, it is not actually used for market data transfer; instead, trading venues provide their own proprietary APIs to retrieve data from there.</p>
<p>As always, in this <em class="italic">gloomy world</em> of communication protocols, everything is individual and each trading venue offers its own API. However, in general, all broker APIs are implemented as REST or Websockets. The former is convenient for occasional requests for quotes, while the latter is best for continuous subscriptions that allow receiving real-time market data.</p>
<p>The following examples I provide are taken from the API of LMAX, one of the key ECNs in the FX market. They are not only great because of their openness to any client, big or small, but also <a id="_idIndexMarker238"/>because they are one of the very few trading venues that publicly disseminate real-time market data – and they do it completely free of charge.</p>
<p>Before you start working with FX market data you should understand and always remember one important thing:</p>
<p><em class="italic">Data in demo environments is always different from that in a </em><em class="italic">live environment.</em></p>
<p>This means that if you receive public data or open a demo account with an ECN to receive market data from there, you should be ready to see quotes that are slightly different from the <em class="italic">real</em> market. The good news is that this difference is not significant; in our particular example with LMAX, it is normally 0.1 to 0.5 pips with a probable slight increase in difference closer to the New York bank settlement time (5 P.M. New York time – see the <em class="italic">Trading the FX market: what and how</em> section in <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a><em class="italic">, FX Market Overview from a Developer’s Standpoint</em>). So, even this publicly available data is good for most development and even for live trading.</p>
<p>In cases where you need only a quote here and a quote there from time to time, then mostly LMAX's REST API is the way to go for you.</p>
<p>As with any regular REST API, it supports a few endpoints that allow retrieving market price data both as the last trade price and as the top of the order book. It also supports retrieving information about all instruments (symbols) supported by the LMAX demo server.</p>
<p>In order to retrieve such a list, let’s execute the following:</p>
<pre class="source-code">
curl -i -X GET "https://public-data-api.london-demo.lmax.com/v1/instruments"</pre>
<p>The response will deliver us a JSON with the list of available instruments:</p>
<pre class="source-code">
[{"instrument_id":"eur-usd","symbol":"EUR/USD","security_id":"4001","currency":"USD","unit_of_measure":"EUR","asset_class":"CURRENCY","quantity_increment":"1000.0000","price_increment":"0.000010","ticker_enabled":true},...]</pre>
<p>I removed the remainder of the JSON to keep it compact but the rest is just repetitions of similar records for other instruments. Let’s parse this answer to understand its components:</p>
<ul>
<li><code>instrument_id</code>: This is the name of the FX instrument supported by the LMAX demo server in <a id="_idIndexMarker239"/>the correct notation (note that no slashes <strong class="bold">/</strong> are allowed in the names, so they are replaced with a dash <strong class="bold">-</strong>).</li>
<li><code>asset_class</code>: Most <a id="_idIndexMarker240"/>of the instruments traded at this ECN are currencies but there are also <strong class="bold">contracts for difference</strong> (<strong class="bold">CFDs</strong>) on metals and energies, so be careful.</li>
<li><code>quantity_increment</code>: This is the minimum <code>quant</code> of the order size; an increment of 1,000.000 euros means that you can send an order to buy or sell 1,003,000 euros for just 2,000 EURUSD, but not 1,003,300 or 1,100,301 euros.</li>
<li><code>price_increment</code>: This is the minimum price fluctuation. 0.00001 means that the minimum change can be in the fifth digit to the right of the decimal point and the amount <a id="_idIndexMarker241"/>of this change is 1 (so-called <strong class="bold">fractional pip</strong>).</li>
<li><code>ticker_enabled</code>: This means that the symbol is available for ordering.</li>
</ul>
<p>To retrieve the entire order book information for the particular symbol, we can use the following:</p>
<pre class="source-code">
curl -i -X GET "https://public-data-api.london-demo.lmax.com/v1/orderbook/eur-usd"</pre>
<p>The response will contain the list of bids and asks for the depth allowed by LMAX for demo accounts again in the form of a plain JSON.</p>
<p>If you want to receive continuous data from the ECN, you may want to use WebSockets instead of REST:</p>
<ol>
<li value="1">First, you will need to install WebSockets, which you can do using pip:<pre class="source-code">
pip install websocket_client</pre></li>
</ol>
<p>If you use Python with an Anaconda distribution, you can use the following code:</p>
<pre class="source-code">
conda install -c conda-forge websocket-client</pre>
<ol>
<li value="2">First of all, we need to import the WebSocket module:<pre class="source-code">
import websocket</pre></li>
<li>Then, set the URL to which we’re going to subscribe:<pre class="source-code">
url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"</pre></li>
<li>Then, create the WebSocket and connect it:<pre class="source-code">
ws = websocket.WebSocket()</pre><pre class="source-code">
ws.connect(url)</pre></li>
<li>Then, form <a id="_idIndexMarker242"/>the request as a regular JSON:<pre class="source-code">
req = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]},{"name": "TICKER","instruments":["usd-jpy"]}]}'</pre></li>
<li>Send the request:<pre class="source-code">
ws.send(req)</pre></li>
</ol>
<p>Watch the response:</p>
<pre class="source-code">
print(ws.recv())</pre>
<p>If you did all the steps correctly, you’re going to see something like this:</p>
<pre class="source-code">
{"type":"SUBSCRIPTIONS","channels":[{"name":"ORDER_BOOK","instruments":["eur-usd"]},{"name":"TICKER","instruments":["usd-jpy"]}]}</pre>
<p>This response means that the subscription has been set up and that the subscribed instruments are the euro for the entire order book and the Japanese yen for the last price data.</p>
<p>As this book is not a tutorial on WebSockets, I recommend reading the very comprehensive tutorial at <a href="https://websockets.readthedocs.io/en/stable/intro/index.html">https://websockets.readthedocs.io/en/stable/intro/index.html</a> if you are not familiar with this kind of network connection.</p>
<p>You can find all <a id="_idIndexMarker243"/>supported REST API endpoints and WebSocket requests in the LMAX official documentation at <a href="https://docs.lmax.com/public-data-api/">https://docs.lmax.com/public-data-api/</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Please don’t forget that the preceding examples are for illustrative purposes only. I would like to keep this book as broker-agnostic as possible so I can’t really recommend any particular broker or an ECN. The example with LMAX is provided here only because they have one of the most simple and easy-to-use APIs.</p>
<p>Other brokers and <a id="_idIndexMarker244"/>trading venues may have different APIs that are sometimes more complex but the key principles of subscribing to data remain the same.</p>
<p>So, now that we know <a id="_idIndexMarker245"/>how to get data from the trading venue, here comes the most important part: <strong class="bold">data handling</strong>. All procedures you perform with data in your trading applications must ensure data consistency.</p>
<p>By data consistency in market data, we assume the following:</p>
<ul>
<li>If tick A is received prior to tick B, then the timestamp of tick A should precede that of tick B</li>
<li>If there is a gap in time between two adjacent ticks that is substantially greater than the average, there must be a clear logical explanation for it</li>
<li>If there is a gap in price between two adjacent ticks that is substantially greater than the average, there must be again a clear logical explanation for it</li>
</ul>
<p>Let’s consider each point in detail in the following sub-sections.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>Tick sequence</h2>
<p>When you start <a id="_idIndexMarker246"/>working with real market data, you will be impressed by the number of ticks with incorrect timestamps. There are several explanations for this phenomenon; the most understandable is probably that the number of ticks (and we remember from <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a> that a tick is an update in price, either a new bid, a new ask, or a new trade) is so huge that the exchange’s or ECN’s own servers can’t really process all of them in the correct sequence and assign the same timestamps to batches of ticks. There are also other reasons that are more related to the latency between the exchange’s servers and trading servers or client computers. Anyway, regardless <a id="_idIndexMarker247"/>of the reason, incorrect timestamps are a real problem and before we start working with data, we always have to perform a check and correct the timestamps if there’s any inconsistency in them.</p>
<p>There are several techniques that allow fixing the timestamp issue and we will consider them in detail in the very next chapter, which is completely dedicated to processing and storing market data.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Time gaps</h2>
<p>Basically, a time gap is a situation <a id="_idIndexMarker248"/>when no market data is received for a considerable amount of time. Of <a id="_idIndexMarker249"/>course, the question is how to define this <em class="italic">considerable amount</em>. How much is it? A second? A minute? An hour? If there’s no market data update in 5 minutes, does it mean that the connection is lost or that there’s simply no activity in the market?</p>
<p>If you receive data as live quotes this problem can be solved relatively easily by adding heartbeat messages to your implementation of market data retrieval.</p>
<p>A <em class="italic">heartbeat message</em> is somewhat similar to <em class="italic">ping</em>: a message with dummy content is sent to the server and the server <a id="_idIndexMarker250"/>just replies with something that means <em class="italic">“OK, I am still alive and can hear you well.”</em> Such a message is sent automatically at equal intervals and is a simple yet robust method of checking the health of your connection.</p>
<p>If you work with FIX, this protocol natively supports heartbeat (message type 0, tag 35=0). If you work with other APIs – well... as always in this chapter, you should refer to your broker’s documentation regarding how they implement heartbeat (and what they expect you to use). If no special heartbeat message is reserved by the broker, you may want to use any neutral request, such as a request for a quote from time to time, and check the response.</p>
<p>The key advantage of using <a id="_idIndexMarker251"/>a special heartbeat message is that it works any time the server is up. Even when the market is actually closed and any attempt to receive a market quote fails, heartbeat messages will go through and will be responded to. So, using heartbeat messages is always the preferred way to go.</p>
<p class="callout-heading">Note</p>
<p class="callout">If your broker or a trading venue does support heartbeat messages, you may want to refrain from using any other type of request just to make sure the connection is alive. In certain cases, such an activity can be a reason for a ban with certain ECNs.</p>
<p>So, with live quotes, the problem of time gaps can be solved relatively easily by adding heartbeat messages. But <a id="_idIndexMarker252"/>what do we do in cases where we work <a id="_idIndexMarker253"/>with <em class="italic">historical data,</em> that is, not the data representing what’s going on in the market now but data indicating what <em class="italic">was going on </em>in the market some time ago? In this case, no heartbeat message is recorded into it (at least I am not aware of any single example suggesting otherwise) and if we see two ticks with a pause of 1 hour between them, there is always a question of whether this data is consistent.</p>
<p>Normally, such a consistency check is performed in two stages:</p>
<ul>
<li>First, we identify the time gaps. The main problem here is how to decide that the pause between ticks is long enough to become suspicious. We will look into this problem in detail in the next chapter. For now, let’s just assume that any pause that is greater than the average plus two sigmas (sigma here stands for standard deviation, we consider it in <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a><em class="italic">, Basics of Fundamental Analysis and its Possible Use in FX Trading</em>) is considered <em class="italic">suspicious</em>.</li>
<li>Next, all <em class="italic">suspicious</em> pauses are checked against the list of known situations when market data can indeed be paused. We exclude all weekends, pauses before and after the bank settlement, and the opening of the bank day for some currencies, and check the rest against a schedule for known events such as releases of important economic news that also may cause interruptions in market quotes.</li>
</ul>
<p>If the remaining list of time gap issues is insignificant (let’s assume for clarity that it is at least 10 times as small as the original list), then we believe that overall this data is satisfactory <a id="_idIndexMarker254"/>to work with. If the amount of unidentified <a id="_idIndexMarker255"/>time gaps is still significant, it would be best to refrain from using this data.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/>Price gaps</h2>
<p>A gap in price is a situation where two adjacent ticks have an abnormal difference in price. Of course, like <a id="_idIndexMarker256"/>with time gaps, the question is how we define this to be <em class="italic">abnormal</em>. Here, we <a id="_idIndexMarker257"/>can use similar techniques as those we used with time gaps. If the difference in the price of two adjacent ticks is greater than the average plus 2 sigma, then this is a potential price gap.</p>
<p>In cases of price gaps, we frequently use 3 sigmas and more because the goal is not really to catch every <a id="_idIndexMarker258"/>situation when the price jumps quickly (in the real market this may happen quite often, at least a few times a day) but to isolate and filter out <strong class="bold">non-market prices</strong>.</p>
<p>Maybe you remember the illustration of what non-market price looked like in <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>? So, a non-market price is something that lies completely, totally outside of any reasonable range, so we can easily consider 10, 20, and sometimes even 100 sigmas to filter out these erroneous quotes.</p>
<p>You may wonder about the source of these non-market prices. There can be multiple reasons for non-market prices:</p>
<ul>
<li>The most common reason is a so-called <strong class="bold">fat finger effect</strong>, simply a mistake in the bid or offer <a id="_idIndexMarker259"/>sent to the market. Typically, it is 10 times greater or 10 times less than the <a id="_idIndexMarker260"/>previous market price because of an extra 0 in the quote or a missing digit. Trades done at these prices are normally reversed in hindsight, but the quotes are recorded in the data stream and stored as historical data.</li>
<li>Some data providers include data not related to trading; for example, I saw a case where the exchange included transfers to an insurance fund as market price data. Luckily they recorded these <em class="italic">ticks</em> at zero price – luckily because it is then very easy to filter out.</li>
<li>In rare cases, there <a id="_idIndexMarker261"/>can be glitches in the data provider’s database, software, or hardware – erroneous quotes caused by this reason are the hardest to find and filter.</li>
</ul>
<p>After you have successfully connected to the data source, received data, and filtered it, it’s time to do something meaningful with it: that is, analyze the data and make some trading decisions. This is what we’re going to consider in the next section.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/>Trading logic – this is where a small mistake may cost a fortune</h1>
<p>Trading logic is obviously the core of the entire trading app. It is the very component that analyzes the <a id="_idIndexMarker262"/>market data in search of any pre-defined price-time patterns (sometimes other data such as volume and open interest is included, but this data is typically not available for the spot market) and generates orders. Almost all of the rest of the book will be dedicated to trading logic and various approaches to developing trading algorithms but we can’t really move on without considering one very typical mistake that already costs many traders millions, if not billions, of dollars. I mean the <strong class="bold">peek </strong><strong class="bold">ahead</strong> issue.</p>
<p>The phenomenon of peeking ahead is specific to only the development phase of the project when the trading algorithm is optimized or trained using past market data, which is called historical data. As you remember from the previous section, historical data is something pre-recorded <a id="_idIndexMarker263"/>either by yourself or a third party such as an exchange, a broker, a data vendor, and so on. This data may contain ticks or may be compressed down to 1-second or 1-minute snapshots. Regardless of data compression, all data in a cleaned-up dataset is sorted by timestamp and there is no situation when any <em class="italic">future </em>data would go before the <em class="italic">past </em>data – or vice versa, when any past data would be recorded after any future data. Let’s look at the following example to see what this means:</p>
<pre class="source-code">
1/27/2015,13:30:00,1.12947,1.12959,1.12941,1.12941,230,438,888,4,7,12
1/27/2015,13:31:00,1.12953,1.12970,1.12951,1.12965,400,240,650,9,4,14
1/27/2015,13:32:00,1.12944,1.12944,1.12883,1.12883,90,609,749,2,10,13
1/27/2015,13:33:00,1.12876,1.12907,1.12876,1.12894,589,170,909,5,4,12
1/27/2015,13:34:00,1.12902,1.12925,1.12902,1.12925,720,400,1120,9,4,13</pre>
<p>In this example, the timestamps are in the correct order. This piece of data means that the closing price of the instrument (which can be found in the sixth position of each record) was <em class="italic">first</em> <code>1.12941</code>, <em class="italic">then</em> <code>1.12965</code>, <em class="italic">then</em> <code>1.12883</code>, <em class="italic">then</em> <code>1.12894,</code> and <em class="italic">finally</em> <code>1.12925</code>.</p>
<p>When we develop and test a trading algorithm, we <em class="italic">simulate </em>trading by processing past data and making a trading decision based on it. Normally, the simulation engine processes pieces of data from a file, a list, or a pandas DataFrame one by one to simulate what <em class="italic">would have happened </em>if our algorithm traded <em class="italic">at that time.</em> So, we <em class="italic">must</em> make sure that at no point our trading algorithm can receive data <em class="italic">from </em><em class="italic">the future</em>.</p>
<p>Let’s again look at the preceding example. Imagine that we simulated the behavior of our trading <a id="_idIndexMarker264"/>algorithm at 13:32. All we and the algorithm may know at this step is that the closing price at that time was 1.12883. We <em class="italic">cannot </em>know – and the algorithm <em class="italic">cannot </em>know – that the closing price <em class="italic">would be</em> 1.12894 one minute later. However, if you store prices in a list (or a pandas DataFrame) it is easy to refer to the <em class="italic">future </em>price just by its index. So, I could potentially write something such as this (the following example assumes that <code>current_position</code> is the pointer which iterates through the dataset and <code>price_data</code> is the dataset itself):</p>
<pre class="source-code">
current_position = x
if price_data[x + 1] &gt; price_data[current_position]:
      order.buy(market)
if price_data[x + 1] &lt; price_data[current_position]:
      order.sell(market)</pre>
<p>In this code, we assume that the <code>buy</code> and <code>sell</code> methods generate buy and sell orders respectively. If we run a simulation using this code, we will have <em class="italic">100% of winning trades.</em> Not a single one will lose money because we compare a price <em class="italic">from the future</em> (lines 2 and 4) with the real price that exists <em class="italic">at the moment of simulation</em>. In our example, it would mean that at 13:32, I <em class="italic">already know what the price will be at 13:33</em> and compare it to the current price. Well, if I really could know that... Anyway, no one can see the <a id="_idIndexMarker265"/>future and you should make sure your algos are no exception.</p>
<p class="callout-heading">Note</p>
<p class="callout">Always make sure you refer to prices one by one without peeking ahead. Use queues or refer to timestamps but always avoid referring to data by the index.</p>
<p>Alright, we now know, at least at a surface glance, how to communicate with the market, how to retrieve data and make sure it’s consistent, and even how to avoid the greatest mistake that systematic trading strategies developers can make in the trading logic. Now, we should be able to send trading orders and protect ourselves against numerous adverse situations.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/>Risk management – your safety belt</h1>
<p>After your algorithm has generated a trading signal, it should go past risk management. While trading logic answers the question <em class="italic">to trade or not to trade</em>, risk management answers another question: how much should be put at stake?</p>
<p>In basic terms, risk management involves analysis of the potential maximum adverse excursion per <a id="_idIndexMarker266"/>trade, account size, leverage and margin as financial components of risk, and macro-economic factors and political events as external and non-market risk. Just to give you an example, it would be wise to just switch off trading before the Swiss National Bank decision in January 2015 or the presidential elections in the US in 2016.</p>
<p>The topic of risk management is really vast and we will go into detail on this later in <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a><em class="italic">, Types of Orders and Their Simulation in Python</em>, after we have learned more about types of trading strategies and orders.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>Ordering – make sure you are understood correctly</h1>
<p>Last, but by far not <a id="_idIndexMarker267"/>least, your trading application will have an ordering module. This module performs the following functions:</p>
<ul>
<li>It maintains the connection to the execution server keeping it alive.</li>
<li>It transforms trading signals passed by the risk management module into actual orders – using FIX or any proprietary API.</li>
<li>It handles all types of responses from the broker or trading venue. These responses range from just <em class="italic">OK</em> to partial fills and rejects.</li>
<li>It decides what to do in cases where your order was rejected or filled partially.</li>
<li>It resubmits orders, full or in parts, in case it is favored by the trading logic.</li>
</ul>
<p>You may have <a id="_idIndexMarker268"/>noticed that one of the responsibilities of the ordering module is maintaining connections – quite like the data handling module. Yes, there’s no mistake here, it is absolutely normal that a trading app uses <strong class="bold">different</strong> connections for data and for orders. Moreover, it is very frequent when data is obtained from a data vendor and orders are executed at an exchange or obtained from an exchange and executed with a market maker, and so on – in any possible combination. So, the ordering module also maintains the connection because this connection is different and separate.</p>
<p>As with risk management, we will go into the details of ordering along with risk management in <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a><em class="italic">, Types of Orders and Their Simulation </em><em class="italic">in Python</em>.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>Summary</h1>
<p>In this chapter, we learned how to connect to a broker or data vendor, retrieve live market data, understand the requirements for the quality of this data, and know all the five core logical blocks of which our future trading application will consist.</p>
<p>In the next chapter, we will move on to discuss the specifics of how we can efficiently handle <em class="italic">historical </em>market data because this is exactly what is required for the research and development phase.</p>
</div>
</body></html>