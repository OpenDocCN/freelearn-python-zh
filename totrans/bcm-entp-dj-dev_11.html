<html><head></head><body>
		<div><h1 id="_idParaDest-215"><em class="italic"><a id="_idTextAnchor239"/>Chapter 8</em>: Working with the Django REST Framework</h1>
			<p>This chapter will focus on <a id="_idIndexMarker1014"/>working with an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). An API is actually a set of tools and communication protocols working to allow two different applications to communicate with each other effectively; it is what acts as the middleman between two systems. A <strong class="bold">REST API</strong> adopts the design principles set forth in a <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) software architecture and is most commonly used with web-based applications. Every time we mention the word API in this chapter, we are really referring to a REST API as they are technically slightly different but usually interpreted as the same thing. </p>
			<p>Django itself relies on third-party packages to work with an existing API or to create an API yourself. A common Python package that is available is called the <code>requests</code> package. The <code>requests</code> package is used to send and receive requests to and from an existing API found on the server side. More information about this package can be found here: <a href="https://pypi.org/project/requests/">https://pypi.org/project/requests/</a>. On the other hand, a JavaScript-based framework, such as React, AngularJS, or Vue.js, to name a few, will all perform these requests on the client side, within the user’s browser. There is no right or wrong way to communicate with an API, in terms of choosing tools that operate on the client versus the server side. Those decisions are made as a result of the technical requirements obtained for your project. We won’t actually be using the <code>requests</code> package or any of the client-side JavaScript-based frameworks; instead, we will focus on just the <strong class="bold">Django REST framework</strong>, which is used to build a model-based API for the models we previously created.</p>
			<p>The Django REST framework is licensed as open source, allowing developers to use it within their commercial or private applications. It is used to construct APIs based on the models of a Django project, where endpoints execute HTTP requests that perform <code>requests</code> package, but it won’t hurt either if you use this package in combination with the framework, which is sometimes done in projects. This chapter will focus entirely on using the Django REST framework to create an API for all of the vehicle models that we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. We will be serializing those models and registering URL patterns, which are the API endpoints, to views and viewsets that we write. We will also be using routers to generate some of those URL patterns for us, based entirely on the data that exists in our database tables.</p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Installing and configuring the Django REST framework</li>
				<li>Serializing related models of a project</li>
				<li>Using the browsable API, a tool provided by the Django REST framework</li>
				<li>Creating SPA-style pages</li>
				<li>Creating custom API endpoints</li>
				<li>Performing API requests using token authentication measures</li>
			</ul>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor240"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder, which is where the <code>manage.py</code> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapter; however, any database type that you choose for your project can be used to work with the examples in this chapter. <a id="_idTextAnchor241"/></p>
			<p>We will also be using data that is in the form of a Django fixture, provided in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Loading the chapter_3 data fixture</em>. Make sure the <code>chapter_3</code> fixture is loaded into your database. If this has already been done, then you may skip the next command. If you have already created the tables found in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, and have not loaded that fixture yet, then run the following command, after activating your virtual environment:</p>
			<pre>(virtual_env) PS &gt; python manage.py loaddata chapter_3</pre>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code depicted in this chapter can be found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/</code> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3Ojocdx">https://bit.ly/3Ojocdx</a>.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor242"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <code>chapter_8</code> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don’t forget to change the value of the <code>name =</code> variable for your app class found in the <code>/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/apps.py</code> file to now point to the path where you installed your app. Be sure to also include this app in the <code>INSTALLED_APPS</code> variable found in the <code>settings.py</code> file as well.</p>
			<p>In the main <code>urls.py</code> file of the site, add the following path, which points to the URL patterns of this chapter that we will be creating:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘’, </strong></pre>
			<pre class="source-code">        <strong class="bold">include(</strong></pre>
			<pre class="source-code">            <strong class="bold">‘becoming_a_django_entdev.chapter_8.urls’</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">]</pre>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor243"/>Installing the Django REST framework</h2>
			<p>To install the <a id="_idIndexMarker1015"/>Django REST framework in any Django project and enable the bare-minimum settings needed to begin working with it, follow these steps:</p>
			<ol>
				<li>Add the <code>djangorestframework</code>, <code>markdown</code>, and <code>django-filter</code> packages to your <code>requirements.txt</code> file and install them in your virtual environment using your IDE or command line. You can also run the following individual <code>pip</code> commands. Use the first of the following commands to activate your virtual environment:<pre><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong>
<strong class="bold">(virtual_env) PS &gt; pip install djangorestframework</strong>
<strong class="bold">(virtual_env) PS &gt; pip install markdown</strong>
<strong class="bold">(virtual_env) PS &gt; pip install django-filter</strong></pre></li>
			</ol>
			<p>There is no need to run the Django migration commands when installing these three packages as no additional tables will be created by them. </p>
			<ol>
				<li value="2">Next, in your <code>settings.py</code> file, add the following app to the <code>INSTALLED_APPS</code> list. Then, add the <code>REST_FRAMEWORK</code> dictionary, including the <code>DjangoModelPermissionsOrAnonReadOnly</code> permission class shown here:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
INSTALLED_APPS = [
    ...
    ‘rest_framework’,
]
REST_FRAMEWORK = {
    <strong class="bold">‘DEFAULT_PERMISSION_CLASSES’</strong>: [
        <strong class="bold">‘rest_framework.permissions.</strong>
<strong class="bold">            DjangoModelPermissionsOrAnonReadOnly’</strong>
    ],
}</pre></li>
			</ol>
			<p>This permission class allows us to check for model-based CRUD rights and allows anonymous users to only view or read items. For a complete breakdown of the over half-dozen other permission classes, visit <a href="https://www.django-rest-framework.org/api-guide/permissions/">https://www.django-rest-framework.org/api-guide/permissions/</a>. We will only be working with one permission class throughout this chapter. </p>
			<ol>
				<li value="3">You will need to register the URL patterns related to this framework’s authentication <a id="_idIndexMarker1016"/>mechanisms. In your <code>/chapter_8/urls.py</code> file, add the following <code>include</code> pattern, along with a home page and Django admin site links for this chapter, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong>
from django.contrib import admin
from django.urls import include, path
from django.views.generic import TemplateView
urlpatterns = [
    path(‘admin/’, admin.site.urls),
    path(
        ‘’, 
        TemplateView.as_view(
            template_name = ‘chapter_8/index.html’
        )
    ),
    <strong class="bold">path(‘api-auth/’, include(‘rest_framework.urls’))</strong>
]</pre></li>
				<li>We also need to include the admin site URLs just like we did in <a href="B17243_06_ePub.xhtml#_idTextAnchor190"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring the Django Admin Site</em>, for this chapter. If you have already placed this include statement in the main <code>urls.py</code> file of your project, then you do not need to include it again in the <code>chapter_8</code> app. </li>
			</ol>
			<p>Now, the Django <a id="_idIndexMarker1017"/>REST framework is installed and ready to use in your project. Currently, we have no API URLs except for the authentication URLs that come with this framework. Currently, those authentication URLs don’t provide us with anything to do. You can navigate to the login page just to see whether it loads properly by visiting the URL <code>http://localhost:8000/api-auth/login/</code>. If you log in with your superuser account, there will currently be nothing to display and it will show you a <strong class="bold">404 Page not found</strong> message. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The reason we enabled the Django admin site URL patterns for the <code>chapter_8</code> app is to be able to log into the Django admin site with a superuser account and authenticate a user when working with some of the exercises in this chapter. For those exercises, if you are not logged in, you will find a message in your results stating <strong class="bold">Authentication credentials were not provided</strong>. For other exercises toward the end of this chapter, you will not need to be logged into the Django admin site; authentication will be performed by using token-based authorization measures.</p>
			<p>To begin using this framework and creating new API endpoints, we will start by creating a serializer class <a id="_idIndexMarker1018"/>for each of the models created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor244"/>Serializing objects</h1>
			<p>Creating an API <a id="_idIndexMarker1019"/>starts with creating a serializer class and then creating<a id="_idIndexMarker1020"/> a view, in particular a <code>ModelViewSet</code> view class. Serializing objects means converting a model object into JSON format to represent the data of that object. The last thing we need to do is create URL patterns that map to the view classes that we wrote; this will be done using URL routers. These URL patterns are considered your API endpoints.</p>
			<p>One thing to note in this section is that we need to create serializers for all models that relate to other models when using related fields. This is why the following exercises will show examples for all four models of the <code>chapter_3</code> app. This has to be done in order to ensure that we do not get errors when usi<a id="_idTextAnchor245"/>ng the Browsable API, which we will introduce later in this chapter, and when performing API requests. This means if you have multiple <code>Seller</code> that have been assigned a <code>Group</code> or <code>Permission</code>, that <code>Group</code> and/or <code>Permission</code> object will also have to be serialized. Remember, the <code>Seller</code> object replaced the default <code>User</code> object found in the <code>django.contrib.auth.models</code> library when we changed the <code>AUTH_USER_MODEL</code> setting to now equal <code>‘chapter_3.Seller’</code> in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. Examples for serializing the <code>Group</code> or <code>Permission</code> objects are not shown because there is only one <code>Seller</code> provided in the <code>chapter_3</code> data fixture, as shown:</p>
			<div><div><img src="img/Figure_8.01_B17243.jpg" alt="Figure 8.1 – chapter_3 data fixture – Seller object"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – chapter_3 data fixture – Seller object</p>
			<p>The <code>Seller</code> here is not assigned to a <code>Group</code> or <code>Permission</code>, so as a result, we should not experience errors in the following exercises. Instead, that <code>Seller</code> has the <code>is_superuser</code> field set to <code>true</code>, which allows us to perform all of the CRUD operations when <a id="_idIndexMarker1021"/>logged<a id="_idIndexMarker1022"/> into the Django admin site.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you experience errors, either delete all but the <code>Seller</code> data shown previously or it is recommended to just create the additional serializers, viewsets, and routers for the <code>Group</code> and <code>Permission</code> objects. Follow the same code format that is used in the following examples. The same applies to the <code>ContentType</code> object found in the <code>django.contrib.contenttypes.models</code> library. This will be needed if you have a <code>depth</code> property defined in the <code>Meta</code> subclass of that serializer class, more specifically, if <code>depth</code> is set to a value of <code>2</code> or greater. We will discuss what this property does soon.</p>
			<p>Next, let’s begin writing our serializer and learn more about the classes that are available to use.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor246"/>The serializer classes</h2>
			<p>The <code>rest_framework.serializers</code> library<a id="_idIndexMarker1023"/> provides us with<a id="_idIndexMarker1024"/> five classes, as follows:</p>
			<ul>
				<li><code>Serializer</code> – used when nesting <code>ManyToManyField</code>, <code>ForeignKey</code>, and <code>OneToOneField</code> relationships.</li>
				<li><code>ModelSerializer</code> – used to create serializers with fields that map directly to fields of models found in your project.</li>
				<li><code>HyperlinkedModelSerializer</code> – used to do everything the <code>ModelSerializer</code> class does, except it will generate a clickable link to each related object when viewed in the Browsable API, instead of displaying those objects as a numeric ID.</li>
				<li><code>ListSerializer</code> – used to serialize multiple objects in one request and is often used by Django when <code>Serializer</code>, <code>ModelSerializer</code>, or <code>HyperlinkedModelSerializer</code> has been initialized with the <code>many=True</code> attribute defined.</li>
				<li><code>BaseSerializer</code> – provided to allow developers the ability to create their own serialization and deserialization styles. This is similar to how the <code>BaseStorage</code> class is used in the Django messages framework, as discussed in <a href="B17243_07_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 7</em></a>, <em class="italic">Working with Messages, Email Notifications, and PDF Reports</em>, in the subsection titled <em class="italic">Message storage backends</em>.</li>
			</ul>
			<p>Begin by following these steps to create a <code>ModelSerializer</code> class for each model created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, the <code>Engine</code>, <code>Vehicle</code>, <code>VehicleModel</code>, and <code>Seller</code> models:</p>
			<ol>
				<li value="1">Create a new file in your <code>/becoming_a_django_entdev/chapter_8/</code> folder called <code>serializers.py</code>. Inside this file, add the following imports:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong>
from rest_framework.serializers import ModelSerializer
from ..chapter_3.models import (
    Seller, 
    Vehicle, 
    Engine, 
    VehicleModel
)</pre></li>
				<li>In this file, add the <code>EngineSerializer</code> class shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong>
...
class <strong class="bold">EngineSerializer</strong>(ModelSerializer):
    class Meta:
        model = Engine
        fields = ‘__all__’</pre></li>
				<li>In this <a id="_idIndexMarker1025"/>file, add the <code>VehicleModelSerializer</code> class shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong>
...
class <strong class="bold">VehicleModelSerializer</strong>(ModelSerializer):
    class Meta:
        model = VehicleModel
        fields = ‘__all__’</pre></li>
				<li>In this file, add the <code>VehicleSerializer</code> class shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong>
...
class <strong class="bold">VehicleSerializer</strong>(ModelSerializer):
    class Meta:
        model = Vehicle
        fields = ‘__all__’</pre></li>
				<li>In this file, add the <code>SellerSerializer</code> class shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong>
...
class <strong class="bold">SellerSerializer</strong>(ModelSerializer):
    class Meta:
        model = Seller
        fields = ‘__all__’</pre></li>
			</ol>
			<p>You might notice that the preceding classes resemble some of the classes used in the exercises found in previous<a id="_idIndexMarker1026"/> chapters. Here, we defined the fields using the <code>‘__all__’</code> value but we can provide a list of only the fields needed and the order in which we need them, as was done with the form classes of <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>.</p>
			<h3>The Meta subclass</h3>
			<p>The <code>Meta</code> subclass <a id="_idIndexMarker1027"/>provides <a id="_idIndexMarker1028"/>additional options, similar to how we customized the <code>Meta</code> subclasses in the models written for <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. For a complete breakdown of all the <code>Meta</code> class options available and anything about serializers in general, visit <a href="https://www.django-rest-framework.org/api-guide/serializers/">https://www.django-rest-framework.org/api-guide/serializers/</a>. Other options include the following: </p>
			<ul>
				<li><code>model</code> – used to specify the model class to map that serializer to.</li>
				<li><code>fields</code> – used to specify what fields, or all fields, to include in that serializer.</li>
				<li><code>validators</code> – used to add validation when performing a create or update operation. Similar to how form validation was used in <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>, Django will rely on any constraints set at the database level first, and then it will check for validation applied at the serializer level. More information about serializer validators can be found here: <a href="https://www.django-rest-framework.org/api-guide/validators/">https://www.django-rest-framework.org/api-guide/validators/</a>. </li>
				<li><code>depth</code> – used to represent related objects as nested JSON instead of using the numeric ID up to the depth specified. The default value for this option is <code>0</code>.</li>
				<li><code>read_only_fields</code> – used to specify the fields that are read-only at the serializer level.</li>
				<li><code>extra_kwargs</code> – used to specify extra keyword arguments on specific fields within that serializer.</li>
				<li><code>list_serializer_class</code> – used to specify a custom <code>ListSerializer</code> that was created using the <code>ListSerializer</code> class. This is done when you need to modify the behavior of the <code>ListSerializer</code> class, such as performing custom validation on the entire set, for example, comparing values of nested objects versus performing field-level validation.</li>
			</ul>
			<p>Now that<a id="_idIndexMarker1029"/> we<a id="_idIndexMarker1030"/> have serializer classes to work with, we need to create a view class for them. We can do that with the <code>ModelViewSet</code> class provided by the Django <a id="_idTextAnchor247"/>REST framework.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor248"/>The viewset classes</h2>
			<p>Instead of <a id="_idIndexMarker1031"/>creating views/methods for each CRUD<a id="_idIndexMarker1032"/> operation, the Django REST framework offers a class that combines them all into one. It starts by creating a view class within the <code>views.py</code> file, similar to what we did in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, except they are constructed using one of the following viewset classes. The Django REST framework provides the following four viewset classes:</p>
			<ul>
				<li><code>GenericViewSet</code> – includes methods that perform certain operations, commonly used for creating APIs that are not model-based.</li>
				<li><code>ModelViewSet</code> – this class includes all of the methods needed to perform CRUD operations and is intended to map directly to the models of your project.</li>
				<li><code>ReadOnlyModelViewSet</code> – only provides read actions and all other methods will not be provided. This viewset is also intended to work with the models of your project.</li>
				<li><code>ViewSet</code> – used by developers to create custom viewsets similar to how the <code>BaseSerializer</code> and <code>BaseStorage</code> classes were used. This class does not provide any actions and those methods will have to be created by the developer in order to use this class.</li>
			</ul>
			<p>Follow these steps to prepare your viewset classes:</p>
			<ol>
				<li value="1">In <a id="_idIndexMarker1033"/>your <code>/chapter_8/views.py</code> file, add the <a id="_idIndexMarker1034"/>following imports:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
from rest_framework.permissions import <strong class="bold">IsAuthenticated</strong>
from rest_framework.viewsets import <strong class="bold">ModelViewSet</strong>
from .serializers import (
    <strong class="bold">EngineSerializer</strong>,
    <strong class="bold">SellerSerializer</strong>,
    <strong class="bold">VehicleSerializer</strong>,
    <strong class="bold">VehicleModelSerializer</strong>
)
from ..chapter_3.models import (
    Engine, 
    Seller, 
    Vehicle, 
    VehicleModel
)</pre></li>
				<li>In that same file, add the following <code>EngineViewSet</code> class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
class <strong class="bold">EngineViewSet</strong>(ModelViewSet):
    queryset = Engine.objects.all().order_by(‘name’)
    serializer_class = <strong class="bold">EngineSerializer</strong>
    permission_classes = [IsAuthenticated]</pre></li>
				<li>In that same file, add the following <code>VehicleModelViewSet</code> class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
class <strong class="bold">VehicleModelViewSet</strong>(ModelViewSet):
    queryset = VehicleModel.objects.all().order_by(
        ‘name’
    )
    serializer_class = <strong class="bold">VehicleModelSerializer</strong>
    permission_classes = [IsAuthenticated]</pre></li>
				<li>In <a id="_idIndexMarker1035"/>that<a id="_idIndexMarker1036"/> same file, add the following <code>VehicleViewSet</code> class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
class <strong class="bold">VehicleViewSet</strong>(ModelViewSet):
    queryset = Vehicle.objects.all().order_by(‘price’)
    serializer_class = <strong class="bold">VehicleSerializer</strong>
    permission_classes = [IsAuthenticated]</pre></li>
				<li>In that same file, add the following <code>SellerViewSet</code> class, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
class <strong class="bold">SellerViewSet</strong>(ModelViewSet):
    queryset = Seller.objects.all()
    serializer_class = <strong class="bold">SellerSerializer</strong>
    permission_classes = [IsAuthenticated]</pre></li>
			</ol>
			<p>In each class depicted, we define only three properties for each of those classes, the <code>queryset</code>, <code>serializer_class</code>, and <code>permission_classes</code> properties. In the preceding examples, we are only using the <code>all()</code> method to search for all records within that table. Instead of using the <code>all()</code> method, the <code>filter()</code> and <code>get()</code> functions can also be used to look up specific records. The <code>serializer_class</code> property is used to map your view to the serializer class that we constructed in the previous subsection; it maps to the model class that we are performing the query on. The <code>permission_classes</code> property is used to define the permissions for that request. Permissions differ from the authentication token that we will discuss toward the end of this chapter. Permissions ensure the user who is accessing the system is allowed to perform those specific CRUD operations on the model in question. These are the only three properties available and only the first two are required when using a <code>ModelViewSet</code> or <code>GenericViewSet</code> class; the last is optional. You can also customize these <a id="_idIndexMarker1037"/>using a callable method or even override<a id="_idIndexMarker1038"/> the default action methods yourself. To learn more about viewsets, visit <a href="https://www.django-rest-framework.org/api-guide/viewsets/">https://www.django-rest-framework.org/api-guide/viewsets/</a>.</p>
			<p>Next, let’s configure those URL routers to map to the viewsets that we just created. These will be the API endpoints of your project.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor249"/>Using URL routers</h2>
			<p>URL routers <a id="_idIndexMarker1039"/>are used as a way to prevent <a id="_idIndexMarker1040"/>developers from having to write individual URL patterns for each of the CRUD operations pertaining to each model in your API. That can get very complicated after a while and the Django REST framework provides these URL routers as a means to automatically generate each endpoint for you.</p>
			<p>Follow these steps to configure your routers:</p>
			<ol>
				<li value="1">In your <code>/chapter_8/urls.py</code> file, add the following <code>import</code> statements: <pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong>
...
from rest_framework import <strong class="bold">routers</strong>
from .views import (
    <strong class="bold">EngineViewSet</strong>,
    <strong class="bold">SellerViewSet</strong>,
    <strong class="bold">VehicleViewSet</strong>,
    <strong class="bold">VehicleModelViewSet</strong>
)</pre></li>
				<li>In that<a id="_idIndexMarker1041"/> same<a id="_idIndexMarker1042"/> file, add the following <code>router</code> and <code>register</code> statements:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong>
...
router = routers.DefaultRouter()
router.register(r’engines’, <strong class="bold">EngineViewSet</strong>)
router.register(r’sellers’, <strong class="bold">SellerViewSet</strong>)
router.register(r’vehicles’, <strong class="bold">VehicleViewSet</strong>)
router.register(
    r’vehicle-models’,
    <strong class="bold">VehicleModelViewSet</strong>
)</pre></li>
				<li>In that same file, include the following <code>include</code> path for your routers:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong>
...
urlpatterns = [
    ...
    <strong class="bold">path(‘chapter-8/’, include(router.urls)),</strong>
    path(‘api-auth/’, include(‘rest_framework.urls’)),
]</pre></li>
			</ol>
			<p>The <code>include(router.urls)</code> path shown previously is placed between the <code>api-auth</code> path and below your admin and home page paths. A router variable is defined for each model using the <code>routers.DefaultRouter()</code> class provided by the Django REST framework. Each <code>router.register()</code> function creates a set of URL patterns for that model. For example, where the <code>engines</code> path is shown in this URL, <code>http://localhost:8000/chapter-8/engines/</code>, that is what is defined in the first parameter of the first register function, as <code>r’engines’</code>. The router generated a set of URL patterns, one for each object in that table, which gets added to your <code>urlpatterns</code> list using the <code>path(‘chapter-8/’, include(router.urls))</code> path. Adding <code>chapter-8</code> to this <code>path()</code> function is where we are telling Django to prefix <code>http://localhost:8000/chapter-8/</code> for every path created using this set of routers. </p>
			<p>That’s it; you now have a very basic API to use with the four models created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. To test your API and see the data that would be sent<a id="_idIndexMarker1043"/> and received in each request, we will use <a id="_idIndexMarker1044"/>the Browsable API next, which is provided with the Django REST framework.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor250"/>Using the Browsable API</h1>
			<p><code>chapter-8</code> path to the URL routers in the previous section, we activated that path as what is <a id="_idIndexMarker1047"/>called the <code>http://localhost:8000/chapter-8/</code> to see these URLs, as depicted here:</p>
			<div><div><img src="img/Figure_8.02_B17243.jpg" alt="Figure 8.2 – The Browsable API – API root&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The Browsable API – API root</p>
			<p>When building custom API endpoints, as we will do later in this chapter, you will likely not see them <a id="_idIndexMarker1048"/>displayed in your API root. You’ll see<a id="_idIndexMarker1049"/> that the serializers for the groups, permissions, and content types have all been included with the code of this book. There is a dropdown at the top right of every main router path that we created, to switch between the two formats, API and JSON, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_8.03_B17243.jpg" alt="Figure 8.3 – The Browsable API – GET formats&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The Browsable API – GET formats</p>
			<p>If using <code>HyperlinkedModelSerializer</code> to construct your serializer classes, each object will be displayed as a clickable URL versus an ID that is not clickable. The hyperlinked version is shown in the following screenshot, when visiting the main URL path that the router created for the <code>Seller</code> model at <code>http://localhost:8000/chapter-8/sellers/</code>:</p>
			<div><div><img src="img/Figure_8.04_B17243.jpg" alt="Figure 8.4 – The Browsable API – Sellers list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The Browsable API – Sellers list</p>
			<p>To view the same results as in the preceding screenshot, just change <code>ModelSerializer</code> to <code>HyperlinkedModelSerializer</code> in all of your serializer classes. Also, change your <code>SellerSerializer</code> class to exclude the fields shown in the following code in order to prevent an error indicating an incorrectly configured <code>lookup_field</code>, which<a id="_idIndexMarker1050"/> is an advanced topic<a id="_idIndexMarker1051"/> that goes beyond the scope of this book to resolve:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from rest_framework.serializers import (</pre>
			<pre class="source-code">    <strong class="bold">HyperlinkedModelSerializer</strong>,</pre>
			<pre class="source-code">    ModelSerializer</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">class <strong class="bold">SellerSerializer</strong>(<strong class="bold">HyperlinkedModelSerializer</strong>):</pre>
			<pre class="source-code">    class Meta:</pre>
			<pre class="source-code">        model = Seller</pre>
			<pre class="source-code">        #fields = ‘__all__’</pre>
			<pre class="source-code">        exclude = <strong class="bold">[‘groups’, ‘user_permissions’]</strong></pre>
			<p>On each of the routers registered in the previous subsection, the main URL, such as the <code>http://localhost:8000/chapter-8/sellers/</code> link shown previously, will allow you to perform a create operation (a <code>POST</code> request) using the form at the bottom of that page. Just viewing this page performs a read operation (a <code>GET</code> request). A <code>http://localhost:8000/chapter-8/sellers/1/</code>, includes a form at the bottom of that page that <a id="_idIndexMarker1053"/>will <a id="_idIndexMarker1054"/>allow you to perform <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code> operations for the object being viewed, as shown here:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_8.05_B17243.jpg" alt="Figure 8.5 – The Browsable API – Sellers detail&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The Browsable API – Sellers detail</p>
			<p>By default, Django will show the <code>Seller</code> that does not have superuser status, then that user/seller must have group or individual permission-level access granted in order to perform any of the CRUD operations on that model object. If a user/seller only has permission to do one thing and not the other, such as update but not delete or create and not update, then only those action buttons will appear. If you do not see any of the action buttons where you would expect to see them, double-check your permission settings for that user.</p>
			<p>Now that <a id="_idIndexMarker1055"/>we <a id="_idIndexMarker1056"/>have a working API and have explored how to use the Browsable API, let’s build pages that change content without needing to reload or redirect that page.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor251"/>Building SPA-like pages</h1>
			<p><strong class="bold">Single-Page App</strong> (<strong class="bold">SPA</strong>) pages <a id="_idIndexMarker1057"/>are web pages where content gets updated within containers/nodes rather than reloading or redirecting the page to display that data. Usually, some of the work of the server is offloaded to the client’s browser to perform these requests and/or render the HTML, usually with JavaScript or jQuery. When an event is triggered, such as the clicking of a button or submission of a form, JavaScript is used to obtain the data from the server and then render that content onto the page, wherever we want it to display. </p>
			<p>In this exercise, we will use the API endpoint of the <code>Seller</code> created by the router, at <code>http://localhost:8000/chapter-8/sellers/1/</code>, to render JSON as a string within a container found in the body of a query page. The query page is just a standard page that uses JavaScript to communicate with an API endpoint.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor252"/>Creating the view</h2>
			<p>In this<a id="_idIndexMarker1058"/> subsection, we will build the view to handle a page where the user can enter a number relating to the ID of a <code>Seller</code> that they want to query. This will be known as the <code>GetSellerView</code> class and it will be used as the backbone for the remaining two exercises of this chapter. </p>
			<p>To get started, take the following step:</p>
			<ol>
				<li value="1">Open the <code>/chapter_8/views.py</code> file and add the following <code>GetSellerView</code> class:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
from django.template.response import <strong class="bold">TemplateResponse</strong>
from django.views.generic import <strong class="bold">View</strong>
...
class <strong class="bold">GetSellerView</strong>(<strong class="bold">View</strong>):
    template_name =   
        <strong class="bold">‘chapter_8/spa_pages/get_seller.html’</strong>
    def get(self, request, *args, **kwargs):
        context = {}
        return TemplateResponse(
            request, 
            self.template_name, 
            context
        )</pre></li>
			</ol>
			<p>In the preceding example, we are constructing a class-based view the same as we did in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. The only thing we are doing differently here is we are not including the <code>post()</code> method; we only provided the <code>get()</code> method. Since we are not working with form submissions. The call-to-action button will be controlled using JavaScript as a button of <code>type=’button’</code> and not <code>type=’submit’</code>. There is no need to use the <code>post()</code> method when that is done. Also, we are<a id="_idIndexMarker1059"/> creating a standard Django view class and not a REST API view class because this page is only used to communicate with API endpoints and not to serve as an API endpoint itself.</p>
			<p>Now, let’s create the template to format the HTML that gets rendered to the page.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor253"/>Building the template</h2>
			<p>The previous<a id="_idIndexMarker1060"/> subsection constructed the view for this exercise. This subsection will create the template that is used in our exercise. </p>
			<p>Follow these steps to create your template:</p>
			<ol>
				<li value="1">Create the <code>get_seller.html</code> template file in the <code>/chapter_8/templates/chapter_8/spa_pages/</code> folder. </li>
				<li>Earlier, in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, we created a file called <code>/chapter_4/templates/chapter_4/base/base_template_1.html</code>. We will repurpose that file for this chapter. Go ahead and copy this file and any related template files, into your <code>chapter_8</code> app. Related template files include the header, footer, JavaScript, and CSS files that are referenced inside the <code>base_template_1.html</code> file. Place them in the <code>templates</code> and <code>static</code> directories in the same subfolders that you copied them from and then rename any mention of <code>chapter_4</code> and <code>chapter-4</code> to now reference <code>chapter_8</code> and <code>chapter-8</code> inside those files. You can always copy the <code>chapter_8</code> JavaScript, CSS, and template files found in the code of this book. </li>
				<li>Next, in<a id="_idIndexMarker1061"/> the <code>get_seller.html</code> file that you created in <em class="italic">step 1</em>, add the following code shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/templates/chapter_</strong>
<strong class="bold">    8/spa_pages/get_seller.html</strong>
{% extends <strong class="bold">‘chapter_8/base/base_template_1.html’</strong> %}
{% load static %}
...
{% block body_content %}
    &lt;form&gt;
        &lt;div class=”field-box input-box”&gt;
            &lt;label for=”seller-id”&gt;Seller ID:&lt;/label&gt;
            &lt;div class=”form-group”&gt;
                &lt;input id=”seller-id” type=”text” /&gt;
                &lt;span class=”help-text”&gt;Please enter 
                    the ID of the seller you want to 
                        lookup&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;button type=”button” id=”get-sellers” onclick
            =”<strong class="bold">$gotoSPA_Page()</strong>”&gt;
                Get Seller Details&lt;/button&gt;
    &lt;/form&gt;
    <strong class="bold">&lt;div id=”details”&gt;</strong>
        &lt;p&gt;!!! No Details to Display !!!&lt;/p&gt;
    &lt;/div&gt;
{% endblock %}</pre></li>
				<li>This page is<a id="_idIndexMarker1062"/> pretty simple. All we are doing is creating an input field of <code>type=”text”</code> and then a button of <code>type=”button”</code>. We gave the button an <code>onclick</code> attribute that fires off a JavaScript function called <code>$gotoSPA_Page()</code>. There is a <code>&lt;div&gt;</code> container with an attribute of <code>id=”details”</code>, which contains a paragraph of text, indicating that there is nothing to display at this time. </li>
			</ol>
			<p>The idea here is that we will replace all of the content of the <code>&lt;div id=”details”&gt;</code> container with the contents of what is received from the API request. A <code>&lt;form&gt;</code> container is not necessary for this particular setup; it has been added only to conform to the same CSS styles and HTML node structuring that was written in previous chapters. It is acceptable to deviate from this structure and create your own. Please use the preceding structure for the purpose of demonstrating this exercise.</p>
			<p>Next, let’s<a id="_idIndexMarker1063"/> add the JavaScript responsible for performing an API request. We will be performing this action on the client side and not on the server side.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor254"/>Writing the JavaScript</h2>
			<p>We don’t <a id="_idIndexMarker1064"/>need much JavaScript, just one small<a id="_idIndexMarker1065"/> function that utilizes the native JavaScript <code>fetch()</code> function. This is almost identical to the jQuery <code>.ajax()</code> function, but it does differ slightly. The <code>fetch()</code> function differs in that it won’t send <code>cross-origin</code> headers, the default mode is set to <code>no-cors</code>, and the <code>.ajax()</code> function sets the default mode to <code>same-origin</code>. That could be important depending on your project’s requirements. The result of the request will then be displayed in the container with the CSS ID attribute of <code>details</code>, better known as the <code>details</code> container. </p>
			<p>If you copied your JavaScript file from <code>chapter_4</code>, that file should be blank right now. Take the following steps to prepare your JavaScript. If you copied this file from <code>chapter_8</code> found in the code of the book, make sure to comment out all but the following code:</p>
			<ol>
				<li value="1">In your <code>/chapter_8/static/chapter_8/js/site-js.js</code> file, add the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong>
function $gotoSPA_Page() {
    const <strong class="bold">input</strong> = document.getElementById(
        ‘seller-id’
    );
    const <strong class="bold">container</strong> = document.getElementById(
        ‘details’
    );
    const <strong class="bold">id</strong> = input.value;
    var <strong class="bold">url</strong> = <strong class="bold">`</strong>/chapter-8/sellers/${id}/<strong class="bold">`</strong>;
}</pre></li>
				<li>In the same <code>$gotoSPA_Page()</code> function, add the <code>fetch()</code> method just below your constants and variables, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong>
function $gotoSPA_Page() {
    ...
    fetch(<strong class="bold">url</strong>, {
        method: <strong class="bold">‘GET’</strong>,
        headers: {
            ‘Content-Type’: <strong class="bold">‘application/json’</strong>,
    }}).then(response =&gt; {
        return response.json();
    }).then(data =&gt; {
        <strong class="bold">container.innerHTML = JSON.stringify(data);</strong>
    });
}</pre></li>
			</ol>
			<p>This is<a id="_idIndexMarker1066"/> the <code>$gotoSPA_Page()</code> function that <a id="_idIndexMarker1067"/>we configured in the previous subsection to execute when the <code>onclick</code> action of the <strong class="bold">Get Seller Details</strong> button is triggered. That’s it! This is all the JavaScript that we need to complete a single task of retrieving an individual record from a database, using the API that we created.</p>
			<p>In the preceding code, we wrote three constants, one called <code>input</code> to target the <code>input</code> field node and another called <code>container</code> to target the <code>details</code> container node. The third, called <code>id</code>, is used to capture the <code>value</code> of the input field at the time that this function is executed. The <code>url</code> variable is used to construct a string using the <code>value</code> of the <code>input</code> field as the keyword argument of that path converter. In JavaScript, this is known as concatenating strings, and because we are doing this, you need to make sure the backtick character (<code>`</code>) is used instead of a single-quote character (<code>‘</code>). They look almost identical; if you are just glancing at the preceding code, be careful. Here, we are telling that <code>url</code> variable to point to the URL created by the router of the <code>Seller</code> API.</p>
			<p>The <code>fetch()</code> function accepts the <code>url</code> variable as the first positional argument of that function, which is a required argument. We then pass in additional optional arguments, such as the method that accepts these values (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, and <code>DELETE</code>). All we want to demonstrate for now is retrieving the data, so we will use the <code>GET</code> method in this exercise. The headers argument is sometimes used to specify <code>‘Content-Type’</code>; in this case, it is set to <code>‘application/json’</code>. The method and headers shown previously are the defaults to using the <code>fetch()</code> function. They are not needed for the read operation since they are the default values but they are provided for illustrative purposes.</p>
			<p>The <code>fetch()</code> function also uses the two <code>then()</code> methods shown previously; they each return a promise as a response object in JSON format. In simple terms, a promise is an object that <a id="_idIndexMarker1068"/>consists of a state and a result. The<a id="_idIndexMarker1069"/> second <code>then()</code> method uses the returned promise as the <code>data</code> variable, which we then use by writing a simple statement to place that <code>data</code> into the <code>details</code> container. We use the <code>JSON.stringify()</code> method to convert that JSON object into a readable format, particularly a string placed inside that container. Without using the <code>JSON.stringify()</code> function, we would only see a single object printed to the screen in brackets, which won’t make much sense to us when we are looking at it. We will see screenshots of this in action in the subsection titled <em class="italic">First demo</em> of this chapter. </p>
			<p>Currently, all we are doing is printing the string of JSON into the <code>&lt;div&gt;</code> container. We are not creating HTML nodes and/or CSS styles for those nodes. This is where you would have to either write additional JavaScript to do that for you manually or use the power of a JavaScript-based framework. Let’s finish this exercise to see it working first, and then we will show you how to render that HTML and CSS on the server side, in the section titled <em class="italic">Writing custom API endpoints</em> of this chapter.</p>
			<h3>Using the async and await keywords</h3>
			<p>Traditional <a id="_idIndexMarker1070"/>JavaScript <a id="_idIndexMarker1071"/>is synchronous <a id="_idIndexMarker1072"/>and<a id="_idIndexMarker1073"/> single-threaded. It will run one process after the other and if one process gets hung up on, say, an API request where the server takes a long time to respond, then processes that take place after will hang up too. The problem is that a page can become unresponsive when this occurs. Asynchronous JavaScript allows functions to run side by side while other functions might be waiting for a response from the server. A <code>then()</code> function returning a promise is already an asynchronous function and is the reason why we gravitated toward using the <code>fetch()</code> function. JavaScript provides the <code>async</code> and <code>await</code> keywords, which make using and working with asynchronous functions a little bit easier, especially when your code begins to grow beyond these basic usage examples.</p>
			<p>Take the following step to modify your JavaScript.</p>
			<p>Make the highlighted changes in the following code block to your <code>$gotoSPA_Page()</code> function from the previous example:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></pre>
			<pre class="source-code">function $gotoSPA_Page() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fetch(url, {</pre>
			<pre class="source-code">        method: ‘GET’,</pre>
			<pre class="source-code">        headers: {</pre>
			<pre class="source-code">            ‘Content-Type’: ‘application/json’,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }).then(<strong class="bold">async(response)</strong> =&gt; {</pre>
			<pre class="source-code">        return <strong class="bold">await</strong> response.json();</pre>
			<pre class="source-code">    }).then(<strong class="bold">async(</strong>data<strong class="bold">)</strong> =&gt; {</pre>
			<pre class="source-code">        <strong class="bold">const thisData = await data;</strong></pre>
			<pre class="source-code">        container.innerHTML = JSON.stringify(</pre>
			<pre class="source-code">            <strong class="bold">thisData</strong></pre>
			<pre class="source-code">        );</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<p>The variable and constants are still needed. They are left unchanged and are represented <a id="_idIndexMarker1074"/>by the previous<a id="_idIndexMarker1075"/> three-dot notation. We <a id="_idIndexMarker1076"/>now <a id="_idIndexMarker1077"/>have enough to almost run our project and demonstrate this exercise in action. We just need to map a URL pattern to the view we create next.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor255"/>Mapping the URL pattern</h2>
			<p>Now, we are going<a id="_idIndexMarker1078"/> to wire up the view that we<a id="_idIndexMarker1079"/> created to a URL pattern, listening for the <code>/chapter-8/get-seller/</code> path.</p>
			<p>Take the following step to configure your URL pattern.</p>
			<p>In your <code>/chapter_8/urls.py</code> file, add the following path to the <code>urlpatterns</code> list:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></pre>
			<pre class="source-code">from .views import ..., <strong class="bold">GetSellerView</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘chapter-8/get-seller/’,</strong></pre>
			<pre class="source-code">        <strong class="bold">GetSellerView.as_view(),</strong></pre>
			<pre class="source-code">        <strong class="bold">name = ‘get-seller’</strong></pre>
			<pre class="source-code">    <strong class="bold">),</strong></pre>
			<pre class="source-code">]</pre>
			<p>You also need to <a id="_idIndexMarker1080"/>import the <code>GetSellerView</code> class<a id="_idIndexMarker1081"/> to map to the preceding pattern. </p>
			<p>Next, let’s demonstrate this code in action.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor256"/>First demo</h2>
			<p>To demonstrate <a id="_idIndexMarker1082"/>the code depicted in the <em class="italic">Building SPA-like pages</em> exercise, follow these steps:</p>
			<ol>
				<li value="1">Navigate to the get seller page at http://localhost:8000/chapter-8/get-seller/, and it should look similar to the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_8.06_B17243.jpg" alt="Figure 8.6 – Get seller page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Get seller page</p>
			<ol>
				<li value="2">Next, enter the number <code>1</code> into the input field shown in the preceding screenshot, relating to the ID of the first <code>Seller</code> in your database. Then, click the button labeled <strong class="bold">Get Seller Details</strong>. </li>
				<li>To witness what is happening, in any major browser, right-click and select <code>console.log()</code> messages or errors that occur during runtime. If this action was successful, you should see the words <strong class="bold">!!! No Details to Display !!!</strong> replaced with the results of the request, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_8.07_B17243.jpg" alt="Figure 8.7 – Get seller results – JSON.stringify()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Get seller results – JSON.stringify()</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You will need to have the <strong class="bold">Network</strong> tab opened at all times in order for data to be logged into this tab. Open this tab and then refresh the page to get accurate results as you perform these actions.</p>
			<ol>
				<li value="4">Now, look at<a id="_idIndexMarker1083"/> the Network tab again, and you should see that we have two <strong class="bold">/chapter-8/get-seller/</strong> requests displayed in that list, as shown here:</li>
			</ol>
			<div><div><img src="img/Figure_8.08_B17243.jpg" alt="Figure 8.8 – Get seller page – Network tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Get seller page – Network tab</p>
			<p>The first request, at the top of this list, was initiated by the browser when the user first loaded the page at http://localhost:8000/chapter-8/get-seller/. The second <code>site-js.js</code> file, which is the file where we wrote the <code>$gotoSPA_Page()</code> function. The last column shows the time it took to perform each request. All of the files in between are other assets, such as CSS and<a id="_idIndexMarker1084"/> JavaScript files used by other apps in your project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is no need to worry if you do not see these files; it just means they have not been loaded for one reason or another.</p>
			<ol>
				<li value="5">Next, remove the <code>JSON.stringify()</code> function used in the <code>$gotoSPA_Page()</code> function and just use the <code>thisData</code> variable instead. Then, refresh this page and perform the query one more time. What we should see is a single object, as shown here:</li>
			</ol>
			<div><div><img src="img/Figure_8.09_B17243.jpg" alt="Figure 8.9 – Get seller results – standard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Get seller results – standard</p>
			<ol>
				<li value="6">It is here that we can see why we had to use the <code>JSON.stringify()</code> function. Without this function, we can see the object is depicted as <strong class="bold">[object Object]</strong>, which is not very helpful.</li>
			</ol>
			<p>Now that we have the client side of our API up and running, let’s explore how to return rendered HTML instead of a string representation of the JSON object that is returned.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor257"/>Writing custom API endpoints</h1>
			<p>Creating our <a id="_idIndexMarker1085"/>own API endpoints is just as easy as writing another URL pattern. This section will teach us how to write our own API endpoints and practice sending preformatted HTML back to the client. You do not need to create all custom API endpoints to return preformatted HTML but we will practice doing that. Preformatting HTML only works well if the app communicating with your API does not need to restructure or restyle the HTML in any way after it has been received. This means the server/developer needs to know exactly how the client will use the data that it receives. No more JavaScript will be needed other than what was already written in the <code>$gotoSPA_Page()</code> function of the previous exercise. We will reuse that same function and just alter one or two things before we move forward. We will create a new view class and add permission logic to secure that endpoint from unwanted users accessing the API.</p>
			<p>Let’s begin working on this exercise in the same order as the previous exercise, starting with the view.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor258"/>Creating the view</h2>
			<p>Follow these<a id="_idIndexMarker1086"/> steps to create your <code>APIView</code> class:</p>
			<ol>
				<li value="1">In your <code>/chapter_8/views.py</code> file, add the <code>import</code> statements shown here:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
from django.shortcuts import <strong class="bold">render</strong>
from ..chapter_3.models import ..., Seller
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import <strong class="bold">APIView</strong>
...</pre></li>
				<li>In that same <a id="_idIndexMarker1087"/>file, create the <code>GetSellerHTMLView</code> class and <code>get()</code> method, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
class <strong class="bold">GetSellerHTMLView</strong>(<strong class="bold">APIView</strong>):
    permission_classes = [<strong class="bold">IsAuthenticated</strong>]
    template_name = <strong class="bold">‘chapter_8/details/seller.html’</strong>
    def <strong class="bold">get(</strong>self, request, format=None, <strong class="bold">id=0</strong>, *args, 
        **kwargs<strong class="bold">)</strong>:
        if request.user.<strong class="bold">is_authenticated</strong> and 
            request.user.<strong class="bold">has_perm</strong>
<strong class="bold">                (‘chapter_3.view_seller’)</strong>:
            try:
                <strong class="bold">seller = Seller.objects.get(id=id)</strong>
            except Seller.DoesNotExist:
                seller = None
        else:
            seller = None
        context = {<strong class="bold">‘seller’: seller,</strong>}
        return <strong class="bold">render</strong>(
            request, 
            self.template_name, 
            context = context
        )</pre></li>
			</ol>
			<p>Here, the new <code>GetSellerHTMLView</code> class mimics the <code>GetSellerView</code> class that we created in the previous exercise, except now it uses the <code>APIView</code> class, provided by the Django REST framework. We only need to specify the <code>get()</code> method in this class as well; there is no need for the <code>post()</code> method since we are not working with form objects. We are only creating a view that handles the <code>GET</code> API method at this time, to view/read an object. The template we are mapping to this view is the <code>/chapter_8/templates/chapter_8/details/seller.html</code> file, which we will create in the next subsection. We need to pass <code>id=0</code> into the <code>get()</code> method, as is highlighted in the preceding code, in anticipation for how we will write the URL pattern for this API endpoint. We have to explicitly set <code>id=0</code> in the <code>get()</code> method since we are using the <code>APIView</code> class. If you are inheriting the regular <code>View</code>, <code>FormView</code>, <code>CreateView</code>, <code>UpdateView</code>, or <code>DeleteView</code> classes, you would only have to write <code>id</code> without the <code>=0</code> part. The same applies to the <code>format=None</code> argument, which is only needed <a id="_idIndexMarker1088"/>when working with <code>APIView</code> classes and not regular <code>View</code> classes.</p>
			<p>This approach is reliant on a user logged into your system, by accessing the currently logged-in user with the <code>request.user</code> object. Users outside your organization, who do not have access to the Django admin site, would have to use an authorization token to log in, which will be discussed later in this chapter. Even though we changed the <code>AUTH_USER_MODEL</code> setting in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, to use the <code>Seller</code> model instead of the Django <code>User</code> model, we can still access the current user in the <code>request</code> object by using <code>request.user</code>. You do not have to use <code>request.seller</code>; in fact, that will result in an error. When using the <code>is_authenticated</code> property of that user, we can determine whether the user is actually logged in with an active session. </p>
			<p>The <code>has_perm()</code> method is used to check the permissions of that user. In this case, we are checking whether the user has read/view permissions on a <code>Seller</code> model object using <code>‘chapter_3.view_seller’</code>. If the user is authenticated and has the correct permissions, we are performing a query to look up the <code>Seller</code> object being searched by using the ID provided. If the user is not authenticated, then we are setting the <code>seller</code> variable to <code>None</code>, which we will use to compare whether or not it has a value within the template file.</p>
			<p>That <code>seller</code> variable then gets passed into the <code>context</code> of the template being used, so that we can access its data. Also, we need to wrap the query statement in a <code>try</code>/<code>except</code> block, which is necessary to prevent runtime errors when the user searches for a <code>Seller</code> that does not exist. With the <code>try</code>/<code>except</code> block, we can set the value of <code>seller</code> to <code>None</code>, allowing the program to continue to run without errors. When used in the template, it will indicate that the search returned nothing. </p>
			<p>We are using the <code>render()</code> method provided by the <code>django.shortcuts</code> library instead of the <code>TemplateResponse</code> class that we have been using up to now. This is because we want to return only a snippet of HTML and not an entire HTML page, with all of the bells <a id="_idIndexMarker1089"/>and whistles that a page may have.</p>
			<p>Now that the view is created, let’s construct the template that uses that <code>seller</code> object as context.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor259"/>Building the template</h2>
			<p>Follow these <a id="_idIndexMarker1090"/>steps to prepare your template:</p>
			<ol>
				<li value="1">Create a file called <code>seller.html</code> in the <code>/chapter_8/templates/chapter_8/details/</code> directory.</li>
				<li>Inside that file, add the following code:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/templates/chapter_8/details/seller.html</strong>
{% load static %}
&lt;h1&gt;Seller Details&lt;/h1&gt;
<strong class="bold">{% if seller %}</strong>
    &lt;h2&gt;{{ seller.first_name|safe }} {{ 
        seller.last_name|safe }}&lt;/h2&gt;
    &lt;h3&gt;{{ seller.name|safe }}&lt;/h3&gt;
    <strong class="bold">{% if seller.vehicles %}</strong>
        &lt;ul&gt;
            <strong class="bold">{% for vehicle in seller.vehicles.all %}</strong>
                &lt;li&gt;{{ vehicle.fullname }}&lt;/li&gt;
            {% endfor %}
        &lt;/ul&gt;
    {% endif %}
{% else %}
    &lt;p&gt;
        &lt;b&gt;No Seller to Display&lt;/b&gt;&lt;br /&gt;
        &lt;em&gt;or you &lt;b&gt;DO NOT&lt;/b&gt; have permission&lt;/em&gt;
    &lt;/p&gt;
{% endif %}</pre></li>
			</ol>
			<p>Note that we are not extending any another template in this file. All we are doing is displaying simple <a id="_idIndexMarker1091"/>text objects as a component of a page and not the page in whole. A conditional statement compares whether or not the <code>seller</code> object has a value, using the <code>{% if seller %}</code> statement. If no <code>seller</code> object exists, text is rendered showing the message <code>seller</code> does exist, then another conditional statement compares whether or not the <code>seller</code> has any <code>vehicles</code>, using the <code>{% if seller.vehicles %}</code> statement. If <code>vehicles</code> do exist, we iterate through all of the vehicle objects using the <code>{% for vehicle in seller.vehicles.all %}</code> statement. It is important that you add <code>.all</code> to the end of this statement; otherwise, you will receive errors. This is how you access any nested list of objects found in a single object within the Django template language. We use the <code>fullname</code> property method created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, to print the full name of the vehicle as an <code>&lt;li&gt;</code> HTML node object.</p>
			<p>Now that we have our template, let’s move on to modify the <code>$gotoSPA_Page()</code> function <a id="_idIndexMarker1092"/>created in the previous exercise.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor260"/>Modifying the JavaScript</h2>
			<p>Change the <code>url</code> variable<a id="_idIndexMarker1093"/> in the existing <code>$gotoSPA_Page()</code> function to point to the new endpoint, which we will write in the next subsection as <code>`/chapter-8/seller/${id}/`</code>, as in a singular <code>seller</code> in contrast to the plural <code>sellers</code> that we used in the previous exercise. </p>
			<p>Take the following step to modify your JavaScript function.</p>
			<p>In the <code>$gotoSPA_Page()</code> function, make the following highlighted changes:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></pre>
			<pre class="source-code">function $gotoSPA_Page() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    var <strong class="bold">url</strong> = `/chapter-8/<strong class="bold">seller</strong>/${id}/`;</pre>
			<pre class="source-code">    fetch(url, {</pre>
			<pre class="source-code">        method: ‘GET’,</pre>
			<pre class="source-code">        headers: {</pre>
			<pre class="source-code">            ‘Content-Type’: ‘application/json’,</pre>
			<pre class="source-code">    }}).then(async(response) =&gt; {</pre>
			<pre class="source-code">        <strong class="bold">return await response.text();</strong></pre>
			<pre class="source-code">    }).then(async(data) =&gt; {</pre>
			<pre class="source-code">        <strong class="bold">container.innerHTML = await data;</strong></pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, we are still using the <code>async</code> and <code>await</code> keywords but you are not required to do so. The first three constants of the <code>$gotoSPA_Page()</code> function, <code>container</code>, <code>input</code>, and <code>id</code>, are left untouched and are represented by the preceding three-dot <a id="_idIndexMarker1094"/>notation. </p>
			<p>That’s it; now all we have to do is create the URL pattern that will act as the API endpoint being used.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor261"/>Mapping the URL pattern</h2>
			<p>Take the <a id="_idIndexMarker1095"/>following step to map your URL pattern.</p>
			<p>In your <code>/chapter_8/urls.py</code> file, add the following highlighted pattern, keeping the <code>get-seller</code> path that we previously wrote:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></pre>
			<pre class="source-code">from .views import (</pre>
			<pre class="source-code">    ..., </pre>
			<pre class="source-code">    GetSellerView,</pre>
			<pre class="source-code">    <strong class="bold">GetSellerHTMLView</strong></pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        ‘chapter-8/get-seller/’, </pre>
			<pre class="source-code">        GetSellerView.as_view(), </pre>
			<pre class="source-code">        name = ‘get-seller’</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘chapter-8/seller/&lt;int:id&gt;/’, </strong></pre>
			<pre class="source-code">        <strong class="bold">GetSellerHTMLView.as_view(), </strong></pre>
			<pre class="source-code">        <strong class="bold">name = ‘seller-detail’</strong></pre>
			<pre class="source-code">    <strong class="bold">),</strong></pre>
			<pre class="source-code">]</pre>
			<p>We will still <a id="_idIndexMarker1096"/>need that first URL pattern because it is the page that triggers the API request, containing the <strong class="bold">Get Seller Details</strong> button.</p>
			<p>That should be it. Now, let’s see what this looks like in action.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor262"/>Second demo</h2>
			<p>To demonstrate<a id="_idIndexMarker1097"/> this in action, follow these steps:</p>
			<ol>
				<li value="1">Make sure you are currently logged into the Django admin site at <code>http://localhost:8000/admin/</code>, with your superuser account. </li>
				<li>Then, navigate to the get seller page at http://localhost:8000/chapter-8/get-seller/ and it should look the same as before, in <em class="italic">Figure 8.6</em>, in the previous exercise. </li>
				<li>Enter the number <code>1</code> into the input field on this page and then click the <code>details</code> container found on this page, as is also shown here:</li>
			</ol>
			<div><div><img src="img/Figure_8.10_B17243.jpg" alt="Figure 8.10 – Get seller page – custom API endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Get seller page – custom API endpoint</p>
			<p>If you have the Network tab of your browser tools open, you will also see that this action was performed without reloading or redirecting your page. You can style this to look exactly as you need it. For this example, we just used simple HTML nodes<a id="_idIndexMarker1098"/> with minimal styling and formatting to demonstrate this exercise.</p>
			<ol>
				<li value="4">Next, add or create a new superuser account using the Django admin site at <code>http://localhost:8000/admin/chapter_3/seller/</code>. This can also be done through the command line just as we did in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. </li>
				<li>In a different browser or incognito window, log in with the new superuser that you just created.</li>
				<li>Next, navigate to the original superuser’s edit page, found here: <code>http://localhost:8000/admin/chapter_3/seller/1/change/</code>. This is the user with the username <code>admin</code> and an ID of <code>1</code>.</li>
				<li>In the <strong class="bold">Permissions</strong> section of this page, uncheck the <strong class="bold">Superuser status</strong> checkbox, restricting that user from doing anything. Leave the <strong class="bold">Active</strong> and <strong class="bold">Staff status</strong> checkboxes enabled. Make sure the <strong class="bold">Chosen user permissions</strong> box has nothing selected, as shown here:</li>
			</ol>
			<div><div><img src="img/Figure_8.11_B17243.jpg" alt="Figure 8.11 – Editing superuser permissions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Editing superuser permissions</p>
			<ol>
				<li value="8">In your first <a id="_idIndexMarker1099"/>browser, where you are already logged in as <code>Seller</code> with the username of <code>admin</code>, navigate to http://localhost:8000/chapter-8/get-seller/ in a different tab or refresh the existing tab if it is still open. </li>
				<li>Enter the number <code>1</code> into the input field and then click the <strong class="bold">Get Seller Details</strong> button again. It should say that you do not have permission, as depicted in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_8.12_B17243.jpg" alt="Figure 8.12 – Get seller page – permission restricted&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – Get seller page – permission restricted</p>
			<ol>
				<li value="10">This is because we removed the original permission for this user. The preceding message is the HTML that we wrote in the <code>/chapter_8/details/seller.html</code> template, specifically in the condition that checks whether the <code>seller</code> object has a value. </li>
				<li>To ensure that the <code>seller</code> object has no value as a result of a permission issue and not because of a non-existent query, you can write <code>print()</code> statements in your code to provide that indicator for you. Go back to the other browser window that is open at <code>http://localhost:8000/admin/chapter_3/seller/1/change/</code>, where you are logged in<a id="_idIndexMarker1100"/> with the new superuser created for this exercise, and edit the <code>admin</code> user one more time.</li>
				<li>Go ahead and give that user the <strong class="bold">chapter_3 | Seller | Can view Seller</strong> permission, as depicted in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_8.13_B17243.jpg" alt="Figure 8.13 – Editing superuser permissions – view Seller&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Editing superuser permissions – view Seller</p>
			<p>By doing this, we are giving this user the exact permission that we are checking for in the <code>GetSellerHTMLView</code> class. Remember to click the <strong class="bold">Save</strong> button at the bottom of this page before proceeding.</p>
			<ol>
				<li value="13">In your first browser, on the get seller page at http://localhost:8000/chapter-8/get-seller/, make sure you are still logged in with the original <code>admin</code> user and click the <strong class="bold">Get Seller Details</strong> button one more time. Here, we will see the same results that we saw before in <em class="italic">Figure 8.9</em>.</li>
			</ol>
			<p>This exercise demonstrated how to use the Django template language to preformat HTML that is being returned in an API <code>GET</code> request. As we discovered working with this exercise, we actually need a user who is already logged into the Django admin site of the site before performing this operation. Without being logged in, this approach will not work. This is controlled by the <strong class="bold">Staff status</strong> checkbox, under the <strong class="bold">Permissions</strong> section when editing a user, which grants that user the ability to access the Django admin site. With the <strong class="bold">Staff status</strong> checkbox left unchecked, a user cannot access your system and thus, will not be able to use any of the permissions in the permission system.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Switch your original superuser, with the username <code>admin</code>, back to its original settings, with the <strong class="bold">Staff status</strong> and <strong class="bold">Superuser status</strong> checkboxes enabled and the individual permissions and group permissions all removed. Make sure this is done and that you are logged in with this user before proceeding to the next exercise.</p>
			<p>If you need to <a id="_idIndexMarker1101"/>build an API that doesn’t grant users access to your Django admin site, then authentication tokens will be needed. In the next exercise, we will use authentication tokens in combination with the Django REST framework to achieve this task.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor263"/>Authenticating with tokens</h1>
			<p>In this exercise, we <a id="_idIndexMarker1102"/>will be treating the API that we built earlier in this chapter as if it is now an API provided by a third party. Pretend for a moment that you did not build your API and we will practice authenticating by using a security token. Token security will be used in addition to the individual model permissions as we did in the previous exercise. This will be done whether you grant a user access to the Django admin site or not. That also means we will create a new user/seller for this exercise and then restrict that user’s access to the Django admin site for demonstration purposes.</p>
			<p>We will follow the same steps as the previous two exercises next.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor264"/>Project configuration</h2>
			<p>This exercise<a id="_idIndexMarker1103"/> requires a little bit of configuration inside the project’s <code>settings.py</code> file before we can get started with the same steps as before. </p>
			<p>Follow these steps to configure your project:</p>
			<ol>
				<li value="1">In your <code>settings.py</code> file, add the following app to your <code>INSTALLED_APPS</code> list, as well as the highlighted additions to the <code>REST_FRAMEWORK</code> setting, as shown:<pre><strong class="bold"># /becoming_a_django_entdev/settings.py</strong>
INSTALLED_APPS = [
    ...
    ‘rest_framework’,
    <strong class="bold">‘rest_framework.authtoken’,</strong>
]
REST_FRAMEWORK = {
    <strong class="bold">‘DEFAULT_AUTHENTICATION_CLASSES’: (</strong>
        <strong class="bold">‘rest_framework.authentication.TokenAuthentication’,</strong>
        <strong class="bold">‘rest_framework.authentication.SessionAuthentication’,</strong>
    <strong class="bold">),</strong>
    ‘DEFAULT_PERMISSION_CLASSES’: [
        ‘rest_framework.permissions.
            DjangoModelPermissionsOrAnonReadOnly’
    ],
}</pre></li>
			</ol>
			<p>The <code>rest_framework.authtoken</code> app is already installed in your virtual environment, so you do not have to install any additional <code>pip</code> packages. It comes standard when installing the <code>djangorestframework</code> package but does not get enabled in your project with just the basic settings needed for this framework. If we actually intend to use it, we have to add the two authentication classes shown previously to the <code>REST_FRAMEWORK</code> setting, telling the Django REST framework to use token authentication with all of its <code>APIView</code> classes. This means that tokens will be needed for any custom endpoints that we create using that <code>APIView</code> class, as well as all of the endpoints created using the <code>router</code> method from earlier in this chapter. </p>
			<p>Endpoints <a id="_idIndexMarker1104"/>created using the <code>router</code> method are all constructed using the <code>APIView</code> class. Adding the <code>SessionAuthentication</code> class means that we will enable the ability for users to log into the Django admin site to test that endpoint using the Browsable API. Without it, you will see a message indicating you are not authenticated. We will also leave the <code>DjangoModelPermissionsOrAnonReadOnly</code> permission class in the settings shown previously to continue to check for model-level permissions.</p>
			<p>Please also make sure you are following proper Python indentation. There is not enough room to display that properly in the code shown previously.</p>
			<ol>
				<li value="2">Now that we have added new packages to our <code>settings.py</code> file for this project, we will need to run the following migrate command:<pre><strong class="bold">(virtual_env) PS &gt; python3 manage.py migrate</strong></pre></li>
				<li>Next, make sure that you are logged into the Django admin site with your <code>admin</code> user and navigate to <code>http://localhost:8000/admin/chapter_3/seller/add/</code>, to create a new user/seller with the username <code>test</code>. You may already have a test user from a previous chapter. If so, just delete that user and recreate it for this exercise. This time, leave the <strong class="bold">Staff status</strong> and <strong class="bold">Superuser status</strong> checkboxes unchecked. Give that new user only one permission, the same <strong class="bold">chapter_3 | Seller | Can view Seller</strong> permission that we used before. </li>
				<li>Next, navigate to the URL <code>http://localhost:8000/admin/authtoken/tokenproxy/</code> and add a new token for the user you just created. This can also be done in your command-line window or terminal by executing the following command:<pre><strong class="bold">(virtual_env) PS &gt; python manage.py drf_create_token test</strong></pre></li>
				<li>Copy <a id="_idIndexMarker1105"/>the token key that was created for that user and save it for later, in Notepad or something.</li>
			</ol>
			<p>Next, we will proceed in the same order as we did for the last two exercises.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor265"/>Creating the view</h2>
			<p>Now, we need to<a id="_idIndexMarker1106"/> create a new view class for this exercise. It will be used for a new endpoint that we will add to the API before we treat it like someone else built it for us. This endpoint will only return standard JSON data and will not return the preformatted HTML that we practiced doing in the previous exercise. JSON is what is traditionally returned in API requests. </p>
			<p>Follow these steps to prepare your view class:</p>
			<ol>
				<li value="1">In your <code>/chapter_8/views.py</code> file, add the following highlighted <code>import</code> statement and the <code>GetSellerWithTokenView</code> class shown:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
from django.http import <strong class="bold">JsonResponse</strong>
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView
from .serializers import SellerSerializer
from ..chapter_3.models import ..., Seller
...
class <strong class="bold">GetSellerWithTokenView</strong>(APIView):
    <strong class="bold">permission_classes = [IsAuthenticated]</strong></pre></li>
				<li>Inside that same <code>GetSellerWithTokenView</code> class, add the following <code>get()</code> method<a id="_idIndexMarker1107"/> and conditional statement:<pre><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong>
...
class <strong class="bold">GetSellerWithTokenView</strong>(APIView):
    ...
    def <strong class="bold">get(</strong>self, request, format=None, id=0, *args,       
        **kwargs<strong class="bold">)</strong>:
        seller = None
        <strong class="bold">req_user = request._user</strong>
        if req_user.has_perm(‘chapter_3.view_seller’):
            perm_granted = True
            try:
                <strong class="bold">seller = Seller.objects.get(id=id)</strong>
            except Seller.DoesNotExist:
                pass
        else:
            perm_granted = False</pre></li>
				<li>Inside that same <code>get()</code> method, add the following <code>context</code>, <code>serializer</code>, <code>new_context</code>, and <code>return</code> statements<a id="_idIndexMarker1108"/> below what you just added to that method:<pre><code>JsonResponse()</code> object to return data as formatted JSON in your endpoint in this way, your endpoint will not be readily available in the Browsable API tool. If you wish for it to be accessible via that tool, use <code>Response()</code> instead. Keep in mind that it may alter the way developers work with the returned data.</p></li>
			</ol>
			<p>In the preceding class, we are following the same logic format as was used in the <code>GetSellerHTMLView</code> class, written in the previous exercise. We added a property called <code>permission_classes</code>, which uses the <code>IsAuthenticated</code> class. This is needed to work with token authentication. We added an additional query to the <code>get()</code> method. The logic here is that we are using two items added to the request headers when the request <a id="_idIndexMarker1109"/>is sent, using the <code>fetch()</code> JavaScript function. Those two headers are <code>HTTP_AUTHORIZATION</code> and <code>HTTP_USER</code>, which we will soon add to our JavaScript function. </p>
			<p>The <code>request._user</code> item is used to look up the user associated with that <code>request</code>, whether the user is logged into the Django admin site or is passed into the request via the <code>HTTP_USER</code> header, that being the <code>test</code> user created for this exercise, the user we will associate with the API request. We are looking up that user to compare individual model permissions using the same <code>has_perm()</code> method from the previous exercise. If the API request user is found, then we are performing the same logic as before to check whether that user has permission to view a <code>seller</code> object. This time, we removed the <code>is_authenticated</code> property from that conditional statement, as we are now relying on this class’s token authentication. If you granted your <code>test</code> user the ability to view a <code>seller</code> object, the logic continues to look up the <code>seller</code> with the ID provided in that input field, the same as before. If your <code>test</code> user is not granted the ability to view a <code>seller</code> object, then the <code>perm_granted</code> context item will return <code>False</code>, to provide an indicator in the data being returned to us.</p>
			<p>The context was broken up into two different items, shown in <em class="italic">step 3</em>, because the request is needed in the context when using <code>SellerSerializer</code>. Then, we are removing that request from the final context being returned as <code>JsonResponse()</code>.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor266"/>Building the template</h2>
			<p>This exercise <a id="_idIndexMarker1110"/>does not require a brand-new template. It will be returning only JSON and is not following the preformatted HTML example.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor267"/>Modifying the JavaScript</h2>
			<p>We will be <a id="_idIndexMarker1111"/>using the same JavaScript example provided in the <em class="italic">Modifying the JavaScript</em> subsection under the <em class="italic">Writing custom API endpoints</em> section. </p>
			<p>Take the following step to modify your JavaScript for this exercise.</p>
			<p>In the same JavaScript file, make the following highlighted changes to your existing <code>$gotoSPA_Page()</code> function:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></pre>
			<pre class="source-code">function $gotoSPA_Page() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">var url = `/chapter-8/sellertoken/${id}/`;</strong></pre>
			<pre class="source-code">    fetch(url, {</pre>
			<pre class="source-code">        method: ‘GET’,</pre>
			<pre class="source-code">        headers: {</pre>
			<pre class="source-code">            ‘Content-Type’: ‘application/json’,</pre>
			<pre class="source-code">            <strong class="bold">‘Authorization’: ‘Token your_token’,</strong></pre>
			<pre class="source-code">            <strong class="bold">‘User’: ‘test’</strong></pre>
			<pre class="source-code">    }}).then(async(response) =&gt; {</pre>
			<pre class="source-code">        return await response.text();</pre>
			<pre class="source-code">    }).then(async(data) =&gt; {</pre>
			<pre class="source-code">        container.innerHTML = await data;</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we are leaving the first three constants, <code>container</code>, <code>input</code>, and <code>id</code>, the same as they have been written in previous examples and represented by the preceding three-dot notation. We are changing the <code>url</code> variable to point to a new path that we will create shortly, <code>`/chapter-8/sellertoken/${id}/`</code>. The rest of the <code>fetch()</code> function is left the same as before, where we are returning the result as preformatted HTML instead of JSON. The only thing different is that we are adding the <code>‘Authorization’</code> and <code>‘User’</code> items to the <code>headers</code> of this request. The value of the <code>‘Authorization’</code> item is the value of the token that was created, the one you were asked to copy earlier; paste that in place of the preceding <code>your_token</code> shown. The value of the <code>‘User’</code> item is the username of the new user/seller that you just created, the one assigned to the token that <a id="_idIndexMarker1112"/>you are providing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Tokens should <em class="italic">never</em> be kept in a JavaScript file, as is done in the preceding example. An explanation for why this is done in the preceding example is provided in the subsection titled <em class="italic">Third demo</em> at the end of this exercise.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor268"/>Mapping the URL pattern</h2>
			<p>We are<a id="_idIndexMarker1113"/> almost done! We just need to map the endpoint that we are communicating with to our new view class. </p>
			<p>Take the following step to map your URL pattern.</p>
			<p>In your <code>/chapter_8/urls.py</code> file, add the following path. You can leave the other paths that have already been created, as depicted:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></pre>
			<pre class="source-code">from .views import ..., GetSellerView, GetSellerHTMLView, </pre>
			<pre class="source-code">    <strong class="bold">GetSellerWithTokenView</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        ‘chapter-8/get-seller/’, </pre>
			<pre class="source-code">        GetSellerView.as_view(), </pre>
			<pre class="source-code">        name = ‘get-seller’</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        ‘chapter-8/seller/&lt;int:id&gt;/’, </pre>
			<pre class="source-code">        GetSellerHTMLView.as_view(), </pre>
			<pre class="source-code">        name = ‘seller-detail’</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘chapter-8/sellertoken/&lt;int:id&gt;/’, </strong></pre>
			<pre class="source-code">        <strong class="bold">GetSellerWithTokenView.as_view(),</strong></pre>
			<pre class="source-code">        <strong class="bold">name = ‘seller-token-detail’</strong></pre>
			<pre class="source-code">    <strong class="bold">),</strong></pre>
			<pre class="source-code">]</pre>
			<p>That’s it; let’s<a id="_idIndexMarker1114"/> demonstrate this code in action next.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor269"/>Third demo</h2>
			<p>Follow <a id="_idIndexMarker1115"/>these steps to see this in action:</p>
			<ol>
				<li value="1">Open a new incognito window and navigate to <code>http://localhost:8000/chapter-8/get-seller/</code>. The reason I am asking you to open an incognito window is to ensure that you are not logged into the Django admin site with any user for this test run. You can also navigate to <code>http://localhost:8000/admin/</code> to double-check, making sure that you are not logged in. </li>
				<li>Next, enter the number <code>1</code> into the input field and click the <code>seller</code> data in JSON format, including the extra <code>perm_granted</code> context that we passed in, as shown in the <a id="_idTextAnchor270"/><a id="_idIndexMarker1116"/>following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_8.14_B17243.jpg" alt="Figure 8.14 – Get seller page – custom API endpoint with token auth&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – Get seller page – custom API endpoint with token auth</p>
			<p>You could also add <code>print()</code> statements to your code to verify if and when each condition is actually met. Additional <code>print()</code> statements and comments providing details have been included with the code of this book. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You will see hyperlinked vehicles in the preceding example if you are inheriting the <code>HyperlinkedModelSerializer</code> class in your serializers. If you are still using the <code>ModelSerializer</code> class, only numeric IDs will be displayed.</p>
			<ol>
				<li value="3">If you were not successful or you enter an incorrect token in your JavaScript file, then you will see an <code>fetch()</code> function just to see the <code>1</code> into the input field again, and click the <strong class="bold">Get Seller Details</strong> button. The invalid token message<a id="_idIndexMarker1117"/> should look something as in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_8.15_B17243.jpg" alt="Figure 8.15 – Get seller page – invalid token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Get seller page – invalid token</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In a real-world example, the token should <em class="italic">never</em> be kept directly in the JavaScript file or even a Python file, if you are using the <code>requests</code> package. Instead, you should consider creating an additional API endpoint that utilizes the built-in token generator called <code>obtain_auth_token</code>, as discussed here: <a href="https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens">https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens</a>. The token generator works by accepting a username and password that is attached to the headers of the first API request and then receives a newly created token in return. Then, a second API request is used to execute the action desired by attaching the token received from the first request to the second request’s headers. The Django REST framework does the rest of the work to authenticate that request using the credentials provided. The examples provided in this exercise are intended only to demonstrate how to perform requests after the token has already been received. The approach of generating tokens requires the use and knowledge of signals, which goes beyond the scope of this book.</p>
			<p>If using the double-request approach as noted in the preceding information box, you can now let developers of third-party apps communicate with your API without needing to create user accounts. However, you can still create a user in your system for that third-party <a id="_idIndexMarker1118"/>user in order to keep using the granular permission levels of your system as was done throughout this exercise. The path you take is determined by the requirements of your project.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor271"/>Summary</h1>
			<p>The examples provided throughout this chapter demonstrate a simple way to construct and work with your newly created API, in a variety of ways! If you want to give your app an SPA-like feel, the simplest implementation is to use the vanilla JavaScript <code>fetch()</code> function or the jQuery <code>ajax()</code> function. Instead of writing your own actions with either of these two functions, you could settle upon using a JavaScript-based framework, such as React, AngularJS, or Vue.js, just to name a few. The JavaScript-based frameworks can format and style your HTML on the client side. One of the template-based approaches provided in this chapter also demonstrates how this work can be transferred from the client side onto the server side. This provides you with numerous tools in your toolbox, in regard to building and working with an API. </p>
			<p>We also learned how to work with authentication tokens and discovered that we can still work with tokens when formatting HTML on the server side. However, the token approach does require additional, more advanced topics of Django and security measures before being able to fully implement that approach on a live site. The Django REST framework is intended to be the backend of an API and is designed to work with any frontend that a team settles upon.</p>
			<p>In the next chapter, we’ll explore how to test our project and make sure what has been written does actually work. To do that, we will explore how to write automated test scripts, and then install a new package that provides even more tools, as well as learning how to use them. </p>
		</div>
	</body></html>