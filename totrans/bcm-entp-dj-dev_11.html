<html><head></head><body>
		<div id="_idContainer127">
			<h1 id="_idParaDest-215"><em class="italic"><a id="_idTextAnchor239"/>Chapter 8</em>: Working with the Django REST Framework</h1>
			<p>This chapter will focus on <a id="_idIndexMarker1014"/>working with an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). An API is actually a set of tools and communication protocols working to allow two different applications to communicate with each other effectively; it is what acts as the middleman between two systems. A <strong class="bold">REST API</strong> adopts the design principles set forth in a <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) software architecture and is most commonly used with web-based applications. Every time we mention the word API in this chapter, we are really referring to a REST API as they are technically slightly different but usually interpreted as the same thing. </p>
			<p>Django itself relies on third-party packages to work with an existing API or to create an API yourself. A common Python package that is available is called the <strong class="source-inline">requests</strong> package. The <strong class="source-inline">requests</strong> package is used to send and receive requests to and from an existing API found on the server side. More information about this package can be found here: <a href="https://pypi.org/project/requests/">https://pypi.org/project/requests/</a>. On the other hand, a JavaScript-based framework, such as React, AngularJS, or Vue.js, to name a few, will all perform these requests on the client side, within the user’s browser. There is no right or wrong way to communicate with an API, in terms of choosing tools that operate on the client versus the server side. Those decisions are made as a result of the technical requirements obtained for your project. We won’t actually be using the <strong class="source-inline">requests</strong> package or any of the client-side JavaScript-based frameworks; instead, we will focus on just the <strong class="bold">Django REST framework</strong>, which is used to build a model-based API for the models we previously created.</p>
			<p>The Django REST framework is licensed as open source, allowing developers to use it within their commercial or private applications. It is used to construct APIs based on the models of a Django project, where endpoints execute HTTP requests that perform <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations. This means it is used to serialize and deserialize related models of a Django project into JSON format, commonly used in web-based APIs. When using the Django REST framework, there is no need to use the pip <strong class="source-inline">requests</strong> package, but it won’t hurt either if you use this package in combination with the framework, which is sometimes done in projects. This chapter will focus entirely on using the Django REST framework to create an API for all of the vehicle models that we created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. We will be serializing those models and registering URL patterns, which are the API endpoints, to views and viewsets that we write. We will also be using routers to generate some of those URL patterns for us, based entirely on the data that exists in our database tables.</p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Installing and configuring the Django REST framework</li>
				<li>Serializing related models of a project</li>
				<li>Using the browsable API, a tool provided by the Django REST framework</li>
				<li>Creating SPA-style pages</li>
				<li>Creating custom API endpoints</li>
				<li>Performing API requests using token authentication measures</li>
			</ul>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor240"/>Technical requirements</h1>
			<p>To work with the code in this chapter, the following tools will need to be installed on your local machine:</p>
			<ul>
				<li>Python version 3.9 – used as the underlying programming language for the project</li>
				<li>Django version 4.0 – used as the backend framework of the project</li>
				<li>pip package manager – used to manage third-party Python/Django packages</li>
			</ul>
			<p>We will continue to work with the solution created in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. However, it is not necessary to use the Visual Studio IDE. The main project itself can be run using another IDE or run independently using a terminal or command-line window from within the project root folder, which is where the <strong class="source-inline">manage.py</strong> file resides. Whatever editor or IDE you are using, a virtual environment will also be needed to work with the Django project. Instructions for how to create a project and virtual environment can be found in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. You will need a database to store the data contained in your project. PostgreSQL was chosen for the examples in the previous chapter; however, any database type that you choose for your project can be used to work with the examples in this chapter. <a id="_idTextAnchor241"/></p>
			<p>We will also be using data that is in the form of a Django fixture, provided in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, in the subsection titled <em class="italic">Loading the chapter_3 data fixture</em>. Make sure the <strong class="source-inline">chapter_3</strong> fixture is loaded into your database. If this has already been done, then you may skip the next command. If you have already created the tables found in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, and have not loaded that fixture yet, then run the following command, after activating your virtual environment:</p>
			<p class="source-code">(virtual_env) PS &gt; python manage.py loaddata chapter_3</p>
			<p>All of the code created in this chapter can be found in the GitHub repository for this book: <a href="https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer">https://github.com/PacktPublishing/Becoming-an-Enterprise-Django-Developer</a>. The bulk of the code depicted in this chapter can be found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/</strong> directory.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3Ojocdx">https://bit.ly/3Ojocdx</a>.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor242"/>Preparing for this chapter</h1>
			<p>Start by creating a new app in your project called <strong class="source-inline">chapter_8</strong> by following the steps discussed in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>, in the subsection titled <em class="italic">Creating a Django app</em>. As discussed in that section, don’t forget to change the value of the <strong class="source-inline">name =</strong> variable for your app class found in the <strong class="source-inline">/becoming_a_django_entdev/becoming_a_django_entdev/chapter_8/apps.py</strong> file to now point to the path where you installed your app. Be sure to also include this app in the <strong class="source-inline">INSTALLED_APPS</strong> variable found in the <strong class="source-inline">settings.py</strong> file as well.</p>
			<p>In the main <strong class="source-inline">urls.py</strong> file of the site, add the following path, which points to the URL patterns of this chapter that we will be creating:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/urls.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘’, </strong></pre>
			<pre class="source-code">        <strong class="bold">include(</strong></pre>
			<pre class="source-code">            <strong class="bold">‘becoming_a_django_entdev.chapter_8.urls’</strong></pre>
			<pre class="source-code">        <strong class="bold">)</strong></pre>
			<pre class="source-code">    <strong class="bold">)</strong>,</pre>
			<pre class="source-code">]</pre>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor243"/>Installing the Django REST framework</h2>
			<p>To install the <a id="_idIndexMarker1015"/>Django REST framework in any Django project and enable the bare-minimum settings needed to begin working with it, follow these steps:</p>
			<ol>
				<li>Add the <strong class="source-inline">djangorestframework</strong>, <strong class="source-inline">markdown</strong>, and <strong class="source-inline">django-filter</strong> packages to your <strong class="source-inline">requirements.txt</strong> file and install them in your virtual environment using your IDE or command line. You can also run the following individual <strong class="source-inline">pip</strong> commands. Use the first of the following commands to activate your virtual environment:<p class="source-code"><strong class="bold">PS C:\Projects\Packt\Repo\becoming_a_django_entdev&gt; virtual_env/Scripts/activate</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; pip install djangorestframework</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; pip install markdown</strong></p><p class="source-code"><strong class="bold">(virtual_env) PS &gt; pip install django-filter</strong></p></li>
			</ol>
			<p>There is no need to run the Django migration commands when installing these three packages as no additional tables will be created by them. </p>
			<ol>
				<li value="2">Next, in your <strong class="source-inline">settings.py</strong> file, add the following app to the <strong class="source-inline">INSTALLED_APPS</strong> list. Then, add the <strong class="source-inline">REST_FRAMEWORK</strong> dictionary, including the <strong class="source-inline">DjangoModelPermissionsOrAnonReadOnly</strong> permission class shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">INSTALLED_APPS = [</p><p class="source-code">    ...</p><p class="source-code">    ‘rest_framework’,</p><p class="source-code">]</p><p class="source-code">REST_FRAMEWORK = {</p><p class="source-code">    <strong class="bold">‘DEFAULT_PERMISSION_CLASSES’</strong>: [</p><p class="source-code">        <strong class="bold">‘rest_framework.permissions.</strong></p><p class="source-code"><strong class="bold">            DjangoModelPermissionsOrAnonReadOnly’</strong></p><p class="source-code">    ],</p><p class="source-code">}</p></li>
			</ol>
			<p>This permission class allows us to check for model-based CRUD rights and allows anonymous users to only view or read items. For a complete breakdown of the over half-dozen other permission classes, visit <a href="https://www.django-rest-framework.org/api-guide/permissions/">https://www.django-rest-framework.org/api-guide/permissions/</a>. We will only be working with one permission class throughout this chapter. </p>
			<ol>
				<li value="3">You will need to register the URL patterns related to this framework’s authentication <a id="_idIndexMarker1016"/>mechanisms. In your <strong class="source-inline">/chapter_8/urls.py</strong> file, add the following <strong class="source-inline">include</strong> pattern, along with a home page and Django admin site links for this chapter, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></p><p class="source-code">from django.contrib import admin</p><p class="source-code">from django.urls import include, path</p><p class="source-code">from django.views.generic import TemplateView</p><p class="source-code">urlpatterns = [</p><p class="source-code">    path(‘admin/’, admin.site.urls),</p><p class="source-code">    path(</p><p class="source-code">        ‘’, </p><p class="source-code">        TemplateView.as_view(</p><p class="source-code">            template_name = ‘chapter_8/index.html’</p><p class="source-code">        )</p><p class="source-code">    ),</p><p class="source-code">    <strong class="bold">path(‘api-auth/’, include(‘rest_framework.urls’))</strong></p><p class="source-code">]</p></li>
				<li>We also need to include the admin site URLs just like we did in <a href="B17243_06_ePub.xhtml#_idTextAnchor190"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring the Django Admin Site</em>, for this chapter. If you have already placed this include statement in the main <strong class="source-inline">urls.py</strong> file of your project, then you do not need to include it again in the <strong class="source-inline">chapter_8</strong> app. </li>
			</ol>
			<p>Now, the Django <a id="_idIndexMarker1017"/>REST framework is installed and ready to use in your project. Currently, we have no API URLs except for the authentication URLs that come with this framework. Currently, those authentication URLs don’t provide us with anything to do. You can navigate to the login page just to see whether it loads properly by visiting the URL <strong class="source-inline">http://localhost:8000/api-auth/login/</strong>. If you log in with your superuser account, there will currently be nothing to display and it will show you a <strong class="bold">404 Page not found</strong> message. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The reason we enabled the Django admin site URL patterns for the <strong class="source-inline">chapter_8</strong> app is to be able to log into the Django admin site with a superuser account and authenticate a user when working with some of the exercises in this chapter. For those exercises, if you are not logged in, you will find a message in your results stating <strong class="bold">Authentication credentials were not provided</strong>. For other exercises toward the end of this chapter, you will not need to be logged into the Django admin site; authentication will be performed by using token-based authorization measures.</p>
			<p>To begin using this framework and creating new API endpoints, we will start by creating a serializer class <a id="_idIndexMarker1018"/>for each of the models created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor244"/>Serializing objects</h1>
			<p>Creating an API <a id="_idIndexMarker1019"/>starts with creating a serializer class and then creating<a id="_idIndexMarker1020"/> a view, in particular a <strong class="source-inline">ModelViewSet</strong> view class. Serializing objects means converting a model object into JSON format to represent the data of that object. The last thing we need to do is create URL patterns that map to the view classes that we wrote; this will be done using URL routers. These URL patterns are considered your API endpoints.</p>
			<p>One thing to note in this section is that we need to create serializers for all models that relate to other models when using related fields. This is why the following exercises will show examples for all four models of the <strong class="source-inline">chapter_3</strong> app. This has to be done in order to ensure that we do not get errors when usi<a id="_idTextAnchor245"/>ng the Browsable API, which we will introduce later in this chapter, and when performing API requests. This means if you have multiple <strong class="source-inline">Seller</strong> that have been assigned a <strong class="source-inline">Group</strong> or <strong class="source-inline">Permission</strong>, that <strong class="source-inline">Group</strong> and/or <strong class="source-inline">Permission</strong> object will also have to be serialized. Remember, the <strong class="source-inline">Seller</strong> object replaced the default <strong class="source-inline">User</strong> object found in the <strong class="source-inline">django.contrib.auth.models</strong> library when we changed the <strong class="source-inline">AUTH_USER_MODEL</strong> setting to now equal <strong class="source-inline">‘chapter_3.Seller’</strong> in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. Examples for serializing the <strong class="source-inline">Group</strong> or <strong class="source-inline">Permission</strong> objects are not shown because there is only one <strong class="source-inline">Seller</strong> provided in the <strong class="source-inline">chapter_3</strong> data fixture, as shown:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_8.01_B17243.jpg" alt="Figure 8.1 – chapter_3 data fixture – Seller object"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – chapter_3 data fixture – Seller object</p>
			<p>The <strong class="source-inline">Seller</strong> here is not assigned to a <strong class="source-inline">Group</strong> or <strong class="source-inline">Permission</strong>, so as a result, we should not experience errors in the following exercises. Instead, that <strong class="source-inline">Seller</strong> has the <strong class="source-inline">is_superuser</strong> field set to <strong class="source-inline">true</strong>, which allows us to perform all of the CRUD operations when <a id="_idIndexMarker1021"/>logged<a id="_idIndexMarker1022"/> into the Django admin site.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you experience errors, either delete all but the <strong class="source-inline">Seller</strong> data shown previously or it is recommended to just create the additional serializers, viewsets, and routers for the <strong class="source-inline">Group</strong> and <strong class="source-inline">Permission</strong> objects. Follow the same code format that is used in the following examples. The same applies to the <strong class="source-inline">ContentType</strong> object found in the <strong class="source-inline">django.contrib.contenttypes.models</strong> library. This will be needed if you have a <strong class="source-inline">depth</strong> property defined in the <strong class="source-inline">Meta</strong> subclass of that serializer class, more specifically, if <strong class="source-inline">depth</strong> is set to a value of <strong class="source-inline">2</strong> or greater. We will discuss what this property does soon.</p>
			<p>Next, let’s begin writing our serializer and learn more about the classes that are available to use.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor246"/>The serializer classes</h2>
			<p>The <strong class="source-inline">rest_framework.serializers</strong> library<a id="_idIndexMarker1023"/> provides us with<a id="_idIndexMarker1024"/> five classes, as follows:</p>
			<ul>
				<li><strong class="source-inline">Serializer</strong> – used when nesting <strong class="source-inline">ManyToManyField</strong>, <strong class="source-inline">ForeignKey</strong>, and <strong class="source-inline">OneToOneField</strong> relationships.</li>
				<li><strong class="source-inline">ModelSerializer</strong> – used to create serializers with fields that map directly to fields of models found in your project.</li>
				<li><strong class="source-inline">HyperlinkedModelSerializer</strong> – used to do everything the <strong class="source-inline">ModelSerializer</strong> class does, except it will generate a clickable link to each related object when viewed in the Browsable API, instead of displaying those objects as a numeric ID.</li>
				<li><strong class="source-inline">ListSerializer</strong> – used to serialize multiple objects in one request and is often used by Django when <strong class="source-inline">Serializer</strong>, <strong class="source-inline">ModelSerializer</strong>, or <strong class="source-inline">HyperlinkedModelSerializer</strong> has been initialized with the <strong class="source-inline">many=True</strong> attribute defined.</li>
				<li><strong class="source-inline">BaseSerializer</strong> – provided to allow developers the ability to create their own serialization and deserialization styles. This is similar to how the <strong class="source-inline">BaseStorage</strong> class is used in the Django messages framework, as discussed in <a href="B17243_07_ePub.xhtml#_idTextAnchor214"><em class="italic">Chapter 7</em></a>, <em class="italic">Working with Messages, Email Notifications, and PDF Reports</em>, in the subsection titled <em class="italic">Message storage backends</em>.</li>
			</ul>
			<p>Begin by following these steps to create a <strong class="source-inline">ModelSerializer</strong> class for each model created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, the <strong class="source-inline">Engine</strong>, <strong class="source-inline">Vehicle</strong>, <strong class="source-inline">VehicleModel</strong>, and <strong class="source-inline">Seller</strong> models:</p>
			<ol>
				<li value="1">Create a new file in your <strong class="source-inline">/becoming_a_django_entdev/chapter_8/</strong> folder called <strong class="source-inline">serializers.py</strong>. Inside this file, add the following imports:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></p><p class="source-code">from rest_framework.serializers import ModelSerializer</p><p class="source-code">from ..chapter_3.models import (</p><p class="source-code">    Seller, </p><p class="source-code">    Vehicle, </p><p class="source-code">    Engine, </p><p class="source-code">    VehicleModel</p><p class="source-code">)</p></li>
				<li>In this file, add the <strong class="source-inline">EngineSerializer</strong> class shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">EngineSerializer</strong>(ModelSerializer):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = Engine</p><p class="source-code">        fields = ‘__all__’</p></li>
				<li>In this <a id="_idIndexMarker1025"/>file, add the <strong class="source-inline">VehicleModelSerializer</strong> class shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">VehicleModelSerializer</strong>(ModelSerializer):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = VehicleModel</p><p class="source-code">        fields = ‘__all__’</p></li>
				<li>In this file, add the <strong class="source-inline">VehicleSerializer</strong> class shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">VehicleSerializer</strong>(ModelSerializer):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = Vehicle</p><p class="source-code">        fields = ‘__all__’</p></li>
				<li>In this file, add the <strong class="source-inline">SellerSerializer</strong> class shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">SellerSerializer</strong>(ModelSerializer):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = Seller</p><p class="source-code">        fields = ‘__all__’</p></li>
			</ol>
			<p>You might notice that the preceding classes resemble some of the classes used in the exercises found in previous<a id="_idIndexMarker1026"/> chapters. Here, we defined the fields using the <strong class="source-inline">‘__all__’</strong> value but we can provide a list of only the fields needed and the order in which we need them, as was done with the form classes of <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>.</p>
			<h3>The Meta subclass</h3>
			<p>The <strong class="source-inline">Meta</strong> subclass <a id="_idIndexMarker1027"/>provides <a id="_idIndexMarker1028"/>additional options, similar to how we customized the <strong class="source-inline">Meta</strong> subclasses in the models written for <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. For a complete breakdown of all the <strong class="source-inline">Meta</strong> class options available and anything about serializers in general, visit <a href="https://www.django-rest-framework.org/api-guide/serializers/">https://www.django-rest-framework.org/api-guide/serializers/</a>. Other options include the following: </p>
			<ul>
				<li><strong class="source-inline">model</strong> – used to specify the model class to map that serializer to.</li>
				<li><strong class="source-inline">fields</strong> – used to specify what fields, or all fields, to include in that serializer.</li>
				<li><strong class="source-inline">validators</strong> – used to add validation when performing a create or update operation. Similar to how form validation was used in <a href="B17243_05_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 5</em></a>, <em class="italic">Django Forms</em>, Django will rely on any constraints set at the database level first, and then it will check for validation applied at the serializer level. More information about serializer validators can be found here: <a href="https://www.django-rest-framework.org/api-guide/validators/">https://www.django-rest-framework.org/api-guide/validators/</a>. </li>
				<li><strong class="source-inline">depth</strong> – used to represent related objects as nested JSON instead of using the numeric ID up to the depth specified. The default value for this option is <strong class="source-inline">0</strong>.</li>
				<li><strong class="source-inline">read_only_fields</strong> – used to specify the fields that are read-only at the serializer level.</li>
				<li><strong class="source-inline">extra_kwargs</strong> – used to specify extra keyword arguments on specific fields within that serializer.</li>
				<li><strong class="source-inline">list_serializer_class</strong> – used to specify a custom <strong class="source-inline">ListSerializer</strong> that was created using the <strong class="source-inline">ListSerializer</strong> class. This is done when you need to modify the behavior of the <strong class="source-inline">ListSerializer</strong> class, such as performing custom validation on the entire set, for example, comparing values of nested objects versus performing field-level validation.</li>
			</ul>
			<p>Now that<a id="_idIndexMarker1029"/> we<a id="_idIndexMarker1030"/> have serializer classes to work with, we need to create a view class for them. We can do that with the <strong class="source-inline">ModelViewSet</strong> class provided by the Django <a id="_idTextAnchor247"/>REST framework.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor248"/>The viewset classes</h2>
			<p>Instead of <a id="_idIndexMarker1031"/>creating views/methods for each CRUD<a id="_idIndexMarker1032"/> operation, the Django REST framework offers a class that combines them all into one. It starts by creating a view class within the <strong class="source-inline">views.py</strong> file, similar to what we did in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, except they are constructed using one of the following viewset classes. The Django REST framework provides the following four viewset classes:</p>
			<ul>
				<li><strong class="source-inline">GenericViewSet</strong> – includes methods that perform certain operations, commonly used for creating APIs that are not model-based.</li>
				<li><strong class="source-inline">ModelViewSet</strong> – this class includes all of the methods needed to perform CRUD operations and is intended to map directly to the models of your project.</li>
				<li><strong class="source-inline">ReadOnlyModelViewSet</strong> – only provides read actions and all other methods will not be provided. This viewset is also intended to work with the models of your project.</li>
				<li><strong class="source-inline">ViewSet</strong> – used by developers to create custom viewsets similar to how the <strong class="source-inline">BaseSerializer</strong> and <strong class="source-inline">BaseStorage</strong> classes were used. This class does not provide any actions and those methods will have to be created by the developer in order to use this class.</li>
			</ul>
			<p>Follow these steps to prepare your viewset classes:</p>
			<ol>
				<li value="1">In <a id="_idIndexMarker1033"/>your <strong class="source-inline">/chapter_8/views.py</strong> file, add the <a id="_idIndexMarker1034"/>following imports:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">from rest_framework.permissions import <strong class="bold">IsAuthenticated</strong></p><p class="source-code">from rest_framework.viewsets import <strong class="bold">ModelViewSet</strong></p><p class="source-code">from .serializers import (</p><p class="source-code">    <strong class="bold">EngineSerializer</strong>,</p><p class="source-code">    <strong class="bold">SellerSerializer</strong>,</p><p class="source-code">    <strong class="bold">VehicleSerializer</strong>,</p><p class="source-code">    <strong class="bold">VehicleModelSerializer</strong></p><p class="source-code">)</p><p class="source-code">from ..chapter_3.models import (</p><p class="source-code">    Engine, </p><p class="source-code">    Seller, </p><p class="source-code">    Vehicle, </p><p class="source-code">    VehicleModel</p><p class="source-code">)</p></li>
				<li>In that same file, add the following <strong class="source-inline">EngineViewSet</strong> class, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">EngineViewSet</strong>(ModelViewSet):</p><p class="source-code">    queryset = Engine.objects.all().order_by(‘name’)</p><p class="source-code">    serializer_class = <strong class="bold">EngineSerializer</strong></p><p class="source-code">    permission_classes = [IsAuthenticated]</p></li>
				<li>In that same file, add the following <strong class="source-inline">VehicleModelViewSet</strong> class, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">VehicleModelViewSet</strong>(ModelViewSet):</p><p class="source-code">    queryset = VehicleModel.objects.all().order_by(</p><p class="source-code">        ‘name’</p><p class="source-code">    )</p><p class="source-code">    serializer_class = <strong class="bold">VehicleModelSerializer</strong></p><p class="source-code">    permission_classes = [IsAuthenticated]</p></li>
				<li>In <a id="_idIndexMarker1035"/>that<a id="_idIndexMarker1036"/> same file, add the following <strong class="source-inline">VehicleViewSet</strong> class, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">VehicleViewSet</strong>(ModelViewSet):</p><p class="source-code">    queryset = Vehicle.objects.all().order_by(‘price’)</p><p class="source-code">    serializer_class = <strong class="bold">VehicleSerializer</strong></p><p class="source-code">    permission_classes = [IsAuthenticated]</p></li>
				<li>In that same file, add the following <strong class="source-inline">SellerViewSet</strong> class, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">SellerViewSet</strong>(ModelViewSet):</p><p class="source-code">    queryset = Seller.objects.all()</p><p class="source-code">    serializer_class = <strong class="bold">SellerSerializer</strong></p><p class="source-code">    permission_classes = [IsAuthenticated]</p></li>
			</ol>
			<p>In each class depicted, we define only three properties for each of those classes, the <strong class="source-inline">queryset</strong>, <strong class="source-inline">serializer_class</strong>, and <strong class="source-inline">permission_classes</strong> properties. In the preceding examples, we are only using the <strong class="source-inline">all()</strong> method to search for all records within that table. Instead of using the <strong class="source-inline">all()</strong> method, the <strong class="source-inline">filter()</strong> and <strong class="source-inline">get()</strong> functions can also be used to look up specific records. The <strong class="source-inline">serializer_class</strong> property is used to map your view to the serializer class that we constructed in the previous subsection; it maps to the model class that we are performing the query on. The <strong class="source-inline">permission_classes</strong> property is used to define the permissions for that request. Permissions differ from the authentication token that we will discuss toward the end of this chapter. Permissions ensure the user who is accessing the system is allowed to perform those specific CRUD operations on the model in question. These are the only three properties available and only the first two are required when using a <strong class="source-inline">ModelViewSet</strong> or <strong class="source-inline">GenericViewSet</strong> class; the last is optional. You can also customize these <a id="_idIndexMarker1037"/>using a callable method or even override<a id="_idIndexMarker1038"/> the default action methods yourself. To learn more about viewsets, visit <a href="https://www.django-rest-framework.org/api-guide/viewsets/">https://www.django-rest-framework.org/api-guide/viewsets/</a>.</p>
			<p>Next, let’s configure those URL routers to map to the viewsets that we just created. These will be the API endpoints of your project.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor249"/>Using URL routers</h2>
			<p>URL routers <a id="_idIndexMarker1039"/>are used as a way to prevent <a id="_idIndexMarker1040"/>developers from having to write individual URL patterns for each of the CRUD operations pertaining to each model in your API. That can get very complicated after a while and the Django REST framework provides these URL routers as a means to automatically generate each endpoint for you.</p>
			<p>Follow these steps to configure your routers:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_8/urls.py</strong> file, add the following <strong class="source-inline">import</strong> statements: <p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></p><p class="source-code">...</p><p class="source-code">from rest_framework import <strong class="bold">routers</strong></p><p class="source-code">from .views import (</p><p class="source-code">    <strong class="bold">EngineViewSet</strong>,</p><p class="source-code">    <strong class="bold">SellerViewSet</strong>,</p><p class="source-code">    <strong class="bold">VehicleViewSet</strong>,</p><p class="source-code">    <strong class="bold">VehicleModelViewSet</strong></p><p class="source-code">)</p></li>
				<li>In that<a id="_idIndexMarker1041"/> same<a id="_idIndexMarker1042"/> file, add the following <strong class="source-inline">router</strong> and <strong class="source-inline">register</strong> statements:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></p><p class="source-code">...</p><p class="source-code">router = routers.DefaultRouter()</p><p class="source-code">router.register(r’engines’, <strong class="bold">EngineViewSet</strong>)</p><p class="source-code">router.register(r’sellers’, <strong class="bold">SellerViewSet</strong>)</p><p class="source-code">router.register(r’vehicles’, <strong class="bold">VehicleViewSet</strong>)</p><p class="source-code">router.register(</p><p class="source-code">    r’vehicle-models’,</p><p class="source-code">    <strong class="bold">VehicleModelViewSet</strong></p><p class="source-code">)</p></li>
				<li>In that same file, include the following <strong class="source-inline">include</strong> path for your routers:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></p><p class="source-code">...</p><p class="source-code">urlpatterns = [</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">path(‘chapter-8/’, include(router.urls)),</strong></p><p class="source-code">    path(‘api-auth/’, include(‘rest_framework.urls’)),</p><p class="source-code">]</p></li>
			</ol>
			<p>The <strong class="source-inline">include(router.urls)</strong> path shown previously is placed between the <strong class="source-inline">api-auth</strong> path and below your admin and home page paths. A router variable is defined for each model using the <strong class="source-inline">routers.DefaultRouter()</strong> class provided by the Django REST framework. Each <strong class="source-inline">router.register()</strong> function creates a set of URL patterns for that model. For example, where the <strong class="source-inline">engines</strong> path is shown in this URL, <strong class="source-inline">http://localhost:8000/chapter-8/engines/</strong>, that is what is defined in the first parameter of the first register function, as <strong class="source-inline">r’engines’</strong>. The router generated a set of URL patterns, one for each object in that table, which gets added to your <strong class="source-inline">urlpatterns</strong> list using the <strong class="source-inline">path(‘chapter-8/’, include(router.urls))</strong> path. Adding <strong class="source-inline">chapter-8</strong> to this <strong class="source-inline">path()</strong> function is where we are telling Django to prefix <strong class="source-inline">http://localhost:8000/chapter-8/</strong> for every path created using this set of routers. </p>
			<p>That’s it; you now have a very basic API to use with the four models created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>. To test your API and see the data that would be sent<a id="_idIndexMarker1043"/> and received in each request, we will use <a id="_idIndexMarker1044"/>the Browsable API next, which is provided with the Django REST framework.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor250"/>Using the Browsable API</h1>
			<p><strong class="bold">The Browsable API</strong> is a <a id="_idIndexMarker1045"/>built-in tool that allows for <a id="_idIndexMarker1046"/>easy browsing and testing of your API. It allows us to read and view data in JSON and API format. This section will teach us how to use and access this tool. When we added the <strong class="source-inline">chapter-8</strong> path to the URL routers in the previous section, we activated that path as what is <a id="_idIndexMarker1047"/>called the <strong class="bold">API root</strong>, which provides all of the URLs available in your API, with some exceptions. Visit <strong class="source-inline">http://localhost:8000/chapter-8/</strong> to see these URLs, as depicted here:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Figure_8.02_B17243.jpg" alt="Figure 8.2 – The Browsable API – API root&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – The Browsable API – API root</p>
			<p>When building custom API endpoints, as we will do later in this chapter, you will likely not see them <a id="_idIndexMarker1048"/>displayed in your API root. You’ll see<a id="_idIndexMarker1049"/> that the serializers for the groups, permissions, and content types have all been included with the code of this book. There is a dropdown at the top right of every main router path that we created, to switch between the two formats, API and JSON, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/Figure_8.03_B17243.jpg" alt="Figure 8.3 – The Browsable API – GET formats&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – The Browsable API – GET formats</p>
			<p>If using <strong class="source-inline">HyperlinkedModelSerializer</strong> to construct your serializer classes, each object will be displayed as a clickable URL versus an ID that is not clickable. The hyperlinked version is shown in the following screenshot, when visiting the main URL path that the router created for the <strong class="source-inline">Seller</strong> model at <strong class="source-inline">http://localhost:8000/chapter-8/sellers/</strong>:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/Figure_8.04_B17243.jpg" alt="Figure 8.4 – The Browsable API – Sellers list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – The Browsable API – Sellers list</p>
			<p>To view the same results as in the preceding screenshot, just change <strong class="source-inline">ModelSerializer</strong> to <strong class="source-inline">HyperlinkedModelSerializer</strong> in all of your serializer classes. Also, change your <strong class="source-inline">SellerSerializer</strong> class to exclude the fields shown in the following code in order to prevent an error indicating an incorrectly configured <strong class="source-inline">lookup_field</strong>, which<a id="_idIndexMarker1050"/> is an advanced topic<a id="_idIndexMarker1051"/> that goes beyond the scope of this book to resolve:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/serializers.py</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">from rest_framework.serializers import (</pre>
			<pre class="source-code">    <strong class="bold">HyperlinkedModelSerializer</strong>,</pre>
			<pre class="source-code">    ModelSerializer</pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">class <strong class="bold">SellerSerializer</strong>(<strong class="bold">HyperlinkedModelSerializer</strong>):</pre>
			<pre class="source-code">    class Meta:</pre>
			<pre class="source-code">        model = Seller</pre>
			<pre class="source-code">        #fields = ‘__all__’</pre>
			<pre class="source-code">        exclude = <strong class="bold">[‘groups’, ‘user_permissions’]</strong></pre>
			<p>On each of the routers registered in the previous subsection, the main URL, such as the <strong class="source-inline">http://localhost:8000/chapter-8/sellers/</strong> link shown previously, will allow you to perform a create operation (a <strong class="source-inline">POST</strong> request) using the form at the bottom of that page. Just viewing this page performs a read operation (a <strong class="source-inline">GET</strong> request). A <strong class="bold">detail page</strong>, such <a id="_idIndexMarker1052"/>as <strong class="source-inline">http://localhost:8000/chapter-8/sellers/1/</strong>, includes a form at the bottom of that page that <a id="_idIndexMarker1053"/>will <a id="_idIndexMarker1054"/>allow you to perform <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">DELETE</strong> operations for the object being viewed, as shown here:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/Figure_8.05_B17243.jpg" alt="Figure 8.5 – The Browsable API – Sellers detail&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The Browsable API – Sellers detail</p>
			<p>By default, Django will show the <strong class="bold">Raw data</strong> tab that is shown in the preceding screenshot. The <strong class="bold">HTML form</strong> tab will only allow <strong class="bold">PUT</strong> operations. The <strong class="bold">Delete</strong> button is found at the top of this page, not where the <strong class="bold">PUT</strong> and <strong class="bold">PATCH</strong> buttons are located in the preceding screenshot. If you are logged into the Django admin site using a <strong class="source-inline">Seller</strong> that does not have superuser status, then that user/seller must have group or individual permission-level access granted in order to perform any of the CRUD operations on that model object. If a user/seller only has permission to do one thing and not the other, such as update but not delete or create and not update, then only those action buttons will appear. If you do not see any of the action buttons where you would expect to see them, double-check your permission settings for that user.</p>
			<p>Now that <a id="_idIndexMarker1055"/>we <a id="_idIndexMarker1056"/>have a working API and have explored how to use the Browsable API, let’s build pages that change content without needing to reload or redirect that page.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor251"/>Building SPA-like pages</h1>
			<p><strong class="bold">Single-Page App</strong> (<strong class="bold">SPA</strong>) pages <a id="_idIndexMarker1057"/>are web pages where content gets updated within containers/nodes rather than reloading or redirecting the page to display that data. Usually, some of the work of the server is offloaded to the client’s browser to perform these requests and/or render the HTML, usually with JavaScript or jQuery. When an event is triggered, such as the clicking of a button or submission of a form, JavaScript is used to obtain the data from the server and then render that content onto the page, wherever we want it to display. </p>
			<p>In this exercise, we will use the API endpoint of the <strong class="source-inline">Seller</strong> created by the router, at <strong class="source-inline">http://localhost:8000/chapter-8/sellers/1/</strong>, to render JSON as a string within a container found in the body of a query page. The query page is just a standard page that uses JavaScript to communicate with an API endpoint.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor252"/>Creating the view</h2>
			<p>In this<a id="_idIndexMarker1058"/> subsection, we will build the view to handle a page where the user can enter a number relating to the ID of a <strong class="source-inline">Seller</strong> that they want to query. This will be known as the <strong class="source-inline">GetSellerView</strong> class and it will be used as the backbone for the remaining two exercises of this chapter. </p>
			<p>To get started, take the following step:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">/chapter_8/views.py</strong> file and add the following <strong class="source-inline">GetSellerView</strong> class:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.template.response import <strong class="bold">TemplateResponse</strong></p><p class="source-code">from django.views.generic import <strong class="bold">View</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">GetSellerView</strong>(<strong class="bold">View</strong>):</p><p class="source-code">    template_name =   </p><p class="source-code">        <strong class="bold">‘chapter_8/spa_pages/get_seller.html’</strong></p><p class="source-code">    def get(self, request, *args, **kwargs):</p><p class="source-code">        context = {}</p><p class="source-code">        return TemplateResponse(</p><p class="source-code">            request, </p><p class="source-code">            self.template_name, </p><p class="source-code">            context</p><p class="source-code">        )</p></li>
			</ol>
			<p>In the preceding example, we are constructing a class-based view the same as we did in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>. The only thing we are doing differently here is we are not including the <strong class="source-inline">post()</strong> method; we only provided the <strong class="source-inline">get()</strong> method. Since we are not working with form submissions. The call-to-action button will be controlled using JavaScript as a button of <strong class="source-inline">type=’button’</strong> and not <strong class="source-inline">type=’submit’</strong>. There is no need to use the <strong class="source-inline">post()</strong> method when that is done. Also, we are<a id="_idIndexMarker1059"/> creating a standard Django view class and not a REST API view class because this page is only used to communicate with API endpoints and not to serve as an API endpoint itself.</p>
			<p>Now, let’s create the template to format the HTML that gets rendered to the page.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor253"/>Building the template</h2>
			<p>The previous<a id="_idIndexMarker1060"/> subsection constructed the view for this exercise. This subsection will create the template that is used in our exercise. </p>
			<p>Follow these steps to create your template:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">get_seller.html</strong> template file in the <strong class="source-inline">/chapter_8/templates/chapter_8/spa_pages/</strong> folder. </li>
				<li>Earlier, in <a href="B17243_04_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 4</em></a>, <em class="italic">URLs, Views, and Templates</em>, we created a file called <strong class="source-inline">/chapter_4/templates/chapter_4/base/base_template_1.html</strong>. We will repurpose that file for this chapter. Go ahead and copy this file and any related template files, into your <strong class="source-inline">chapter_8</strong> app. Related template files include the header, footer, JavaScript, and CSS files that are referenced inside the <strong class="source-inline">base_template_1.html</strong> file. Place them in the <strong class="source-inline">templates</strong> and <strong class="source-inline">static</strong> directories in the same subfolders that you copied them from and then rename any mention of <strong class="source-inline">chapter_4</strong> and <strong class="source-inline">chapter-4</strong> to now reference <strong class="source-inline">chapter_8</strong> and <strong class="source-inline">chapter-8</strong> inside those files. You can always copy the <strong class="source-inline">chapter_8</strong> JavaScript, CSS, and template files found in the code of this book. </li>
				<li>Next, in<a id="_idIndexMarker1061"/> the <strong class="source-inline">get_seller.html</strong> file that you created in <em class="italic">step 1</em>, add the following code shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/templates/chapter_</strong></p><p class="source-code"><strong class="bold">    8/spa_pages/get_seller.html</strong></p><p class="source-code">{% extends <strong class="bold">‘chapter_8/base/base_template_1.html’</strong> %}</p><p class="source-code">{% load static %}</p><p class="source-code">...</p><p class="source-code">{% block body_content %}</p><p class="source-code">    &lt;form&gt;</p><p class="source-code">        &lt;div class=”field-box input-box”&gt;</p><p class="source-code">            &lt;label for=”seller-id”&gt;Seller ID:&lt;/label&gt;</p><p class="source-code">            &lt;div class=”form-group”&gt;</p><p class="source-code">                &lt;input id=”seller-id” type=”text” /&gt;</p><p class="source-code">                &lt;span class=”help-text”&gt;Please enter </p><p class="source-code">                    the ID of the seller you want to </p><p class="source-code">                        lookup&lt;/span&gt;</p><p class="source-code">            &lt;/div&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">        &lt;button type=”button” id=”get-sellers” onclick</p><p class="source-code">            =”<strong class="bold">$gotoSPA_Page()</strong>”&gt;</p><p class="source-code">                Get Seller Details&lt;/button&gt;</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">    <strong class="bold">&lt;div id=”details”&gt;</strong></p><p class="source-code">        &lt;p&gt;!!! No Details to Display !!!&lt;/p&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">{% endblock %}</p></li>
				<li>This page is<a id="_idIndexMarker1062"/> pretty simple. All we are doing is creating an input field of <strong class="source-inline">type=”text”</strong> and then a button of <strong class="source-inline">type=”button”</strong>. We gave the button an <strong class="source-inline">onclick</strong> attribute that fires off a JavaScript function called <strong class="source-inline">$gotoSPA_Page()</strong>. There is a <strong class="source-inline">&lt;div&gt;</strong> container with an attribute of <strong class="source-inline">id=”details”</strong>, which contains a paragraph of text, indicating that there is nothing to display at this time. </li>
			</ol>
			<p>The idea here is that we will replace all of the content of the <strong class="source-inline">&lt;div id=”details”&gt;</strong> container with the contents of what is received from the API request. A <strong class="source-inline">&lt;form&gt;</strong> container is not necessary for this particular setup; it has been added only to conform to the same CSS styles and HTML node structuring that was written in previous chapters. It is acceptable to deviate from this structure and create your own. Please use the preceding structure for the purpose of demonstrating this exercise.</p>
			<p>Next, let’s<a id="_idIndexMarker1063"/> add the JavaScript responsible for performing an API request. We will be performing this action on the client side and not on the server side.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor254"/>Writing the JavaScript</h2>
			<p>We don’t <a id="_idIndexMarker1064"/>need much JavaScript, just one small<a id="_idIndexMarker1065"/> function that utilizes the native JavaScript <strong class="source-inline">fetch()</strong> function. This is almost identical to the jQuery <strong class="source-inline">.ajax()</strong> function, but it does differ slightly. The <strong class="source-inline">fetch()</strong> function differs in that it won’t send <strong class="source-inline">cross-origin</strong> headers, the default mode is set to <strong class="source-inline">no-cors</strong>, and the <strong class="source-inline">.ajax()</strong> function sets the default mode to <strong class="source-inline">same-origin</strong>. That could be important depending on your project’s requirements. The result of the request will then be displayed in the container with the CSS ID attribute of <strong class="source-inline">details</strong>, better known as the <strong class="source-inline">details</strong> container. </p>
			<p>If you copied your JavaScript file from <strong class="source-inline">chapter_4</strong>, that file should be blank right now. Take the following steps to prepare your JavaScript. If you copied this file from <strong class="source-inline">chapter_8</strong> found in the code of the book, make sure to comment out all but the following code:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_8/static/chapter_8/js/site-js.js</strong> file, add the following code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></p><p class="source-code">function $gotoSPA_Page() {</p><p class="source-code">    const <strong class="bold">input</strong> = document.getElementById(</p><p class="source-code">        ‘seller-id’</p><p class="source-code">    );</p><p class="source-code">    const <strong class="bold">container</strong> = document.getElementById(</p><p class="source-code">        ‘details’</p><p class="source-code">    );</p><p class="source-code">    const <strong class="bold">id</strong> = input.value;</p><p class="source-code">    var <strong class="bold">url</strong> = <strong class="bold">`</strong>/chapter-8/sellers/${id}/<strong class="bold">`</strong>;</p><p class="source-code">}</p></li>
				<li>In the same <strong class="source-inline">$gotoSPA_Page()</strong> function, add the <strong class="source-inline">fetch()</strong> method just below your constants and variables, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></p><p class="source-code">function $gotoSPA_Page() {</p><p class="source-code">    ...</p><p class="source-code">    fetch(<strong class="bold">url</strong>, {</p><p class="source-code">        method: <strong class="bold">‘GET’</strong>,</p><p class="source-code">        headers: {</p><p class="source-code">            ‘Content-Type’: <strong class="bold">‘application/json’</strong>,</p><p class="source-code">    }}).then(response =&gt; {</p><p class="source-code">        return response.json();</p><p class="source-code">    }).then(data =&gt; {</p><p class="source-code">        <strong class="bold">container.innerHTML = JSON.stringify(data);</strong></p><p class="source-code">    });</p><p class="source-code">}</p></li>
			</ol>
			<p>This is<a id="_idIndexMarker1066"/> the <strong class="source-inline">$gotoSPA_Page()</strong> function that <a id="_idIndexMarker1067"/>we configured in the previous subsection to execute when the <strong class="source-inline">onclick</strong> action of the <strong class="bold">Get Seller Details</strong> button is triggered. That’s it! This is all the JavaScript that we need to complete a single task of retrieving an individual record from a database, using the API that we created.</p>
			<p>In the preceding code, we wrote three constants, one called <strong class="source-inline">input</strong> to target the <strong class="source-inline">input</strong> field node and another called <strong class="source-inline">container</strong> to target the <strong class="source-inline">details</strong> container node. The third, called <strong class="source-inline">id</strong>, is used to capture the <strong class="source-inline">value</strong> of the input field at the time that this function is executed. The <strong class="source-inline">url</strong> variable is used to construct a string using the <strong class="source-inline">value</strong> of the <strong class="source-inline">input</strong> field as the keyword argument of that path converter. In JavaScript, this is known as concatenating strings, and because we are doing this, you need to make sure the backtick character (<strong class="source-inline">`</strong>) is used instead of a single-quote character (<strong class="source-inline">‘</strong>). They look almost identical; if you are just glancing at the preceding code, be careful. Here, we are telling that <strong class="source-inline">url</strong> variable to point to the URL created by the router of the <strong class="source-inline">Seller</strong> API.</p>
			<p>The <strong class="source-inline">fetch()</strong> function accepts the <strong class="source-inline">url</strong> variable as the first positional argument of that function, which is a required argument. We then pass in additional optional arguments, such as the method that accepts these values (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, and <strong class="source-inline">DELETE</strong>). All we want to demonstrate for now is retrieving the data, so we will use the <strong class="source-inline">GET</strong> method in this exercise. The headers argument is sometimes used to specify <strong class="source-inline">‘Content-Type’</strong>; in this case, it is set to <strong class="source-inline">‘application/json’</strong>. The method and headers shown previously are the defaults to using the <strong class="source-inline">fetch()</strong> function. They are not needed for the read operation since they are the default values but they are provided for illustrative purposes.</p>
			<p>The <strong class="source-inline">fetch()</strong> function also uses the two <strong class="source-inline">then()</strong> methods shown previously; they each return a promise as a response object in JSON format. In simple terms, a promise is an object that <a id="_idIndexMarker1068"/>consists of a state and a result. The<a id="_idIndexMarker1069"/> second <strong class="source-inline">then()</strong> method uses the returned promise as the <strong class="source-inline">data</strong> variable, which we then use by writing a simple statement to place that <strong class="source-inline">data</strong> into the <strong class="source-inline">details</strong> container. We use the <strong class="source-inline">JSON.stringify()</strong> method to convert that JSON object into a readable format, particularly a string placed inside that container. Without using the <strong class="source-inline">JSON.stringify()</strong> function, we would only see a single object printed to the screen in brackets, which won’t make much sense to us when we are looking at it. We will see screenshots of this in action in the subsection titled <em class="italic">First demo</em> of this chapter. </p>
			<p>Currently, all we are doing is printing the string of JSON into the <strong class="source-inline">&lt;div&gt;</strong> container. We are not creating HTML nodes and/or CSS styles for those nodes. This is where you would have to either write additional JavaScript to do that for you manually or use the power of a JavaScript-based framework. Let’s finish this exercise to see it working first, and then we will show you how to render that HTML and CSS on the server side, in the section titled <em class="italic">Writing custom API endpoints</em> of this chapter.</p>
			<h3>Using the async and await keywords</h3>
			<p>Traditional <a id="_idIndexMarker1070"/>JavaScript <a id="_idIndexMarker1071"/>is synchronous <a id="_idIndexMarker1072"/>and<a id="_idIndexMarker1073"/> single-threaded. It will run one process after the other and if one process gets hung up on, say, an API request where the server takes a long time to respond, then processes that take place after will hang up too. The problem is that a page can become unresponsive when this occurs. Asynchronous JavaScript allows functions to run side by side while other functions might be waiting for a response from the server. A <strong class="source-inline">then()</strong> function returning a promise is already an asynchronous function and is the reason why we gravitated toward using the <strong class="source-inline">fetch()</strong> function. JavaScript provides the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords, which make using and working with asynchronous functions a little bit easier, especially when your code begins to grow beyond these basic usage examples.</p>
			<p>Take the following step to modify your JavaScript.</p>
			<p>Make the highlighted changes in the following code block to your <strong class="source-inline">$gotoSPA_Page()</strong> function from the previous example:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></pre>
			<pre class="source-code">function $gotoSPA_Page() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    fetch(url, {</pre>
			<pre class="source-code">        method: ‘GET’,</pre>
			<pre class="source-code">        headers: {</pre>
			<pre class="source-code">            ‘Content-Type’: ‘application/json’,</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }).then(<strong class="bold">async(response)</strong> =&gt; {</pre>
			<pre class="source-code">        return <strong class="bold">await</strong> response.json();</pre>
			<pre class="source-code">    }).then(<strong class="bold">async(</strong>data<strong class="bold">)</strong> =&gt; {</pre>
			<pre class="source-code">        <strong class="bold">const thisData = await data;</strong></pre>
			<pre class="source-code">        container.innerHTML = JSON.stringify(</pre>
			<pre class="source-code">            <strong class="bold">thisData</strong></pre>
			<pre class="source-code">        );</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<p>The variable and constants are still needed. They are left unchanged and are represented <a id="_idIndexMarker1074"/>by the previous<a id="_idIndexMarker1075"/> three-dot notation. We <a id="_idIndexMarker1076"/>now <a id="_idIndexMarker1077"/>have enough to almost run our project and demonstrate this exercise in action. We just need to map a URL pattern to the view we create next.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor255"/>Mapping the URL pattern</h2>
			<p>Now, we are going<a id="_idIndexMarker1078"/> to wire up the view that we<a id="_idIndexMarker1079"/> created to a URL pattern, listening for the <strong class="source-inline">/chapter-8/get-seller/</strong> path.</p>
			<p>Take the following step to configure your URL pattern.</p>
			<p>In your <strong class="source-inline">/chapter_8/urls.py</strong> file, add the following path to the <strong class="source-inline">urlpatterns</strong> list:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></pre>
			<pre class="source-code">from .views import ..., <strong class="bold">GetSellerView</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘chapter-8/get-seller/’,</strong></pre>
			<pre class="source-code">        <strong class="bold">GetSellerView.as_view(),</strong></pre>
			<pre class="source-code">        <strong class="bold">name = ‘get-seller’</strong></pre>
			<pre class="source-code">    <strong class="bold">),</strong></pre>
			<pre class="source-code">]</pre>
			<p>You also need to <a id="_idIndexMarker1080"/>import the <strong class="source-inline">GetSellerView</strong> class<a id="_idIndexMarker1081"/> to map to the preceding pattern. </p>
			<p>Next, let’s demonstrate this code in action.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor256"/>First demo</h2>
			<p>To demonstrate <a id="_idIndexMarker1082"/>the code depicted in the <em class="italic">Building SPA-like pages</em> exercise, follow these steps:</p>
			<ol>
				<li value="1">Navigate to the get seller page at http://localhost:8000/chapter-8/get-seller/, and it should look similar to the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/Figure_8.06_B17243.jpg" alt="Figure 8.6 – Get seller page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Get seller page</p>
			<ol>
				<li value="2">Next, enter the number <strong class="source-inline">1</strong> into the input field shown in the preceding screenshot, relating to the ID of the first <strong class="source-inline">Seller</strong> in your database. Then, click the button labeled <strong class="bold">Get Seller Details</strong>. </li>
				<li>To witness what is happening, in any major browser, right-click and select <strong class="bold">Inspect element</strong> or press <em class="italic">F12</em> on your keyboard. When that window opens, navigate to the <strong class="bold">Network</strong> tab if it didn’t already navigate there for you. Here, you can watch each request that is performed in your browser as you press the preceding button. It is in this tab that you can see that your page is not reloading or redirecting in any way. Instead, you will see that it is just performing API requests. You can view the details of each request, such as what errors you are receiving, if any. You can navigate to the <strong class="bold">Console</strong> tab to view additional details about the JavaScript that is being executed, such as displaying any <strong class="source-inline">console.log()</strong> messages or errors that occur during runtime. If this action was successful, you should see the words <strong class="bold">!!! No Details to Display !!!</strong> replaced with the results of the request, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_8.07_B17243.jpg" alt="Figure 8.7 – Get seller results – JSON.stringify()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Get seller results – JSON.stringify()</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You will need to have the <strong class="bold">Network</strong> tab opened at all times in order for data to be logged into this tab. Open this tab and then refresh the page to get accurate results as you perform these actions.</p>
			<ol>
				<li value="4">Now, look at<a id="_idIndexMarker1083"/> the Network tab again, and you should see that we have two <strong class="bold">/chapter-8/get-seller/</strong> requests displayed in that list, as shown here:</li>
			</ol>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_8.08_B17243.jpg" alt="Figure 8.8 – Get seller page – Network tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Get seller page – Network tab</p>
			<p>The first request, at the top of this list, was initiated by the browser when the user first loaded the page at http://localhost:8000/chapter-8/get-seller/. The second <strong class="bold">request, /chapter-8/sellers/1/</strong> at the very bottom of this list, shows that the initiator was the <strong class="source-inline">site-js.js</strong> file, which is the file where we wrote the <strong class="source-inline">$gotoSPA_Page()</strong> function. The last column shows the time it took to perform each request. All of the files in between are other assets, such as CSS and<a id="_idIndexMarker1084"/> JavaScript files used by other apps in your project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is no need to worry if you do not see these files; it just means they have not been loaded for one reason or another.</p>
			<ol>
				<li value="5">Next, remove the <strong class="source-inline">JSON.stringify()</strong> function used in the <strong class="source-inline">$gotoSPA_Page()</strong> function and just use the <strong class="source-inline">thisData</strong> variable instead. Then, refresh this page and perform the query one more time. What we should see is a single object, as shown here:</li>
			</ol>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_8.09_B17243.jpg" alt="Figure 8.9 – Get seller results – standard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Get seller results – standard</p>
			<ol>
				<li value="6">It is here that we can see why we had to use the <strong class="source-inline">JSON.stringify()</strong> function. Without this function, we can see the object is depicted as <strong class="bold">[object Object]</strong>, which is not very helpful.</li>
			</ol>
			<p>Now that we have the client side of our API up and running, let’s explore how to return rendered HTML instead of a string representation of the JSON object that is returned.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor257"/>Writing custom API endpoints</h1>
			<p>Creating our <a id="_idIndexMarker1085"/>own API endpoints is just as easy as writing another URL pattern. This section will teach us how to write our own API endpoints and practice sending preformatted HTML back to the client. You do not need to create all custom API endpoints to return preformatted HTML but we will practice doing that. Preformatting HTML only works well if the app communicating with your API does not need to restructure or restyle the HTML in any way after it has been received. This means the server/developer needs to know exactly how the client will use the data that it receives. No more JavaScript will be needed other than what was already written in the <strong class="source-inline">$gotoSPA_Page()</strong> function of the previous exercise. We will reuse that same function and just alter one or two things before we move forward. We will create a new view class and add permission logic to secure that endpoint from unwanted users accessing the API.</p>
			<p>Let’s begin working on this exercise in the same order as the previous exercise, starting with the view.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor258"/>Creating the view</h2>
			<p>Follow these<a id="_idIndexMarker1086"/> steps to create your <strong class="source-inline">APIView</strong> class:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_8/views.py</strong> file, add the <strong class="source-inline">import</strong> statements shown here:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.shortcuts import <strong class="bold">render</strong></p><p class="source-code">from ..chapter_3.models import ..., Seller</p><p class="source-code">from rest_framework.permissions import IsAuthenticated</p><p class="source-code">from rest_framework.views import <strong class="bold">APIView</strong></p><p class="source-code">...</p></li>
				<li>In that same <a id="_idIndexMarker1087"/>file, create the <strong class="source-inline">GetSellerHTMLView</strong> class and <strong class="source-inline">get()</strong> method, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">GetSellerHTMLView</strong>(<strong class="bold">APIView</strong>):</p><p class="source-code">    permission_classes = [<strong class="bold">IsAuthenticated</strong>]</p><p class="source-code">    template_name = <strong class="bold">‘chapter_8/details/seller.html’</strong></p><p class="source-code">    def <strong class="bold">get(</strong>self, request, format=None, <strong class="bold">id=0</strong>, *args, </p><p class="source-code">        **kwargs<strong class="bold">)</strong>:</p><p class="source-code">        if request.user.<strong class="bold">is_authenticated</strong> and </p><p class="source-code">            request.user.<strong class="bold">has_perm</strong></p><p class="source-code"><strong class="bold">                (‘chapter_3.view_seller’)</strong>:</p><p class="source-code">            try:</p><p class="source-code">                <strong class="bold">seller = Seller.objects.get(id=id)</strong></p><p class="source-code">            except Seller.DoesNotExist:</p><p class="source-code">                seller = None</p><p class="source-code">        else:</p><p class="source-code">            seller = None</p><p class="source-code">        context = {<strong class="bold">‘seller’: seller,</strong>}</p><p class="source-code">        return <strong class="bold">render</strong>(</p><p class="source-code">            request, </p><p class="source-code">            self.template_name, </p><p class="source-code">            context = context</p><p class="source-code">        )</p></li>
			</ol>
			<p>Here, the new <strong class="source-inline">GetSellerHTMLView</strong> class mimics the <strong class="source-inline">GetSellerView</strong> class that we created in the previous exercise, except now it uses the <strong class="source-inline">APIView</strong> class, provided by the Django REST framework. We only need to specify the <strong class="source-inline">get()</strong> method in this class as well; there is no need for the <strong class="source-inline">post()</strong> method since we are not working with form objects. We are only creating a view that handles the <strong class="source-inline">GET</strong> API method at this time, to view/read an object. The template we are mapping to this view is the <strong class="source-inline">/chapter_8/templates/chapter_8/details/seller.html</strong> file, which we will create in the next subsection. We need to pass <strong class="source-inline">id=0</strong> into the <strong class="source-inline">get()</strong> method, as is highlighted in the preceding code, in anticipation for how we will write the URL pattern for this API endpoint. We have to explicitly set <strong class="source-inline">id=0</strong> in the <strong class="source-inline">get()</strong> method since we are using the <strong class="source-inline">APIView</strong> class. If you are inheriting the regular <strong class="source-inline">View</strong>, <strong class="source-inline">FormView</strong>, <strong class="source-inline">CreateView</strong>, <strong class="source-inline">UpdateView</strong>, or <strong class="source-inline">DeleteView</strong> classes, you would only have to write <strong class="source-inline">id</strong> without the <strong class="source-inline">=0</strong> part. The same applies to the <strong class="source-inline">format=None</strong> argument, which is only needed <a id="_idIndexMarker1088"/>when working with <strong class="source-inline">APIView</strong> classes and not regular <strong class="source-inline">View</strong> classes.</p>
			<p>This approach is reliant on a user logged into your system, by accessing the currently logged-in user with the <strong class="source-inline">request.user</strong> object. Users outside your organization, who do not have access to the Django admin site, would have to use an authorization token to log in, which will be discussed later in this chapter. Even though we changed the <strong class="source-inline">AUTH_USER_MODEL</strong> setting in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, to use the <strong class="source-inline">Seller</strong> model instead of the Django <strong class="source-inline">User</strong> model, we can still access the current user in the <strong class="source-inline">request</strong> object by using <strong class="source-inline">request.user</strong>. You do not have to use <strong class="source-inline">request.seller</strong>; in fact, that will result in an error. When using the <strong class="source-inline">is_authenticated</strong> property of that user, we can determine whether the user is actually logged in with an active session. </p>
			<p>The <strong class="source-inline">has_perm()</strong> method is used to check the permissions of that user. In this case, we are checking whether the user has read/view permissions on a <strong class="source-inline">Seller</strong> model object using <strong class="source-inline">‘chapter_3.view_seller’</strong>. If the user is authenticated and has the correct permissions, we are performing a query to look up the <strong class="source-inline">Seller</strong> object being searched by using the ID provided. If the user is not authenticated, then we are setting the <strong class="source-inline">seller</strong> variable to <strong class="source-inline">None</strong>, which we will use to compare whether or not it has a value within the template file.</p>
			<p>That <strong class="source-inline">seller</strong> variable then gets passed into the <strong class="source-inline">context</strong> of the template being used, so that we can access its data. Also, we need to wrap the query statement in a <strong class="source-inline">try</strong>/<strong class="source-inline">except</strong> block, which is necessary to prevent runtime errors when the user searches for a <strong class="source-inline">Seller</strong> that does not exist. With the <strong class="source-inline">try</strong>/<strong class="source-inline">except</strong> block, we can set the value of <strong class="source-inline">seller</strong> to <strong class="source-inline">None</strong>, allowing the program to continue to run without errors. When used in the template, it will indicate that the search returned nothing. </p>
			<p>We are using the <strong class="source-inline">render()</strong> method provided by the <strong class="source-inline">django.shortcuts</strong> library instead of the <strong class="source-inline">TemplateResponse</strong> class that we have been using up to now. This is because we want to return only a snippet of HTML and not an entire HTML page, with all of the bells <a id="_idIndexMarker1089"/>and whistles that a page may have.</p>
			<p>Now that the view is created, let’s construct the template that uses that <strong class="source-inline">seller</strong> object as context.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor259"/>Building the template</h2>
			<p>Follow these <a id="_idIndexMarker1090"/>steps to prepare your template:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">seller.html</strong> in the <strong class="source-inline">/chapter_8/templates/chapter_8/details/</strong> directory.</li>
				<li>Inside that file, add the following code:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/templates/chapter_8/details/seller.html</strong></p><p class="source-code">{% load static %}</p><p class="source-code">&lt;h1&gt;Seller Details&lt;/h1&gt;</p><p class="source-code"><strong class="bold">{% if seller %}</strong></p><p class="source-code">    &lt;h2&gt;{{ seller.first_name|safe }} {{ </p><p class="source-code">        seller.last_name|safe }}&lt;/h2&gt;</p><p class="source-code">    &lt;h3&gt;{{ seller.name|safe }}&lt;/h3&gt;</p><p class="source-code">    <strong class="bold">{% if seller.vehicles %}</strong></p><p class="source-code">        &lt;ul&gt;</p><p class="source-code">            <strong class="bold">{% for vehicle in seller.vehicles.all %}</strong></p><p class="source-code">                &lt;li&gt;{{ vehicle.fullname }}&lt;/li&gt;</p><p class="source-code">            {% endfor %}</p><p class="source-code">        &lt;/ul&gt;</p><p class="source-code">    {% endif %}</p><p class="source-code">{% else %}</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">        &lt;b&gt;No Seller to Display&lt;/b&gt;&lt;br /&gt;</p><p class="source-code">        &lt;em&gt;or you &lt;b&gt;DO NOT&lt;/b&gt; have permission&lt;/em&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">{% endif %}</p></li>
			</ol>
			<p>Note that we are not extending any another template in this file. All we are doing is displaying simple <a id="_idIndexMarker1091"/>text objects as a component of a page and not the page in whole. A conditional statement compares whether or not the <strong class="source-inline">seller</strong> object has a value, using the <strong class="source-inline">{% if seller %}</strong> statement. If no <strong class="source-inline">seller</strong> object exists, text is rendered showing the message <strong class="bold">No Seller to Display</strong>. If a <strong class="source-inline">seller</strong> does exist, then another conditional statement compares whether or not the <strong class="source-inline">seller</strong> has any <strong class="source-inline">vehicles</strong>, using the <strong class="source-inline">{% if seller.vehicles %}</strong> statement. If <strong class="source-inline">vehicles</strong> do exist, we iterate through all of the vehicle objects using the <strong class="source-inline">{% for vehicle in seller.vehicles.all %}</strong> statement. It is important that you add <strong class="source-inline">.all</strong> to the end of this statement; otherwise, you will receive errors. This is how you access any nested list of objects found in a single object within the Django template language. We use the <strong class="source-inline">fullname</strong> property method created in <a href="B17243_03_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 3</em></a>, <em class="italic">Models, Relations, and Inheritance</em>, to print the full name of the vehicle as an <strong class="source-inline">&lt;li&gt;</strong> HTML node object.</p>
			<p>Now that we have our template, let’s move on to modify the <strong class="source-inline">$gotoSPA_Page()</strong> function <a id="_idIndexMarker1092"/>created in the previous exercise.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor260"/>Modifying the JavaScript</h2>
			<p>Change the <strong class="source-inline">url</strong> variable<a id="_idIndexMarker1093"/> in the existing <strong class="source-inline">$gotoSPA_Page()</strong> function to point to the new endpoint, which we will write in the next subsection as <strong class="source-inline">`/chapter-8/seller/${id}/`</strong>, as in a singular <strong class="source-inline">seller</strong> in contrast to the plural <strong class="source-inline">sellers</strong> that we used in the previous exercise. </p>
			<p>Take the following step to modify your JavaScript function.</p>
			<p>In the <strong class="source-inline">$gotoSPA_Page()</strong> function, make the following highlighted changes:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></pre>
			<pre class="source-code">function $gotoSPA_Page() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    var <strong class="bold">url</strong> = `/chapter-8/<strong class="bold">seller</strong>/${id}/`;</pre>
			<pre class="source-code">    fetch(url, {</pre>
			<pre class="source-code">        method: ‘GET’,</pre>
			<pre class="source-code">        headers: {</pre>
			<pre class="source-code">            ‘Content-Type’: ‘application/json’,</pre>
			<pre class="source-code">    }}).then(async(response) =&gt; {</pre>
			<pre class="source-code">        <strong class="bold">return await response.text();</strong></pre>
			<pre class="source-code">    }).then(async(data) =&gt; {</pre>
			<pre class="source-code">        <strong class="bold">container.innerHTML = await data;</strong></pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, we are still using the <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong> keywords but you are not required to do so. The first three constants of the <strong class="source-inline">$gotoSPA_Page()</strong> function, <strong class="source-inline">container</strong>, <strong class="source-inline">input</strong>, and <strong class="source-inline">id</strong>, are left untouched and are represented by the preceding three-dot <a id="_idIndexMarker1094"/>notation. </p>
			<p>That’s it; now all we have to do is create the URL pattern that will act as the API endpoint being used.</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor261"/>Mapping the URL pattern</h2>
			<p>Take the <a id="_idIndexMarker1095"/>following step to map your URL pattern.</p>
			<p>In your <strong class="source-inline">/chapter_8/urls.py</strong> file, add the following highlighted pattern, keeping the <strong class="source-inline">get-seller</strong> path that we previously wrote:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></pre>
			<pre class="source-code">from .views import (</pre>
			<pre class="source-code">    ..., </pre>
			<pre class="source-code">    GetSellerView,</pre>
			<pre class="source-code">    <strong class="bold">GetSellerHTMLView</strong></pre>
			<pre class="source-code">)</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        ‘chapter-8/get-seller/’, </pre>
			<pre class="source-code">        GetSellerView.as_view(), </pre>
			<pre class="source-code">        name = ‘get-seller’</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘chapter-8/seller/&lt;int:id&gt;/’, </strong></pre>
			<pre class="source-code">        <strong class="bold">GetSellerHTMLView.as_view(), </strong></pre>
			<pre class="source-code">        <strong class="bold">name = ‘seller-detail’</strong></pre>
			<pre class="source-code">    <strong class="bold">),</strong></pre>
			<pre class="source-code">]</pre>
			<p>We will still <a id="_idIndexMarker1096"/>need that first URL pattern because it is the page that triggers the API request, containing the <strong class="bold">Get Seller Details</strong> button.</p>
			<p>That should be it. Now, let’s see what this looks like in action.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor262"/>Second demo</h2>
			<p>To demonstrate<a id="_idIndexMarker1097"/> this in action, follow these steps:</p>
			<ol>
				<li value="1">Make sure you are currently logged into the Django admin site at <strong class="source-inline">http://localhost:8000/admin/</strong>, with your superuser account. </li>
				<li>Then, navigate to the get seller page at http://localhost:8000/chapter-8/get-seller/ and it should look the same as before, in <em class="italic">Figure 8.6</em>, in the previous exercise. </li>
				<li>Enter the number <strong class="source-inline">1</strong> into the input field on this page and then click the <strong class="bold">Get Seller Details</strong> button. Since you have superuser status, you should see the formatted HTML get injected into the <strong class="source-inline">details</strong> container found on this page, as is also shown here:</li>
			</ol>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_8.10_B17243.jpg" alt="Figure 8.10 – Get seller page – custom API endpoint&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Get seller page – custom API endpoint</p>
			<p>If you have the Network tab of your browser tools open, you will also see that this action was performed without reloading or redirecting your page. You can style this to look exactly as you need it. For this example, we just used simple HTML nodes<a id="_idIndexMarker1098"/> with minimal styling and formatting to demonstrate this exercise.</p>
			<ol>
				<li value="4">Next, add or create a new superuser account using the Django admin site at <strong class="source-inline">http://localhost:8000/admin/chapter_3/seller/</strong>. This can also be done through the command line just as we did in <a href="B17243_02_ePub.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Project Configuration</em>. </li>
				<li>In a different browser or incognito window, log in with the new superuser that you just created.</li>
				<li>Next, navigate to the original superuser’s edit page, found here: <strong class="source-inline">http://localhost:8000/admin/chapter_3/seller/1/change/</strong>. This is the user with the username <strong class="source-inline">admin</strong> and an ID of <strong class="source-inline">1</strong>.</li>
				<li>In the <strong class="bold">Permissions</strong> section of this page, uncheck the <strong class="bold">Superuser status</strong> checkbox, restricting that user from doing anything. Leave the <strong class="bold">Active</strong> and <strong class="bold">Staff status</strong> checkboxes enabled. Make sure the <strong class="bold">Chosen user permissions</strong> box has nothing selected, as shown here:</li>
			</ol>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_8.11_B17243.jpg" alt="Figure 8.11 – Editing superuser permissions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Editing superuser permissions</p>
			<ol>
				<li value="8">In your first <a id="_idIndexMarker1099"/>browser, where you are already logged in as <strong class="source-inline">Seller</strong> with the username of <strong class="source-inline">admin</strong>, navigate to http://localhost:8000/chapter-8/get-seller/ in a different tab or refresh the existing tab if it is still open. </li>
				<li>Enter the number <strong class="source-inline">1</strong> into the input field and then click the <strong class="bold">Get Seller Details</strong> button again. It should say that you do not have permission, as depicted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_8.12_B17243.jpg" alt="Figure 8.12 – Get seller page – permission restricted&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – Get seller page – permission restricted</p>
			<ol>
				<li value="10">This is because we removed the original permission for this user. The preceding message is the HTML that we wrote in the <strong class="source-inline">/chapter_8/details/seller.html</strong> template, specifically in the condition that checks whether the <strong class="source-inline">seller</strong> object has a value. </li>
				<li>To ensure that the <strong class="source-inline">seller</strong> object has no value as a result of a permission issue and not because of a non-existent query, you can write <strong class="source-inline">print()</strong> statements in your code to provide that indicator for you. Go back to the other browser window that is open at <strong class="source-inline">http://localhost:8000/admin/chapter_3/seller/1/change/</strong>, where you are logged in<a id="_idIndexMarker1100"/> with the new superuser created for this exercise, and edit the <strong class="source-inline">admin</strong> user one more time.</li>
				<li>Go ahead and give that user the <strong class="bold">chapter_3 | Seller | Can view Seller</strong> permission, as depicted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_8.13_B17243.jpg" alt="Figure 8.13 – Editing superuser permissions – view Seller&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Editing superuser permissions – view Seller</p>
			<p>By doing this, we are giving this user the exact permission that we are checking for in the <strong class="source-inline">GetSellerHTMLView</strong> class. Remember to click the <strong class="bold">Save</strong> button at the bottom of this page before proceeding.</p>
			<ol>
				<li value="13">In your first browser, on the get seller page at http://localhost:8000/chapter-8/get-seller/, make sure you are still logged in with the original <strong class="source-inline">admin</strong> user and click the <strong class="bold">Get Seller Details</strong> button one more time. Here, we will see the same results that we saw before in <em class="italic">Figure 8.9</em>.</li>
			</ol>
			<p>This exercise demonstrated how to use the Django template language to preformat HTML that is being returned in an API <strong class="source-inline">GET</strong> request. As we discovered working with this exercise, we actually need a user who is already logged into the Django admin site of the site before performing this operation. Without being logged in, this approach will not work. This is controlled by the <strong class="bold">Staff status</strong> checkbox, under the <strong class="bold">Permissions</strong> section when editing a user, which grants that user the ability to access the Django admin site. With the <strong class="bold">Staff status</strong> checkbox left unchecked, a user cannot access your system and thus, will not be able to use any of the permissions in the permission system.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Switch your original superuser, with the username <strong class="source-inline">admin</strong>, back to its original settings, with the <strong class="bold">Staff status</strong> and <strong class="bold">Superuser status</strong> checkboxes enabled and the individual permissions and group permissions all removed. Make sure this is done and that you are logged in with this user before proceeding to the next exercise.</p>
			<p>If you need to <a id="_idIndexMarker1101"/>build an API that doesn’t grant users access to your Django admin site, then authentication tokens will be needed. In the next exercise, we will use authentication tokens in combination with the Django REST framework to achieve this task.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor263"/>Authenticating with tokens</h1>
			<p>In this exercise, we <a id="_idIndexMarker1102"/>will be treating the API that we built earlier in this chapter as if it is now an API provided by a third party. Pretend for a moment that you did not build your API and we will practice authenticating by using a security token. Token security will be used in addition to the individual model permissions as we did in the previous exercise. This will be done whether you grant a user access to the Django admin site or not. That also means we will create a new user/seller for this exercise and then restrict that user’s access to the Django admin site for demonstration purposes.</p>
			<p>We will follow the same steps as the previous two exercises next.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor264"/>Project configuration</h2>
			<p>This exercise<a id="_idIndexMarker1103"/> requires a little bit of configuration inside the project’s <strong class="source-inline">settings.py</strong> file before we can get started with the same steps as before. </p>
			<p>Follow these steps to configure your project:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">settings.py</strong> file, add the following app to your <strong class="source-inline">INSTALLED_APPS</strong> list, as well as the highlighted additions to the <strong class="source-inline">REST_FRAMEWORK</strong> setting, as shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/settings.py</strong></p><p class="source-code">INSTALLED_APPS = [</p><p class="source-code">    ...</p><p class="source-code">    ‘rest_framework’,</p><p class="source-code">    <strong class="bold">‘rest_framework.authtoken’,</strong></p><p class="source-code">]</p><p class="source-code">REST_FRAMEWORK = {</p><p class="source-code">    <strong class="bold">‘DEFAULT_AUTHENTICATION_CLASSES’: (</strong></p><p class="source-code">        <strong class="bold">‘rest_framework.authentication.TokenAuthentication’,</strong></p><p class="source-code">        <strong class="bold">‘rest_framework.authentication.SessionAuthentication’,</strong></p><p class="source-code">    <strong class="bold">),</strong></p><p class="source-code">    ‘DEFAULT_PERMISSION_CLASSES’: [</p><p class="source-code">        ‘rest_framework.permissions.</p><p class="source-code">            DjangoModelPermissionsOrAnonReadOnly’</p><p class="source-code">    ],</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">rest_framework.authtoken</strong> app is already installed in your virtual environment, so you do not have to install any additional <strong class="source-inline">pip</strong> packages. It comes standard when installing the <strong class="source-inline">djangorestframework</strong> package but does not get enabled in your project with just the basic settings needed for this framework. If we actually intend to use it, we have to add the two authentication classes shown previously to the <strong class="source-inline">REST_FRAMEWORK</strong> setting, telling the Django REST framework to use token authentication with all of its <strong class="source-inline">APIView</strong> classes. This means that tokens will be needed for any custom endpoints that we create using that <strong class="source-inline">APIView</strong> class, as well as all of the endpoints created using the <strong class="source-inline">router</strong> method from earlier in this chapter. </p>
			<p>Endpoints <a id="_idIndexMarker1104"/>created using the <strong class="source-inline">router</strong> method are all constructed using the <strong class="source-inline">APIView</strong> class. Adding the <strong class="source-inline">SessionAuthentication</strong> class means that we will enable the ability for users to log into the Django admin site to test that endpoint using the Browsable API. Without it, you will see a message indicating you are not authenticated. We will also leave the <strong class="source-inline">DjangoModelPermissionsOrAnonReadOnly</strong> permission class in the settings shown previously to continue to check for model-level permissions.</p>
			<p>Please also make sure you are following proper Python indentation. There is not enough room to display that properly in the code shown previously.</p>
			<ol>
				<li value="2">Now that we have added new packages to our <strong class="source-inline">settings.py</strong> file for this project, we will need to run the following migrate command:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python3 manage.py migrate</strong></p></li>
				<li>Next, make sure that you are logged into the Django admin site with your <strong class="source-inline">admin</strong> user and navigate to <strong class="source-inline">http://localhost:8000/admin/chapter_3/seller/add/</strong>, to create a new user/seller with the username <strong class="source-inline">test</strong>. You may already have a test user from a previous chapter. If so, just delete that user and recreate it for this exercise. This time, leave the <strong class="bold">Staff status</strong> and <strong class="bold">Superuser status</strong> checkboxes unchecked. Give that new user only one permission, the same <strong class="bold">chapter_3 | Seller | Can view Seller</strong> permission that we used before. </li>
				<li>Next, navigate to the URL <strong class="source-inline">http://localhost:8000/admin/authtoken/tokenproxy/</strong> and add a new token for the user you just created. This can also be done in your command-line window or terminal by executing the following command:<p class="source-code"><strong class="bold">(virtual_env) PS &gt; python manage.py drf_create_token test</strong></p></li>
				<li>Copy <a id="_idIndexMarker1105"/>the token key that was created for that user and save it for later, in Notepad or something.</li>
			</ol>
			<p>Next, we will proceed in the same order as we did for the last two exercises.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor265"/>Creating the view</h2>
			<p>Now, we need to<a id="_idIndexMarker1106"/> create a new view class for this exercise. It will be used for a new endpoint that we will add to the API before we treat it like someone else built it for us. This endpoint will only return standard JSON data and will not return the preformatted HTML that we practiced doing in the previous exercise. JSON is what is traditionally returned in API requests. </p>
			<p>Follow these steps to prepare your view class:</p>
			<ol>
				<li value="1">In your <strong class="source-inline">/chapter_8/views.py</strong> file, add the following highlighted <strong class="source-inline">import</strong> statement and the <strong class="source-inline">GetSellerWithTokenView</strong> class shown:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">from django.http import <strong class="bold">JsonResponse</strong></p><p class="source-code">from rest_framework.permissions import IsAuthenticated</p><p class="source-code">from rest_framework.views import APIView</p><p class="source-code">from .serializers import SellerSerializer</p><p class="source-code">from ..chapter_3.models import ..., Seller</p><p class="source-code">...</p><p class="source-code">class <strong class="bold">GetSellerWithTokenView</strong>(APIView):</p><p class="source-code">    <strong class="bold">permission_classes = [IsAuthenticated]</strong></p></li>
				<li>Inside that same <strong class="source-inline">GetSellerWithTokenView</strong> class, add the following <strong class="source-inline">get()</strong> method<a id="_idIndexMarker1107"/> and conditional statement:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">GetSellerWithTokenView</strong>(APIView):</p><p class="source-code">    ...</p><p class="source-code">    def <strong class="bold">get(</strong>self, request, format=None, id=0, *args,       </p><p class="source-code">        **kwargs<strong class="bold">)</strong>:</p><p class="source-code">        seller = None</p><p class="source-code">        <strong class="bold">req_user = request._user</strong></p><p class="source-code">        if req_user.has_perm(‘chapter_3.view_seller’):</p><p class="source-code">            perm_granted = True</p><p class="source-code">            try:</p><p class="source-code">                <strong class="bold">seller = Seller.objects.get(id=id)</strong></p><p class="source-code">            except Seller.DoesNotExist:</p><p class="source-code">                pass</p><p class="source-code">        else:</p><p class="source-code">            perm_granted = False</p></li>
				<li>Inside that same <strong class="source-inline">get()</strong> method, add the following <strong class="source-inline">context</strong>, <strong class="source-inline">serializer</strong>, <strong class="source-inline">new_context</strong>, and <strong class="source-inline">return</strong> statements<a id="_idIndexMarker1108"/> below what you just added to that method:<p class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/views.py</strong></p><p class="source-code">...</p><p class="source-code">class <strong class="bold">GetSellerWithTokenView</strong>(APIView):</p><p class="source-code">    ...</p><p class="source-code">    def <strong class="bold">get(</strong>self, request, format=None, id=0, *args, </p><p class="source-code">        **kwargs<strong class="bold">)</strong>:</p><p class="source-code">        ...</p><p class="source-code">        <strong class="bold">context</strong> = {</p><p class="source-code">            ‘request’: request,</p><p class="source-code">            ‘seller’: seller,</p><p class="source-code">        }</p><p class="source-code">        seller = <strong class="bold">SellerSerializer(</strong></p><p class="source-code">            seller, </p><p class="source-code">            context = context</p><p class="source-code">        <strong class="bold">)</strong></p><p class="source-code">        <strong class="bold">new_context</strong> = {</p><p class="source-code">            ‘seller’: seller.data,</p><p class="source-code">            <strong class="bold">‘perm_granted’: perm_granted</strong></p><p class="source-code">        }</p><p class="source-code">        <strong class="bold">return JsonResponse(new_context)</strong></p><p class="callout-heading">Note</p><p class="callout">When using the <strong class="source-inline">JsonResponse()</strong> object to return data as formatted JSON in your endpoint in this way, your endpoint will not be readily available in the Browsable API tool. If you wish for it to be accessible via that tool, use <strong class="source-inline">Response()</strong> instead. Keep in mind that it may alter the way developers work with the returned data.</p></li>
			</ol>
			<p>In the preceding class, we are following the same logic format as was used in the <strong class="source-inline">GetSellerHTMLView</strong> class, written in the previous exercise. We added a property called <strong class="source-inline">permission_classes</strong>, which uses the <strong class="source-inline">IsAuthenticated</strong> class. This is needed to work with token authentication. We added an additional query to the <strong class="source-inline">get()</strong> method. The logic here is that we are using two items added to the request headers when the request <a id="_idIndexMarker1109"/>is sent, using the <strong class="source-inline">fetch()</strong> JavaScript function. Those two headers are <strong class="source-inline">HTTP_AUTHORIZATION</strong> and <strong class="source-inline">HTTP_USER</strong>, which we will soon add to our JavaScript function. </p>
			<p>The <strong class="source-inline">request._user</strong> item is used to look up the user associated with that <strong class="source-inline">request</strong>, whether the user is logged into the Django admin site or is passed into the request via the <strong class="source-inline">HTTP_USER</strong> header, that being the <strong class="source-inline">test</strong> user created for this exercise, the user we will associate with the API request. We are looking up that user to compare individual model permissions using the same <strong class="source-inline">has_perm()</strong> method from the previous exercise. If the API request user is found, then we are performing the same logic as before to check whether that user has permission to view a <strong class="source-inline">seller</strong> object. This time, we removed the <strong class="source-inline">is_authenticated</strong> property from that conditional statement, as we are now relying on this class’s token authentication. If you granted your <strong class="source-inline">test</strong> user the ability to view a <strong class="source-inline">seller</strong> object, the logic continues to look up the <strong class="source-inline">seller</strong> with the ID provided in that input field, the same as before. If your <strong class="source-inline">test</strong> user is not granted the ability to view a <strong class="source-inline">seller</strong> object, then the <strong class="source-inline">perm_granted</strong> context item will return <strong class="source-inline">False</strong>, to provide an indicator in the data being returned to us.</p>
			<p>The context was broken up into two different items, shown in <em class="italic">step 3</em>, because the request is needed in the context when using <strong class="source-inline">SellerSerializer</strong>. Then, we are removing that request from the final context being returned as <strong class="source-inline">JsonResponse()</strong>.</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor266"/>Building the template</h2>
			<p>This exercise <a id="_idIndexMarker1110"/>does not require a brand-new template. It will be returning only JSON and is not following the preformatted HTML example.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor267"/>Modifying the JavaScript</h2>
			<p>We will be <a id="_idIndexMarker1111"/>using the same JavaScript example provided in the <em class="italic">Modifying the JavaScript</em> subsection under the <em class="italic">Writing custom API endpoints</em> section. </p>
			<p>Take the following step to modify your JavaScript for this exercise.</p>
			<p>In the same JavaScript file, make the following highlighted changes to your existing <strong class="source-inline">$gotoSPA_Page()</strong> function:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/static/chapter_8/js/site-js.js</strong></pre>
			<pre class="source-code">function $gotoSPA_Page() {</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    <strong class="bold">var url = `/chapter-8/sellertoken/${id}/`;</strong></pre>
			<pre class="source-code">    fetch(url, {</pre>
			<pre class="source-code">        method: ‘GET’,</pre>
			<pre class="source-code">        headers: {</pre>
			<pre class="source-code">            ‘Content-Type’: ‘application/json’,</pre>
			<pre class="source-code">            <strong class="bold">‘Authorization’: ‘Token your_token’,</strong></pre>
			<pre class="source-code">            <strong class="bold">‘User’: ‘test’</strong></pre>
			<pre class="source-code">    }}).then(async(response) =&gt; {</pre>
			<pre class="source-code">        return await response.text();</pre>
			<pre class="source-code">    }).then(async(data) =&gt; {</pre>
			<pre class="source-code">        container.innerHTML = await data;</pre>
			<pre class="source-code">    });</pre>
			<pre class="source-code">}</pre>
			<p>In this example, we are leaving the first three constants, <strong class="source-inline">container</strong>, <strong class="source-inline">input</strong>, and <strong class="source-inline">id</strong>, the same as they have been written in previous examples and represented by the preceding three-dot notation. We are changing the <strong class="source-inline">url</strong> variable to point to a new path that we will create shortly, <strong class="source-inline">`/chapter-8/sellertoken/${id}/`</strong>. The rest of the <strong class="source-inline">fetch()</strong> function is left the same as before, where we are returning the result as preformatted HTML instead of JSON. The only thing different is that we are adding the <strong class="source-inline">‘Authorization’</strong> and <strong class="source-inline">‘User’</strong> items to the <strong class="source-inline">headers</strong> of this request. The value of the <strong class="source-inline">‘Authorization’</strong> item is the value of the token that was created, the one you were asked to copy earlier; paste that in place of the preceding <strong class="source-inline">your_token</strong> shown. The value of the <strong class="source-inline">‘User’</strong> item is the username of the new user/seller that you just created, the one assigned to the token that <a id="_idIndexMarker1112"/>you are providing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Tokens should <em class="italic">never</em> be kept in a JavaScript file, as is done in the preceding example. An explanation for why this is done in the preceding example is provided in the subsection titled <em class="italic">Third demo</em> at the end of this exercise.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor268"/>Mapping the URL pattern</h2>
			<p>We are<a id="_idIndexMarker1113"/> almost done! We just need to map the endpoint that we are communicating with to our new view class. </p>
			<p>Take the following step to map your URL pattern.</p>
			<p>In your <strong class="source-inline">/chapter_8/urls.py</strong> file, add the following path. You can leave the other paths that have already been created, as depicted:</p>
			<pre class="source-code"><strong class="bold"># /becoming_a_django_entdev/chapter_8/urls.py</strong></pre>
			<pre class="source-code">from .views import ..., GetSellerView, GetSellerHTMLView, </pre>
			<pre class="source-code">    <strong class="bold">GetSellerWithTokenView</strong></pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">urlpatterns = [</pre>
			<pre class="source-code">    ...</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        ‘chapter-8/get-seller/’, </pre>
			<pre class="source-code">        GetSellerView.as_view(), </pre>
			<pre class="source-code">        name = ‘get-seller’</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    path(</pre>
			<pre class="source-code">        ‘chapter-8/seller/&lt;int:id&gt;/’, </pre>
			<pre class="source-code">        GetSellerHTMLView.as_view(), </pre>
			<pre class="source-code">        name = ‘seller-detail’</pre>
			<pre class="source-code">    ),</pre>
			<pre class="source-code">    <strong class="bold">path(</strong></pre>
			<pre class="source-code">        <strong class="bold">‘chapter-8/sellertoken/&lt;int:id&gt;/’, </strong></pre>
			<pre class="source-code">        <strong class="bold">GetSellerWithTokenView.as_view(),</strong></pre>
			<pre class="source-code">        <strong class="bold">name = ‘seller-token-detail’</strong></pre>
			<pre class="source-code">    <strong class="bold">),</strong></pre>
			<pre class="source-code">]</pre>
			<p>That’s it; let’s<a id="_idIndexMarker1114"/> demonstrate this code in action next.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor269"/>Third demo</h2>
			<p>Follow <a id="_idIndexMarker1115"/>these steps to see this in action:</p>
			<ol>
				<li value="1">Open a new incognito window and navigate to <strong class="source-inline">http://localhost:8000/chapter-8/get-seller/</strong>. The reason I am asking you to open an incognito window is to ensure that you are not logged into the Django admin site with any user for this test run. You can also navigate to <strong class="source-inline">http://localhost:8000/admin/</strong> to double-check, making sure that you are not logged in. </li>
				<li>Next, enter the number <strong class="source-inline">1</strong> into the input field and click the <strong class="bold">Get Seller Details</strong> button. If everything is successful, you should now see the <strong class="source-inline">seller</strong> data in JSON format, including the extra <strong class="source-inline">perm_granted</strong> context that we passed in, as shown in the <a id="_idTextAnchor270"/><a id="_idIndexMarker1116"/>following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_8.14_B17243.jpg" alt="Figure 8.14 – Get seller page – custom API endpoint with token auth&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – Get seller page – custom API endpoint with token auth</p>
			<p>You could also add <strong class="source-inline">print()</strong> statements to your code to verify if and when each condition is actually met. Additional <strong class="source-inline">print()</strong> statements and comments providing details have been included with the code of this book. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">You will see hyperlinked vehicles in the preceding example if you are inheriting the <strong class="source-inline">HyperlinkedModelSerializer</strong> class in your serializers. If you are still using the <strong class="source-inline">ModelSerializer</strong> class, only numeric IDs will be displayed.</p>
			<ol>
				<li value="3">If you were not successful or you enter an incorrect token in your JavaScript file, then you will see an <strong class="bold">Invalid token</strong> message returned to you. Go ahead and enter an invalid token into the <strong class="source-inline">fetch()</strong> function just to see the <strong class="bold">Invalid token</strong> message display, and then refresh your get seller page, enter the number <strong class="source-inline">1</strong> into the input field again, and click the <strong class="bold">Get Seller Details</strong> button. The invalid token message<a id="_idIndexMarker1117"/> should look something as in the following screenshot:</li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_8.15_B17243.jpg" alt="Figure 8.15 – Get seller page – invalid token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – Get seller page – invalid token</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In a real-world example, the token should <em class="italic">never</em> be kept directly in the JavaScript file or even a Python file, if you are using the <strong class="source-inline">requests</strong> package. Instead, you should consider creating an additional API endpoint that utilizes the built-in token generator called <strong class="source-inline">obtain_auth_token</strong>, as discussed here: <a href="https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens">https://www.django-rest-framework.org/api-guide/authentication/#generating-tokens</a>. The token generator works by accepting a username and password that is attached to the headers of the first API request and then receives a newly created token in return. Then, a second API request is used to execute the action desired by attaching the token received from the first request to the second request’s headers. The Django REST framework does the rest of the work to authenticate that request using the credentials provided. The examples provided in this exercise are intended only to demonstrate how to perform requests after the token has already been received. The approach of generating tokens requires the use and knowledge of signals, which goes beyond the scope of this book.</p>
			<p>If using the double-request approach as noted in the preceding information box, you can now let developers of third-party apps communicate with your API without needing to create user accounts. However, you can still create a user in your system for that third-party <a id="_idIndexMarker1118"/>user in order to keep using the granular permission levels of your system as was done throughout this exercise. The path you take is determined by the requirements of your project.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor271"/>Summary</h1>
			<p>The examples provided throughout this chapter demonstrate a simple way to construct and work with your newly created API, in a variety of ways! If you want to give your app an SPA-like feel, the simplest implementation is to use the vanilla JavaScript <strong class="source-inline">fetch()</strong> function or the jQuery <strong class="source-inline">ajax()</strong> function. Instead of writing your own actions with either of these two functions, you could settle upon using a JavaScript-based framework, such as React, AngularJS, or Vue.js, just to name a few. The JavaScript-based frameworks can format and style your HTML on the client side. One of the template-based approaches provided in this chapter also demonstrates how this work can be transferred from the client side onto the server side. This provides you with numerous tools in your toolbox, in regard to building and working with an API. </p>
			<p>We also learned how to work with authentication tokens and discovered that we can still work with tokens when formatting HTML on the server side. However, the token approach does require additional, more advanced topics of Django and security measures before being able to fully implement that approach on a live site. The Django REST framework is intended to be the backend of an API and is designed to work with any frontend that a team settles upon.</p>
			<p>In the next chapter, we’ll explore how to test our project and make sure what has been written does actually work. To do that, we will explore how to write automated test scripts, and then install a new package that provides even more tools, as well as learning how to use them. </p>
		</div>
	</body></html>