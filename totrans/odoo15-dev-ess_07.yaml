- en: '[*Chapter 8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227): Business Logic
    – Supporting Business Processes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第8章*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227)：业务逻辑 - 支持业务流程'
- en: In the previous chapters, we learned how to use models to build the application
    data structures, and then how to explore and interact with that data using the
    ORM API and recordsets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用模型来构建应用程序数据结构，然后如何使用ORM API和记录集探索和交互数据。
- en: In this chapter, we will put all this together to implement business logic patterns
    that are common in applications. We will learn about the several ways business
    logic can be triggered, as well as some common patterns that are used to support
    them. We will also learn about important development techniques, such as logging,
    debugging, and testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把这些内容结合起来实现应用程序中常见的业务逻辑模式。我们将了解业务逻辑可以触发的几种方式，以及一些常用的支持模式。我们还将了解重要的开发技术，如日志记录、调试和测试。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Learning project – the book checkout module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习项目 - 书籍借阅模块
- en: Ways to trigger business logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发业务逻辑的方法
- en: Understanding ORM method decorators for recordsets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ORM方法装饰器用于记录集
- en: Exploring useful data model patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索有用的数据模型模式
- en: Using the ORM built-in methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ORM内置方法
- en: Adding onchange user interface logic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加onchange用户界面逻辑
- en: The message and activity features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息和活动功能
- en: Creating a wizard
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建向导
- en: Raising exceptions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Writing unit tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Using log messages
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志消息
- en: Learning about the available developer tools
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的开发者工具
- en: By the end of this chapter, you should be confident in designing and implementing
    business logic automation and know how to test and debug your code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对设计和实现业务逻辑自动化充满信心，并知道如何测试和调试你的代码。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will create a new `library_checkout` add-on module. It depends
    on the `library_app` and `library_member` add-on modules, which we created in
    the previous chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的`library_checkout`附加模块。它依赖于我们在前几章中创建的`library_app`和`library_member`附加模块。
- en: The code for these add-on modules can be found in this book's GitHub repository,
    at [https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition](https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition),
    in the `ch08` directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些附加模块的代码可以在本书的GitHub仓库中找到，在[https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition](https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition)的`ch08`目录下。
- en: Both of these add-on modules need to be available in the Odoo add-ons path so
    that they can be installed and used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个附加模块需要在Odoo附加模块路径中可用，以便它们可以被安装和使用。
- en: Learning project – the book checkout module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习项目 - 书籍借阅模块
- en: The master data structures for the library application are in place. Now, we
    want to add transactions to our system. We would like library members to be able
    to borrow books. This means we should keep track of book availability and returns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆应用程序的主数据结构已经就绪。现在，我们希望向我们的系统中添加交易。我们希望图书馆会员能够借阅书籍。这意味着我们应该跟踪书籍的可用性和归还情况。
- en: Each book checkout has a life cycle, from the moment they are created to the
    moment when the books are returned. It is a simple workflow that can be represented
    as a Kanban board, where the several stages are presented as columns, and the
    work items from the left-hand column are sent to the right until they are completed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每本书的借阅都有一个生命周期，从它们被创建的那一刻到书籍归还的那一刻。这是一个简单的流程，可以用看板（Kanban）板表示，其中几个阶段作为列呈现，来自左侧列的工作项被发送到右侧直到完成。
- en: This chapter focuses on the data model and business logic that are needed to
    support this feature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍支持此功能所需的数据模型和业务逻辑。
- en: The basic user interface will be discussed in [*Chapter 10*](B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287),
    *Backend Views – Designing the User Interface*, while the Kanban views will be
    discussed in [*Chapter 11*](B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324), *Kanban
    Views and Client-Side QWeb*. Let's quickly have a rundown of the data model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用户界面将在[*第10章*](B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287)，“后端视图 - 设计用户界面”中进行讨论，而看板视图将在[*第11章*](B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324)，“看板视图和客户端QWeb”中进行讨论。让我们快速了解一下数据模型。
- en: Preparing the data model
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据模型
- en: The first thing we must do is plan the data model that's needed for the book
    checkout feature.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是为书籍借阅功能规划所需的数据模型。
- en: 'The **book checkout** model should have the following fields:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图书借阅**模型应具有以下字段：'
- en: '**Library member** borrowing books (required)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图书馆会员**借阅图书（必需）'
- en: '**Checkout date** (defaults to today)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借阅日期**（默认为今天）'
- en: '**Responsible person** for the checkout (defaults to the current user)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负责人**（默认为当前用户）负责结账'
- en: '**Checkout lines**, with the books requested (one or more)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借阅条目**，请求的图书（一个或多个）'
- en: 'To support the book checkout life cycle, we will also have the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持图书借阅生命周期，我们还将有以下内容：
- en: '**Stage** of the request—draft, open, borrowed, returned, or canceled'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求阶段**—草稿、开放、借出、归还或取消'
- en: '**Due date**, when the books are due to be returned'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**到期日期**，图书应归还的日期'
- en: '**Returned date**, when the books were returned'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归还日期**，图书归还的日期'
- en: We will start by creating the new `library_checkout` module and implementing
    an initial version of the library checkout model. This will not introduce anything
    new compared to the previous chapters but will provide the foundation to build
    the features that are relevant for this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建新的`library_checkout`模块并实现图书馆借阅模型的初始版本。与前面的章节相比，这不会引入任何新内容，但将为构建本章相关功能提供基础。
- en: Creating the module
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'The `library_checkout` module needs to be created, similar to what we did in
    the previous chapters. Follow these steps to do this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`library_checkout`模块需要创建，类似于我们在前面的章节中所做的那样。按照以下步骤进行操作：'
- en: Create a new `library_checkout` directory in the same directory as the other
    add-on modules of the library project. This is where the following files should
    be added.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与图书馆项目其他附加模块相同的目录中创建一个新的`library_checkout`目录。以下文件应添加到此目录。
- en: 'Add the `__manifest__.py`  file and ensure it has the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`__manifest__.py`文件并确保其包含以下内容：
- en: '[PRE0]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the main `__init__.py` file with the following line of code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加主`__init__.py`文件，包含以下代码行：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the `models/__init__.py` file with the following line of code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`models/__init__.py`文件，包含以下代码行：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the model definition file, `models/library_checkout.py`, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加模型定义文件，`models/library_checkout.py`，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we should add the data files, including the access rule, the menu items,
    and some basic views so that the module can be used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该添加数据文件，包括访问规则、菜单项和一些基本视图，以便模块可以使用。
- en: 'Add the access security configuration to the `security/ir.model.access.``csv`
    file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将访问安全配置添加到`security/ir.model.access.csv`文件中：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, the `views/library_menu.xml` file needs to be added for implementing
    the menu items:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要添加`views/library_menu.xml`文件以实现菜单项：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The views are implemented in the `views/checkout_view.xml` file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图在`views/checkout_view.xml`文件中实现：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that the module contains the preceding files, it can be installed in our
    development database:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块包含上述文件后，可以在我们的开发数据库中安装：
- en: '![Figure 8.1 – The initial Library Checkout feature'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 初始图书馆借阅功能'
- en: '](img/Figure_8.1_B16119.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16119.jpg)'
- en: Figure 8.1 – The initial Library Checkout feature
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 初始图书馆借阅功能
- en: Now, we can start adding more interesting features.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加更多有趣的功能。
- en: Throughout this project, we will be adding pieces of business logic to different
    places to showcase the several possibilities that Odoo provides. The next section
    will discuss these options.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，我们将向不同位置添加业务逻辑片段，以展示Odoo提供的多种可能性。下一节将讨论这些选项。
- en: Exploring ways to trigger business logic
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索触发业务逻辑的方法
- en: Once the data model is in place, business logic is needed to perform some automatic
    actions on it. Business logic can either be directly initiated by the user, with
    an action such as a button click, or it can be triggered automatically when an
    event occurs, such as a write on a record.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据模型就绪，就需要业务逻辑来执行一些自动操作。业务逻辑可以由用户直接启动，例如通过按钮点击，或者当发生事件时自动触发，例如在记录上写入。
- en: Much of this business logic will involve reading and writing on recordsets.
    The details and techniques for this were discussed in [*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194),
    *Recordsets – Working with Model Data*, where we provided the tools for the actual
    business logic implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分业务逻辑将涉及对记录集的读取和写入。这些细节和技术在[*第7章*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194)，*记录集
    – 与模型数据交互*中进行了讨论，我们提供了实际业务逻辑实现所需的工具。
- en: The next question is how the business logic should be triggered. This will depend
    on when and why the business logic should be triggered. Here is a summary of the
    several options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Some business logic is tightly connected to the model field definitions. Some
    of the instances of **model definition-related business logic** are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`@api.constrains`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@api.depends` and assigned to the `compute` field attribute.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@api.model` and assigned to the `default` field attribute.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This model definition logic was discussed in detail in [*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164),
    *Models – Structuring the Application Data*. Some examples can be found in the
    *Data model patterns* section. The *ORM method decorators for recordsets* section
    provides a recap of the several ORM decorators mentioned here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have **model event-related business logic**, which is related to business
    workflows. It can be attached to the following record-related events:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Create, write, and unlink** business logic can be added to these events,
    for the cases where the other, more elegant approaches are not possible.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onchange** logic can be applied to user interface views so that we have some
    field values that are changed as a consequence of changes being made to other
    fields.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For actions that are directly initiated by the user, the following options
    are available:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A `button` view element for calling an object method. The button can be on a
    form or tree of the Kanban view.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `server` action, which is available from a menu item or in the `Action` context
    menu.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `window` action for opening a wizard form, where input can be collected from
    the user and a button will call the business logic. This allows for richer user
    interaction.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques will be presented throughout this chapter. The supporting methods
    will often use API decorators, so it is important to understand the different
    available ones. For clarity, the next section provides an overview of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ORM method decorators for recordsets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method definition can be preceded by an `@`, which applies a decorator to
    it. These decorators add specific behaviors for these methods and depending on
    the purpose of a method, different decorators can be used.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Decorators for computed fields and validation methods
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few decorators are useful for validation logic and computed fields. They
    are listed here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`@api.depends(fld1,...)` is used for computed field functions to identify what
    changes the (re)calculation should be triggered on. It must set values on the
    computed fields; otherwise, an error will be shown.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@api.constrains(fld1,...)` is used for model validation functions and performs
    checks for when any of the mentioned fields are changed. It should not write changes
    in the data. If the checks fail, an exception should be raised.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were discussed in detail in [*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164),
    *Models – Structuring the Application Data*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Another group of decorators affect the `self` recordset behavior and are relevant
    when you're implementing other kinds of business logic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组装饰器会影响 `self` 记录集的行为，并且当你实现其他类型的业务逻辑时是相关的。
- en: Decorators that affect the self recordset
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响self记录集的装饰器
- en: By default, methods are expected to act on a recordset that's provided by the
    self `first` argument. The method code will usually include a `for` statement
    that loops through each of the records in the `self` recordset.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，方法预期作用于由 `self` 的第一个参数提供的记录集。方法代码通常会包含一个 `for` 语句，该语句遍历 `self` 记录集中的每个记录。
- en: Changes in Odoo 14
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 14 的变化
- en: The `@api.multi` decorator was removed from Odoo 14\. In previous Odoo versions,
    it was used to explicitly signal that the decorated method expects a recordset
    in the `self` parameter. This is already the default behavior for methods, so
    its use is only for clarity. The `@api.one` decorator has been deprecated since
    Odoo 9 and was also removed in Odoo 14\. It handled the record loop for you so
    that the method code would be called once for each record, and the `self` argument
    would always be a singleton. Since Odoo 14, both decorators must be removed from
    the code since they are not supported anymore.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@api.multi` 装饰器在 Odoo 14 中已被移除。在之前的 Odoo 版本中，它被用来明确表示被装饰的方法期望在 `self` 参数中有一个记录集。这对于方法来说已经是默认行为，因此它的使用只是为了清晰。`@api.one`
    装饰器自 Odoo 9 起已被弃用，并在 Odoo 14 中被移除。它为你处理记录循环，使得方法代码对每个记录只调用一次，并且 `self` 参数始终是一个单例。从
    Odoo 14 开始，这两个装饰器都必须从代码中移除，因为它们不再被支持。'
- en: In some cases, the method is expected to work at the class level and not on
    particular records, behaving like a `@api.model` and, in this case, the `self`
    method parameter should be used as a reference to the model; it is not expected
    to contain records.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，方法预期在类级别上工作，而不是在特定记录上，表现得像 `@api.model`，在这种情况下，`self` 方法参数应该用作模型的引用；它不期望包含记录。
- en: For example, the `create()` method uses `@api.model` – it does not expect records
    as input, only a values dictionary, which will be used to create and return a
    record. The methods that are used to calculate default values should also use
    the `@api.model` decorator.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`create()` 方法使用 `@api.model` – 它不期望输入记录，只期望一个值字典，该字典将被用来创建并返回一个记录。用于计算默认值的方法也应该使用
    `@api.model` 装饰器。
- en: Before we can go deeper into the business logic's implementation, we must add
    more depth to the data model and, in the process, provide examples of a couple
    of common data model patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以深入到业务逻辑实现之前，我们必须使数据模型更加深入，在这个过程中，提供一些常见数据模型模式的示例。
- en: Exploring useful data model patterns
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索有用的数据模型模式
- en: There are a few data structures that are often needed for models that represent
    business documents. These can be seen in several Odoo apps, such as **Sales Orders**
    or **Invoices**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表示业务文档的模型，通常需要一些数据结构。这些可以在几个 Odoo 应用程序中看到，例如 **销售订单** 或 **发票**。
- en: A common pattern is the header/lines data structure. It will be used for a checkout
    request so that you can have several books. Another pattern is to use states or
    stages. These two have differences, and we will discuss them and provide a reference
    implementation shortly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是表头/行数据结构。它将用于结账请求，以便你可以有多个书籍。另一个模式是使用状态或阶段。这两个有区别，我们将在稍后讨论它们并提供一个参考实现。
- en: Finally, the ORM API provides a few methods that are relevant for the user interface.
    These will also be discussed in this section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，ORM API 提供了一些与用户界面相关的几个方法。这些方法也将在本节中讨论。
- en: Using header and lines models
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表头和行模型
- en: A common need for form views is to have header-line data structures. For example,
    a sales order includes several lines for the ordered items. In the case of the
    checkout feature, a checkout request can have several request lines, one for each
    of the borrowed items.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表单视图的一个常见需求是拥有表头行数据结构。例如，销售订单包括几个订单项的行。在结账功能的案例中，一个结账请求可以有多个请求行，每个请求行对应一个借出的物品。
- en: With Odoo, it is simple to implement this. Two models are needed for a header-line
    form view – one for the document header and another for the document lines. The
    line model has a many-to-one field to identify the header it belongs to, while
    the header model has a one-to-many field listing the lines in that document.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Odoo，实现这一点很简单。需要一个表头行表视图的两种模型 – 一个用于文档表头，另一个用于文档行。行模型有一个多对一字段来标识它所属的表头，而表头模型有一个一对多字段列出该文档中的行。
- en: 'The `library_checkout` module was already added to the checkout model, so now,
    we want to add the lines. Follow these steps to do so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`library_checkout`模块已经添加到结账模型中，因此现在我们想要添加行。按照以下步骤进行操作：'
- en: 'Edit the `models/library_checkout.py` file to add the one-to-many field for
    the checkout lines:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`models/library_checkout.py`文件，为结账行添加多对一字段：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the file for the new model to `models/__init__.py`, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新模型的文件添加到`models/__init__.py`中，如下所示：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, add the Python file for declaring the checkout lines model, `models/library_checkout_line.py`,
    with the following content:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加声明结账行模型的Python文件，`models/library_checkout_line.py`，内容如下：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We must also add access security configuration. Edit the `security/ir.model.access.csv`
    file and add the following highlighted line:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须添加访问安全配置。编辑`security/ir.model.access.csv`文件，并添加以下突出显示的行：
- en: '[PRE10]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we want to add the checkout lines to the form. We will be adding it as
    the first page of a notebook widget. Edit the `views/checkout_view.xml` file and,
    just before the `</sheet>` element, add the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要将结账行添加到表单中。我们将将其添加为笔记本小部件的第一页。编辑`views/checkout_view.xml`文件，并在`</sheet>`元素之前添加以下代码：
- en: '[PRE11]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Checkouts form will look as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结账表单将如下所示：
- en: '![Figure 8.2 – The Checkouts form with the notebook widget'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 带有笔记本小部件的结账表单'
- en: '](img/Figure_8.2_B16119.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B16119.jpg)'
- en: Figure 8.2 – The Checkouts form with the notebook widget
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 带有笔记本小部件的结账表单
- en: The line's one-to-many field displays a list view that's nested in the parent
    form view. By default, Odoo will look up a list view definition to use for rendering,
    which is typical for any list view. If none are found, a default one will be automatically
    generated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该行的多对一字段显示一个嵌套在父表单视图中的列表视图。默认情况下，Odoo将查找用于渲染的列表视图定义，这对任何列表视图都是典型的。如果没有找到，将自动生成一个默认视图。
- en: It is also possible to declare specific views inside `<field>`. We did this
    in the preceding code. Inside the `line_ids` field element, there is a nested
    `<tree>` view definition that will be used for this form.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在`<field>`内部声明特定的视图。我们在前面的代码中就是这样做的。在`line_ids`字段元素内部，有一个嵌套的`<tree>`视图定义，将用于此表单。
- en: Using stages and states for document-centered workflows
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用阶段和状态进行以文档为中心的工作流程
- en: In Odoo, we can implement workflows that are centered on documents. What we
    refer to as documents can be things such as sales orders, project tasks, or HR
    applicants. All of these are expected to follow a certain life cycle since they're
    created until they conclude. Each work item is recorded in a document that will
    progress through a list of possible stages until it is completed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo中，我们可以实现以文档为中心的工作流程。我们所说的文档可以是销售订单、项目任务或人力资源申请人等。所有这些在创建到完成的过程中都应遵循一定的生命周期。每个工作项都记录在将经过一系列可能阶段的文档中，直到完成。
- en: If we present these stages as columns in a board, and the documents as items
    in those columns, we get a Kanban board, providing a quick view of all the work
    in progress.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些阶段作为看板中的列，并将文档作为这些列中的项目，我们就会得到一个看板，提供所有进行中工作的快速视图。
- en: 'There are two approaches to implementing these progress steps – **states**
    and **stages**:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些进度步骤有两种方法 – **状态**和**阶段**：
- en: '`state` special field name, making it convenient to use. The closed states
    list is a disadvantage, in that it can''t easily accommodate custom process steps.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`特殊字段名称，使其使用方便。关闭状态列表的缺点在于它不能轻易地容纳自定义流程步骤。'
- en: '`stage_id` field name. The list of available stages is easy to modify as you
    can remove, add, or reorder them. It has the disadvantage of not being reliable
    for process automation. Since the list of stages can be changed, automation rules
    can''t rely on particular stage IDs or descriptions.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stage_id`字段名称。可用的阶段列表容易修改，因为您可以删除、添加或重新排序它们。它的缺点是对于流程自动化来说不可靠。由于阶段列表可以更改，自动化规则不能依赖于特定的阶段ID或描述。'
- en: When we're designing the data model, we need to decide whether it should use
    stages or states. If triggering business logic is more important than the ability
    to configure the process steps, states should be preferred; otherwise, stages
    should be the preferred choice.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计数据模型时，我们需要决定是否应该使用阶段或状态。如果触发业务逻辑比配置流程步骤的能力更重要，则应优先选择状态；否则，阶段应该是首选选择。
- en: 'If you can''t decide, there is an approach that can provide the best of both
    worlds: we can use stages and map each stage to a corresponding state. The list
    of process steps can easily be configured by users, and since each stage will
    be linked to some reliable state code, it can also be confidently used to automate
    business logic.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法决定，有一种方法可以提供两种世界的最佳结合：我们可以使用阶段并将每个阶段映射到相应的状态。流程步骤的列表可以很容易地由用户进行配置，并且由于每个阶段都将与某些可靠的状态代码相关联，因此也可以自信地用于自动化业务逻辑。
- en: 'This combined approach will be used for the library checkout feature. To implement
    the checkout stages, we will add the `library.checkout.stage` model. The fields
    that are needed to describe a stage are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结合的方法将被用于图书馆借阅功能。为了实现借阅阶段，我们将添加`library.checkout.stage`模型。描述阶段所需的字段如下：
- en: '**Name**, or title.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**，或标题。'
- en: '**Sequence**, which is used to order the stage columns.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**，用于对阶段列进行排序。'
- en: '**Fold**, to be used by the Kanban view to decide what columns should be folded
    by default. We usually want to set this on inactive item columns, such as *Done*
    or *Canceled*.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠**，用于Kanban视图决定默认应该折叠哪些列。我们通常希望将此设置在非活动项列上，例如*完成*或*取消*。'
- en: '**Active**, to allow archived or no-longer-used stages, in case the process
    is changed.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活**，允许存档或不再使用的阶段，以防流程发生变化。'
- en: '**State**, a closed selection list, which is used to map each stage to a fixed
    state.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**，一个封闭的选择列表，用于将每个阶段映射到固定状态。'
- en: 'To implement the preceding fields, we should start adding the **Stages** model,
    including the model definition, views, menus, and access security:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的字段，我们应该开始添加**阶段**模型，包括模型定义、视图、菜单和访问安全：
- en: 'Add the `models/library_checkout_stage.py` file and ensure it contains the
    following model definition code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`models/library_checkout_stage.py`文件并确保它包含以下模型定义代码：
- en: '[PRE12]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code shouldn't be surprising to you. Stages have a logical sequence,
    so the order in which they are presented is important. This is ensured by `_order="sequence"`.
    We can also see the `state` field mapping each stage to a basic state, which can
    be safely used by the business logic.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码不应让您感到惊讶。阶段有一个逻辑顺序，因此它们呈现的顺序很重要。这通过`_order="sequence"`得到保证。我们还可以看到`state`字段将每个阶段映射到基本状态，这可以安全地用于业务逻辑。
- en: 'As usual, the new code file must be added to the `models/__init__.py` file,
    which should then look like this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，新的代码文件必须添加到`models/__init__.py`文件中，该文件应如下所示：
- en: '[PRE13]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Access security rules are also needed. Stages contain setup data, and it should
    only be editable by the `security/ir.model.access.csv` file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问安全规则。阶段包含设置数据，并且只能通过`security/ir.model.access.csv`文件进行编辑：
- en: '[PRE14]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, a menu item is needed, to navigate to the stage''s setup. This should
    be under the `library_app` module does not provide one yet, so let''s edit it
    to add this. Edit the `library_app/views/library_menu.xml` file and add the following
    XML:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要一个菜单项，用于导航到阶段的设置。由于`library_app`模块尚未提供，让我们编辑它以添加此功能。编辑`library_app/views/library_menu.xml`文件并添加以下XML：
- en: '[PRE15]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the `library_checkout/views/library_menu.xml` file and add the following
    XML:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`library_checkout/views/library_menu.xml`文件中添加以下XML：
- en: '[PRE16]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need some stages to work with, so let''s add some default data to the module.
    Create the `data/library_checkout_stage.xml` file with the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一些阶段来工作，因此让我们向模块添加一些默认数据。创建`data/library_checkout_stage.xml`文件，并包含以下代码：
- en: '[PRE17]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before this can take effect, it needs to be added to the `library_checkout/__manifest__.py`
    file, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此生效之前，需要将其添加到`library_checkout/__manifest__.py`文件中，如下所示：
- en: '[PRE18]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot shows what the Stages list view is expected to look
    like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了预期的阶段列表视图：
- en: '![Figure 8.3 – The Stages list view'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 阶段列表视图'
- en: '](img/Figure_8.3_B16119.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B16119.jpg)'
- en: Figure 8.3 – The Stages list view
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 阶段列表视图
- en: This takes care of all the components that are needed to add the Stages model
    to `library_checkout` and allow users to configure it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了添加阶段模型到`library_checkout`并允许用户配置它所需的所有组件。
- en: Adding stage workflow support to models
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向模型添加阶段工作流支持
- en: 'Next, the stage field should be added to the library checkout model. For a
    proper user experience, two more things should be taken care of:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，应将阶段字段添加到图书馆借阅模型中。为了提供良好的用户体验，还应注意以下两点：
- en: The default stage to assign should be the first with a `new` state.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应分配的默认阶段应该是具有`new`状态的第一个。
- en: When grouping by stage, all the available stages should be present, even if
    there are no checkouts in each of the stages.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按阶段分组时，所有可用的阶段都应该存在，即使每个阶段都没有结账。
- en: These should be added to the `library_checkout/models/library_checkout.py` file,
    in the `Checkout` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应该添加到`library_checkout/models/library_checkout.py`文件中的`Checkout`类。
- en: 'The function for finding the default stage should return the record that will
    be used as the default value:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查找默认阶段的函数应返回将用作默认值的记录：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This returns the first record in the stage model. Since the stage model is ordered
    by sequence, it will return the one with the lowest sequence number.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回阶段模型中的第一条记录。由于阶段模型按顺序排序，它将返回具有最低序列号的记录。
- en: 'When we''re grouping by stages, we would like to see all the possible stages
    rather than only the ones with checkout records. The method that''s used for this
    should return a recordset to use for the groups. In this case, it is appropriate
    to return all the active stages:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按阶段分组时，我们希望看到所有可能的阶段，而不仅仅是具有结账记录的阶段。用于此的方法应返回用于分组的记录集。在这种情况下，返回所有活动阶段是合适的：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the `stage_id` field we wish to add to the checkout model can use
    the preceding methods for the `default` and `group_expand` attributes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望添加到结账模型的`stage_id`字段可以使用前面提到的`default`和`group_expand`属性的方法：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`stage_id` has a many-to-one relationship with the stages model. The default
    value is calculated by the `_default_stage_id` method function, and the groupby
    on `stage_id` will use the result of the `_group_expand_stage_id` method function.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`stage_id`与阶段模型具有多对一的关系。默认值由`_default_stage_id`方法函数计算，`stage_id`上的groupby将使用`_group_expand_stage_id`方法函数的结果。'
- en: Changes in Odoo 10
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 10的变化
- en: The `group_expand` field attribute was introduced in Odoo 10 and is not available
    in previous versions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_expand`字段属性是在Odoo 10中引入的，在之前的版本中不可用。'
- en: The `group_expand` parameter overrides the way grouping works on the field.
    The default behavior for grouping operations is to only see the stages that are
    being used; the stages with no checkout document won't be shown. But in the case
    of the `stage_id` field, we want to see all the available stages, even if some
    don't have any items.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_expand`参数覆盖了字段上分组的方式。分组操作的默认行为是只看到正在使用的阶段；没有结账文档的阶段不会显示。但在`stage_id`字段的情况下，我们希望看到所有可用的阶段，即使其中一些没有任何项目。'
- en: The `_group_expand_stage_id()` helper function returns the list of group records
    that the grouping operation should use. In this case, it returns all the existing
    stages, regardless of having library checkouts in that stage or not.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`_group_expand_stage_id()`辅助函数返回分组操作应使用的分组记录列表。在这种情况下，它返回所有现有阶段，无论该阶段是否有图书馆结账。'
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `group_expand` attribute must be a string with a method name. This is unlike
    other attributes, such as `default`, which can be either strings or direct references
    to the method name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`group_expand`属性必须是一个包含方法名称的字符串。这与其他属性不同，例如`default`，它可以是要字符串或直接引用方法名称。'
- en: The `state` field was also added. It simply makes the stage-related `state`
    field in this model available so that it can be used in views. This will use the
    special support for `state` that views have available.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 也添加了`state`字段。它只是使此模型中与阶段相关的`state`字段可用，以便可以在视图中使用。这将使用视图可用的特殊`state`支持。
- en: Methods to support the user interface
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持用户界面的方法
- en: 'The following methods are mostly used by the web client to render the user
    interface and perform basic interaction:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法主要用于网络客户端以渲染用户界面和执行基本交互：
- en: '`name_get()` computes the `(ID, name)` tuples, along with the ID. It is the
    default computation for the `display_name` value and can be extended to implement
    custom display representations, such as displaying an identifier code along with
    the record name.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_get()`计算`(ID, name)`元组，以及ID。它是`display_name`值的默认计算，可以扩展以实现自定义显示表示，例如在记录名称旁边显示标识代码。'
- en: '`name_search(name="", args=None, operator="ilike", limit=100)` performs a search
    on the display name. It is used on views when the user is typing in a relationship
    field to produce a list containing the suggested records that match the typed
    text. It returns a list of `(ID, name)` tuples.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_search(name="", args=None, operator="ilike", limit=100)`在显示名称上执行搜索。当用户在关系字段中键入时用于视图，以生成包含与键入文本匹配的建议记录的列表。它返回`(ID,
    name)`元组的列表。'
- en: '`name_create(name)` creates a new record that only has a name as input. It
    is used in Kanban views with `on_create="quick_create"`, where you can quickly
    create a related record by just providing its name. It can be extended to provide
    specific defaults for the new records that are created through this feature.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_create(name)`创建一个只接受名称作为输入的新记录。它在`on_create="quick_create"`的看板视图中使用，您只需提供其名称即可快速创建相关记录。它可以扩展以提供通过此功能创建的新记录的特定默认值。'
- en: '`default_get([fields])` returns the default values for a new record to be created,
    as a dictionary. The default values may depend on variables, such as the current
    user or the session context. This can be extended to add additional default values.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_get([fields])`返回要创建的新记录的默认值，作为一个字典。默认值可能取决于变量，例如当前用户或会话上下文。这可以扩展以添加额外的默认值。'
- en: '`fields_get()` is used to describe the model''s field definitions.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields_get()`用于描述模型的字段定义。'
- en: '`fields_view_get()` is used by the web client to retrieve the structure of
    the UI view to render. It can be given the ID of the view as an argument, or the
    type of view we want using `view_type="form"`. For example, `self.fields_view_get(view_type="tree")`
    will return the tree view XML architecture to be rendered for the `self` model.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields_view_get()`由Web客户端用于检索UI视图的结构以进行渲染。它可以提供一个视图的ID作为参数，或者使用`view_type="form"`来指定我们想要的视图类型。例如，`self.fields_view_get(view_type="tree")`将返回用于渲染`self`模型的树视图XML架构。'
- en: These built-in ORM models can be helpful as extension points to implement model-specific
    business logic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置ORM模型可以作为实现特定模型业务逻辑的扩展点。
- en: The next section will discuss how business logic can be triggered by record
    operations, such as creating or writing on a record.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论如何通过记录操作（如创建或写入记录）触发业务逻辑。
- en: Using the ORM built-in methods
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM内置方法
- en: The model definition-related methods can do many things, but some business logic
    is not possible through them, so it needs to be attached to the ORM record writing
    operations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模型定义相关的方法可以执行许多操作，但某些业务逻辑无法通过它们实现，因此需要附加到ORM记录写操作上。
- en: ORM provides methods to perform **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations on our model data. Let's explore these write operations
    and how they can be extended to support custom logic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ORM提供了执行**创建**、**读取**、**更新**和**删除**（**CRUD**）操作的方法，这些操作针对我们的模型数据。让我们探讨这些写操作以及如何扩展以支持自定义逻辑。
- en: To read data, the main methods that are provided are `search()` and `browse()`,
    as discussed in [*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194),
    *Recordsets – Working with Model Data*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取数据，提供的主要方法是`search()`和`browse()`，如在第[*第7章*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194)中所述，*记录集
    – 与模型数据交互*。
- en: Methods for writing model data
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入模型数据的方法
- en: 'The ORM provides three methods for the three basic write operations, shown
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ORM提供了三种基本写操作的方法，如下所示：
- en: '`<Model>.create(values)` creates a new record on the model. It returns the
    created record. `values` can be a dictionary or a list of dictionaries for mass-creating
    records.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Model>.create(values)`在模型上创建一个新的记录。它返回创建的记录。`values`可以是一个字典或字典列表，用于批量创建记录。'
- en: '`<Recordset>.write(values)` updates the recordset with the `values` dictionary.
    It returns nothing.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Recordset>.write(values)`使用`values`字典更新记录集。它不返回任何内容。'
- en: '`<Recordset>.unlink()` deletes the records from the database. It returns nothing.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Recordset>.unlink()`从数据库中删除记录。它不返回任何内容。'
- en: The `values` argument is a dictionary that maps field names to values to write.
    These methods are decorated with `@api.multi`, except for the `create()` method,
    which is decorated with `@api.model`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`参数是一个将字段名称映射到要写入的值的字典。这些方法除了`create()`方法外，都带有`@api.multi`装饰器，而`create()`方法则带有`@api.model`装饰器。'
- en: Changes in Odoo 12
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 12的变化
- en: Being able to use `create()` to access a list of dictionaries, instead of a
    single dictionary object, was introduced in Odoo 12\. This also allows us to create
    records in batches. This capability is supported through the special `@api.model_create_multi`
    decorator.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo 12中引入了能够使用`create()`访问字典列表，而不是单个字典对象的能力。这也允许我们批量创建记录。这种能力是通过特殊的`@api.model_create_multi`装饰器支持的。
- en: In some cases, these methods need to be extended to run some specific business
    logic when they are triggered. This business logic can be run before or after
    the main method operations are executed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这些方法需要扩展以在触发时运行一些特定的业务逻辑。这个业务逻辑可以在主方法操作执行前后运行。
- en: Example of extending create()
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展create()的示例
- en: Let's look at an example that makes use of this. We want to prevent new checkout
    records from being created directly in the `Borrowed` or `Returned` states. Usually,
    validations should be implemented in specific methods that are decorated with
    `@api.constrains`. But this particular case is tied to the create record event
    and is hard to implement as a regular validation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `library_checkout/models/library_checkout.py` file and add the `create()`
    extension method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The new record is created by the `super().create()` call. Before this, the new
    record is not available to use in the business logic – only the `values` dictionary
    can be used, or even changed, to force values on the to-be-created record.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The code after `super().create()` does have access to the new record that's
    been created and can use record features, such as accessing related records using
    dot-notation chains. The preceding example uses `new_record.stage_id.state` to
    access the state that corresponds to the new record stage. States are not user-configurable
    and provide a reliable list of values to use in business logic. So, we can look
    for `open` or `done` states and raise an error if any of them are found.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Example of extending write()
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at another example. The `Checkout` model should keep track of the
    date when the books were borrowed, `Checkout Date`, and the date when they were
    returned, `Close Date`. This can''t be done using computed fields. Instead, the
    `write()` method should be extended to detect changes on the checkout state and
    then update the dates that have been filed at the right moment: when changing
    into the `open` or `close` states.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement this logic, the two date fields must be created. Edit the
    `library_checkout/models/library_checkout.py` file and add the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When a record is modified, the `checkout_date` and `close_date` fields should
    be set when the checkout record enters the appropriated states. For this, we will
    use a custom `write()` method, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the extension code was added before the `super()`
    call; so, *before* the write operation is done on the `self` record. To know what
    change is about to be made to the record, we can inspect the `vals` parameter.
    The `stage_id` value in the `vals` dictionary is an ID number, not a record, so
    it needs to be browsed to get the corresponding record, and then read the corresponding
    `state`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The old and new states are compared to trigger the date value update at the
    appropriate moment. Whenever possible, we prefer to change the values to write
    before the `super().write()` instruction and modify the `vals` dictionary instead
    of setting the field value directly. We'll see why in the next section.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Example of extending write() that sets values on fields
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code only modifies the values to use for the write; it does not
    assign values directly to the model fields. This is safe to do, but it may not
    be enough in some cases.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning a model field value inside a `write()` method leads to an infinite
    recursion loop: the assignment triggers the write method again, which then repeats
    the assignment, triggering yet another write call. This will repeat until Python
    returns a recursion error.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: There is a technique to avoid this recursion loop, making it possible for `write()`
    methods to set values on its record fields. The trick is to set a unique marker
    in the environment's `context` before setting the values, and only run the setting
    values code when that marker is not present.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will help make this clear. Let''s rewrite the previous example so
    that the updates are done after calling `super()`, rather than before:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this technique, the extension code is guarded by an `if` statement and
    only runs if a specific marker is not found in the context. Furthermore, the additional
    `self.write()` operations use the `with_context` method to set that marker before
    doing the write. This combination ensures that the custom login inside the `if`
    statement runs only once and is not triggered on further `write()` calls, avoiding
    the infinite loop.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: When (not) to extend the create() and write() methods
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extending the `create()` or `write()` methods should be carefully considered.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, some validation must be performed, or some value must be automatically
    computed when the record is saved. For these common cases, there are better options,
    as listed here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: For field values that are automatically calculated based on other fields, use
    computed fields. For example, you should calculate a header total when the values
    of the lines are changed.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-fixed field default values, use a function as the default field value.
    It will be evaluated and used to assign the default value.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have other field values change when some field is changed, use the `onchange`
    methods, if this is expected to be done on the user interface, or use the new
    `onchange` methods, this only works on form view interaction, not on direct write
    calls, though computed writable fields work in both cases. The *Adding onchange
    user interface logic* section will provide more detail about this.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For validations, use `constraint` functions. These are automatically triggered
    when the field value changes and are expected to raise errors if the validation
    conditions fail.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are still cases where none of these options will work and extending `create()`
    or `write()` is needed, such as when the default values to set depend on the other
    fields of the record that's being created. In this case, a default value function
    won't work because it does not have access to the other field values of the new
    record.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Methods for data import and export
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data import and export, as discussed in [*Chapter 5*](B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146),
    *Importing, Exporting, and Module Data*, is also available from the ORM API, through
    the following methods:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '`load([fields], [data])` is used to import data and is used by Odoo when importing
    CSV or spreadsheet data into Odoo. The first argument is the list of fields to
    import, and it maps directly to a CSV top row. The second argument is a list of
    records, where each record is a list of string values to parse and import. It
    maps directly to the CSV data rows and columns and implements the features of
    CSV data import, such as external identifiers support.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export_data([fields])` is used by the web client''s `Export` function. It
    returns a dictionary with a `datas` key containing the data; that is, a list of
    rows. The field names can use the `.id` and `/id` suffixes that are used in CSV
    files, and the data is in a format that''s compatible with an importable CSV file.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to implement automation on the user interface, while the
    user is editing data. We'll learn about this in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Adding onchange user interface logic
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to make changes to the web client view while the user is editing
    it. This mechanism is known as `@api.onchange`, and they are triggered by the
    user interface view when the user edits a value on a particular field.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Since Odoo 13, the same effect can be achieved by using a particular form of
    computed fields, called **computed writable fields**. This ORM improvement aims
    to avoid some limitations of the classic onchange mechanism, and in the long run,
    it should replace it completely.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Classic onchange methods
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Onchange methods can change other field values in the form, perform a validation,
    show a message to the user, or set a domain filter in relation fields, limiting
    the available options.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The onchange method is called asynchronously and returns data that's being used
    by the web client to update the fields in the current view.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Onchange methods are linked to the triggering fields, which are passed as arguments
    to the `@api.onchange("fld1", "fld2", ...)` decorator.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The `api.onchange` arguments do not support dot notation; for example, `"partner_id.name"`.
    If used, it will be ignored.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Inside the method, the `self` argument is a virtual record that contains the
    current form data. It is virtual because it can be a new or changed record that
    is still being edited and hasn't been saved to the database yet. If values are
    set on this `self` record, these will be changed on the user interface form. Notice
    that it doesn't write to database records; instead, it provides information so
    that you can change the data in the UI form.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Other restrictions apply to onchange methods, as documented at [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange).Computed
    writable fields can be used as a full-featured alternative to onchanges. See the
    *The new onchange, with computed writable fields* section for more information.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: No return value is needed, but a `dict` structure may be returned with a warning
    message to display in the user interface, or a domain filter to be set on form
    fields.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with an example. On the checkout form, when the library member is
    selected, the request date will be set to `today`. If the date changed, a warning
    message will be shown to the user, alerting them about it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, edit the `library_checkout/models/library_checkout.py` file
    and add the following method:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous `onchange` method is triggered when the `member_id` field is set
    on the user interface. The actual method name is not relevant, but the convention
    is for its name to begin with the `onchange_` prefix.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Inside an `onchange` method, `self` represents a single virtual record containing
    all of the fields that have currently been set in the record being edited, and
    we can interact with them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The method code checks whether the current `request_date` needs to be changed.
    If it does, `request_date` is set to today so that the user will see that change
    in the form. Then, a non-blocking warning message is returned to the user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onchange` methods do not need to return anything, but they can return
    a dictionary containing a warning or a domain key, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'The warning key should describe a message to show in a dialog window, such
    as `{"title": "Message Title", "message": "Message Body"}`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The domain key can set or change the domain attribute of other fields. This
    allows you to build more user-friendly interfaces; having a to-many field only
    makes the options that make sense at that moment available. The value for the
    domain key looks like `{"user_id": [("email", "!=", False)]}`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new onchange, with computed writable fields
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classic onchange mechanism has a key role in the user experience that's
    provided by the Odoo framework. However, it has a few important limitations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: One is that it works disconnected from the server-side events. Onchange is only
    played when requested by the form view and is not called as a consequence of an
    actual `write()` value change. This forces the server-side business logic to explicitly
    replay the relevant onchange methods.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation is that onchange is attached to the triggering fields and
    not to the change-affected fields. In non-trivial cases, this becomes hard to
    extend and makes it difficult to track the source of the changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To address these issues, the Odoo framework expanded the computed field capabilities
    so that it can also address the onchange use case. We will call this technique
    **computed writable fields**. The classic onchange is still supported and used,
    but it is expected to be replaced by computed fields and become deprecated in
    future versions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Computed writable fields were introduced in Odoo 13 and are available for that
    version and later ones.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Computed writable fields have compute methods assigned to them, must be stored,
    and must have the **readonly=False** attribute.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the previous onchange using this technique instead. This is
    how the `request_date` field definition should be changed:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a regular stored and writable field, but it has attached a compute method
    that can be triggered in particular conditions. For example, the computed method
    should be triggered when the `member_id` field changes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code for the compute method, `_compute_request_date_onchange`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`@api.depends` works as usual for computed fields and declares the fields to
    watch for changes. The actual field list to provide is the same as the one that''s
    used by the classic `@api.onchange`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The method code can be very similar to the equivalent onchange method. In this
    particular case, it is identical. Note that the computed field is not ensured
    to be set a value on every method call. This only happens when some conditions
    are met. In this case, the original request date is different from today's date.
    This goes against regular computed field rules but is allowed for computed writable
    fields.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Particularly relevant to business processes is the ability to send emails or
    notify users. The next section discusses the features that Odoo provides for this.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The message and activity features
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo has global messaging and activity planning features available, all of which
    are provided by the `mail` technical name.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The messaging features are added by the `mail.thread` model and make a message
    widget on form views available, also known as C*hatter*. This widget allows you
    to log notes or send messages to other people. It also keeps a history of the
    messages that have been sent, and it is also used by automatic processes to log
    progress tracking messages.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: The same app also provides activity management features through the `mail.activity.mixin`
    model. The activity widget can be added to the form view to allow users to schedule
    and track the history of activities.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Adding message and activity features
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mail module provides the `mail.thread` abstract class, which is used to
    add the messaging features to any model, and `mail.activity.mixin`, which does
    the same for the planned activity features. In [*Chapter 4*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119),
    *Extending Modules*, we explained how to add these inherited features to models
    using the inheritance from mixin abstract classes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the necessary steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `mail` module dependency to the `library_checkout` add-on module by
    editing the `''depends''` key in the `library_checkout/__manifest__.py` file,
    as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To have the `library.checkout` model inherit from the message and activity
    abstract classes, edit the `library_checkout/models/library_checkout.py` files,
    as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To add the message and activity fields to the checkout form view, edit the
    `library_checkout/` and `views/checkout_view.xml` files:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Having done this, the checkout model will have the message and activity fields
    and their features available.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Message and activity fields and models
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message and activity features add new fields to the models that inherit
    the `mail.thread` and `mail.activity.mixin` classes, along with all the supporting
    models for these features. These are the basic data structures that have been
    added.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mail.thread` mixin class makes two new fields available:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '`message_follower_ids` has a one-to-many relationship with `mail.followers`
    and stores the message followers that should receive notifications. Followers
    can either be partners or channels. A **partner** represents a specific person
    or organization. A **channel** is not a particular person and instead represents
    a subscription list.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_ids` has a one-to-many relationship with `mail.message` records and
    lists the record message history.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mail.activity.mixin` mixin class adds the following new field:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`activity_ids` has a one-to-many relationship with `mail.activity` and stores
    activities that have been completed or planned.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message subtypes
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages can be assigned a **subtype**. Subtypes can identify particular events,
    such as a task being created or closed, and are useful for fine-tuning what notifications
    should be sent to whom.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Subtypes are stored in the `mail.message.subtype` model and can be configured
    in the **Settings** | **Technical** | **Email** | **Subtypes** menu.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic message subtypes that are available are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '`mail.mt_comment` XML ID, are used for the messages that are sent through the
    **Send message** option in the message widget. Followers will be sent a message
    notification about this.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mail.mt_note` XML ID, is used by the messages that are created with the **Log
    note** XML ID, which do not send out notifications.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mail.mt_activities` XML ID, are used for the messages that are created with
    the `Schedule activity` link. It is not intended to send a notification.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps can add their own subtypes, which are usually linked to relevant events.
    For example, the `Quotation sent` and `Sales Order Confirmed`. These are used
    by the app's business logic when you're logging these events in the message history.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtypes allow you to determine when notifications should be sent out and to
    whom. The followers menu, at the top right of the messages widget, allows you
    to add or remove followers, as well as selecting the particular subtypes they
    will receive notifications about. The following screenshot shows the subtype selection
    form for a specific follower – *Deco Addict*, in this case:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Followers widget to select the active message subtypes'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16119.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Followers widget to select the active message subtypes
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The subtype subscription flags can be edited manually, and their default value
    is configured on editing the **Subtype** definition to check the **Default** field.
    When it is set, the followers on new records will receive notifications by default.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Other than the built-in subtypes, add-on modules add their own subtypes. A subtype
    can be global or intended for a particular model. In the latter case, the subtype's
    `res_model` field identifies the model it applies to.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Posting messages
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Module business logic can make use of the messaging system to send notifications
    to users.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The `message_post()` method is used to post a message. Here is an example:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code adds a simple text message but sends no notification to the
    followers. This is because, by default, messages are posted using `subtype="mail.mt_note"`
    parameter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'To have the message send a notification as well, the `mail.mt_comment` subtype
    should be used, as shown in the following example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The message body is HTML, so we can include markup for text effects, such as
    `<b>` for bold text or `<i>` for italics.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The message body will be sanitized for security reasons, so some particular
    HTML elements may not make it to the final message.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Adding followers
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also useful from a business logic viewpoint is the ability to automatically
    add followers to a document so that they can then get the corresponding notifications.
    There are a few methods available to add followers, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '`message_subscribe(partner_ids=<list of int IDs>)` adds partners'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_subscribe(channel_ids=<list of int IDs>)` adds channels'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_subscribe_users(user_ids=<list of int IDs>)` adds users'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default subtypes will be applied to each subscriber. To force a user to
    subscribe to a specific list of subtypes, you can add the `subtype_ids=<list of
    int IDs>` attribute, which lists the specific subtypes to enable for the subscription.
    If this is used, it will also reset the existing follower-subscribed subtypes
    to the specified ones.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Creating a wizard
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wizards** are user interface patterns that provide rich interaction for the
    user, usually to provide input for an automated process.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the `checkout` module will provide a wizard for library users
    to mass email borrowers. For example, they could select the oldest checkouts with
    borrowed books and send them all a message, requesting for the books to be returned.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Users start by going to the checkouts list view, selecting the checkout records
    to use, and then selecting a **Send Messages** option from the **Action** context
    menu. This will open the wizard form, allowing them to write the message subject
    and body. Clicking the **Send** button will send an email to each person that
    borrowed the selected checkouts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The wizard model
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A wizard displays a form view to the user, usually as a dialog window, with
    some fields to be filled in and buttons to trigger some business logic. These
    will then be used for the wizard's logic.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: This is implemented using the same model/view architecture that's used for regular
    views, but the supporting model is based on `models.TransientModel` instead of
    `models.Model`. This type of model has a database representation too, which is
    used to store the wizard's state. The wizard data is temporary, to allow the wizard
    to complete its work. A scheduled job regularly cleans up the old data from the
    wizard database tables.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'The `library_checkout/wizard/library_checkout_massmessage.py` file will create
    the model data structure that''s needed for the user interaction: the list of
    checkout records to be notified, the message subject, and the message body.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add the wizard to the `library_checkout` module:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit the `library_checkout/__init__.py` file to import the code into
    the `wizard/` subdirectory, as follows:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the `wizard/__init__.py` file with the following line of code:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, create the actual `wizard/checkout_mass_message.py` file, as follows:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With that, we have prepared the basic data structures that are needed for the
    wizard.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Note that regular models shouldn't have relationship fields that use transient
    models.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of this is that transient models shouldn't have one-to-many
    relationships with regular models. The reason for this is that the one-to-many
    relationship on the transient model would require the regular model to have the
    inverse many-to-one relationship with the transient model, which would cause issues
    with automatically cleaning up transient records.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to this is to use a many-to-many relationship. Many-to-many
    relationships are stored in a dedicated table, and the rows in this table are
    automatically deleted when either side of the relationship is deleted.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The wizard's access security
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like regular models, transient models also need access security rules to
    be defined on them. This is done in the same way as it is for regular modules
    – usually, in the `security/ir.model.access.csv` file.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Up until Odoo 12, transient models did not need access security rules. This
    changed in Odoo 13, so now, transient models require access rules, just like regular
    models do.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'To add ACLs for the wizard''s model, edit the `security/ir.model.access.csv`
    file and add the following highlighted line:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding one line is enough to add full access to the Library User group; no specific
    access rights are needed for the Library Manager group.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: The wizard form
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The wizard form views are defined in the same way as they are for regular models,
    except for two specific elements:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: A `<footer>` section can be used to replace the action buttons.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `special="cancel"` button is available to interrupt the wizard without performing
    any action.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the content of the `wizard/checkout_mass_message_wizard_view.xml`
    file:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The previous XML code adds two data records – one for the wizard form view and
    another for the action to open the wizard.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The `ir.actions.act_window` window action record is made available in the `binding_model_id`
    field value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to add this file to the manifest file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The wizard form will look as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Send Messages wizard form'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16119.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The Send Messages wizard form
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: To open the wizard, the user should select one or more records on the checkout
    list view and choose the **Send Messages** option via the **Action** menu, which
    is available at the top of the list view.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The wizard business logic
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, the action opens the wizard form, but it is not capable of performing
    any operations on the records yet. To start with, we would like the wizard to
    present the list of records that were selected in the checkout list view.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: When the wizard form is opened, it displays an empty form. It is not a record
    yet; this will only happen when you click on a button that's calling a method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: When the wizard form is opened, we have an empty record. The `create()` method
    hasn't been invoked yet; this will only happen when we press a button. So, it
    can't be used to set the initial values to be presented in a wizard form.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'It is still possible to populate data on the empty form by setting default
    values on the fields. `default_get()` is an ORM API method that''s in charge of
    computing the default values for a record. It can be extended to add custom logic,
    like so:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding method function can be used to add the default value for the `checkout_ids`
    field. But we still need to know how to access the list of records that will be
    selected in the origin list view.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re navigating from a client window to the next, the web client stores
    some data about the origin view in the environment''s `context`. This data is
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '`Active_model`, which is the technical name of the model'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Active_id`, which is the ID of the form active record or the tree view''s
    first record, if you''re navigating from a list'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_ids`, which is a list that contains the selected records or just one
    element if you''re navigating from a form'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_domain`, if the action is triggered from a form view'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, `active_ids` can be used to get the record IDs that have been
    selected in the list view and set the default value on the `checkout_ids` field.
    This is what the `default_get` method looks like:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, `super()` is used to call the framework's `default_get()` implementation,
    which returns a dictionary containing default values. Then, the `checkout_id`
    key is added to `defaults_dict`, with the `active_ids` value read from the environment's
    context.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: With this, when the wizard form is opened, the `checkout_ids` field will be
    automatically populated with the records that have been selected. Next, the logic
    for the form's **Send Messages** button needs to be implemented.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon inspecting the form XML code, we can see that `button_send` is the name
    of the function that''s called by the button. It should be defined in the `wizard/checkout_mass_message.py`
    file, as shown in the following code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method is designed to work with a single record and would not work correctly
    if `self` was a recordset instead of a singleton. To make this explicit, `self.ensure_one()`
    is being used.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Here, `self` represents the wizard record data, which was created when the button
    was pressed. It contains the data that was entered on the wizard form. Validation
    is performed to ensure a message body text is provided by the user.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The `checkout_id` field is accessed, and a loop iterates through each of its
    records. For each checkout record, a message is posted using the `mail.thread`
    API. The `mail.mt_comment` subtype must be used for a notification email to be
    sent to the record followers. The message's `body` and `subject` are taken from
    the `self` record fields.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice for methods to always return something – the `True` value
    at the very least. The sole reason for this is that some XML-RPC clients don't
    support `None` values. When a Python function has no explicit `return`, it implicitly
    returns the `None` value. In practice, you may not be aware of the issue because
    the web client uses JSON-RPC, not XML-RPC, but it is still a good practice to
    follow.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Wizards are the most complex tools in our business logic toolbox and close out
    the list of techniques that will be presented in this chapter.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Business logic also involves testing if the right conditions are being met before
    or after running some operation. The next section explains how to trigger exceptions
    when this doesn't happen.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times where the inputs are inappropriate for the task to perform,
    and the code needs to warn the user about it and interrupt the program's execution
    with an error message. This is done by raising an exception. Odoo provides exception
    classes that should be used in these situations.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful Odoo exceptions are as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `ValidationError` exception should be used for validations in Python code,
    such as the ones in `@api.constrains` decorated methods.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: The `UserError` exception should be used in all other cases where some action
    should not be allowed because it goes against business logic.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, all data manipulation that's done during method execution
    is done in a database transaction and rolled back when an exception occurs. This
    means that, when an exception is raised, all of the previous data changes are
    canceled.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of using the wizard's `button_send` method. If we think
    about it, it doesn't make any sense to run the send message's logic if no checkout
    document was selected. And it doesn't make sense to send messages with no message
    body. Let's warn the user if any of these things happen.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, edit the `button_send()` method and add the following highlighted
    code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When you're using exceptions, make sure that the `from odoo import exceptions`
    instruction is added to the top of the code file. Adding validations is as simple
    as checking that some conditions have been met and raising an exception if they
    haven't been.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses the development tools that every Odoo developer should
    be familiar with. We will start with automated tests.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated tests are generally accepted as a best practice in software. They
    not only help ensure code is correctly implemented, but more importantly, they
    provide a safety net for future code changes or rewrites.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: In the case of dynamic programming languages, such as Python, there is no compilation
    step and syntax errors can go unnoticed. Ensuring there's test code coverage is
    particularly important for detecting code writing mistakes, such as a mistyped
    identifier name.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: These two goals provide a guiding light to test writing. One goal should be
    test coverage – writing test cases that run all your lines of code.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: This alone will usually make good progress on the second goal, which is to verify
    the correctness of the code. This is because, after working on code coverage tests,
    we will surely have a great starting point to build additional test cases for
    non-trivial use cases.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: In earlier Odoo versions, tests could also be described using YAML data files.
    With Odoo 12, the YAML data file engine was removed, and this type of file is
    not supported anymore. The last piece of documentation on it is available at https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to add unit tests to a module and then run them.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Adding unit tests
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add-on module tests must be added to a `tests/` subdirectory. The test runner
    will automatically discover tests in the subdirectories with this particular name,
    and the module's top `__init__.py` file should *not* import them.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'To add tests for the wizard logic that was created in the `library_checkout`
    add-on module, we will start by creating the `tests/__init__.py` file and importing
    the test files to be used. In this case, it should contain the following line
    of code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we must create the `tests/test_checkout_mass_message.py` file and ensure
    it has the basic skeleton for the unit test code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Odoo provides a few classes to use for tests, as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '`TransactionCase` uses a different transaction for each test, which is automatically
    rolled back at the end.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SingleTransactionCase` runs all the tests in a single transaction, which are
    only rolled back at the end of the last test. This can speed up tests significantly,
    but the individual tests need to be written in such a way that they are compatible.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These test classes are wrappers around the `unittest` test cases, which are
    part of the Python standard library. For more details on this, you can refer to
    the official documentation at https://docs.python.org/3/library/unittest.html.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The `setUp()` method is where test data is prepared and is usually stored as
    class attributes so that it is available to the test methods.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Tests are implemented as class methods, such as the `test_01_button_send()`
    example in the previous code. The test case method names must begin with the `test_`
    prefix. This is what allows them to be discovered by the test runner. Test methods
    are run in the order of the test function names.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The `docstring` method is printed to the server log when the tests are run and
    should be used to provide a short description of the test that's being performed.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the tests have been written, it is time to run them. For that, you must
    upgrade or install the modules to test (`-I` or `-u`) and add the–`-test-enable`
    option to the Odoo `server` command.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will look like this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Only the installed or upgraded modules will be tested – that's why the `-u`
    option was used. If some dependencies need to be installed, their tests will run
    too. If you don't want this to happen, then install the new modules and then run
    the tests while upgrading (`-u`) the module to test.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the module contains testing code, this code doesn''t test anything
    yet and should run successfully. If we take a closer look at the server log, there
    should be `INFO` messages reporting the test runs, similar to this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The test code skeleton is ready. Now, the actual testing code needs to be added.
    We should start with setting up the data.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Setting up tests
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step when writing tests is to prepare the data to use. This is typically
    done in the `setUp` method. For our example, a checkout record is needed so that
    it can be used in the wizard tests.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: It is convenient to perform the test actions as a specific user to also test
    that access control has been configured properly. This can be achieved using the
    `sudo(<user>)` model method. Recordsets carry that information with them, so after
    being created using `sudo()`, later operations in the same recordset will be performed
    using that same context.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code for the `setUp` method:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we can use the `self.checkout0` record and the `self.Wizard` model for
    our tests.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's expand the `test_button_test()` method that we saw in the initial
    skeleton to implement the tests.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: A basic test runs some code on the tested object, gets a result, and then uses
    an `assert` statement to compare it with an expected result. The message posting
    logic does not return any value to check, so a different approach is needed.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'The `button_send()` method adds a message to the message history. One way to
    check if this happened is to count the number of messages before and after running
    the method. The test code can count the number of messages before and after the
    wizard. The following code adds this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The check for verifying whether the test succeeded or failed is the `self.assertEqual`
    statement. It compares the number of messages before and after running the wizard.
    It is expected to find one more message than it did previously. The last parameter
    provides an optional but recommended message that's printed when the test fails.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The `assertEqual` function is just one of the assert methods that's available.
    The appropriate assert function should be selected for the check to perform. The
    `unittest` documentation provides a good reference for all of the methods. It
    can be found at https://docs.python.org/3/library/unittest.html#test-cases.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Running the wizard is not straightforward, and the user interface workflow needs
    to be mimicked. Recall that the environment's context is used to pass data to
    the wizard, on the `active_ids` key. We must create a wizard record with the values
    that have been filled in the wizard form for the message subject and body and
    then run the `button_send` method.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code looks like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `with_context` model method is used to add `active_ids` to the environment's
    context. Then, the `create()` method is used to create the wizard record and add
    the user-entered data. Finally, the `button_send` method is called.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: More test cases are added with additional methods for the test class. Remember,
    with `TransactionCase` tests, a rollback is done at the end of each test and the
    operations that were performed in the previous test are reverted. With `SingleTransactionCase`,
    tests build each other up, and the test run sequence is important. Since tests
    are run in alphabetical order, the names that are chosen for the test methods
    are relevant. To make this clearer, it is a good practice to add a number at the
    beginning of the test method names, as we did in the preceding example.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, the code is expected to raise an exception, and that should also
    be tested. For example, we can test whether validation is being performed correctly.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the wizard tests, validation is performed to check for an empty
    message body. A test can be added to check that this validation is done properly.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: To check whether an exception has been raised, the corresponding code must be
    placed inside a `with self.assertRaises()` code block.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method should be added for this test, as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the `button_send()` method doesn't raise `UserException`, the test will fail.
    If it does raise that exception, the test will succeed. The exception that's raised
    is stored in the `e` variable, which could be inspected by additional method commands
    – for example, to verify the content of the error message.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Using log messages
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing messages to the log file is useful for monitoring and auditing running
    systems. It can also help with code maintenance, making it easier to get debug
    information from running processes, without the need to change code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'To use logging in Odoo code, first, a logger object must be prepared. For this,
    add the following code lines at the top of the `library_checkout/wizard/checkout_mass_message.py`
    file:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `logging` Python standard library module is being used here. The `_logger`
    object is initialized using the name of the current code file, `__name__`. With
    this, the log messages will include information about the file that generated
    them.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several levels available for log messages. These are as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can now use the logger to write messages to the Odoo server log.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'This log can be added to the `button_send` wizard method. Add the following
    instruction before the ending line; that is, `return True`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With this code, when the wizard is used to send messages, a message similar
    to the following will be printed to the server log:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice that Python string interpolation – that is, using the `%` operator –
    was not used in the log message. More specifically, instead of `_logger.info("Hello
    %s" % "World")`, what was used was something like `_logger.info("Hello %s", "World")`.
    Not using interpolation means one less task for the code to perform at runtime,
    which makes logging more efficient. So, the variables should always be provided
    as additional log parameters.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: The timestamps of server log messages always use UTC. This may come as a surprise
    and comes from the fact that the Odoo server internally handles all dates in UTC.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'For debug-level log messages, `_logger.debug()` is used. As an example, add
    the following debug log message right after the `checkout.message_post()` instruction:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By default, this won't print anything to the server log, since the default log
    level is `INFO`. The log level needs to be set to `DEBUG` for the debug messages
    to be printed to the log.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The Odoo `--log-level` command option sets the general log level. For example,
    adding `--log-level=debug` to the command line enables all debug log messages.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: This can be fine-tuned and have a specific log level set only for particular
    modules. To enable debug messages only for this wizard code, use the `--log-handler`
    option. This can be used several times to set the log level for several modules.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the Python module for the wizard is `odoo.addons.library_checkout.wizard.checkout_mass_message`,
    as shown in the `INFO` log messages. To set a debug log level for it, use the
    following command-line option:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The complete reference to the Odoo server logging options can be found in the
    official documentation: [https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html](https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html).'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get into the nitty-gritty details of Python logging, the official
    documentation is a good place to start: [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Logging is a useful tool, but it's short when it comes to debugging. There are
    a few tools and techniques that are available to help developers with their work.
    We'll look at these in the next section.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the available developer tools
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few tools to ease developers' work. The web interface's **Developer
    Mode**, which we introduced earlier in this book, is one of them. A server developer
    mode option is also available that provides some developer-friendly features.
    It will be explained in more detail next. After that, we will discuss how to debug
    code on the server.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Server development options
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Odoo server provides a `--dev` option, which enables developer features
    to speed up the development cycle, such as the following:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Entering the debugger when an exception is found in an add-on module. This is
    done by setting a debugger. `pdb` is the default one.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloading Python code automatically when a Python code file is saved, avoiding
    a manual server restart. This can be enabled with the `reload` option.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading view definitions directly from XML files, avoiding manual module upgrades.
    This can be enabled with the `xml` option.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python debugging interface is used directly in the web browser. This can be
    enabled with the `werkzeug` option.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--dev` option accepts a comma-separated list of options. The `all` option
    can be used to conveniently enable all of these options using `--dev=all`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re enabling a debugger, the Odoo server will use `pdb` by default,
    but other options can be used if they''ve been installed in your system. The supported
    alternatives are as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '`ipdb`; see [https://pypi.org/project/ipdb](https://pypi.org/project/ipdb)
    for details.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pudb`; see [https://pypi.org/project/pudb](https://pypi.org/project/pudb)
    for details.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wdb`; see [https://pypi.org/project/wdb](https://pypi.org/project/wdb) for
    details.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're editing Python code, the server needs to be restarted every time
    the code is changed so that the latest code is reloaded and used by Odoo. The
    `--dev=reload` option automates this reloading. When enabled, the Odoo server
    detects changes that have been made to code files and automatically triggers code
    reloading, making the code changes effective immediately.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code reload to work, the `watchdog` Python package is required. It
    can be installed with the following command:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `--dev=all` server command option also enables `reload`, and it is what
    is used most of the time:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that this is only useful for Python code changes. For other changes, such
    as changing the model's data structure, a module upgrade is needed; reloading
    it is not enough.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big part of a developer's work is debugging code. For this, it is convenient
    to be able to set breakpoints and run the code step by step.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Odoo is a server that runs Python code that waits for client requests, which
    are processed by the relevant server code, and then returns a response to the
    client. This means that Python code debugging is done on the server side. Breakpoints
    are activated in the server, pausing the server's execution on that line of code.
    So, the developer needs access to the terminal window running the server both
    to set breakpoints and to operate the debugger when those breakpoints are triggered.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: The Python debugger
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest debugging tool that's available is the Python integrated debugger,
    `pdb`. However, other options are available that provide a richer user interface,
    closer to what sophisticated IDEs usually provide.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways a debugger prompt can be triggered.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: One is when an unhandled exception is raised and the `--dev=all` option is enabled.
    The debugger will stop the code's execution at the instruction causing the exception.
    The developer can then inspect the variables and program state at that moment,
    to gain a better understanding of what is causing it.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way is to manually set a breakpoint by editing the code and adding
    the following line where the execution should pause:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This does not require the `–dev` mode to be enabled. An Odoo server reload is
    needed for the changed code to be used. When the program execution reaches the
    `pdb.set_trace()` command, a `(pdb)` Python prompt will be shown in the server's
    terminal window, waiting for input.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: The `(pdb)` prompt works as a Python shell and can run any expression or command
    in the current execution context. This means that the current variables can be
    inspected and even modified.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'A few debugger-specific commands are also available. These are the most important
    commands that are available:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '`h` (help) displays a summary of the available `pdb` commands.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` (print) evaluates and prints an expression.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pp` (pretty-print) is useful to print data structures, such as dictionaries
    or lists.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l` (list) lists the code around the instruction to be executed next.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` (next) steps over to the next instruction.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` (step) steps into the current instruction.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` (continue) continues execution normally.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u` (up) moves up in the execution stack.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` (down) moves down in the execution stack.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt` (backtrace) shows the current execution stack.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python official documentation includes a complete description of the `pdb`
    commands: [https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands).'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: A sample debugging session
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand how to use the debugger's features, let's see what a debugging
    session looks like.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a debugger breakpoint to the first line of the `button_send()`
    wizard method, as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After performing a server reload, open the `button_send()` method on the server,
    which will pause at the breakpoint. The web client will stay in a **Loading…**
    state while it is waiting for the server's response.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'At that point, the terminal window where the server is running should display
    something similar to this:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is the `pdb` debugger prompt, and the two previous lines provide information
    about where the Python code execution was paused. The first line shows the file,
    line number, and function name, while the second line is the code in that line
    that will be run next.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: During a debug session, server log messages can creep in. Most of these are
    from the `werkzeug` module. They can be silenced by adding the `--log-handler=werkzeug:WARNING`
    option to the Odoo command. Another option is to lower the general log verbosity
    using `--log-level=warn`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Typing `h` shows a quick reference of the available commands. Typing `l` shows
    the current line of code and the surrounding lines of code.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Typing `n` runs the current line of code and moves to the next one. Pressing
    *Enter* repeats the previous command.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'The `p` debug command prints out the result of an expression, while `pp` does
    the same but formats the output to be more readable, especially the `dict` and
    `list` data structures. For example, to print the value for the `checkout_ids`
    field that''s used in the wizard, type the following:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The debug prompt can run Python commands and expressions. Any Python expressions
    are allowed, even variable assignments.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: When you're done with a debugging session, type `c` to continue the normal program
    execution. In some cases, you may want to interrupt the execution, and `q` can
    be used to quit.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: When you go back from the debugger to the terminal prompt, the terminal may
    look unresponsive, and any typed text won't be printed to the terminal. This can
    be solved by using the `reset` command; that is, by typing `<enter>reset<enter>`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Python debuggers
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While `pdb` has the advantage of being available out of the box, it can be quite
    terse. Fortunately, a few more comfortable options exist.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'The IronPython debugger, `ipdb`, is a popular choice that uses the same commands
    as `pdb` but adds improvements such as tab completion and syntax highlighting
    for more comfortable usage. It can be installed with the following command:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To add a breakpoint, use the following command:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Another alternative debugger is `pudb`. It also supports the same commands as
    `pdb` and works in text terminals, but it uses a window-like graphical display.
    Useful information, such as the variables in the current context and their values,
    is readily available on the screen in separate windows.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be installed either through the system package manager or through `pip`,
    as shown here:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A breakpoint can be added in a way similar to `pdb`:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'A short version is also available:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code can be typed faster and also provides the intended effect
    – to add a code execution breakpoint.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.7, breakpoints can be simplified by using the `breakpoint()`
    function instead of `pdb.set_trace()`. Debugging libraries can overwrite the `breakpoint()`
    behavior to directly call them. However, at the time of writing, `pudb` and `ipdb`
    aren't doing this, so there is no benefit to using `breakpoint()` with them.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Printing messages and logging
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we just need to inspect the values of some variables or check whether
    some code blocks are being executed. A Python `print()` instruction can do the
    job perfectly without stopping the flow of execution. Note that the printed text
    is sent to the standard output and won't be stored in the server log if it is
    being written to a file.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` function is only being used as a development aid and should not
    make its way to the final code, ready to be deployed. If the `print` statements
    can also help investigate issues in a production system, consider converting them
    into debug-level log messages.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting and killing running processes
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also a few tricks that allow us to inspect running Odoo processes.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find the server instance''s **process ID** (**PID**). This number is
    printed with each log message, right after the timestamp. Another way to find
    the PID is to run the following command in another terminal window:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here is a sample output:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The first column in the output is the PID of the processes. In this example,
    `21688` is the Odoo process PID.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the process PID, signals can be sent to that Odoo server process.
    The `kill` command is used to send these signals. By default, `kill` sends a signal
    to terminate a process, but it can also send other, friendlier signals.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'The Odoo server will print out the stack trace at the code currently being
    executed if it''s sent a `SIGQUIT` or `-3` signal:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After sending `SIGQUIT`, the Odoo server log will display a stack trace. This
    can be useful for understanding what code was being executed at that point. This
    information is printed for each of the threads being used.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: It is used by some code profiling approaches to track where the server is spending
    time and profile the code's execution. Some useful information on code profiling
    is given in the official documentation at [https://www.odoo.com/documentation/15.0/howtos/profilecode.html](https://www.odoo.com/documentation/15.0/howtos/profilecode.html).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'Other signals we can send to the Odoo server process include `HUP`, to reload
    the server, and `INT` or `TERM` to force the server to shut down, as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The HUP signal can be particularly useful for reloading the Odoo configuration
    without stopping the server.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the various features of the ORM API and how to
    use them to create dynamic applications that react to users, which helps them
    avoid errors and automate tedious tasks.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: The model validations and computed fields can cover a lot of use cases, but
    not all. We learned how to extend the API's create, write, and unlink methods
    to cover further use cases.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: For rich user interaction, we used the `mail` core add-on mixins to add features
    for users to communicate about documents and plan activities on them. Wizards
    allow the application to dialogue with the user and gather the data that's needed
    to run particular processes. Exceptions allow the application to abort incorrect
    operations, informing the user of the problem and rolling back intermediate changes,
    keeping the system consistent.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'We also discussed the tools that are available for developers to create and
    maintain their applications: logging messages, debugging tools, and unit tests.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will still be working with the ORM, but we will be
    looking at this from the point of view of an external application: we will be
    working with the Odoo server as a backend for storing data and running business
    processes.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the most relevant reference materials for the topics that
    were discussed in this chapter:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM reference: [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message and activities features: [https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html)'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Odoo tests reference: [https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html)'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python `unittest` reference: [https://docs.python.org/3/library/unittest.html#module-unittest](https://docs.python.org/3/library/unittest.html#module-unittest)'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
