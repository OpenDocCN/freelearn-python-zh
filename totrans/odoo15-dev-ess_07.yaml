- en: '[*Chapter 8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227): Business Logic
    – Supporting Business Processes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to use models to build the application
    data structures, and then how to explore and interact with that data using the
    ORM API and recordsets.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will put all this together to implement business logic patterns
    that are common in applications. We will learn about the several ways business
    logic can be triggered, as well as some common patterns that are used to support
    them. We will also learn about important development techniques, such as logging,
    debugging, and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning project – the book checkout module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to trigger business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding ORM method decorators for recordsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring useful data model patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ORM built-in methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding onchange user interface logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message and activity features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a wizard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the available developer tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be confident in designing and implementing
    business logic automation and know how to test and debug your code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a new `library_checkout` add-on module. It depends
    on the `library_app` and `library_member` add-on modules, which we created in
    the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The code for these add-on modules can be found in this book's GitHub repository,
    at [https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition](https://github.com/PacktPublishing/Odoo-15-Development-Essentials-Fifth-Edition),
    in the `ch08` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these add-on modules need to be available in the Odoo add-ons path so
    that they can be installed and used.
  prefs: []
  type: TYPE_NORMAL
- en: Learning project – the book checkout module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The master data structures for the library application are in place. Now, we
    want to add transactions to our system. We would like library members to be able
    to borrow books. This means we should keep track of book availability and returns.
  prefs: []
  type: TYPE_NORMAL
- en: Each book checkout has a life cycle, from the moment they are created to the
    moment when the books are returned. It is a simple workflow that can be represented
    as a Kanban board, where the several stages are presented as columns, and the
    work items from the left-hand column are sent to the right until they are completed.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on the data model and business logic that are needed to
    support this feature.
  prefs: []
  type: TYPE_NORMAL
- en: The basic user interface will be discussed in [*Chapter 10*](B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287),
    *Backend Views – Designing the User Interface*, while the Kanban views will be
    discussed in [*Chapter 11*](B16119_11_Final_PD_ePub.xhtml#_idTextAnchor324), *Kanban
    Views and Client-Side QWeb*. Let's quickly have a rundown of the data model.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we must do is plan the data model that's needed for the book
    checkout feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **book checkout** model should have the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Library member** borrowing books (required)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkout date** (defaults to today)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsible person** for the checkout (defaults to the current user)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkout lines**, with the books requested (one or more)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To support the book checkout life cycle, we will also have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage** of the request—draft, open, borrowed, returned, or canceled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Due date**, when the books are due to be returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Returned date**, when the books were returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by creating the new `library_checkout` module and implementing
    an initial version of the library checkout model. This will not introduce anything
    new compared to the previous chapters but will provide the foundation to build
    the features that are relevant for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `library_checkout` module needs to be created, similar to what we did in
    the previous chapters. Follow these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `library_checkout` directory in the same directory as the other
    add-on modules of the library project. This is where the following files should
    be added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `__manifest__.py`  file and ensure it has the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the main `__init__.py` file with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `models/__init__.py` file with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the model definition file, `models/library_checkout.py`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we should add the data files, including the access rule, the menu items,
    and some basic views so that the module can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the access security configuration to the `security/ir.model.access.``csv`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the `views/library_menu.xml` file needs to be added for implementing
    the menu items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The views are implemented in the `views/checkout_view.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the module contains the preceding files, it can be installed in our
    development database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The initial Library Checkout feature'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.1_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – The initial Library Checkout feature
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start adding more interesting features.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this project, we will be adding pieces of business logic to different
    places to showcase the several possibilities that Odoo provides. The next section
    will discuss these options.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ways to trigger business logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the data model is in place, business logic is needed to perform some automatic
    actions on it. Business logic can either be directly initiated by the user, with
    an action such as a button click, or it can be triggered automatically when an
    event occurs, such as a write on a record.
  prefs: []
  type: TYPE_NORMAL
- en: Much of this business logic will involve reading and writing on recordsets.
    The details and techniques for this were discussed in [*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194),
    *Recordsets – Working with Model Data*, where we provided the tools for the actual
    business logic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is how the business logic should be triggered. This will depend
    on when and why the business logic should be triggered. Here is a summary of the
    several options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some business logic is tightly connected to the model field definitions. Some
    of the instances of **model definition-related business logic** are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@api.constrains`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@api.depends` and assigned to the `compute` field attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@api.model` and assigned to the `default` field attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This model definition logic was discussed in detail in [*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164),
    *Models – Structuring the Application Data*. Some examples can be found in the
    *Data model patterns* section. The *ORM method decorators for recordsets* section
    provides a recap of the several ORM decorators mentioned here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have **model event-related business logic**, which is related to business
    workflows. It can be attached to the following record-related events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create, write, and unlink** business logic can be added to these events,
    for the cases where the other, more elegant approaches are not possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onchange** logic can be applied to user interface views so that we have some
    field values that are changed as a consequence of changes being made to other
    fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For actions that are directly initiated by the user, the following options
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: A `button` view element for calling an object method. The button can be on a
    form or tree of the Kanban view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `server` action, which is available from a menu item or in the `Action` context
    menu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `window` action for opening a wizard form, where input can be collected from
    the user and a button will call the business logic. This allows for richer user
    interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques will be presented throughout this chapter. The supporting methods
    will often use API decorators, so it is important to understand the different
    available ones. For clarity, the next section provides an overview of them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ORM method decorators for recordsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The method definition can be preceded by an `@`, which applies a decorator to
    it. These decorators add specific behaviors for these methods and depending on
    the purpose of a method, different decorators can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators for computed fields and validation methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A few decorators are useful for validation logic and computed fields. They
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@api.depends(fld1,...)` is used for computed field functions to identify what
    changes the (re)calculation should be triggered on. It must set values on the
    computed fields; otherwise, an error will be shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@api.constrains(fld1,...)` is used for model validation functions and performs
    checks for when any of the mentioned fields are changed. It should not write changes
    in the data. If the checks fail, an exception should be raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These were discussed in detail in [*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164),
    *Models – Structuring the Application Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Another group of decorators affect the `self` recordset behavior and are relevant
    when you're implementing other kinds of business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators that affect the self recordset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, methods are expected to act on a recordset that's provided by the
    self `first` argument. The method code will usually include a `for` statement
    that loops through each of the records in the `self` recordset.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 14
  prefs: []
  type: TYPE_NORMAL
- en: The `@api.multi` decorator was removed from Odoo 14\. In previous Odoo versions,
    it was used to explicitly signal that the decorated method expects a recordset
    in the `self` parameter. This is already the default behavior for methods, so
    its use is only for clarity. The `@api.one` decorator has been deprecated since
    Odoo 9 and was also removed in Odoo 14\. It handled the record loop for you so
    that the method code would be called once for each record, and the `self` argument
    would always be a singleton. Since Odoo 14, both decorators must be removed from
    the code since they are not supported anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the method is expected to work at the class level and not on
    particular records, behaving like a `@api.model` and, in this case, the `self`
    method parameter should be used as a reference to the model; it is not expected
    to contain records.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `create()` method uses `@api.model` – it does not expect records
    as input, only a values dictionary, which will be used to create and return a
    record. The methods that are used to calculate default values should also use
    the `@api.model` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can go deeper into the business logic's implementation, we must add
    more depth to the data model and, in the process, provide examples of a couple
    of common data model patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring useful data model patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few data structures that are often needed for models that represent
    business documents. These can be seen in several Odoo apps, such as **Sales Orders**
    or **Invoices**.
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern is the header/lines data structure. It will be used for a checkout
    request so that you can have several books. Another pattern is to use states or
    stages. These two have differences, and we will discuss them and provide a reference
    implementation shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the ORM API provides a few methods that are relevant for the user interface.
    These will also be discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using header and lines models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common need for form views is to have header-line data structures. For example,
    a sales order includes several lines for the ordered items. In the case of the
    checkout feature, a checkout request can have several request lines, one for each
    of the borrowed items.
  prefs: []
  type: TYPE_NORMAL
- en: With Odoo, it is simple to implement this. Two models are needed for a header-line
    form view – one for the document header and another for the document lines. The
    line model has a many-to-one field to identify the header it belongs to, while
    the header model has a one-to-many field listing the lines in that document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `library_checkout` module was already added to the checkout model, so now,
    we want to add the lines. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models/library_checkout.py` file to add the one-to-many field for
    the checkout lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the file for the new model to `models/__init__.py`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the Python file for declaring the checkout lines model, `models/library_checkout_line.py`,
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must also add access security configuration. Edit the `security/ir.model.access.csv`
    file and add the following highlighted line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to add the checkout lines to the form. We will be adding it as
    the first page of a notebook widget. Edit the `views/checkout_view.xml` file and,
    just before the `</sheet>` element, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Checkouts form will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Checkouts form with the notebook widget'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.2_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – The Checkouts form with the notebook widget
  prefs: []
  type: TYPE_NORMAL
- en: The line's one-to-many field displays a list view that's nested in the parent
    form view. By default, Odoo will look up a list view definition to use for rendering,
    which is typical for any list view. If none are found, a default one will be automatically
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to declare specific views inside `<field>`. We did this
    in the preceding code. Inside the `line_ids` field element, there is a nested
    `<tree>` view definition that will be used for this form.
  prefs: []
  type: TYPE_NORMAL
- en: Using stages and states for document-centered workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Odoo, we can implement workflows that are centered on documents. What we
    refer to as documents can be things such as sales orders, project tasks, or HR
    applicants. All of these are expected to follow a certain life cycle since they're
    created until they conclude. Each work item is recorded in a document that will
    progress through a list of possible stages until it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: If we present these stages as columns in a board, and the documents as items
    in those columns, we get a Kanban board, providing a quick view of all the work
    in progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two approaches to implementing these progress steps – **states**
    and **stages**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`state` special field name, making it convenient to use. The closed states
    list is a disadvantage, in that it can''t easily accommodate custom process steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stage_id` field name. The list of available stages is easy to modify as you
    can remove, add, or reorder them. It has the disadvantage of not being reliable
    for process automation. Since the list of stages can be changed, automation rules
    can''t rely on particular stage IDs or descriptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we're designing the data model, we need to decide whether it should use
    stages or states. If triggering business logic is more important than the ability
    to configure the process steps, states should be preferred; otherwise, stages
    should be the preferred choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t decide, there is an approach that can provide the best of both
    worlds: we can use stages and map each stage to a corresponding state. The list
    of process steps can easily be configured by users, and since each stage will
    be linked to some reliable state code, it can also be confidently used to automate
    business logic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This combined approach will be used for the library checkout feature. To implement
    the checkout stages, we will add the `library.checkout.stage` model. The fields
    that are needed to describe a stage are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**, or title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence**, which is used to order the stage columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fold**, to be used by the Kanban view to decide what columns should be folded
    by default. We usually want to set this on inactive item columns, such as *Done*
    or *Canceled*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active**, to allow archived or no-longer-used stages, in case the process
    is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**, a closed selection list, which is used to map each stage to a fixed
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement the preceding fields, we should start adding the **Stages** model,
    including the model definition, views, menus, and access security:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `models/library_checkout_stage.py` file and ensure it contains the
    following model definition code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code shouldn't be surprising to you. Stages have a logical sequence,
    so the order in which they are presented is important. This is ensured by `_order="sequence"`.
    We can also see the `state` field mapping each stage to a basic state, which can
    be safely used by the business logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As usual, the new code file must be added to the `models/__init__.py` file,
    which should then look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access security rules are also needed. Stages contain setup data, and it should
    only be editable by the `security/ir.model.access.csv` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, a menu item is needed, to navigate to the stage''s setup. This should
    be under the `library_app` module does not provide one yet, so let''s edit it
    to add this. Edit the `library_app/views/library_menu.xml` file and add the following
    XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the `library_checkout/views/library_menu.xml` file and add the following
    XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need some stages to work with, so let''s add some default data to the module.
    Create the `data/library_checkout_stage.xml` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before this can take effect, it needs to be added to the `library_checkout/__manifest__.py`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows what the Stages list view is expected to look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The Stages list view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.3_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The Stages list view
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of all the components that are needed to add the Stages model
    to `library_checkout` and allow users to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding stage workflow support to models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, the stage field should be added to the library checkout model. For a
    proper user experience, two more things should be taken care of:'
  prefs: []
  type: TYPE_NORMAL
- en: The default stage to assign should be the first with a `new` state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When grouping by stage, all the available stages should be present, even if
    there are no checkouts in each of the stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These should be added to the `library_checkout/models/library_checkout.py` file,
    in the `Checkout` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for finding the default stage should return the record that will
    be used as the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This returns the first record in the stage model. Since the stage model is ordered
    by sequence, it will return the one with the lowest sequence number.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re grouping by stages, we would like to see all the possible stages
    rather than only the ones with checkout records. The method that''s used for this
    should return a recordset to use for the groups. In this case, it is appropriate
    to return all the active stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `stage_id` field we wish to add to the checkout model can use
    the preceding methods for the `default` and `group_expand` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`stage_id` has a many-to-one relationship with the stages model. The default
    value is calculated by the `_default_stage_id` method function, and the groupby
    on `stage_id` will use the result of the `_group_expand_stage_id` method function.'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 10
  prefs: []
  type: TYPE_NORMAL
- en: The `group_expand` field attribute was introduced in Odoo 10 and is not available
    in previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: The `group_expand` parameter overrides the way grouping works on the field.
    The default behavior for grouping operations is to only see the stages that are
    being used; the stages with no checkout document won't be shown. But in the case
    of the `stage_id` field, we want to see all the available stages, even if some
    don't have any items.
  prefs: []
  type: TYPE_NORMAL
- en: The `_group_expand_stage_id()` helper function returns the list of group records
    that the grouping operation should use. In this case, it returns all the existing
    stages, regardless of having library checkouts in that stage or not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `group_expand` attribute must be a string with a method name. This is unlike
    other attributes, such as `default`, which can be either strings or direct references
    to the method name.
  prefs: []
  type: TYPE_NORMAL
- en: The `state` field was also added. It simply makes the stage-related `state`
    field in this model available so that it can be used in views. This will use the
    special support for `state` that views have available.
  prefs: []
  type: TYPE_NORMAL
- en: Methods to support the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods are mostly used by the web client to render the user
    interface and perform basic interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name_get()` computes the `(ID, name)` tuples, along with the ID. It is the
    default computation for the `display_name` value and can be extended to implement
    custom display representations, such as displaying an identifier code along with
    the record name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name_search(name="", args=None, operator="ilike", limit=100)` performs a search
    on the display name. It is used on views when the user is typing in a relationship
    field to produce a list containing the suggested records that match the typed
    text. It returns a list of `(ID, name)` tuples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name_create(name)` creates a new record that only has a name as input. It
    is used in Kanban views with `on_create="quick_create"`, where you can quickly
    create a related record by just providing its name. It can be extended to provide
    specific defaults for the new records that are created through this feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_get([fields])` returns the default values for a new record to be created,
    as a dictionary. The default values may depend on variables, such as the current
    user or the session context. This can be extended to add additional default values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields_get()` is used to describe the model''s field definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields_view_get()` is used by the web client to retrieve the structure of
    the UI view to render. It can be given the ID of the view as an argument, or the
    type of view we want using `view_type="form"`. For example, `self.fields_view_get(view_type="tree")`
    will return the tree view XML architecture to be rendered for the `self` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These built-in ORM models can be helpful as extension points to implement model-specific
    business logic.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will discuss how business logic can be triggered by record
    operations, such as creating or writing on a record.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ORM built-in methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model definition-related methods can do many things, but some business logic
    is not possible through them, so it needs to be attached to the ORM record writing
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: ORM provides methods to perform **Create**, **Read**, **Update**, and **Delete**
    (**CRUD**) operations on our model data. Let's explore these write operations
    and how they can be extended to support custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: To read data, the main methods that are provided are `search()` and `browse()`,
    as discussed in [*Chapter 7*](B16119_07_Final_PD_ePub.xhtml#_idTextAnchor194),
    *Recordsets – Working with Model Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for writing model data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ORM provides three methods for the three basic write operations, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Model>.create(values)` creates a new record on the model. It returns the
    created record. `values` can be a dictionary or a list of dictionaries for mass-creating
    records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Recordset>.write(values)` updates the recordset with the `values` dictionary.
    It returns nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Recordset>.unlink()` deletes the records from the database. It returns nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `values` argument is a dictionary that maps field names to values to write.
    These methods are decorated with `@api.multi`, except for the `create()` method,
    which is decorated with `@api.model`.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: Being able to use `create()` to access a list of dictionaries, instead of a
    single dictionary object, was introduced in Odoo 12\. This also allows us to create
    records in batches. This capability is supported through the special `@api.model_create_multi`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, these methods need to be extended to run some specific business
    logic when they are triggered. This business logic can be run before or after
    the main method operations are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Example of extending create()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at an example that makes use of this. We want to prevent new checkout
    records from being created directly in the `Borrowed` or `Returned` states. Usually,
    validations should be implemented in specific methods that are decorated with
    `@api.constrains`. But this particular case is tied to the create record event
    and is hard to implement as a regular validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `library_checkout/models/library_checkout.py` file and add the `create()`
    extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The new record is created by the `super().create()` call. Before this, the new
    record is not available to use in the business logic – only the `values` dictionary
    can be used, or even changed, to force values on the to-be-created record.
  prefs: []
  type: TYPE_NORMAL
- en: The code after `super().create()` does have access to the new record that's
    been created and can use record features, such as accessing related records using
    dot-notation chains. The preceding example uses `new_record.stage_id.state` to
    access the state that corresponds to the new record stage. States are not user-configurable
    and provide a reliable list of values to use in business logic. So, we can look
    for `open` or `done` states and raise an error if any of them are found.
  prefs: []
  type: TYPE_NORMAL
- en: Example of extending write()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at another example. The `Checkout` model should keep track of the
    date when the books were borrowed, `Checkout Date`, and the date when they were
    returned, `Close Date`. This can''t be done using computed fields. Instead, the
    `write()` method should be extended to detect changes on the checkout state and
    then update the dates that have been filed at the right moment: when changing
    into the `open` or `close` states.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement this logic, the two date fields must be created. Edit the
    `library_checkout/models/library_checkout.py` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When a record is modified, the `checkout_date` and `close_date` fields should
    be set when the checkout record enters the appropriated states. For this, we will
    use a custom `write()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the extension code was added before the `super()`
    call; so, *before* the write operation is done on the `self` record. To know what
    change is about to be made to the record, we can inspect the `vals` parameter.
    The `stage_id` value in the `vals` dictionary is an ID number, not a record, so
    it needs to be browsed to get the corresponding record, and then read the corresponding
    `state`.
  prefs: []
  type: TYPE_NORMAL
- en: The old and new states are compared to trigger the date value update at the
    appropriate moment. Whenever possible, we prefer to change the values to write
    before the `super().write()` instruction and modify the `vals` dictionary instead
    of setting the field value directly. We'll see why in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Example of extending write() that sets values on fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code only modifies the values to use for the write; it does not
    assign values directly to the model fields. This is safe to do, but it may not
    be enough in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning a model field value inside a `write()` method leads to an infinite
    recursion loop: the assignment triggers the write method again, which then repeats
    the assignment, triggering yet another write call. This will repeat until Python
    returns a recursion error.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a technique to avoid this recursion loop, making it possible for `write()`
    methods to set values on its record fields. The trick is to set a unique marker
    in the environment's `context` before setting the values, and only run the setting
    values code when that marker is not present.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example will help make this clear. Let''s rewrite the previous example so
    that the updates are done after calling `super()`, rather than before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this technique, the extension code is guarded by an `if` statement and
    only runs if a specific marker is not found in the context. Furthermore, the additional
    `self.write()` operations use the `with_context` method to set that marker before
    doing the write. This combination ensures that the custom login inside the `if`
    statement runs only once and is not triggered on further `write()` calls, avoiding
    the infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: When (not) to extend the create() and write() methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extending the `create()` or `write()` methods should be carefully considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, some validation must be performed, or some value must be automatically
    computed when the record is saved. For these common cases, there are better options,
    as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: For field values that are automatically calculated based on other fields, use
    computed fields. For example, you should calculate a header total when the values
    of the lines are changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-fixed field default values, use a function as the default field value.
    It will be evaluated and used to assign the default value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have other field values change when some field is changed, use the `onchange`
    methods, if this is expected to be done on the user interface, or use the new
    `onchange` methods, this only works on form view interaction, not on direct write
    calls, though computed writable fields work in both cases. The *Adding onchange
    user interface logic* section will provide more detail about this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For validations, use `constraint` functions. These are automatically triggered
    when the field value changes and are expected to raise errors if the validation
    conditions fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are still cases where none of these options will work and extending `create()`
    or `write()` is needed, such as when the default values to set depend on the other
    fields of the record that's being created. In this case, a default value function
    won't work because it does not have access to the other field values of the new
    record.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for data import and export
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data import and export, as discussed in [*Chapter 5*](B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146),
    *Importing, Exporting, and Module Data*, is also available from the ORM API, through
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load([fields], [data])` is used to import data and is used by Odoo when importing
    CSV or spreadsheet data into Odoo. The first argument is the list of fields to
    import, and it maps directly to a CSV top row. The second argument is a list of
    records, where each record is a list of string values to parse and import. It
    maps directly to the CSV data rows and columns and implements the features of
    CSV data import, such as external identifiers support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export_data([fields])` is used by the web client''s `Export` function. It
    returns a dictionary with a `datas` key containing the data; that is, a list of
    rows. The field names can use the `.id` and `/id` suffixes that are used in CSV
    files, and the data is in a format that''s compatible with an importable CSV file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to implement automation on the user interface, while the
    user is editing data. We'll learn about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding onchange user interface logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to make changes to the web client view while the user is editing
    it. This mechanism is known as `@api.onchange`, and they are triggered by the
    user interface view when the user edits a value on a particular field.
  prefs: []
  type: TYPE_NORMAL
- en: Since Odoo 13, the same effect can be achieved by using a particular form of
    computed fields, called **computed writable fields**. This ORM improvement aims
    to avoid some limitations of the classic onchange mechanism, and in the long run,
    it should replace it completely.
  prefs: []
  type: TYPE_NORMAL
- en: Classic onchange methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Onchange methods can change other field values in the form, perform a validation,
    show a message to the user, or set a domain filter in relation fields, limiting
    the available options.
  prefs: []
  type: TYPE_NORMAL
- en: The onchange method is called asynchronously and returns data that's being used
    by the web client to update the fields in the current view.
  prefs: []
  type: TYPE_NORMAL
- en: Onchange methods are linked to the triggering fields, which are passed as arguments
    to the `@api.onchange("fld1", "fld2", ...)` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `api.onchange` arguments do not support dot notation; for example, `"partner_id.name"`.
    If used, it will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the method, the `self` argument is a virtual record that contains the
    current form data. It is virtual because it can be a new or changed record that
    is still being edited and hasn't been saved to the database yet. If values are
    set on this `self` record, these will be changed on the user interface form. Notice
    that it doesn't write to database records; instead, it provides information so
    that you can change the data in the UI form.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Other restrictions apply to onchange methods, as documented at [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange).Computed
    writable fields can be used as a full-featured alternative to onchanges. See the
    *The new onchange, with computed writable fields* section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: No return value is needed, but a `dict` structure may be returned with a warning
    message to display in the user interface, or a domain filter to be set on form
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work with an example. On the checkout form, when the library member is
    selected, the request date will be set to `today`. If the date changed, a warning
    message will be shown to the user, alerting them about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this, edit the `library_checkout/models/library_checkout.py` file
    and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous `onchange` method is triggered when the `member_id` field is set
    on the user interface. The actual method name is not relevant, but the convention
    is for its name to begin with the `onchange_` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Inside an `onchange` method, `self` represents a single virtual record containing
    all of the fields that have currently been set in the record being edited, and
    we can interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: The method code checks whether the current `request_date` needs to be changed.
    If it does, `request_date` is set to today so that the user will see that change
    in the form. Then, a non-blocking warning message is returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onchange` methods do not need to return anything, but they can return
    a dictionary containing a warning or a domain key, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The warning key should describe a message to show in a dialog window, such
    as `{"title": "Message Title", "message": "Message Body"}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The domain key can set or change the domain attribute of other fields. This
    allows you to build more user-friendly interfaces; having a to-many field only
    makes the options that make sense at that moment available. The value for the
    domain key looks like `{"user_id": [("email", "!=", False)]}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new onchange, with computed writable fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classic onchange mechanism has a key role in the user experience that's
    provided by the Odoo framework. However, it has a few important limitations.
  prefs: []
  type: TYPE_NORMAL
- en: One is that it works disconnected from the server-side events. Onchange is only
    played when requested by the form view and is not called as a consequence of an
    actual `write()` value change. This forces the server-side business logic to explicitly
    replay the relevant onchange methods.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation is that onchange is attached to the triggering fields and
    not to the change-affected fields. In non-trivial cases, this becomes hard to
    extend and makes it difficult to track the source of the changes.
  prefs: []
  type: TYPE_NORMAL
- en: To address these issues, the Odoo framework expanded the computed field capabilities
    so that it can also address the onchange use case. We will call this technique
    **computed writable fields**. The classic onchange is still supported and used,
    but it is expected to be replaced by computed fields and become deprecated in
    future versions.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: Computed writable fields were introduced in Odoo 13 and are available for that
    version and later ones.
  prefs: []
  type: TYPE_NORMAL
- en: Computed writable fields have compute methods assigned to them, must be stored,
    and must have the **readonly=False** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the previous onchange using this technique instead. This is
    how the `request_date` field definition should be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a regular stored and writable field, but it has attached a compute method
    that can be triggered in particular conditions. For example, the computed method
    should be triggered when the `member_id` field changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code for the compute method, `_compute_request_date_onchange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`@api.depends` works as usual for computed fields and declares the fields to
    watch for changes. The actual field list to provide is the same as the one that''s
    used by the classic `@api.onchange`.'
  prefs: []
  type: TYPE_NORMAL
- en: The method code can be very similar to the equivalent onchange method. In this
    particular case, it is identical. Note that the computed field is not ensured
    to be set a value on every method call. This only happens when some conditions
    are met. In this case, the original request date is different from today's date.
    This goes against regular computed field rules but is allowed for computed writable
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Particularly relevant to business processes is the ability to send emails or
    notify users. The next section discusses the features that Odoo provides for this.
  prefs: []
  type: TYPE_NORMAL
- en: The message and activity features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Odoo has global messaging and activity planning features available, all of which
    are provided by the `mail` technical name.
  prefs: []
  type: TYPE_NORMAL
- en: The messaging features are added by the `mail.thread` model and make a message
    widget on form views available, also known as C*hatter*. This widget allows you
    to log notes or send messages to other people. It also keeps a history of the
    messages that have been sent, and it is also used by automatic processes to log
    progress tracking messages.
  prefs: []
  type: TYPE_NORMAL
- en: The same app also provides activity management features through the `mail.activity.mixin`
    model. The activity widget can be added to the form view to allow users to schedule
    and track the history of activities.
  prefs: []
  type: TYPE_NORMAL
- en: Adding message and activity features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mail module provides the `mail.thread` abstract class, which is used to
    add the messaging features to any model, and `mail.activity.mixin`, which does
    the same for the planned activity features. In [*Chapter 4*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119),
    *Extending Modules*, we explained how to add these inherited features to models
    using the inheritance from mixin abstract classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the necessary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `mail` module dependency to the `library_checkout` add-on module by
    editing the `''depends''` key in the `library_checkout/__manifest__.py` file,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To have the `library.checkout` model inherit from the message and activity
    abstract classes, edit the `library_checkout/models/library_checkout.py` files,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add the message and activity fields to the checkout form view, edit the
    `library_checkout/` and `views/checkout_view.xml` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having done this, the checkout model will have the message and activity fields
    and their features available.
  prefs: []
  type: TYPE_NORMAL
- en: Message and activity fields and models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message and activity features add new fields to the models that inherit
    the `mail.thread` and `mail.activity.mixin` classes, along with all the supporting
    models for these features. These are the basic data structures that have been
    added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mail.thread` mixin class makes two new fields available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`message_follower_ids` has a one-to-many relationship with `mail.followers`
    and stores the message followers that should receive notifications. Followers
    can either be partners or channels. A **partner** represents a specific person
    or organization. A **channel** is not a particular person and instead represents
    a subscription list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_ids` has a one-to-many relationship with `mail.message` records and
    lists the record message history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mail.activity.mixin` mixin class adds the following new field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activity_ids` has a one-to-many relationship with `mail.activity` and stores
    activities that have been completed or planned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message subtypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages can be assigned a **subtype**. Subtypes can identify particular events,
    such as a task being created or closed, and are useful for fine-tuning what notifications
    should be sent to whom.
  prefs: []
  type: TYPE_NORMAL
- en: Subtypes are stored in the `mail.message.subtype` model and can be configured
    in the **Settings** | **Technical** | **Email** | **Subtypes** menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic message subtypes that are available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mail.mt_comment` XML ID, are used for the messages that are sent through the
    **Send message** option in the message widget. Followers will be sent a message
    notification about this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mail.mt_note` XML ID, is used by the messages that are created with the **Log
    note** XML ID, which do not send out notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mail.mt_activities` XML ID, are used for the messages that are created with
    the `Schedule activity` link. It is not intended to send a notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps can add their own subtypes, which are usually linked to relevant events.
    For example, the `Quotation sent` and `Sales Order Confirmed`. These are used
    by the app's business logic when you're logging these events in the message history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtypes allow you to determine when notifications should be sent out and to
    whom. The followers menu, at the top right of the messages widget, allows you
    to add or remove followers, as well as selecting the particular subtypes they
    will receive notifications about. The following screenshot shows the subtype selection
    form for a specific follower – *Deco Addict*, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Followers widget to select the active message subtypes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.4_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Followers widget to select the active message subtypes
  prefs: []
  type: TYPE_NORMAL
- en: The subtype subscription flags can be edited manually, and their default value
    is configured on editing the **Subtype** definition to check the **Default** field.
    When it is set, the followers on new records will receive notifications by default.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the built-in subtypes, add-on modules add their own subtypes. A subtype
    can be global or intended for a particular model. In the latter case, the subtype's
    `res_model` field identifies the model it applies to.
  prefs: []
  type: TYPE_NORMAL
- en: Posting messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Module business logic can make use of the messaging system to send notifications
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `message_post()` method is used to post a message. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds a simple text message but sends no notification to the
    followers. This is because, by default, messages are posted using `subtype="mail.mt_note"`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have the message send a notification as well, the `mail.mt_comment` subtype
    should be used, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The message body is HTML, so we can include markup for text effects, such as
    `<b>` for bold text or `<i>` for italics.
  prefs: []
  type: TYPE_NORMAL
- en: The message body will be sanitized for security reasons, so some particular
    HTML elements may not make it to the final message.
  prefs: []
  type: TYPE_NORMAL
- en: Adding followers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also useful from a business logic viewpoint is the ability to automatically
    add followers to a document so that they can then get the corresponding notifications.
    There are a few methods available to add followers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`message_subscribe(partner_ids=<list of int IDs>)` adds partners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_subscribe(channel_ids=<list of int IDs>)` adds channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_subscribe_users(user_ids=<list of int IDs>)` adds users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default subtypes will be applied to each subscriber. To force a user to
    subscribe to a specific list of subtypes, you can add the `subtype_ids=<list of
    int IDs>` attribute, which lists the specific subtypes to enable for the subscription.
    If this is used, it will also reset the existing follower-subscribed subtypes
    to the specified ones.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a wizard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Wizards** are user interface patterns that provide rich interaction for the
    user, usually to provide input for an automated process.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the `checkout` module will provide a wizard for library users
    to mass email borrowers. For example, they could select the oldest checkouts with
    borrowed books and send them all a message, requesting for the books to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Users start by going to the checkouts list view, selecting the checkout records
    to use, and then selecting a **Send Messages** option from the **Action** context
    menu. This will open the wizard form, allowing them to write the message subject
    and body. Clicking the **Send** button will send an email to each person that
    borrowed the selected checkouts.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A wizard displays a form view to the user, usually as a dialog window, with
    some fields to be filled in and buttons to trigger some business logic. These
    will then be used for the wizard's logic.
  prefs: []
  type: TYPE_NORMAL
- en: This is implemented using the same model/view architecture that's used for regular
    views, but the supporting model is based on `models.TransientModel` instead of
    `models.Model`. This type of model has a database representation too, which is
    used to store the wizard's state. The wizard data is temporary, to allow the wizard
    to complete its work. A scheduled job regularly cleans up the old data from the
    wizard database tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `library_checkout/wizard/library_checkout_massmessage.py` file will create
    the model data structure that''s needed for the user interaction: the list of
    checkout records to be notified, the message subject, and the message body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add the wizard to the `library_checkout` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, edit the `library_checkout/__init__.py` file to import the code into
    the `wizard/` subdirectory, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `wizard/__init__.py` file with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the actual `wizard/checkout_mass_message.py` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have prepared the basic data structures that are needed for the
    wizard.
  prefs: []
  type: TYPE_NORMAL
- en: Note that regular models shouldn't have relationship fields that use transient
    models.
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of this is that transient models shouldn't have one-to-many
    relationships with regular models. The reason for this is that the one-to-many
    relationship on the transient model would require the regular model to have the
    inverse many-to-one relationship with the transient model, which would cause issues
    with automatically cleaning up transient records.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative to this is to use a many-to-many relationship. Many-to-many
    relationships are stored in a dedicated table, and the rows in this table are
    automatically deleted when either side of the relationship is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard's access security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like regular models, transient models also need access security rules to
    be defined on them. This is done in the same way as it is for regular modules
    – usually, in the `security/ir.model.access.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: Up until Odoo 12, transient models did not need access security rules. This
    changed in Odoo 13, so now, transient models require access rules, just like regular
    models do.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add ACLs for the wizard''s model, edit the `security/ir.model.access.csv`
    file and add the following highlighted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Adding one line is enough to add full access to the Library User group; no specific
    access rights are needed for the Library Manager group.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The wizard form views are defined in the same way as they are for regular models,
    except for two specific elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A `<footer>` section can be used to replace the action buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `special="cancel"` button is available to interrupt the wizard without performing
    any action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the content of the `wizard/checkout_mass_message_wizard_view.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The previous XML code adds two data records – one for the wizard form view and
    another for the action to open the wizard.
  prefs: []
  type: TYPE_NORMAL
- en: The `ir.actions.act_window` window action record is made available in the `binding_model_id`
    field value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to add this file to the manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The wizard form will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – The Send Messages wizard form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.5_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – The Send Messages wizard form
  prefs: []
  type: TYPE_NORMAL
- en: To open the wizard, the user should select one or more records on the checkout
    list view and choose the **Send Messages** option via the **Action** menu, which
    is available at the top of the list view.
  prefs: []
  type: TYPE_NORMAL
- en: The wizard business logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, the action opens the wizard form, but it is not capable of performing
    any operations on the records yet. To start with, we would like the wizard to
    present the list of records that were selected in the checkout list view.
  prefs: []
  type: TYPE_NORMAL
- en: When the wizard form is opened, it displays an empty form. It is not a record
    yet; this will only happen when you click on a button that's calling a method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When the wizard form is opened, we have an empty record. The `create()` method
    hasn't been invoked yet; this will only happen when we press a button. So, it
    can't be used to set the initial values to be presented in a wizard form.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is still possible to populate data on the empty form by setting default
    values on the fields. `default_get()` is an ORM API method that''s in charge of
    computing the default values for a record. It can be extended to add custom logic,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method function can be used to add the default value for the `checkout_ids`
    field. But we still need to know how to access the list of records that will be
    selected in the origin list view.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re navigating from a client window to the next, the web client stores
    some data about the origin view in the environment''s `context`. This data is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Active_model`, which is the technical name of the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Active_id`, which is the ID of the form active record or the tree view''s
    first record, if you''re navigating from a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_ids`, which is a list that contains the selected records or just one
    element if you''re navigating from a form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_domain`, if the action is triggered from a form view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, `active_ids` can be used to get the record IDs that have been
    selected in the list view and set the default value on the `checkout_ids` field.
    This is what the `default_get` method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First, `super()` is used to call the framework's `default_get()` implementation,
    which returns a dictionary containing default values. Then, the `checkout_id`
    key is added to `defaults_dict`, with the `active_ids` value read from the environment's
    context.
  prefs: []
  type: TYPE_NORMAL
- en: With this, when the wizard form is opened, the `checkout_ids` field will be
    automatically populated with the records that have been selected. Next, the logic
    for the form's **Send Messages** button needs to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon inspecting the form XML code, we can see that `button_send` is the name
    of the function that''s called by the button. It should be defined in the `wizard/checkout_mass_message.py`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The method is designed to work with a single record and would not work correctly
    if `self` was a recordset instead of a singleton. To make this explicit, `self.ensure_one()`
    is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `self` represents the wizard record data, which was created when the button
    was pressed. It contains the data that was entered on the wizard form. Validation
    is performed to ensure a message body text is provided by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `checkout_id` field is accessed, and a loop iterates through each of its
    records. For each checkout record, a message is posted using the `mail.thread`
    API. The `mail.mt_comment` subtype must be used for a notification email to be
    sent to the record followers. The message's `body` and `subject` are taken from
    the `self` record fields.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice for methods to always return something – the `True` value
    at the very least. The sole reason for this is that some XML-RPC clients don't
    support `None` values. When a Python function has no explicit `return`, it implicitly
    returns the `None` value. In practice, you may not be aware of the issue because
    the web client uses JSON-RPC, not XML-RPC, but it is still a good practice to
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: Wizards are the most complex tools in our business logic toolbox and close out
    the list of techniques that will be presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Business logic also involves testing if the right conditions are being met before
    or after running some operation. The next section explains how to trigger exceptions
    when this doesn't happen.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times where the inputs are inappropriate for the task to perform,
    and the code needs to warn the user about it and interrupt the program's execution
    with an error message. This is done by raising an exception. Odoo provides exception
    classes that should be used in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful Odoo exceptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `ValidationError` exception should be used for validations in Python code,
    such as the ones in `@api.constrains` decorated methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `UserError` exception should be used in all other cases where some action
    should not be allowed because it goes against business logic.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, all data manipulation that's done during method execution
    is done in a database transaction and rolled back when an exception occurs. This
    means that, when an exception is raised, all of the previous data changes are
    canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of using the wizard's `button_send` method. If we think
    about it, it doesn't make any sense to run the send message's logic if no checkout
    document was selected. And it doesn't make sense to send messages with no message
    body. Let's warn the user if any of these things happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, edit the `button_send()` method and add the following highlighted
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When you're using exceptions, make sure that the `from odoo import exceptions`
    instruction is added to the top of the code file. Adding validations is as simple
    as checking that some conditions have been met and raising an exception if they
    haven't been.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses the development tools that every Odoo developer should
    be familiar with. We will start with automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated tests are generally accepted as a best practice in software. They
    not only help ensure code is correctly implemented, but more importantly, they
    provide a safety net for future code changes or rewrites.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of dynamic programming languages, such as Python, there is no compilation
    step and syntax errors can go unnoticed. Ensuring there's test code coverage is
    particularly important for detecting code writing mistakes, such as a mistyped
    identifier name.
  prefs: []
  type: TYPE_NORMAL
- en: These two goals provide a guiding light to test writing. One goal should be
    test coverage – writing test cases that run all your lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: This alone will usually make good progress on the second goal, which is to verify
    the correctness of the code. This is because, after working on code coverage tests,
    we will surely have a great starting point to build additional test cases for
    non-trivial use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: In earlier Odoo versions, tests could also be described using YAML data files.
    With Odoo 12, the YAML data file engine was removed, and this type of file is
    not supported anymore. The last piece of documentation on it is available at https://doc.odoo.com/v6.0/contribute/15_guidelines/coding_guidelines_testing/.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to add unit tests to a module and then run them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add-on module tests must be added to a `tests/` subdirectory. The test runner
    will automatically discover tests in the subdirectories with this particular name,
    and the module's top `__init__.py` file should *not* import them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add tests for the wizard logic that was created in the `library_checkout`
    add-on module, we will start by creating the `tests/__init__.py` file and importing
    the test files to be used. In this case, it should contain the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must create the `tests/test_checkout_mass_message.py` file and ensure
    it has the basic skeleton for the unit test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Odoo provides a few classes to use for tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TransactionCase` uses a different transaction for each test, which is automatically
    rolled back at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SingleTransactionCase` runs all the tests in a single transaction, which are
    only rolled back at the end of the last test. This can speed up tests significantly,
    but the individual tests need to be written in such a way that they are compatible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These test classes are wrappers around the `unittest` test cases, which are
    part of the Python standard library. For more details on this, you can refer to
    the official documentation at https://docs.python.org/3/library/unittest.html.
  prefs: []
  type: TYPE_NORMAL
- en: The `setUp()` method is where test data is prepared and is usually stored as
    class attributes so that it is available to the test methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are implemented as class methods, such as the `test_01_button_send()`
    example in the previous code. The test case method names must begin with the `test_`
    prefix. This is what allows them to be discovered by the test runner. Test methods
    are run in the order of the test function names.
  prefs: []
  type: TYPE_NORMAL
- en: The `docstring` method is printed to the server log when the tests are run and
    should be used to provide a short description of the test that's being performed.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the tests have been written, it is time to run them. For that, you must
    upgrade or install the modules to test (`-I` or `-u`) and add the–`-test-enable`
    option to the Odoo `server` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Only the installed or upgraded modules will be tested – that's why the `-u`
    option was used. If some dependencies need to be installed, their tests will run
    too. If you don't want this to happen, then install the new modules and then run
    the tests while upgrading (`-u`) the module to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the module contains testing code, this code doesn''t test anything
    yet and should run successfully. If we take a closer look at the server log, there
    should be `INFO` messages reporting the test runs, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The test code skeleton is ready. Now, the actual testing code needs to be added.
    We should start with setting up the data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step when writing tests is to prepare the data to use. This is typically
    done in the `setUp` method. For our example, a checkout record is needed so that
    it can be used in the wizard tests.
  prefs: []
  type: TYPE_NORMAL
- en: It is convenient to perform the test actions as a specific user to also test
    that access control has been configured properly. This can be achieved using the
    `sudo(<user>)` model method. Recordsets carry that information with them, so after
    being created using `sudo()`, later operations in the same recordset will be performed
    using that same context.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code for the `setUp` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the `self.checkout0` record and the `self.Wizard` model for
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's expand the `test_button_test()` method that we saw in the initial
    skeleton to implement the tests.
  prefs: []
  type: TYPE_NORMAL
- en: A basic test runs some code on the tested object, gets a result, and then uses
    an `assert` statement to compare it with an expected result. The message posting
    logic does not return any value to check, so a different approach is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `button_send()` method adds a message to the message history. One way to
    check if this happened is to count the number of messages before and after running
    the method. The test code can count the number of messages before and after the
    wizard. The following code adds this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The check for verifying whether the test succeeded or failed is the `self.assertEqual`
    statement. It compares the number of messages before and after running the wizard.
    It is expected to find one more message than it did previously. The last parameter
    provides an optional but recommended message that's printed when the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: The `assertEqual` function is just one of the assert methods that's available.
    The appropriate assert function should be selected for the check to perform. The
    `unittest` documentation provides a good reference for all of the methods. It
    can be found at https://docs.python.org/3/library/unittest.html#test-cases.
  prefs: []
  type: TYPE_NORMAL
- en: Running the wizard is not straightforward, and the user interface workflow needs
    to be mimicked. Recall that the environment's context is used to pass data to
    the wizard, on the `active_ids` key. We must create a wizard record with the values
    that have been filled in the wizard form for the message subject and body and
    then run the `button_send` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `with_context` model method is used to add `active_ids` to the environment's
    context. Then, the `create()` method is used to create the wizard record and add
    the user-entered data. Finally, the `button_send` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: More test cases are added with additional methods for the test class. Remember,
    with `TransactionCase` tests, a rollback is done at the end of each test and the
    operations that were performed in the previous test are reverted. With `SingleTransactionCase`,
    tests build each other up, and the test run sequence is important. Since tests
    are run in alphabetical order, the names that are chosen for the test methods
    are relevant. To make this clearer, it is a good practice to add a number at the
    beginning of the test method names, as we did in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Testing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, the code is expected to raise an exception, and that should also
    be tested. For example, we can test whether validation is being performed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with the wizard tests, validation is performed to check for an empty
    message body. A test can be added to check that this validation is done properly.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether an exception has been raised, the corresponding code must be
    placed inside a `with self.assertRaises()` code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method should be added for this test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the `button_send()` method doesn't raise `UserException`, the test will fail.
    If it does raise that exception, the test will succeed. The exception that's raised
    is stored in the `e` variable, which could be inspected by additional method commands
    – for example, to verify the content of the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Using log messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing messages to the log file is useful for monitoring and auditing running
    systems. It can also help with code maintenance, making it easier to get debug
    information from running processes, without the need to change code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use logging in Odoo code, first, a logger object must be prepared. For this,
    add the following code lines at the top of the `library_checkout/wizard/checkout_mass_message.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `logging` Python standard library module is being used here. The `_logger`
    object is initialized using the name of the current code file, `__name__`. With
    this, the log messages will include information about the file that generated
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several levels available for log messages. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the logger to write messages to the Odoo server log.
  prefs: []
  type: TYPE_NORMAL
- en: 'This log can be added to the `button_send` wizard method. Add the following
    instruction before the ending line; that is, `return True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, when the wizard is used to send messages, a message similar
    to the following will be printed to the server log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Notice that Python string interpolation – that is, using the `%` operator –
    was not used in the log message. More specifically, instead of `_logger.info("Hello
    %s" % "World")`, what was used was something like `_logger.info("Hello %s", "World")`.
    Not using interpolation means one less task for the code to perform at runtime,
    which makes logging more efficient. So, the variables should always be provided
    as additional log parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The timestamps of server log messages always use UTC. This may come as a surprise
    and comes from the fact that the Odoo server internally handles all dates in UTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'For debug-level log messages, `_logger.debug()` is used. As an example, add
    the following debug log message right after the `checkout.message_post()` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: By default, this won't print anything to the server log, since the default log
    level is `INFO`. The log level needs to be set to `DEBUG` for the debug messages
    to be printed to the log.
  prefs: []
  type: TYPE_NORMAL
- en: The Odoo `--log-level` command option sets the general log level. For example,
    adding `--log-level=debug` to the command line enables all debug log messages.
  prefs: []
  type: TYPE_NORMAL
- en: This can be fine-tuned and have a specific log level set only for particular
    modules. To enable debug messages only for this wizard code, use the `--log-handler`
    option. This can be used several times to set the log level for several modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the Python module for the wizard is `odoo.addons.library_checkout.wizard.checkout_mass_message`,
    as shown in the `INFO` log messages. To set a debug log level for it, use the
    following command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete reference to the Odoo server logging options can be found in the
    official documentation: [https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html](https://www.odoo.com/documentation/15.0/developer/misc/other/cmdline.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get into the nitty-gritty details of Python logging, the official
    documentation is a good place to start: [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Logging is a useful tool, but it's short when it comes to debugging. There are
    a few tools and techniques that are available to help developers with their work.
    We'll look at these in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the available developer tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few tools to ease developers' work. The web interface's **Developer
    Mode**, which we introduced earlier in this book, is one of them. A server developer
    mode option is also available that provides some developer-friendly features.
    It will be explained in more detail next. After that, we will discuss how to debug
    code on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Server development options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Odoo server provides a `--dev` option, which enables developer features
    to speed up the development cycle, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Entering the debugger when an exception is found in an add-on module. This is
    done by setting a debugger. `pdb` is the default one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloading Python code automatically when a Python code file is saved, avoiding
    a manual server restart. This can be enabled with the `reload` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading view definitions directly from XML files, avoiding manual module upgrades.
    This can be enabled with the `xml` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python debugging interface is used directly in the web browser. This can be
    enabled with the `werkzeug` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--dev` option accepts a comma-separated list of options. The `all` option
    can be used to conveniently enable all of these options using `--dev=all`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re enabling a debugger, the Odoo server will use `pdb` by default,
    but other options can be used if they''ve been installed in your system. The supported
    alternatives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ipdb`; see [https://pypi.org/project/ipdb](https://pypi.org/project/ipdb)
    for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pudb`; see [https://pypi.org/project/pudb](https://pypi.org/project/pudb)
    for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wdb`; see [https://pypi.org/project/wdb](https://pypi.org/project/wdb) for
    details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're editing Python code, the server needs to be restarted every time
    the code is changed so that the latest code is reloaded and used by Odoo. The
    `--dev=reload` option automates this reloading. When enabled, the Odoo server
    detects changes that have been made to code files and automatically triggers code
    reloading, making the code changes effective immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code reload to work, the `watchdog` Python package is required. It
    can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--dev=all` server command option also enables `reload`, and it is what
    is used most of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is only useful for Python code changes. For other changes, such
    as changing the model's data structure, a module upgrade is needed; reloading
    it is not enough.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big part of a developer's work is debugging code. For this, it is convenient
    to be able to set breakpoints and run the code step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo is a server that runs Python code that waits for client requests, which
    are processed by the relevant server code, and then returns a response to the
    client. This means that Python code debugging is done on the server side. Breakpoints
    are activated in the server, pausing the server's execution on that line of code.
    So, the developer needs access to the terminal window running the server both
    to set breakpoints and to operate the debugger when those breakpoints are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: The Python debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest debugging tool that's available is the Python integrated debugger,
    `pdb`. However, other options are available that provide a richer user interface,
    closer to what sophisticated IDEs usually provide.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways a debugger prompt can be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: One is when an unhandled exception is raised and the `--dev=all` option is enabled.
    The debugger will stop the code's execution at the instruction causing the exception.
    The developer can then inspect the variables and program state at that moment,
    to gain a better understanding of what is causing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way is to manually set a breakpoint by editing the code and adding
    the following line where the execution should pause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This does not require the `–dev` mode to be enabled. An Odoo server reload is
    needed for the changed code to be used. When the program execution reaches the
    `pdb.set_trace()` command, a `(pdb)` Python prompt will be shown in the server's
    terminal window, waiting for input.
  prefs: []
  type: TYPE_NORMAL
- en: The `(pdb)` prompt works as a Python shell and can run any expression or command
    in the current execution context. This means that the current variables can be
    inspected and even modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few debugger-specific commands are also available. These are the most important
    commands that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`h` (help) displays a summary of the available `pdb` commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` (print) evaluates and prints an expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pp` (pretty-print) is useful to print data structures, such as dictionaries
    or lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l` (list) lists the code around the instruction to be executed next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n` (next) steps over to the next instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s` (step) steps into the current instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c` (continue) continues execution normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u` (up) moves up in the execution stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d` (down) moves down in the execution stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt` (backtrace) shows the current execution stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python official documentation includes a complete description of the `pdb`
    commands: [https://docs.python.org/3/library/pdb.html#debugger-commands](https://docs.python.org/3/library/pdb.html#debugger-commands).'
  prefs: []
  type: TYPE_NORMAL
- en: A sample debugging session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand how to use the debugger's features, let's see what a debugging
    session looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a debugger breakpoint to the first line of the `button_send()`
    wizard method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: After performing a server reload, open the `button_send()` method on the server,
    which will pause at the breakpoint. The web client will stay in a **Loading…**
    state while it is waiting for the server's response.
  prefs: []
  type: TYPE_NORMAL
- en: 'At that point, the terminal window where the server is running should display
    something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is the `pdb` debugger prompt, and the two previous lines provide information
    about where the Python code execution was paused. The first line shows the file,
    line number, and function name, while the second line is the code in that line
    that will be run next.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: During a debug session, server log messages can creep in. Most of these are
    from the `werkzeug` module. They can be silenced by adding the `--log-handler=werkzeug:WARNING`
    option to the Odoo command. Another option is to lower the general log verbosity
    using `--log-level=warn`.
  prefs: []
  type: TYPE_NORMAL
- en: Typing `h` shows a quick reference of the available commands. Typing `l` shows
    the current line of code and the surrounding lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Typing `n` runs the current line of code and moves to the next one. Pressing
    *Enter* repeats the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `p` debug command prints out the result of an expression, while `pp` does
    the same but formats the output to be more readable, especially the `dict` and
    `list` data structures. For example, to print the value for the `checkout_ids`
    field that''s used in the wizard, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The debug prompt can run Python commands and expressions. Any Python expressions
    are allowed, even variable assignments.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done with a debugging session, type `c` to continue the normal program
    execution. In some cases, you may want to interrupt the execution, and `q` can
    be used to quit.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When you go back from the debugger to the terminal prompt, the terminal may
    look unresponsive, and any typed text won't be printed to the terminal. This can
    be solved by using the `reset` command; that is, by typing `<enter>reset<enter>`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Python debuggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While `pdb` has the advantage of being available out of the box, it can be quite
    terse. Fortunately, a few more comfortable options exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IronPython debugger, `ipdb`, is a popular choice that uses the same commands
    as `pdb` but adds improvements such as tab completion and syntax highlighting
    for more comfortable usage. It can be installed with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a breakpoint, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Another alternative debugger is `pudb`. It also supports the same commands as
    `pdb` and works in text terminals, but it uses a window-like graphical display.
    Useful information, such as the variables in the current context and their values,
    is readily available on the screen in separate windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be installed either through the system package manager or through `pip`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A breakpoint can be added in a way similar to `pdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A short version is also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can be typed faster and also provides the intended effect
    – to add a code execution breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.7, breakpoints can be simplified by using the `breakpoint()`
    function instead of `pdb.set_trace()`. Debugging libraries can overwrite the `breakpoint()`
    behavior to directly call them. However, at the time of writing, `pudb` and `ipdb`
    aren't doing this, so there is no benefit to using `breakpoint()` with them.
  prefs: []
  type: TYPE_NORMAL
- en: Printing messages and logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we just need to inspect the values of some variables or check whether
    some code blocks are being executed. A Python `print()` instruction can do the
    job perfectly without stopping the flow of execution. Note that the printed text
    is sent to the standard output and won't be stored in the server log if it is
    being written to a file.
  prefs: []
  type: TYPE_NORMAL
- en: The `print()` function is only being used as a development aid and should not
    make its way to the final code, ready to be deployed. If the `print` statements
    can also help investigate issues in a production system, consider converting them
    into debug-level log messages.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting and killing running processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also a few tricks that allow us to inspect running Odoo processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find the server instance''s **process ID** (**PID**). This number is
    printed with each log message, right after the timestamp. Another way to find
    the PID is to run the following command in another terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The first column in the output is the PID of the processes. In this example,
    `21688` is the Odoo process PID.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the process PID, signals can be sent to that Odoo server process.
    The `kill` command is used to send these signals. By default, `kill` sends a signal
    to terminate a process, but it can also send other, friendlier signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Odoo server will print out the stack trace at the code currently being
    executed if it''s sent a `SIGQUIT` or `-3` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: After sending `SIGQUIT`, the Odoo server log will display a stack trace. This
    can be useful for understanding what code was being executed at that point. This
    information is printed for each of the threads being used.
  prefs: []
  type: TYPE_NORMAL
- en: It is used by some code profiling approaches to track where the server is spending
    time and profile the code's execution. Some useful information on code profiling
    is given in the official documentation at [https://www.odoo.com/documentation/15.0/howtos/profilecode.html](https://www.odoo.com/documentation/15.0/howtos/profilecode.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other signals we can send to the Odoo server process include `HUP`, to reload
    the server, and `INT` or `TERM` to force the server to shut down, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The HUP signal can be particularly useful for reloading the Odoo configuration
    without stopping the server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the various features of the ORM API and how to
    use them to create dynamic applications that react to users, which helps them
    avoid errors and automate tedious tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The model validations and computed fields can cover a lot of use cases, but
    not all. We learned how to extend the API's create, write, and unlink methods
    to cover further use cases.
  prefs: []
  type: TYPE_NORMAL
- en: For rich user interaction, we used the `mail` core add-on mixins to add features
    for users to communicate about documents and plan activities on them. Wizards
    allow the application to dialogue with the user and gather the data that's needed
    to run particular processes. Exceptions allow the application to abort incorrect
    operations, informing the user of the problem and rolling back intermediate changes,
    keeping the system consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also discussed the tools that are available for developers to create and
    maintain their applications: logging messages, debugging tools, and unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will still be working with the ORM, but we will be
    looking at this from the point of view of an external application: we will be
    working with the Odoo server as a backend for storing data and running business
    processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the most relevant reference materials for the topics that
    were discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ORM reference: [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message and activities features: [https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Odoo tests reference: [https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python `unittest` reference: [https://docs.python.org/3/library/unittest.html#module-unittest](https://docs.python.org/3/library/unittest.html#module-unittest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
