- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using Go and Python for Network Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go和Python进行网络编程
- en: In this chapter, we’re going to see how Python and Go are powerful and used
    for network programming, but depending on what your requirements are and your
    environment, one might be better suited for you than the other. We are going to
    use Python and Go for network programming by checking the advantages and disadvantages
    of using each.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python和Go在网络编程中的强大功能和用途，但根据您的需求和您的环境，其中一个可能比另一个更适合您。我们将通过检查使用每种语言的优缺点来进行网络编程。
- en: By the end of this chapter, you will be able to identify which language (Python
    or Go) is more suitable for your network project and which library to use. You
    are going to learn the differences and superpowers of each language that will
    probably make the difference in your network automation work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够确定哪种语言（Python或Go）更适合您的网络项目，以及使用哪个库。您将学习每种语言的不同之处和超能力，这些可能会在您的网络自动化工作中产生差异。
- en: 'The topics we are going to cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要涵盖的主题如下：
- en: Looking into the language runtime
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看语言运行时
- en: Using third-party libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库
- en: Accessing network devices using libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库访问网络设备
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在本书的GitHub仓库中，网址为[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06)。
- en: The examples in this chapter were created and tested using a simple network
    device simulator. The instructions on how to download and run this simulator are
    included in the `Chapter06/Device-Simulator` directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例是使用一个简单的网络设备模拟器创建和测试的。如何下载和运行此模拟器的说明包含在`Chapter06/Device-Simulator`目录中。
- en: Looking into the language runtime
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看语言运行时
- en: After writing your code and saving it, you are going to run it somewhere in
    your network. Go and Python have different ways to combine your source code and
    all imported libraries before running. Which one suits you more? Are there any
    relevant differences that are important to know? We’ll discuss that in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码并保存后，您将在您的网络中的某个位置运行它。Go和Python在运行前有不同的方式来组合您的源代码和所有导入的库。哪一个更适合您？是否存在任何重要的相关差异需要了解？我们将在本节中讨论这个问题。
- en: What are compiled and interpreted languages?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是编译型和解释型语言？
- en: After writing your code, some computer languages need to be compiled to run
    on your machine, though some don’t as they are interpreted line by line as it
    runs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码后，一些计算机语言需要编译才能在您的机器上运行，尽管有些不需要，因为它们在运行时逐行解释。
- en: The languages that are compiled have to have a compiler that translates the
    source code into a series of bits and bytes that can run on the CPU architecture
    of your computer; it also has to link all static and dynamic system libraries.
    For instance, a computer with an Apple M1 processor will have a different compiler
    than an Apple with an Intel x86 processor. The result after the compilation is
    a binary program that can’t be read by humans and when it runs, it is loaded from
    disk to main memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言必须有一个编译器，将源代码转换成一系列可以在您计算机的CPU架构上运行的比特和字节；它还必须链接所有静态和动态系统库。例如，配备苹果M1处理器的计算机将使用与配备英特尔x86处理器的苹果不同的编译器。编译后的结果是二进制程序，人类无法阅读，当它运行时，它将从磁盘加载到主内存中。
- en: Once you have compiled, you don’t need to have your source code to run your
    program. The machine that runs your code does not need the compiler or the source
    code, only the compiled program binaries, which adds free space, code privacy,
    and code security.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，您不需要源代码来运行程序。运行代码的机器不需要编译器或源代码，只需要编译后的程序二进制文件，这增加了自由空间、代码隐私和代码安全性。
- en: On the other hand, interpreted languages (as it stands) are interpreted by a
    code interpreter, which interprets your code line by line when it is running.
    These interpreted languages are also known as **scripting languages**. The machine
    that runs the interpreted language needs to have the interpreter and the source
    code, which unfortunately exposes the source code and needs additional space to
    store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，解释语言（目前）由代码解释器解释，解释器在运行时逐行解释你的代码。这些解释语言也被称为 **脚本语言**。运行解释语言所需的机器需要拥有解释器和源代码，不幸的是，这暴露了源代码并需要额外的空间来存储。
- en: Examples of compiled languages include Go, C, C++, Haskel, and Rust. Examples
    of interpreted languages include Python, PHP, Unix Shell, JavaScript, and Ruby.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言的例子包括 Go、C、C++、Haskell 和 Rust。解释语言的例子包括 Python、PHP、Unix Shell、JavaScript
    和 Ruby。
- en: Java is a special case because it has a compiler but compiles to its own **Java
    Virtual Machine** (**JVM**) architecture, which is not the CPU architecture where
    the program will run. Once compiled, you can use it anywhere but will need to
    install a JVM for the specific CPU architecture, adding extra storage and runtime
    complexity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一个特殊情况，因为它有一个编译器，但它编译成自己的 **Java 虚拟机** (**JVM**) 架构，这不是程序将运行的 CPU 架构。一旦编译，你可以在任何地方使用它，但需要为特定的
    CPU 架构安装 JVM，这会增加额外的存储和运行时复杂性。
- en: Python interpreter
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 解释器
- en: The Python interpreter is sometimes called a Python virtual machine as a reference
    to a JVM, which can run anywhere. But Python does not provide a virtual machine
    like Java – it provides an interpreter, which is quite different.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器有时被称为 Python 虚拟机，以参考 JVM，它可以在任何地方运行。但 Python 并不提供像 Java 那样的虚拟机 – 它提供的是一个解释器，这与其非常不同。
- en: In Java, this virtual machine is like a virtual CPU that provides an environment
    for the Java bytecode-compiled program to run. The JVM translates the Java-compiled
    bytecode into the bytecode of the CPU architecture where it is running. So, Java
    code will need to be compiled first; then, the compiled program can run on any
    machine that has a JVM installed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，这个虚拟机就像一个虚拟 CPU，为 Java 字节码编译程序提供运行环境。JVM 将 Java 编译的字节码转换为运行所在 CPU 架构的字节码。因此，Java
    代码需要首先编译；然后，编译后的程序可以在安装了 JVM 的任何机器上运行。
- en: On the contrary, the interpreter is much more complicated as it does not translate
    bytecode as it does in a JVM but interprets lines in a context with its surroundings.
    The interpreter reads the whole code and parses the syntax that must be decoded
    in the program’s context. Because of this complexity, this can be a very slow
    process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，解释器更加复杂，因为它不像 JVM 那样翻译字节码，而是在其周围的环境中逐行解释。解释器读取整个代码并解析程序上下文中必须解码的语法。正因为这种复杂性，这可以是一个非常慢的过程。
- en: Let’s investigate some of the available Python interpreters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一些可用的 Python 解释器。
- en: Using CPython
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CPython
- en: '**CPython** is one of the most common interpreter programs that is required
    to be installed in the machine where the Python code will run. CPython is written
    in C and is perhaps the first implementation of the Python interpreter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPython** 是最常用的解释器程序之一，需要在 Python 代码将运行的机器上安装。CPython 用 C 语言编写，可能是 Python
    解释器的第一个实现。'
- en: CPython is the place where new functionalities will be created before they can
    be exposed in Python. As an example, when concurrency was added to Python, it
    was first achieved by the CPython interpreter process using the operating system’s
    multitasking properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CPython 是新功能在暴露于 Python 之前被创建的地方。例如，当并发性被添加到 Python 中时，它最初是通过 CPython 解释器进程利用操作系统的多任务属性来实现的。
- en: CPython implementations can be compiled into proprietary bytecode before being
    passed to the interpreter. The reason is that it is easier to create an interpreter
    based on a stack machine instruction set, even though an interpreter doesn’t need
    to do so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CPython 实现可以在传递给解释器之前编译成专有字节码。原因是基于堆栈机器指令集创建解释器更容易，尽管解释器不需要这样做。
- en: 'The following is an example of a CPython stack machine instruction set:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 CPython 堆栈机器指令集的例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the `return_the_bigest` function is translated into the CPython
    bytecode shown, which will be used by the CPython interpreter when it’s run. Note
    that the instruction set does the same as the `return_the_bigest` function, which
    is harder for humans to read and easier for the Python interpreter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'More on disassembler Python bytecode can be found here: [https://docs.python.org/3/library/dis.html](https://docs.python.org/3/library/dis.html).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'More on CPython can be found here: [https://github.com/python/cpython](https://github.com/python/cpython).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Using Jython
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Jython** is another Python interpreter that was created originally in 1997
    by Jim Hugunin as **JPython**. In 1999, JPython was renamed to Jython, as it is
    known today.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Jython is used to compile Python code into a Java bytecode virtual machine that
    can run on any hardware that has a JVM installed. Sometimes, it can run faster
    as it does not need to be interpreted like CPython.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Although the project started with high expectations, today, it only supports
    Python 2.7, and the support for Python 3.x is still under development. Therefore,
    you are only going to need Jython if you are running your code on a machine that
    only supports JVMs. There will also be lots of limitations as it only supports
    Python version 2.7, which is no longer supported by the Python community and was
    deprecated in January 2020.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'More on Jython can be found here: [https://github.com/jython/jython](https://github.com/jython/jython).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Using PyPy
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PyPy** is another Python interpreter implementation that claims to run Python
    code faster than CPython. PyPy also claims to handle concurrency better than CPython
    with the usage of micro-threads. And finally, it claims to use less memory than
    CPython.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Despite the great advantages of PyPy, CPython is still the most used Python
    interpreter, mainly because people don’t know about PyPy and the default Python
    installation uses CPython.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'PyPy has a website dedicated to comparing its speed with other interpreters,
    such as CPython. The website also has comparisons with other versions of PyPy.
    *Figure 6.1* shows a comparison between CPython and PyPy with information taken
    from the PyPy speed website. On average, PyPy is 4 times faster than CPython:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org](img/B18165_06_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure contains blue bars, which represent how a specific benchmark
    runs in PyPy 3.9 in comparison to CPython 3.7.6\. As an example, the `bm_dulwich_log`
    benchmark runs twice as fast compared to CPython (0.5). The sixth blue bar shows
    that PyPy runs slower for the `bm_mdp` benchmark (1.3), but for the second blue
    bar, which represents the `chaos` benchmark, PyPy runs up to 20 times faster.
    Details about each benchmark can be obtained at [https://speed.pypy.org/](https://speed.pypy.org/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: For more on PyPy, check its home page at [https://www.pypy.org/](https://www.pypy.org/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Using Cython
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although some people compare PyPy with **Cython**, Cython is not a Python interpreter
    like PyPy. Cython is a compiler that can be used with the Python and Cython languages,
    which is based on **Pyrex**, a superset of the Python language. Cython can add
    C and C++ extensions easily to your code. As it is implemented in C, the Cython
    code claims to be faster than Python when using PyPy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you are looking to write Python code and require high performance,
    try Cython. More on Cython can be found at [https://cython.org/](https://cython.org/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Using IPython and Jupyter
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The major advantage of an interpreted language is that it can run interactively
    easier. Python has an interpreter for this called **IPython**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: IPython can be used to run your code gradually line by line and then check what
    happens in memory. This is useful when testing or trying a new code or function.
    It is also quite handy to get results as the program runs and adapts the code
    to suit your desired output during code development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In conjunction with IPython, you can use a **Jupyter** notebook, which is a
    web interface that’s easy to use and has graphical output capabilities.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine you need to gather information from 100 network nodes
    on CPU usage on the network and make a graphical report for the last hour. How
    could you do that quickly without worrying about building or testing? The best
    platform you can use is Jupyter notebook with IPython.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: IPython and Jupyter are also frequently used for data science and machine learning,
    because of their advantages in terms of interactive methods and graphical interfaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: For our network programming, IPython is a powerful tool to create **Proof of
    Concept** (**PoC**) coding and test new functionalities when creating solutions
    in Python.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: More on IPython can be found at [https://ipython.org/](https://ipython.org/).
    More on Jupyter can be found at [https://jupyter.org/](https://jupyter.org/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have looked at the major Python interpreters. Now, let’s look
    at how Go works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Go compiler
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go language development, there is no code interpretation like in Python code;
    instead, there’s compilation. This compilation is done by the Go compiler, which
    normally comes with the Go language package. The compiler reads the source code
    and then translates it into the bytecode of the CPU architecture where this program
    is going to be executed. When executing the compiled code, there is no need to
    have the compiler or the source code, only the compiled binary code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this compilation, Go programs run faster than Python-based programs
    – in some cases, they can run 30 to 100 times faster, especially when dealing
    with concurrency. As an example, the `fannkuch-redux` benchmark, which is used
    to test multicore parallelism, takes 8 seconds to run in Go, whereas it takes
    5 minutes to run in Python (source: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html)).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Although the Go language distribution provides the compiler, the Go community
    has started other projects as alternatives for the Go compiler. One of them is
    called **TinyGo**, which is used when the compiled code does not have much memory
    to be stored, such as in small microcontrollers or small computers. Therefore,
    TinyGo is used when memory space in the running target computer is limited. More
    on TinyGo can be found at [https://github.com/tinygo-org/tinygo](https://github.com/tinygo-org/tinygo).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s compare both languages in terms of computing runtime.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of programming runtimes
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s explore the pros and cons of using Go and Python for programming while
    focusing on the code that will run on the machine during runtime.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros of using the Python runtime:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Easy to create PoC code by using interactive Python with IPython and Jupyter
    notebooks
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to create data visualization during prototyping
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a large community with different interpreters, libraries, and frameworks
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons of using the Python runtime:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Consumes more space and memory on the target running machine
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumes more CPU and is slower to complete tasks compared to Go
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is visible on the target running machine, which can be unsecure
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime parallelism implementation is weak compared to Go
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pros of using the Go runtime:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Consumes less memory and space on the target running machine
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumes less CPU and runs faster than Python
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is compiled, which is not human readable and can’t easily be decoded
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime parallelism implementation is much better than Python
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons of using the Go runtime:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: More difficult to create prototypes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smaller development community and fewer runtime libraries
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For network programming, Go has much more benefits compared to Python in terms
    of performance. However, as Python is an older language, it has a broader community
    with more network libraries and functionalities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: So, choosing which language to use will depend on the use case you are working
    on. If you want something quick and wish to write less code by reusing someone
    else’s library, then Python is probably the best fit. But if you want something
    that has more performance, is secure, uses less memory, and can be built as one
    binary program, Go is your best fit. As the Go community grows, it will probably
    have more libraries that can help with network automation over time, but as it
    stands today, Python has more community contributions in the network automation
    field.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择使用哪种语言将取决于你正在处理的使用案例。如果你想要快速完成，并且希望通过重用他人的库来编写更少的代码，那么 Python 可能是最合适的选择。但如果你想要性能更高、更安全、占用内存更少，并且可以构建为一个二进制程序的东西，Go
    就是你的最佳选择。随着 Go 社区的成长，它可能会随着时间的推移拥有更多帮助网络自动化的库，但就目前而言，Python 在网络自动化领域有更多的社区贡献。
- en: In the next section, we’ll learn how we can add external libraries to our code
    in Go and Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在 Go 和 Python 代码中添加外部库。
- en: Using third-party libraries
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方库
- en: When developing network automation, it is always worth researching tools and
    libraries in the community to see if you can incorporate some external code that
    will add functionalities or speed up your development process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网络自动化时，总是值得研究社区中的工具和库，看看你是否可以整合一些外部代码，这将增加功能或加快你的开发过程。
- en: In preparation to explain how to use third-party libraries, it is important
    to understand how libraries in general are used in Python and Go. We’ll detail
    the library-adding process in Python and Go in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释如何使用第三方库，了解 Python 和 Go 中库的一般使用方式非常重要。在本节中，我们将详细说明 Python 和 Go 中的库添加过程。
- en: Adding Python libraries
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Python 库
- en: Before discussing how libraries are added to Python, it is important to explain
    that, in Python, a **library** is also known as a **package** or a **module**.
    These three terms are used widely throughout Python documentation, which can make
    some new Python developers confused. So, whenever you see the term “Python library”,
    it can also mean a package or a module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何将库添加到 Python 之前，重要的是要解释，在 Python 中，**库**也被称为**包**或**模块**。这三个术语在 Python
    文档中广泛使用，这可能会让一些新的 Python 开发者感到困惑。所以，无论何时看到“Python 库”这个术语，它也可以指包或模块。
- en: A library in Python can be external, internal, or built-in. These external libraries
    are also known as third-party modules, packages, or libraries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的库可以是外部的、内部的或内置的。这些外部库也被称为第三方模块、包或库。
- en: 'To use a library in Python, you just need to use the `import` statement at
    the beginning of the code. If the library is not found, it will raise an error
    exception called `ModuleNotFoundError`, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中使用库，你只需在代码开头使用 `import` 语句。如果库未找到，它将引发一个名为 `ModuleNotFoundError`
    的错误异常，如下所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, the Python interpreter threw an exception called
    `ModuleNotFoundError`, which means the package is not installed or is not in the
    search path. The search path is normally included in the `path` variable inside
    the `sys` package, as shown in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Python 解释器抛出了一个名为 `ModuleNotFoundError` 的异常，这意味着包未安装或不在搜索路径中。搜索路径通常包含在
    `sys` 包内的 `path` 变量中，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in the preceding example, the `sys.path` variable has been pre-filed
    with a list of system paths, but you can append more if needed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的示例中，`sys.path` 变量已经被预填充了一个系统路径列表，但如果你需要，可以追加更多。
- en: Now, let’s discuss how the built-in, standard, and external modules are used
    in Python.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何在 Python 中使用内置的、标准的和外部模块。
- en: Using Python built-in libraries
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 内置库
- en: The built-in modules (or libraries) are modules that can be imported, but they
    come within the Python runtime program. They are not external files to be added,
    so they don’t need to be found in the `sys.path` variable. There are also built-in
    functions, such as `print`, but built-in modules are the ones that you are going
    to explicitly import before using them, such as the popular one known as `sys`,
    or others such as `array` and `time`. These built-in modules are not external
    programs like they are in Python standard libraries, but they are included in
    the binary code of the interpreter, like in CPython.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Using Python standard libraries
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are modules that come with the Python distribution, but they are separate
    Python files that are added when you state `import` at the beginning of the Python
    code; they need to be found in the `sys.path` variable. These modules are Python
    programs and can be found in the Python library installation directory, such as
    the `socket` library, as illustrated in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `/usr/lib/pytho3.10/socket.py` location will depend on the operating
    system and version of Python. In the preceding example, Linux Ubuntu and Python
    3.10 are being used. A list of all standard libraries for Python 3.10.x can be
    found at [https://github.com/python/cpython/tree/3.10/Lib](https://github.com/python/cpython/tree/3.10/Lib).
    More information about each built-in and standard library for Python 3.x can be
    found at [https://docs.python.org/3/library/](https://docs.python.org/3/library/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party Python libraries
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External libraries or third-party libraries are modules (or packages) in Python
    that are not included with the Python distribution and need to be installed manually
    before they’re used. These modules are normally not maintained by the Python library
    team but by developers of the Python community, which are not necessarily related
    to the Python main distribution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127), before adding
    the external module to your code, have a look in the `LICENSE` file and check
    if any limitations might impact the usage of this module on your code or in your
    organization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The Python community has organized a group called `pip`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: PyPA is also responsible for maintaining [pypi.org](http://pypi.org), where
    all packages that can be included with `pip` are documented. On this site, there
    is a search engine for finding packages and also documentation for developers
    that want to contribute or share their packages. Note that the source code for
    the packages is not on the [pypi.org](http://pypi.org) site, but in repositories
    such as **GitHub**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go through an example of the process of using a third-party package
    in our code. The package that we are adding as an example is called `netmiko`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Check if the package is included on [pypi.org](http://pypi.org) as per PyPA.
    If so, we can use `pip` to add the package to our local Python environment.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes, it is: [https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Read the `LICENSE` file and check if it is allowed to be used in your organization.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This license is based on MIT, which is less restrictive, so we can use it:
    [https://github.com/ktbyers/netmiko/blob/develop/LICENSE](https://github.com/ktbyers/netmiko/blob/develop/LICENSE).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `pip` to install the package to your local Python environment, as shown
    in the following example:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Check if you can import and locate where the `netmiko` library is installed:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the `netmiko` package has been installed using the
    `pip` tool, and the library is located under my home directory, `/home/claus`.
    However, this varies, depending on the version of Python and the operating system
    used. It also varies within Linux, depending on the distribution, such as Debian,
    Ubuntu, or Red Hat.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Just keep in mind that third-party Python libraries will be installed normally
    under a directory called `site-packages`. Here are some examples of where it can
    be located for each operating system:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS: `/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Windows: `C:\Users\username\AppData\Local\Programs\Python\Python39\lib\site-packages`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Linux Ubuntu: `/usr/lib/python3.9/site-packages`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A complete list of all packages that you have installed on your system can
    be found by typing the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let’s explore how we can use libraries and third-party libraries in Go.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Adding Go libraries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast with Python, Go only has two types of libraries: the standard libraries
    and the third-party libraries. For Go, there is no concept of built-in libraries
    because it does not have an interpreter; instead, it has a compiler. The reason
    is that an interpreter can include a few libraries in its binary, which are called
    built-in libraries.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: To add a library to your Go code, you will need to use the `import` statement,
    which is the same in Python but the syntax is a bit different.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Python, in Go, a library is also known as a **package**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how to add standard libraries and then third-party libraries
    in Go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Using standard libraries in Go
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each version of Go includes a set of standard libraries that are installed with
    the Go distribution. These standard libraries are also Go programs that, when
    imported, will be combined with your code during compilation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: A list of standard libraries can be found at [https://pkg.go.dev/std](https://pkg.go.dev/std).
    The website is very useful because it includes an explanation of each library
    (or package).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The standard libraries can also be found in your local development filesystem.
    Go’s installation includes all standard libraries, such as the `fmt` and `math`
    packages. The location of these standard libraries will vary for each operating
    system but can be found by looking into the `GOROOT` environment variable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operating systems do not populate the `GOROOT` variable, so they will
    use the Go language’s default location. To find out your default location, you
    can run the `go env` command, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, `GOROOT` is located in `/usr/lib/go-1.19`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how the libraries are located, let’s use the `fmt` standard library
    to print a string to the computer terminal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, the `import` statement tells the Go compiler that
    it needs to add the `fmt` package, which in this case is a standard library package.
    In this example, the Go compiler will search for this package, starting by looking
    in the `/usr/lib/go-1.19` directory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, the `fmt` package is located at `/usr/lib/go-1.19/src/fmt`.
    The `Println` function that’s being used in this example is described in the `/usr/lib/go-1.19/src/fmt/print.go`
    file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: In Go, all programs have to belong to a package, and the package name is described
    in the first line of the code. In the `fmt` directory (`/usr/lib/go-1.19/src/fmt`),
    all the files included in the directory have a first line that contains the `package
    fmt` statement. This includes the `scan.go`, `format.go`, and `print.go` files,
    which are located in the `fmt` directory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of standard libraries in Go can be found in your local Go installation,
    normally under the `src` directory. In the preceding example, it is under `/usr/lib/go-1.19/src`.
    Some other examples include the `math` package, located at `/usr/lib/go-1.19/src/math/`,
    and the `time` package, located at `/usr/lib/go-1.19/src/time/`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example, which uses the `math` standard library:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, the `math` library uses the `Sqrt` function, which
    is described in the `/usr/lib/go-1.19/src/math/sqrt.go` file. Again, all the files
    in the `math` directory have the `package math` statement on their first line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to add third-party libraries to Go.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party libraries in Go
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Third-party library packages in Go are added in a similar way to standard libraries
    – by using the `import` statement in your code. However, the underlying process
    of adding these packages to the Go development environment is a bit different
    in terms of a few characteristics.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In the case of third-party packages, the compiler needs to search for new files
    containing the package in a different path, which is populated in the `GOPATH`
    environment variable. Like `GOROOT`, you don’t need to populate `GOPATH` as the
    Go compiler has a default location for the `GOPATH` variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Go example, let’s check the default location for `GOPATH` by running
    the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the default location for `GOPATH` is the `go` directory inside
    my home directory (`/home/claus`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, third-party libraries can be added by invoking the `get` subcommand
    on the `go` command line, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we added the `x/crypto` package. Note that all other
    dependencies of the package are also added; in this example, the other dependency
    is `x/sys`. The `get` subcommand also stores the version of the package – in this
    case, `v0.0.0-20220622213112-05595931fe9d`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Then, the package is saved under the `GOPATH` directory. In the preceding example,
    it is saved at `/home/claus/go/pkg/mod/golang.org/x/crypto@<VERSION>`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Every time you run `go get` and there is a new version available, Go stores
    the new version and keeps the old one in a different directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to run `go get` when adding a third-party library. The `get`
    command is sometimes invoked when you run `go build` if the package has not been
    downloaded or cached, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, the Go program had an `import` statement:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After adding a third-party library, Go also updates the `go.mod` file. This
    file is required to keep track of the versions of the packages that are added
    to your Go program. The following is the content of the `go.mod` file for the
    preceding examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the `go.mod` file also stores the versions of the packages for all
    dependencies. In the preceding example, the `x/sys` package version is also stored
    in the file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with adding third-party libraries to Go and Python,
    let’s dive into the next section and look at some libraries that can be used to
    access the network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Accessing network devices using libraries
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed how to run and work with libraries in Python and Go.
    Now, let’s focus on how to use Python and Go to access network devices, which
    is one of the most important points in our network automation work.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), we discussed several methods
    to access network devices. One of the most popular ones is using a **command-line
    interface** (**CLI**). We also discussed SNMP, NETCONF, gRPC, and gNMI. In this
    section, we are going to explore a few examples of how to use libraries to access
    network devices, mainly using the CLI. Later, we are going to explain and show
    the libraries for accessing the network using other methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access the network via a CLI
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of libraries on the internet that can access network devices,
    and some of them might be obsolete or not used anymore. Here, we are going to
    present the most popular ones in chronological order, from the old to the newer
    ones.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The following examples are going to collect the uptime of the network device
    by sending the `uptime` command via the CLI on an SSH connection.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Using Python Paramiko
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Paramiko is perhaps one of the oldest implementations for accessing network
    devices via the CLI. The first release was published in 2003\. Today, it has more
    than 300 contributors and there are almost 2,000 packages depending on Paramiko
    ([https://github.com/paramiko/paramiko/network/dependents](https://github.com/paramiko/paramiko/network/dependents)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), the correct
    way to use CLI libraries is via **Secure Shell** (**SSH**). Paramiko implements
    secure cryptography for SSH using a lower-level library called PyCrypto ([http://pycrypto.org/](http://pycrypto.org/)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to obtain the uptime of the network host:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the connection is successful, the output of the preceding program will be
    the uptime of the network host:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using Python Netmiko
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Netmiko is also another popular library for accessing network devices via the
    CLI. The first release was published in 2014 and was built on top of Paramiko
    to simplify connections to network devices. In summary, Netmiko is simpler than
    Paramiko and more focused on network devices.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn what the same example for Paramiko will look like when using Netmiko:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the implementation of the Netmiko code is just 2 lines, with
    much smaller and simpler code compared to Paramiko. The big advantage of the Netmiko
    library is that it handles the device’s command prompt automatically and works
    with ease when changing the configuration in privilege mode since the prompt normally
    changes. In the preceding example, the device type was `linux_ssh` because our
    target host was a Linux device.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Netmiko can support dozens of network devices, including Cisco, Huawei, Juniper,
    and Alcatel. A complete list of devices can be found here: [https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md](https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Using Python AsyncSSH
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AsyncSSH is a modern implementation of Python **AsyncIO** for SSH. Python AsyncIO
    was introduced in Python version 3.4 and allows Python to work concurrently using
    async/await syntax and provides high performance for network access. To use AsyncSSH,
    you will need to have Python version 3.6 or higher.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In summary, AsyncSSH provides better performance for multiple hosts, but it
    is a lower-level implementation that requires more complexity in your code to
    handle network devices in comparison to Netmiko.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The same example of getting uptime for AsyncSSH can be written like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that when using AsyncSSH, you will have to work with routines and events,
    as instructed by Python AsyncIO and the preceding example. If you want to dig
    into this, some great documentation can be found at https://realpython.com/async-io-python/.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Using Python Scrapli
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In comparison to Netmiko, Scrapli is newer. The first release was published
    in 2019 and is also built on top of Paramiko but has capabilities to use AsyncSSH,
    which claims to improve performance when accessing multiple devices. The idea
    of the name Scrapli came from *scrape cli*, similar to someone scraping the screen.
    This is because Scrapli’s main objective is to interpret text from the network
    terminal using the CLI.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Scrapli was built to allow its users to interpret prompts from multi-vendor
    network devices such as Netmiko but with a reduced set of platforms. The 2022.7.30
    version supports Cisco, Juniper, and Arista. One advantage of using Scrapli is
    that it also supports NETCONF.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same example to get uptime but using Scrapli:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So far, we have learned about the most popular libraries for accessing network
    terminals using Python. Now, let’s learn we can do this with the Go language.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Using Go ssh
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to Python, Go does not have a large community for working with libraries
    that can handle network devices. Therefore, in some particular cases, you might
    have to write your own scrape mechanism to interpret the remote network terminal
    via the CLI. The problem with doing this yourself is it will be different for
    each network vendor and will take more coding time as you add different network
    devices.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of getting uptime from the remote network host:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the preceding example contains much more code than some higher-level
    libraries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Using Go vSSH
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a library in Go called vSSH, which is built on top of `golang.org/x/crypto`
    by engineers at Yahoo. It creates an abstraction for accessing remote terminals
    on network devices, which avoids the code that we saw previously with the SSH
    example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: One of the main claims of vSSH is that it can handle access to multiple targets
    with high performance, which is obtained by using Go routines (a great beginner’s
    guide for Go routines can be found at [https://go.dev/tour/concurrency/1](https://go.dev/tour/concurrency/1)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Although vSSH can handle multiple targets efficiently, let’s start by writing
    an example that uses only one target:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Go routines have been used in this example. Additional targets can be added
    using `vs.AddClient()` before calling `vs.Wait()`. In our example, only one target
    was added to get the uptime of the remote network host. The loop at the end is
    not necessary for only one target, but I left it there to demonstrate how to use
    it with multiple targets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: As we can have one host that might be faulty or slow when using multiple targets,
    a parse timeout is used, which in our example is 4 seconds. The preceding example
    uses a channel via the `rChannel` variable to obtain the results of the Go routines
    for each target.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Using Go Scrapligo
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scrapligo is a Go version of the successful Python library Scrapli. It supports
    the same network platforms and also supports NETCONF. The advantages of using
    Scrapligo over Scrapli are the ones we discussed earlier in this chapter related
    to how Go and Python runtime perform.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example in Scrapligo would look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have just discussed how to access network devices via the CLI using Python
    and Go libraries. Now, let’s learn how to use libraries to access the network
    using other methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access networks using SNMP
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Excluding the CLI, the second most popular network device access method is SNMP.
    But as we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), SNMP is
    only used to read information from network devices. The SNMP write method is not
    used for the reasons discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: For the SNMP examples, we are going to pick up one library from Python and one
    from Go. These libraries are the most popular ones for using the SNMP method today.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: In the previous subsection, we used CLI methods to collect the uptime of the
    network device. We are going to demonstrate now that we can also get the uptime
    of the remote network device by using the SNMP method. For that, we need to collect
    the `SNMPv2-MIB::sysUpTime` MIB variable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Using Python PySNMP
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PySNMP is the most popular library for Python for the SNMP method. It supports
    all versions of SNMP from version 1 to version 3\. The following is an example
    of using the SNMP method to obtain the uptime of the network device:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output will be `SNMPv2-MIB::sysUpTime.0 = 72515`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: More on PySNMP can be found at [https://pysnmp.readthedocs.io/en/latest/](https://pysnmp.readthedocs.io/en/latest/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Using gosnmp
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Go, the most popular library for the SNMP method is `gosnmp`. It also supports
    version 1 to version 3 of the SNMP protocol. Compared to PySNMP, `gosnmp` is newer
    but has more developers and more users, making it more reliable in terms of future
    development. The following is an example of collecting uptime from a network device
    using the SNMP method in Go. In this example, the OID number (`1.3.6.1.2.1.1.3.0`)
    represents the same as `SNMPv2-MIB::sysUpTime`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will be `oid: .1.3.6.1.2.1.1.3.0 : 438678`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: More on `gosnmp` can be found at [https://pkg.go.dev/github.com/gosnmp/gosnmp](https://pkg.go.dev/github.com/gosnmp/gosnmp).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access networks using NETCONF or RESTCONF
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing configuration to the network devices, the preferred method would
    be NETCONF or RESTCONF. However, some devices or some functions of the device
    might not have it implemented yet. In this case, the most appropriate method would
    be via a CLI as SNMP is not used to write data on the device.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The RESTCONF/NETCONF methods are newer methods to access network devices compared
    to a CLI or SNMP. Because of that, there are not many libraries available. Today,
    the best library to use NETCONF in Python would be Scrapli; for Go, this would
    be Scrapligo.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using Python Scrapli with NETCONF can be found at [https://scrapli.github.io/scrapli_netconf/](https://scrapli.github.io/scrapli_netconf/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using Go Scrapligo with NETCONF can be found at [https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics](https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a plain HTTP library to collect information using RESTCONF,
    as shown in the following Python example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s learn how to use Python and Go to access networks using gRPC and
    gNMI.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access networks using gRPC and gNMI
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the other methods, gRPC is quite new and network device vendors
    have added this capability in recent years. So, if you have old devices in your
    network, you might not be able to use gRPC or gNMI.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), gRPC is
    a more generic method, and gNMI is more specific for network interfaces. The main
    use of gNMI is network telemetry by invoking the underlying gRPC streaming subscription
    capability. Using gNMI allows your network code to scale easily and collect much
    more network management data compared to SNMP. The gNMI libraries are built on
    top of the gRPC protocol.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: All major network device vendors have some sort of gRPC and/or gNMI implementation
    on their newer network operating systems. Among them are Cisco, Juniper, Arista,
    Nokia, Broadcom, and others.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC in Python
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only newer versions of Python support gRPC, and the Python version has to be
    3.7 or above. To use it, you need to install `grpcio` ([https://pypi.org/project/grpcio/](https://pypi.org/project/grpcio/)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of using gRPC in Python can be obtained here: [https://grpc.io/docs/languages/python/quickstart/](https://grpc.io/docs/languages/python/quickstart/).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC in Go
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go, gRPC can run on any major version. It is well documented and several
    examples can be found at [https://github.com/grpc/grpc-go](https://github.com/grpc/grpc-go).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Using gNMI in Python
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python support for gNMI is particularly rare. There are not many libraries
    available in the Python community. The following list describes the major ones:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`Cisco-gnmi-python` was created in 2018 and was initially supported by Cisco
    Networks. The library was created by Cisco to foment the use of gNMI on Cisco
    devices, and perhaps not a good match for multi-vendor support. More details can
    be found at [https://github.com/cisco-ie/cisco-gnmi-python](https://github.com/cisco-ie/cisco-gnmi-python).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gnmi-py` was created in 2019 and is sponsored by Arista Networks. This library
    does not support multi-vendor platforms and can be only used for Arista devices.
    More details can be found at [https://github.com/arista-northwest/gnmi-py](https://github.com/arista-northwest/gnmi-py).'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyygnmi` was created in 2020\. The library can be imported using `pip` and
    has been tested on Cisco, Arista, Juniper, and Nokia devices. This would be the
    preferred choice for multi-vendor platform support. More details can be found
    at [https://github.com/akarneliuk/pygnmi](https://github.com/akarneliuk/pygnmi).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gNMI in Go
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Go, gNMI is more mature and has better support compared to gNMI implementations
    for Python. There is only one library that can use gNMI in Go, which is called
    `openconfig-gnmi`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The `openconfig-gnmi` library was created in 2016/2017 by Google and is now
    supported under the GitHub `openconfig` group. More on this library can be found
    at [https://pkg.go.dev/github.com/openconfig/gnmi](https://pkg.go.dev/github.com/openconfig/gnmi).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `openconfig-gnmi` library, there are other libraries related to
    gNMI in Go that you might find useful. Here is a list of the major ones:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`google-gnxi` is a combination of tools that can be used with gNMI and gNOI.
    Details can be found at [https://github.com/google/gnxi](https://github.com/google/gnxi).'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openconfig-gnmi-gateway` is a library that can be used for high-availability
    streaming to collect network data with multiple clients. Details can be found
    at [https://github.com/openconfig/gnmi-gateway](https://github.com/openconfig/gnmi-gateway).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openconfig-gnmic` is a CLI tool written in Go that you can use to test gNMI
    capabilities. The CLI implements all gNMI client capabilities. More details can
    be found at https://github.com/openconfig/gnmic.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have covered the major and most popular libraries used to access
    network devices via several different methods. Further discussion on this topic
    can be found in open chat communities such as Slack groups. Examples include [https://devopschat.slack.com/](https://devopschat.slack.com/)
    and https://alldaydevops.slack.com/.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deeper into Python and Go runtime behavior, investigated
    how libraries are added to both languages, and we saw a few examples of network
    libraries to use when accessing the network devices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided sufficient information to help you differentiate how Python
    and Go run and how they can be used with standard and third-party libraries. Now,
    you should be able to choose a proper language for your network automation based
    on the requirements of performance, security, maintainability, and reliability.
    You should also be able to choose a proper method and a library to access your
    network devices, either for configuration purposes or to collect network data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to touch on how to handle errors in Go and
    Python, and how we can write code to handle exceptions properly in our network
    automation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
