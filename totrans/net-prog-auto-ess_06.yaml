- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using Go and Python for Network Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go和Python进行网络编程
- en: In this chapter, we’re going to see how Python and Go are powerful and used
    for network programming, but depending on what your requirements are and your
    environment, one might be better suited for you than the other. We are going to
    use Python and Go for network programming by checking the advantages and disadvantages
    of using each.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python和Go在网络编程中的强大功能和用途，但根据您的需求和您的环境，其中一个可能比另一个更适合您。我们将通过检查使用每种语言的优缺点来进行网络编程。
- en: By the end of this chapter, you will be able to identify which language (Python
    or Go) is more suitable for your network project and which library to use. You
    are going to learn the differences and superpowers of each language that will
    probably make the difference in your network automation work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够确定哪种语言（Python或Go）更适合您的网络项目，以及使用哪个库。您将学习每种语言的不同之处和超能力，这些可能会在您的网络自动化工作中产生差异。
- en: 'The topics we are going to cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要涵盖的主题如下：
- en: Looking into the language runtime
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看语言运行时
- en: Using third-party libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方库
- en: Accessing network devices using libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用库访问网络设备
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在本书的GitHub仓库中，网址为[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06)。
- en: The examples in this chapter were created and tested using a simple network
    device simulator. The instructions on how to download and run this simulator are
    included in the `Chapter06/Device-Simulator` directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例是使用一个简单的网络设备模拟器创建和测试的。如何下载和运行此模拟器的说明包含在`Chapter06/Device-Simulator`目录中。
- en: Looking into the language runtime
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看语言运行时
- en: After writing your code and saving it, you are going to run it somewhere in
    your network. Go and Python have different ways to combine your source code and
    all imported libraries before running. Which one suits you more? Are there any
    relevant differences that are important to know? We’ll discuss that in this section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码并保存后，您将在您的网络中的某个位置运行它。Go和Python在运行前有不同的方式来组合您的源代码和所有导入的库。哪一个更适合您？是否存在任何重要的相关差异需要了解？我们将在本节中讨论这个问题。
- en: What are compiled and interpreted languages?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是编译型和解释型语言？
- en: After writing your code, some computer languages need to be compiled to run
    on your machine, though some don’t as they are interpreted line by line as it
    runs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码后，一些计算机语言需要编译才能在您的机器上运行，尽管有些不需要，因为它们在运行时逐行解释。
- en: The languages that are compiled have to have a compiler that translates the
    source code into a series of bits and bytes that can run on the CPU architecture
    of your computer; it also has to link all static and dynamic system libraries.
    For instance, a computer with an Apple M1 processor will have a different compiler
    than an Apple with an Intel x86 processor. The result after the compilation is
    a binary program that can’t be read by humans and when it runs, it is loaded from
    disk to main memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言必须有一个编译器，将源代码转换成一系列可以在您计算机的CPU架构上运行的比特和字节；它还必须链接所有静态和动态系统库。例如，配备苹果M1处理器的计算机将使用与配备英特尔x86处理器的苹果不同的编译器。编译后的结果是二进制程序，人类无法阅读，当它运行时，它将从磁盘加载到主内存中。
- en: Once you have compiled, you don’t need to have your source code to run your
    program. The machine that runs your code does not need the compiler or the source
    code, only the compiled program binaries, which adds free space, code privacy,
    and code security.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，您不需要源代码来运行程序。运行代码的机器不需要编译器或源代码，只需要编译后的程序二进制文件，这增加了自由空间、代码隐私和代码安全性。
- en: On the other hand, interpreted languages (as it stands) are interpreted by a
    code interpreter, which interprets your code line by line when it is running.
    These interpreted languages are also known as **scripting languages**. The machine
    that runs the interpreted language needs to have the interpreter and the source
    code, which unfortunately exposes the source code and needs additional space to
    store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，解释语言（目前）由代码解释器解释，解释器在运行时逐行解释你的代码。这些解释语言也被称为 **脚本语言**。运行解释语言所需的机器需要拥有解释器和源代码，不幸的是，这暴露了源代码并需要额外的空间来存储。
- en: Examples of compiled languages include Go, C, C++, Haskel, and Rust. Examples
    of interpreted languages include Python, PHP, Unix Shell, JavaScript, and Ruby.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言的例子包括 Go、C、C++、Haskell 和 Rust。解释语言的例子包括 Python、PHP、Unix Shell、JavaScript
    和 Ruby。
- en: Java is a special case because it has a compiler but compiles to its own **Java
    Virtual Machine** (**JVM**) architecture, which is not the CPU architecture where
    the program will run. Once compiled, you can use it anywhere but will need to
    install a JVM for the specific CPU architecture, adding extra storage and runtime
    complexity.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一个特殊情况，因为它有一个编译器，但它编译成自己的 **Java 虚拟机** (**JVM**) 架构，这不是程序将运行的 CPU 架构。一旦编译，你可以在任何地方使用它，但需要为特定的
    CPU 架构安装 JVM，这会增加额外的存储和运行时复杂性。
- en: Python interpreter
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 解释器
- en: The Python interpreter is sometimes called a Python virtual machine as a reference
    to a JVM, which can run anywhere. But Python does not provide a virtual machine
    like Java – it provides an interpreter, which is quite different.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器有时被称为 Python 虚拟机，以参考 JVM，它可以在任何地方运行。但 Python 并不提供像 Java 那样的虚拟机 – 它提供的是一个解释器，这与其非常不同。
- en: In Java, this virtual machine is like a virtual CPU that provides an environment
    for the Java bytecode-compiled program to run. The JVM translates the Java-compiled
    bytecode into the bytecode of the CPU architecture where it is running. So, Java
    code will need to be compiled first; then, the compiled program can run on any
    machine that has a JVM installed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，这个虚拟机就像一个虚拟 CPU，为 Java 字节码编译程序提供运行环境。JVM 将 Java 编译的字节码转换为运行所在 CPU 架构的字节码。因此，Java
    代码需要首先编译；然后，编译后的程序可以在安装了 JVM 的任何机器上运行。
- en: On the contrary, the interpreter is much more complicated as it does not translate
    bytecode as it does in a JVM but interprets lines in a context with its surroundings.
    The interpreter reads the whole code and parses the syntax that must be decoded
    in the program’s context. Because of this complexity, this can be a very slow
    process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，解释器更加复杂，因为它不像 JVM 那样翻译字节码，而是在其周围的环境中逐行解释。解释器读取整个代码并解析程序上下文中必须解码的语法。正因为这种复杂性，这可以是一个非常慢的过程。
- en: Let’s investigate some of the available Python interpreters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一些可用的 Python 解释器。
- en: Using CPython
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CPython
- en: '**CPython** is one of the most common interpreter programs that is required
    to be installed in the machine where the Python code will run. CPython is written
    in C and is perhaps the first implementation of the Python interpreter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPython** 是最常用的解释器程序之一，需要在 Python 代码将运行的机器上安装。CPython 用 C 语言编写，可能是 Python
    解释器的第一个实现。'
- en: CPython is the place where new functionalities will be created before they can
    be exposed in Python. As an example, when concurrency was added to Python, it
    was first achieved by the CPython interpreter process using the operating system’s
    multitasking properties.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CPython 是新功能在暴露于 Python 之前被创建的地方。例如，当并发性被添加到 Python 中时，它最初是通过 CPython 解释器进程利用操作系统的多任务属性来实现的。
- en: CPython implementations can be compiled into proprietary bytecode before being
    passed to the interpreter. The reason is that it is easier to create an interpreter
    based on a stack machine instruction set, even though an interpreter doesn’t need
    to do so.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CPython 实现可以在传递给解释器之前编译成专有字节码。原因是基于堆栈机器指令集创建解释器更容易，尽管解释器不需要这样做。
- en: 'The following is an example of a CPython stack machine instruction set:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 CPython 堆栈机器指令集的例子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the `return_the_bigest` function is translated into the CPython
    bytecode shown, which will be used by the CPython interpreter when it’s run. Note
    that the instruction set does the same as the `return_the_bigest` function, which
    is harder for humans to read and easier for the Python interpreter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`return_the_bigest` 函数被翻译成下面的 CPython 字节码，这将由 CPython 解释器在运行时使用。请注意，指令集执行与
    `return_the_bigest` 函数相同的功能，这对人类来说更难阅读，但对 Python 解释器来说更容易。
- en: 'More on disassembler Python bytecode can be found here: [https://docs.python.org/3/library/dis.html](https://docs.python.org/3/library/dis.html).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于反汇编 Python 字节码的信息可以在这里找到：[https://docs.python.org/3/library/dis.html](https://docs.python.org/3/library/dis.html)。
- en: 'More on CPython can be found here: [https://github.com/python/cpython](https://github.com/python/cpython).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 CPython 的信息可以在这里找到：[https://github.com/python/cpython](https://github.com/python/cpython)。
- en: Using Jython
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Jython
- en: '**Jython** is another Python interpreter that was created originally in 1997
    by Jim Hugunin as **JPython**. In 1999, JPython was renamed to Jython, as it is
    known today.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jython** 是另一种 Python 解释器，最初于 1997 年由 Jim Hugunin 创建，最初称为 **JPython**。1999
    年，JPython 被更名为 Jython，正如今天所知。'
- en: Jython is used to compile Python code into a Java bytecode virtual machine that
    can run on any hardware that has a JVM installed. Sometimes, it can run faster
    as it does not need to be interpreted like CPython.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Jython 用于将 Python 代码编译成可以在安装了 JVM 的任何硬件上运行的 Java 字节码虚拟机。有时，它运行得更快，因为它不需要像 CPython
    那样进行解释。
- en: Although the project started with high expectations, today, it only supports
    Python 2.7, and the support for Python 3.x is still under development. Therefore,
    you are only going to need Jython if you are running your code on a machine that
    only supports JVMs. There will also be lots of limitations as it only supports
    Python version 2.7, which is no longer supported by the Python community and was
    deprecated in January 2020.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该项目一开始期望很高，但如今，它只支持 Python 2.7，对 Python 3.x 的支持仍在开发中。因此，只有当您在只支持 JVM 的机器上运行代码时，您才需要
    Jython。由于它只支持 Python 2.7，而 Python 社区不再支持，且已于 2020 年 1 月弃用，因此它将存在许多限制。
- en: 'More on Jython can be found here: [https://github.com/jython/jython](https://github.com/jython/jython).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Jython 的信息可以在这里找到：[https://github.com/jython/jython](https://github.com/jython/jython)。
- en: Using PyPy
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PyPy
- en: '**PyPy** is another Python interpreter implementation that claims to run Python
    code faster than CPython. PyPy also claims to handle concurrency better than CPython
    with the usage of micro-threads. And finally, it claims to use less memory than
    CPython.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyPy** 是另一种 Python 解释器实现，声称比 CPython 运行 Python 代码更快。PyPy 还声称使用微线程可以更好地处理并发，并且最终它声称比
    CPython 使用更少的内存。'
- en: Despite the great advantages of PyPy, CPython is still the most used Python
    interpreter, mainly because people don’t know about PyPy and the default Python
    installation uses CPython.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PyPy 具有巨大的优势，但 CPython 仍然是使用最广泛的 Python 解释器，主要是因为人们不知道 PyPy，并且默认的 Python
    安装使用的是 CPython。
- en: 'PyPy has a website dedicated to comparing its speed with other interpreters,
    such as CPython. The website also has comparisons with other versions of PyPy.
    *Figure 6.1* shows a comparison between CPython and PyPy with information taken
    from the PyPy speed website. On average, PyPy is 4 times faster than CPython:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: PyPy 有一个专门用于比较其与其他解释器速度的网站，例如 CPython。该网站还提供了与其他 PyPy 版本的比较。*图 6.1* 展示了从 PyPy
    速度网站获取的信息，CPython 和 PyPy 的比较。平均而言，PyPy 比 CPython 快 4 倍：
- en: '![Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org](img/B18165_06_001.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 从 speed.pypy.org 获取的 CPython 和 PyPy 比较](img/B18165_06_001.jpg)'
- en: Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 从 speed.pypy.org 获取的 CPython 和 PyPy 比较
- en: The preceding figure contains blue bars, which represent how a specific benchmark
    runs in PyPy 3.9 in comparison to CPython 3.7.6\. As an example, the `bm_dulwich_log`
    benchmark runs twice as fast compared to CPython (0.5). The sixth blue bar shows
    that PyPy runs slower for the `bm_mdp` benchmark (1.3), but for the second blue
    bar, which represents the `chaos` benchmark, PyPy runs up to 20 times faster.
    Details about each benchmark can be obtained at [https://speed.pypy.org/](https://speed.pypy.org/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表包含蓝色条形，这些条形表示特定基准在 PyPy 3.9 中与 CPython 3.7.6 的运行情况。例如，`bm_dulwich_log`
    基准比 CPython 快一倍（0.5）。第六个蓝色条形显示 PyPy 在 `bm_mdp` 基准（1.3）上运行较慢，但对于第二个蓝色条形，它代表的是 `chaos`
    基准，PyPy 的运行速度可高达 20 倍。有关每个基准的详细信息，可以在 [https://speed.pypy.org/](https://speed.pypy.org/)
    获取。
- en: For more on PyPy, check its home page at [https://www.pypy.org/](https://www.pypy.org/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 PyPy 的信息，请访问其主页 [https://www.pypy.org/](https://www.pypy.org/)。
- en: Using Cython
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Cython
- en: Although some people compare PyPy with **Cython**, Cython is not a Python interpreter
    like PyPy. Cython is a compiler that can be used with the Python and Cython languages,
    which is based on **Pyrex**, a superset of the Python language. Cython can add
    C and C++ extensions easily to your code. As it is implemented in C, the Cython
    code claims to be faster than Python when using PyPy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些人将 PyPy 与 **Cython** 进行比较，但 Cython 并不是像 PyPy 那样的 Python 解释器。Cython 是一个可以与
    Python 和 Cython 语言一起使用的编译器，它基于 **Pyrex**，这是 Python 语言的超集。Cython 可以轻松地将 C 和 C++
    扩展添加到你的代码中。由于它是用 C 实现的，Cython 代码声称在使用 PyPy 时比 Python 快。
- en: Therefore, if you are looking to write Python code and require high performance,
    try Cython. More on Cython can be found at [https://cython.org/](https://cython.org/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你正在寻找编写高性能 Python 代码的方法，尝试使用 Cython。更多关于 Cython 的信息可以在 [https://cython.org/](https://cython.org/)
    找到。
- en: Using IPython and Jupyter
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IPython 和 Jupyter
- en: The major advantage of an interpreted language is that it can run interactively
    easier. Python has an interpreter for this called **IPython**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型语言的主要优势是它更容易进行交互式运行。Python 有一个名为 **IPython** 的解释器来实现这一点。
- en: IPython can be used to run your code gradually line by line and then check what
    happens in memory. This is useful when testing or trying a new code or function.
    It is also quite handy to get results as the program runs and adapts the code
    to suit your desired output during code development.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 可以逐行运行你的代码，并检查内存中的变化情况。这在测试或尝试新的代码或函数时非常有用。在代码开发过程中，它也便于获取运行结果并调整代码以适应你期望的输出。
- en: In conjunction with IPython, you can use a **Jupyter** notebook, which is a
    web interface that’s easy to use and has graphical output capabilities.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IPython 结合使用，你可以使用一个 **Jupyter** 笔记本，这是一个易于使用的网络界面，具有图形输出功能。
- en: As an example, imagine you need to gather information from 100 network nodes
    on CPU usage on the network and make a graphical report for the last hour. How
    could you do that quickly without worrying about building or testing? The best
    platform you can use is Jupyter notebook with IPython.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要从 100 个网络节点收集关于网络 CPU 使用情况的信息，并为过去一小时制作一个图形报告。你如何快速完成这项工作，而不用担心构建或测试呢？你可以使用的最佳平台是带有
    IPython 的 Jupyter 笔记本。
- en: IPython and Jupyter are also frequently used for data science and machine learning,
    because of their advantages in terms of interactive methods and graphical interfaces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 和 Jupyter 也常用于数据科学和机器学习，因为它们在交互方法和图形界面方面的优势。
- en: For our network programming, IPython is a powerful tool to create **Proof of
    Concept** (**PoC**) coding and test new functionalities when creating solutions
    in Python.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络编程，IPython 是一个强大的工具，用于在 Python 中创建 **概念验证**（**PoC**）代码并测试新功能。
- en: More on IPython can be found at [https://ipython.org/](https://ipython.org/).
    More on Jupyter can be found at [https://jupyter.org/](https://jupyter.org/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 IPython 的信息可以在 [https://ipython.org/](https://ipython.org/) 找到。更多关于 Jupyter
    的信息可以在 [https://jupyter.org/](https://jupyter.org/) 找到。
- en: With that, we have looked at the major Python interpreters. Now, let’s look
    at how Go works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上内容，我们已经了解了主要的 Python 解释器。现在，让我们看看 Go 是如何工作的。
- en: Go compiler
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 编译器
- en: In Go language development, there is no code interpretation like in Python code;
    instead, there’s compilation. This compilation is done by the Go compiler, which
    normally comes with the Go language package. The compiler reads the source code
    and then translates it into the bytecode of the CPU architecture where this program
    is going to be executed. When executing the compiled code, there is no need to
    have the compiler or the source code, only the compiled binary code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言开发中，没有像 Python 代码那样的代码解释；相反，是编译。这种编译由 Go 编译器完成，它通常包含在 Go 语言包中。编译器读取源代码，然后将其转换为程序将要执行的
    CPU 架构的字节码。在执行编译后的代码时，不需要编译器或源代码，只需要编译后的二进制代码。
- en: 'Because of this compilation, Go programs run faster than Python-based programs
    – in some cases, they can run 30 to 100 times faster, especially when dealing
    with concurrency. As an example, the `fannkuch-redux` benchmark, which is used
    to test multicore parallelism, takes 8 seconds to run in Go, whereas it takes
    5 minutes to run in Python (source: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html)).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种编译，Go 程序比基于 Python 的程序运行得更快——在某些情况下，它们可以快 30 到 100 倍，尤其是在处理并发时。例如，用于测试多核并行性的
    `fannkuch-redux` 基准测试在 Go 中运行需要 8 秒，而在 Python 中运行则需要 5 分钟（来源：[https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html))。
- en: Although the Go language distribution provides the compiler, the Go community
    has started other projects as alternatives for the Go compiler. One of them is
    called **TinyGo**, which is used when the compiled code does not have much memory
    to be stored, such as in small microcontrollers or small computers. Therefore,
    TinyGo is used when memory space in the running target computer is limited. More
    on TinyGo can be found at [https://github.com/tinygo-org/tinygo](https://github.com/tinygo-org/tinygo).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Go 语言发行版提供了编译器，但 Go 社区已经开始启动其他项目作为 Go 编译器的替代方案。其中之一是名为 **TinyGo** 的项目，当编译的代码没有太多内存需要存储时使用，例如在小型微控制器或小型计算机中。因此，当运行目标计算机的内存空间有限时，会使用
    TinyGo。更多关于 TinyGo 的信息可以在 [https://github.com/tinygo-org/tinygo](https://github.com/tinygo-org/tinygo)
    找到。
- en: Now, let’s compare both languages in terms of computing runtime.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从计算运行时的角度比较这两种语言。
- en: Pros and cons of programming runtimes
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程运行时的优缺点
- en: Let’s explore the pros and cons of using Go and Python for programming while
    focusing on the code that will run on the machine during runtime.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨使用 Go 和 Python 进行编程的优缺点，同时关注在运行时将在机器上运行的代码。
- en: 'Pros of using the Python runtime:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 运行时的优点：
- en: Easy to create PoC code by using interactive Python with IPython and Jupyter
    notebooks
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用交互式 Python（IPython 和 Jupyter 笔记本）易于创建 PoC 代码
- en: Easy to create data visualization during prototyping
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原型设计期间易于创建数据可视化
- en: Has a large community with different interpreters, libraries, and frameworks
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有庞大的社区，拥有不同的解释器、库和框架
- en: 'Cons of using the Python runtime:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 运行时的缺点：
- en: Consumes more space and memory on the target running machine
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标运行机器上消耗更多空间和内存
- en: Consumes more CPU and is slower to complete tasks compared to Go
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比 Go，消耗更多 CPU，完成任务速度较慢
- en: Code is visible on the target running machine, which can be unsecure
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在目标运行机器上可见，可能存在不安全因素
- en: Runtime parallelism implementation is weak compared to Go
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Go 相比，运行时并行实现较弱
- en: 'Pros of using the Go runtime:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 运行时的优点：
- en: Consumes less memory and space on the target running machine
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标运行机器上消耗更少的内存和空间
- en: Consumes less CPU and runs faster than Python
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗更少的 CPU，运行速度比 Python 快
- en: Code is compiled, which is not human readable and can’t easily be decoded
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码被编译，这使其不可读，且难以解码
- en: The runtime parallelism implementation is much better than Python
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时并行实现的性能远优于 Python
- en: 'Cons of using the Go runtime:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 运行时的缺点：
- en: More difficult to create prototypes
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原型更困难
- en: A smaller development community and fewer runtime libraries
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发社区较小，运行时库较少
- en: For network programming, Go has much more benefits compared to Python in terms
    of performance. However, as Python is an older language, it has a broader community
    with more network libraries and functionalities.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络编程，与 Python 相比，Go 在性能方面具有更多优势。然而，由于 Python 是一种较老的语言，它拥有更广泛的社区，拥有更多的网络库和功能。
- en: So, choosing which language to use will depend on the use case you are working
    on. If you want something quick and wish to write less code by reusing someone
    else’s library, then Python is probably the best fit. But if you want something
    that has more performance, is secure, uses less memory, and can be built as one
    binary program, Go is your best fit. As the Go community grows, it will probably
    have more libraries that can help with network automation over time, but as it
    stands today, Python has more community contributions in the network automation
    field.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择使用哪种语言将取决于你正在处理的使用案例。如果你想要快速完成，并且希望通过重用他人的库来编写更少的代码，那么 Python 可能是最合适的选择。但如果你想要性能更高、更安全、占用内存更少，并且可以构建为一个二进制程序的东西，Go
    就是你的最佳选择。随着 Go 社区的成长，它可能会随着时间的推移拥有更多帮助网络自动化的库，但就目前而言，Python 在网络自动化领域有更多的社区贡献。
- en: In the next section, we’ll learn how we can add external libraries to our code
    in Go and Python.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在 Go 和 Python 代码中添加外部库。
- en: Using third-party libraries
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方库
- en: When developing network automation, it is always worth researching tools and
    libraries in the community to see if you can incorporate some external code that
    will add functionalities or speed up your development process.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发网络自动化时，总是值得研究社区中的工具和库，看看你是否可以整合一些外部代码，这将增加功能或加快你的开发过程。
- en: In preparation to explain how to use third-party libraries, it is important
    to understand how libraries in general are used in Python and Go. We’ll detail
    the library-adding process in Python and Go in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释如何使用第三方库，了解 Python 和 Go 中库的一般使用方式非常重要。在本节中，我们将详细说明 Python 和 Go 中的库添加过程。
- en: Adding Python libraries
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Python 库
- en: Before discussing how libraries are added to Python, it is important to explain
    that, in Python, a **library** is also known as a **package** or a **module**.
    These three terms are used widely throughout Python documentation, which can make
    some new Python developers confused. So, whenever you see the term “Python library”,
    it can also mean a package or a module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何将库添加到 Python 之前，重要的是要解释，在 Python 中，**库**也被称为**包**或**模块**。这三个术语在 Python
    文档中广泛使用，这可能会让一些新的 Python 开发者感到困惑。所以，无论何时看到“Python 库”这个术语，它也可以指包或模块。
- en: A library in Python can be external, internal, or built-in. These external libraries
    are also known as third-party modules, packages, or libraries.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的库可以是外部的、内部的或内置的。这些外部库也被称为第三方模块、包或库。
- en: 'To use a library in Python, you just need to use the `import` statement at
    the beginning of the code. If the library is not found, it will raise an error
    exception called `ModuleNotFoundError`, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Python 中使用库，你只需在代码开头使用 `import` 语句。如果库未找到，它将引发一个名为 `ModuleNotFoundError`
    的错误异常，如下所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, the Python interpreter threw an exception called
    `ModuleNotFoundError`, which means the package is not installed or is not in the
    search path. The search path is normally included in the `path` variable inside
    the `sys` package, as shown in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Python 解释器抛出了一个名为 `ModuleNotFoundError` 的异常，这意味着包未安装或不在搜索路径中。搜索路径通常包含在
    `sys` 包内的 `path` 变量中，如下面的示例所示：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in the preceding example, the `sys.path` variable has been pre-filed
    with a list of system paths, but you can append more if needed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的示例中，`sys.path` 变量已经被预填充了一个系统路径列表，但如果你需要，可以追加更多。
- en: Now, let’s discuss how the built-in, standard, and external modules are used
    in Python.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何在 Python 中使用内置的、标准的和外部模块。
- en: Using Python built-in libraries
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 内置库
- en: The built-in modules (or libraries) are modules that can be imported, but they
    come within the Python runtime program. They are not external files to be added,
    so they don’t need to be found in the `sys.path` variable. There are also built-in
    functions, such as `print`, but built-in modules are the ones that you are going
    to explicitly import before using them, such as the popular one known as `sys`,
    or others such as `array` and `time`. These built-in modules are not external
    programs like they are in Python standard libraries, but they are included in
    the binary code of the interpreter, like in CPython.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内置模块（或库）是可以导入的模块，但它们包含在 Python 运行时程序中。它们不是需要添加的外部文件，因此不需要在 `sys.path` 变量中找到。还有内置函数，如
    `print`，但内置模块是在使用之前需要显式导入的，例如众所周知的 `sys`，或其他如 `array` 和 `time` 的模块。这些内置模块不是像 Python
    标准库中的那样是外部程序，而是包含在解释器的二进制代码中，就像 CPython 一样。
- en: Using Python standard libraries
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 标准库
- en: 'These are modules that come with the Python distribution, but they are separate
    Python files that are added when you state `import` at the beginning of the Python
    code; they need to be found in the `sys.path` variable. These modules are Python
    programs and can be found in the Python library installation directory, such as
    the `socket` library, as illustrated in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与 Python 发行版一起提供的模块，但它们是当你开始在 Python 代码中声明 `import` 时添加的独立 Python 文件；它们需要在
    `sys.path` 变量中找到。这些模块是 Python 程序，可以在 Python 库安装目录中找到，例如下面的示例中的 `socket` 库：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `/usr/lib/pytho3.10/socket.py` location will depend on the operating
    system and version of Python. In the preceding example, Linux Ubuntu and Python
    3.10 are being used. A list of all standard libraries for Python 3.10.x can be
    found at [https://github.com/python/cpython/tree/3.10/Lib](https://github.com/python/cpython/tree/3.10/Lib).
    More information about each built-in and standard library for Python 3.x can be
    found at [https://docs.python.org/3/library/](https://docs.python.org/3/library/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`/usr/lib/pytho3.10/socket.py` 的位置将取决于操作系统和 Python 版本。在上面的例子中，使用了 Linux Ubuntu
    和 Python 3.10。Python 3.10.x 的所有标准库的列表可以在 [https://github.com/python/cpython/tree/3.10/Lib](https://github.com/python/cpython/tree/3.10/Lib)
    找到。有关 Python 3.x 中每个内置和标准库的更多信息，可以在 [https://docs.python.org/3/library/](https://docs.python.org/3/library/)
    找到。
- en: Using third-party Python libraries
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用第三方 Python 库
- en: External libraries or third-party libraries are modules (or packages) in Python
    that are not included with the Python distribution and need to be installed manually
    before they’re used. These modules are normally not maintained by the Python library
    team but by developers of the Python community, which are not necessarily related
    to the Python main distribution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 外部库或第三方库是 Python 中不包含在 Python 发行版中的模块（或包），在使用之前需要手动安装。这些模块通常不是由 Python 库团队维护，而是由
    Python 社区的开发者维护，这些开发者与 Python 主发行版不一定相关。
- en: As we discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127), before adding
    the external module to your code, have a look in the `LICENSE` file and check
    if any limitations might impact the usage of this module on your code or in your
    organization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第五章*](B18165_05.xhtml#_idTextAnchor127) 中讨论的，在将外部模块添加到代码之前，查看 `LICENSE`
    文件，并检查是否有任何限制可能会影响该模块在您的代码或组织中的使用。
- en: The Python community has organized a group called `pip`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python 社区已经组织了一个名为 `pip` 的团队。
- en: PyPA is also responsible for maintaining [pypi.org](http://pypi.org), where
    all packages that can be included with `pip` are documented. On this site, there
    is a search engine for finding packages and also documentation for developers
    that want to contribute or share their packages. Note that the source code for
    the packages is not on the [pypi.org](http://pypi.org) site, but in repositories
    such as **GitHub**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: PyPA 还负责维护 [pypi.org](http://pypi.org)，其中记录了所有可以与 `pip` 一起使用的包。在这个网站上，有一个用于查找包的搜索引擎，还有为想要贡献或分享他们的包的开发者提供的文档。请注意，包的源代码不在
    [pypi.org](http://pypi.org) 网站上，而是在如 **GitHub** 这样的仓库中。
- en: 'Now, let’s go through an example of the process of using a third-party package
    in our code. The package that we are adding as an example is called `netmiko`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个例子来了解在代码中使用第三方包的过程。我们作为例子添加的包名为 `netmiko`：
- en: Check if the package is included on [pypi.org](http://pypi.org) as per PyPA.
    If so, we can use `pip` to add the package to our local Python environment.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 PyPA 检查包是否包含在 [pypi.org](http://pypi.org) 上。如果是，我们可以使用 `pip` 将包添加到我们的本地 Python
    环境中。
- en: 'Yes, it is: [https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是这样的：[https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/).
- en: Read the `LICENSE` file and check if it is allowed to be used in your organization.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读许可证文件并检查是否允许在您的组织中使用。
- en: 'This license is based on MIT, which is less restrictive, so we can use it:
    [https://github.com/ktbyers/netmiko/blob/develop/LICENSE](https://github.com/ktbyers/netmiko/blob/develop/LICENSE).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本许可证基于 MIT 协议，限制较少，因此我们可以使用它：[https://github.com/ktbyers/netmiko/blob/develop/LICENSE](https://github.com/ktbyers/netmiko/blob/develop/LICENSE).
- en: 'Use `pip` to install the package to your local Python environment, as shown
    in the following example:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pip` 工具将包安装到您的本地 Python 环境中，如下例所示：
- en: '[PRE4]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Check if you can import and locate where the `netmiko` library is installed:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您是否可以导入并定位 `netmiko` 库的安装位置：
- en: '[PRE5]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the `netmiko` package has been installed using the
    `pip` tool, and the library is located under my home directory, `/home/claus`.
    However, this varies, depending on the version of Python and the operating system
    used. It also varies within Linux, depending on the distribution, such as Debian,
    Ubuntu, or Red Hat.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`netmiko` 包已使用 `pip` 工具安装，并且库位于我的家目录下，`/home/claus`。然而，这取决于 Python 的版本和使用的操作系统。在
    Linux 中，它也取决于发行版，如 Debian、Ubuntu 或 Red Hat。
- en: 'Just keep in mind that third-party Python libraries will be installed normally
    under a directory called `site-packages`. Here are some examples of where it can
    be located for each operating system:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，第三方 Python 库将在名为 `site-packages` 的目录下正常安装。以下是每个操作系统可能的位置示例：
- en: 'For macOS: `/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS：`/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages`
- en: 'For Windows: `C:\Users\username\AppData\Local\Programs\Python\Python39\lib\site-packages`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Windows：`C:\Users\username\AppData\Local\Programs\Python\Python39\lib\site-packages`
- en: 'For Linux Ubuntu: `/usr/lib/python3.9/site-packages`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Linux Ubuntu：`/usr/lib/python3.9/site-packages`
- en: 'A complete list of all packages that you have installed on your system can
    be found by typing the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找您在系统上安装的所有包的完整列表，请输入以下命令：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let’s explore how we can use libraries and third-party libraries in Go.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何在 Go 中使用库和第三方库。
- en: Adding Go libraries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Go 库
- en: 'In contrast with Python, Go only has two types of libraries: the standard libraries
    and the third-party libraries. For Go, there is no concept of built-in libraries
    because it does not have an interpreter; instead, it has a compiler. The reason
    is that an interpreter can include a few libraries in its binary, which are called
    built-in libraries.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 相比，Go 只有两种类型的库：标准库和第三方库。对于 Go，没有内置库的概念，因为它没有解释器；相反，它有一个编译器。原因是解释器可以在其二进制文件中包含一些库，这些库被称为内置库。
- en: To add a library to your Go code, you will need to use the `import` statement,
    which is the same in Python but the syntax is a bit different.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要将库添加到您的 Go 代码中，您需要使用 `import` 语句，这与 Python 中的用法相同，但语法略有不同。
- en: Similar to Python, in Go, a library is also known as a **package**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 类似，在 Go 中，一个库也被称为 **包**。
- en: Let’s have a look at how to add standard libraries and then third-party libraries
    in Go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Go 中添加标准库和第三方库。
- en: Using standard libraries in Go
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Go 中使用标准库
- en: Each version of Go includes a set of standard libraries that are installed with
    the Go distribution. These standard libraries are also Go programs that, when
    imported, will be combined with your code during compilation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的每个版本都包含一组与 Go 发行版一起安装的标准库。这些标准库也是 Go 程序，当导入时，将在编译期间与您的代码结合。
- en: A list of standard libraries can be found at [https://pkg.go.dev/std](https://pkg.go.dev/std).
    The website is very useful because it includes an explanation of each library
    (or package).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的列表可以在 [https://pkg.go.dev/std](https://pkg.go.dev/std) 找到。该网站非常有用，因为它包括每个库（或包）的解释。
- en: The standard libraries can also be found in your local development filesystem.
    Go’s installation includes all standard libraries, such as the `fmt` and `math`
    packages. The location of these standard libraries will vary for each operating
    system but can be found by looking into the `GOROOT` environment variable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库也可以在您的本地开发文件系统中找到。Go 的安装包括所有标准库，例如 `fmt` 和 `math` 包。这些标准库的位置因操作系统而异，但可以通过查看
    `GOROOT` 环境变量来找到。
- en: 'Most operating systems do not populate the `GOROOT` variable, so they will
    use the Go language’s default location. To find out your default location, you
    can run the `go env` command, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统不会设置`GOROOT`变量，因此它们将使用Go语言的默认位置。要找出您的默认位置，您可以运行`go env`命令，如下所示：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, `GOROOT` is located in `/usr/lib/go-1.19`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`GOROOT`位于`/usr/lib/go-1.19`。
- en: 'To learn how the libraries are located, let’s use the `fmt` standard library
    to print a string to the computer terminal:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解库的定位方式，让我们使用`fmt`标准库将字符串打印到计算机终端：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, the `import` statement tells the Go compiler that
    it needs to add the `fmt` package, which in this case is a standard library package.
    In this example, the Go compiler will search for this package, starting by looking
    in the `/usr/lib/go-1.19` directory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`import`语句告诉Go编译器需要添加`fmt`包，在这种情况下是一个标准库包。在这个示例中，Go编译器将从这个包开始搜索，首先查找`/usr/lib/go-1.19`目录。
- en: To be more specific, the `fmt` package is located at `/usr/lib/go-1.19/src/fmt`.
    The `Println` function that’s being used in this example is described in the `/usr/lib/go-1.19/src/fmt/print.go`
    file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，`fmt`包位于`/usr/lib/go-1.19/src/fmt`。在这个示例中使用的`Println`函数在`/usr/lib/go-1.19/src/fmt/print.go`文件中有描述。同样，`math`目录中的所有文件在其第一行上都有`package
    math`语句。
- en: In Go, all programs have to belong to a package, and the package name is described
    in the first line of the code. In the `fmt` directory (`/usr/lib/go-1.19/src/fmt`),
    all the files included in the directory have a first line that contains the `package
    fmt` statement. This includes the `scan.go`, `format.go`, and `print.go` files,
    which are located in the `fmt` directory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，所有程序都必须属于一个包，包名在代码的第一行中描述。在`fmt`目录（`/usr/lib/go-1.19/src/fmt`）中，该目录下所有包含的文件的第一行都包含`package
    fmt`语句。这包括位于`fmt`目录中的`scan.go`、`format.go`和`print.go`文件。
- en: Other examples of standard libraries in Go can be found in your local Go installation,
    normally under the `src` directory. In the preceding example, it is under `/usr/lib/go-1.19/src`.
    Some other examples include the `math` package, located at `/usr/lib/go-1.19/src/math/`,
    and the `time` package, located at `/usr/lib/go-1.19/src/time/`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的其他标准库示例可以在您的本地Go安装中找到，通常位于`src`目录下。在前面的示例中，它位于`/usr/lib/go-1.19/src`。其他示例包括位于`/usr/lib/go-1.19/src/math/`的`math`包和位于`/usr/lib/go-1.19/src/time/`的`time`包。
- en: 'Here is another example, which uses the `math` standard library:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个示例，它使用了`math`标准库：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, the `math` library uses the `Sqrt` function, which
    is described in the `/usr/lib/go-1.19/src/math/sqrt.go` file. Again, all the files
    in the `math` directory have the `package math` statement on their first line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`math`库使用了`Sqrt`函数，该函数在`/usr/lib/go-1.19/src/math/sqrt.go`文件中有描述。同样，`math`目录中的所有文件在其第一行上都有`package
    math`语句。
- en: Now, let’s learn how to add third-party libraries to Go.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将第三方库添加到Go中。
- en: Using third-party libraries in Go
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Go中使用第三方库
- en: Third-party library packages in Go are added in a similar way to standard libraries
    – by using the `import` statement in your code. However, the underlying process
    of adding these packages to the Go development environment is a bit different
    in terms of a few characteristics.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的第三方库包的添加方式与标准库类似——通过在代码中使用`import`语句。然而，将这些包添加到Go开发环境中的底层过程在几个特性上略有不同。
- en: In the case of third-party packages, the compiler needs to search for new files
    containing the package in a different path, which is populated in the `GOPATH`
    environment variable. Like `GOROOT`, you don’t need to populate `GOPATH` as the
    Go compiler has a default location for the `GOPATH` variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三方包，编译器需要在不同的路径中搜索包含该包的新文件，这个路径由`GOPATH`环境变量设置。与`GOROOT`一样，您不需要设置`GOPATH`，因为Go编译器为`GOPATH`变量有一个默认位置。
- en: 'In our Go example, let’s check the default location for `GOPATH` by running
    the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Go示例中，让我们通过运行以下命令来检查`GOPATH`的默认位置：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, the default location for `GOPATH` is the `go` directory inside
    my home directory (`/home/claus`).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`GOPATH`的默认位置是我家目录中的`go`目录（`/home/claus`）。
- en: 'In Go, third-party libraries can be added by invoking the `get` subcommand
    on the `go` command line, as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，可以通过在`go`命令行上调用`get`子命令来添加第三方库，如下所示：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we added the `x/crypto` package. Note that all other
    dependencies of the package are also added; in this example, the other dependency
    is `x/sys`. The `get` subcommand also stores the version of the package – in this
    case, `v0.0.0-20220622213112-05595931fe9d`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们添加了`x/crypto`包。请注意，该包的所有其他依赖项也被添加；在这个例子中，其他依赖项是`x/sys`。`get`子命令还存储了包的版本——在这种情况下，`v0.0.0-20220622213112-05595931fe9d`。
- en: Then, the package is saved under the `GOPATH` directory. In the preceding example,
    it is saved at `/home/claus/go/pkg/mod/golang.org/x/crypto@<VERSION>`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该包被保存在`GOPATH`目录下。在先前的例子中，它被保存在`/home/claus/go/pkg/mod/golang.org/x/crypto@<VERSION>`。
- en: Every time you run `go get` and there is a new version available, Go stores
    the new version and keeps the old one in a different directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你运行`go get`并且有新版本可用时，Go都会存储新版本，并将旧版本保存在不同的目录中。
- en: 'You don’t need to run `go get` when adding a third-party library. The `get`
    command is sometimes invoked when you run `go build` if the package has not been
    downloaded or cached, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加第三方库时，不需要运行`go get`。如果包尚未下载或缓存，则在运行`go build`时有时会调用`get`命令，如下所示：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, the Go program had an `import` statement:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，Go程序有一个`import`语句：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After adding a third-party library, Go also updates the `go.mod` file. This
    file is required to keep track of the versions of the packages that are added
    to your Go program. The following is the content of the `go.mod` file for the
    preceding examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加第三方库后，Go也会更新`go.mod`文件。此文件用于跟踪添加到你的Go程序中的包版本。以下是为先前列举的示例的`go.mod`文件内容：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the `go.mod` file also stores the versions of the packages for all
    dependencies. In the preceding example, the `x/sys` package version is also stored
    in the file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`go.mod`文件还存储了所有依赖项的包版本。在先前的例子中，`x/sys`包的版本也存储在该文件中。
- en: Now that you’re familiar with adding third-party libraries to Go and Python,
    let’s dive into the next section and look at some libraries that can be used to
    access the network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了将第三方库添加到Go和Python中，让我们深入下一节，看看一些可以用来访问网络的库。
- en: Accessing network devices using libraries
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库访问网络设备
- en: So far, we have discussed how to run and work with libraries in Python and Go.
    Now, let’s focus on how to use Python and Go to access network devices, which
    is one of the most important points in our network automation work.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何在Python和Go中运行和使用库。现在，让我们专注于如何使用Python和Go来访问网络设备，这是我们网络自动化工作中最重要的一个点。
- en: In [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), we discussed several methods
    to access network devices. One of the most popular ones is using a **command-line
    interface** (**CLI**). We also discussed SNMP, NETCONF, gRPC, and gNMI. In this
    section, we are going to explore a few examples of how to use libraries to access
    network devices, mainly using the CLI. Later, we are going to explain and show
    the libraries for accessing the network using other methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18165_03.xhtml#_idTextAnchor067)中，我们讨论了几种访问网络设备的方法。其中最受欢迎的一种是使用**命令行界面**（CLI）。我们还讨论了SNMP、NETCONF、gRPC和gNMI。在本节中，我们将探讨一些使用库来访问网络设备的示例，主要使用CLI。稍后，我们将解释并展示使用其他方法访问网络的库。
- en: Libraries to access the network via a CLI
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过CLI访问网络的库
- en: There are lots of libraries on the internet that can access network devices,
    and some of them might be obsolete or not used anymore. Here, we are going to
    present the most popular ones in chronological order, from the old to the newer
    ones.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多可以访问网络设备的库，其中一些可能已经过时或不再使用。在这里，我们将按时间顺序介绍最受欢迎的库，从旧到新。
- en: The following examples are going to collect the uptime of the network device
    by sending the `uptime` command via the CLI on an SSH connection.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将通过SSH连接在CLI上发送`uptime`命令来收集网络设备的运行时间。
- en: Using Python Paramiko
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python Paramiko
- en: Paramiko is perhaps one of the oldest implementations for accessing network
    devices via the CLI. The first release was published in 2003\. Today, it has more
    than 300 contributors and there are almost 2,000 packages depending on Paramiko
    ([https://github.com/paramiko/paramiko/network/dependents](https://github.com/paramiko/paramiko/network/dependents)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko可能是通过CLI访问网络设备的最早实现之一。它的第一个版本发布于2003年。如今，它拥有超过300位贡献者，并且有近2000个包依赖于Paramiko([https://github.com/paramiko/paramiko/network/dependents](https://github.com/paramiko/paramiko/network/dependents))。
- en: As we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), the correct
    way to use CLI libraries is via **Secure Shell** (**SSH**). Paramiko implements
    secure cryptography for SSH using a lower-level library called PyCrypto ([http://pycrypto.org/](http://pycrypto.org/)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 3 章*](B18165_03.xhtml#_idTextAnchor067) 中讨论的那样，正确使用 CLI 库的方式是通过 **Secure
    Shell** （**SSH**）。Paramiko 使用名为 PyCrypto 的底层库实现 SSH 的安全加密（[http://pycrypto.org/](http://pycrypto.org/)）。
- en: 'Let’s look at a simple example to obtain the uptime of the network host:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的示例，以获取网络主机的 uptime：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the connection is successful, the output of the preceding program will be
    the uptime of the network host:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接成功，前面程序的输出将是网络主机的 uptime。
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using Python Netmiko
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python Netmiko
- en: Netmiko is also another popular library for accessing network devices via the
    CLI. The first release was published in 2014 and was built on top of Paramiko
    to simplify connections to network devices. In summary, Netmiko is simpler than
    Paramiko and more focused on network devices.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko 也是另一个流行的库，用于通过 CLI 访问网络设备。它的第一个版本发布于 2014 年，建立在 Paramiko 之上，以简化对网络设备的连接。总的来说，Netmiko
    比 Paramiko 更简单，更专注于网络设备。
- en: 'Let’s learn what the same example for Paramiko will look like when using Netmiko:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当使用 Netmiko 时，与 Paramiko 相同的示例会是什么样子：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the implementation of the Netmiko code is just 2 lines, with
    much smaller and simpler code compared to Paramiko. The big advantage of the Netmiko
    library is that it handles the device’s command prompt automatically and works
    with ease when changing the configuration in privilege mode since the prompt normally
    changes. In the preceding example, the device type was `linux_ssh` because our
    target host was a Linux device.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Netmiko 代码的实现只有 2 行，与 Paramiko 相比，代码更小、更简单。Netmiko 库的巨大优势在于它自动处理设备的命令提示符，并在更改特权模式下的配置时轻松工作，因为提示符通常会改变。在上一个示例中，设备类型是
    `linux_ssh`，因为我们的目标主机是 Linux 设备。
- en: 'Netmiko can support dozens of network devices, including Cisco, Huawei, Juniper,
    and Alcatel. A complete list of devices can be found here: [https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md](https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko 可以支持数十种网络设备，包括 Cisco、华为、Juniper 和 Alcatel。设备列表的完整列表可以在以下链接找到：[https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md](https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md)。
- en: Using Python AsyncSSH
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python AsyncSSH
- en: AsyncSSH is a modern implementation of Python **AsyncIO** for SSH. Python AsyncIO
    was introduced in Python version 3.4 and allows Python to work concurrently using
    async/await syntax and provides high performance for network access. To use AsyncSSH,
    you will need to have Python version 3.6 or higher.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: AsyncSSH 是 Python **AsyncIO** 的现代实现，用于 SSH。Python AsyncIO 在 Python 3.4 版本中引入，允许
    Python 使用 async/await 语法进行并发工作，并为网络访问提供高性能。要使用 AsyncSSH，您需要 Python 3.6 或更高版本。
- en: In summary, AsyncSSH provides better performance for multiple hosts, but it
    is a lower-level implementation that requires more complexity in your code to
    handle network devices in comparison to Netmiko.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，AsyncSSH 为多个主机提供了更好的性能，但它是一个更底层的实现，与 Netmiko 相比，在处理网络设备时需要更多的代码复杂性。
- en: 'The same example of getting uptime for AsyncSSH can be written like so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 AsyncSSH 的 uptime 的相同示例可以写成这样：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that when using AsyncSSH, you will have to work with routines and events,
    as instructed by Python AsyncIO and the preceding example. If you want to dig
    into this, some great documentation can be found at https://realpython.com/async-io-python/.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当使用 AsyncSSH 时，您将不得不按照 Python AsyncIO 和前面示例的指示与例程和事件一起工作。如果您想深入了解，可以在 https://realpython.com/async-io-python/
    找到一些优秀的文档。
- en: Using Python Scrapli
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python Scrapli
- en: In comparison to Netmiko, Scrapli is newer. The first release was published
    in 2019 and is also built on top of Paramiko but has capabilities to use AsyncSSH,
    which claims to improve performance when accessing multiple devices. The idea
    of the name Scrapli came from *scrape cli*, similar to someone scraping the screen.
    This is because Scrapli’s main objective is to interpret text from the network
    terminal using the CLI.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Netmiko 相比，Scrapli 是较新的。它的第一个版本发布于 2019 年，也是建立在 Paramiko 之上，但具有使用 AsyncSSH
    的能力，声称在访问多个设备时可以提高性能。Scrapli 这个名字的灵感来自 *scrape cli*，类似于某人刮擦屏幕。这是因为 Scrapli 的主要目标是使用
    CLI 从网络终端解释文本。
- en: Scrapli was built to allow its users to interpret prompts from multi-vendor
    network devices such as Netmiko but with a reduced set of platforms. The 2022.7.30
    version supports Cisco, Juniper, and Arista. One advantage of using Scrapli is
    that it also supports NETCONF.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Scrapli被构建出来，允许其用户以减少的平台集来解释来自多厂商网络设备（如Netmiko）的提示。2022.7.30版本支持Cisco、Juniper和Arista。使用Scrapli的一个优点是它还支持NETCONF。
- en: 'The following is the same example to get uptime but using Scrapli:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Scrapli获取运行时间的相同示例：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So far, we have learned about the most popular libraries for accessing network
    terminals using Python. Now, let’s learn we can do this with the Go language.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了使用Python访问网络终端最流行的库。现在，让我们学习如何使用Go语言来做这件事。
- en: Using Go ssh
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go ssh
- en: In contrast to Python, Go does not have a large community for working with libraries
    that can handle network devices. Therefore, in some particular cases, you might
    have to write your own scrape mechanism to interpret the remote network terminal
    via the CLI. The problem with doing this yourself is it will be different for
    each network vendor and will take more coding time as you add different network
    devices.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python相比，Go没有处理网络设备的库的大社区。因此，在某些特定情况下，您可能必须编写自己的抓取机制来通过CLI解释远程网络终端。自己这样做的问题在于，它将因每个网络供应商而异，并且随着添加不同的网络设备，将需要更多的时间进行编码。
- en: 'Let’s look at an example of getting uptime from the remote network host:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从远程网络主机获取运行时间的示例：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the preceding example contains much more code than some higher-level
    libraries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前一个示例比一些高级库包含更多的代码。
- en: Using Go vSSH
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go vSSH
- en: There is a library in Go called vSSH, which is built on top of `golang.org/x/crypto`
    by engineers at Yahoo. It creates an abstraction for accessing remote terminals
    on network devices, which avoids the code that we saw previously with the SSH
    example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中有一个名为vSSH的库，它是由雅虎的工程师基于`golang.org/x/crypto`构建的。它为访问网络设备上的远程终端创建了一个抽象层，从而避免了我们在之前的SSH示例中看到的代码。
- en: One of the main claims of vSSH is that it can handle access to multiple targets
    with high performance, which is obtained by using Go routines (a great beginner’s
    guide for Go routines can be found at [https://go.dev/tour/concurrency/1](https://go.dev/tour/concurrency/1)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: vSSH的主要主张之一是它能够以高性能处理对多个目标的访问，这是通过使用Go协程（可以在[https://go.dev/tour/concurrency/1](https://go.dev/tour/concurrency/1)找到关于Go协程的优秀入门指南）实现的。
- en: 'Although vSSH can handle multiple targets efficiently, let’s start by writing
    an example that uses only one target:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管vSSH可以有效地处理多个目标，但让我们先从一个只使用一个目标的示例开始：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Go routines have been used in this example. Additional targets can be added
    using `vs.AddClient()` before calling `vs.Wait()`. In our example, only one target
    was added to get the uptime of the remote network host. The loop at the end is
    not necessary for only one target, but I left it there to demonstrate how to use
    it with multiple targets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用了Go协程。在调用`vs.Wait()`之前，可以使用`vs.AddClient()`添加更多目标。在我们的示例中，只添加了一个目标来获取远程网络主机的运行时间。末尾的循环对于单个目标来说不是必需的，但我将其留下以演示如何与多个目标一起使用。
- en: As we can have one host that might be faulty or slow when using multiple targets,
    a parse timeout is used, which in our example is 4 seconds. The preceding example
    uses a channel via the `rChannel` variable to obtain the results of the Go routines
    for each target.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个目标时，我们可能有一个可能存在故障或速度较慢的主机，因此使用了解析超时，在我们的示例中是4秒。前面的示例通过`rChannel`变量使用通道来获取每个目标的Go协程的结果。
- en: Using Go Scrapligo
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go Scrapligo
- en: Scrapligo is a Go version of the successful Python library Scrapli. It supports
    the same network platforms and also supports NETCONF. The advantages of using
    Scrapligo over Scrapli are the ones we discussed earlier in this chapter related
    to how Go and Python runtime perform.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Scrapligo是成功的Python库Scrapli的Go版本。它支持相同的网络平台，也支持NETCONF。使用Scrapligo而不是Scrapli的优点是我们在本章前面讨论的与Go和Python运行时性能相关的优点。
- en: 'The preceding example in Scrapligo would look like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scrapligo中的前一个示例看起来是这样的：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have just discussed how to access network devices via the CLI using Python
    and Go libraries. Now, let’s learn how to use libraries to access the network
    using other methods.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了如何使用Python和Go库通过CLI访问网络设备。现在，让我们学习如何使用其他方法通过库访问网络。
- en: Libraries to access networks using SNMP
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SNMP访问网络的库
- en: Excluding the CLI, the second most popular network device access method is SNMP.
    But as we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), SNMP is
    only used to read information from network devices. The SNMP write method is not
    used for the reasons discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 CLI 之外，第二种最受欢迎的网络设备访问方法是 SNMP。但正如我们在 [*第 3 章*](B18165_03.xhtml#_idTextAnchor067)
    中讨论的那样，SNMP 仅用于从网络设备读取信息。SNMP 写入方法不使用，原因如 [*第 3 章*](B18165_03.xhtml#_idTextAnchor067)
    中所述。
- en: For the SNMP examples, we are going to pick up one library from Python and one
    from Go. These libraries are the most popular ones for using the SNMP method today.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SNMP 示例，我们将从 Python 和 Go 中各选择一个库。这些是目前使用 SNMP 方法最受欢迎的库。
- en: In the previous subsection, we used CLI methods to collect the uptime of the
    network device. We are going to demonstrate now that we can also get the uptime
    of the remote network device by using the SNMP method. For that, we need to collect
    the `SNMPv2-MIB::sysUpTime` MIB variable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个子节中，我们使用了 CLI 方法来收集网络设备的运行时间。现在我们将演示，我们也可以通过使用 SNMP 方法来获取远程网络设备的运行时间。为此，我们需要收集
    `SNMPv2-MIB::sysUpTime` MIB 变量。
- en: Using Python PySNMP
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python PySNMP
- en: 'PySNMP is the most popular library for Python for the SNMP method. It supports
    all versions of SNMP from version 1 to version 3\. The following is an example
    of using the SNMP method to obtain the uptime of the network device:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: PySNMP 是 Python 中用于 SNMP 方法的最受欢迎的库。它支持从版本 1 到版本 3 的所有 SNMP 版本。以下是一个使用 SNMP 方法获取网络设备运行时间的示例：
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output will be `SNMPv2-MIB::sysUpTime.0 = 72515`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是 `SNMPv2-MIB::sysUpTime.0 = 72515`。
- en: More on PySNMP can be found at [https://pysnmp.readthedocs.io/en/latest/](https://pysnmp.readthedocs.io/en/latest/).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 PySNMP 的信息可以在 [https://pysnmp.readthedocs.io/en/latest/](https://pysnmp.readthedocs.io/en/latest/)
    找到。
- en: Using gosnmp
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 gosnmp
- en: 'For Go, the most popular library for the SNMP method is `gosnmp`. It also supports
    version 1 to version 3 of the SNMP protocol. Compared to PySNMP, `gosnmp` is newer
    but has more developers and more users, making it more reliable in terms of future
    development. The following is an example of collecting uptime from a network device
    using the SNMP method in Go. In this example, the OID number (`1.3.6.1.2.1.1.3.0`)
    represents the same as `SNMPv2-MIB::sysUpTime`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Go 语言，用于 SNMP 方法的最受欢迎的库是 `gosnmp`。它也支持 SNMP 协议的 1 到 3 版本。与 PySNMP 相比，`gosnmp`
    更新，但拥有更多的开发者和用户，使其在未来的开发中更加可靠。以下是一个使用 Go 语言通过 SNMP 方法从网络设备收集运行时间的示例。在这个例子中，OID
    号码 (`1.3.6.1.2.1.1.3.0`) 与 `SNMPv2-MIB::sysUpTime` 相同：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will be `oid: .1.3.6.1.2.1.1.3.0 : 438678`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '输出将是 `oid: .1.3.6.1.2.1.1.3.0 : 438678`。'
- en: More on `gosnmp` can be found at [https://pkg.go.dev/github.com/gosnmp/gosnmp](https://pkg.go.dev/github.com/gosnmp/gosnmp).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `gosnmp` 的信息可以在 [https://pkg.go.dev/github.com/gosnmp/gosnmp](https://pkg.go.dev/github.com/gosnmp/gosnmp)
    找到。
- en: Libraries to access networks using NETCONF or RESTCONF
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NETCONF 或 RESTCONF 访问网络的库示例
- en: When writing configuration to the network devices, the preferred method would
    be NETCONF or RESTCONF. However, some devices or some functions of the device
    might not have it implemented yet. In this case, the most appropriate method would
    be via a CLI as SNMP is not used to write data on the device.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当向网络设备写入配置时，首选的方法将是 NETCONF 或 RESTCONF。然而，某些设备或设备的某些功能可能尚未实现。在这种情况下，最合适的方法是通过
    CLI，因为 SNMP 不会用于在设备上写入数据。
- en: The RESTCONF/NETCONF methods are newer methods to access network devices compared
    to a CLI or SNMP. Because of that, there are not many libraries available. Today,
    the best library to use NETCONF in Python would be Scrapli; for Go, this would
    be Scrapligo.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CLI 或 SNMP 相比，RESTCONF/NETCONF 方法是较新的网络设备访问方法。因此，可用的库不多。今天，在 Python 中使用 NETCONF
    的最佳库是 Scrapli；对于 Go，这将是在 Scrapligo。
- en: Examples of using Python Scrapli with NETCONF can be found at [https://scrapli.github.io/scrapli_netconf/](https://scrapli.github.io/scrapli_netconf/).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python Scrapli 与 NETCONF 的示例可以在 [https://scrapli.github.io/scrapli_netconf/](https://scrapli.github.io/scrapli_netconf/)
    找到。
- en: Examples of using Go Scrapligo with NETCONF can be found at [https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics](https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go Scrapligo 与 NETCONF 的示例可以在 [https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics](https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics)
    找到。
- en: 'You can also use a plain HTTP library to collect information using RESTCONF,
    as shown in the following Python example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用纯 HTTP 库通过 RESTCONF 收集信息，如下面的 Python 示例所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let’s learn how to use Python and Go to access networks using gRPC and
    gNMI.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 Python 和 Go 通过 gRPC 和 gNMI 访问网络。
- en: Libraries to access networks using gRPC and gNMI
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 gRPC 和 gNMI 访问网络的库
- en: Compared to the other methods, gRPC is quite new and network device vendors
    have added this capability in recent years. So, if you have old devices in your
    network, you might not be able to use gRPC or gNMI.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他方法相比，gRPC 相对较新，网络设备供应商在近年来添加了这项功能。因此，如果您网络中有旧设备，您可能无法使用 gRPC 或 gNMI。
- en: As we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), gRPC is
    a more generic method, and gNMI is more specific for network interfaces. The main
    use of gNMI is network telemetry by invoking the underlying gRPC streaming subscription
    capability. Using gNMI allows your network code to scale easily and collect much
    more network management data compared to SNMP. The gNMI libraries are built on
    top of the gRPC protocol.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第 3 章*](B18165_03.xhtml#_idTextAnchor067)中讨论的，gRPC 是一种更通用的方法，而 gNMI 更适用于网络接口。gNMI
    的主要用途是通过调用底层 gRPC 流式订阅功能来进行网络遥测。使用 gNMI 允许您的网络代码轻松扩展，并且与 SNMP 相比，可以收集更多的网络管理数据。gNMI
    库是建立在 gRPC 协议之上的。
- en: All major network device vendors have some sort of gRPC and/or gNMI implementation
    on their newer network operating systems. Among them are Cisco, Juniper, Arista,
    Nokia, Broadcom, and others.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要网络设备供应商在其较新的网络操作系统上都有某种 gRPC 和/或 gNMI 实现。其中包括 Cisco、Juniper、Arista、Nokia、Broadcom
    以及其他公司。
- en: Using gRPC in Python
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中使用 gRPC
- en: Only newer versions of Python support gRPC, and the Python version has to be
    3.7 or above. To use it, you need to install `grpcio` ([https://pypi.org/project/grpcio/](https://pypi.org/project/grpcio/)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 Python 的新版本支持 gRPC，并且 Python 版本必须为 3.7 或更高。要使用它，您需要安装 `grpcio` ([https://pypi.org/project/grpcio/](https://pypi.org/project/grpcio/))。
- en: 'Examples of using gRPC in Python can be obtained here: [https://grpc.io/docs/languages/python/quickstart/](https://grpc.io/docs/languages/python/quickstart/).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以找到使用 Python 的 gRPC 示例：[https://grpc.io/docs/languages/python/quickstart/](https://grpc.io/docs/languages/python/quickstart/).
- en: Using gRPC in Go
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Go 中使用 gRPC
- en: In Go, gRPC can run on any major version. It is well documented and several
    examples can be found at [https://github.com/grpc/grpc-go](https://github.com/grpc/grpc-go).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，gRPC 可以运行在任何主要版本上。它有很好的文档，可以在 [https://github.com/grpc/grpc-go](https://github.com/grpc/grpc-go)
    找到几个示例。
- en: Using gNMI in Python
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中使用 gNMI
- en: 'Python support for gNMI is particularly rare. There are not many libraries
    available in the Python community. The following list describes the major ones:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对 gNMI 的支持特别罕见。Python 社区中可用的库不多。以下列表描述了主要的一些：
- en: '`Cisco-gnmi-python` was created in 2018 and was initially supported by Cisco
    Networks. The library was created by Cisco to foment the use of gNMI on Cisco
    devices, and perhaps not a good match for multi-vendor support. More details can
    be found at [https://github.com/cisco-ie/cisco-gnmi-python](https://github.com/cisco-ie/cisco-gnmi-python).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cisco-gnmi-python` 于 2018 年创建，最初由 Cisco Networks 支持。这个库是由 Cisco 创建的，旨在促进在
    Cisco 设备上使用 gNMI，可能不适合多供应商支持。更多详情可以在 [https://github.com/cisco-ie/cisco-gnmi-python](https://github.com/cisco-ie/cisco-gnmi-python)
    找到。'
- en: '`gnmi-py` was created in 2019 and is sponsored by Arista Networks. This library
    does not support multi-vendor platforms and can be only used for Arista devices.
    More details can be found at [https://github.com/arista-northwest/gnmi-py](https://github.com/arista-northwest/gnmi-py).'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnmi-py` 于 2019 年创建，由 Arista Networks 赞助。这个库不支持多供应商平台，只能用于 Arista 设备。更多详情可以在
    [https://github.com/arista-northwest/gnmi-py](https://github.com/arista-northwest/gnmi-py)
    找到。'
- en: '`pyygnmi` was created in 2020\. The library can be imported using `pip` and
    has been tested on Cisco, Arista, Juniper, and Nokia devices. This would be the
    preferred choice for multi-vendor platform support. More details can be found
    at [https://github.com/akarneliuk/pygnmi](https://github.com/akarneliuk/pygnmi).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pyygnmi` 于 2020 年创建。这个库可以使用 `pip` 导入，并在 Cisco、Arista、Juniper 和 Nokia 设备上进行了测试。这将是在多供应商平台支持下的首选选择。更多详情可以在
    [https://github.com/akarneliuk/pygnmi](https://github.com/akarneliuk/pygnmi) 找到。'
- en: Using gNMI in Go
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Go 中使用 gNMI
- en: For Go, gNMI is more mature and has better support compared to gNMI implementations
    for Python. There is only one library that can use gNMI in Go, which is called
    `openconfig-gnmi`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Go，gNMI 比Python的 gNMI 实现更为成熟，支持也更好。Go 中只有一个库可以使用 gNMI，称为 `openconfig-gnmi`。
- en: The `openconfig-gnmi` library was created in 2016/2017 by Google and is now
    supported under the GitHub `openconfig` group. More on this library can be found
    at [https://pkg.go.dev/github.com/openconfig/gnmi](https://pkg.go.dev/github.com/openconfig/gnmi).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`openconfig-gnmi` 库由 Google 在 2016/2017 年创建，现在在 GitHub `openconfig` 组下得到支持。更多关于这个库的信息可以在
    [https://pkg.go.dev/github.com/openconfig/gnmi](https://pkg.go.dev/github.com/openconfig/gnmi)
    找到。'
- en: 'Besides the `openconfig-gnmi` library, there are other libraries related to
    gNMI in Go that you might find useful. Here is a list of the major ones:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `openconfig-gnmi` 库之外，还有其他与 gNMI 相关的 Go 库可能对你有用。以下是主要的一些：
- en: '`google-gnxi` is a combination of tools that can be used with gNMI and gNOI.
    Details can be found at [https://github.com/google/gnxi](https://github.com/google/gnxi).'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`google-gnxi` 是一个可以与 gNMI 和 gNOI 一起使用的工具组合。详细信息可以在 [https://github.com/google/gnxi](https://github.com/google/gnxi)
    找到。'
- en: '`openconfig-gnmi-gateway` is a library that can be used for high-availability
    streaming to collect network data with multiple clients. Details can be found
    at [https://github.com/openconfig/gnmi-gateway](https://github.com/openconfig/gnmi-gateway).'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openconfig-gnmi-gateway` 是一个库，可用于通过多个客户端进行高可用性流式传输以收集网络数据。详细信息可以在 [https://github.com/openconfig/gnmi-gateway](https://github.com/openconfig/gnmi-gateway)
    找到。'
- en: '`openconfig-gnmic` is a CLI tool written in Go that you can use to test gNMI
    capabilities. The CLI implements all gNMI client capabilities. More details can
    be found at https://github.com/openconfig/gnmic.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openconfig-gnmic` 是一个用 Go 编写的 CLI 工具，你可以用它来测试 gNMI 功能。CLI 实现了所有 gNMI 客户端功能。更多详细信息可以在
    https://github.com/openconfig/gnmic 找到。'
- en: So far, we have covered the major and most popular libraries used to access
    network devices via several different methods. Further discussion on this topic
    can be found in open chat communities such as Slack groups. Examples include [https://devopschat.slack.com/](https://devopschat.slack.com/)
    and https://alldaydevops.slack.com/.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了通过几种不同的方法访问网络设备的主要和最受欢迎的库。关于这个主题的进一步讨论可以在 Slack 等聊天社区中找到。例如，包括
    [https://devopschat.slack.com/](https://devopschat.slack.com/) 和 https://alldaydevops.slack.com/。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dove deeper into Python and Go runtime behavior, investigated
    how libraries are added to both languages, and we saw a few examples of network
    libraries to use when accessing the network devices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 Python 和 Go 的运行时行为，研究了如何将库添加到这两种语言中，并展示了在访问网络设备时可以使用的一些网络库的示例。
- en: This chapter provided sufficient information to help you differentiate how Python
    and Go run and how they can be used with standard and third-party libraries. Now,
    you should be able to choose a proper language for your network automation based
    on the requirements of performance, security, maintainability, and reliability.
    You should also be able to choose a proper method and a library to access your
    network devices, either for configuration purposes or to collect network data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了足够的信息，帮助你区分 Python 和 Go 的运行方式以及它们如何与标准库和第三方库一起使用。现在，你应该能够根据性能、安全性、可维护性和可靠性要求选择合适的语言用于网络自动化。你也应该能够选择合适的方法和库来访问你的网络设备，无论是用于配置还是收集网络数据。
- en: In the next chapter, we are going to touch on how to handle errors in Go and
    Python, and how we can write code to handle exceptions properly in our network
    automation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在 Go 和 Python 中处理错误，以及我们如何编写代码来正确处理网络自动化中的异常。
