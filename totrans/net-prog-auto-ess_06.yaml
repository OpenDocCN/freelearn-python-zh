- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Go and Python for Network Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to see how Python and Go are powerful and used
    for network programming, but depending on what your requirements are and your
    environment, one might be better suited for you than the other. We are going to
    use Python and Go for network programming by checking the advantages and disadvantages
    of using each.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to identify which language (Python
    or Go) is more suitable for your network project and which library to use. You
    are going to learn the differences and superpowers of each language that will
    probably make the difference in your network automation work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we are going to cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Looking into the language runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing network devices using libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code described in this chapter is stored in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter were created and tested using a simple network
    device simulator. The instructions on how to download and run this simulator are
    included in the `Chapter06/Device-Simulator` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Looking into the language runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After writing your code and saving it, you are going to run it somewhere in
    your network. Go and Python have different ways to combine your source code and
    all imported libraries before running. Which one suits you more? Are there any
    relevant differences that are important to know? We’ll discuss that in this section.
  prefs: []
  type: TYPE_NORMAL
- en: What are compiled and interpreted languages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After writing your code, some computer languages need to be compiled to run
    on your machine, though some don’t as they are interpreted line by line as it
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: The languages that are compiled have to have a compiler that translates the
    source code into a series of bits and bytes that can run on the CPU architecture
    of your computer; it also has to link all static and dynamic system libraries.
    For instance, a computer with an Apple M1 processor will have a different compiler
    than an Apple with an Intel x86 processor. The result after the compilation is
    a binary program that can’t be read by humans and when it runs, it is loaded from
    disk to main memory.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have compiled, you don’t need to have your source code to run your
    program. The machine that runs your code does not need the compiler or the source
    code, only the compiled program binaries, which adds free space, code privacy,
    and code security.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, interpreted languages (as it stands) are interpreted by a
    code interpreter, which interprets your code line by line when it is running.
    These interpreted languages are also known as **scripting languages**. The machine
    that runs the interpreted language needs to have the interpreter and the source
    code, which unfortunately exposes the source code and needs additional space to
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of compiled languages include Go, C, C++, Haskel, and Rust. Examples
    of interpreted languages include Python, PHP, Unix Shell, JavaScript, and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Java is a special case because it has a compiler but compiles to its own **Java
    Virtual Machine** (**JVM**) architecture, which is not the CPU architecture where
    the program will run. Once compiled, you can use it anywhere but will need to
    install a JVM for the specific CPU architecture, adding extra storage and runtime
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Python interpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Python interpreter is sometimes called a Python virtual machine as a reference
    to a JVM, which can run anywhere. But Python does not provide a virtual machine
    like Java – it provides an interpreter, which is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, this virtual machine is like a virtual CPU that provides an environment
    for the Java bytecode-compiled program to run. The JVM translates the Java-compiled
    bytecode into the bytecode of the CPU architecture where it is running. So, Java
    code will need to be compiled first; then, the compiled program can run on any
    machine that has a JVM installed.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, the interpreter is much more complicated as it does not translate
    bytecode as it does in a JVM but interprets lines in a context with its surroundings.
    The interpreter reads the whole code and parses the syntax that must be decoded
    in the program’s context. Because of this complexity, this can be a very slow
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate some of the available Python interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: Using CPython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CPython** is one of the most common interpreter programs that is required
    to be installed in the machine where the Python code will run. CPython is written
    in C and is perhaps the first implementation of the Python interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: CPython is the place where new functionalities will be created before they can
    be exposed in Python. As an example, when concurrency was added to Python, it
    was first achieved by the CPython interpreter process using the operating system’s
    multitasking properties.
  prefs: []
  type: TYPE_NORMAL
- en: CPython implementations can be compiled into proprietary bytecode before being
    passed to the interpreter. The reason is that it is easier to create an interpreter
    based on a stack machine instruction set, even though an interpreter doesn’t need
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a CPython stack machine instruction set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `return_the_bigest` function is translated into the CPython
    bytecode shown, which will be used by the CPython interpreter when it’s run. Note
    that the instruction set does the same as the `return_the_bigest` function, which
    is harder for humans to read and easier for the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'More on disassembler Python bytecode can be found here: [https://docs.python.org/3/library/dis.html](https://docs.python.org/3/library/dis.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'More on CPython can be found here: [https://github.com/python/cpython](https://github.com/python/cpython).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Jython** is another Python interpreter that was created originally in 1997
    by Jim Hugunin as **JPython**. In 1999, JPython was renamed to Jython, as it is
    known today.'
  prefs: []
  type: TYPE_NORMAL
- en: Jython is used to compile Python code into a Java bytecode virtual machine that
    can run on any hardware that has a JVM installed. Sometimes, it can run faster
    as it does not need to be interpreted like CPython.
  prefs: []
  type: TYPE_NORMAL
- en: Although the project started with high expectations, today, it only supports
    Python 2.7, and the support for Python 3.x is still under development. Therefore,
    you are only going to need Jython if you are running your code on a machine that
    only supports JVMs. There will also be lots of limitations as it only supports
    Python version 2.7, which is no longer supported by the Python community and was
    deprecated in January 2020.
  prefs: []
  type: TYPE_NORMAL
- en: 'More on Jython can be found here: [https://github.com/jython/jython](https://github.com/jython/jython).'
  prefs: []
  type: TYPE_NORMAL
- en: Using PyPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PyPy** is another Python interpreter implementation that claims to run Python
    code faster than CPython. PyPy also claims to handle concurrency better than CPython
    with the usage of micro-threads. And finally, it claims to use less memory than
    CPython.'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the great advantages of PyPy, CPython is still the most used Python
    interpreter, mainly because people don’t know about PyPy and the default Python
    installation uses CPython.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyPy has a website dedicated to comparing its speed with other interpreters,
    such as CPython. The website also has comparisons with other versions of PyPy.
    *Figure 6.1* shows a comparison between CPython and PyPy with information taken
    from the PyPy speed website. On average, PyPy is 4 times faster than CPython:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org](img/B18165_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – CPython and PyPy comparison taken from speed.pypy.org
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure contains blue bars, which represent how a specific benchmark
    runs in PyPy 3.9 in comparison to CPython 3.7.6\. As an example, the `bm_dulwich_log`
    benchmark runs twice as fast compared to CPython (0.5). The sixth blue bar shows
    that PyPy runs slower for the `bm_mdp` benchmark (1.3), but for the second blue
    bar, which represents the `chaos` benchmark, PyPy runs up to 20 times faster.
    Details about each benchmark can be obtained at [https://speed.pypy.org/](https://speed.pypy.org/).
  prefs: []
  type: TYPE_NORMAL
- en: For more on PyPy, check its home page at [https://www.pypy.org/](https://www.pypy.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Cython
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although some people compare PyPy with **Cython**, Cython is not a Python interpreter
    like PyPy. Cython is a compiler that can be used with the Python and Cython languages,
    which is based on **Pyrex**, a superset of the Python language. Cython can add
    C and C++ extensions easily to your code. As it is implemented in C, the Cython
    code claims to be faster than Python when using PyPy.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you are looking to write Python code and require high performance,
    try Cython. More on Cython can be found at [https://cython.org/](https://cython.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Using IPython and Jupyter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The major advantage of an interpreted language is that it can run interactively
    easier. Python has an interpreter for this called **IPython**.
  prefs: []
  type: TYPE_NORMAL
- en: IPython can be used to run your code gradually line by line and then check what
    happens in memory. This is useful when testing or trying a new code or function.
    It is also quite handy to get results as the program runs and adapts the code
    to suit your desired output during code development.
  prefs: []
  type: TYPE_NORMAL
- en: In conjunction with IPython, you can use a **Jupyter** notebook, which is a
    web interface that’s easy to use and has graphical output capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine you need to gather information from 100 network nodes
    on CPU usage on the network and make a graphical report for the last hour. How
    could you do that quickly without worrying about building or testing? The best
    platform you can use is Jupyter notebook with IPython.
  prefs: []
  type: TYPE_NORMAL
- en: IPython and Jupyter are also frequently used for data science and machine learning,
    because of their advantages in terms of interactive methods and graphical interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For our network programming, IPython is a powerful tool to create **Proof of
    Concept** (**PoC**) coding and test new functionalities when creating solutions
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: More on IPython can be found at [https://ipython.org/](https://ipython.org/).
    More on Jupyter can be found at [https://jupyter.org/](https://jupyter.org/).
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have looked at the major Python interpreters. Now, let’s look
    at how Go works.
  prefs: []
  type: TYPE_NORMAL
- en: Go compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Go language development, there is no code interpretation like in Python code;
    instead, there’s compilation. This compilation is done by the Go compiler, which
    normally comes with the Go language package. The compiler reads the source code
    and then translates it into the bytecode of the CPU architecture where this program
    is going to be executed. When executing the compiled code, there is no need to
    have the compiler or the source code, only the compiled binary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this compilation, Go programs run faster than Python-based programs
    – in some cases, they can run 30 to 100 times faster, especially when dealing
    with concurrency. As an example, the `fannkuch-redux` benchmark, which is used
    to test multicore parallelism, takes 8 seconds to run in Go, whereas it takes
    5 minutes to run in Python (source: [https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html](https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/fannkuchredux.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Although the Go language distribution provides the compiler, the Go community
    has started other projects as alternatives for the Go compiler. One of them is
    called **TinyGo**, which is used when the compiled code does not have much memory
    to be stored, such as in small microcontrollers or small computers. Therefore,
    TinyGo is used when memory space in the running target computer is limited. More
    on TinyGo can be found at [https://github.com/tinygo-org/tinygo](https://github.com/tinygo-org/tinygo).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s compare both languages in terms of computing runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of programming runtimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s explore the pros and cons of using Go and Python for programming while
    focusing on the code that will run on the machine during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros of using the Python runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to create PoC code by using interactive Python with IPython and Jupyter
    notebooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to create data visualization during prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a large community with different interpreters, libraries, and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons of using the Python runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumes more space and memory on the target running machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumes more CPU and is slower to complete tasks compared to Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is visible on the target running machine, which can be unsecure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime parallelism implementation is weak compared to Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pros of using the Go runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Consumes less memory and space on the target running machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumes less CPU and runs faster than Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is compiled, which is not human readable and can’t easily be decoded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime parallelism implementation is much better than Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons of using the Go runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: More difficult to create prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A smaller development community and fewer runtime libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For network programming, Go has much more benefits compared to Python in terms
    of performance. However, as Python is an older language, it has a broader community
    with more network libraries and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: So, choosing which language to use will depend on the use case you are working
    on. If you want something quick and wish to write less code by reusing someone
    else’s library, then Python is probably the best fit. But if you want something
    that has more performance, is secure, uses less memory, and can be built as one
    binary program, Go is your best fit. As the Go community grows, it will probably
    have more libraries that can help with network automation over time, but as it
    stands today, Python has more community contributions in the network automation
    field.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn how we can add external libraries to our code
    in Go and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing network automation, it is always worth researching tools and
    libraries in the community to see if you can incorporate some external code that
    will add functionalities or speed up your development process.
  prefs: []
  type: TYPE_NORMAL
- en: In preparation to explain how to use third-party libraries, it is important
    to understand how libraries in general are used in Python and Go. We’ll detail
    the library-adding process in Python and Go in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Python libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before discussing how libraries are added to Python, it is important to explain
    that, in Python, a **library** is also known as a **package** or a **module**.
    These three terms are used widely throughout Python documentation, which can make
    some new Python developers confused. So, whenever you see the term “Python library”,
    it can also mean a package or a module.
  prefs: []
  type: TYPE_NORMAL
- en: A library in Python can be external, internal, or built-in. These external libraries
    are also known as third-party modules, packages, or libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a library in Python, you just need to use the `import` statement at
    the beginning of the code. If the library is not found, it will raise an error
    exception called `ModuleNotFoundError`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the Python interpreter threw an exception called
    `ModuleNotFoundError`, which means the package is not installed or is not in the
    search path. The search path is normally included in the `path` variable inside
    the `sys` package, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding example, the `sys.path` variable has been pre-filed
    with a list of system paths, but you can append more if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss how the built-in, standard, and external modules are used
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python built-in libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The built-in modules (or libraries) are modules that can be imported, but they
    come within the Python runtime program. They are not external files to be added,
    so they don’t need to be found in the `sys.path` variable. There are also built-in
    functions, such as `print`, but built-in modules are the ones that you are going
    to explicitly import before using them, such as the popular one known as `sys`,
    or others such as `array` and `time`. These built-in modules are not external
    programs like they are in Python standard libraries, but they are included in
    the binary code of the interpreter, like in CPython.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python standard libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are modules that come with the Python distribution, but they are separate
    Python files that are added when you state `import` at the beginning of the Python
    code; they need to be found in the `sys.path` variable. These modules are Python
    programs and can be found in the Python library installation directory, such as
    the `socket` library, as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `/usr/lib/pytho3.10/socket.py` location will depend on the operating
    system and version of Python. In the preceding example, Linux Ubuntu and Python
    3.10 are being used. A list of all standard libraries for Python 3.10.x can be
    found at [https://github.com/python/cpython/tree/3.10/Lib](https://github.com/python/cpython/tree/3.10/Lib).
    More information about each built-in and standard library for Python 3.x can be
    found at [https://docs.python.org/3/library/](https://docs.python.org/3/library/).
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party Python libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External libraries or third-party libraries are modules (or packages) in Python
    that are not included with the Python distribution and need to be installed manually
    before they’re used. These modules are normally not maintained by the Python library
    team but by developers of the Python community, which are not necessarily related
    to the Python main distribution.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127), before adding
    the external module to your code, have a look in the `LICENSE` file and check
    if any limitations might impact the usage of this module on your code or in your
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: The Python community has organized a group called `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: PyPA is also responsible for maintaining [pypi.org](http://pypi.org), where
    all packages that can be included with `pip` are documented. On this site, there
    is a search engine for finding packages and also documentation for developers
    that want to contribute or share their packages. Note that the source code for
    the packages is not on the [pypi.org](http://pypi.org) site, but in repositories
    such as **GitHub**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go through an example of the process of using a third-party package
    in our code. The package that we are adding as an example is called `netmiko`:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the package is included on [pypi.org](http://pypi.org) as per PyPA.
    If so, we can use `pip` to add the package to our local Python environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Yes, it is: [https://pypi.org/project/netmiko/](https://pypi.org/project/netmiko/).'
  prefs: []
  type: TYPE_NORMAL
- en: Read the `LICENSE` file and check if it is allowed to be used in your organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This license is based on MIT, which is less restrictive, so we can use it:
    [https://github.com/ktbyers/netmiko/blob/develop/LICENSE](https://github.com/ktbyers/netmiko/blob/develop/LICENSE).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `pip` to install the package to your local Python environment, as shown
    in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if you can import and locate where the `netmiko` library is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, the `netmiko` package has been installed using the
    `pip` tool, and the library is located under my home directory, `/home/claus`.
    However, this varies, depending on the version of Python and the operating system
    used. It also varies within Linux, depending on the distribution, such as Debian,
    Ubuntu, or Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just keep in mind that third-party Python libraries will be installed normally
    under a directory called `site-packages`. Here are some examples of where it can
    be located for each operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS: `/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/site-packages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Windows: `C:\Users\username\AppData\Local\Programs\Python\Python39\lib\site-packages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Linux Ubuntu: `/usr/lib/python3.9/site-packages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A complete list of all packages that you have installed on your system can
    be found by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s explore how we can use libraries and third-party libraries in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Go libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast with Python, Go only has two types of libraries: the standard libraries
    and the third-party libraries. For Go, there is no concept of built-in libraries
    because it does not have an interpreter; instead, it has a compiler. The reason
    is that an interpreter can include a few libraries in its binary, which are called
    built-in libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: To add a library to your Go code, you will need to use the `import` statement,
    which is the same in Python but the syntax is a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Python, in Go, a library is also known as a **package**.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at how to add standard libraries and then third-party libraries
    in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Using standard libraries in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each version of Go includes a set of standard libraries that are installed with
    the Go distribution. These standard libraries are also Go programs that, when
    imported, will be combined with your code during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: A list of standard libraries can be found at [https://pkg.go.dev/std](https://pkg.go.dev/std).
    The website is very useful because it includes an explanation of each library
    (or package).
  prefs: []
  type: TYPE_NORMAL
- en: The standard libraries can also be found in your local development filesystem.
    Go’s installation includes all standard libraries, such as the `fmt` and `math`
    packages. The location of these standard libraries will vary for each operating
    system but can be found by looking into the `GOROOT` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operating systems do not populate the `GOROOT` variable, so they will
    use the Go language’s default location. To find out your default location, you
    can run the `go env` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `GOROOT` is located in `/usr/lib/go-1.19`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how the libraries are located, let’s use the `fmt` standard library
    to print a string to the computer terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `import` statement tells the Go compiler that
    it needs to add the `fmt` package, which in this case is a standard library package.
    In this example, the Go compiler will search for this package, starting by looking
    in the `/usr/lib/go-1.19` directory.
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, the `fmt` package is located at `/usr/lib/go-1.19/src/fmt`.
    The `Println` function that’s being used in this example is described in the `/usr/lib/go-1.19/src/fmt/print.go`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, all programs have to belong to a package, and the package name is described
    in the first line of the code. In the `fmt` directory (`/usr/lib/go-1.19/src/fmt`),
    all the files included in the directory have a first line that contains the `package
    fmt` statement. This includes the `scan.go`, `format.go`, and `print.go` files,
    which are located in the `fmt` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of standard libraries in Go can be found in your local Go installation,
    normally under the `src` directory. In the preceding example, it is under `/usr/lib/go-1.19/src`.
    Some other examples include the `math` package, located at `/usr/lib/go-1.19/src/math/`,
    and the `time` package, located at `/usr/lib/go-1.19/src/time/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example, which uses the `math` standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `math` library uses the `Sqrt` function, which
    is described in the `/usr/lib/go-1.19/src/math/sqrt.go` file. Again, all the files
    in the `math` directory have the `package math` statement on their first line.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to add third-party libraries to Go.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party libraries in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Third-party library packages in Go are added in a similar way to standard libraries
    – by using the `import` statement in your code. However, the underlying process
    of adding these packages to the Go development environment is a bit different
    in terms of a few characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of third-party packages, the compiler needs to search for new files
    containing the package in a different path, which is populated in the `GOPATH`
    environment variable. Like `GOROOT`, you don’t need to populate `GOPATH` as the
    Go compiler has a default location for the `GOPATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our Go example, let’s check the default location for `GOPATH` by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the default location for `GOPATH` is the `go` directory inside
    my home directory (`/home/claus`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, third-party libraries can be added by invoking the `get` subcommand
    on the `go` command line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we added the `x/crypto` package. Note that all other
    dependencies of the package are also added; in this example, the other dependency
    is `x/sys`. The `get` subcommand also stores the version of the package – in this
    case, `v0.0.0-20220622213112-05595931fe9d`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the package is saved under the `GOPATH` directory. In the preceding example,
    it is saved at `/home/claus/go/pkg/mod/golang.org/x/crypto@<VERSION>`.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you run `go get` and there is a new version available, Go stores
    the new version and keeps the old one in a different directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to run `go get` when adding a third-party library. The `get`
    command is sometimes invoked when you run `go build` if the package has not been
    downloaded or cached, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the Go program had an `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding a third-party library, Go also updates the `go.mod` file. This
    file is required to keep track of the versions of the packages that are added
    to your Go program. The following is the content of the `go.mod` file for the
    preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `go.mod` file also stores the versions of the packages for all
    dependencies. In the preceding example, the `x/sys` package version is also stored
    in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with adding third-party libraries to Go and Python,
    let’s dive into the next section and look at some libraries that can be used to
    access the network.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing network devices using libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed how to run and work with libraries in Python and Go.
    Now, let’s focus on how to use Python and Go to access network devices, which
    is one of the most important points in our network automation work.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), we discussed several methods
    to access network devices. One of the most popular ones is using a **command-line
    interface** (**CLI**). We also discussed SNMP, NETCONF, gRPC, and gNMI. In this
    section, we are going to explore a few examples of how to use libraries to access
    network devices, mainly using the CLI. Later, we are going to explain and show
    the libraries for accessing the network using other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access the network via a CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of libraries on the internet that can access network devices,
    and some of them might be obsolete or not used anymore. Here, we are going to
    present the most popular ones in chronological order, from the old to the newer
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples are going to collect the uptime of the network device
    by sending the `uptime` command via the CLI on an SSH connection.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python Paramiko
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Paramiko is perhaps one of the oldest implementations for accessing network
    devices via the CLI. The first release was published in 2003\. Today, it has more
    than 300 contributors and there are almost 2,000 packages depending on Paramiko
    ([https://github.com/paramiko/paramiko/network/dependents](https://github.com/paramiko/paramiko/network/dependents)).
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), the correct
    way to use CLI libraries is via **Secure Shell** (**SSH**). Paramiko implements
    secure cryptography for SSH using a lower-level library called PyCrypto ([http://pycrypto.org/](http://pycrypto.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example to obtain the uptime of the network host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the connection is successful, the output of the preceding program will be
    the uptime of the network host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using Python Netmiko
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Netmiko is also another popular library for accessing network devices via the
    CLI. The first release was published in 2014 and was built on top of Paramiko
    to simplify connections to network devices. In summary, Netmiko is simpler than
    Paramiko and more focused on network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn what the same example for Paramiko will look like when using Netmiko:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation of the Netmiko code is just 2 lines, with
    much smaller and simpler code compared to Paramiko. The big advantage of the Netmiko
    library is that it handles the device’s command prompt automatically and works
    with ease when changing the configuration in privilege mode since the prompt normally
    changes. In the preceding example, the device type was `linux_ssh` because our
    target host was a Linux device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Netmiko can support dozens of network devices, including Cisco, Huawei, Juniper,
    and Alcatel. A complete list of devices can be found here: [https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md](https://github.com/ktbyers/netmiko/blob/develop/PLATFORMS.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Python AsyncSSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AsyncSSH is a modern implementation of Python **AsyncIO** for SSH. Python AsyncIO
    was introduced in Python version 3.4 and allows Python to work concurrently using
    async/await syntax and provides high performance for network access. To use AsyncSSH,
    you will need to have Python version 3.6 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, AsyncSSH provides better performance for multiple hosts, but it
    is a lower-level implementation that requires more complexity in your code to
    handle network devices in comparison to Netmiko.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same example of getting uptime for AsyncSSH can be written like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using AsyncSSH, you will have to work with routines and events,
    as instructed by Python AsyncIO and the preceding example. If you want to dig
    into this, some great documentation can be found at https://realpython.com/async-io-python/.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python Scrapli
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In comparison to Netmiko, Scrapli is newer. The first release was published
    in 2019 and is also built on top of Paramiko but has capabilities to use AsyncSSH,
    which claims to improve performance when accessing multiple devices. The idea
    of the name Scrapli came from *scrape cli*, similar to someone scraping the screen.
    This is because Scrapli’s main objective is to interpret text from the network
    terminal using the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Scrapli was built to allow its users to interpret prompts from multi-vendor
    network devices such as Netmiko but with a reduced set of platforms. The 2022.7.30
    version supports Cisco, Juniper, and Arista. One advantage of using Scrapli is
    that it also supports NETCONF.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the same example to get uptime but using Scrapli:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have learned about the most popular libraries for accessing network
    terminals using Python. Now, let’s learn we can do this with the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go ssh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to Python, Go does not have a large community for working with libraries
    that can handle network devices. Therefore, in some particular cases, you might
    have to write your own scrape mechanism to interpret the remote network terminal
    via the CLI. The problem with doing this yourself is it will be different for
    each network vendor and will take more coding time as you add different network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of getting uptime from the remote network host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the preceding example contains much more code than some higher-level
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go vSSH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a library in Go called vSSH, which is built on top of `golang.org/x/crypto`
    by engineers at Yahoo. It creates an abstraction for accessing remote terminals
    on network devices, which avoids the code that we saw previously with the SSH
    example.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main claims of vSSH is that it can handle access to multiple targets
    with high performance, which is obtained by using Go routines (a great beginner’s
    guide for Go routines can be found at [https://go.dev/tour/concurrency/1](https://go.dev/tour/concurrency/1)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although vSSH can handle multiple targets efficiently, let’s start by writing
    an example that uses only one target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Go routines have been used in this example. Additional targets can be added
    using `vs.AddClient()` before calling `vs.Wait()`. In our example, only one target
    was added to get the uptime of the remote network host. The loop at the end is
    not necessary for only one target, but I left it there to demonstrate how to use
    it with multiple targets.
  prefs: []
  type: TYPE_NORMAL
- en: As we can have one host that might be faulty or slow when using multiple targets,
    a parse timeout is used, which in our example is 4 seconds. The preceding example
    uses a channel via the `rChannel` variable to obtain the results of the Go routines
    for each target.
  prefs: []
  type: TYPE_NORMAL
- en: Using Go Scrapligo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scrapligo is a Go version of the successful Python library Scrapli. It supports
    the same network platforms and also supports NETCONF. The advantages of using
    Scrapligo over Scrapli are the ones we discussed earlier in this chapter related
    to how Go and Python runtime perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example in Scrapligo would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have just discussed how to access network devices via the CLI using Python
    and Go libraries. Now, let’s learn how to use libraries to access the network
    using other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access networks using SNMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Excluding the CLI, the second most popular network device access method is SNMP.
    But as we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), SNMP is
    only used to read information from network devices. The SNMP write method is not
    used for the reasons discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067).
  prefs: []
  type: TYPE_NORMAL
- en: For the SNMP examples, we are going to pick up one library from Python and one
    from Go. These libraries are the most popular ones for using the SNMP method today.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous subsection, we used CLI methods to collect the uptime of the
    network device. We are going to demonstrate now that we can also get the uptime
    of the remote network device by using the SNMP method. For that, we need to collect
    the `SNMPv2-MIB::sysUpTime` MIB variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python PySNMP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PySNMP is the most popular library for Python for the SNMP method. It supports
    all versions of SNMP from version 1 to version 3\. The following is an example
    of using the SNMP method to obtain the uptime of the network device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The output will be `SNMPv2-MIB::sysUpTime.0 = 72515`.
  prefs: []
  type: TYPE_NORMAL
- en: More on PySNMP can be found at [https://pysnmp.readthedocs.io/en/latest/](https://pysnmp.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Using gosnmp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For Go, the most popular library for the SNMP method is `gosnmp`. It also supports
    version 1 to version 3 of the SNMP protocol. Compared to PySNMP, `gosnmp` is newer
    but has more developers and more users, making it more reliable in terms of future
    development. The following is an example of collecting uptime from a network device
    using the SNMP method in Go. In this example, the OID number (`1.3.6.1.2.1.1.3.0`)
    represents the same as `SNMPv2-MIB::sysUpTime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be `oid: .1.3.6.1.2.1.1.3.0 : 438678`.'
  prefs: []
  type: TYPE_NORMAL
- en: More on `gosnmp` can be found at [https://pkg.go.dev/github.com/gosnmp/gosnmp](https://pkg.go.dev/github.com/gosnmp/gosnmp).
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access networks using NETCONF or RESTCONF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing configuration to the network devices, the preferred method would
    be NETCONF or RESTCONF. However, some devices or some functions of the device
    might not have it implemented yet. In this case, the most appropriate method would
    be via a CLI as SNMP is not used to write data on the device.
  prefs: []
  type: TYPE_NORMAL
- en: The RESTCONF/NETCONF methods are newer methods to access network devices compared
    to a CLI or SNMP. Because of that, there are not many libraries available. Today,
    the best library to use NETCONF in Python would be Scrapli; for Go, this would
    be Scrapligo.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using Python Scrapli with NETCONF can be found at [https://scrapli.github.io/scrapli_netconf/](https://scrapli.github.io/scrapli_netconf/).
  prefs: []
  type: TYPE_NORMAL
- en: Examples of using Go Scrapligo with NETCONF can be found at [https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics](https://github.com/scrapli/scrapligo/tree/main/examples/netconf_driver/basics).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a plain HTTP library to collect information using RESTCONF,
    as shown in the following Python example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s learn how to use Python and Go to access networks using gRPC and
    gNMI.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries to access networks using gRPC and gNMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the other methods, gRPC is quite new and network device vendors
    have added this capability in recent years. So, if you have old devices in your
    network, you might not be able to use gRPC or gNMI.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 3*](B18165_03.xhtml#_idTextAnchor067), gRPC is
    a more generic method, and gNMI is more specific for network interfaces. The main
    use of gNMI is network telemetry by invoking the underlying gRPC streaming subscription
    capability. Using gNMI allows your network code to scale easily and collect much
    more network management data compared to SNMP. The gNMI libraries are built on
    top of the gRPC protocol.
  prefs: []
  type: TYPE_NORMAL
- en: All major network device vendors have some sort of gRPC and/or gNMI implementation
    on their newer network operating systems. Among them are Cisco, Juniper, Arista,
    Nokia, Broadcom, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only newer versions of Python support gRPC, and the Python version has to be
    3.7 or above. To use it, you need to install `grpcio` ([https://pypi.org/project/grpcio/](https://pypi.org/project/grpcio/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of using gRPC in Python can be obtained here: [https://grpc.io/docs/languages/python/quickstart/](https://grpc.io/docs/languages/python/quickstart/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go, gRPC can run on any major version. It is well documented and several
    examples can be found at [https://github.com/grpc/grpc-go](https://github.com/grpc/grpc-go).
  prefs: []
  type: TYPE_NORMAL
- en: Using gNMI in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python support for gNMI is particularly rare. There are not many libraries
    available in the Python community. The following list describes the major ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cisco-gnmi-python` was created in 2018 and was initially supported by Cisco
    Networks. The library was created by Cisco to foment the use of gNMI on Cisco
    devices, and perhaps not a good match for multi-vendor support. More details can
    be found at [https://github.com/cisco-ie/cisco-gnmi-python](https://github.com/cisco-ie/cisco-gnmi-python).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gnmi-py` was created in 2019 and is sponsored by Arista Networks. This library
    does not support multi-vendor platforms and can be only used for Arista devices.
    More details can be found at [https://github.com/arista-northwest/gnmi-py](https://github.com/arista-northwest/gnmi-py).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyygnmi` was created in 2020\. The library can be imported using `pip` and
    has been tested on Cisco, Arista, Juniper, and Nokia devices. This would be the
    preferred choice for multi-vendor platform support. More details can be found
    at [https://github.com/akarneliuk/pygnmi](https://github.com/akarneliuk/pygnmi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gNMI in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Go, gNMI is more mature and has better support compared to gNMI implementations
    for Python. There is only one library that can use gNMI in Go, which is called
    `openconfig-gnmi`.
  prefs: []
  type: TYPE_NORMAL
- en: The `openconfig-gnmi` library was created in 2016/2017 by Google and is now
    supported under the GitHub `openconfig` group. More on this library can be found
    at [https://pkg.go.dev/github.com/openconfig/gnmi](https://pkg.go.dev/github.com/openconfig/gnmi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `openconfig-gnmi` library, there are other libraries related to
    gNMI in Go that you might find useful. Here is a list of the major ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`google-gnxi` is a combination of tools that can be used with gNMI and gNOI.
    Details can be found at [https://github.com/google/gnxi](https://github.com/google/gnxi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openconfig-gnmi-gateway` is a library that can be used for high-availability
    streaming to collect network data with multiple clients. Details can be found
    at [https://github.com/openconfig/gnmi-gateway](https://github.com/openconfig/gnmi-gateway).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openconfig-gnmic` is a CLI tool written in Go that you can use to test gNMI
    capabilities. The CLI implements all gNMI client capabilities. More details can
    be found at https://github.com/openconfig/gnmic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have covered the major and most popular libraries used to access
    network devices via several different methods. Further discussion on this topic
    can be found in open chat communities such as Slack groups. Examples include [https://devopschat.slack.com/](https://devopschat.slack.com/)
    and https://alldaydevops.slack.com/.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deeper into Python and Go runtime behavior, investigated
    how libraries are added to both languages, and we saw a few examples of network
    libraries to use when accessing the network devices.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided sufficient information to help you differentiate how Python
    and Go run and how they can be used with standard and third-party libraries. Now,
    you should be able to choose a proper language for your network automation based
    on the requirements of performance, security, maintainability, and reliability.
    You should also be able to choose a proper method and a library to access your
    network devices, either for configuration purposes or to collect network data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to touch on how to handle errors in Go and
    Python, and how we can write code to handle exceptions properly in our network
    automation.
  prefs: []
  type: TYPE_NORMAL
