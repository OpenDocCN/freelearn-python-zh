<html><head></head><body>
<div><div><div><h1 id="_idParaDest-384"><em class="italic"><a id="_idTextAnchor365"/>Chapter 25</em>: The Command Pattern</h1>
			<p>In this chapter, we will cover the <strong class="bold">command pattern</strong>. Using this design pattern, we can encapsulate an operation, such as <em class="italic">copy and paste</em>, as an object. The command pattern is also great for grouping multiple commands. It's useful for implementing macros, multilevel undoing, and transactions. Throughout our discussions, we will learn about the idea of treating an operation as an object and use this command mindset to handle application transactions.</p>
			<p>We will discuss the following:</p>
			<ul>
				<li>Understanding the command pattern</li>
				<li>Real-world examples</li>
				<li>Use cases</li>
				<li>Implementation</li>
			</ul>
			<h1 id="_idParaDest-385"><a id="_idTextAnchor366"/>Technical requirements</h1>
			<p>The code files for this chapter can be accessed through this link: <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter25</a>.</p>
			<h1 id="_idParaDest-386"><a id="_idTextAnchor367"/>Understanding the command pattern</h1>
			<p>Most applications nowadays<a id="_idIndexMarker1404"/> have an <strong class="bold">undo</strong> operation. It is hard to imagine, but undo did not exist in any software<a id="_idIndexMarker1405"/> for many years. Undo was introduced in 1974 (<a href="http://j.mp/wiundo">j.mp/wiundo</a>), but Fortran and Lisp, two programming languages that are still widely used, were created in 1957 and 1958, respectively (<a href="http://j.mp/proghist">j.mp/proghist</a>)! The user had no easy way to fix a mistake. I wouldn't like to have been an application user during those years.</p>
			<p>Enough with the history! We want to know how we can implement the undo functionality in our applications, and since you have read the title of this chapter, you already know which design pattern is recommended to implement undo: the command pattern.</p>
			<p>The command design<a id="_idIndexMarker1406"/> pattern helps us encapsulate an operation (undo, redo, copy, paste, and so forth) as an object. What this simply means is that we create a class that contains all the logic and the methods required to implement the operation. The advantages<a id="_idIndexMarker1407"/> of doing this are as follows (<a href="http://j.mp/cmdpattern">j.mp/cmdpattern</a>):</p>
			<ul>
				<li>We don't have to execute a command directly. It can be executed at will.</li>
				<li>The object that invokes the command is decoupled from the object that knows how to perform it. The invoker does not need to know any implementation details about the command.</li>
				<li>If it makes sense, multiple commands can be grouped to allow the invoker to execute them in order. This is useful, for instance, when implementing a multilevel undo command.</li>
			</ul>
			<p>As you can imagine, this pattern has a wide range of use cases in the real world, which we will see in the next section.</p>
			<h1 id="_idParaDest-387"><a id="_idTextAnchor368"/>Real-world examples</h1>
			<p>When we go to a restaurant<a id="_idIndexMarker1408"/> for dinner, we give the order to the waiter. The order pad (usually paper) that they use to write the order is an example of a command. After writing the order, the waiter places it in the queue that is executed by the cook. Each check is independent and can be used to execute many different commands, for example, one command for each item that will be cooked.</p>
			<p>As you would expect, we also have several examples in software. Here are two I can think of:</p>
			<ul>
				<li>PyQt is the Python binding of the QT toolkit. PyQt contains a <code>QAction</code> class that models an action as a command. Extra optional information is supported for every action, such as description, tooltip, or shortcut (<a href="http://j.mp/qaction">j.mp/qaction</a>).</li>
				<li>Git Cola (<a href="http://j.mp/git-cola">j.mp/git-cola</a>), a Git GUI written in Python, uses the Command pattern to modify the model, amend a commit, apply a different election, check out, and so forth (<a href="http://j.mp/git-cola-code">j.mp/git-cola-code</a>).</li>
			</ul>
			<p>Let's now be more general and discuss when<a id="_idIndexMarker1409"/> the command pattern will prove useful in the next section.</p>
			<h1 id="_idParaDest-388"><a id="_idTextAnchor369"/>Use cases</h1>
			<p>Many developers use the undo example as the only use case<a id="_idIndexMarker1410"/> of the command pattern. The truth is that undo is the killer feature of the command pattern. However, the command pattern can actually do much more (<a href="http://j.mp/commddp">j.mp/commddp</a>):</p>
			<ul>
				<li><strong class="bold">GUI buttons and menu items</strong>: The PyQt example that was already mentioned uses<a id="_idIndexMarker1411"/> the command pattern to implement actions on buttons<a id="_idIndexMarker1412"/> and menu items.</li>
				<li><strong class="bold">Other operations</strong>: Apart from undo, commands<a id="_idIndexMarker1413"/> can be used to implement any operation. A few examples are cut, copy, paste, redo, and capitalize text.</li>
				<li><strong class="bold">Transactional behavior and logging</strong>: Transactional behavior and logging are important<a id="_idIndexMarker1414"/> to keep a persistent<a id="_idIndexMarker1415"/> log of changes. They are used by operating systems to recover from system crashes, relational databases to implement transactions, filesystems to implement snapshots, and installers (wizards) to revert canceled installations.</li>
				<li><strong class="bold">Macros</strong>: By macros, in this case, we mean<a id="_idIndexMarker1416"/> a sequence of actions that can be recorded and executed on demand at any point in time. Popular editors such as Emacs and Vim support macros.</li>
			</ul>
			<p>To demonstrate what we have discussed so far, we will implement a file utility management application next.</p>
			<h1 id="_idParaDest-389"><a id="_idTextAnchor370"/>Implementation</h1>
			<p>In this section, we will use the command pattern<a id="_idIndexMarker1417"/> to implement the most basic file utilities:</p>
			<ul>
				<li>Creating a file and optionally writing text (a string) to it</li>
				<li>Reading the contents of a file</li>
				<li>Renaming a file</li>
				<li>Deleting a file</li>
			</ul>
			<p>We will not implement these utilities from scratch, since Python already offers good implementations of them in the <code>os</code> module. What we want is to add an extra abstraction level on top of them so that they can be treated as commands. By doing this, we get all the advantages offered by commands.</p>
			<p>From the operations shown, renaming a file and creating a file support undo. Deleting a file and reading the contents of a file do not support undo. Undo can actually be implemented on delete file operations. One technique is to use a special trash/wastebasket directory that stores all the deleted files so that they can be restored when the user requests them. This is the default behavior used on all modern desktop environments and is left as an exercise to you.</p>
			<p>Each command has two parts:</p>
			<ul>
				<li><code>__init__()</code> method and contains all the information<a id="_idIndexMarker1418"/> required by the command to be able to do something useful (the path of a file, the contents that will be written to the file, and so forth).</li>
				<li><code>execute()</code> method. We call the <code>execute()</code> method when<a id="_idIndexMarker1419"/> we want to actually run a command. This is not necessarily right after initializing it.</li>
			</ul>
			<p>Let's start with the rename utility, which is implemented using the <code>RenameFile</code> class. The <code>__init__()</code> method accepts the source (<code>src</code>) and destination (<code>dest</code>) file paths as parameters (strings). If no path separators are used, the current directory is used to create the file. An example of using a path separator is passing the <code>/tmp/file1</code> string as <code>src</code> and the <code>/home/user/file2</code> string as <code>dest</code>. Another example, where we would not use a path, is passing <code>file1</code> as <code>src</code> and <code>file2</code> as <code>dest</code>:</p>
			<pre>class RenameFile:
     def __init__(self, src, dest):  
         self.src = src
         self.dest = dest</pre>
			<p>We add the <code>execute()</code> method to the class. This method<a id="_idIndexMarker1420"/> does the actual renaming using <code>os.rename()</code>. The <code>verbose</code> variable<a id="_idIndexMarker1421"/> corresponds to a global <code>print()</code> is good enough for an example, normally something more mature and powerful can be used, for example, the logging module (<a href="http://j.mp/py3log">j.mp/py3log</a>):</p>
			<pre>    def execute(self):  
        if verbose:  
            print(f"[renaming '{self.src}' to \
              '{self.dest}']")  
        os.rename(self.src, self.dest)</pre>
			<p>Our rename utility (<code>RenameFile</code>) supports the undo operation through its <code>undo()</code> method. In this case, we use <code>os.rename()</code> again to revert the name of the file to its original value:</p>
			<pre>    def undo(self):  
        if verbose:  
            print(f"[renaming '{self.dest}' back to \
              '{self.src}']")  
        os.rename(self.dest, self.src)</pre>
			<p>In this example, deleting a file is implemented in a function, instead of a class. That is to show it is not mandatory to create a new class for every command that you want to add (more on that will be covered later). The <code>delete_file()</code> function accepts a file path as a string and uses <code>os.remove()</code> to delete it:</p>
			<pre>def delete_file(path):
    if verbose:
        print(f"deleting file {path}")
    os.remove(path)</pre>
			<p>Back to using classes again. The <code>CreateFile</code> class is used to create a file. The <code>__init__()</code> method for that class<a id="_idIndexMarker1422"/> accepts the familiar <code>path</code> parameter and a <code>txt</code> parameter for the content (a string) that will be written to the file. If nothing is passed as <code>txt</code>, the default <code>hello world</code> text is written to the file. Normally, the same default behavior is to create an empty file, but for the needs of this example, I decided to write a default string in it.</p>
			<p>The definition of the <code>CreateFile</code> class starts as follows:</p>
			<pre>class CreateFile:
 
    def __init__(self, path, txt='hello world\n'):  
        self.path = path 
        self.txt = txt</pre>
			<p>Then we add an <code>execute()</code> method, in which we use the <code>with</code> statement and Python's <code>open()</code> built-in function to open the file (<code>mode='w'</code> means write mode), and the <code>write()</code> function to write the <code>txt</code> string to it, as follows:</p>
			<pre>    def execute(self):  
        if verbose:  
            print(f"[creating file '{self.path}']")  
        with open(self.path, mode='w', encoding='utf-8') \
           as out_file:  
            out_file.write(self.txt)</pre>
			<p>The undo action for the operation of creating a file is to delete that file. So, the <code>undo()</code> method, which we add to the class, simply uses the <code>delete_file()</code> function to achieve that, as follows:</p>
			<pre>    def undo(self):  
        delete_file(self.path)</pre>
			<p>The last utility gives us the ability<a id="_idIndexMarker1423"/> to read the contents of a file. The <code>execute()</code> method of the <code>ReadFile</code> class uses <code>open()</code> again, this time in read mode, and just prints the content of the file using <code>print()</code>.</p>
			<p>The <code>ReadFile</code> class is defined as follows:</p>
			<pre>class ReadFile:
 
     def __init__(self, path):  
         self.path = path
 
     def execute(self):  
         if verbose:  
             print(f"[reading file '{self.path}']")  
         with open(self.path, mode='r', encoding='utf-8') \
           as in_file:  
             print(in_file.read(), end='')</pre>
			<p>The <code>main()</code> function makes use of the utilities we have defined. The <code>orig_name</code> and <code>new_name</code> parameters are the original and new names of the file that is created and renamed. A commands list is used to add (and configure) all the commands that we want to execute at a later point. Note that the commands are not executed unless we explicitly call <code>execute()</code> for each command:</p>
			<pre>def main():
     orig_name, new_name = 'file1', 'file2'
     commands = (
         CreateFile(orig_name),
         ReadFile(orig_name),  
         RenameFile(orig_name, new_name)
     )
  
     [c.execute() for c in commands]</pre>
			<p>The next step is to ask the users whether they want to undo the executed commands or not. The user selects whether the commands will be undone or not. If they choose to undo them, <code>undo()</code> is executed<a id="_idIndexMarker1424"/> for all commands in the commands list. However, since not all commands support undo, exception handling is used to catch (and ignore) the <code>AttributeError</code> exception generated when the <code>undo()</code> method is missing. The code would look like the following:</p>
			<pre>answer = input('reverse the executed commands? [y/n] ')  
  
if answer not in 'yY':
   print(f"the result is {new_name}")  
   exit()  
  
for c in reversed(commands):  
   try:  
   c.undo()  
except AttributeError as e:  
    print("Error", str(e))</pre>
			<p>Using exception handling for such cases is an acceptable practice, but if you don't like it, you can check explicitly whether a command supports<a id="_idIndexMarker1425"/> the undo operation by adding a <code>supports_undo()</code> or <code>can_be_undone()</code>. Again, that is not mandatory.</p>
			<p>Let's see two sample executions using the <code>python command.py</code> command line.</p>
			<p>In the first one, there is no undo of commands:</p>
			<pre>[creating file 'file1']
[reading file 'file1']
hello world
[renaming 'file1' to 'file2']
reverse the executed commands? [y/n] y
[renaming 'file2' back to 'file1']
Error 'ReadFile' object has no attribute 'undo'
deleting file file1</pre>
			<p>In the second one, we have<a id="_idIndexMarker1426"/> the undo of commands:</p>
			<pre>[creating file 'file1']
[reading file 'file1']
hello world
[renaming 'file1' to 'file2']
reverse the executed commands? [y/n] n
the result is file2</pre>
			<p>But wait! Let's see what can be improved in our command implementation example. Among the things to consider are the following:</p>
			<ul>
				<li>What happens if we try to rename a file that doesn't exist?</li>
				<li>What about files that exist but cannot be renamed because we don't have the proper filesystem permissions?</li>
			</ul>
			<p>We can try improving the utilities by doing some kind of error handling. Checking the return status of the functions in the <code>os</code> module can be useful. We could check whether the file exists before trying the delete action, using the <code>os.path.exists()</code> function.</p>
			<p>Also, the file creation utility creates a file using the default file permissions as decided by the filesystem. For example, in POSIX systems, the permissions are <code>-rw-rw-r--</code>. You might want to give the ability to the user to provide their own permissions by passing the appropriate parameter to <code>CreateFile</code>. How can you do that? Hint: one way is by using <code>os.fdopen()</code>.</p>
			<p>And now, here's something<a id="_idIndexMarker1427"/> for you to think about. I mentioned earlier that a command does not necessarily need to be a class. That's how the delete utility was implemented; there is just a <code>delete_file()</code> function. What are the advantages and disadvantages of this approach? Here's a hint: is it possible to put a delete command in the commands list as was done for the rest of the commands? We know that functions are first-class citizens in Python, so we can do something such as the following (see the <code>first-class.py</code> file):</p>
			<pre>import os  
verbose = True  
class CreateFile:
    def undo(self):  
        try:
            delete_file(self.path)
        except:
            print('delete action not successful...')
            print('... file was probably already deleted.')
     
def main():
    orig_name = 'file1'  
    df=delete_file  
    commands = [CreateFile(orig_name),] 
    commands.append(df)  
  
    for c in commands:  
        try:  
            c.execute()  
        except AttributeError as e:  
            df(orig_name)  
  
    for c in reversed(commands):  
        try:  
            c.undo()  
        except AttributeError as e:  
            pass
            
if __name__ == "__main__":  
    main()</pre>
			<p>Running <code>first-class.py</code> gives <a id="_idIndexMarker1428"/>us the following output:</p>
			<pre>[creating file 'file1']
deleting file file1...
deleting file file1...
delete action not successful...
... file was probably already deleted.</pre>
			<p>We see that this variant of the implementation example works as intended, as the second delete throws an error saying that the action was not successful.</p>
			<p>With that said, there are some potential improvements to this program that you could think about. First, the code we have is not uniform; we rely too much on exception handling, which is not the normal flow of a program. While all the other commands we implemented have an <code>execute()</code> method, in this case, there is no <code>execute()</code>.</p>
			<p>Furthermore, the delete file utility currently has no undo support. What happens if we eventually decide to add undo support for it? Normally, we add an <code>undo()</code> method to the class that represents<a id="_idIndexMarker1429"/> the command. However, in this case, there is no class. We could create another function to handle undo, but creating a class is a better approach.</p>
			<h1 id="_idParaDest-390"><a id="_idTextAnchor371"/>Summary</h1>
			<p>In this chapter, we covered the command pattern. Using this design pattern, we can encapsulate an operation, such as copy and paste, as an object. Using this pattern, we can execute a command whenever we want, and not necessarily at creation time, while the client code that executes a command does not need to know any details about how it is implemented. Moreover, we can group commands and execute them in a specific order.</p>
			<p>To demonstrate command, we implemented some basic file utilities on top of Python's <code>os</code> module. Our utilities supported undo and had a uniform interface, which makes grouping commands easy.</p>
			<p>The next chapter covers the Observer pattern.</p>
			<h1 id="_idParaDest-391"><a id="_idTextAnchor372"/>Questions</h1>
			<p>The answers to these questions can be found in the <em class="italic">Assessments</em> section at the end of the book:</p>
			<ol>
				<li>What are the high-level benefits of the command pattern?</li>
				<li>From the perspective of the client of an application, how is the command pattern specifically useful?</li>
				<li>How is the command pattern implemented in the Python example of file management?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>