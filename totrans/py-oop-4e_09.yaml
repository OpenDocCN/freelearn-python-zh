- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Strings, Serialization, and File Paths
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串、序列化和文件路径
- en: 'Before we get involved with higher-level design patterns, let''s take a deep
    dive into one of Python''s most common objects: the string. We''ll see that there
    is a lot more to the string than meets the eye, and we''ll also cover searching
    strings for patterns, and serializing data for storage or transmission.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们涉足高级设计模式之前，让我们深入探讨Python中最常见的对象之一：字符串。我们会发现字符串远比表面看起来要复杂得多，我们还将涵盖在字符串中搜索模式以及序列化数据以进行存储或传输的内容。
- en: 'All of these topics are elements of making objects persistent. Our application
    can create objects in files for use at a later time. We often take persistence
    – the ability to write data to a file and retrieve it at an arbitrary later date
    – for granted. Because persistence happens via files, at the byte level, via OS
    writes and reads, it leads to two transformations: data we have stored must be
    decoded into a nice, useful object collection of objects in memory; objects from
    memory need to be encoded to some kind of clunky text or bytes format for storage,
    transfer over the network, or remote invocation on a distant server.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些主题都是使对象持久化的元素。我们的应用程序可以在文件中创建对象，以便在以后使用。我们通常将持久性——将数据写入文件并在任意日期检索的能力——视为理所当然。因为持久性是通过文件、在字节级别、通过操作系统写入和读取来实现的，这导致了两个转换：我们存储的数据必须解码成内存中一个漂亮、有用的对象集合；内存中的对象需要编码成某种笨拙的文本或字节格式以供存储、通过网络传输或在远程服务器上进行远程调用。
- en: 'In this chapter, we''ll look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The complexities of strings, bytes, and byte arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串、字节和字节数组的复杂性
- en: The ins and outs of string formatting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化的方方面面
- en: The mysterious regular expression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 神秘的正则表达式
- en: How to use the `pathlib` module to manage the filesystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`pathlib`模块来管理文件系统
- en: A few ways to serialize data, including Pickle and JSON
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种数据序列化的方法，包括Pickle和JSON
- en: This chapter will extend the case study to examine how best to work with collections
    of data files. We'll look at another serialization format, CSV, in the case study.
    This will help us explore alternative representations for the training and testing
    data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将扩展案例研究，探讨如何最佳地处理数据文件集合。在案例研究中，我们将探讨另一种序列化格式，CSV。这将帮助我们探索训练和测试数据的替代表示形式。
- en: We'll start by looking Python strings. They do so much and it's easy to overlook
    the wealth of available features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从了解 Python 字符串开始。它们功能强大，很容易忽视其丰富的特性。
- en: Strings
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are a basic primitive in Python; we've used them in nearly every example
    we've discussed so far. All they do is represent an immutable sequence of characters.
    However, though you may not have considered it before, *character* is a bit of
    an ambiguous word; can Python strings represent sequences of accented characters?
    Chinese characters? What about Greek, Cyrillic, or Farsi?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 Python 中的基本原始类型；到目前为止，我们在讨论的几乎所有例子中都使用了它们。它们所做的只是表示一个不可变的字符序列。然而，尽管你可能之前没有考虑过，*字符*这个词有点模糊；Python
    字符串能否表示带重音的字符序列？中文字符？又或者是希腊文、西里尔文或波斯文？
- en: 'In Python 3, the answer is yes. Python strings are all represented in Unicode,
    a character definition standard that can represent virtually any character in
    any language on the planet (and some made-up languages and random characters as
    well). This is done seamlessly. So, let''s think of Python 3 strings as an immutable
    sequence of Unicode characters. We''ve touched on many of the ways strings can
    be manipulated in previous examples, but let''s quickly cover it all in one place:
    a crash course in string theory!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，答案是肯定的。Python 字符串都是用 Unicode 表示的，这是一种字符定义标准，可以代表地球上任何语言（以及一些虚构语言和随机字符）中的几乎所有字符。这是无缝完成的。因此，让我们将
    Python 3 字符串视为不可变的 Unicode 字符序列。我们在之前的例子中已经触及了字符串可以操作的各种方法，但让我们在这里快速总结一下：字符串理论的快速入门！
- en: It's very important to step away from the older encodings we used to know and
    love. The ASCII encoding, for example, was limited to one byte per character.
    Unicode has several ways to encode a character into bytes. The most popular, called
    UTF-8, tends to parallel the old ASCII encoding for some punctuation and letters.
    It's approximately one byte per character. But, if you need one of the thousands
    of other Unicode characters, there may be multiple bytes involved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要摆脱我们曾经熟悉和喜爱的旧编码方式。例如，ASCII 编码每个字符限制为一个字节。Unicode 有几种方法将字符编码成字节。最流行的一种，称为
    UTF-8，对于一些标点和字母来说，与旧的 ASCII 编码相似。它大约每个字符一个字节。但是，如果你需要成千上万的其它 Unicode 字符之一，可能涉及多个字节。
- en: 'The important rule is this: we *encode* our characters to create bytes; we
    *decode* bytes to recover the characters. The two are separated by a high fence
    with a gate labeled encode on one side and decode on the other. We can visualize
    it like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的规则是这样的：我们将字符*编码*成字节；我们将字节*解码*以恢复字符。这两者之间由一个高高的栅栏隔开，栅栏上有一个标有“编码”的侧门和标有“解码”的另一侧门。我们可以这样可视化它：
- en: '![Diagram  Description automatically generated](img/B17070_09_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_09_01.png)'
- en: 'Figure 9.1: Strings and bytes'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：字符串和字节
- en: There's a potential source of confusion that arises from the canonical display
    of a bytes value. Python will show a bytes value as `b'Flamb\xc3\xa9'`. In a bytes
    value, the letters are shorthand for numbers and use the older ASCII encoding
    scheme.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从字节值的规范显示中可能会产生一种混淆源。Python 会将字节值显示为 `b'Flamb\xc3\xa9'`。在字节值中，字母是数字的缩写，并使用较旧的
    ASCII 编码方案。
- en: For most letters, the UTF-8 and ASCII encoding are the same. The `b'` prefix
    tells us these are bytes, and the letters are really only ASCII codes, not proper
    Unicode characters. We can see this because the Unicode `é` – encoded in UTF-8
    – takes two bytes, and there's no ASCII shorthand for either of those bytes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数字母，UTF-8 和 ASCII 编码是相同的。`b'` 前缀告诉我们这些是字节，而这些字母实际上只是 ASCII 码，而不是真正的 Unicode
    字符。我们可以通过这一点看出，Unicode 中的 `é` – 使用 UTF-8 编码 – 占用两个字节，而且这两个字节在 ASCII 中都没有简写。
- en: String manipulation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: 'As you know, strings can be created in Python by wrapping a sequence of characters
    in single or double quotes. Multiline strings can easily be created using three
    quote characters, and multiple hardcoded strings can be concatenated together
    by placing them side by side. Here are some examples:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在Python中，可以通过将字符序列用单引号或双引号括起来来创建字符串。使用三个引号字符可以轻松创建多行字符串，并且可以通过将它们并排放置来将多个硬编码的字符串连接在一起。以下是一些示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That last string is automatically composed into a single string by the interpreter.
    It is also possible to concatenate strings using the `+` operator (as in `"hello
    " + "world"`). Of course, strings don't have to be hardcoded. They can also come
    from various outside sources, such as text files and user input, or can be transmitted
    on the network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后那个字符串会被解释器自动组合成一个单一的字符串。也可以使用`+`运算符来连接字符串（例如`"hello " + "world"`）。当然，字符串不必硬编码。它们也可以来自各种外部来源，例如文本文件和用户输入，或者可以在网络上传输。
- en: '**Watch for missing operators**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意缺失的操作符**'
- en: The automatic concatenation of adjacent strings can make for some hilarious
    bugs when a comma is missed. It is, however, extremely useful when a long string
    needs to be placed inside a function call without exceeding the 79-character line-length
    limit suggested by PEP-8, the Python style guide.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自动连接相邻的字符串可能会在遗漏逗号时引发一些令人捧腹的bug。然而，当需要将长字符串放入函数调用中而不超过由Python风格指南PEP-8建议的79个字符的行长度限制时，这却非常有用。
- en: Like other sequences, strings can be iterated over (character by character),
    indexed, sliced, or concatenated. The syntax is the same as for lists and tuples.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他序列一样，字符串可以逐个字符迭代（按字符迭代），索引，切片或连接。语法与列表和元组相同。
- en: The `str` class has numerous methods on it to make manipulating strings easier.
    The `dir()` and `help()` functions can tell us how to use all of them; we'll consider
    some of the more common ones directly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`str` 类提供了许多方法来简化字符串操作。`dir()` 和 `help()` 函数可以告诉我们如何使用它们的所有方法；我们将直接考虑一些更常见的方法。'
- en: 'Several Boolean convenience methods help us identify whether or not the characters
    in a string match a certain pattern. Most of these, such as `isalpha()`, `isupper()`,
    `islower()`, `startswith()`, and `endswith()`, have reasonably easy-to-understand
    interpretations. The `isspace()` method is also fairly obvious, but remember that
    all whitespace characters (including tab and newline) are considered, not just
    the space character. When in doubt, the `help()` function is useful:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 几个布尔便利方法帮助我们识别字符串中的字符是否匹配某种模式。其中大多数，如 `isalpha()`、`isupper()`、`islower()`、`startswith()`
    和 `endswith()`，都有相对容易理解的解释。`isspace()` 方法也很明显，但请记住，所有空白字符（包括制表符和换行符）都被考虑在内，而不仅仅是空格字符。如有疑问，`help()`
    函数很有用：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `istitle()` method returns `True` if the first character of each word is
    capitalized and all other characters are lowercase. Note that it does not strictly
    enforce the English grammatical definition of title formatting. For example, Leigh
    Hunt's poem *The Glove and the Lions* follows common style guides for a title,
    but doesn't fit the narrow rule of Python's method. Similarly, Robert Service's *The
    Cremation of Sam McGee* follows the usual English rules for a valid title, even
    though there is an uppercase letter in the middle of the last word; Python's `istitle()`
    method will return `False`, unaware of the rules for capitalizing a name like
    McGee or words like *and* *the* in a title.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`istitle()` 方法返回 `True` 如果每个单词的首字母都大写且所有其他字母都小写。请注意，它并不严格遵循英语语法对标题格式的定义。例如，利·亨特的诗作《手套与狮子》遵循常见的标题风格指南，但不符合
    Python 方法狭窄的规则。同样，罗伯特·塞尔的《萨姆·麦基的火化》遵循通常的英语规则，即使最后一个单词中间有一个大写字母；Python 的 `istitle()`
    方法将返回 `False`，因为它不了解像 McGee 这样的名字或标题中像 *and* 和 *the* 这样的单词需要大写的规则。'
- en: 'Be careful with the `isdigit()`, `isdecimal()`, and `isnumeric()` methods,
    as they are more nuanced than we would expect. Many Unicode characters are considered
    numbers besides the 10 digits we are used to. Worse, the period character that
    we use to construct floats from strings is not considered a decimal character,
    so `''45.2''.isdecimal()` returns `False`. The real decimal character is represented
    by the Unicode value 0660, as in 45.2 (or `45\u06602`). Further, these methods
    do not verify whether the strings are valid numbers; `127.0.0.1` returns `True` for
    all three methods. We might think we should use that decimal character instead
    of a period for all numeric quantities, but passing that character into the `float()` or `int()` constructor
    converts that decimal character to a zero:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心使用 `isdigit()`、`isdecimal()` 和 `isnumeric()` 方法，因为它们比我们预期的要复杂。除了我们习惯的10个数字之外，许多Unicode字符也被认为是数字。更糟糕的是，我们用来从字符串构造浮点数的点字符不被认为是十进制字符，所以
    `'45.2'.isdecimal()` 返回 `False`。真正的十进制字符由Unicode值 0660 表示，例如 45.2（或 `45\u06602`）。此外，这些方法并不验证字符串是否是有效的数字；`127.0.0.1`
    对所有三种方法都返回 `True`。我们可能会认为我们应该用那个十进制字符而不是点来表示所有的数值，但将那个字符传递给 `float()` 或 `int()`
    构造函数会将那个十进制字符转换为零：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of all these inconsistencies is that the Boolean numeric checks
    must be used carefully, knowing the details of the rules. We''ll often need to
    write a regular expression (discussed later in this chapter) to confirm whether
    the string matches a specific numeric pattern. We call this LBYL-style programming:
    "Look Before You Leap." One very common approach is to use a `try/except` block
    wrapped around an `int()` or `float()` conversion attempt. We call this EAFP-style
    programming: "It''s Easier to Ask Forgiveness than to Ask Permission." The EAFP
    style fits naturally with Python.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不一致的结果是，布尔数值检查必须谨慎使用，了解规则的细节。我们通常会需要编写一个正则表达式（本章后面将讨论）来确认字符串是否匹配特定的数值模式。我们称这种编程风格为LBYL（"在跳之前先看"）。一个非常常见的方法是使用一个包裹在`int()`或`float()`转换尝试周围的`try/except`块。我们称这种编程风格为EAFP（"请求原谅比请求许可更容易"）。EAFP风格与Python非常自然地契合。
- en: 'Other methods useful for pattern-matching do not return Booleans. The `count()`
    method tells us how many times a given substring shows up in the string, while
    `find()`, `index()`, `rfind()`, and `rindex()` tell us the position of a given
    substring within the original string. Most operations start at the zero index
    and work from left to right. The two `r` (for *right* or *reverse*) methods start
    searching from the highest index end of the string and work from right to left.
    The `find()` methods return `-1` if the substring can''t be found, while `index()`
    raises a `ValueError` exception in this situation. Have a look at some of these
    methods in action:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用于模式匹配的方法不会返回布尔值。`count()` 方法告诉我们给定子字符串在字符串中出现的次数，而 `find()`、`index()`、`rfind()`
    和 `rindex()` 告诉我们在原始字符串中给定子字符串的位置。大多数操作从零索引开始，从左到右进行。两个带有 `r`（表示 *right* 或 *reverse*）的方法从字符串的最高索引端开始搜索，并从右到左进行。如果找不到子字符串，`find()`
    方法返回 `-1`，而在此情况下 `index()` 会引发一个 `ValueError` 异常。看看这些方法在实际中的应用：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most of the remaining string methods return transformations of the string. The
    `upper()`, `lower()`, `capitalize()`, and `title()` methods create new strings
    with all alphabetical characters following the given format rules. The `translate()` method
    can use a dictionary to map arbitrary input characters to specified output characters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数剩余的字符串方法返回字符串的转换。`upper()`、`lower()`、`capitalize()`和`title()`方法会创建新的字符串，其中所有字母字符都遵循给定的格式规则。`translate()`方法可以使用字典将任意输入字符映射到指定的输出字符。
- en: For all of these methods, note that the input string remains unmodified; a brand
    new `str` instance is created. If we need to manipulate the resultant string,
    we should assign it to a new variable, as in `new_value = value.capitalize()`.
    Often, once we've performed the transformation, we don't need the old value anymore,
    so a common idiom is to assign it to the same variable, as in `value = value.title()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些方法，请注意输入字符串保持未修改；会创建一个新的`str`实例。如果我们需要操作结果字符串，我们应该将其分配给一个新的变量，例如`new_value
    = value.capitalize()`。通常，一旦我们完成了转换，我们就不再需要旧值了，所以一个常见的习惯用法是将它分配给相同的变量，例如`value
    = value.title()`。
- en: 'Finally, a couple of string methods return or operate on lists. The `split()` method
    accepts a substring and splits the string into a list of strings breaking wherever
    that substring occurs. You can pass a number as a second parameter to limit the
    number of resultant strings. The `rsplit()` method behaves identically to `split()` if
    you don''t limit the number of strings, but if you do supply a limit, it starts
    splitting from the end of the string. The `partition()` and `rpartition()` methods
    split the string at only the first or last occurrence of the substring, and return
    a tuple of three values: characters before the substring, the substring itself,
    and the characters after the substring.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有几个字符串方法返回或操作列表。`split()` 方法接受一个子字符串，并将字符串分割成一系列字符串，分割点在子字符串出现的地方。你可以传递一个数字作为第二个参数来限制结果字符串的数量。如果未限制字符串数量，`rsplit()`
    方法的行为与 `split()` 相同，但如果你提供了限制，它将从字符串的末尾开始分割。`partition()` 和 `rpartition()` 方法仅在子字符串的第一个或最后一个出现处分割字符串，并返回一个包含三个值的元组：子字符串之前的部分、子字符串本身以及子字符串之后的部分。
- en: 'As the inverse of `split()`, the `join()` method accepts a list of strings,
    and returns all of those strings combined together by placing the original string
    between them. The `replace()` method accepts two arguments, and returns a string
    where each instance of the first argument has been replaced with the second. Here
    are some of these methods in action:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`split()`方法的逆操作，`join()`方法接受一个字符串列表，并将这些字符串通过在它们之间放置原始字符串的方式组合在一起。`replace()`方法接受两个参数，并返回一个字符串，其中每个第一个参数的实例都被第二个参数所替换。以下是一些这些方法的应用示例：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There you have it, a whirlwind tour of the most common methods on the `str` class!
    Now, let's look at Python 3's approach to composing strings and values from variables
    and other expressions to create new strings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最常见的`str`类方法的快速浏览！现在，让我们看看Python 3如何通过变量和其他表达式组合字符串和值来创建新的字符串。
- en: String formatting
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: Python 3 has powerful string formatting and templating mechanisms that allow
    us to construct strings comprised of template text and interspersed representations
    of objects usually from variables, but also from expressions. We've used it in
    many previous examples, but it is much more versatile than the simple formatting
    specifiers we've used.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 拥有强大的字符串格式化和模板机制，使我们能够构建由模板文本和对象表示穿插组成的字符串，这些对象通常来自变量，但也来自表达式。我们已经在许多之前的例子中使用过它，但它比我们使用的简单格式化说明符要灵活得多。
- en: 'A format string (also called an **f-string**) has a prefix on the opening quotation
    mark of `f`, as in `f"hello world"`. If such a string contains the special characters `{` and `}`,
    expressions, including variables from the surrounding scope, are evaluated and
    then interpolated into the string. Here''s an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化字符串（也称为**f-string**）在开引号`f`处有一个前缀，例如`f"hello world"`。如果这样的字符串包含特殊字符`{`和`}`以及表达式，包括周围作用域中的变量，这些表达式将被评估，然后插入到字符串中。以下是一个示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run these statements, it replaces the braces with variables, in order:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些语句，它会按照以下顺序用变量替换大括号：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Escaping braces
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逃离花括号
- en: 'Brace characters are often useful in strings, aside from formatting. We need
    a way to escape them in situations where we want them to be displayed as themselves,
    rather than being replaced. This can be done by doubling the braces. For example,
    we can use Python to format a basic Java program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 括号字符在字符串中除了用于格式化外，通常很有用。我们需要一种方法来转义它们，以便在想要它们显示为自身而不是被替换的情况下使用。这可以通过重复括号来实现。例如，我们可以使用Python来格式化一个基本的Java程序：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Where we see the `{{` and `}}` sequence in the template – that is, the braces
    enclosing the Java class and method definition – we know the f-string will replace
    them with single braces, rather than some argument in the surrounding methods.
    Here''s the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中我们看到`{{`和`}}`序列——也就是说，包围Java类和方法定义的花括号——我们知道f-string将会用单个花括号替换它们，而不是周围方法中的某个参数。以下是输出结果：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The class name and contents of the output have been replaced with two parameters,
    while the double braces have been replaced with single braces, giving us a valid
    Java file. Turns out, this is about the simplest possible Python program to print
    the simplest possible Java program that can print the simplest possible Python
    program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类名和输出内容已被两个参数所替换，同时双大括号已被单大括号所取代，从而生成一个有效的Java文件。结果证明，这可能是打印出最简单的Java程序，该程序又能打印出最简单的Python程序的最简单Python程序。
- en: f-strings can contain Python code
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: f-字符串可以包含 Python 代码
- en: We aren't restricted to interpolating the values of simple string variables
    into an f-string template. Any primitives, such as integers or floats, can be
    formatted. More interestingly, complex objects, including lists, tuples, dictionaries,
    and arbitrary objects, can be used, and we can access indexes and variables or
    call functions on those objects from within the `format` string.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于将简单字符串变量的值插入到 f-string 模板中。任何原始数据类型，如整数或浮点数，都可以进行格式化。更有趣的是，包括列表、元组、字典和任意对象在内的复杂对象也可以使用，并且我们可以在
    `format` 字符串内部访问这些对象的索引和变量或调用这些对象上的函数。
- en: 'For example, if our email message had grouped the `From` and `To` email addresses
    into a tuple and placed the subject and message in a dictionary, for some reason
    (perhaps because that''s the input required for an existing `send_mail` function
    we want to use), we can format it like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的电子邮件消息将`From`和`To`电子邮件地址组合成一个元组，并将主题和消息放入一个字典中，由于某种原因（可能是因为我们需要使用的一个现有`send_mail`函数需要这样的输入），我们可以这样格式化它：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The variables inside the braces in the template string look a little weird,
    so let's look at what they're doing. The two email addresses are looked up by
    the expression `emails[x]`, where `x` is either `0` or `1`. This is an ordinary
    tuple indexing operation, so `emails[0]` refers to the first item in the `emails` tuple.
    Similarly, the expression `message['subject']` gets an item from a dictionary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串中花括号内的变量看起来有点奇怪，让我们看看它们在做什么。两个电子邮件地址是通过表达式 `emails[x]` 查找的，其中 `x` 要么是 `0`
    要么是 `1`。这是一个普通的元组索引操作，所以 `emails[0]` 指的是 `emails` 元组中的第一个元素。同样，表达式 `message['subject']`
    从字典中获取一个项。
- en: 'This works out particularly well when we have a more complex object to display.
    We can extract object attributes and properties and even call methods inside the
    f-string. Let''s change our email message data once again, this time to a class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要展示一个更复杂的目标时，这种方法尤其有效。我们可以提取目标属性和特性，甚至可以在 f-string 内调用方法。让我们再次更改我们的电子邮件消息数据，这次改为一个类：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s an instance of the `Notification` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Notification`类的一个实例：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use this email instance to fill in an f-string as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个电子邮件实例来填充一个f-string，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Pretty much any Python code that you would expect to return a string (or a
    value that can convert to a string with the `str()` function) can be executed
    inside an f-string. As an example of how powerful it can get, you can even use
    a list comprehension or ternary operator in a format string parameter:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何你期望返回字符串（或可以由 `str()` 函数转换为字符串的值）的 Python 代码都可以在 f-string 中执行。作为一个如何强大到何种程度的例子，你甚至可以在格式字符串参数中使用列表推导式或三元运算符：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In some cases, we''ll want to include a label on the value. This is great for
    debugging; we can add an `=` suffix to the expression. It looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要在值上包含一个标签。这对于调试来说非常好；我们可以在表达式中添加一个`=`后缀。它看起来是这样的：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This technique creates a label and a value for us. It can be very helpful. Of
    course, there are a number of more sophisticated formatting options available
    to us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为我们创建了一个标签和值。这可以非常有帮助。当然，还有许多更复杂的格式化选项可供我们选择。
- en: Making it look right
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使其看起来正确
- en: 'It''s nice to be able to include variables in template strings, but sometimes
    the variables need a bit of coercion to make them look the way we want them to
    in the output. We''re planning a sailing trip around the Chesapeake Bay. Starting
    from Annapolis, we want to visit Saint Michaels, Oxford, and Cambridge. To do
    this, we''ll need to know the distances among these sailing ports. Here''s a useful
    distance computation for relatively short distances. First, the formal math, because
    that can help explain the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在模板字符串中包含变量是一件很方便的事情，但有时变量需要一点强制转换才能在输出中呈现出我们想要的样子。我们计划在切萨皮克湾周围进行一次航海之旅。从安纳波利斯出发，我们想去圣迈克尔、牛津和剑桥。为了做到这一点，我们需要知道这些航海港口之间的距离。这里有一个用于相对较短距离的有用距离计算方法。首先，是正式的数学公式，因为那可以帮助解释代码：
- en: '![](img/B17070_09_001.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_09_001.png)'
- en: This follows the same pattern as the hypotenuse of a triangle computation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循与三角形斜边计算相同的模式。
- en: '![](img/B17070_09_002.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17070_09_002.png)'
- en: 'There are some differences, which are important:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些重要的差异：
- en: We wrote ![](img/B17070_09_003.png) for the differences in the north-south latitudes,
    converted to radians from degrees. This seemed simpler than ![](img/B17070_09_004.png).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将南北纬度的差异写为 ![](img/B17070_09_003.png)，从度转换为弧度。这看起来比 ![](img/B17070_09_004.png)
    更简单。
- en: We wrote ![](img/B17070_09_005.png) for the differences in the east-west longitudes,
    converted to radians from degrees. This is simpler than ![](img/B17070_09_006.png).
    In some parts of the world, the longitudes will be a mix of positive and negative
    numbers, and we'll need to sort out the minimum positive-valued distance rather
    than compute a trip all the way around the world.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为东西经度的差异编写了 ![](img/B17070_09_005.png)，将其从度转换为弧度。这比 ![](img/B17070_09_006.png)
    更简单。在世界的某些地区，经度将是一个正负数的混合，我们需要找出最小正值距离，而不是计算绕地球一周的行程。
- en: The value of R converts radians to nautical miles (about 1.85 km, 1.15 statute
    miles, exactly 1/60th of a degree of latitude).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R值将弧度转换为海里（大约1.85公里，1.15英里，正好是纬度1/60度）。
- en: The cosine computation reflects the way longitude distances compress toward
    zero at the pole. At the north pole, we can walk in a tiny circle and cover all
    360°. At the equator, we have to walk (or walk and sail) 40,000 km to cover the
    same 360°.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 余弦计算反映了经度距离在极点处向零压缩的方式。在北极，我们可以沿着一个微小的圆圈行走，覆盖所有360°。而在赤道，我们必须行走（或行走并航行）40,000公里才能覆盖同样的360°。
- en: Otherwise, this is similar to the `math.hypot()` function we used in the *Chapter
    3* case study, which means it involves square roots and awkwardly too-precise
    floating-point numbers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，这与我们在*第3章*案例研究中使用的`math.hypot()`函数类似，这意味着它涉及到平方根以及过于精确的浮点数。
- en: 'Here''s the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s our test case:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的测试用例：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That sounds like fun. A `17.070608794` nautical mile trip in a sailboat going
    about 6 knots will take 2.845101465666667 hours to cross the bay. If the wind
    is lighter, maybe we'll only go 5 knots, and the trip will take 3.4141217588000004
    hours.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很有趣。一艘帆船以大约6节的速度航行，17.070608794海里的旅程将花费2.845101465666667小时穿越海湾。如果风更小，我们可能只能达到5节的速度，这次旅行将需要3.4141217588000004小时。
- en: This is too many decimal places to be really useful. The boat is 42 feet (12.8m)
    long; that's 0.007 nautical miles; so, anything after the third decimal place
    is noise, not a useful result. We'll need to adjust these distances to provide
    useful information. Also, we have multiple legs, and we don't want to treat each
    leg as a special case. We need to provide better organization and better display
    of the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这位数太多，实际上并没有太大用处。船的长度是42英尺（12.8米）；那相当于0.007海里；所以，小数点后第三位及以后的数字都是噪音，不是有用的结果。我们需要调整这些距离以提供有用的信息。此外，我们有多段航程，我们不希望将每一段航程视为特殊情况。我们需要提供更好的组织和数据展示。
- en: Here's how we'd like to plan this trip. First, we'll define our four waypoints
    for the places we want to go. Then we'll combine the waypoints into legs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们计划这次旅行的方案。首先，我们将定义我们想要去的地方的四个航点。然后，我们将这些航点组合成路段。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then use the distance computation to figure out how far it is to each
    destination. We can figure the speed to cover the distance, and we can even compute
    the fuel required if we can''t sail and have to motor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用距离计算来确定到达每个目的地有多远。我们可以计算出覆盖这段距离所需的速度，如果我们不能航行而必须使用引擎，我们甚至可以计算出所需的燃油量：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While we've structured the whole journey, we still have too many digits. Distances
    only need two decimal places at most. A tenth of an hour is six minutes; we don't
    need too many digits there. And fuel, similarly, can be computed to the nearest
    tenth of a gallon. (A tenth of a gallon is 0.4 liters.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经规划了整个旅程，但我们仍然有太多的数字。距离最多只需要两位小数。十分之一小时是六分钟；那里不需要太多数字。同样，燃料也可以计算到最近的十分之一加仑。（十分之一加仑是0.4升。）
- en: 'The f-string substitution rules include formatting that can help us. After
    the expression (a variable is a very simple expression), we can use `:` followed
    by a detailed description of the layout of the numbers. We''ll return to the details
    after an example. Here''s an improved plan with more useful print formatting:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: f-string替换规则包括一些可以帮助我们的格式化功能。在表达式（一个变量是一个非常简单的表达式）之后，我们可以使用`:`后跟对数字布局的详细描述。我们将在示例之后返回细节。以下是一个包含更多有用打印格式的改进计划：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As an example, the `:5.2f` format specifier says the following, from left to
    right:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`:5.2f`格式说明符的含义如下，从左到右：
- en: '`5`: take up at most five spaces – this guarantees column alignment when using
    a fixed-width font'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`: 占用最多五个空格 – 这在使用固定宽度字体时保证了列对齐'
- en: '`.`: show the decimal point'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`: 显示小数点'
- en: '`2`: show two places after the decimal'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`: 显示小数点后两位'
- en: '`f`: format the input value as a floating-point numeric value'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`: 将输入值格式化为浮点数值'
- en: 'Nifty! The location is formatted as `16s`. This follows the same pattern as
    the float format:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！位置格式化为`16s`。这遵循了与浮点格式相同的模式：
- en: '`16` means it should take up 16 characters. By default, with strings, if the
    string is shorter than the specified number of characters, it appends spaces to
    the right-hand side of the string to make it long enough (beware, however: if
    the original string is too long, it won''t be truncated!).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`16` 表示它应该占用16个字符。默认情况下，对于字符串，如果字符串的长度小于指定的字符数，它会在字符串的右侧添加空格，使其足够长（但是请注意：如果原始字符串太长，它不会被截断！）。'
- en: '`s` means it is a string value.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 表示它是一个字符串值。'
- en: 'When we wrote the headings, we used an odd-looking f-string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写标题时，我们使用了看起来很奇怪的f-string：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This has string literals like `'leg'` with a format of `16s`, and `'dist'` with
    a format of `5s`. The sizes are copied from the detail lines to make sure the
    headers fit over their respective columns. Making sure the sizes match makes it
    easy to be sure the heading and the details align.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有字符串字面量如`'leg'`，其格式为`16s`，以及`'dist'`，其格式为`5s`。大小是从详细行复制的，以确保标题能够覆盖各自的列。确保大小匹配使得确认标题和细节对齐变得容易。
- en: 'All these format specifiers have the same pattern; the details are optional:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些格式说明符都有相同的模式；细节是可选的：
- en: A filler character (space if nothing is provided) that's used to pad out the
    number to fill in the specified size.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个填充字符（如果没有提供则为空格）用于填充数字以达到指定的长度。
- en: The alignment rule. By default, numbers are right-aligned and strings are left-aligned.
    Characters like `<`, `^`, and `>` can force left, centered, or right alignment.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐规则。默认情况下，数字右对齐，字符串左对齐。字符如 `<`、`^` 和 `>` 可以强制左对齐、居中对齐或右对齐。
- en: How to handle the sign (default is `–` for negative, nothing for positive.)
    You can use `+` to show all signs. Also, " " (a space) leaves a space for positive
    numbers and `-` for negative numbers to assure proper alignment.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理符号（默认负数为`–`，正数为无符号。）您可以使用`+`来显示所有符号。此外，空格（" "）为正数留出空间，而`-`为负数留出空间，以确保正确的对齐。
- en: A `0` if you want leading zeroes to fill in the front of the number.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在数字前面填充前导零，则为`0`。
- en: The overall size of the field. This should include signs, decimal places, commas,
    and the period itself for floating-point numbers.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该字段的整体大小。这应包括符号、小数点、逗号以及浮点数本身的句点。
- en: A `,` if you want 1,000 groups separated by ",". Use `_` to separate groups
    with an "_". If you have a locale where grouping is done with ".", and the decimal
    separator is ",", you'll want to use the `n` format to use all of the locale settings.
    The `f` format is biased toward locales that use "," for grouping.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要以逗号","分隔的1,000组，请使用下划线"_"来分隔带有下划线的组。如果您所在的地区使用"."进行分组，并且小数分隔符是逗号","，您将希望使用`n`格式来使用所有地区设置。`f`格式倾向于使用逗号","进行分组的地区。
- en: The `.` if it's a float (`f`) or general (`g`) number, followed by the number
    of digits to the right of the decimal point.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是浮点数（`f`）或一般数（`g`），后面跟着小数点右边的数字位数。
- en: The type. Common types are `s` for strings, `d` for decimal integers, and `f`
    for floating-point. The default is `s` for string. Most of the other format specifiers
    are alternative versions of these; for example, `o` represents octal format and `X` represents
    hexadecimal format for integers. The `n` type specifier can be useful for formatting
    any kind of number in the current locale's format. For floating-point numbers,
    the `%` type will multiply by 100 and format a float as a percentage.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型。常见的类型有 `s` 用于字符串，`d` 用于十进制整数，以及 `f` 用于浮点数。默认类型为 `s`，即字符串。大多数其他格式说明符是这些类型的变体；例如，`o`
    表示八进制格式，而 `X` 表示整数的十六进制格式。`n` 类型说明符对于按当前区域设置格式化任何类型的数字可能很有用。对于浮点数，`%` 类型会将数值乘以
    100 并将浮点数格式化为百分比。
- en: This is a very sophisticated way to display numbers. It can simplify otherwise
    confusing output, by reducing clutter and aligning data into columns when the
    information is related.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常复杂的显示数字的方式。它可以通过减少杂乱并使数据按列对齐，来简化其他情况下可能令人困惑的输出。
- en: '**Faulty Navigation Advice**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误的导航建议**'
- en: These waypoints are a little misleading. The route from St. Michaels to Oxford
    is only 6.41 miles if you're a bird. There's a big peninsula in the way, and it's
    actually a delightfully longer trip outside Poplar and Tilghman Islands and up
    the Choptank River. A superficial analysis of distances needs to be backed up
    with actually looking at the nautical chart and inserting a number of additional
    waypoints. Our algorithm permits this, and updating the list of legs is easy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些航路点有点误导。如果你是只鸟，从圣迈克尔到牛津的路程只有6.41英里。中间有一个大半岛挡路，实际上，绕过波普勒和蒂尔曼群岛，沿着切帕恩克河的旅程会愉快地更长。对距离的表面分析需要通过实际查看海图并插入多个额外的航路点来支持。我们的算法允许这样做，更新航段列表也很容易。
- en: Custom formatters
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义格式化工具
- en: 'While these standard formatters apply to most built-in objects, it is also
    possible for other objects to define nonstandard specifiers. For example, if we
    pass a `datetime` object into `format`, we can use the specifiers used in the
    `datetime.strftime()` function, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些标准格式化程序适用于大多数内置对象，但其他对象也可以定义非标准指定符。例如，如果我们将一个`datetime`对象传递给`format`函数，我们可以使用`datetime.strftime()`函数中使用的指定符，如下所示：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is even possible to write custom formatters for objects we create ourselves,
    but that is beyond the scope of this book. Look into overriding the `__format__()` special
    method if you need to do this in your code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以为我们自己创建的对象编写自定义格式化程序，但这超出了本书的范围。如果你需要在代码中这样做，请查看如何重写`__format__()`特殊方法。
- en: The Python formatting syntax is quite flexible, but it is a difficult mini-language
    to remember. It's helpful to bookmark the page in the Python standard library
    to help look up details. While good for many things, this formatting capability
    isn't powerful enough for larger-scale templating needs, such as generating web
    pages. There are several third-party templating libraries you can look into if
    you need to do more than basic formatting of a few strings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python的格式化语法非常灵活，但它是一种难以记忆的小型语言。将Python标准库中的页面添加到书签以帮助查找细节是很有帮助的。虽然这种格式化功能在很多方面都很不错，但对于更大规模的模板需求，如生成网页，它的功能还不够强大。如果你需要做的不仅仅是格式化几个字符串，你可以考虑使用几个第三方模板库。
- en: The format() method
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`format()` 方法'
- en: 'F-strings were introduced in Python 3.6\. Since Python 3.5''s support ended
    in 2020 (see PEP-478 for details), we no longer need to worry about old Python
    runtimes without f-strings. There''s a slightly more general tool for plugging
    values into a string template: the `format()` method of a string. It uses the
    same formatting specifiers as f-strings. The values come from parameter values
    to the `format()` method. Here''s an example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: F 字符串是在 Python 3.6 中引入的。由于 Python 3.5 的支持在 2020 年结束（详情请见 PEP-478），我们不再需要担心没有
    f-strings 的旧 Python 运行时。有一个稍微更通用的工具可以将值插入到字符串模板中：字符串的 `format()` 方法。它使用与 f-strings
    相同的格式说明符。值来自 `format()` 方法的参数值。以下是一个示例：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `format()` method behaves similarly to an f-string with one important distinction:
    you can access values provided as the arguments to the `format()` method only.
    This permits us to provide message templates as configuration items in a complex
    application.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 方法的行为与 f-string 类似，但有一个重要的区别：你只能访问作为 `format()` 方法参数提供的值。这使得我们能够在复杂应用程序中将消息模板作为配置项提供。'
- en: 'We have three ways to refer to the arguments that will be inserted into the
    template string:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方式来引用将要插入到模板字符串中的参数：
- en: '**By name**: The example has `{label}` and `{number}` in the template and provides
    the `label=` and `number=` named arguments to the `format()` method.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按名称**: 示例在模板中包含 `{label}` 和 `{number}`，并为 `format()` 方法提供了名为 `label=` 和 `number=`
    的参数。'
- en: '**By position**: We can use `{0}` in the template, and this will use the first
    positional argument to `format()`, like this: `"Hello {0}!".format("world")`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位置**：我们可以在模板中使用 `{0}`，这将使用 `format()` 的第一个位置参数，如下所示：`"Hello {0}!".format("world")`。'
- en: '**By implied position**: We can use `{}` in the template, and this will use
    the positional arguments in order from the template, like this: `"{} {}!".format("Hello",
    "world")`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过隐式位置**：我们可以在模板中使用 `{}`，这将按照模板中的顺序使用位置参数，例如：`"{} {}!".format("Hello", "world")`。'
- en: Between f-strings and the `format()` method of a template, we can create complex
    string values by interpolating expressions or values into a template. In most
    cases, the f-string is what we need. In rare cases where a format string might
    be a configuration parameter for a complex application, the `format()` method
    is helpful.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 f 字符串和模板的 `format()` 方法之间，我们可以通过将表达式或值插入到模板中来创建复杂的字符串值。在大多数情况下，f 字符串就是我们需要的。在极少数情况下，如果格式字符串可能是一个复杂应用的配置参数，那么
    `format()` 方法是有帮助的。
- en: Strings are Unicode
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串是Unicode
- en: At the beginning of this section, we defined strings as immutable collections
    of Unicode characters. This actually makes things very complicated at times, because
    Unicode isn't a storage format. If you get a string of bytes from a file or a
    socket, for example, they won't be in Unicode. They will, in fact, be the built-in
    type `bytes`. Bytes are immutable sequences of...well, bytes. Bytes are the basic
    storage format in computing. They represent 8 bits, usually described as an integer
    between 0 and 255, or a hexadecimal equivalent between `0x00` and `0xFF`. Bytes
    don't represent anything specific; a sequence of bytes may store characters of
    an encoded string, or pixels in an image, or represent an integer, or part of
    a floating-point value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我们将字符串定义为不可变的Unicode字符集合。这实际上在某些时候会使事情变得非常复杂，因为Unicode不是一个存储格式。例如，如果你从一个文件或套接字中获取一个字节字符串，它们将不会是Unicode。实际上，它们将是内置的`bytes`类型。字节是...嗯，字节的不可变序列。字节是计算中的基本存储格式。它们代表8位，通常描述为介于0到255之间的整数，或者介于`0x00`和`0xFF`之间的十六进制等效值。字节不表示任何特定内容；字节序列可能存储编码字符串的字符，或图像中的像素，或表示一个整数，或浮点值的一部分。
- en: If we print a `bytes` object, Python uses a canonical display that's reasonably
    compact. Any of the individual byte values that map to ASCII characters are displayed
    as characters, while non-character ASCII bytes are printed as escapes, either
    a one-character escape like `\n` or a hex code like `\x1b`. You may find it odd
    that a byte, represented as an integer, can map to an ASCII character. But the
    old ASCII code defined Latin letters for many different byte values. In ASCII
    the character `a` is represented by the same byte as the integer 97, which is
    the hexadecimal number `0x61`. All of these are an interpretation of the binary
    pattern `0b1100001`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印一个`bytes`对象，Python会使用一种合理的紧凑的规范显示方式。任何映射到ASCII字符的单独字节值都会以字符形式显示，而非字符ASCII字节则以转义序列的形式打印，要么是一个字符的转义序列，如`\n`，要么是一个十六进制代码，如`\x1b`。你可能觉得奇怪，一个表示为整数的字节可以映射到一个ASCII字符。但旧的ASCII代码为许多不同的字节值定义了拉丁字母。在ASCII中，字符`a`由与整数97相同的字节表示，这是十六进制数`0x61`。所有这些都是对二进制模式`0b1100001`的解释。
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here''s how the canonical display bytes might look when they have a mixture
    of values that have ASCII character representations and values that don''t have
    a simple character:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当这些标准显示字节包含既有ASCII字符表示又有无简单字符表示的值的混合时，它们可能看起来是怎样的：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first byte used a hexadecimal escape, `\x89`. The next three bytes had ASCII
    characters, `P`, `N`, and `G`. The next two characters had one-character escapes,
    `\r` and `\n`. The seventh byte also had a hexadecimal escape, `\x1a`, because
    there was no other encoding. The final byte is another one-character escape, `\n`.
    The eight bytes were expanded into 17 printable characters, not counting the prefix
    `b'` and the final `'`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字节使用了十六进制转义，`\x89`。接下来的三个字节是ASCII字符，`P`、`N`和`G`。接下来的两个字符使用了一个字符的转义，`\r`和`\n`。第七个字节也使用了十六进制转义，`\x1a`，因为没有任何其他编码。最后一个字节是另一个一个字符的转义，`\n`。这八个字节扩展成了17个可打印字符，不包括前缀`b'`和最后的`'`。
- en: Many I/O operations only know how to deal with `bytes`, even if the `bytes` object
    is the encoding of textual data. It is therefore vital to know how to convert
    between `bytes` values and Unicode `str` values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 许多I/O操作只知道如何处理`bytes`，即使`bytes`对象是文本数据的编码。因此，了解如何在不同`bytes`值和Unicode `str`值之间进行转换是至关重要的。
- en: The problem is that there are many encodings that map `bytes` to Unicode text.
    Several are true international standards, but many others are parts of commercial
    offerings, making them really popular, but not – exactly – standardized. The Python
    `codecs` module provides many of these code-decode rules for decoding bytes into
    a string and encoding a string into bytes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于存在许多编码方式，它们将`bytes`映射到Unicode文本。其中一些是真正的国际标准，但许多其他的是商业产品的一部分，使得它们非常流行，但并不——确切地说——是标准化的。Python的`codecs`模块提供了许多这些编码解码规则，用于将字节解码为字符串以及将字符串编码为字节。
- en: The important consequence of multiple encodings is that the same sequence of
    bytes represents completely different text characters when mapped using different
    encodings! So, `bytes` must be decoded using the same character set with which
    they were encoded. It's not possible to get text from bytes without knowing how
    the bytes should be decoded. If we receive unknown bytes without a specified encoding,
    the best we can do is guess what format they are encoded in, and we are likely
    to be wrong.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多种编码的重要后果是，当使用不同的编码进行映射时，相同的字节序列会表示完全不同的文本字符！因此，`bytes` 必须使用与它们编码时相同的字符集进行解码。如果不了解字节应该如何解码，就无法从字节中获取文本。如果我们收到未指定编码的未知字节，我们最好的做法是猜测它们编码的格式，但我们很可能会出错。
- en: Decoding bytes to text
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解码字节到文本
- en: If we have an array of `bytes` from somewhere, we can convert it to Unicode
    using the `.decode()` method on the `bytes` class. This method accepts a string
    for the name of the character encoding. There are many such encodings; common
    ones include ASCII, UTF-8, latin-1, and cp-1252\. Of these, UTF-8 is one of the
    most commonly used.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从某处获得了一个`bytes`数组，我们可以使用`bytes`类的`.decode()`方法将其转换为Unicode。此方法接受一个字符串作为字符编码的名称。存在许多这样的编码；常见的包括ASCII、UTF-8、latin-1和cp-1252。在这些中，UTF-8是最常用的之一。
- en: 'The sequence of bytes (in hex), `63 6c 69 63 68 c3 a9`, actually represents
    the characters of the word cliche in UTF-8 encoding:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序列（十六进制表示），`63 6c 69 63 68 c3 a9`，实际上代表了单词cliche在UTF-8编码下的字符：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line creates a `bytes` literal as a `b''` string. The `b` character
    immediately before the string tells us that we are defining a `bytes` object instead
    of a normal Unicode text string. Within the string, each byte is specified using
    – in this case – a hexadecimal number. The `\x` character escapes within the byte
    string, and each says *the next two characters represent a byte using hexadecimal
    digits*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个`bytes`字面量，作为一个`b''`字符串。字符串前面的`b`字符告诉我们我们正在定义一个`bytes`对象，而不是一个普通的Unicode文本字符串。在字符串内部，每个字节使用十六进制数指定，在这种情况下，使用的是十六进制数。`\x`字符在字节字符串中用于转义，并且每个`\x`表示*接下来的两个字符使用十六进制数字表示一个字节*。
- en: The final line is the output, showing us Python's canonical representation of
    a `bytes` object. The first five of the seven bytes had an ASCII character that
    could be used. The final two bytes, however, don't have ASCII characters, and
    `\xc3\xa9` had to be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的行是输出结果，展示了 Python 对 `bytes` 对象的规范表示。在这七个字节中的前五个字节中，有一个可用的 ASCII 字符。然而，最后的两个字节却没有
    ASCII 字符，因此必须使用 `\xc3\xa9`。
- en: 'Provided we are using a shell that understands UTF-8 encoding, we can decode
    the bytes to Unicode and see the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用的是一个支持UTF-8编码的shell，我们可以将字节解码为Unicode，并看到以下内容：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `decode` method returns a text (Unicode) `str` object, with the correct
    characters. Note that the `\xc3\xa9` sequence of bytes maps to a single Unicode
    character.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`decode` 方法返回一个包含正确字符的文本（Unicode）`str`对象。注意，字节序列`\xc3\xa9`映射为一个单一的Unicode字符。'
- en: In some cases, the Python terminal may not have the correct encodings defined
    so the operating system can pick the right characters from the OS font. Yes, there's
    a very complex mapping from bytes to text to displayed characters, part of which
    is a Python problem, and part of which is an OS problem. Ideally, your computer
    is using UTF-8 encodings and has fonts with the full Unicode character set. If
    not, you may need to research the `PYTHONIOENCODING` environment variable. See
    [https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONIOENCODING](https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONIOENCODING).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Python 终端可能没有定义正确的编码，因此操作系统无法从操作系统字体中正确选择字符。是的，从字节到文本再到显示字符的映射非常复杂，其中一部分是
    Python 的问题，另一部分是操作系统的问题。理想情况下，您的计算机使用 UTF-8 编码并且具有包含完整 Unicode 字符集的字体。如果不是这样，您可能需要研究
    `PYTHONIOENCODING` 环境变量。请参阅 [https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONIOENCODING](https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONIOENCODING)。
- en: 'However, if we had decoded this same string using the Cyrillic `iso8859-5` encoding,
    we''d have ended up with this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用西里尔文`iso8859-5`编码来解码这个相同的字符串，我们最终会得到这个：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is because the `\xc3\xa9`  bytes map to different characters in the other
    encoding. Over the years a lot of different encodings have been invented, and
    not all of them are in wide use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `\xc3\xa9` 字节在其他编码中映射到不同的字符。多年来，发明了大量的不同编码，但并非所有编码都得到广泛使用。
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is why we need to know the encoding used. Generally, UTF-8 should be the
    encoding of choice. This is a common default, but it isn't universal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要知道所使用的编码。通常，UTF-8应该是首选的编码。这是一个常见的默认设置，但并非普遍适用。
- en: Encoding text to bytes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文本编码为字节
- en: 'The flip side of converting bytes to Unicode is situations where we convert
    outgoing Unicode into byte sequences. This is done with the `encode()` method
    on the `str` class, which, like the `decode()` method, requires an encoding name.
    The following code creates a Unicode string and encodes it in different character
    sets:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节转换为Unicode的另一方面是将输出的Unicode转换为字节序列的情况。这通过`str`类的`encode()`方法完成，与`decode()`方法一样，需要指定一个编码名称。以下代码创建了一个Unicode字符串，并将其编码为不同的字符集：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you should understand the importance of encodings! The accented character
    is represented as a different byte by most of these encodings; if we use the wrong
    one when we are decoding bytes to text, we get the wrong character.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该明白编码的重要性了！在这些编码中，带重音的字符通常被表示为不同的字节；如果我们解码字节为文本时使用了错误的编码，我们就会得到错误的字符。
- en: 'The exception in the last case is not always the desired behavior; there may
    be cases where we want the unknown characters to be handled in a different way.
    The `encode` method takes an optional string argument named `errors` that can
    define how such characters should be handled. This string can be one of the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下的异常并不总是期望的行为；可能存在我们希望未知字符以不同方式处理的情况。`encode`方法接受一个名为`errors`的可选字符串参数，该参数可以定义如何处理此类字符。此字符串可以是以下之一：
- en: '`"strict"`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"严格"`'
- en: '`"replace"`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"替换"`'
- en: '`"ignore"`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"忽略"`'
- en: '`"xmlcharrefreplace"`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"xmlcharrefreplace"`'
- en: The `strict` replacement strategy is the default we just saw. When a byte sequence
    is encountered that does not have a valid representation in the requested encoding,
    an exception is raised. When the `replace` strategy is used, the character is
    replaced with a different character. In ASCII, it is a question mark; other encodings
    may use different symbols, such as an empty box.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`严格`替换策略是我们刚刚看到的默认设置。当遇到一个在请求的编码中没有有效表示的字节序列时，会引发一个异常。当使用`replace`策略时，字符会被替换成另一个字符。在ASCII编码中，它是一个问号；其他编码可能使用不同的符号，例如一个空框。'
- en: The `ignore` strategy simply discards any bytes it doesn't understand, while
    the `xmlcharrefreplace` strategy creates an `xml` entity representing the Unicode
    character. This can be useful when converting unknown strings for use in an XML
    document.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignore`策略简单地丢弃它不理解的所有字节，而`xmlcharrefreplace`策略则创建一个表示Unicode字符的`xml`实体。这在将未知字符串转换为用于XML文档时可能很有用。'
- en: 'Here''s how each of the strategies affects our sample word:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每种策略如何影响我们的样本单词：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is possible to call the `str.encode()` and `bytes.decode()` methods without
    passing an encoding name. The encoding will be set to the default encoding for
    the current platform. This will depend on the current operating system and locale
    or regional settings; you can look it up using the `sys.getdefaultencoding()`
    function. It is usually a good idea to specify the encoding explicitly, though,
    since the default encoding for a platform may change, or the program may one day
    be extended to work on text from a wider variety of sources.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用 `str.encode()` 和 `bytes.decode()` 方法而不传递编码名称。编码将设置为当前平台的默认编码。这取决于当前的操作系统和区域设置；您可以使用
    `sys.getdefaultencoding()` 函数来查找它。尽管如此，通常最好明确指定编码，因为平台的默认编码可能会更改，或者程序将来可能会扩展以处理来自更广泛来源的文本。
- en: If you are encoding text and don't know which encoding to use, it is best to
    use UTF-8 encoding. UTF-8 is able to represent any Unicode character. In modern
    software, it is a widely used, standard encoding to ensure documents in any language—or
    even multiple languages—can be exchanged. The various other possible encodings
    are useful for legacy documents or in software that uses different character encodings
    by default.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编码文本且不知道使用哪种编码，最好使用UTF-8编码。UTF-8能够表示任何Unicode字符。在现代软件中，它是一种广泛使用的标准编码，以确保任何语言——甚至多种语言的文档——可以交换。其他各种可能的编码对于旧文档或在默认使用不同字符编码的软件中是有用的。
- en: The UTF-8 encoding uses one byte to represent ASCII and other common characters,
    and up to four bytes for other characters. UTF-8 is special because it is (mostly)
    backward-compatible with ASCII; an ASCII document encoded using UTF-8 will be
    almost identical to the original ASCII document.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 编码使用一个字节来表示 ASCII 和其他常见字符，而对于其他字符则最多使用四个字节。UTF-8 的特别之处在于它（大部分情况下）与 ASCII
    兼容；使用 UTF-8 编码的 ASCII 文档几乎与原始的 ASCII 文档相同。
- en: '**Encode vs. Decode**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码与解码**'
- en: It's hard to remember whether to use `encode` or `decode` to convert from binary
    bytes to Unicode text. The problem is that the letters "code" in Uni*code* can
    be confusing. I suggest ignoring them. If we think of bytes as code, we encode
    plain text to bytes and decode bytes back to plain text.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆起来是否使用 `encode` 或 `decode` 来将二进制字节转换为 Unicode 文本是很困难的。问题在于 "code" 这个词在 Uni*code*
    中可能会造成混淆。我建议忽略它们。如果我们把字节看作是代码，我们就将纯文本编码成字节，再将字节解码回纯文本。
- en: Mutable byte strings
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变字节字符串
- en: The `bytes` type, like `str`, is immutable. We can use index and slice notation
    on a `bytes` object and search for a particular sequence of bytes, but we can't
    extend or modify them. This can be inconvenient when dealing with I/O, as it is
    often necessary to buffer incoming or outgoing bytes until they are ready to be
    sent. For example, if we are receiving data from a socket, we may have to accumulate
    the results of several `recv` calls before we have received an entire message.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes` 类型，与 `str` 类似，是不可变的。我们可以在 `bytes` 对象上使用索引和切片表示法来搜索特定的字节序列，但我们不能扩展或修改它们。在处理
    I/O 时，这可能会不方便，因为通常需要缓冲输入或输出的字节，直到它们准备好发送。例如，如果我们从套接字接收数据，我们可能需要在接收到整个消息之前，累积几个
    `recv` 调用的结果。'
- en: This is where the `bytearray` built-in comes in. This type behaves something
    like a list, except it only holds bytes. The constructor for the class can accept
    a `bytes` object to initialize it. The `extend` method can be used to append another `bytes` object
    to the existing array (for example, when more data comes from a socket or other
    I/O channel).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是内置的`bytearray`类型发挥作用的地方。这种类型的行为类似于列表，但它只存储字节。该类的构造函数可以接受一个`bytes`对象来初始化它。可以使用`extend`方法将另一个`bytes`对象追加到现有数组中（例如，当从套接字或其他I/O通道接收更多数据时）。
- en: 'Slice notation can be used on `bytearray` to modify the item in place, without
    the overhead of creating a new object. For example, this code constructs a `bytearray` from
    a `bytes` object and then replaces two bytes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 切片符号可用于`bytearray`以就地修改项目，无需创建新对象的额外开销。例如，此代码从一个`bytes`对象构建一个`bytearray`，然后替换两个字节：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We used slice notation to replace bytes in the `[4:6]` slice with two replacement
    bytes, `b"\x15\xa3"`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用切片符号将 `[4:6]` 切片中的字节替换为两个替换字节，`b"\x15\xa3"`。
- en: If we want to manipulate a single element in `bytearray`, the value must be
    an integer between 0 and 255 (inclusive), which is a specific `bytes` pattern.
    If we try to pass a character or `bytes` object, it will raise an exception.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在`bytearray`中操作单个元素，其值必须是一个介于0到255（包含）之间的整数，这是一个特定的`bytes`模式。如果我们尝试传递一个字符或`bytes`对象，将会引发异常。
- en: 'A single byte character can be converted to an integer using the `ord()` (short
    for *ordinal*) function. This function returns the integer representation of a
    single character:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 单个字节字符可以使用`ord()`（简称*序数*）函数转换为整数。此函数返回单个字符的整数表示：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After constructing the array, we replace the character at index `3` (the fourth
    character, as indexing starts at `0`, as with lists) with byte `103`. This integer
    was returned by the `ord()` function and is the ASCII character for the lowercase `g`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建数组后，我们将索引`3`（第四个字符，因为索引从`0`开始，与列表相同）处的字符替换为字节`103`。这个整数是由`ord()`函数返回的，并且是小写字母`g`的ASCII字符。
- en: For illustration, we also replaced the next character up with byte number `68`,
    which maps to the ASCII character for the uppercase `D`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们还用字节编号`68`替换了下一个字符，它对应于大写字母`D`的ASCII字符。
- en: The `bytearray` type has methods that allow it to behave like a list (we can
    append integer bytes to it, for example). It can also behave like a `bytes` object
    (we can use methods such as `count()` and `find()`). The difference is that `bytearray` is
    a mutable type, which can be useful for building up complex sequences of bytes
    from a specific input source. We may, for example, have to read a four byte header
    with length information before reading the payload bytes. It's handy to be able
    to perform the reads directly into a mutable `bytearray` to save creating lots
    of small objects in memory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytearray` 类型具有允许其像列表一样操作的方法（例如，我们可以向其中追加整数字节）。它也可以像 `bytes` 对象一样操作（我们可以使用
    `count()` 和 `find()` 等方法）。不同之处在于 `bytearray` 是一个可变类型，这对于从特定的输入源构建复杂的字节序列非常有用。例如，我们可能需要在读取有效载荷字节之前读取一个包含长度信息的四个字节的头部。能够直接将读取操作执行到可变的
    `bytearray` 中，以节省在内存中创建大量小对象，是非常方便的。'
- en: Regular expressions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: You know what's really hard to do using object-oriented principles? Parsing
    strings to match arbitrary patterns, that's what. There have been a fair number
    of academic papers written in which object-oriented design is used to set up string-parsing,
    but the results seem too verbose and hard to read, and they are not widely used
    in practice.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道使用面向对象原则真正难以做到的是什么吗？解析字符串以匹配任意模式，就是这样。已经有许多学术论文被撰写，其中使用面向对象设计来设置字符串解析，但结果看起来过于冗长且难以阅读，而且在实践中并不广泛使用。
- en: In the real world, string-parsing in most programming languages is handled by
    regular expressions. These are not verbose, but, wow, are they ever hard to read,
    at least until you learn the syntax. Even though regular expressions are not object-oriented,
    the Python regular expression library provides a few classes and objects that
    you can use to construct and run regular expressions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，大多数编程语言中的字符串解析都是由正则表达式处理的。这些表达式并不冗长，但哇，它们确实很难阅读，至少在你学会语法之前是这样的。尽管正则表达式不是面向对象的，但Python的正则表达式库提供了一些类和对象，你可以使用它们来构建和运行正则表达式。
- en: While we use regular expressions to "match" a string, this is only a partial
    description of what a regular expression really is. It can help to think of a
    regular expression as a mathematical rule that could generate a (potentially infinite)
    collection of strings. When we "match" a regular expression, it's similar to asking
    if a given string is in the set generated by the expression. What's tricky is
    rewriting some fancy math using the paltry collection of punctuation marks available
    in the original ASCII character set. To help explain the syntax of regular expressions,
    we'll take a little side-tour through some of these typographic problems that
    make regular expressions a challenge to read.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用正则表达式来“匹配”一个字符串时，这仅仅是对正则表达式真正含义的部分描述。我们可以将正则表达式想象成一个数学规则，它可以生成（可能无限多的）字符串集合。当我们“匹配”一个正则表达式时，这类似于询问给定的字符串是否在由表达式生成的集合中。棘手的是，使用原始ASCII字符集中可用的一小部分标点符号来重写一些复杂的数学表达式。为了帮助解释正则表达式的语法，我们将稍微偏离一下，通过一些使正则表达式阅读变得具有挑战性的排版问题进行一次小型的侧游。
- en: 'Here''s an idealized mathematical regular expression for a small set of strings:
    *world*. We want to match these five characters. The set has one string, `"world"`,
    that matches. This doesn''t seem too complex; the expression amounts to w AND
    o AND r AND l AND d with "AND" being implied. This parallels the way ![](img/B17070_09_007.png)
    means d = r *times* t; the multiplication is implied.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对一小组字符串的理想化数学正则表达式：*world*。我们希望匹配这五个字符。这个集合中有一个字符串 `"world"` 与之匹配。这似乎并不复杂；表达式相当于
    w AND o AND r AND l AND d，其中 "AND" 是隐含的。这与 ![](img/B17070_09_007.png) 表示 d = r
    *times* t 的方式相类似；乘法是隐含的。
- en: 'Here''s a regular expression for a pattern with repeats: ![](img/B17070_09_008.png).
    We want to match five characters, but one of them must occur twice. This set has
    one string, `"hello"`, that matches. This emphasizes the parallel between regular
    expressions, multiplication, and exponents. It also points out the use of exponents
    to distinguish between matching the `2` character and matching the previous regular
    expression two times.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有重复模式的正则表达式的示例：![](img/B17070_09_008.png)。我们希望匹配五个字符，但其中之一必须重复出现。这个集合中有一个字符串
    `"hello"` 与之匹配。这强调了正则表达式、乘法和指数之间的平行关系。它还指出了使用指数来区分匹配 `2` 个字符和匹配前一个正则表达式两次的情况。
- en: 'Sometimes, we want some flexibility, and we want to match any digit. Mathematical
    typesetting lets us use a new font for this: we can say ![](img/B17070_09_009.png).
    This fancy-looking D means any digit, or ![](img/B17070_09_010.png), and the raised
    4 means four copies. This describes a set that has 10,000 possible matching strings
    from "0000" to "9999". Why use the fancy math typesetting? We can use different
    fonts and letter arrangements to distinguish the concept of "any digit" and "four
    copies" from the letter `D` and the digit `4`. Code – as we''ll see – lacks the
    fancy fonts, forcing designers to work around the distinction between letters
    meaning themselves, like `D`, and letters having other useful meanings, like ![](img/B17070_09_011.png).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望有一些灵活性，并且想要匹配任何数字。数学排版允许我们使用一种新的字体来实现这一点：我们可以说 ![](img/B17070_09_009.png)。这个看起来很花哨的
    D 代表任何数字，或者 ![](img/B17070_09_010.png)，而上面的 4 代表四份。这描述了一个包含从 "0000" 到 "9999" 共
    10,000 个可能匹配字符串的集合。为什么使用这种花哨的数学排版？我们可以使用不同的字体和字母排列来区分“任何数字”和“四份”的概念，与字母 `D` 和数字
    `4` 区分开来。代码——正如我们将看到的——缺乏这些花哨的字体，迫使设计师在区分代表自身意义的字母，如 `D`，和具有其他有用意义的字母，如 ![](img/B17070_09_011.png)
    之间进行工作。
- en: And yes, a regular expression looks a lot like a long multiplication. There's
    a very strong parallel with "must have these" and multiplication. Is there a parallel
    with addition? Yes, it's the idea of optional or alternative constructs; in effect
    an "or" instead of the default "and."
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正则表达式看起来很像一个长乘法。它与“必须包含这些”和乘法之间有着非常强的平行关系。与加法有平行关系吗？是的，这是可选或替代结构的概念；实际上是一个“或”代替了默认的“与”。
- en: What if we want to describe years in a date where there could be two digits
    or four digits? Mathematically, we might say ![](img/B17070_09_012.png). What
    if we're not sure how many digits? We have a special "to any power," the Kleene
    star. We can say ![](img/B17070_09_013.png) to mean any number of repeats of a
    character in the ![](img/B17070_09_014.png) set.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在日期中描述可能有两个或四个数字的年份，从数学上讲，我们可能会说 ![图片](img/B17070_09_012.png)。如果我们不确定有多少位数字呢？我们有一个特殊的“任何次方”，即Kleene星号。我们可以说
    ![图片](img/B17070_09_013.png) 来表示在 ![图片](img/B17070_09_014.png) 集合中字符的任意重复次数。
- en: All of this math typesetting has to be implemented in the regular expression
    language. This can make it difficult to sort out precisely what a regular expression
    means.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数学排版都必须在正则表达式语言中实现。这可能会使得精确地理解正则表达式的含义变得困难。
- en: 'Regular expressions are used to solve a common problem: given a string, determine
    whether that string matches a given pattern and, optionally, collect substrings
    that contain relevant information. They can be used to answer questions such as
    the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式用于解决一个常见问题：给定一个字符串，确定该字符串是否与给定的模式匹配，并且可选地收集包含相关信息子串。它们可以用来回答以下问题：
- en: Is this string a valid URL?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这串字符是否是一个有效的URL？
- en: What is the date and time of all warning messages in a log file?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件中所有警告信息的日期和时间是什么？
- en: Which users in `/etc/passwd` are in a given group?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd` 文件中哪些用户属于指定的组？'
- en: What username and document were requested by the URL a visitor typed?
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访客输入的URL请求了什么用户名和文档？
- en: There are many similar scenarios where regular expressions are the correct answer.
    In this section, we'll gain enough knowledge of regular expressions to compare
    strings against relatively common patterns.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多类似场景中，正则表达式是正确的答案。在本节中，我们将获得足够关于正则表达式的知识，以便将字符串与相对常见的模式进行比较。
- en: 'There are important limitations here. Regular expressions don''t describe languages
    with recursive structures. When we look at XML or HTML, for example, a `<p>` tag
    can contain inline `<span>` tags, like this: `<p><span>hello</span><span>world</span></p>`.
    This recursive nesting of tag-within-tag is generally not a great thing to try
    and process with a regular expression. We can recognize the individual elements
    of the XML language, but higher-level constructs like a paragraph tag with other
    tags inside it require more powerful tools than regular expressions. The XML parsers
    in the Python standard library can handle these more complex constructs.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的限制。正则表达式不能描述具有递归结构的语言。当我们查看XML或HTML时，例如，一个`<p>`标签可以包含内联的`<span>`标签，如下所示：`<p><span>hello</span><span>world</span></p>`。这种标签嵌套标签的递归结构通常不是用正则表达式尝试处理的好方法。我们可以识别XML语言的各个元素，但像包含其他标签的段落标签这样的高级结构需要比正则表达式更强大的工具。Python标准库中的XML解析器可以处理这些更复杂的结构。
- en: Matching patterns
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配模式
- en: 'Regular expressions are a complicated mini-language. We need to be able to
    describe individual characters as well as classes of characters, as well as operators
    that group and combine characters, all using a few ASCII-compatible characters.
    Let''s start with literal characters, such as letters, numbers, and the space
    character, which always match themselves. Let''s see a basic example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种复杂的迷你语言。我们需要能够描述单个字符以及字符类，以及用于分组和组合字符的运算符，所有这些都可以使用几个与ASCII兼容的字符来完成。让我们从字面字符开始，例如字母、数字和空格字符，它们总是匹配自身。让我们看一个基本示例：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Python Standard Library module for regular expressions is called `re`. We
    import it and set up a search string and pattern to search for; in this case,
    they are the same string. Since the search string matches the given pattern, the
    conditional passes and the `print` statement executes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的正则表达式模块被称为 `re`。我们导入它并设置一个搜索字符串和搜索模式；在这种情况下，它们是相同的字符串。由于搜索字符串与给定的模式匹配，条件成立并且执行了
    `print` 语句。
- en: A successful match returns a `re.Match` object describing what – exactly – matched.
    A failing match returns `None`, which is equivalent to `False` in the Boolean
    context of an `if`-statement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的匹配会返回一个`re.Match`对象，描述了精确匹配的内容。一个失败的匹配返回`None`，这在`if`语句的布尔上下文中等同于`False`。
- en: We've used the "walrus" operator (`:=`) to compute the results of `re.match()`
    and save those results in a variable all as part of an `if`-statement. This is
    one of the most common ways to use the walrus operator to compute a result and
    then test the result to see if it's truthy. This is a little optimization that
    can help clarify how the results of the matching operation will be used if they
    are not `None`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了“海象”操作符（`:=`）来计算`re.match()`的结果，并将这些结果保存到变量中，所有这些都是在`if`语句的一部分。这是使用海象操作符计算结果然后测试结果是否为真的一种最常见方式。这是一种小小的优化，可以帮助阐明如果匹配操作的结果不是`None`，它们将如何被使用。
- en: We'll almost always use "raw" strings with the `r` prefix for regular expressions.
    Raw strings do not have the backslash escapes processed by Python into other letters.
    In an ordinary string, for example, `\b` is transformed to a single backspace
    character. In a raw string, it's two characters, `\` and `b`. In this example,
    the r-string wasn't really needed because the pattern didn't involve any special
    `\d` or `\w` kinds of regular expression symbols. Using r-strings is a good habit,
    and we'll try to do it consistently.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是使用带有 `r` 前缀的“原始”字符串来表示正则表达式。原始字符串不会将反斜杠转义符转换为 Python 中的其他字符。例如，在一个普通字符串中，`\b`
    被转换为一个单独的退格字符。在原始字符串中，它由两个字符组成，`\` 和 `b`。在这个例子中，r-字符串实际上并不是必需的，因为模式没有涉及任何特殊的 `\d`
    或 `\w` 类型的正则表达式符号。使用 r-字符串是一个好习惯，我们将努力做到一致。
- en: 'Bear in mind that the `match` function matches the pattern anchored at the
    beginning of the string. Thus, if the pattern were `r"ello world"`, no match would
    be found because the `search_string` value starts with "h" not "e". With confusing
    asymmetry, the parser stops searching as soon as it finds a match, so the pattern `r"hello
    wo"` matches the `search_string` value successfully, with a few characters left
    over. Let''s build a small example program to demonstrate these differences and
    help us learn other regular expression syntax:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`match` 函数匹配的是字符串开头锚定的模式。因此，如果模式是 `r"ello world"`，则不会找到匹配，因为 `search_string`
    的值以 "h" 开头而不是 "e"。带有令人困惑的不对称性，解析器一旦找到匹配就会停止搜索，所以模式 `r"hello wo"` 成功匹配了 `search_string`
    的值，并且留下了一些多余的字符。让我们构建一个小型示例程序来展示这些差异，并帮助我们学习其他正则表达式语法：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `matchy()` function expands on the earlier example; it accepts the pattern
    and search string as parameters. We can see how the start of the pattern must
    match, but a value is returned as soon as a match is found.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchy()` 函数在先前的例子基础上进行了扩展；它接受模式和搜索字符串作为参数。我们可以看到模式的开头必须匹配，但一旦找到匹配项，就会立即返回一个值。'
- en: 'Here are some examples of using this function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用此函数的一些示例：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We'll be using this function throughout the next few sections. A sequence of
    test cases is a common way to develop a regular expression – from a bunch of examples
    of text we want to match and text we don't want to match, we test to make sure
    our expression works as expected.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几节中使用这个函数。一系列测试用例是开发正则表达式的一种常见方法——从我们想要匹配和不想匹配的一堆文本示例中，我们测试以确保我们的表达式按预期工作。
- en: If you need control over whether items happen at the beginning or end of a line
    (or if there are no newlines in the string, or at the beginning and end of the
    string), you can use the `^` and `$` characters to represent the start and end
    of the string respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要控制项目是否出现在行首或行尾（或者字符串中没有换行符，或者在字符串的开始和结束处），你可以使用`^`和`$`字符分别表示字符串的开始和结束。
- en: 'If you want a pattern to match an entire string, it''s a good idea to include
    both of these:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个模式匹配整个字符串，包含这两个都很好主意：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We call the `^` and `$` characters "anchors." They anchor the match to the beginning
    or end of the string. What's important is that they don't literally match themselves;
    they're also called meta-characters. If we were doing fancy math typesetting,
    we'd use a different font to distinguish between `^` meaning anchored at the beginning
    and `^` meaning the actual `"^"` character. Since we don't have fancy math typesetting
    in Python code, we use `\` to distinguish between meta-character and ordinary
    character. In this case, `^` is a meta-character, and `\^` is the ordinary character.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称 `^` 和 `$` 字符为“锚点”。它们将匹配定位到字符串的开始或结束位置。重要的是，它们并不字面地匹配自身；它们也被称为元字符。如果我们进行复杂的数学排版，我们会使用不同的字体来区分表示“锚定在开始”的
    `^` 和表示实际字符 `"^"` 的 `^`。由于在 Python 代码中我们没有复杂的数学排版，我们使用 `\` 来区分元字符和普通字符。在这种情况下，`^`
    是一个元字符，而 `\^` 是一个普通字符。
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because we used `\^`, we need to match the `^` character in the string; this
    is not the meta-character acting as an anchor. Note that we used `r"\^hello…"`
    to create a raw string. Python's canonical display came back as `'\\^hello…'`.
    The canonical version – with double `\\` – can be awkward to type. While raw strings
    are easier to work with, they don't display the way we entered them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用了 `\^`，所以我们需要在字符串中匹配 `^` 字符；这并不是作为锚点的元字符。注意，我们使用了 `r"\^hello…"` 来创建一个原始字符串。Python
    的规范显示结果为 `'\\^hello…'`。带有双反斜杠的规范版本可能难以输入。虽然原始字符串更容易处理，但它们的显示方式与我们输入的方式不同。
- en: Matching a selection of characters
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配一组字符
- en: 'Let''s start with matching an arbitrary character. The period character, when
    used in a regular expression pattern, is a meta-character that stands for a set
    containing all characters. This will match any single character. Using a period
    in the string means you don''t care what the character is, just that there is
    a character there. Here is some example output from the `matchy()` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从匹配任意字符开始。在正则表达式模式中，点号字符是一个元字符，代表包含所有字符的集合。这将匹配任何单个字符。在字符串中使用点号意味着你不在乎字符是什么，只要那里有一个字符即可。以下是`matchy()`函数的一些示例输出：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how the last example does not match because there is no character at
    the period's position in the pattern. We can't match "nothing" without some extra
    features. We'll get to the idea of optional characters later in this section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后一个例子不匹配，因为模式中没有字符位于句号的位置。没有一些额外的特征，我们无法匹配“无”。我们将在本节稍后讨论可选字符的概念。
- en: 'That''s all well and good, but what if we only want a smaller set of characters
    to match? We can put a set of characters inside square brackets to match any one
    of those characters. So, if we encounter the string `[abc]` in a regular expression
    pattern, this defines a set of alternatives to match one character in the string
    being searched; this one character will be in the set of characters. Note that
    the `[]` around the set are meta-characters; they enclose the set and don''t match
    themselves. Let''s see a few examples:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不错，但如果我们只想匹配一组较小的字符集怎么办？我们可以在方括号内放置一组字符来匹配这些字符中的任何一个。所以，如果我们在一个正则表达式模式中遇到字符串`[abc]`，这定义了一组备选方案来匹配正在搜索的字符串中的一个字符；这个字符将位于字符集中。请注意，包围集合的`[]`是元字符；它们包含集合，并且不匹配自身。让我们看几个例子：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As with `^` and `$`, the characters `.`, `[` and `]` are meta-characters. Meta-characters
    define a more complex feature of a regular expression. If we want to actually
    match a `[` character, we'd use `\[` to escape the meta-meaning and understand
    this to match `[` instead of starting the definition of a class of characters.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `^` 和 `$` 一样，字符 `.`, `[` 和 `]` 是元字符。元字符定义了正则表达式的更复杂特性。如果我们想要实际匹配一个 `[` 字符，我们需要使用
    `\[` 来转义其元意义，并理解这是匹配 `[` 而不是开始定义字符类定义。
- en: 'These square bracket sets could be named *character sets*, but they are more
    often referred to as **character classes**. Often, we want to include a large
    range of characters inside these sets, and typing them all out can be monotonous
    and error-prone. Fortunately, the regular expression designers thought of this
    and gave us a shortcut. The dash character, in a character set, will create a
    range. This is especially useful if you want to match *all lowercase letters*, *all
    letters*, or *all numbers,* as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方括号集合可以命名为*字符集*，但它们更常被称为**字符类**。通常，我们希望在集合中包含大量字符，手动输入它们可能会很单调且容易出错。幸运的是，正则表达式设计者想到了这一点，并为我们提供了一个快捷方式。在字符集中，破折号字符将创建一个范围。如果你想要匹配*所有小写字母*、*所有字母*或*所有数字*，这尤其有用，如下所示：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are some character classes that are so common they have their own abbreviations.
    `\d` is digits, `\s` is whitespace, and `\w` is "word" characters. Instead of
    `[0-9]`, use `\d`. Instead of trying to enumerate all the Unicode whitespace characters,
    use `\s`. Instead of `[a-z0-9_]`, use `\w`. Here''s an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有些字符类非常常见，以至于它们有自己的缩写。`\d`代表数字，`\s`代表空白字符，`\w`代表“单词”字符。与其使用`[0-9]`，不如使用`\d`。与其尝试枚举所有Unicode空白字符，不如使用`\s`。与其使用`[a-z0-9_]`，不如使用`\w`。以下是一个示例：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Without the defined sets, this pattern would start out as `[0-9][0-9][ \t\n\r\f\v][A-Za-z0-9_][A-Za-z0-9_][A-Za-z0-9_]`.
    It gets quite long as we repeat the `[ \t\n\r\f\v]` class and the `[0-9]` class
    four more times.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义的集合，这个模式将开始为 `[0-9][0-9][ \t\n\r\f\v][A-Za-z0-9_][A-Za-z0-9_][A-Za-z0-9_]`。随着我们重复
    `[ \t\n\r\f\v]` 类和 `[0-9]` 类四次，它变得相当长。
- en: When defining a class with `[]`'s, the `–` becomes a meta-character. What if
    we want to match `[A-Z]` and `-`, too? We can do this by including the `–` at
    the very beginning or the very end; `[A-Z-]` means any character between `A` and
    `Z`, and the `-`, also.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`[]`定义一个类时，`-`变成了一个元字符。如果我们还想匹配`[A-Z]`和`-`，怎么办？我们可以通过将`-`放在非常开头或非常末尾来实现这一点；`[A-Z-]`表示在`A`和`Z`之间的任何字符，也包括`-`。
- en: Escaping characters
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: As we've noted above, a lot of characters have special meanings. For example,
    putting a period character in a pattern matches any arbitrary character. How do
    we match just a period in a string? We'll use backslashes to escape the special
    meaning and change the character from a meta-character (like a class definition,
    or an anchor or the start of a class) and understand it as an ordinary character.
    This means we'll often have a bunch of `\` characters in a regular expression,
    making r-strings really helpful.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们上面所提到的，许多字符具有特殊含义。例如，在一个模式中放置一个句号字符可以匹配任何任意字符。我们如何只匹配字符串中的一个句号呢？我们将使用反斜杠来转义特殊含义，并将字符从元字符（如类定义、锚点或类的开始）转变为一个普通字符来理解。这意味着我们通常会在正则表达式中有一系列的反斜杠字符，这使得r字符串变得非常有用。
- en: 'Here''s a regular expression to match two-digit decimal numbers between 0.00
    and 0.99:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于匹配0.00到0.99之间两位小数数字的正则表达式：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For this pattern, the two characters `\.` match the single `.` character. If
    the period character is missing or is a different character, it will not match.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个模式，两个字符`\.`匹配单个`.`字符。如果点号字符缺失或不是相同的字符，则不会匹配。
- en: This backslash escape sequence is used for a variety of special characters in
    regular expressions. You can use `\[` to insert a square bracket without starting
    a character class, and `\(` to insert a parenthesis, which we'll later see is
    also a meta-character.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反斜杠转义序列用于正则表达式中的各种特殊字符。你可以使用`\[`来插入一个方括号而不开始一个字符类，并且使用`\(`来插入一个括号，我们稍后将会看到它也是一个元字符。
- en: More interestingly, we can also use the escape symbol followed by a character
    to represent special characters such as newlines (`\n`) and tabs (`\t`). As we
    saw earlier, some character classes can be represented more succinctly using escape
    strings.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，我们还可以使用转义符号后跟一个字符来表示特殊字符，例如换行符（`\n`）和制表符（`\t`）。正如我们之前所看到的，一些字符类可以使用转义字符串更简洁地表示。
- en: To make the raw strings and backslashes more clear, we'll include the function
    calls again to show the code we wrote separate from Python's canonical display
    of the raw strings.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使原始字符串和反斜杠更加清晰，我们将再次包含函数调用，以展示我们编写的代码与Python对原始字符串的规范显示是分开的。
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To summarize, this use of a backslash has two distinct meanings:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这种反斜杠的使用有两种不同的含义：
- en: For meta-characters, a backslash escapes the meta-meaning. For example, `.`
    is a class of characters, whereas `\.` is a single character; similarly, `^` is
    an anchor at the start of a string, but `\^` is the hat character.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于元字符，反斜杠`\`可以使其摆脱元字符的意义。例如，`.`代表一类字符，而`\.`则代表单个字符；同样，`^`是字符串开头的锚点，但`\^`则是帽子字符。
- en: For a few ordinary characters, a backslash is used to name a character class.
    There aren't many examples of this; the most commonly used are `\s`, `\d`, `\w`,
    `\S`, `\D`, and `\W`. The uppercase variants, `\S`, `\D`, and `\W`, are the inverses
    of the lower case. For example, `\d` is any digit, and `\D` is any non-digit.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些普通字符，反斜杠用于命名字符类。这种用法并不常见；最常用的例子有 `\s`、`\d`、`\w`、`\S`、`\D` 和 `\W`。大写变体 `\S`、`\D`
    和 `\W` 是小写字母的逆。例如，`\d` 表示任何数字，而 `\D` 表示任何非数字。
- en: This odd distinction can be confusing at first. What's often helpful is to remember
    `\` in front of a letter creates a special case, whereas `\` in front of punctuation
    removes a meta-character meaning.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种奇怪的区别一开始可能会让人感到困惑。通常有帮助的是记住，字母前有一个反斜杠`\`会创建一个特殊情况，而标点符号前的`\`则移除了元字符的含义。
- en: Repeating patterns of characters
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符重复的模式
- en: With this information, we can match most strings of a known length, but most
    of the time, we don't know how many characters to match inside a pattern. Regular
    expressions can take care of this, too. We can modify a pattern with a suffix
    character. When we think of a regular expression as a product, a repeating sequence
    is like raising to a power. This follows the pattern of `a*a*a*a == a**4`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们能够匹配大多数已知长度的字符串，但大多数情况下，我们并不知道在模式内部需要匹配多少个字符。正则表达式也能处理这种情况。我们可以通过添加后缀字符来修改模式。当我们把正则表达式看作一个乘积时，一个重复的序列就像是对某个数进行幂运算。这遵循了`a*a*a*a
    == a**4`的模式。
- en: 'The asterisk (`*`) character says that the previous pattern can be matched
    zero or more times. This probably sounds silly, but it''s one of the most useful
    repetition characters. Before we explore why, consider some silly examples to
    make sure we understand what it does:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（`*`）字符表示前面的模式可以匹配零次或多次。这听起来可能有些荒谬，但它是最有用的重复字符之一。在我们探讨为什么之前，考虑一些荒谬的例子以确保我们理解它的作用：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, the `*` character in the pattern says that the previous pattern (the `l` character)
    is optional, and if present, can be repeated as many times as possible to match
    the pattern. The rest of the characters (`h`, `e`, and `o`) have to appear exactly
    once.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模式中的 `*` 字符表示前面的模式（即 `l` 字符）是可选的，如果存在，可以尽可能多地重复以匹配模式。其余的字符（`h`、`e` 和 `o`）必须恰好出现一次。
- en: 'This gets more interesting if we combine the asterisk with patterns that match
    multiple characters. So, `.*`, for example, will match any string, whereas `[a-z]*`
    matches any collection of lowercase letters, including the empty string. Here
    are a few examples:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将星号与匹配多个字符的模式结合起来，这会变得更加有趣。例如，`.*` 将匹配任何字符串，而 `[a-z]*` 则匹配任何由小写字母组成的集合，包括空字符串。以下是一些示例：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The plus (`+`) sign in a pattern behaves similarly to an asterisk; it states
    that the previous pattern can be repeated one or more times; this means the expression
    is not optional. The question mark (`?`) ensures a pattern shows up exactly zero
    or one times, but not more. Let''s explore some of these by playing with numbers
    (remember that `\d` matches the same character class as `[0-9]`):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '模式中加号（`+`）的行为类似于星号（`*`）；它表示前面的模式可以重复一次或多次；这意味着表达式不是可选的。问号（`?`）确保模式恰好出现零次或一次，但不能更多。让我们通过玩数字来探索这些模式（记住`\d`与`[0-9]`匹配相同的字符类）:'
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These examples illustrate the two different uses of `\`, also. For the `.` character,
    `\.` changes it from a meta-character that matches anything to a literal period.
    For the `d` character, `\d` changes it from a literal `d` to a class of characters,
    `[0-9]`. Don't forget that `*`, `+`, and `?` are meta-characters, and matching
    them literally means using `\*`, `\+`, or `\?`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子也说明了反斜杠 `\` 的两种不同用法。对于点号 `.` 字符，`\.` 将其从匹配任何内容的元字符转换为字面意义上的点号。对于字母 `d`，`\d`
    将其从字面意义上的 `d` 转换为字符类 `[0-9]`。别忘了 `*`、`+` 和 `?` 都是元字符，而字面匹配它们意味着使用 `\*`、`\+` 或
    `\?`。
- en: Grouping patterns together
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式分组
- en: 'So far, we''ve seen how we can repeat a pattern multiple times, but we are
    restricted in what patterns we can repeat. If we want to repeat individual characters,
    we''re covered, but what if we want a repeating sequence of characters? Enclosing
    any set of patterns in parentheses allows them to be treated as a single pattern
    when applying repetition operations. Compare these patterns:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何多次重复一个模式，但我们受到可以重复的模式类型的限制。如果我们想重复单个字符，我们没问题，但如果我们想重复字符序列呢？将任何一组模式用括号括起来，在应用重复操作时，它们可以被当作一个单独的模式来处理。比较以下模式：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This follows from the core mathematics behind regular expressions. The formulas
    ![](img/B17070_09_015.png) and ![](img/B17070_09_016.png) have dramatically different
    meanings.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这源于正则表达式背后的核心数学原理。公式 ![](img/B17070_09_015.png) 和 ![](img/B17070_09_016.png)
    具有截然不同的含义。
- en: 'Combined with complex patterns, this grouping feature greatly expands our pattern-matching
    repertoire. Here''s a regular expression that matches simple English sentences:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结合复杂模式，此分组功能极大地扩展了我们的模式匹配库。以下是一个匹配简单英文句子的正则表达式：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first word starts with a capital, followed by zero or more lowercase letters,
    `[A-Z][a-z]*`. Then, we enter a parenthetical that matches a single space followed
    by a word of one or more lowercase letters, `[a-z]+`. This entire parenthetical
    is repeated zero or more times, `( [a-z]+)*`. The pattern is terminated with a
    period. There cannot be any other characters after the period, as indicated by
    the `$` anchor at the end of the pattern.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一词以大写字母开头，后跟零个或多个小写字母，`[A-Z][a-z]*`。然后，我们进入一个括号表达式，匹配一个空格后跟一个由一个或多个小写字母组成的单词，`[a-z]+`。这个整个括号表达式可以重复零次或多次，`(
    [a-z]+)*`。模式以句号结束。句号之后不能有其他字符，如模式末尾的`$`锚点所示。
- en: We've seen many of the most basic patterns, but the regular expression language
    supports many more. It is worth bookmarking Python's documentation for the `re` module
    and reviewing it frequently. There are very few things that regular expressions
    cannot match, and they should be the first tool you reach for when parsing strings
    that don't involve complex recursive definitions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多最基本的模式，但正则表达式语言支持更多。值得将 Python 的 `re` 模块文档加入书签并经常查阅。正则表达式几乎可以匹配任何东西，因此在解析不涉及复杂递归定义的字符串时，它们应该是你首先考虑的工具。
- en: Parsing information with regular expressions
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正则表达式解析信息
- en: Let's now focus on the Python side of things. The regular expression syntax
    is the furthest thing from object-oriented programming. However, Python's `re` module
    provides an object-oriented interface to enter the regular expression engine.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在关注Python方面的事情。正则表达式语法与面向对象编程相去甚远。然而，Python的`re`模块提供了一个面向对象的接口来进入正则表达式引擎。
- en: We've been checking whether the `re.match()` function returns a valid object
    or not. If a pattern does not match, that function returns `None`. If it does
    match, however, it returns a useful object that we can inspect for information
    about the pattern.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在检查`re.match()`函数是否返回一个有效的对象。如果模式不匹配，该函数返回`None`。然而，如果它匹配，它将返回一个有用的对象，我们可以检查它以获取有关模式的信息。
- en: 'So far, our regular expressions have answered questions such as *does this
    string match this pattern?* Matching patterns is useful, but in many cases, a
    more interesting question is *if this string matches this pattern, what is the
    value of a relevant substring?* If you use groups to identify parts of the pattern
    that you want to reference later, you can get them out of the match return value,
    as illustrated in the next example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的正则表达式已经回答了诸如*这个字符串是否匹配这个模式？*的问题。匹配模式很有用，但在许多情况下，一个更有趣的问题可能是*如果这个字符串匹配这个模式，相关子串的值是多少？*如果你使用分组来标识你稍后想要引用的模式部分，你可以从匹配返回值中提取它们，如下一个示例所示：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The full specification describing all valid email addresses is extremely complicated,
    and the regular expression that accurately matches all possibilities is obscenely
    long. So, we cheated and made a smaller regular expression that matches many common
    email addresses; the point is that we want to access the domain name (after the `@` sign)
    so we can connect to that address. This is done easily by wrapping that part of
    the pattern in parentheses and calling the `group()` method on the object returned
    by `match()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 描述所有有效电子邮件地址的完整规范极其复杂，准确匹配所有可能性的正则表达式异常地长。因此，我们采取了欺骗手段，创建了一个更小的正则表达式，它可以匹配许多常见的电子邮件地址；关键是我们想访问域名（在`@`符号之后）以便我们可以连接到该地址。这可以通过将模式的一部分用括号括起来，并在`match()`方法返回的对象上调用`group()`方法轻松实现。
- en: We've used an additional argument value, `re.IGNORECASE`, to mark this pattern
    as case-independent. This saves us from having to use `[a-zA-Z…]` in three places
    in the pattern. It is a handy simplification when case doesn't matter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了额外的参数值，`re.IGNORECASE`，来标记这个模式为不区分大小写。这使我们不必在模式中三个地方都使用 `[a-zA-Z…]`。当大小写不重要时，这是一个方便的简化方法。
- en: There are three ways to collect the groups that match. We've used the `group()`
    method, which provides one matching group. Since there's only one pair of `()`'s,
    this seems prudent. The more general `groups()` method returns a tuple of all
    the `()` groups matched inside the pattern, which we can index to access a specific
    value. The groups are ordered from left to right. However, bear in mind that groups
    can be nested, meaning you can have one or more groups inside another group. In
    this case, the groups are returned in the order of their leftmost `(`'s, so the
    outermost group will be returned before its inner matching groups.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 收集匹配的组有三种方法。我们使用了`group()`方法，它提供一组匹配的组。由于只有一个`()`对，这似乎是谨慎的做法。更通用的`groups()`方法返回一个元组，包含模式内所有匹配的`()`组，我们可以通过索引来访问特定的值。组是从左到右排序的。然而，请注意，组可以是嵌套的，这意味着你可以在一个组内有一个或多个组。在这种情况下，组是按照它们最左边的`(`的顺序返回的，所以最外层的组会在其内部匹配的组之前返回。
- en: We can also provide names for groups. The syntax is very complex-looking. We
    have to use `(?P<name>…)` instead of `(…)` to collect the matched text as a group.
    The `?P<name>` is how we provide a group name of `name` inside the `()`'s. This
    lets us use the `groupdict()` method to extract names and their contents.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为组提供名称。语法看起来非常复杂。我们必须使用 `(?P<name>…)` 而不是 `(…)` 来收集匹配的文本作为一个组。`?P<name>`
    是我们在括号内提供名为 `name` 的组名的方式。这使得我们可以使用 `groupdict()` 方法来提取名称及其内容。
- en: 'Here''s an alternative to the email domain parser; this one uses named groups:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是电子邮件域名解析器的另一种选择；这个使用命名组：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've changed the pattern to add `?P<name>` and `?<domain>` inside the `()`'s
    to provide names to these capture groups. This part of the regular expression
    doesn't change what is matched, it provides names to the capture groups.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将模式修改为在括号`()`内添加`?P<name>`和`?<domain>`，以提供这些捕获组的名称。这部分正则表达式不会改变匹配的内容，它只是为捕获组提供名称。
- en: Other features of the re module
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: re模块的其他特性
- en: In addition to the `match()` function, the `re` module provides a couple of
    other useful functions, `search()` and `findall()`. The `search()` function finds
    the first instance of a matching pattern, relaxing the restriction that the pattern
    should be implicitly anchored to the first letter of the string. Note that you
    can get a similar effect by using `match()` and putting a  `.*` character at the
    front of the pattern to match any characters between the start of the string and
    the pattern you are looking for.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`match()`函数外，`re`模块还提供了一些其他有用的函数，例如`search()`和`findall()`。`search()`函数用于查找匹配模式的第一个实例，放宽了模式应该隐式锚定到字符串第一个字母的限制。请注意，您可以通过使用`match()`并在模式前添加一个`.*`字符来达到类似的效果，以匹配字符串开始和您要查找的模式之间的任何字符。
- en: The `findall()` function behaves similarly to `search()`, except that it finds
    all non-overlapping instances of the matching pattern, not just the first one.
    Think of it searching for the first match, then continuing the search after the
    end of the first matching to find the next one.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`findall()` 函数的行为与 `search()` 类似，但它找到的是匹配模式的全部非重叠实例，而不仅仅是第一个。可以将其想象为首先搜索第一个匹配项，然后在第一个匹配项结束后继续搜索以找到下一个匹配项。'
- en: 'Instead of returning a list of `re.Match` objects, as you would expect, it
    returns a list of matching strings, or tuples. Sometimes it''s strings, sometimes
    it''s tuples. It''s not a very good API at all! As with all bad APIs, you''ll
    have to memorize the differences and not rely on intuition. The type of the return
    value depends on the number of bracketed groups inside the regular expression:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与您预期的返回`re.Match`对象列表不同，它返回的是匹配的字符串列表或元组。有时是字符串，有时是元组。这根本不是一个好的API！和所有糟糕的API一样，您必须记住这些差异，而不能依赖直觉。返回值的类型取决于正则表达式内部括号组的数量：
- en: If there are no groups in the pattern, `re.findall()` will return a list of
    strings, where each value is a complete substring from the source string that
    matches the pattern
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中没有分组，`re.findall()`将返回一个字符串列表，其中每个值都是从源字符串中匹配到模式的完整子串
- en: If there is exactly one group in the pattern, `re.findall()` will return a list
    of strings where each value is the contents of that group
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中恰好有一个分组，`re.findall()` 将返回一个字符串列表，其中每个值都是该分组的内 容
- en: If there are multiple groups in the pattern, `re.findall()` will return a list
    of tuples where each tuple contains a value from a matching group, in order
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模式中有多个组，`re.findall()`将返回一个包含元组的列表，其中每个元组包含一个匹配组的值，顺序如下
- en: '**Consistency Helps**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性有助于**'
- en: When you are designing function calls in your own Python libraries, try to make
    the function always return a consistent data structure. It is often good to design
    functions that can take arbitrary inputs and process them, but the return value
    should not switch from a single value to a list, or a list of values to a list
    of tuples depending on the input. Let `re.findall()` be a lesson!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在设计自己的 Python 库中的函数调用时，尽量让函数总是返回一致的数据结构。设计能够接受任意输入并处理它们的函数通常是好的，但返回值不应该根据输入从单个值切换到列表，或者从值列表切换到元组列表。让
    `re.findall()` 成为我们的教训！
- en: 'The examples in the following interactive session will hopefully clarify the
    differences:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互会话中的示例有望阐明差异：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It seems like it's always a good practice to decompose the data elements to
    the extent possible. In this case, we separated the numeric value from the units,
    hours, minutes, or seconds, making it easier to convert a complex string into
    a time interval.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来尽可能分解数据元素总是一个好的实践。在这种情况下，我们将数值与单位、小时、分钟或秒分离开来，这使得将一个复杂的字符串转换成时间间隔变得更加容易。
- en: Making regular expressions efficient
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使正则表达式高效
- en: Whenever you call one of the regular expression methods, the `re module` has
    to convert the pattern string into an internal structure that makes searching
    strings fast. This conversion takes a non-trivial amount of time. If a regular
    expression pattern is going to be reused multiple times (for example, inside a `for` or `while` statement),
    it would be better if this conversion step could be done only once.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用正则表达式方法时，`re 模块` 都必须将模式字符串转换为一种内部结构，以便快速搜索字符串。这种转换需要相当多的时间。如果正则表达式模式将被多次使用（例如，在
    `for` 或 `while` 语句中），那么最好只进行一次这种转换步骤。
- en: 'This is possible with the `re.compile()` method. It returns an object-oriented
    version of the regular expression that has been compiled down and has the methods
    we''ve explored (`match()`, `search()`, and `findall()`), among others. The changes
    to what we''ve seen are minor. Here''s what we''ve been using:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`re.compile()`方法实现。它返回一个经过编译的面向对象的正则表达式对象，该对象具有我们已探索的方法（如`match()`、`search()`和`findall()`）等。对我们所看到的内容的改变是微小的。以下是我们的使用方法：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can create a two-step operation, where a single pattern is reused for a number
    of strings.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个两步操作，其中单个模式被重复用于多个字符串。
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Compiling the patterns in advance of using them is a handy optimization. It
    makes the application slightly simpler and a bit more efficient.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前预先编译模式是一种方便的优化。这使得应用程序稍微简单一些，并且更有效率。
- en: 'This has definitely been a condensed introduction to regular expressions. At
    this point, we have a good feel for the basics and will recognize when we need
    to do further research. If we have a string pattern-matching problem, regular
    expressions will almost certainly be able to solve them for us. However, we may
    need to look up new syntax in a more comprehensive coverage of the topic. But
    now we know what to look for! Some tools, like Pythex at [https://pythex.org](https://pythex.org),
    can help develop and debug regular expressions. Let''s move on to a completely
    different topic: filesystem paths.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是对正则表达式的简要介绍。到目前为止，我们对基础知识有了很好的感觉，并且会知道何时需要进一步研究。如果我们有一个字符串模式匹配问题，正则表达式几乎肯定能够为我们解决它们。然而，我们可能需要在一个更全面的正则表达式主题覆盖中查找新的语法。但现在我们知道该寻找什么了！一些工具，如
    Pythex 在 [https://pythex.org](https://pythex.org)，可以帮助开发和调试正则表达式。让我们继续到一个完全不同的主题：文件系统路径。
- en: Filesystem paths
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统路径
- en: Most operating systems provide a *filesystem*, a way of mapping a logical abstraction
    of *directories* (often depicted as *folders*) and *files* to the bits and bytes
    stored on a hard drive or another storage device. As humans, we typically interact
    with the filesystem using a drag-and-drop interface with images of folders and
    files of different types. Or we can use command-line programs such as `cp`, `mv`,
    and `mkdir`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都提供了一个**文件系统**，这是一种将逻辑抽象的**目录**（通常表示为**文件夹**）和**文件**映射到硬盘或另一个存储设备上存储的位和字节的方法。作为人类，我们通常通过带有文件夹和不同类型文件图像的拖放界面与文件系统进行交互。或者，我们可以使用如`cp`、`mv`和`mkdir`之类的命令行程序。
- en: As programmers, we have to interact with the filesystem with a series of system
    calls. You can think of these as library functions supplied by the operating system
    so that programs can call them. They have a clunky interface with integer file
    handles and buffered reads and writes, and that interface is different depending
    on which operating system you are using. The Python `os` module exposes some of
    these underlying calls.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们必须通过一系列系统调用来与文件系统进行交互。你可以把它们看作是操作系统提供的库函数，以便程序可以调用它们。它们有一个笨拙的接口，包括整数文件句柄和缓冲的读写操作，而且这个接口根据你使用的操作系统而有所不同。Python
    的 `os` 模块暴露了其中一些底层调用。
- en: 'Inside the `os` module is the `os.path` module. While it works, it''s not very
    intuitive. It requires a lot of string concatenation and you have to be conscious
    of OS differences. For example, there is an `os.sep` attribute representing the
    path separator; that''s a "`/`" on POSIX-compliant OSes and "`\`" for Windows.
    Using it can lead to code that looks like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`os`模块中包含`os.path`模块。虽然它能够工作，但并不十分直观。它需要大量的字符串连接操作，并且你必须注意操作系统之间的差异。例如，有一个`os.sep`属性表示路径分隔符；在符合POSIX规范的操作系统上它是"`/`"，而在Windows上是"`\`"。使用它可能会导致如下所示的代码：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `os.path` module conceals some of the platform-specific details. But this
    still forces us to work with paths as strings.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path` 模块隐藏了一些平台特定的细节。但这一点仍然迫使我们以字符串的形式处理路径。'
- en: Working with filesystem paths in the form of strings is often irritating. Paths
    that are easy to type on the command line become illegible in Python code. When
    working with multiple paths (for example, when processing images in a data pipeline
    for a machine learning computer vision problem), just managing those directories
    becomes a bit of an ordeal.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串形式的文件系统路径通常令人烦恼。在命令行上容易输入的路径在Python代码中变得难以辨认。当处理多个路径时（例如，在处理机器学习计算机视觉问题中的数据管道中的图像时），仅仅管理这些目录就变成了一件有点麻烦的事情。
- en: 'So, the Python language designers included a module called `pathlib` in the
    standard library. It''s an object-oriented representation of paths and files that
    is much more pleasant to work with. The preceding path, using `pathlib`, would
    look like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python语言设计者将一个名为`pathlib`的模块包含在了标准库中。它是对路径和文件的对象化表示，与使用起来更加愉快。使用`pathlib`的前一个路径看起来会是这样：
- en: '[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, it's quite a bit easier to see what's going on. Notice the unique
    use of the division operator as a path separator so you don't have to do anything
    with `os.sep`. This is an elegant use of overloading Python's `__truediv__()`
    method to provide this feature for `Path` object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，观察正在发生的事情要容易得多。注意除法运算符的独特用法，作为路径分隔符，这样你就不必对`os.sep`做任何事情。这是对Python的`__truediv__()`方法进行重载的优雅应用，为`Path`对象提供这一功能。
- en: 'In a more real-world example, consider some code that counts the number of
    lines of code – excluding whitespace and comments – in all Python files in a given
    directory and subdirectories:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更贴近现实世界的例子中，考虑一些代码，这些代码可以计算给定目录及其子目录中所有Python文件中代码行的数量——不包括空白和注释：
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In typical `pathlib` usage, we rarely have to construct many `Path` objects.
    In this example, the base `Path` is provided as a parameter. The bulk of the `Path`
    manipulation is locating other files or directories relative to a given `Path`.
    The rest of the `Path`-related processing is asking for attributes of a specific
    `Path`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的`pathlib`使用中，我们很少需要构造许多`Path`对象。在这个例子中，基本的`Path`作为参数提供。大部分的`Path`操作是定位相对于给定`Path`的其他文件或目录。其余的与`Path`相关的处理是请求特定`Path`的属性。
- en: The `count_sloc()` function looks at the name of the path, skipping names beginning
    with "`.`". This avoids the "`.`" and "`..`" directories, but it also skips directories
    like `.tox`, `.coverage`, or `.git` that are created by our tools.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_sloc()` 函数会查看路径名称，跳过以 "`.`" 开头的名称。这避免了 "`.`" 和 "`..`" 目录，但它也会跳过由我们的工具创建的类似
    `.tox`、`.coverage` 或 `.git` 的目录。'
- en: 'There are three general cases:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种一般情况：
- en: Actual files that might have Python source. We make sure the suffix of the file
    name is `.py` to be sure we want to open the file. We'll call the given `scanner()`
    function to open and read each Python file. There are several approaches to counting
    source code; we've shown one here, in the `scan_python_1()` function that should
    be provided as an argument value.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际文件可能包含 Python 源代码。我们确保文件名的后缀是 `.py` 以确保我们想要打开该文件。我们将调用给定的 `scanner()` 函数来打开并读取每个
    Python 文件。在计算源代码方面有几种方法；我们在这里展示了其中一种，即在 `scan_python_1()` 函数中，该函数应作为参数值提供。
- en: Directories. In this case, we iterate through the directory's content, calling
    `count_sloc()` on the items we find inside this directory.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录。在这种情况下，我们遍历目录的内容，对我们在这个目录内找到的项调用`count_sloc()`函数。
- en: Other filesystem objects like device mount names, symbolic links, devices, FIFO
    queues, and sockets. We ignore these.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他文件系统对象，如设备挂载名称、符号链接、设备、FIFO队列和套接字。我们忽略这些。
- en: The `Path.open` method takes similar arguments to the `open` built-in function,
    but it uses a more object-oriented syntax. We can use `Path('./README.md').open()` to
    open the file for reading, if the path already exists.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path.open` 方法与内置的 `open` 函数具有类似的参数，但它使用更面向对象的语法。我们可以使用 `Path(''./README.md'').open()`
    来打开文件进行读取，如果路径已存在。'
- en: The `scan_python_1()` function iterates over each line in the file and adds
    it to the count. We skip whitespace and comment lines, since these don't represent
    actual source code. The total count is returned to the calling function.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan_python_1()` 函数遍历文件中的每一行并将其添加到计数中。我们跳过空白行和注释行，因为这些并不代表实际的源代码。总计数被返回到调用函数。'
- en: Here's how we invoke this function to count lines of code in one directory.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何调用此函数来统计一个目录中的代码行数。
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This shows the one-and-only `Path()` constructor in this fairly complex example.
    We leap up to the parent directory from the **current working directory** (**CWD**).
    From there we can descend into the `ch_02` subdirectory and rummage around, looking
    at directories and Python files.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了这个相当复杂的例子中唯一的 `Path()` 构造函数。我们从 **当前工作目录**（**CWD**）跳转到父目录。从那里我们可以进入 `ch_02`
    子目录并四处翻找，查看目录和 Python 文件。
- en: This also shows how we provide the `scan_python_1()` function as the argument
    value for the scanner parameter. For more insight into using functions as parameters
    to other functions, see *Chapter 8*, *The Intersection of Object-Oriented and
    Functional Programming*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这也展示了我们如何将`scan_python_1()`函数作为扫描参数的参数值。要深入了解将函数作为其他函数的参数的使用，请参阅*第8章*，*面向对象与函数式编程的交汇点*。
- en: 'The `Path` class in the `pathlib` module has a method or property to cover
    pretty much everything you might want to do with a path. In addition to those
    we covered in the example, here are a few more methods and attributes of a `Path`
    object:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 模块中的 `Path` 类拥有一个方法或属性，几乎可以覆盖你想要对路径进行的所有操作。除了我们在示例中提到的那些之外，这里还有一些
    `Path` 对象的额外方法和属性：'
- en: '`.absolute()` returns the full path from the root of the filesystem. This helps
    show where relative paths came from.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.absolute()` 返回从文件系统根目录开始的完整路径。这有助于显示相对路径的来源。'
- en: '`.parent` returns a path to the parent directory.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.parent` 返回父目录的路径。'
- en: '`.exists()` checks whether the file or directory exists.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.exists()` 检查文件或目录是否存在。'
- en: '`.mkdir()` creates a directory at the current path. It takes Boolean `parents` and `exist_ok` arguments
    to indicate that it should recursively create the directories if necessary and
    that it shouldn''t raise an exception if the directory already exists.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.mkdir()` 在当前路径下创建一个目录。它接受 `parents` 和 `exist_ok` 参数来指示如果需要应递归创建目录，并且如果目录已存在则不应抛出异常。'
- en: Refer to the standard library documentation at [https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html) for
    even more uses. The authors are proud to have contributed to this library.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考标准库文档[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)以获取更多用法。作者们自豪地为这个库做出了贡献。
- en: 'Almost all of the standard library modules that accept a string path can also
    accept a `pathlib.Path` object. An `os.PathLike` type hint is used to describe
    parameters that accept a `Path`. For example, you can open a ZIP file by passing
    a path into it:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有接受字符串路径的标准库模块也可以接受一个`pathlib.Path`对象。使用`os.PathLike`类型提示来描述接受`Path`的参数。例如，你可以通过传递一个路径来打开一个ZIP文件：
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Some external packages may not work with `Path` objects. In those cases, you'll
    have to cast the path to a string using `str(pathname)`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一些外部包可能无法与`Path`对象一起使用。在这种情况下，您需要使用`str(pathname)`将路径转换为字符串。
- en: '**Statements vs. Lines of Code**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**语句与代码行**'
- en: The `scan_python_1()` function counts each line of a triple-quoted, multi-line
    strings as if they're lines of code. If we're sure each *physical* line matters,
    then a long docstring might be relevant, even when it's not really code. On the
    other hand, we might decide that we want to count meaningful *statements* instead
    of physical lines; in this case, we'll need a smarter function that uses the `ast`
    module. It's far, far better to work with the **Abstract Syntax Trees** (**ASTs**)
    than it is to try and work with the source text. Using the `ast` module doesn't
    change the `Path` processing. It's a little more complex than reading the text,
    and outside the scope of this book. If we count statements (not lines that could
    be statements or could be triple-quoted comments) there are 257 statements, in
    542 lines of code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`scan_python_1()` 函数将三引号的多行字符串中的每一行都当作代码行来计数。如果我们确定每一行*物理*上的内容都很重要，那么即使它实际上不是代码，一个长的文档字符串也可能是有意义的。另一方面，我们可能决定我们想要计数有意义的*语句*而不是物理行；在这种情况下，我们需要一个更智能的函数，该函数使用
    `ast` 模块。与尝试处理源文本相比，与**抽象语法树**（**ASTs**）一起工作要好得多。使用 `ast` 模块不会改变 `Path` 处理。这比阅读文本要复杂一些，并且超出了本书的范围。如果我们计数语句（而不是可能是语句或可能是三引号注释的行），那么有
    257 个语句，分布在 542 行代码中。'
- en: We've looked at working strings, bytes, and filesystem paths. The next concept
    we need to cover is how to save our application's objects to files and recovering
    objects from the bytes of a file. We call this process serialization.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了工作字符串、字节和文件系统路径。接下来，我们需要介绍如何将应用程序的对象保存到文件中，以及如何从文件的字节中恢复对象。我们称这个过程为序列化。
- en: Serializing objects
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象序列化
- en: We've been working with bytes and file paths as foundations that support working
    with persistent objects. To make an object persistent, we need to create a series
    of bytes that represent the state of the object, and write those bytes to a file.
    The missing piece of persistence, then, is this process of encoding objects as
    a series of bytes. We also want to decode objects and their relationships from
    a series of bytes. This encoding and decoding is also described as **serializing**
    and **deserializing**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用字节和文件路径作为支持处理持久化对象的基础。为了使一个对象持久化，我们需要创建一系列代表对象状态的字节，并将这些字节写入文件。因此，持久化过程中缺失的部分就是将对象编码为一系列字节的过程。我们还想从一系列字节中解码对象及其关系。这种编码和解码过程也被称为**序列化**和**反序列化**。
- en: 'When we look at web services, we''ll often see a service described as RESTful.
    The "REST" concept is REpresentational State Transfer; the server and client will
    exchange representations of object states. The distinction here can be helpful:
    the two pieces of software don''t exchange objects. The applications have their
    own internal objects; they exchange a representation of object state.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看网络服务时，经常会看到一个服务被描述为RESTful。这里的“REST”概念代表的是表现层状态转移；服务器和客户端将交换对象状态的表示。这里的区别可能很有帮助：这两块软件并不交换对象。应用程序有自己的内部对象；它们交换的是对象状态的表示。
- en: There are several ways to serialize objects. We'll start with a simple and general
    approach using the `pickle` module. Later, we'll look at the `json` package as
    an alternative.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对象序列化的方法有多种。我们将从使用`pickle`模块的一个简单且通用的方法开始。稍后，我们将探讨`json`包作为替代方案。
- en: The Python `pickle` module is an object-oriented way to store object state directly
    in a special storage format. It essentially converts an object's state (and all
    the state of all the objects it holds as attributes) into a series of bytes that
    can be stored or transported however we see fit.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `pickle` 模块是一种面向对象的方式，可以直接将对象状态存储在一种特殊的存储格式中。它本质上将对象的状态（以及它作为属性持有的所有对象的状态）转换成一系列字节，这些字节可以按我们的需求进行存储或传输。
- en: 'For basic tasks, the `pickle` module has an extremely simple interface. It
    comprises four basic functions for storing and loading data: two for manipulating
    file-like objects, and two for manipulating `bytes` objects so we can work with
    pickled objects without necessarily having an open file.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本任务，`pickle`模块提供了一个极其简单的接口。它包含四个基本函数用于存储和加载数据：两个用于操作类似文件的对象，另外两个用于操作`bytes`对象，这样我们就可以在不一定需要打开文件的情况下处理序列化对象。
- en: The `dump()` method accepts an object to be written and a file-like object to
    write the serialized bytes to. A file-like object must have a `write()` method,
    and that method must know how to handle a `bytes` argument. This means a file
    opened for text output wouldn't work; we need to open the file with a mode value
    of `wb`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump()` 方法接受一个要写入的对象和一个用于写入序列化字节的类似文件对象。类似文件对象必须有一个 `write()` 方法，并且该方法必须知道如何处理
    `bytes` 参数。这意味着以文本输出打开的文件将不起作用；我们需要以 `wb` 模式打开文件。'
- en: 'The `load()` method does exactly the opposite; it reads a serialized object''s
    state from a file-like object. This object must have the proper file-like `read()`
    and `readline()` methods, each of which must, of course, return `bytes`. The `pickle` module
    will read the bytes and the `load()` method will return the fully reconstructed
    object. Here''s an example that stores and then loads some data in a list object:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`方法正好相反；它从一个类似文件的对象中读取序列化对象的状态。此对象必须具有适当的类似文件`read()`和`readline()`方法，每个方法当然都必须返回`bytes`。`pickle`模块将读取这些字节，而`load()`方法将返回完全重建的对象。以下是一个示例，它在一个列表对象中存储一些数据，然后加载这些数据：'
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This code serializes the object referred to by `some_list`. This includes the
    associated strings, and dictionaries, and even an integer. This is stored in the
    file and then loaded from the same file. In each case, we open the file using
    a `with` statement so that it is automatically closed. We've been careful to use
    modes of `wb` and `rb` to be sure the file is in bytes mode instead of text mode.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码序列化由 `some_list` 指向的对象。这包括相关的字符串、字典，甚至整数。这些数据被存储在文件中，然后从同一文件中加载。在每种情况下，我们使用
    `with` 语句打开文件，以确保它自动关闭。我们已小心使用 `wb` 和 `rb` 模式，以确保文件处于字节模式而不是文本模式。
- en: The `assert` statement at the end would raise an error if the newly loaded object
    was not equal to the original object. Equality does not imply that they are the
    same object. Indeed, if we were to print the `id()` of both objects, we would
    discover they are distinct objects with distinct internal identifiers. However,
    because they are both lists whose contents are equal, the two lists are also considered
    equal.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾的`assert`语句会在新加载的对象与原始对象不相等时引发错误。相等性并不意味着它们是同一个对象。实际上，如果我们打印出两个对象的`id()`，我们会发现它们是具有不同内部标识符的不同对象。然而，由于它们都是内容相等的列表，这两个列表也被认为是相等的。
- en: The `dumps()` and `loads()` functions behave much like their file-like counterparts,
    except they return or accept `bytes` instead of file-like objects. The `dumps` function
    requires only one argument, the object to be stored, and it returns a serialized `bytes` object.
    The `loads()` function requires a `bytes` object and returns the restored object.
    The `'s'` character in the method names is short for string; it's a legacy name
    from ancient versions of Python, where `str` objects were used instead of `bytes`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumps()` 和 `loads()` 函数的行为与它们的文件类对应函数非常相似，只是它们返回或接受的是 `bytes` 而不是文件类对象。`dumps`
    函数只需要一个参数，即要存储的对象，并返回一个序列化的 `bytes` 对象。`loads()` 函数需要一个 `bytes` 对象，并返回恢复的对象。方法名中的
    `''s''` 字符代表字符串；它是 Python 早期版本中的一个遗留名称，在那个版本中，使用 `str` 对象而不是 `bytes`。'
- en: It is possible to call `dump()` or `load()` on a single open file more than
    once. Each call to `dump` will store a single object (plus any objects it is composed
    of or contains), while a call to `load()` will load and return just one object.
    So, for a single file, each separate call to `dump()` when storing the object
    should have an associated call to `load()` when restoring at a later date.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个已打开文件上可以多次调用`dump()`或`load()`。每次对`dump`的调用将存储一个单独的对象（以及它所组成的或包含的任何对象），而`load()`的调用将加载并返回一个对象。因此，对于单个文件，在存储对象时对`dump()`的每次单独调用都应该在稍后恢复时有一个相关的`load()`调用。
- en: It's important to be aware that the representation of the state of an object
    is highly focused on a specific major release of Python. A pickle file created
    in Python 3.7, for example, may not be usable by Python 3.8\. This suggests that
    pickle files are good for temporary persistence, but not suitable for long-term
    storage or sharing among Python applications that might not all have a common
    version.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，对象的表示高度集中在Python的一个特定主要版本上。例如，在Python 3.7中创建的pickle文件可能无法被Python 3.8使用。这表明pickle文件适合临时持久化，但不适合长期存储或在不同可能不具有相同版本的Python应用程序之间共享。
- en: 'The process of recovering the state of an object from a pickled representation
    can – under some circumstances – result in evaluating arbitrary code buried in
    the pickle file. This means a pickle file can be a vector for malicious code.
    This leads to a prominent warning in the documentation for the pickle module:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从序列化表示恢复对象状态的过程在某些情况下可能会导致评估 pickle 文件中埋藏的任意代码。这意味着 pickle 文件可能成为恶意代码的载体。这导致在
    pickle 模块的文档中有一个显著的警告：
- en: '**Warning**'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: The pickle module is not secure. Only unpickle data you trust.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块不安全。仅解包你信任的数据。'
- en: This advice generally leads us to avoid accepting pickle-format files without
    trusting the sender and having assurance no person in the middle has tampered
    with the file. An application that uses a pickle for a temporary cache has nothing
    to worry about.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建议通常引导我们避免在没有信任发送者并确保中间没有人篡改文件的情况下接受pickle格式的文件。使用pickle作为临时缓存的应用程序无需担忧。
- en: Customizing pickles
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制泡菜
- en: With most common Python objects, pickling *just works*. Basic primitive types
    such as integers, floats, and strings can be pickled, as can any container objects,
    such as lists or dictionaries, provided the contents of those containers are also
    picklable. Further, and importantly, any object can be pickled, so long as all
    of its attributes are also picklable.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数常见的 Python 对象，序列化（pickling）*总是有效*。基本原始类型，如整数、浮点数和字符串，可以被序列化，同样，任何容器对象，如列表或字典，也可以被序列化，前提是这些容器的内容也必须是可序列化的。此外，并且非常重要的一点是，任何对象都可以被序列化，只要它的所有属性也都是可序列化的。
- en: So, what makes an attribute unpicklable? Usually, it has something to do with
    dynamic attribute values subject to change. For example, if we have an open network
    socket, open file, running thread, subprocess, processing pool, or database connection
    stored as an attribute on an object, it will not make sense to pickle these objects.
    Device and operating system state will be meaningless when we attempt to reload
    the object later. We can't just pretend the original thread or socket connection
    exists when we reload! No, we need to somehow customize how such transient and
    dynamic data is dumped and loaded.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么使得一个属性不可序列化？通常，这与可能发生变化的动态属性值有关。例如，如果我们有一个打开的网络套接字、打开的文件、正在运行的线程、子进程、处理池或作为对象属性存储的数据库连接，那么对这些对象进行序列化就没有意义了。当我们尝试稍后重新加载对象时，设备和操作系统状态将变得毫无意义。我们不能假装原始的线程或套接字连接在重新加载时仍然存在！不，我们需要以某种方式自定义如何转储和加载这种短暂和动态的数据。
- en: 'Here''s a class that loads the contents of a web page every hour to ensure
    that they stay up to date. It uses the `threading.Timer` class to schedule the
    next update:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个每小时加载网页内容的类，以确保内容保持最新。它使用`threading.Timer`类来安排下一次更新：
- en: '[PRE60]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Objects like `url`, `contents`, and `last_updated` are all picklable, but if
    we try to pickle an instance of this class, things go a little nutty on the `self.timer` instance:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `url`、`contents` 和 `last_updated` 这样的对象都是可序列化的，但如果尝试序列化这个类的实例，`self.timer`
    实例就会变得有点疯狂：
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That's not a very useful error, but it looks like we're trying to pickle something
    we shouldn't be pickling. That would be the `Timer` instance; we're storing a
    reference to `self.timer` in the `schedule()` method, and that attribute cannot
    be serialized.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很有用的错误，但看起来我们正在尝试对不应该pickle的东西进行pickle操作。那将是`Timer`实例；我们在`schedule()`方法中存储了对`self.timer`的引用，而这个属性不能被序列化。
- en: When `pickle` tries to serialize an object, it simply tries to store the state,
    the value of the object's `__dict__` attribute; `__dict__` is a dictionary mapping
    all the attribute names on the object to their values. Luckily, before checking `__dict__`, `pickle` checks
    to see whether a `__getstate__()` method exists. If it does, it will store the
    return value of that method instead of the `__dict__` object.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当`pickle`尝试序列化一个对象时，它只是尝试存储状态，即对象的`__dict__`属性值；`__dict__`是一个字典，将对象上的所有属性名映射到它们的值。幸运的是，在检查`__dict__`之前，`pickle`会检查是否存在一个`__getstate__()`方法。如果存在，它将存储该方法的返回值而不是`__dict__`对象。
- en: 'Let''s add a `__getstate__()` method to our `URLPolling` class that simply
    returns a copy of the `__dict__` without the unpicklable timer object:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`URLPolling`类中添加一个`__getstate__()`方法，该方法简单地返回一个不包含不可序列化的计时器对象的`__dict__`的副本：
- en: '[PRE62]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we pickle an instance of this expanded version of `URLPolling`, it will no
    longer fail. And we can even successfully restore that object using `loads()`.
    However, the restored object doesn't have a `self.timer` attribute, so it will
    not be refreshing the content like it is designed to do. We need to somehow create
    a new timer (to replace the missing one) when the object is unpickled.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个`URLPolling`扩展版本的实例进行序列化，它将不再失败。我们甚至可以使用`loads()`方法成功恢复该对象。然而，恢复的对象没有`self.timer`属性，因此它不会像设计的那样刷新内容。我们需要在对象反序列化时以某种方式创建一个新的计时器（以替换缺失的那个）。
- en: 'As we might expect, there is a complementary `__setstate__()` method that can
    be implemented to customize unpickling. This method accepts a single argument,
    which is the object returned by `__getstate__`. If we implement both methods,
    `__getstate__()` is not required to return a dictionary, since `__setstate__()`
    will know what to do with whatever object `__getstate__()` chooses to return.
    In our case, we simply want to restore the `__dict__`, and then create a new timer:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可能预料的，存在一个可以实现的互补的 `__setstate__()` 方法来定制反序列化过程。此方法接受一个单一参数，即由 `__getstate__`
    返回的对象。如果我们实现了这两个方法，`__getstate__()` 就不需要返回一个字典，因为 `__setstate__()` 会知道如何处理 `__getstate__()`
    选择返回的任何对象。在我们的情况下，我们只是想恢复 `__dict__`，然后创建一个新的计时器：
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The parallels between `__init__()` and `__setstate__()` are important. Both
    involve a call to `self.schedule()` to create (or recreate) the internal timer
    object. This is a common pattern for working with pickled objects that have dynamic
    state that must be recovered.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 和 `__setstate__()` 之间的相似之处很重要。两者都涉及到调用 `self.schedule()` 来创建（或重新创建）内部计时器对象。这是处理具有动态状态且必须恢复的序列化对象时的常见模式。'
- en: The `pickle` module is very flexible and provides other tools to further customize
    the pickling process if you need them. However, these are beyond the scope of
    this book. The tools we've covered are sufficient for many basic pickling tasks.
    Objects to be pickled are normally relatively simple data objects. Some of the
    popular machine learning frameworks, like scikit-learn, use `pickle` to preserve
    the model that was created. This lets a data scientist use the model for predictions
    or for further testing.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 模块非常灵活，并提供其他工具以供进一步自定义序列化过程，如果您需要的话。然而，这些内容超出了本书的范围。我们已涵盖的工具对于许多基本的序列化任务已经足够。要序列化的对象通常是相对简单的数据对象。一些流行的机器学习框架，如
    scikit-learn，使用 `pickle` 来保存创建的模型。这使得数据科学家可以使用该模型进行预测或进一步测试。'
- en: Because of the security limitation, we need an alternative format for exchanging
    data. A text-based format can be helpful because it's often easier to inspect
    a text file to be sure it isn't malicious. We'll look at JSON as a popular text-based
    serialization format.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全限制，我们需要一个用于交换数据的替代格式。基于文本的格式可能很有帮助，因为通常检查一个文本文件以确保它不是恶意的要容易得多。我们将探讨JSON作为一种流行的基于文本的序列化格式。
- en: Serializing objects using JSON
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 序列化对象
- en: There are many formats that have been used for text-based data exchange over
    the years. **Extensible Markup Language** (**XML**) is popular, but the files
    tend to be large. **Yet Another Markup Language** (**YAML**) is another format
    that you may see referenced occasionally. Tabular data is frequently exchanged
    in the **Comma-Separated Value** (**CSV**) format. Many of these are fading into
    obscurity and there are many more that you will encounter over time. Python has
    solid standard or third-party libraries for all of them.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年，用于文本数据交换的格式有很多。**可扩展标记语言**（**XML**）很受欢迎，但文件往往很大。**另一种标记语言**（**YAML**）是另一种偶尔会提到的格式。表格数据通常以**逗号分隔值**（**CSV**）格式交换。其中许多正在逐渐消失，你将在未来遇到更多。Python
    为它们都提供了稳固的标准库或第三方库。
- en: Before using such libraries on untrusted data, make sure to investigate security
    concerns with each of them. XML and YAML, for example, both have obscure features
    that, used maliciously, can allow arbitrary commands to be executed on the host
    machine. These features may not be turned off by default. Do your research. Even
    something as simple-seeming as a ZIP file or a JPEG image can be hacked to create
    a data structure that can crash a web server.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些库处理不可信数据之前，务必调查每个库的安全问题。例如，XML 和 YAML 都有一些不为人知的特性，如果被恶意使用，可能会允许在宿主机器上执行任意命令。这些特性可能默认并未关闭。做好你的研究。即使是看似简单的
    ZIP 文件或 JPEG 图像也可能被黑客攻击，创建出可能导致网页服务器崩溃的数据结构。
- en: '**JavaScript Object Notation** (**JSON**) is a human-readable format for exchanging
    data. JSON is a standard format that can be interpreted by a wide array of heterogeneous
    client systems. This means JSON is extremely useful for transmitting data between
    completely decoupled systems. The JSON format does not have any support for executable
    code; because only data can be serialized, it is more difficult to inject malicious
    content.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种可读性强的数据交换格式。JSON是一种标准格式，可以被各种异构客户端系统解释。这意味着JSON在传输完全解耦的系统之间的数据时极为有用。JSON格式不支持可执行代码；因为只有数据可以被序列化，因此注入恶意内容更为困难。'
- en: Because JSON can be easily interpreted by JavaScript engines, it is often used
    for transmitting data from a web server to a JavaScript-capable web browser. If
    the web application serving the data is written in Python, the server needs a
    way to convert internal data into the JSON format.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON可以被JavaScript引擎轻松解析，它通常用于从Web服务器传输数据到具有JavaScript功能的Web浏览器。如果提供数据的服务器应用程序是用Python编写的，那么服务器需要一种方法将内部数据转换为JSON格式。
- en: 'There is a module to do this, predictably named `json`. This module provides
    a similar interface to the `pickle` module, with `dump()`, `load()`, `dumps()`,
    and `loads()` functions. The default calls to these functions are nearly identical
    to those in `pickle`, so let''s not repeat the details. There are a couple of
    differences: obviously, the output of these calls is valid JSON notation, rather
    than a pickled object. In addition, the `json` functions operate on `str` objects,
    rather than `bytes`. Therefore, when dumping to or loading from a file, we need
    to create text files rather than binary ones.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个模块可以完成这个任务，其名称很自然地被命名为`json`。这个模块提供了一个与`pickle`模块类似的接口，包括`dump()`、`load()`、`dumps()`和`loads()`函数。这些函数的默认调用几乎与`pickle`中的调用相同，所以这里就不重复细节了。存在一些差异：显然，这些调用的输出是有效的JSON表示，而不是一个序列化对象。此外，`json`函数操作的是`str`对象，而不是`bytes`。因此，当我们向文件中写入或从文件中读取时，我们需要创建文本文件而不是二进制文件。
- en: The JSON serializer is not as robust as the `pickle` module; it can only serialize
    basic types such as integers, floats, and strings, and simple containers such
    as dictionaries and lists. Each of these has a direct mapping to a JSON representation,
    but JSON is unable to represent objects unique to Python like class or function
    definitions.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: JSON序列化器不如`pickle`模块强大；它只能序列化基本类型，如整数、浮点数和字符串，以及简单的容器，如字典和列表。这些每个都有直接映射到JSON表示的形式，但JSON无法表示Python特有的对象，如类或函数定义。
- en: 'Generally, the `json` module''s functions try to serialize the object''s state
    using the value of the object''s `__dict__` attribute. A better approach is to
    supply custom code to serialize an object''s state into a JSON-friendly dictionary.
    We also want to go the other way: deserializing a JSON dictionary to recover a
    Python object''s state.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`json`模块的函数尝试使用对象的`__dict__`属性值来序列化对象的状态。一个更好的方法是提供自定义代码来将对象的状态序列化为一个JSON友好的字典。我们还想走另一条路：将JSON字典反序列化以恢复Python对象的状态。
- en: In the `json` module, both the object encoding and decoding functions accept
    optional arguments to customize the behavior. The `dump()` and `dumps()` functions
    accept a poorly named `cls` keyword argument. (It's short for "class", which we
    have to spell funny because `class` is a reserved keyword.) If this argument value
    is provided to the function, it should be a subclass of the `JSONEncoder` class,
    with the `default()` method overridden. This overridden `default()` method accepts
    an arbitrary Python object and converts it to a dictionary that `json` can serialize.
    If it doesn't know how to process the object, we should call the `super()` method,
    so that it can take care of serializing basic types in the normal way.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在`json`模块中，对象编码和解码函数都接受可选参数以自定义行为。`dump()`和`dumps()`函数接受一个命名不佳的`cls`关键字参数。（它是“class”的缩写，我们不得不以奇怪的方式拼写，因为`class`是一个保留关键字。）如果这个参数值被提供给函数，它应该是一个`JSONEncoder`类的子类，并且重写了`default()`方法。这个重写的`default()`方法接受一个任意的Python对象，并将其转换为`json`可以序列化的字典。如果它不知道如何处理该对象，我们应该调用`super()`方法，这样它就可以以正常方式处理基本类型的序列化。
- en: The `load()` and `loads()` methods also accept such a `cls` argument that can
    be a subclass of the inverse class, `JSONDecoder`. However, it is normally sufficient
    to pass a function into these methods using the `object_hook` keyword argument.
    This function accepts a dictionary and returns an object; if it doesn't know what
    to do with the input dictionary, it can return it unmodified.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()` 和 `loads()` 方法也接受一个 `cls` 参数，该参数可以是逆类 `JSONDecoder` 的子类。然而，通常情况下，只需使用
    `object_hook` 关键字参数将这些方法传递一个函数即可。这个函数接受一个字典并返回一个对象；如果它不知道如何处理输入字典，它可以返回未修改的字典。'
- en: 'Let''s look at an example. Imagine we have the following simple contact class
    that we want to serialize:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。想象一下，我们有一个以下简单的联系人类，我们希望对其进行序列化：
- en: '[PRE64]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can try to serialize the `__dict__` attribute:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试序列化`__dict__`属性：
- en: '[PRE65]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'But accessing the special `__dict__` attribute in this fashion is kind of crude.
    This can lead to problems when an attribute has a value that''s not already serialized
    by the `json` module; `datetime` objects are a common problem. Also, what if the
    receiving code (perhaps some JavaScript on a web page) wanted that `full_name` property
    to be supplied? Of course, we could construct the dictionary by hand, but let''s
    create a custom encoder instead:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但以这种方式访问特殊的 `__dict__` 属性有点粗糙。当属性具有 `json` 模块尚未序列化的值时，这可能会导致问题；`datetime` 对象就是一个常见的问题。此外，如果接收代码（可能是一些网页上的
    JavaScript）希望提供 `full_name` 属性怎么办？当然，我们可以手动构造字典，但让我们创建一个自定义编码器代替：
- en: '[PRE66]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `default` method needs to check to see what kind of object we're trying
    to serialize. If it's a `Contact`, we convert it to a dictionary manually. Otherwise,
    we let the parent class handle serialization (by assuming that it is a basic type,
    which `json` knows how to handle). Notice that we pass an extra attribute to identify
    this object as a contact, since there would be no way to tell upon loading it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法需要检查我们试图序列化的对象类型。如果是`Contact`类型，我们手动将其转换为字典。否则，我们让父类处理序列化（假设它是一个基本类型，`json`知道如何处理）。请注意，我们传递了一个额外的属性来识别这个对象是一个联系人，因为在加载时无法区分。
- en: In some cases, we may want to provide a more complete, fully qualified name,
    including the package and module. Remember that the format of the dictionary depends
    on the code at the receiving end; there has to be an agreement as to how the data
    is going to be specified.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要提供一个更完整、完全限定的名称，包括包和模块。记住，字典的格式取决于接收端的代码；必须就如何指定数据达成一致。
- en: 'We can use this class to encode a contact by passing the class (not an instantiated
    object) to the `dump` or `dumps` function:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将类（而不是实例化对象）传递给`dump`或`dumps`函数来使用这个类来编码一个联系人：
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For decoding, we can write a function that accepts a dictionary and checks
    the existence of the `__class__` attribute to decide whether to convert it to
    a `Contact` instance or leave it as a default dictionary:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解码，我们可以编写一个函数，该函数接受一个字典并检查是否存在`__class__`属性，以决定是否将其转换为`Contact`实例或保持为默认字典：
- en: '[PRE68]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can pass this function to the `load()` or `loads()` function using the `object_hook` keyword
    argument:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`object_hook`关键字参数将此函数传递给`load()`或`loads()`函数：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: These examples show how we can use JSON to exchange objects that encode a number
    of common Python objects. For uncommon Python objects, there are straightforward
    ways to add an encoder or a decoder to handle more complex cases. In larger applications,
    we might include a special `to_json()` method to produce a useful serialization
    of an object.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了我们如何使用 JSON 来交换编码了多个常见 Python 对象的对象。对于不常见的 Python 对象，有直接的方法添加编码器或解码器来处理更复杂的情况。在更大的应用程序中，我们可能包括一个特殊的
    `to_json()` 方法来生成一个有用的对象序列化。
- en: Case study
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: In the previous chapters of the case study, we've been skirting an issue that
    arises frequently when working with complex data. Files have both a logical layout
    and a physical format. We've been laboring under a tacit assumption that our files
    are in CSV format, with a layout defined by the first line of the file. In *Chapter
    2,* we touched on file loading. In *Chapter 6*, we revisited loading data and
    partitioning it into training and testing sets.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在案例研究的上一章节中，我们一直在回避一个在处理复杂数据时经常出现的问题。文件既有逻辑布局也有物理格式。我们一直隐含地假设我们的文件是CSV格式，布局由文件的第一行定义。在*第二章*中，我们提到了文件加载。在*第六章*中，我们重新讨论了数据的加载以及将其划分为训练集和测试集。
- en: In both previous chapters, we trusted that the data would be in a CSV format.
    This isn't a great assumption to make. We need to look at the alternatives and
    elevate our assumptions into a design choice. We also need to build in the flexibility
    to make changes as the context for using our application evolves.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们相信数据将以 CSV 格式存在。这不是一个很好的假设。我们需要考虑替代方案，并将我们的假设提升为设计选择。同时，我们也需要构建灵活性，以便随着我们应用使用环境的演变而进行更改。
- en: It's common to map complex objects to dictionaries, which have a tidy JSON representation.
    For this reason, the `Classifier` web application makes use of dictionaries. We
    can also parse CSV data into dictionaries. The idea of working with dictionaries
    provides a kind of grand unification of CSV, Python, and JSON. We'll start by
    looking at the CSV format before moving on to some alternatives for serialization,
    like JSON.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂对象映射到字典中是很常见的，因为字典有整洁的JSON表示形式。因此，`Classifier` 网络应用程序利用了字典。我们还可以将CSV数据解析成字典。与字典一起工作的想法为CSV、Python和JSON提供了一种某种意义上的大统一。我们将首先查看CSV格式，然后再探讨一些序列化的替代方案，如JSON。
- en: CSV format designs
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV格式设计
- en: We can make use of the `csv` module to read and write files. **CSV** stands
    for **Comma-Separated Values**, designed (originally) to export and import data
    from a spreadsheet.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`csv`模块来读取和写入文件。**CSV**代表**逗号分隔值**，最初是为了从电子表格中导出和导入数据而设计的。
- en: The CSV format describes a sequence of rows. Each row is a sequence of strings.
    That's all there is, and it can be a bit of a limitation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: CSV格式描述了一组行。每一行是一组字符串。这就是全部，但也可能存在一定的局限性。
- en: The "comma" in CSV is a role, not a specific character. The purpose of this
    character is to separate the columns of data. For the most part, the role of the
    comma is played by the literal "`,`". But other actors can fill this role. It's
    common to see the tab character, written as "`\t`" or "`\x09`", fill the role
    of the comma.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: CSV中的“逗号”是一个角色，而不是一个特定的字符。这个字符的作用是分隔数据列。在大多数情况下，逗号的角色由字面上的“`,`”扮演。但其他字符也可以承担这个角色。常见的做法是使用制表符字符，写作“`\t`”或“`\x09`”，来扮演逗号的角色。
- en: The end-of-line is often the CRLF sequence, written as "`\r\n`" or `\x0d\x0a`.
    On macOS X and Linux, it's also possible to use a single newline character, `\n`,
    at the end of each row. Again, this is a role, and other characters could be used.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾通常是 CRLF 序列，写作 "`\r\n`" 或 `\x0d\x0a`。在 macOS X 和 Linux 上，每行末尾也可以使用单个换行符，`\n`。同样，这只是一个角色，还可以使用其他字符。
- en: In order to contain the comma character within a column's data, the data can
    be quoted. This is often done by surrounding a column's value with the `"` character.
    It's possible to specify a different quote character when describing a CSV dialect.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在列的数据中包含逗号字符，可以将数据引用起来。这通常是通过在列的值周围使用 `"` 字符来实现的。在描述CSV方言时，可以指定不同的引用字符。
- en: 'Because CSV data is simply a sequence of strings, any other interpretation
    of the data requires processing by our application. For example, within the `TrainingSample` class,
    the `load()` method includes processing like the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 CSV 数据仅仅是字符串的序列，对数据的任何其他解释都需要通过我们的应用程序进行处理。例如，在 `TrainingSample` 类中，`load()`
    方法包括如下处理：
- en: '[PRE70]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This `load()` method extracts specific column values from each row, applies
    a conversion function to build a Python object from the text, and uses all of
    the attribute values to build a resulting object.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `load()` 方法从每一行中提取特定的列值，将转换函数应用于文本以构建一个 Python 对象，并使用所有属性值来构建结果对象。
- en: There are two ways to consume (and produce) CSV-formatted data. We can work
    with each row as a dictionary, or we can process each row as a simple list of
    strings. We'll look at both alternatives to see how well they apply to the data
    in our case study.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 消费（和生成）CSV格式数据的两种方式。我们可以将每一行作为一个字典来处理，或者将每一行处理为一个简单的字符串列表。我们将探讨这两种方法，看看它们在我们的案例研究中适用得如何。
- en: CSV dictionary reader
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV 字典读取器
- en: We can read CSV files as a sequence of strings, or as a dictionary. When we
    read the file as a sequence of strings, there are no special provisions for column
    headers. We're forced to manage the details of which column has a particular attribute.
    This is unpleasantly complex, but sometimes necessary.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 CSV 文件读取为字符串序列，或者作为字典。当我们以字符串序列读取文件时，没有为列标题做特殊处理。我们被迫管理哪些列具有特定属性的细节。这很复杂，但有时是必要的。
- en: We can also read a CSV file so each row becomes a dictionary. We can provide
    a sequence of keys, or the first line of the file can provide the keys. This is
    relatively common, and it saves a little bit of confusion when the column headers
    are part of the data.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以读取 CSV 文件，使每一行成为一个字典。我们可以提供一个键的序列，或者文件的第一行可以提供键。这是相对常见的做法，当列标题是数据的一部分时，它可以减少一些混淆。
- en: We've been looking at the Bezdek Iris data for our case study. There's a copy
    of the data in the Kaggle repository, [https://www.kaggle.com/uciml/iris](https://www.kaggle.com/uciml/iris).
    The data is also available at [https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris).
    The UCI Machine Learning Repository file, `bezdekIris.data`, does not have column
    titles; these are provided separately in a file named `iris.names`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究 Bezdek Iris 数据集作为我们的案例研究。该数据集的副本可在 Kaggle 仓库中找到，[https://www.kaggle.com/uciml/iris](https://www.kaggle.com/uciml/iris)。数据同样可在
    [https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)
    获取。UCI 机器学习仓库中的文件 `bezdekIris.data` 没有列标题；这些标题在名为 `iris.names` 的单独文件中提供。
- en: 'The `iris.names` file has a great deal of information in it, including this
    in section 7 of the document:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`iris.names` 文件中包含大量信息，包括文档第7节中的以下内容：'
- en: '[PRE71]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This defines the five columns of data. This separation between the metadata
    and the sample data isn't ideal, but we can copy and paste this information into
    code to make something useful from it.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了五列数据。元数据与样本数据之间的这种分离并不理想，但我们可以将此信息复制粘贴到代码中，从而使其变得有用。
- en: 'We''ll use it to define an Iris reader class as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用它来定义一个 Iris 读取器类，如下所示：
- en: '[PRE72]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We transformed the documentation into a sequence of column names. The transformation
    isn't arbitrary. We matched the resulting `KnownSample` class attribute names.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文档转换成一系列列名。这种转换并非随意为之。我们匹配了结果`KnownSample`类的属性名称。
- en: In relatively simple applications, there's a single source of data, so the attribute
    names for classes and column names for CSV files are easy to keep aligned. This
    isn't always the case. In some problem domains, the data may have several variant
    names and formats. We may choose attribute names that seem good, but may not simply
    match any of the input files.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在相对简单的应用中，数据来源单一，因此类和CSV文件列的属性名称容易保持一致。但这并不总是如此。在某些问题领域，数据可能有多个变体名称和格式。我们可能会选择看似合适的属性名称，但可能并不简单地匹配任何输入文件。
- en: The `data_iter()` method has a name suggesting it is an iterator over multiple
    data items. The type hint (`Iterator[Dict[str, str]]`) confirms this. The function
    uses `yield from` to provide rows from the CSV `DictReader` object as they're
    demanded by a client process.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_iter()` 方法有一个表明它是多个数据项迭代器的名字。类型提示 (`Iterator[Dict[str, str]]`) 确认了这一点。该函数使用
    `yield from` 来按需提供来自 CSV `DictReader` 对象的行。'
- en: This is a "lazy" way to read lines from the CSV as they're required by another
    object. The iterator is like a factory using kanban techniques – it prepares data
    in response to demand. This doesn't slurp in the entire file, creating a gigantic
    list of dictionaries. Instead, the iterator produces one dictionary at a time,
    as they're requested.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种“懒惰”的方式来读取CSV文件中的行，因为它们被另一个对象所需要。迭代器就像是一个使用看板技术的工厂——它根据需求准备数据。这种方式不会一次性将整个文件吸入，从而创建一个庞大的字典列表。相反，迭代器每次只产生一个字典，正如它们被请求的那样。
- en: 'One way to request data from an iterator is to use the built-in `list()` function.
    We can use this class as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 从迭代器请求数据的一种方法是通过使用内置的`list()`函数。我们可以这样使用这个类：
- en: '[PRE73]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The CSV `DictReader` produces a dictionary. We provided the keys for this dictionary
    with the `self.header` value; an alternative is to use the first row of the file
    as the keys. In this case, the file doesn't have column headers in the first row,
    so we provided column headers.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 的 `DictReader` 生成一个字典。我们使用 `self.header` 的值提供了这个字典的键；另一种选择是使用文件的第一个行作为键。在这种情况下，文件的第一行没有列标题，因此我们提供了列标题。
- en: The `data_iter()` method produces rows for a consuming class or function. In
    this example, the `list()` function consumes the available rows. As expected,
    the dataset has 150 rows. We've shown the first row.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_iter()` 方法为消费类或函数生成行。在这个例子中，`list()` 函数消费了可用的行。正如预期的那样，数据集有 150 行。我们已经展示了第一行。'
- en: 'Note that the attribute values are strings. This is always true when reading
    CSV files: all of the input values are strings. Our application must convert the
    strings to `float` values to be able to create `KnownSample` objects.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意属性值是字符串。在读取CSV文件时这一点始终成立：所有输入值都是字符串。我们的应用程序必须将字符串转换为`float`类型的值，以便能够创建`KnownSample`对象。
- en: 'Another way to consume values is with a `for` statement. This how the `load()`
    method of the `TrainingData` class works. It uses code that looks like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种消费值的方式是使用`for`循环语句。这就是`TrainingData`类的`load()`方法是如何工作的。它使用如下所示的代码：
- en: '[PRE74]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We combine an `IrisReader` object with this object to load the samples. It
    looks like this:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`IrisReader`对象与这个对象结合来加载样本。它看起来是这样的：
- en: '[PRE75]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `load()` method will consume values produced by the `data_iter()` method.
    The loading of the data is a cooperative process from the two objects.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`方法将消耗由`data_iter()`方法产生的值。数据的加载是两个对象之间的协作过程。'
- en: Working with CSV data as dictionaries seems to be very handy. To show an alternative,
    we'll turn to reading data using a non-dictionary CSV reader.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 将CSV数据作为字典处理似乎非常方便。为了展示一种替代方法，我们将转向使用非字典CSV读取器来读取数据。
- en: CSV list reader
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV 列表读取器
- en: The non-dictionary CSV reader produces a list of strings from each row. This
    is not what our `TrainingData` collection's `load()` method expects, however.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 非字典CSV读取器从每一行生成一个字符串列表。然而，这并不是我们的`TrainingData`集合的`load()`方法所期望的。
- en: 'We have two choices to meet the interface requirement for the `load()` method:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个选择来满足`load()`方法的接口要求：
- en: Convert the list of column values to a dictionary.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列值列表转换为字典。
- en: Change `load()` to use a list of values in a fixed order. This would have the
    unfortunate consequence of forcing the `load()` method of the `TrainingData` class to
    match a specific file layout. Alternatively, we'd have to re-order input values
    to match the requirements of `load()`; doing this is about as complex as building
    a dictionary.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`load()`方法改为使用固定顺序的值列表。这会带来一个不幸的后果，即迫使`TrainingData`类的`load()`方法与特定的文件布局相匹配。或者，我们不得不重新排序输入值以匹配`load()`的要求；这样做大约与构建字典一样复杂。
- en: Building a dictionary seems relatively easy; this allows the `load()` method
    to work with data where the column layout varies from our initial expectation.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个字典似乎相对简单；这使得`load()`方法能够处理列布局与我们的初始预期不同的数据。
- en: Here's a `CSVIrisReader_2` class that uses `csv.reader()` to read a file, and
    builds dictionaries based on the attribute information published in the `iris.names` file.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为 `CSVIrisReader_2` 的类，它使用 `csv.reader()` 来读取文件，并根据在 `iris.names` 文件中发布的属性信息构建字典。
- en: '[PRE76]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `data_iter()` method yields individual dictionary objects. This `for-with-yield`
    summarizes what a `yield from` does. When we write `yield from X`, that is effectively
    the same as the longer
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_iter()` 方法产生单个字典对象。这个 `for-with-yield` 概括了 `yield from` 的作用。当我们写 `yield
    from X` 时，这实际上等同于更长的'
- en: '[PRE77]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: For this application, the non-dictionary processing works by creating a dictionary
    from the input row. This doesn't seem to have any advantage over the `csv.DictReader`
    class.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，非字典处理是通过从输入行创建一个字典来工作的。这似乎并没有比`csv.DictReader`类有任何优势。
- en: The other big alternative is JSON serialization. We'll look at ways to apply
    the techniques shown in this chapter to our case study data.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的选择是 JSON 序列化。我们将探讨如何将本章中展示的技术应用到我们的案例研究数据中。
- en: JSON serialization
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON序列化
- en: 'The JSON format can serialize a number of commonly used Python object classes,
    including:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式可以序列化多种常用的Python对象类，包括：
- en: None
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无（None）
- en: Boolean
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Float and integer
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数和整数
- en: String
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Lists of compatible objects
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容对象列表
- en: Dictionaries with string keys and compatible objects as values
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串键和兼容对象值的字典
- en: The "compatible objects" can include nested structures. This dictionary-within-list
    and dictionary-within-dictionary recursion can allow JSON to represent very complex
    things.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '"兼容对象"可以包括嵌套结构。这种列表内的字典和字典内的字典递归可以允许JSON表示非常复杂的事物。'
- en: 'We might consider a theoretical (but invalid) type hint like the following:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑以下一个理论上的（但无效的）类型提示：
- en: '[PRE78]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This hint isn''t directly supported by **mypy**, because it involves explicit
    recursion: the JSON type is defined based on the JSON type. This hint can be a
    helpful conceptual framework for understanding what we can represent in JSON notation.
    As a practical matter, we often use `Dict[str, Any]` to describe JSON objects,
    ignoring the details of other structures that might be present. We can be a little
    more specific, though, when we know the expected keys for the dictionary; we''ll
    expand on this below.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示在**mypy**中并不直接支持，因为它涉及显式递归：JSON类型是基于JSON类型定义的。这个提示可以作为一个有助于理解我们在JSON表示法中可以表示什么的概念框架。从实际的角度来看，我们通常使用`Dict[str,
    Any]`来描述JSON对象，忽略可能存在的其他结构的细节。然而，当我们知道字典的预期键时，我们可以更加具体一些；我们将在下面展开讨论。
- en: 'In JSON notation, our data will look like this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 表示法中，我们的数据将看起来像这样：
- en: '[PRE79]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note that the numeric values don't have quotation marks, and they will be converted
    to `float` values if they have a `.` character or converted to an integer if they
    lack the `.` character.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数值没有引号，如果它们包含`.`字符，则会被转换为`float`值，如果它们缺少`.`字符，则会被转换为整数。
- en: 'The [json.org](http://json.org) standards require a single JSON object in a
    file. This encourages us to create a "list-of-dict" structure. Pragmatically,
    the structure of the file can be summarized by this type hint:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[json.org](http://json.org) 标准要求文件中包含一个单独的 JSON 对象。这促使我们创建一个“字典列表”结构。从实用主义的角度来看，文件的结构可以通过以下类型提示来概括：'
- en: '[PRE80]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The document – as a whole – is a list. It contains a number of dictionaries
    that map string keys to either float or string values.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 该文档——作为一个整体——是一个列表。它包含多个将字符串键映射到浮点数或字符串值的字典。
- en: 'Above, we noted that we can be more specific about the keys expected. In this
    case, we want to limit our application to working with specific dictionary keys.
    We can be a bit more precise, by using the `typing.TypedDict` hint:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们可以对预期的键更加具体。在这种情况下，我们希望将我们的应用程序限制为只处理特定的字典键。我们可以通过使用`typing.TypedDict`提示来更加精确：
- en: '[PRE81]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This can be helpful to **mypy** (and other people reading our code) by showing
    what the expected structure *should* be. We can even add `total=True` to assert
    that the definition shows the entire domain of valid keys.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于**mypy**（以及其他阅读我们代码的人）来说可能很有帮助，因为它展示了预期的结构*应该是*怎样的。我们甚至可以添加`total=True`来断言定义显示了所有有效键的整个域。
- en: This `TypedDict` hint doesn't really confirm the contents of the JSON document
    are valid or sensible, however. Remember, **mypy** is only a static check on the
    code, and has no runtime impact. To check the JSON document's structure, we'll
    need something more sophisticated than a Python type hint.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TypedDict`提示并不能真正确认JSON文档的内容是否有效或合理。记住，**mypy**只对代码进行静态检查，并且没有运行时影响。要检查JSON文档的结构，我们需要比Python类型提示更复杂的东西。
- en: 'Here''s our JSON reader class definition:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的 JSON 读取器类定义：
- en: '[PRE82]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We've opened the source file and loaded the list-of-dict objects. We can then
    yield the individual sample dictionaries by iterating over the list.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了源文件并加载了字典列表对象。然后我们可以通过遍历列表来逐个生成样本字典。
- en: This has a hidden cost. We'll look at how newline-delimited JSON – a modification
    to the standard – can help reduce the memory used.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这存在一个隐藏的成本。我们将探讨如何通过修改标准，使用换行符分隔的 JSON 来帮助减少使用的内存。
- en: Newline-delimited JSON
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 换行符分隔的 JSON
- en: For large collections of objects, reading a single, massive list into memory
    first isn't ideal. The "newline-delimited" JSON format, described by [ndjson.org](http://ndjson.org),
    provides a way to put a large number of separate JSON documents into a single
    file.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大量对象的集合，首先将单个庞大的列表读入内存并不是理想的做法。由[ndjson.org](http://ndjson.org)描述的“按行分隔”的JSON格式提供了一种将大量单独的JSON文档放入单个文件的方法。
- en: 'The file would look like this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 文件将看起来像这样：
- en: '[PRE83]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: There's no overall `[]` to create a list. Each individual sample *must* be complete
    on one physical line of the file.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 没有整体的`[]`来创建列表。每个单独的样本*必须*在文件的单独一行中完整。
- en: 'This leads to a slight difference in the way we process the sequence of documents:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们在处理文档序列的方式上存在细微的差异：
- en: '[PRE84]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We''ve read each line of the file and used `json.loads()` to parse the single
    string into a sample dictionary. The interface is the same: an `Iterator[SampleDict]`.
    The technique for producing that iterator is unique to newline-delimited JSON.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经读取了文件中的每一行，并使用`json.loads()`将单个字符串解析成样本字典。接口保持一致：一个`Iterator[SampleDict]`。生成该迭代器的技术是针对以换行符分隔的JSON的独特方法。
- en: JSON validation
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON验证
- en: We noted that our **mypy** type hint doesn't really guarantee the JSON document
    is – in any way – what we expected. There is a package in the Python Package Index
    that can be used for this. The `jsonschema` package lets us provide a specification
    for a JSON document, and then confirm whether or not the document meets the specification.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到我们的**mypy**类型提示并不能真正保证JSON文档确实是我们所期望的。Python包索引中有一个包可以用于此目的。`jsonschema`包允许我们为JSON文档提供一个规范，然后确认文档是否符合该规范。
- en: 'We''ll need to install an additional library to do the validation:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装一个额外的库来进行验证：
- en: '[PRE85]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The JSON Schema validation is a runtime check, unlike the **mypy** type hint.
    This means using validation will make our program slower. It can also help to
    diagnose subtly incorrect JSON documents. For details, see [https://json-schema.org](https://json-schema.org). This
    is evolving toward standardization, and there are several versions of compliance
    checking available.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 验证是一个运行时检查，与 **mypy** 类型提示不同。这意味着使用验证会使我们的程序变慢。它还可以帮助诊断微小的 JSON
    文档错误。有关详细信息，请参阅 [https://json-schema.org](https://json-schema.org)。这正朝着标准化方向发展，并且有多个符合性检查版本可用。
- en: We'll focus on newline-delimited JSON. This means we need a schema for each
    sample document within the larger collection of documents. This kind of additional
    validation might be relevant when receiving a batch of unknown samples to classify.
    Before doing anything, we'd like to be sure the sample document has the right
    attributes.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于换行符分隔的 JSON。这意味着在更大的文档集合中，我们需要为每个样本文档定义一个模式。当接收一批未知样本进行分类时，这种额外的验证可能相关。在采取任何行动之前，我们希望确保样本文档具有正确的属性。
- en: A JSON Schema document is also written in JSON. It includes some metadata to
    help clarify the purpose and meaning of the document. It's often a little easier
    to create a Python dictionary with the JSON Schema definition.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 文档也使用 JSON 编写。它包含一些元数据，有助于阐明文档的目的和意义。通常，使用 JSON Schema 定义创建 Python
    字典会稍微容易一些。
- en: 'Here''s a candidate definition for the Iris schema for an individual sample:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个针对单个样本的 Iris 架构的候选定义：
- en: '[PRE86]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Each sample is an `object`, the JSON Schema term for a dictionary with keys
    and values. The `properties` of an object are the dictionary keys. Each one of
    these is described with a type of data, `number` in this case. We can provide
    additional details, like ranges of values. We provided a description, taken from
    the `iris.names` file.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 每个样本都是一个 `object`，这是 JSON Schema 中用于表示具有键和值的字典的术语。对象的 `properties` 是字典的键。这些键中的每一个都用数据类型进行描述，在这种情况下是
    `number`。我们可以提供额外的细节，例如值的范围。我们提供了一个描述，取自 `iris.names` 文件。
- en: In the case of the `species` property, we've provided an enumeration of the
    valid string values. This can be handy for confirming that the data meets our
    overall expectations.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在`species`属性的情况下，我们提供了一系列有效的字符串值。这有助于确认数据是否符合我们的整体预期。
- en: 'We use this schema information by creating a `jsonschema` validator and applying
    the validator to check each sample we read. An extended class might look like
    this:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个`jsonschema`验证器并应用该验证器来检查我们读取的每个样本来使用这个模式信息。一个扩展的类可能看起来像这样：
- en: '[PRE87]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We've accepted an additional parameter in the `__init__()` method with the schema
    definition. We use this to create the `Validator` instance that will be applied
    to each document.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`__init__()`方法中接受了一个额外的参数，该参数包含模式定义。我们使用这个参数来创建将应用于每个文档的`Validator`实例。
- en: The `data_iter()` method uses the `is_valid()` method of `validator` to process
    only samples that pass the JSON Schema validation. The others will be reported
    and ignored. We've printed the output using the `print()` function. It would be
    smarter to use the `file=sys.stderr` keyword parameter to direct the output to
    the error output. It would be even better to use the `logging` package to write
    error messages to a log.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_iter()` 方法使用 `validator` 的 `is_valid()` 方法来处理仅通过 JSON Schema 验证的样本。其他样本将被报告并忽略。我们使用
    `print()` 函数打印了输出。使用 `file=sys.stderr` 关键字参数将输出定向到错误输出会更聪明。使用 `logging` 包将错误消息写入日志会更好。'
- en: 'Note that we now have two separate, but similar definitions for the raw data
    that builds a `Sample` instance:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在有两个独立的、但类似的定义用于构建`Sample`实例的原始数据：
- en: A type hint, `SampleDict`, describing the expected Python intermediate data
    structure. This can be applied to CSV as well as JSON data, and helps summarize
    the relationship between the `load()` method of the `TrainingData` class, and
    the various readers.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于描述预期 Python 中间数据结构的类型提示 `SampleDict`。这同样适用于 CSV 以及 JSON 数据，并有助于总结 `TrainingData`
    类的 `load()` 方法与各种读取器之间的关系。
- en: A JSON Schema that *also* describes an expected external data structure. This
    doesn't describe a Python object, it describes the JSON serialization of a Python
    object.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个同时描述预期外部数据结构的 JSON Schema。这并不描述一个 Python 对象，而是描述了 Python 对象的 JSON 序列化。
- en: For very simple cases, these two descriptions of the data seem redundant. In
    more complex situations, however, these two will diverge, and fairly complex conversions
    between external schema, intermediate results, and the final class definition
    is a common feature of Python applications. This occurs because there are a variety
    of ways to serialize Python objects. We need to be flexible enough to work with
    a useful variety of representations.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的情况，这两种数据描述似乎有些冗余。然而，在更复杂的情况下，这两种描述将会出现分歧，并且在外部模式、中间结果和最终类定义之间的相当复杂的转换是Python应用程序的常见特征。这是因为序列化Python对象有多种方式。我们需要足够灵活，以便与各种有用的表示形式一起工作。
- en: Recall
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'In this chapter, we''ve looked at the following topics:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了以下主题：
- en: The ways to encode strings into bytes and decode bytes into strings. While some
    older character encodings (like ASCII) treat bytes and characters alike, this
    leads to confusion. Python text can be any Unicode character and Python bytes
    are numbers in the range 0 to 255.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串编码为字节以及将字节解码为字符串的方法。虽然一些较老的字符编码（如ASCII）将字节和字符同等对待，但这会导致混淆。Python文本可以是任何Unicode字符，而Python字节是范围在0到255之间的数字。
- en: String formatting lets us prepare string objects that have template pieces and
    dynamic pieces. This works for a lot of situations in Python. One is to create
    readable output for people, but we can use f-strings and the string `format()`
    method everywhere we're creating a complex string from pieces.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串格式化允许我们准备包含模板片段和动态片段的字符串对象。这在Python中的许多情况下都适用。其中之一是为人们创建可读的输出，但我们可以在从各个部分创建复杂字符串的任何地方使用f字符串和字符串`format()`方法。
- en: We use regular expressions to decompose complex strings. In effect, a regular
    expression is the opposite of a fancy string formatter. Regular expressions struggle
    to separate the characters we're matching from "meta-characters" that provide
    additional matching rules, like repetition or alternative choices.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用正则表达式来分解复杂的字符串。实际上，正则表达式与花哨的字符串格式化器正好相反。正则表达式在区分我们要匹配的字符和提供额外匹配规则（如重复或选择）的“元字符”方面存在困难。
- en: We've looked at a few ways to serialize data, including Pickle, CSV, and JSON.
    There are other formats, including YAML, that are similar enough to JSON and Pickle
    that we didn't need to cover them in detail. Other serializations like XML and
    HTML are quite a bit more complex, and we've avoided them.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经探讨了几种数据序列化的方法，包括Pickle、CSV和JSON。还有一些其他格式，如YAML，与JSON和Pickle足够相似，所以我们没有详细涵盖它们。其他序列化方式如XML和HTML则要复杂得多，我们避开了它们。
- en: Exercises
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've covered a wide variety of topics in this chapter, from strings to regular
    expressions, to object serialization, and back again. Now it's time to consider
    how these ideas can be applied to your own code.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了广泛的主题，从字符串到正则表达式，再到对象序列化，最后又回到起点。现在，是时候考虑如何将这些想法应用到您自己的代码中了。
- en: Python strings are very flexible, and Python is an extremely powerful tool for
    string-based manipulations. If you don't do a lot of string processing in your
    daily work, try designing a tool that is exclusively intended for manipulating
    strings. Try to come up with something innovative, but if you're stuck, consider
    writing a web log analyzer (how many requests per hour? How many people visit
    more than five pages?) or a template tool that replaces certain variable names
    with the contents of other files.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Python 字符串非常灵活，Python 也是处理字符串的强大工具。如果你在日常工作中不经常进行字符串处理，试着设计一个专门用于字符串操作的工具。尽量想出一些创新的东西，但如果遇到瓶颈，可以考虑编写一个网站日志分析器（每小时有多少请求？有多少人访问了五个以上的页面？）或者是一个模板工具，用其他文件的內容替换特定的变量名。
- en: Spend a lot of time toying with the string formatting operators until you've
    got the syntax memorized. Write a bunch of template strings and objects to pass
    into the format function, and see what kind of output you get. Try the exotic
    formatting operators, such as percentage or hexadecimal notation. Try out the
    fill and alignment operators, and see how they behave differently for integers,
    strings, and floats. Consider writing a class of your own that has a `__format__` method;
    we didn't discuss this in detail, but explore just how much you can customize
    formatting.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 花大量时间玩转字符串格式化运算符，直到你记住了它们的语法。编写一些模板字符串和对象，将它们传递给格式化函数，看看能得到什么样的输出。尝试一些异国风情的格式化运算符，比如百分比或十六进制表示法。尝试使用填充和对齐运算符，看看它们在整数、字符串和浮点数上的表现有何不同。考虑编写一个包含`__format__`方法的类；我们之前没有详细讨论这一点，但探索一下你可以定制格式化的程度。
- en: Make sure you understand the difference between `bytes` and `str` objects. The
    way that Python's canonical display of bytes looks like a string can be confusing.
    The only tricky part is knowing how and when to convert between the two. For practice,
    try writing text data to a file opened for writing `bytes` (you'll have to encode
    the text yourself), and then reading from the same file.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你理解`bytes`和`str`对象之间的区别。Python对字节显示的方式看起来像字符串可能会让人困惑。唯一棘手的部分是知道何时以及如何在这两者之间进行转换。为了练习，尝试将文本数据写入一个以`bytes`模式打开的文件（你需要自己编码文本），然后从同一个文件中读取。
- en: Do some experimenting with `bytearray`. See how it can act both like a `bytes` object
    and a list or container object at the same time. Try writing to a buffer that
    holds data in the bytes array until it is a certain length before returning it.
    You can simulate the code that puts data into the buffer by using `time.sleep` calls
    to ensure data doesn't arrive too quickly.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bytearray`上进行一些实验。看看它如何同时像`bytes`对象和列表或容器对象一样工作。尝试向一个缓冲区写入数据，该缓冲区在返回之前将数据存储在字节数组中，直到达到一定的长度。你可以通过使用`time.sleep`调用模拟将数据放入缓冲区的代码，以确保数据不会太快到达。
- en: Study regular expressions online. Study them some more. Especially learn about
    named groups, greedy versus lazy matching, and regex flags, three features that
    we didn't cover in this chapter. Make conscious decisions about when not to use
    them. Many people have very strong opinions about regular expressions and either
    overuse them or refuse to use them at all. Try to convince yourself to use them
    only when appropriate, and figure out when that is.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在线学习正则表达式。再深入学习一些。特别是了解命名组、贪婪匹配与懒惰匹配，以及正则表达式标志，这三个我们在本章中没有涉及到的特性。有意识地决定何时不使用它们。很多人对正则表达式有非常强烈的看法，要么过度使用，要么完全拒绝使用。尽量让自己相信只在适当的时候使用它们，并找出何时是适当的时候。
- en: 'If you''ve ever written an adapter to load small amounts of data from a file
    or database and convert it to an object, consider using a pickle instead. Pickles
    are not efficient for storing massive amounts of data, but they can be useful
    for loading configuration or other simple objects. Try coding it multiple ways:
    using a pickle, a text file, or a small database. Which do you find easiest to
    work with?'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经编写过适配器来从文件或数据库中加载少量数据并将其转换为对象，考虑使用pickle。pickle不适合存储大量数据，但它们在加载配置或其他简单对象时可能很有用。尝试用多种方式编码：使用pickle、文本文件或小型数据库。你发现哪种方式最容易使用？
- en: 'Try experimenting with pickling data, then modifying the class that holds the
    data, and loading the pickle into the new class. What works? What doesn''t? Is
    there a way to make drastic changes to a class, such as renaming an attribute
    or splitting it into two new attributes and still get the data out of an older
    pickle? (Hint: try placing a private pickle version number on each object and
    update it each time you change the class; you can then put a migration path in `__setstate__`.)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对数据进行腌制实验，然后修改持有数据的类，并将腌制的数据加载到新的类中。哪些方法有效？哪些方法无效？有没有一种方法可以对类进行重大更改，例如重命名属性或将它拆分为两个新的属性，同时还能从旧的腌制文件中提取数据？（提示：尝试在每个对象上放置一个私有的腌制版本号，并在更改类时更新它；你可以在`__setstate__`中放置一个迁移路径。）
- en: If you do any web development at all, the JSON serializer will be central. It
    can simplify things to stick with standard JSON serializable objects, rather than
    writing custom encoders or `object_hooks`, but the design depends on the complexity
    of the objects and the state representations being transferred.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从事任何形式的网页开发，JSON序列化器将是核心。它可以通过坚持使用标准的JSON可序列化对象来简化事情，而不是编写自定义编码器或`object_hooks`，但设计取决于对象的复杂性和传输的状态表示。
- en: In the case study, we applied the JSON Schema validation to a JSON file. It
    can also be applied to the rows read from a file in CSV format. This is a powerful
    combination of tools to work with data in two common formats; it helps to apply
    rigorous validation rules to assure that the rows meet the application's expectations.
    To see how this works, modify the `CSVIrisReader` class to include JSON Schema
    validation of the rows of data.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在案例研究中，我们将 JSON Schema 验证应用于一个 JSON 文件。它同样适用于从 CSV 格式的文件中读取的行。这是两种常见数据格式中处理数据的强大工具组合；它有助于应用严格的验证规则，以确保行符合应用程序的期望。要了解这是如何工作的，请修改
    `CSVIrisReader` 类以包含对数据行的 JSON Schema 验证。
- en: Summary
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered string manipulation, regular expressions, and object serialization
    in this chapter. Hardcoded strings and program variables can be combined into
    outputtable strings using the powerful string formatting system. It is important
    to distinguish between binary and textual data, and `bytes` and `str` have specific
    purposes that must be understood. Both are immutable, but the `bytearray` type
    can be used when manipulating bytes.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中介绍了字符串操作、正则表达式和对象序列化。可以使用强大的字符串格式化系统将硬编码的字符串和程序变量组合成可输出的字符串。区分二进制和文本数据非常重要，`bytes`和`str`具有特定的用途，这些用途必须理解。两者都是不可变的，但在处理字节时可以使用`bytearray`类型。
- en: Regular expressions are a complex topic, and we only scratched the surface.
    There are many ways to serialize Python data; pickles and JSON are two of the
    most popular.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个复杂的话题，我们只是触及了皮毛。Python 数据的序列化方式有很多种；pickle 和 JSON 是其中最流行的两种。
- en: 'In the next chapter, we''ll look at a design pattern that is so fundamental
    to Python programming that it has been given special syntax support: the iterator
    pattern.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个对 Python 编程至关重要的设计模式，它甚至得到了特殊的语法支持：迭代器模式。
