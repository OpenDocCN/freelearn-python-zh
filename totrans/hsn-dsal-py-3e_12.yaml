- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selection Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One interesting set of algorithms related to finding elements in an unordered
    list of items is selection algorithms. Given a list of elements, selection algorithms
    are used to find the `k`^(th) smallest or largest element from the list. So given
    a list of data elements and a number (`k`), the aim is to find the `k`^(th) smallest
    or largest element. The simplest case of selection algorithms is to find the minimum
    or maximum data element from the list. However, sometimes, we may need to find
    the `k`^(th) smallest or largest element in the list. The simplest way is to first
    sort the list using any sorting algorithm, and then we can easily obtain the `k`^(th)
    smallest (or largest) element. However, when the list is very large, then it is
    not efficient to sort the list to get the `k`^(th) smallest or largest element.
    In that case, we can use different selection algorithms that can efficiently produce
    the `k`^(th) smallest or largest element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Selection by sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomized selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deterministic selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with the technical requirements, and then we will discuss selection
    by sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the source code that’s used in this chapter is provided in the given
    GitHub link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Selection by sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Items in a list may undergo statistical inquiries such as finding the mean,
    median, and mode values. Finding the mean and mode values does not require the
    list to be ordered. However, to find the median in a list of numbers, the list
    must first be ordered. Finding the median requires you to find the element in
    the middle position of the ordered list. In addition, this can be used when we
    want to find the `k`^(th) smallest item in the list. To find the `k`^(th) smallest
    number in an unordered list of items, an obvious method is to first sort the list,
    and after sorting, you can rest assured that the element at index 0 will hold
    the smallest element in the list. Likewise, the last element in the list will
    hold the largest element in the list.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to order data items within a list, see *Chapter
    11*, *Sorting*. However, in order to obtain a `k`^(th) smallest element from the
    list, it is not a good solution to apply a sorting algorithm to a long list of
    elements to obtain the minimum or maximum or `k`^(th) smallest or largest value
    from the list since sorting is quite an expensive operation. Thus, if we need
    to find out the `k`^(th) smallest or largest element from a given list, there
    is no need to sort the complete list as we have other methods that we can use
    for this purpose. Let’s discuss better techniques to find the `k`^(th) smallest
    element without having to sort the list in the first place, starting with randomized
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: Randomized selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The randomized selection algorithm is used to obtain the `k`^(th) smallest
    number that is based on the quicksort algorithm; the randomized selection algorithm
    is also known as quickselect. In *Chapter 11*, *Sorting*, we discussed the quicksort
    algorithm. The quicksort algorithm is an efficient algorithm to sort an unordered
    list of items. To summarize, the quicksort algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It selects a pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It partitions the unsorted list around the pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It recursively sorts the two halves of the partitioned list using *steps 1*
    and *2.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One important fact about quicksort is that after every partitioning step, the
    index of the pivot does not change, even after the list becomes sorted. This means
    that after each iteration, the selected pivot value will be placed in its correct
    position in the list. This property of quicksort enables us to obtain the `k`^(th)
    smallest number without sorting the complete list. Let’s discuss the randomized
    selection method, which is also known as the quickselect algorithm, to obtain
    the `k`^(th) smallest element from a list of n data items.
  prefs: []
  type: TYPE_NORMAL
- en: Quickselect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The quickselect algorithm is used to obtain the `k`^(th) smallest element in
    an unordered list of items. It is based on the quicksort algorithm, in which we
    recursively sort the elements of both the sublists from the pivot point. In each
    iteration, the pivot value reaches the correct position in the list, which divides
    the list into two unordered sublists (left and right sublists), where the left
    sublist has smaller values as compared to the pivot value, and the right sublist
    has greater values compared to the pivot value. Now, in the case of the quickselect
    algorithm, we recursively call the function only for the sublist that has the
    `k`^(th) smallest element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the quickselect algorithm, we compare the index of the pivot point with
    the `k` value to obtain the `k`^(th) smallest element from the given unordered
    list. There will be three cases in the quickselect algorithm, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the index of the pivot point is smaller than `k`, then we are sure that the
    `k`^(th) smallest value will be present on the right-hand sublist of the pivot
    point. So we only recursively call the quickselect function for the right sublist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the index of the pivot point is greater than `k`, then it is obvious that
    the `k`^(th) smallest element will be present on the left-hand side of the pivot
    point. So we only recursively look for the `i`^(th) element in the left sublist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the index of the pivot point is equal to `k`, then it means that we have
    found out the `k`^(th) smallest value, and we return it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s understand the working of the quickselect algorithm with an example. Consider
    a list of elements, `{45, 23, 87, 12, 72, 4, 54, 32, 52}`. We can use the quickselect
    algorithm to find the third smallest element in this list.
  prefs: []
  type: TYPE_NORMAL
- en: We start the algorithm by selecting a pivot value, that is, `45`. Here we are
    choosing the first element as the pivot element for simplicity; however, any other
    element can be chosen as a pivot element. After the first iteration of the algorithm,
    the pivot value moves to its correct position in the list, which in this example
    is at index 4 (the index is starting from 0). Next, we check the condition `k<pivot`
    point (that is, `2<4`). Case- 2 is applicable, so we only consider the left sublist,
    and recursively call the function. Here, we compare the index of the pivot value
    (that is, `4`) with the value of `k` (that is, the 3^(rd) position or at index
    2).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take the left sublist and select the pivot point (that is, `4`). After
    the run, the `4` is placed in its correct position (that is, the 0^(th) index).
    As the index of the pivot is less than the value of `k`, we consider the right
    sublist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we take `23` as the pivot point, which is also placed in its correct
    position. Now, when we compare the index of the pivot point and the value of `k`,
    they are equal, which means we have found the 3^(rd) smallest element, and it
    will be returned. The complete step-by-step process to find the 3^(rd) smallest
    element is shown in *Figure 12.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Step-by-step demonstration of the quickselect algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s discuss the implementation of the `quick_select` method. It is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, the `quick_select` function takes the complete array, the
    index of the first element of the list, the index of the last element, and the
    `k`^(th) element specified by value `k` as parameters. The value of `k` maps with
    the index that the user is searching for, meaning the `k`^(th) smallest number
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we use the `partition()` method (which is defined and discussed
    in detail in *Chapter 11*, *Sorting*) to place the selected pivot point in such
    a way that it divides the given list of elements in the left sublist and the right
    sublist, in which the left sublist has data elements that are smaller than the
    pivot value, and right subtree has data elements that are greater than the pivot
    value. The `partition()` method is called `split = partition(array_list, start,
    end)` and returns the `split` index. Here, the `split` index is the position where
    the pivot element is placed in the array, and (`start`, `end`) is the starting
    and ending indices of the list. Once we get the split point, we compare the `split`
    index with the required value of `k` to find out whether we have reached the position
    of the `k`^(th) smallest data item or whether the required `k`^(th) smallest element
    will be on the left sublist or the right sublist. These three conditions are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `split` is equal to the value of `k`, then it means that we have reached
    the `k`^(th) smallest data item in the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `split` is less than `k`, then it means that the `k`^(th) smallest item
    should exist or be found between `split+1` and `right`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `split` is greater than `k`, then it means that the `k`^(th) smallest
    item should exist or be found between `left` and `split-1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding example, a split point occurs at index 4 (index starting from
    0). If we are searching for the 3^(rd) smallest number, then since 4 < 2 yields
    `false`, a recursive call to the right sublist is made using `quick_select(array_list,
    left, split-1, k)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, for the completeness of this algorithm, the `partition()` method is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the above code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we get the 2^(nd) and 3^(rd) smallest elements from the given
    list of elements. The worst-case performance of a randomized selection-based `quick-select`
    algorithm is O(n²).
  prefs: []
  type: TYPE_NORMAL
- en: In the above implementation of the `partition()` method, we use the first element
    of the list as the pivot element for simplicity, but any element can be chosen
    from the list as the pivot element. A good pivot element is one that divides the
    list into almost equal halves. Therefore, it is possible to improve the performance
    of the quickselect algorithm by selecting the split point more efficiently in
    linear time with the worst-case complexity of `O(n)`. We discuss how to do this
    in the next section using deterministic selection.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deterministic selection is an algorithm for finding out the `k`^(th) item in
    an unordered list of elements. As we have seen in the `quickselect` algorithm,
    we select a random “pivot” element that partitions the list into two sublists
    and calls itself recursively for one of the two sublists. In a deterministic selection
    algorithm, we choose a pivot element more efficiently instead of taking any random
    pivot element.
  prefs: []
  type: TYPE_NORMAL
- en: The main concept of the deterministic algorithm is to select a pivot element
    that produces a good split of the list, and a good split is one that divides the
    list into two halves. For instance, a good way to select a pivot element would
    be to choose the median of all the values. But we will need to sort the elements
    in order to find out the median element, which is not efficient, so instead, we
    try to find a way to select a pivot element that divides the list roughly in the
    middle.
  prefs: []
  type: TYPE_NORMAL
- en: The median of medians is a method that provides us with the approximate median
    value, that is, a value close to the actual median for a given unsorted list of
    elements. It divides the given list of elements in such a way that in the worst
    case, at least 3 out of 10 (3/10) of the list will be below the pivot element,
    and at least 3 out of 10 of the elements will be above the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example to understand this. Let’s say we have a list of 15 elements:
    `{11, 13, 12, 111, 110, 15, 14, 16, 113, 112, 19, 18, 17, 114, 115}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we divide it into groups of 5 elements and sort them as follows: `{{11,
    12, 13, 110, 111}, {14, 15, 16, 112, 113}, {17, 18, 19, 114, 115}}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the median of each of these groups, and they are `13`, `16`,
    and `19`, respectively. Further, the median of these median values `{13, 16, 19}`
    is `16`. This is the median of medians for the given list. Here, we can see that
    5 elements are smaller, and `9` elements are greater than the pivot element. When
    we select this median of the median as a pivot element, the list of `n` elements
    is divided in such a way that at least `3n/10` elements are smaller than the pivot
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deterministic algorithm to select the `k`^(th) smallest element works as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the list of unordered items into groups of five elements each (the number
    5 is not mandatory; it can be changed to any other number, for example, 8)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort these groups (in general, we use insertion sort for this purpose) and find
    the median of all these groups
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively, find the median of the medians obtained from these groups; let’s
    say that is point **p**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using this point **p** as the pivot element, recursively call the partition
    algorithm similar to quickselect to find out the `k`^(th) smallest element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s consider an example list of 15 elements to understand the working of the
    deterministic algorithm to find out the 3^(rd) smallest element from the list,
    as shown in *Figure 12.2*. First, we divide the list into groups of 5 elements
    each, and then we sort these groups/sublists. Once we have sorted the lists, we
    find out the median of the sublists. For this example, items **23**, **52**, and
    **34** are the medians of these three sublists, as shown in *Figure 12.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we sort the list of medians for all the sublists. Further, we find out
    the median of this list, that is, the median of the median, which is **34**. This
    median of medians is used to select the partition/pivot point for the whole list.
    Further, we divide the given list using this pivot element to partition the list
    into 2 sublists, placing the given pivot element at its correct position in the
    list. For this example, the index of the pivot element is 7 (index starting from
    0; this is shown in *Figure 12.2.*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17217_12_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Step-by-step procedure for the deterministic selection algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: The index of the pivot element is greater than the `k`^(th) value, and hence,
    we recursively call the algorithm on the left sublist to obtain the required `k`^(th)
    smallest element.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the implementation of the deterministic selection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the deterministic selection algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the deterministic algorithm for determining the `k`^(th) smallest
    value from the list, we start implementing the updated `partition()` method, which
    divides the list where we select the pivot element using the median of medians
    method. Let’s now understand the code for the `partition` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we implement the partition method, which is very similar
    to what we did in the quickselect algorithm. In the quickselect algorithm, we
    used a random pivot element (for simplicity, the first element of the list), but
    in the deterministic selection algorithm, we select the pivot element using the
    median of medians. The partition method divides the list into two sublists – the
    left and right sublists, in which the left sublist has elements that are smaller
    than the pivot element, and the right sublist has elements that are greater than
    the pivot element. The main benefit of using the pivot element with the median
    of medians is that it, in general, divides the list into almost two halves.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the code, firstly, in the `if-else` condition, we check the
    length of the given list of elements. If the length of the list is 1, then we
    return the index of that element, so if the `unsorted_array` has only one element,
    `first_index` and `last_index` will be equal. Therefore, `first_index` is returned.
    And, if the length is greater than 1, then we call the `median_of_medians()` method
    to compute the median of medians of the list passed to this method with the starting
    and ending indices as `first_index` and `last_index`. The return median of medians
    value is stored in the `nearest_median` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s understand the code of the `median_of_medians()` method. It is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the above code of the `median_of_medians` function, recursion is used to
    compute the median of medians for the given list. The function begins by splitting
    the given list, `elems`, into groups of five elements each. As discussed earlier
    in the deterministic algorithm, we divide the given list into groups of 5 elements.
    Here, we choose 5 elements since it mostly performs well. However, we could have
    used any other number as well. This means that if `elems` contains 100 items,
    there will be 20 groups that are created by the `sublists = [elems[j:j+5] for
    j in range(0, len(elems), 5)]` statement, with each containing a maximum of five
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: After creating sublists of five elements each, we create an empty array, `medians`,
    that stores the medians of each of the five-element arrays (i.e., `sublists`).
    Further, the `for` loop iterates over the list of lists inside `sublists`. Each
    sublist is sorted, the median is found, and it is stored in the `medians` list.
    The `medians.append(sorted(sublist)[len(sublist)//2])` statement will sort the
    list and obtain the element stored in its middle index. The `medians` variable
    becomes the median list of all the sublists of which there are five elements in
    each sublist. In this implementation, we use an existing sorting function of Python;
    it will not impact the performance of the algorithm due to the list’s small size.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, the next step is to recursively compute the median of medians, which
    we will use as a pivot element. It is important to note here that the length of
    the median array can itself be a large array because if the original length of
    the array is n, then the length of the median array will be n/5, and sorting this
    may be time-consuming in itself. Hence, we check the length of the `medians` array,
    and if it is less than 5, we sort the `medians` list and return the element located
    in its middle index. If, on the other hand, the size of the list is greater than
    five, we recursively call the `median_of_medians` function again, supplying it
    with the list of the medians stored in `medians`. Finally, the function returns
    the median of medians of the given list of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take another example to better understand the concept of the median of
    medians with the following list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can break this list down into groups of five elements, each with the `sublists
    = [elems[j:j+5] for j in range(0, len(elems), 5)]` code statement, in order to
    obtain the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the five-element lists will be sorted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we obtain their medians to produce the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We sort the above list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the list is five elements in size, we only return the median of the sorted
    list, which is `12` in this case. Otherwise, if the length of this array had been
    greater than 5, we would have made another call to the `median_of_median` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the median of the median value, we need to find out its index
    in the given list. We write the `get_index_of_nearest_median` function for this
    purpose. This function takes the starting and ending indices of the list indicated
    by the `first` and `last` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next in the partition method, we swap the median of medians value with the
    first element of the list, that is, we swap `index_of_nearest_median` with `first_index`
    of the `unsorted_array` using the `swap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `utility` function to swap two array elements is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We swap these two elements. The rest of the implementation is quite similar
    to what we discussed in the `quick_select` algorithm. Now, we have the median
    of the median for the given list, which is stored in `first_index` of the unsorted
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the rest of the implementation is similar to the partition method of the
    `quick_select` algorithm and also the quicksort algorithm, which is discussed
    in detail in *Chapter 11*, *Sorting*. For the completeness of the algorithm here,
    we discuss this again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We consider the first element as a pivot element, and we take two pointers,
    that is, left and right. The left pointer moves from the left to the right direction
    in the list to keep elements that are smaller than the pivot element on the left
    hand side of the pivot element. It is initialized with the second element of the
    list, that is, `first_index+1`, whereas the right pointer moved from the right
    to the left direction, which maintains the list in a way that elements greater
    than the pivot element are on the right-hand side of the pivot element in the
    list. It is initialized with the last element of the list. So we have two variables
    `less_than_pivot_index` (the right pointer) and `greater_than_pivot_index` (the
    left pointer) in which `less_than_pivot_index` is initialized with `index_of_last_element`
    and `greater_than_pivot_index` with `first_index + 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move the left and right pointers in such a way that after one iteration,
    the pivot element is placed in its correct position in the list. That means it
    divides the list into two sublists such that the left sublist has all the elements
    that are smaller than the pivot element, and the right sublist has elements greater
    than the pivot element. We do this with these three steps given below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first while loop will move `greater_than_pivot_index` to the right side
    of the array until the element pointed out by `greater_than_pivot_index` is less
    than the pivot element and `greater_than_pivot_index` is less than `last_index`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the second `while` loop, we’ll be doing the same thing but for the `less_than_pivot_index`
    in the array. We’ll move `less_than_pivot_index` to the left direction until the
    element pointed out by `less_than_pivot_index` is greater than the pivot element
    and `less_than_pivot_index` is greater than or equal to `first_index`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we check if `greater_than_pivot_index` and `less_than_pivot_index` have
    crossed each other or not. If `greater_than_pivot_index` is still less than `less_than_pivot_index`
    (that is, we have not found the correct position for the pivot element yet), we
    swap the elements indicated by `greater_than_pivot_index` and `less_than_pivot_index`,
    and then we will repeat the same three steps again. If they have crossed each
    other, that means we have found the correct position for the pivot element, and
    we will break from the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After exiting the loop, the variable `less_than_pivot_index` will point to
    the correct index of the pivot, so we will just swap the values that are present
    at `less_than_pivot_index` and `pivot_index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will simply return the pivot index, which is stored in the variable
    `less_than_pivot_index`.
  prefs: []
  type: TYPE_NORMAL
- en: After the partition method, the pivot element reaches its correct position in
    the list. Thereafter, we recursively call the partition method to one of the sublists
    (the left sublist or the right sublist) depending on the required value of `k`
    and the pivot element position to find out the `k`^(th) smallest element. This
    process is the same as the quickselect algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of the deterministic select algorithm is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you may have observed, the implementation of the deterministic selection
    algorithm looks exactly the same as the quickselect algorithm. The only difference
    between the two is how we select the pivot element; apart from that, everything
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the initial `array_list` has been partitioned by the selected pivot element,
    which is the median of medians of the list, a comparison with the `k`^(th) element
    is made:'
  prefs: []
  type: TYPE_NORMAL
- en: If the index of the split point, that is, `split`, is equal to the required
    value of `k`, it means that we have found the required `k`^(th) smallest element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the index of the split point, the, `split` is less than the required value
    of `k`, then a recursive call to the right sublist is made as `deterministic_select(array_list,
    split + 1, right, k)`. This will look for the `k`^(th) element on the right-hand
    side of the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, if the split index is greater than the value of k, then the function
    call to the left sublist is made as `deterministic_select(array_list, left, split-1,
    k)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output of the above code is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the output of the above code, we have the 6^(th) smallest element from a
    given list of 25 elements. The deterministic selection algorithm improves the
    quickselect algorithm by using the median of medians element as a pivot point
    for selecting the `k`^(th) smallest element from a list. It improves performance
    because the median of medians method finds out the estimated median in linear
    time, and when this estimated median is used as a pivot point in the quickselect
    algorithm, the worst-case running time’s complexity improves from O(n²) to the
    linear O(n).
  prefs: []
  type: TYPE_NORMAL
- en: The median of medians algorithm can also be used to choose a pivot point in
    the quicksort algorithm for sorting a list of elements. This significantly improves
    the worst-case performance of the quicksort algorithm from O(n²) to a complexity
    of O(nlogn).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed two important methods to find the k^(th) smallest
    element in a list, randomized selection and deterministic selection algorithms.
    The simple solution of merely sorting a list to perform the operation of finding
    the k^(th) smallest element is not optimal as we can use better methods to determine
    the k^(th) smallest element. The quickselect algorithm, which is the random selection
    algorithm, divides the list into two sublists. One list has smaller values, and
    the other list has greater values as compared to the selected pivot element. We
    reclusively use one of the sublists to find the location of the k^(th) smallest
    element, which can be further improved by selecting the pivot point using the
    median of medians method in the deterministic selection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss several important string matching algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will be the output if the quickselect algorithm is applied to the given
    array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`arr = [3, 1, 10, 4, 6, 5]` with `k` given as 2?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Can quickselect find the smallest element in an array with duplicate values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the quicksort algorithm and the quickselect algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main difference between the deterministic selection algorithm and
    the quickselect algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What triggers the worst-case behavior of the selection algorithm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1421249772551223062.png)'
  prefs: []
  type: TYPE_IMG
