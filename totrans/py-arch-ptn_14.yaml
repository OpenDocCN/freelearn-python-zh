- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Package Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包管理
- en: When working in complex systems, especially in microservices or similar architectures,
    there is sometimes a need to share code so it's available at different, unconnected
    parts of the system. That's normally code that will help to abstract some functions,
    which can vary greatly, from security purposes (for example, calculating a signature
    in a way that's understood by other systems that will have to verify it), to connecting
    to databases or external APIs, or even helping to monitor the system consistently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当在复杂系统中工作时，尤其是在微服务或类似架构中，有时需要共享代码，以便它在系统的不同、不相连的部分中可用。这通常是帮助抽象一些可能差异很大的函数的代码，从安全目的（例如，以其他系统将需要验证的方式计算签名），到连接到数据库或外部API，甚至帮助一致地监控系统。
- en: Instead of reinventing the wheel each time, we can reuse the same code multiple
    times to be certain that it's properly tested and validated, and consistent throughout
    the entire system. Some modules may be interesting to share not only across the
    organization but even outside it, creating a standard module others can take advantage
    of.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必每次都重新发明轮子，我们可以多次重用相同的代码，以确保它经过适当的测试和验证，并在整个系统中保持一致性。一些模块可能不仅可以在组织内部共享，甚至可以在组织外部共享，创建其他人可以利用的标准模块。
- en: Others have done that before, and a lot of common use cases, such as connecting
    to existing databases, using network resources, accessing OS features, understanding
    files in all kinds of formats, calculating common algorithms and formulas, in
    all kinds of domains, creating and operating AI models, and a long list of other
    cases besides, are available.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之前有人这样做过，许多常见的用例，如连接到现有的数据库、使用网络资源、访问操作系统功能、理解各种格式的文件、计算常见的算法和公式、在各个领域，创建和操作AI模型，以及其他许多案例，都是可用的。
- en: To enhance the sharing and utilization of all those abilities, modern programming
    languages have their own ways of creating and sharing packages, so the usefulness
    of the language multiplies greatly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强所有这些能力的共享和利用，现代编程语言都有它们自己的创建和共享包的方式，因此语言的有用性大大增加。
- en: In this chapter, we will discuss the use of packages, mostly from a Python perspective,
    covering when and how to decide to create a package. We will explore the different
    options available, from a simple structure to packages that include code compiled
    so that it can be optimized for specific tasks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论包的使用，主要从Python的角度出发，涵盖何时以及如何决定创建一个包。我们将探讨不同的选项，从简单的结构到包含编译代码的包，以便它可以针对特定任务进行优化。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The creation of a new package
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的包
- en: Trivial packaging in Python
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的简单打包
- en: The Python packaging ecosystem
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python打包生态系统
- en: Creating a package
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包
- en: Cython
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython
- en: Python package with binary code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有二进制代码的Python包
- en: Uploading your package to PyPI
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的包上传到PyPI
- en: Creating your own private index
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的私有索引
- en: Let's start by defining what code could be a candidate to create a package.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一下哪些代码可能成为创建包的候选者。
- en: The creation of a new package
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的包
- en: In any software, there will be snippets of code that could be shared across
    different parts of the code. When working with small, monolithic applications,
    this can be as easy as creating some internal modules or functions that can share
    functionality by calling it directly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何软件中，都可能会有一些代码片段可以在代码的不同部分之间共享。当处理小型、单体应用程序时，这可以通过创建一些内部模块或函数来实现，通过直接调用它们来共享功能。
- en: Over time, this common function or functions could be grouped together under
    a module to clarify that they are to be used across the application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这个或这些常用函数可能会被分组到一个模块中，以明确它们将在整个应用程序中使用。
- en: Avoid the temptation to use the name `utils` for a module with code expected
    to be used in different positions. While this is very common, it is also not very
    descriptive and a bit lazy. How does someone know if a function is in the `utils`
    module? Instead of that, try to use a descriptive name.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `utils` 这样的名字来命名一个预期在不同位置使用的代码模块。虽然这很常见，但它也不是很具有描述性，有点懒惰。别人怎么知道一个函数是否在
    `utils` 模块中？相反，尝试使用一个描述性的名字。
- en: If it's not possible, divide it into submodules, so you can create something
    like `utils.communication` or `utils.math` to avoid this effect.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不可能，将其划分为子模块，这样你可以创建类似 `utils.communication` 或 `utils.math` 的东西，以避免这种影响。
- en: 'This will work fine up to a certain size. Some of the problems that can arise
    as the code grows and becomes more complex are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定规模内，这将会运行得很好。随着代码的增长和复杂度的增加，可能会出现以下一些问题：
- en: Create a more generic API to interact with the module, aimed at greater flexibility
    in terms of module utilization. This can involve creating a more defensive style
    of programming, to be sure that the module is used as expected and return proper
    errors.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个更通用的API来与模块交互，旨在提高模块利用的灵活性。这可能包括创建一种更防御性的编程风格，以确保模块按预期使用并返回适当的错误。
- en: Specific documentation needs to be provided for the module so that developers
    who are not familiar with the module are able to use it.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要为模块提供具体的文档，以便不熟悉模块的开发者能够使用它。
- en: Ownership of the module may need to be clarified and its own maintainers specified.
    This can take the form of a stricter code review before changing the code, with
    some developer or developers designated as the point of contact for the module.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要明确模块的所有权并指定其维护者。这可以采取在更改代码前进行更严格的代码审查的形式，指定一些开发者或开发者为模块的联系人。
- en: The most critical one, the functionality of the module, is required to be present
    in two or more independent services or code bases. If this happens, instead of
    just copying/pasting the code across different code bases, it makes sense to create
    an independent module that can be imported. This could be a deliberate option
    upfront, to standardize certain operations (for example, produce and verify signed
    messages across multiple services) or it could be an afterthought following successful
    implementation of the functionality in one code base that it could be handy to
    have in other services of the system. For example, instrumenting the communication
    messages to you generates a log. This log can be useful in other services, so,
    from the original service, it gets migrated to others.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最关键的是，模块的功能需要在两个或更多独立的服务或代码库中存在。如果发生这种情况，而不是仅仅在不同代码库之间复制/粘贴代码，创建一个独立的模块以便导入是有意义的。这可能是一个事先的明确选择，以标准化某些操作（例如，在多个服务中产生和验证签名消息）或可能是在一个代码库中成功实现功能后的一种后续想法，这种功能在其他服务中可能很有用。例如，对通信消息进行监控会生成日志。这个日志在其他服务中可能很有用，因此，从原始服务中，它会被迁移到其他服务。
- en: In general, the module starts getting its own entity, and not only as a shared
    location for incorporating code that is going to be shared. At that time, it starts
    to make sense to treat it as an independent library more than a module attached
    to a particular code base.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块开始获得自己的实体，而不仅仅是一个共享位置来集成将要共享的代码。那时，将其视为一个独立的库而不是特定代码库的模块更有意义。
- en: 'Once the decision to create some code as an independent package has been taken,
    several aspects should be considered:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦决定将某些代码作为一个独立的包来创建，应考虑以下几个方面：
- en: As we've seen before, the most important is the ownership of the new package.
    Packages exist in the boundaries between different teams and groups, as they are
    used by different ones. Be sure to provide clear ownership regarding any package
    to be sure that the team responsible for it is reachable, both for any possible
    inquiries and for setting its own maintenance.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如我们之前所见，最重要的是新包的所有权。包存在于不同团队和群体之间的边界上，因为它们被不同的人使用。务必提供关于任何包的明确所有权，以确保负责该包的团队可接触，无论是为了任何可能的询问还是为了设置其自身的维护。
- en: Any new package will require time to develop new features and adjustments, especially
    as the package is in use, probably stretching its limits as it's used in multiple
    services and in more ways. Be sure to take this into account and adjust the load
    of the team responsible accordingly. This will be very dependent on how mature
    the package is and how many new features are required.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何新的包都需要时间来开发新功能和调整，尤其是在包被使用时，可能因为被多个服务和多种方式使用而拉伸其极限。务必考虑到这一点，并相应地调整负责团队的工作量。这将非常依赖于包的成熟度和所需的新功能数量。
- en: In the same way, be sure to budget time to maintain the package. Even if there
    are no new features, bugs will be detected and other general maintenance, such
    as updating the dependencies on account of security fixes or compatibility with
    new OS versions, will need to be continued.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，务必预留时间来维护包。即使没有新功能，也会发现错误，以及其他一般性维护，如由于安全修复或与新操作系统版本的兼容性而更新依赖项，这些都需要继续进行。
- en: All these elements should be taken into account. In general, it is advisable
    to create some sort of roadmap where the team responsible can define what the
    objectives are and a time frame to achieve them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些元素都应该被考虑进去。一般来说，建议创建某种路线图，以便负责的团队可以定义目标及其实现的时间框架。
- en: The bottom line is that a new package is a new project. You need to treat it
    as such.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，一个新的包是一个新的项目。你需要像对待项目一样对待它。
- en: We will focus on creating a new package in Python, but the basics are similar
    when creating other packages in other languages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于在Python中创建一个新的包，但创建其他语言中的其他包时，基本原理是相似的。
- en: Trivial packaging in Python
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的简单打包
- en: In Python, it is easy to create a package to be imported by just adding a subdirectory
    to the code. While this is simple, it can be adequate initially, as the subdirectory
    can be copied. For example, the code can be added directly to the source control
    system, or it can even be installed by compressing the code and uncompressing
    it in place.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，创建一个可以被导入的包非常简单，只需将子目录添加到代码中即可。虽然这很简单，但最初可能足够用，因为子目录可以被复制。例如，代码可以直接添加到源代码控制系统中，或者甚至可以通过压缩代码并在原地解压缩来安装。
- en: This is not a long-term solution, as it won't handle multiple versions, dependencies,
    and so on, but it can work in some cases as a first step. At least initially,
    all the code to be packetized needs to be stored in the same subdirectory.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个长期解决方案，因为它不会处理多个版本、依赖关系等问题，但在某些情况下可以作为第一步。至少最初，所有需要打包的代码都需要存储在同一个子目录中。
- en: 'The structure of the code for a module in Python can be worked out as a subdirectory
    with a single entry point. For example, when creating a module called `naive_package`
    with the following structure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python中模块的代码结构可以作为一个具有单个入口点的子目录来处理。例如，当创建一个名为`naive_package`的模块，其结构如下：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that the module contains a submodule, so let's start there. The submodule
    directory contains two files, the `submodule.py` file with the code, and an empty
    `__init__.py` file to allow the other file to be imported, as we will see later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到该模块包含一个子模块，所以让我们从这里开始。子模块目录包含两个文件，包含代码的`submodule.py`文件和一个空的`__init__.py`文件，以便其他文件可以被导入，正如我们稍后将会看到的。
- en: '`__init__.py` is a special Python file that indicates that the directory contains
    Python code and can be imported externally. It symbolizes the directory itself,
    as we will see later.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`是一个特殊的Python文件，它表示目录包含Python代码并且可以被外部导入。它象征着目录本身，正如我们稍后将会看到的。'
- en: 'The content of `submodule.py` is this example function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`submodule.py`的内容是这个示例函数：'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The top level is the module itself. We have the `module.py` file, which defines
    the `some_function` function that calls the submodule:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级别是模块本身。我们有一个`module.py`文件，它定义了调用子模块的`some_function`函数：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `import` line has a detail, a dot in the form of the submodule located in
    the same directory. This is specific syntax in Python 3 for being more precise
    when importing. Without the dot, it will try to import from the library instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`行有一个细节，即位于同一目录中的子模块的点形式。这是Python 3中导入时更精确的特定语法。如果没有点，它将尝试从库中导入。'
- en: 'You can learn more about relative imports in PEP-328, which describes it, here:
    [https://www.python.org/dev/peps/pep-0328/](https://www.python.org/dev/peps/pep-0328/).
    **PEPs** (**Python Enhancement Proposals**) are documents describing new features
    relating to the Python language or information related to the community. It is
    the official channel for proposing changes and advancing the language.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在PEP-328中了解更多关于相对导入的信息，它在这里进行了描述：[https://www.python.org/dev/peps/pep-0328/](https://www.python.org/dev/peps/pep-0328/)。**PEPs**（**Python
    Enhancement Proposals**）是描述与Python语言相关的新特性或与社区相关的信息的文档。它是提出更改和推进语言的官方渠道。
- en: The rest of the function calls `subfunction` and combines the result to return
    a string of text.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分调用`subfunction`并将结果组合成一个文本字符串返回。
- en: 'The `__init__.py` file, in this case, is not empty, but instead, it imports
    the `some_function` function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`__init__.py`文件不是空的，而是导入`some_function`函数：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note again the relative `import` as indicated by the preceding dot. This allows
    having the `some_function` function available as part of the top level of the
    `naive_package` module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意前面的点所指示的相对`import`。这允许`some_function`函数作为`naive_package`模块最高级别的一部分可用。
- en: 'We can now create a file to call the module. We''ll write the `call_naive_package.py`
    file, which needs to be at the same level as the `native_package` directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个文件来调用模块。我们将编写`call_naive_package.py`文件，该文件需要与`native_package`目录处于同一级别：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This file just calls the module-defined function and prints the result:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件仅调用模块定义的函数并打印结果：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method of handling a module to be shared is not recommended, but this small
    module can help us understand how to create a package and what the structure of
    a module is. The first step to detaching a module and creating an independent
    package will be to create a single subdirectory that has a clear API, including
    clear entry points to use it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理要共享的模块的方法不建议使用，但这个小模块可以帮助我们了解如何创建包以及模块的结构。将模块分离并创建独立包的第一步是创建一个具有清晰API的单个子目录，包括使用它的清晰入口点。
- en: But to get a better solution, we will need to be able to create a full Python
    package from there. Let's take a look at what that means exactly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了得到更好的解决方案，我们需要能够从那里创建一个完整的Python包。让我们看看这究竟意味着什么。
- en: The Python packaging ecosystem
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python打包生态系统
- en: Python has a very active ecosystem of third-party open source packages that
    covers a wide variety of topics and enables the power of any Python program to
    be enhanced. You can take advantage of installing them by using `pip`, which is
    installed automatically for any new Python install.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有一个非常活跃的第三方开源包生态系统，涵盖了广泛的主题，并增强了任何Python程序的功能。您可以通过使用`pip`来利用安装它们，`pip`在安装任何新的Python时都会自动安装。
- en: 'For example, to install the package named `requests`, a package allowing the
    compilation of easier and more powerful HTTP requests, the command is:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装名为`requests`的包，这是一个允许编译更简单、更强大的HTTP请求的包，命令如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`pip` searches in the Python Package Index automatically to see whether the
    package is available and if it is, it will download it and install it.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`会自动在Python包索引中搜索，以查看包是否可用。如果可用，它将下载并安装它。'
- en: Note that the `pip` command could take the form of `pip3`. This depends on the
    installation of Python in your system. We will use them indistinctly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`pip`命令可能是`pip3`的形式。这取决于您系统中Python的安装。我们将不加区分地使用它们。
- en: We will see more detailed usage on `pip` later in the chapter, but first, we
    need to discuss the main source where the packages are downloaded.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地介绍`pip`的使用，但首先，我们需要讨论包下载的主要来源。
- en: PyPI
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPI
- en: 'The Python Package Index (PyPI, normally pronounced as *Pie-P-I*, as opposed
    to *Pie-Pie*) is the official source of packages in Python and can be checked
    at [https://pypi.org](https://pypi.org):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python包索引（PyPI，通常发音为*Pie-P-I*，而不是*Pie-Pie*）是Python中包的官方来源，可以在[https://pypi.org](https://pypi.org)上检查：
- en: '![Graphical user interface, text, website'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本，网站'
- en: Description automatically generated](img/B17580_11_01.png)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_11_01.png)
- en: 'Figure 11.1: pypi.org main page'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：pypi.org主页
- en: On the PyPI web page, the search enables specific packages to be found along
    with useful information, including available packages with partial matches. They
    can also be filtered.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyPI网页上，搜索可以找到特定的包以及有用的信息，包括具有部分匹配的可用包。它们也可以被过滤。
- en: '![Graphical user interface, application'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_11_02.png)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_11_02.png)
- en: 'Figure 11.2: Searching for packages'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：搜索包
- en: Once the individual package is specified, more information can be found regarding
    brief documentation, links to the source and home page of the project, and other
    similar kinds of licenses or maintainers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定了单个包，就可以找到有关简要文档、项目源和主页的链接以及其他类似类型的许可证或维护者的更多信息。
- en: The home page and documentation page are very significant for big packages,
    as they will include much more information about how to use the package. Smaller
    packages will normally only include the documentation on this page, but it's always
    worth checking their page for the source as it may link to a GitHub page with
    details about bugs and the possibility of submitting patches or reports.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型包，主页和文档页非常重要，因为它们将包含有关如何使用包的更多信息。较小的包通常只会包含此页面的文档，但检查它们的页面以查看源总是值得的，因为它可能链接到一个GitHub页面，其中包含有关错误和提交补丁或报告的可能性。
- en: 'The page for `requests` looks like this at the time of writing this book:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，`requests`页面的样子如下：
- en: '![Graphical user interface, application'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B17580_11_03.png)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_11_03.png)
- en: 'Figure 11.3: Detailed info about a module'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：关于模块的详细信息
- en: Searching directly in PyPI can help locate some interesting modules, and in
    some cases, will be quite straightforward, such as finding a module to connect
    to a database (for example, searching by the name of the database). This, though,
    normally involves a significant amount of trial and error, as the name may not
    be indicative of how good a module will be for your use case.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在 PyPI 中搜索可以帮助定位一些有趣的模块，在某些情况下，将会非常直接，例如查找连接到数据库的模块（例如，通过数据库的名称进行搜索）。然而，这通常涉及大量的试错，因为名称可能不会表明模块对您的用例有多好。
- en: Spending some time on the internet searching for the best module for a use case
    is a great idea and it will improve the chances of finding the right package for
    your use case.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上花些时间搜索最适合特定用例的最佳模块是一个好主意，这将提高找到适合您用例的正确包的机会。
- en: A great source of knowledge in this case is StackOverflow ([https://stackoverflow.com/](https://stackoverflow.com/)),
    which contains a lot of questions and answers that can be used to ascertain interesting
    modules. A general Google search will also help.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，StackOverflow ([https://stackoverflow.com/](https://stackoverflow.com/))
    是一个很好的知识来源，它包含大量的问题和答案，可用于确定有趣的模块。一般的谷歌搜索也会有所帮助。
- en: In any case, given the number of available packages for Python, of varying quality
    and maturity, it's always worthwhile setting aside some time to research alternatives.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，鉴于Python有大量不同质量和成熟度的可用包，花些时间研究替代方案总是值得的。
- en: Packages are not curated in any way by `pypi.org`, as it's publicly available
    to anyone to submit their packages, although malicious ones will be eliminated.
    How popular a package is will require more indirect methods, such as searching
    how many downloads or searching through a searcher online to see whether other
    projects are using it. Ultimately, it will require the performance of some Proof-of-Concept
    programs to analyze whether the candidate packages cover all the required functionalities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pypi.org` 并没有以任何方式对包进行精选，因为它是公开的，任何人都可以提交他们的包，尽管恶意包将被消除。一个包有多流行将需要更多间接的方法，例如搜索下载次数或通过在线搜索器查看是否有其他项目在使用它。最终，将需要执行一些概念验证程序来分析候选包是否涵盖了所有必需的功能。'
- en: Virtual environments
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: The next element in the packaging chain is the creation of virtual environments
    to isolate the installation of modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打包链中的下一个元素是创建虚拟环境以隔离模块的安装。
- en: When dealing with installing packages, using the default environments in the
    system leads to the packages being installed there. This means that the general
    installation of the Python interpreter will be affected by this.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理安装包时，使用系统中的默认环境会导致包安装在那里。这意味着 Python 解释器的常规安装将受到影响。
- en: This can lead to problems, as you may install packages that have side effects
    when using the Python interpreter for other purposes, as dependencies in the packages
    may interfere with each other.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致问题，因为您可能安装了在使用 Python 解释器进行其他目的时会产生副作用的其他包，因为包中的依赖项可能会相互干扰。
- en: For example, if the same machine has a Python program that requires the `package1`
    package and another Python program that requires `package2`, and they are both
    incompatible, that will create a conflict. Installing both `package1` and `package2`
    won't be possible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果同一台机器上有一个需要 `package1` 包的 Python 程序，另一个需要 `package2` 的 Python 程序，并且它们都不兼容，这将产生冲突。安装
    `package1` 和 `package2` 都是不可能的。
- en: Note that this can also happen through version incompatibility, especially in
    the dependencies of the packages, or in the dependencies of dependencies. For
    example, `package1` requires dependency version 5 to be installed, and `package2`
    requires dependency version 6 or higher. They won't be able to run in conjunction
    with one another.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这也可能通过版本不兼容发生，尤其是在包的依赖项或依赖项的依赖项中。例如，`package1` 需要安装依赖项版本 5，而 `package2` 需要版本
    6 或更高。它们将无法同时运行。
- en: The solution to this problem is to create two different environments, so each
    package and its dependencies are stored independently – independently from each
    other, but also independently from the system Python interpreter, so it won't
    affect any possible system activity that depends on the Python system interpreter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是创建两个不同的环境，这样每个包及其依赖项都会独立存储——不仅彼此独立，而且与系统 Python 解释器也独立，因此不会影响依赖于系统
    Python 解释器的任何可能的活动。
- en: 'To create a new virtual environment, you can use the standard module `venv`,
    included in all installations of Python 3 after 3.3:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的虚拟环境，可以使用 Python 3.3 之后所有安装中包含的标准模块 `venv`：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This creates the `venv` subdirectory, which contains the virtual environment.
    The environment can be activated using the following `source` command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建 `venv` 子目录，其中包含虚拟环境。可以使用以下 `source` 命令来激活环境：
- en: Please note that we have used a name for the created virtual environment, `venv`,
    which is the same as the name of the module. That's not necessary. Virtual environments
    can be created with any name. Be sure to use a name that's descriptive in your
    use case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为创建的虚拟环境使用了名称 `venv`，这与模块的名称相同。这不是必要的。虚拟环境可以用任何名称创建。确保使用一个在您的用例中具有描述性的名称。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the `python` interpreter and `pip` that get executed is the
    one located in the virtual environment, and not the system one, and also the indication
    in the prompt that the virtual environment, `venv`, is active.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到执行的是虚拟环境中的 `python` 解释器和 `pip`，而不是系统版本，并且在提示符中也有指示，说明虚拟环境 `venv` 已激活。
- en: The virtual environment also has its own library, so any installed packages
    will be stored here, and not in the system environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境也有自己的库，因此任何安装的包都会存储在这里，而不是在系统环境中。
- en: The virtual environment can be deactivated by calling the `deactivate` command.
    You can see that the `(venv)` indication disappears.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `deactivate` 命令来停用虚拟环境。你可以看到 `(venv)` 标识消失了。
- en: Once in the virtual environment, any call to `pip` will install the packages
    in the virtual environment, so they are independent of any other environment.
    Each program can then be executed within its own virtual environment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入虚拟环境，任何对 `pip` 的调用都会在虚拟环境中安装包，因此它们与其他环境独立。然后每个程序都可以在其自己的虚拟环境中执行。
- en: In cases where the virtual environment cannot be activated directly through
    the command line and the command needs to be executed directly, for example, for
    cronjob cases, you can call the `python` interpreter directly in the virtual environment
    by its full path, such as `/path/to/venv/python/your_script.py`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法直接通过命令行激活虚拟环境，需要直接执行命令的情况下，例如 cronjob 情况，可以直接通过虚拟环境的完整路径调用 `python` 解释器，例如
    `/path/to/venv/python/your_script.py`。
- en: With a proper environment, we can use pip to install the different dependencies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在合适的环境中，我们可以使用 `pip` 安装不同的依赖项。
- en: Preparing an environment
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备环境
- en: Creating a virtual environment is the first stage, but we need to install all
    dependencies for our software.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境是第一步，但我们需要安装软件的所有依赖项。
- en: To be able to replicate the environment in all situations, the best is to create
    a requirements file that defines all dependencies that should be installed. `pip`
    allows working with a file, normally called `requirements.txt`, to install dependencies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在所有情况下都能复制环境，最好的做法是创建一个定义了所有应安装依赖项的 requirements 文件。`pip` 允许通过一个文件（通常称为 `requirements.txt`）来安装依赖项。
- en: This is an excellent way of creating a replicable environment that can be started
    from scratch when necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种创建可复制环境的极好方法，当需要时可以从头开始。
- en: 'For example, let''s take a look at the following `requirements.txt` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下下面的 `requirements.txt` 文件：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The file can be downloaded from GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_11_package_management/requirements.txt](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_11_package_management/requirements.txt).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 下载该文件：[https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_11_package_management/requirements.txt](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/chapter_11_package_management/requirements.txt)。
- en: Note the format is `package==version`. This specifies the exact version to use
    for the package, which is the recommended way of installing dependencies. That
    avoids the problem of using just `package`, which will install the latest version,
    and which can lead to an upgrade that's not planned, which may break compatibility.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意格式为`package==version`。这指定了用于该包的确切版本，这是安装依赖项的推荐方式。这样可以避免仅使用`package`，这会导致安装最新版本，可能会引起未计划的升级，这可能导致兼容性问题。
- en: Other options, such as `package>=version`, to specify a minimum version are
    available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项，如`package>=version`，可以指定最小版本。
- en: 'The file can be installed in the virtual environment (remember to activate
    it) using the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在虚拟环境中安装该文件（请记住激活它）：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After that, all the specified requirements will be installed in the environment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，所有指定的需求都将安装到环境中。
- en: Note that the dependencies of your specified dependencies may not be totally
    pinned down to specific versions. This is because the dependencies have their
    own definition, which can produce unknown upgrades on second-level dependencies
    when a new package is delivered.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你指定的依赖项的依赖项可能并没有完全固定到特定版本。这是因为依赖项有自己的定义，当交付新包时，它可能会在二级依赖项上产生未知的升级。
- en: 'To avoid having that problem, you can create an initial installation with your
    first-level dependencies, and then obtain all the dependencies that have been
    installed with the `pip freeze` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免出现这个问题，你可以创建一个包含一级依赖的初始安装，然后使用`pip freeze`命令获取所有已安装的依赖项：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can use the output to update the `requirements.txt` directly, so the next
    installation will have all the second-level dependencies also pinned down.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用输出更新`requirements.txt`，这样下一次安装将具有所有二级依赖项也固定下来。
- en: Note that adding new requirements will require the same process to be generated,
    to install first, then run `freeze`, and then update the `requirements.txt` file
    with the ouput.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，添加新需求将需要生成相同的过程，首先安装，然后运行`freeze`，然后使用输出更新`requirements.txt`文件。
- en: A note on containers
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于容器的一些注意事项
- en: When working in a container manner, the distinction between the system interpreter
    and the program interpreter is more diluted, as the container has its own OS wrapped,
    thereby enforcing a strong separation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化工作方式中，系统解释器和程序解释器之间的区别更加模糊，因为容器包含了自己的操作系统封装，从而强制执行了强分离。
- en: In the traditional way of deploying services, they are installed and run in
    the same server, making it necessary to keep a separation between the interpreter
    due to the restrictions that we talked about previously.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的服务部署方式中，它们在同一服务器上安装和运行，由于我们之前讨论的限制，这需要保持解释器之间的分离。
- en: By using containers, we have already created a wrap around each of the services
    into their own OS filesystem, which means that we can skip the creation of a virtual
    environment. The container acts as a virtual environment in this case, enforcing
    separation between different containers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用容器，我们已经在每个服务周围创建了一个封装到它们自己的操作系统文件系统，这意味着我们可以跳过虚拟环境的创建。在这种情况下，容器充当虚拟环境，强制不同容器之间的分离。
- en: As we've discussed previously in *Chapter 8*, *Advanced Event-Driven Structures*,
    when talking about containers, each container should serve only a single service,
    coordinating different containers to generate different servers. That way, it
    eliminates the case of having to share the same interpreter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第8章*高级事件驱动结构*中讨论的那样，当谈论容器时，每个容器应仅服务于单个服务，协调不同容器以生成不同的服务器。这样，它消除了需要共享相同解释器的情况。
- en: This means that we can ease some of the restrictions that we would normally
    impose in a traditional setting, and care just about one environment, being able
    to take less care about polluting the system environment. There's only one environment,
    so we can play with it more freely. If we need more services or environments,
    we can always create more containers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以放宽在传统环境中通常施加的一些限制，只需关注一个环境，能够更少地担心污染系统环境。只有一个环境，所以我们可以更自由地玩耍。如果我们需要更多服务或环境，我们总是可以创建更多容器。
- en: Python packages
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python包
- en: A Python module ready to use is, in essence, a subdirectory with certain Python
    code. This subdirectory gets installed in the proper library's subdirectoy, and
    the interpreter searches in this subdirectory. The directory is called `site-packages`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个准备就绪的Python模块本质上是一个包含某些Python代码的子目录。这个子目录被安装到适当的库子目录中，解释器会在这个子目录中搜索。这个目录被称为`site-packages`。
- en: 'This subdirectory is available in the virtual environment, if you are using
    one. You can check the following subdirectory: `venv/lib/python3.9/site-packages/`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用虚拟环境，这个子目录在虚拟环境中是可用的。你可以检查以下子目录：`venv/lib/python3.9/site-packages/`。
- en: To distribute it, the subdirectory is packaged into two different files, either
    `Egg` files or `Wheel` files. Importantly, though, `pip` can only install `Wheel`
    files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分发，这个子目录被打包成两个不同的文件，即`Egg`文件或`Wheel`文件。重要的是，`pip`只能安装`Wheel`文件。
- en: Source packages can also be created. In this case, the file is a tar file that
    contains all the code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建源代码包。在这种情况下，文件是一个包含所有代码的tar文件。
- en: '`Egg` files are considered deprecated, as their format is older and it''s basically
    a zipped file containing some metadata. `Wheel` files have several advantages:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Egg`文件被认为是过时的，因为它们的格式较旧，基本上是一个包含一些元数据的压缩文件。`Wheel`文件有几个优点：'
- en: They are better defined and allow for more use cases. There's a specific PEP,
    PEP-427 ([https://www.python.org/dev/peps/pep-0427/](https://www.python.org/dev/peps/pep-0427/)),
    that defines the format. `Egg` files were never officially defined.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们定义得更好，允许更多的使用场景。有一个特定的PEP，PEP-427 ([https://www.python.org/dev/peps/pep-0427/](https://www.python.org/dev/peps/pep-0427/))，它定义了格式。`Egg`文件从未被正式定义。
- en: They can be defined to have better compatibility, allowing the creation of `Wheel`
    files that are compatible between different versions of Python, including Python
    2 and Python 3.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被定义为具有更好的兼容性，允许创建在不同版本的Python之间兼容的`Wheel`文件，包括Python 2和Python 3。
- en: '`Wheel` files can include already compiled binary code. Python allows the inclusion
    of libraries that are written in C, but these libraries need to target the proper
    hardware architecture. In `Egg` files, the source files were included and compiled
    at install time, but that required the proper compilation tools and environment
    in the installation machine, and this could easily result in compilation issues.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wheel`文件可以包含已经编译的二进制代码。Python允许包含用C语言编写的库，但这些库需要针对正确的硬件架构。在`Egg`文件中，源文件在安装时被包含并编译，但这需要在安装机器上提供适当的编译工具和环境，这很容易导致编译问题。'
- en: Instead of that, `Wheel` files can be precompiled with binary files. The `Wheel`
    file has better-defined compatibility based on hardware architecture and the OS,
    so the right `Wheel` file will be downloaded and installed, if available. This
    makes the installation faster, as no compilation needs to be performed in the
    installation, and removes the need for compilation tools available in the target
    machine. A `Wheel` file with a source file can also be created to allow its installation
    in machines not already precompiled, though in this case, it will require a compiler.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，`Wheel`文件可以预先编译二进制文件。`Wheel`文件基于硬件架构和操作系统有更好的定义的兼容性，因此如果可用，将下载并安装正确的`Wheel`文件。这使得安装更快，因为不需要在安装时进行编译，并且消除了在目标机器上需要编译工具的需求。也可以创建包含源文件的`Wheel`文件，以便在未预先编译的机器上安装，尽管在这种情况下，它将需要一个编译器。
- en: '`Wheel` files can be cryptographically signed, while `Eggs` don''t support
    this option. That adds an extra layer to avoid compromised and modified packages.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wheel`文件可以进行加密签名，而`Eggs`不支持此选项。这为避免受损和修改的包添加了一个额外的安全层。'
- en: Right now, the standard for packaging in Python is `Wheel` files, and they should
    be preferred as a general rule. `Egg` files should be limited to older packages
    that haven't been upgraded to the new format.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Python的打包标准是`Wheel`文件，并且应该作为一般规则优先选择。`Egg`文件应限制在尚未升级到新格式的旧包中。
- en: 'Egg files can be installed with the older `easy_install` script, although this
    is no longer included in the latest versions of Python. Check the documentation
    for setup tools on how to use `easy_install`: [https://setuptools.readthedocs.io/en/latest/deprecated/easy_install.html](https://setuptools.readthedocs.io/en/latest/deprecated/easy_install.html).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用较旧的`easy_install`脚本来安装Egg文件，尽管这个脚本已经不再包含在Python的最新版本中。有关如何使用`easy_install`的设置工具文档，请参阅：[https://setuptools.readthedocs.io/en/latest/deprecated/easy_install.html](https://setuptools.readthedocs.io/en/latest/deprecated/easy_install.html)。
- en: We will see now how to create your own package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到如何创建自己的软件包。
- en: Creating a package
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建软件包
- en: Even if, in most cases, we will use third-party packages, at some point, it
    is possible that you'll need to create your own package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在大多数情况下，我们将使用第三方软件包，但在某些时候，你可能需要创建自己的软件包。
- en: 'To do so, you need to create a `setup.py` file, which is the base of the package,
    describing what is inside it. Base package code will look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要创建一个`setup.py`文件，这是软件包的基础，描述了其中包含的内容。基本软件包代码看起来像这样：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `LICENSE` and `README` files are not mandatory but are good to include for
    adding information about the package. The `LICENSE` file will be included automatically
    in the package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`LICENSE`和`README`文件不是必需的，但包含有关软件包的信息是很好的。`LICENSE`文件将自动包含在软件包中。'
- en: Choosing your own open source license can be difficult. You can use the web
    ([https://choosealicense.com/](https://choosealicense.com/)), which shows different
    options and explains them. We will use the MIT license as an example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 选择自己的开源许可可能很困难。你可以使用网站([https://choosealicense.com/](https://choosealicense.com/))，它展示了不同的选项并解释了它们。我们将以MIT许可为例。
- en: The `README` file is not included, but we will include its content in a full
    description of the package as part of the build process, as we will see later.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`README`文件不包括在内，但我们将将其内容包含在软件包的完整描述中，作为构建过程的一部分，就像我们稍后将要看到的那样。'
- en: 'The code of the process is the `setup.py` file. Let''s take a look at an example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的代码是`setup.py`文件。让我们看看一个例子：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `setup.py` file essentially contains the `setuptools.setup` function, which
    defines the package. It defines the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件本质上包含`setuptools.setup`函数，它定义了软件包。它定义了以下内容：'
- en: '`name`: The name of the package.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 软件包的名称。'
- en: '`version`: The version of the package. It will be used when installing a particular
    version or when ascertaining which is the latest version.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 软件包的版本。它将在安装特定版本或确定最新版本时使用。'
- en: '`author` and `author_email`: It is good to include these to receive any possible
    bug reports or requests.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`和`author_email`: 包括这些以接收任何可能的错误报告或请求。'
- en: '`description`: A short description.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 一个简短的描述。'
- en: '`url`: The URL for the project.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`: 项目的URL。'
- en: '`long_description`: A longer description. Here, we are reading the `README`
    file, storing the content in the `description` variable:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long_description`: 一个更长的描述。在这里，我们正在读取`README`文件，将内容存储在`description`变量中：'
- en: '[PRE14]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An important detail of `setup.py` is that it is dynamic, so we can use code
    to determine the values of any parameter.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setup.py`的一个重要细节是它是动态的，因此我们可以使用代码来确定任何参数的值。'
- en: '`classifier`: Categories for allowing packages to be categorized in different
    areas, such as the kinds of licenses and languages, or if the package is supposed
    to work with a framework like Django. You can check the full list of classifiers
    at the following link: [https://pypi.org/classifiers/](https://pypi.org/classifiers/).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classifier`: 允许软件包在不同领域进行分类的类别，例如许可证类型和语言，或者软件包是否应该与Django等框架一起工作。你可以在以下链接中查看完整的分类器列表：[https://pypi.org/classifiers/](https://pypi.org/classifiers/)。'
- en: '`package_dir`: The subdirectory where the code of the package is located. Here,
    we specify `src`. By default, it will use the same directory as `setup.py`, but
    it''s better to make the division so as to keep the code tidy.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package_dir`: 包代码所在的子目录。在这里，我们指定`src`。默认情况下，它将使用与`setup.py`相同的目录，但最好是进行划分，以保持代码整洁。'
- en: '`install_requires`: Any dependency that needs to be installed with your package.
    Here, we are adding `requests` as an example. Note that any second-order dependencies
    (dependencies of `requests`) will be installed as well.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install_requires`: 需要与您的软件包一起安装的任何依赖项。在这里，我们以`requests`为例。请注意，任何二阶依赖项（`requests`的依赖项）也将被安装。'
- en: '`packages`: Using the `setuptools.find_packages` function, include everything
    that''s in the `src` directory.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages`: 使用`setuptools.find_packages`函数，包括`src`目录中的所有内容。'
- en: '`python_requires`: Define what Python interpreters are compatible with the
    package. In this case, we define it for Python 3.9 or higher.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python_requires`: 定义与该软件包兼容的Python解释器。在这种情况下，我们将其定义为Python 3.9或更高版本。'
- en: 'Once the file is ready, you can run the `setup.py` script directly, for example,
    to check that the data is correct:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 文件准备好后，你可以直接运行`setup.py`脚本，例如，以检查数据是否正确：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This command will verify that the `setup.py` definition is correct and that
    no mandatory elements are missing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将验证`setup.py`的定义是否正确，以及是否有任何必需元素缺失。
- en: Development mode
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发模式
- en: 'The `setup.py` file can be used to install the package in `develop` mode. This
    installs the package in the current environment in a linked way. This means that
    any changes to the code will be applied directly to the package after the interpreter
    is restarted, making it easy to change and work with tests. Remember to run it
    while inside the virtual environment:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件可用于在`develop`模式下安装包。这意味着以链接方式将包安装到当前环境中。这意味着任何对代码的更改将在解释器重新启动后直接应用于包，这使得更改和与测试一起工作变得容易。请记住，在虚拟环境中运行它：'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The developed version can be uninstalled easily to clean up the environment:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 开发版本可以轻松卸载以清理环境：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can read more about development mode in the official documentation here:
    [https://setuptools.readthedocs.io/en/latest/userguide/development_mode.html](https://setuptools.readthedocs.io/en/latest/userguide/development_mode.html).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处阅读有关开发模式的官方文档：[https://setuptools.readthedocs.io/en/latest/userguide/development_mode.html](https://setuptools.readthedocs.io/en/latest/userguide/development_mode.html)。
- en: This step installs the package directly in the current environment and can be
    used to run tests and validate that the package is working as expected once installed.
    Once this is done, we can prepare the package itself.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤将包直接安装到当前环境中，并可用于运行测试并验证包安装后是否按预期工作。一旦完成，我们就可以准备包本身。
- en: Pure Python package
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯Python包
- en: 'To create a package, we first need to define what kind of package we want to
    create. As we described before, we have three options: a source distribution,
    an `Egg`, or a `Wheel`. Each one is defined by a different command in `setup.py`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包，我们首先需要定义我们想要创建哪种类型的包。正如我们之前所描述的，我们有三种选择：源分发、`Egg`或`Wheel`。每个都由`setup.py`中的不同命令定义。
- en: 'To create a source distribution, we will use `sdist` (source distribution):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建源分发，我们将使用`sdist`（源分发）：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `dist` package is available in the newly created `dist` subdirectory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`dist`包可在新创建的`dist`子目录中找到：'
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To generate a proper `Wheel` package, we need to install the `wheel` module
    first:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成合适的`Wheel`包，我们首先需要安装`wheel`模块：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This adds the `bdist_wheel` command to the available commands in `setup.py`,
    which generates a `wheel`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`setup.py`中添加`bdist_wheel`命令到可用的命令中，该命令生成一个`wheel`：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the `wheel` file is available, once more, in the `dist` subdirectory:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 并且`wheel`文件再次在`dist`子目录中可用：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that it also includes Python version 3.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它还包括Python 3版本。
- en: Wheel packages compatible with both Python 2 and Python 3 can be used. These
    wheels are called *Universal*. That was useful while doing the transition between
    both versions. Hopefully, by now, most of the new code in Python is using version
    3 and we don't have to worry about that.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python 2和Python 3都兼容的Wheel包可以用于。这些wheel被称为*通用*。在两个版本之间进行过渡时这很有用。希望到现在为止，Python中的大多数新代码都在使用版本3，我们不必担心这一点。
- en: 'All these created packages can be installed directly with pip:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些创建的包都可以直接使用pip安装：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the dependencies, in this case, `requests`, are installed automatically
    as well as any second-level dependency, for example, `urllib3`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，依赖项`requests`以及任何二级依赖项，例如`urllib3`，都将自动安装。
- en: The power of the packaging is not only applicable to packages that contain only
    Python code. One of the most interesting features of `wheels` is the ability to
    generate pre-compiled packages, which includes compiled code for a target system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的力量不仅适用于仅包含Python代码的包。`wheels`最有趣的功能之一是能够生成预编译的包，这包括针对目标系统的编译代码。
- en: To be able to show that, we need to produce some Python module that contains
    code that will be compiled. To do so, we need to take a small detour.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要展示这一点，我们需要生成一些包含将被编译的代码的Python模块。为此，我们需要稍微绕一下。
- en: Cython
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython
- en: Python is capable of creating C and C++ language extensions that are compiled
    and interact with the Python code. Python itself is written in C, so this is a
    natural extension.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Python能够创建C和C++语言扩展，这些扩展被编译并与Python代码交互。Python本身是用C编写的，因此这是一个自然的扩展。
- en: While Python has a lot of great features, pure speed when performing certain
    operations, such as numerical operations, is not its forte. This is where the
    C extensions come into their own as they enable low-level code to be accessed,
    which can be optimized and run faster than Python. Don't underestimate the possibility
    of creating a small, localized C extension that speeds up critical parts of the
    code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 有很多优秀的特点，但在执行某些操作（如数值操作）时，纯速度并不是其强项。这就是 C 扩展大显身手的地方，因为它们允许访问底层代码，这些代码可以被优化并比
    Python 运行得更快。不要低估创建一个小型、局部化的 C 扩展来加速代码关键部分的可能性。
- en: Creating a C extension, however, can be difficult. The interface between Python
    and C is not straightforward, and the memory management required in C may be daunting
    unless you have significant experience of working with the C language.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建一个 C 扩展可能很困难。Python 和 C 之间的接口并不直接，而且 C 中所需的内存管理可能令人望而却步，除非您有丰富的 C 语言工作经验。
- en: If you want to dive deep into the topic and create your own C/C++ extensions,
    you can start by reading the official documentation at [https://docs.python.org/3/extending/index.html](https://docs.python.org/3/extending/index.html).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入研究这个主题并创建自己的 C/C++ 扩展，可以从阅读官方文档开始：[https://docs.python.org/3/extending/index.html](https://docs.python.org/3/extending/index.html)。
- en: 'Other options are available, such as creating extensions in Rust. You can check
    how to do this in the following article: [https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust](https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项还包括在 Rust 中创建扩展。您可以在以下文章中查看如何操作：[https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust](https://developers.redhat.com/blog/2017/11/16/speed-python-using-rust)。
- en: Fortunately, there are some alternatives to make the task easier. A very good
    one is Cython.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些替代方案可以使任务变得更容易。其中一个非常好的选择是 Cython。
- en: Cython is a tool that compiles Python code with some extensions in C, so writing
    a C extension is as simple as writing Python code. The code is annotated to describe
    the C types for variables, but other than that, it looks pretty similar.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一种工具，它使用 C 的一些扩展来编译 Python 代码，因此编写 C 扩展就像编写 Python 代码一样简单。代码有注释来描述变量的
    C 类型，但除此之外，它看起来非常相似。
- en: 'A complete description of Cython and all its possibilities is beyond the scope
    of this book. We present just a brief introduction. Please check the complete
    documentation for more information: [https://cython.org/](https://cython.org/).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 及其所有可能性的完整描述超出了本书的范围。我们仅提供简要介绍。请查阅完整文档以获取更多信息：[https://cython.org/](https://cython.org/)。
- en: 'Cython files are stored as `.pyx` files. Let''s see an example, which will
    determine whether a number is a prime number with the help of the `wheel_package_compiled.pyx`
    file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 文件存储为 `.pyx` 文件。让我们看一个例子，它将使用 `wheel_package_compiled.pyx` 文件来确定一个数字是否为素数：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code is checking whether a positive number is a prime number:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正在检查一个正数是否为素数：
- en: It returns `False` if the input is zero.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入为零，则返回 `False`。
- en: It tries to divide the number by a number from 2 to the number. If any division
    is exact, it returns `False` as the number is not a prime number.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它尝试将数字除以从 2 到该数字的每个数字。如果任何除法是精确的，它返回 `False`，因为该数字不是素数。
- en: If no division is exact, or the number is lower than 2, it returns `True`.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有精确的除法，或者数字小于 2，它返回 `True`。
- en: The code is not exactly Pythonic, as it will be translated into C. It's more
    efficient to avoid Python calls like `range` or similar. Don't be afraid to test
    different approaches to see what's faster to execute.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并不完全符合 Python 风格，因为它将被翻译成 C。避免使用 `range` 或类似的 Python 调用会更有效率。不要害怕测试不同的方法，看看哪种执行速度更快。
- en: The code is not particularly good; it attempts too many divisions in general.
    It is just for the purpose of showing example code that may make sense to be compiled
    and is not too complicated.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 代码并不特别出色；它通常尝试过多的除法。它只是为了展示可能被编译且不太复杂的示例代码。
- en: 'Once the `pyx` file is ready, it can be compiled and imported into Python,
    using Cython. First, we need to install Cython:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `pyx` 文件准备就绪，就可以使用 Cython 编译并导入到 Python 中。首先，我们需要安装 Cython：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, using `pyximport`, we can import the module directly like a `py` file.
    Cython will automatically compile it if necessary:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `pyximport`，我们可以像导入 `py` 文件一样直接导入模块。如果需要，Cython 会自动编译它：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see that the compiler produces an error because there's a comparison
    between `unsigned int` and `int` (between `counter` and `number`).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到编译器产生了一个错误，因为存在`unsigned int`和`int`（`counter`和`number`之间）的比较。
- en: This has been deliberately left to clearly show when the compilation takes place
    and that any compilation feedback, such as warnings or errors, will be displayed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意为之，以便清楚地显示编译发生的时间和任何编译反馈，如警告或错误，将会显示。
- en: 'Once the code is compiled, Cython creates both a `wheel_package_compiled.c`
    file, local to the directory, and the compiled `.so` file, which, by default,
    is stored in `$HOME/ .pyxbld`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码编译完成，Cython将创建一个位于目录本地的`wheel_package_compiled.c`文件和一个编译后的`.so`文件，默认情况下存储在`$HOME/
    .pyxbld`：
- en: Note that this will be specific to your system. Here, we are showing a module
    compiled for macOS.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这将是特定于你的系统的。在这里，我们展示了一个为macOS编译的模块。
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using `pyximport` is good for local development, but we can create a package
    that compiles and packages it as part of the build process.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pyximport`对本地开发很有用，但我们可以创建一个包，在构建过程中编译并打包它。
- en: Python package with binary code
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有二进制代码的Python包
- en: We will use the code we created using Cython to show how to build a package
    that combines Python code with precompiled code. We will generate a `Wheel` file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用使用Cython创建的代码来展示如何构建一个结合Python代码和预编译代码的包。我们将生成一个`Wheel`文件。
- en: We create a package called `wheel_package_compiled` that extends the previous
    example package, `wheel_package`, with the code presented to be compiled in Cython.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`wheel_package_compiled`的包，它扩展了之前的示例包`wheel_package`，并包含了要使用Cython编译的代码。
- en: The code is available in GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_11_package_management/wheel_package_compiled](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_11_package_management/wheel_package_compiled).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上找到：[https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_11_package_management/wheel_package_compiled](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_11_package_management/wheel_package_compiled)。
- en: 'The structure of the package will be like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 包的结构将如下所示：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the same as the package introduced previously, but with the addition
    of the `.pyx` file. The `setup.py` file needs to add some changes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前介绍的包相同，但增加了`.pyx`文件。`setup.py`文件需要添加一些更改：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The changes introduced, other than the `name` change for the package, are all
    related to the new extension:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包的`name`更改之外，引入的所有更改都与新的扩展有关：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The extension definition targets the name of the module to add, and the location
    of the source. With the `cythonize` function, we are indicating that we want to
    use Cython to compile it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展定义针对要添加的模块名称和源位置。使用`cythonize`函数，我们表示希望使用Cython来编译它。
- en: Extension modules are modules compiled in C/C++. In this case, Cython will run
    the intermediate steps to be sure that the proper `.c` file is the one being compiled.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展模块是使用C/C++编译的模块。在这种情况下，Cython将运行中间步骤以确保正在编译的是正确的`.c`文件。
- en: 'Once this is configured, we can run the code to generate the wheel, calling
    `setup.py`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，我们可以运行代码生成`Wheel`，调用`setup.py`：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The compiled `Wheel` is available, as before, in the `dist` subdirectory.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的`Wheel`包，与之前一样，位于`dist`子目录中。
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Compared with the `Wheel` created previously, we can see that it adds the platform
    and hardware architecture (macOS 11 and x86 64 bits, which is the computer used
    to compile it while writing the book). The `cp39` part shows that it used the
    Python 3.9 ABI (Application Binary Interface).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前创建的`Wheel`相比，我们可以看到它增加了平台和硬件架构（macOS 11和x86 64位，这是编写本书时用于编译的计算机）。`cp39`部分表明它使用了Python
    3.9 ABI（应用程序二进制接口）。
- en: The created `Wheel` is ready to use for the same architecture and system. The
    `Wheel` package directly includes all the compiled code, so the package will install
    quickly, as only copying files is involved. Also, there will be no need to install
    compilation tools and dependencies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`Wheel`包适用于相同的架构和系统。`Wheel`包直接包含所有编译后的代码，因此安装速度快，只需复制文件即可。此外，无需安装编译工具和依赖项。
- en: When working with packages that need to be installed in multiple architectures
    or systems, you'll need to create an individual `Wheel` for each case and add
    the source distribution file to allow other systems to work with it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当与需要在多个架构或系统上安装的包一起工作时，你需要为每种情况创建一个单独的`Wheel`，并将源分发文件添加进去，以便其他系统可以与之协同工作。
- en: But, unless you are creating a general package to be submitted to PyPI, the
    package will be for self-consumption, and normally you only need to create a `Wheel`
    file for your specific use case.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除非您正在创建一个要提交给PyPI的通用包，否则该包将用于自用，并且通常您只需要为您的特定用例创建一个`Wheel`文件。
- en: Which leads to the same step. What if you want to share your module with the
    whole Python community?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致相同的步骤。如果您想与整个Python社区分享您的模块怎么办？
- en: Uploading your package to PyPI
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的包上传到PyPI
- en: PyPI is open to accepting packages from any developer. We can create a new account
    and upload our packages to the official Python repo to allow any project to use
    it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PyPI对所有开发者开放，接受包。我们可以创建一个新账户并将我们的包上传到官方Python仓库，以便任何项目都可以使用它。
- en: One of the great characteristics of open source projects, like Python and its
    ecosystem, is the ability to use code that is gracefully shared by other developers.
    While not mandatory, it is always good to give back and to share code that could
    be of interest to other developers to increase the usefulness of the Python library.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 开源项目，如Python及其生态系统，的一个伟大特征是能够使用其他开发者优雅共享的代码。虽然不是强制性的，但总是好的，要回馈并分享可能对其他开发者感兴趣的代码，以增加Python库的有用性。
- en: Be a good participant in the Python ecosystem and share code that could be useful
    to others.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 成为Python生态系统的良好参与者，并分享可能对他人有用的代码。
- en: To help with testing and to be sure that we can verify the process, there's
    a testing site called **TestPyPI** at [https://test.pypi.org/](https://test.pypi.org/)
    that can be used to perform tests and to upload your package first.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助测试并确保我们可以验证这个过程，有一个名为**TestPyPI**的测试网站[https://test.pypi.org/](https://test.pypi.org/)，可以用来执行测试并首先上传您的包。
- en: '![Graphical user interface, website'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，网站'
- en: Description automatically generated](img/B17580_11_04.png)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_11_04.png)
- en: 'Figure 11.4: TestPyPI main page'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：TestPyPI主页
- en: The site is the same as the production one but indicates with a banner that
    it's the testing site.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 网站与生产环境相同，但通过横幅标明它是测试网站。
- en: You can register a new user at [https://test.pypi.org/account/register/](https://test.pypi.org/account/register/).
    After that, you'll need to create a new API token to allow the package to be uploaded.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://test.pypi.org/account/register/](https://test.pypi.org/account/register/)注册新用户。之后，您需要创建一个新的API令牌，以便允许上传包。
- en: Remember to verify your email. Without a verified email, you won't be able to
    create an API token.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 记得验证您的电子邮件。如果没有验证的电子邮件，您将无法创建API令牌。
- en: If there's a problem with the API token or you lose it, you can always delete
    it and start again.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API令牌有问题或丢失，您总是可以删除它并重新开始。
- en: '![Graphical user interface, text, application'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，文本，应用程序'
- en: Description automatically generated](img/B17580_11_05.png)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_11_05.png)
- en: 'Figure 11.5: You''ll need to grant the full scope to upload a new package'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：您需要授予完整权限才能上传新包
- en: Create a new token and copy it to a safe place. The token (which starts with
    `pypi-`) will only be displayed once for safety reasons, so be careful with it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的令牌并将其复制到安全的地方。出于安全原因，令牌（以`pypi-`开头）只会显示一次，所以请小心处理。
- en: The token replaces the login and password when uploading a package. We will
    see later how to use it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌在上传包时替换了登录名和密码。我们稍后会看到如何使用它。
- en: 'The next step is to install the `twine` package, which simplifies the process
    of uploading. Be sure to install it in our virtual environment:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装`twine`包，它简化了上传过程。请确保在我们的虚拟环境中安装它：
- en: '[PRE33]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we can upload the packages created in the `dist` subdirectory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以上传在`dist`子目录中创建的包。
- en: For our example, we will use the same package created previously, but keep in
    mind that trying to reupload it may not work, as there may already be a package
    called that in TestPyPI. TestPyPI is not permanent, and regularly deletes packages,
    but the example uploaded as part of the writing process of the book could still
    be there. To do your tests, create your own package with a unique name.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用之前创建的相同包，但请注意，尝试重新上传可能不起作用，因为在TestPyPI中可能已经有一个同名包。TestPyPI不是永久的，并且定期删除包，但作为本书写作过程的一部分上传的示例可能仍然存在。为了进行测试，创建一个具有唯一名称的自己的包。
- en: 'We have now built the compiled `Wheel` and the source distribution:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了编译的`Wheel`和源分发：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s upload the packages. We need to indicate that we want to upload to the
    `testpy` repo. We will use `__token__` as the username and the full token (including
    the `pypi-` prefix) as the password:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The package is now uploaded! We can check the page on the TestPyPI website.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_06.png)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Main page for the package'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the uploaded files by clicking **Download files**:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, website'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_07.png)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.7: Verifying the uploaded files'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also access the files through the search function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_08.png)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.8: The package available in search'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now download the package directly through `pip`, but you need to indicate
    that the index to use is the TestPyPI one. To ensure a clean installation, create
    a new virtual environment as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the version downloaded is the `Wheel` one, as it is the right target
    for the compiled version. It also correctly downloads the specified `requests`
    dependency.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now test the package through the Python interpreter:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The package is now installed and ready to use. The next step is to upload this
    package to production PyPI instead of TestPyPI. This is totally analogous to the
    process that we've seen here, creating an account in PyPI and proceeding from
    there.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: But, what if the objective of the package is not to create a publicly available
    package? It is possible that we need to create our own index with our packages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own private index
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you'll need to have your own private index, so you can serve your
    own packages without opening them to the full internet, for internal packages
    that need to be used across the company, but where it doesn't make sense to upload
    them to the public PyPI.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own private index that can be used to share those packages
    and install them by calling to that index.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To serve the packages, we need to run a PyPI server locally. There are several
    options in terms of available servers that can be used, but an easy option is
    `pypiserver` ([https://github.com/pypiserver/pypiserver](https://github.com/pypiserver/pypiserver)).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`pypiserver` can be installed in several ways; we will see how to run it locally,
    but to serve it correctly, you''ll need to install it in a way that''s available
    in your network. Check the documentation to see several options, but a good option
    is to use the official Docker image available.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `pypiserver`, first, install the package using `pip` and create a directory
    for storing the packages:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Start the server. We use the parameter `-p 8080` to serve it in that port,
    the directory to store the packages, and `-P . -a .` to facilitate the uploading
    of packages without authentication:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open a browser and check `http://localhost:8080`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_09.png)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.9: Local pypi server'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: You can check the available packages in this index by going to `http://localhost:8080/simple/`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_10.png)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.10: Empty index so far'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to upload the packages, using `twine` again, but pointing to our
    private URL. As we are able to upload with no authentication, we can enter an
    empty username and password:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The index is now showing the package available.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_11.png)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.11: Showing the package uploaded'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B17580_11_12.png)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.12: All the uploaded files for the package'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'The files are also uploaded to the `package-library` directory:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Any file added to `package-library` will also be served, allowing packages to
    be added by moving them to the directory, although that could be complicated once
    the server is deployed properly to the packages over the network.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The package can now be downloaded and installed, pointing to your private index
    using the `–index-url` parameter:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This tests that the module can be imported and executed after installation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described when it's a good idea to create a standard package
    and the caveats and requirements that we should add to be sure that we are taking
    a good decision. In essence, creating a new package is creating a new project,
    and we should give the proper ownership, documentation, and so on, as expected
    of other projects in the organization.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We described the simplest possible package in Python just by structuring code,
    but without creating a proper package. This acts as a baseline on how the code
    should be structured later.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We continued describing what the current packaging environment is and what are
    the different elements that are part of it, like PyPI, which is the official source
    for publicly available packages, and how to create virtual environments to not
    cross-contaminate different environments when requiring different dependencies.
    We also described the `Wheel` package, which will be the kind of package that
    we will create later.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Next, we described how to create such a package, creating a `setup.py` file.
    We described how to install it in development mode to be able to do tests and
    how to build and get the package ready.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: There are some alternatives to creating packages instead of using the standard
    `setup.py` file. You can take a look at the `Poetry` package ([https://python-poetry.org/](https://python-poetry.org/))
    to see how to manage packages in a more integrated way, especially if the package
    has many dependencies.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: We took a small detour to explain how to generate code to be compiled with Cython,
    an easy way to create Python extensions writing in Python code with some extensions,
    to generate C code automatically.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍作绕道解释了如何生成用 Cython 编译的代码，这是一种通过在 Python 代码中添加一些扩展来创建 Python 扩展的简单方法，可以自动生成
    C 代码。
- en: We used Cython code to show how to generate a compiled `Wheel`, allowing the
    distribution of already precompiled code without needing to be compiled on installation.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Cython 代码展示了如何生成编译后的 `Wheel`，允许分发已经预先编译的代码，无需在安装时进行编译。
- en: We showed how to upload packages to PyPI to distribute publicly (showing how
    to upload to TestPyPI, allowing the upload of packages to be tested) and described
    how to create your own individual index so that you can distribute your own packages
    privately.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何将软件包上传到 PyPI 以公开分发（展示了如何上传到 TestPyPI，允许测试软件包的上传）并描述了如何创建你自己的个人索引，以便你可以私下分发你自己的软件包。
