<html><head></head><body>
        

                            
                    <h1 class="header-title">RESTful Services API Testing and Security</h1>
                
            
            
                
<p>Any software that claims to be enterprise-ready must have gone through rigorous testing cycles, be quality assurance certified, and have met several quality measures so that it gets used on production servers. The security of a software application is another critical aspect that determines whether or not it will be used on production servers.</p>
<p>To equip readers with an understanding of different aspects of production and enterprise-ready RESTful APIs, this chapter will discuss various aspects of those quality and security measures.</p>
<p>This chapter's intention is to take readers on an API testing journey. These are the milestones or topics we will cover as we go along:</p>
<ul>
<li>Types of API tests</li>
<li>Challenges in API testing</li>
<li>Security in API testing</li>
<li>In addition, we will give you a glimpse of various API testing tools, API security tools, and frameworks</li>
</ul>
<p>Midway through the API testing journey, readers will be taken on a detour to be introduced to some security issues and API vulnerabilities and learn how to expose them as part of API testing.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of software testing </h1>
                
            
            
                
<p>Any product, be it simple safety pins or majestic airplanes, needs to go through a process to ensure that it solves the purpose of its creation, and so does software, too. Software testing is a process to confirm the accuracy and quality of software through the verification and validation of its purpose, end-to-end.</p>
<p>So, the primary focus of any software product or application is verification (checks for consistency and alignment according to the documented requirements) and validation (checks the accuracy of the system and validates the end user's needs versus the actual outcome).</p>
<p>Let's list a few essential outcomes of software testing and move on to focus more on API testing in the upcoming sections:</p>
<ul>
<li>Assert and ensure that there are no differences between the realities and the expectations of the requirements</li>
<li>Assert and ensure software product continuity and availability, regardless of the amount of end users</li>
<li>Foresee and uncover concealed problems</li>
<li>Assert and ensure that offerings function seamlessly with anticipated end user platforms, browsers, and so on</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">RESTful APIs and testing</h1>
                
            
            
                
<p>As this book deals with RESTful APIs, this chapter is intended to take readers through a few essential best practices and API testing principles, along with a couple of testing frameworks. With integration tests (both manual and automated), we can accomplish most critical API testing strategies for distributed applications and help those applications to be production-ready, deployable, and part of CI/CD, as well as to assert their scalability and stability for every release.</p>
<p>The following section introduces the basics of API testing, API testing approaches, their types, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basics of API testing</h1>
                
            
            
                
<p>A software application product, that we discussed in an earlier section, has various software layers such, as the <strong>user interface</strong> (<strong>UI</strong>), the business logic layer, middleware, and a database. <strong>API testing</strong> and certification primarily focuses on data integration tests on the <strong>Business layer</strong>. <strong>API testing</strong> is software testing that involves direct <strong>API testing</strong>, unlike other generic tests, which primarily involve the UI:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4aee86d4-d52a-4cde-bbf1-4aa5cb2e33dd.png" style="width:30.33em;height:9.58em;"/></p>
<p>The preceding diagram depicts the typical layers of software, with <strong>API testing</strong> on the <strong>Business layer</strong> and the functional or UI testing on the <strong>Presentation layer</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding API testing approaches</h1>
                
            
            
                
<p>Agreeing on an approach for API testing when beginning API development is an essential API strategy. Let's look at a few principles of API testing:</p>
<ul>
<li>Clear definition of the scope and a good understanding of the functionality of the API</li>
<li>Common testing methodologies such as boundary analysis and equivalence classes are part of API test cases</li>
<li>Plan, define, and be ready with input parameters, zero, and sample data for the API</li>
<li>Determine and compare expected and actual results, and ensure that there are no differences</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">API testing types</h1>
                
            
            
                
<p>In this section, we will review the various categories of API testing and move on to best practices as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unit tests</h1>
                
            
            
                
<p>Tests that involves the validation of individual operations are unit tests. In our investor services API examples in <a href="c44b2a11-65db-459f-a799-1692dd3930e8.xhtml">Chapter 4</a>, <em>Advanced RESTful API Patterns</em>, we covered numerous unit test cases, and the following is one of the sample code snippets of a specific unit test case that validates getting all the investors from the API:</p>
<pre>    @Test 
    public void fetchAllInvestors() throws Exception{ 
          RequestBuilder requestBuilder =  
               MockMvcRequestBuilders.get( 
                      "/investors").accept( 
                      MediaType.APPLICATION_JSON); 
          MvcResult result =  
              mockMvc.perform(requestBuilder).andReturn(); 
          MockHttpServletResponse response = 
              result.getResponse();      
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">API validation tests</h1>
                
            
            
                
<p>All software needs quick evaluation and to assert its purpose of creation. The validation tests need to be run for every function that is developed, at the end of the development process. Unlike unit tests, which focus on particular pieces or functions of the API, validation tests are a higher-level consideration, answering a set of questions so that the development can move on to the next phase.</p>
<p>A set of questions for validation tests could be the following:</p>
<ol>
<li>A product-specific question, such as, is it the necessary function that is asked for?</li>
<li>A behavioral question, such as, is the developed function doing what is intended?</li>
<li>An efficiency-related question, such as, is the intended function using the necessary code, in an independent and optimized manner?</li>
</ol>
<p>All of these questions, in essence, serve to validate the API in line with the agreed acceptance criteria and also to ensure its adherence to standards regarding the delivery of expected end goals and meeting user needs and requirements flawlessly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Functional tests</h1>
                
            
            
                
<p>Tests that involve specific functions of the APIs and their code base are functional tests. Validating the count of active users through the API, regression tests and test case execution come under functional tests. We saw many examples of functional tests executed with the Postman tool earlier, in <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API Patterns</em>, and <a href="c44b2a11-65db-459f-a799-1692dd3930e8.xhtml">Chapter 4</a>, <em>Advanced RESTful API Patterns</em>. The following screenshot may refresh your memory of one such functional testing example of investor service validation for user authentication:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a465ead7-212a-4aea-91bb-0de24776e251.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">UI or end-to-end tests</h1>
                
            
            
                
<p>Tests that involve and assert end-to-end scenarios, including GUI functions and API functions, which in most of the cases, validate every transaction of an application, are grouped under end-to-end tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Load testing</h1>
                
            
            
                
<p>As we know, an increase in the number of end users should not affect the performance of the functions of an application. Load testing will uncover such issues and also validate the performance of an API in normal conditions too.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Runtime error detection tests</h1>
                
            
            
                
<p>Tests that help to monitor the application and detect problems such as race conditions, exceptions, and resource leaks belong in the runtime error tests category. The following points capture a brief about those factors.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Monitoring APIs</h1>
                
            
            
                
<p>Tests for various implementation errors, handler failures, and other inherent concerns inside the API code base and ensures it does not have any holes that would lead to application insecurity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Execution errors</h1>
                
            
            
                
<p>Valid requests to the API return responses and asserting them for expected valid responses is common, however, asserting invalid requests for expected failures is also essential as part of an API testing strategy, and those tests come under execution errors:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bbccd840-8914-46c3-84a3-dd1ff4296c6a.png"/></p>
<p>The preceding screenshot depicts the <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API Patterns</em>, example of expecting an error when the user gives an ID that is not present on the system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Resource leaks</h1>
                
            
            
                
<p>Negative tests to validate the underlying API resource malfunctions by submitting invalid requests to the API. The resources, in this case, are memory, data, insecurities, timeout operations, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Error detection</h1>
                
            
            
                
<p>Detect network communication failures. Authentication failures from giving the wrong credentials is an example error detection scenario. These are tests ensure the errors are captured and then resolved as well:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/43e9cab8-a9ad-409f-ab6a-49702c77fd31.png"/></p>
<p>We saw an authentication error in our <a href="c44b2a11-65db-459f-a799-1692dd3930e8.xhtml">Chapter 4</a>, <em>Advanced RESTful API Patterns</em>, investor-service example, and the previous screenshot depicts this, as the code returns <kbd>401</kbd> (as it should); this is an example of an error detection test.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">REST API security vulnerabilities</h1>
                
            
            
                
<p>APIs are popular and widely used because they are simple, schematic, fast to develop, and quick to deploy. This naturally brings challenges in terms of ensuring that implementations are secured from various threats, such as <strong>man-in-the-middle-attacks</strong> (<strong>MITM</strong>), a lack of XML encryptions, insecure endpoints, and API URL parameters.</p>
<p>REST APIs have similar vulnerabilities as web applications; we will present the most common API attacks and vulnerabilities in the following sections, then move on to security tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exposing sensitive data</h1>
                
            
            
                
<p>The first and foremost essential security aspect of testing a REST API (or any application) is to evaluate and determine the categories of data and the need for data protection when they are in transit or in a persisted state. For instance, personal information, credit card information, health records, financial information, business information, and many other such categories of information need protection.</p>
<p>Moreover, data is fundamentally protected through encryption, as exposing sensitive data with no encryption could lead to an attacker stealing sensitive data, which would not just be limited to personal data, credit card numbers, identity theft, and so on.</p>
<p>There are many preventative measures and means of protection sensitive data you can apply according to the classification (of data) and data protection needs. Some of these protection measures are listed here:</p>
<ul>
<li>Classify data and apply controls according to data classification.</li>
<li>Do not store sensitive information unless necessary and discard it as soon as possible. Use tokenization and truncation methods to prevent the exposure of sensitive data.</li>
<li>Encryption is a necessary and crucial protection measure.</li>
<li>Do not implement a cache for sensitive data (or disable caches for sensitive data transactions).</li>
<li>Use salts and adaptive (with a configurable number of iterations) hashing methodologies for passwords.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding authentication and authentication attacks</h1>
                
            
            
                
<p>Authentication is a process to determine the identity of an entity (a process, a machine, or a human user) to either disallow or allow that entity to access underlying application functionalities.</p>
<p>Logon authentication, network authentication, IP authentication, remote authentication, basic authentication, and client certificates are a few authentication types.</p>
<p>Authentication attacks are processes with which hackers attempt to exploit an authentication process and gain unauthorized access. Successfully penetrating an authentication system and gaining unauthorized access will allow a hacker to steal sensitive information and alter, corrupt, or delete valuable data. Imagine a hacker assumes someone's identity; this is identity theft and can lead to personal damage and monetary theft. Worse, if the hacked identity is of a network or server administrator, then the damage may be beyond our imagination.</p>
<p>Authentication-type attacks include bypass attacks, brute-force attacks (for passwords), verify impersonation, and reflection attacks.</p>
<p>While we are discussing authentication attacks, it may be good to recollect an example implementation of basic authentication <a href="c44b2a11-65db-459f-a799-1692dd3930e8.xhtml">Chapter 4</a>, <em>Advanced RESTful API Patterns</em>. The investor service has some necessary security measure such as basic authentication, authorization with a default key, and also authorization with credentials to restrict API access only to genuine users. We also touched upon how to test and validate those security measures with Postman.</p>
<p>The following screenshot depicts one such scenario (Authorization with a default key) and how we validate access using a default security key:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d96067ed-c4e1-46a8-862e-be25b2e07cf1.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding authorization and OAuth2 schemes</h1>
                
            
            
                
<p>As we now understand, proving a correct identity is authentication, and allowing a specific action by authenticated users is authorization. In this section, we will present a brief about OAuth—an industry-standard protocol for authorization – along with a few authorization schemes. When we mention the OAuth IETF OAuth Working Group (<a href="https://tools.ietf.org/wg/oauth/">https://tools.ietf.org/wg/oauth/</a>) in this section, it's OAuth 2.0, which focuses on client-developer simplicity (a RESTful principle) while providing specific authorization flows for various application use cases such as desktop applications, web applications, mobile phones, and even IoT-enabled living room devices.</p>
<p class="chapter-content">Before we move on to OAuth 2.0 schemes, let's understand why you would choose OAuth-based authorization over traditional cookie-based authorization with the following list:</p>
<ul>
<li>Cookie-based authorization is mostly stateful, that is, the server has to keep a record of active user sessions. To manage active sessions, the server would need multiple database calls to maintain the state. Also, a few other server-side overheads make it difficult to decouple the authorization process from the application server (to be stateless).</li>
<li>Cookie-based authentication and authorization involve domains, as applications may interact with multiple domains, and so the underlying server needs a few additional configurations, resulting in maintenance and security overheads.</li>
<li>Integration of third-party clients such as Google+ and Facebook. Authorization for the application with cookie-based authorization is not a feasible solution in many cases.</li>
<li>Cookie-based authorization is considered a maintenance nightmare (in some cases, such as native mobile apps) and so is not a preferred choice for many applications, especially when relying on mobile-based authentication.</li>
</ul>
<p>OAuth addresses these concerns by allowing arbitrary clients (for example, a first-party iOS application or a third-party web application) to access user's (resource owner's) resources on resource servers via authorization servers with secure, reliable, and effective methods:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ec89ac69-cd08-49ff-9b65-4e2c78a149ea.png" style="font-size: 1em;width:38.92em;height:24.25em;"/></p>
<p>The preceding diagram depicts OAuth authorization stakeholders and their roles.</p>
<p>Now, let's look at a few OAuth 2.0-based authorization schemes and the situations or business cases you would choose those specific schemes for, with the following table:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 96px">
<td style="height: 96px">
<p><strong>Schemes / Flow</strong></p>
</td>
<td style="height: 96px">
<p><strong>Client type</strong></p>
</td>
<td style="height: 96px">
<p><strong>Brief description</strong></p>
</td>
</tr>
<tr style="height: 106.688px">
<td style="height: 106.688px">
<p>Implicit</p>
</td>
<td style="height: 106.688px">
<p><strong>Single-page application</strong> (<strong>SPA</strong>) such as Google Fonts.</p>
</td>
<td style="height: 106.688px">
<p>Application requests access tokens from the gateway and the user grants permission</p>
</td>
</tr>
<tr style="height: 192px">
<td style="height: 192px">
<p>Client-credentials</p>
</td>
<td style="height: 192px">
<p>Machine-to-machine non-interactive programs such as services, daemons, and so on</p>
</td>
<td style="height: 192px">
<p>The application passes the client credentials and gets the access token from the gateway server</p>
</td>
</tr>
<tr style="height: 160px">
<td style="height: 160px">
<p>Authorization code</p>
</td>
<td style="height: 160px">
<p>Less trusted apps (third-party apps requesting access to your application)</p>
</td>
<td style="height: 160px">
<p>The application sends a temporary authorization code it receives from the gateway and gets it validated (by the same gateway)</p>
</td>
</tr>
<tr style="height: 160px">
<td style="height: 160px">
<p>Resource owner password credentials</p>
</td>
<td style="height: 160px">
<p>Highly trusted apps (first-party apps)</p>
</td>
<td style="height: 160px">
<p>The client will ask the user for their authorization credentials (usually a username and password), then the client sends a few parameters (<kbd>grant_type</kbd>, <kbd>client_id</kbd>, <kbd>client_secret</kbd>) to the authorization server</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As part of this chapter, we have provided OAuth 2.0 example code that implements the <strong>Resource Owner</strong> password credentials flow and is available on GitHub for anyone to download and execute.</p>
<p>The following diagram depicts the typical sequence of a resource owner password credential OAuth scheme, before we move to the section that explains how to run that example code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/af08c287-fef1-4dfd-850a-f9aeeb3d5aa4.png" style="width:50.75em;height:26.25em;"/></p>
<p>The following steps and a few screenshots of the Postman tool will be useful if you want to run and test that example code on your system:</p>
<ol>
<li>Download the code from GitHub (you may want to refer to the <em>Technical requirement</em> section <a href="bdb7c23e-8c80-4a89-af31-e40d1b4c1d36.xhtml">Chapter 3</a>, <em>Essential RESTful API Patterns</em>).</li>
</ol>
<ol start="2">
<li>Open the Terminal and <kbd>cd</kbd> to <kbd>downloaded_loc/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices\Chapter06\oauth2-sample</kbd>.</li>
<li>Run <kbd>mvn clean install</kbd> and wait for the <kbd>BUILD SUCCESS</kbd> message.</li>
<li>Run the application by running the <kbd>java -jar target\ oauth2-sample-0.0.1-SNAPSHOT.jar</kbd> command.</li>
<li>Open the local Postman tool and test the URLs (in the <kbd>Chapter06</kbd> folder of Postman collections).</li>
<li>you will see the following screenshots when you run the different scenarios.</li>
<li>Try error conditions and other scenarios as well (by providing incorrect credentials, user credentials instead of admin credential, and so on).</li>
<li>Run the sample with the <kbd>java -jar</kbd> command:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e0f85e6-0756-4eb2-ba5e-273f31769792.png"/></p>
<ol start="9">
<li>Wait for the local server to start and be ready to accept requests:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6eacd0e4-1cfd-49eb-8b0b-555ed7190353.png"/></p>
<ol start="10">
<li>Open the Postman tool, run the collections in the <kbd>Chapter06</kbd> folder, and observe the client credentials (required for the Authorization server):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f6c06887-3630-436f-929a-16db396bf8b2.png"/></p>
<ol start="11">
<li>Now enter user credentials for the Authorization server to provide the necessary token:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/873d65ba-5ad2-401b-933d-13b96175b8f4.png"/></p>
<ol start="12">
<li>Get the access-token from the Authorization server so that we can use it to access the necessary resources in the next step:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/145b19ac-494c-4183-84d8-b1921d3173fb.png"/></p>
<ol start="13">
<li>Use the access token that we got in the last step and access the admin (resource) API. Notice the response body:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/927e0519-6a19-438a-813d-b78748f0fb87.png"/></p>
<ol start="14">
<li>Repeat the same steps for user resources with the necessary user credentials (notice the user name in the input):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/70aa2a4c-6608-450b-bc80-17c61193a6dc.png"/></p>
<p>So, you can execute different scenarios (not provided as part of this chapter) such as error messages and different HTTP error codes (<kbd>403</kbd>, <kbd>302</kbd>, and so on) with the sample code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-site scripting</h1>
                
            
            
                
<p>A <strong>Cross-site scripting</strong> (<strong>XSS</strong>) attack is the process of injecting malicious code as part of the input to web services, usually through a browser. Once injected, the malicious script can access any cookies, session tokens, and sensitive information retained by the browser, and can even masquerade as the content of the rendered pages. XSS can be categorized into server-side XSS and client-side XSS.</p>
<p>Traditionally, XSS is one of three types:</p>
<ul>
<li>Reflected XSS</li>
<li>Stored XSS</li>
<li>DOM XSS</li>
</ul>
<p>An exciting read about stored XSS on the word-press REST API defect can be found here: <a href="https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/">https://threatpost.com/wordpress-rest-api-bug-could-be-used-in-stored-xss-attacks/124294/</a> and here: <a href="https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/">https://threatpost.com/wordpress-silently-fixed-privilege-escalation-vulnerability-in-4-72-update/123533/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reflected XSS</h1>
                
            
            
                
<p>Successful reflected cross-site scripting happens when an application allows an attacker to inject browser-executable code (such as JavaScript, Applets, Action Scripts, Flash) within a single HTTP response. You may be aware the injected code is non-persistent and impacts the users only when they open the maliciously crafted link or URL or third-party web page that renders the affected response.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Stored XSS</h1>
                
            
            
                
<p>Stored XSS, also known as persistent XSS, often considered harmful and high risk, occurs when a malicious script is injected into a vulnerable application as input and is viewed by another user or an administrator at a later time.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">DOM XSS</h1>
                
            
            
                
<p>The third type (developed by Amit Klein and available since 2005), DOM XSS, occurs when client-side code uses insecure references to DOM objects that are not entirely controlled by server-provided pages. Generally, but not limited to, APIs that dynamically inject attacker-controllable data to a page and JavaScript frameworks. Single-page applications are vulnerable to DOM XSS.</p>
<p>XSS protection needs to filter malicious content from user input and also needs encoding (escape).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-site request forgery</h1>
                
            
            
                
<p><strong>Cross-site request forgery</strong> (<strong>CSRF</strong>), Sea Surf, or XSRF, as it's known, is a one-click attack vulnerability that web applications exposes the possibility of the end user being forced (by forged links, emails, and HTML pages) to execute unwanted actions on a currently authenticated session.</p>
<p>The synchronize token pattern, cookie-to-header token, double submit cookie, and client-side safeguards are common CSRF prevention methodologies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Denial-of-service attack</h1>
                
            
            
                
<p>A <strong>denial-of-service</strong> (<strong>DoS</strong>) attack is intended to make the targeted machine reach its maximum load (capacity to serve requests) quickly by sending numerous false requests so the target system denies further genuine requests.</p>
<p>Flood attacks and buffer overflow attacks are two categories of DoS. With flood attacks, the attacker saturates the target server by generating enormous traffic to the server, causing the target server to end up in DoS.</p>
<p>On the other hand, a buffer overflow attack is intended to target a machine and make that machine consume all available memory or hard disk space, or cause high usage of the CPU. This result in various consequences, such as the system becoming slow to respond or sluggish in its behavior, and there may even be a situation in which the targeted system will crash, creating potentially catastrophic results.  </p>
<p>Please note that, generally, DoS attacks happen on networks where the malicious user (attacker) has more available bandwidth than the target server. Smurf attacks, ping floods, and ping of death attacks are some actual DoS attacks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Distributed denial of service</h1>
                
            
            
                
<p>DoS attacks on distribution systems are known as <strong>distributed denial of service</strong> (<strong>DDoS</strong>) attacks. DDoS attacks achieve success by employing multiple compromised computer systems, including network resources such as IoT devices, as sources of attack traffic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Injection attacks</h1>
                
            
            
                
<p>One of the most harmful and dangerous attacks is an injection attack. The attacker supplies untrusted input to the application, which gets executed/processed as a part of a command or query, thus resulting in the partial or complete discourse of the application behavior and leading to consequences such as data theft, data loss, loss of data integrity, and DoS. It can even lead to full-system compromise.</p>
<p>The following table captures a few common injection attack types, brief descriptions for each, and their potential impact:</p>
<table border="1" style="border-collapse: collapse;width: 725px;height: 1286px">
<tbody>
<tr>
<td style="width: 140px">
<p><strong>Type of Injection</strong></p>
</td>
<td style="width: 292px">
<p><strong>A brief description</strong></p>
</td>
<td style="width: 292px">
<p><strong>Potential impacts</strong></p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>Code injection/OS command injection</p>
</td>
<td style="width: 292px">
<p>Execute operating system commands with application code</p>
</td>
<td style="width: 283px">
<p>Gains higher privileges with higher privilege escalation vulnerabilities and lead to full-system compromise</p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>CRLF injection</p>
</td>
<td style="width: 292px">
<p>Injects an EOL/carriage return character in an input sequence</p>
</td>
<td style="width: 283px">
<p>Results in splitting the HTTP header to facilitate arbitrary content injection in the response body, including XSS</p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>Email (Mail command/SMTP) injection</p>
</td>
<td style="width: 292px">
<p>Injects IMAP/SMTP statements to a mail server</p>
</td>
<td style="width: 283px">
<p>Personal information disclosure and relay of SPAM emails</p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>Host header injection</p>
</td>
<td style="width: 292px">
<p>Abuses the trust of the HTTP Host Header by dynamically generating headers based on user input</p>
</td>
<td style="width: 283px">
<p>Cache poisoning—manipulates the caching system and serves malicious pages</p>
<p>Password reset poisoning—exploits with password reset email and delivers malicious content directly to the target</p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>LDAP injection</p>
</td>
<td style="width: 292px">
<p>Injects <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>) statements and executes them</p>
</td>
<td style="width: 283px">
<p>Modifies contents of LDAP tree and grants illegitimate permissions, privilege escalations, and bypass authentication</p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>SQL injection</p>
</td>
<td style="width: 292px">
<p>Injects fabricated SQL commands to exercise database read or modify data</p>
</td>
<td style="width: 283px">
<p>Leads to data loss, data theft, data integrity loss, DoS, and can even result in full system compromise due to advanced variations of SQL injections</p>
</td>
</tr>
<tr>
<td style="width: 140px">
<p>XPath injection</p>
</td>
<td style="width: 292px">
<p>Executes fabricated XPath queries by injecting false data into an application</p>
</td>
<td style="width: 283px">
<p>Results in information disclosure and bypass authentication</p>
</td>
</tr>
</tbody>
</table>
<div><h1 class="header-title">Insecure direct object references</h1>
                
            
            
                
<p><strong>Insecure direct object references</strong> (<strong>IDOR</strong>) are equally as harmful as the other top API vulnerabilities; they occur when an application exposes direct access to internal objects based on user inputs such as ID and filename.</p>
<p>Let's look at a quick example of IDOR with the following diagram. In it, Bob is getting his file having ID 1001 from the app does make sense, but what about he is getting Alice's document with ID <strong>1003</strong>?</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b802c14b-e9af-4981-8b73-edda25649ccf.png" style="width:40.33em;height:35.08em;"/></p>
<p>A direct object reference is happening, as the developer exposed a reference to an internal implementation object – here, in the preceding example, it is a file (an object reference may be a directory, an image file, a database key, and so on) – with the application.</p>
<p>So, not having a validation mechanism, allowing Bob (the attacker) to manipulate these references to access unauthorized data is called an IDOR vulnerability.</p>
<p>One can test for IDOR vulnerabilities by mapping out all of the endpoints where the user input is a direct reference (as depicted in the example diagram) and used as a reference object. Its always recommended two ore more users to cover direct objects and functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Missing function-level access control</h1>
                
            
            
                
<p>Another aspect of IDOR is missing functional level access rights. The application might have missed implementing function-level access rights, and so anyone with network access will be able to send a request and get a response rather than just the specific user who has privileges. For instance, an admin URL should not be available to a user who does not have admin-level access rights.</p>
<p>APIs with insufficient protection for sensitive request handlers within an application fall into the category of missing functional-level access rights vulnerability, and so allow hackers to penetrate the application without the necessary authorization.</p>
<p>Testing aspects of this vulnerability should focus on two essential scenarios—whether the user can directly browse a resource, and whether the UI accessing the API resources expose an unauthorized resource to that UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Man-in-the-middle attacks</h1>
                
            
            
                
<p>An MITM attack is an attack by a perpetrator who has placed themself in the middle of a network or communication between a genuine user and an application server. They intend to steal, eavesdrop on, impersonate and secretly relay, intercept, or alter communications, including API messages, between two communicating parties, all while it appears as though a normal exchange of information is underway:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6fa3b6d9-a6d1-42c4-95c0-6c8c79383708.png" style="width:30.25em;height:24.50em;"/></p>
<p>The preceding diagram depicts a typical MITM attack, where the eavesdropper impersonates and relays communications/responses to the caller as they come from the server, and they will appear genuine.</p>
<p>An example of an MITM attack could be communication between an API that issues a session token as part of an HTTP header and a perpetrator acting as a man in the middle between the user's browser and the HTTP header (session token). So, it's easy to intercept that session token as it opens up access to the user's account, then the damage can be done depending on that account's privileges.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Common types of MITM attacks and protection measures</h1>
                
            
            
                
<p>There are a few common MITM attacks, as found in the following list, that you need to be aware of, and also a few protection measures against those attacks:</p>
<ul>
<li class="mce-root"><strong>Sniffing</strong>: Sniffing, also known as packet sniffing, in which attackers use widely/freely available packet capture tools by using specific wireless devices to inspect and monitor packets communicated over a network.</li>
<li class="mce-root"><strong>Packet injection</strong>: Injecting malicious packets into data communication streams in such a way that they blend in with valid data streams and appear as part of the original/intended communication.</li>
<li class="mce-root"><strong>SSL stripping</strong>: Altering HTTPS network communication to HTTP on the fly and making the communication insecure is another form of MITM attack (the user may not even realize that they are redirected to unsecured endpoints) and, leaking sensitive information as plain text, which attackers get onto it quickly.</li>
<li class="mce-root"><strong>Email hijacking</strong>: A very common type of MITM attack, in which attackers mimic a trusted site (for example, a bank's website) send an email with instructions to the targeted account and convinces the account holder to follow the instructions in the email, resulting in the catastrophic effect of losing their money/personal information and so on.</li>
<li class="mce-root"><strong>Wi-Fi eavesdropping</strong>: This involves setting up exclusive Wi-Fi access points to lure users to get connected and make them use the network. Once the user is connected to those Wi-Fi access points, attackers will intercept and gain their credentials, credit card information, and much more sensitive information.</li>
<li class="mce-root"><strong>Session hijacking</strong>: Once the user logs in to an application with their credentials, the application will generate a temporary token so that user does not need to provide credentials again to access subsequent pages. However, an attacker can sniff and pick up that session token and use it to gain access to the user's account.</li>
<li class="mce-root"><strong>Protection measures</strong>: Protection against MITM attacks are as follow:
<ul>
<li><strong>Secure/Multipurpose Internet Mail Extensions</strong> (<strong>S/MIME</strong>)</li>
<li><strong>Public key infrastructure</strong> (<strong>PKI</strong>) based authentication certificates</li>
<li>SSL/TLS certificates</li>
<li>System and server configurations</li>
<li><strong>HTTP Strict Transport Security</strong> (<strong>HSTS</strong>)</li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Replay attacks and spoofing</h1>
                
            
            
                
<p>Replay attacks, also known as playback attacks, are network attacks in which valid data transmissions (supposed to be once only) are repeated many times (maliciously) by the attacker who spoofed the valid transaction. While a server is expecting a valid transaction, it will not have any doubts as to whether requests are valid transactions. However, these are a masqueraded request and lead to catastrophic effects for clients:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/9b1355a7-fbcf-4228-970c-0af52e8f450c.png" style="width:29.67em;height:20.00em;"/></p>
<p>The previous diagram depicts a replay attack example where the legitimate user sends a valid request, but the attacker spoofs it and resends/replays it to the APIs.</p>
<p>As RESTful APIs are stateless, the chances of getting those APIs into replay attacks are high (they're an easy target). So, it is evident that API designers/developers need to have countermeasures in their APIs for all replay attacks. Protection measures include a one-time password with session identifiers, <strong>time-to-live</strong> (<strong>TTL</strong>) measures, MAC implementation on the client side, and including timestamps in requests, along with secure protocol such as Kerberos protocol prevention, secure routing, and the <strong>challenge-handshake authentication protocol</strong> (<strong>CHAP</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Causes of vulnerabilities</h1>
                
            
            
                
<p>As we have looked at a few of the vulnerabilities in the previous section, let's also familiarize ourselves with a few common concerns and issues that cause APIs to be vulnerable to various attacks in the following paragraphs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">
API design and development flaws</h1>
                
            
            
                
<p>Missing or not adhering to API security principles and best practices may lead to defects that expose business-critical data. Another aspect of design and development is to keep APIs as simple as possible, as complexity may lead to less coverage and vulnerability. Poor user input validation, SQL injection loopholes, and buffer overflows are a few other causes.</p>
<p class="mce-root"/>
<p><a href="edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml">Chapter 2</a><em>, Design Strategy, Guidelines, and Best Practices</em>, discussed various aspects of design strategies and RESTful API design practices. Understanding and implementing those design principles and practices in APIs helps reduce design and development flaws.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Poor system configuration</h1>
                
            
            
                
<p>Even the best design and development is not necessarily enough to safeguard a system if the system configurations (where the APIs are) do not adhere to security compliance. This will also lead to loopholes and attackers stealing information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Human error</h1>
                
            
            
                
<p>Non-adherence to organization security compliance and inadequate knowledge of security measures such as document-shredding policies, secure coding practices, strong passwords, maintaining the confidentiality of passwords, periodical resetting passwords, and preventing access to unknown/unsecured sites creates loopholes in the API that can lead to security breaches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Internal and external connectivity</h1>
                
            
            
                
<p>As APIs are part of unsecured internal and external networks, the connectivity of APIs in an unsecured network is another major cause of vulnerability. Also, APIs' exposure to large and unique channels, such as mobile networks, poor risk management, and lenient authorization practices within a network are a few examples from this category of vulnerability.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Security tests</h1>
                
            
            
                
<p>Security tests ensure APIs are secure from external threats and protected from the vulnerabilities that we have discussed in earlier sections. The primary focus of API security tests and security testers is to find the vulnerabilities of the API they intend to test by running penetration tests, fuzz tests, validations, sensitive data exposure determination, and so on.</p>
<p>Security functional testing and security vulnerability testing are two categories of security tests. A functional test executes manual tests and manually checks for the presence of security mechanisms within API's implementation. Security vulnerability tests execute automated test cases that may expose vulnerabilities.</p>
<p class="mce-root"/>
<p>The ultimate goal of the tester should be to understand the system behavior by studying error messages and expose any security vulnerability such as gaining unauthorized access, IDOR, MITM, and replay attacks.</p>
<p>You can fulfil security test goals by running penetration tests and fuzz tests along with various manual tests.</p>
<p>This section discusses penetration tests and fuzz tests in detail and also discusses the tools/frameworks that provide out-of-the-box support for security tests so that API testers can make use of tools to get security assurance for underlying APIs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Penetration tests or pen tests</h1>
                
            
            
                
<p>One of the imperatives in API testing is penetration tests, also known as pen tests. Pen tests are the process of simulating cyber attack against a the system or API to expose/determine exploitable vulnerabilities such as intra-network loopholes, XSS attacks, SQL injections, and code-injection attacks.</p>
<p>Pen tests asses the threat vector from an external standpoint, such as supported functions, available resources, and the API's internal components as well.</p>
<p>Let's discuss more details about pen testing—its stages, testing methods, frameworks that support pen testing, and a few criteria for selecting the best penetration tool in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Importance of penetration tests</h1>
                
            
            
                
<p>Before we delve into the details, the following rationalizations will help us understand why pen tests are so crucial in API testing:</p>
<ul>
<li>No compromise to data privacy</li>
<li>Guaranteed and secured financial transactions and financial data over the network</li>
<li>Discover security vulnerabilities and loopholes in APIs and in underlying systems</li>
<li>Simulate, forecast, understand, and assess the impacts of attacks</li>
<li>Make APIs fully information security compliant</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Pen testing lifecycle</h1>
                
            
            
                
<p>Now that we have a good understanding of vulnerability causes from the earlier section, let's look at the five stages of pen tests in this section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/184aeeb9-4c31-43a2-b458-63f044b39990.png" style="width:40.83em;height:28.83em;"/></p>
<p>The preceding diagram depicts the life cycle of pen tests, involving five phases of activities such as Preparation, <strong>Scanning</strong>, <strong>Gaining Access</strong> and <strong>Maintaining Access</strong>, and reporting.</p>
<p>Let's look at each phase in more detail in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparation, planning, and reconnaissance</h1>
                
            
            
                
<p>The first phase of the life cycle involves the following two parts:</p>
<ul>
<li>Scope, scope definitions, defining the goals of the tests to be carried out, and defining the testing methods and systems to be addressed</li>
<li>Gathering intelligence such as the domain and endpoints, and understanding how the target API works, along with its exposure to vulnerabilities</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Scanning</h1>
                
            
            
                
<p>Understanding the target application's response to various intrusion attempts with static and dynamic analysis is the focus of the <strong>Scanning</strong> phase.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gaining access</h1>
                
            
            
                
<p>This involves attempting to uncover API vulnerabilities with application attacks such as XSS, SQL injections, code injections, and backdoors. Once those vulnerabilities are uncovered, exploiting them with privilege escalations, data stealing methods, and traffic interceptions are part of the <strong>Gaining Access</strong> scope, as well as assessing the damage that API vulnerability could cause.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maintaining access</h1>
                
            
            
                
<p>An illicit, long-term intruder presence in a network may cause irreversible damage to the system, as they may be present in the system for a long time, which facilitates highly sensitive data mining (especially on government, military, and financial networks) in steady, well-researched, and meticulously planned attacks.</p>
<p>Assessing the long-term presence abilities, and the chances of them gaining in-depth access to systems/APIs is the primary intention of this <strong>Maintaining Access</strong> phase.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Analysis</h1>
                
            
            
                
<p>The final phase of the life cycle focuses on compiling and presenting the results of penetration tests as a report. These reports generally contain a specific vulnerability that was exploited as part of pen tests, details of compromised/accessed sensitive data as part of the pen test exercise, and, most importantly, the duration of the time that you were able to remain in the system undetected. These results and reports will act as a feed/input security configurations across the organization to prevent any future attacks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pen testing types for API testing</h1>
                
            
            
                
<p>We discussed the importance of penetration tests in security testing, and APIs are no exception; they all need to go through these penetration tests and ensure that underlying APIs are not exposing any vulnerabilities. Please note that there are three categories of pen tests in practice and they are—black-box pen tests, grey-box pen tests, and white-box pen tests.</p>
<p>Black-box and grey-box testing assumes testers have only limited knowledge about the underlying API. We shall briefly cover white-box testing in this section, as it's essential for API security testing, and why it is preferred for API penetration tests in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">White-box penetration testing</h1>
                
            
            
                
<p>White-box testing is also known as <strong>structure-testing</strong>, open-box, clear-box, and glass-box testing. The white-box pen test is a comprehensive testing methodology, as you get a whole range of information about the schema, source code, models, and so on, before starting the testing. White-box tests are intended to scrutinize the code and catch any design and development errors. They are simulations of internal security attacks.</p>
<p>API pen tests rely on white-box testing for the following reasons:</p>
<ul>
<li>The tests run on all of the independent paths of a module</li>
<li>The tests confirm and verify all logical decisions (<kbd>true</kbd>/<kbd>false</kbd>) inside the code</li>
<li>The tests execute syntax checking, and so find typographical errors that are critical to finding code injections and SQL injection attacks</li>
<li>The tests find design errors caused by a mismatch of the logical flow of the program and the actual execution (design for intent)</li>
</ul>
<p>There are plenty of open source tools available and commercial versions that can scan code, check for malicious code, find security loopholes using data encryption techniques, and even find hardcoded username and passwords. A few of the tools are listed in the following table (both commercial and open source versions):</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Tool</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Type</strong></p>
</td>
<td class="CDPAlignCenter CDPAlign">
<p><strong>Providers</strong></p>
</td>
</tr>
<tr>
<td>
<p>Nmap</p>
</td>
<td>
<p>OpenSSL</p>
</td>
<td>
<p>Pure Hacking</p>
</td>
</tr>
<tr>
<td>
<p>Nessus</p>
</td>
<td>
<p>Cain and Abel</p>
</td>
<td>
<p>Torrid Networks</p>
</td>
</tr>
<tr>
<td>
<p>Metasploit</p>
</td>
<td>
<p>THC Hydra</p>
</td>
<td>
<p>SecPoint</p>
</td>
</tr>
<tr>
<td>
<p>Wireshark</p>
</td>
<td>
<p>w3af</p>
</td>
<td>
<p>Veracode</p>
</td>
</tr>
</tbody>
</table>
<p>Let's summarize this section by stating that pen tests for APIs should expose API vulnerabilities before real attackers find them, and move on to fuzz tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fuzz tests</h1>
                
            
            
                
<p>Fuzz testing, also known as fuzzing, is one of the most widely used testing practices in the quality assurance phase. It involves massive amounts of random data (noise or fuzz) as input to the target system with the intention of targeting APIs to exhibit buffer overflow or any other unwanted behaviors, or even to provoke the system to crash.</p>
<p>Barton Miller at the University of Wisconsin introduced fuzz testing (in 1988, as part of his <em>Operating System Utility Program Reliability – The Fuzz Generator project</em>) to reveal any security loopholes and coding errors in APIs, software, networks, and operating systems.</p>
<p>The primary purpose of API fuzzing is not to test the correct functionality of the API as such, but to explore and test the undefined region with the help of fuzzed data:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/16a6fa71-6dde-4f41-85d0-db716b7b93b5.png" style="width:26.67em;height:16.50em;"/></p>
<p>As shown in the preceding diagram, the scope of fuzzing is to expose any unexpected behaviors of the underlying API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The life cycle of fuzz tests</h1>
                
            
            
                
<p>The various stages in a typical life cycle of an API fuzz test start with identifying the target APIs and defining the inputs for the test, and end with the generation of logs showing vulnerabilities detected in the API. The following diagram depicts each phase of the fuzz testing lifecycle:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7f7e8b8b-044b-4bc0-9410-c5c4156463dc.png" style="width:35.08em;height:36.08em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fuzz testing strategy</h1>
                
            
            
                
<p>Fuzz testing strategy varies depending on the attack vectors, fuzzing targets, fuzzing methods, and so forth. For an API, let's focus on fuzzing targets. Fuzz testing has two primary classifications—mutation based and generation based. We will look at the details of both classifications in the following section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mutation-based fuzz tests</h1>
                
            
            
                
<p>Mutation or dumb fuzz tests are a simple approach, wherein we create new test data by altering existing data samples. Sample data generation starts with valid samples of protocols and altering the supplied inputs, to the extent of altering every bit of the inputs. The following diagrams illustrate two ways of going about mutation:</p>
<ol>
<li>Bit flipping, where inputs are flipped in a sequence or in a random manner:</li>
</ol>
<div><img src="img/6a659ec3-f090-401b-8bdd-2afa8a1b3902.png" style="width:41.83em;height:8.83em;"/></div>
<ol start="2">
<li> Append a random string, where the end of the input has random strings appended:</li>
</ol>
<div><img src="img/f0da69fb-586b-44bd-a833-0aa84fa420e4.png" style="width:41.17em;height:8.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Generation-based fuzz tests</h1>
                
            
            
                
<p>Generation-based fuzz tests, also known as intelligent fuzzing, are tests based on an understanding of known formats, known protocols, and the generation of inputs from scratch according to the system/API specifications (RFC) and formats (for instance, the format from the API documentation).</p>
<p>Generation fuzz tests are capable of building test data based on the data model. Sometimes, these tests are as simple as injecting random bytes, and sometimes they can be much smarter, knowing good data values and combining them in multiple interesting ways (such as having regular expressions as part of the request body, having hostnames in the header, and changing intended response types to different types).</p>
<p>Before we conclude this section on fuzz-testing strategies, let's get to know another very successful fuzz testing method, known as protocol-based fuzz testing (also known as syntax testing, grammar testing, and robust testing). In protocol-based fuzz testing, the testers have detailed knowledge of the protocol format, and their understanding depends on the given specifications. Here, the specifications are intended as an array of stored specifications within a model-based testing tool, and it is also capable of generating test data. Then, the tool needs to go through all of the specifications and add irregularity to the sequence, data contents, and so on to expose vulnerabilities.</p>
<p>Please note that, as the mutation approach does not require you to understand the protocol, you may feel more comfortable using it compared to the generation-based approach at first glance. However, the generation-based approach is a thorough, better, and recommended process even though it takes more time because it involves several valid input combinations. It does, however, lead to better code coverage and code paths.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advantages and disadvantages of fuzz tests</h1>
                
            
            
                
<p>The following points intend to justify why fuzz tests are popular among the software professional community:</p>
<ul>
<li>They are extremely simple, easy, cost-effective, and quick to set up as they are free of preconceptions about system behavior</li>
<li>Their one-time setup is easy to repeat for regression (automation)</li>
<li>As it is a protocol-aware test, test results lead to finding precise, descriptive, and easy-to-debug errors</li>
<li>They enables you to find bugs that are impossible to find with the human eye in defined testing or approach-based testing</li>
<li>They yields the best results when used in conjunction with black-box testing, beta testing, and other debugging methods</li>
</ul>
<p>While fuzz tests bring many advantages to the table, we also need to be aware of and understand a few disadvantages, which are listed here:</p>
<ul>
<li>Mutation-based fuzz tests can run indefinitely (generate numerous test cases and run indefinitely) and so determining the optimal number of tests, or determining whether time they run for is long enough, is a difficult in some cases</li>
<li>Tests results may report no defects, even after running numerous test cases</li>
<li>Test results may report the same defects for various test cases</li>
<li>It is challenging to find which test case caused the fault</li>
<li>It is difficult to find the vulnerability in the event of a system crash</li>
</ul>
<p>To conclude this section, let's list a few tools that you can take advantage of when running fuzz tests for APIs without much pain.</p>
<p class="mce-root">Open source:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 64px">
<td>
<p><strong>Mutational fuzzing</strong></p>
</td>
<td style="height: 64px;width: 172px">
<p><strong>Fuzzing Frameworks</strong></p>
</td>
<td style="height: 64px;width: 291px">
<p><strong>Domain Specific fuzzing</strong></p>
</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 230px">
<p>American fuzzy lop</p>
</td>
<td style="height: 64px;width: 172px">
<p>Sulley</p>
</td>
<td style="height: 64px;width: 291px">
<p>Microsoft SDL MiniFuzz File Fuzzer</p>
</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 230px">
<p>Radamsa—a flock of fuzzers</p>
</td>
<td style="height: 64px;width: 172px">
<p>Boofuzz</p>
</td>
<td style="height: 64px;width: 291px">
<p>Microsoft SDL Regex Fuzzer</p>
</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 230px">OWASP WebScarab</td>
<td style="height: 64px;width: 172px">
<p>BFuzz</p>
</td>
<td style="height: 64px;width: 291px">
<p>ABNF Fuzzer</p>
</td>
</tr>
<tr style="height: 64px">
<td style="height: 64px;width: 230px">
<p>OWASP WSFuzzer</p>
</td>
<td style="height: 64px;width: 172px">
<p class="CDPAlignCenter CDPAlign">-</p>
</td>
<td style="height: 64px;width: 291px">
<p class="CDPAlignCenter CDPAlign">-</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The preceding table details open source fuzzing tools. The following list provides a few commercial tools you may want to make use of for fuzz tests:</p>
<ul>
<li class="mce-root">Codenomicon's product suite</li>
<li class="mce-root">The Peach Fuzer Platform</li>
<li class="mce-root">Spirent Avalanche NEXT</li>
<li class="mce-root">Beyond Security's beSTORM product</li>
</ul>
<p class="mce-root">And also, here are a few of the latest tools that readers might find exciting to run through their APIs:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Tool</strong></p>
</td>
<td>
<p><strong>Reference/Link</strong></p>
</td>
</tr>
<tr>
<td>
<p>REST-ler</p>
</td>
<td>
<p><a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2018/04/restler.pdf</a></p>
</td>
</tr>
<tr>
<td>
<p>Burp</p>
</td>
<td>
<p><a href="https://portswigger.net/burp">https://portswigger.net/burp</a></p>
</td>
</tr>
<tr>
<td>
<p>Fuzzapi</p>
</td>
<td>
<p><a href="https://github.com/Fuzzapi/fuzzapi">https://github.com/Fuzzapi/fuzzapi</a></p>
</td>
</tr>
<tr>
<td>
<p>Fuzz-rest-api</p>
</td>
<td>
<p><a href="https://github.com/dubzzz/fuzz-rest-api">https://github.com/dubzzz/fuzz-rest-api</a></p>
</td>
</tr>
<tr>
<td>
<p>Big-list-of-naughty-strings</p>
</td>
<td>
<p><a href="https://github.com/minimaxir/big-list-of-naughty-strings/">https://github.com/minimaxir/big-list-of-naughty-strings/</a></p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">Back to API testing</h1>
                
            
            
                
<p>We have taken a detour from API tests and looked at many aspects of security tests in the previous sections. Now, let's get our focus back and redirect our journey to a few more API testing aspects in the rest of the chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API test cases</h1>
                
            
            
                
<p>To begin with, let's say that test cases for APIs need to have a few parameters or placeholders, such as input parameters, expected results, the time taken to receive a response (from the API), parsing input, error handling, and response formats so that test results of an API are ascertained and certified.</p>
<p>Before we move on to a few aspects of test case preparation, let's get a glimpse of the possible types of bug that API tests help us to detect:</p>
<ul>
<li>Mishandled errors or disgraceful error conditions by the API</li>
<li>Any unused flags</li>
<li>Missing or duplicate functionality</li>
<li>Multi-threading issues</li>
<li>Incorrect handling of valid argument values</li>
<li>Validation issues such as schema validations or structure issues</li>
<li>Reliability issues and performance issues (such as timeout and connecting and getting a response time) of the API</li>
<li>API vulnerabilities and any security issues</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Essential aspects of API test cases and test case preparation</h1>
                
            
            
                
<p>The following list covers a few essential aspects of test case preparation for API testing, as the test cases on API testing depend on their outputs:</p>
<ul>
<li>Assert a return value based on different input conditions and a combination of inputs.</li>
<li>Assert the behavior of the API when there is no return value. Check for return codes.</li>
<li>Assert the events and triggers of an API if the underlying/target API creates subsequent events.</li>
<li>Assert not only the API results in case of update data structure but validate the effect on the system that it has updated.</li>
<li>Assert by accessing impacted resources when the API is involved in modifying specific resources.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">API testing challenges</h1>
                
            
            
                
<p>If you are ready with the necessary test cases, is it sufficient to start testing the intended API? No, it is not—there are some more challenges one should be aware of, and we will look at a few common challenges you may face and also how to address those challenges when you want to start API testing in the following sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Initial setup</h1>
                
            
            
                
<p>The testing infrastructure and its stability/availability, and uptime. Starting and practising API testing in the design phase and checking the APIs for 100% uptime is key.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API schema updates for testing</h1>
                
            
            
                
<p>Request and response schema or formats are the lifelines of the API. However, frequent changes to schemas are inevitable (especially during the development phase) and so test cases for schema configuration too. Managing tests in alpha and beta environments may reduce the number of issues (due to schema updates) by up to 90%.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing parameter combinations</h1>
                
            
            
                
<p>Adding additional parameters to the API increases the number of combinations exponentially, while it is necessary to test every possible combination of parameter requests to find issues specific to configurations. API releases and ensuring potential API release candidates are available for testing helps address these challenges effectively.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">API call sequence</h1>
                
            
            
                
<p>Calling APIs in a specific sequence to attain the desired result is inevitable in many cases, and for those scenarios, test cases also need to have the proper sequence implemented. However, this is challenging in major APIs, and becomes even more challenging when cases of multi threaded applications are involved. Along with enforcing release candidates, a visual representation of a sequence of API calls or a flow chart for the sequence of API calls will help not only the testing phase but also the development team as well (as part of development phase).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Validating parameters</h1>
                
            
            
                
<p>Checking numbers and the number of digits in a phone number, length restrictions, data type validations, data-ranges modifications, and such validation criteria or tests are daunting tasks for the testing team especially with larger APIs that have a vast number of parameters to validate. Implementing synthetic and <strong>application performance monitoring</strong> (<strong>APM</strong>) tools will help to ensure catching any problems that arise due to parameter validations. Validating parameter is one of the crucial aspects of security testing as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tracking system integration</h1>
                
            
            
                
<p>A data tracking system helps to find the correct responses to the calls. However, it is a challenging task for the team to ensure that the API testing system is working correctly with the data tracking system and calls that the API is making are getting the right response. you can address this challenge by implementing and including load tests with <strong>continuous delivery </strong>(<strong>CD</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API testing best practices</h1>
                
            
            
                
<p>The following section lists a few API testing best practices you should know about. To start with, the following are test case best practices:</p>
<ul>
<li>Group API test cases by test category (unit tests, functional tests, security tests, and so on)</li>
<li>Ensure test cases indicate the declarations of involved (called) APIs on top of each test case</li>
<li>Ensure parameter selections are mentioned explicitly in the test case itself</li>
<li>Executes test cases independently, that is, each test case is a self-contained and an independent entity</li>
<li>prioritize API calls, which helps to simplify API testing</li>
<li>Keep test cases free from <em>test chaining</em> (reusing test data objects created by other tests)</li>
<li>Test cases deal with one-time call functions such as delete, close window, asynchronous calls, and so need special attention to avoid undesirable executions</li>
<li>Ensure API call sequences are well planned and also have clear execution plans</li>
<li>Create test cases for every possible known input combination of the API, as this leads to better test coverage of the underlying APIs</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">API testing tools</h1>
                
            
            
                
<p>It may be a good idea to complete our API testing journey with some information about a few common API testing tools. The following screenshot of API testing tools gives brief details on each tool, their ease of use, and supporting platforms and may come in handy:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/facc50dc-0ff7-49f2-83d6-c1c9918f030d.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">CQRS</h1>
                
            
            
                
<p class="mce-root"><strong>Command Query Responsibility Segregation</strong> (<strong>CQRS</strong>) is an architectural pattern, proposed by Greg Young. CQRS suggests the segregation of the reading operations (queries) and writing operations (commands) of a system to separate subsystems, as reads are eventually consistent and retrieved from de-normalized views and commands are usually asynchronous and stored in transactional storage, and reads are eventually consistent and retrieved from deformalized views.</p>
<p>So, segregating read and write operations with separate interfaces or subsystems doesn't only help to maximize the performance of APIs, it also helps in security and scalability aspects, as well as managing merge conflicts at the domain level, due to update commands, leading to more flexibility.</p>
<p>Before we delve further into CQRS, let's look at traditional patterns for <strong>Data Access</strong> in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/81fca498-5e41-44d2-8df9-550481f1e125.png"/></p>
<p>Traditional Data Source and DTO models (CRUD)</p>
<p>As depicted, the read and write operations of data (source) are from one data source or data storage, with updates or writes and Queries (read).</p>
<p>There are a few disadvantages with the CRUD approach, as listed here:</p>
<ul>
<li>The data that is being read and the data being updated may have different representations and managing that updated data in sync to serve both reads and writes is an overhead to the underlying system.</li>
<li>Performance is affected by the high load on the data store and data access layers and depends on queries and the complexities involved in retrieving information. High volume transactions also increase the chances of data contention when records are locked in a data store and accessed by multiple domains.</li>
<li>Managing security and roles for data access might be challenging as well.</li>
</ul>
<p>The CQRS pattern addresses those disadvantages, as its implementation segregates queries (reads) from the update (<strong>Commands</strong>) operations with separate interfaces:  </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/31719e3c-885f-4207-82c7-19808c1a6c5c.png" style="width:27.50em;height:24.67em;"/></p>
<p>It also check the following instances:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7121565c-7b6f-47f6-b195-bfbb8558df8d.png" style="width:26.92em;height:22.83em;"/></p>
<p>The preceding two diagrams depict two variations of CQRS implementation. The first one represents a simplified design and implementation of CQRS with read and write models within a single data source. Note that it is not a single data model (like CRUD), but read and write as a separate models. The downside of this version of CQRS implementation is that, unlike CRUD, the automatic code generation with scaffolding mechanism is not possible for CQRS based systems.</p>
<p>The diagram with a separate data source depicts another CQRS design, where we have two different physical data stores one for write or update operations (commands) and then another one exclusively for queries. Separate data store implementation maximizes performance, scalability, and security.</p>
<p>While CQRS brings higher performance, scalability, and security, it also brings increased complexity and maintenance overheads to manage consistency due to multiple data stores and also one would need to understand from the following list when to choose CQRS for your implementations:</p>
<ul>
<li>CQRS is suitable for systems in which number of writing (updates) and reading (queries) differ significantly</li>
<li>It's ideal for systems in which reads and writes need individual scaling</li>
<li>It's suitable for systems where the consistency of data is not critical (addressed eventual consistency) but the availability</li>
<li>It 's ideal for systems that prefer fire-and-forget events (asynchronous events)</li>
<li>It's suitable for the systems that have a data store access layer based on event sources</li>
<li>It's ideal for systems that implement domain-driven designs and isolate the business or domain complexity, and having CRUD would make more complex</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We are at the end of our API testing journey and, reflecting on of this journey, we have learned a few basics of API testing types and API testing approaches, starting from unit test cases, through to API validation tests, functional tests, load tests, and end-to-end tests, along with API monitoring. We have also touched on a few important API errors aspects such as execution errors, resource leaks, and error detection methodologies.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>While we were looking at on API testing, we got to know a few critical security vulnerabilities in the REST API world, including sensitive data exposure, authentication attacks, XSS attacks, see-surf (CSRF), DoS attacks, and injection attacks. We did not just focus on attacks, as this chapter introduced the causes of those attacks (vulnerabilities), as well as methods and tools for detecting those API vulnerabilities by means of penetration and fuzz tests.</p>
<p>We continued on our API testing journey after understanding API security measures—we got to know a few of the basics of API test case creation, API testing challenges, and API testing best practices, and concluded our journey with a snapshot of API testing tools.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p><em>Mastering Modern Web Penetration Testing</em> (<a href="https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing">https://www.packtpub.com/networking-and-servers/mastering-modern-web-penetration-testing</a>), Prakhar Prasad, Packt Publishing.</p>


            

            
        
    </body></html>