- en: '*Chapter 1*: The Need for and Applications of Metaprogramming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Metaprogramming with Python* is a practical guide to learning metaprogramming
    in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: In today’s programming world, Python is considered one of the easiest languages
    to learn and use to develop useful applications. Understanding the programming
    concepts and applying them is easier in Python compared to any other programming
    language. A Python program can be written simply by adding existing libraries
    and making use of their inbuilt methods. At the same time, the language also has
    many powerful features that can help in developing robust libraries and applications.
  prefs: []
  type: TYPE_NORMAL
- en: This book covers the need for one of the most advanced features in Python, called
    metaprogramming, along with insights into its practical applications. Understanding
    the concepts of metaprogramming helps in tapping into the advanced features of
    Python 3 and knowing where to apply them to make Python code more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the regular Python-based application development that follows object-oriented
    programming, metaprogramming covers certain advanced concepts of Python that deal
    with manipulating the programmable objects of Python, such as its classes, methods,
    functions, and variables. Throughout this book, we will look at applications and
    examples that help in understanding these concepts in a user-friendly manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will provide an introduction to metaprogramming and the
    need to perform metaprogramming using Python 3\. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why we need metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the applications of metaprogramming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a high-level understanding of metaprogramming
    in Python 3, the need for using it, and know of a few practical examples where
    it can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter are available on GitHub repository for this
    chapter at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: An overview of metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Metaprogramming** is a concept widely heard of in other programming languages
    such as C++, Java, .NET, and Ruby but not so widely heard of in Python. Python
    is a programming language that is easy to learn for beginners to programming and
    efficient to implement for advanced programmers. Therefore, it has an additional
    advantage in improving efficiency and optimization while developing high-performance
    applications when techniques such as metaprogramming are blended with the process
    of application development.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will deep dive into the concepts of metaprogramming using Python
    3.
  prefs: []
  type: TYPE_NORMAL
- en: The term **meta**, as the name suggests, is a process that references itself
    or its the high-level information. In the context of programming, metaprogramming
    also describes the similar concept of a program referencing itself or a program
    object referencing itself. A program referencing itself or its entity gives data
    on the program or the programming entity that can be used at various levels to
    perform activities, such as transformations or manipulations, in a programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the term **meta**, let’s consider the term *metadata*. As an
    example, let’s look at a Python DataFrame. For those who are not familiar with
    the term DataFrame, we can use the term *table*. The one shown in the following
    screenshot is called *Employee Data*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Employee Data table ](img/B13426_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Employee Data table
  prefs: []
  type: TYPE_NORMAL
- en: This Employee Data table consists of employee information such as the name of
    the employee, employee ID, qualification, experience, salary, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: All of this information are attributes of single or multiple employees, and
    it is the data of employees in an organization. So, what will the metadata be?
    The **m****etadata** is the data of how employee data is stored in the Employee
    Data table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The metadata for the Employee Data table defines how each column and its values
    are stored in the table. For example, in the following screenshot, we can see
    metadata where **Name** is stored as a string with a length of 64 characters,
    while **Salary** is stored as a **Float** with a length of 12 digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Metadata representation for the Employee Data table ](img/B13426_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Metadata representation for the Employee Data table
  prefs: []
  type: TYPE_NORMAL
- en: Accessing, modifying, transforming, and updating the Employee Data table using
    information such as the name or ID of an employee is data manipulation, while
    accessing, modifying, transforming, and updating the data type or size of the
    column name or employee ID or salary, is metadata manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding, let’s look at an example of metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming – a practical introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any programming language that can be used to write code to perform actions consists
    of a basic unit or piece of code that can be written to perform an action. This
    is known as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have two numbers stored in two variables, `a` and `b`, to perform an
    `add` action, you can simply add those two numbers by writing a function, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we execute this code, it can go through different scenarios, depending
    on the input data provided to the `add` function. Let’s take a close look at each
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `add` function with two integers would result in two numbers being
    added together, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `add` function with two strings would result in the concatenation
    of two words, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at running the `add` function with one string and one integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – TypeError ](img/B13426_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – TypeError
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine this error in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The error in the preceding code snippet denotes a `TypeError`, which was caused
    by an attempt to add a `meta` string with an integer of `1`. The question that
    may occur to you is, *can we resolve this error using metaprogramming*?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` function in this example denotes a piece of code or program, similar
    to how the Employee Data table in *Figure 1.1* denotes data. In the same line,
    can we identify the metadata of the `add` function and use it to resolve the `TypeError`
    object returned by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at a practical example of metaprogramming. We will be making
    use of the metadata of the `add` function to understand this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata of the add function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function in any programming language is written to perform a set of operations
    on the input variables; it will return the results as a consequence of the operations
    performed on them. In this section, we will look at a simple example of a function
    that adds two variables. This will help us understand that metaprogramming can
    be applied to functions and manipulate the behavior of the function without modifying
    the algorithm of the function. We will be adding these two variables by writing
    an `add` function. To change the results of the `add` function, we will be manipulating
    the metadata of its two input variables, thus getting different results each time
    a different type of input variable is provided to execute the function. Just like
    we can manipulate what a function should do by writing lines of code to perform
    various operations, we can also manipulate the function itself by programming
    its metadata and setting restrictions on what it should and shouldn’t do. Just
    like a dataset, DataFrame, or table has data and metadata, a program or a function
    in Python 3 also has data and metadata. In this example, we will be manipulating
    the actions that are performed by the `add` function by restricting its behavior
    – not based on the input data provided to the function but on the *type* of input
    data provided to the `add` function instead. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Examining the data and metadata of the add function ](img/B13426_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Examining the data and metadata of the add function
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code helps us identify the metadata for each data item in the
    `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A function call to the preceding function will now return the metadata of the
    `add` function instead of its result. Now, let’s call the `add` method with an
    integer as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can also check the addition of strings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Python 3 allows us to use the metadata of the code to manipulate it so that
    it deviates from its actual behavior. This will also provide customized solutions
    for the problems we are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the `type` function, a method in Python that
    returns the class or data type that any object or variable belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, it is evident that the `a` and `b` variables we passed
    to the `add` function belong to the integer data type, and its result, `c`, is
    an integer too. The `add` function itself is of the `function` class/type.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving type errors using metaprogramming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many variations on how we can resolve the type error from the `add`
    function we saw in the previous section using metaprogramming. We will look at
    this in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario 1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following meta-program handles the error and allows the `add` function
    to add two strings or two integers. It also suggests that the user enters the
    input data with the right data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the function definition of `add`, we have added two conditions – one to check
    if the type of `a` is a string and the type of `b` is an int, or if the type of
    `a` is an int and the type of `b` is a string. We are checking the combination
    of these input variables to handle the type mismatch error and directing the users
    to provide the right data type for input variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the various combinations of input variable data types
    and their corresponding output or results based on the conditions set on the metadata
    of the `add` function, based on **Scenario 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Scenario 1 metadata combinations ](img/B13426_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Scenario 1 metadata combinations
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code executes the `add` function to reinforce the input-output
    combinations explained in *Figure 1.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following meta-program resolves the type mismatch error by converting the
    mismatching data types into string variables and performing a string concatenation.
    It is only logical to concatenate a string and an integer using a `+` operator
    as we cannot perform arithmetic addition on these two different data types. Take
    a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, no matter what input we provide for the `a` and `b` variables, they both
    get converted into string variables and are then concatenated using `+`, whereas
    if both the input variables are integers, they get added using arithmetic addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the various combinations of input variable data types
    and their corresponding output or results based on the conditions set on the metadata
    of the `add` function based on **Scenario 2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Scenario 2 metadata combinations ](img/B13426_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Scenario 2 metadata combinations
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the following code provides the combinations of output values we
    saw in the preceding table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Scenario 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go a step further and restrict the nature of the `add` function itself
    to ensure it only performs arithmetic addition and doesn’t accept any other data
    types or combinations of data types.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code block, we have added another condition to perform a data
    type check on floating-point values, along with data type checks for the string
    and integer input values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function only accepts numeric values as input and will return a message
    directing users to input numbers so that only arithmetic addition is performed.
    Let’s look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the various combinations of input variable data types
    and their corresponding output or results based on the conditions set on the metadata
    of the `add` function based on **Scenario 3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Scenario 3 metadata combinations ](img/B13426_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Scenario 3 metadata combinations
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the following code provides the combination of output values shown
    in *Figure 1.7*, including the addition of floating-point values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: These are some of the approaches that can be applied to perform simple metaprogramming
    on a function. However, these are not the only solutions that solve type errors
    or manipulate a function. There is more than one way or approach to implementing
    solutions using metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding why we need metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Considering what we’ve learned about metaprogramming, we may be wondering the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Is it always mandatory to apply metaprogramming techniques or to manipulate
    the metadata of the code while developing applications using Python 3 or above?*”
  prefs: []
  type: TYPE_NORMAL
- en: This is a common question that can be asked not only while developing applications
    using Python 3 or above, but also when using any programming language that supports
    the techniques of metaprogramming and gives developers the option to apply them
    in the application development process.
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, it is important to understand the flexibility of metaprogramming
    and the techniques that are supported by Python to handle code manipulation, which
    will be covered throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons to apply metaprogramming is to avoid repetition in various
    aspects of the Python-based application development process. We will look at an
    example of this in the *Don’t Repeat Yourself* section.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, introducing concepts such as code generators at the meta level
    can save development and execution time in functional- or domain-level programming.
    Domain-level programming corresponds to writing code for a particular domain,
    such as finance, networking, social media, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The other need is to increase the abstraction of your code at the program metadata
    level rather than at the functional level. **Abstraction** is the concept of information
    hiding in the literal sense or in terms of object-oriented programming. Implementing
    abstraction at the meta-program level would help us decide what information to
    provide to the next level of coding and what not to provide.
  prefs: []
  type: TYPE_NORMAL
- en: For example, developing a function template at the meta-program level would
    hide the function definition at the domain or functional level, as well as limit
    the amount of information that goes to the functional-level code.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming allows us to manipulate programs using metadata at the meta
    level, which helps define how the grammar and semantics of your program should
    be. For example, in the *Resolving type erors using metaprogramming* section,
    we looked at controlling the outcome of the data types of a function by manipulating
    the function’s variables.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Repeat Yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any application development process, thousands of lines of code are written.
    Don’t Repeat Yourself is a principle defined by *Andy Hunt and Dave Thomas* in
    their book *The Pragmatic Programmer*. The principle states that “*Every piece
    of knowledge must have a single, unambiguous, authoritative representation within
    a system.*”
  prefs: []
  type: TYPE_NORMAL
- en: While writing code, there are very high chances of writing multiple functions
    or methods that perform similar kinds of repetitive tasks, and the functions or
    methods, in turn, might be repetitive. This leads to redundancy in application
    development. The greatest disadvantage of redundancy is that when you make any
    modifications at one location, the implementation, modification, or code fixing
    needs to be repeated at multiple locations.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries are developed with classes and methods, including object-oriented
    programming techniques such as abstraction, inheritance, encapsulation, and so
    on, to avoid redundancy and maintain coding standards as much as possible. Even
    then, there are chances of repetitive methods being within a class that can still
    be simplified.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming can help in handling such instances by implementing approaches
    such as dynamic code generation, dynamic function creation, and more. Throughout
    this book, we will be looking at various approaches that help you not to repeat
    yourself while developing applications.
  prefs: []
  type: TYPE_NORMAL
- en: To get a taste of how we can dynamically generate code and avoid repetitions,
    let’s look at a simple example where arithmetic operations are implemented as
    repetitive functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code consists of four basic arithmetic operations that can be
    performed on two numeric variables. We will be declaring and defining four functions
    that add, subtract, multiply, and divide two variables, `a` and `b`, store the
    result in a variable, `c`, and return it while the function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the preceding functions needs to be called separately and variables
    need to be provided as input to execute them individually, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there is only one difference – the arithmetic operator that’s
    used in the function definition. This code can be simplified without implementing
    metaprogramming, just by declaring a new function that takes in an additional
    input variable operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn how to avoid this repetitive function definition and simplify the
    logic. The following code block defines one common function that can be reused
    to perform all four arithmetic operations. Let’s start by importing Python’s inbuilt
    `module` operator, which contains methods that support multiple arithmetic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, we have declared three variables, including the operation
    in the function arithmetic. Let’s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Executing this function using input variables would return a concatenated string,
    `25`, that will serve the purpose of creating the common `arithmetic` function
    to perform multiple operations. We can look at providing various operations as
    input to see how this one common function serves multiple purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this function with different arithmetic operators would resolve the
    need for repetitive function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: This is one approach to resolving code redundancy and avoiding multiple function
    definitions. But what if we do not want to define the function itself until and
    unless it is required?
  prefs: []
  type: TYPE_NORMAL
- en: To answer this question, we can implement dynamic function creation using metaprogramming.
    Dynamic functions are created during the code’s runtime as and when they are required.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are still in the introductory chapter, we will discuss an example
    of dynamic function creation next to get a view of what kind of programming will
    be covered throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating dynamic functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll look at an example of how dynamic functions can be created
    for the same set of arithmetic operations we discussed earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an arithmetic function dynamically, we need to import the library
    types and the `FunctionType` type. `FunctionType` is the type of all user-defined
    functions created by users during the Python-based application development process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'To begin this process, we will create a string variable that is a function
    definition of the arithmetic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create another variable, `functiontemplate`, and compile `''functionstring''`
    into a code object. We will also set the code object to be executed using `''exec''`.
    The `compile` method is used to convert the string in Python into a code object
    that can be further executed using the `exec` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The code object of the function definition arithmetic will be stored in a tuple
    in `functiontemplate` and can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step involves creating a function object using the `functiontemplate`
    code object. This can be done using the `FunctionType` method, which accepts the
    code object and global variables as input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon executing, `dynamicfunction`, it will behave the same way as the `add`
    operation works in the operator module’s `add` method in the arithmetic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to create a function dynamically, we can look at extending
    it further to create multiple functions, each with a different operation and a
    different name, dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we must create a list of operators and a list of function names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Our earlier list of four functions only contained the add, sub, multiply, and
    divide operations.
  prefs: []
  type: TYPE_NORMAL
- en: The earlier `functionname` list contained eight functions. This is the flexibility
    we get while creating dynamic functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For ease of use, let’s also create two input variables, `a` and `b`, to be
    used while executing the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: In the following code, we will be creating a function called `functiongenerator()`
    that implements metaprogramming to dynamically generate as many arithmetic functions
    as we want. This function will take four input parameters – that is, the list’s
    `functionname`, `operator`, `a`, and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Within `functiongenerator()`, the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: A new `functionstring` list is created with a function definition for each arithmetic
    operator provided in the operator list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `functiontemplate` list is created with a code object for each function
    definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `dynamicfunction` list is created with a function object for each code
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `functiondict` dictionary is created with a key-value pair of function
    name-function objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Functiongenerator` returns the generated functions as a dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, `functiongenerator` executes the dynamic functions and prints
    the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executing this function results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Any specific function from the preceding generated functions can be called
    individually and used further, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the complete process of metaprogramming to develop
    these dynamic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Dynamic function generator ](img/B13426_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Dynamic function generator
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about dynamic function generators, let’s look at other applications
    of metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the applications of metaprogramming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaprogramming can be applied to various Python-based application development
    solutions, such as automated code generators, component-based or flow-based application
    development, domain-specific language development, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Any code you develop, be it for a class or a method, internally applies metaprogramming,
    and its use is inevitable in the Python application development process. However,
    applying metaprogramming concepts explicitly is a conscious decision-making process
    and it purely depends on the expected outcome of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In our example of dynamic function creation, we implemented metaprogramming
    to avoid repetitions and also to ensure the abstraction of the code at the meta-level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a scenario where we want to develop a functional flow-based
    application for non-programmers to use. For instance, the application can be a
    domain-specific data transformation tool that works with high levels of abstraction
    and does not provide too much design or development-based information to the end
    users. However, it also helps the end users dynamically create modules that can
    help in their domain-specific problem solving, without the need to write any programs.
    In such cases, metaprogramming comes in handy for the application development
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Levels of programming ](img/B13426_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Levels of programming
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the case studies and applications of metaprogramming in more
    detail throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provide a quick overview of the programming paradigm of
    metaprogramming and looked at an example of solving a type error using metaprogramming
    in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: We learned why there is a need to apply metaprogramming techniques in the Python
    application development process. We also learned about the Don’t Repeat Yourself
    concept by looking at a practical approach that explains an example implementation
    of dynamic function creation using metaprogramming, emphasizing the concepts of
    avoiding repetition and implementing abstraction at the meta level in the code.
    Finally, we provided a high-level overview of the applications of metaprogramming
    that we will look at throughout this book. These skills will help us understand
    how and why to apply metaprogramming in various applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review the object-oriented programming concepts
    of Python. The next chapter is more of a refresher on object-oriented programming
    concepts and is optional if you are already familiar with those concepts.
  prefs: []
  type: TYPE_NORMAL
