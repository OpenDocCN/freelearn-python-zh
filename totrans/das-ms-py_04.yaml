- en: Basic Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to put together a Python package of code
    and data. In this chapter, we're going to look at some rather simple things we
    can do that will make our lives as Python programmers simpler overall. We'll switch
    gears and look at version control, which will help us to collaborate with other
    programmers and serve as an undo buffer for the whole lifetime of a project. We're
    going to look at Python's built-in virtual environment tool, venv, which allows
    us to keep our programs and dependencies separate from each other and the software
    installed on our overall system.
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn how to structure our docstrings for maximum utility, how to add
    Rich Text formatting to them, and how to export them into hyperlinked HTML documentation
    for viewing in a web browser. You'll also see one more cool advantage we can get
    from docstrings by actually executing the examples we include in our documentation
    and making sure they agree with what the code actually does.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 and writing readable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using venv to create a stable and isolated work area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the most out of docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 8 and writing readable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a quick look at how to format our code so that it'll
    be easy to read when we come back to it at some later date or when somebody else
    has to work with it. We will specifically take a look at indentation rules, the
    Python code style guide, and finally, the standard naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Enhancement Proposals** or **PEPs** are the documents that establish
    standards in the Python community. Most PEPs describe new features for Python
    or Python''s standard library, but a few of them are more nebulous. PEP 8 is one
    of those; it tells us what the Python community considers to be well-written,
    readable code.'
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 â€” guidelines for Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The very first rule PEP 8 introduces is that rules/guidelines in PEP 8 should
    only apply when they make our code easier to read. This means we should apply
    PEP 8 to enhance the readability of the code and to make it less complex. For
    example, if we''re working on a project that was already written with a different
    coding style (that is, it is already easy to read), we should use that project
    style for new code. If the PEP 8 rules somehow make the code harder to read or
    make it complex while writing the code, we should ignore those rules. As Guido
    Van Rossum, the creator of Python, has noted:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code* *is read more often than it is written*.'
  prefs: []
  type: TYPE_NORMAL
- en: Code should always be written in a way that promotes readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on PEP 8 rules and guidelines, you can refer to the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To know when to ignore a particular guideline, you can follow the *A Foolish
    Consistency is the Hobgoblin of Little Minds* article at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds](https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds).'
  prefs: []
  type: TYPE_NORMAL
- en: Code indentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As programmers, when we read code we look at how it''s indented to tell us
    how the code blocks are nested. However, most other programming languages use
    actual symbols to tell the language parser where a block begins and ends. In coding,
    the same information in two different places is a violation of the basic best
    practices of any programming language. So, Python omits the beginning and ending
    block markers and uses indentation (as shown in the following code screenshot)
    to inform the parser as well as the programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ffd557-be03-4213-ba16-8e9820c338f1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is one problem that arises from that, though!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways of encoding indentation in a text file. These are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Space characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of both
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The codes we're looking at in the preceding code image mixes spaces and tabs,
    which, in Python 2 was valid, but a terrible idea, and which, in Python 3, is
    a syntax error. I've configured the editor to highlight tab characters in color,
    so we can easily see which indentation comes from spaces and which comes from
    tabs, to see why mixing spaces and tabs is not good, even when it's allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do is change the tab width and it will look something like the
    following code image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e84779a7-6bb4-4097-a00a-4260142de33b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Even though the indentation looked good in the previous code image, now it's
    clearly wrong. There's no ambiguity if all indentation comes from tab characters.
    So, using only tabs is valid, even in Python 3\. However, it is the recommendation
    of PEP 8 and the Python community that we always use exactly four spaces to indicate
    one level of indentation. Any halfway decent editor can insert those spaces for
    us when we press the Tab key. There are several more recommendations, which we're
    going to go through quickly in the next sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in the following screenshot demonstrates almost all the PEP 8 formatting
    recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cbe77b4-8c6f-4db6-901a-7cef90e2bf66.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll now walk us through the recommendations one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 recommends that a single line of code should not exceed a width of 79
    characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this is consistent with displaying the code on a standard text mode interface,
    the primary reason for this rule in the modern world of widescreens and resizable
    windows is that it helps with reading. Even in contexts that have nothing to do
    with programming, layout designers prefer to limit line width.
  prefs: []
  type: TYPE_NORMAL
- en: Import statements should be placed at the top of the file, with standard library
    imports first, third-party imports next, and then imports from other modules within
    the same project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a blank line between each group of imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and functions at the top level should have two blank lines separating
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods within a class should have one blank line separating them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within a function or method, blank lines should be used to indicate separation
    between conceptual groupings of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't insert extra spaces before or after parentheses, brackets, or braces;
    and don't insert spaces before commas or colons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always put a single space on either side of a binary operator, such as `+` or
    `/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't put more than one statement on the same line, which is occasionally possible,
    but never a good idea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments should be written in human language, using that language's correct
    grammar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preferably, that language should be English if you're going to allow your source
    code into the wild because this language is common to the majority of Python programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Comments should also precede the section of code they described and be indented
    to the same level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every public module, class, function, or method should have a properly formatted
    docstring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at what properly formatted means for docstrings in the *Getting the
    most out of docstrings* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to picking names for variables, functions, methods, classes, modules,
    packages, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The overriding rule of Python naming conventions is that the naming style for
    an object should make it plain how the object is used, not what the object is
    underneath. This means, for example, that a top-level function, which is called
    to create new objects and which therefore behaves like a class, should be named
    like a class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Packages and modules**: These should have reasonably short names consisting
    entirely of lowercase letters, and in the case of modules, underscores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes**: These should be named with a capitalized first letter and capitals
    at the start of every new word within the name. This is sometimes also called
    camel case. Exceptions should be classes and so they should follow the class naming
    convention, but they should also end with the word `Error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions**, **methods**, **instance variables**, and **global variables**:
    These all should be lower case, with underscores separating the words. If they
    are meant to be internal rather than part of the public interface, their names
    should begin with a single underscore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter of an instance method should always be named self. Named
    **constant** values should be written in all capital letters, with underscores
    separating the words.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it for PEP 8 and the formatting rules that most Python programmers expect
    other people's code to follow. Now, let's move on to talking about nuts and bolts
    with a discussion of version control.
  prefs: []
  type: TYPE_NORMAL
- en: Using version control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Version control is one of the fundamental tools for programmers in the modern
    world. It helps us with almost every aspect of a project, in one way or another.
    There are many version control systems and each of them is a topic in itself,
    so we're going to narrow our focus here and talk about how to do a few particularly
    useful things, using a specific version control system called Git.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do to use Git, after installing it of course, is
    to set up a folder as ourÂ `Git repository`. This only takes a couple of commands
    on the command line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f66424f9-95fe-485d-b159-89106a7d77bd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we move to the folders where we want the repository to be, that
    is, `git init` and `git add`. Once we''ve initialized the repository, we add any
    files that we''ve already created to it with the `git add` command. Then, we create
    our first safe point in the code with the `git commitÂ -a` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Committing the changes in Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git commitÂ -a` commit command tells Git to commit all the changes that
    have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cd7114b-98b8-4ce2-bb35-01c66b55eaa5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the future, if we add new files to the project, we should also use `git add`
    to tell Git to start tracking them. Any time you want Git to remember the current
    state of our project, we run `git commit -a` again.
  prefs: []
  type: TYPE_NORMAL
- en: Undoing the changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nice thing about having old project states saved away is that we can go
    back to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have made some changes in our `file.txt` file from
    `moo cow` to `moo aardvark`, as shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdcb6853-b147-44b2-b4a9-6327a6dad98d.jpg)![](img/2c7faeb6-03a2-4d2f-8e6d-0dedfc07e17c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to revert a file to a previous state, undoing everything we''ve
    done to that file since a particular commit, we just use the `git log` command
    to find the identifier for that commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will lead us to our commit, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/051956b2-d5de-4b8a-a742-edcc9cea7400.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we use the `git checkout` command to undo our changes. To use the `git
    checkout` command, we just need to enter the commit and the filename and you will
    get to undo the changes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eff2b33-1d76-4b82-902f-f988d59d35c1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we later change our minds, we can redo the changes in the same way. The ability
    to undo on the project level is great, but it's even more useful to make provisional
    changes to our code and then decide, once the changes are done, whether or not
    we really want them in our main code. That's what branches are for.
  prefs: []
  type: TYPE_NORMAL
- en: Branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can make a new branch with `git checkout -b`, which will create the branch
    and switch to it automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5377626-1f05-4271-bbfe-eec7cbe38c6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we're in the branch, any code changes we make are associated with a branch,
    and when we leave the branch, they go away. This can be shown in the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to change the `moo cow` to `moo horse`. For this, we''ll
    run the following command to open up Emacs and edit the text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**![](img/a054b692-dd3e-4cda-89c8-1b3193dfc2a2.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then make the changes we want in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34c3bfba-d4cc-447b-b79c-4de115ef32a7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then commit the file to the branch using the `git commit -a` command
    and add a commit message to keep track of the changes that we''ve made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb30482a-0d56-43a9-b2f0-225504d211de.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll see a record of those changes to show what''s been committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99f154f5-e06b-4ec4-85c3-b314f52ba4b0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can then switch back to the master version using the `git checkout master`
    command to see the original files without any changes, and when we re-enter the
    branch, those changes come back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe541818-0d84-455e-8746-17c79a6e1003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that we can still work on bug fixes in our main branch while we
    are working on new features in their own development branches. For example, here
    we can enter the same text file and change the animal to a dog, leaving a comment
    explaining what we''ve done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8eae197d-9405-4da6-a7c5-d208fdf9ac55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, when we commit that file, we''ll also leave a message stating that we''ve
    just made a bugfix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82e5165c-754e-4940-baa4-27be50fb609b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As always, we commit the file using the `git commit` -a command, and we are
    shown a record of the changes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b2e675b-10a5-48aa-84c0-47ccbd9cb47f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we're finally happy with a feature, we can merge it into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Merging codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To merge code from a different branch, all we have to do is to use the `git
    merge` command from inside the branch we''re merging to and give it the name of
    the branch we''re merging from. If the two branches cannot be automatically combined,
    Git will do it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/227c83bb-d526-4625-b1c2-c694e48326ad.png)'
  prefs: []
  type: TYPE_IMG
- en: That's usually all there is to it, but sometimes there are overlapping changes
    in both branches; when that happens, Git knows it's not smart enough to handle
    the merger on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run `git merge`, it will notify us that there are conflicts. Then,
    we can use `git mergetool` to start up the merge resolution tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e435b720-5edf-4f00-a205-11fd3782d20c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mergetool command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The merge resolution tool lets us use our greater intelligence to resolve the
    conflict, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b844b5a-5a12-4902-98b8-72006f8342ad.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `moo cow` should be changed to `moo horse` to avoid the conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd30f82a-d0c3-44fb-8254-ac921997414a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the required changes, go to File and quit the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Once that's done, we use the `git commit` command to finalize our changes, as
    shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8acc4bef-6b14-4e67-bc20-37ca33770644.png)'
  prefs: []
  type: TYPE_IMG
- en: The `mergetool` command is a smart command that looks for several different
    tools that exist on various operating systems and picks one of them that it hopes
    is the best choice for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the present case, it has picked a tool called `meld`, which is also written
    in Python incidentally, for me to use to fix the ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: The pull command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git can do something very similar to combine code from other repositories into
    our own. The command for that is `git pull`, rather than `git merge`, and instead
    of a branch name, we provide the URL or pathname to a different repository, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39c85324-5650-4bc6-9aaf-a23d297ae2e8.png)'
  prefs: []
  type: TYPE_IMG
- en: But otherwise, it functions in the same way. This is an incredibly useful feature
    because it allows us to easily collaborate with other coders, both locally and
    around the world.
  prefs: []
  type: TYPE_NORMAL
- en: Using venv to create a stable and isolated work area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we're working on a project, we usually like the parts of the project that
    aren't our own code to stay the same. We might have a good reason to install a
    new version of Python or updated library on our system, but we don't really want
    those things to change within our development environment. Even more so, we can
    easily find ourselves targeting entirely different and incompatible system configurations
    with different projects. We need a way to set aside an area for each project that
    is separate and can be configured for the specific needs of that project. That's
    what we call a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: The venv tool that's built in to Python 3.3, and later, creates a virtual environment
    for us. Each virtual environment created by venv knows which version of Python
    it should be using and has its own package library, which means that as far as
    Python code is concerned, it's basically disconnected from the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: We can install, uninstall, and update packages on the system and the code inside
    the virtual environment won't even notice. We can install new versions of Python
    and the code inside the virtual environment won't notice. The only thing we can't
    safely do at the system level is uninstalling the version of Python that the virtual
    environment is based on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a virtual environment for a new project is easy; we just open the
    command line and go to the folder where we want the project folder to reside.Â Then,
    we use the version of Python that we want the virtual environment to use to run
    theÂ venv tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2544e884-ecbe-40e2-9136-2cd5754cbf6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we call venv, we tell it the name we want to give to the project folder.
    The venv tool will create the project folder and populate it with the files needed
    to support the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53a206ad-0e8f-41fd-8489-e1b1b6c105fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Each time we actually want to work inside the virtual environment, we should
    activate it. This will make whatever changes are needed, so that the contents
    of the virtual environment override the system-level defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Activating a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To activate a virtual environment, we open a command line and go to the folder
    containing the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76583a08-77b0-4b7a-a5e5-9c81fc460d7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, execute the activation command. The specific activation command we're
    using depends on the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: On most Unix-style systems, including Macintosh, we use the `$ source bin\activate`
    command (as shown in the preceding screengrab). On Windows, we run `Scripts\activate.bat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are operating inside an activated virtual environment, pip automatically
    knows it should manage packages for that environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cddec0aa-7780-4447-acd9-7f778c3efc2d.png)'
  prefs: []
  type: TYPE_IMG
- en: pip in virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, the virtual environment contains only the Python standard library
    and a couple of utilities, including pip itself.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use `pip` to install the third-party packages that we're going
    to use on the project. When we looked at pip, you learned about its `--user` command-line
    option, which installs the package into a personal package library instead of
    the system library.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the package into a personal package library, instead of the system
    library, is never necessary when installing into a virtual environment because
    the virtual environment has changed where the default installation location is.
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything is set up, we can begin work. We shouldn't delete any of
    the files or folders created by venv or pip. However, other than that, we're free
    to create files and folders as needed for our project. It is often useful to create
    a subdirectory to contain our working code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you learned how to use the simple, but useful, venv tool to isolate
    our coding projects from each other and from most changes to our development system,
    let's turn to another useful best practice, docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the most out of docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at how to format docstrings for maximum
    readability and how to transform them into structured and formatted documentation.
    We're also going to look at how to make examples in the documentation testable
    so that the documentation is never out of date.
  prefs: []
  type: TYPE_NORMAL
- en: PEP 257 and docutils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PEP 257 documents the expectations of Python programmers and tools with respect
    to docstrings. The basic rules are quite simple. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation is available atÂ [https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/).
  prefs: []
  type: TYPE_NORMAL
- en: Use triple quotes to delimit the docstring. Triple quotes are how Python expresses
    the idea of a multiline text string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing triple quotes should be on a line of their own if your docstring
    is longer than one line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line should present a short description of the thing being documented,
    such as "return the distance between n-points a and b."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the first line, we can either end the docstring or insert a blank line,
    followed by a more in-depth description of the documented object, containing descriptions
    of parameters, attributes, usage semantics examples, and so on (refer to the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec67a7e5-b391-45ba-abc0-09f0b02cea0e.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason for this layout is that many tools show the first line of the docstring
    as a popup, tooltip, or otherwise presented as a quick reference. The text after
    the blank line is presented when detailed documentation is requested. The docstring
    processing tools are smart about indentation, so it's safe and encouraged to indent
    our docstrings, so that they match up with the rest of the code block that they're
    describing.
  prefs: []
  type: TYPE_NORMAL
- en: Those basic rules are all that are required to make our docstrings interact
    well with Python's `pydoc` and help tools with IDEs, and so on. But they don't
    give us any way of creating well-formatted standalone documentation. That's where
    Sphinx comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sphinx is a tool that can process Python source code and standalone documentation
    files and generate nicely formatted documentation in a number of formats, notably
    HTML. Sphinx, like other Python documentation tools, recognizes a markup language
    called `reStructuredText`, which is intentionally readable and informative, even
    when its markup is presented as plaintext rather than being interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: '`reStructuredText` can be found at the following link: [https://docs.python.org/devguide/documenting.html#reStructuredText-primer](https://docs.python.org/devguide/documenting.html#reStructuredText-primer).'
  prefs: []
  type: TYPE_NORMAL
- en: reStructuredText documents are still readable in a simple text editor, but when
    we feed them through a tool such as Sphinx they make the end result richer. The
    reStructuredText syntax is based on the conventions that developed on the internet
    before actual rich text was widely available in email and real-time chat.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, words are emphasized by putting an asterisk (`*text*`) at each
    end and emphasized further by making that into two asterisks (`**text**`). Paragraphs
    are marked by placing a blank line between them.
  prefs: []
  type: TYPE_NORMAL
- en: There are syntaxes for lists, headings, and so on, all plainly readable in text
    mode. The syntax is nicely described in the Python developer's guide, but we're
    going to concentrate on a few bits of markup that do a lot to enhance the documentation
    for modules and packages. We actually saw one of those bits of markup earlier.
  prefs: []
  type: TYPE_NORMAL
- en: When our docstrings make reference to a local variable, such as a function parameter,
    that reference should be enclosed in asterisks to emphasize it and make it distinct
    from the normal text of the documentation. The names of modules, classes, functions,
    methods, attributes, exceptions, global variables, and constants should all be
    marked properly, so that Sphinx can cross-reference them and create links to their
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these object types share a similar syntax, which is that we put a type
    identifying keyword between colons, immediately followed by the name of the object
    in back quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6a50fec-5b59-4ee3-855c-e3780d4e1051.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you saw in the preceding example with classes and methods, we used the keywords
    class for `classes` and `meth` for methods. Other keywords available are: `mod`
    for modules, `func` for functions, `attr` for attributes, `data` for variables,
    and `const` for constants.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s enough reStructuresText syntax to make a big difference in the quality
    of our documentation. So, we''re going to leave it there and go on to talk about
    how to actually use the Sphinx tool. If it''s not already installed, we can install
    it using `pip`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Sphinx can do a lot more, so it's worth working through the tutorial on
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.sphinx-doc.org/en/stable/tutorial.html](https://www.sphinx-doc.org/en/stable/tutorial.html).'
  prefs: []
  type: TYPE_NORMAL
- en: It's quite nice.
  prefs: []
  type: TYPE_NORMAL
- en: For our own purposes though, all we're interested in is turning docstrings into
    HTML. So, we'll work through that process in the next sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: Turning docstrings into HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to generate HTML documentation for our example package, which is
    just a docstring example. We start by going to the directory that contains our
    package directory.Â Once there, we run `sphinx-quickstart` to set things up.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58f0e7e-3c9b-4145-b352-b24e3edd85a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that `sphinx-quickstart` asks is what the root path for the
    documentation should be. I find that it works well to use a folder called `docs`
    for this, so I suggest typing in `docs` for the root path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57a68d82-89a0-487c-beda-11827c630f93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sphinx-quickstart` command will ask several more questions, which we can
    answer as we like, and then eventually it will ask if we want to enable the autodoc
    plugin; we will enable it by entering yes (`y`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba5c2263-90ba-4736-933e-a24f5b7c26aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The rest of the questions are not so important for our purposes. After answering
    all the questions, the `sphinx-quickstart` command is completed as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7e22da1-93c7-4d6d-9130-9611452a901f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once `sphinx-quickstart` is completed, we''ll want to run `sphinx-apidoc -o`
    with our directoryÂ to automatically generate Sphinx or Sphinx source files describing
    our package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7e4c475-ee44-4405-aad8-89355a0be4ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Our docstrings are extracted and incorporated into these source files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we want to generate the HTML we can construct it by running `make
    html` from the command line. Sphinx will translate its source files, including
    the ones automatically generated by `sphinx-apidoc` into HTML and store the result
    in the build directory that we specified when we were going through the `sphinx-quickstart`
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we edit our source code and want to update the HTML documentation, we can
    usually do it simply by running the following command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''ve made major changes to the package structure, we''ll need to run the
    `sphinx-apidoc` command again as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, Sphinx can be used as a documentation compiler, which turns our docstrings
    source code into HTML-compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: Using doctest to test documentation examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Including examples of use in our docstrings is common, but if we're not careful,
    those examples can get left behind when the code changes, and the wrong documentation
    is worse than no documentation. Fortunately, we have a tool that can check whether
    the documentation agrees with the code by running the examples from our documentation
    and seeing what happens. That tool is called **doctest**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable doctest to recognize our examples as things it can test, all we have
    to do is include the Python interactive shell prompt into our example. In the
    simplest and most common case, that just means putting a `>>>` symbol in front
    of each statement, as shown in the following screenshot. For multi-line statements,
    we prefix the continuation line with a `...` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd6e73d-25de-4916-bc5a-5373f2ad476b.png)'
  prefs: []
  type: TYPE_IMG
- en: After each statement, we should write down the expected result of the statement,
    written the same way the interactive shell would write it. In other words, if
    we copy and paste directly from the interactive shell, we've created an example
    that doctest can recognize. So, writing doctest is pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: There's a decent chance of writing a doctest into our docstrings, even if we
    didn't know the doctest tool exists. As an added bonus, Sphinx recognizes doctest
    and formats it appropriately too. So, if we're going to include code examples
    in our docstrings, the way to do it is explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Testing examples using doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the code example using doctest, we just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe6cd367-a947-47f3-9709-ce3a3d8a69bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Having doctest run all the examples in a file and report back whether they worked
    is easy. We just run the doctest utility from the command line and tell it which
    files we were interested in. The `-v` option in the command makes it pull out
    extra information, which isn't necessary, but often is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: All we see in the preceding example is a lack of error messages rather than
    any confirmation that everything worked or is tested.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways of running doctests including a Sphinx plugin that sphinx-quickstart
    asks us whether we want. It's also possible to integrate doctests into a test
    suite for Python's standard unit test library, or to use an integrated test runner
    called nos to find an excuse to execute them; doctests directly will do for our
    purposes in such cases, though.
  prefs: []
  type: TYPE_NORMAL
- en: What it means when a code example fails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, what happens if a doctest fails, but after looking at it we see that the
    documentation and example are actually correct? Well, that means our code is incorrect.
    Believe it or not, this is a very good thing. I don't mean that having an error
    is a good thing, but that error was there whether we found it or not. Finding
    it and having a test on hand that will let us check whether we've succeeded in
    fixing it, though, is definitely good.
  prefs: []
  type: TYPE_NORMAL
- en: So, doctest ties our code and documentation together, so that they stay synchronized
    and serve to double-check each other. That's a very useful docstring trick.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about writing readable code, version control to
    keep track of our code, and about the venv tool and the isolated virtual environments
    it creates. You learned how to format our docstrings to take advantage of automated
    tools, such as IDEs and the Sphinx documentation compiler. You also learned about
    writing examples into our documentation and how to use the doctest tool to check
    whether the examples and code are synchronized
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll get to learn how to turn a package into a program
    that can be run from the command line.
  prefs: []
  type: TYPE_NORMAL
