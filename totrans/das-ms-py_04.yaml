- en: Basic Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本最佳实践
- en: In the previous chapter, we saw how to put together a Python package of code
    and data. In this chapter, we're going to look at some rather simple things we
    can do that will make our lives as Python programmers simpler overall. We'll switch
    gears and look at version control, which will help us to collaborate with other
    programmers and serve as an undo buffer for the whole lifetime of a project. We're
    going to look at Python's built-in virtual environment tool, venv, which allows
    us to keep our programs and dependencies separate from each other and the software
    installed on our overall system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何组合Python代码和数据包。在本章中，我们将探讨一些可以使我们作为Python程序员的生活更加简单的事情。我们将转换方向，探讨版本控制，这将帮助我们与其他程序员协作，并在整个项目生命周期中作为撤销缓冲。我们将查看Python内置的虚拟环境工具venv，它允许我们将我们的程序和依赖项彼此分离，以及与系统上安装的软件分离。
- en: You'll learn how to structure our docstrings for maximum utility, how to add
    Rich Text formatting to them, and how to export them into hyperlinked HTML documentation
    for viewing in a web browser. You'll also see one more cool advantage we can get
    from docstrings by actually executing the examples we include in our documentation
    and making sure they agree with what the code actually does.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何为最大效用结构化我们的文档字符串，如何向它们添加富文本格式，以及如何将它们导出为超链接HTML文档，以便在网页浏览器中查看。您还将看到通过实际执行我们在文档中包含的示例并确保它们与代码的实际行为一致，我们可以从文档字符串中获得的一个额外的好处。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: PEP 8 and writing readable code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 8和编写可读的代码
- en: Using version control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制
- en: Using venv to create a stable and isolated work area
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用venv创建一个稳定且隔离的工作区域
- en: Getting the most out of docstrings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用文档字符串
- en: PEP 8 and writing readable code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 8和编写可读的代码
- en: In this section, we'll take a quick look at how to format our code so that it'll
    be easy to read when we come back to it at some later date or when somebody else
    has to work with it. We will specifically take a look at indentation rules, the
    Python code style guide, and finally, the standard naming convention.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速浏览如何格式化我们的代码，以便在稍后日期返回时或当其他人需要处理它时易于阅读。我们将特别关注缩进规则、Python代码风格指南，以及最终的命名约定。
- en: '**Python Enhancement Proposals** or **PEPs** are the documents that establish
    standards in the Python community. Most PEPs describe new features for Python
    or Python''s standard library, but a few of them are more nebulous. PEP 8 is one
    of those; it tells us what the Python community considers to be well-written,
    readable code.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python增强提案**或**PEPs**是建立Python社区标准的文档。大多数PEP描述了Python或Python标准库的新功能，但其中一些较为模糊。PEP
    8就是其中之一；它告诉我们Python社区认为什么样的代码是写得好的、可读的代码。'
- en: PEP 8 — guidelines for Python code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 8 — Python代码指南
- en: 'The very first rule PEP 8 introduces is that rules/guidelines in PEP 8 should
    only apply when they make our code easier to read. This means we should apply
    PEP 8 to enhance the readability of the code and to make it less complex. For
    example, if we''re working on a project that was already written with a different
    coding style (that is, it is already easy to read), we should use that project
    style for new code. If the PEP 8 rules somehow make the code harder to read or
    make it complex while writing the code, we should ignore those rules. As Guido
    Van Rossum, the creator of Python, has noted:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 8引入的第一条规则是，PEP 8中的规则/指南仅在它们使我们的代码更容易阅读时才适用。这意味着我们应该应用PEP 8来提高代码的可读性，并使其更简单。例如，如果我们正在处理一个已经使用不同编码风格（即已经易于阅读）的项目，我们应该为新代码使用该项目的风格。如果PEP
    8规则在某种程度上使代码更难以阅读或在编写代码时使其复杂，我们应该忽略这些规则。正如Python的创造者Guido Van Rossum所指出的：
- en: '*Code* *is read more often than it is written*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码* *被阅读的次数比被编写的次数多*。'
- en: Code should always be written in a way that promotes readability.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该始终以促进可读性的方式编写。
- en: 'For more information on PEP 8 rules and guidelines, you can refer to the following
    link:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于PEP 8规则和指南的信息，您可以参考以下链接：
- en: '[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)'
- en: 'To know when to ignore a particular guideline, you can follow the *A Foolish
    Consistency is the Hobgoblin of Little Minds* article at the following link:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道何时忽略特定的指南，您可以参考以下链接中的“A Foolish Consistency is the Hobgoblin of Little Minds”文章：
- en: '[https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds](https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Code indentation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As programmers, when we read code we look at how it''s indented to tell us
    how the code blocks are nested. However, most other programming languages use
    actual symbols to tell the language parser where a block begins and ends. In coding,
    the same information in two different places is a violation of the basic best
    practices of any programming language. So, Python omits the beginning and ending
    block markers and uses indentation (as shown in the following code screenshot)
    to inform the parser as well as the programmer:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6ffd557-be03-4213-ba16-8e9820c338f1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: There is one problem that arises from that, though!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways of encoding indentation in a text file. These are
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Use Space characters
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tab characters
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of both
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The codes we're looking at in the preceding code image mixes spaces and tabs,
    which, in Python 2 was valid, but a terrible idea, and which, in Python 3, is
    a syntax error. I've configured the editor to highlight tab characters in color,
    so we can easily see which indentation comes from spaces and which comes from
    tabs, to see why mixing spaces and tabs is not good, even when it's allowed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do is change the tab width and it will look something like the
    following code image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e84779a7-6bb4-4097-a00a-4260142de33b.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Even though the indentation looked good in the previous code image, now it's
    clearly wrong. There's no ambiguity if all indentation comes from tab characters.
    So, using only tabs is valid, even in Python 3\. However, it is the recommendation
    of PEP 8 and the Python community that we always use exactly four spaces to indicate
    one level of indentation. Any halfway decent editor can insert those spaces for
    us when we press the Tab key. There are several more recommendations, which we're
    going to go through quickly in the next sub-section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Formatting recommendations
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in the following screenshot demonstrates almost all the PEP 8 formatting
    recommendations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cbe77b4-8c6f-4db6-901a-7cef90e2bf66.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'I''ll now walk us through the recommendations one by one:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: PEP 8 recommends that a single line of code should not exceed a width of 79
    characters
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this is consistent with displaying the code on a standard text mode interface,
    the primary reason for this rule in the modern world of widescreens and resizable
    windows is that it helps with reading. Even in contexts that have nothing to do
    with programming, layout designers prefer to limit line width.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Import statements should be placed at the top of the file, with standard library
    imports first, third-party imports next, and then imports from other modules within
    the same project
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be a blank line between each group of imports
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and functions at the top level should have two blank lines separating
    them.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶级类和函数之间应该有两行空白来分隔。
- en: Methods within a class should have one blank line separating them
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的方法应该用一行空白来分隔它们。
- en: Within a function or method, blank lines should be used to indicate separation
    between conceptual groupings of code
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数或方法内部，空白行应该用来表示代码概念分组之间的分隔。
- en: Don't insert extra spaces before or after parentheses, brackets, or braces;
    and don't insert spaces before commas or colons
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在括号、方括号或花括号前后插入额外的空格；也不要在逗号或冒号前插入空格。
- en: Always put a single space on either side of a binary operator, such as `+` or
    `/`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在二元运算符（如`+`或`/`）的两侧放置单个空格。
- en: Don't put more than one statement on the same line, which is occasionally possible,
    but never a good idea
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在同一行上放置多个语句，尽管偶尔可能这样做，但这从来不是一个好主意。
- en: Comments should be written in human language, using that language's correct
    grammar
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释应该用人类语言编写，使用该语言的正确语法。
- en: Preferably, that language should be English if you're going to allow your source
    code into the wild because this language is common to the majority of Python programmers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要将源代码发布到野外，那么最好使用英语，因为这种语言是大多数Python程序员的通用语言。
- en: Comments should also precede the section of code they described and be indented
    to the same level
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释也应该在描述的代码部分之前，并且应该缩进到相同的级别。
- en: Every public module, class, function, or method should have a properly formatted
    docstring
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个公开的模块、类、函数或方法都应该有一个格式正确的文档字符串。
- en: We'll look at what properly formatted means for docstrings in the *Getting the
    most out of docstrings* section of this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“充分利用文档字符串”部分中查看格式正确的文档字符串意味着什么。
- en: Let's move on to picking names for variables, functions, methods, classes, modules,
    packages, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续选择变量、函数、方法、类、模块、包等的名称。
- en: Naming conventions
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: The overriding rule of Python naming conventions is that the naming style for
    an object should make it plain how the object is used, not what the object is
    underneath. This means, for example, that a top-level function, which is called
    to create new objects and which therefore behaves like a class, should be named
    like a class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python命名约定的主导规则是，对象的命名风格应该清楚地表明对象的使用方式，而不是对象本身是什么。这意味着，例如，一个顶级函数，它被调用以创建新对象，因此表现得像类，应该像类一样命名。
- en: '**Packages and modules**: These should have reasonably short names consisting
    entirely of lowercase letters, and in the case of modules, underscores.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包和模块**：这些应该有合理短的名字，完全由小写字母组成，在模块的情况下，可以使用下划线。'
- en: '**Classes**: These should be named with a capitalized first letter and capitals
    at the start of every new word within the name. This is sometimes also called
    camel case. Exceptions should be classes and so they should follow the class naming
    convention, but they should also end with the word `Error`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：这些应该使用首字母大写和每个新单词开头的首字母大写来命名。这有时也被称为驼峰式命名。例外情况是类，因此它们应该遵循类命名约定，但它们也应该以单词`Error`结尾。'
- en: '**Functions**, **methods**, **instance variables**, and **global variables**:
    These all should be lower case, with underscores separating the words. If they
    are meant to be internal rather than part of the public interface, their names
    should begin with a single underscore.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**、**方法**、**实例变量**和**全局变量**：这些都应该使用小写字母，单词之间用下划线分隔。如果它们打算作为内部组件而不是公共接口的一部分，那么它们的名称应该以单个下划线开头。'
- en: The first parameter of an instance method should always be named self. Named
    **constant** values should be written in all capital letters, with underscores
    separating the words.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法的第一个参数应该始终命名为`self`。命名的**常量**值应该全部大写，单词之间用下划线分隔。
- en: That's it for PEP 8 and the formatting rules that most Python programmers expect
    other people's code to follow. Now, let's move on to talking about nuts and bolts
    with a discussion of version control.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是PEP 8和大多数Python程序员期望其他人遵循的格式规则。现在，让我们通过讨论版本控制来谈谈细节。
- en: Using version control
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制
- en: Version control is one of the fundamental tools for programmers in the modern
    world. It helps us with almost every aspect of a project, in one way or another.
    There are many version control systems and each of them is a topic in itself,
    so we're going to narrow our focus here and talk about how to do a few particularly
    useful things, using a specific version control system called Git.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Git
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do to use Git, after installing it of course, is
    to set up a folder as our `Git repository`. This only takes a couple of commands
    on the command line, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f66424f9-95fe-485d-b159-89106a7d77bd.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'After that, we move to the folders where we want the repository to be, that
    is, `git init` and `git add`. Once we''ve initialized the repository, we add any
    files that we''ve already created to it with the `git add` command. Then, we create
    our first safe point in the code with the `git commit -a` command, as shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Committing the changes in Git
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git commit -a` commit command tells Git to commit all the changes that
    have been made:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cd7114b-98b8-4ce2-bb35-01c66b55eaa5.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: In the future, if we add new files to the project, we should also use `git add`
    to tell Git to start tracking them. Any time you want Git to remember the current
    state of our project, we run `git commit -a` again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Undoing the changes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nice thing about having old project states saved away is that we can go
    back to them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we have made some changes in our `file.txt` file from
    `moo cow` to `moo aardvark`, as shown in the following screenshots:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdcb6853-b147-44b2-b4a9-6327a6dad98d.jpg)![](img/2c7faeb6-03a2-4d2f-8e6d-0dedfc07e17c.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'If we want to revert a file to a previous state, undoing everything we''ve
    done to that file since a particular commit, we just use the `git log` command
    to find the identifier for that commit:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will lead us to our commit, as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/051956b2-d5de-4b8a-a742-edcc9cea7400.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Then, we use the `git checkout` command to undo our changes. To use the `git
    checkout` command, we just need to enter the commit and the filename and you will
    get to undo the changes, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eff2b33-1d76-4b82-902f-f988d59d35c1.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: If we later change our minds, we can redo the changes in the same way. The ability
    to undo on the project level is great, but it's even more useful to make provisional
    changes to our code and then decide, once the changes are done, whether or not
    we really want them in our main code. That's what branches are for.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Branches
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can make a new branch with `git checkout -b`, which will create the branch
    and switch to it automatically:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5377626-1f05-4271-bbfe-eec7cbe38c6e.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: When we're in the branch, any code changes we make are associated with a branch,
    and when we leave the branch, they go away. This can be shown in the following
    example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to change the `moo cow` to `moo horse`. For this, we''ll
    run the following command to open up Emacs and edit the text file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将 `moo cow` 改为 `moo horse`。为此，我们将运行以下命令以打开Emacs并编辑文本文件：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**![](img/a054b692-dd3e-4cda-89c8-1b3193dfc2a2.jpg)**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](img/a054b692-dd3e-4cda-89c8-1b3193dfc2a2.jpg)**'
- en: 'We''ll then make the changes we want in the file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在文件中进行我们想要的更改：
- en: '![](img/34c3bfba-d4cc-447b-b79c-4de115ef32a7.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34c3bfba-d4cc-447b-b79c-4de115ef32a7.jpg)'
- en: 'We can then commit the file to the branch using the `git commit -a` command
    and add a commit message to keep track of the changes that we''ve made:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `git commit -a` 命令将文件提交到分支，并添加一条提交信息以跟踪我们所做的更改：
- en: '![](img/eb30482a-0d56-43a9-b2f0-225504d211de.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb30482a-0d56-43a9-b2f0-225504d211de.jpg)'
- en: 'You''ll see a record of those changes to show what''s been committed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到这些变更的记录，以显示已提交的内容：
- en: '![](img/99f154f5-e06b-4ec4-85c3-b314f52ba4b0.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99f154f5-e06b-4ec4-85c3-b314f52ba4b0.jpg)'
- en: 'You can then switch back to the master version using the `git checkout master`
    command to see the original files without any changes, and when we re-enter the
    branch, those changes come back:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `git checkout master` 命令切换回主版本，查看未做任何更改的原始文件，当我们重新进入分支时，那些更改会回来：
- en: '![](img/fe541818-0d84-455e-8746-17c79a6e1003.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe541818-0d84-455e-8746-17c79a6e1003.jpg)'
- en: 'This means that we can still work on bug fixes in our main branch while we
    are working on new features in their own development branches. For example, here
    we can enter the same text file and change the animal to a dog, leaving a comment
    explaining what we''ve done:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在自己的开发分支上工作新特性时，仍然可以在主分支上修复bug。例如，在这里我们可以进入相同的文本文件，将动物改为狗，并留下注释说明我们做了什么：
- en: '![](img/8eae197d-9405-4da6-a7c5-d208fdf9ac55.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8eae197d-9405-4da6-a7c5-d208fdf9ac55.jpg)'
- en: 'Then, when we commit that file, we''ll also leave a message stating that we''ve
    just made a bugfix:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们提交该文件时，我们也会留下一条消息，说明我们刚刚进行了bug修复：
- en: '![](img/82e5165c-754e-4940-baa4-27be50fb609b.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82e5165c-754e-4940-baa4-27be50fb609b.jpg)'
- en: 'As always, we commit the file using the `git commit` -a command, and we are
    shown a record of the changes, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们使用 `git commit -a` 命令提交文件，然后会看到变更记录，如下所示：
- en: '![](img/1b2e675b-10a5-48aa-84c0-47ccbd9cb47f.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b2e675b-10a5-48aa-84c0-47ccbd9cb47f.jpg)'
- en: When we're finally happy with a feature, we can merge it into the main branch.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最终对某个特性满意时，我们可以将其合并到主分支。
- en: Merging codes
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码合并
- en: 'To merge code from a different branch, all we have to do is to use the `git
    merge` command from inside the branch we''re merging to and give it the name of
    the branch we''re merging from. If the two branches cannot be automatically combined,
    Git will do it for us:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从不同的分支合并代码，我们只需在我们要合并到的分支内部使用 `git merge` 命令，并给出我们要合并的分支名称。如果两个分支不能自动合并，Git会为我们处理：
- en: '![](img/227c83bb-d526-4625-b1c2-c694e48326ad.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/227c83bb-d526-4625-b1c2-c694e48326ad.png)'
- en: That's usually all there is to it, but sometimes there are overlapping changes
    in both branches; when that happens, Git knows it's not smart enough to handle
    the merger on its own.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常就是全部，但有时两个分支都有重叠的更改；当这种情况发生时，Git知道它自己不足以处理合并。
- en: 'When we run `git merge`, it will notify us that there are conflicts. Then,
    we can use `git mergetool` to start up the merge resolution tool:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `git merge` 时，它会通知我们存在冲突。然后，我们可以使用 `git mergetool` 来启动合并解决工具：
- en: '![](img/e435b720-5edf-4f00-a205-11fd3782d20c.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e435b720-5edf-4f00-a205-11fd3782d20c.jpg)'
- en: The mergetool command
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并工具命令
- en: 'The merge resolution tool lets us use our greater intelligence to resolve the
    conflict, as shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 合并解决工具让我们能够利用我们的更高智能来解决冲突，如下所示：
- en: '![](img/0b844b5a-5a12-4902-98b8-72006f8342ad.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b844b5a-5a12-4902-98b8-72006f8342ad.jpg)'
- en: 'The `moo cow` should be changed to `moo horse` to avoid the conflict:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应将 `moo cow` 改为 `moo horse` 以避免冲突：
- en: '![](img/cd30f82a-d0c3-44fb-8254-ac921997414a.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd30f82a-d0c3-44fb-8254-ac921997414a.jpg)'
- en: After the required changes, go to File and quit the interface.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成必要的更改后，转到文件并退出界面。
- en: Once that's done, we use the `git commit` command to finalize our changes, as
    shown in the following screenshot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们使用 `git commit` 命令来最终确定我们的更改，如下面的截图所示。
- en: '![](img/8acc4bef-6b14-4e67-bc20-37ca33770644.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8acc4bef-6b14-4e67-bc20-37ca33770644.png)'
- en: The `mergetool` command is a smart command that looks for several different
    tools that exist on various operating systems and picks one of them that it hopes
    is the best choice for you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergetool` 命令是一个智能命令，它会寻找存在于各种操作系统上的多个不同工具，并从中选择一个它认为最适合您的工具。'
- en: In the present case, it has picked a tool called `meld`, which is also written
    in Python incidentally, for me to use to fix the ambiguity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前情况下，它为我选择了一个名为 `meld` 的工具，这个工具偶然也是用 Python 编写的，用于修复歧义。
- en: The pull command
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取命令
- en: 'Git can do something very similar to combine code from other repositories into
    our own. The command for that is `git pull`, rather than `git merge`, and instead
    of a branch name, we provide the URL or pathname to a different repository, as
    shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Git 可以做类似的事情，将其他存储库中的代码合并到我们的存储库中。该命令是 `git pull`，而不是 `git merge`，并且不是分支名称，而是提供不同存储库的
    URL 或路径名，如上图所示：
- en: '![](img/39c85324-5650-4bc6-9aaf-a23d297ae2e8.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39c85324-5650-4bc6-9aaf-a23d297ae2e8.png)'
- en: But otherwise, it functions in the same way. This is an incredibly useful feature
    because it allows us to easily collaborate with other coders, both locally and
    around the world.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但除此之外，它的功能是一样的。这是一个极其有用的功能，因为它允许我们轻松地与其他本地和全球的程序员协作。
- en: Using venv to create a stable and isolated work area
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 venv 创建稳定且独立的作业区域
- en: When we're working on a project, we usually like the parts of the project that
    aren't our own code to stay the same. We might have a good reason to install a
    new version of Python or updated library on our system, but we don't really want
    those things to change within our development environment. Even more so, we can
    easily find ourselves targeting entirely different and incompatible system configurations
    with different projects. We need a way to set aside an area for each project that
    is separate and can be configured for the specific needs of that project. That's
    what we call a virtual environment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在处理一个项目时，我们通常希望项目中的非我们自己的代码部分保持不变。我们可能有一个很好的理由在我们的系统上安装 Python 的新版本或更新库，但我们真的不希望这些事情在我们的开发环境中发生变化。更不用说，我们很容易发现自己针对完全不同且不兼容的系统配置进行不同的项目。我们需要为每个项目设置一个独立且可以针对该项目特定需求进行配置的区域。这就是我们所说的虚拟环境。
- en: The venv tool that's built in to Python 3.3, and later, creates a virtual environment
    for us. Each virtual environment created by venv knows which version of Python
    it should be using and has its own package library, which means that as far as
    Python code is concerned, it's basically disconnected from the rest of the system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.3 及以后的版本内置了 venv 工具，它为我们创建虚拟环境。每个由 venv 创建的虚拟环境都知道它应该使用哪个版本的 Python，并且拥有自己的包库，这意味着对于
    Python 代码来说，它基本上与系统其他部分是断开的。
- en: We can install, uninstall, and update packages on the system and the code inside
    the virtual environment won't even notice. We can install new versions of Python
    and the code inside the virtual environment won't notice. The only thing we can't
    safely do at the system level is uninstalling the version of Python that the virtual
    environment is based on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在系统级别和虚拟环境内部的代码上安装、卸载和更新包，而虚拟环境内部的代码甚至不会注意到。我们可以安装 Python 的新版本，而虚拟环境内部的代码也不会注意到。我们唯一不能在系统级别安全做的事情是卸载虚拟环境基于的
    Python 版本。
- en: Creating a virtual environment
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: 'Creating a virtual environment for a new project is easy; we just open the
    command line and go to the folder where we want the project folder to reside. Then,
    we use the version of Python that we want the virtual environment to use to run
    the venv tool:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为新项目创建虚拟环境非常简单；我们只需打开命令行，转到我们希望项目文件夹所在的文件夹。然后，我们使用我们想要虚拟环境使用的 Python 版本来运行 venv
    工具：
- en: '![](img/2544e884-ecbe-40e2-9136-2cd5754cbf6e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2544e884-ecbe-40e2-9136-2cd5754cbf6e.png)'
- en: 'When we call venv, we tell it the name we want to give to the project folder.
    The venv tool will create the project folder and populate it with the files needed
    to support the virtual environment:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 venv 时，我们告诉它我们想要为项目文件夹命名的名称。venv 工具将创建项目文件夹，并用支持虚拟环境的所需文件填充它：
- en: '![](img/53a206ad-0e8f-41fd-8489-e1b1b6c105fe.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/53a206ad-0e8f-41fd-8489-e1b1b6c105fe.png)'
- en: Each time we actually want to work inside the virtual environment, we should
    activate it. This will make whatever changes are needed, so that the contents
    of the virtual environment override the system-level defaults.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们实际上想在虚拟环境中工作，我们都应该激活它。这将使需要进行的任何更改，以便虚拟环境的内容覆盖系统级别的默认设置。
- en: Activating a virtual environment
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活虚拟环境
- en: 'To activate a virtual environment, we open a command line and go to the folder
    containing the virtual environment:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活虚拟环境，我们打开命令行并转到包含虚拟环境的文件夹：
- en: '![](img/76583a08-77b0-4b7a-a5e5-9c81fc460d7d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76583a08-77b0-4b7a-a5e5-9c81fc460d7d.png)'
- en: Then, execute the activation command. The specific activation command we're
    using depends on the operating system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行激活命令。我们使用的具体激活命令取决于操作系统。
- en: On most Unix-style systems, including Macintosh, we use the `$ source bin\activate`
    command (as shown in the preceding screengrab). On Windows, we run `Scripts\activate.bat`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Unix风格的系统上，包括Macintosh，我们使用`$ source bin\activate`命令（如前一个屏幕截图所示）。在Windows上，我们运行`Scripts\activate.bat`。
- en: 'We are operating inside an activated virtual environment, pip automatically
    knows it should manage packages for that environment:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在激活的虚拟环境中操作，pip自动知道它应该管理该环境的包：
- en: '![](img/cddec0aa-7780-4447-acd9-7f778c3efc2d.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cddec0aa-7780-4447-acd9-7f778c3efc2d.png)'
- en: pip in virtual environments
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟环境中的pip
- en: Initially, the virtual environment contains only the Python standard library
    and a couple of utilities, including pip itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，虚拟环境仅包含Python标准库和一些实用工具，包括pip本身。
- en: However, we can use `pip` to install the third-party packages that we're going
    to use on the project. When we looked at pip, you learned about its `--user` command-line
    option, which installs the package into a personal package library instead of
    the system library.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用`pip`安装项目中将使用的第三方包。当我们查看pip时，你学习了它的`--user`命令行选项，该选项将包安装到个人包库而不是系统库中。
- en: Installing the package into a personal package library, instead of the system
    library, is never necessary when installing into a virtual environment because
    the virtual environment has changed where the default installation location is.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当在虚拟环境中安装时，将包安装到个人包库而不是系统库中是永远不必要的，因为虚拟环境已经改变了默认安装位置。
- en: Now that everything is set up, we can begin work. We shouldn't delete any of
    the files or folders created by venv or pip. However, other than that, we're free
    to create files and folders as needed for our project. It is often useful to create
    a subdirectory to contain our working code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，我们可以开始工作了。我们不应该删除venv或pip创建的任何文件或文件夹。然而，除了这一点，我们可以根据项目需要自由创建文件和文件夹。创建一个子目录来包含我们的工作代码通常很有用。
- en: Now that you learned how to use the simple, but useful, venv tool to isolate
    our coding projects from each other and from most changes to our development system,
    let's turn to another useful best practice, docstrings.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用简单但有用的venv工具来隔离我们的编码项目，以及从我们的开发系统的大部分更改中隔离，让我们转向另一个有用的最佳实践，即文档字符串。
- en: Getting the most out of docstrings
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用文档字符串
- en: In this section, we will take a look at how to format docstrings for maximum
    readability and how to transform them into structured and formatted documentation.
    We're also going to look at how to make examples in the documentation testable
    so that the documentation is never out of date.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何格式化文档字符串以实现最佳可读性，以及如何将它们转换为结构化和格式化的文档。我们还将探讨如何使文档中的示例可测试，以确保文档始终保持最新。
- en: PEP 257 and docutils
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEP 257和docutils
- en: 'PEP 257 documents the expectations of Python programmers and tools with respect
    to docstrings. The basic rules are quite simple. These are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 257记录了Python程序员和工具对文档字符串的期望。基本规则相当简单。如下所示：
- en: The documentation is available at [https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可在[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)找到。
- en: Use triple quotes to delimit the docstring. Triple quotes are how Python expresses
    the idea of a multiline text string.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三引号来界定文档字符串。三引号是Python表达多行文本字符串概念的方式。
- en: The closing triple quotes should be on a line of their own if your docstring
    is longer than one line.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的文档字符串超过一行，则关闭的三引号应单独占一行。
- en: The first line should present a short description of the thing being documented,
    such as "return the distance between n-points a and b."
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行应提供一个关于所记录内容的简短描述，例如“返回点a和点b之间的距离。”
- en: 'After the first line, we can either end the docstring or insert a blank line,
    followed by a more in-depth description of the documented object, containing descriptions
    of parameters, attributes, usage semantics examples, and so on (refer to the following
    screenshot):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行之后，我们既可以结束文档字符串，也可以插入一个空白行，然后插入对所记录对象的更深入描述，包括参数、属性、使用语义示例等（参见图表）：
- en: '![](img/ec67a7e5-b391-45ba-abc0-09f0b02cea0e.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ec67a7e5-b391-45ba-abc0-09f0b02cea0e.png)'
- en: The reason for this layout is that many tools show the first line of the docstring
    as a popup, tooltip, or otherwise presented as a quick reference. The text after
    the blank line is presented when detailed documentation is requested. The docstring
    processing tools are smart about indentation, so it's safe and encouraged to indent
    our docstrings, so that they match up with the rest of the code block that they're
    describing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局的原因是许多工具会将文档字符串的第一行显示为弹出窗口、工具提示或以其他方式作为快速参考。当请求详细文档时，空白行之后的文本会被显示出来。文档字符串处理工具对缩进很智能，所以安全并鼓励我们对文档字符串进行缩进，以便它们与它们所描述的代码块的其他部分相匹配。
- en: Those basic rules are all that are required to make our docstrings interact
    well with Python's `pydoc` and help tools with IDEs, and so on. But they don't
    give us any way of creating well-formatted standalone documentation. That's where
    Sphinx comes into play.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本规则是我们使文档字符串与 Python 的 `pydoc` 和帮助工具以及 IDE 等交互所必需的，但它们并没有给我们提供创建格式良好的独立文档的方法。这就是
    Sphinx 发挥作用的地方。
- en: Sphinx
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sphinx
- en: Sphinx is a tool that can process Python source code and standalone documentation
    files and generate nicely formatted documentation in a number of formats, notably
    HTML. Sphinx, like other Python documentation tools, recognizes a markup language
    called `reStructuredText`, which is intentionally readable and informative, even
    when its markup is presented as plaintext rather than being interpreted.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是一个工具，可以处理 Python 源代码和独立的文档文件，并以多种格式生成格式良好的文档，尤其是 HTML。Sphinx 与其他 Python
    文档工具一样，识别一种名为 `reStructuredText` 的标记语言，这种语言故意设计得易于阅读和提供信息，即使其标记以纯文本形式呈现而不是被解释。
- en: '`reStructuredText` can be found at the following link: [https://docs.python.org/devguide/documenting.html#reStructuredText-primer](https://docs.python.org/devguide/documenting.html#reStructuredText-primer).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`reStructuredText` 可以在以下链接找到：[https://docs.python.org/devguide/documenting.html#reStructuredText-primer](https://docs.python.org/devguide/documenting.html#reStructuredText-primer)。'
- en: reStructuredText documents are still readable in a simple text editor, but when
    we feed them through a tool such as Sphinx they make the end result richer. The
    reStructuredText syntax is based on the conventions that developed on the internet
    before actual rich text was widely available in email and real-time chat.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText 文档在简单的文本编辑器中仍然可读，但当我们通过像 Sphinx 这样的工具处理它们时，最终结果会更加丰富。reStructuredText
    语法基于在电子邮件和实时聊天中实际富文本广泛可用之前在互联网上发展起来的约定。
- en: So, for example, words are emphasized by putting an asterisk (`*text*`) at each
    end and emphasized further by making that into two asterisks (`**text**`). Paragraphs
    are marked by placing a blank line between them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单词通过在每个端点放置一个星号（`*text*`）来强调，并通过将其变成两个星号（`**text**`）来进一步强调。段落通过在它们之间放置一个空白行来标记。
- en: There are syntaxes for lists, headings, and so on, all plainly readable in text
    mode. The syntax is nicely described in the Python developer's guide, but we're
    going to concentrate on a few bits of markup that do a lot to enhance the documentation
    for modules and packages. We actually saw one of those bits of markup earlier.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、标题等语法在文本模式下都很容易阅读。这些语法在 Python 开发者指南中有很好的描述，但我们将集中讨论一些可以大大增强模块和包文档的标记。我们实际上之前已经看到了这些标记之一。
- en: When our docstrings make reference to a local variable, such as a function parameter,
    that reference should be enclosed in asterisks to emphasize it and make it distinct
    from the normal text of the documentation. The names of modules, classes, functions,
    methods, attributes, exceptions, global variables, and constants should all be
    marked properly, so that Sphinx can cross-reference them and create links to their
    documentation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的文档字符串引用局部变量，例如函数参数时，该引用应该用星号括起来以强调它，并使其与文档的正常文本区分开来。模块、类、函数、方法、属性、异常、全局变量和常量的名称都应该正确标记，以便
    Sphinx 可以交叉引用它们并创建到其文档的链接。
- en: 'All of these object types share a similar syntax, which is that we put a type
    identifying keyword between colons, immediately followed by the name of the object
    in back quotes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对象类型都共享类似的语法，即我们在冒号之间放置一个类型标识关键字，紧接着是对象名称，用反引号括起来：
- en: '![](img/b6a50fec-5b59-4ee3-855c-e3780d4e1051.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6a50fec-5b59-4ee3-855c-e3780d4e1051.png)'
- en: 'As you saw in the preceding example with classes and methods, we used the keywords
    class for `classes` and `meth` for methods. Other keywords available are: `mod`
    for modules, `func` for functions, `attr` for attributes, `data` for variables,
    and `const` for constants.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s enough reStructuresText syntax to make a big difference in the quality
    of our documentation. So, we''re going to leave it there and go on to talk about
    how to actually use the Sphinx tool. If it''s not already installed, we can install
    it using `pip`, as shown in the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sphinx can do a lot more, so it's worth working through the tutorial on
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.sphinx-doc.org/en/stable/tutorial.html](https://www.sphinx-doc.org/en/stable/tutorial.html).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: It's quite nice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For our own purposes though, all we're interested in is turning docstrings into
    HTML. So, we'll work through that process in the next sub-section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Turning docstrings into HTML
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to generate HTML documentation for our example package, which is
    just a docstring example. We start by going to the directory that contains our
    package directory. Once there, we run `sphinx-quickstart` to set things up.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58f0e7e-3c9b-4145-b352-b24e3edd85a8.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that `sphinx-quickstart` asks is what the root path for the
    documentation should be. I find that it works well to use a folder called `docs`
    for this, so I suggest typing in `docs` for the root path:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57a68d82-89a0-487c-beda-11827c630f93.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'The `sphinx-quickstart` command will ask several more questions, which we can
    answer as we like, and then eventually it will ask if we want to enable the autodoc
    plugin; we will enable it by entering yes (`y`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba5c2263-90ba-4736-933e-a24f5b7c26aa.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: 'The rest of the questions are not so important for our purposes. After answering
    all the questions, the `sphinx-quickstart` command is completed as shown in the
    following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7e22da1-93c7-4d6d-9130-9611452a901f.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Once `sphinx-quickstart` is completed, we''ll want to run `sphinx-apidoc -o`
    with our directory to automatically generate Sphinx or Sphinx source files describing
    our package:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7e4c475-ee44-4405-aad8-89355a0be4ab.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Our docstrings are extracted and incorporated into these source files.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we want to generate the HTML we can construct it by running `make
    html` from the command line. Sphinx will translate its source files, including
    the ones automatically generated by `sphinx-apidoc` into HTML and store the result
    in the build directory that we specified when we were going through the `sphinx-quickstart`
    questions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'If we edit our source code and want to update the HTML documentation, we can
    usually do it simply by running the following command again:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we''ve made major changes to the package structure, we''ll need to run the
    `sphinx-apidoc` command again as well:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, Sphinx can be used as a documentation compiler, which turns our docstrings
    source code into HTML-compiled code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Using doctest to test documentation examples
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Including examples of use in our docstrings is common, but if we're not careful,
    those examples can get left behind when the code changes, and the wrong documentation
    is worse than no documentation. Fortunately, we have a tool that can check whether
    the documentation agrees with the code by running the examples from our documentation
    and seeing what happens. That tool is called **doctest**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable doctest to recognize our examples as things it can test, all we have
    to do is include the Python interactive shell prompt into our example. In the
    simplest and most common case, that just means putting a `>>>` symbol in front
    of each statement, as shown in the following screenshot. For multi-line statements,
    we prefix the continuation line with a `...` symbol:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6dd6e73d-25de-4916-bc5a-5373f2ad476b.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: After each statement, we should write down the expected result of the statement,
    written the same way the interactive shell would write it. In other words, if
    we copy and paste directly from the interactive shell, we've created an example
    that doctest can recognize. So, writing doctest is pretty straightforward.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: There's a decent chance of writing a doctest into our docstrings, even if we
    didn't know the doctest tool exists. As an added bonus, Sphinx recognizes doctest
    and formats it appropriately too. So, if we're going to include code examples
    in our docstrings, the way to do it is explained in the following section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Testing examples using doctest
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the code example using doctest, we just need to run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will get the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe6cd367-a947-47f3-9709-ce3a3d8a69bf.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Having doctest run all the examples in a file and report back whether they worked
    is easy. We just run the doctest utility from the command line and tell it which
    files we were interested in. The `-v` option in the command makes it pull out
    extra information, which isn't necessary, but often is helpful.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: All we see in the preceding example is a lack of error messages rather than
    any confirmation that everything worked or is tested.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways of running doctests including a Sphinx plugin that sphinx-quickstart
    asks us whether we want. It's also possible to integrate doctests into a test
    suite for Python's standard unit test library, or to use an integrated test runner
    called nos to find an excuse to execute them; doctests directly will do for our
    purposes in such cases, though.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: What it means when a code example fails
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, what happens if a doctest fails, but after looking at it we see that the
    documentation and example are actually correct? Well, that means our code is incorrect.
    Believe it or not, this is a very good thing. I don't mean that having an error
    is a good thing, but that error was there whether we found it or not. Finding
    it and having a test on hand that will let us check whether we've succeeded in
    fixing it, though, is definitely good.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: So, doctest ties our code and documentation together, so that they stay synchronized
    and serve to double-check each other. That's a very useful docstring trick.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，doctest将我们的代码和文档联系起来，确保它们保持同步并相互校验。这是一个非常实用的文档字符串技巧。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about writing readable code, version control to
    keep track of our code, and about the venv tool and the isolated virtual environments
    it creates. You learned how to format our docstrings to take advantage of automated
    tools, such as IDEs and the Sphinx documentation compiler. You also learned about
    writing examples into our documentation and how to use the doctest tool to check
    whether the examples and code are synchronized
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写可读的代码，使用版本控制来跟踪我们的代码，以及venv工具及其创建的隔离虚拟环境。你学习了如何格式化我们的文档字符串以利用自动化工具，例如IDE和Sphinx文档编译器。你还学习了如何在我们的文档中编写示例，以及如何使用doctest工具来检查示例和代码是否同步
- en: In the next chapter, you'll get to learn how to turn a package into a program
    that can be run from the command line.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将一个包转换成一个可以从命令行运行的程序。
