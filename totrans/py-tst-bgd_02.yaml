- en: 'Chapter 2. Doctest: The Easiest Testing Tool'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*This chapter will introduce you to a fantastic tool called doctest. Doctest
    is a program that ships with Python that lets you write down what you expect from
    your code in a way that''s easy for both people and computers to read. Doctest
    files can often be created just by copying the text out of a Python interactive
    shell and pasting it into a file. Doctest will often be the fastest and easiest
    way to write tests for your software.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the doctest language and syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write doctests embedded in text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write doctests embedded in Python docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doctest will be the mainstay of your testing toolkit. You'll be using it for
    tests, of course, but also for things that you may not think of as tests right
    now. For example, program specifications and API documentation both benefit from
    being written as doctests and checked alongside your other tests.
  prefs: []
  type: TYPE_NORMAL
- en: Like program source code, doctest tests are written in plain text. Doctest extracts
    the tests and ignores the rest of the text, which means that the tests can be
    embedded in human-readable explanations or discussions. This is the feature that
    makes doctest so suitable for non-classical uses such as program specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating and running your first doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create a simple doctest, to demonstrate the fundamentals of using doctest.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new text file in your editor, and name it `test.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following text into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now run the doctest. The details of how we do that depend on which version
    of Python we're using. At the command prompt, change to the directory where you
    saved `test.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are using Python 2.6 or higher, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using python 2.5 or lower, the above command may seem to work, but
    it won't produce the expected result. This is because Python 2.6 is the first
    version in which doctest looks for test file names on the command line when you
    invoke it this way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''re using an older version of Python, you can run your doctest by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the test is run, you should see output as shown in the following screen:![Time
    for action – creating and running your first doctest](img/8846_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wrote a doctest file that describes a couple of arithmetic operations, and
    executed it to check whether Python behaved as the tests said it should. You ran
    the tests by telling Python to execute doctest on the files that contained the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Python's behavior differed from the tests because according to
    the tests, three times three equals ten! However, Python disagrees on that. As
    doctest expected one thing and Python did something different, doctest presented
    you with a nice little error report showing where to find the failed test, and
    how the actual result differed from the expected result. At the bottom of the
    report, is a summary showing how many tests failed in each file tested, which
    is helpful when you have more than one file containing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, doctest files are for computer and human consumption. Try to write
    the test code in a way that human readers can easily understand, and add in plenty
    of plain language commentary.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might have guessed from looking at the previous example: doctest recognizes
    tests by looking for sections of text that look like they''ve been copied and
    pasted from a Python interactive session. Anything that can be expressed in Python
    is valid within a doctest.'
  prefs: []
  type: TYPE_NORMAL
- en: Lines that start with a `>>>` prompt are sent to a Python interpreter. Lines
    that start with a `...` prompt are sent as continuations of the code from the
    previous line, allowing you to embed complex block statements into your doctests.
    Finally, any lines that don't start with `>>>` or `...`, up to the next blank
    line or `>>>` prompt, represent the output expected from the statement. The output
    appears as it would in an interactive Python session, including both the return
    value and the one printed to the console. If you don't have any output lines,
    doctest assumes it to mean that the statement is expected to have no visible result
    on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest ignores anything in the file that isn't part of a test, which means
    that you can place explanatory text, HTML, line-art diagrams, or whatever else
    strikes your fancy in between your tests. We took advantage of that in the previous
    doctest, to add an explanatory sentence before the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – writing a more complex test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll write another test (you can add it to `test.txt` if you like) which shows
    off most of the details of doctest syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following text into your doctest file (`test.txt`), separated from
    the existing tests by at least one blank line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Think about it for a moment: What does this do? Do you expect the test to pass,
    or to fail?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run doctest on the test file, just as we discussed before. Because we added
    the new tests to the same file containing the tests from before, we still see
    the notification that three times three does not equal ten. Now, though, we also
    see that five tests were run, which means our new tests ran and succeeded.![Time
    for action – writing a more complex test](img/8846_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As far as doctest is concerned, we added three tests to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The first one says that when we `import sys`, nothing visible should happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test says that when we define the `test_write` function, nothing
    visible should happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third test says that when we call the `test_write` function, **Hello** and
    **True** should appear on the console, in that order, on separate lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since all three of these tests pass, doctest doesn't bother to say much about
    them. All it did was increase the number of tests reported at the bottom from
    two to five.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That's all well and good for testing that things work as expected, but it is
    just as important to make sure that things fail when they're supposed to fail.
    Put another way; sometimes your code is supposed to raise an exception, and you
    need to be able to write tests that check that behavior as well.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, doctest follows nearly the same principle in dealing with exceptions,
    that it does with everything else; it looks for text that looks like a Python
    interactive session. That means it looks for text that looks like a Python exception
    report and traceback, matching it against any exception that gets raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Doctest does handle exceptions a little differently from other tools. It doesn''t
    just match the text precisely and report a failure if it doesn''t match. Exception
    tracebacks tend to contain many details that are not relevant to the test, but
    which can change unexpectedly. Doctest deals with this by ignoring the traceback
    entirely: it''s only concerned with the first line—**Traceback (most recent call
    last)**—which tells it that you expect an exception, and the part after the traceback,
    which tells it which exception you expect. Doctest only reports a failure if one
    of these parts does not match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s helpful for a second reason as well: manually figuring out what the
    traceback would look like, when you''re writing your tests would require a significant
    amount of effort, and would gain you nothing. It''s better to simply omit them.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – expecting an exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is yet another test that you can add to `test.txt`, this time testing some
    code that ought to raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following text into your doctest file (Please note that the last
    line of this text has been wrapped due to the constraints of the book''s format,
    and should be a single line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The test is supposed to raise an exception, so it will fail if it doesn''t
    raise the exception, or if it raises the wrong exception. Make sure you have your
    mind wrapped around that: if the test code executes successfully, the test fails,
    because it expected an exception.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests using doctest and the following screen will be displayed:![Time
    for action – expecting an exception](img/8846_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Python doesn't allow a function to contain both yield statements and return
    statements with values, having the test to define such a function caused an exception.
    In this case, the exception was a `SyntaxError` with the expected value. As a
    result, doctest considered it a match with the expected output, and thus the test
    passed. When dealing with exceptions, it is often desirable to be able to use
    a wildcard matching mechanism. Doctest provides this facility through its ellipsis
    directive, which we'll discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting blank lines in the output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Doctest uses the first blank line to identify the end of the expected output.
    So what do you do, when the expected output actually contains a blank line?
  prefs: []
  type: TYPE_NORMAL
- en: Doctest handles this situation by matching a line that contains only the text
    `<BLANKLINE>` in the expected output, with a real blank line in the actual output.
  prefs: []
  type: TYPE_NORMAL
- en: Using directives to control doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the default behavior of doctest makes writing a particular test inconvenient.
    That's where doctest directives come to our rescue. Directives are specially formatted
    comments that you place after the source code of a test, which tell doctest to
    alter its default behavior in some way.
  prefs: []
  type: TYPE_NORMAL
- en: A directive comment begins with `# doctest:`, after which comes a comma-separated
    list of options, that either enable or disable various behaviors. To enable a
    behavior, write a `+` (plus symbol) followed by the behavior name. To disable
    a behavior, white a `–` (minus symbol) followed by the behavior name.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring part of the result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's fairly common that only part of the output of a test is actually relevant
    to determining whether the test passes. By using the `+ELLIPSIS` directive, you
    can make doctest treat the text `...` (called an ellipsis) in the expected output
    as a wildcard, which will match any text in the output.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an ellipsis, doctest will scan ahead until it finds text matching
    whatever comes after the ellipsis in the expected output, and continue matching
    from there. This can lead to surprising results such as an ellipsis matching against
    a 0-length section of the actual output, or against multiple lines. For this reason,
    it needs to be used thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – using ellipsis in tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll use the ellipsis in a few different tests, to get a better feel for what
    it does and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following text into your doctest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests using doctest and the following screen is displayed:.![Time for
    action – using ellipsis in tests](img/8846_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of these tests would pass without the ellipsis. Think about that, and then
    try making some changes and see if they produce the results you expect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just saw how to enable ellipsis matching. In addition, we saw a couple of
    variations on where the doctest directive comment can be placed, including on
    a block continuation line by itself.
  prefs: []
  type: TYPE_NORMAL
- en: We got a chance to play with the ellipsis a little bit, and hopefully saw why
    it should be used carefully. Look at that last test. Can you imagine any output
    that wasn't an ISO-formatted time stamp, but that it would match anyway?
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring whitespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, whitespace (spaces, tabs, newlines, and their ilk) are more trouble
    than they're worth. Maybe you want to be able to break a single line of expected
    output across several lines in your test file, or maybe you're testing a system
    that uses lots of whitespace but doesn't convey any useful information with it.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest gives you a way to "normalize" whitespace, turning any sequence of whitespace
    characters, in both the expected output and in the actual output, into a single
    space. It then checks whether these normalized versions match.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – normalizing whitespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll write a couple tests that demonstrate how whitespace normalization works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following text into your doctest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests using doctest and the following screen is displayed:![Time for
    action – normalizing whitespace](img/8846_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how one of the tests inserts extra whitespace in the expected output,
    while the other one ignores extra whitespace in the actual output. When you use
    `+NORMALIZE_WHITESPACE`, you gain a lot of flexibility with regard to how things
    are formatted in the text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skipping an example entirely
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On some occasions, doctest would recognize some text as an example to be checked,
    when in truth you want it to be simply text. This situation is rarer than it might
    at first seem, because usually there's no harm in letting doctest check everything
    it can. In fact, it is usually helpful to have doctest check everything it can.
    For those times when you want to limit what doctest checks, though, there's the
    `+SKIP` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – skipping tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an example of how to skip a test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following text into your doctest file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests using doctest and the following screen will be displayed:![Timedoctest,
    controllingexample, skipping for action – skipping tests](img/8846_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the test didn't fail, and that the number of tests that were run
    did not change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The skip directive transformed what would have been a test, into plain text(as
    far as doctest is concerned). Doctest never ran the test, and in fact never counted
    it as a test at all.
  prefs: []
  type: TYPE_NORMAL
- en: There are several situations where skipping a test might be a good idea. Sometimes,
    you have a test which doesn't pass (which you know doesn't pass), but which simply
    isn't something that should be addressed at the moment. Using the `skip` directive
    lets you ignore the test for a while. Sometimes, you have a section of human readable
    text that looks like a test to the doctest parser, even though it's really only
    for human consumption. The `skip` directive can be used to mark that code as not
    for actual testing.
  prefs: []
  type: TYPE_NORMAL
- en: Other doctest directives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a number of other directives that can be issued to adjust the behavior
    of doctest. They are fully documented at [http://docs.python.org/library/doctest.html#option-flags-and-directives](http://docs.python.org/library/doctest.html#option-flags-and-directives),
    but here is a quick overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+DONT_ACCEPT_TRUE_FOR_1`, which makes doctest treat `True` and `1` as different
    values, instead of treating them as matching as it normally does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+DONT_ACCEPT_BLANKLINE`, which makes doctest forget about the special meaning
    of `<BLANKLINE>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+IGNORE_EXCEPTION_DETAIL`, which makes doctest treat exceptions as matches
    if the exception type is the same, regardless of whether the rest of the exception
    matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+REPORT_UDIFF`, which makes doctest use `unified diff` format when it displays
    a failed test. This is useful if you are used to reading the `unified diff` format,
    which is by far the most common diff format within the open source community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+REPORT_CDIFF`, which makes doctest use `context diff` format when it displays
    a failed test. This is useful if you are used to reading the `context diff` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+REPORT_NDIFF`, which makes doctest use `ndiff` format when it displays a
    failed test. This is usefull if you are used to reading the `ndiff` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+REPORT_ONLY_FIRST_FAILURE` makes doctest avoid printing out failure reports
    on those tests after it is applied, if a failure report has already been printed.
    The tests are still executed, and doctest still keeps track of whether they failed
    or not. Only the report is changed by using this flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When doctest is running the tests from text files, all the tests from the same
    file are run in the same execution scope. That means that if you import a module
    or bind a variable in one test, that module or variable is still available in
    later tests. We took advantage of this fact several times in the tests written
    so far in this chapter: the `sys` module was only imported once, for example,
    although it was used in several tests.'
  prefs: []
  type: TYPE_NORMAL
- en: That behavior is not necessarily beneficial, because tests need to be isolated
    from each other. We don't want them to contaminate each other, because if a test
    depends on something that another test does, or if it fails because of something
    that another test does, those two tests are in some sense turned into one test
    that covers a larger section of your code. You don't want that to happen, because
    knowing which test has failed doesn't give you as much information about what
    went wrong and where it happened.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we give each test its own execution scope? There are a few ways
    to do it. One would be to simply place each test in its own file, along with whatever
    explanatory text that is needed. This works beautifully, but running the tests
    can be a pain unless you have a tool to find and run all of them. We'll talk about
    one such tool (called nose) later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to give each test its own execution scope, is to define each test
    within a function, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By doing that, the only thing that ends up in the shared scope is the test function
    (named `test1` here). The `frob` module, and any other names bound inside the
    function, are isolated.
  prefs: []
  type: TYPE_NORMAL
- en: The third way is to exercise caution with the names you create, and be sure
    to set them to known values at the beginning of each test section. In many ways
    this is the easiest approach, but it's also the one that places the most burden
    on you, because you have to keep track of what's in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Why does doctest behave this way, instead of isolating tests from each other?
    Doctest files are intended not just for computers to read, but also for humans.
    They often form a sort of narrative, flowing from one thing to the next. It would
    break the narrative to be constantly repeating what came before. In other words,
    this approach is a compromise between being a document and being a test framework,
    a middle ground that works for both humans and computers.
  prefs: []
  type: TYPE_NORMAL
- en: The other framework that we study in depth in this book (called simply unittest)
    works at a more formal level, and enforces the separation between tests.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – doctest syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no answer key for these questions. Try your answers in doctest and
    see if you're right!
  prefs: []
  type: TYPE_NORMAL
- en: How does doctest recognize the beginning of a test expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does doctest know where the expected output of a text expression begins
    and ends?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you tell doctest that you want to break a long expected output across
    multiple lines, even though that's not how the test actually outputs it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which parts of an exception report are ignored by doctest?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you bind a variable in a test file, what code can "see" that variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we care what code can see a variable created by a test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we make doctest not care what a section of output contains?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero – from English to doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time to stretch your wings a bit! I'm going to give you a description of a single
    function, in English. Your job is to copy the description into a new text file,
    and then add tests that describe all the requirements in a way in which the computer
    can understand and check.
  prefs: []
  type: TYPE_NORMAL
- en: Try to make the doctests that are not just for the computer. Good doctests tend
    to clarify things for human readers as well. By and large, that means that you
    present them to human readers as examples interspersed with the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, here is the English description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I'll give you a hint and point out that the last sentence—about the function
    being slow—isn't really testable. As computers get faster, any test you write
    that depends on an arbitrary definition of "slow" will eventually fail. Also,
    there's no good way to test the difference between a slow function and a function
    stuck in an infinite loop, so there's no point in trying. If you find yourself
    needing to do that, it's best to back off and try a different solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not being able to tell whether a function is stuck or just slow is called the
    Halting Problem by computer scientists. We know that it can't be solved unless
    we someday discover a fundamentally better kind of computer. Faster computers
    won't do the trick, and neither will quantum computers, so don't hold your breath!
  prefs: []
  type: TYPE_NORMAL
- en: Embedding doctests in Python docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doctests aren't confined to simple text files. You can put doctests into Python's
    docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to do that? There are a couple of reasons. First of all,
    docstrings are an important part of the usability of Python code (but only if
    they tell the truth). If the behavior of a function, method, or module changes
    and the docstring doesn't get updated, then the docstring becomes misinformation,
    and a hindrance rather than a help. If the docstring contains a couple of doctest
    examples, then the out-of-date docstrings can be located automatically. Another
    reason for placing doctest examples into docstrings is simply that it can be very
    convenient. This practice keeps the tests, documentation and code all in the same
    place, where it can all be located easily.
  prefs: []
  type: TYPE_NORMAL
- en: If the docstring becomes home to too many tests, this can destroy its utility
    as documentation. This should be avoided; if you find yourself with so many tests
    in the docstrings that they aren't useful as a quick reference, move most of them
    to a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – embedding a doctest in a docstring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll embed a test right inside the Python source file that it tests, by placing
    it inside a docstring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `test.py` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the command prompt, change to the directory where you saved `test.py` and
    then run the tests by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier before, if you have an older version of Python, this isn't
    going to work for you. Instead, you need to type `python -c "__import__('doctest').testmod(__import__('test'))"`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If everything worked, you shouldn''t see anything at all. If you want some
    confirmation that doctest is doing something, turn on verbose reporting by changing
    the command to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For older versions of Python, instead use `python -c "__import__('doctest').testmod(__import__('test'),
    verbose=True)"`
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You put the doctest right inside the docstring of the function it was testing.
    This is a good place for tests that also show a user how to do something. It's
    not a good place for detailed, low-level tests (the above example, which was quite
    detailed for illustrative purposes, is skirting the edge of being too detailed),
    because docstrings need to serve as API documentation. You can see the reason
    for this just by looking back at the example, where the doctests take up most
    of the room in the docstring, without telling the readers any more than they would
    have learned from a single test.
  prefs: []
  type: TYPE_NORMAL
- en: Any test that will serve as good API documentation is a good candidate for including
    in the docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of a raw string for the docstring (denoted by the `r` character
    before the first triple-quote). Using raw strings for your docstrings is a good
    habit to get into, because you usually don't want escape sequences—e.g. `\n` for
    newline—to be interpreted by the Python interpreter. You want them to be treated
    as text, so that they are correctly passed on to doctest.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedded doctests can accept exactly the same directives as doctests in text
    files can, using exactly the same syntax. Because of this, all of the doctest
    directives that we discussed before can also be used to affect the way embedded
    doctests are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Execution scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Doctests embedded in docstrings have a somewhat different execution scope than
    doctests in text files do. Instead of having a single scope for all of the tests
    in the file, doctest creates a single scope for each docstring. All of the tests
    that share a docstring, also share an execution scope, but they're isolated from
    tests in other docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: The separation of each docstring into its own execution scope often means that
    we don't need to put much thought into isolating doctests, when they're embedded
    in docstrings. That is fortunate, since docstrings are primarily intended for
    documentation, and the tricks needed to isolate the tests might obscure the meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it in practice: an AVL tree'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll walk step-by-step through the process of using doctest to create a testable
    specification for a data structure called an AVL Tree. An AVL tree is a way to
    organize key-value pairs, so that they can be quickly located by key. In other
    words, it's a lot like Python's built-in dictionary type. The name AVL references
    the initials of the people who invented this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, an AVL tree organizes the keys that are stored in it into
    a tree structure, with each key having up to two **child** keys—one **child**
    key that is less than the **parent** key by comparison, and one that is more.
    In the following picture, the key **Elephant** has two child keys, **Goose** has
    one, and **Aardvark** and **Frog** both have none.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it in practice: an AVL tree](img/8846_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The AVL tree is special, because it keeps one side of the tree from getting
    much taller than the other, which means that users can expect it to perform reliably
    and efficiently no matter what. In the previous image, an AVL tree would reorganize
    to stay balanced if **Frog** gained a child.
  prefs: []
  type: TYPE_NORMAL
- en: We'll write tests for an AVL tree implementation here, rather than writing the
    implementation itself. Therefore, we'll elaborate over the details of *how* an
    AVL tree works, in favor of looking at what it should do when it works right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to know more about AVL Trees, you will find many good references
    on the Internet. Wikipedia''s entry on the subject is a good place to start with:
    [http://en.wikipedia.org/wiki/AVL_tree](http://en.wikipedia.org/wiki/AVL_tree).'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a plain language specification, and then interject tests between
    the paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't have to actually type all of this into a text file; it is here for
    you to read and to think about. It's also available in the code download that
    accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: English specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to describe what the desired result should be, in normal language.
    This might be something that you do for yourself, or something that somebody else
    does for you. If you're working for somebody, hopefully you and your employer
    can sit down together and work this part out.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there's not much to work out, because AVL Trees have been fully
    described for decades. Even so, the description here isn't quite like one you'd
    find anywhere else. This capacity for ambiguity is exactly the reason why a plain
    language specification isn't good enough. We need an unambiguous specification,
    and that's exactly what the tests in a doctest file can give us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text goes in a file called `AVL.txt`, (which you can find in
    its final form in the accompanying code archive. At this stage of the process,
    the file contains only the normal language specification.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Node data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first three paragraphs of the specification describe the member variables
    of a AVL tree node, and tell us what the valid values for the variables are. They
    also tell us how tree height should be measured and define what a balanced tree
    means. It's our job now to take up those ideas, and encode them into tests that
    the computer can eventually use to check our code.
  prefs: []
  type: TYPE_NORMAL
- en: We could check these specifications by creating a node and then testing the
    values, but that would really just be a test of the constructor. It's important
    to test the constructor, but what we really want to do is to incorporate checks
    that the node variables are left in a valid state into our tests of each member
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that end, we''ll define a function that our tests can call to check that
    the state of a node is valid. We''ll define that function just after the third
    paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that this test is written as if the AVL tree implementation already existed.
    It tries to import an `avl_tree` module containing an `AVL` class, and it tries
    to use the `AVL` class is specific ways. Of course, at the moment there is no
    `avl_tree` module, so the test will fail. That's as it should be. All that the
    failure means is that, when the time comes to implement the tree, we should do
    so in a module called `avl_tree`, with contents that function as our test assumes.
    Part of the benefit of testing like this is being able to test-drive your code
    before you even write it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't actually call those functions yet. They aren't tests,
    per se, but tools that we'll use to simplify writing tests. We define them here,
    rather than in the Python module that we're going to test, because they aren't
    conceptually part of the tested code, and because anyone who reads the tests will
    need to be able to see what the helper functions do.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fourth paragraph describes the constructor for an AVL node: The node constructor
    takes either a pair of parameters representing a key and a value, or a `dict`
    object representing the key-value pairs with which to initialize a new tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor has two possible modes of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: it can either create a single initialized node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'or it can create and initialize a whole tree of nodes. The test for the single
    node mode is easy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other mode of the constructor is a problem, because it is almost certain
    that it will be implemented by creating an initial tree node and then calling
    its set method to add the rest of the nodes. Why is that a problem? Because we
    don''t want to test the set method here: this test should be focused entirely
    on whether the constructor works correctly, *when everything it depends on works*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In other words, the tests should be able to assume that everything outside of
    the specific chunk of code being tested works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: However, that's not always a valid assumption. So, how can we write tests for
    things that call on code outside of what's being tested?
  prefs: []
  type: TYPE_NORMAL
- en: There is a solution for this problem, about which we'll learn in Chapter 4\.
    For now, we'll just leave the second mode of operation of the constructor untested.
  prefs: []
  type: TYPE_NORMAL
- en: Recalculate height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `recalculate_height` method is described in the fifth paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: To test it, we'll need a tree for it to operate on, and we don't want to use
    the second mode of the constructor to create it. After all, that mode isn't tested
    at all yet, and even if it were, we want this test to be independent of it. We
    would prefer to make the test entirely independent of the constructor, but in
    this case we need to make a small exception to the rule(since it's difficult to
    create an object without calling its constructor in some way).
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do is define a function that builds a specific tree and returns it.
    This function will be useful in several of our later tests as well. Using this
    function, testing `recalculate_height` will be easy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make_test_tree` function builds a tree by manually constructing each part
    of it and hooking it together into a structure that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recalculate height](img/8846_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make deletable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can't delete a node that has children, because that would leave the node's
    children disconnected from the rest of the tree. If we delete the **Elephant**
    node from the bottom of the tree, what do we do about **Aardvark**, **Goose**,
    and **Frog**? If we delete **Goose**, how do we find **Frog** afterwards?
  prefs: []
  type: TYPE_NORMAL
- en: '![Make deletable](img/8846_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The way around that is to have the node swap places with it's largest leaf descendant
    on the left side (or its smallest leaf descendant on the right side, but we'll
    not do it that way).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll test this by using the same `make_test_tree` function that we defined
    before to create a new tree to work on, and then checking that `make_deletable`
    swaps correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Something to notice here is that the `make_deletable` function isn't supposed
    to delete the node that it's called on. It's supposed to move that node into a
    position where it could be safely deleted. It must do this reorganization of the
    tree, without violating any of the constraints that define an AVL tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two rotate functions perform a somewhat tricky manipulation of the links
    in a tree. You probably found the plain language description of what they do,
    a bit confusing. This is one of those times when a little bit of code makes a
    whole lot more sense than any number of sentences.
  prefs: []
  type: TYPE_NORMAL
- en: While tree rotation is usually defined in terms of rearranging the links between
    nodes in the tree, we'll check whether it worked by looking at the values (rather
    than by looking directly at the left and right links). This allows the implementation
    to swap the contents of nodes—rather than the nodes themselves—when it wishes.
    After all, it's not important to the specification which operation happens, so
    we shouldn't rule out a perfectly reasonable implementation choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the test code for rotation just creates a tree and verifies
    that it looks like we expect it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a tree to work with, we try a rotation operation and check that
    the result still looks like it should:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we rotate back in the other direction, and check that the final result
    is the same as the original tree, as we expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Locating a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `locate` method is expected to return a node, or raise a `KeyError` exception,
    depending on whether the key exists in the tree or not. We'll use our specially
    built tree again, so that we know exactly what the tree's structure looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `locate` method is intended to facilitate insertion, deletion, and lookup
    of values based on their keys, but it's not a high-level interface. It returns
    a node object, because it's easy to implement the higher-level operations, if
    you have a function the finds the right node for you.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the rest of the specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the second mode of the constructor, testing the rest of the specification
    involves testing code that depends on things outside of itself, which we'll cover
    in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the syntax of doctest, and went through several examples describing
    how to use it. After that, we took a real-world specification for the AVL tree,
    and examined how to formalize it as a set of doctests, so that we could use it
    to automatically check the correctness of an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered doctest's default syntax, and the directives that alter
    it, how to write doctests in text files, how to write doctests in Python docstrings,
    and what it feels like to use doctest to turn a specification into tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about doctest, we're ready to talk about how to use doctest
    to do unit testing—which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
