- en: 'Chapter 2. Doctest: The Easiest Testing Tool'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. Doctest：最简单的测试工具
- en: '*This chapter will introduce you to a fantastic tool called doctest. Doctest
    is a program that ships with Python that lets you write down what you expect from
    your code in a way that''s easy for both people and computers to read. Doctest
    files can often be created just by copying the text out of a Python interactive
    shell and pasting it into a file. Doctest will often be the fastest and easiest
    way to write tests for your software.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章将向你介绍一个名为doctest的神奇工具。Doctest是Python附带的一个程序，它允许你以对人和计算机都容易阅读的方式写下你对代码的期望。Doctest文件通常可以通过从Python交互式外壳中复制文本并将其粘贴到文件中来创建。Doctest通常是编写软件测试最快、最简单的方式。*'
- en: 'In this chapter, we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn the doctest language and syntax
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习doctest语言和语法
- en: Write doctests embedded in text files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本文件中编写嵌入的doctests
- en: Write doctests embedded in Python docstrings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python文档字符串中编写嵌入的doctests
- en: Basic doctest
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本doctest
- en: Doctest will be the mainstay of your testing toolkit. You'll be using it for
    tests, of course, but also for things that you may not think of as tests right
    now. For example, program specifications and API documentation both benefit from
    being written as doctests and checked alongside your other tests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest将成为你的测试工具包中的主要工具。你当然会使用它来进行测试，但也会用于你现在可能不会认为是测试的事情。例如，程序规范和API文档都受益于以doctests的形式编写并在你的其他测试中一起检查。
- en: Like program source code, doctest tests are written in plain text. Doctest extracts
    the tests and ignores the rest of the text, which means that the tests can be
    embedded in human-readable explanations or discussions. This is the feature that
    makes doctest so suitable for non-classical uses such as program specifications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序源代码一样，doctest测试是用纯文本编写的。Doctest提取测试并忽略其余文本，这意味着测试可以嵌入在可读的解释或讨论中。这正是使doctest非常适合非经典用途（如程序规范）的功能。
- en: Time for action – creating and running your first doctest
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 创建和运行你的第一个doctest
- en: We'll create a simple doctest, to demonstrate the fundamentals of using doctest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的doctest，以演示使用doctest的基本原理。
- en: Open a new text file in your editor, and name it `test.txt`.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开一个新的文本文件，并将其命名为`test.txt`。
- en: 'Insert the following text into the file:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到文件中：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can now run the doctest. The details of how we do that depend on which version
    of Python we're using. At the command prompt, change to the directory where you
    saved `test.txt`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行doctest。我们如何运行它的细节取决于我们使用的Python版本。在命令提示符下，切换到保存`test.txt`的目录。
- en: 'If you are using Python 2.6 or higher, type:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Python 2.6或更高版本，输入以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using python 2.5 or lower, the above command may seem to work, but
    it won't produce the expected result. This is because Python 2.6 is the first
    version in which doctest looks for test file names on the command line when you
    invoke it this way.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是python 2.5或更低版本，上述命令可能看起来可以工作，但不会产生预期的结果。这是因为Python 2.6是第一个在以这种方式调用时在命令行上查找测试文件名的版本。
- en: 'If you''re using an older version of Python, you can run your doctest by typing:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是较旧的Python版本，你可以通过输入以下命令来运行你的doctest：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the test is run, you should see output as shown in the following screen:![Time
    for action – creating and running your first doctest](img/8846_02_01.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试运行时，你应该看到如下屏幕所示的输出：![动手实践 – 创建和运行你的第一个doctest](img/8846_02_01.jpg)
- en: '*What just happened?*'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You wrote a doctest file that describes a couple of arithmetic operations, and
    executed it to check whether Python behaved as the tests said it should. You ran
    the tests by telling Python to execute doctest on the files that contained the
    tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写了一个doctest文件，描述了一些算术运算，并执行它来检查Python是否像测试所说的那样表现。你是通过告诉Python在包含测试的文件上执行doctest来运行测试的。
- en: In this case, Python's behavior differed from the tests because according to
    the tests, three times three equals ten! However, Python disagrees on that. As
    doctest expected one thing and Python did something different, doctest presented
    you with a nice little error report showing where to find the failed test, and
    how the actual result differed from the expected result. At the bottom of the
    report, is a summary showing how many tests failed in each file tested, which
    is helpful when you have more than one file containing tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python 的行为与测试不同，因为根据测试，三乘三等于十！然而，Python 并不同意这一点。由于 doctest 预期的是一种情况而
    Python 做了不同的处理，doctest 向你展示了一个漂亮的错误报告，显示了失败测试的位置以及实际结果与预期结果之间的差异。报告底部是一个总结，显示了每个测试文件中失败的测试数量，当你有多个包含测试的文件时，这很有帮助。
- en: Remember, doctest files are for computer and human consumption. Try to write
    the test code in a way that human readers can easily understand, and add in plenty
    of plain language commentary.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，doctest 文件是供计算机和人类消费的。尽量以人类读者容易理解的方式编写测试代码，并添加大量的普通语言注释。
- en: The syntax of doctests
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doctests 的语法
- en: 'You might have guessed from looking at the previous example: doctest recognizes
    tests by looking for sections of text that look like they''ve been copied and
    pasted from a Python interactive session. Anything that can be expressed in Python
    is valid within a doctest.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从查看之前的示例中猜到了：doctest 通过寻找看起来像是从 Python 交互会话中复制粘贴的文本部分来识别测试。任何可以用 Python
    表达的内容都可以在 doctest 中使用。
- en: Lines that start with a `>>>` prompt are sent to a Python interpreter. Lines
    that start with a `...` prompt are sent as continuations of the code from the
    previous line, allowing you to embed complex block statements into your doctests.
    Finally, any lines that don't start with `>>>` or `...`, up to the next blank
    line or `>>>` prompt, represent the output expected from the statement. The output
    appears as it would in an interactive Python session, including both the return
    value and the one printed to the console. If you don't have any output lines,
    doctest assumes it to mean that the statement is expected to have no visible result
    on the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `>>>` 提示符开头的行会被发送到 Python 解释器。以 `...` 提示符开头的行作为上一行代码的延续，允许你将复杂的块语句嵌入到你的 doctests
    中。最后，任何不以 `>>>` 或 `...` 开头的行，直到下一个空白行或 `>>>` 提示符，代表从该语句期望得到的输出。输出将像在交互式 Python
    会话中一样显示，包括返回值和打印到控制台的内容。如果你没有输出行，doctest 假设该语句在控制台上没有可见的结果。
- en: Doctest ignores anything in the file that isn't part of a test, which means
    that you can place explanatory text, HTML, line-art diagrams, or whatever else
    strikes your fancy in between your tests. We took advantage of that in the previous
    doctest, to add an explanatory sentence before the test itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest 忽略文件中不属于测试的部分，这意味着你可以在测试之间放置解释性文本、HTML、行图或其他任何你喜欢的元素。我们在之前的 doctest
    中就利用了这一点，在测试本身之前添加了一个解释性句子。
- en: Time for action – writing a more complex test
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 编写一个更复杂的测试
- en: We'll write another test (you can add it to `test.txt` if you like) which shows
    off most of the details of doctest syntax.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写另一个测试（如果你喜欢，可以将其添加到 `test.txt` 文件中），展示 doctest 语法的大部分细节。
- en: 'Insert the following text into your doctest file (`test.txt`), separated from
    the existing tests by at least one blank line:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到你的 doctest 文件（`test.txt`）中，与现有测试至少隔一个空白行：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Think about it for a moment: What does this do? Do you expect the test to pass,
    or to fail?'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想想看：这会做什么？你期望测试通过，还是失败？
- en: Run doctest on the test file, just as we discussed before. Because we added
    the new tests to the same file containing the tests from before, we still see
    the notification that three times three does not equal ten. Now, though, we also
    see that five tests were run, which means our new tests ran and succeeded.![Time
    for action – writing a more complex test](img/8846_02_02.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前讨论的那样，在测试文件上运行 doctest。因为我们添加了新的测试到包含之前测试的同一文件中，所以我们仍然看到通知说三乘三不等于十。现在，尽管如此，我们还看到运行了五个测试，这意味着我们的新测试已经运行并成功。![行动时间
    – 编写一个更复杂的测试](img/8846_02_02.jpg)
- en: '*What just happened?*'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: As far as doctest is concerned, we added three tests to the file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就 doctest 而言，我们在文件中添加了三个测试。
- en: The first one says that when we `import sys`, nothing visible should happen.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试表示，当我们 `import sys` 时，不应该有任何可见的操作发生。
- en: The second test says that when we define the `test_write` function, nothing
    visible should happen.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试表示，当我们定义 `test_write` 函数时，不应该有任何可见的操作发生。
- en: The third test says that when we call the `test_write` function, **Hello** and
    **True** should appear on the console, in that order, on separate lines.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个测试说明，当我们调用`test_write`函数时，**Hello**和**True**应该按顺序出现在控制台上，每行一个。
- en: Since all three of these tests pass, doctest doesn't bother to say much about
    them. All it did was increase the number of tests reported at the bottom from
    two to five.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个测试都通过了，doctest对于它们并没有太多要说的。它所做的只是将底部报告的测试数量从两个增加到五个。
- en: Expecting exceptions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预期异常
- en: That's all well and good for testing that things work as expected, but it is
    just as important to make sure that things fail when they're supposed to fail.
    Put another way; sometimes your code is supposed to raise an exception, and you
    need to be able to write tests that check that behavior as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试预期中的行为是否正常，这当然很好，但同样重要的是要确保当预期失败时，确实会失败。换句话说；有时你的代码应该抛出一个异常，你需要能够编写测试来检查这种行为。
- en: Fortunately, doctest follows nearly the same principle in dealing with exceptions,
    that it does with everything else; it looks for text that looks like a Python
    interactive session. That means it looks for text that looks like a Python exception
    report and traceback, matching it against any exception that gets raised.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，doctest在处理异常时遵循了几乎与处理其他一切相同的原理；它寻找看起来像Python交互会话的文本。这意味着它寻找看起来像Python异常报告和回溯的文本，并将其与抛出的任何异常进行匹配。
- en: 'Doctest does handle exceptions a little differently from other tools. It doesn''t
    just match the text precisely and report a failure if it doesn''t match. Exception
    tracebacks tend to contain many details that are not relevant to the test, but
    which can change unexpectedly. Doctest deals with this by ignoring the traceback
    entirely: it''s only concerned with the first line—**Traceback (most recent call
    last)**—which tells it that you expect an exception, and the part after the traceback,
    which tells it which exception you expect. Doctest only reports a failure if one
    of these parts does not match.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest在处理异常方面与其他工具略有不同。它不仅仅精确匹配文本，如果匹配失败则报告失败。异常回溯通常包含许多与测试无关的细节，但这些细节可能会意外地改变。Doctest通过完全忽略回溯来处理这个问题：它只关心第一行——**Traceback
    (most recent call last)**——这告诉它你预期会有一个异常，以及回溯之后的部分，这告诉它你预期哪种异常。只有当这些部分之一不匹配时，Doctest才会报告失败。
- en: 'That''s helpful for a second reason as well: manually figuring out what the
    traceback would look like, when you''re writing your tests would require a significant
    amount of effort, and would gain you nothing. It''s better to simply omit them.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有另一个好处：当你编写测试时，手动确定回溯的外观需要大量的努力，而且不会带来任何好处。最好是简单地省略它们。
- en: Time for action – expecting an exception
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——预期异常
- en: This is yet another test that you can add to `test.txt`, this time testing some
    code that ought to raise an exception.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是你可以添加到`test.txt`中的另一个测试，这次测试的是应该抛出异常的代码。
- en: 'Insert the following text into your doctest file (Please note that the last
    line of this text has been wrapped due to the constraints of the book''s format,
    and should be a single line):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到你的doctest文件中（请注意，由于书籍格式的限制，这段文本的最后一行已被换行，应该是一行）：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The test is supposed to raise an exception, so it will fail if it doesn''t
    raise the exception, or if it raises the wrong exception. Make sure you have your
    mind wrapped around that: if the test code executes successfully, the test fails,
    because it expected an exception.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试应该抛出一个异常，所以如果它没有抛出异常，或者抛出了错误的异常，测试就会失败。请确保你理解这一点：如果测试代码执行成功，那么测试就会失败，因为它预期会有一个异常。
- en: Run the tests using doctest and the following screen will be displayed:![Time
    for action – expecting an exception](img/8846_02_03.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用doctest运行测试，以下屏幕将显示：![行动时间——预期异常](img/8846_02_03.jpg)
- en: '*What just happened?*'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Since Python doesn't allow a function to contain both yield statements and return
    statements with values, having the test to define such a function caused an exception.
    In this case, the exception was a `SyntaxError` with the expected value. As a
    result, doctest considered it a match with the expected output, and thus the test
    passed. When dealing with exceptions, it is often desirable to be able to use
    a wildcard matching mechanism. Doctest provides this facility through its ellipsis
    directive, which we'll discuss later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python不允许一个函数同时包含yield语句和带有值的return语句，因此测试定义这样的函数会导致异常。在这种情况下，异常是一个带有预期值的`SyntaxError`。因此，doctest将其视为与预期输出匹配，从而测试通过。在处理异常时，通常希望能够使用通配符匹配机制。Doctest通过其省略号指令提供这种功能，我们将在后面讨论。
- en: Expecting blank lines in the output
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预期输出中有空白行
- en: Doctest uses the first blank line to identify the end of the expected output.
    So what do you do, when the expected output actually contains a blank line?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest使用第一个空白行来识别预期输出的结束。那么，当预期输出实际上包含空白行时，您该怎么办？
- en: Doctest handles this situation by matching a line that contains only the text
    `<BLANKLINE>` in the expected output, with a real blank line in the actual output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest通过匹配预期输出中只包含文本`<BLANKLINE>`的行，与实际输出中的真实空白行进行匹配来处理这种情况。
- en: Using directives to control doctest
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指令控制doctest
- en: Sometimes, the default behavior of doctest makes writing a particular test inconvenient.
    That's where doctest directives come to our rescue. Directives are specially formatted
    comments that you place after the source code of a test, which tell doctest to
    alter its default behavior in some way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，doctest的默认行为使得编写特定的测试变得不方便。这就是doctest指令发挥作用的地方。指令是特殊格式的注释，您将其放置在测试的源代码之后，告诉doctest以某种方式更改其默认行为。
- en: A directive comment begins with `# doctest:`, after which comes a comma-separated
    list of options, that either enable or disable various behaviors. To enable a
    behavior, write a `+` (plus symbol) followed by the behavior name. To disable
    a behavior, white a `–` (minus symbol) followed by the behavior name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 指令注释以`# doctest:`开头，之后跟一个以逗号分隔的选项列表，这些选项可以启用或禁用各种行为。要启用一个行为，写一个`+`（加号符号）后跟行为名称。要禁用一个行为，写一个`–`（减号符号）后跟行为名称。
- en: Ignoring part of the result
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略部分结果
- en: It's fairly common that only part of the output of a test is actually relevant
    to determining whether the test passes. By using the `+ELLIPSIS` directive, you
    can make doctest treat the text `...` (called an ellipsis) in the expected output
    as a wildcard, which will match any text in the output.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出中只有一部分实际上与确定测试是否通过相关是很常见的。通过使用`+ELLIPSIS`指令，您可以使得doctest将预期输出中的文本`...`（称为省略号）视为通配符，这将匹配输出中的任何文本。
- en: When you use an ellipsis, doctest will scan ahead until it finds text matching
    whatever comes after the ellipsis in the expected output, and continue matching
    from there. This can lead to surprising results such as an ellipsis matching against
    a 0-length section of the actual output, or against multiple lines. For this reason,
    it needs to be used thoughtfully.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用省略号时，doctest将向前扫描，直到找到与预期输出中省略号之后文本匹配的文本，然后从那里继续匹配。这可能导致意外的结果，例如省略号匹配实际输出中的0长度部分，或匹配多行。因此，需要谨慎使用。
- en: Time for action – using ellipsis in tests
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在测试中使用省略号
- en: We'll use the ellipsis in a few different tests, to get a better feel for what
    it does and how to use it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几个不同的测试中使用省略号，以更好地了解它的作用和使用方法。
- en: 'Insert the following text into your doctest file:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到您的doctest文件中：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the tests using doctest and the following screen is displayed:.![Time for
    action – using ellipsis in tests](img/8846_02_04.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用doctest运行测试，以下屏幕显示:.![行动时间 – 在测试中使用省略号](img/8846_02_04.jpg)
- en: None of these tests would pass without the ellipsis. Think about that, and then
    try making some changes and see if they produce the results you expect.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有省略号，这些测试都不会通过。考虑一下这一点，然后尝试进行一些更改，看看它们是否产生您预期的结果。
- en: '*What just happened?*'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just saw how to enable ellipsis matching. In addition, we saw a couple of
    variations on where the doctest directive comment can be placed, including on
    a block continuation line by itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何启用省略号匹配。此外，我们还看到了doctest指令注释可以放置的位置的一些变化，包括单独的块续行符。
- en: We got a chance to play with the ellipsis a little bit, and hopefully saw why
    it should be used carefully. Look at that last test. Can you imagine any output
    that wasn't an ISO-formatted time stamp, but that it would match anyway?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有机会稍微玩一下省略号，也许看到了为什么应该小心使用。看看最后一个测试。你能想象任何输出不是ISO格式的日期时间戳，但它仍然会匹配的情况吗？
- en: Ignoring whitespace
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略空白
- en: Sometimes, whitespace (spaces, tabs, newlines, and their ilk) are more trouble
    than they're worth. Maybe you want to be able to break a single line of expected
    output across several lines in your test file, or maybe you're testing a system
    that uses lots of whitespace but doesn't convey any useful information with it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，空白（空格、制表符、换行符及其类似物）带来的麻烦比它们的价值要大。也许你希望能够在测试文件中将单个预期输出行的内容拆分成多行，或者也许你正在测试一个使用大量空白但不会提供任何有用信息的系统。
- en: Doctest gives you a way to "normalize" whitespace, turning any sequence of whitespace
    characters, in both the expected output and in the actual output, into a single
    space. It then checks whether these normalized versions match.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest提供了一种“标准化”空白的方式，将预期输出和实际输出中的任何空白字符序列都转换为一个空格。然后它会检查这些标准化版本是否匹配。
- en: Time for action – normalizing whitespace
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 标准化空白
- en: We'll write a couple tests that demonstrate how whitespace normalization works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写几个测试来展示空白标准化是如何工作的。
- en: 'Insert the following text into your doctest file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到你的doctest文件中：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the tests using doctest and the following screen is displayed:![Time for
    action – normalizing whitespace](img/8846_02_05.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用doctest运行测试，以下屏幕将显示：![Time for action – normalizing whitespace](img/8846_02_05.jpg)
- en: Notice how one of the tests inserts extra whitespace in the expected output,
    while the other one ignores extra whitespace in the actual output. When you use
    `+NORMALIZE_WHITESPACE`, you gain a lot of flexibility with regard to how things
    are formatted in the text file.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，其中一个测试在预期输出中插入额外的空白，而另一个测试则忽略了实际输出中的额外空白。当你使用`+NORMALIZE_WHITESPACE`时，你会在文本文件中格式化事物方面获得很大的灵活性。
- en: Skipping an example entirely
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全跳过一个示例
- en: On some occasions, doctest would recognize some text as an example to be checked,
    when in truth you want it to be simply text. This situation is rarer than it might
    at first seem, because usually there's no harm in letting doctest check everything
    it can. In fact, it is usually helpful to have doctest check everything it can.
    For those times when you want to limit what doctest checks, though, there's the
    `+SKIP` directive.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，doctest会将一些文本识别为要检查的示例，而实际上你只想让它作为普通文本。这种情况比最初看起来要少，因为通常让doctest检查所有它能检查的内容并没有什么坏处。事实上，通常让doctest检查所有它能检查的内容是有帮助的。然而，当你想限制doctest检查的内容时，可以使用`+SKIP`指令。
- en: Time for action – skipping tests
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 跳过测试
- en: 'This is an example of how to skip a test:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个跳过测试的例子：
- en: 'Insert the following text into your doctest file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到你的doctest文件中：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the tests using doctest and the following screen will be displayed:![Timedoctest,
    controllingexample, skipping for action – skipping tests](img/8846_02_05.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用doctest运行测试，以下屏幕将显示：![Timedoctest, controllingexample, skipping for action
    – skipping tests](img/8846_02_05.jpg)
- en: Notice that the test didn't fail, and that the number of tests that were run
    did not change.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，测试并没有失败，并且运行测试的数量没有改变。
- en: '*What just happened?*'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The skip directive transformed what would have been a test, into plain text(as
    far as doctest is concerned). Doctest never ran the test, and in fact never counted
    it as a test at all.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过指令将原本应该是测试的内容转换成了纯文本（就doctest而言）。Doctest从未运行过这个测试，实际上从未将其计为一个测试。
- en: There are several situations where skipping a test might be a good idea. Sometimes,
    you have a test which doesn't pass (which you know doesn't pass), but which simply
    isn't something that should be addressed at the moment. Using the `skip` directive
    lets you ignore the test for a while. Sometimes, you have a section of human readable
    text that looks like a test to the doctest parser, even though it's really only
    for human consumption. The `skip` directive can be used to mark that code as not
    for actual testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下跳过测试可能是个好主意。有时候，你有一个测试没有通过（你知道它不会通过），但这并不是目前应该解决的问题。使用`skip`指令让你可以暂时忽略这个测试。有时候，你有一个看起来像测试的文本块，但doctest解析器认为它只是供人类阅读的。`skip`指令可以用来标记这段代码不是实际测试的一部分。
- en: Other doctest directives
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他doctest指令
- en: 'There are a number of other directives that can be issued to adjust the behavior
    of doctest. They are fully documented at [http://docs.python.org/library/doctest.html#option-flags-and-directives](http://docs.python.org/library/doctest.html#option-flags-and-directives),
    but here is a quick overview:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他指令可以发出以调整doctest的行为。它们在[http://docs.python.org/library/doctest.html#option-flags-and-directives](http://docs.python.org/library/doctest.html#option-flags-and-directives)中得到了全面记录，但这里有一个简要概述：
- en: '`+DONT_ACCEPT_TRUE_FOR_1`, which makes doctest treat `True` and `1` as different
    values, instead of treating them as matching as it normally does.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+DONT_ACCEPT_TRUE_FOR_1`，这使得doctest将`True`和`1`视为不同的值，而不是像通常那样将它们视为匹配。'
- en: '`+DONT_ACCEPT_BLANKLINE`, which makes doctest forget about the special meaning
    of `<BLANKLINE>`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+DONT_ACCEPT_BLANKLINE`，这使得doctest忽略`<BLANKLINE>`的特殊含义。'
- en: '`+IGNORE_EXCEPTION_DETAIL`, which makes doctest treat exceptions as matches
    if the exception type is the same, regardless of whether the rest of the exception
    matches.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+IGNORE_EXCEPTION_DETAIL`，这使得doctest在异常类型相同的情况下，无论其余的异常是否匹配，都将异常视为匹配。'
- en: '`+REPORT_UDIFF`, which makes doctest use `unified diff` format when it displays
    a failed test. This is useful if you are used to reading the `unified diff` format,
    which is by far the most common diff format within the open source community.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+REPORT_UDIFF`，这使得doctest在显示失败的测试时使用`unified diff`格式。如果你习惯于阅读`unified diff`格式，这很有用，这是开源社区中最常见的diff格式。'
- en: '`+REPORT_CDIFF`, which makes doctest use `context diff` format when it displays
    a failed test. This is useful if you are used to reading the `context diff` format.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+REPORT_CDIFF`，这使得doctest在显示失败的测试时使用`context diff`格式。如果你习惯于阅读`context diff`格式，这很有用。'
- en: '`+REPORT_NDIFF`, which makes doctest use `ndiff` format when it displays a
    failed test. This is usefull if you are used to reading the `ndiff` format.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+REPORT_NDIFF`，这使得doctest在显示失败的测试时使用`ndiff`格式。如果你习惯于阅读`ndiff`格式，这很有用。'
- en: '`+REPORT_ONLY_FIRST_FAILURE` makes doctest avoid printing out failure reports
    on those tests after it is applied, if a failure report has already been printed.
    The tests are still executed, and doctest still keeps track of whether they failed
    or not. Only the report is changed by using this flag.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+REPORT_ONLY_FIRST_FAILURE`使得doctest在应用后避免打印出失败报告，如果已经打印了失败报告。测试仍然被执行，doctest仍然跟踪它们是否失败。只有通过使用此标志来更改报告。'
- en: Execution scope
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行范围
- en: 'When doctest is running the tests from text files, all the tests from the same
    file are run in the same execution scope. That means that if you import a module
    or bind a variable in one test, that module or variable is still available in
    later tests. We took advantage of this fact several times in the tests written
    so far in this chapter: the `sys` module was only imported once, for example,
    although it was used in several tests.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当doctest从文本文件中运行测试时，同一文件中的所有测试都在相同的执行范围内运行。这意味着如果你在一个测试中导入一个模块或绑定一个变量，那么这个模块或变量在后续的测试中仍然可用。我们已经在本章迄今为止编写的测试中多次利用了这个事实：例如，`sys`模块只导入了一次，尽管它在几个测试中使用。
- en: That behavior is not necessarily beneficial, because tests need to be isolated
    from each other. We don't want them to contaminate each other, because if a test
    depends on something that another test does, or if it fails because of something
    that another test does, those two tests are in some sense turned into one test
    that covers a larger section of your code. You don't want that to happen, because
    knowing which test has failed doesn't give you as much information about what
    went wrong and where it happened.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为并不一定有益，因为测试需要彼此隔离。我们不希望它们相互污染，因为如果一个测试依赖于另一个测试所做的东西，或者如果它因为另一个测试所做的东西而失败，那么这两个测试在某种程度上就变成了一个覆盖更大代码部分的测试。你不想这种情况发生，因为知道哪个测试失败了并不能给你提供太多关于出错原因和出错位置的信息。
- en: So, how can we give each test its own execution scope? There are a few ways
    to do it. One would be to simply place each test in its own file, along with whatever
    explanatory text that is needed. This works beautifully, but running the tests
    can be a pain unless you have a tool to find and run all of them. We'll talk about
    one such tool (called nose) later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何为每个测试提供自己的执行范围呢？有几种方法可以实现。一种方法是将每个测试简单地放在自己的文件中，以及所需的任何解释性文本。这工作得很好，但除非你有工具来查找和运行所有测试，否则运行测试可能会很痛苦。我们稍后会讨论这样一个工具（称为nose）。
- en: 'Another way to give each test its own execution scope, is to define each test
    within a function, as shown below:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种给每个测试自己的执行范围的方法是在函数内定义每个测试，如下所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By doing that, the only thing that ends up in the shared scope is the test function
    (named `test1` here). The `frob` module, and any other names bound inside the
    function, are isolated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，最终在共享作用域中结束的只有测试函数（在这里命名为`test1`）。`frob`模块，以及函数内部绑定的任何其他名称，都是隔离的。
- en: The third way is to exercise caution with the names you create, and be sure
    to set them to known values at the beginning of each test section. In many ways
    this is the easiest approach, but it's also the one that places the most burden
    on you, because you have to keep track of what's in the scope.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是在创建名称时要谨慎，并确保在每个测试部分的开始将它们设置为已知值。在许多方面，这是一种最简单的方法，但也是最让你感到负担的方法，因为你必须跟踪作用域中的内容。
- en: Why does doctest behave this way, instead of isolating tests from each other?
    Doctest files are intended not just for computers to read, but also for humans.
    They often form a sort of narrative, flowing from one thing to the next. It would
    break the narrative to be constantly repeating what came before. In other words,
    this approach is a compromise between being a document and being a test framework,
    a middle ground that works for both humans and computers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么doctest以这种方式行为，而不是将测试相互隔离？doctest文件不仅是为了计算机阅读，也是为了人类阅读。它们通常形成一种叙事，从一件事流向另一件事。不断地重复之前的内容会打断叙事。换句话说，这种方法是在文档和测试框架之间的一种折衷，是一种既适合人类也适合计算机的中间地带。
- en: The other framework that we study in depth in this book (called simply unittest)
    works at a more formal level, and enforces the separation between tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们深入研究（简单地称为unittest）的另一个框架在更正式的层面上工作，并强制执行测试之间的分离。
- en: Pop quiz – doctest syntax
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——doctest语法
- en: There is no answer key for these questions. Try your answers in doctest and
    see if you're right!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题没有答案。在doctest中尝试你的答案，看看你是否正确！
- en: How does doctest recognize the beginning of a test expression?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: doctest如何识别测试表达式的开始？
- en: How does doctest know where the expected output of a text expression begins
    and ends?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: doctest如何知道文本表达式的预期输出开始和结束的位置？
- en: How would you tell doctest that you want to break a long expected output across
    multiple lines, even though that's not how the test actually outputs it?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何告诉doctest你想要将一个长的预期输出拆分成多行，即使实际的测试输出并不是这样？
- en: Which parts of an exception report are ignored by doctest?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常报告中哪些部分被doctest忽略？
- en: When you bind a variable in a test file, what code can "see" that variable?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在测试文件中绑定一个变量时，什么代码可以“看到”这个变量？
- en: Why do we care what code can see a variable created by a test?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么关心代码可以看到由测试创建的变量？
- en: How can we make doctest not care what a section of output contains?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何让doctest不关心输出部分的内容？
- en: Have a go hero – from English to doctest
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄——从英语到doctest
- en: Time to stretch your wings a bit! I'm going to give you a description of a single
    function, in English. Your job is to copy the description into a new text file,
    and then add tests that describe all the requirements in a way in which the computer
    can understand and check.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候展翅飞翔了！我将给你一个关于单个函数的描述，用英语。你的任务是把这个描述复制到一个新的文本文件中，然后添加测试，以描述所有要求，让计算机能够理解和检查。
- en: Try to make the doctests that are not just for the computer. Good doctests tend
    to clarify things for human readers as well. By and large, that means that you
    present them to human readers as examples interspersed with the text.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 努力使doctests不仅仅是为了计算机。好的doctests往往也会为人类读者澄清事情。总的来说，这意味着你将它们作为例子呈现给人类读者，穿插在文本中。
- en: 'Without further ado, here is the English description:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，以下是英文描述：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I'll give you a hint and point out that the last sentence—about the function
    being slow—isn't really testable. As computers get faster, any test you write
    that depends on an arbitrary definition of "slow" will eventually fail. Also,
    there's no good way to test the difference between a slow function and a function
    stuck in an infinite loop, so there's no point in trying. If you find yourself
    needing to do that, it's best to back off and try a different solution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我给你一个提示，并指出最后一句——关于函数运行缓慢——实际上并不是可测试的。随着计算机变得越来越快，任何依赖于“慢”的任意定义的测试最终都会失败。此外，没有好的方法来测试一个慢函数和一个陷入无限循环的函数之间的差异，所以尝试这样做是没有意义的。如果你发现自己需要这样做，最好是退一步，尝试不同的解决方案。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not being able to tell whether a function is stuck or just slow is called the
    Halting Problem by computer scientists. We know that it can't be solved unless
    we someday discover a fundamentally better kind of computer. Faster computers
    won't do the trick, and neither will quantum computers, so don't hold your breath!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家称无法判断一个函数是否卡住还是只是运行缓慢为“停机问题”。我们知道除非我们有一天发现一种根本更好的计算机类型，否则这个问题是无法解决的。更快的计算机无法解决这个问题，量子计算机也无法，所以不要抱太大希望！
- en: Embedding doctests in Python docstrings
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 文档字符串中嵌入 doctests
- en: Doctests aren't confined to simple text files. You can put doctests into Python's
    docstrings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Doctests 并不局限于简单的文本文件。你可以将 doctests 放入 Python 的文档字符串中。
- en: Why would you want to do that? There are a couple of reasons. First of all,
    docstrings are an important part of the usability of Python code (but only if
    they tell the truth). If the behavior of a function, method, or module changes
    and the docstring doesn't get updated, then the docstring becomes misinformation,
    and a hindrance rather than a help. If the docstring contains a couple of doctest
    examples, then the out-of-date docstrings can be located automatically. Another
    reason for placing doctest examples into docstrings is simply that it can be very
    convenient. This practice keeps the tests, documentation and code all in the same
    place, where it can all be located easily.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么想要这样做呢？有几个原因。首先，文档字符串是 Python 代码可用性的重要部分（但只有当它们讲述真相时）。如果一个函数、方法或模块的行为发生变化，而文档字符串没有更新，那么文档字符串就变成了错误信息，反而成为一种阻碍而不是帮助。如果文档字符串包含几个
    doctest 示例，那么可以自动定位过时的文档字符串。将 doctest 示例放入文档字符串的另一个原因是它非常方便。这种做法将测试、文档和代码都放在同一个地方，可以轻松找到。
- en: If the docstring becomes home to too many tests, this can destroy its utility
    as documentation. This should be avoided; if you find yourself with so many tests
    in the docstrings that they aren't useful as a quick reference, move most of them
    to a separate file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档字符串成为太多测试的家园，这可能会破坏其作为文档的效用。应避免这种情况；如果你发现自己有太多的测试在文档字符串中，以至于它们不能作为快速参考，那么将大多数测试移动到单独的文件中。
- en: Time for action – embedding a doctest in a docstring
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在文档字符串中嵌入 doctest
- en: We'll embed a test right inside the Python source file that it tests, by placing
    it inside a docstring.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接在测试的 Python 源文件中嵌入一个测试，通过将其放置在文档字符串中来实现。
- en: 'Create a file called `test.py` with the following contents:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test.py` 的文件，内容如下：
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the command prompt, change to the directory where you saved `test.py` and
    then run the tests by typing:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，切换到保存 `test.py` 的目录，然后通过输入以下命令来运行测试：
- en: '[PRE11]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier before, if you have an older version of Python, this isn't
    going to work for you. Instead, you need to type `python -c "__import__('doctest').testmod(__import__('test'))"`
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，如果你有一个较旧的 Python 版本，这对你来说不起作用。相反，你需要输入 `python -c "__import__('doctest').testmod(__import__('test'))"`
- en: 'If everything worked, you shouldn''t see anything at all. If you want some
    confirmation that doctest is doing something, turn on verbose reporting by changing
    the command to:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，你根本不应该看到任何东西。如果你想确认 doctest 正在执行某些操作，请通过将命令更改为来开启详细报告：
- en: '[PRE12]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For older versions of Python, instead use `python -c "__import__('doctest').testmod(__import__('test'),
    verbose=True)"`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较旧的 Python 版本，请使用 `python -c "__import__('doctest').testmod(__import__('test'),
    verbose=True)"`
- en: '*What just happened?*'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: You put the doctest right inside the docstring of the function it was testing.
    This is a good place for tests that also show a user how to do something. It's
    not a good place for detailed, low-level tests (the above example, which was quite
    detailed for illustrative purposes, is skirting the edge of being too detailed),
    because docstrings need to serve as API documentation. You can see the reason
    for this just by looking back at the example, where the doctests take up most
    of the room in the docstring, without telling the readers any more than they would
    have learned from a single test.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 doctest 直接放在被测试函数的文档字符串中。这是一个展示用户如何做某事的测试的好地方。它不是一个详细、低级测试的好地方（上面的例子为了说明目的而相当详细，已经接近过于详细），因为文档字符串需要作为
    API 文档。你只需回顾一下例子，就可以看到 doctests 占据了文档字符串的大部分空间，而没有告诉读者比单个测试更多的信息。
- en: Any test that will serve as good API documentation is a good candidate for including
    in the docstrings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以作为良好 API 文档的测试都是包含在文档字符串中的良好候选。
- en: Notice the use of a raw string for the docstring (denoted by the `r` character
    before the first triple-quote). Using raw strings for your docstrings is a good
    habit to get into, because you usually don't want escape sequences—e.g. `\n` for
    newline—to be interpreted by the Python interpreter. You want them to be treated
    as text, so that they are correctly passed on to doctest.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意docstring使用了原始字符串（由第一个三引号前的`r`字符表示）。养成使用原始字符串作为docstrings的习惯是个好习惯，因为你通常不希望转义序列（例如`\n`表示换行）被Python解释器解释。你希望它们被当作文本处理，以便它们能正确地传递给doctest。
- en: Doctest directives
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest指令
- en: Embedded doctests can accept exactly the same directives as doctests in text
    files can, using exactly the same syntax. Because of this, all of the doctest
    directives that we discussed before can also be used to affect the way embedded
    doctests are evaluated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入的doctests可以接受与文本文件中的doctests完全相同的指令，使用完全相同的语法。正因为如此，我们之前讨论的所有doctest指令也可以用来影响嵌入的doctests的评估方式。
- en: Execution scope
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行范围
- en: Doctests embedded in docstrings have a somewhat different execution scope than
    doctests in text files do. Instead of having a single scope for all of the tests
    in the file, doctest creates a single scope for each docstring. All of the tests
    that share a docstring, also share an execution scope, but they're isolated from
    tests in other docstrings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入在docstrings中的doctests与文本文件中的doctests的执行范围略有不同。doctest不是为文件中的所有测试提供一个单一的执行范围，而是为每个docstring创建一个单一的执行范围。共享同一个docstring的所有测试也共享一个执行范围，但它们与其他docstrings中的测试是隔离的。
- en: The separation of each docstring into its own execution scope often means that
    we don't need to put much thought into isolating doctests, when they're embedded
    in docstrings. That is fortunate, since docstrings are primarily intended for
    documentation, and the tricks needed to isolate the tests might obscure the meaning.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个docstring独立于其自身的执行范围通常意味着，当它们嵌入在docstrings中时，我们不需要过多考虑隔离doctests。这是幸运的，因为docstrings主要是为了文档而设计的，而隔离测试所需的技巧可能会模糊其含义。
- en: 'Putting it in practice: an AVL tree'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将理论付诸实践：AVL树
- en: We'll walk step-by-step through the process of using doctest to create a testable
    specification for a data structure called an AVL Tree. An AVL tree is a way to
    organize key-value pairs, so that they can be quickly located by key. In other
    words, it's a lot like Python's built-in dictionary type. The name AVL references
    the initials of the people who invented this data structure.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍使用doctest为名为AVL树的数据结构创建可测试规范的过程。AVL树是一种组织键值对的方式，以便可以通过键快速定位它们。换句话说，它非常类似于Python内置的字典类型。AVL这个名字指的是发明这种数据结构的人的姓名首字母。
- en: As its name suggests, an AVL tree organizes the keys that are stored in it into
    a tree structure, with each key having up to two **child** keys—one **child**
    key that is less than the **parent** key by comparison, and one that is more.
    In the following picture, the key **Elephant** has two child keys, **Goose** has
    one, and **Aardvark** and **Frog** both have none.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，AVL树将存储在其中的键组织成一种树结构，每个键最多有两个**子**键——一个**子**键通过比较小于**父**键，另一个则更大。在下面的图片中，键**Elephant**有两个子键，**Goose**有一个，而**Aardvark**和**Frog**都没有。
- en: '![Putting it in practice: an AVL tree](img/8846_02_06.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![将理论付诸实践：AVL树](img/8846_02_06.jpg)'
- en: The AVL tree is special, because it keeps one side of the tree from getting
    much taller than the other, which means that users can expect it to perform reliably
    and efficiently no matter what. In the previous image, an AVL tree would reorganize
    to stay balanced if **Frog** gained a child.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树是特殊的，因为它保持树的某一侧不会比另一侧高得多，这意味着用户可以期望它无论在什么情况下都能可靠且高效地执行。在之前的图片中，如果**Frog**获得一个子键，AVL树将重新组织以保持平衡。
- en: We'll write tests for an AVL tree implementation here, rather than writing the
    implementation itself. Therefore, we'll elaborate over the details of *how* an
    AVL tree works, in favor of looking at what it should do when it works right.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写AVL树实现的测试，而不是编写实现本身。因此，我们将详细阐述AVL树是如何工作的细节，以便查看它正常工作时应做什么。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to know more about AVL Trees, you will find many good references
    on the Internet. Wikipedia''s entry on the subject is a good place to start with:
    [http://en.wikipedia.org/wiki/AVL_tree](http://en.wikipedia.org/wiki/AVL_tree).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于AVL树的信息，你将在互联网上找到许多很好的参考资料。关于这个主题的维基百科条目是一个很好的起点：[http://en.wikipedia.org/wiki/AVL_tree](http://en.wikipedia.org/wiki/AVL_tree)。
- en: We'll start with a plain language specification, and then interject tests between
    the paragraphs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一份普通语言规范开始，然后在段落之间插入测试。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don't have to actually type all of this into a text file; it is here for
    you to read and to think about. It's also available in the code download that
    accompanies this book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必真的将这些内容全部输入到文本文件中；这里是为了让你阅读和思考。它也包含在这本书的代码下载中。
- en: English specification
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英文规范
- en: The first step is to describe what the desired result should be, in normal language.
    This might be something that you do for yourself, or something that somebody else
    does for you. If you're working for somebody, hopefully you and your employer
    can sit down together and work this part out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是用普通语言描述期望的结果。这可能是一些你自己做的事情，或者别人为你做的事情。如果你在为别人工作，希望你和你的雇主可以坐下来一起解决这个问题。
- en: In this case, there's not much to work out, because AVL Trees have been fully
    described for decades. Even so, the description here isn't quite like one you'd
    find anywhere else. This capacity for ambiguity is exactly the reason why a plain
    language specification isn't good enough. We need an unambiguous specification,
    and that's exactly what the tests in a doctest file can give us.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有太多需要解决的问题，因为AVL树已经描述了几十年。即便如此，这里的描述并不完全像你在其他地方能找到的。这种歧义性正是为什么纯语言规范不够好的原因。我们需要一个明确的规范，这正是doctest文件中的测试可以提供的。
- en: 'The following text goes in a file called `AVL.txt`, (which you can find in
    its final form in the accompanying code archive. At this stage of the process,
    the file contains only the normal language specification.):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本将放入一个名为`AVL.txt`的文件中（你可以在附带的代码存档中找到其最终形式。在这个处理阶段，该文件只包含普通语言规范）：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Node data
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点数据
- en: The first three paragraphs of the specification describe the member variables
    of a AVL tree node, and tell us what the valid values for the variables are. They
    also tell us how tree height should be measured and define what a balanced tree
    means. It's our job now to take up those ideas, and encode them into tests that
    the computer can eventually use to check our code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的前三段描述了AVL树节点的成员变量，并告诉我们变量的有效值。它们还告诉我们如何测量树的高度，并定义了平衡树的意义。现在我们的任务是吸收这些想法，并将它们编码成计算机最终可以用来检查我们代码的测试。
- en: We could check these specifications by creating a node and then testing the
    values, but that would really just be a test of the constructor. It's important
    to test the constructor, but what we really want to do is to incorporate checks
    that the node variables are left in a valid state into our tests of each member
    function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个节点并测试其值来检查这些规范，但这实际上只是对构造函数的测试。测试构造函数是很重要的，但我们真正想要做的是将检查节点变量是否处于有效状态的检查纳入到我们对每个成员函数的测试中。
- en: 'To that end, we''ll define a function that our tests can call to check that
    the state of a node is valid. We''ll define that function just after the third
    paragraph:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，我们将定义一个我们的测试可以调用的函数来检查节点的状态是否有效。我们将在第三段之后定义这个函数：
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that this test is written as if the AVL tree implementation already existed.
    It tries to import an `avl_tree` module containing an `AVL` class, and it tries
    to use the `AVL` class is specific ways. Of course, at the moment there is no
    `avl_tree` module, so the test will fail. That's as it should be. All that the
    failure means is that, when the time comes to implement the tree, we should do
    so in a module called `avl_tree`, with contents that function as our test assumes.
    Part of the benefit of testing like this is being able to test-drive your code
    before you even write it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个测试被编写成好像AVL树实现已经存在。它试图导入一个包含`AVL`类的`avl_tree`模块，并试图以特定的方式使用`AVL`类。当然，目前并没有`avl_tree`模块，所以测试会失败。这正是应该发生的。失败仅仅意味着，当真正需要实现树的时候，我们应该在一个名为`avl_tree`的模块中实现，其内容应该符合我们的测试假设。这样测试的一个好处是能够在编写代码之前就测试代码。
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we didn't actually call those functions yet. They aren't tests,
    per se, but tools that we'll use to simplify writing tests. We define them here,
    rather than in the Python module that we're going to test, because they aren't
    conceptually part of the tested code, and because anyone who reads the tests will
    need to be able to see what the helper functions do.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上还没有调用那些函数。它们本身不是测试，而是我们将用来简化编写测试的工具。我们在这里定义它们，而不是在我们要测试的Python模块中定义，因为它们在概念上不是测试代码的一部分，并且任何阅读测试的人都需要能够看到辅助函数的作用。
- en: Constructor
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'The fourth paragraph describes the constructor for an AVL node: The node constructor
    takes either a pair of parameters representing a key and a value, or a `dict`
    object representing the key-value pairs with which to initialize a new tree.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第四段描述了AVL节点的构造函数：节点构造函数接受一对表示键和值的参数，或者一个表示要初始化新树的键值对的`dict`对象。
- en: 'The constructor has two possible modes of operation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有两种可能的操作模式：
- en: it can either create a single initialized node
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以创建一个初始化的单个节点
- en: 'or it can create and initialize a whole tree of nodes. The test for the single
    node mode is easy:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者它可以创建并初始化一个整个节点树。对于单个节点模式的测试很简单：
- en: '[PRE15]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The other mode of the constructor is a problem, because it is almost certain
    that it will be implemented by creating an initial tree node and then calling
    its set method to add the rest of the nodes. Why is that a problem? Because we
    don''t want to test the set method here: this test should be focused entirely
    on whether the constructor works correctly, *when everything it depends on works*.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的另一种模式是一个问题，因为它几乎肯定将通过创建一个初始树节点然后调用其set方法来添加其余节点来实现。为什么那是一个问题？因为我们不想在这里测试set方法：这个测试应该完全集中在构造函数是否正确工作，*当它所依赖的一切都正常工作时*。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In other words, the tests should be able to assume that everything outside of
    the specific chunk of code being tested works correctly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，测试应该能够假设除了正在测试的具体代码块之外的所有内容都工作正常。
- en: However, that's not always a valid assumption. So, how can we write tests for
    things that call on code outside of what's being tested?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是有效的假设。那么，我们如何为调用测试之外代码的事情编写测试？
- en: There is a solution for this problem, about which we'll learn in Chapter 4\.
    For now, we'll just leave the second mode of operation of the constructor untested.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们将在第4章中了解到解决方案。现在，我们只需将构造函数的第二种操作模式留待测试。
- en: Recalculate height
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新计算高度
- en: The `recalculate_height` method is described in the fifth paragraph.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`recalculate_height`方法在第5段中描述。'
- en: To test it, we'll need a tree for it to operate on, and we don't want to use
    the second mode of the constructor to create it. After all, that mode isn't tested
    at all yet, and even if it were, we want this test to be independent of it. We
    would prefer to make the test entirely independent of the constructor, but in
    this case we need to make a small exception to the rule(since it's difficult to
    create an object without calling its constructor in some way).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们需要一个树来操作，我们不想使用构造函数的第二种模式来创建它。毕竟，那种模式还没有经过测试，即使它经过了测试，我们也希望这个测试与它独立。我们更愿意使测试完全独立于构造函数，但在这个情况下，我们需要对规则做出一个小小的例外（因为在不以某种方式调用其构造函数的情况下创建对象是困难的）。
- en: What we'll do is define a function that builds a specific tree and returns it.
    This function will be useful in several of our later tests as well. Using this
    function, testing `recalculate_height` will be easy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个函数来构建一个特定的树并返回它。这个函数将在我们后面的几个测试中也很有用。使用这个函数，测试`recalculate_height`将变得容易。
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `make_test_tree` function builds a tree by manually constructing each part
    of it and hooking it together into a structure that looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_test_tree`函数通过手动构建其每个部分并将其连接成一个类似这样的结构来构建一个树：'
- en: '![Recalculate height](img/8846_02_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![重新计算高度](img/8846_02_07.jpg)'
- en: Make deletable
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可删除
- en: You can't delete a node that has children, because that would leave the node's
    children disconnected from the rest of the tree. If we delete the **Elephant**
    node from the bottom of the tree, what do we do about **Aardvark**, **Goose**,
    and **Frog**? If we delete **Goose**, how do we find **Frog** afterwards?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能删除有子节点的节点，因为这会使节点的小孩与树的其他部分断开连接。如果我们从树的底部删除**Elephant**节点，那么**Aardvark**、**Goose**和**Frog**怎么办？如果我们删除**Goose**，之后如何找到**Frog**？
- en: '![Make deletable](img/8846_02_06.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![可删除](img/8846_02_06.jpg)'
- en: The way around that is to have the node swap places with it's largest leaf descendant
    on the left side (or its smallest leaf descendant on the right side, but we'll
    not do it that way).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是让节点与其左侧最大的叶子子节点交换位置（或者右侧最小的叶子子节点，但我们不会那样做）。
- en: 'We''ll test this by using the same `make_test_tree` function that we defined
    before to create a new tree to work on, and then checking that `make_deletable`
    swaps correctly:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用之前定义的 `make_test_tree` 函数来创建一个新的树来工作，并检查 `make_deletable` 是否正确交换：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Something to notice here is that the `make_deletable` function isn't supposed
    to delete the node that it's called on. It's supposed to move that node into a
    position where it could be safely deleted. It must do this reorganization of the
    tree, without violating any of the constraints that define an AVL tree structure.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，`make_deletable` 函数不应该删除它被调用的节点。它应该将节点移动到一个可以安全删除的位置。它必须在不违反定义 AVL
    树结构的任何约束的情况下进行这种树的重组织。
- en: Rotation
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转
- en: The two rotate functions perform a somewhat tricky manipulation of the links
    in a tree. You probably found the plain language description of what they do,
    a bit confusing. This is one of those times when a little bit of code makes a
    whole lot more sense than any number of sentences.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 两个旋转函数在树中执行一些相当复杂的链接操作。你可能发现它们在普通语言描述中的操作有些令人困惑。在这些情况下，一点点的代码比任何数量的句子都要有意义得多。
- en: While tree rotation is usually defined in terms of rearranging the links between
    nodes in the tree, we'll check whether it worked by looking at the values (rather
    than by looking directly at the left and right links). This allows the implementation
    to swap the contents of nodes—rather than the nodes themselves—when it wishes.
    After all, it's not important to the specification which operation happens, so
    we shouldn't rule out a perfectly reasonable implementation choice.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然树旋转通常是通过重新排列树中节点之间的链接来定义的，但我们会通过查看值（而不是直接查看左右链接）来检查它是否成功。这允许实现者在需要时交换节点的内容——而不是节点本身。毕竟，对于规范来说，哪个操作发生并不重要，所以我们不应该排除一个完全合理的实现选择。
- en: 'The first part of the test code for rotation just creates a tree and verifies
    that it looks like we expect it to:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转测试代码的第一部分只是创建一个树并验证它看起来是否符合我们的预期：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we have a tree to work with, we try a rotation operation and check that
    the result still looks like it should:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个可以工作的树，我们就尝试旋转操作，并检查结果是否看起来应该是这样的：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we rotate back in the other direction, and check that the final result
    is the same as the original tree, as we expect it to be:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以相反的方向旋转，并检查最终结果是否与原始树相同，正如我们所期望的那样：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Locating a node
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位一个节点
- en: The `locate` method is expected to return a node, or raise a `KeyError` exception,
    depending on whether the key exists in the tree or not. We'll use our specially
    built tree again, so that we know exactly what the tree's structure looks like.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`locate` 方法预期返回一个节点，或者根据键值是否存在于树中而抛出 `KeyError` 异常。我们将再次使用我们特别构建的树，这样我们就能确切知道树的结构。'
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `locate` method is intended to facilitate insertion, deletion, and lookup
    of values based on their keys, but it's not a high-level interface. It returns
    a node object, because it's easy to implement the higher-level operations, if
    you have a function the finds the right node for you.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`locate` 方法旨在通过键值来简化插入、删除和查找操作，但它不是一个高级接口。它返回一个节点对象，因为如果你有一个能为你找到正确节点的函数，实现高级操作就很容易了。'
- en: Testing the rest of the specification
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试其余的规范
- en: Like the second mode of the constructor, testing the rest of the specification
    involves testing code that depends on things outside of itself, which we'll cover
    in Chapter 4.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像构造函数的第二种模式一样，测试其余的规范涉及到测试依赖于自身之外的事物的代码，我们将在第 4 章中介绍。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned the syntax of doctest, and went through several examples describing
    how to use it. After that, we took a real-world specification for the AVL tree,
    and examined how to formalize it as a set of doctests, so that we could use it
    to automatically check the correctness of an implementation.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 doctest 的语法，并探讨了几个示例，描述了如何使用它。之后，我们针对 AVL 树的实际规范进行了研究，探讨了如何将其形式化为一系列 doctests，以便我们可以用它来自动检查实现的正确性。
- en: Specifically, we covered doctest's default syntax, and the directives that alter
    it, how to write doctests in text files, how to write doctests in Python docstrings,
    and what it feels like to use doctest to turn a specification into tests.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了doctest的默认语法，以及如何修改它的指令，如何在文本文件中编写doctests，如何在Python文档字符串中编写doctests，以及使用doctest将规范转换为测试的感觉。
- en: Now that we've learned about doctest, we're ready to talk about how to use doctest
    to do unit testing—which is the topic of the next chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了doctest，我们准备讨论如何使用doctest进行单元测试——这是下一章的主题。
