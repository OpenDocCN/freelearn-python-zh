- en: 2 Organizing a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is Day 0\. You have a project in hand. You are fired up and ready to build
    a new web application. Ideas are swirling in your head, and your fingers are itching
    to start punching the keyboard. Time to sit down and start coding!
  prefs: []
  type: TYPE_NORMAL
- en: Or is it? It is tempting to start building an application as soon as the ideas
    about what we want to build begin to formulate in our heads. Before doing that,
    we should think about setting ourselves up for success. Having a solid foundation
    for the building will make the process much easier, reduce bugs, and result in
    a cleaner application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three foundations for beginning any Python web application project are:'
  prefs: []
  type: TYPE_NORMAL
- en: your IDE/coding editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an environment for running your development application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a project application structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three elements take into account a lot of personal tastes. There are
    so many good tools and approaches. There is no way a single book could cover them
    all. If you are a more seasoned developer and already have a set of preferences:
    great, run with that and skip ahead to the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore a couple of modern options to get you up and
    running. The focus will be upon foundation #2 (the environment) and foundation
    #3 (the application structure). We skip #1 and assume you are using a modern IDE
    of your own choosing. Popular choices in the Python world include VS Code, Pycharm,
    and Sublime Text. If you are not using one of these or something similar, go look
    them up and find one that works for you.'
  prefs: []
  type: TYPE_NORMAL
- en: After we setup our environment, we will explore some patterns to be implemented
    in Sanic that will help define your application architecture. This is not a software
    architecture book. I highly recommend you learn about approaches like “Domain
    Driven Design” and “Clean Architecture”. This book is focused much more on the
    practical aspects and decisions of building a web application in Sanic, so feel
    free to adjust the patterns as you feel necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an environment and directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blueprints effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring it all up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, we will assume you have the following already setup on your
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern Python installation (Python 3.7 or newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal (and basic knowledge of how to execute programs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE (as discussed above)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an environment and directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first few steps that you take when starting any project have a monumental
    impact on the entirety of the project. Whether you are embarking on a multi-year
    project—or one that will be complete in a couple of hours—these early decisions
    will shape how you and others work on the project. But, even though these are
    important choices, do not fall into the trap of thinking that you need to find
    the *perfect* solution. There is no single “right way” to set up an environment
    or project directory. Remember our discussion from the previous chapter: we want
    to make the choices that fit the project at hand.'
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good practice for Python development is to isolate its running environment
    from other projects. This is typically accomplished with virtual environments.
    In its most basic understanding, a virtual environment is a tool that allows you
    to install Python dependencies in isolation. This is important so that when we
    begin to develop our application, we have control of the requirements and dependencies
    in use. In its absence, we might mistakenly run our application and have requirements
    from other projects bleed into the application causing bugs and unintended behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of a virtual environment is so foundational in the Python development
    world, that it has become the expected “norm” when creating a Python script or
    application. The first step you should always do when starting a new project is
    making a new virtual environment for it. The alternative to them is to run your
    application with your operating system’s installation of Python. Do not do this.
    It may be fine for a while, but eventually, you will come across conflicting requirements,
    naming collisions, or other difficulties that all stem from a lack of isolation.
    The first step to becoming a better Python developer is to use virtual environments
    if you are not already.
  prefs: []
  type: TYPE_NORMAL
- en: It is also extremely helpful to acquaint yourself with the different tools that
    IDEs provide in hooking up to your virtual environment. These tools will often
    include things like code completion, and guide you as you start using features
    of your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We do eventually want to run our application using containers. Being able to
    run our application inside of a Docker container will greatly reduce the complexity
    in deploying our application down the road. This will be discussed further in
    *Chapter 9, Best practices to improve your web applications*. However, I also
    believe that our application should be runnable (and therefore testable) from
    multiple environments. Even if we intend to use Docker down the road, we first
    need our application running locally without it. Debugging becomes much easier
    when our application does not rely upon an overly complex set of requirements
    just to run. Therefore, let’s spend some time thinking about how to setup a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are many great tutorials and resources about how to use virtual environments.
    There are also many tools out there that are created to help manage the process.
    While I personally am a fan of the simple, tried and true method of `virtualenv`
    plus `virtuanenvwrapper`, there are many people who are fans of `pipenv`, or `poetry`.
    These latter tools are meant to be a more “complete” encapsulation of your running
    environment. If they work for you, great. You are encouraged to spend some time
    to see what strikes a chord and resonates with your development pattern and needs.
  prefs: []
  type: TYPE_NORMAL
- en: We will leave virtual environments aside for now, and briefly explore the usage
    of a relatively new pattern in Python. In Python 3.8, Python adopted a new pattern
    in PEP 582 that formalizes the inclusion of requirements into an isolated environment
    in a special `__pypackages__` directory that lives inside the project. While the
    concept is similar to virtual environments, it works a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement `__pypackages__`, we are making it mandatory for our fictitious
    development team to use `pdm`. This is a relatively new tool that makes it super
    simple to adhere to some of the latest practices in modern Python development.
    If this approach interests you, take some time to go read PEP 582 ([https://www.python.org/dev/peps/pep-0582/](https://www.python.org/dev/peps/pep-0582/))
    and look at `pdm` ([https://pdm.fming.dev/](https://pdm.fming.dev/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get started by installing it with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the installation instructions on their website for more details: [https://pdm.fming.dev/#installation](https://pdm.fming.dev/#installation).
    Pay particular attention to useful features like shell completion and IDE integrations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s proceed with setting up:'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we create a new directory for our application, and from that
    directory run the following and follow the prompts to setup a basic structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we will install Sanic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have access to Sanic. Just to confirm in our heads that we are indeed
    in an isolated environment, let’s quickly jump into the Python REPL, and check
    the location of Sanic using: sanic.__file__.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sanic CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in *Chapter 8, Running a Server*, there are many considerations
    that go into *how* to deploy and run Sanic. Unless we are specifically looking
    into one of these alternatives, you can assume in this book that we are running
    Sanic using the Sanic CLI. This will standup our application using the integrated
    Sanic web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will check to see what version we are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And check to see what options we can use with the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our standard form for running our applications right now will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What thought went into the decision for using this command? Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Why src.server:app?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we are going to run this from the `./booktracker` directory. All of our
    code will be nested in a `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, it is somewhat standard practice that our application creates a single
    `Sanic()` instance, and assigns it to a variable called `app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we were to place that into a file called `app.py`, then our module and variable
    start to get confused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The above import statement is, well, ugly. As much as possible, it is beneficial
    to avoid naming conflicts between modules and the contents of that module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bad example of this exists in the standard library. Have you ever done this
    one by accident:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Oops, we should have used `from datetime import datetime`. We want to minimize
    the replication of module names and properties, and to make our imports easy to
    remember and intuitive to look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will place our global `app` variable into a file called `server.py`.
    Sanic will look for our app instance when you pass in the form: `<module>:<variable>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Why -p 7777?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We, of course, could choose any arbitrary port here. Many web servers will use
    port `8000` and that is the Sanic default if we just left it out completely. However,
    precisely because it is standard, we want to choose something else. Often, it
    is beneficial to choose a port that is less likely to collide with other ports
    that might be running on your machine. The more we can preserve common ports,
    the less likely we will run into collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Why --debug?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While developing, having `DEBUG` mode enabled provides: a more verbose output
    from Sanic, and an auto-reloading server. It can be helpful to see more logs,
    but make sure you turn this off in production.'
  prefs: []
  type: TYPE_NORMAL
- en: The auto-reloading feature is particularly beneficial because you can start
    writing your app in one window, and in a separate terminal session have it running.
    Then, every time that you make a change and save the application, Sanic will restart
    the server and immediately your new code is available for testing.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the auto-reloading, but not all the extra verbosity, consider using
    `--auto-reload` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Why --workers=2?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is not an uncommon problem where someone begins to build an application and
    then realizes down the road that they have made a mistake by not preparing for
    horizontal scaling. Perhaps they added global state that cannot be accessed outside
    of a single process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Oops, now that person needs to go back and re-engineer the solution if they
    want to scale up the application. This could be a costly endeavor. Luckily, we
    are smarter than that.
  prefs: []
  type: TYPE_NORMAL
- en: By forcing our development pattern to include multiple workers from the beginning,
    it will help remind us as we are solving problems that our application *must*
    account for scaling. Even if our ultimate deployment does not use multiple Sanic
    workers per instance (and instead, for example, uses multiple Kubernetes pods
    with single worker instances–see *Chapter 9, Best practices to improve your web
    applications*), this constant safeguard is a helpful way to keep the ultimate
    goal integral to the design process.
  prefs: []
  type: TYPE_NORMAL
- en: Directory Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many different patterns you can follow for organizing a web application.
    Perhaps the simplest would be the single file `server.py` where all of your logic
    exists together. For obvious reasons, this is not a practical solution for larger,
    real world projects. So we will ignore that one.
  prefs: []
  type: TYPE_NORMAL
- en: What types of solutions are there? Perhaps we could use the “apps” structure
    that Django prefers where discrete portions of our application are grouped together
    into a single module. Or, perhaps you prefer to group by type, for example, by
    keeping all of your view controllers together. We make no judgments here about
    what is better for your needs, but we need to understand some consequences of
    our decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When making a decision, you might want to learn some common practices. This
    might be a good opportunity to go look up some of the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model View Controller** (**MVC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model View ViewModel** (**MVVM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Driven Design** (**DDD**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean Architecture** (**CA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just to give you a flavor of the differences (or at least my interpretation
    of them), you might structure your project in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might use MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you might use DDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this book, we are going to adopt something that approximates a hybrid approach.
    There is a time and place for applying these theoretical constructs. I urge you
    to learn them. The information is useful. But we are here to learn *how* to practically
    go about building an application with Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the modified structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let’s breakdown each of these to see what they might look like and understand
    the thought process behind this application design.
  prefs: []
  type: TYPE_NORMAL
- en: ./blueprints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This might strike you as odd since ultimately this directory looks like it contains
    more than just blueprints. And, you would be right. Looking at the tree, you see
    that “blueprints” includes both `view.py` and `model.py`. The goal of this directory
    is to separate your application into logical components, or domains. It functions
    much the same way as an `apps` directory might in a Django application. If you
    can isolate some construct or portion of your application as being a distinct
    entity, it should probably have a subfolder here.
  prefs: []
  type: TYPE_NORMAL
- en: A single module in this directory might contain models for validating incoming
    requests, utilities for fetching data from a database, and blueprints with attached
    route handlers. This keeps related code close together.
  prefs: []
  type: TYPE_NORMAL
- en: But why call it `blueprints`? Each subdirectory will contain much more than
    a single `Blueprint` object. The point is to reinforce the idea that everything
    in this directory resolves around one of these discrete components. The standard
    method for organization a so-called component in Sanic is the `Blueprint` (which
    we will more about in the next section). Therefore, each subdirectory will have
    one–and only one–`Blueprint` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important rule: *nothing* inside the `./bluprints` directory will reference
    our Sanic application. That means that both `Sanic.get_app()` and `from server
    import app` are forbidden inside this directory.'
  prefs: []
  type: TYPE_NORMAL
- en: It is generally helpful to think of a blueprint as corresponding to a portion
    of your API design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '`example.com/auth -> ./blueprints/auth`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com/cake -> ./blueprints/cake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com/pie -> ./blueprints/pie`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com/user -> ./blueprints/user`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ./middleware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This directory should contain any middleware that is meant to be global in scope.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As discussed later in this Chapter and in *Chapter 6, Outside the response cycle*
    and also at the Sanic User Guide ([https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware](https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware)),
    middleware can be global or attach to blueprints. If you need to apply middleware
    to specific routes, perhaps blueprint based middleware makes sense. In this case,
    you should nest them in the appropriate `./blueprints` directory and not here.
  prefs: []
  type: TYPE_NORMAL
- en: ./common
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This module is meant to be a place to store class definitions and functions
    that will be used to build your application. It is for everything that will span
    your blueprints and be pervasive within your application.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to expand upon the directory structure here to meet your needs. But, try
    not to add too many top level directories. If you start cluttering up your folders,
    think about how you might be able to nest directories inside one another. Usually
    you will find that this leads to a cleaner architecture. There is also such as
    thing as going too far with nesting. For example, if you need to navigate ten
    levels deep in your appication code, perhaps you should dial it back.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s still Day 0\. You still have a lot of great ideas in your head about what
    you want to build. And thanks to some thoughtful pre-planning, we now have an
    effective setup for building out application locally. At this point we should
    know how the application will run locally, and generally how the project will
    be organized. What we will learn next is the transition step from application
    structure to business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Using Blueprints effectively
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you already know what a blueprint is, imagine for a moment that you do not.
    As we are building out our application and trying to structure our code base in
    a logical and maintainable pattern, we realize that we need to constantly pass
    around our `app` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This can become very tedious if we need to make changes to our endpoints. You
    can imagine a scenario where we would need to go update a bunch of separate files
    to duplicate the same change over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps more frustratingly, we might end up in a scenario where we have circular
    imports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Blueprints solve both of these problems, and allow us to abstract away some
    content so that the component can stand on its own. Returning to the above example,
    we take the common part of the endpoints (`/my`) and add it to the `Blueprint`
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we were able to group these routes together into a single blueprint.
    Importantly, this allows us to pull common parts of the URL path (`/my`) to the
    `Blueprint`, which gives us flexibility to make changes in the future.
  prefs: []
  type: TYPE_NORMAL
- en: No matter how you decide to organize your file structure, you probably should
    always use blueprints. They make organization easier, and can even be nested.
    Personally, I will only ever use `@app.route` in the most trivial of web applications.
    For any *real* projects, I always attach routes to blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just creating our blueprints is not enough. Python would have no way to know
    they exist. We need to import our blueprints and attach them to our application.
    This is done through a simple registration method: `app.blueprint()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A common “gotcha” is misunderstanding what `blueprint` is doing. Something
    like this will not work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At the instant that we register a Blueprint, everything that was attached to
    it will reattach to the application. That means that anything added to the Blueprint
    *after* the call to `app.blueprint()` will not be applied. In the above example,
    `/oops` will not exist on the application. Therefore, you should try and register
    your blueprints as late as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I think it is super convenient to always name blueprint variables `bp`. When
    I open a file, I automatically know what `bp` means. Some people may find it helpful
    to name their variable more meaningful: `user_bp` or `auth_bp`. For me, I would
    rather keep them consistent in the files I am always looking at, and just rename
    them at import: `from user import bp as user_bp`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Blueprint versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very powerful and common construct in API design is versioning. Let’s imagine
    that we are developing our book API that will be consumed by customers. They have
    already created their integrations, and perhaps they have been using the API for
    some time already.
  prefs: []
  type: TYPE_NORMAL
- en: You have some new business requirements, or new features you want to support.
    The only way to accomplish that is to change how a particular endpoint works.
    But, this will break backwards compatibility for the users. This is a dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: API designers often solve this problem by versioning their routes. Sanic makes
    this easy by adding a keyword argument to a route definition, or (perhaps more
    usefully) a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about versioning in the User Guide ([https://sanicframework.org/en/guide/advanced/versioning.html](https://sanicframework.org/en/guide/advanced/versioning.html))
    and we will discuss it in more depth in *Chapter 3, Routing and intaking HTTP
    requests*. For now, we will be content to know that our original API design needs
    a modification, and we will see how we can achieve that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping blueprints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you begin to develop your applications, you might start to see similarities
    between blueprints. Just like we saw that we could pull common parts of routes
    out to the `Blueprint`, we can pull common parts of a `Blueprint` out into a `BlueprintGroup`.
    This provides the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have now added `/api` to the beginning of every route path defined inside
    of `myinfo` and `somethingelse`.
  prefs: []
  type: TYPE_NORMAL
- en: By grouping blueprints, we are condensing our logic and becoming less repetitive.
    In the above example, by adding a prefix to the whole group, we no longer need
    to manage individual endpoints or even Blueprints. We really need to keep the
    nesting possibilities in mind as we design the layout of our endpoints and our
    project structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last section, we mentioned using versions to provide an easy path towards
    flexibly upgrading our API. Let’s go back to our book tracking application and
    see what this might look like. If you recall our application looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `view.py` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`# ./blueprints/book/view.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bp = Blueprint("book", url_prefix="/book")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`# ./blueprints/author/view.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bp = Blueprint("author", url_prefix="/author")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s imagine the scenario where this API is already deployed and in use by
    customers when our new business requirements come in for a `/v2/books` route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add it to our existing architecture, and immediately it is starting to look
    ugly and messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s re-factor this. We will not change `./blueprints/author` or `./blueprints/book`,
    just nest them a little deeper. That part of the application is already built
    and we do not want to touch it. But, now that we have learned from our mistake,
    we want to revise our strategy for `/v2` endpoints to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We just created a new file, `group.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Grouping blueprints is a powerful concept when building complex APIs. It allows
    us to nest Blueprints as deep as we need to, while providing us with both routing
    and organizational control. In this example, notice how we were able to assign
    `version=2` to the group. This means now that every route attached to a Blueprint
    in this group will have a `/v2` path prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it all up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have learned, creating a pragmatic directory structure leads to predictable
    and easy to navigate source code. Because it is predictable to us as developers,
    it is also predictable for computers to run. Perhaps we can use this to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we discussed one of the problems we often encounter when trying to
    expand our application from the single file structure: circular imports. We can
    solve this well with our blueprints, but it still leaves us wondering about what
    to do with things that we might want to attach at the application level (such
    as middleware, listeners, and signals). Let’s take a look at those use cases now.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlled imports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is generally preferred to break code up into modules using nested directories
    and files that helps us both logically think about our code, but also navigate
    to it. This does not come without a cost. What happens when there are two modules
    that are interdependent? This will cause a circular import exception, and our
    Python application will crash. We need to not only think about how to logically
    organize our code, but also how different parts of the code can be imported and
    used in other locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. First, create a file called `./server.py` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Second, create a second file called `./services/db.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates the problem. When we run our application, we need `Sanic(__file__)`
    to run before `Sanic.get_app()`. But, we need to import `.services.db` so that
    it can attach to our application. Which file evaluates first? Since the Python
    interpreter will run instructions sequentially, we need to make sure that we instantiate
    the `Sanic()` object before importing the `db` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But, it sort of looks ugly and non-Pythonic. Indeed, if you run tools like
    `flake8` you will start to notice that your environment does not really like this
    pattern so much either. It breaks the normal practice of placing imports at the
    top of the file. Learn more about this anti-pattern here: [https://www.flake8rules.com/rules/E402.html](https://www.flake8rules.com/rules/E402.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You may decide that you do not care, and that is perfectly okay. Remember, we
    are in this to find the solution that works for your application. Before we make
    the decision, however, let’s look at some other alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have a single “startup” file that will be a controlled set of import
    ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of running `sanic server:app` we want to point our server to the
    new `startup.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s keep looking for an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `Sanic.get_app()` construct is a very useful pattern to get access to your
    app instance without having to pass it around by import. This is a very helpful
    step in the right direction, and you can learn more about it in the User Guide.
    https://sanicframework.org/en/guide/basics/app.html#app-registry
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to move our application creation into a factory pattern. You may
    be familiar with this if you come from Flask as many examples and tutorials use
    a similar construct. The main reason for doing this here is that we want to setup
    our application for good development practices in the future. It also will ultimately
    solve the circular import problem. Later on down the line in Chapter 9, we will
    talk about testing. In the absence of a nice factory, testing will become much
    more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a new file `./utilities/app_factory.py`, and redo our `./server.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our new factory will create the `app` instance, and attach some
    blueprints to it. We specifically are allowing for the factory to override the
    blueprints that it will use. Perhaps this is unnecessary and we could instead
    hard-code them in all the time. But, I like the flexibility that this provides
    us, and find it helpful later on down the road when I want to start testing my
    application.
  prefs: []
  type: TYPE_NORMAL
- en: One problem that might jump out at you is that it requires our modules to have
    a global `bp` variable. While I mentioned that is standard practice for me, it
    might not work in all scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Autodiscovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sanic User Guide gives us another idea in the “How to…” section. See https://sanicframework.org/en/guide/how-to/autodiscovery.html.
    It suggests we create an `autodiscover` utility that will handle some of the importing
    for us, and also have the benefit of automatically attaching blueprints. Remember
    how I said I like predictable folder structures? We are about to take advantage
    of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create `./utilities/autodiscovery.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This file closely matches what the User Guide suggests ([https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py](https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py)).
    Noticeably absent from the code presented there is the idea of recursion. If you
    look up the function in the User Guide, you will see that it includes the ability
    to recursively search through our source code looking for `Blueprint` instances.
    While convenient, in the application that we are building we want the express
    control provided by having to declare every blueprint’s location. Quoting Tim
    Peters, *The Zen of Python*, again:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  prefs: []
  type: TYPE_NORMAL
- en: What the autodiscover tool does is allow us to pass locations to modules, and
    hands the task of importing them over to the application. After loading the module,
    it will inspect it any Blueprints. The last thing it will handle is automatically
    registering the discovered Blueprints to our application instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `server.py` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this example, we are using the import paths as strings. We just as easily
    could import the modules here, and pass those objects since the `autodiscover`
    utility works with both module objects and strings. We prefer strings though since
    it will keep the annoying circular import exceptions away.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that this autodiscover tool could be used for
    a module containing middleware or listeners. The given example is still fairly
    simplistic, and will not cover all use cases. How, for example, should we handle
    deeply nested Blueprint groups? This is a great opportunity for you to experiment,
    and I highly encourage you to spend some time playing with application structure
    and the autodiscover tool to figure out what works best for you.
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have laid our application foundations, we are almost ready to run
    our server. We are going to make one small change to `server.py` to include a
    small little utility to run at startup to show us what routes are registered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can head over to the GitHub repository [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02)
    to see the full source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start our application for the first time. Remember, this is going
    to be our pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, for the tempting part. What does our code actually do? Head over to
    your favorite web browser and open: [http://127.0.0.1:7777/book](http://127.0.0.1:7777/book).
    It might not be much to look at yet, but you should see some JSON data. Next,
    try going to `/author` and `/v2/book`. You should now see the content that we
    created above. Feel free to play around with these routes adding to them. Every
    time you do, you should see your changes reflected in the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Our journey into web application development as officially begun.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at the important impact of some of the early decisions we make
    about setting up our environment and project organization. We can—and should—constantly
    adapt our environment and application to meet changing needs. We used `pdm` to
    leverage some of the newest tools for running our server in a well-defined and
    isolated environment.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we then started to build our application. Perhaps we were too
    hasty when we added our `/book` route, because we quickly realized that we needed
    the endpoint to perform differently. Rather than breaking the application for
    existing users, we simply created a new group of blueprints that will be the beginning
    of a `/v2` of our API. By nesting and grouping blueprints, we are setting the
    application up for future flexibility and development maintainability. Going forward,
    let’s stick to this pattern as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined a few alternative approaches for organizing our application
    logic. These early decisions will impact the import ordering and shape the look
    of the application. We decided to adopt a factory method that will help us in
    the future when we start to test the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the basic application structure decided, we will begin in the next chapter
    to explore the most important aspect of a web server and framework: handling the
    request/response cycle. We know that we will use blueprints, but it is time to
    dive in and look more closely at what we can do with Sanic routing and handlers.
    In this chapter, there was a taste of it with API versioning. In the next chapter
    we will also look at routing more generally, and try to understand some strategies
    for designing application logic within a web API.'
  prefs: []
  type: TYPE_NORMAL
