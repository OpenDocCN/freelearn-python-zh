- en: 2 Organizing a project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is Day 0\. You have a project in hand. You are fired up and ready to build
    a new web application. Ideas are swirling in your head, and your fingers are itching
    to start punching the keyboard. Time to sit down and start coding!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Or is it? It is tempting to start building an application as soon as the ideas
    about what we want to build begin to formulate in our heads. Before doing that,
    we should think about setting ourselves up for success. Having a solid foundation
    for the building will make the process much easier, reduce bugs, and result in
    a cleaner application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The three foundations for beginning any Python web application project are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: your IDE/coding editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an environment for running your development application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a project application structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three elements take into account a lot of personal tastes. There are
    so many good tools and approaches. There is no way a single book could cover them
    all. If you are a more seasoned developer and already have a set of preferences:
    great, run with that and skip ahead to the next chapter.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore a couple of modern options to get you up and
    running. The focus will be upon foundation #2 (the environment) and foundation
    #3 (the application structure). We skip #1 and assume you are using a modern IDE
    of your own choosing. Popular choices in the Python world include VS Code, Pycharm,
    and Sublime Text. If you are not using one of these or something similar, go look
    them up and find one that works for you.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: After we setup our environment, we will explore some patterns to be implemented
    in Sanic that will help define your application architecture. This is not a software
    architecture book. I highly recommend you learn about approaches like “Domain
    Driven Design” and “Clean Architecture”. This book is focused much more on the
    practical aspects and decisions of building a web application in Sanic, so feel
    free to adjust the patterns as you feel necessary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll go through the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an environment and directory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using blueprints effectively
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring it all up
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running our application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we begin, we will assume you have the following already setup on your
    computer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Modern Python installation (Python 3.7 or newer)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal (and basic knowledge of how to execute programs)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE (as discussed above)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an environment and directory
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first few steps that you take when starting any project have a monumental
    impact on the entirety of the project. Whether you are embarking on a multi-year
    project—or one that will be complete in a couple of hours—these early decisions
    will shape how you and others work on the project. But, even though these are
    important choices, do not fall into the trap of thinking that you need to find
    the *perfect* solution. There is no single “right way” to set up an environment
    or project directory. Remember our discussion from the previous chapter: we want
    to make the choices that fit the project at hand.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始任何项目时，你采取的前几步将对整个项目产生重大影响。无论你是开始一个可能持续多年的项目，还是只需要几个小时就能完成的项目，这些早期的决定将塑造你和他人如何在这个项目上工作。但是，尽管这些选择很重要，不要陷入认为你需要找到*完美*解决方案的陷阱。没有单一的正确方式来设置环境或项目目录。记住我们之前章节的讨论：我们想要做出适合当前项目的选择。
- en: Environment
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境
- en: A good practice for Python development is to isolate its running environment
    from other projects. This is typically accomplished with virtual environments.
    In its most basic understanding, a virtual environment is a tool that allows you
    to install Python dependencies in isolation. This is important so that when we
    begin to develop our application, we have control of the requirements and dependencies
    in use. In its absence, we might mistakenly run our application and have requirements
    from other projects bleed into the application causing bugs and unintended behaviors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python开发来说，一个良好的实践是将它的运行环境与其他项目隔离开来。这通常是通过虚拟环境来实现的。在最基本的理解中，虚拟环境是一个工具，它允许你在隔离的环境中安装Python依赖项。这很重要，因为当我们开始开发我们的应用程序时，我们可以控制所使用的需求和依赖项。如果没有它，我们可能会错误地运行我们的应用程序，导致其他项目的需求渗透到应用程序中，造成错误和意外的行为。
- en: Usage of a virtual environment is so foundational in the Python development
    world, that it has become the expected “norm” when creating a Python script or
    application. The first step you should always do when starting a new project is
    making a new virtual environment for it. The alternative to them is to run your
    application with your operating system’s installation of Python. Do not do this.
    It may be fine for a while, but eventually, you will come across conflicting requirements,
    naming collisions, or other difficulties that all stem from a lack of isolation.
    The first step to becoming a better Python developer is to use virtual environments
    if you are not already.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python开发世界中，虚拟环境的使用是如此基础，以至于在创建Python脚本或应用程序时，它已经成为预期的“规范”。当你开始一个新的项目时，你应该做的第一步是为它创建一个新的虚拟环境。它们的替代方案是使用操作系统安装的Python运行你的应用程序。不要这样做。这可能在一开始是可行的，但最终，你将遇到冲突的需求、命名冲突或其他困难，所有这些困难都源于缺乏隔离。成为更好的Python开发者的第一步是使用虚拟环境，如果你还没有这样做的话。
- en: It is also extremely helpful to acquaint yourself with the different tools that
    IDEs provide in hooking up to your virtual environment. These tools will often
    include things like code completion, and guide you as you start using features
    of your dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉IDE提供的将虚拟环境连接到你的不同工具也非常有帮助。这些工具通常包括代码补全等功能，并指导你开始使用依赖项的功能。
- en: We do eventually want to run our application using containers. Being able to
    run our application inside of a Docker container will greatly reduce the complexity
    in deploying our application down the road. This will be discussed further in
    *Chapter 9, Best practices to improve your web applications*. However, I also
    believe that our application should be runnable (and therefore testable) from
    multiple environments. Even if we intend to use Docker down the road, we first
    need our application running locally without it. Debugging becomes much easier
    when our application does not rely upon an overly complex set of requirements
    just to run. Therefore, let’s spend some time thinking about how to setup a virtual
    environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终希望使用容器来运行我们的应用程序。能够在Docker容器中运行我们的应用程序将大大减少未来部署应用程序的复杂性。这将在*第9章，提高你的Web应用程序的最佳实践*中进一步讨论。然而，我也相信我们的应用程序应该能够在多个环境中运行（因此可测试）。即使我们打算将来使用Docker，我们首先也需要在没有它的本地环境中运行我们的应用程序。当我们的应用程序不依赖于过于复杂的依赖项来运行时，调试变得更加容易。因此，让我们花些时间思考如何设置虚拟环境。
- en: There are many great tutorials and resources about how to use virtual environments.
    There are also many tools out there that are created to help manage the process.
    While I personally am a fan of the simple, tried and true method of `virtualenv`
    plus `virtuanenvwrapper`, there are many people who are fans of `pipenv`, or `poetry`.
    These latter tools are meant to be a more “complete” encapsulation of your running
    environment. If they work for you, great. You are encouraged to spend some time
    to see what strikes a chord and resonates with your development pattern and needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We will leave virtual environments aside for now, and briefly explore the usage
    of a relatively new pattern in Python. In Python 3.8, Python adopted a new pattern
    in PEP 582 that formalizes the inclusion of requirements into an isolated environment
    in a special `__pypackages__` directory that lives inside the project. While the
    concept is similar to virtual environments, it works a little differently.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement `__pypackages__`, we are making it mandatory for our fictitious
    development team to use `pdm`. This is a relatively new tool that makes it super
    simple to adhere to some of the latest practices in modern Python development.
    If this approach interests you, take some time to go read PEP 582 ([https://www.python.org/dev/peps/pep-0582/](https://www.python.org/dev/peps/pep-0582/))
    and look at `pdm` ([https://pdm.fming.dev/](https://pdm.fming.dev/)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get started by installing it with `pip`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Refer to the installation instructions on their website for more details: [https://pdm.fming.dev/#installation](https://pdm.fming.dev/#installation).
    Pay particular attention to useful features like shell completion and IDE integrations.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s proceed with setting up:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we create a new directory for our application, and from that
    directory run the following and follow the prompts to setup a basic structure.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we will install Sanic.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now have access to Sanic. Just to confirm in our heads that we are indeed
    in an isolated environment, let’s quickly jump into the Python REPL, and check
    the location of Sanic using: sanic.__file__.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sanic CLI
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in *Chapter 8, Running a Server*, there are many considerations
    that go into *how* to deploy and run Sanic. Unless we are specifically looking
    into one of these alternatives, you can assume in this book that we are running
    Sanic using the Sanic CLI. This will standup our application using the integrated
    Sanic web server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will check to see what version we are running:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And check to see what options we can use with the CLI:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our standard form for running our applications right now will be:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What thought went into the decision for using this command? Let’s take a look.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Why src.server:app?
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we are going to run this from the `./booktracker` directory. All of our
    code will be nested in a `src` directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, it is somewhat standard practice that our application creates a single
    `Sanic()` instance, and assigns it to a variable called `app`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we were to place that into a file called `app.py`, then our module and variable
    start to get confused.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above import statement is, well, ugly. As much as possible, it is beneficial
    to avoid naming conflicts between modules and the contents of that module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'A bad example of this exists in the standard library. Have you ever done this
    one by accident:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Oops, we should have used `from datetime import datetime`. We want to minimize
    the replication of module names and properties, and to make our imports easy to
    remember and intuitive to look at.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will place our global `app` variable into a file called `server.py`.
    Sanic will look for our app instance when you pass in the form: `<module>:<variable>`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Why -p 7777?
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We, of course, could choose any arbitrary port here. Many web servers will use
    port `8000` and that is the Sanic default if we just left it out completely. However,
    precisely because it is standard, we want to choose something else. Often, it
    is beneficial to choose a port that is less likely to collide with other ports
    that might be running on your machine. The more we can preserve common ports,
    the less likely we will run into collisions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Why --debug?
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While developing, having `DEBUG` mode enabled provides: a more verbose output
    from Sanic, and an auto-reloading server. It can be helpful to see more logs,
    but make sure you turn this off in production.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The auto-reloading feature is particularly beneficial because you can start
    writing your app in one window, and in a separate terminal session have it running.
    Then, every time that you make a change and save the application, Sanic will restart
    the server and immediately your new code is available for testing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: If you want the auto-reloading, but not all the extra verbosity, consider using
    `--auto-reload` instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Why --workers=2?
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is not an uncommon problem where someone begins to build an application and
    then realizes down the road that they have made a mistake by not preparing for
    horizontal scaling. Perhaps they added global state that cannot be accessed outside
    of a single process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Oops, now that person needs to go back and re-engineer the solution if they
    want to scale up the application. This could be a costly endeavor. Luckily, we
    are smarter than that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: By forcing our development pattern to include multiple workers from the beginning,
    it will help remind us as we are solving problems that our application *must*
    account for scaling. Even if our ultimate deployment does not use multiple Sanic
    workers per instance (and instead, for example, uses multiple Kubernetes pods
    with single worker instances–see *Chapter 9, Best practices to improve your web
    applications*), this constant safeguard is a helpful way to keep the ultimate
    goal integral to the design process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Directory Structure
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many different patterns you can follow for organizing a web application.
    Perhaps the simplest would be the single file `server.py` where all of your logic
    exists together. For obvious reasons, this is not a practical solution for larger,
    real world projects. So we will ignore that one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组织Web应用程序，你可以遵循许多不同的模式。可能最简单的是单文件`server.py`，其中包含所有的逻辑。由于显而易见的原因，这不是更大、更实际的项目的实际解决方案。所以我们将忽略这一点。
- en: What types of solutions are there? Perhaps we could use the “apps” structure
    that Django prefers where discrete portions of our application are grouped together
    into a single module. Or, perhaps you prefer to group by type, for example, by
    keeping all of your view controllers together. We make no judgments here about
    what is better for your needs, but we need to understand some consequences of
    our decisions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些类型的解决方案？也许我们可以使用Django偏好的“apps”结构，将应用程序的离散部分组合成一个模块。或者，也许你更喜欢按类型分组，例如，将所有的视图控制器放在一起。在这里，我们不做任何关于什么更适合你需求的判断，但我们需要了解我们决策的一些后果。
- en: 'When making a decision, you might want to learn some common practices. This
    might be a good opportunity to go look up some of the following patterns:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在做决定时，你可能想了解一些常见的做法。这可能是一个查找以下模式的好机会：
- en: '**Model View Controller** (**MVC**)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型视图控制器**（**MVC**）'
- en: '**Model View ViewModel** (**MVVM**)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型视图视图模型**（**MVVM**）'
- en: '**Domain Driven Design** (**DDD**)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）'
- en: '**Clean Architecture** (**CA**)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清洁架构**（**CA**）'
- en: 'Just to give you a flavor of the differences (or at least my interpretation
    of them), you might structure your project in one of the following ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了让你了解这些差异（或者至少是我对它们的解释），你可能会以以下方式之一来构建你的项目：
- en: 'You might use MVC:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会使用MVC：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you might use DDD:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可能使用DDD：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this book, we are going to adopt something that approximates a hybrid approach.
    There is a time and place for applying these theoretical constructs. I urge you
    to learn them. The information is useful. But we are here to learn *how* to practically
    go about building an application with Sanic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将采用一种类似于混合方法的东西。应用这些理论结构的时间和地点是存在的。我敦促你们去学习它们。这些信息是有用的。但我们在这里是为了学习**如何**使用Sanic实际构建一个应用程序。
- en: 'Here’s the modified structure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的结构：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s breakdown each of these to see what they might look like and understand
    the thought process behind this application design.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些，看看它们可能是什么样子，并理解这个应用程序设计的背后的思考过程。
- en: ./blueprints
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ./blueprints
- en: This might strike you as odd since ultimately this directory looks like it contains
    more than just blueprints. And, you would be right. Looking at the tree, you see
    that “blueprints” includes both `view.py` and `model.py`. The goal of this directory
    is to separate your application into logical components, or domains. It functions
    much the same way as an `apps` directory might in a Django application. If you
    can isolate some construct or portion of your application as being a distinct
    entity, it should probably have a subfolder here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你觉得有些奇怪，因为最终这个目录看起来包含的不仅仅是蓝图。而且，你会是对的。查看树状结构，你会看到“blueprints”包括`view.py`和`model.py`。这个目录的目标是将你的应用程序分成逻辑组件或领域。它的工作方式与Django应用程序中的`apps`目录非常相似。如果你可以将某些结构或应用程序的一部分隔离为独立的实体，那么它可能应该有一个子目录。
- en: A single module in this directory might contain models for validating incoming
    requests, utilities for fetching data from a database, and blueprints with attached
    route handlers. This keeps related code close together.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本目录下的单个模块可能包含验证传入请求的模型、从数据库获取数据的实用工具以及带有附加路由处理器的蓝图。这样做可以将相关代码放在一起。
- en: But why call it `blueprints`? Each subdirectory will contain much more than
    a single `Blueprint` object. The point is to reinforce the idea that everything
    in this directory resolves around one of these discrete components. The standard
    method for organization a so-called component in Sanic is the `Blueprint` (which
    we will more about in the next section). Therefore, each subdirectory will have
    one–and only one–`Blueprint` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么叫它`blueprints`？每个子目录将包含比单个`Blueprint`对象多得多的内容。重点是强化这样一个观点：这个目录中的所有内容都围绕这些离散组件之一。在Sanic中组织所谓的组件的标准方法是`Blueprint`（我们将在下一节中了解更多）。因此，每个子目录将有一个——而且只有一个——`Blueprint`对象。
- en: 'Another important rule: *nothing* inside the `./bluprints` directory will reference
    our Sanic application. That means that both `Sanic.get_app()` and `from server
    import app` are forbidden inside this directory.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: It is generally helpful to think of a blueprint as corresponding to a portion
    of your API design pattern.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`example.com/auth -> ./blueprints/auth`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com/cake -> ./blueprints/cake`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com/pie -> ./blueprints/pie`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com/user -> ./blueprints/user`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ./middleware
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This directory should contain any middleware that is meant to be global in scope.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As discussed later in this Chapter and in *Chapter 6, Outside the response cycle*
    and also at the Sanic User Guide ([https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware](https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware)),
    middleware can be global or attach to blueprints. If you need to apply middleware
    to specific routes, perhaps blueprint based middleware makes sense. In this case,
    you should nest them in the appropriate `./blueprints` directory and not here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: ./common
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This module is meant to be a place to store class definitions and functions
    that will be used to build your application. It is for everything that will span
    your blueprints and be pervasive within your application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to expand upon the directory structure here to meet your needs. But, try
    not to add too many top level directories. If you start cluttering up your folders,
    think about how you might be able to nest directories inside one another. Usually
    you will find that this leads to a cleaner architecture. There is also such as
    thing as going too far with nesting. For example, if you need to navigate ten
    levels deep in your appication code, perhaps you should dial it back.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s still Day 0\. You still have a lot of great ideas in your head about what
    you want to build. And thanks to some thoughtful pre-planning, we now have an
    effective setup for building out application locally. At this point we should
    know how the application will run locally, and generally how the project will
    be organized. What we will learn next is the transition step from application
    structure to business logic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Using Blueprints effectively
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you already know what a blueprint is, imagine for a moment that you do not.
    As we are building out our application and trying to structure our code base in
    a logical and maintainable pattern, we realize that we need to constantly pass
    around our `app` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This can become very tedious if we need to make changes to our endpoints. You
    can imagine a scenario where we would need to go update a bunch of separate files
    to duplicate the same change over and over again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps more frustratingly, we might end up in a scenario where we have circular
    imports.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Blueprints solve both of these problems, and allow us to abstract away some
    content so that the component can stand on its own. Returning to the above example,
    we take the common part of the endpoints (`/my`) and add it to the `Blueprint`
    definition.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图解决了这两个问题，并允许我们抽象出一些内容，以便组件可以独立存在。回到上面的例子，我们将端点的公共部分（`/my`）添加到`Blueprint`定义中。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we were able to group these routes together into a single blueprint.
    Importantly, this allows us to pull common parts of the URL path (`/my`) to the
    `Blueprint`, which gives us flexibility to make changes in the future.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们能够将这些路由组合成一个单独的蓝图。重要的是，这允许我们将URL路径的公共部分（`/my`）拉到`Blueprint`中，这为我们提供了在将来进行更改的灵活性。
- en: No matter how you decide to organize your file structure, you probably should
    always use blueprints. They make organization easier, and can even be nested.
    Personally, I will only ever use `@app.route` in the most trivial of web applications.
    For any *real* projects, I always attach routes to blueprints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定如何组织你的文件结构，你可能应该始终使用蓝图。它们使组织更容易，甚至可以嵌套。我个人只会在我最简单的Web应用中使用`@app.route`。对于任何*真实*的项目，我总是将路由附加到蓝图上。
- en: Blueprint registration
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图注册
- en: 'Just creating our blueprints is not enough. Python would have no way to know
    they exist. We need to import our blueprints and attach them to our application.
    This is done through a simple registration method: `app.blueprint()`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建我们的蓝图是不够的。Python将无法知道它们的存在。我们需要导入我们的蓝图并将它们附加到我们的应用程序上。这是通过一个简单的注册方法完成的：`app.blueprint()`。
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A common “gotcha” is misunderstanding what `blueprint` is doing. Something
    like this will not work as expected:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的“陷阱”是误解了`blueprint`的作用。以下这样的代码不会按预期工作：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At the instant that we register a Blueprint, everything that was attached to
    it will reattach to the application. That means that anything added to the Blueprint
    *after* the call to `app.blueprint()` will not be applied. In the above example,
    `/oops` will not exist on the application. Therefore, you should try and register
    your blueprints as late as possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们注册蓝图的那一刻，所有附加到它的内容都将重新附加到应用程序上。这意味着在调用`app.blueprint()`之后添加到蓝图中的任何内容都不会应用。在上面的例子中，`/oops`将不会存在于应用程序中。因此，你应该尽可能晚地注册你的蓝图。
- en: '**TIP**'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I think it is super convenient to always name blueprint variables `bp`. When
    I open a file, I automatically know what `bp` means. Some people may find it helpful
    to name their variable more meaningful: `user_bp` or `auth_bp`. For me, I would
    rather keep them consistent in the files I am always looking at, and just rename
    them at import: `from user import bp as user_bp`.'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为始终将蓝图变量命名为`bp`非常方便。当我打开一个文件时，我自动就知道`bp`代表什么。有些人可能觉得将变量命名得更有意义更有帮助：`user_bp`或`auth_bp`。对我来说，我更愿意在我总是查看的文件中保持一致性，并在导入时重命名它们：`from
    user import bp as user_bp`。
- en: Blueprint versioning
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图版本控制
- en: A very powerful and common construct in API design is versioning. Let’s imagine
    that we are developing our book API that will be consumed by customers. They have
    already created their integrations, and perhaps they have been using the API for
    some time already.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在API设计中，版本控制是一个非常强大且常见的结构。让我们想象一下，我们正在开发我们的书籍API，该API将被客户使用。他们已经创建了他们的集成，也许他们已经使用了一段时间的API。
- en: You have some new business requirements, or new features you want to support.
    The only way to accomplish that is to change how a particular endpoint works.
    But, this will break backwards compatibility for the users. This is a dilemma.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些新的业务需求，或者你想要支持的新功能。完成这一点的唯一方法是改变特定端点的工作方式。但这将破坏用户的向后兼容性。这是一个困境。
- en: API designers often solve this problem by versioning their routes. Sanic makes
    this easy by adding a keyword argument to a route definition, or (perhaps more
    usefully) a Blueprint.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: API设计者通常通过版本控制他们的路由来解决此问题。Sanic通过向路由定义添加一个关键字参数或（可能更有用）一个蓝图来简化这一点。
- en: You can learn more about versioning in the User Guide ([https://sanicframework.org/en/guide/advanced/versioning.html](https://sanicframework.org/en/guide/advanced/versioning.html))
    and we will discuss it in more depth in *Chapter 3, Routing and intaking HTTP
    requests*. For now, we will be content to know that our original API design needs
    a modification, and we will see how we can achieve that in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Grouping blueprints
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you begin to develop your applications, you might start to see similarities
    between blueprints. Just like we saw that we could pull common parts of routes
    out to the `Blueprint`, we can pull common parts of a `Blueprint` out into a `BlueprintGroup`.
    This provides the same purpose.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have now added `/api` to the beginning of every route path defined inside
    of `myinfo` and `somethingelse`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: By grouping blueprints, we are condensing our logic and becoming less repetitive.
    In the above example, by adding a prefix to the whole group, we no longer need
    to manage individual endpoints or even Blueprints. We really need to keep the
    nesting possibilities in mind as we design the layout of our endpoints and our
    project structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last section, we mentioned using versions to provide an easy path towards
    flexibly upgrading our API. Let’s go back to our book tracking application and
    see what this might look like. If you recall our application looked like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the `view.py` files:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`# ./blueprints/book/view.py`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bp = Blueprint("book", url_prefix="/book")`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`# ./blueprints/author/view.py`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bp = Blueprint("author", url_prefix="/author")`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s imagine the scenario where this API is already deployed and in use by
    customers when our new business requirements come in for a `/v2/books` route.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'We add it to our existing architecture, and immediately it is starting to look
    ugly and messy:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s re-factor this. We will not change `./blueprints/author` or `./blueprints/book`,
    just nest them a little deeper. That part of the application is already built
    and we do not want to touch it. But, now that we have learned from our mistake,
    we want to revise our strategy for `/v2` endpoints to look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We just created a new file, `group.py`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Grouping blueprints is a powerful concept when building complex APIs. It allows
    us to nest Blueprints as deep as we need to, while providing us with both routing
    and organizational control. In this example, notice how we were able to assign
    `version=2` to the group. This means now that every route attached to a Blueprint
    in this group will have a `/v2` path prefix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Wiring it all up
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have learned, creating a pragmatic directory structure leads to predictable
    and easy to navigate source code. Because it is predictable to us as developers,
    it is also predictable for computers to run. Perhaps we can use this to our advantage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we discussed one of the problems we often encounter when trying to
    expand our application from the single file structure: circular imports. We can
    solve this well with our blueprints, but it still leaves us wondering about what
    to do with things that we might want to attach at the application level (such
    as middleware, listeners, and signals). Let’s take a look at those use cases now.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Controlled imports
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is generally preferred to break code up into modules using nested directories
    and files that helps us both logically think about our code, but also navigate
    to it. This does not come without a cost. What happens when there are two modules
    that are interdependent? This will cause a circular import exception, and our
    Python application will crash. We need to not only think about how to logically
    organize our code, but also how different parts of the code can be imported and
    used in other locations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. First, create a file called `./server.py` like
    this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Second, create a second file called `./services/db.py`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example illustrates the problem. When we run our application, we need `Sanic(__file__)`
    to run before `Sanic.get_app()`. But, we need to import `.services.db` so that
    it can attach to our application. Which file evaluates first? Since the Python
    interpreter will run instructions sequentially, we need to make sure that we instantiate
    the `Sanic()` object before importing the `db` module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This will work:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But, it sort of looks ugly and non-Pythonic. Indeed, if you run tools like
    `flake8` you will start to notice that your environment does not really like this
    pattern so much either. It breaks the normal practice of placing imports at the
    top of the file. Learn more about this anti-pattern here: [https://www.flake8rules.com/rules/E402.html](https://www.flake8rules.com/rules/E402.html).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: You may decide that you do not care, and that is perfectly okay. Remember, we
    are in this to find the solution that works for your application. Before we make
    the decision, however, let’s look at some other alternatives.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have a single “startup” file that will be a controlled set of import
    ordering:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, instead of running `sanic server:app` we want to point our server to the
    new `startup.py`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s keep looking for an alternative.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `Sanic.get_app()` construct is a very useful pattern to get access to your
    app instance without having to pass it around by import. This is a very helpful
    step in the right direction, and you can learn more about it in the User Guide.
    https://sanicframework.org/en/guide/basics/app.html#app-registry
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Factory pattern
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to move our application creation into a factory pattern. You may
    be familiar with this if you come from Flask as many examples and tutorials use
    a similar construct. The main reason for doing this here is that we want to setup
    our application for good development practices in the future. It also will ultimately
    solve the circular import problem. Later on down the line in Chapter 9, we will
    talk about testing. In the absence of a nice factory, testing will become much
    more difficult.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: We need to create a new file `./utilities/app_factory.py`, and redo our `./server.py`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, our new factory will create the `app` instance, and attach some
    blueprints to it. We specifically are allowing for the factory to override the
    blueprints that it will use. Perhaps this is unnecessary and we could instead
    hard-code them in all the time. But, I like the flexibility that this provides
    us, and find it helpful later on down the road when I want to start testing my
    application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: One problem that might jump out at you is that it requires our modules to have
    a global `bp` variable. While I mentioned that is standard practice for me, it
    might not work in all scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Autodiscovery
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Sanic User Guide gives us another idea in the “How to…” section. See https://sanicframework.org/en/guide/how-to/autodiscovery.html.
    It suggests we create an `autodiscover` utility that will handle some of the importing
    for us, and also have the benefit of automatically attaching blueprints. Remember
    how I said I like predictable folder structures? We are about to take advantage
    of this pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create `./utilities/autodiscovery.py`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This file closely matches what the User Guide suggests ([https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py](https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py)).
    Noticeably absent from the code presented there is the idea of recursion. If you
    look up the function in the User Guide, you will see that it includes the ability
    to recursively search through our source code looking for `Blueprint` instances.
    While convenient, in the application that we are building we want the express
    control provided by having to declare every blueprint’s location. Quoting Tim
    Peters, *The Zen of Python*, again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Explicit is better than implicit.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: What the autodiscover tool does is allow us to pass locations to modules, and
    hands the task of importing them over to the application. After loading the module,
    it will inspect it any Blueprints. The last thing it will handle is automatically
    registering the discovered Blueprints to our application instance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `server.py` looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**TIP**'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this example, we are using the import paths as strings. We just as easily
    could import the modules here, and pass those objects since the `autodiscover`
    utility works with both module objects and strings. We prefer strings though since
    it will keep the annoying circular import exceptions away.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that this autodiscover tool could be used for
    a module containing middleware or listeners. The given example is still fairly
    simplistic, and will not cover all use cases. How, for example, should we handle
    deeply nested Blueprint groups? This is a great opportunity for you to experiment,
    and I highly encourage you to spend some time playing with application structure
    and the autodiscover tool to figure out what works best for you.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have laid our application foundations, we are almost ready to run
    our server. We are going to make one small change to `server.py` to include a
    small little utility to run at startup to show us what routes are registered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can head over to the GitHub repository [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02)
    to see the full source code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start our application for the first time. Remember, this is going
    to be our pattern:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We should see something like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hooray!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, for the tempting part. What does our code actually do? Head over to
    your favorite web browser and open: [http://127.0.0.1:7777/book](http://127.0.0.1:7777/book).
    It might not be much to look at yet, but you should see some JSON data. Next,
    try going to `/author` and `/v2/book`. You should now see the content that we
    created above. Feel free to play around with these routes adding to them. Every
    time you do, you should see your changes reflected in the web browser.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Our journey into web application development as officially begun.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at the important impact of some of the early decisions we make
    about setting up our environment and project organization. We can—and should—constantly
    adapt our environment and application to meet changing needs. We used `pdm` to
    leverage some of the newest tools for running our server in a well-defined and
    isolated environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we then started to build our application. Perhaps we were too
    hasty when we added our `/book` route, because we quickly realized that we needed
    the endpoint to perform differently. Rather than breaking the application for
    existing users, we simply created a new group of blueprints that will be the beginning
    of a `/v2` of our API. By nesting and grouping blueprints, we are setting the
    application up for future flexibility and development maintainability. Going forward,
    let’s stick to this pattern as much as possible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: We also examined a few alternative approaches for organizing our application
    logic. These early decisions will impact the import ordering and shape the look
    of the application. We decided to adopt a factory method that will help us in
    the future when we start to test the application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'With the basic application structure decided, we will begin in the next chapter
    to explore the most important aspect of a web server and framework: handling the
    request/response cycle. We know that we will use blueprints, but it is time to
    dive in and look more closely at what we can do with Sanic routing and handlers.
    In this chapter, there was a taste of it with API versioning. In the next chapter
    we will also look at routing more generally, and try to understand some strategies
    for designing application logic within a web API.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
