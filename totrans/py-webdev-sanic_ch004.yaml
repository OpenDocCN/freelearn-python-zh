- en: 3 Routing and Intaking HTTP Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 路由和接收HTTP请求
- en: 'Back in *Chapter 1, Introduction to Sanic and Async Frameworks,* we looked
    at a raw HTTP request to see what kind of information it includes. In this chapter,
    we are going to take a closer look at that first line that contains the HTTP Method
    and the URI path. As we learned, the most basic function of a web framework is
    to translate the raw HTTP request into an actionable handler. Before we see how
    we can implement this, it is good to keep in mind what the raw requests look like:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章，Sanic和异步框架的介绍*中，我们查看了一个原始HTTP请求以了解它包含的信息。在本章中，我们将更仔细地查看包含HTTP方法和URI路径的第一行。正如我们所学的，Web框架最基本的功能是将原始HTTP请求转换为可执行的处理程序。在我们看到如何实现之前，记住原始请求的样子是好的：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the request, we see the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 观察请求，我们看到以下内容：
- en: 'The first line (sometimes called the *start line*) contains three subparts:
    **HTTP Method**, **request target**, and **HTTP** protocol'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行（有时称为*起始行*）包含三个子部分：**HTTP方法**、**请求目标**和**HTTP**协议
- en: 'The second section contains zero or more lines of HTTP headers in `key: value`
    form, with each pair separated by a line break'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第二部分包含零个或多个以`key: value`形式出现的HTTP头信息，每对之间由换行符分隔'
- en: Then, we have a blank line separating the head from the body
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个空白行将头部与正文分开
- en: Lastly, we have the *optional* body
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们还有可选的正文
- en: The exact specification is covered by RFC 7230, 3\. [https://datatracker.ietf.org/doc/html/rfc7230#section-3](https://datatracker.ietf.org/doc/html/rfc7230#section-3)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的规范由RFC 7230，3\. [https://datatracker.ietf.org/doc/html/rfc7230#section-3](https://datatracker.ietf.org/doc/html/rfc7230#section-3)
    覆盖
- en: 'One of the goals of this book is to learn strategies to design API endpoints
    that will be easily consumable, keeping in mind the needs and limitations of the
    application we are building. The goal is to understand the first interactions
    that the server has with an incoming web request, and how to design our application
    around that. We will learn about: how requests are structured; what choices Sanic
    makes for us and what choices it leaves; and other issues involved in turning
    an HTTP request into actionable code. Remember, the purpose of this book is not
    just to learn how to use a fancy new tool, but also to level-up web development
    skills and knowledge. To become more informed developers, we seek to not only
    understand *how* to build with Sanic, but *why* we might build something in a
    particular way. We will learn to ask better questions and to make better decisions
    by understanding some of the mechanics. This does not mean we need to be experts
    on the HTTP protocol and specification. By being familiar with, however, with
    what Sanic is doing with the raw request, we will ultimately be armed with a greater
    set of tools for building web applications.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是通过学习策略来设计易于消费的API端点，同时考虑到我们正在构建的应用程序的需求和限制。目标是理解服务器与传入的Web请求的第一交互，以及如何围绕这一点设计我们的应用程序。我们将学习：请求的结构；Sanic为我们做出的选择以及它留下的选择；以及将HTTP请求转换为可执行代码所涉及的其他问题。记住，本书的目的不仅仅是学习如何使用一个花哨的新工具，还要提升Web开发和知识技能。为了成为更了解的开发者，我们不仅寻求理解*如何*使用Sanic构建，还要理解*为什么*我们可能以特定方式构建某些内容。通过理解一些机制，我们将学会提出更好的问题并做出更好的决策。这并不意味着我们需要成为HTTP协议和规范的专家。然而，通过熟悉Sanic对原始请求的处理，我们最终将拥有构建Web应用程序的更强大的工具集。
- en: 'In particular, we’ll cover these topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Understanding HTTP Methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解HTTP方法
- en: Paths, slashes, and why they matter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径、斜杠及其重要性
- en: Advanced path parameters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级路径参数
- en: API versioning
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Virtual hosts
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟主机
- en: Serving static content
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态内容
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to what we have been building before, in this chapter you should
    have the following tools at your disposal in order to be able to follow along
    with the examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前所构建的内容之外，在本章中，你应该拥有以下工具以便能够跟随示例进行学习：
- en: Docker Compose
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Curl
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Curl
- en: 'You can access source code for this chapter on GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的源代码：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03)
- en: Understanding HTTP Methods
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解HTTP方法
- en: If you have built any kind of a website before, you probably have an understanding
    of the concept of **HTTP Methods**; or at least the basic `GET` and `POST` methods.
    However, did you know that there are nine standard HTTP Methods? In this section,
    we will learn about these different methods and how we *could* take advantage
    of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前构建过任何类型的网站，你可能对**HTTP方法**的概念有所了解；或者至少对基本的`GET`和`POST`方法有所了解。然而，你知道有九种标准的HTTP方法吗？在本节中，我们将了解这些不同的方法以及我们**可以**如何利用它们。
- en: 'In the same way that an IP address or a web domain is a *place* on the Internet,
    an HTTP Method is an *action* on the Internet. They are the collection of verbs
    in the language of the web. These HTTP Methods have a shared understanding and
    meaning. Web applications will commonly use these methods in similar use cases.
    That does not mean that you must follow the conventions, or that your application
    will break if you venture away from the standards. We should learn the rules so
    that we know when it may be appropriate to break them. These standards exist to
    create a common language that web developers and consumers can use to communicate:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像IP地址或网络域名是互联网上的**地点**一样，HTTP方法是在互联网上的**动作**。它们是网络语言中的动词集合。这些HTTP方法有一个共同的理解和意义。Web应用程序通常会在类似的使用场景中使用这些方法。这并不意味着你必须遵循这些约定，或者如果你的应用程序偏离了标准就会出错。我们应该学习这些规则，以便我们知道何时可能适合打破它们。这些标准存在是为了创建一个共同的语言，让Web开发者和消费者可以使用它来沟通：
- en: '| Method | Description | Has body | Safe | Sanic support |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | 有主体 | 安全 | Sanic支持 |'
- en: '| `CONNECT` | Open two-way communication, like a tunnel to the resource | No
    | Yes | No |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `CONNECT` | 打开双向通信，如到资源的隧道 | 否 | 是 | 否 |'
- en: '| `DELETE` | Delete the resource | No (usually) | No | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源 | 否（通常） | 否 | 是 |'
- en: '| `GET` | Fetch the resource | No | Yes | Yes |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取资源 | 否 | 是 | 是 |'
- en: '| `HEAD` | Fetch the meta-data *only* for the resource | No | Yes | Yes |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 仅获取资源的元数据 | 否 | 是 | 是 |'
- en: '| `OPTIONS` | Request permitted communication options | No | Yes | Yes |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 请求允许的通信选项 | 否 | 是 | 是 |'
- en: '| `PATCH` | Partially modify the resource | Yes | No | Yes |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 部分修改资源 | 是 | 否 | 是 |'
- en: '| `POST` | Send data to the server | Yes | No | Yes |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 向服务器发送数据 | 是 | 否 | 是 |'
- en: '| `PUT` | Create a new resource or update completely if existing | Yes | No
    | Yes |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 创建新资源或如果存在则完全更新 | 是 | 否 | 是 |'
- en: '| `TRACE` | Perform message loopback used for debugging | No | Yes | No |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `TRACE` | 执行用于调试的消息回环 | 否 | 是 | 否 |'
- en: Table 3.1 - HTTP Method Overview
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 - HTTP方法概述
- en: When we talk about a method being *safe*, what we mean is that it should not
    be state-changing. That is not to say that a `GET` method cannot have side effects.
    Of course, it can. For example, someone hitting the endpoint will trigger logs
    or some sort of a resource counter. These are technically what the industry might
    refer to as side-effects. “*The important distinction here is that the user did
    not request the side-effects, so therefore cannot be held accountable for them.”*
    RFC 2616, 9.1.1 ([https://datatracker.ietf.org/doc/html/rfc2616#section-9](https://datatracker.ietf.org/doc/html/rfc2616#section-9)).
    This means that from the perspective of the user accessing the resource, the determination
    of whether an endpoint is *safe* is a matter of intent. If the user intends to
    retrieve profile information, it is safe. If the user intends to update profile
    information, it is not safe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论一个方法是否**安全**时，我们的意思是它不应该改变状态。这并不是说`GET`方法不能有副作用。当然，它可以。例如，有人点击端点会触发日志或某种资源计数器。这些在技术上可能是行业所说的副作用。“*这里的重要区别是用户没有请求这些副作用，因此不能对它们负责。”*
    RFC 2616，9.1.1 ([https://datatracker.ietf.org/doc/html/rfc2616#section-9](https://datatracker.ietf.org/doc/html/rfc2616#section-9))。这意味着从用户访问资源的角度来看，确定一个端点是否**安全**是一个意图问题。如果用户意图检索个人资料信息，则是安全的。如果用户意图更新个人资料信息，则是不安全的。
- en: While it is certainly helpful to try and stick to the descriptions of the methods
    in *Table 3.1*, undoubtedly you will come across use cases that do not fit nicely
    into these categories. When that happens, I encourage you to reexamine your application
    design. Sometimes the problem can be solved with new endpoint paths. Sometimes
    we need to create our own definitions. This is okay. I would, however, caution
    against changing a *safe* method to *unsafe.* Performing stateful changes with
    a `GET` request is considered poor form, and a *rookie mistake*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管尝试坚持 *表 3.1* 中的方法描述当然很有帮助，但无疑你将遇到不符合这些类别的用例。当这种情况发生时，我鼓励你重新审视你的应用程序设计。有时问题可以通过新的端点路径来解决。有时我们需要创建自己的定义。这是可以的。然而，我警告不要将
    *安全* 方法改为 *不安全*。使用 `GET` 请求进行状态更改被认为是不良的做法，是 *新手错误*。
- en: After deciding what our HTTP Methods should be, we will venture into the next
    section to learn about how we can implement them and attach them to routes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定我们的 HTTP 方法之后，我们将进入下一节学习如何实现它们并将它们附加到路由上。
- en: Using HTTP Methods on route handlers
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在路由处理器中使用 HTTP 方法
- en: 'We are finally ready to learn and see what frameworks are all about! If you
    have used Flask in the paste, this will look familiar. If not, what we are about
    to do is create a route definition that is a set of instructions to tell Sanic
    to send any incoming HTTP requests to our route handler. A route definition must
    have two parts: a URI path and one or more HTTP Methods.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好学习和了解框架是什么了！如果你之前使用过 Flask，这会看起来很熟悉。如果没有，我们即将要做的是创建一个路由定义，它是一组指令，告诉 Sanic
    将任何传入的 HTTP 请求发送到我们的路由处理器。路由定义必须有两个部分：一个 URI 路径和一个或多个 HTTP 方法。
- en: 'Matching on the URI path alone is not enough. HTTP Methods are also used by
    Sanic to get your incoming request to the correct handler. Even when we implement
    the most basic form of a route definition, both parts must exist. Let’s look at
    the simplest use case and see what default choices Sanic will make:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 仅匹配 URI 路径是不够的。HTTP 方法也被 Sanic 用于将你的传入请求路由到正确的处理器。即使我们实现最基本的路由定义形式，这两部分都必须存在。让我们看看最简单的用例，看看
    Sanic 会做出什么默认选择：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we defined a route at `/my/stuff`. Usually we inject the `route()`
    call with an optional `methods` argument to tell it what HTTP Methods we want
    that handler to respond to. We have not here, so it will default to just `GET`.
    We have the option of telling the route that it should also handle other HTTP
    Methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 `/my/stuff` 上定义了一个路由。通常我们会用可选的 `methods` 参数注入 `route()` 调用，以告诉它我们希望该处理器响应哪些
    HTTP 方法。我们没有在这里这样做，所以它将默认为 `GET`。我们有告诉路由它应该处理其他 HTTP 方法的选项：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**IMPORTANT NOTE**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will look at `HEAD` method a little later in this chapter. But it is important
    to know that a `HEAD` request should not have any response body. This is enforced
    by Sanic for us. Even though technically this endpoint is responding with the
    text `Hello`, Sanic removes the body from the response and only sends the meta
    data.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论 `HEAD` 方法。但重要的是要知道，`HEAD` 请求不应该有任何响应体。Sanic 会为我们强制执行这一点。尽管技术上这个端点正在响应文本
    `Hello`，但 Sanic 会从响应中移除体，只发送元数据。
- en: Now that we have a single endpoint setup with multiple methods, we can access
    it with both methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个具有多个方法的单个端点，我们可以用这两种方法来访问它。
- en: 'First, with a `GET` request (it should be noted that when using `curl`, if
    you do not specify a method, it will default to `GET`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `GET` 请求（应该注意的是，当使用 `curl` 时，如果你没有指定方法，它将默认为 `GET`）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a convenience, Sanic provides shortcut decorators to all of its supported
    HTTP Methods on both the app instance and any Blueprint instance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Sanic 为其支持的所有 HTTP 方法在应用实例和任何 Blueprint 实例上提供了快捷装饰器：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These decorators can also be stacked. The last example that we saw could also
    be written like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器也可以堆叠。我们之前看到的最后一个例子也可以这样写：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One more fundamental thing to know about HTTP Methods is that you can access
    the incoming method on the HTTP request object. This is very helpful if you are
    handling different types of methods on the same handler, but need to treat them
    differently. Here is an example where we look at the HTTP Method to change the
    behavior of the handler
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HTTP 方法还有一点需要了解，那就是你可以访问 HTTP 请求对象上的传入方法。如果你在同一个处理器上处理不同类型的 HTTP 方法，但需要以不同的方式处理它们，这非常有帮助。以下是一个例子，我们通过查看
    HTTP 方法来改变处理器的行为
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before moving on to advanced method routing, there is some Sanic syntax we
    should mention. All of the examples here use the decorator syntax to define routes.
    This is by far the most common way to achieve this because of its convenience.
    There is, however, an alternative. All route definitions could be converted to
    functional definitions as shown below:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In some circumstances this may be a more attractive pattern to use. We will
    see it again when we encounter Class-Based Views later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Advanced method routing
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sanic does not out-of-the-box support `CONNECT` and `TRACE`, two standard HTTP
    Methods. But let’s imagine that you want to build an HTTP proxy or some other
    system that needs to have the `CONNECT` method available in your route handler.
    Even though Sanic does not out-of-the-box allow it, you have two potential approaches:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we could create a piece of middleware that is on the lookout for `CONNECT`
    and hijacks the request to provide a custom response. This *trick* of responding
    from middleware is a feature that allows you to halt the execution of the request/response
    lifecycle before the handlers would take over and otherwise fail as a `404 Not
    Found`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that a potential downside to this approach is that we need to implement
    our own routing system if we wanted to send different endpoints to different handlers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'A second approach might be to tell the Sanic router that `CONNECT` is a valid
    HTTP Method. Once we do this, we can add it to a normal request handler:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One important consideration for this strategy is that you will need to redefine
    `app.router.ALLOWED_METHODS` as early as possible before registering the new handlers.
    For this reason, it might be best for it to come directly after `app = Sanic(...)`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: A side benefit that this strategy provides is the ability to create your own
    ecosystem of HTTP Methods with your own definitions. This may not necessarily
    be advisable if you intend for your API to be used for public consumption. However,
    it may be useful, practical, or just plain fun for your own purposes. There may
    only be nine standard methods, but there are infinite possibilities. Do you want
    to create your own verbs? You are certainly free to do so.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '`ATTACK /path/to/the/dragon HTTP/1.1`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Method safety and request body
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have learned, there are generally two types of HTTP Methods: **safe**
    and **unsafe**. The unsafe methods are `POST`, `PUT`, `PATCH`, and `DELETE`. These
    methods are generally understood to mean that they are state-changing. That is
    to say that by hitting these endpoints, the user is intending to change or alter
    the resource in some way.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The converse of this are safe methods: `GET`, `HEAD`, and `OPTIONS`. The purpose
    of these endpoints is to request information from the application, not change
    state.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: It is considered good practice to follow this practice. If an endpoint will
    make a change on the server, do not use `GET`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Lining up with this division is the concept of request body. Let’s revisit
    the raw HTTP request one more time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种划分相对应的是请求体的概念。让我们再次回顾一下原始的HTTP请求：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'HTTP request can optionally include a body. In the above example, the request
    body is the last line: `{"foo": "bar"}`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP请求可以可选地包含一个消息体。在上面的例子中，请求体是最后一行：`{"foo": "bar"}`。'
- en: It is important to note that Sanic will only take the time to read the message
    body for `POST`, `PUT`, and `PATCH` requests. It will stop reading the HTTP message
    after the headers if it is an HTTP request using any other HTTP Method. This is
    a performance optimization since we generally do not expect there to be a message
    body on the *safe* HTTP requests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Sanic只会花费时间读取`POST`、`PUT`和`PATCH`请求的消息体。如果是一个使用任何其他HTTP方法的HTTP请求，它将在读取头部后停止读取HTTP消息。这是一个性能优化，因为我们通常不期望在*安全*的HTTP请求中存在消息体。
- en: 'You may have noticed this list did not include `DELETE`. Why? In general, the
    HTTP specification says that there *may* be a request body ([https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5)).
    Sanic assumes that it will not have one unless you tell it that it does. To do
    this, we simply set `ignore_body=False`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这个列表中没有包括`DELETE`。为什么？一般来说，HTTP规范说可能存在请求体（[https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5)）。Sanic假设除非你告诉它，否则它不会存在。为此，我们只需设置`ignore_body=False`：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we do not set `ignore_body=False`, and we send a body with our `DELETE` requests,
    Sanic will raise a warning in the logs to let us know that part of the HTTP message
    was not consumed. If you intend to use `DELETE` methods, you should be on the
    lookout for this since Sanic makes the assumption. It should also be noted that
    if you are in the habit of receiving GET requests with a body, you will also need
    to use `ignore_body=False`. However, I hope you have a very good reason for doing
    that since it breaks most web standards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有设置`ignore_body=False`，并且我们在`DELETE`请求中发送一个消息体，Sanic将在日志中发出警告，让我们知道HTTP消息的一部分没有被消费。如果你打算使用`DELETE`方法，你应该注意这一点，因为Sanic做出了这样的假设。还应该注意的是，如果你习惯于接收带有消息体的GET请求，你也需要使用`ignore_body=False`。然而，我希望你有一个非常好的理由来做这件事，因为这将违反大多数网络标准。
- en: One helpful takeaway from this is that out of the box, the following two endpoints
    are *not* equal.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以得到的一个有用的启示是，开箱即用，以下两个端点**并不相等**。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both `/one` and `/two` will behave similarly. Without further customization,
    however, the first request will spend time trying to read the request body even
    if it does not exist, while the second just assumes that it is the case that there
    is no body. While the performance difference will be small, it is generally preferred
    to use `@app.get("/two")` over `@app.route("/one", methods=["GET"])`. The reason
    that these two endpoints differ is that they have different default values for
    `ignore_body`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`/one`和`/two`的行为将相似。然而，如果没有进一步的定制，第一个请求将花费时间尝试读取可能不存在的请求体，而第二个则假设不存在消息体。虽然性能差异可能很小，但通常更倾向于使用`@app.get("/two")`而不是`@app.route("/one",
    methods=["GET"])`。这两个端点之所以不同，是因为它们对`ignore_body`的默认值不同。'
- en: '**IMPORTANT NOTE**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are building a GraphQL application, then usually `POST` is used by the
    endpoint even for informational requests. This is because it is generally much
    more acceptable to pass a body on a `POST` request than a `GET` request. However,
    it is worth mentioning that we could consume a message body from a `GET` request
    if we really wanted to by setting `ignore_body=False`.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在构建一个GraphQL应用程序，那么通常即使对于信息请求，端点也会使用`POST`。这是因为将消息体放在`POST`请求中通常比放在`GET`请求中更容易被接受。然而，值得一提的是，如果我们真的想的话，我们可以通过设置`ignore_body=False`从`GET`请求中消费消息体。
- en: 'When deciding what method you should use, another factor to consider is **idempotency**.
    In short, idempotence means that you can perform the same action over and over
    again, and the result should be the same every time. The HTTP Methods that are
    considered idempotent are: `GET`, `HEAD`, `PUT`, `DELETE`, `OPTIONS`, and `TRACE`.
    Keep this in mind when designing your API.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定使用哪种方法时，另一个需要考虑的因素是**幂等性**。简而言之，幂等性意味着你可以重复执行相同的操作，每次的结果都应该是相同的。被认为是幂等的HTTP方法有：`GET`、`HEAD`、`PUT`、`DELETE`、`OPTIONS`和`TRACE`。在设计你的API时请记住这一点。
- en: RESTful API design
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTful API设计
- en: HTTP Methods are often used in **RESTful API design**. There is a wealth of
    literature already written on building RESTful APIs, so we will not dive deeply
    into *what* it is, but more *how* we can practically implement it. We shall, however,
    first have a quick refresher of the basic premise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 方法通常用于 **RESTful API 设计**。关于构建 RESTful API 的文献已经非常丰富，因此我们不会深入探讨它是什么，而是更多地关注我们如何实际实现它。然而，我们首先应该快速回顾一下基本前提。
- en: Web API endpoints have a target. That target is *something* that either the
    user would like to fetch information about, or manipulate by adding or changing
    it. Based upon a shared understanding, the HTTP Method tells the server how you
    would like to interact with that target. The *target* is often called a *resource*,
    and we may use the terms interchangeably here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 端点有一个目标。这个目标是指用户想要获取信息或通过添加或更改来操作的东西。基于共同的理解，HTTP 方法告诉服务器您希望如何与该目标交互。该
    **目标** 通常被称为 **资源**，在这里我们可以互换使用这些术语。
- en: 'To grasp this concept, I like to think back to the adventure computer games
    I played as a child. My swashbuckling character would happen upon an object: let’s
    say a rubber chicken. When I clicked on that object, a menu would appear with
    different verbs that told me what I could do with that object: pick up, look at,
    use, talk to, and so on. There was a target (the rubber chicken), and methods
    (the verbs or actions).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，我喜欢回想我小时候玩的冒险电脑游戏。我的冒险角色会偶然发现一个物品：比如说一个橡胶鸡。当我点击那个物品时，会出现一个菜单，显示不同的动词，告诉我我可以对这个物品做什么：捡起、查看、使用、交谈等等。有一个目标（橡胶鸡），以及方法（动词或动作）。
- en: 'Putting this together with the HTTP Methods we defined above, let’s look at
    a concrete example. In our hypothetical situation, we will be building an API
    to manage a social media platform for people that love adventure computer games.
    Users need to be able to create a profile, view other profiles, and update their
    own. We might design the following endpoints:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些与我们上面定义的 HTTP 方法结合起来，让我们看看一个具体的例子。在我们的假设情况下，我们将构建一个用于管理喜欢冒险电脑游戏的人们的社交媒体平台的
    API。用户需要能够创建个人资料、查看其他个人资料以及更新自己的个人资料。我们可能会设计以下端点：
- en: '| **METHOD** | **URI PATH** | **DESCRIPTION** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URI 路径** | **描述** |'
- en: '| `GET` | `/profiles` | A list of all of the member profiles |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/profiles` | 所有成员个人资料的列表 |'
- en: '| `POST` | `/profiles` | Create a new profile |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/profiles` | 创建新的个人资料 |'
- en: '| `GET` | `/profiles/<username>` | Retrieve profile for a single user |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/profiles/<username>` | 获取单个用户的个人资料 |'
- en: '| `PUT` | `/profiles/<username>` | Remove the old profile and replace with
    a complete profile |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/profiles/<username>` | 删除旧的个人资料并用完整的个人资料替换 |'
- en: '| `PATCH` | `/profiles/<username>` | Make a change to only a part of a profile
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | `/profiles/<username>` | 仅对个人资料的一部分进行更改 |'
- en: '| `DELETE` | `/profiles/<username>` | Remove a profile–but why would anyone
    want to remove their swashbuckling adventure gamer profile? |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/profiles/<username>` | 删除个人资料——但为什么有人会想删除他们的冒险游戏玩家个人资料呢？ |'
- en: Table 3.2 - Example HTTP Methods and endpoints
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 - 示例 HTTP 方法与端点
- en: 'Before we go further, if you are unfamiliar with how routing works in Sanic
    (and what the `<username>` syntax means), you can get more information in the
    User Guide here: [https://sanicframework.org/en/guide/basics/routing.html](https://sanicframework.org/en/guide/basics/routing.html),
    and we will also look at it more closely later in this chapter in the section
    titled *Extracting information from the path*. Feel free to skip ahead and come
    back.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，如果您对 Sanic 中的路由工作方式不熟悉（以及 `<username>` 语法意味着什么），您可以在用户指南中获取更多信息：[https://sanicframework.org/en/guide/basics/routing.html](https://sanicframework.org/en/guide/basics/routing.html)，我们也会在本章的“从路径中提取信息”部分更详细地探讨它。您可以自由地跳过并稍后回来。
- en: 'As you can see, there really are only two URI paths: `/profiles` and `/profiles/<username>`.
    Using the HTTP Methods, however, we have been able to define six different interactions
    with our API! What might the profile blueprint look like?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实际上只有两个 URI 路径：`/profiles` 和 `/profiles/<username>`。然而，通过使用 HTTP 方法，我们已经能够定义与我们的
    API 的六种不同交互！个人资料蓝图可能是什么样的呢？
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using HTTP Methods to define our use cases seems helpful and having decorators
    that map them seems convenient. But, it seems like there is a lot of boilerplate
    there, and repetition. We will next look at Class-Based Views and how we can simplify
    our code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP 方法来定义我们的用例似乎很有帮助，并且有映射它们的装饰器似乎很方便。但是，似乎有很多样板代码和重复。接下来，我们将探讨基于类的视图以及我们如何简化我们的代码。
- en: Simplifying your endpoints with Class-Based Views
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基于类的视图简化你的端点
- en: The previous example exposes a weakness with using functions and decorators
    alone to design your API. What happens when we want to add endpoint handlers for
    `/profile/<user_id:uuid>`? Or when we want to make some other change to the existing
    endpoint? We now have multiple places to make the same change, leading to a higher
    chance that we do not maintain parity among all our route definitions. This is
    a violation of the **DRY** (**don’t repeat yourself**) principle, and could lead
    to bugs. Maintaining these endpoints over the long term therefore might be more
    difficult than necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子暴露了仅使用函数和装饰器来设计 API 的弱点。当我们想要为 `/profile/<user_id:uuid>` 添加端点处理程序时会发生什么？或者当我们想要对现有端点进行其他更改时？我们现在有多个地方可以做出相同的更改，这导致我们无法在所有路由定义之间保持一致性，这是违反了
    **DRY**（**不要重复自己**）原则的，可能会导致错误。因此，从长远来看，维护这些端点可能比必要的更困难。
- en: 'This is one of the compelling reasons to use **Class-Based Views** (**CBVs**).
    This pattern will give us the opportunity to link together the first two endpoints,
    and the last four endpoints so they become easier to manage. They are being grouped
    together because they share the same URI path. Instead of standalone functions,
    each HTTP Method will be a functional method on a class. And, that class will
    be assigned a common URI path. A bit of code should make this easy to understand:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 **基于类的视图**（**CBV**）的一个非常有说服力的原因。这个模式将给我们提供将前两个端点和最后四个端点链接在一起的机会，使它们更容易管理。它们被分组在一起是因为它们共享相同的
    URI 路径。而不是独立的函数，每个 HTTP 方法将是一个类上的功能方法。而且，这个类将被分配一个公共的 URI 路径。一点代码应该能让你更容易理解：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**IMPORTANT NOTE**'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later in this book we may see more and more use of custom decorators to add
    shared functionality. It is worth mentioning that we can also add them easily
    to CBVs, and I highly suggest you take a moment to refer to the User Guide to
    see it in action: [https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators](https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators)'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本书的后面，我们可能会看到更多使用自定义装饰器来添加共享功能的情况。值得一提的是，我们也可以很容易地将它们添加到 CBV 中，我强烈建议你花点时间查阅用户指南，看看它是如何工作的：[https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators](https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators)
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One thing to be on the lookout for when adding decorators to CBV methods is
    the `self` argument on instance methods. You may need to adjust your decorator,
    or use a `staticmethod` to get it to work as expected. The above mentioned documentation
    explains how to do that.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在向 CBV 方法添加装饰器时，需要注意的一点是实例方法的 `self` 参数。你可能需要调整你的装饰器，或者使用 `staticmethod` 来使其按预期工作。上面提到的文档解释了如何做到这一点。
- en: 'Earlier, we saw how `add_route` could be used as an alternative approach to
    attaching a single function as a handler to a route definition. It looked like
    this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何使用 `add_route` 作为将单个函数作为处理程序附加到路由定义的替代方法。它看起来是这样的：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This pattern is one of the main ways to attach a CBV to a Sanic or Blueprint
    instance. The caveat is that you need to call it using the class method: `as_view()`.
    In our previous example, we saw what this looked like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是将 CBV 附加到 Sanic 或 Blueprint 实例的主要方式之一。需要注意的是，你需要使用类方法 `as_view()` 来调用它。在我们之前的例子中，我们看到了它的样子：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This could also be achieved by attaching the CBV when it is declared. This is
    option will only work if you already have a known Blueprint or Application instance.
    We will rewrite `SingleProfileView` to take advantage of this alternative syntax.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在声明时附加 CBV 来实现。这个选项只在你已经有一个已知的 Blueprint 或 Application 实例时才有效。我们将重写 `SingleProfileView`
    以利用这种替代语法。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How should you decide which to use? Personally, I find this second version to
    be easier and cleaner. The big downside is that you cannot lazily create the CBV
    and attach it later since it needs to be known up front.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该如何决定使用哪一个？我个人觉得第二个版本更容易、更简洁。但最大的缺点是，你不能懒加载 CBV 并稍后附加，因为它需要提前知道。
- en: Blanket support for OPTIONS and HEAD
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 OPTIONS 和 HEAD 的全面支持
- en: It is generally best practice to support `OPTIONS` and `HEAD` methods on all
    of your endpoints, where it is appropriate. This could become tedious and include
    a lot of repetitive boilerplate. To achieve this with standard route definitions
    alone would require a lot of code duplication as seen below. Below, we see that
    we need for route definitions where two would be sufficient. Now imagine if every
    endpoint needed to also have `OPTIONS` and `HEAD`!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在所有端点上支持`OPTIONS`和`HEAD`方法是一种最佳实践，只要这是合适的。这可能会变得繁琐，包括大量的重复模板代码。仅使用标准路由定义来实现这一点，就需要大量的代码重复，如下所示。下面，我们看到我们需要两个路由定义，而实际上只需要一个。现在想象一下，如果每个端点都需要有`OPTIONS`和`HEAD`会怎样！
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use Sanic’s router to our advantage to add on a handler for these requests
    to each and every route. The idea will be to loop over all of the routes defined
    in our application and dynamically add handlers for `OPTIONS` and `HEAD` if needed.
    Later on in *Chapter 7*, we will use this strategy for creating our customized
    CORS policy. For now, however, all we need to keep in mind is that we want to
    be able to handle ANY request to a valid endpoint using one of these HTTP Methods:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Sanic的路由器来添加处理程序，为每个路由添加处理这些请求的处理程序。想法将是遍历我们应用程序中定义的所有路由，并在需要时动态添加`OPTIONS`和`HEAD`的处理程序。在*第7章*的后面，我们将使用这种策略来创建我们的自定义CORS策略。然而，现在我们只需要记住，我们希望能够使用以下HTTP方法之一来处理对有效端点的任何请求：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s take a closer look at this code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码。
- en: 'First, we create route handlers: the functions that will do the work when the
    endpoint is hit. For now, they do not do anything. If you want to know what this
    endpoint *could* do, jump ahead to the CORS discussion in *Setting up an effective
    CORS policy* located in *Chapter 7*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建路由处理程序：当端点被击中时将执行工作的函数。现在，它们不做任何事情。如果您想知道这个端点*可能*做什么，请跳转到*设置有效的CORS策略*中的CORS讨论，该讨论位于*第7章*。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next part needs to be done after we register all of our endpoints. In *Chapter
    11*, we accomplish this by running the code inside of a factory. Feel free to
    take a look ahead to the example there to be able to compare it with our current
    implementation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们注册了所有端点之后，下一部分需要完成。在*第11章*中，我们通过在工厂内部运行代码来完成这个任务。您可以随意提前查看那里的示例，以便能够将其与我们的当前实现进行比较。
- en: In our current example, we do not have a factory, and are adding the routes
    inside an event listener. Normally, this would not be possible since we cannot
    change our routes after the application is running. When a Sanic application starts
    up, one of the first things it does internally is call `app.router.finalize()`.
    But, it will not let us call that method twice. Therefore, we need to run `app.router.reset()`,
    add our routes, and finally call `app.router.finalize()` after all of our dynamic
    route generation is complete. You can use this same strategy anywhere that you
    might want to dynamically add routes. Is this a good idea? In general, I would
    say that dynamically adding routes is a bad idea. Having changing endpoints might
    lead to unpredictability, or weird bugs across a distributed application. However,
    the benefit we are gaining through dynamic route generation in this instance is
    great, and the risk is very low.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的当前示例中，我们没有工厂，而是在事件监听器内部添加路由。通常情况下，这是不可能的，因为我们不能在应用程序运行后更改我们的路由。当Sanic应用程序启动时，它内部首先做的事情之一就是调用`app.router.finalize()`。但是，它不会让我们调用这个方法两次。因此，我们需要在所有动态路由生成完成后运行`app.router.reset()`，添加我们的路由，并最终在所有动态路由生成完成后调用`app.router.finalize()`。您可以在可能动态添加路由的任何地方使用这种相同的策略。这是一个好主意吗？一般来说，我会说动态添加路由不是一个好主意。端点的变化可能会导致不可预测性，或者在分布式应用程序中出现奇怪的错误。然而，在这个例子中，通过动态路由生成获得的收益是巨大的，风险非常低。
- en: 'There are a few different properties that the Sanic router provides us with
    that we could loop over to see what routes are registered. The two most commonly
    used for public consumption are `app.router.routes` and `app.router.groups`. It
    is helpful to understand what they are and how they differ. We will put our discussion
    on `OPTIONS` and `HEAD` on pause for a brief moment to look at these two properties
    to see how:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic路由器为我们提供了一些不同的属性，我们可以遍历它们来查看注册了哪些路由。最常用于公共消费的两个属性是`app.router.routes`和`app.router.groups`。了解它们是什么以及它们之间的区别是有帮助的。我们将暂时暂停对`OPTIONS`和`HEAD`的讨论，来看看这两个属性是如何实现的：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing to notice is that one of them is producing `Route` objects,
    and the other `RouteGroup` objects. The second obvious takeaway is that one is
    a list and the other a dictionary. But what are `Route` and `RouteGroup`?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'In our console, we will see that there are three `Route` objects, but only
    two `RouteGroup` objects. This is because Sanic has grouped together similar looking
    routes to more efficiently match them later. A `Route` is a single definition.
    Every time we call `@app.route`, we are creating a new `Route`. Here, we can see
    that they have been grouped by the URI path:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getting back to our discussion of automation, we are going to use `app.router.groups`.
    This is because we want to know which methods have and have not been assigned
    to a given path. The quickest way to figure that out is to look at the groups
    that Sanic has already provided for us. All we need to do is check if the group
    already includes a handler for the HTTP Method (so we do not overwrite anything
    that already exists), and call `add_route`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although we will not look at `options_handler` right now, we can look more
    closely at `head_handler`. A `HEAD` request is defined in RFC 2616 as being identical
    to a `GET` request: “*The HEAD method is identical to GET except that the server
    MUST NOT return a message-body in the response”* ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4)).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty easy to implement in Sanic. Really what we want to do is retrieve
    the response from the `GET` handler for the same endpoint, but only return the
    metadata, *not* the request body. We will use `functools.partial` to pass the
    `GET` handler to our `head_handler`. Then, all it needs to do is run the `get_handler`
    and return the response. As we saw earlier in the chapter, Sanic will do the work
    for us of removing the body before it sends the response to the client:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**IMPORTANT NOTE**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the above example we added `name=f"{get_route.name}_head"` to our `add_route`
    method. This is because all routes in Sanic get a “name”. If you do not manually
    supply one, then Sanic will attempt to generate a name for you using `handler.__name__.`
    In this case, we are passing a `partial` function as a route handler, and Sanic
    does not know how to generate a name for that since partial functions in Python
    have no `__name__` property.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we know about how to use HTTP Methods to our advantage, we will look
    at the next big area in routing: **paths**.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Paths, slashes, and why they matter
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Way back in the stone-age when the Internet was invented, if you navigated to
    a URL, you were literally being delivered a file that existed on a computer somewhere.
    If you asked for `/path/to/something.html`, the server would look in the `/path/to`
    directory for a file called `something.html`. If that file existed, it would send
    it to you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'While this does still exist, times have certainly changed for many applications.
    The Internet is still largely based upon this premise, but often a generated document
    is sent instead of a static document. It is helpful to still keep this mental
    model in your head though. Thinking that a path on your API should lead to a resource
    of some kind will keep you away from certain API design flaws. For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Your URI paths should use nouns, not verbs. If we want to perform an action
    and tell the server to do something, we should manipulate the HTTP Method as we
    learned, not the path of the URI. Going down this path—believe me, I’ve done it—will
    lead to some messy looking applications. Very likely you will wake up one day
    and look at a mess of disjointed and incoherent paths and ask yourself: what have
    I done? There might, however, be a time and place for this, so we will revisit
    it shortly.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that our paths should contain nouns, the obvious next question is whether
    they should be singular or plural. I do not think there is a single consensus
    on the Internet about what is right here. Many people always use plural; many
    people always use singular; and some wild hooligans decide to mix and match. While
    the decision itself may seem small, it is nevertheless important to establish
    consistency. Picking a system and applying consistency is itself more important
    than the actual decision.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, I will give you my opinion. Use plural nouns. Why?
    It makes for very nice nesting of paths, which could translate nicely to nesting
    of Blueprints:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I do encourage you to use singular nouns if it makes sense to you. But if you
    do, you must do it everywhere. As long as you stay consistent and logical about
    your choice, your API will feel polished. Mixing plural and singular paths will
    make your API feel haphazard and amateurish. A really nice resource that explains
    how to *consistently* break the two rules I just laid out (use nouns, use plural)
    is found here: [https://restfulapi.net/resource-naming/.](https://restfulapi.net/resource-naming/.)
    Again, it is important and helpful for us to not only learn the *rules* or the
    *right way* to do something but to also learn when to break them, or when to make
    our own set of rules. Sometimes following standards makes sense, sometimes not.
    This is how we go from someone that merely is capable of making a web application,
    to someone that knows how to design and build one. The difference is expertise.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also encouraged when designing paths to favor hyphens (`-`) over spaces,
    capitalization, or underscores. This increases the human readability of your API.
    Consider the difference between these:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Most people would consider the last option to be the easiest to read.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Strict slashes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the legacy paradigm where endpoints were equivalent to the file structure
    of a server, the trailing slash in a path took on a specific meaning. It is widely
    accepted that paths with and without trailing slashes are not the same and are
    not interchangeable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: If you navigated to `/characters`, you might expect to receive a list of all
    the characters in our fictitious social media application. However, `/characters/`
    technically means *show me a list of everything that is in the* `characters` *directory*.
    Because this could be confusing, you are encouraged to avoid using trailing slashes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, it is also widely accepted that these *are* the same thing.
    In fact, a lot of browsers (and websites) treat them the same. I’ll show you how
    you can test this for yourself:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your web browser and go to: [https://sanic.readthedocs.io/en/stable/](https://sanic.readthedocs.io/en/stable/)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open a second tab and go to: [https://sanic.readthedocs.io/en/stable](https://sanic.readthedocs.io/en/stable)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: It is the same page. In fact, it seems that this web server breaks the rule
    that I just mentioned and prefers the trailing slash to not having it at all.
    So, where does this leave us, and what should we implement? It is really up to
    you to determine, so let’s see how we can control it in Sanic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do nothing, Sanic will drop the trailing slash for you. Sanic does,
    however, provide you with the ability to control whether that trailing slash should
    have meaning or not by setting the `strict_slashes` argument. Consider an application
    setup with and without trailing slashes, and with and without `strict_slashes`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The above definitions will fail. Why? When Sanic sees a trailing slash on a
    path definition it will remove it, *unless* `strict_slashes=True`. Therefore,
    the first and second routes are considered identical. Furthermore, the third route
    is also the same, therefore causing a conflict.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: While the generally accepted rule is that a trailing slash *should* have meaning,
    this is not the case for a trailing slash that is the only part of a path. RFC
    2616, Section 3.2.3 states that an empty path (`""`) is the same thing as a single
    slash path (`"/"`). ([https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3](https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3))
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'I put together a deeper discussion about how Sanic handles the possible scenarios
    of trailing slashes. If this is something you are considering to use, I suggest
    you take a look here: [https://community.sanicframework.org/t/route-paths-how-do-they-work/825.](https://community.sanicframework.org/t/route-paths-how-do-they-work/825.)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to ask me my opinion, I would say do not use them. It is much more
    forgiving to allow `/characters` and `/characters/` to have the same meaning.
    Therefore, I personally would define the above route as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Extracting information from the path
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to consider in this section is extracting usable information
    from our request. The first place we often look is the URI path. Sanic provides
    a simple syntax for extracting parameters from the path:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have declared the second segment in our path to contain a variable. The Sanic
    router extracts that and injects it as an argument in our handler. It is important
    to note that if we do nothing else, that injection will be a `str` type value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Sanic also provides an easy mechanism for converting the type. Suppose we want
    to retrieve a single message from a message feed, query it in the DB, and return
    the message. In this case, our call to the DB requires the `message_id` to be
    an `int`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This route definition will tell Sanic to convert the second segment into an
    `int` before injecting it. It is also important to note that if the value is something
    that cannot be cast as an `int`, it will raise a `404 Not Found`. Therefore, the
    parameter type does more than just type casting. It is also involved in route
    handling.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the next section, and the User Guide to learn what all of the
    allowed parameter types are. [https://sanicframework.org/en/guide/basics/routing.html#path-parameters](https://sanicframework.org/en/guide/basics/routing.html#path-parameters)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides extracting information from the path itself, the two other places we
    may want to look for user data are the query parameters, and the request body.
    Query parameters is the part of the URL that comes after a `?`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`/characters?count=10&name=george`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'How should we decide if information should be passed in the path, the query
    arguments, or as a part of form or JSON body? Best practices dictate that information
    should be accessed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**path parameters**: Information to describe *what* the resource is we are
    looking for'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**query parameters**: Information that can be used to filter, search, or sort
    the response'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**request body**: Everything else'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good habit to get into very early on in your application development
    to learn where different usable bits of information can come from. Chapter 4 dives
    much further into passing data through query patameters and the request body.
    Just as valuable is of course the HTTP path itself. We just looked at how important
    crafting purposeful paths might be. Next, we will take a deeper look at extracting
    data from the HTTP path.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Advanced path parameters
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we learned the basics of extracting information from a
    dynamic URL path to something we can code with. This is truly a fundamental feature
    of all web frameworks. It is also extremely common among many frameworks to allow
    you to specify what that path parameter should be. We learned that `/messages/<message_id:int>`
    would match `/messages/123` but not `/messages/abc`. We also learned about the
    convenience that Sanic provides in converting the match path segment to an integer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: But, what about more complex types? Or what if we need to modify the matched
    value before using it in our application? In this section, we will explore a couple
    helpful patterns to achieve these goals.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Custom parameter matching
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Out of the box, Sanic provides eight path parameter types that can be matched:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`str`: matches any valid string'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slug`: matches standard path slugs'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: matches any integer'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: matches any number'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`: matches only alphabetic characters'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: matches any expandable path'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ymd`: matches `YYYY-MM-DD`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid`: matches a `UUID`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these provides a type that corresponds to the matched parameter. For
    example, if you have this path: `/report/<report_date:ymd>`, the `date` object
    in your handler will be a `datetime.date` instance:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a very helpful pattern because it accomplishes two things for us. First,
    it makes sure that the incoming request is in the correct format. A request that
    is `/report/20210101` would receive a `404 Not Found` response. Second, when we
    go to work with that `report_date` instance in our handler, it has already been
    cast into a usable data type: `date`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we need routing for types outside of the standard types?
    Sanic does of course allow us to achieve the first part by defining a custom regular
    expression for a path segment. Let’s imagine that we have an endpoint that we
    want to match on a valid IPv4 address: `/ip/1.2.3.4`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest approach here would be to find a relevant regular expression and
    add it to our path segment definition:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, when we access our endpoint we should have a valid match:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using regular expression matching also allows us to narrowly define an endpoint
    between a limited number of options:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now have routing based upon our two available choices:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While regular expression matching is incredibly helpful sometimes, the problem
    is that the output is still a `str`. Going back to our first IPv4 example, we
    would need to manually cast the matched value into a `ipaddress.IPv4Address` if
    we wanted an instance of that class to work with.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'While this might not seem like a big deal if you have one or two handlers,
    if you have a dozen endpoints that needed a dynamic IP address as a path parameter,
    it could become cumbersome. Sanic’s solution to this is custom pattern matching.
    We can tell Sanic that we want to create our own parameter type. To do this we
    need three things:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: A short descriptor that we will use to name our type
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that will return the value we want or raise `ValueError` if there
    is no match
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fallback regular expression that also matches our value
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the IP address example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: We will name the parameter `ipv4`
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the standard library’s `ipaddress.ip_address` constructor
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We already have our fallback regular expression from earlier. We can proceed
    to registering the custom parameter type:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we have a more usable object in the handler (`ipaddress.IPv4Address`),
    and we also have a very easy to reuse path parameter (`<ip:ipv4>`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'What about our second example with ice cream flavors? Instead of having a `str`
    type, what if we wanted to have an `Enum` or some other custom model? There is
    unfortunately no function in Python’s standard library for parsing ice cream flavors
    (maybe someone should build that), so we will need to create our own:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will create our model using an `Enum`. Why an Enum? It is a fantastic
    tool to keep our code nice and consistent. If our environment is setup right—which
    it is because we took care in *Chapter 2* to use good tools—we have a single place
    where we can maintain our flavors with code completion:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need a regular expression that we can later use in our route definition
    for matching incoming requests:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The resulting pattern should be: `vanilla|chocolate`.'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to create a function that will act as our parser. Its job is to
    either return our target type or raise `ValueError`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can now proceed to register that pattern with Sanic. Just like the IP address
    example before, we have the name of our parameter type, a function to check the
    match, and a fallback regular expression.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With our pattern now registered, we can proceed to use it in all of our ice
    cream endpoints:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we access the endpoint now, we should have an `Enum` instance, but still
    only accept requests that match one of our two defined flavors. Yum!
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The key to this example is having a good parse function. In our example, we
    know that if a bad flavor is entered into the `Enum` constructor it will raise
    `KeyError`. This is a problem. If our application cannot match `mint`, it will
    throw a `KeyError` and the application will respond with a `500 Internal Server
    Error`. This is not what we want. By catching the exception and casting it to
    `ValueError`, Sanic is able to understand that this is expected, and it should
    respond with a `404 Not Found`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Modifying matched parameter values
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have learned, using path parameter types is extremely helpful in building
    our API to respond to intended requests and ignoring bad paths. As much as possible,
    it is best practice to be as specific as your endpoint needs to get the right
    data in. We just explored how we might also use parameter types to recast the
    matched value to a more useful data type. But what if we are not concerned about
    changing the `type` of the value, but the actual value itself?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our character profile application example, imagine that we have
    some URLs that include **slugs**. If you are not familiar with a slug, it is basically
    a string that uses lower cases letters and hyphens to make human friendly content
    in URL paths. We saw an example of this earlier: `/users/adam-hopkins`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In our hypothetical application, we need to build an endpoint that returns details
    about a character instance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a model for what the character object will look like.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We want to be able to return specific details about out character. For example,
    the endpoint `/characters/george/name` should return `George`. So, our next task
    is to define our route:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is a fairly simple route. It searches for the character, and then returns
    the requested attribute. Let’s check it out in action:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let’s try getting George’s super powers.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Uh oh, what happened? The property we are trying to access is `Character.super_powers`.
    But, our endpoint accepts slugs (because they are easier for people to read).
    So we need to convert the attribute. Just like in the previous section where we
    *could* cast our value inside of the handler, it becomes more difficult to scale
    that solution. We *could* run `attr.replace("-", "_")` inside of our handler,
    and perhaps this is a viable solution. It does make for extra code inside the
    handlers.Luckily, we also have another alternative. This is a good use case for
    middleware where we need to convert all slugs (eg. `this-is-a-slug`) to snake
    case (eg. `this_is_snake_case`) so that they can be used programatically down
    the road. By converting the slugs, we can look for `super_powers` instead of `super-powers`.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s make that middleware:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What this will do is modify the `Request` instance before it gets executed by
    the route handler. For our use case, this means that every value that is matched
    will be converted from a slug to snake case. Note that we are *not* returning
    anything in this function. If we do, Sanic will think that we are trying to halt
    the request/response cycle by providing an early return. This is not the intention.
    All we want to do is modify the `Request`.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s test that endpoint again:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Middleware is not the only solution to this problem though. Sanic makes use
    of signals to dispatch events that your application can listen to. Instead of
    the above middleware, we could do something similar like this with signals:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, it is a very similar implementation. Perhaps the biggest difference
    to us as developers is that the signal provides us with some more arguments to
    work with. Although, to be honest, the `route` , the `handler`, and the `kwargs`
    are all properties that could be accessed from the `Request` instance. Middleware
    and signals are discussed in greater depth in Chapter 6\. For now, just know that
    these are two methods for altering the request/response cycle outside of the route
    handler. Later on we will learn more about the differences between them and when
    it might be preferable to choose one or the other.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in *Chapter 2,* *Organizing a project* we discussed how you could implement
    API versioning using Blueprints. If you recall, it was simply a matter of adding
    a keyword value to the Blueprint definition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the below Blueprint definition, we get the URL path: `/v1/characters`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That `version` keyword argument is available at the route level as well. If
    the version is defined in multiple places (for example, on the route and also
    the Blueprint), priority is given to the narrowest scope. Let’s look at an example
    of different places where the version can be defined, and see what the result
    is. We will define it at the route level, the Blueprint level, and the Blueprint
    group level:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We now have the following routes. Take a closer look at the example to see
    how we manipulate the Blueprints and the `version` argument to control the handler
    that each path is delivered to:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`/v1/characters <Route: name=main.Characters.version_1 path=v1/characters>`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v3/characters <Route: name=main.Characters.version_3 path=v3/characters>`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v2/characters <Route: name=main.CharactersV2.version_2 path=v2/characters>`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding versions to endpoint paths is fairly simple. But why should we do it?
    It is a good practice because it keeps your API flexible, but also consistent
    and stable for your users. By allowing endpoints to be versioned, you maintain
    the ability to make changes to them and still allow for legacy requests to not
    be denied. It is incredibly beneficial as over time as you transition your API
    to add, remove, or enhance features.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Even if the only consumer of your API is your own website, it is still a good
    practice to version your APIs so that you have an easier path towards upgrades
    without potentially causing application regressions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to “lock-in” features with a version. This is a form
    of creating what is known as an API contract. Think of an API contract as a promise
    by the developer that the API will continue to work. In other words, once you
    put an API into usage—and especially if you publish documentation—you are creating
    a promise to the user that the API will continue to function as is. You are free
    to add new features, but any breaking changes that are not backwards compatible
    violate that contract. Therefore, when you do need to add breaking changes, versions
    might be the right trick in your tool bag to accomplish your goal.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example. We’re building out our database of character profiles.
    The first version of our API has an endpoint to create a new profile and it looks
    something like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This endpoint is built upon the assumption that the incoming JSON body will
    be fairly simple like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What happens when we want to handle some more complex use cases?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It might start getting complicated, messy, and overall difficult to maintain
    our route handler if we put too much logic into it. As a general practice, I like
    to keep my route handlers very concise. If I see my code creeping up to 50 lines
    of code inside a view handler, I know there is probably some refactoring that
    needs to be done. Ideally, I like to keep them to about 20 lines or less.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: One way we can keep our code clean is to split these use cases. Version 1 of
    the API will still be able to create characters using the simpler data structure,
    and version 2 has the capability of the more complex structure.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Should all of my routes bump versions?
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be curious to know why you would want to
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you will have a need to increase a version on a single endpoint, but
    not all of them. This raises the question: what version do I use on the unchanged
    endpoints? Ultimately, this is going to be a question that can only be dictated
    by the application. It might be helpful to keep in mind how the API is being used.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Very often you will see APIs bumping versions when there is a complete break
    or some major overhaul in the API structure. This could accompany a new technology
    stack, or a new API structure or design pattern. An example of this is when GitHub
    changed their API from v3 to v4\. The older version of their API (v3) is RESTful,
    similar to what we discussed earlier in this chapter. The newer version (v4) is
    based upon GraphQL (see Chapter 10 for more on GraphQL). This is a complete redesign
    of the API. Because v3 and v4 are completely incompatible, they changed the version
    number.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub’s case, it was clear all endpoints needed to change as it was effectively
    a brand new API. Drastic changes like this are not the only catalyst for version
    changing, however. What if we are only changing compatibility on a smaller portion
    of our API and keeping the rest intact?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people may find that it makes sense to implement the new version number
    on all of their endpoints. One way to accomplish this is to add multiple route
    definitions to an endpoint:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The downside of this approach is that could become very cumbersome to maintain.
    If you needed to add a new route definition to *every* handler when you want to
    change a version, you might be discouraged from adding versions in the first place.
    Take this into consideration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: How about nesting blueprints? How about a function that dynamically adds routes
    at startup? Can you think of a solution? We have already seen various tools and
    strategies earlier in this book that might help us out. This might be a good time
    to put the book down and jump into your code editor on your computer. I encourage
    you to play around with versions and nesting to see what is and is not possible.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember `app.router.routes` and `app.router.groups`? Try adding a single handler
    to multiple Blueprints. Or try adding the same Blueprints to different groups.
    I challenge you to come up with a pattern to have the same handler be on different
    versions without multiple definitions like the above example. Start with this,
    and see what you can come up with, without doubling up the route definition as
    above:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is a handy snippet you can use while developing to see which paths are
    defined:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Getting back to our question: should all of my routes bump versions? Some people
    will say yes, but it seems artificially complex to bump the version of all routes
    when only one has changed. By all means, if it makes sense, bump everything simultaneously.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only want to bump the routes that are changing, it causes another problem.
    What should we bump it to? Many people will tell you that versions should *only*
    ever be integers: `v1`, `v2`, `v99`, etc. I find this limiting, and it really
    makes the following set of endpoints feel unnatural:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`/v1/characters`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/characters/puppets`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/characters/super_heroes`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/characters/historical`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v2/characters`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While I am not discounting this approach, it does seem like there *should*
    be a `v2` for all of the routes, even if they did not change. We are trying to
    avoid that. Why not use minor versions like semantic versioning? It seems more
    natural and accepting to have a single `/v1.1` endpoint than a single `/v2`. Again,
    this is going to be a matter of what works for your application needs, and what
    is reasonable given the types of users that will be consuming your API. Should
    you decided that semantic versioning style will work for your application needs,
    you can add it by using a float for the version argument as seen here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**IMPORTANT NOTE**'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Semantic versioning is an important concept in software development, but beyond
    the scope here. In brief, the concept is to create a version by declaring a major,
    minor and patch numer that are connected by a period. Example: 1.2.3\. Generally
    speaking, semantic versioning states that an increment of the major version corresponds
    to a backwards-incompatible change, the minor version to a new feature, and the
    patch version to a bug fix. If you are unfamiliar with it, I suggest taking some
    time to read through the documentation for it since it is widely used throughout
    software development: [https://semver.org/](https://semver.org/)'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is highly recommended that you use version with your endpoints if you intend
    for there to be third-party integration with your API. If the API is only meant
    to be used by your own application, perhaps this is less important. Nevertheless,
    it may still be a useful pattern. Therefore, I recommend using `version=1` for
    new projects or `version=2` for projects that are replacing an existing API even
    if the legacy application did not have a version scheme.
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Version prefixing
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard way to use versions in Sanic is `version=<int>` or `version=<float>`.
    The version will *ALWAYS* be inserted into your path at the very beginning. It
    does not matter how deeply nested and how many layers of `url_prefix` you may
    have. Even a deeply nested route definition can have a single version and it will
    be the first segment in the path: `/v1/some/deeply/nested/path/to/handler`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'This does, however, impose a problem when you are trying to build multiple
    layers on your application. What if you want to have some HTML pages and an API
    and keep them separate based upon their path? Consider the following paths that
    we might like to have in our application:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '`/page/profile.html`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/v1/characters/<name>`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice how the versioned API route starts with `/api`? This is impossible to
    control only with URIs and Blueprint URI prefixes since Sanic *always* puts the
    version before the rest of the path. However, Sanic provides a `version_prefix`
    argument in all of the same places that `version` can be used. The default value
    is `/v`, but feel free to update it as needed. In the following example, we can
    nest our entire API design in a single blueprint group to automatically add `/api`
    to the front of every endpoint:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**TIP**'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The same path parameters are available here. You could, for example, do something
    like this: `version_prefix=/<section>/v`. Just make sure you remember that `section`
    will now be an injected keyword argument into every route handler.'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You should now have a good grasp of how and when to use versions. They are
    a powerful tool in making your API more professional and maintainable since they
    allow for more flexible development patterns. Next, we will explore another tool
    for creating flexibility and reusability of your application code: virtual hosts.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Virtual hosts
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications can be accessed from multiple domains. This gives the benefit
    of having a single application deployment to manage, but the ability to service
    multiple domains. In our example, we will imagine that we completed the computer
    adventure game social media site. The API is truly something amazing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: It is so incredible in fact that both Alice and Bob have approached us about
    the opportunity to be resellers and to *white label* our application, or reuse
    the API for their own social media sites. This is a somewhat common practice in
    the Internet world where once provider builds an application, and other providers
    simply point their domain to the same application and operate as if it is their
    own. To achieve this, we need to have distinct URLs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '`mine.com`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alice.com`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bob.com`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these domains will be setup with their DNS records pointing to our application.
    This can work without any further changes inside the application. But what if
    we need to know which domain a request is serving, and do something slightly different
    for each one? This information should be available to us in the request headers.
    It should simply be a matter of checking the headers:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This example may seem small and simple, but you can probably imagine how the
    complexity could increase. Remember earlier I stated how I like to keep the lines
    of code per handler to a minimum? This is certainly a use case where you can imagine
    the handlers could get very lengthy.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what we are doing in this endpoint is host-based routing. Depending
    upon the incoming request host, we are routing the endpoint to a different location.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Sanic already does that for us. All we need to do is break the logic into separate
    route handlers and give each one a `host` argument. This achieves the routing
    that we need, but keeps it out of our response handlers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you find yourself in this situation, you do not need to define a `host` for
    every endpoint. Only the endpoints where you would want to have host-based routing.
    Following this pattern, we can reuse the same application across multiple domains,
    and still have some endpoints capable of distinguishing between them, and others
    ignorant to the fact that multiple domains are reaching it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that is important to keep in mind: if you create an endpoint that
    has host level routing, then all routes on that same path must also have it. You
    cannot, for example, do the following. Notice how the third route does *not* define
    the `host` argument.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will *not* work, and will raise an exception at startup:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To solve this, make sure that all routes that could be grouped together have
    a `host` value. This way they can be distinguished. If one of them has a `host`,
    they all need to have one.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: We have generally now discussed all of the considerations to make when routing
    web requests to our response handlers. But, we have not yet looked at how Sanic
    delivers requests to static content (that is, actual files on your webserver that
    you want to send like images and stylesheets). Next, we will discuss some options
    both with and without using Sanic.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Serving static content
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far all of our discussion in this chapter has been about dynamically generating
    content for responses. We did, however, discuss that passing files that exist
    inside of a directory structure is a valid use case that Sanic supports. This
    is because most web applications have a need for serving some static content.
    The most common use cases would be for delivering Javascript files, images, and
    style sheets to be rendered by the browser. Now, we are going to dive into static
    content to see how that works, and we can deliver this type of content. After
    learning how Sanic does it, we will see another very common pattern to serve the
    content outside of Sanic with a proxy.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Serving static content from Sanic
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `app` instance has a method on it called `app.static()`. That method requires
    two arguments:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: A URI path for our application
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path to tell Sanic where it can access that resource
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That second argument can either be a single file, or a directory. If it is a
    directory, everything inside of it will be accessible like the old school web
    servers we talked about at the beginning of the chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This is very helpful if you plan to serve all of your web assets. What if you
    have a folder structure like this?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can use Sanic to serve all of those assets and make them accessible like
    this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '`app.static("/static", "./assets")`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Those assets are now accessible:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '`$ curl localhost:7777/static/css/styles.css`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Serving static content with Nginx
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have seen how to serve static files with Sanic, a good next question
    is: should you?'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Sanic is very fast at creating the sort of dynamic endpoints that are required
    by most web APIs. It even does a pretty good job serving static content, keeps
    all of your endpoint logic in one application, and even allows for manipulating
    those endpoints or renaming files. As we discussed in *Chapter 1*, *Introduction
    to Sanic and async frameworks* Sanic applications are also meant to be fast to
    build.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: There is however a potentially faster method for delivering static content.
    For a single-page application that is meant to be consumed by a browser that requests
    data through your API, one of your biggest stumbling blocks will be reducing the
    time to your first page render. This means that you must package up all of your
    JS, CSS, image, or other files as quick as possible to the browser to reduce rendering
    latency.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you might want to consider using a proxy layer like Nginx in
    front of Sanic. The purpose of the proxy would be to (1) send any requests to
    the API through to Sanic, and (2) handle serving static content itself. You may
    want to consider this option especially if you intend to serve a lot of static
    content. Nginx has a caching engine built in to be able to deliver static content
    much faster than any Python application could.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Running a server* discusses deployment strategies and considerations
    to make when deciding whether to use tools like Nginx and Docker. For now, we
    will use Docker Compose to really quickly and easily stand up Nginx.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make our `docker-compose.yml` manifest:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you are not familiar with Docker Compose or how to install and run it, you
    should be able to find a wealth of tutorials and information online.This simple
    setup we are going for in our example will require that you set the path for `./static`
    in our `docker-compose.yml` file to whatever directory you have your static assets
    in.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**TIP**'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is intentionally a super simple implementation. You should make sure that
    a real Nginx deployment includes things like TLS encyption and proxy secrets.
    Checkout the User Guide for more details and a helpful walkthrough. [https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration](https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration)
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we will create the .`/nginx/default.conf` file needed to control Nginx.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We start it using the following command:`$ docker-compose up`The most important
    thing to change here is the server address. You should change `1.2.3.4:8000` to
    whatever address and port your application can be accessed at. Keep in mind that
    this will *NOT* be `127.0.0.1` or `localhost`. Since Nginx will be running inside
    of a Docker container, that local address would point to the container itself,
    and not your computer’s local network address. Instead, for development purposes,
    you should consider setting it to your local IP address.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 3, you will need to make sure that Sanic knows to serve on that network
    address. Do you remember how we said we are running Sanic back in Chapter 2 Like
    this:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For this example, we will change that to:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'My local IP address is `192.168.1.7`, therefore I will set the `upstream` block
    in my Nginx configuration to: `server 192.168.1.7:7777;`.'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Step 4, you should now be able to access any static files in your `./static`
    directory. I have a file called `foo.txt.` I am using the `-i` flag with `curl`
    to be able to see the headers. The important header to see is the `Expires` and
    `Cache-Control`. These help your browser to cache the file instead of re-requesting
    it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you try to send a request to a file that does not exist, Nginx will send
    that route on to your Sanic application. This setup really just touches the tip
    of the iceberg when it comes to proxying and Nginx. It is, however, very common
    for Python web applications to use a strategy like this. As mentioned earlier,
    we will dig in deeper to this topic when we discuss deployment options in Chapter
    8.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Streaming Static Content
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also worth reiterating that the Sanic server is built and intended to
    be a front line server. That means that it can certainly stand as your point of
    ingress without a proxy server in front of it, including serving static content.
    The decision about whether to proxy or not—at least as it relates to delivering
    static files—is likely a question of how much traffic, and how many files your
    application may need to deliver.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor to consider is whether your application needs to stream
    files. Streaming will be discussed in depth in Chapter 5\. Let’s create a real
    simple web page to stream a video and see what that might look like.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: First the HTML. Store this as `index.html`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, find an `mp4` file that you want to stream. It can be any video file.
    If you do not have one, you can download a sample file for free from a website
    like this: [https://samplelib.com/sample-mp4.html](https://samplelib.com/sample-mp4.html).'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now create a small Sanic app to stream that video.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the server as normal and visit it in your web browser: [http://localhost:7777](http://localhost:7777)'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should notice that the root URI (`/`) redirected you to `/index.html`. Using
    `app.static`, the application tells Sanic that it should accept any requests to
    `/index.html` and serve back the static content that is located on the server
    at `/path/to/index.html` . This should be your delivered content from above. Hopefully
    you have a play button, and you can now stream your video to your browser. Enjoy!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This Chapter covers a lot of material on taking an HTTP request and turning
    it into something usable. At the core of a web framework is its ability to translate
    the raw request into an actionable handler. We have learned about how Sanic does
    this and how we can use HTTP Methods, good API design principles paths, path parameter
    extraction, and static content to build useful applications. As we learned earlier
    in this book, a little bit of up front planning goes a long way. Before putting
    too much code together, it is really helpful to think about the tools HTTP offers,
    and how Sanic allows us to take advantage of those features.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: If we did a good job in Chapter 2 of setting up directories, it should be very
    easy for us to loosely mirror that structure and nest Blueprints to match our
    intended API design.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: There are some key takeaways from this Chapter. You should purposely, and thoughtfully
    design your API endpoint paths—using nouns—that point to an intended target or
    resource. Then, HTTP Methods should be used as the verbs that tell your application
    and users *what* to do with that target or resource. Finally, you should extract
    helpful information from those paths to be used in your handlers.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'We mainly focused our attention on that first line of the raw HTTP request:
    the HTTP Method and URI path. In the next chapter, we will dive into extracting
    more data from the request including the headers and the request body.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
