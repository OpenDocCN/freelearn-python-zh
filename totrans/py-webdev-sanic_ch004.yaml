- en: 3 Routing and Intaking HTTP Requests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 路由和接收HTTP请求
- en: 'Back in *Chapter 1, Introduction to Sanic and Async Frameworks,* we looked
    at a raw HTTP request to see what kind of information it includes. In this chapter,
    we are going to take a closer look at that first line that contains the HTTP Method
    and the URI path. As we learned, the most basic function of a web framework is
    to translate the raw HTTP request into an actionable handler. Before we see how
    we can implement this, it is good to keep in mind what the raw requests look like:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章，Sanic和异步框架的介绍*中，我们查看了一个原始HTTP请求以了解它包含的信息。在本章中，我们将更仔细地查看包含HTTP方法和URI路径的第一行。正如我们所学的，Web框架最基本的功能是将原始HTTP请求转换为可执行的处理程序。在我们看到如何实现之前，记住原始请求的样子是好的：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the request, we see the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 观察请求，我们看到以下内容：
- en: 'The first line (sometimes called the *start line*) contains three subparts:
    **HTTP Method**, **request target**, and **HTTP** protocol'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行（有时称为*起始行*）包含三个子部分：**HTTP方法**、**请求目标**和**HTTP**协议
- en: 'The second section contains zero or more lines of HTTP headers in `key: value`
    form, with each pair separated by a line break'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第二部分包含零个或多个以`key: value`形式出现的HTTP头信息，每对之间由换行符分隔'
- en: Then, we have a blank line separating the head from the body
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个空白行将头部与正文分开
- en: Lastly, we have the *optional* body
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们还有可选的正文
- en: The exact specification is covered by RFC 7230, 3\. [https://datatracker.ietf.org/doc/html/rfc7230#section-3](https://datatracker.ietf.org/doc/html/rfc7230#section-3)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的规范由RFC 7230，3\. [https://datatracker.ietf.org/doc/html/rfc7230#section-3](https://datatracker.ietf.org/doc/html/rfc7230#section-3)
    覆盖
- en: 'One of the goals of this book is to learn strategies to design API endpoints
    that will be easily consumable, keeping in mind the needs and limitations of the
    application we are building. The goal is to understand the first interactions
    that the server has with an incoming web request, and how to design our application
    around that. We will learn about: how requests are structured; what choices Sanic
    makes for us and what choices it leaves; and other issues involved in turning
    an HTTP request into actionable code. Remember, the purpose of this book is not
    just to learn how to use a fancy new tool, but also to level-up web development
    skills and knowledge. To become more informed developers, we seek to not only
    understand *how* to build with Sanic, but *why* we might build something in a
    particular way. We will learn to ask better questions and to make better decisions
    by understanding some of the mechanics. This does not mean we need to be experts
    on the HTTP protocol and specification. By being familiar with, however, with
    what Sanic is doing with the raw request, we will ultimately be armed with a greater
    set of tools for building web applications.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是通过学习策略来设计易于消费的API端点，同时考虑到我们正在构建的应用程序的需求和限制。目标是理解服务器与传入的Web请求的第一交互，以及如何围绕这一点设计我们的应用程序。我们将学习：请求的结构；Sanic为我们做出的选择以及它留下的选择；以及将HTTP请求转换为可执行代码所涉及的其他问题。记住，本书的目的不仅仅是学习如何使用一个花哨的新工具，还要提升Web开发和知识技能。为了成为更了解的开发者，我们不仅寻求理解*如何*使用Sanic构建，还要理解*为什么*我们可能以特定方式构建某些内容。通过理解一些机制，我们将学会提出更好的问题并做出更好的决策。这并不意味着我们需要成为HTTP协议和规范的专家。然而，通过熟悉Sanic对原始请求的处理，我们最终将拥有构建Web应用程序的更强大的工具集。
- en: 'In particular, we’ll cover these topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Understanding HTTP Methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解HTTP方法
- en: Paths, slashes, and why they matter
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径、斜杠及其重要性
- en: Advanced path parameters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级路径参数
- en: API versioning
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本控制
- en: Virtual hosts
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟主机
- en: Serving static content
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态内容
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to what we have been building before, in this chapter you should
    have the following tools at your disposal in order to be able to follow along
    with the examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前所构建的内容之外，在本章中，你应该拥有以下工具以便能够跟随示例进行学习：
- en: Docker Compose
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Curl
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Curl
- en: 'You can access source code for this chapter on GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的源代码：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03)
- en: Understanding HTTP Methods
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解HTTP方法
- en: If you have built any kind of a website before, you probably have an understanding
    of the concept of **HTTP Methods**; or at least the basic `GET` and `POST` methods.
    However, did you know that there are nine standard HTTP Methods? In this section,
    we will learn about these different methods and how we *could* take advantage
    of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前构建过任何类型的网站，你可能对**HTTP方法**的概念有所了解；或者至少对基本的`GET`和`POST`方法有所了解。然而，你知道有九种标准的HTTP方法吗？在本节中，我们将了解这些不同的方法以及我们**可以**如何利用它们。
- en: 'In the same way that an IP address or a web domain is a *place* on the Internet,
    an HTTP Method is an *action* on the Internet. They are the collection of verbs
    in the language of the web. These HTTP Methods have a shared understanding and
    meaning. Web applications will commonly use these methods in similar use cases.
    That does not mean that you must follow the conventions, or that your application
    will break if you venture away from the standards. We should learn the rules so
    that we know when it may be appropriate to break them. These standards exist to
    create a common language that web developers and consumers can use to communicate:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像IP地址或网络域名是互联网上的**地点**一样，HTTP方法是在互联网上的**动作**。它们是网络语言中的动词集合。这些HTTP方法有一个共同的理解和意义。Web应用程序通常会在类似的使用场景中使用这些方法。这并不意味着你必须遵循这些约定，或者如果你的应用程序偏离了标准就会出错。我们应该学习这些规则，以便我们知道何时可能适合打破它们。这些标准存在是为了创建一个共同的语言，让Web开发者和消费者可以使用它来沟通：
- en: '| Method | Description | Has body | Safe | Sanic support |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 | 有主体 | 安全 | Sanic支持 |'
- en: '| `CONNECT` | Open two-way communication, like a tunnel to the resource | No
    | Yes | No |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `CONNECT` | 打开双向通信，如到资源的隧道 | 否 | 是 | 否 |'
- en: '| `DELETE` | Delete the resource | No (usually) | No | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除资源 | 否（通常） | 否 | 是 |'
- en: '| `GET` | Fetch the resource | No | Yes | Yes |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 获取资源 | 否 | 是 | 是 |'
- en: '| `HEAD` | Fetch the meta-data *only* for the resource | No | Yes | Yes |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 仅获取资源的元数据 | 否 | 是 | 是 |'
- en: '| `OPTIONS` | Request permitted communication options | No | Yes | Yes |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 请求允许的通信选项 | 否 | 是 | 是 |'
- en: '| `PATCH` | Partially modify the resource | Yes | No | Yes |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 部分修改资源 | 是 | 否 | 是 |'
- en: '| `POST` | Send data to the server | Yes | No | Yes |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 向服务器发送数据 | 是 | 否 | 是 |'
- en: '| `PUT` | Create a new resource or update completely if existing | Yes | No
    | Yes |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 创建新资源或如果存在则完全更新 | 是 | 否 | 是 |'
- en: '| `TRACE` | Perform message loopback used for debugging | No | Yes | No |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `TRACE` | 执行用于调试的消息回环 | 否 | 是 | 否 |'
- en: Table 3.1 - HTTP Method Overview
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 - HTTP方法概述
- en: When we talk about a method being *safe*, what we mean is that it should not
    be state-changing. That is not to say that a `GET` method cannot have side effects.
    Of course, it can. For example, someone hitting the endpoint will trigger logs
    or some sort of a resource counter. These are technically what the industry might
    refer to as side-effects. “*The important distinction here is that the user did
    not request the side-effects, so therefore cannot be held accountable for them.”*
    RFC 2616, 9.1.1 ([https://datatracker.ietf.org/doc/html/rfc2616#section-9](https://datatracker.ietf.org/doc/html/rfc2616#section-9)).
    This means that from the perspective of the user accessing the resource, the determination
    of whether an endpoint is *safe* is a matter of intent. If the user intends to
    retrieve profile information, it is safe. If the user intends to update profile
    information, it is not safe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论一个方法是否**安全**时，我们的意思是它不应该改变状态。这并不是说`GET`方法不能有副作用。当然，它可以。例如，有人点击端点会触发日志或某种资源计数器。这些在技术上可能是行业所说的副作用。“*这里的重要区别是用户没有请求这些副作用，因此不能对它们负责。”*
    RFC 2616，9.1.1 ([https://datatracker.ietf.org/doc/html/rfc2616#section-9](https://datatracker.ietf.org/doc/html/rfc2616#section-9))。这意味着从用户访问资源的角度来看，确定一个端点是否**安全**是一个意图问题。如果用户意图检索个人资料信息，则是安全的。如果用户意图更新个人资料信息，则是不安全的。
- en: While it is certainly helpful to try and stick to the descriptions of the methods
    in *Table 3.1*, undoubtedly you will come across use cases that do not fit nicely
    into these categories. When that happens, I encourage you to reexamine your application
    design. Sometimes the problem can be solved with new endpoint paths. Sometimes
    we need to create our own definitions. This is okay. I would, however, caution
    against changing a *safe* method to *unsafe.* Performing stateful changes with
    a `GET` request is considered poor form, and a *rookie mistake*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管尝试坚持 *表 3.1* 中的方法描述当然很有帮助，但无疑你将遇到不符合这些类别的用例。当这种情况发生时，我鼓励你重新审视你的应用程序设计。有时问题可以通过新的端点路径来解决。有时我们需要创建自己的定义。这是可以的。然而，我警告不要将
    *安全* 方法改为 *不安全*。使用 `GET` 请求进行状态更改被认为是不良的做法，是 *新手错误*。
- en: After deciding what our HTTP Methods should be, we will venture into the next
    section to learn about how we can implement them and attach them to routes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定我们的 HTTP 方法之后，我们将进入下一节学习如何实现它们并将它们附加到路由上。
- en: Using HTTP Methods on route handlers
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在路由处理器中使用 HTTP 方法
- en: 'We are finally ready to learn and see what frameworks are all about! If you
    have used Flask in the paste, this will look familiar. If not, what we are about
    to do is create a route definition that is a set of instructions to tell Sanic
    to send any incoming HTTP requests to our route handler. A route definition must
    have two parts: a URI path and one or more HTTP Methods.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好学习和了解框架是什么了！如果你之前使用过 Flask，这会看起来很熟悉。如果没有，我们即将要做的是创建一个路由定义，它是一组指令，告诉 Sanic
    将任何传入的 HTTP 请求发送到我们的路由处理器。路由定义必须有两个部分：一个 URI 路径和一个或多个 HTTP 方法。
- en: 'Matching on the URI path alone is not enough. HTTP Methods are also used by
    Sanic to get your incoming request to the correct handler. Even when we implement
    the most basic form of a route definition, both parts must exist. Let’s look at
    the simplest use case and see what default choices Sanic will make:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 仅匹配 URI 路径是不够的。HTTP 方法也被 Sanic 用于将你的传入请求路由到正确的处理器。即使我们实现最基本的路由定义形式，这两部分都必须存在。让我们看看最简单的用例，看看
    Sanic 会做出什么默认选择：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we defined a route at `/my/stuff`. Usually we inject the `route()`
    call with an optional `methods` argument to tell it what HTTP Methods we want
    that handler to respond to. We have not here, so it will default to just `GET`.
    We have the option of telling the route that it should also handle other HTTP
    Methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 `/my/stuff` 上定义了一个路由。通常我们会用可选的 `methods` 参数注入 `route()` 调用，以告诉它我们希望该处理器响应哪些
    HTTP 方法。我们没有在这里这样做，所以它将默认为 `GET`。我们有告诉路由它应该处理其他 HTTP 方法的选项：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**IMPORTANT NOTE**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will look at `HEAD` method a little later in this chapter. But it is important
    to know that a `HEAD` request should not have any response body. This is enforced
    by Sanic for us. Even though technically this endpoint is responding with the
    text `Hello`, Sanic removes the body from the response and only sends the meta
    data.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在本章稍后讨论 `HEAD` 方法。但重要的是要知道，`HEAD` 请求不应该有任何响应体。Sanic 会为我们强制执行这一点。尽管技术上这个端点正在响应文本
    `Hello`，但 Sanic 会从响应中移除体，只发送元数据。
- en: Now that we have a single endpoint setup with multiple methods, we can access
    it with both methods.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个具有多个方法的单个端点，我们可以用这两种方法来访问它。
- en: 'First, with a `GET` request (it should be noted that when using `curl`, if
    you do not specify a method, it will default to `GET`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `GET` 请求（应该注意的是，当使用 `curl` 时，如果你没有指定方法，它将默认为 `GET`）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a convenience, Sanic provides shortcut decorators to all of its supported
    HTTP Methods on both the app instance and any Blueprint instance:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Sanic 为其支持的所有 HTTP 方法在应用实例和任何 Blueprint 实例上提供了快捷装饰器：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These decorators can also be stacked. The last example that we saw could also
    be written like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器也可以堆叠。我们之前看到的最后一个例子也可以这样写：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One more fundamental thing to know about HTTP Methods is that you can access
    the incoming method on the HTTP request object. This is very helpful if you are
    handling different types of methods on the same handler, but need to treat them
    differently. Here is an example where we look at the HTTP Method to change the
    behavior of the handler
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 HTTP 方法还有一点需要了解，那就是你可以访问 HTTP 请求对象上的传入方法。如果你在同一个处理器上处理不同类型的 HTTP 方法，但需要以不同的方式处理它们，这非常有帮助。以下是一个例子，我们通过查看
    HTTP 方法来改变处理器的行为
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before moving on to advanced method routing, there is some Sanic syntax we
    should mention. All of the examples here use the decorator syntax to define routes.
    This is by far the most common way to achieve this because of its convenience.
    There is, however, an alternative. All route definitions could be converted to
    functional definitions as shown below:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到高级方法路由之前，我们应该提到一些 Sanic 语法。这里所有的示例都使用装饰器语法来定义路由。这无疑是实现这一目标最常见的方式，因为它很方便。然而，还有一个替代方案。所有的路由定义都可以转换为如下所示的功能定义：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In some circumstances this may be a more attractive pattern to use. We will
    see it again when we encounter Class-Based Views later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能是一个更吸引人的模式来使用。当我们在本章后面遇到基于类的视图时，我们还会再次看到它。
- en: Advanced method routing
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级方法路由
- en: 'Sanic does not out-of-the-box support `CONNECT` and `TRACE`, two standard HTTP
    Methods. But let’s imagine that you want to build an HTTP proxy or some other
    system that needs to have the `CONNECT` method available in your route handler.
    Even though Sanic does not out-of-the-box allow it, you have two potential approaches:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 默认不支持 `CONNECT` 和 `TRACE` 这两种标准 HTTP 方法。但让我们想象一下，如果你想构建一个 HTTP 代理或需要在其路由处理程序中提供
    `CONNECT` 方法的其他系统。尽管 Sanic 默认不允许这样做，但你有两种潜在的方法：
- en: 'First, we could create a piece of middleware that is on the lookout for `CONNECT`
    and hijacks the request to provide a custom response. This *trick* of responding
    from middleware is a feature that allows you to halt the execution of the request/response
    lifecycle before the handlers would take over and otherwise fail as a `404 Not
    Found`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以创建一个中间件，它会寻找 `CONNECT` 并劫持请求以提供自定义响应。这种从中间件响应的 *技巧* 是一个允许你在处理程序接管之前停止请求/响应生命周期的功能，否则会失败并显示
    `404 Not Found`：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that a potential downside to this approach is that we need to implement
    our own routing system if we wanted to send different endpoints to different handlers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这种方法的潜在缺点是我们需要实现自己的路由系统，如果我们想要将不同的端点发送到不同的处理程序。
- en: 'A second approach might be to tell the Sanic router that `CONNECT` is a valid
    HTTP Method. Once we do this, we can add it to a normal request handler:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法可能是告诉 Sanic 路由器 `CONNECT` 是一个有效的 HTTP 方法。一旦我们这样做，我们就可以将其添加到正常的请求处理程序中：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: One important consideration for this strategy is that you will need to redefine
    `app.router.ALLOWED_METHODS` as early as possible before registering the new handlers.
    For this reason, it might be best for it to come directly after `app = Sanic(...)`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种策略的一个重要考虑是，你需要在注册新处理程序之前尽可能早地重新定义 `app.router.ALLOWED_METHODS`。因此，它最好直接在
    `app = Sanic(...)` 之后进行。
- en: A side benefit that this strategy provides is the ability to create your own
    ecosystem of HTTP Methods with your own definitions. This may not necessarily
    be advisable if you intend for your API to be used for public consumption. However,
    it may be useful, practical, or just plain fun for your own purposes. There may
    only be nine standard methods, but there are infinite possibilities. Do you want
    to create your own verbs? You are certainly free to do so.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略提供的一个附带好处是能够创建自己的 HTTP 方法生态系统，并使用自己的定义。如果你打算让你的 API 供公众使用，这可能并不一定可取。然而，对于你自己的目的来说，这可能是有用的、实用的，或者只是纯粹的乐趣。虽然有九种标准方法，但可能性是无限的。你想要创建自己的动词吗？你当然可以这样做。
- en: '`ATTACK /path/to/the/dragon HTTP/1.1`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ATTACK /path/to/the/dragon HTTP/1.1`'
- en: Method safety and request body
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法安全性和请求体
- en: 'As we have learned, there are generally two types of HTTP Methods: **safe**
    and **unsafe**. The unsafe methods are `POST`, `PUT`, `PATCH`, and `DELETE`. These
    methods are generally understood to mean that they are state-changing. That is
    to say that by hitting these endpoints, the user is intending to change or alter
    the resource in some way.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，通常有两种类型的 HTTP 方法：**安全** 和 **不安全**。不安全的方法是 `POST`、`PUT`、`PATCH` 和 `DELETE`。这些方法通常被理解为它们是改变状态的。也就是说，通过点击这些端点，用户意图以某种方式改变或修改资源。
- en: 'The converse of this are safe methods: `GET`, `HEAD`, and `OPTIONS`. The purpose
    of these endpoints is to request information from the application, not change
    state.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的是安全方法：`GET`、`HEAD` 和 `OPTIONS`。这些端点的目的是从应用程序请求信息，而不是改变状态。
- en: It is considered good practice to follow this practice. If an endpoint will
    make a change on the server, do not use `GET`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一种良好的实践来遵循这一做法。如果一个端点将在服务器上做出更改，请不要使用 `GET`。
- en: 'Lining up with this division is the concept of request body. Let’s revisit
    the raw HTTP request one more time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种划分相对应的是请求体的概念。让我们再次回顾一下原始的HTTP请求：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'HTTP request can optionally include a body. In the above example, the request
    body is the last line: `{"foo": "bar"}`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP请求可以可选地包含一个消息体。在上面的例子中，请求体是最后一行：`{"foo": "bar"}`。'
- en: It is important to note that Sanic will only take the time to read the message
    body for `POST`, `PUT`, and `PATCH` requests. It will stop reading the HTTP message
    after the headers if it is an HTTP request using any other HTTP Method. This is
    a performance optimization since we generally do not expect there to be a message
    body on the *safe* HTTP requests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Sanic只会花费时间读取`POST`、`PUT`和`PATCH`请求的消息体。如果是一个使用任何其他HTTP方法的HTTP请求，它将在读取头部后停止读取HTTP消息。这是一个性能优化，因为我们通常不期望在*安全*的HTTP请求中存在消息体。
- en: 'You may have noticed this list did not include `DELETE`. Why? In general, the
    HTTP specification says that there *may* be a request body ([https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5)).
    Sanic assumes that it will not have one unless you tell it that it does. To do
    this, we simply set `ignore_body=False`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这个列表中没有包括`DELETE`。为什么？一般来说，HTTP规范说可能存在请求体（[https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5)）。Sanic假设除非你告诉它，否则它不会存在。为此，我们只需设置`ignore_body=False`：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we do not set `ignore_body=False`, and we send a body with our `DELETE` requests,
    Sanic will raise a warning in the logs to let us know that part of the HTTP message
    was not consumed. If you intend to use `DELETE` methods, you should be on the
    lookout for this since Sanic makes the assumption. It should also be noted that
    if you are in the habit of receiving GET requests with a body, you will also need
    to use `ignore_body=False`. However, I hope you have a very good reason for doing
    that since it breaks most web standards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有设置`ignore_body=False`，并且我们在`DELETE`请求中发送一个消息体，Sanic将在日志中发出警告，让我们知道HTTP消息的一部分没有被消费。如果你打算使用`DELETE`方法，你应该注意这一点，因为Sanic做出了这样的假设。还应该注意的是，如果你习惯于接收带有消息体的GET请求，你也需要使用`ignore_body=False`。然而，我希望你有一个非常好的理由来做这件事，因为这将违反大多数网络标准。
- en: One helpful takeaway from this is that out of the box, the following two endpoints
    are *not* equal.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以得到的一个有用的启示是，开箱即用，以下两个端点**并不相等**。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Both `/one` and `/two` will behave similarly. Without further customization,
    however, the first request will spend time trying to read the request body even
    if it does not exist, while the second just assumes that it is the case that there
    is no body. While the performance difference will be small, it is generally preferred
    to use `@app.get("/two")` over `@app.route("/one", methods=["GET"])`. The reason
    that these two endpoints differ is that they have different default values for
    `ignore_body`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`/one`和`/two`的行为将相似。然而，如果没有进一步的定制，第一个请求将花费时间尝试读取可能不存在的请求体，而第二个则假设不存在消息体。虽然性能差异可能很小，但通常更倾向于使用`@app.get("/two")`而不是`@app.route("/one",
    methods=["GET"])`。这两个端点之所以不同，是因为它们对`ignore_body`的默认值不同。'
- en: '**IMPORTANT NOTE**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are building a GraphQL application, then usually `POST` is used by the
    endpoint even for informational requests. This is because it is generally much
    more acceptable to pass a body on a `POST` request than a `GET` request. However,
    it is worth mentioning that we could consume a message body from a `GET` request
    if we really wanted to by setting `ignore_body=False`.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在构建一个GraphQL应用程序，那么通常即使对于信息请求，端点也会使用`POST`。这是因为将消息体放在`POST`请求中通常比放在`GET`请求中更容易被接受。然而，值得一提的是，如果我们真的想的话，我们可以通过设置`ignore_body=False`从`GET`请求中消费消息体。
- en: 'When deciding what method you should use, another factor to consider is **idempotency**.
    In short, idempotence means that you can perform the same action over and over
    again, and the result should be the same every time. The HTTP Methods that are
    considered idempotent are: `GET`, `HEAD`, `PUT`, `DELETE`, `OPTIONS`, and `TRACE`.
    Keep this in mind when designing your API.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定使用哪种方法时，另一个需要考虑的因素是**幂等性**。简而言之，幂等性意味着你可以重复执行相同的操作，每次的结果都应该是相同的。被认为是幂等的HTTP方法有：`GET`、`HEAD`、`PUT`、`DELETE`、`OPTIONS`和`TRACE`。在设计你的API时请记住这一点。
- en: RESTful API design
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTful API设计
- en: HTTP Methods are often used in **RESTful API design**. There is a wealth of
    literature already written on building RESTful APIs, so we will not dive deeply
    into *what* it is, but more *how* we can practically implement it. We shall, however,
    first have a quick refresher of the basic premise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 方法通常用于 **RESTful API 设计**。关于构建 RESTful API 的文献已经非常丰富，因此我们不会深入探讨它是什么，而是更多地关注我们如何实际实现它。然而，我们首先应该快速回顾一下基本前提。
- en: Web API endpoints have a target. That target is *something* that either the
    user would like to fetch information about, or manipulate by adding or changing
    it. Based upon a shared understanding, the HTTP Method tells the server how you
    would like to interact with that target. The *target* is often called a *resource*,
    and we may use the terms interchangeably here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Web API 端点有一个目标。这个目标是指用户想要获取信息或通过添加或更改来操作的东西。基于共同的理解，HTTP 方法告诉服务器您希望如何与该目标交互。该
    **目标** 通常被称为 **资源**，在这里我们可以互换使用这些术语。
- en: 'To grasp this concept, I like to think back to the adventure computer games
    I played as a child. My swashbuckling character would happen upon an object: let’s
    say a rubber chicken. When I clicked on that object, a menu would appear with
    different verbs that told me what I could do with that object: pick up, look at,
    use, talk to, and so on. There was a target (the rubber chicken), and methods
    (the verbs or actions).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，我喜欢回想我小时候玩的冒险电脑游戏。我的冒险角色会偶然发现一个物品：比如说一个橡胶鸡。当我点击那个物品时，会出现一个菜单，显示不同的动词，告诉我我可以对这个物品做什么：捡起、查看、使用、交谈等等。有一个目标（橡胶鸡），以及方法（动词或动作）。
- en: 'Putting this together with the HTTP Methods we defined above, let’s look at
    a concrete example. In our hypothetical situation, we will be building an API
    to manage a social media platform for people that love adventure computer games.
    Users need to be able to create a profile, view other profiles, and update their
    own. We might design the following endpoints:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些与我们上面定义的 HTTP 方法结合起来，让我们看看一个具体的例子。在我们的假设情况下，我们将构建一个用于管理喜欢冒险电脑游戏的人们的社交媒体平台的
    API。用户需要能够创建个人资料、查看其他个人资料以及更新自己的个人资料。我们可能会设计以下端点：
- en: '| **METHOD** | **URI PATH** | **DESCRIPTION** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URI 路径** | **描述** |'
- en: '| `GET` | `/profiles` | A list of all of the member profiles |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/profiles` | 所有成员个人资料的列表 |'
- en: '| `POST` | `/profiles` | Create a new profile |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/profiles` | 创建新的个人资料 |'
- en: '| `GET` | `/profiles/<username>` | Retrieve profile for a single user |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/profiles/<username>` | 获取单个用户的个人资料 |'
- en: '| `PUT` | `/profiles/<username>` | Remove the old profile and replace with
    a complete profile |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/profiles/<username>` | 删除旧的个人资料并用完整的个人资料替换 |'
- en: '| `PATCH` | `/profiles/<username>` | Make a change to only a part of a profile
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | `/profiles/<username>` | 仅对个人资料的一部分进行更改 |'
- en: '| `DELETE` | `/profiles/<username>` | Remove a profile–but why would anyone
    want to remove their swashbuckling adventure gamer profile? |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/profiles/<username>` | 删除个人资料——但为什么有人会想删除他们的冒险游戏玩家个人资料呢？ |'
- en: Table 3.2 - Example HTTP Methods and endpoints
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 - 示例 HTTP 方法与端点
- en: 'Before we go further, if you are unfamiliar with how routing works in Sanic
    (and what the `<username>` syntax means), you can get more information in the
    User Guide here: [https://sanicframework.org/en/guide/basics/routing.html](https://sanicframework.org/en/guide/basics/routing.html),
    and we will also look at it more closely later in this chapter in the section
    titled *Extracting information from the path*. Feel free to skip ahead and come
    back.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，如果您对 Sanic 中的路由工作方式不熟悉（以及 `<username>` 语法意味着什么），您可以在用户指南中获取更多信息：[https://sanicframework.org/en/guide/basics/routing.html](https://sanicframework.org/en/guide/basics/routing.html)，我们也会在本章的“从路径中提取信息”部分更详细地探讨它。您可以自由地跳过并稍后回来。
- en: 'As you can see, there really are only two URI paths: `/profiles` and `/profiles/<username>`.
    Using the HTTP Methods, however, we have been able to define six different interactions
    with our API! What might the profile blueprint look like?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实际上只有两个 URI 路径：`/profiles` 和 `/profiles/<username>`。然而，通过使用 HTTP 方法，我们已经能够定义与我们的
    API 的六种不同交互！个人资料蓝图可能是什么样的呢？
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using HTTP Methods to define our use cases seems helpful and having decorators
    that map them seems convenient. But, it seems like there is a lot of boilerplate
    there, and repetition. We will next look at Class-Based Views and how we can simplify
    our code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP 方法来定义我们的用例似乎很有帮助，并且有映射它们的装饰器似乎很方便。但是，似乎有很多样板代码和重复。接下来，我们将探讨基于类的视图以及我们如何简化我们的代码。
- en: Simplifying your endpoints with Class-Based Views
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用基于类的视图简化你的端点
- en: The previous example exposes a weakness with using functions and decorators
    alone to design your API. What happens when we want to add endpoint handlers for
    `/profile/<user_id:uuid>`? Or when we want to make some other change to the existing
    endpoint? We now have multiple places to make the same change, leading to a higher
    chance that we do not maintain parity among all our route definitions. This is
    a violation of the **DRY** (**don’t repeat yourself**) principle, and could lead
    to bugs. Maintaining these endpoints over the long term therefore might be more
    difficult than necessary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子暴露了仅使用函数和装饰器来设计 API 的弱点。当我们想要为 `/profile/<user_id:uuid>` 添加端点处理程序时会发生什么？或者当我们想要对现有端点进行其他更改时？我们现在有多个地方可以做出相同的更改，这导致我们无法在所有路由定义之间保持一致性，这是违反了
    **DRY**（**不要重复自己**）原则的，可能会导致错误。因此，从长远来看，维护这些端点可能比必要的更困难。
- en: 'This is one of the compelling reasons to use **Class-Based Views** (**CBVs**).
    This pattern will give us the opportunity to link together the first two endpoints,
    and the last four endpoints so they become easier to manage. They are being grouped
    together because they share the same URI path. Instead of standalone functions,
    each HTTP Method will be a functional method on a class. And, that class will
    be assigned a common URI path. A bit of code should make this easy to understand:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 **基于类的视图**（**CBV**）的一个非常有说服力的原因。这个模式将给我们提供将前两个端点和最后四个端点链接在一起的机会，使它们更容易管理。它们被分组在一起是因为它们共享相同的
    URI 路径。而不是独立的函数，每个 HTTP 方法将是一个类上的功能方法。而且，这个类将被分配一个公共的 URI 路径。一点代码应该能让你更容易理解：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**IMPORTANT NOTE**'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later in this book we may see more and more use of custom decorators to add
    shared functionality. It is worth mentioning that we can also add them easily
    to CBVs, and I highly suggest you take a moment to refer to the User Guide to
    see it in action: [https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators](https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators)'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本书的后面，我们可能会看到更多使用自定义装饰器来添加共享功能的情况。值得一提的是，我们也可以很容易地将它们添加到 CBV 中，我强烈建议你花点时间查阅用户指南，看看它是如何工作的：[https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators](https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators)
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One thing to be on the lookout for when adding decorators to CBV methods is
    the `self` argument on instance methods. You may need to adjust your decorator,
    or use a `staticmethod` to get it to work as expected. The above mentioned documentation
    explains how to do that.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在向 CBV 方法添加装饰器时，需要注意的一点是实例方法的 `self` 参数。你可能需要调整你的装饰器，或者使用 `staticmethod` 来使其按预期工作。上面提到的文档解释了如何做到这一点。
- en: 'Earlier, we saw how `add_route` could be used as an alternative approach to
    attaching a single function as a handler to a route definition. It looked like
    this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何使用 `add_route` 作为将单个函数作为处理程序附加到路由定义的替代方法。它看起来是这样的：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This pattern is one of the main ways to attach a CBV to a Sanic or Blueprint
    instance. The caveat is that you need to call it using the class method: `as_view()`.
    In our previous example, we saw what this looked like:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是将 CBV 附加到 Sanic 或 Blueprint 实例的主要方式之一。需要注意的是，你需要使用类方法 `as_view()` 来调用它。在我们之前的例子中，我们看到了它的样子：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This could also be achieved by attaching the CBV when it is declared. This is
    option will only work if you already have a known Blueprint or Application instance.
    We will rewrite `SingleProfileView` to take advantage of this alternative syntax.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在声明时附加 CBV 来实现。这个选项只在你已经有一个已知的 Blueprint 或 Application 实例时才有效。我们将重写 `SingleProfileView`
    以利用这种替代语法。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How should you decide which to use? Personally, I find this second version to
    be easier and cleaner. The big downside is that you cannot lazily create the CBV
    and attach it later since it needs to be known up front.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该如何决定使用哪一个？我个人觉得第二个版本更容易、更简洁。但最大的缺点是，你不能懒加载 CBV 并稍后附加，因为它需要提前知道。
- en: Blanket support for OPTIONS and HEAD
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 OPTIONS 和 HEAD 的全面支持
- en: It is generally best practice to support `OPTIONS` and `HEAD` methods on all
    of your endpoints, where it is appropriate. This could become tedious and include
    a lot of repetitive boilerplate. To achieve this with standard route definitions
    alone would require a lot of code duplication as seen below. Below, we see that
    we need for route definitions where two would be sufficient. Now imagine if every
    endpoint needed to also have `OPTIONS` and `HEAD`!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在所有端点上支持`OPTIONS`和`HEAD`方法是一种最佳实践，只要这是合适的。这可能会变得繁琐，包括大量的重复模板代码。仅使用标准路由定义来实现这一点，就需要大量的代码重复，如下所示。下面，我们看到我们需要两个路由定义，而实际上只需要一个。现在想象一下，如果每个端点都需要有`OPTIONS`和`HEAD`会怎样！
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use Sanic’s router to our advantage to add on a handler for these requests
    to each and every route. The idea will be to loop over all of the routes defined
    in our application and dynamically add handlers for `OPTIONS` and `HEAD` if needed.
    Later on in *Chapter 7*, we will use this strategy for creating our customized
    CORS policy. For now, however, all we need to keep in mind is that we want to
    be able to handle ANY request to a valid endpoint using one of these HTTP Methods:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Sanic的路由器来添加处理程序，为每个路由添加处理这些请求的处理程序。想法将是遍历我们应用程序中定义的所有路由，并在需要时动态添加`OPTIONS`和`HEAD`的处理程序。在*第7章*的后面，我们将使用这种策略来创建我们的自定义CORS策略。然而，现在我们只需要记住，我们希望能够使用以下HTTP方法之一来处理对有效端点的任何请求：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s take a closer look at this code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这段代码。
- en: 'First, we create route handlers: the functions that will do the work when the
    endpoint is hit. For now, they do not do anything. If you want to know what this
    endpoint *could* do, jump ahead to the CORS discussion in *Setting up an effective
    CORS policy* located in *Chapter 7*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建路由处理程序：当端点被击中时将执行工作的函数。现在，它们不做任何事情。如果您想知道这个端点*可能*做什么，请跳转到*设置有效的CORS策略*中的CORS讨论，该讨论位于*第7章*。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The next part needs to be done after we register all of our endpoints. In *Chapter
    11*, we accomplish this by running the code inside of a factory. Feel free to
    take a look ahead to the example there to be able to compare it with our current
    implementation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们注册了所有端点之后，下一部分需要完成。在*第11章*中，我们通过在工厂内部运行代码来完成这个任务。您可以随意提前查看那里的示例，以便能够将其与我们的当前实现进行比较。
- en: In our current example, we do not have a factory, and are adding the routes
    inside an event listener. Normally, this would not be possible since we cannot
    change our routes after the application is running. When a Sanic application starts
    up, one of the first things it does internally is call `app.router.finalize()`.
    But, it will not let us call that method twice. Therefore, we need to run `app.router.reset()`,
    add our routes, and finally call `app.router.finalize()` after all of our dynamic
    route generation is complete. You can use this same strategy anywhere that you
    might want to dynamically add routes. Is this a good idea? In general, I would
    say that dynamically adding routes is a bad idea. Having changing endpoints might
    lead to unpredictability, or weird bugs across a distributed application. However,
    the benefit we are gaining through dynamic route generation in this instance is
    great, and the risk is very low.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的当前示例中，我们没有工厂，而是在事件监听器内部添加路由。通常情况下，这是不可能的，因为我们不能在应用程序运行后更改我们的路由。当Sanic应用程序启动时，它内部首先做的事情之一就是调用`app.router.finalize()`。但是，它不会让我们调用这个方法两次。因此，我们需要在所有动态路由生成完成后运行`app.router.reset()`，添加我们的路由，并最终在所有动态路由生成完成后调用`app.router.finalize()`。您可以在可能动态添加路由的任何地方使用这种相同的策略。这是一个好主意吗？一般来说，我会说动态添加路由不是一个好主意。端点的变化可能会导致不可预测性，或者在分布式应用程序中出现奇怪的错误。然而，在这个例子中，通过动态路由生成获得的收益是巨大的，风险非常低。
- en: 'There are a few different properties that the Sanic router provides us with
    that we could loop over to see what routes are registered. The two most commonly
    used for public consumption are `app.router.routes` and `app.router.groups`. It
    is helpful to understand what they are and how they differ. We will put our discussion
    on `OPTIONS` and `HEAD` on pause for a brief moment to look at these two properties
    to see how:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic路由器为我们提供了一些不同的属性，我们可以遍历它们来查看注册了哪些路由。最常用于公共消费的两个属性是`app.router.routes`和`app.router.groups`。了解它们是什么以及它们之间的区别是有帮助的。我们将暂时暂停对`OPTIONS`和`HEAD`的讨论，来看看这两个属性是如何实现的：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing to notice is that one of them is producing `Route` objects,
    and the other `RouteGroup` objects. The second obvious takeaway is that one is
    a list and the other a dictionary. But what are `Route` and `RouteGroup`?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要注意的是，其中一个是生成`Route`对象，另一个是生成`RouteGroup`对象。第二个明显的启示是，一个是列表，另一个是字典。但`Route`和`RouteGroup`是什么？
- en: 'In our console, we will see that there are three `Route` objects, but only
    two `RouteGroup` objects. This is because Sanic has grouped together similar looking
    routes to more efficiently match them later. A `Route` is a single definition.
    Every time we call `@app.route`, we are creating a new `Route`. Here, we can see
    that they have been grouped by the URI path:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制台，我们会看到有三个`Route`对象，但只有两个`RouteGroup`对象。这是因为Sanic将看起来相似的路径组合在一起，以便更有效地匹配它们。`Route`是一个单独的定义。每次我们调用`@app.route`时，我们都在创建一个新的`Route`。在这里，我们可以看到它们是根据URI路径进行分组的：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getting back to our discussion of automation, we are going to use `app.router.groups`.
    This is because we want to know which methods have and have not been assigned
    to a given path. The quickest way to figure that out is to look at the groups
    that Sanic has already provided for us. All we need to do is check if the group
    already includes a handler for the HTTP Method (so we do not overwrite anything
    that already exists), and call `add_route`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们对自动化的讨论，我们将使用`app.router.groups`。这是因为我们想知道哪些方法被分配给了特定的路径，哪些没有被分配。最快的方法是查看Sanic为我们提供的组。我们只需要检查该组是否已经包含了一个处理HTTP方法的处理程序（这样我们就不会覆盖已经存在的内容），然后调用`add_route`。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although we will not look at `options_handler` right now, we can look more
    closely at `head_handler`. A `HEAD` request is defined in RFC 2616 as being identical
    to a `GET` request: “*The HEAD method is identical to GET except that the server
    MUST NOT return a message-body in the response”* ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4)).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在不会查看`options_handler`，但我们可以更仔细地看看`head_handler`。根据RFC 2616的定义，`HEAD`请求与`GET`请求相同：“*HEAD方法与GET方法相同，除了服务器在响应中不得返回消息体。*”（[https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4))。
- en: 'This is pretty easy to implement in Sanic. Really what we want to do is retrieve
    the response from the `GET` handler for the same endpoint, but only return the
    metadata, *not* the request body. We will use `functools.partial` to pass the
    `GET` handler to our `head_handler`. Then, all it needs to do is run the `get_handler`
    and return the response. As we saw earlier in the chapter, Sanic will do the work
    for us of removing the body before it sends the response to the client:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sanic中实现这一点相当简单。实际上我们想要做的是检索同一端点的`GET`处理程序的响应，但只返回元数据，*而不是*请求体。我们将使用`functools.partial`将`GET`处理程序传递给我们的`head_handler`。然后，它只需要运行`get_handler`并返回响应。正如我们在本章前面看到的，Sanic会在发送响应到客户端之前为我们处理移除体（body）的工作：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**IMPORTANT NOTE**'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the above example we added `name=f"{get_route.name}_head"` to our `add_route`
    method. This is because all routes in Sanic get a “name”. If you do not manually
    supply one, then Sanic will attempt to generate a name for you using `handler.__name__.`
    In this case, we are passing a `partial` function as a route handler, and Sanic
    does not know how to generate a name for that since partial functions in Python
    have no `__name__` property.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们在`add_route`方法中添加了`name=f"{get_route.name}_head"`。这是因为Sanic中的所有路由都有一个“名称”。如果你没有手动提供，那么Sanic会尝试使用`handler.__name__`为你生成一个名称。在这种情况下，我们传递了一个`partial`函数作为路由处理程序，而Sanic不知道如何为它生成名称，因为Python中的`partial`函数没有`__name__`属性。
- en: 'Now that we know about how to use HTTP Methods to our advantage, we will look
    at the next big area in routing: **paths**.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何利用HTTP方法来获取优势，我们将探讨路由中的下一个重要领域：**路径**。
- en: Paths, slashes, and why they matter
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径、斜杠以及它们的重要性
- en: Way back in the stone-age when the Internet was invented, if you navigated to
    a URL, you were literally being delivered a file that existed on a computer somewhere.
    If you asked for `/path/to/something.html`, the server would look in the `/path/to`
    directory for a file called `something.html`. If that file existed, it would send
    it to you.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在石器的时代，当互联网被发明出来时，如果你导航到一个URL，你实际上是在接收一个存在于某台电脑上的文件。如果你请求`/path/to/something.html`，服务器会在`/path/to`目录中寻找一个名为`something.html`的文件。如果该文件存在，它会发送给你。
- en: 'While this does still exist, times have certainly changed for many applications.
    The Internet is still largely based upon this premise, but often a generated document
    is sent instead of a static document. It is helpful to still keep this mental
    model in your head though. Thinking that a path on your API should lead to a resource
    of some kind will keep you away from certain API design flaws. For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种情况仍然存在，但许多应用的时代确实已经改变。互联网在很大程度上仍然基于这个前提，但通常发送的是生成的文档而不是静态文档。尽管如此，仍然保持这种心理模型在脑海中是有帮助的。认为你的API路径应该指向某种资源将帮助你避免某些API设计缺陷。例如：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Your URI paths should use nouns, not verbs. If we want to perform an action
    and tell the server to do something, we should manipulate the HTTP Method as we
    learned, not the path of the URI. Going down this path—believe me, I’ve done it—will
    lead to some messy looking applications. Very likely you will wake up one day
    and look at a mess of disjointed and incoherent paths and ask yourself: what have
    I done? There might, however, be a time and place for this, so we will revisit
    it shortly.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你的URI路径应该使用名词，而不是动词。如果我们想执行一个动作并告诉服务器做什么，我们应该像我们学的那样操作HTTP方法，而不是URI路径。走这条路——相信我，我试过——会导致一些看起来很混乱的应用程序。很可能有一天早上醒来，你会看到一堆零散和不连贯的路径，然后问自己：我做了什么？然而，可能会有时间和地点适合这样做，所以我们很快会重新讨论这个问题。
- en: Knowing that our paths should contain nouns, the obvious next question is whether
    they should be singular or plural. I do not think there is a single consensus
    on the Internet about what is right here. Many people always use plural; many
    people always use singular; and some wild hooligans decide to mix and match. While
    the decision itself may seem small, it is nevertheless important to establish
    consistency. Picking a system and applying consistency is itself more important
    than the actual decision.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们的路径应该包含名词，接下来的明显问题是它们应该是单数还是复数。我认为在互联网上关于这里什么是对的并没有一个单一的共识。许多人总是使用复数；许多人总是使用单数；还有一些人决定混合使用。虽然这个决定本身可能看起来很小，但它仍然很重要，需要建立一致性。选择一个系统并保持一致性本身比实际的决定更重要。
- en: 'With that out of the way, I will give you my opinion. Use plural nouns. Why?
    It makes for very nice nesting of paths, which could translate nicely to nesting
    of Blueprints:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题解决之后，我将给出我的观点。使用复数名词。为什么？它使得路径的嵌套非常优雅，这可以很好地转化为Blueprints的嵌套：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I do encourage you to use singular nouns if it makes sense to you. But if you
    do, you must do it everywhere. As long as you stay consistent and logical about
    your choice, your API will feel polished. Mixing plural and singular paths will
    make your API feel haphazard and amateurish. A really nice resource that explains
    how to *consistently* break the two rules I just laid out (use nouns, use plural)
    is found here: [https://restfulapi.net/resource-naming/.](https://restfulapi.net/resource-naming/.)
    Again, it is important and helpful for us to not only learn the *rules* or the
    *right way* to do something but to also learn when to break them, or when to make
    our own set of rules. Sometimes following standards makes sense, sometimes not.
    This is how we go from someone that merely is capable of making a web application,
    to someone that knows how to design and build one. The difference is expertise.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实鼓励你在觉得合理的情况下使用单数名词。但如果你这样做，你必须无处不在。只要你在选择上保持一致和逻辑，你的API就会显得很精致。混合单数和复数路径会让你的API显得杂乱无章和业余。这里有一个非常好的资源，解释了如何*一致地*打破我刚刚提出的两个规则（使用名词，使用复数）：[https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)。再次强调，对于我们来说，不仅学习*规则*或做某事的*正确方式*很重要和有帮助，而且学习何时打破它们，或何时制定我们自己的规则也很重要。有时遵循标准是有意义的，有时则不然。这就是我们从仅仅能够制作网络应用的人，变成知道如何设计和构建网络应用的人的过程。这种区别就是专业知识。
- en: 'It is also encouraged when designing paths to favor hyphens (`-`) over spaces,
    capitalization, or underscores. This increases the human readability of your API.
    Consider the difference between these:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计路径时，也鼓励优先使用连字符（`-`）而不是空格、大写字母或下划线。这增加了API的人阅读性。考虑一下这些之间的区别：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Most people would consider the last option to be the easiest to read.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人都会认为最后一个选项是最容易阅读的。
- en: Strict slashes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格的斜杠
- en: Because of the legacy paradigm where endpoints were equivalent to the file structure
    of a server, the trailing slash in a path took on a specific meaning. It is widely
    accepted that paths with and without trailing slashes are not the same and are
    not interchangeable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传统的范式，其中端点等同于服务器的文件结构，路径中的尾部斜杠获得了特定的含义。人们普遍认为，带有和没有尾部斜杠的路径是不同的，不能互换。
- en: If you navigated to `/characters`, you might expect to receive a list of all
    the characters in our fictitious social media application. However, `/characters/`
    technically means *show me a list of everything that is in the* `characters` *directory*.
    Because this could be confusing, you are encouraged to avoid using trailing slashes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到`/characters`，您可能会期望收到我们虚构社交媒体应用中所有字符的列表。然而，`/characters/`在技术上意味着*显示*
    `characters` *目录中的所有内容*。因为这可能令人困惑，您被鼓励避免使用尾部斜杠。
- en: 'On the other hand, it is also widely accepted that these *are* the same thing.
    In fact, a lot of browsers (and websites) treat them the same. I’ll show you how
    you can test this for yourself:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，人们普遍认为这些*确实是*同一回事。事实上，许多浏览器（和网站）都把它们视为相同。我将向您展示您如何自己测试这一点：
- en: 'Open your web browser and go to: [https://sanic.readthedocs.io/en/stable/](https://sanic.readthedocs.io/en/stable/)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的网络浏览器并访问：[https://sanic.readthedocs.io/en/stable/](https://sanic.readthedocs.io/en/stable/)
- en: 'Now open a second tab and go to: [https://sanic.readthedocs.io/en/stable](https://sanic.readthedocs.io/en/stable)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开第二个标签页并访问：[https://sanic.readthedocs.io/en/stable](https://sanic.readthedocs.io/en/stable)
- en: It is the same page. In fact, it seems that this web server breaks the rule
    that I just mentioned and prefers the trailing slash to not having it at all.
    So, where does this leave us, and what should we implement? It is really up to
    you to determine, so let’s see how we can control it in Sanic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它是同一页。事实上，似乎这个网络服务器打破了刚才提到的规则，并更喜欢没有尾部斜杠。那么，这让我们处于什么位置，我们应该实现什么？这完全取决于您自己决定，让我们看看我们如何在Sanic中控制它。
- en: 'If you do nothing, Sanic will drop the trailing slash for you. Sanic does,
    however, provide you with the ability to control whether that trailing slash should
    have meaning or not by setting the `strict_slashes` argument. Consider an application
    setup with and without trailing slashes, and with and without `strict_slashes`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您什么都不做，Sanic会为您删除尾部斜杠。然而，Sanic确实提供了通过设置`strict_slashes`参数来控制尾部斜杠是否有意义的选项。考虑一个带有和没有尾部斜杠，以及带有和没有`strict_slashes`的应用程序设置：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The above definitions will fail. Why? When Sanic sees a trailing slash on a
    path definition it will remove it, *unless* `strict_slashes=True`. Therefore,
    the first and second routes are considered identical. Furthermore, the third route
    is also the same, therefore causing a conflict.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义将失败。为什么？当Sanic在路径定义中看到尾部斜杠时，它会将其删除，*除非* `strict_slashes=True`。因此，第一条和第二条路由被认为是相同的。此外，第三条路由也是相同的，因此导致冲突。
- en: While the generally accepted rule is that a trailing slash *should* have meaning,
    this is not the case for a trailing slash that is the only part of a path. RFC
    2616, Section 3.2.3 states that an empty path (`""`) is the same thing as a single
    slash path (`"/"`). ([https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3](https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3))
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然普遍认为规则是尾部斜杠*应该*有含义，但对于仅是路径一部分的尾部斜杠来说，情况并非如此。RFC 2616，第3.2.3节指出，空路径（`""`）与单个斜杠路径（`"/"`）是同一回事。（[https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3](https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3)）
- en: 'I put together a deeper discussion about how Sanic handles the possible scenarios
    of trailing slashes. If this is something you are considering to use, I suggest
    you take a look here: [https://community.sanicframework.org/t/route-paths-how-do-they-work/825.](https://community.sanicframework.org/t/route-paths-how-do-they-work/825.)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我整理了一个关于Sanic如何处理尾部斜杠可能场景的深入讨论。如果您正在考虑使用它，我建议您查看这里：[https://community.sanicframework.org/t/route-paths-how-do-they-work/825.](https://community.sanicframework.org/t/route-paths-how-do-they-work/825.)
- en: 'If you were to ask me my opinion, I would say do not use them. It is much more
    forgiving to allow `/characters` and `/characters/` to have the same meaning.
    Therefore, I personally would define the above route as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果让我发表意见，我会说不要使用它们。允许`/characters`和`/characters/`具有相同含义会更加宽容。因此，我个人会这样定义上述路由：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Extracting information from the path
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从路径中提取信息
- en: 'The last thing we need to consider in this section is extracting usable information
    from our request. The first place we often look is the URI path. Sanic provides
    a simple syntax for extracting parameters from the path:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要考虑的最后一件事情是从我们的请求中提取可用的信息。我们经常查看的第一个地方是 URI 路径。Sanic 提供了一种简单的语法来从路径中提取参数：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have declared the second segment in our path to contain a variable. The Sanic
    router extracts that and injects it as an argument in our handler. It is important
    to note that if we do nothing else, that injection will be a `str` type value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明路径的第二部分包含一个变量。Sanic 路由器会提取这个变量，并将其作为参数注入到我们的处理器中。需要注意的是，如果我们不做其他操作，这种注入将是一个
    `str` 类型的值。
- en: Sanic also provides an easy mechanism for converting the type. Suppose we want
    to retrieve a single message from a message feed, query it in the DB, and return
    the message. In this case, our call to the DB requires the `message_id` to be
    an `int`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 还提供了一个简单的机制来转换类型。假设我们想从消息源中检索一条消息，在数据库中查询它，并返回该消息。在这种情况下，我们的数据库调用需要 `message_id`
    是一个 `int`。
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This route definition will tell Sanic to convert the second segment into an
    `int` before injecting it. It is also important to note that if the value is something
    that cannot be cast as an `int`, it will raise a `404 Not Found`. Therefore, the
    parameter type does more than just type casting. It is also involved in route
    handling.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由定义将告诉 Sanic 在注入之前将第二部分转换为 `int` 类型。同样重要的是要注意，如果值是无法转换为 `int` 的类型，它将引发一个
    `404 Not Found` 错误。因此，参数类型不仅仅是类型转换，它还涉及到路由处理。
- en: You can refer to the next section, and the User Guide to learn what all of the
    allowed parameter types are. [https://sanicframework.org/en/guide/basics/routing.html#path-parameters](https://sanicframework.org/en/guide/basics/routing.html#path-parameters)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考下一节和用户指南，了解所有允许的参数类型。[https://sanicframework.org/en/guide/basics/routing.html#path-parameters](https://sanicframework.org/en/guide/basics/routing.html#path-parameters)
- en: 'Besides extracting information from the path itself, the two other places we
    may want to look for user data are the query parameters, and the request body.
    Query parameters is the part of the URL that comes after a `?`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从路径本身提取信息外，我们可能还想查找用户数据的两个其他地方是查询参数和请求体。查询参数是 URL 中 `?` 后的部分：
- en: '`/characters?count=10&name=george`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`/characters?count=10&name=george`'
- en: 'How should we decide if information should be passed in the path, the query
    arguments, or as a part of form or JSON body? Best practices dictate that information
    should be accessed as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何决定信息应该通过路径、查询参数，还是作为表单或 JSON 体的部分传递？最佳实践规定，信息应该按照以下方式访问：
- en: '**path parameters**: Information to describe *what* the resource is we are
    looking for'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径参数**：描述我们正在寻找的资源的信息'
- en: '**query parameters**: Information that can be used to filter, search, or sort
    the response'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询参数**：可用于过滤、搜索或排序响应的信息'
- en: '**request body**: Everything else'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求体**：所有其他内容'
- en: It is a good habit to get into very early on in your application development
    to learn where different usable bits of information can come from. Chapter 4 dives
    much further into passing data through query patameters and the request body.
    Just as valuable is of course the HTTP path itself. We just looked at how important
    crafting purposeful paths might be. Next, we will take a deeper look at extracting
    data from the HTTP path.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发初期就养成一个良好的习惯，了解不同可用的信息来源。第四章深入探讨了通过查询参数和请求体传递数据。当然，HTTP 路径本身也非常有价值。我们刚刚看到了精心设计路径可能有多么重要。接下来，我们将更深入地探讨从
    HTTP 路径中提取数据。
- en: Advanced path parameters
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级路径参数
- en: In the last section, we learned the basics of extracting information from a
    dynamic URL path to something we can code with. This is truly a fundamental feature
    of all web frameworks. It is also extremely common among many frameworks to allow
    you to specify what that path parameter should be. We learned that `/messages/<message_id:int>`
    would match `/messages/123` but not `/messages/abc`. We also learned about the
    convenience that Sanic provides in converting the match path segment to an integer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们学习了从动态 URL 路径中提取信息的基本知识，这些信息可以用于编码。这确实是所有 Web 框架的基本功能。许多框架也允许您指定路径参数应该是什么。我们了解到
    `/messages/<message_id:int>` 会匹配 `/messages/123` 但不会匹配 `/messages/abc`。我们还了解了
    Sanic 在将匹配路径段转换为整数方面提供的便利。
- en: But, what about more complex types? Or what if we need to modify the matched
    value before using it in our application? In this section, we will explore a couple
    helpful patterns to achieve these goals.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于更复杂的类型怎么办？或者如果我们需要在将匹配的值用于我们的应用程序之前修改它怎么办？在本节中，我们将探讨一些有助于实现这些目标的实用模式。
- en: Custom parameter matching
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义参数匹配
- en: 'Out of the box, Sanic provides eight path parameter types that can be matched:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Sanic 提供了八种可匹配的路径参数类型：
- en: '`str`: matches any valid string'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`：匹配任何有效的字符串'
- en: '`slug`: matches standard path slugs'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slug`：匹配标准路径别名'
- en: '`int`: matches any integer'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：匹配任何整数'
- en: '`float`: matches any number'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：匹配任何数字'
- en: '`alpha`: matches only alphabetic characters'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`：仅匹配字母字符'
- en: '`path`: matches any expandable path'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：匹配任何可展开的路径'
- en: '`ymd`: matches `YYYY-MM-DD`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ymd`：匹配 `YYYY-MM-DD`'
- en: '`uuid`: matches a `UUID`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid`：匹配一个 `UUID`'
- en: 'Each of these provides a type that corresponds to the matched parameter. For
    example, if you have this path: `/report/<report_date:ymd>`, the `date` object
    in your handler will be a `datetime.date` instance:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的每一个都提供了一个与匹配参数相对应的类型。例如，如果你有这个路径：`/report/<report_date:ymd>`，你的处理程序中的 `date`
    对象将是一个 `datetime.date` 实例：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a very helpful pattern because it accomplishes two things for us. First,
    it makes sure that the incoming request is in the correct format. A request that
    is `/report/20210101` would receive a `404 Not Found` response. Second, when we
    go to work with that `report_date` instance in our handler, it has already been
    cast into a usable data type: `date`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的模式，因为它为我们完成了两件事。首先，它确保传入的请求是正确的格式。一个请求为 `/report/20210101` 将收到一个 `404
    Not Found` 响应。其次，当我们开始在处理程序中处理那个 `report_date` 实例时，它已经被转换成了一个可用的数据类型：`date`。
- en: 'What happens when we need routing for types outside of the standard types?
    Sanic does of course allow us to achieve the first part by defining a custom regular
    expression for a path segment. Let’s imagine that we have an endpoint that we
    want to match on a valid IPv4 address: `/ip/1.2.3.4`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要对标准类型之外的类型进行路由时会发生什么？Sanic 当然允许我们通过定义一个路径段的自定义正则表达式来实现第一部分。让我们想象一下，我们有一个想要匹配有效
    IPv4 地址的端点：`/ip/1.2.3.4`。
- en: 'The simplest approach here would be to find a relevant regular expression and
    add it to our path segment definition:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最简单的方法是找到一个相关的正则表达式并将其添加到我们的路径段定义中：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, when we access our endpoint we should have a valid match:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们访问我们的端点时，我们应该有一个有效的匹配：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using regular expression matching also allows us to narrowly define an endpoint
    between a limited number of options:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式匹配还允许我们在有限数量的选项之间定义一个狭窄的端点：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We now have routing based upon our two available choices:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了基于我们两个可用选择的路由：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: While regular expression matching is incredibly helpful sometimes, the problem
    is that the output is still a `str`. Going back to our first IPv4 example, we
    would need to manually cast the matched value into a `ipaddress.IPv4Address` if
    we wanted an instance of that class to work with.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正则表达式匹配在某些时候非常有帮助，但问题在于输出仍然是一个 `str`。回到我们最初的 IPv4 示例，如果我们想要一个 `ipaddress.IPv4Address`
    类的实例来工作，我们需要手动将匹配的值转换为 `ipaddress.IPv4Address`。
- en: 'While this might not seem like a big deal if you have one or two handlers,
    if you have a dozen endpoints that needed a dynamic IP address as a path parameter,
    it could become cumbersome. Sanic’s solution to this is custom pattern matching.
    We can tell Sanic that we want to create our own parameter type. To do this we
    need three things:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你只有一个或两个处理程序，这可能看起来不是什么大问题，但如果你有十几个端点需要动态 IP 地址作为路径参数，这可能会变得繁琐。Sanic 的解决方案是自定义模式匹配。我们可以告诉
    Sanic 我们想要创建自己的参数类型。为此，我们需要三样东西：
- en: A short descriptor that we will use to name our type
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简短的描述符，我们将用它来命名我们的类型
- en: A function that will return the value we want or raise `ValueError` if there
    is no match
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，它将返回我们想要的值或在没有匹配时引发 `ValueError`
- en: A fallback regular expression that also matches our value
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个回退正则表达式，它也会匹配我们的值
- en: 'In the IP address example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IP 地址示例中：
- en: We will name the parameter `ipv4`
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将参数命名为 `ipv4`
- en: We can use the standard library’s `ipaddress.ip_address` constructor
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用标准库的 `ipaddress.ip_address` 构造函数
- en: 'We already have our fallback regular expression from earlier. We can proceed
    to registering the custom parameter type:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经从之前有了回退正则表达式。我们可以继续注册自定义参数类型：
- en: '[PRE37]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we have a more usable object in the handler (`ipaddress.IPv4Address`),
    and we also have a very easy to reuse path parameter (`<ip:ipv4>`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在处理程序中有一个更可用的对象（`ipaddress.IPv4Address`），并且我们还有一个非常容易重用的路径参数（`<ip:ipv4>`）。
- en: 'What about our second example with ice cream flavors? Instead of having a `str`
    type, what if we wanted to have an `Enum` or some other custom model? There is
    unfortunately no function in Python’s standard library for parsing ice cream flavors
    (maybe someone should build that), so we will need to create our own:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于我们的第二个例子，冰淇淋口味呢？如果我们想要一个`Enum`或其他自定义模型，而不是`str`类型，那会怎么样？不幸的是，Python标准库中没有用于解析冰淇淋口味的函数（也许有人应该构建一个），因此我们需要创建自己的：
- en: 'To start, we will create our model using an `Enum`. Why an Enum? It is a fantastic
    tool to keep our code nice and consistent. If our environment is setup right—which
    it is because we took care in *Chapter 2* to use good tools—we have a single place
    where we can maintain our flavors with code completion:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用`Enum`创建我们的模型。为什么是`Enum`？这是一个保持我们的代码整洁和一致性的绝佳工具。如果我们设置的环境正确——因为我们已经在*第二章*中注意到了使用好工具——我们有一个单一的地方可以维护我们的口味，并使用代码补全：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we need a regular expression that we can later use in our route definition
    for matching incoming requests:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个正则表达式，我们可以在稍后的路由定义中使用它来匹配传入的请求：
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The resulting pattern should be: `vanilla|chocolate`.'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果模式应该是：`vanilla|chocolate`。
- en: 'We also need to create a function that will act as our parser. Its job is to
    either return our target type or raise `ValueError`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个函数，它将充当我们的解析器。其任务是返回我们的目标类型或引发`ValueError`：
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can now proceed to register that pattern with Sanic. Just like the IP address
    example before, we have the name of our parameter type, a function to check the
    match, and a fallback regular expression.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以继续将这个模式注册到Sanic中。就像之前的IP地址示例一样，我们有我们的参数类型名称，一个用于检查匹配的函数，以及一个回退正则表达式。
- en: '[PRE41]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With our pattern now registered, we can proceed to use it in all of our ice
    cream endpoints:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经注册了我们的模式，我们可以继续在所有的冰淇淋端点中使用它：
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we access the endpoint now, we should have an `Enum` instance, but still
    only accept requests that match one of our two defined flavors. Yum!
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们现在访问端点时，我们应该有一个`Enum`实例，但仍然只接受匹配我们定义的两个口味之一的请求。美味！
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The key to this example is having a good parse function. In our example, we
    know that if a bad flavor is entered into the `Enum` constructor it will raise
    `KeyError`. This is a problem. If our application cannot match `mint`, it will
    throw a `KeyError` and the application will respond with a `500 Internal Server
    Error`. This is not what we want. By catching the exception and casting it to
    `ValueError`, Sanic is able to understand that this is expected, and it should
    respond with a `404 Not Found`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的关键是有一个好的解析函数。在我们的例子中，我们知道如果将不良口味输入到`Enum`构造函数中，它将引发`KeyError`。这是一个问题。如果我们的应用程序无法匹配`mint`，它将抛出`KeyError`，并且应用程序将响应`500
    内部服务器错误`。这不是我们想要的。通过捕获异常并将其转换为`ValueError`，Sanic能够理解这是预期的，并且它应该响应`404 未找到`。
- en: Modifying matched parameter values
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改匹配的参数值
- en: As we have learned, using path parameter types is extremely helpful in building
    our API to respond to intended requests and ignoring bad paths. As much as possible,
    it is best practice to be as specific as your endpoint needs to get the right
    data in. We just explored how we might also use parameter types to recast the
    matched value to a more useful data type. But what if we are not concerned about
    changing the `type` of the value, but the actual value itself?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，使用路径参数类型在构建我们的API以响应预期请求和忽略不良路径方面非常有帮助。尽可能具体，这是最佳实践，以便我们的端点能够获取正确的数据。我们刚刚探讨了如何使用参数类型将匹配的值重铸为更有用的数据类型。但是，如果我们不关心改变值的`type`，而是实际值本身呢？
- en: 'Returning to our character profile application example, imagine that we have
    some URLs that include **slugs**. If you are not familiar with a slug, it is basically
    a string that uses lower cases letters and hyphens to make human friendly content
    in URL paths. We saw an example of this earlier: `/users/adam-hopkins`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的角色配置文件应用示例，假设我们有一些包含**短横线**的URL。如果你不熟悉短横线，它基本上是一个使用小写字母和短横线来在URL路径中创建人类友好内容的字符串。我们之前已经看到了一个例子：`/users/adam-hopkins`。
- en: In our hypothetical application, we need to build an endpoint that returns details
    about a character instance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的假设应用中，我们需要构建一个端点，该端点返回关于角色实例的详细信息。
- en: First, we will create a model for what the character object will look like.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个模型来描述字符对象的外观。
- en: '[PRE44]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We want to be able to return specific details about out character. For example,
    the endpoint `/characters/george/name` should return `George`. So, our next task
    is to define our route:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能够返回关于我们角色的具体细节。例如，端点 `/characters/george/name` 应该返回 `George`。因此，我们的下一个任务是定义我们的路由：
- en: '[PRE45]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is a fairly simple route. It searches for the character, and then returns
    the requested attribute. Let’s check it out in action:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个相当简单的路由。它搜索角色，然后返回请求的属性。让我们看看它在实际操作中的表现：
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, let’s try getting George’s super powers.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取乔治的超级能力。
- en: '![](img/file0.png)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/file0.png)'
- en: Uh oh, what happened? The property we are trying to access is `Character.super_powers`.
    But, our endpoint accepts slugs (because they are easier for people to read).
    So we need to convert the attribute. Just like in the previous section where we
    *could* cast our value inside of the handler, it becomes more difficult to scale
    that solution. We *could* run `attr.replace("-", "_")` inside of our handler,
    and perhaps this is a viable solution. It does make for extra code inside the
    handlers.Luckily, we also have another alternative. This is a good use case for
    middleware where we need to convert all slugs (eg. `this-is-a-slug`) to snake
    case (eg. `this_is_snake_case`) so that they can be used programatically down
    the road. By converting the slugs, we can look for `super_powers` instead of `super-powers`.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哎呀，发生了什么事？我们试图访问的属性是 `Character.super_powers`。但是，我们的端点接受缩写（因为它们对人们来说更容易阅读）。因此，我们需要转换属性。就像在前一节中，我们可以在处理程序内部**可以**转换我们的值一样，这会使解决方案的扩展变得更加困难。我们**可以**在我们的处理程序内部运行
    `attr.replace("-", "_")`，也许这是一个可行的解决方案。它确实在处理程序中增加了额外的代码。幸运的是，我们还有另一个选择。这是一个很好的中间件用例，我们需要将所有缩写（例如
    `this-is-a-slug`）转换为蛇形小写（例如 `this_is_snake_case`），以便将来可以编程使用。通过转换缩写，我们可以查找 `super_powers`
    而不是 `super-powers`。
- en: 'Let’s make that middleware:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建这个中间件：
- en: '[PRE47]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What this will do is modify the `Request` instance before it gets executed by
    the route handler. For our use case, this means that every value that is matched
    will be converted from a slug to snake case. Note that we are *not* returning
    anything in this function. If we do, Sanic will think that we are trying to halt
    the request/response cycle by providing an early return. This is not the intention.
    All we want to do is modify the `Request`.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将修改在路由处理程序执行之前 `Request` 实例。对我们这个用例来说，这意味着所有匹配的值都将从缩写形式转换为蛇形小写。请注意，我们在这个函数中**没有**返回任何内容。如果我们这样做，Sanic
    会认为我们正在尝试通过提前返回来终止请求/响应周期。这不是我们的意图。我们只想修改 `Request`。
- en: 'Let’s test that endpoint again:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次测试这个端点：
- en: '[PRE48]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Middleware is not the only solution to this problem though. Sanic makes use
    of signals to dispatch events that your application can listen to. Instead of
    the above middleware, we could do something similar like this with signals:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然中间件不是解决这个问题的唯一方法。Sanic 使用信号来分发应用程序可以监听的事件。而不是上面的中间件，我们可以使用信号做类似的事情，如下所示：
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, it is a very similar implementation. Perhaps the biggest difference
    to us as developers is that the signal provides us with some more arguments to
    work with. Although, to be honest, the `route` , the `handler`, and the `kwargs`
    are all properties that could be accessed from the `Request` instance. Middleware
    and signals are discussed in greater depth in Chapter 6\. For now, just know that
    these are two methods for altering the request/response cycle outside of the route
    handler. Later on we will learn more about the differences between them and when
    it might be preferable to choose one or the other.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常相似的实现。也许对我们作为开发者来说最大的区别是，信号为我们提供了更多的工作参数。尽管如此，坦白说，`route`、`handler`
    和 `kwargs` 都是可以在 `Request` 实例中访问的属性。中间件和信号在第六章中进行了更深入的讨论。现在，只需知道这些是在路由处理程序之外改变请求/响应周期的两种方法。稍后我们将了解更多关于它们之间的区别以及何时可能更倾向于选择其中一种。
- en: API versioning
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 版本控制
- en: Back in *Chapter 2,* *Organizing a project* we discussed how you could implement
    API versioning using Blueprints. If you recall, it was simply a matter of adding
    a keyword value to the Blueprint definition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第二章* *组织项目* 中，我们讨论了如何使用 Blueprints 实现API版本控制。如果您还记得，这只是一个在 Blueprint 定义中添加关键字值的问题。
- en: 'Given the below Blueprint definition, we get the URL path: `/v1/characters`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 给定下面的 Blueprint 定义，我们得到 URL 路径：`/v1/characters`：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That `version` keyword argument is available at the route level as well. If
    the version is defined in multiple places (for example, on the route and also
    the Blueprint), priority is given to the narrowest scope. Let’s look at an example
    of different places where the version can be defined, and see what the result
    is. We will define it at the route level, the Blueprint level, and the Blueprint
    group level:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`version`关键字参数在路由级别也是可用的。如果版本在多个地方定义（例如，在路由和蓝图上），则优先考虑范围最窄的。让我们看看版本可以在哪些不同的地方定义的例子，并看看结果是什么。我们将在路由级别、蓝图级别和蓝图组级别定义它：'
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We now have the following routes. Take a closer look at the example to see
    how we manipulate the Blueprints and the `version` argument to control the handler
    that each path is delivered to:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有以下路由。仔细看看例子，看看我们是如何操纵蓝图和`version`参数来控制每个路径交付的处理程序的：
- en: '`/v1/characters <Route: name=main.Characters.version_1 path=v1/characters>`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v1/characters <Route: name=main.Characters.version_1 path=v1/characters>`'
- en: '`/v3/characters <Route: name=main.Characters.version_3 path=v3/characters>`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v3/characters <Route: name=main.Characters.version_3 path=v3/characters>`'
- en: '`/v2/characters <Route: name=main.CharactersV2.version_2 path=v2/characters>`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v2/characters <Route: name=main.CharactersV2.version_2 path=v2/characters>`'
- en: Adding versions to endpoint paths is fairly simple. But why should we do it?
    It is a good practice because it keeps your API flexible, but also consistent
    and stable for your users. By allowing endpoints to be versioned, you maintain
    the ability to make changes to them and still allow for legacy requests to not
    be denied. It is incredibly beneficial as over time as you transition your API
    to add, remove, or enhance features.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 向端点路径添加版本相当简单。但为什么我们要这样做呢？这是一个好的做法，因为它使你的API对用户来说既灵活又一致稳定。通过允许端点进行版本控制，你保持了对其做出更改的能力，同时仍然允许旧请求不被拒绝。随着时间的推移，当你过渡你的API以添加、删除或增强功能时，这会带来极大的好处。
- en: Even if the only consumer of your API is your own website, it is still a good
    practice to version your APIs so that you have an easier path towards upgrades
    without potentially causing application regressions.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的API的唯一消费者是你的自己的网站，仍然是一个好的做法来对API进行版本控制，这样你就有了一条更容易的升级路径，而不会导致应用程序退化。
- en: It is a common practice to “lock-in” features with a version. This is a form
    of creating what is known as an API contract. Think of an API contract as a promise
    by the developer that the API will continue to work. In other words, once you
    put an API into usage—and especially if you publish documentation—you are creating
    a promise to the user that the API will continue to function as is. You are free
    to add new features, but any breaking changes that are not backwards compatible
    violate that contract. Therefore, when you do need to add breaking changes, versions
    might be the right trick in your tool bag to accomplish your goal.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本“锁定”功能是一种常见的做法。这是一种创建所谓的API合约的形式。将API合约视为开发者对API将继续工作的承诺。换句话说，一旦你将API投入使用——尤其是如果你发布了文档——你就向用户承诺API将继续按原样运行。你可以自由地添加新功能，但任何不向后兼容的破坏性更改都违反了该合约。因此，当你确实需要添加破坏性更改时，版本可能是你工具箱中实现目标的好方法。
- en: 'Here is an example. We’re building out our database of character profiles.
    The first version of our API has an endpoint to create a new profile and it looks
    something like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。我们正在构建我们的角色资料数据库。我们API的第一个版本提供了一个创建新资料的端点，它看起来可能像这样：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This endpoint is built upon the assumption that the incoming JSON body will
    be fairly simple like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点是建立在假设传入的JSON体相对简单的基础上的，如下所示：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What happens when we want to handle some more complex use cases?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要处理更复杂的使用案例时会发生什么？
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It might start getting complicated, messy, and overall difficult to maintain
    our route handler if we put too much logic into it. As a general practice, I like
    to keep my route handlers very concise. If I see my code creeping up to 50 lines
    of code inside a view handler, I know there is probably some refactoring that
    needs to be done. Ideally, I like to keep them to about 20 lines or less.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将太多逻辑放入其中，我们的路由处理程序可能会变得复杂、混乱，总体上难以维护。作为一个一般做法，我喜欢保持我的路由处理程序非常简洁。如果我看到我的代码在视图处理程序内部接近50行代码，我知道可能需要进行一些重构。理想情况下，我喜欢将它们保持在20行或更少。
- en: One way we can keep our code clean is to split these use cases. Version 1 of
    the API will still be able to create characters using the simpler data structure,
    and version 2 has the capability of the more complex structure.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保持代码整洁的一种方法是将这些用例分开。API的版本1仍然可以使用更简单的数据结构创建角色，而版本2具有更复杂结构的处理能力。
- en: Should all of my routes bump versions?
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我是否应该让所有路由都提升版本？
- en: You may be curious to know why you would want to
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么你想要
- en: 'Often, you will have a need to increase a version on a single endpoint, but
    not all of them. This raises the question: what version do I use on the unchanged
    endpoints? Ultimately, this is going to be a question that can only be dictated
    by the application. It might be helpful to keep in mind how the API is being used.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你可能需要在单个端点增加版本，但不是所有端点都需要。这引发了一个问题：在未更改的端点上我应该使用哪个版本？最终，这将成为只能由应用程序决定的唯一问题。记住API的使用方式可能会有所帮助。
- en: Very often you will see APIs bumping versions when there is a complete break
    or some major overhaul in the API structure. This could accompany a new technology
    stack, or a new API structure or design pattern. An example of this is when GitHub
    changed their API from v3 to v4\. The older version of their API (v3) is RESTful,
    similar to what we discussed earlier in this chapter. The newer version (v4) is
    based upon GraphQL (see Chapter 10 for more on GraphQL). This is a complete redesign
    of the API. Because v3 and v4 are completely incompatible, they changed the version
    number.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的是，当API结构有完全的断裂或某些重大的重构时，API会提升版本。这可能会伴随着新的技术栈、新的API结构或设计模式。一个例子是GitHub将他们的API从v3更改为v4。他们API的旧版本（v3）是RESTful的，类似于我们在本章前面讨论的。新版本（v4）基于GraphQL（关于GraphQL的更多信息请见第10章）。这是API的完全重新设计。因为v3和v4完全不兼容，所以他们改变了版本号。
- en: In GitHub’s case, it was clear all endpoints needed to change as it was effectively
    a brand new API. Drastic changes like this are not the only catalyst for version
    changing, however. What if we are only changing compatibility on a smaller portion
    of our API and keeping the rest intact?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub的情况下，所有端点都需要更改，因为它实际上是一个全新的API。然而，这种剧烈的变化并不是版本更改的唯一催化剂。如果我们只更改API的一小部分兼容性，而保持其余部分不变呢？
- en: 'Some people may find that it makes sense to implement the new version number
    on all of their endpoints. One way to accomplish this is to add multiple route
    definitions to an endpoint:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会觉得在所有端点上实施新版本号是有意义的。实现这一目标的一种方法是在端点上添加多个路由定义：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The downside of this approach is that could become very cumbersome to maintain.
    If you needed to add a new route definition to *every* handler when you want to
    change a version, you might be discouraged from adding versions in the first place.
    Take this into consideration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是可能会变得非常繁琐，难以维护。如果你需要在更改版本时向每个处理器添加新的路由定义，你可能会从一开始就放弃添加版本。请考虑这一点。
- en: How about nesting blueprints? How about a function that dynamically adds routes
    at startup? Can you think of a solution? We have already seen various tools and
    strategies earlier in this book that might help us out. This might be a good time
    to put the book down and jump into your code editor on your computer. I encourage
    you to play around with versions and nesting to see what is and is not possible.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套蓝图怎么样？有没有一个在启动时动态添加路由的功能？你能想到解决方案吗？在这本书的前面我们已经看到了各种工具和策略，可能会对我们有所帮助。现在放下这本书，打开你的电脑上的代码编辑器，尝试一下。我鼓励你尝试版本和嵌套，看看哪些是可能的，哪些是不可能的。
- en: 'Remember `app.router.routes` and `app.router.groups`? Try adding a single handler
    to multiple Blueprints. Or try adding the same Blueprints to different groups.
    I challenge you to come up with a pattern to have the same handler be on different
    versions without multiple definitions like the above example. Start with this,
    and see what you can come up with, without doubling up the route definition as
    above:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`app.router.routes`和`app.router.groups`吗？尝试将单个处理器添加到多个Blueprints中。或者尝试将相同的Blueprints添加到不同的组中。我挑战你找出一个模式，让相同的处理器在不同的版本上运行，而无需像上面示例中那样进行多次定义。从这一点开始，看看你能想出什么，不要像上面那样重复路由定义：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is a handy snippet you can use while developing to see which paths are
    defined:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个实用的代码片段，你可以在开发过程中使用，以查看哪些路径被定义：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Getting back to our question: should all of my routes bump versions? Some people
    will say yes, but it seems artificially complex to bump the version of all routes
    when only one has changed. By all means, if it makes sense, bump everything simultaneously.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的问题：我的所有路由都应该更新版本吗？有些人会说是的，但当只有一条路由发生变化时，更新所有路由的版本似乎人为地复杂。无论如何，如果这样做有意义，可以同时更新所有内容。
- en: 'If we only want to bump the routes that are changing, it causes another problem.
    What should we bump it to? Many people will tell you that versions should *only*
    ever be integers: `v1`, `v2`, `v99`, etc. I find this limiting, and it really
    makes the following set of endpoints feel unnatural:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想更新正在变化的路由，这又会带来另一个问题。我们应该更新到哪个版本呢？很多人会告诉你版本应该**只**是整数：`v1`、`v2`、`v99`等。我觉得这很受限制，而且它确实让以下一组端点感觉很不自然：
- en: '`/v1/characters`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v1/characters`'
- en: '`/v1/characters/puppets`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v1/characters/puppets`'
- en: '`/v1/characters/super_heroes`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v1/characters/super_heroes`'
- en: '`/v1/characters/historical`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v1/characters/historical`'
- en: '`/v2/characters`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/v2/characters`'
- en: 'While I am not discounting this approach, it does seem like there *should*
    be a `v2` for all of the routes, even if they did not change. We are trying to
    avoid that. Why not use minor versions like semantic versioning? It seems more
    natural and accepting to have a single `/v1.1` endpoint than a single `/v2`. Again,
    this is going to be a matter of what works for your application needs, and what
    is reasonable given the types of users that will be consuming your API. Should
    you decided that semantic versioning style will work for your application needs,
    you can add it by using a float for the version argument as seen here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不否认这种方法，但它似乎**应该**为所有路由都有一个 `v2`，即使它们没有变化。我们正在努力避免这种情况。为什么不使用像语义版本控制那样的次版本号呢？拥有单个
    `/v1.1` 端点似乎比单个 `/v2` 更自然和易于接受。再次强调，这将是根据您的应用程序需求以及将消费您的API的用户类型来决定的问题。如果您决定语义版本控制风格适合您的应用程序需求，您可以通过使用浮点数作为版本参数来添加它，如下所示：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**IMPORTANT NOTE**'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Semantic versioning is an important concept in software development, but beyond
    the scope here. In brief, the concept is to create a version by declaring a major,
    minor and patch numer that are connected by a period. Example: 1.2.3\. Generally
    speaking, semantic versioning states that an increment of the major version corresponds
    to a backwards-incompatible change, the minor version to a new feature, and the
    patch version to a bug fix. If you are unfamiliar with it, I suggest taking some
    time to read through the documentation for it since it is widely used throughout
    software development: [https://semver.org/](https://semver.org/)'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 语义版本控制是软件开发中的一个重要概念，但超出了这里的范围。简而言之，这个概念是通过声明由点连接的主版本号、次版本号和修订号来创建一个版本。例如：1.2.3。一般来说，语义版本控制表明主版本号的增加对应于向后不兼容的更改，次版本号对应于新功能，修订号对应于错误修复。如果您不熟悉它，我建议花些时间阅读相关的文档，因为它在软件开发中得到广泛应用：[https://semver.org/](https://semver.org/)
- en: '**TIP**'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is highly recommended that you use version with your endpoints if you intend
    for there to be third-party integration with your API. If the API is only meant
    to be used by your own application, perhaps this is less important. Nevertheless,
    it may still be a useful pattern. Therefore, I recommend using `version=1` for
    new projects or `version=2` for projects that are replacing an existing API even
    if the legacy application did not have a version scheme.
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您打算让第三方集成您的API，强烈建议您在端点中使用版本。如果API只打算由您的应用程序使用，这可能就不那么重要了。尽管如此，它可能仍然是一个有用的模式。因此，我建议对于新项目使用
    `version=1`，对于替换现有API的项目使用 `version=2`，即使遗留应用程序没有版本方案。
- en: Version prefixing
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本前缀
- en: 'The standard way to use versions in Sanic is `version=<int>` or `version=<float>`.
    The version will *ALWAYS* be inserted into your path at the very beginning. It
    does not matter how deeply nested and how many layers of `url_prefix` you may
    have. Even a deeply nested route definition can have a single version and it will
    be the first segment in the path: `/v1/some/deeply/nested/path/to/handler`.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sanic 中使用版本的标准方式是 `version=<int>` 或 `version=<float>`。版本将**始终**插入到您的路径的最开始。无论您嵌套多深以及有多少层
    `url_prefix`，都无关紧要。即使是深度嵌套的路由定义也可以只有一个版本，并且它将是路径中的第一个部分：`/v1/some/deeply/nested/path/to/handler`。
- en: 'This does, however, impose a problem when you are trying to build multiple
    layers on your application. What if you want to have some HTML pages and an API
    and keep them separate based upon their path? Consider the following paths that
    we might like to have in our application:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你试图在你的应用程序上构建多层时，这确实会带来一个问题。如果你想有一些HTML页面和一个API，并基于它们的路径将它们分开，你会怎么做？考虑以下我们可能希望在应用程序中拥有的路径：
- en: '`/page/profile.html`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/page/profile.html`'
- en: '`/api/v1/characters/<name>`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/v1/characters/<name>`'
- en: 'Notice how the versioned API route starts with `/api`? This is impossible to
    control only with URIs and Blueprint URI prefixes since Sanic *always* puts the
    version before the rest of the path. However, Sanic provides a `version_prefix`
    argument in all of the same places that `version` can be used. The default value
    is `/v`, but feel free to update it as needed. In the following example, we can
    nest our entire API design in a single blueprint group to automatically add `/api`
    to the front of every endpoint:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，版本化的API路由是以`/api`开头的吗？由于Sanic*总是*将版本放在路径的其他部分之前，因此仅使用URI和Blueprint URI前缀是无法控制的。然而，Sanic在所有可以使用`version`的地方提供了一个`version_prefix`参数。默认值是`/v`，但请随意根据需要更新它。在下面的例子中，我们可以将整个API设计嵌套在一个蓝图组中，以自动将`/api`添加到每个端点的前面：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**TIP**'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The same path parameters are available here. You could, for example, do something
    like this: `version_prefix=/<section>/v`. Just make sure you remember that `section`
    will now be an injected keyword argument into every route handler.'
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里也有相同的路径参数。例如，你可以这样做：`version_prefix=/<section>/v`。只是确保你记住，`section`现在将作为每个路由处理器的注入关键字参数。
- en: 'You should now have a good grasp of how and when to use versions. They are
    a powerful tool in making your API more professional and maintainable since they
    allow for more flexible development patterns. Next, we will explore another tool
    for creating flexibility and reusability of your application code: virtual hosts.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经很好地掌握了如何以及何时使用版本。它们是使你的API更加专业和可维护的强大工具，因为它们允许更灵活的开发模式。接下来，我们将探讨另一个创建应用程序代码灵活性和可重用性的工具：虚拟主机。
- en: Virtual hosts
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟主机
- en: Some applications can be accessed from multiple domains. This gives the benefit
    of having a single application deployment to manage, but the ability to service
    multiple domains. In our example, we will imagine that we completed the computer
    adventure game social media site. The API is truly something amazing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序可以从多个域名访问。这带来了只有一个应用程序部署来管理的优势，但能够服务多个域名。在我们的例子中，我们将想象我们已经完成了计算机冒险游戏社交媒体网站。API确实是件了不起的事情。
- en: It is so incredible in fact that both Alice and Bob have approached us about
    the opportunity to be resellers and to *white label* our application, or reuse
    the API for their own social media sites. This is a somewhat common practice in
    the Internet world where once provider builds an application, and other providers
    simply point their domain to the same application and operate as if it is their
    own. To achieve this, we need to have distinct URLs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这太令人难以置信了，Alice和Bob都向我们提出了成为分销商和*白标*我们的应用程序，或为他们的社交媒体网站重用API的机会。在互联网世界中，这是一种相当常见的做法，一旦提供商构建了一个应用程序，其他提供商只需将他们的域名指向同一个应用程序，并像拥有自己的那样运营。为了实现这一点，我们需要有独特的URL。
- en: '`mine.com`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mine.com`'
- en: '`alice.com`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alice.com`'
- en: '`bob.com`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bob.com`'
- en: 'All of these domains will be setup with their DNS records pointing to our application.
    This can work without any further changes inside the application. But what if
    we need to know which domain a request is serving, and do something slightly different
    for each one? This information should be available to us in the request headers.
    It should simply be a matter of checking the headers:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些域名都将设置其DNS记录指向我们的应用程序。这可以在应用程序内部不进行任何进一步更改的情况下工作。但如果我们需要知道哪个域名正在处理请求，并且为每个域名执行一些不同的操作呢？这些信息应该在我们的请求头中可用。这应该仅仅是一个检查头的问题：
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This example may seem small and simple, but you can probably imagine how the
    complexity could increase. Remember earlier I stated how I like to keep the lines
    of code per handler to a minimum? This is certainly a use case where you can imagine
    the handlers could get very lengthy.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能看起来很小很简单，但你可能可以想象复杂性如何增加。记住我之前提到我喜欢将每个处理器的代码行数保持到最小？这确实是一个你可以想象处理器可能会变得非常长的用例。
- en: Essentially, what we are doing in this endpoint is host-based routing. Depending
    upon the incoming request host, we are routing the endpoint to a different location.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们在这个端点所做的是基于主机的路由。根据传入请求的主机，我们将端点路由到不同的位置。
- en: Sanic already does that for us. All we need to do is break the logic into separate
    route handlers and give each one a `host` argument. This achieves the routing
    that we need, but keeps it out of our response handlers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 已经为我们做了这件事。我们只需要将逻辑拆分成单独的路由处理器，并为每个处理器提供一个 `host` 参数。这样就能实现我们需要的路由，同时将其从我们的响应处理器中分离出来。
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you find yourself in this situation, you do not need to define a `host` for
    every endpoint. Only the endpoints where you would want to have host-based routing.
    Following this pattern, we can reuse the same application across multiple domains,
    and still have some endpoints capable of distinguishing between them, and others
    ignorant to the fact that multiple domains are reaching it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于这种情况，你不需要为每个端点定义 `host`。只需要为那些你希望有基于主机路由的端点定义。遵循这个模式，我们可以在多个域名之间重用同一个应用程序，并且仍然有一些端点能够区分它们，而其他端点则对多个域名正在访问它的事实一无所知。
- en: 'One thing that is important to keep in mind: if you create an endpoint that
    has host level routing, then all routes on that same path must also have it. You
    cannot, for example, do the following. Notice how the third route does *not* define
    the `host` argument.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要记住：如果你创建了一个具有主机级别路由的端点，那么该路径上的所有路由也必须具有它。例如，你不能这样做。注意第三个路由没有定义 `host`
    参数。
- en: 'The following example will *not* work, and will raise an exception at startup:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将不会工作，并在启动时引发异常：
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To solve this, make sure that all routes that could be grouped together have
    a `host` value. This way they can be distinguished. If one of them has a `host`,
    they all need to have one.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，确保所有可以组合在一起的路由都有一个 `host` 值。这样它们就可以被区分开来。如果其中之一有 `host`，那么它们都需要有。
- en: We have generally now discussed all of the considerations to make when routing
    web requests to our response handlers. But, we have not yet looked at how Sanic
    delivers requests to static content (that is, actual files on your webserver that
    you want to send like images and stylesheets). Next, we will discuss some options
    both with and without using Sanic.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经一般性地讨论了在将网络请求路由到我们的响应处理器时需要考虑的所有因素。但是，我们还没有探讨 Sanic 如何将请求传递到静态内容（即你希望在 web
    服务器上发送的实际文件，如图片和样式表）。接下来，我们将讨论一些使用和不使用 Sanic 的选项。
- en: Serving static content
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器静态内容
- en: So far all of our discussion in this chapter has been about dynamically generating
    content for responses. We did, however, discuss that passing files that exist
    inside of a directory structure is a valid use case that Sanic supports. This
    is because most web applications have a need for serving some static content.
    The most common use cases would be for delivering Javascript files, images, and
    style sheets to be rendered by the browser. Now, we are going to dive into static
    content to see how that works, and we can deliver this type of content. After
    learning how Sanic does it, we will see another very common pattern to serve the
    content outside of Sanic with a proxy.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们本章的所有讨论都是关于为响应动态生成内容。然而，我们确实讨论了在目录结构中传递文件是一个有效的用例，Sanic 支持这种情况。这是因为大多数网络应用程序都需要为一些静态内容提供服务。最常见的情况是为浏览器渲染的
    JavaScript 文件、图片和样式表。现在，我们将深入了解静态内容，看看它是如何工作的，并且我们可以提供这种类型的内容。在了解 Sanic 是如何做到这一点之后，我们将看到另一种非常常见的模式，即使用代理在
    Sanic 之外提供内容。
- en: Serving static content from Sanic
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Sanic 服务器静态内容
- en: 'Our `app` instance has a method on it called `app.static()`. That method requires
    two arguments:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `app` 实例上有一个名为 `app.static()` 的方法。该方法需要两个参数：
- en: A URI path for our application
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用程序的 URI 路径
- en: A path to tell Sanic where it can access that resource
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个路径告诉 Sanic 它可以从哪里访问该资源
- en: That second argument can either be a single file, or a directory. If it is a
    directory, everything inside of it will be accessible like the old school web
    servers we talked about at the beginning of the chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数可以是单个文件，也可以是目录。如果是目录，目录中的所有内容都将像我们在本章开头讨论的老式网络服务器一样可访问。
- en: This is very helpful if you plan to serve all of your web assets. What if you
    have a folder structure like this?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划为所有网络资源提供服务，这将非常有帮助。如果你的文件夹结构如下所示？
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can use Sanic to serve all of those assets and make them accessible like
    this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Sanic 来提供所有这些资源，并使它们像这样可访问：
- en: '`app.static("/static", "./assets")`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.static("/static", "./assets")`'
- en: 'Those assets are now accessible:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源现在可以访问：
- en: '`$ curl localhost:7777/static/css/styles.css`'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl localhost:7777/static/css/styles.css`'
- en: Serving static content with Nginx
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Nginx 提供静态内容
- en: 'Now that we have seen how to serve static files with Sanic, a good next question
    is: should you?'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用 Sanic 提供静态文件，一个很好的下一个问题是：你应该这样做吗？
- en: Sanic is very fast at creating the sort of dynamic endpoints that are required
    by most web APIs. It even does a pretty good job serving static content, keeps
    all of your endpoint logic in one application, and even allows for manipulating
    those endpoints or renaming files. As we discussed in *Chapter 1*, *Introduction
    to Sanic and async frameworks* Sanic applications are also meant to be fast to
    build.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 在创建大多数 Web API 所需的动态端点方面非常快。它甚至在提供静态内容方面做得相当不错，将所有端点逻辑保持在单个应用程序中，甚至允许操作这些端点或重命名文件。正如我们在
    *第一章*，*Sanic 和异步框架简介* 中讨论的那样，Sanic 应用程序也旨在快速构建。
- en: There is however a potentially faster method for delivering static content.
    For a single-page application that is meant to be consumed by a browser that requests
    data through your API, one of your biggest stumbling blocks will be reducing the
    time to your first page render. This means that you must package up all of your
    JS, CSS, image, or other files as quick as possible to the browser to reduce rendering
    latency.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种可能更快的方法来提供静态内容。对于一个旨在通过你的 API 请求数据的浏览器单页应用程序，你最大的障碍之一将是减少首次页面渲染的时间。这意味着你必须尽可能快地将所有
    JS、CSS、图片或其他文件打包到浏览器中，以减少渲染延迟。
- en: For this reason, you might want to consider using a proxy layer like Nginx in
    front of Sanic. The purpose of the proxy would be to (1) send any requests to
    the API through to Sanic, and (2) handle serving static content itself. You may
    want to consider this option especially if you intend to serve a lot of static
    content. Nginx has a caching engine built in to be able to deliver static content
    much faster than any Python application could.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能想要考虑在 Sanic 前使用像 Nginx 这样的代理层。代理的目的将是（1）将任何请求发送到 API 通过 Sanic，并且（2）自己处理提供静态内容。如果你打算提供大量的静态内容，你可能想要考虑这个选项。Nginx
    内置了一个缓存引擎，能够比任何 Python 应用程序更快地提供静态内容。
- en: '*Chapter 8*, *Running a server* discusses deployment strategies and considerations
    to make when deciding whether to use tools like Nginx and Docker. For now, we
    will use Docker Compose to really quickly and easily stand up Nginx.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*第八章*，*运行服务器* 讨论了在决定是否使用 Nginx 和 Docker 等工具时需要考虑的部署策略。现在，我们将使用 Docker Compose
    快速轻松地启动 Nginx。'
- en: 'We need to make our `docker-compose.yml` manifest:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建我们的 `docker-compose.yml` 清单：
- en: '[PRE64]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you are not familiar with Docker Compose or how to install and run it, you
    should be able to find a wealth of tutorials and information online.This simple
    setup we are going for in our example will require that you set the path for `./static`
    in our `docker-compose.yml` file to whatever directory you have your static assets
    in.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不太熟悉 Docker Compose 或如何安装和运行它，你应该能够在网上找到大量的教程和信息。我们示例中的简单设置将需要你在 `docker-compose.yml`
    文件中将 `./static` 的路径设置为你的静态资源所在的任何目录。
- en: '**TIP**'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is intentionally a super simple implementation. You should make sure that
    a real Nginx deployment includes things like TLS encyption and proxy secrets.
    Checkout the User Guide for more details and a helpful walkthrough. [https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration](https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration)
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个故意设计的非常简单的实现。你应该确保一个真实的 Nginx 部署包括像 TLS 加密和代理密钥这样的功能。查看用户指南以获取更多详细信息和使用说明。[https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration](https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration)
- en: Next, we will create the .`/nginx/default.conf` file needed to control Nginx.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建控制 Nginx 所需的 `.nginx/default.conf` 文件。
- en: '[PRE65]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We start it using the following command:`$ docker-compose up`The most important
    thing to change here is the server address. You should change `1.2.3.4:8000` to
    whatever address and port your application can be accessed at. Keep in mind that
    this will *NOT* be `127.0.0.1` or `localhost`. Since Nginx will be running inside
    of a Docker container, that local address would point to the container itself,
    and not your computer’s local network address. Instead, for development purposes,
    you should consider setting it to your local IP address.
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用以下命令启动它：`$ docker-compose up`这里最重要的更改是服务器地址。你应该将`1.2.3.4:8000`更改为你的应用程序可以访问的任何地址和端口。请记住，这**不会**是`127.0.0.1`或`localhost`。由于Nginx将在Docker容器内运行，该本地地址将指向容器本身，而不是你的计算机的本地网络地址。相反，出于开发目的，你应该考虑将其设置为你的本地IP地址。
- en: 'Step 3, you will need to make sure that Sanic knows to serve on that network
    address. Do you remember how we said we are running Sanic back in Chapter 2 Like
    this:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第3步，你需要确保Sanic知道要在该网络地址上提供服务。你还记得我们在第2章中是如何说我们要运行Sanic的吗？就像这样：
- en: '[PRE66]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For this example, we will change that to:'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将将其更改为：
- en: '[PRE67]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'My local IP address is `192.168.1.7`, therefore I will set the `upstream` block
    in my Nginx configuration to: `server 192.168.1.7:7777;`.'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的本地IP地址是`192.168.1.7`，因此我将我的Nginx配置中的`upstream`块设置为：`server 192.168.1.7:7777;`。
- en: Step 4, you should now be able to access any static files in your `./static`
    directory. I have a file called `foo.txt.` I am using the `-i` flag with `curl`
    to be able to see the headers. The important header to see is the `Expires` and
    `Cache-Control`. These help your browser to cache the file instead of re-requesting
    it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第4步，你现在应该能够访问`./static`目录中的任何静态文件。我有一个名为`foo.txt`的文件。我使用`curl`的`-i`标志来查看头部信息。重要的头部信息是`Expires`和`Cache-Control`。这些帮助你的浏览器缓存文件而不是重新请求它。
- en: '[PRE68]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you try to send a request to a file that does not exist, Nginx will send
    that route on to your Sanic application. This setup really just touches the tip
    of the iceberg when it comes to proxying and Nginx. It is, however, very common
    for Python web applications to use a strategy like this. As mentioned earlier,
    we will dig in deeper to this topic when we discuss deployment options in Chapter
    8.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试向一个不存在的文件发送请求，Nginx会将该路由发送到你的Sanic应用程序。当涉及到代理和Nginx时，这种设置只是冰山一角。然而，这种策略对于Python网络应用来说是非常常见的。如前所述，当我们讨论第8章中的部署选项时，我们将更深入地探讨这个话题。
- en: Streaming Static Content
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式传输静态内容
- en: It is also worth reiterating that the Sanic server is built and intended to
    be a front line server. That means that it can certainly stand as your point of
    ingress without a proxy server in front of it, including serving static content.
    The decision about whether to proxy or not—at least as it relates to delivering
    static files—is likely a question of how much traffic, and how many files your
    application may need to deliver.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得重申的是，Sanic服务器是构建并旨在作为前端服务器。这意味着它可以在没有代理服务器的情况下作为你的入口点，包括提供静态内容。是否要代理的决定——至少与交付静态文件相关——可能是一个关于流量多少以及你的应用程序可能需要交付多少文件的问题。
- en: Another important factor to consider is whether your application needs to stream
    files. Streaming will be discussed in depth in Chapter 5\. Let’s create a real
    simple web page to stream a video and see what that might look like.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的重要因素是，你的应用程序是否需要流式传输文件。流式传输将在第5章中深入讨论。让我们创建一个简单的网页来流式传输视频，看看它可能是什么样子。
- en: First the HTML. Store this as `index.html`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是HTML。将其存储为`index.html`。
- en: '[PRE69]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, find an `mp4` file that you want to stream. It can be any video file.
    If you do not have one, you can download a sample file for free from a website
    like this: [https://samplelib.com/sample-mp4.html](https://samplelib.com/sample-mp4.html).'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到一个你想要流式传输的`mp4`文件。它可以任何视频文件。如果你没有，你可以从像这样的网站免费下载一个示例文件：[https://samplelib.com/sample-mp4.html](https://samplelib.com/sample-mp4.html)。
- en: We will now create a small Sanic app to stream that video.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个小的Sanic应用程序来流式传输该视频。
- en: '[PRE70]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the server as normal and visit it in your web browser: [http://localhost:7777](http://localhost:7777)'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正常运行服务器并在你的网页浏览器中访问它：[http://localhost:7777](http://localhost:7777)
- en: You should notice that the root URI (`/`) redirected you to `/index.html`. Using
    `app.static`, the application tells Sanic that it should accept any requests to
    `/index.html` and serve back the static content that is located on the server
    at `/path/to/index.html` . This should be your delivered content from above. Hopefully
    you have a play button, and you can now stream your video to your browser. Enjoy!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到根URI（`/`）将你重定向到了`/index.html`。使用`app.static`，应用程序告诉Sanic它应该接受对`/index.html`的任何请求，并从服务器上位于`/path/to/index.html`的静态内容中返回。这应该是你上面提供的内容。希望你有播放按钮，现在你可以将视频流到你的浏览器中。享受吧！
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This Chapter covers a lot of material on taking an HTTP request and turning
    it into something usable. At the core of a web framework is its ability to translate
    the raw request into an actionable handler. We have learned about how Sanic does
    this and how we can use HTTP Methods, good API design principles paths, path parameter
    extraction, and static content to build useful applications. As we learned earlier
    in this book, a little bit of up front planning goes a long way. Before putting
    too much code together, it is really helpful to think about the tools HTTP offers,
    and how Sanic allows us to take advantage of those features.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了将HTTP请求转换为可用内容的大量内容。在Web框架的核心是其将原始请求转换为可执行处理器的功能。我们已经了解了Sanic是如何做到这一点的，以及我们如何使用HTTP方法、良好的API设计原则、路径、路径参数提取和静态内容来构建有用的应用程序。正如我们在本书前面所学，一点初步规划就能走得很远。在编写大量代码之前，考虑HTTP提供的工具以及Sanic如何让我们利用这些功能是非常有帮助的。
- en: If we did a good job in Chapter 2 of setting up directories, it should be very
    easy for us to loosely mirror that structure and nest Blueprints to match our
    intended API design.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在第二章中很好地设置了目录，那么轻松地镜像那种结构并将蓝图嵌套以匹配我们预期的API设计应该会非常容易。
- en: There are some key takeaways from this Chapter. You should purposely, and thoughtfully
    design your API endpoint paths—using nouns—that point to an intended target or
    resource. Then, HTTP Methods should be used as the verbs that tell your application
    and users *what* to do with that target or resource. Finally, you should extract
    helpful information from those paths to be used in your handlers.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有一些关键要点。你应该有目的地、深思熟虑地设计你的API端点路径——使用名词——指向预期的目标或资源。然后，应该使用HTTP方法作为动词，告诉你的应用程序和用户对那个目标或资源*做什么*。最后，你应该从那些路径中提取有用的信息，以便在处理程序中使用。
- en: 'We mainly focused our attention on that first line of the raw HTTP request:
    the HTTP Method and URI path. In the next chapter, we will dive into extracting
    more data from the request including the headers and the request body.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注原始HTTP请求的第一行：HTTP方法和URI路径。在下一章中，我们将深入探讨从请求中提取更多数据，包括头部和请求体。
