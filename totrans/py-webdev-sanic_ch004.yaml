- en: 3 Routing and Intaking HTTP Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in *Chapter 1, Introduction to Sanic and Async Frameworks,* we looked
    at a raw HTTP request to see what kind of information it includes. In this chapter,
    we are going to take a closer look at that first line that contains the HTTP Method
    and the URI path. As we learned, the most basic function of a web framework is
    to translate the raw HTTP request into an actionable handler. Before we see how
    we can implement this, it is good to keep in mind what the raw requests look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the request, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line (sometimes called the *start line*) contains three subparts:
    **HTTP Method**, **request target**, and **HTTP** protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second section contains zero or more lines of HTTP headers in `key: value`
    form, with each pair separated by a line break'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have a blank line separating the head from the body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we have the *optional* body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exact specification is covered by RFC 7230, 3\. [https://datatracker.ietf.org/doc/html/rfc7230#section-3](https://datatracker.ietf.org/doc/html/rfc7230#section-3)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the goals of this book is to learn strategies to design API endpoints
    that will be easily consumable, keeping in mind the needs and limitations of the
    application we are building. The goal is to understand the first interactions
    that the server has with an incoming web request, and how to design our application
    around that. We will learn about: how requests are structured; what choices Sanic
    makes for us and what choices it leaves; and other issues involved in turning
    an HTTP request into actionable code. Remember, the purpose of this book is not
    just to learn how to use a fancy new tool, but also to level-up web development
    skills and knowledge. To become more informed developers, we seek to not only
    understand *how* to build with Sanic, but *why* we might build something in a
    particular way. We will learn to ask better questions and to make better decisions
    by understanding some of the mechanics. This does not mean we need to be experts
    on the HTTP protocol and specification. By being familiar with, however, with
    what Sanic is doing with the raw request, we will ultimately be armed with a greater
    set of tools for building web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we’ll cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paths, slashes, and why they matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced path parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to what we have been building before, in this chapter you should
    have the following tools at your disposal in order to be able to follow along
    with the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can access source code for this chapter on GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/03)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding HTTP Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have built any kind of a website before, you probably have an understanding
    of the concept of **HTTP Methods**; or at least the basic `GET` and `POST` methods.
    However, did you know that there are nine standard HTTP Methods? In this section,
    we will learn about these different methods and how we *could* take advantage
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that an IP address or a web domain is a *place* on the Internet,
    an HTTP Method is an *action* on the Internet. They are the collection of verbs
    in the language of the web. These HTTP Methods have a shared understanding and
    meaning. Web applications will commonly use these methods in similar use cases.
    That does not mean that you must follow the conventions, or that your application
    will break if you venture away from the standards. We should learn the rules so
    that we know when it may be appropriate to break them. These standards exist to
    create a common language that web developers and consumers can use to communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description | Has body | Safe | Sanic support |'
  prefs: []
  type: TYPE_TB
- en: '| `CONNECT` | Open two-way communication, like a tunnel to the resource | No
    | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Delete the resource | No (usually) | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Fetch the resource | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | Fetch the meta-data *only* for the resource | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Request permitted communication options | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Partially modify the resource | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | Send data to the server | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Create a new resource or update completely if existing | Yes | No
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `TRACE` | Perform message loopback used for debugging | No | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 - HTTP Method Overview
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about a method being *safe*, what we mean is that it should not
    be state-changing. That is not to say that a `GET` method cannot have side effects.
    Of course, it can. For example, someone hitting the endpoint will trigger logs
    or some sort of a resource counter. These are technically what the industry might
    refer to as side-effects. “*The important distinction here is that the user did
    not request the side-effects, so therefore cannot be held accountable for them.”*
    RFC 2616, 9.1.1 ([https://datatracker.ietf.org/doc/html/rfc2616#section-9](https://datatracker.ietf.org/doc/html/rfc2616#section-9)).
    This means that from the perspective of the user accessing the resource, the determination
    of whether an endpoint is *safe* is a matter of intent. If the user intends to
    retrieve profile information, it is safe. If the user intends to update profile
    information, it is not safe.
  prefs: []
  type: TYPE_NORMAL
- en: While it is certainly helpful to try and stick to the descriptions of the methods
    in *Table 3.1*, undoubtedly you will come across use cases that do not fit nicely
    into these categories. When that happens, I encourage you to reexamine your application
    design. Sometimes the problem can be solved with new endpoint paths. Sometimes
    we need to create our own definitions. This is okay. I would, however, caution
    against changing a *safe* method to *unsafe.* Performing stateful changes with
    a `GET` request is considered poor form, and a *rookie mistake*.
  prefs: []
  type: TYPE_NORMAL
- en: After deciding what our HTTP Methods should be, we will venture into the next
    section to learn about how we can implement them and attach them to routes.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP Methods on route handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are finally ready to learn and see what frameworks are all about! If you
    have used Flask in the paste, this will look familiar. If not, what we are about
    to do is create a route definition that is a set of instructions to tell Sanic
    to send any incoming HTTP requests to our route handler. A route definition must
    have two parts: a URI path and one or more HTTP Methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Matching on the URI path alone is not enough. HTTP Methods are also used by
    Sanic to get your incoming request to the correct handler. Even when we implement
    the most basic form of a route definition, both parts must exist. Let’s look at
    the simplest use case and see what default choices Sanic will make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we defined a route at `/my/stuff`. Usually we inject the `route()`
    call with an optional `methods` argument to tell it what HTTP Methods we want
    that handler to respond to. We have not here, so it will default to just `GET`.
    We have the option of telling the route that it should also handle other HTTP
    Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will look at `HEAD` method a little later in this chapter. But it is important
    to know that a `HEAD` request should not have any response body. This is enforced
    by Sanic for us. Even though technically this endpoint is responding with the
    text `Hello`, Sanic removes the body from the response and only sends the meta
    data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we have a single endpoint setup with multiple methods, we can access
    it with both methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, with a `GET` request (it should be noted that when using `curl`, if
    you do not specify a method, it will default to `GET`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As a convenience, Sanic provides shortcut decorators to all of its supported
    HTTP Methods on both the app instance and any Blueprint instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These decorators can also be stacked. The last example that we saw could also
    be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One more fundamental thing to know about HTTP Methods is that you can access
    the incoming method on the HTTP request object. This is very helpful if you are
    handling different types of methods on the same handler, but need to treat them
    differently. Here is an example where we look at the HTTP Method to change the
    behavior of the handler
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before moving on to advanced method routing, there is some Sanic syntax we
    should mention. All of the examples here use the decorator syntax to define routes.
    This is by far the most common way to achieve this because of its convenience.
    There is, however, an alternative. All route definitions could be converted to
    functional definitions as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In some circumstances this may be a more attractive pattern to use. We will
    see it again when we encounter Class-Based Views later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced method routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sanic does not out-of-the-box support `CONNECT` and `TRACE`, two standard HTTP
    Methods. But let’s imagine that you want to build an HTTP proxy or some other
    system that needs to have the `CONNECT` method available in your route handler.
    Even though Sanic does not out-of-the-box allow it, you have two potential approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we could create a piece of middleware that is on the lookout for `CONNECT`
    and hijacks the request to provide a custom response. This *trick* of responding
    from middleware is a feature that allows you to halt the execution of the request/response
    lifecycle before the handlers would take over and otherwise fail as a `404 Not
    Found`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see that a potential downside to this approach is that we need to implement
    our own routing system if we wanted to send different endpoints to different handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second approach might be to tell the Sanic router that `CONNECT` is a valid
    HTTP Method. Once we do this, we can add it to a normal request handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: One important consideration for this strategy is that you will need to redefine
    `app.router.ALLOWED_METHODS` as early as possible before registering the new handlers.
    For this reason, it might be best for it to come directly after `app = Sanic(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: A side benefit that this strategy provides is the ability to create your own
    ecosystem of HTTP Methods with your own definitions. This may not necessarily
    be advisable if you intend for your API to be used for public consumption. However,
    it may be useful, practical, or just plain fun for your own purposes. There may
    only be nine standard methods, but there are infinite possibilities. Do you want
    to create your own verbs? You are certainly free to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '`ATTACK /path/to/the/dragon HTTP/1.1`'
  prefs: []
  type: TYPE_NORMAL
- en: Method safety and request body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have learned, there are generally two types of HTTP Methods: **safe**
    and **unsafe**. The unsafe methods are `POST`, `PUT`, `PATCH`, and `DELETE`. These
    methods are generally understood to mean that they are state-changing. That is
    to say that by hitting these endpoints, the user is intending to change or alter
    the resource in some way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The converse of this are safe methods: `GET`, `HEAD`, and `OPTIONS`. The purpose
    of these endpoints is to request information from the application, not change
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: It is considered good practice to follow this practice. If an endpoint will
    make a change on the server, do not use `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lining up with this division is the concept of request body. Let’s revisit
    the raw HTTP request one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'HTTP request can optionally include a body. In the above example, the request
    body is the last line: `{"foo": "bar"}`.'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that Sanic will only take the time to read the message
    body for `POST`, `PUT`, and `PATCH` requests. It will stop reading the HTTP message
    after the headers if it is an HTTP request using any other HTTP Method. This is
    a performance optimization since we generally do not expect there to be a message
    body on the *safe* HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed this list did not include `DELETE`. Why? In general, the
    HTTP specification says that there *may* be a request body ([https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.5)).
    Sanic assumes that it will not have one unless you tell it that it does. To do
    this, we simply set `ignore_body=False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we do not set `ignore_body=False`, and we send a body with our `DELETE` requests,
    Sanic will raise a warning in the logs to let us know that part of the HTTP message
    was not consumed. If you intend to use `DELETE` methods, you should be on the
    lookout for this since Sanic makes the assumption. It should also be noted that
    if you are in the habit of receiving GET requests with a body, you will also need
    to use `ignore_body=False`. However, I hope you have a very good reason for doing
    that since it breaks most web standards.
  prefs: []
  type: TYPE_NORMAL
- en: One helpful takeaway from this is that out of the box, the following two endpoints
    are *not* equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Both `/one` and `/two` will behave similarly. Without further customization,
    however, the first request will spend time trying to read the request body even
    if it does not exist, while the second just assumes that it is the case that there
    is no body. While the performance difference will be small, it is generally preferred
    to use `@app.get("/two")` over `@app.route("/one", methods=["GET"])`. The reason
    that these two endpoints differ is that they have different default values for
    `ignore_body`.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you are building a GraphQL application, then usually `POST` is used by the
    endpoint even for informational requests. This is because it is generally much
    more acceptable to pass a body on a `POST` request than a `GET` request. However,
    it is worth mentioning that we could consume a message body from a `GET` request
    if we really wanted to by setting `ignore_body=False`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When deciding what method you should use, another factor to consider is **idempotency**.
    In short, idempotence means that you can perform the same action over and over
    again, and the result should be the same every time. The HTTP Methods that are
    considered idempotent are: `GET`, `HEAD`, `PUT`, `DELETE`, `OPTIONS`, and `TRACE`.
    Keep this in mind when designing your API.'
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP Methods are often used in **RESTful API design**. There is a wealth of
    literature already written on building RESTful APIs, so we will not dive deeply
    into *what* it is, but more *how* we can practically implement it. We shall, however,
    first have a quick refresher of the basic premise.
  prefs: []
  type: TYPE_NORMAL
- en: Web API endpoints have a target. That target is *something* that either the
    user would like to fetch information about, or manipulate by adding or changing
    it. Based upon a shared understanding, the HTTP Method tells the server how you
    would like to interact with that target. The *target* is often called a *resource*,
    and we may use the terms interchangeably here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To grasp this concept, I like to think back to the adventure computer games
    I played as a child. My swashbuckling character would happen upon an object: let’s
    say a rubber chicken. When I clicked on that object, a menu would appear with
    different verbs that told me what I could do with that object: pick up, look at,
    use, talk to, and so on. There was a target (the rubber chicken), and methods
    (the verbs or actions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this together with the HTTP Methods we defined above, let’s look at
    a concrete example. In our hypothetical situation, we will be building an API
    to manage a social media platform for people that love adventure computer games.
    Users need to be able to create a profile, view other profiles, and update their
    own. We might design the following endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **METHOD** | **URI PATH** | **DESCRIPTION** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/profiles` | A list of all of the member profiles |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/profiles` | Create a new profile |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/profiles/<username>` | Retrieve profile for a single user |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/profiles/<username>` | Remove the old profile and replace with
    a complete profile |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | `/profiles/<username>` | Make a change to only a part of a profile
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/profiles/<username>` | Remove a profile–but why would anyone
    want to remove their swashbuckling adventure gamer profile? |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 - Example HTTP Methods and endpoints
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go further, if you are unfamiliar with how routing works in Sanic
    (and what the `<username>` syntax means), you can get more information in the
    User Guide here: [https://sanicframework.org/en/guide/basics/routing.html](https://sanicframework.org/en/guide/basics/routing.html),
    and we will also look at it more closely later in this chapter in the section
    titled *Extracting information from the path*. Feel free to skip ahead and come
    back.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there really are only two URI paths: `/profiles` and `/profiles/<username>`.
    Using the HTTP Methods, however, we have been able to define six different interactions
    with our API! What might the profile blueprint look like?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using HTTP Methods to define our use cases seems helpful and having decorators
    that map them seems convenient. But, it seems like there is a lot of boilerplate
    there, and repetition. We will next look at Class-Based Views and how we can simplify
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying your endpoints with Class-Based Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous example exposes a weakness with using functions and decorators
    alone to design your API. What happens when we want to add endpoint handlers for
    `/profile/<user_id:uuid>`? Or when we want to make some other change to the existing
    endpoint? We now have multiple places to make the same change, leading to a higher
    chance that we do not maintain parity among all our route definitions. This is
    a violation of the **DRY** (**don’t repeat yourself**) principle, and could lead
    to bugs. Maintaining these endpoints over the long term therefore might be more
    difficult than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the compelling reasons to use **Class-Based Views** (**CBVs**).
    This pattern will give us the opportunity to link together the first two endpoints,
    and the last four endpoints so they become easier to manage. They are being grouped
    together because they share the same URI path. Instead of standalone functions,
    each HTTP Method will be a functional method on a class. And, that class will
    be assigned a common URI path. A bit of code should make this easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Later in this book we may see more and more use of custom decorators to add
    shared functionality. It is worth mentioning that we can also add them easily
    to CBVs, and I highly suggest you take a moment to refer to the User Guide to
    see it in action: [https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators](https://sanicframework.org/en/guide/advanced/class-based-views.html#decorators)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One thing to be on the lookout for when adding decorators to CBV methods is
    the `self` argument on instance methods. You may need to adjust your decorator,
    or use a `staticmethod` to get it to work as expected. The above mentioned documentation
    explains how to do that.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Earlier, we saw how `add_route` could be used as an alternative approach to
    attaching a single function as a handler to a route definition. It looked like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This pattern is one of the main ways to attach a CBV to a Sanic or Blueprint
    instance. The caveat is that you need to call it using the class method: `as_view()`.
    In our previous example, we saw what this looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This could also be achieved by attaching the CBV when it is declared. This is
    option will only work if you already have a known Blueprint or Application instance.
    We will rewrite `SingleProfileView` to take advantage of this alternative syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How should you decide which to use? Personally, I find this second version to
    be easier and cleaner. The big downside is that you cannot lazily create the CBV
    and attach it later since it needs to be known up front.
  prefs: []
  type: TYPE_NORMAL
- en: Blanket support for OPTIONS and HEAD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is generally best practice to support `OPTIONS` and `HEAD` methods on all
    of your endpoints, where it is appropriate. This could become tedious and include
    a lot of repetitive boilerplate. To achieve this with standard route definitions
    alone would require a lot of code duplication as seen below. Below, we see that
    we need for route definitions where two would be sufficient. Now imagine if every
    endpoint needed to also have `OPTIONS` and `HEAD`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use Sanic’s router to our advantage to add on a handler for these requests
    to each and every route. The idea will be to loop over all of the routes defined
    in our application and dynamically add handlers for `OPTIONS` and `HEAD` if needed.
    Later on in *Chapter 7*, we will use this strategy for creating our customized
    CORS policy. For now, however, all we need to keep in mind is that we want to
    be able to handle ANY request to a valid endpoint using one of these HTTP Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a closer look at this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create route handlers: the functions that will do the work when the
    endpoint is hit. For now, they do not do anything. If you want to know what this
    endpoint *could* do, jump ahead to the CORS discussion in *Setting up an effective
    CORS policy* located in *Chapter 7*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The next part needs to be done after we register all of our endpoints. In *Chapter
    11*, we accomplish this by running the code inside of a factory. Feel free to
    take a look ahead to the example there to be able to compare it with our current
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In our current example, we do not have a factory, and are adding the routes
    inside an event listener. Normally, this would not be possible since we cannot
    change our routes after the application is running. When a Sanic application starts
    up, one of the first things it does internally is call `app.router.finalize()`.
    But, it will not let us call that method twice. Therefore, we need to run `app.router.reset()`,
    add our routes, and finally call `app.router.finalize()` after all of our dynamic
    route generation is complete. You can use this same strategy anywhere that you
    might want to dynamically add routes. Is this a good idea? In general, I would
    say that dynamically adding routes is a bad idea. Having changing endpoints might
    lead to unpredictability, or weird bugs across a distributed application. However,
    the benefit we are gaining through dynamic route generation in this instance is
    great, and the risk is very low.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few different properties that the Sanic router provides us with
    that we could loop over to see what routes are registered. The two most commonly
    used for public consumption are `app.router.routes` and `app.router.groups`. It
    is helpful to understand what they are and how they differ. We will put our discussion
    on `OPTIONS` and `HEAD` on pause for a brief moment to look at these two properties
    to see how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that one of them is producing `Route` objects,
    and the other `RouteGroup` objects. The second obvious takeaway is that one is
    a list and the other a dictionary. But what are `Route` and `RouteGroup`?
  prefs: []
  type: TYPE_NORMAL
- en: 'In our console, we will see that there are three `Route` objects, but only
    two `RouteGroup` objects. This is because Sanic has grouped together similar looking
    routes to more efficiently match them later. A `Route` is a single definition.
    Every time we call `@app.route`, we are creating a new `Route`. Here, we can see
    that they have been grouped by the URI path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Getting back to our discussion of automation, we are going to use `app.router.groups`.
    This is because we want to know which methods have and have not been assigned
    to a given path. The quickest way to figure that out is to look at the groups
    that Sanic has already provided for us. All we need to do is check if the group
    already includes a handler for the HTTP Method (so we do not overwrite anything
    that already exists), and call `add_route`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we will not look at `options_handler` right now, we can look more
    closely at `head_handler`. A `HEAD` request is defined in RFC 2616 as being identical
    to a `GET` request: “*The HEAD method is identical to GET except that the server
    MUST NOT return a message-body in the response”* ([https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pretty easy to implement in Sanic. Really what we want to do is retrieve
    the response from the `GET` handler for the same endpoint, but only return the
    metadata, *not* the request body. We will use `functools.partial` to pass the
    `GET` handler to our `head_handler`. Then, all it needs to do is run the `get_handler`
    and return the response. As we saw earlier in the chapter, Sanic will do the work
    for us of removing the body before it sends the response to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the above example we added `name=f"{get_route.name}_head"` to our `add_route`
    method. This is because all routes in Sanic get a “name”. If you do not manually
    supply one, then Sanic will attempt to generate a name for you using `handler.__name__.`
    In this case, we are passing a `partial` function as a route handler, and Sanic
    does not know how to generate a name for that since partial functions in Python
    have no `__name__` property.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now that we know about how to use HTTP Methods to our advantage, we will look
    at the next big area in routing: **paths**.'
  prefs: []
  type: TYPE_NORMAL
- en: Paths, slashes, and why they matter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Way back in the stone-age when the Internet was invented, if you navigated to
    a URL, you were literally being delivered a file that existed on a computer somewhere.
    If you asked for `/path/to/something.html`, the server would look in the `/path/to`
    directory for a file called `something.html`. If that file existed, it would send
    it to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this does still exist, times have certainly changed for many applications.
    The Internet is still largely based upon this premise, but often a generated document
    is sent instead of a static document. It is helpful to still keep this mental
    model in your head though. Thinking that a path on your API should lead to a resource
    of some kind will keep you away from certain API design flaws. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Your URI paths should use nouns, not verbs. If we want to perform an action
    and tell the server to do something, we should manipulate the HTTP Method as we
    learned, not the path of the URI. Going down this path—believe me, I’ve done it—will
    lead to some messy looking applications. Very likely you will wake up one day
    and look at a mess of disjointed and incoherent paths and ask yourself: what have
    I done? There might, however, be a time and place for this, so we will revisit
    it shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that our paths should contain nouns, the obvious next question is whether
    they should be singular or plural. I do not think there is a single consensus
    on the Internet about what is right here. Many people always use plural; many
    people always use singular; and some wild hooligans decide to mix and match. While
    the decision itself may seem small, it is nevertheless important to establish
    consistency. Picking a system and applying consistency is itself more important
    than the actual decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, I will give you my opinion. Use plural nouns. Why?
    It makes for very nice nesting of paths, which could translate nicely to nesting
    of Blueprints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'I do encourage you to use singular nouns if it makes sense to you. But if you
    do, you must do it everywhere. As long as you stay consistent and logical about
    your choice, your API will feel polished. Mixing plural and singular paths will
    make your API feel haphazard and amateurish. A really nice resource that explains
    how to *consistently* break the two rules I just laid out (use nouns, use plural)
    is found here: [https://restfulapi.net/resource-naming/.](https://restfulapi.net/resource-naming/.)
    Again, it is important and helpful for us to not only learn the *rules* or the
    *right way* to do something but to also learn when to break them, or when to make
    our own set of rules. Sometimes following standards makes sense, sometimes not.
    This is how we go from someone that merely is capable of making a web application,
    to someone that knows how to design and build one. The difference is expertise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also encouraged when designing paths to favor hyphens (`-`) over spaces,
    capitalization, or underscores. This increases the human readability of your API.
    Consider the difference between these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Most people would consider the last option to be the easiest to read.
  prefs: []
  type: TYPE_NORMAL
- en: Strict slashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the legacy paradigm where endpoints were equivalent to the file structure
    of a server, the trailing slash in a path took on a specific meaning. It is widely
    accepted that paths with and without trailing slashes are not the same and are
    not interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: If you navigated to `/characters`, you might expect to receive a list of all
    the characters in our fictitious social media application. However, `/characters/`
    technically means *show me a list of everything that is in the* `characters` *directory*.
    Because this could be confusing, you are encouraged to avoid using trailing slashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, it is also widely accepted that these *are* the same thing.
    In fact, a lot of browsers (and websites) treat them the same. I’ll show you how
    you can test this for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your web browser and go to: [https://sanic.readthedocs.io/en/stable/](https://sanic.readthedocs.io/en/stable/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open a second tab and go to: [https://sanic.readthedocs.io/en/stable](https://sanic.readthedocs.io/en/stable)'
  prefs: []
  type: TYPE_NORMAL
- en: It is the same page. In fact, it seems that this web server breaks the rule
    that I just mentioned and prefers the trailing slash to not having it at all.
    So, where does this leave us, and what should we implement? It is really up to
    you to determine, so let’s see how we can control it in Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do nothing, Sanic will drop the trailing slash for you. Sanic does,
    however, provide you with the ability to control whether that trailing slash should
    have meaning or not by setting the `strict_slashes` argument. Consider an application
    setup with and without trailing slashes, and with and without `strict_slashes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The above definitions will fail. Why? When Sanic sees a trailing slash on a
    path definition it will remove it, *unless* `strict_slashes=True`. Therefore,
    the first and second routes are considered identical. Furthermore, the third route
    is also the same, therefore causing a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: While the generally accepted rule is that a trailing slash *should* have meaning,
    this is not the case for a trailing slash that is the only part of a path. RFC
    2616, Section 3.2.3 states that an empty path (`""`) is the same thing as a single
    slash path (`"/"`). ([https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3](https://datatracker.ietf.org/doc/html/rfc2616#section-3.2.3))
  prefs: []
  type: TYPE_NORMAL
- en: 'I put together a deeper discussion about how Sanic handles the possible scenarios
    of trailing slashes. If this is something you are considering to use, I suggest
    you take a look here: [https://community.sanicframework.org/t/route-paths-how-do-they-work/825.](https://community.sanicframework.org/t/route-paths-how-do-they-work/825.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to ask me my opinion, I would say do not use them. It is much more
    forgiving to allow `/characters` and `/characters/` to have the same meaning.
    Therefore, I personally would define the above route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Extracting information from the path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to consider in this section is extracting usable information
    from our request. The first place we often look is the URI path. Sanic provides
    a simple syntax for extracting parameters from the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have declared the second segment in our path to contain a variable. The Sanic
    router extracts that and injects it as an argument in our handler. It is important
    to note that if we do nothing else, that injection will be a `str` type value.
  prefs: []
  type: TYPE_NORMAL
- en: Sanic also provides an easy mechanism for converting the type. Suppose we want
    to retrieve a single message from a message feed, query it in the DB, and return
    the message. In this case, our call to the DB requires the `message_id` to be
    an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This route definition will tell Sanic to convert the second segment into an
    `int` before injecting it. It is also important to note that if the value is something
    that cannot be cast as an `int`, it will raise a `404 Not Found`. Therefore, the
    parameter type does more than just type casting. It is also involved in route
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the next section, and the User Guide to learn what all of the
    allowed parameter types are. [https://sanicframework.org/en/guide/basics/routing.html#path-parameters](https://sanicframework.org/en/guide/basics/routing.html#path-parameters)
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides extracting information from the path itself, the two other places we
    may want to look for user data are the query parameters, and the request body.
    Query parameters is the part of the URL that comes after a `?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/characters?count=10&name=george`'
  prefs: []
  type: TYPE_NORMAL
- en: 'How should we decide if information should be passed in the path, the query
    arguments, or as a part of form or JSON body? Best practices dictate that information
    should be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**path parameters**: Information to describe *what* the resource is we are
    looking for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**query parameters**: Information that can be used to filter, search, or sort
    the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**request body**: Everything else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good habit to get into very early on in your application development
    to learn where different usable bits of information can come from. Chapter 4 dives
    much further into passing data through query patameters and the request body.
    Just as valuable is of course the HTTP path itself. We just looked at how important
    crafting purposeful paths might be. Next, we will take a deeper look at extracting
    data from the HTTP path.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced path parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section, we learned the basics of extracting information from a
    dynamic URL path to something we can code with. This is truly a fundamental feature
    of all web frameworks. It is also extremely common among many frameworks to allow
    you to specify what that path parameter should be. We learned that `/messages/<message_id:int>`
    would match `/messages/123` but not `/messages/abc`. We also learned about the
    convenience that Sanic provides in converting the match path segment to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: But, what about more complex types? Or what if we need to modify the matched
    value before using it in our application? In this section, we will explore a couple
    helpful patterns to achieve these goals.
  prefs: []
  type: TYPE_NORMAL
- en: Custom parameter matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Out of the box, Sanic provides eight path parameter types that can be matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '`str`: matches any valid string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slug`: matches standard path slugs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: matches any integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: matches any number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`: matches only alphabetic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: matches any expandable path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ymd`: matches `YYYY-MM-DD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uuid`: matches a `UUID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these provides a type that corresponds to the matched parameter. For
    example, if you have this path: `/report/<report_date:ymd>`, the `date` object
    in your handler will be a `datetime.date` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very helpful pattern because it accomplishes two things for us. First,
    it makes sure that the incoming request is in the correct format. A request that
    is `/report/20210101` would receive a `404 Not Found` response. Second, when we
    go to work with that `report_date` instance in our handler, it has already been
    cast into a usable data type: `date`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we need routing for types outside of the standard types?
    Sanic does of course allow us to achieve the first part by defining a custom regular
    expression for a path segment. Let’s imagine that we have an endpoint that we
    want to match on a valid IPv4 address: `/ip/1.2.3.4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest approach here would be to find a relevant regular expression and
    add it to our path segment definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we access our endpoint we should have a valid match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Using regular expression matching also allows us to narrowly define an endpoint
    between a limited number of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have routing based upon our two available choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: While regular expression matching is incredibly helpful sometimes, the problem
    is that the output is still a `str`. Going back to our first IPv4 example, we
    would need to manually cast the matched value into a `ipaddress.IPv4Address` if
    we wanted an instance of that class to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this might not seem like a big deal if you have one or two handlers,
    if you have a dozen endpoints that needed a dynamic IP address as a path parameter,
    it could become cumbersome. Sanic’s solution to this is custom pattern matching.
    We can tell Sanic that we want to create our own parameter type. To do this we
    need three things:'
  prefs: []
  type: TYPE_NORMAL
- en: A short descriptor that we will use to name our type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that will return the value we want or raise `ValueError` if there
    is no match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fallback regular expression that also matches our value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the IP address example:'
  prefs: []
  type: TYPE_NORMAL
- en: We will name the parameter `ipv4`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the standard library’s `ipaddress.ip_address` constructor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We already have our fallback regular expression from earlier. We can proceed
    to registering the custom parameter type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have a more usable object in the handler (`ipaddress.IPv4Address`),
    and we also have a very easy to reuse path parameter (`<ip:ipv4>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'What about our second example with ice cream flavors? Instead of having a `str`
    type, what if we wanted to have an `Enum` or some other custom model? There is
    unfortunately no function in Python’s standard library for parsing ice cream flavors
    (maybe someone should build that), so we will need to create our own:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we will create our model using an `Enum`. Why an Enum? It is a fantastic
    tool to keep our code nice and consistent. If our environment is setup right—which
    it is because we took care in *Chapter 2* to use good tools—we have a single place
    where we can maintain our flavors with code completion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need a regular expression that we can later use in our route definition
    for matching incoming requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting pattern should be: `vanilla|chocolate`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to create a function that will act as our parser. Its job is to
    either return our target type or raise `ValueError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can now proceed to register that pattern with Sanic. Just like the IP address
    example before, we have the name of our parameter type, a function to check the
    match, and a fallback regular expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our pattern now registered, we can proceed to use it in all of our ice
    cream endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we access the endpoint now, we should have an `Enum` instance, but still
    only accept requests that match one of our two defined flavors. Yum!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The key to this example is having a good parse function. In our example, we
    know that if a bad flavor is entered into the `Enum` constructor it will raise
    `KeyError`. This is a problem. If our application cannot match `mint`, it will
    throw a `KeyError` and the application will respond with a `500 Internal Server
    Error`. This is not what we want. By catching the exception and casting it to
    `ValueError`, Sanic is able to understand that this is expected, and it should
    respond with a `404 Not Found`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying matched parameter values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have learned, using path parameter types is extremely helpful in building
    our API to respond to intended requests and ignoring bad paths. As much as possible,
    it is best practice to be as specific as your endpoint needs to get the right
    data in. We just explored how we might also use parameter types to recast the
    matched value to a more useful data type. But what if we are not concerned about
    changing the `type` of the value, but the actual value itself?
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our character profile application example, imagine that we have
    some URLs that include **slugs**. If you are not familiar with a slug, it is basically
    a string that uses lower cases letters and hyphens to make human friendly content
    in URL paths. We saw an example of this earlier: `/users/adam-hopkins`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our hypothetical application, we need to build an endpoint that returns details
    about a character instance.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will create a model for what the character object will look like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to be able to return specific details about out character. For example,
    the endpoint `/characters/george/name` should return `George`. So, our next task
    is to define our route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is a fairly simple route. It searches for the character, and then returns
    the requested attribute. Let’s check it out in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s try getting George’s super powers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/file0.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Uh oh, what happened? The property we are trying to access is `Character.super_powers`.
    But, our endpoint accepts slugs (because they are easier for people to read).
    So we need to convert the attribute. Just like in the previous section where we
    *could* cast our value inside of the handler, it becomes more difficult to scale
    that solution. We *could* run `attr.replace("-", "_")` inside of our handler,
    and perhaps this is a viable solution. It does make for extra code inside the
    handlers.Luckily, we also have another alternative. This is a good use case for
    middleware where we need to convert all slugs (eg. `this-is-a-slug`) to snake
    case (eg. `this_is_snake_case`) so that they can be used programatically down
    the road. By converting the slugs, we can look for `super_powers` instead of `super-powers`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s make that middleware:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What this will do is modify the `Request` instance before it gets executed by
    the route handler. For our use case, this means that every value that is matched
    will be converted from a slug to snake case. Note that we are *not* returning
    anything in this function. If we do, Sanic will think that we are trying to halt
    the request/response cycle by providing an early return. This is not the intention.
    All we want to do is modify the `Request`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s test that endpoint again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Middleware is not the only solution to this problem though. Sanic makes use
    of signals to dispatch events that your application can listen to. Instead of
    the above middleware, we could do something similar like this with signals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, it is a very similar implementation. Perhaps the biggest difference
    to us as developers is that the signal provides us with some more arguments to
    work with. Although, to be honest, the `route` , the `handler`, and the `kwargs`
    are all properties that could be accessed from the `Request` instance. Middleware
    and signals are discussed in greater depth in Chapter 6\. For now, just know that
    these are two methods for altering the request/response cycle outside of the route
    handler. Later on we will learn more about the differences between them and when
    it might be preferable to choose one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in *Chapter 2,* *Organizing a project* we discussed how you could implement
    API versioning using Blueprints. If you recall, it was simply a matter of adding
    a keyword value to the Blueprint definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the below Blueprint definition, we get the URL path: `/v1/characters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That `version` keyword argument is available at the route level as well. If
    the version is defined in multiple places (for example, on the route and also
    the Blueprint), priority is given to the narrowest scope. Let’s look at an example
    of different places where the version can be defined, and see what the result
    is. We will define it at the route level, the Blueprint level, and the Blueprint
    group level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the following routes. Take a closer look at the example to see
    how we manipulate the Blueprints and the `version` argument to control the handler
    that each path is delivered to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/v1/characters <Route: name=main.Characters.version_1 path=v1/characters>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v3/characters <Route: name=main.Characters.version_3 path=v3/characters>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v2/characters <Route: name=main.CharactersV2.version_2 path=v2/characters>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding versions to endpoint paths is fairly simple. But why should we do it?
    It is a good practice because it keeps your API flexible, but also consistent
    and stable for your users. By allowing endpoints to be versioned, you maintain
    the ability to make changes to them and still allow for legacy requests to not
    be denied. It is incredibly beneficial as over time as you transition your API
    to add, remove, or enhance features.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the only consumer of your API is your own website, it is still a good
    practice to version your APIs so that you have an easier path towards upgrades
    without potentially causing application regressions.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice to “lock-in” features with a version. This is a form
    of creating what is known as an API contract. Think of an API contract as a promise
    by the developer that the API will continue to work. In other words, once you
    put an API into usage—and especially if you publish documentation—you are creating
    a promise to the user that the API will continue to function as is. You are free
    to add new features, but any breaking changes that are not backwards compatible
    violate that contract. Therefore, when you do need to add breaking changes, versions
    might be the right trick in your tool bag to accomplish your goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example. We’re building out our database of character profiles.
    The first version of our API has an endpoint to create a new profile and it looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This endpoint is built upon the assumption that the incoming JSON body will
    be fairly simple like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: What happens when we want to handle some more complex use cases?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: It might start getting complicated, messy, and overall difficult to maintain
    our route handler if we put too much logic into it. As a general practice, I like
    to keep my route handlers very concise. If I see my code creeping up to 50 lines
    of code inside a view handler, I know there is probably some refactoring that
    needs to be done. Ideally, I like to keep them to about 20 lines or less.
  prefs: []
  type: TYPE_NORMAL
- en: One way we can keep our code clean is to split these use cases. Version 1 of
    the API will still be able to create characters using the simpler data structure,
    and version 2 has the capability of the more complex structure.
  prefs: []
  type: TYPE_NORMAL
- en: Should all of my routes bump versions?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be curious to know why you would want to
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you will have a need to increase a version on a single endpoint, but
    not all of them. This raises the question: what version do I use on the unchanged
    endpoints? Ultimately, this is going to be a question that can only be dictated
    by the application. It might be helpful to keep in mind how the API is being used.'
  prefs: []
  type: TYPE_NORMAL
- en: Very often you will see APIs bumping versions when there is a complete break
    or some major overhaul in the API structure. This could accompany a new technology
    stack, or a new API structure or design pattern. An example of this is when GitHub
    changed their API from v3 to v4\. The older version of their API (v3) is RESTful,
    similar to what we discussed earlier in this chapter. The newer version (v4) is
    based upon GraphQL (see Chapter 10 for more on GraphQL). This is a complete redesign
    of the API. Because v3 and v4 are completely incompatible, they changed the version
    number.
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub’s case, it was clear all endpoints needed to change as it was effectively
    a brand new API. Drastic changes like this are not the only catalyst for version
    changing, however. What if we are only changing compatibility on a smaller portion
    of our API and keeping the rest intact?
  prefs: []
  type: TYPE_NORMAL
- en: 'Some people may find that it makes sense to implement the new version number
    on all of their endpoints. One way to accomplish this is to add multiple route
    definitions to an endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The downside of this approach is that could become very cumbersome to maintain.
    If you needed to add a new route definition to *every* handler when you want to
    change a version, you might be discouraged from adding versions in the first place.
    Take this into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: How about nesting blueprints? How about a function that dynamically adds routes
    at startup? Can you think of a solution? We have already seen various tools and
    strategies earlier in this book that might help us out. This might be a good time
    to put the book down and jump into your code editor on your computer. I encourage
    you to play around with versions and nesting to see what is and is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember `app.router.routes` and `app.router.groups`? Try adding a single handler
    to multiple Blueprints. Or try adding the same Blueprints to different groups.
    I challenge you to come up with a pattern to have the same handler be on different
    versions without multiple definitions like the above example. Start with this,
    and see what you can come up with, without doubling up the route definition as
    above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a handy snippet you can use while developing to see which paths are
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting back to our question: should all of my routes bump versions? Some people
    will say yes, but it seems artificially complex to bump the version of all routes
    when only one has changed. By all means, if it makes sense, bump everything simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only want to bump the routes that are changing, it causes another problem.
    What should we bump it to? Many people will tell you that versions should *only*
    ever be integers: `v1`, `v2`, `v99`, etc. I find this limiting, and it really
    makes the following set of endpoints feel unnatural:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/v1/characters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/characters/puppets`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/characters/super_heroes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v1/characters/historical`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/v2/characters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While I am not discounting this approach, it does seem like there *should*
    be a `v2` for all of the routes, even if they did not change. We are trying to
    avoid that. Why not use minor versions like semantic versioning? It seems more
    natural and accepting to have a single `/v1.1` endpoint than a single `/v2`. Again,
    this is going to be a matter of what works for your application needs, and what
    is reasonable given the types of users that will be consuming your API. Should
    you decided that semantic versioning style will work for your application needs,
    you can add it by using a float for the version argument as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Semantic versioning is an important concept in software development, but beyond
    the scope here. In brief, the concept is to create a version by declaring a major,
    minor and patch numer that are connected by a period. Example: 1.2.3\. Generally
    speaking, semantic versioning states that an increment of the major version corresponds
    to a backwards-incompatible change, the minor version to a new feature, and the
    patch version to a bug fix. If you are unfamiliar with it, I suggest taking some
    time to read through the documentation for it since it is widely used throughout
    software development: [https://semver.org/](https://semver.org/)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is highly recommended that you use version with your endpoints if you intend
    for there to be third-party integration with your API. If the API is only meant
    to be used by your own application, perhaps this is less important. Nevertheless,
    it may still be a useful pattern. Therefore, I recommend using `version=1` for
    new projects or `version=2` for projects that are replacing an existing API even
    if the legacy application did not have a version scheme.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Version prefixing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard way to use versions in Sanic is `version=<int>` or `version=<float>`.
    The version will *ALWAYS* be inserted into your path at the very beginning. It
    does not matter how deeply nested and how many layers of `url_prefix` you may
    have. Even a deeply nested route definition can have a single version and it will
    be the first segment in the path: `/v1/some/deeply/nested/path/to/handler`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This does, however, impose a problem when you are trying to build multiple
    layers on your application. What if you want to have some HTML pages and an API
    and keep them separate based upon their path? Consider the following paths that
    we might like to have in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/page/profile.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/v1/characters/<name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice how the versioned API route starts with `/api`? This is impossible to
    control only with URIs and Blueprint URI prefixes since Sanic *always* puts the
    version before the rest of the path. However, Sanic provides a `version_prefix`
    argument in all of the same places that `version` can be used. The default value
    is `/v`, but feel free to update it as needed. In the following example, we can
    nest our entire API design in a single blueprint group to automatically add `/api`
    to the front of every endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The same path parameters are available here. You could, for example, do something
    like this: `version_prefix=/<section>/v`. Just make sure you remember that `section`
    will now be an injected keyword argument into every route handler.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You should now have a good grasp of how and when to use versions. They are
    a powerful tool in making your API more professional and maintainable since they
    allow for more flexible development patterns. Next, we will explore another tool
    for creating flexibility and reusability of your application code: virtual hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some applications can be accessed from multiple domains. This gives the benefit
    of having a single application deployment to manage, but the ability to service
    multiple domains. In our example, we will imagine that we completed the computer
    adventure game social media site. The API is truly something amazing.
  prefs: []
  type: TYPE_NORMAL
- en: It is so incredible in fact that both Alice and Bob have approached us about
    the opportunity to be resellers and to *white label* our application, or reuse
    the API for their own social media sites. This is a somewhat common practice in
    the Internet world where once provider builds an application, and other providers
    simply point their domain to the same application and operate as if it is their
    own. To achieve this, we need to have distinct URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '`mine.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alice.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bob.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these domains will be setup with their DNS records pointing to our application.
    This can work without any further changes inside the application. But what if
    we need to know which domain a request is serving, and do something slightly different
    for each one? This information should be available to us in the request headers.
    It should simply be a matter of checking the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This example may seem small and simple, but you can probably imagine how the
    complexity could increase. Remember earlier I stated how I like to keep the lines
    of code per handler to a minimum? This is certainly a use case where you can imagine
    the handlers could get very lengthy.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, what we are doing in this endpoint is host-based routing. Depending
    upon the incoming request host, we are routing the endpoint to a different location.
  prefs: []
  type: TYPE_NORMAL
- en: Sanic already does that for us. All we need to do is break the logic into separate
    route handlers and give each one a `host` argument. This achieves the routing
    that we need, but keeps it out of our response handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself in this situation, you do not need to define a `host` for
    every endpoint. Only the endpoints where you would want to have host-based routing.
    Following this pattern, we can reuse the same application across multiple domains,
    and still have some endpoints capable of distinguishing between them, and others
    ignorant to the fact that multiple domains are reaching it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that is important to keep in mind: if you create an endpoint that
    has host level routing, then all routes on that same path must also have it. You
    cannot, for example, do the following. Notice how the third route does *not* define
    the `host` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will *not* work, and will raise an exception at startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To solve this, make sure that all routes that could be grouped together have
    a `host` value. This way they can be distinguished. If one of them has a `host`,
    they all need to have one.
  prefs: []
  type: TYPE_NORMAL
- en: We have generally now discussed all of the considerations to make when routing
    web requests to our response handlers. But, we have not yet looked at how Sanic
    delivers requests to static content (that is, actual files on your webserver that
    you want to send like images and stylesheets). Next, we will discuss some options
    both with and without using Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far all of our discussion in this chapter has been about dynamically generating
    content for responses. We did, however, discuss that passing files that exist
    inside of a directory structure is a valid use case that Sanic supports. This
    is because most web applications have a need for serving some static content.
    The most common use cases would be for delivering Javascript files, images, and
    style sheets to be rendered by the browser. Now, we are going to dive into static
    content to see how that works, and we can deliver this type of content. After
    learning how Sanic does it, we will see another very common pattern to serve the
    content outside of Sanic with a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static content from Sanic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `app` instance has a method on it called `app.static()`. That method requires
    two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A URI path for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path to tell Sanic where it can access that resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That second argument can either be a single file, or a directory. If it is a
    directory, everything inside of it will be accessible like the old school web
    servers we talked about at the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is very helpful if you plan to serve all of your web assets. What if you
    have a folder structure like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use Sanic to serve all of those assets and make them accessible like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.static("/static", "./assets")`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Those assets are now accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ curl localhost:7777/static/css/styles.css`'
  prefs: []
  type: TYPE_NORMAL
- en: Serving static content with Nginx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have seen how to serve static files with Sanic, a good next question
    is: should you?'
  prefs: []
  type: TYPE_NORMAL
- en: Sanic is very fast at creating the sort of dynamic endpoints that are required
    by most web APIs. It even does a pretty good job serving static content, keeps
    all of your endpoint logic in one application, and even allows for manipulating
    those endpoints or renaming files. As we discussed in *Chapter 1*, *Introduction
    to Sanic and async frameworks* Sanic applications are also meant to be fast to
    build.
  prefs: []
  type: TYPE_NORMAL
- en: There is however a potentially faster method for delivering static content.
    For a single-page application that is meant to be consumed by a browser that requests
    data through your API, one of your biggest stumbling blocks will be reducing the
    time to your first page render. This means that you must package up all of your
    JS, CSS, image, or other files as quick as possible to the browser to reduce rendering
    latency.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you might want to consider using a proxy layer like Nginx in
    front of Sanic. The purpose of the proxy would be to (1) send any requests to
    the API through to Sanic, and (2) handle serving static content itself. You may
    want to consider this option especially if you intend to serve a lot of static
    content. Nginx has a caching engine built in to be able to deliver static content
    much faster than any Python application could.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Running a server* discusses deployment strategies and considerations
    to make when deciding whether to use tools like Nginx and Docker. For now, we
    will use Docker Compose to really quickly and easily stand up Nginx.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make our `docker-compose.yml` manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are not familiar with Docker Compose or how to install and run it, you
    should be able to find a wealth of tutorials and information online.This simple
    setup we are going for in our example will require that you set the path for `./static`
    in our `docker-compose.yml` file to whatever directory you have your static assets
    in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is intentionally a super simple implementation. You should make sure that
    a real Nginx deployment includes things like TLS encyption and proxy secrets.
    Checkout the User Guide for more details and a helpful walkthrough. [https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration](https://sanicframework.org/en/guide/deployment/nginx.html#nginx-configuration)
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we will create the .`/nginx/default.conf` file needed to control Nginx.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start it using the following command:`$ docker-compose up`The most important
    thing to change here is the server address. You should change `1.2.3.4:8000` to
    whatever address and port your application can be accessed at. Keep in mind that
    this will *NOT* be `127.0.0.1` or `localhost`. Since Nginx will be running inside
    of a Docker container, that local address would point to the container itself,
    and not your computer’s local network address. Instead, for development purposes,
    you should consider setting it to your local IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 3, you will need to make sure that Sanic knows to serve on that network
    address. Do you remember how we said we are running Sanic back in Chapter 2 Like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this example, we will change that to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'My local IP address is `192.168.1.7`, therefore I will set the `upstream` block
    in my Nginx configuration to: `server 192.168.1.7:7777;`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Step 4, you should now be able to access any static files in your `./static`
    directory. I have a file called `foo.txt.` I am using the `-i` flag with `curl`
    to be able to see the headers. The important header to see is the `Expires` and
    `Cache-Control`. These help your browser to cache the file instead of re-requesting
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you try to send a request to a file that does not exist, Nginx will send
    that route on to your Sanic application. This setup really just touches the tip
    of the iceberg when it comes to proxying and Nginx. It is, however, very common
    for Python web applications to use a strategy like this. As mentioned earlier,
    we will dig in deeper to this topic when we discuss deployment options in Chapter
    8.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming Static Content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also worth reiterating that the Sanic server is built and intended to
    be a front line server. That means that it can certainly stand as your point of
    ingress without a proxy server in front of it, including serving static content.
    The decision about whether to proxy or not—at least as it relates to delivering
    static files—is likely a question of how much traffic, and how many files your
    application may need to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor to consider is whether your application needs to stream
    files. Streaming will be discussed in depth in Chapter 5\. Let’s create a real
    simple web page to stream a video and see what that might look like.
  prefs: []
  type: TYPE_NORMAL
- en: First the HTML. Store this as `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, find an `mp4` file that you want to stream. It can be any video file.
    If you do not have one, you can download a sample file for free from a website
    like this: [https://samplelib.com/sample-mp4.html](https://samplelib.com/sample-mp4.html).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now create a small Sanic app to stream that video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the server as normal and visit it in your web browser: [http://localhost:7777](http://localhost:7777)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should notice that the root URI (`/`) redirected you to `/index.html`. Using
    `app.static`, the application tells Sanic that it should accept any requests to
    `/index.html` and serve back the static content that is located on the server
    at `/path/to/index.html` . This should be your delivered content from above. Hopefully
    you have a play button, and you can now stream your video to your browser. Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This Chapter covers a lot of material on taking an HTTP request and turning
    it into something usable. At the core of a web framework is its ability to translate
    the raw request into an actionable handler. We have learned about how Sanic does
    this and how we can use HTTP Methods, good API design principles paths, path parameter
    extraction, and static content to build useful applications. As we learned earlier
    in this book, a little bit of up front planning goes a long way. Before putting
    too much code together, it is really helpful to think about the tools HTTP offers,
    and how Sanic allows us to take advantage of those features.
  prefs: []
  type: TYPE_NORMAL
- en: If we did a good job in Chapter 2 of setting up directories, it should be very
    easy for us to loosely mirror that structure and nest Blueprints to match our
    intended API design.
  prefs: []
  type: TYPE_NORMAL
- en: There are some key takeaways from this Chapter. You should purposely, and thoughtfully
    design your API endpoint paths—using nouns—that point to an intended target or
    resource. Then, HTTP Methods should be used as the verbs that tell your application
    and users *what* to do with that target or resource. Finally, you should extract
    helpful information from those paths to be used in your handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mainly focused our attention on that first line of the raw HTTP request:
    the HTTP Method and URI path. In the next chapter, we will dive into extracting
    more data from the request including the headers and the request body.'
  prefs: []
  type: TYPE_NORMAL
