- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic Data Viewing with SciView and Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue our scientific voyage through the exploration
    of two vital features of PyCharm: **SciView** and integration with **Jupyter notebooks**.
    Both features give us integrated and usable interfaces, allowing us to view and
    work with data and variables in our science projects.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by discussing the SciView panel, which was introduced tacitly in
    the last chapter. Here, we’ll be going into more depth and realism by working
    with NumPy arrays and pandas DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll evolve our workflow even further to include coverage of working
    with interactive Python computing tools such as Jupyter notebooks within the context
    of our scientific projects in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should have gained understanding in the following
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and interacting with data in the SciView panel in PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integration of **Interactive Python** (**IPython**) within PyCharm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jupyter notebook support for interactive programming within a PyCharm
    scientific project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the time you’re flipping the page to the next chapter, you’ll be armed with
    the knowledge needed to wield the two most important weapons in the war to tame
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we’ve switched to the topic of data science, I’ve switched my preferred
    Python distribution to Anaconda, which is a Python distribution tailored to data
    science workloads. You can find it, along with installation instructions for your
    operating system, at [https://anaconda.com](https://anaconda.com).
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, instead of the usual `pip`, I’ll be leveraging `conda`, which is Anaconda’s
    package manager. It is installed alongside Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need an installed and working copy of PyCharm. Installation was covered
    in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*,
    in case you are jumping into the middle of the book.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also need this book’s sample source code from GitHub. We covered cloning
    the code in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and
    Configuration*. You’ll find this chapter’s code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-13](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-13).
  prefs: []
  type: TYPE_NORMAL
- en: Data viewing made easy with PyCharm’s SciView panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took a 10,000-foot view of the SciView panel in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298),
    so we know what’s coming. We know SciView is a panel that allows us to visualize
    our data graphically, alongside a second panel that allows us easy and integrated
    access to documentation for the more complex data science libraries at play in
    a typical scientific project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see this magic in action, we’re going to revisit some code we wrote
    back in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), with a small enhancement.
    Rather than having you go back into the code for [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298),
    I’ve copied the project into the [*Chapter 13*](B19644_13.xhtml#_idTextAnchor318)
    folder in the repository so everything is together. You can find it in the `chapter-13/sci_view_panel`
    project within the `main.py` file. Don’t forget you’ll need to install the requirements
    within the `requirements.txt` file in a virtual environment in order to use the
    sample project. If you need a refresher on how to do this, refer back to [*Chapter
    3*](B19644_03.xhtml#_idTextAnchor052):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’ll recognize what this does from the last chapter. The code generates two
    sample sets of data and then plots the results as a histogram. The difference
    is that we’ve added `for _ in range(5)`. It’s the same code; we’re simply running
    it five times in succession, which will generate five different histograms.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and working with plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this example, you should take advantage of the ability to run your code
    in the console. The setting for this is probably already ticked, but you can double-check
    in the default run configuration as shown in *Figure 13**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: The pointed-to setting indicates this code will run in the console
    window, which is frequently used in scientific projects](img/B19644_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: The pointed-to setting indicates this code will run in the console
    window, which is frequently used in scientific projects'
  prefs: []
  type: TYPE_NORMAL
- en: You saw this plot in the graph in the previous chapter, but take a look at the
    results for this run in *Figure 13**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: The SciView window shows us the latest plot but also allows
    us to pick the plots from the other runs](img/B19644_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: The SciView window shows us the latest plot but also allows us
    to pick the plots from the other runs'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can already see a difference: there are five plots this time. Clicking
    each plot will change the histogram that changes in the viewer. This is an improvement
    over normal Python runs since the plot view would normally block execution while
    it displayed the histogram. You can normally only view one at a time, and the
    next is only generated when you hit the *Q* key to quit the current plot.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the default functionality, PyCharm grabbed all your plots to save
    you from having to individually export each image by hand. This is a huge time
    saver! You also have the option to zoom in and out using the toolbar at the top
    of the panel, remove the plot from view using the **X** button to the right of
    its icon, save the plot to an image file, or remove all the plots from view by
    right-clicking on the plot icon, as shown in *Figure 13**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: PyCharm gives you many options for working with plots](img/B19644_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: PyCharm gives you many options for working with plots'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the ability to save the graphs that interest you, your viewer
    has some viewing options, such as the ability to zoom in, which is indicated by
    the arrow in the preceding figure.
  prefs: []
  type: TYPE_NORMAL
- en: Heatmaps and correlational data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PyCharm is able to color heatmap plots to help you easily spot correlations
    within a correlation matrix. To see this, let’s generate some data that will have
    some data points that are correlated and some that are not. You’ll find a file
    in the chapter source called `correlation_heatmap.py`. The substance of the code
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code contains cell separators delineated by `#%%` characters.
    We covered the special meaning of these characters to PyCharm in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298).
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we are creating a `x`, `y`, and `z`) that are randomly generated.
    We’re adjusting these random numbers between `x`, `y`, and `z` so that there will
    be some level of correlation between them. Then, we compute the correlation matrix
    of this dataset using the `corr()` method. Finally, we display this correlation
    matrix as a heatmap using the `matshow()` method from Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: On the theoretical side, a correlation matrix tells us how much an attribute
    in each dataset is correlated to another. A higher value means a higher correlation
    between a pair of attributes. Generally, knowing which attributes are highly correlated
    to each other will offer valuable insights into the dataset of a data science
    project.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this point, we generate the `y` attribute to be roughly two times
    the size of the `x` attribute, creating a correlation between these two attributes.
    The `z` attribute, on the other hand, is generated randomly and independently
    from `x` and `y`, so there should not be a high correlation between `z` and either
    of the other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The project should have a run configuration called `correlation`. The settings
    for the run configuration are shown in *Figure 13**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: This is the run configuration for the correlation_heatmap.py
    file](img/B19644_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: This is the run configuration for the correlation_heatmap.py file'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, it is important that we check the **Run with Python Console** checkbox.
    Go ahead and run the file and view the plot result. Mine is in *Figure 13**.5*.
    Since the data is random, yours may appear differently than mine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: Correlational heatmaps are rendered using colors to indicate
    the level of correlation within the correlational matrix](img/B19644_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: Correlational heatmaps are rendered using colors to indicate the
    level of correlation within the correlational matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is printed in black and white, I’ve tried to do you a solid
    here by adding letters to indicate the colors. This isn’t a feature of the graph.
    The cells labeled **Y** are yellow. **G** is for green and **P** is for purple.
    The first and second attributes are highly correlated, so the color in the corresponding
    cells in the correlation matrix (row 1 column 2 and row 2 column 1) is bright
    (yellow or green, each of similar brightness). The correlation between the third
    attribute with the other two is low, indicated by a dark purple color. Naturally,
    each attribute is perfectly correlated with itself, hence the bright yellow or
    green color in the diagonal cells.
  prefs: []
  type: TYPE_NORMAL
- en: The visual ramifications here are very helpful. When working with correlation
    matrices, we can instantly see the relationships between our variables.
  prefs: []
  type: TYPE_NORMAL
- en: The **Plots** tab in SciView gives us a lot of great tools we can use to view
    and manage plots in our data science projects. Note, too, that there are two tabs
    shown in *Figure 13**.2* (circled) at the top of the SciView panel. We’ll talk
    about the **Data** tab next.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and working with data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you click on the **Data** tab, you might be a little underwhelmed. As you
    can see in *Figure 13**.6*, the real action is further down in the debugger window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Nothing shows up in the Data tab until you select one of the
    sample sets to view as an array](img/B19644_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: Nothing shows up in the Data tab until you select one of the sample
    sets to view as an array'
  prefs: []
  type: TYPE_NORMAL
- en: Shift your attention to the `N`, this panel is sufficient. However, if you are
    using NumPy arrays, as we are, viewing the array in the context of a normal debugger
    window like this one is problematic.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the **View as Array** link, which can also be activated by right-clicking
    the variable, you can see a spreadsheet-like table in the **Data** panel. Check
    out *Figure 13**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Having selected the X variable in the lower panel, the Data
    tab now displays the elements of the NumPy array within X](img/B19644_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Having selected the X variable in the lower panel, the Data tab
    now displays the elements of the NumPy array within X'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `X`, and so I see `X` displayed as a long row of colored
    data. I can scroll to the right and inspect all 100 elements. Cells with high
    values are filled with warmer colors, while the ones with low values are filled
    with cooler colors. This provides you with contrast so you can visually detect
    differences between values without squinting at the decimal place.
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost arrow in *Figure 13**.7* shows you that `X` in the textbox above
    relates to `X` in the window below. You can change the value in the textbox to
    `Y`, or any other valid variable name present in the lower console, and see the
    data represented more graphically above. The key here is the word *valid*. The
    `N` variable will display an error in the **Data** tab.
  prefs: []
  type: TYPE_NORMAL
- en: To the right of the textbox is the formatter. This allows you to specify how
    the numbers in the **Data** tab appear. The formatting string uses the same format
    as normal Python string formatting.
  prefs: []
  type: TYPE_NORMAL
- en: When you select multiple variables in the console view, each variable will be
    displayed in its own tab as shown in *Figure 13**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: Picking multiple variables in the console will open a tab for
    each variable in the Data tab](img/B19644_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: Picking multiple variables in the console will open a tab for
    each variable in the Data tab'
  prefs: []
  type: TYPE_NORMAL
- en: Just remember, this only works for NumPy arrays and pandas DataFrames. This
    data is a little boring since there’s just one row. Let’s try something a little
    spicier, so we can see more of the features in the **Data** tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the chapter code, you’ll find a file called `meteor.py` that only has two
    lines in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This data comes from the **National Aeronautical and Space Administration**
    (**NASA**) in the United States. You’ll find it, along with thousands of other
    freely available datasets, at [https://data.gov](https://data.gov), all courtesy
    of me personally, since I pay a lot in taxes. Sure, others helped, but at least
    once per year, it feels like it is all up to me.
  prefs: []
  type: TYPE_NORMAL
- en: The data file contains NASA’s data on meteorite landings. Specifics can be found
    at [https://catalog.data.gov/dataset/meteorite-landings](https://catalog.data.gov/dataset/meteorite-landings).
  prefs: []
  type: TYPE_NORMAL
- en: There should be a run configuration for `meteor_data.py` in the project from
    the repository, but just in case, my settings are in *Figure 13**.9*. If you need
    a refresher on run configurations, we covered this topic in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: This is the run configuration settings dialog for the meteor.py
    file. Be sure that Run with Python Console is checked](img/B19644_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: This is the run configuration settings dialog for the meteor.py
    file. Be sure that Run with Python Console is checked'
  prefs: []
  type: TYPE_NORMAL
- en: As before, the key here is to make sure the file runs in **Python Console**
    so you get the panel view needed for SciView. Go ahead and run the file. You can
    see the result of my run in *Figure 13**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: My run of the meteor data has to be squished and stretched
    so you can see everything](img/B19644_13_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: My run of the meteor data has to be squished and stretched so
    you can see everything'
  prefs: []
  type: TYPE_NORMAL
- en: I had to seriously drag panels around to get it all to fit in the screenshot.
    Note that, this time, the button indicated by the arrow says **View as DataFrame**
    since this time we used pandas instead of NumPy. I’ve clicked it and the **Data**
    tab has loaded the DataFrame for viewing.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering in the Data tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The meteor dataset is a little more realistic. It contains a lot of values and
    it might make sense to filter on some of the fields. PyCharm gives you the ability
    to filter the data appearing in the data tab using either a wildcard or an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with a wildcard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Figure 13**.11*, you can see I am hovering over the `name` column in the
    **Data** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: Hovering over a column reveals a filter icon, which resembles
    a funnel](img/B19644_13_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: Hovering over a column reveals a filter icon, which resembles
    a funnel'
  prefs: []
  type: TYPE_NORMAL
- en: When I do this, a filter icon appears. Click that icon to bring up your filtering
    options as seen in *Figure 13**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: You can filter by expression or by substring (wildcard)](img/B19644_13_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: You can filter by expression or by substring (wildcard)'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `Bal`. You can see mine in *Figure 13**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: We’re filtering the name column to show all names with the
    characters Bal somewhere in the name](img/B19644_13_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: We’re filtering the name column to show all names with the characters
    Bal somewhere in the name'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the trashcan icon lets you remove the filter. While the substring
    filter can be useful, the expression filter is far more powerful and precise.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering with expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using expressions, you can be a little more selective. Meteors are pretty cool,
    but nobody is impressed by a tiny pebble. For example, let’s filter meteors larger
    than 10kg in *Figure 13**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14: Filtering on the mass column where x (the value in the column)
    is greater than 10,000](img/B19644_13_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: Filtering on the mass column where x (the value in the column)
    is greater than 10,000'
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few! Now let’s filter to more recent strikes by filtering
    to only those occurring from the year 2010 onward. Mine is in *Figure 13**.15*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15: Limit data to just meteor strikes during and after 2010](img/B19644_13_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.15: Limit data to just meteor strikes during and after 2010'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there are not as many, and the data ends with only one strike in
    2013\. As coincidence would have it, that’s the last year I paid my income taxes
    on time. I told you it was all me.
  prefs: []
  type: TYPE_NORMAL
- en: Dear Internal Revenue Service
  prefs: []
  type: TYPE_NORMAL
- en: That last line is what we in the writing biz call “a joke.” I know this is a
    foreign concept to you all, but trust me, everybody else laughed.
  prefs: []
  type: TYPE_NORMAL
- en: I am so getting audited.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, another thing we can see through our filtering experiment is there is
    missing data in the `reclat`, `reclong`, and `GeoLocation` fields. These were
    no doubt recorded in Area 51 where geolocation data is illegal. Nevertheless,
    this can be a quick way to check your data for anomalies as part of creating a
    data pipeline, which we’ll be covering in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting to files or new tabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take a look at the top of the **Data** tab in *Figure 13**.16*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16: You can export your data or pop it out into a new tab in the
    editor window](img/B19644_13_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.16: You can export your data or pop it out into a new tab in the
    editor window'
  prefs: []
  type: TYPE_NORMAL
- en: The `.csv` or `.tsv` file. This is pretty straightforward, so I think you can
    live without a screenshot. You can also pop the contents of your data tab in SciView
    into the regular tab in your editor view. I’ve done this in *Figure 13**.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17: I’ve popped the SciView Data tab contents into a tab in the
    main editor window](img/B19644_13_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.17: I’ve popped the SciView Data tab contents into a tab in the main
    editor window'
  prefs: []
  type: TYPE_NORMAL
- en: All totaled, the **Data** tab in SciView contains a lot of useful features for
    performing explorations on your data, whether it be raw, as with the meteor data,
    or generated through calculation, as with our earlier random set. When you combine
    this graphical way to view input and output data with PyCharm’s cell mode described
    in the last chapter, you start to see the power of the data science tools in PyCharm.
    They are just a few simple panels, but there is so much we can do with them!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IPython and magic commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IPython** is an enhanced interactive shell for the Python programming language.
    It provides a more feature-rich and user-friendly environment compared to the
    default Python interactive interpreter. IPython was developed to make interactive
    computing and data analysis tasks more convenient and efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: When working with IPython beyond the confines of PyCharm, you’ll find some features
    you won’t find in any standard console or REPL environment. The shell experienced
    is heavily enhanced to support features you’d expect within PyCharm, such as tab
    completion, syntax highlighting, and history navigation.
  prefs: []
  type: TYPE_NORMAL
- en: The tool allows for an array of rich display options. Imagine a command-line
    interface that includes the ability to work with images, videos, audio, and interactive
    widgets directly within the interactive environment. Obviously, you can execute
    Python code in the form of snippets, expressions, or entire scripts, and you do
    all of this in an interactive fashion.
  prefs: []
  type: TYPE_NORMAL
- en: IPython also makes it easier to work in a distributed compute environment. As
    you may know, threaded computing is effectively disabled in most mainline Python
    interpreters owing to the **Global Interpreter Lock** (**GIL**). The GIL is a
    mechanism in the CPython interpreter, the most widely used implementation of Python.
    The GIL is a mutex (or a lock) that only allows one thread to execute in the interpreter
    at a time, even on multi-core systems. This means that in a multithreaded Python
    program, only one thread can execute Python bytecode at any given moment, regardless
    of how many CPU cores are available.
  prefs: []
  type: TYPE_NORMAL
- en: The GIL was introduced to simplify memory management and avoid potential conflicts
    that could arise from multiple threads accessing and modifying Python objects
    concurrently. While the GIL ensures that Python memory management remains simpler
    and safer, it also has implications for multithreaded programs insofar as Python
    programs tend to struggle to actually utilize all the compute resources available
    on a system that supports multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: While IPython doesn’t have any secret sauce that defeats the GIL limitation,
    it does provide a module called `ipython.parallel` that makes it easy to work
    with parallel compute resources. You can create clusters of IPython engines that
    can run code in parallel across multiple processes or even multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: IPython seems like something we should be very interested in, given that it
    is obviously a powerful tool that more fully enables a mode of enriched stepwise
    data interaction that is the modus operandi of modern data science workflows.
    The standing question then is, how can we leverage IPython within PyCharm?
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing IPython is done like any other Python library. You can use `pip install
    ipython` from PyCharm’s terminal, or you can use the package management screen
    we’ve been working with since [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052).
    *Figure 13**.18* shows me about to install using the **Python Packages** panel
    in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18: I’ve searched for ipython in the Python Packages pane and I’m
    about to install it to my project using conda](img/B19644_13_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.18: I’ve searched for ipython in the Python Packages pane and I’m
    about to install it to my project using conda'
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to work with IPython often, you might consider installing this one
    globally so it is available to all your projects. You’d do this by simply installing
    IPython outside the confines of a virtual environment using `pip`, `conda`, or
    whichever tool you prefer for package management.
  prefs: []
  type: TYPE_NORMAL
- en: Once IPython is available, PyCharm will use it owing to the default settings
    in the IDE’s **Build, Execution, Deployment** settings, as shown in *Figure 13**.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19: By default, PyCharm will use IPython for its console if it
    is available](img/B19644_13_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.19: By default, PyCharm will use IPython for its console if it is
    available'
  prefs: []
  type: TYPE_NORMAL
- en: We covered settings in great detail in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    so if you’ve skipped to this chapter and you’re not sure how to get to the settings,
    go review the earlier chapter. Once IPython is available in your project, you
    need to close or cycle any consoles that might be open. So far, we’ve run three
    programs that we intentionally set to run in the console, so you won’t see any
    change to those since they were running before we installed IPython. *Figure 13**.20*
    shows you what an IPython prompt looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20: The IPython prompt appears after I close or restart my existing
    console](img/B19644_13_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.20: The IPython prompt appears after I close or restart my existing
    console'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 13**.20*, I’ve drawn an arrow to remind you how to open the console,
    if it isn’t already open. If you don’t see that icon, try clicking the three-dot
    icon above the arrow. If you still can’t find it, review [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028)
    where we talk about working with the console for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned, if you already have consoles open, they need to be restarted.
    I’ve circled the button for this in *Figure 13**.20*. When the console is restarted,
    you should see a different prompt beginning with the word `In`, in contrast to
    the normal prompt, which displayed `>>>` symbols. Following the word `In`, you’ll
    see some square brackets containing a number. In *Figure 13**.20*, it’s showing
    `2`. This number indicates the order of commands entered so far. If you look at
    the top of the new IPython console, you’ll see a few commands were entered automatically,
    which import the `sys` library, print out the Python version, and extend our path.
    That’s three commands, but remember we start at `0`. The next command you enter
    will be the fourth command and will be labeled as `3`.
  prefs: []
  type: TYPE_NORMAL
- en: If PyCharm were a video game, installing IPython would be like unlocking the
    super gun, sword, or magic power you can use to vanquish your unwitting and utterly
    unprepared foes. If this is your first time, you probably can’t wait to explode
    some data zombies, so let’s take a look at IPython’s magic commands. Hyperbole
    aside, *magic commands* are literally what they are called!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing IPython magic commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In IPython, a `%` (for line magics) or `%%` (for cell magics) symbol and is
    used within an IPython session or Jupyter notebook cell. These magic commands
    provide shortcuts for performing various tasks, from running code with specific
    options to interacting with the environment or controlling IPython’s behavior.
    Magic commands are a convenient way to execute common operations without writing
    extensive code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of magic commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%` symbol and are used on a single line. They typically take arguments and
    options to modify their behavior. For example, `%run script.py` can be used to
    run an external script within the IPython session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%%` and are used at the beginning of a cell. They allow you to affect the
    entire cell’s content. For example, `%%time` can be used to measure the execution
    time of the entire cell’s code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few common examples of magic commands you’ll use daily:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%run script.py`: Runs an external Python script in the IPython session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%timeit`: Measures the execution time of a Python statement or expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%matplotlib inline`: Configures `matplotlib` to display plots directly in
    the notebook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%%writefile filename.txt`: Writes the contents of a notebook cell to a file
    named `filename.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%load_ext extension_name`: Loads a specific IPython extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%%html`: Renders the content of a cell as HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%reset`: Resets the namespace by removing all names defined by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object_name?`: Don’t take me literally on this one. You don’t type *object_name?*.
    Instead, you type the name of an object you’ve instantiated. Maybe we should just
    do this in just a moment, so you understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, you’re starting to smell what we’re cooking up here. We’ve seen cell
    mode in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), but now, with IPython,
    there is a lot more we can do with a cell using these magic commands. Like any
    good magic spell from the movies, there is just enough cryptic but short syntax
    to learn, which adds to the mystique and makes you feel just a little more elite
    than your non-magic-using colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try a few out, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: In your IPython console, type `a = 1`. Now, let’s try the `object_name?` magic.
    You don’t type *object_name?*; instead, you type `a?`. The name of the object
    is `a` and you follow it with a question mark as if you were Canadian or Australian.
    Whatever object name you use, assuming it is valid, you’ll get back information
    about that object. You can see my result in *Figure 13**.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21: How’s it goin, a?](img/B19644_13_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.21: How’s it goin, a?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve learned a lot about `a`, eh? Okay, eh, let’s try another one. Type `%precision
    4`. The result should be `''%.4f''`. This tells us we’ve set our session to four
    decimals of precision. Let’s test that by typing in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Lowercase `e` is a reference to `e` to 10 places is 2.7182818285\. We, though,
    are set for 4 decimal places of precision, so the result from IPython should show
    `2.7183`, as shown in *Figure 13**.22*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22: Having set our precision to four decimal places, we can see
    the constant e is rendered properly](img/B19644_13_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.22: Having set our precision to four decimal places, we can see the
    constant e is rendered properly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try one more. The `%%timeit` magic is very useful during the creation
    of algorithms. Algorithms are simply repeatable sets of instructions; however,
    in order to be useful, an algorithm needs to be efficient. Efficiency is judged
    by two vectors: time needed to complete and space required to work. For example,
    the **National Health System** (**NHS**) in England has devised an algorithm that
    matches organ donors to recipients based on a number of complicated factors. It
    is meant to match an organ to a donor in a way that minimizes risks of tissue
    rejection, among other factors. As you can imagine, this is a complicated algorithm
    that has to operate against a dataset containing thousands of registered donors
    and thousands of registered recipients. When an organ becomes available, it has
    a limited shelf life. If the matching algorithm takes too long to generate a match,
    the organ becomes unviable for transplant, and the algorithm is effectively useless.
    We covered profiling in [*Chapter 6*](B19644_06.xhtml#_idTextAnchor145), but this
    was really meant for software engineering workflows to help find bottlenecks in
    execution.'
  prefs: []
  type: TYPE_NORMAL
- en: In data science, we’re operating outside the confines of a typical software
    project, so it makes sense to time individual steps to at least gain some insight
    into how a step of our calculations might scale. Even if our objective isn’t to
    create an algorithm, we still have to deal with practical limitations on time
    and compute space (such as memory and storage) in our regular exploratory work.
  prefs: []
  type: TYPE_NORMAL
- en: The `%%timeit` magic then becomes an integral part of our work. Now that I’ve
    spent all this time building up a huge example, let’s try it out with something
    laughably trivial in *Figure 13**.23*.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.23: We’re trying out %\uFEFF%timeit with a simple sort to find\
    \ the operation completes in around 318 ns](img/B19644_13_023.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.23: We’re trying out %%timeit with a simple sort to find the operation
    completes in around 318 ns'
  prefs: []
  type: TYPE_NORMAL
- en: This truly was a trivial task. Start by typing `%%timeit` in the IPython console.
    When you press *Enter*, it takes you to the next line. In the second line, we’re
    creating a list with the numbers 0 through 9 in reverse order. On the last line,
    we’re sorting them back into their normal order. This is super boring! Hit *Enter*
    on the last blank line to run the code. Look at what `%%timeit` did! It could
    have just started a clock, run the script, then stopped the clock and reported
    the delta. Instead, `%%timeit` ran this code over and over to gain a sample size
    where it can compute a mean and standard deviation. This gives us better and more
    accurate insight into how long this code will take to run. Naturally, different
    computers will perform differently. For me, it ran in 318 nanoseconds plus or
    minus 3.44 nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have considered three of the most common magic commands in IPython.
    Of course, there are many other useful commands that you can take advantage of,
    which can be found in IPython’s official documentation: [https://ipython.readthedocs.io/en/stable/index.html](https://ipython.readthedocs.io/en/stable/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: With that said, the main purpose of IPython is not simply the ability to utilize
    convenient APIs to facilitate specific tasks such as variable inspection, formatting,
    or profiling—IPython actually uses those functionalities to power its underlying
    interactive characteristics. In the context of data science projects, IPython,
    when used in PyCharm, offers a great way for us to inspect and test small blocks
    of code before using them in a large program.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s move on to the next section, where we will consider the other
    notable support PyCharm offers for scientific computing—Jupyter notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Jupyter notebooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jupyter notebooks** are arguably the most-used tool in Python scientific
    computing and data science projects. In this section, we will briefly discuss
    the basics of Jupyter notebooks as well as the reasons why they are a great tool
    for data analysis purposes. Then, we will consider the way PyCharm supports the
    usage of these notebooks.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be working with the `jupyter_notebooks` project in the chapter source.
    Don’t forget you’ll need to install the requirements within the `requirements.txt`
    file in a virtual environment in order to use the sample project. If you need
    a refresher on how to do this, refer back to [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052).
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we will be writing code in Jupyter notebooks, it is beneficial
    to first consider a bare-bones program in a traditional Python script so that
    we can fully appreciate the advantages of using a notebook later on. Let’s look
    at the `main.py` file and see how we can work with it. We can see that this file
    contains the same program from the previous section, where we randomly generate
    a dataset of three attributes (`x`, `y`, and `z`) and consider their correlation
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is roughly the same code we used earlier in this chapter when we wanted
    to expose the heatmap features in PyCharm when reviewing a correlational matrix.
    Here, we have added the last two lines, which are different. Instead of a heatmap,
    this time we’re drawing a scatter plot. I explained earlier that we have intentionally
    and artificially introduced correlation into our otherwise randomly generated
    data. Examine where we set `y` and you’ll see we multiplied the matrix from `x`
    by 2, then added some small numbers from another random sample generation. This
    will make `y` appear to be roughly, but not exactly, correlated to `x` allowing
    us to see a plausible, though contrived, correlation matrix. This proves out when
    we run the file. My result is shown in *Figure 13**.24*. Don’t forget that our
    data is random, so yours will not precisely match mine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24: This is the scatter plot produced by our code](img/B19644_13_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.24: This is the scatter plot produced by our code'
  prefs: []
  type: TYPE_NORMAL
- en: Like I said, there’s nothing new or amazing here besides the change from a heatmap
    to a scattelot. We ran this as a point of comparison for our discussion of Jupyter
    notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Jupyter basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jupyter notebooks are built on the idea of iterative development. In any development
    effort regardless of what you are creating, breaking a large project into smaller
    pieces always yields rewards. Nobody at the Ford Motor Company just builds a car.
    They build millions of pieces that are later assembled into a car. Each piece
    can be designed, produced, tested, and inspected as individual pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, by separating a given program into individual sections that can be
    written and run independently from each other, programmers in general and data
    scientists specifically can work on the logic of their programs in an incremental
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of iterative development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most practitioners in the world of software development are used to the ideals
    behind agile methodologies. There are dozens of agile frameworks designed to help
    you manage software, or really, any project with the aim of creating some useful
    product. One thing they consistently have in common is the idea of iterative development.
    The development effort is broken down into smaller, simpler tasks called an iteration.
    At the end of each iteration, we should have some usable product. This is important!
  prefs: []
  type: TYPE_NORMAL
- en: You might think about making a car, but think truly about the research and development
    that went into the first cars. Our main concern at that time was to produce a
    vehicle to take us from point A to some distant point B in a manner that was faster
    and more efficient than using a domesticated animal.
  prefs: []
  type: TYPE_NORMAL
- en: We already know about the wheel, so let’s entertain at a somewhat comical level
    the process your average software developer might use if they were going to create
    the world’s first automobile. Remember, each iteration must produce some usable
    means of traveling from place to place. Our development team might start with
    a skateboard. This is something simple we could make in a short iteration. The
    next iteration might produce a scooter, the next a bicycle, the next might be
    a powered tricycle, then eventually, a rudimentary car. See *Figure 13**.25*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25: An iterative process realizes a goal one step at a time](img/B19644_13_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.25: An iterative process realizes a goal one step at a time'
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration produces a usable result, and we can point to this as continuous
    progress. At the end of each iteration, you should reflect upon the next because,
    with each iteration, your understanding of the final objective becomes clearer.
    You learn a lot from each iteration, and if you keep your iterations small, you
    have the flexibility to change direction when you discover you need to.
  prefs: []
  type: TYPE_NORMAL
- en: This happens all the time in traditional software development and in data science
    work. You may set out with a particular research objective in mind, but ultimately,
    you have to go where the data leads you rather than succumbing to your own bias.
    Iterative processes make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply this to the ideas behind Jupyter notebooks since these involve
    building up your work one cell, or iteration, at a time. During each iteration,
    you add or make the appropriate changes in the code cell that reads in the dataset
    and rerun the subsequent cells, as opposed to rerunning the code before it. As
    a tribute to its users, Jupyter notebooks were named after the three most common
    scientific programming languages: **Julia**, **Python**, and **R**.'
  prefs: []
  type: TYPE_NORMAL
- en: Another integral part of Jupyter notebooks is the support for the Markdown language.
    As we mentioned previously, at the beginning of the previous chapter, Markdown
    is a markup language that’s commonly used in `README.md` files in GitHub. Furthermore,
    because of its ability to work with LaTeX (which is typically used for writing
    mathematical equations and scientific papers in general), Markdown is heavily
    favored by the data science community.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how we can use a Jupyter notebook in a regular PyCharm project
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter notebooks in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this task, we will be translating the program we have in the `main.py` file
    into a Jupyter notebook so that we can see the interface that Jupyter offers compared
    to a traditional Python script. I’ll be leveraging my existing `jupyter_notebooks`
    project we started with. You can find it in the chapter’s sample code. If you
    don’t have that repository, we cover cloning it in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028).
    If you’d like to start from scratch, you can simply create a new scientific project,
    which was covered in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a notebook and adding our code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add a new Jupyter notebook in a PyCharm project, create it as though it were
    just a file. Click **File** | **New** | **Jupyter Notebook** as shown in *Figure
    13**.26*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26: Create a new Jupyter notebook using the File | New menu option](img/B19644_13_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.26: Create a new Jupyter notebook using the File | New menu option'
  prefs: []
  type: TYPE_NORMAL
- en: You are immediately prompted to name your notebook. I called mine `basic.ipynb`.
    The file was created in the root folder of my project, but I went ahead and dragged
    it into the `notebooks` folder. You can see my starting point in *Figure 13**.27*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27: My new notebook is ready!](img/B19644_13_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.27: My new notebook is ready!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by typing some documentation along with some known imports. At
    the prompt, type this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you type the last `#%%`, you’ll find PyCharm starts a new cell for you.
    In the second cell, let’s enter some of the code we had earlier in our illustrative
    Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I’ve explained this code earlier in this chapter, so I won’t do that again.
    As before, the last `#%%` will create a new cell. See *Figure 13**.28* to see
    what I have so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.28: I now have two cells containing our code from our earlier program](img/B19644_13_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.28: I now have two cells containing our code from our earlier program'
  prefs: []
  type: TYPE_NORMAL
- en: So far so good! I have my imports and a cell that generates my dataset for me
    just as I had in my Python script. I’ve been breaking my program up into small,
    iterative steps. First, my imports, then my dataset. Next, I can look at doing
    something with my data. We know from earlier discussions that this is going to
    be a correlative matrix. What if this is a university project, and our professor
    wants us to document the formulae we use? That’s probably a good idea even if
    you’re out of school. Let’s take a moment to look at a cool documentation feature
    we can use. We know we can have code cells. We can also have documentation cells
    that leverage not only Markdown but also LaTeX.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting with Markdown and LaTeX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Markdown is something we’ve already seen. It is a simple markup language that
    lets you create HTML-like documents, but instead of a rich set of tags, you use
    symbols to mark your documentation. Markdown only covers basics, such as headings,
    lists, and simple images. We covered the use of PyCharm’s integrated Markdown
    plugin in [*Chapter 12*](B19644_12.xhtml#_idTextAnchor298).
  prefs: []
  type: TYPE_NORMAL
- en: Working with Markdown in our notebooks allows us some simple formatting to enhance
    the look and readability of our notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX, which is pronounced “LAY-tech” or “LAH-tech," depending on where your
    math professor studied, is a typesetting convention used in the fields of science
    and mathematics. This kind of thing is needed in academic journals because you
    can’t very well type complicated formulas easily on a keyboard, and not many math
    professors can bust out Adobe Illustrator and do their own illustration work.
    Instead of a graphical tool, they instead invented a terse, hard-to-understand,
    and impossible-to-remember convention for marking up their formulas in their journal
    articles. Then they named it a common English word but insisted we all mispronounce
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it out!
  prefs: []
  type: TYPE_NORMAL
- en: First, I haven’t been totally up-front with you on how to create cells. Sure,
    you can just start typing stuff in, and using `#%%` to separate cells works just
    fine. You can also hover over the space between cells, or where the division would
    be if you’re at the top or bottom of the notebook. Check out *Figure 13**.29*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.29: You can hover in the space between cells to get a little GUI
    help with adding new cells](img/B19644_13_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.29: You can hover in the space between cells to get a little GUI
    help with adding new cells'
  prefs: []
  type: TYPE_NORMAL
- en: When you click these buttons between cells, it triggers a process of cell division
    called mitosis. Wait, no, that’s biology. It does split the cells by adding a
    new one between the two we have. I’m going to add a cell below my last one by
    hovering just below the last cell and clicking **Add Markdown Cell**. See *Figure
    13**.30*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.30: Hover above the last empty cell and click Add Markdown Cell](img/B19644_13_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.30: Hover above the last empty cell and click Add Markdown Cell'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a light blue cell without the IPython prompt. Since it’s a
    Markdown cell, PyCharm isn’t expecting code, so there’s no need for the prompt.
    Now, within the cell, type this absolute nonsense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is LaTeX markup syntax that will convey Pearson’s formula for correlation.
    Trust me, it will be quite impressive in just a moment when we run our notebook.
    Let’s go ahead and add our two plots from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new code cell below the last one and add this code for our heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add another code cell for our scattelot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our implementation of our code as a Jupyter notebook is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can execute the notebook by clicking the run button at the top of the notebook
    as shown in *Figure 13**.31*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.31: Run all the cells in the notebook using the double green arrow
    button](img/B19644_13_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.31: Run all the cells in the notebook using the double green arrow
    button'
  prefs: []
  type: TYPE_NORMAL
- en: This triggers a marvelous transformation in PyCharm. *Figure 13**.32* is a good
    starting place.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.32: We’ve run the notebook, which causes a lot of changes in the
    PyCharm UI](img/B19644_13_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.32: We’ve run the notebook, which causes a lot of changes in the
    PyCharm UI'
  prefs: []
  type: TYPE_NORMAL
- en: First, notice there is a new tool on the left sidebar for Jupyter. We can see
    we’ve started a Jupyter server running on port `8888`. If you were using Jupyter
    independently of PyCharm, this would be the normal mode of operation. You’d have
    run the Jupyter server from the command line and navigated to the notebook in
    your browser. PyCharm is replacing that experience within the IDE, but we still
    need to run the server to get the results.
  prefs: []
  type: TYPE_NORMAL
- en: If you scroll up, you’ll see the LaTeX markup has been rendered in our Markdown
    cell shown in *Figure 13**.33*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.33: The nonsense now looks absolutely stunning!](img/B19644_13_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.33: The nonsense now looks absolutely stunning!'
  prefs: []
  type: TYPE_NORMAL
- en: If you scroll down to inspect the scatterplot, we see… Well phooey! There’s
    an error! See *Figure 13**.34*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13:34: The error message shows us exactly what is wrong](img/B19644_13_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13:34: The error message shows us exactly what is wrong'
  prefs: []
  type: TYPE_NORMAL
- en: 'I messed up. I put parentheses alongside the DataFrame object, `df`. I need
    to take those off so it looks like it’s a neighbor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, I could rerun the whole notebook, but I don’t need to. The problem was
    in the last cell, so I could just put my cursor in the last cell and click the
    single green run arrow. See *Figure 13**.35*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.35: Yes, that’s much better!](img/B19644_13_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.35: Yes, that’s much better!'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up our coverage of Jupyter with a few odds and ends.
  prefs: []
  type: TYPE_NORMAL
- en: Odds and ends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At present, we’re running a Jupyter server. We saw a moment ago this created
    a new tool icon on the left side menu. Let’s click that and see what’s up. See
    *Figure 13**.36*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.36: The Jupyter panel opens and we can see the output from the
    running server on the Server tab](img/B19644_13_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.36: The Jupyter panel opens and we can see the output from the running
    server on the Server tab'
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling to the top of this window will reveal the local URL for the Jupyter
    server if you’d like to work with your notebook in the browser. But why would
    you do that when PyCharm is so much better?
  prefs: []
  type: TYPE_NORMAL
- en: Note the stop button that allows you to stop the running Jupyter server. Next
    to the **Server** tab is the **Variables** tab shown in *Figure 13**.37*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.37: The Variables tab in the Jupyter pane allows for deep inspection
    into variables within your notebook](img/B19644_13_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.37: The Variables tab in the Jupyter pane allows for deep inspection
    into variables within your notebook'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Variables** tab, you get the inspections that allow you to drill down
    into any variable within the notebook. Notice, too, that the **View as Array**
    and **View as DataFrame** options are there so you can also use the SciView panel
    to see and filter your array contents.
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t really talk much about the toolbar at the top of the notebook tab,
    as shown in *Figure 13**.38*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.38: Controls for manipulating cells in your notebook](img/B19644_13_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.38: Controls for manipulating cells in your notebook'
  prefs: []
  type: TYPE_NORMAL
- en: There is a set of tools for cutting, copying, and pasting your cells (**1**).
    The arrows at (**2**) allow you to reorder the cells in the notebook by shifting
    them up or down. There is a broad set of run and debug tools at (**3**) that you
    no doubt recognize as a common theme.
  prefs: []
  type: TYPE_NORMAL
- en: The broom icon will clear the output from a cell, which is handy if you’re working
    on salary projections based on the raise you’re about to ask for just as your
    boss walks up behind you. The trashcan deletes a cell entirely. There is also
    a dropdown here, marked **Code**, that allows you to change the type of cell,
    maybe from a code cell to a markup cell, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: We have gone through the main features of PyCharm in the context of Jupyter
    notebooks. In general, one of the biggest drawbacks of using traditional Jupyter
    notebooks is the lack of code completion while writing code in individual code
    cells. Specifically, when we write code in Jupyter notebooks in our browser, the
    process is very similar to writing code in a simple text editor with limited support.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we work with Jupyter notebooks directly inside the PyCharm editor,
    we will see that all the code-writing support features that are available to regular
    Python scripts are also available here. In other words, when using PyCharm to
    write Jupyter notebooks, we get the best of both worlds—powerful, intelligent
    support from PyCharm and an iterative development style from Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python programmer typically works on a data science project in two ways—writing
    a traditional Python script or using a Jupyter notebook, both of which are heavily
    supported by PyCharm. Specifically, the SciView panel in PyCharm is a comprehensive
    and dynamic way to view, manage, and inspect data within a data science project.
    It offers a great way for us to display visualizations that have been produced
    by Python scripts as well as to inspect the values within pandas DataFrames and
    NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Jupyter notebooks are a great tool for facilitating iterative
    development in Python, allowing users to make incremental steps toward analyzing
    and extracting insights from their datasets. Jupyter notebooks are also well supported
    by PyCharm, being able to be edited directly inside the PyCharm editor. This allows
    us to skip the middle step of using a web browser to run our Jupyter notebooks
    while being able to utilize the powerful code-writing support features that PyCharm
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: By going in depth into what PyCharm helps with regarding the process of viewing
    and working with data, either via the SciView panel or with Jupyter notebooks,
    we have learned how to use PyCharm to facilitate various data science tasks in
    Python. With this, we have equipped ourselves with enough knowledge and tools
    to tackle real-life projects using PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will combine all the knowledge we have learned so far
    regarding the topic of data science and scientific computing and walk through
    the process of building a data science pipeline in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What two main features does the SciView panel contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of using the plot viewer in the SciView panel when multiple
    visualizations are generated by a Python program?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of data structures does the data viewer in the SciView panel support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the idea of iterative development and how do Jupyter notebooks support
    that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Markdown and LaTeX? Why is it beneficial to have support for them in
    Jupyter notebooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is a Jupyter code cell represented in the PyCharm editor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of writing Jupyter notebooks in the PyCharm editor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
