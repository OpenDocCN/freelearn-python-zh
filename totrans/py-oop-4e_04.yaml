- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expecting the Unexpected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Systems built with software can be fragile. While the software is highly predictable,
    the runtime context can provide unexpected inputs and situations. Devices fail,
    networks are unreliable, mere anarchy is loosed on our application. We need to
    have a way to work around the spectrum of failures that plague computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two broad approaches to dealing with the unforeseen. One approach
    is to return a recognizable error-signaling value from a function. A value, like
    `None`, could be used. Other library functions can then be used by an application
    to retrieve details of the erroneous condition. A variation on this theme is to
    pair a return from an OS request with a success or failure indicator. The other
    approach is to interrupt the normal, sequential execution of statements and divert
    to statements that handle exceptions. This second approach is what Python does:
    it eliminates the need to check return values for errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study **exceptions**, special error objects raised
    when a normal response is impossible. In particular, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to cause an exception to occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to recover when an exception has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle different exception types in different ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up when an exception has occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new types of exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the exception syntax for flow control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case study for this chapter will look at data validation. We'll examine
    a number of ways exceptions can be used to ensure that inputs to our classifier
    are valid.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by looking at Python's concept of an `Exception`, and how exceptions
    are raised and handled.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's normal behavior is to execute statements in the order they are found,
    either in a file or at the `>>>` prompt interactively. A few statements, specifically
    `if`, `while`, and `for`, alter the simple top-to-bottom sequence of statement
    execution. Additionally, an exception can break the sequential flow of execution.
    Exceptions are raised, and this interrupts the sequential execution of statements.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the exception that's raised is also an object. There are many different
    exception classes available, and we can easily define more of our own. The one
    thing they all have in common is that they inherit from a built-in class called `BaseException`.
  prefs: []
  type: TYPE_NORMAL
- en: When an exception is raised, everything that was supposed to happen is pre-empted.
    Instead, exception handling replaces normal processing. Make sense? Don't worry,
    it will!
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to cause an exception to occur is to do something silly. Chances
    are you''ve done this already and seen the exception output. For example, any
    time Python encounters a line in your program that it can''t understand, it bails
    with `SyntaxError`, which is a type of exception. Here''s a common one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `print()` function requires the arguments to be enclosed in parentheses.
    So, if we type the preceding command into a Python 3 interpreter, we raise a `SyntaxError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `SyntaxError`, some other common exceptions are shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can partition these exceptions into roughly four categories. Some cases
    are blurry, but some edges have a bright line separating them:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, these exceptions are indicators of something clearly wrong in our
    program. Exceptions like `SyntaxError` and `NameError` mean we need to find the
    indicated line number and fix the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, these exceptions are indicators of something wrong in the Python
    runtime. There's a `RuntimeError` exception that can get raised. In many cases,
    this is resolved by downloading and installing a newer Python. (Or, if you're
    wrestling with a "Release Candidate" version, reporting the bug to the maintainers.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some exceptions are design problems. We may fail to account for an edge case
    properly and sometimes try to compute an average of an empty list. This will result
    in a `ZeroDivisionError`. When we find these, again, we'll have to go to the indicated
    line number. But once we've found the resulting exception, we'll need to work
    backwards from there to find out what caused the problem that raised the exception.
    Somewhere there will be an object in an unexpected or not-designed-for state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The bulk of the exceptions arise near our program''s interfaces. Any user input,
    or operating system request, including file operations, can encounter problems
    with the resources outside our program, leading to exceptions. We can subdivide
    these interface problems further into two sub-groups:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External objects in an unusual or unanticipated state. This is common with files
    that aren't found because the path was spelled incorrectly, or directories that
    already exist because our application crashed earlier and we restarted it. These
    will often be some kind of `OSError` with a reasonably clear root cause. It's
    also common with users entering things incorrectly, or even users maliciously
    trying to subvert the application. These should be application-specific exceptions
    to prevent dumb mistakes or intentional abuse.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And there's also the (relatively small) category of simple chaos. In the final
    analysis, a computer system is a lot of interconnected devices and any one of
    the components could behave badly. These are hard to anticipate and it's harder
    still to plan a recovery strategy. When working with a small IoT computer, there
    are few parts, but it may be installed in a challenging physical environment.
    When working with an enterprise server farm with thousands of components, a 0.1%
    failure rate means something is always broken.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed all of Python's built-in exceptions end with the name `Error`.
    In Python, the words **error** and **exception** are used almost interchangeably.
    Errors are sometimes considered more dire than exceptions, but they are dealt
    with in exactly the same way. Indeed, all the error classes in the preceding example
    have `Exception` (which extends `BaseException`) as their superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Raising an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll get to responding to such exceptions in a minute, but first, let''s
    discover what we should do if we''re writing a program that needs to inform the
    user or a calling function that the inputs are invalid. We can use the exact same
    mechanism that Python uses. Here''s a simple class that adds items to a list only
    if they are even-numbered integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This class extends the built-in list, as we discussed in *Chapter 2*, *Objects
    in Python*. We've provided a type hint suggesting we're creating a list of integer
    objects only. To do this, we've overridden the `append` method to check two conditions
    that ensure the item is an even integer. We first check whether the input is an
    instance of the `int` type, and then use the modulo operator to ensure it is divisible
    by two. If either of the two conditions is not met, the `raise` keyword causes
    an exception to occur.
  prefs: []
  type: TYPE_NORMAL
- en: The `raise` keyword is followed by the object being raised as an exception.
    In the preceding example, two objects are constructed from the built-in `TypeError` and `ValueError` classes.
    The raised object could just as easily be an instance of a new `Exception` class
    we create ourselves (we'll see how shortly), an exception that was defined elsewhere,
    or even an `Exception` object that has been previously raised and handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we test this class in the Python interpreter, we can see that it is outputting
    useful error information when exceptions occur, just as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While this class is effective for demonstrating exceptions in action, it isn't
    very good at its job. It is still possible to get other values into the list using
    index notation or slice notation. These additional behaviors can be avoided by
    overriding other appropriate methods, some of which are magic double-underscore
    methods. To be really complete, we'd need to override methods like `extend()`,
    `insert()`, `__setitem__()`, and even `__init__()` to be sure things start off
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The effects of an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is raised, it appears to stop program execution immediately.
    Any lines that were supposed to run after the exception is raised are not executed,
    and unless the exception is handled by an `except` clause, the program will exit
    with an error message. We'll examine unhandled exceptions first, and then take
    a close look at handling exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this basic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've included the `NoReturn` type hint for this function. This helps ease **mypy**'s
    worry that there's no way for this function to reach the end and return a string
    value. The type hint states, formally, the function isn't expected to return a
    value.
  prefs: []
  type: TYPE_NORMAL
- en: (Note that **mypy** is aware the final `return` cannot be executed. It does
    not object to the return type being `NoReturn`, even though there's a `return`
    statement with a string literal. It's clear this cannot be executed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute this function, we see that the first `print()` call is executed
    and then the exception is raised. The second `print()` function call is never
    executed, nor is the `return` statement. Here''s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, if we have a function that calls another function that raises
    an exception, nothing is executed in the first function after the point where
    the second function''s exception was raised. Raising an exception stops all execution
    right up through the function call stack until it is either handled or forces
    the interpreter to exit. To demonstrate, let''s add a second function that calls
    the `never_returns()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call this function, we see that the first `print` statement executes,
    as well as the first line in the `never_returns()` function. But once the exception
    is raised, nothing else executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that **mypy** didn't recognize what `never_returns()` does to the processing
    in `call_exceptor()`. Based on previous examples, it seems like `call_exceptor()`
    is better described as a `NoReturn` function. When we try this, we get a warning
    from **mypy**. It turns out the **mypy** focus is rather narrow; it examines function
    and method definitions in relative isolation; it isn't aware that `never_returns()`
    raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We can control how exceptions propagate from the initial `raise` statement.
    We can react to and deal with the exception inside either of these methods in
    the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the output from the unhandled exception above, called a **traceback**.
    This shows the call stack. The command line ("`<module>`" is the name used when
    there's no input file) called `call_exceptor()`, and `call_exceptor()` called
    `never_returns()`. Inside `never_returns()`, the exception is initially raised.
  prefs: []
  type: TYPE_NORMAL
- en: The exception propagates up through the call stack. From inside `call_exceptor()`,
    the pesky `never_returns()` function was called and the exception *bubbled up* to
    the calling method. From there, it went up one more level to the main interpreter,
    which, not knowing what else to do with it, gave up and printed the traceback
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s look at the tail side of the exception coin. If we encounter an
    exception situation, how should our code react to or recover from it? We handle
    exceptions by wrapping any code that might throw one (whether it is exception
    code itself, or a call to any function or method that may have an exception raised
    inside it) inside a `try...except` clause. The most basic syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this simple script using our existing `never_returns()` function—which,
    as we know very well, always throws an exception—we get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `never_returns()` function happily informs us that it is about to raise
    an exception and raises it. The `handler()` function's `except` clause catches
    the exception. Once caught, we are able to clean up after ourselves (in this case,
    by outputting that we are handling the situation), and continue on our way. The
    remainder of the code in the `never_returns()` function remains unexecuted, but
    the code in the `handler()` function after the `try:` statement is able to recover
    and continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note the indentation around `try` and `except`. The `try` clause wraps any code
    that might throw an exception. The `except` clause is then back on the same indentation
    level as the `try` line. Any code to handle the exception is indented inside the `except` clause.
    Then normal code resumes at the original indentation level.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the preceding code is that it uses the `Exception` class to
    match any type of exception. What if we were writing some code that could raise
    either `TypeError` or `ZeroDivisionError`? We might need to catch `ZeroDivisionError`
    because it reflects a known object state, but let any other exceptions propagate
    to the console because they reflect bugs we need to catch and kill. Can you guess
    the syntax?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rather silly function that does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function does a simple computation. We've provided the type hint of `float`
    for the `divisor` parameter. We can provide an integer, and ordinary Python type
    coercion will work. The **mypy** tool is aware of the ways integers can be coerced
    to floats, saving it from having to obsess over the parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do, however, have to be very clear about the return types. If we don''t
    raise an exception, we''ll compute and return a floating result. If we do raise
    a `ZeroDivisionError` exception, it will be handled, and we''ll return a string
    result. Any other exceptions? Let''s try it and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line of output shows that if we enter `0`, we get properly mocked.
    If we call with a valid number, it operates correctly. Yet if we enter a string
    (you were wondering how to get a `TypeError`, weren't you?), it fails with an
    unhandled exception. If we don't specify matching the `ZeroDivisionError` exception
    class, our handler would also see the `TypeError`, and accuse us of dividing by
    zero when we sent it a string, which is not a proper behavior at all.
  prefs: []
  type: TYPE_NORMAL
- en: Python also has a bare except syntax. Using `except:` with no exception class
    to match is widely frowned upon because it will prevent an application from simply
    crashing when it should. We generally use `except Exception:` to explicitly catch
    a sensible set of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The bare except syntax is actually the same as using `except BaseException``:`,
    which attempts to handle system-level exceptions that are often impossible to
    recover from. Indeed, this can make it impossible to crash your application when
    it's misbehaving.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even catch two or more different exceptions and handle them with the
    same code. Here''s an example that raises three different types of exceptions.
    It handles `TypeError` and `ZeroDivisionError` with the same exception handler,
    but it may also raise a `ValueError` error if you supply the number `13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve included multiple exception classes in the `except` clause. This lets
    us handle a variety of conditions with a common handler. Here''s how we can test
    this with a bunch of different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `for` statement iterates over several test inputs and prints the results.
    If you're wondering about that `end` parameter in the `print` function, it just
    turns the default trailing newline into a space so that it's joined with the output
    from the next line.
  prefs: []
  type: TYPE_NORMAL
- en: The number 0 and the string are both caught by the `except` clause, and a suitable
    error message is printed. The exception from the number `13` is not caught because
    it is a `ValueError`, which was not included in the types of exceptions being
    handled. This is all well and good, but what if we want to catch different exceptions
    and do different things with them? Or maybe we want to do something with an exception
    and then allow it to continue to bubble up to the parent function, as if it had
    never been caught?
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need any new syntax to deal with these cases. It''s possible to stack
    the `except` clauses, and only the first match will be executed. For the second
    question, the `raise` keyword, with no arguments, will re-raise the last exception
    if we''re already inside an exception handler. Observe the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last line re-raises the `ValueError` error, so after outputting `No, No,
    not 13!`, it will raise the exception again; we'll still get the original stack
    trace on the console.
  prefs: []
  type: TYPE_NORMAL
- en: If we stack exception clauses like we did in the preceding example, only the
    first matching clause will be run, even if more than one of them fits. How can
    more than one clause match? Remember that exceptions are objects, and can therefore
    be subclassed. As we'll see in the next section, most exceptions extend the `Exception` class
    (which is itself derived from `BaseException`). If we have an `except` clause
    to match `Exception` before we match `TypeError`, then only the `Exception` handler
    will be executed, because `TypeError` is an `Exception` by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: This can come in handy in cases where we want to handle some exceptions specifically,
    and then handle all remaining exceptions as a more general case. We can list `Exception` in
    its own clause after catching all the specific exceptions and handle the general
    case there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, when we catch an exception, we need a reference to the `Exception` object
    itself. This most often happens when we define our own exceptions with custom
    arguments, but can also be relevant with standard exceptions. Most exception classes
    accept a set of arguments in their constructor, and we might want to access those
    attributes in the exception handler. If we define our own `Exception` class, we
    can even call custom methods on it when we catch it. The syntax for capturing
    an exception as a variable uses the `as` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've seen several variations on the syntax for handling exceptions, but we
    still don't know how to execute code regardless of whether or not an exception
    has occurred. We also can't specify code that should be executed **only** if an
    exception does **not** occur. Two more keywords, `finally` and `else`, provide
    some additional execution paths. Neither one takes any extra arguments.
  prefs: []
  type: TYPE_NORMAL
- en: We'll show an example with the `finally` clause. For the most part, we often
    use context managers instead of exception blocks as a cleaner way to implement
    a finalization that occurs whether or not an exception interrupted processing.
    The idea is to encapsulate responsibility for finalization in the context manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example iterates through a number of exception classes, raising
    an instance of each. Then some not-so-complicated exception handling code runs
    that illustrates the newly introduced syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this example – which illustrates almost every conceivable exception
    handling scenario – we''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the `print` statement in the `finally` clause is executed no matter
    what happens. This is one way to perform certain tasks after our code has finished
    running (even if an exception has occurred). Some common examples include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up an open database connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closing an open file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a closing handshake over the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are more commonly handled with context managers, one of the topics
    of *Chapter 8*, *The Intersection of Object-Oriented and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: While obscure, the `finally` clause is executed after the `return` statement
    inside a `try` clause. While this can be exploited for post-`return` processing,
    it can also be confusing to folks reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, pay attention to the output when no exception is raised: both the `else` and
    the `finally` clauses are executed. The `else` clause may seem redundant, as the
    code that should be executed when no exception is raised could just be placed
    after the entire `try...except` block. The difference is that the `else` block
    will not be executed if an exception is caught and handled. We''ll see more on
    this when we discuss using exceptions as flow control later.'
  prefs: []
  type: TYPE_NORMAL
- en: Any of the `except`, `else`, and `finally` clauses can be omitted after a `try` block
    (although `else` by itself is invalid). If you include more than one, the `except` clauses
    must come first, then the `else` clause, with the `finally` clause at the end.
    You must be sure the order of the `except` clauses has classes that move from
    the most specific subclasses to most generic superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: The exception hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already seen several of the most common built-in exceptions, and you'll
    probably encounter the rest over the course of your regular Python development.
    As we noticed earlier, most exceptions are subclasses of the `Exception` class.
    But this is not true of all exceptions. The `Exception` class actually extends
    a class called `BaseException`. In fact, all exceptions must extend the `BaseException` class
    or one of its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: There are two key built-in exception classes, `SystemExit` and `KeyboardInterrupt`,
    that derive directly from the `BaseException` class instead of the `Exception`
    class. The `SystemExit` exception is raised whenever the program exits naturally,
    typically because we called the `sys.exit()` function somewhere in our code (for
    example, when the user selected an exit menu item, clicked the Close button on
    a window, entered a command to shut down a server, or the OS sent a signal to
    the application to terminate). This exception is designed to allow us to clean
    up code before the program ultimately exits.
  prefs: []
  type: TYPE_NORMAL
- en: If we do handle the `SystemExit` exception, we would normally re-raise the exception,
    since catching it could stop the program from exiting. Imagine a web service with
    a bug that is holding database locks and can't be stopped without rebooting the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want a `SystemExit` exception to be accidentally caught in generic
    `except Exception:` clauses. This is why it derives directly from `BaseException`.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeyboardInterrupt` exception is common in command-line programs. It is
    thrown when the user explicitly interrupts program execution with an OS-dependent
    key combination (normally, Ctrl + C). For Linux and macOS users, the `kill -2
    <pid>` command will also work. This is a standard way for the user to deliberately
    interrupt a running program and, like the `SystemExit` exception, it should almost
    always respond by terminating the program. Also, like `SystemExit`, it can handle
    any cleanup tasks inside the `finally` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a class diagram that fully illustrates the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Exception hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `except:` clause without specifying any type of exception, it
    will catch all subclasses of `BaseException`; which is to say, it will catch all
    exceptions, including the two special ones. Since we almost always want these
    to get special treatment, it is unwise to use the `except:` statement without
    arguments. If you want to catch all exceptions (other than `SystemExit` and `KeyboardInterrupt`),
    always explicitly catch `Exception`. Most Python developers assume that `except:` without
    a type is an error and will flag it in code review.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our own exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, when we want to raise an exception, we find that none of the built-in
    exceptions are suitable. The distinction is often focused on how applications
    must handle the exception; when we introduce a new exception it must be because
    there will be distinct processing in a handler.
  prefs: []
  type: TYPE_NORMAL
- en: There's no good reason to define an exception that's handled exactly like `ValueError`;
    we can use `ValueError`. Luckily, it's trivial to define new exceptions of our
    own. The name of the class is usually designed to communicate what went wrong,
    and we can provide arbitrary arguments in the initializer to include additional
    information.
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do is inherit from the `Exception` class or one of the existing
    exceptions that's semantically similar. We don't even have to add any content
    to the class! We can, of course, extend `BaseException` directly, but this means
    we're inventing new ways of stopping a running program, a very unusual thing to
    be creating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple exception we might use in a banking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `raise` statement illustrates how to raise the newly defined exception.
    We are able to pass an arbitrary number of arguments into the exception. Often
    a string message is used, but any object that might be useful in a later exception
    handler can be stored. The `Exception.__init__()` method is designed to accept
    any arguments and store them as a tuple in an attribute named `args`. This makes
    exceptions easier to define without needing to override `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if we do want to customize the initializer, we are free to do so.
    Here''s a revision to the above exception whose initializer accepts the current
    balance and the amount the user wants to withdraw. In addition, it adds a method
    to calculate how overdrawn the request is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since we're working with currency, we've imported the `Decimal` class of numbers.
    We can't use Python's default `int` or `float` types for money where there are
    a fixed number of decimal places and exquisitely complex rounding rules that assume
    exact decimal arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: (Also note that the account number is not part of the exception. Bankers frown
    on using account numbers in a way that could expose them in a log or a traceback
    message.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of creating an instance of this exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we would handle an `InvalidWithdrawal` exception if one was raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we see a valid use of the `as` keyword to save the exception in a local
    variable, `ex`. By convention, most Python coders assign the exception a variable
    like `ex`, `exc`, or `exception`; although, as usual, you are free to call it `the_exception_raised_above`,
    or `aunt_sally` if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many reasons for defining our own exceptions. It is often useful
    to add information to the exception or log it in some way. But the utility of
    custom exceptions truly comes to light when creating a framework, library, or
    API that is intended for access by other programmers. In that case, be careful
    to ensure your code is raising exceptions that make sense to the client programmer.
    Here are some criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: They should clearly describe what went on. The `KeyError` exception, for example,
    provides the key that could not be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client programmer should easily see how to fix the error (if it reflects
    a bug in their code) or handle the exception (if it's a situation they need to
    be made aware of).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handling should be distinct from other exceptions. If the handling is the
    same as an existing exception, reusing the existing exception is best.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we've looked at raising exceptions and defining new exceptions, we
    can look at some of the design considerations that surround exceptional data and
    responding to problems. There are a number of alternative design choices, and
    we'll start with the idea that exceptions, in Python, can be used for a number
    of things that aren't – strictly speaking – erroneous.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions aren't exceptional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Novice programmers tend to think of exceptions as only useful for exceptional
    circumstances. However, the definition of exceptional circumstances can be vague
    and subject to interpretation. Consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These two functions behave identically. If `divisor` is zero, an error message
    is printed; otherwise, a message printing the result of the division is displayed.
    We could avoid `ZeroDivisionError` ever being thrown by testing for it with an `if` statement.
    In this example, the test for a valid division is relatively simple-looking (`divisor
    == 0`). In some cases, it can be rather complex. In some cases, it may involve
    computing intermediate results. In the worst cases, the test for "will this work?"
    involves using a number of other methods of a class to – in effect – dry-run the
    operation to see if there would be an error along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Python programmers tend to follow a model summarized by "**It's Easier to Ask
    Forgiveness Than Permission**," sometimes abbreviated EAFP. The point is to execute
    code and then deal with anything that goes wrong. The alternative is described
    as "**Look Before You Leap**," often abbreviated LBYL. This is generally less
    popular. There are a few reasons for this, but the main one is that it shouldn't
    be necessary to burn CPU cycles looking for an unusual situation that is not going
    to arise in the normal path through the code.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is wise to use exceptions for exceptional circumstances, even
    if those circumstances are only a little bit exceptional. Taking this argument
    further, exception syntax can be effective for flow control. Like an `if` statement,
    exceptions can be used for decision making, branching, and message passing.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine an inventory application for a company that sells widgets and gadgets.
    When a customer makes a purchase, the item can either be available, in which case
    the item is removed from inventory and the number of items left is returned, or
    it might be out of stock. Now, being out of stock is a perfectly normal thing
    to happen in an inventory application. It is certainly not an exceptional circumstance.
    But what do we return if it's out of stock? A string saying "out of stock"? A
    negative number? In both cases, the calling method would have to check whether
    the return value is a positive integer or something else, to determine if it is
    out of stock. That seems a bit messy, especially if we forget to do it somewhere
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can raise an `OutOfStock` exception and use the `try` statement
    to direct program flow control. Make sense? In addition, we want to make sure
    we don't sell the same item to two different customers, or sell an item that isn't
    in stock yet. One way to facilitate this is to lock each type of item to ensure
    only one person can update it at a time. The user must lock the item, manipulate
    the item (purchase, add stock, count items left...), and then unlock the item.
    (This is, in effect, a context manager, one subject of *Chapter 8*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an incomplete `Inventory` example with docstrings that describes what
    some of the methods should do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We could hand this object prototype to a developer and have them implement the
    methods to do exactly as they say while we work on the code needed to make a purchase.
    We'll use Python's robust exception handling to consider different branches, depending
    on how the purchase was made. We can even write a test case to be sure there's
    no question about how this class should work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a definition of `ItemType`, just to round out the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an interactive session using this `Inventory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All the possible exception handling clauses are used to ensure the correct actions
    happen at the correct time. Even though `OutOfStock` is not a terribly exceptional
    circumstance, we are able to use an exception to handle it suitably. This same
    code could be written with an `if...elif...else` structure, but it wouldn't be
    as easy to read or maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, one of the exception messages, `There are {num_left} {item_to_buy.name}s
    left`, suffers from a goofy English grammar problem. When there''s only one item
    left, it needs a major revision to `There is {num_left} {item_to_buy.name} left`.
    In order to support a sensible approach to translation, it''s best to avoid fiddling
    around with grammar details inside the f-string. It''s best to deal with it in
    the `else:` clause, using something like this to select the message with appropriate
    grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can also use exceptions to pass messages between different methods. For example,
    if we wanted to inform the customer as to what date the item is expected to be
    in stock again, we could ensure our `OutOfStock` object requires a `back_in_stock`
    parameter when it is constructed. Then, when we handle the exception, we can check
    that value and provide additional information to the customer. The information
    attached to the object can be easily passed between two different parts of the
    program. The exception could even provide a method that instructs the inventory
    object to reorder or backorder an item.
  prefs: []
  type: TYPE_NORMAL
- en: Using exceptions for flow control can make for some handy program designs. The
    important thing to take from this discussion is that exceptions are not a bad
    thing that we should try to avoid. Having an exception occur does not mean that
    you should have prevented this exceptional circumstance from happening. Rather,
    it is just a powerful way to communicate information between two sections of code
    that may not be directly calling each other.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter''s case study will look at some ways that we can find – and help
    the users fix – potential problems with the data or the application''s computations.
    Both the data and the processing are possible sources of exceptional behavior.
    They aren''t, however, equivalent; we can compare the two as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptional data is the most common source of problems. The data may not follow
    the syntax rules and have an invalid physical format. Other, more minor errors
    may stem from data not having a recognized logical organization, for example wrong
    spelling of column names. Exceptions can also reflect users attempting to perform
    an unauthorized operation. We need to alert users and administrators of invalid
    data or invalid operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptional processing is what is commonly called a **bug**. An application
    shouldn't try to recover from these problems. While we prefer to find them as
    part of unit or integration testing (see *Chapter 13*, *Testing Object-Oriented
    Programs*), it's possible that a problem escaped our scrutiny and wound up in
    production, and is exposed to the users of our software. We need to tell the users
    that something's broken and – as gracefully as possible – stop processing, or
    "crash." To continue in the presence of a bug is a serious breach of trust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case study, we have three kinds of inputs that need to be examined for
    potential problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The known `Sample` instances, provided by a Botanist, and reflecting expert
    judgement. While this data should be exemplary in its quality, there's no guarantee
    that someone didn't accidentally rename a file and replace good data with something
    invalid or otherwise unprocessable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The unknown `Sample` instances, provided by Researchers. These may have all
    kinds of data quality problems. We'll look at few of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actions taken by a Researcher or a Botanist. We'll review the use cases to see
    what actions should be allowed by each class of user. In some cases, these problems
    are prevented by offering each class of user a focused menu of actions they can
    take.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll start with a review of the use cases, so we can identify the kinds of
    exceptions that are required by this application.
  prefs: []
  type: TYPE_NORMAL
- en: Context view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The role of "User" in the Context Diagram from *Chapter 1* is – at this point
    – less than ideal. It was tolerable as an initial description of the interfaces
    to the application. As we work through the design, we can see that a more specific
    term like "Researcher" might be a better description for someone researching a
    sample and looking for a classification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an expanded context diagram with a new consideration of users and their
    authorized actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Application context diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The Botanist is responsible for one kind of data, and has two valid operations.
    The Researcher is responsible for a different kind of data, and has only one valid
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: The data and the processing use cases are intimately tied together. When a Botanist
    provides new training data or sets the parameters and tests the classifier, the
    application software must be sure their inputs are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when a Researcher tries to classify a sample, the software must confirm
    that the data is valid and can be used. Invalid data must be reported to the Researcher
    so they can fix their inputs and try again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can decompose handling bad data into two parts, each of which is tackled
    separately:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering exceptional data. As we've seen in this chapter, this is implemented
    as raising an exception when invalid data is encountered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to exceptional data. This is implemented as a `try:`/`except:` block
    that provides useful information on the nature of the problem and likely courses
    of action to resolve it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll start with discovering the exceptional data, first. Raising the right
    exception is the foundation for handling bad data.
  prefs: []
  type: TYPE_NORMAL
- en: Processing view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are a lot of data objects in this application, we''re going to
    narrow our focus to the `KnownSample` and `UnknownSample` classes. These two are
    related to a common superclass, the `Sample` class. These are created by two other
    classes. The following diagram shows where the `Sample` objects are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Object creation'
  prefs: []
  type: TYPE_NORMAL
- en: We've included two classes that will create these two kinds of samples. The `TrainingData` class
    will load known samples. An overall `ClassifierApp` class will validate an unknown
    sample, and attempt to classify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `KnownSample` object has five attributes, each of which has a narrowly-defined
    set of valid values:'
  prefs: []
  type: TYPE_NORMAL
- en: The measurements, `sepal_length`, `sepal_width`, `petal_length`, `petal_width`,
    are all floating-point numbers. There's a lower-bound of zero for these values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expert-supplied `species` value is a string, with three valid values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `UnknownSample` object has only the four measurements. The idea of using
    a common superclass definition can help us ensure this validation processing is
    reused.
  prefs: []
  type: TYPE_NORMAL
- en: The rules for valid values listed above only define the valid values for each
    attribute considered in isolation. In some applications, there may be complex
    relationships among the attributes, or rules that define relationships among the
    samples. For our case study, we'll focus on the five attribute validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: What can go wrong?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It helps to consider what can go wrong when loading a `Sample` object, and what
    – if anything – the user can do about it. Our sample validation rules suggest
    we may want to raise specialized kinds of `ValueError` exceptions to describe
    data where the measurements aren't valid float values or the species name isn't
    one of the known strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a class like the following to define the condition of bad data that
    can''t be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This lets us raise an `InvalidSampleError` exception for input data that this
    application can't process. The intent is to provide a message with the details
    of what needs to be repaired.
  prefs: []
  type: TYPE_NORMAL
- en: This can help us distinguish between bugs in our code, which may raise a `ValueError`
    exception, and correct behavior in the presence of bad data, where the `InvalidSampleError`
    exception will be raised. This means we need to be specific in our `except:` blocks,
    using the `InvalidSampleError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: If we ever use `except ValueError:`, it will handle both generic exceptions
    as well as our unique exception. This means we might treat a more serious bug
    as invalid data. The trick is to be cautious handling generic exceptions; we may
    be working around a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Bad behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier we suggested that a user might attempt an action which is invalid. For
    example, a Researcher might try to provide classified `KnownSample` objects. The
    action of loading new training data is reserved for the Botanist; this means an
    attempt by a Researcher should raise some kind of exception.
  prefs: []
  type: TYPE_NORMAL
- en: Our application works in the context of the overall operating system. For command-line
    applications, we can partition users into two groups, and use the operating system
    file ownership and access permissions to limit which group can run which applications.
    This is an effective and comprehensive solution, and doesn't require any Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: For web-based applications, however, we need to authenticate each user to a
    web application. All of the web application frameworks for Python provide user
    authentication mechanisms. Many frameworks have handy plug-ins for systems like
    Open Authentication, OAuth. See [https://oauth.net/2/](https://oauth.net/2/) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'For web applications, we generally have two tiers of processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication** of the user. This is where a user identifies themselves.
    This might involve a single factor like a password, or multiple factors like a
    physical key or an interaction with a cell phone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization** to perform some action. We''ll often define roles for the
    users, and limit access to various resources based on the user''s role. This means
    raising an exception when the user doesn''t have the appropriate role to access
    a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many web frameworks will use exceptions as an internal signal that something
    should not be allowed. This internal exception must then be mapped to external
    HTTP status codes, like a `401 Authorization Required` response.
  prefs: []
  type: TYPE_NORMAL
- en: This is a deep topic, outside the scope of this book. See, for example, *Building
    Web Applications with Flask* ([https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152](https://www.packtpub.com/product/building-web-applications-with-flask/9781784396152))
    for an introduction to web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating samples from CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Details of various options for reading samples in different file formats is
    something we need to defer to *Chapter 9*, *Strings, Serialization, and File Paths*,
    where we talk in detail about serialization techniques. For now, we'll skip a
    number of details and focus on an approach that works very nicely for CSV-formatted
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '**CSV** – **Comma-Separated Values** – can be used to define the rows of a
    spreadsheet. Within each row, the cell values are represented as text, separated
    by commas. When this data is parsed by Python''s `csv` module, each row can be
    represented by a dictionary where the keys are the column names and the values
    are the cell values from a particular row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a row might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `csv` module's `DictReader` class provides an iterable sequence of `dict[str,
    str]` row instances. We need to transform these raw rows into instances of one
    of the subclasses of `Sample`, if all of the features have valid string values.
    If the raw data isn't valid, then we need to raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given rows like the example above, here''s a method that will translate from
    the dictionary to a more useful object. This is part of the `KnownSample` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `from_dict()` method makes a check of the species value, raising an exception
    if it's not valid. It attempts to create a row, applying the `float()` function
    to convert various measurements from string values to float values. If the conversions
    all work, then the `cls` parameter – the class to create – will build the expected
    object.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the `float()` function evaluations encounters a problem, and raises
    a `ValueError` exception; this is used to create our application's unique `InvalidSampleError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: This style of validation is a mixture of some **Look Before You Leap** (**LBYL**)
    and **Easier to Ask Forgiveness than Permission** (**EAFP**) styles. The most
    widely-used approach in Python is EAFP. In the case of the species value, however,
    there's no conversion function similar to `float()` to raise an exception or bad
    data. In this example, we've chosen to use LBYL for this attribute value. We'll
    look at an alternative below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `from_dict()` method is defined with the `@classmethod` decoration. This
    means the actual class object becomes the first parameter, `cls`. When we do this,
    it means any subclass that inherits this will have the method tailored for that
    subclass. We can create a new subclass, for example, `TrainingKnownSample`, using
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `TrainingKnownSample.from_dict()` method will be given the `TrainingKnownSample`
    class as the `cls` parameter value; without any other code, the `from_dict()`
    method of this class will build instances of the `TrainingKnownSample` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this works nicely, it''s not clear to **mypy** that it works. We can
    use the following definition to provide an explicit type mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: An alternative is to use the simpler class definition and put the `cast()` operation
    in the places where `from_dict()` is actually used, for example, `cast(TrainingKnownSample,
    TrainingKnownSample.from_dict(data))`. Since this method is not used in very many
    places, it's difficult to assert which variation is simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the rest of the `KnownSample` class, repeated from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this works in practice. Here''s an example of loading some valid
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We created the dictionary, `valid`, that a `csv.DictReader` would create from
    a line of input. Then, we built a `TrainingKnownSample` instance, `rks`, from
    this dictionary. The resulting object has proper floating-point values, showing
    that conversions from strings have been performed as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the validation behaves. This is an example of the kind of exception
    raised for bad data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When we tried to create a `TestingKnownSample` instance, the invalid species
    value raised an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Have we spotted all potential problems? The `csv` module handles the physical
    format issues, so providing a PDF file, for example, will lead to exceptions being
    raised by the `csv` module. Invalid species names and float values are checked
    in the `from_dict()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some things we did not check. Here are some additional validations:'
  prefs: []
  type: TYPE_NORMAL
- en: Missing keys. If a key is spelled incorrectly, this code will raise a `KeyError` exception,
    which would not be restated as an `InvalidSampleError` exception. This change
    is left as an exercise for the reader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra keys. If there are unexpected columns, is the data invalid, or do we ignore
    this? It may be that we're given data from a spreadsheet with extra columns that
    should be ignored. While it's helpful to be flexible, it's also important to expose
    potential problems with the input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-range float values. There are likely some sensible upper and lower bounds
    on the range of measurements. The lower bound of zero, seems clear; negative measurements
    don't make much sense. The upper bound, however, isn't as clear. There are some
    statistical techniques for locating outliers, including the **Median Absolute
    Deviation** (**MAD**) technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm](https://www.itl.nist.gov/div898/handbook/eda/section3/eda35h.htm)
    for more information on how to spot data that doesn't seem to fit a normal distribution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first of these additional checks can be added to the `from_dict()` method.
    The second is a decision that must be reached with the users, and then potentially
    added to the `from_dict()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outlier detection is more sophisticated. We need to perform this check
    after all the testing and training samples have been loaded. Because the outlier
    check doesn''t apply to a single row, it needs a different exception. We might
    define another exception like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This exception can be used with a simple range check, or the more sophisticated
    MAD method for outlier detection.
  prefs: []
  type: TYPE_NORMAL
- en: Validating enumerated values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list of valid species isn't very visible. We've essentially buried it inside
    the `from_dict()` method, which may become a maintenance problem. When the source
    data changes, we need to also update this method, something that can be hard to
    remember and almost as hard to find. If the list of species becomes long, the lines
    of code could become hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an explicit `enum` class with the list of valid values is a way to convert
    this to purely EAFP processing. Consider using the following to validate species.
    Doing this means redefining a number of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we apply the `enum` class name, `Species`, to one of the enumerated literal
    values, it will raise a `ValueError` exception to show the string representation
    of the species is invalid. This parallels the way `float()` and `int()` raise `ValueError` exceptions
    for a string that's not a valid number.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to enumerated values would also require changes to the class definition
    for a known sample. The class needs to be modified to use the enumeration, `Species`,
    instead of `str`. For this case study, the list of values is small, and an `Enum`
    seems practical. For other problem domains, however, the enumerated list of values
    could be quite large and an `Enum` class might be long and uninformative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of an `Enum` class, we might continue to use string objects. We can
    define each unique domain of string values as an extension to a `Set[str]` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `species.validate()` function similar to the way we used the
    `float()` function. This will validate the string, without coercing it to a different
    value. Instead, it returns the string. For invalid values, it raises a `ValueError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lets us rewrite the body of the `from_dict()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This variation relies on the global `species` to be a set of valid species.
    It also uses a pleasantly consistent EAFP approach to building the required object
    or raising an exception.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, there are two parts to this design. We've looked at
    the foundational element, raising an appropriate exception. Now we can look at
    the context in which we use this `from_dict()` function, and how errors get reported
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: Reading CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll provide a common template for creating objects from CSV source data.
    The idea is to leverage the `from_dict()` methods of the various classes to create
    the objects our application uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `load()` method is partitioning the samples into testing and training subsets.
    It expects an iterable source of `dict[str, str]` objects, which are produced
    by a `csv.DictReader` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user experience implemented here is to report the first failure and return.
    This might lead to an error message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This message has all the required information, but may not be as helpful as
    desired. We might, for example, want to report *all* failures, instead of the
    first failure. Here''s how we might restructure the `load()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This variation would catch each `InvalidSampleError` error, displaying a message
    and counting the number of problems. This information might be more helpful because
    the user could then correct all of the rows which are invalid.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a very, very large set of data, this may lead to a useless level
    of detail. If we accidentally used a CSV file with several hundred thousand rows
    of images of hand-written numbers, for example, instead of Iris data, we'd get
    several hundred thousand messages telling us each individual row was bad.
  prefs: []
  type: TYPE_NORMAL
- en: Some additional user experience design is required around this loading operation,
    to make it useful in a wide variety of situations. The foundation, however, is
    the Python exception that's raised when something's not right. In this case study,
    we leveraged the `float()` function's `ValueError` and rewrote it to be our application's
    unique `InvalidSampleError` exception. We also created our own `ValueError` exceptions
    for unexpected strings.
  prefs: []
  type: TYPE_NORMAL
- en: Don't repeat yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `load()` method of `TrainingData` will create two different subclasses of
    `KnownSample`. We've put most of the processing into the `KnownSample` superclass;
    this avoids repeating the validation processing in each subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an `UnknownSample`, however, we have a tiny problem: there''s no species
    data in an `UnknownSample`. It would be ideal to extract the validation of the
    four measurements, and keep them separate from validating the species. If we do
    this, we can''t trivially combine building a `Sample` with doing the validation
    in one simple EAFP kind of method that either creates the desired object or raises
    an exception that it can''t be built.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a subclass introduces new fields, we have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abandon simple-looking EAFP validation. In this case, we would need to separate
    validation from object construction. This will lead to the cost of doing `float()`
    conversions twice: once to validate the data and again to create the target object.
    Multiple `float()` conversions means we haven''t really followed the **Don''t
    Repeat Yourself** (**DRY**) principle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build an intermediate representation that can be used by subclasses. This means
    the two `KnownSample` subclass of `Sample` would involve three steps. First, build
    a `Sample` object, validating the four measurements. Then, validate the species.
    Finally, build the `KnownSample` using the valid fields from the `Sample` object
    and the valid species value. This creates a temporary object, but avoids repeating
    any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll leave the implementation details as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Once the exception is defined, we also need to display the results to the user
    in a form that guides them to a the right remedial action. This is a separate
    user experience design consideration that is built on the foundation of the underlying
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some key points in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Raising an exception happens when something goes wrong. We looked at division
    by zero as an example. Exceptions can also be raised with the `raise` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The effects of an exception are to interrupt the normal sequential execution
    of statements. It saves us from having to write a lot of `if` statements to check
    to see if things can possibly work or check to see if something actually failed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions is done with the `try:` statement, which has an `except:`
    clause for each kind of exception we want to handle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception hierarchy follows object-oriented design patterns to define a
    number of subclasses of the `Exception` class we can work with. Some additional
    exceptions, `SystemExit` and `KeyboardInterrupt`, are not subclasses of the `Exception`
    class; handling these introduces risks and doesn't solve very many problems, so
    we generally ignore them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining our own exceptions is a matter of extending the `Exception` class.
    This makes it possible to define exceptions with very specific semantics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've never dealt with exceptions before, the first thing you need to do
    is look at any old Python code you've written and notice if there are places you
    should have been handling exceptions. How would you handle them? Do you need to
    handle them at all? Sometimes, letting the exception propagate to the console
    is the best way to communicate to the user, especially if the user is also the
    script's coder. Sometimes, you can recover from the error and allow the program
    to continue. Sometimes, you can only reformat the error into something the user
    can understand and display it to them.
  prefs: []
  type: TYPE_NORMAL
- en: Some common places to look are file I/O (is it possible your code will try to
    read a file that doesn't exist?), mathematical expressions (is it possible that
    a value you are dividing by is zero?), list indices (is the list empty?), and
    dictionaries (does the key exist?).
  prefs: []
  type: TYPE_NORMAL
- en: Ask yourself whether you should ignore the problem, handle it by checking values
    first, or handle it with an exception. Pay special attention to areas where you
    might have used `finally` and `else` to ensure the correct code is executed under
    all conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Now write some new code, extending the case study to cover any additional validation
    checks for the input data. For example, we need to check the measurements to be
    sure they're in a sensible range. This can be an additional subclass of `ValueError`.
    We can apply the concept to other parts of the case study. For example, we might
    want to validate `Sample` objects to be sure the values are all positive numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The case study doesn't do any range checking in the `from_dict()` method. Checking
    the lower bound of zero is easy, and it would be good to add this as the first
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: For setting an upper bound on the various measurements, it's important to know
    the data. First, it's helpful to survey the data and find the actual minimum,
    maximum, median, and the absolute deviations from the median. Given this summary
    information, a sensible set of limits can be defined and range checks added.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t addressed creating `UnknownSample` instances, leaving the `from_dict()`
    method as an exercise for the reader. In the *Don''t repeat yourself* section,
    above, we described an implementation where validating the four measurements in
    the `from_dict()` processing is refactored into the Sample class. This leads to
    two design changes:'
  prefs: []
  type: TYPE_NORMAL
- en: In `KnownSample`, use the `Sample.from_dict()` to validate the measurements,
    validate species, and build the final `KnownSample` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `UnknownSample`, use the `Sample.from_dict()` to validate the measurements,
    then build the final `UnknownSample` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These changes should lead to a reasonably flexible data validation that doesn't
    involve copying and pasting the validation rules for measurements or species.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try to think of places in your code where you can raise exceptions.
    It can be in code you've written or are working on, or you can write a new project
    as an exercise. You'll probably have the best luck designing a small framework
    or API that is meant to be used by other people; exceptions are a terrific communication
    tool between your code and someone else's. Remember to design and document any
    self-raised exceptions as part of the API, or they won't know whether or how to
    handle them!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went into the gritty details of raising, handling, defining,
    and manipulating exceptions. Exceptions are a powerful way to communicate unusual
    circumstances or error conditions without requiring a calling function to explicitly
    check return values. There are many built-in exceptions and raising them is trivially
    easy. There are several different syntaxes for handling different exception events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, everything we've studied so far will come together as we
    discuss how object-oriented programming principles and structures should best
    be applied in Python applications.
  prefs: []
  type: TYPE_NORMAL
