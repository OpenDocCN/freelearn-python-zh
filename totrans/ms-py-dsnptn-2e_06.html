<html><head></head><body>
		<div><h1 id="_idParaDest-157" class="chapter-number"><a id="_idTextAnchor163"/>6</h1>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor164"/>Architectural Design Patterns</h1>
			<p>In the previous chapter, we covered <strong class="bold">behavioral patterns</strong>, patterns that help with object interconnection and algorithms. The next category of design patterns is <strong class="bold">architectural design patterns</strong>. These<a id="_idIndexMarker595"/> patterns provide a template for solving common architectural problems, facilitating the development of scalable, maintainable, and reusable systems.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>The <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) pattern</li>
				<li>The <strong class="bold">Microservices</strong> pattern</li>
				<li>The <strong class="bold">Serverless</strong> pattern</li>
				<li>The <strong class="bold">Event </strong><strong class="bold">Sourcing</strong> pattern</li>
				<li>Other architectural design patterns</li>
			</ul>
			<p>At the end of this chapter, you will understand how to build robust and flexible software using popular architectural design patterns.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor165"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>. The additional technical requirements for the code discussed in this chapter are the following:</p>
			<ul>
				<li>For the <em class="italic">Microservices pattern</em> section, install the following:<ul><li><code>python -m pip </code><code>install grpcio</code></li><li><code>python -m pip </code><code>install grpcio-tools</code></li><li><code>python -m pip install "lanarky[openai]"==0.8.6 uvicorn==0.29.0</code> (Note that this is not compatible with Python 3.12, at the time of writing. In this case, you may reproduce the related example using Python 3.11 instead.)</li></ul></li>
				<li>For the <em class="italic">Serverless pattern</em> section, install <a id="_idIndexMarker599"/>the following:<ul><li><code>python –m pip install localstack</code> (Note that this is not compatible with Python 3.12, at the time of writing. You may use Python 3.11 instead for this case.)</li><li><code>python -m pip </code><code>install awscli-local</code></li><li><code>awscli</code>, using the command: <code>python -m pip </code><code>install awscli</code></li></ul></li>
				<li>For the <em class="italic">Event Sourcing</em> section, install the following:<ul><li><code>eventsourcing</code>, using the command: <code>python –m pip </code><code>install eventsourcing</code></li></ul></li>
			</ul>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor166"/>The MVC pattern</h1>
			<p>The <a id="_idIndexMarker602"/>MVC pattern is another application of <a id="_idIndexMarker603"/>the <strong class="bold">loose coupling</strong> principle. The name of the pattern comes from the three main <a id="_idIndexMarker604"/>components used to split a software application: the model, the view, and the controller.</p>
			<p>Even if we will never have to implement it from scratch, we need to be familiar with it because all common frameworks use MVC or a slightly different version of it (more on this later).</p>
			<p>The model is the core component. It represents knowledge. It contains and manages the (business) logic, data, state, and rules of an application. The view is a visual representation of the model. Examples of views are a computer GUI, the text output of a computer terminal, a smartphone’s application GUI, a PDF document, a pie chart, a bar chart, and so forth. The view only displays the data; it doesn’t handle it. The controller is the link/glue between the model and the view. All communication between the model and the view happens through a controller.</p>
			<p>A typical use of an <a id="_idIndexMarker605"/>application that uses MVC, after the initial screen is rendered to the user, is as follows:</p>
			<ol>
				<li>The user triggers a view by clicking (typing, touching, and so on) a button.</li>
				<li>The view informs the controller of the user’s action.</li>
				<li>The controller processes user input and interacts with the model.</li>
				<li>The model performs all the necessary validation and state changes and informs the controller about what should be done.</li>
				<li>The controller <a id="_idIndexMarker606"/>instructs the view to update and display the output appropriately, following the model’s instructions.</li>
			</ol>
			<div><div><img src="img/B21896_06_01.jpg" alt="Figure 6.1 – The MVC pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The MVC pattern</p>
			<p>But is the controller part necessary? Can’t we just skip it? We could, but then we would lose a big benefit that MVC provides: the ability to use more than one view (even at the same time, if that’s what we want) without modifying the model. To achieve decoupling between the model and its representation, every view typically needs its own controller. If the model <a id="_idIndexMarker607"/>communicated directly with a specific view, we wouldn’t be able to use multiple <a id="_idIndexMarker608"/>views (or, at least, not in a clean and modular way).</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor167"/>Real-world examples</h2>
			<p>MVC is an <a id="_idIndexMarker609"/>application of the <strong class="bold">separation of concern</strong> principle. Separation of concern is used a lot in real life. For<a id="_idIndexMarker610"/> example, if you build a new house, you usually assign different professionals to 1) install the plumbing and electricity; and, 2) paint the house.</p>
			<p>Another example is a restaurant. In a restaurant, the waiters receive orders and serve dishes to the customers, but the meals are cooked by the chefs.</p>
			<p>In web development, several frameworks use the MVC idea, for example:</p>
			<ul>
				<li>The <strong class="bold">Web2py framework</strong> is a <a id="_idIndexMarker611"/>lightweight Python framework that embraces the MVC pattern. There are many examples that demonstrate how MVC can be used in Web2py on the project’s site (<a href="http://web2py.com/">http://web2py.com/</a>) and in<a id="_idIndexMarker612"/> the GitHub repository.</li>
				<li><strong class="bold">Django</strong> (<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a>) is also an MVC framework, although it<a id="_idIndexMarker613"/> uses different<a id="_idIndexMarker614"/> naming conventions. The controller is called <em class="italic">view</em>, and the view is called <em class="italic">template</em>. Django uses the name <strong class="bold">Model-View Template</strong> (<strong class="bold">MVT</strong>). According to the designers of Django, the view describes <a id="_idIndexMarker615"/>what<a id="_idIndexMarker616"/> data is seen by the user, and therefore, it uses the name view as the Python callback function for a particular URL. The term “template” in Django is used to separate content from representation. It describes how the data is seen by the user, not which data is seen.</li>
			</ul>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor168"/>Use cases for the MVC pattern</h2>
			<p>MVC is a <a id="_idIndexMarker617"/>very<a id="_idIndexMarker618"/> generic and useful design pattern. In fact, all popular web frameworks (Django, Rails, Symfony, and Yii) and application<a id="_idIndexMarker619"/> frameworks (iPhone SDK, Android, and QT) make use of MVC or a <a id="_idIndexMarker620"/>variation of it (<strong class="bold">model-view-adapter</strong> (<strong class="bold">MVA</strong>), <strong class="bold">model-view-presenter</strong> (<strong class="bold">MVP</strong>), or <strong class="bold">MVT</strong>, for example). However, even if we don’t use any of these frameworks, it makes sense to implement the pattern on our own because of the benefits it provides, which are as follows:</p>
			<ul>
				<li>The separation between the view and model allows graphics designers to focus on the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) part and programmers to focus on development, without interfering with each other.</li>
				<li>Because of the loose coupling between the view and model, each part can be modified/extended without affecting the other. For example, adding a new view is trivial. Just implement a new controller for it.</li>
				<li>Maintaining each part is easier because the responsibilities are clear.</li>
			</ul>
			<p>When implementing MVC from scratch, be sure that you create smart models, thin controllers, and dumb views.</p>
			<p>A model is considered smart because it does the following:</p>
			<ul>
				<li>It contains all the validation/business rules/logic</li>
				<li>It handles the state of the application</li>
				<li>It has access to application data (database, cloud, and so on)</li>
				<li>It does not depend on the UI</li>
			</ul>
			<p>A controller is considered thin because it does the following:</p>
			<ul>
				<li>It updates the model when the user interacts with the view</li>
				<li>It updates the view when the model changes</li>
				<li>It processes the data before delivering it to the model/view, if necessary</li>
				<li>It does not display the data</li>
				<li>It does not access the application data directly</li>
				<li>It does not contain validation/business rules/logic</li>
			</ul>
			<p>A view is considered dumb because it does the following:</p>
			<ul>
				<li>It displays the data</li>
				<li>It allows the user to interact with it</li>
				<li>It does only minimal processing, usually provided by a template language (for example, using simple variables and loop controls)</li>
				<li>It does not store any data</li>
				<li>It does not access the application data directly</li>
				<li>It does not contain validation/business rules/logic</li>
			</ul>
			<p>If you are implementing MVC from scratch and want to find out whether you did it right, you can try answering some key questions:</p>
			<ul>
				<li>If your<a id="_idIndexMarker621"/> application <a id="_idIndexMarker622"/>has a GUI, is it skinnable? How easily can you change the skin/look and feel of it? Can you give the user the ability to change the skin of your application during runtime? If this is not simple, it means that something is going wrong with your MVC implementation.</li>
				<li>If your application has no GUI (for instance, if it’s a terminal application), how hard is it to add GUI support? Or, if adding a GUI is irrelevant, is it easy to add views to display the results in a chart (pie chart, bar chart, and so on) or a document (PDF, spreadsheet, and so on)? If these changes are not trivial (a matter of creating a new controller with a view attached to it, without modifying the model), MVC is not implemented properly.</li>
				<li>If you make<a id="_idIndexMarker623"/> sure that these conditions are satisfied, your application will be more flexible and maintainable compared to an application that does not use MVC.</li>
			</ul>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor169"/>Implementing the MVC pattern</h2>
			<p>I could use any of the<a id="_idIndexMarker624"/> common frameworks to demonstrate how to use MVC, but I feel that the picture will be incomplete. So, I decided to show you how to implement MVC from scratch, using a very simple example: a quote printer. The idea is extremely simple. The user enters a number and sees the quote related to that number. The quotes are stored in a <code>quotes</code> tuple. This is the data that normally exists in a database, file, and so on, and only the model has direct access to it.</p>
			<p>Let’s consider this <a id="_idIndexMarker625"/>example for the <code>quotes</code> tuple:</p>
			<pre class="source-code">
quotes = (
    "A man is not complete until he is married. Then he is finished.",
    "As I said before, I never repeat myself.",
    "Behind a successful man is an exhausted woman.",
    "Black holes really suck...",
    "Facts are stubborn things.",
)</pre>			<p>The model is minimalistic; it only has a <code>get_quote()</code> method that returns the quote (string) of the <code>quotes</code> tuple based on its index, <code>n</code>. The model class is as follows:</p>
			<pre class="source-code">
class QuoteModel:
    def get_quote(self, n):
        try:
            value = quotes[n]
        except IndexError as err:
            value = "Not found!"
        return value</pre>			<p>The view has three methods: <code>show()</code>, which is used to print a quote (or the <code>Not found!</code> message) on the screen; <code>error()</code>, which is used to print an error message on the screen; and <code>select_quote()</code>, which reads the <a id="_idIndexMarker626"/>user’s selection. This can be seen in the following <a id="_idIndexMarker627"/>code:</p>
			<pre class="source-code">
class QuoteTerminalView:
    def show(self, quote):
        print(f'And the quote is: "{quote}"')
    def error(self, msg):
        print(f"Error: {msg}")
    def select_quote(self):
        return input("Which quote number would you like to see? ")</pre>			<p>The controller does the coordination. The <code>__init__()</code> method initializes the model and view. The <code>run()</code> method validates the quoted index given by the user, gets the quote from the model, and passes it back to the view to be displayed, as shown in the following code:</p>
			<pre class="source-code">
class QuoteTerminalController:
    def __init__(self):
        self.model = QuoteModel()
        self.view = QuoteTerminalView()
    def run(self):
        valid_input = False
        while not valid_input:
            try:
                n = self.view.select_quote()
                n = int(n)
                valid_input = True
            except ValueError as err:
                self.view.error(f"Incorrect index '{n}'")
        quote = self.model.get_quote(n)
        self.view.show(quote)</pre>			<p>Finally, the <code>main()</code> function initializes and fires the controller, as shown in the following code:</p>
			<pre class="source-code">
def main():
    controller = QuoteTerminalController()
    while True:
        controller.run()</pre>			<p>Here is a recap of our <a id="_idIndexMarker628"/>example (the full <a id="_idIndexMarker629"/>code is in <code>ch06/mvc.py</code> file):</p>
			<ol>
				<li>We start by defining a variable for the list of quotes.</li>
				<li>We define the model class, <code>QuoteModel</code>.</li>
				<li>We define the view class, <code>QuoteTerminalView</code>.</li>
				<li>We define the controller class, <code>QuoteTermin<a id="_idTextAnchor170"/>alController</code>.</li>
				<li>Finally, we add the <code>main()</code> function to test the different classes, followed by the usual trick to call it.</li>
			</ol>
			<p>A sample <a id="_idIndexMarker630"/>execution of the <code>python ch06/mvc.py</code> command shows how the program prints quotes to the <a id="_idIndexMarker631"/>user:</p>
			<pre class="source-code">
<strong class="bold">Which quote number would you like to see? 3</strong>
<strong class="bold">And the quote is: "Black holes really suck..."</strong>
<strong class="bold">Which quote number would you like to see? 2</strong>
<strong class="bold">And the quote is: "Behind a successful man is an exhausted woman."</strong>
<strong class="bold">Which quote number would you like to see? 6</strong>
<strong class="bold">And the quote is: "Not found!"</strong>
<strong class="bold">Which quote number would you like to see? 4</strong>
<strong class="bold">And the quote is: "Facts are stubborn things."</strong>
<strong class="bold">Which quote number would you like to see? 3</strong>
<strong class="bold">And the quote is: "Black holes really suck..."</strong>
<strong class="bold">Which quote number would you like to see? 1</strong>
<strong class="bold">And the quote is: "As I said before, I never repeat myself."</strong></pre>			<h1 id="_idParaDest-164"><a id="_idTextAnchor171"/>The Microservices pattern</h1>
			<p>Traditionally, developers working on <a id="_idIndexMarker632"/>building a server-side application have been using a <a id="_idIndexMarker633"/>single code base and implementing all or most functionalities right there, using common development practices such as functions and classes, and design patterns such as the ones we have covered in this book so far.</p>
			<p>However, with the evolution of the IT industry, economic factors, and pressure for fast times to market and returns on investment, there is a constant need to improve the practices of engineering teams and ensure more reactivity and scalability with servers, service delivery, and operations. We need to learn about other useful patterns, not only object-oriented programming ones.</p>
			<div><div><img src="img/B21896_06_02.jpg" alt="Figure 6.2 – The Microservices pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The Microservices pattern</p>
			<p>One of the main additions to the catalog of patterns for engineers in recent years has been the <strong class="bold">Microservice Architecture</strong> pattern or <strong class="bold">Microservices</strong>. The idea is that we can build an <a id="_idIndexMarker634"/>application as a set of loosely coupled, collaborating services. In this architectural style, an application might consist of services such as the order management service, the customer management service, and so on. These services are loosely <a id="_idIndexMarker635"/>coupled, independently deployable, and communicate via well-defined APIs.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor172"/>Real-world examples</h2>
			<p>We can cite several<a id="_idIndexMarker636"/> examples, such as the following:</p>
			<ul>
				<li><strong class="bold">Netflix</strong>: One of the pioneers in adopting microservices to handle millions of content streams simultaneously</li>
				<li><strong class="bold">Uber</strong>: The company uses microservices to handle different aspects such as billing, notifications, and ride tracking</li>
				<li><strong class="bold">Amazon</strong>: They transitioned from a monolithic architecture to microservices to support their ever-growing scale</li>
			</ul>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor173"/>Use cases for the Microservices pattern</h2>
			<p>We can<a id="_idIndexMarker637"/> think of several use cases<a id="_idIndexMarker638"/> where Microservices offer a clever answer. We can use a Microservices architecture-based design every time we are building an application that has at least one of the following characteristics:</p>
			<ul>
				<li>There is a requirement to support different clients, including desktop and mobile</li>
				<li>There is an API for third parties to consume</li>
				<li>We must communicate with other applications using messaging</li>
				<li>We serve requests by accessing a database, communicating with other systems, and returning the right type of response (JSON, XML, HTML, or even PDF)</li>
				<li>There are logical components corresponding to different functional areas of the application</li>
			</ul>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor174"/>Implementing the microservices pattern – a payment service using gRPC</h2>
			<p>Let’s briefly talk about<a id="_idIndexMarker639"/> software installation and application deployment in<a id="_idIndexMarker640"/> the Microservices world. Switching from deploying a single application to deploying many small services means that the number of things that need to be handled increases exponentially. While you might have been fine with a single application server and a few runtime dependencies, when moving to Microservices, the number of dependencies will increase drastically. For example, one service could benefit from the relational database while the other would <a id="_idIndexMarker641"/>need <strong class="bold">ElasticSearch</strong>. You may need a service that uses <strong class="bold">MySQL</strong> and <a id="_idIndexMarker642"/>another one that uses <a id="_idIndexMarker643"/>the <strong class="bold">Redis</strong> server. So, using the Microservices approach also means you will need to <a id="_idIndexMarker644"/>use <strong class="bold">containers</strong>.</p>
			<p>Thanks to Docker, things have become easier, since we can run those services as containers. The idea is that your application server, dependencies and runtime libraries, compiled code, configurations, and so on, are inside those containers. Then, all you must do is run services packed as containers and make sure that they can communicate with each other.</p>
			<p>You can<a id="_idIndexMarker645"/> implement the Microservices pattern, for a<a id="_idIndexMarker646"/> web app or an API, by directly using Django, Flask, or FastAPI. However, to quickly show a working example, we are going to use gRPC, a high-performance universal RPC framework that uses <strong class="bold">Protocol Buffers</strong> (<strong class="bold">protobuf</strong>) as its<a id="_idIndexMarker647"/> interface description language, making it an ideal candidate for microservices communication due to its efficiency and cross-language support.</p>
			<p>Imagine a scenario where your application architecture includes a microservice dedicated to handling payment<a id="_idIndexMarker648"/> processing. This microservice (let’s call it <code>PaymentService</code>), is responsible for processing payments and interacts with other services such as <code>OrderService</code> and <code>AccountService</code>. We are going to focus on the implementation of such a service using gRPC.</p>
			<p>First, we define the service and its methods using protobuf, in the <code>ch06/microservices/grpc/payment.proto</code> file. This includes specifying request and response message formats:</p>
			<pre class="source-code">
syntax = "proto3";
package payment;
// The payment service definition.
service PaymentService {
  // Processes a payment
  rpc ProcessPayment (PaymentRequest) returns (PaymentResponse) {}
}
// The request message containing payment details.
message PaymentRequest {
  string order_id = 1;
  double amount = 2;
  string currency = 3;
  string user_id = 4;
}
// The response message containing the result of the payment process.
message PaymentResponse {
  string payment_id = 1;
  string status = 2; // e.g., "SUCCESS", "FAILED"
}</pre>			<p>Then, you <a id="_idIndexMarker649"/>must compile the <code>payment.proto</code> file into <a id="_idIndexMarker650"/>Python code using the protobuf compiler (<code>protoc</code>). For that, you need to use a specific command line that <a id="_idIndexMarker651"/>invokes <code>protoc</code> with the appropriate plugins and options for Python.</p>
			<p>Here is the general form of the command line for compiling <code>.proto</code> files for use with gRPC in Python:</p>
			<pre class="source-code">
<code>cd ch06/microservices/grpc</code>), and then we run the following command:</p>
			<pre class="source-code">
<code>payment_pb2.py</code> and <code>payment_pb2_grpc.py</code>. Those files are not to be manually edited.</p>
			<p>Next, we provide, in a <code>payment_service.py</code> file, the service logic for the payment processing, extending what has been provided in the generated <code>.py</code> files. In the module, we define the <code>Pay<a id="_idTextAnchor175"/>mentServiceImpl</code> class, inheriting from the <code>payment_pb2_grpc.PaymentServiceServicer</code> class, and we override the <code>ProcessPayment()</code> method that will do what is needed to process the payment (e.g., calling external APIs, doing database updates, etc.) Note that here, we have a simplified example, but you would have more complex logic. The code is as follows:</p>
			<pre class="source-code">
from concurrent.futures import ThreadPoolExecutor
import grpc
import payment_pb2
import payment_pb2_grpc
class PaymentServiceImpl(payment_pb2_grpc.PaymentServiceServicer):
    def ProcessPayment(self, request, context):
        return payment_pb2.PaymentResponse(payment_id="12345", status="SUCCESS")</pre>			<p>Then, we have <a id="_idIndexMarker652"/>the <code>main()</code> function, with the code<a id="_idIndexMarker653"/> needed to start the <a id="_idIndexMarker654"/>processing service, created by calling <code>grpc.server(ThreadPoolExecutor(max_workers=10))</code>. The code of the function is as follows:</p>
			<pre class="source-code">
def main():
    print("Payment Processing Service ready!")
    server = grpc.server(ThreadPoolExecutor(max_workers=10))
    payment_pb2_grpc.add_PaymentServiceServicer_to_server(PaymentServiceImpl(), server)
    server.add_insecure_port("[::]:50051")
    server.start()
    server.wait_for_termination()</pre>			<p>With th<a id="_idTextAnchor176"/>at, the<a id="_idIndexMarker655"/> service is done and ready to be tested. We need a client to be able to test it. We can write a test client with code that calls the <a id="_idIndexMarker656"/>service using gRPC, with the<a id="_idIndexMarker657"/> following code (in the <code>ch06/microservices/grpc/client.py</code> file):</p>
			<pre class="source-code">
import grpc
import payment_pb2
import payment_pb2_grpc
with grpc.insecure_channel("localhost:50051") as chan:
    stub = payment_pb2_grpc.PaymentServiceStub(chan)
    resp = stub.ProcessPayment(
        payment_pb2.PaymentRequest(
            order_id="order123",
            amount=99.99,
            currency="USD",
            user_id="user456",
        )
    )
    print("Payment Service responded.")
    print(f"Response status: {resp.status}")</pre>			<p>To start the service (in the <code>ch06/microservices/grpc/payment_service.py</code> file), you can run the following command:</p>
			<pre class="source-code">
<strong class="bold">python ch06/microservices/grpc/payment_service.py</strong></pre>			<p>You will get the following output, showing that the service has started as expected:</p>
			<pre class="source-code">
<code>ch06/microservices/grpc/client.py</code> file):</p>
			<pre class="source-code">
<strong class="bold">python ch06/microservices/grpc/client.py</strong></pre>			<p>In the terminal where you have run the client code, you should get the following output:</p>
			<pre class="source-code">
<strong class="bold">Payment Service responded.</strong>
<strong class="bold">Response status: SUCCESS</strong></pre>			<p>This output is what is expected.</p>
			<p>Note <a id="_idIndexMarker658"/>that while gRPC is a powerful choice for Microservices communication, other approaches such as <strong class="bold">REST over HTTP</strong> can also<a id="_idIndexMarker659"/> be used, especially when human readability or web<a id="_idIndexMarker660"/> integration is a priority. However, gRPC <a id="_idIndexMarker661"/>provides advantages in terms of performance and support for streaming requests and responses, and it was interesting to introduce it with this example.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor177"/>Implementing the microservices pattern – an LLM service using Lanarky</h2>
			<p>Lanarky<a id="_idIndexMarker662"/> is a web<a id="_idIndexMarker663"/> framework that builds upon the FastAPI <a id="_idIndexMarker664"/>framework, to provide batteries for building Microservices that<a id="_idIndexMarker665"/> use <strong class="bold">large language </strong><strong class="bold">models</strong> (<strong class="bold">LLMs</strong>).</p>
			<p>We will follow the <em class="italic">Getting started</em> instructions from the website (<a href="https://lanarky.ajndkr.com">https://lanarky.ajndkr.com</a>) to showcase a microservice backed by Lanarky. To be able to test the example, you need to set the <code>OPENAI_API_KEY</code> environment variable to use OpenAI. Visit <a href="https://openai.com">https://openai.com</a> and follow the instructions to get your API key.</p>
			<p>The LLM service code starts by importing the modules we need:</p>
			<pre class="source-code">
import os
import uvicorn
from lanarky import Lanarky
from lanarky.adapters.openai.resources import ChatCompletionResource
from lanarky.adapters.openai.routing import OpenAIAPIRouter</pre>			<p>Before <a id="_idIndexMarker666"/>starting the actual application code, you need to pass the<a id="_idIndexMarker667"/> OpenAI API key, which is used by<a id="_idIndexMarker668"/> Lanarky’s code via the <code>os.environ</code> object. For example, pass the value of the secret key via this line:</p>
			<pre class="source-code">
os.environ["OPENAI_API_KEY"] = "Your OpenAI API key here"</pre>			<p class="callout-heading">Security practice</p>
			<p class="callout">It is recommended that you pass secret keys to the code, by setting an environment variable in your shell.</p>
			<p>Then, we create an <code>app</code> object, an instance of the <code>Lanarky</code> class, and the <code>router</code> object that will be used for the definition of the service’s routes, as is conventional with FastAPI. This router is an instance of the <code>OpenAPIRouter</code> class provided by the Lanarky f<a id="_idTextAnchor178"/>ramework:</p>
			<pre class="source-code">
app = Lanarky()
router = OpenAIAPIRouter()</pre>			<p>Next, we provide a <code>chat()</code> function for the <code>/chat</code> route, when there is a <code>POST</code> request, as follows:</p>
			<pre class="source-code">
@router.post("/chat")
def chat(stream: bool = True) -&gt; ChatCompletionResource:
    system = "Here is your assistant"
    return ChatCompletionResource(stream=stream, system=system)</pre>			<p>Finally, we associate the router to the FastAPI application (standard FastAPI convention) and we run the FastAPI application (our service) using <code>uvicorn.run()</code>, as follows:</p>
			<pre class="source-code">
if __name__ == "__main__":
    app.include_router(router)
    uvicorn.run(app)</pre>			<p>To finalize this <a id="_idIndexMarker669"/>demonstration implementation, we can write client <a id="_idIndexMarker670"/>code to interact with the service. The<a id="_idIndexMarker671"/> code for that part is as follows:</p>
			<pre class="source-code">
import click
import sys
from lanarky.clients import StreamingClient
args = sys.argv[1:]
if len(args) == 1:
    message = args[0]
    client = StreamingClient()
    for event in client.stream_response(
        "POST",
        "/chat",
        params={"stream": "false"},
        json={"messages": [dict(role="user", content=message)]},
    ):
        print(f"{event.event}: {event.data}")
else:
    print("You need to pass a message!")</pre>			<p>To test the <a id="_idIndexMarker672"/>example, similarly to the previous one (where we<a id="_idIndexMarker673"/> tested a gRPC-based microservice), open <a id="_idIndexMarker674"/>a terminal, and run the LLM service code (in the <code>ch06/microservices/lanarky/llm_service.py</code> file) using the following command:</p>
			<pre class="source-code">
<strong class="bold">python ch06/microservices/lanarky/llm_service.py</strong></pre>			<p>You should get an output like the following:</p>
			<pre class="source-code">
<strong class="bold">INFO:   Started server process [18617]</strong>
<strong class="bold">INFO:   Waiting for application startup.</strong>
<strong class="bold">INFO:   Application startup complete.</strong>
<strong class="bold">INFO:   Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)</strong></pre>			<p>Then, open a second terminal to run the client program, using the following command:</p>
			<pre class="source-code">
<strong class="bold">python ch06/microservices/lanarky/client.py "Hello"</strong></pre>			<p>You should get the following output:</p>
			<pre class="source-code">
<strong class="bold">completion: Hello! How can I assist you today?</strong></pre>			<p>Now, you can continue sending messages via the client program, and wait for the service to come back with the completion, as you would do via the ChatGPT interface.</p>
			<p>For example, see the following code:</p>
			<pre class="source-code">
<strong class="bold">python ch06/microservices/lanarky/client.py "What is the capital of Switzerland?"</strong>
<strong class="bold">completion: The capital of Switzerland is Bern.</strong></pre>			<h1 id="_idParaDest-169"><a id="_idTextAnchor179"/>The Serverless pattern</h1>
			<p>The <a id="_idIndexMarker675"/>Serverless pattern<a id="_idIndexMarker676"/> abstracts server management, allowing developers to focus solely on code. Cloud providers handle the scaling and execution based on event triggers, such <a id="_idIndexMarker677"/>as HTTP requests, file uploads, or database modifications.</p>
			<div><div><img src="img/B21896_06_03.jpg" alt="Figure 6.3 – The Serverless pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The Serverless pattern</p>
			<p>The<a id="_idIndexMarker678"/> Serverless pattern is particularly useful for Microservices, APIs, and event-driven architectures.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor180"/>Real-world examples</h2>
			<p>There are several examples we can<a id="_idIndexMarker679"/> think of for the Serverless pattern. Here are some of them:</p>
			<ul>
				<li><strong class="bold">Automated data backups</strong>: Serverless functions can be scheduled to automatically back up important data to cloud storage</li>
				<li><strong class="bold">Image processing</strong>: Whenever a user uploads an image, a serverless function can automatically resize, compress, or apply filters to the image</li>
				<li><strong class="bold">PDF generation for E-commerce receipts</strong>: After a purchase is made, a serverless function generates a PDF receipt and emails it to the customer</li>
			</ul>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor181"/>Use cases for the Serverless pattern</h2>
			<p>There are two types of use cases<a id="_idIndexMarker680"/> the Serverless pattern can be used for.</p>
			<p>First, Serverless is useful for handling event-driven architectures where specific functions need to be executed in response to events, such as doing image processing (cropping, resizing) or dynamic PDF generation.</p>
			<p>The second type of <a id="_idIndexMarker681"/>architecture where Serverless can be used<a id="_idIndexMarker682"/> is <strong class="bold">Microservices</strong>. Each microservice can be a serverless function, making it easier to manage and scale.</p>
			<p>Since we have already <a id="_idIndexMarker683"/>discussed the Microservices pattern in the previous section, we are going to focus on how to implement the first use case.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor182"/>Implementing the Serverless pattern</h2>
			<p>Let’s see a simple example<a id="_idIndexMarker684"/> using AWS Lambda to create a function that squares a number. AWS Lambda<a id="_idIndexMarker685"/> is Amazon’s serverless <strong class="bold">compute</strong> service, which runs code in response to triggers such as changes in data, shifts in system state, or actions by users.</p>
			<p>There is no need to add more complexity since there’s already enough to get right with the Serverless architecture itself and AWS Lambda’s deployment details.</p>
			<p>First, we need to write the Python code for the function. We create a <code>lambda_handler()</code> function, which takes two parameters, <code>event</code> and <code>context</code>. In our case, the input number is accessed as a value of the “number” key in the event dictionary. We take the square of that value and we return a a string containing the expected result. The code is as follows:</p>
			<pre class="source-code">
import json
def lambda_handler(event, context):
    number = event["number"]
    squared = number * number
    return f"The square of {number} is {squared}."</pre>			<p>Once we have the<a id="_idIndexMarker686"/> Py<a id="_idTextAnchor183"/>thon function, we need to deploy it<a id="_idIndexMarker687"/> so that it can be invoked as an AWS Lambda function. For our learning, instead of going through the procedure of deploying to AWS infrastructure, we can use a method that consists of testing things locally. This is what the <code>LocalStack</code> Python package allows us to do. Once it is installed, from your environment, you can start LocalStack inside a Docker container by running the available executable in your Python environment, using the command:</p>
			<pre class="source-code">
<code>ch06/lambda_function_square.py</code>) to a ZIP file, for example, by using the ZIP program as follows:</p>
			<pre class="source-code">
<code>awslocal</code> tool (a Python module we need to install). Once installed, we can use this program to deploy the Lambda function into the “local stack” AWS infrastructure. This is done, in our case, using the following command:</p>
			<pre class="source-code">
<strong class="bold">awslocal lambda create-function \</strong>
<strong class="bold">    --function-name lambda_function_square \</strong>
<strong class="bold">    --runtime python3.11 \</strong>
<strong class="bold">    --zip-file fileb://lambda.zip \</strong>
<strong class="bold">    --handler lambda_function_square.lambda_handler \</strong>
<strong class="bold">    --role arn:aws:iam::000000000000:role/lambda-role</strong></pre>			<p class="callout-heading">Adapt to your Python version</p>
			<p class="callout">At the time of writing, this was tested with Python 3.11. You must adapt this command to your Python version.</p>
			<p>You can test the Lambda function, providing an input using the <code>payload.json</code> file, using the command:</p>
			<pre class="source-code">
<strong class="bold">awslocal lambda invoke --function-name lambda_function_square \</strong>
<code>output.txt</code> file’s content. You should see the text:</p>
			<pre class="source-code">
<code>awslocal</code>, running the following command:</p>
			<pre class="source-code">
<strong class="bold">awslocal lambda create-function-url-config \</strong>
<strong class="bold">    --function-name lambda_function_square \</strong>
<code>http://&lt;XXXXXXXX&gt;.lambda-url.us-east-1.localhost.localstack.cloud:4566</code> format.</p>
			<p>Now, for example, we can trigger the Lambda function URL using <code>cUrl</code>:</p>
			<pre class="source-code">
<strong class="bold">curl -X POST \</strong>
<strong class="bold">    'http://iu4s187onr1oabg50dbvm77bk6r5sunk.lambda-url.us-east-1.localhost.localstack.cloud:4566/' \</strong>
<strong class="bold">    -H 'Content-Type: application/json' \</strong>
<strong class="bold">    -d '{"number": 6}'</strong></pre>			<p>For up-to-date and detailed guides related to AWS Lambda, consult the documentation at <a href="https://docs.aws.amazon.com/lambda/">https://docs.aws.amazon.com/lambda/</a>.</p>
			<p>This was a minimal example. Another example of a serverless application could be a function that generates PDF receipts for a business. This would allow the business to not worry about server management and only pay for the computing time that is consumed.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor184"/>The Event Sourcing pattern</h1>
			<p>The Event Sourcing pattern <a id="_idIndexMarker690"/>stores state changes as a sequence of events, allowing the <a id="_idIndexMarker691"/>reconstruction of past states and providing an audit trail. This pattern is particularly useful in systems where the state is complex and the business rules for transitions are complex.</p>
			<p>As we will see in implementation examples later, the Event Sourcing pattern emphasizes the importance of capturing all changes to an application state as a sequence of events. An outcome of this is that the application state can be reconstructed at any point in time by replaying these events.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor185"/>Real-world examples</h2>
			<p>There are several real-world<a id="_idIndexMarker692"/> examples in the software category:</p>
			<ul>
				<li><strong class="bold">Audit trails</strong>: Keeping a record of all changes made to a database for compliance</li>
				<li><strong class="bold">Collaborative editing</strong>: Allowing multiple users to edit a document simultaneously</li>
				<li><strong class="bold">Undo/redo features</strong>: Providing the ability to undo or redo actions in an application</li>
			</ul>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor186"/>Use cases for the Event Sourcing pattern</h2>
			<p>There are several use cases<a id="_idIndexMarker693"/> for the Event Sourcing pattern. Let’s consider the following three:</p>
			<ul>
				<li><strong class="bold">Financial transactions</strong>: Event <a id="_idIndexMarker694"/>Sourcing can be used to record every change to an account’s balance as a chronological series of immutable events. This method ensures that every deposit, withdrawal, or transfer is captured as a distinct event. This way, we can provide a transparent, auditable, and secure ledger of all financial activities.</li>
				<li><strong class="bold">Inventory management</strong>: Within inventory management contexts, Event Sourcing helps in tracking each item’s life cycle by logging all changes as events. This enables businesses to maintain accurate and up-to-date records of stock levels, identify patterns in item usage or sales, and predict future inventory needs. It also facilitates tracing the history of any item, aiding in recall processes or quality assurance investigations.</li>
				<li><strong class="bold">Customer behavior tracking</strong>: Event Sourcing plays a critical role in capturing and storing every interaction a customer has with a platform, from browsing history and cart modifications to purchases and returns. This wealth of data, structured as a series of events, becomes a valuable resource for analyzing customer behavior, personalizing marketing strategies, enhancing user experience, and improving<a id="_idIndexMarker695"/> product recommendations.</li>
			</ul>
			<p>Let’s now see how we can implement this pattern.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor187"/>Implementing the event sourcing pattern – the manual way</h2>
			<p>Let’s start with some <a id="_idIndexMarker696"/>definitions. The components of the Event<a id="_idIndexMarker697"/> Sourcing pattern implementation are as follows:</p>
			<ul>
				<li><strong class="bold">Event</strong>: A representation of a state change, typically containing the type of event and the data associated with that event. Once an event is created and applied, it cannot be changed.</li>
				<li><strong class="bold">Aggregate</strong>: An object (or group of objects) that represents a single unit of business logic or data. It keeps track of things, and every time something changes (an event), it makes a record of it.</li>
				<li><strong class="bold">Event store</strong>: A collection of all the events that have occurred.</li>
			</ul>
			<p>By handling state changes through events, the business logic becomes more flexible and easier to extend. For example, adding new types of events or modifying the handling of existing events can be done with minimal impact on the rest of the system.</p>
			<p>In this first example, for the bank account use case, we will see how to implement the event sourcing pattern in a manual way. In such an implementation, you would typically define your event classes and manually write the logic to apply these events to your aggregates. Let’s see that.</p>
			<p>We start by defining an <code>Account</code> class <a id="_idIndexMarker698"/>representing a bank account with a balance and a list of events attached to it, for the operations on the account. This class acts as the aggregate. Its <code>events</code> attribute represents the event store. Here, an event will be represented by a dictionary containing the type of operation (“deposited” or “withdrawn”) and the amount value.</p>
			<p>We then add the <code>apply_event()</code> method taking an event as the input. Depending on <code>event["type"]</code>, we increment or decrement the account balance by the event’s amount, and we add the event to the <code>events</code> list, effectively storing the event:</p>
			<pre class="source-code">
class Account:
    def __init__(self):
        self.balance = 0
        self.events = []
    def apply_event(self, event):
        if event["type"] == "deposited":
            self.balance += event["amount"]
        elif event["type"] == "withdrawn":
            self.balance -= event["amount"]
        self.events.append(event)</pre>			<p>Then, we add a <code>deposit()</code> method <a id="_idIndexMarker699"/>and a <code>withdraw()</code> method, which both call the <code>apply_event()</code> method, as follows:</p>
			<pre class="source-code">
    def deposit(self, amount):
        event = {"type": "deposited", "amount": amount}
        self.apply_event(event)
    def withdraw(self, amount):
        event = {"type": "withdrawn", "amount": amount}
        self.apply_event(event)</pre>			<p>Finally, we<a id="_idIndexMarker700"/> add the <code>main()</code> function, as <a id="_idIndexMarker701"/>follows:</p>
			<pre class="source-code">
def main():
    account = Account()
    account.deposit(100)
    account.deposit(50)
    account.withdraw(30)
    account.deposit(30)
    for evt in account.events:
        print(evt)
    print(f"Balance: {account.balance}")</pre>			<p>Running the code, using the <code>python ch06/ event_sourcing/bankaccount.py</code> command, gives the following output:</p>
			<pre class="source-code">
<strong class="bold">{'type': 'deposited', 'amount': 100}</strong>
<strong class="bold">{'type': 'deposited', 'amount': 50}</strong>
<strong class="bold">{'type': 'withdrawn', 'amount': 30}</strong>
<strong class="bold">{'type': 'deposited', 'amount': 30}</strong>
<strong class="bold">Balance: 150</strong></pre>			<p>This example provided a first understanding of Event Sourcing through a simple, manual implementation. For more complex systems, frameworks and libraries designed for Event Sourcing can help manage some of this complexity, providing utilities for event storage, querying, and processing. We will test such a library next.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor188"/>Implementing the Event Sourcing pattern – using a library</h2>
			<p>In this second example, we <a id="_idIndexMarker702"/>will use the <code>eventsourcing</code> library to<a id="_idIndexMarker703"/> implement the Event Sourcing pattern. Let’s consider an inventory management system where we track the quantity of items.</p>
			<p>We start by importing what we need, as follows:</p>
			<pre class="source-code">
from eventsourcing.domain import Aggregate, event
from eventsourcing.application import Application</pre>			<p>Then, we define the class for the aggregate object, <code>InventoryItem</code>, by inheriting from the <code>Aggregate</code> class. The class has an <code>increase_quantity()</code> and a <code>decrease_quantity</code> method, each decorated with the <code>@event</code> decorator. The code for this class is as follows:</p>
			<pre class="source-code">
class InventoryItem(Aggregate):
    @event("ItemCreated")
    def __init__(self, name, quantity=0):
        self.name = name
        self.quantity = quantity
    @event("QuantityIncreased")
    def increase_quantity(self, amount):
        self.quantity += amount
    @event("QuantityDecreased")
    def decrease_quantity(self, amount):
        self.quantity -= amount</pre>			<p>Next, we create our inventory application’s class, <code>InventoryApp</code>, inheriting from the <code>eventsourcing</code> library’s <code>Application</code> class. The first method handles the creation of an item, taking an instance of the <code>InventoryItem</code> class (<code>item</code>) and calling the <code>save()</code> method on the <code>InventoryApp</code> object using the item. But what exactly does the <code>save()</code> method do? It collects pending events from given aggregates and puts them in the application’s event store. The definition of the class starts as follows:</p>
			<pre class="source-code">
class InventoryApp(Application):
    def create_item(self, name, quantity):
        item = InventoryItem(name, quantity)
        self.save(item)
        return item.id</pre>			<p>Next, similarly to what we did in the previous example, we add an <code>increase_item_quantity()</code> method, which handles the increase of the item’s quantity (for the aggregate object) and then saves the aggregate object on the application, followed by the corresponding <code>decrease_item_quantity()</code> method, for the decreasing action, as follows:</p>
			<pre class="source-code">
    def increase_item_quantity(self, item_id, amount):
        item = self.repository.get(item_id)
        item.increase_quantity(amount)
        self.save(item)
    def decrease_item_quantity(self, item_id, amount):
        item = self.repository.get(item_id)
        item.decrease_quantity(amount)
        self.save(item)</pre>			<p>Finally, we add the <code>main()</code> function, with <a id="_idIndexMarker704"/>some code to test our design, as<a id="_idIndexMarker705"/> follows:</p>
			<pre class="source-code">
def main():
    app = InventoryApp()
    # Create a new item
    item_id = app.create_item("Laptop", 10)
    # Increase quantity
    app.increase_item_quantity(item_id, 5)
    # Decrease quantity
    app.decrease_item_quantity(item_id, 3)
    notifs = app.notification_log.select(start=1, limit=5)
    notifs = [notif.state for notif in notifs]
    for notif in notifs:
        print(notif.decode())</pre>			<p>Running the <a id="_idIndexMarker706"/>code, using the <code>python ch06/ event_sourcing/inventory.py</code> command, gives the<a id="_idIndexMarker707"/> following output:</p>
			<pre class="source-code">
<strong class="bold">{"timestamp":{"_type_":"datetime_iso","_data_":"2024-03-18T08:05:10.583875+00:00"},"originator_topic":"__main__:InventoryItem","name":"Laptop","quantity":10}</strong>
<strong class="bold">{"timestamp":{"_type_":"datetime_iso","_data_":"2024-03-18T08:05:10.584818+00:00"},"amount":5}</strong>
<code>eventsourcing</code> library, which makes it easier to implement this type of application.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor189"/>Other architectural design patterns</h1>
			<p>You may encounter documentation about other architectural design patterns. Here are three other patterns:</p>
			<ul>
				<li><strong class="bold">Event-Driven Architecture (EDA)</strong>: This <a id="_idIndexMarker708"/>pattern emphasizes the production, detection, consumption of, and reaction to events. EDA <a id="_idIndexMarker709"/>is highly adaptable and scalable, making it suitable for environments where systems need to react to significant events in real time.</li>
				<li><strong class="bold">Command Query Responsibility Segregation (CQRS)</strong>: This pattern separates the models for reading <a id="_idIndexMarker710"/>and writing data, allowing for more scalable and maintainable architectures, especially <a id="_idIndexMarker711"/>when there are clear distinctions between operations that mutate data and those that only read data.</li>
				<li><strong class="bold">Clean Architecture</strong>: This<a id="_idIndexMarker712"/> pattern proposes a<a id="_idIndexMarker713"/> way to organize code such that it encapsulates the business logic but keeps it separate from the interfaces through which the application is exposed to users or other systems. It emphasizes the use of dependency inversion to drive the decoupling of software components.</li>
			</ul>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor190"/>Summary</h1>
			<p>In this chapter, we explored several foundational architectural design patterns that are pivotal in modern software development, each useful for different requirements and solving unique challenges.</p>
			<p>We first covered the MVC pattern, which promotes the separation of concerns by dividing the application into three interconnected components. This separation allows for more manageable, scalable, and testable code by isolating the UI, the data, and the logic that connects the two.</p>
			<p>Then, we looked at the Microservices pattern, which takes a different approach by structuring an application as a collection of small, independent services, each responsible for a specific business function. This pattern enhances scalability, flexibility, and ease of deployment, making it an ideal choice for complex, evolving applications that need to rapidly adapt to changing business requirements.</p>
			<p>Next, we looked at the Serverless pattern, which shifts the focus from server management to pure business logic by leveraging cloud services to execute code snippets in response to events. This pattern offers significant cost savings, scalability, and productivity benefits by abstracting the underlying infrastructure, allowing developers to concentrate on writing code that adds direct value.</p>
			<p>Afterward, we went over the Event Sourcing pattern, which offers another way to handle data changes in an application by storing each change as a sequence of events. This not only provides a robust audit trail and enables complex business functionalities but also allows the system to reconstruct past states, offering invaluable insights into the data life cycle and changes over time.</p>
			<p>Lastly, we touched upon other architectural design patterns, such as CQRS and Clean Architecture. Each offers unique advantages and addresses different aspects of software design and architecture. Even if we could not dive deep into these patterns, they complement the developer’s toolkit for building well-structured and maintainable systems.</p>
			<p>In the next chapter, we will discuss concurrency and asynchronous patterns and techniques to help our program manage multiple operations simultaneously or move on to other tasks while waiting for operations to complete.</p>
		</div>
	</body></html>