["```py\n@app.get(\"/stalls/<market_date:ymd>\")\nasync def market_stalls(request: Request, market_date: date):\n    info = await fetch_stall_info(market_date)\n    return json({\"stalls\": info})\n```", "```py\nfrom enum import Enum, auto\nclass ParticipantType(Enum):\n    UNKNOWN = auto()\n    FARMER = auto()\n    RESTAURANT = auto()\n    CONSUMER = auto()\n@app.get(\"/stalls/<market_date:ymd>\")\nasync def market_stalls(request: Request, market_date: date):\n    header = request.headers.get(\"participant-type\", \"unknown\")\n    try:\n        paticipant_type = ParticipantType[header.upper()]\n    except KeyError:\n        paticipant_type = ParticipantType.UNKNOWN\n    info = await fetch_stall_info(market_date, paticipant_type)\n    return json(\n        {\n            \"meta\": {\n                \"market_date\": market_date.isoformat(),\n                \"paticipant_type\": paticipant_type.name.lower(),\n            },\n            \"stalls\": info,\n        }\n    )\n```", "```py\n    $ curl localhost:8000/stalls/2021-06-24 -H \"Participant-Type: farmer\"\n    {\n      \"meta\": {\n        \"market_date\": \"2021-06-24\",\n        \"paticipant_type\": \"farmer\"\n      },\n      \"stalls\": [...]\n    }\n    ```", "```py\n    $ curl localhost:8000/stalls/2021-06-24 \n    {\n      \"meta\": {\n        \"market_date\": \"2021-06-24\",\n        \"paticipant_type\": \"unknown\"\n      },\n      \"stalls\": [...]\n    }\n    ```", "```py\n    $ curl localhost:9898/stalls/2021-06-24 -H \"Participant-Type: organizer\"\n    {\n      \"meta\": {\n        \"market_date\": \"2021-06-24\",\n        \"paticipant_type\": \"unknown\"\n      },\n      \"stalls\": [...]\n    }\n    ```", "```py\n@app.on_request\nasync def determine_participant_type(request: Request):\n    header = request.headers.get(\"participant-type\", \"unknown\")\n    try:\n        paticipant_type = ParticipantType[header.upper()]\n    except KeyError:\n        paticipant_type = ParticipantType.UNKNOWN\n    request.ctx.paticipant_type = paticipant_type\n@app.get(\"/stalls/<market_date:ymd>\")\nasync def market_stalls(request: Request, market_date: date):\n    info = await fetch_stall_info(market_date, request.ctx.paticipant_type)\n    return json(\n        {\n            \"meta\": {\n                \"market_date\": market_date.isoformat(),\n                \"paticipant_type\": request.ctx.paticipant_type.name.lower(),\n            },\n            \"stalls\": info,\n        }\n    )\n```", "```py\nfrom functools import wraps\nfrom sanic.exceptions import Unauthorized\ndef authenticated(handler=None):\n    def decorator(f):\n        @wraps(f)\n        async def decorated_function(request, *args, **kwargs):\n            auth_header = request.headers.get(\"authorization\")\n            is_authenticated = await check_authentication(auth_header)\n            if is_authenticated:\n                return await f(request, *args, **kwargs)\n            else:\n                raise Unauthorized(\"who are you?\")\n        return decorated_function\n    return decorator(handler) if handler else decorator\n@app.route(\"/\")\n@authenticated\nasync def handler(request):\n    return json({\"status\": \"authenticated\"})\n```", "```py\n@app.on_request\nasync def do_check_authentication(request: Request):\n    is_authenticated = await check_authentication(auth_header)\n    if not is_authenticated:\n        raise Unauthorized(\"who are you?\")\n```", "```py\n@app.on_request\nasync def do_check_authentication(request: Request):\n    if request.route and request.route.name not in (\n        \"MyApp.login\",\n        \"MyApp.market_stalls\",\n    ):\n        is_authenticated = await check_authentication(auth_header)\n        if not is_authenticated:\n            raise Unauthorized(\"who are you?\")\n```", "```py\n@app.route(..., name=\"hello_world\")\n```", "```py\nprotected = Blueprint(\"Protected\")\n@protected.route(\"/\")\nasync def handler(request):\n    return json({\"status\": \"authenticated\"})\n@protected.on_request\nasync def do_check_authentication(request: Request):\n    auth_header = request.headers.get(\"authorization\")\n    is_authenticated = await check_authentication(auth_header)\n    if not is_authenticated:\n        raise Unauthorized(\"who are you?\")\n```", "```py\none_to_one = {\n  \"fruit\": \"apples\"\n}\none_to_many = {\n  \"Fruit\": [\"apples\", \"bananas\"]\n}\n```", "```py\n\"fruit\" in one_to_one and \"fruit\" in one_to_many\n```", "```py\n@app.route(\"/\")\nasync def handler(request):\n    return json(\n        {\n            \"fruit_brackets\": request.headers[\"fruit\"],\n            \"fruit_get\": request.headers.get(\"fruit\"),\n            \"fruit_getone\": request.headers.getone(\"fruit\"),\n            \"fruit_getall\": request.headers.getall(\"fruit\"),\n        }\n    )\n```", "```py\n$ curl localhost:7777/ -H \"Fruit: apples\" -H \"Fruit: Bananas\"\n{\n  \"fruit_brackets\": \"apples\",\n  \"fruit_get\": \"apples\",\n  \"fruit_getone\": \"apples\",\n  \"fruit_getall\": [\n    \"apples\",\n    \"Bananas\"\n  ]\n}\n```", "```py\n    @app.route(\"/cookies\")\n    async def cookies(request):\n        return json(request.cookies)\n    ```", "```py\n    $ curl localhost:7777/cookie -H \"Cookie: name=value; name2=value2; name3=value3\"\n    {\n      \"name\": \"value\",\n      \"name2\": \"value2\",\n      \"name3\": \"value3\"\n    }\n    ```", "```py\nGET /stalls/2021-07-01?type=fruit HTTP/1.1\n```", "```py\n@app.route(\"/\")\nasync def handler(request: Request):\n    print(request.args)\n    return text(request.args.get(\"fruit\"))\n$ curl localhost:7777\\?fruit=apples\napples\n```", "```py\n{'fruit': ['apples']}\n[INFO][127.0.0.1:53842]: GET http://localhost:7777/?fruit=apples  200 6\n```", "```py\n@app.route(\"/\")\nasync def handler(request: Request):\n    return json(\n        {\n            \"fruit_brackets\": request.args[\"fruit\"],\n            \"fruit_get\": request.args.get(\"fruit\"),\n            \"fruit_getlist\": request.args.getlist(\"fruit\"),\n        }\n    )\n```", "```py\n$ curl localhost:7777\\?fruit=apples\\&fruit=bananas\n{\n  \"fruit_brackets\": [\"apples\",\"bananas\"],\n  \"fruit_get\": \"apples\",\n  \"fruit_getlist\": [\"apples\",\"bananas\"]\n}\n```", "```py\nrequest.query_args == [('fruit', 'apples'), ('fruit', 'bananas')]\n```", "```py\n>>> dict( [('fruit', 'apples'), ('fruit', 'bananas')])\n{'fruit': 'bananas'}\n```", "```py\n@app.post(\"/form\")\nasync def form_handler(request: Request):\n    return json(request.form)\n@app.post(\"/files\")\nasync def file_handler(request: Request):\n    return json(request.files)\n```", "```py\n$ curl localhost:7777/form -F 'fruit=apples'                   \n{\"fruit\":[\"apples\"]}\n$ curl localhost:7777/form -F 'fruit=apples' -F 'fruit=bananas'\n{\"fruit\":[\"apples\",\"bananas\"]}\n```", "```py\nassert request.form.get(\"fruit\") == \"apples\"\nassert request.form.getlist(\"fruit\") == [\"apples\",\"bananas\"]\n```", "```py\n$ curl localhost:7777/files -F 'po=@/tmp/purchase_order.txt'\n{\n\"po\": [\n[\"text\\/plain\",\"product,qty\\napples,99\\n\",\"purchase_order.txt\"]\n]\n}\n```", "```py\nFile(\n    type='text/plain',\n    body=b'product,qty\\napples,99\\n',\n    name='purchase_order.txt'\n)\n```", "```py\n@app.post(\"/\")\nasync def handler(request: Request):\nreturn json(request.json)\nOur request JSON is converted to a Python dictionary.\n$ curl localhost:7777 -d '{\"foo\": \"bar\"}'     \n{\"foo\":\"bar\"}\n```", "```py\nasync def read_full_body(request: Request):\n    result = \"\"\n    while True:\n        body = await request.stream.read()\n        if body is None:\n            break\n        result += body.decode(\"utf-8\")\n    return result\n@app.post(\"/transaction\", stream=True)\nasync def transaction(request: Request):\n    body = await read_full_body(request)\n    data = ujson.loads(body)\n    await do_transaction(data)\n    return text(\"Transaction recorded\", status=201)\n```", "```py\n    from sanic.views import stream\n    @app.post(\"/transaction\", stream=True)\n    async def transaction(request: Request):\n        ...\n    # OR\n    @app.post(\"/transaction\")\n    @stream\n    async def transaction(request: Request):\n        ...\n    ```", "```py\n    result = \"\"\n    while True:\n        body = await request.stream.read()\n        if body is None:\n            break\n        result += body.decode(\"utf-8\")\n    ```", "```py\n@app.post(\"/upload\")\n@stream\nasync def upload(request: Request):\n    filename = await request.stream.read()\n    async with aiofiles.open(filename.decode(\"utf-8\"), mode=\"w\") as f:\n        while True:\n            body = await request.stream.read()\n            if body is None:\n                break\n            await f.write(body.decode(\"utf-8\"))\n    return text(\"Done\", status=201)\n```", "```py\n@app.post(\"/stalls\")\n@validate\nasync def book_a_stall(request: Request, body: BookStallBody):\n    ...\n```", "```py\ndef validate(wrapped=None):\n    def decorator(handler):\n        @wraps(handler)\n        async def decorated_function(request, *args, **kwargs):\n            return await handler(request, *args, **kwargs)\n        return decorated_function\n    return decorator if wrapped is None else decorator(wrapped)\n```", "```py\n@app.post(\"/stalls\")\n@validate(model=BookStallBody, location=\"body\")\nasync def book_a_stall(request: Request, body: BookStallBody):\n    ...\n```", "```py\nimport typing\ndef validate(wrapped=None):\n    def decorator(handler):\n        annotations = typing.get_type_hints(handler)\n        body_model = None\n        for param_name, annotation in annotations.items():\n            if param_name == \"body\":\n                body_model = annotation\n        # Remainder of decorator skipped\n```", "```py\ndef validate(wrapped=None, body_arg=\"body\"):\n    def decorator(handler):\n        annotations = typing.get_type_hints(handler)\n        body_model = None\n        for param_name, annotation in annotations.items():\n            if param_name == body_arg:\n                body_model = annotation\n        @wraps(handler)\n        async def decorated_function(request, *args, **kwargs):\n            nonlocal body_model\n\n            return await handler(request, *args, **kwargs)\n        return decorated_function\n    return decorator if wrapped is None else decorator(wrapped)\n```", "```py\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nclass ProductType(Enum):\n    def _generate_next_value_(name, *_):\n        return name.lower()\n    FRUIT = auto()\n    VEGETABLES = auto()\n    FISH = auto()\n    MEAT = auto()\nclass ValidatorModel:\n    def __post_init__(self):\n        ...\n@dataclass\nclass Product(ValidatorModel):\n    name: str\n    product_type: ProductType\n@dataclass\nclass BookStallBody(ValidatorModel):\n    name: str\n    vendor_id: UUID\n    description: str\n    employees: int\n    products: List[Product]\n```", "```py\nassert ProductType.FRUIT.value == \"fruit\"\n```", "```py\n{\n    \"name\": \"Adam's Fruit Stand\",\n    \"vendor_id\": \"b716337f-98a9-4426-8809-2b52fbb807b3\",\n    \"employees\": 1,\n    \"description\": \"The best fruit you've ever tasted\",\n    \"products\": [\n        {\n            \"name\": \"bananas\",\n            \"product_type\": \"fruit\"\n        }\n    ]\n}\n```", "```py\nclass ValidatorModel:\n    def __post_init__(self):\n        for field in fields(self.__class__):\n            existing = getattr(self, field.name)\n            hydrated = self._hydrate(field.type, existing)\n\n            if hydrated:\n                setattr(self, field.name, hydrated)\n            elif type(existing) is not field.type:\n                setattr(self, field.name, field.type(existing))\n\n    def _hydrate(self, field_type, value):\n        args = get_args(field_type)\n        check_type = field_type\n        if args:\n            check_type = args[0]\n        if is_dataclass(check_type):\n            if isinstance(value, list):\n                return [self._hydrate(check_type, item) for item in value]\n            elif isinstance(value, dict):\n                return field_type(**value)\n        return None\n```", "```py\ndef validate(wrapped=None, body_arg=\"body\"):\n    def decorator(handler):\n        annotations = get_type_hints(handler)\n        body_model = None\n        for param_name, annotation in annotations.items():\n            if param_name == body_arg:\n                body_model = annotation\n        @wraps(handler)\n        async def decorated_function(request, *args, **kwargs):\n            nonlocal body_model\n            nonlocal body_arg\n            if body_model:\n                kwargs[body_arg] = do_validation(body_model, request.json)\n            return await handler(request, *args, **kwargs)\n        return decorated_function\n    return decorator if wrapped is None else decorator(wrapped)\n```", "```py\nif body_model:\n    kwargs[body_arg] = do_validation(body_model, request.json)\n```", "```py\nfrom sanic.exceptions import SanicException\nclass ValidationError(SanicException):\n    status_code = 400\ndef do_validation(model, data):\n    try:\n        instance = model(**data)\n    except (ValueError, TypeError) as e:\n        raise ValidationError(\n            f\"There was a problem validating {model} \"\n            f\"with the raw data: {data}.\\n\"\n            f\"The encountered exception: {e}\"\n        ) from e\n    return instance\n```", "```py\n    from pydantic.dataclasses import dataclass\n    ```", "```py\n    @dataclass\n    class Product:\n    name: str\n    product_type: ProductType\n    @dataclass\n    class BookStallBody:\n    name: str\n    vendor_id: UUID\n    description: str\n    employees: int\n    products: List[Product]\n    @dataclass\n    class PaginationQuery:\n    limit: int = field(default=0)\n    offset: int = field(default=0)\n    ```", "```py\n    def do_validation(model, data):\n        try:\n            instance = model(**data)\n        except PydanticValidationError as e:\n            raise ValidationError(\n                f\"There was a problem validating {model} \"\n                f\"with the raw data: {data}.\\n\"\n                f\"The encountered exception: {e}\"\n            ) from e\n        return instance\n    ```", "```py\n    from dataclasses import field\n    @dataclass\n    class PaginationQuery:\n        limit: int = field(default=0)\n        offset: int = field(default=0)\n    ```", "```py\n    def validate(\n        wrapped=None,\n        body_arg=\"body\",\n        query_arg=\"query\",\n    ):\n        def decorator(handler):\n            annotations = get_type_hints(handler)\n            body_model = None\n            query_model = None\n            for param_name, annotation in annotations.items():\n                if param_name == body_arg:\n                    body_model = annotation\n                elif param_name == query_arg:\n                    query_model = annotation\n            @wraps(handler)\n            async def decorated_function(request: Request, *args, **kwargs):\n                nonlocal body_arg\n                nonlocal body_model\n                nonlocal query_arg\n                nonlocal query_model\n                if body_model:\n                    kwargs[body_arg] = do_validation(body_model, request.json)\n                if query_model:\n                    kwargs[query_arg] = do_validation(query_model, dict(request.query_args))\n                return await handler(request, *args, **kwargs)\n            return decorated_function\n        return decorator if wrapped is None else decorator(wrapped)\n    ```", "```py\n    @app.get(\"/stalls/<market_date:ymd>\")\n    @validate\n    async def check_stalls(\n        request: Request,\n        query: PaginationQuery,\n        market_date: date,\n    ):\n        ...\n    ```"]