- en: Chapter 4. Wrapping States Around Execution Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve covered execution modules and configuration modules, it''s
    time to talk about configuration management. The idea behind a state module is
    to use execution modules as a mechanism for bringing a resource to a certain state:
    a package is in an installed state, a service is in a running state, a file''s
    contents match the state defined on the Master. In this chapter, we''ll discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: The concepts behind a basic state module layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding how far to take each state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting state modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forming a state module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State modules are more structured than most other kinds of modules, but as you'll
    soon see, that actually makes them easier to write.
  prefs: []
  type: TYPE_NORMAL
- en: Determining state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a set of operations that a state module must take in order to perform
    its job, and as those operations are done, there is certain data that is stored.
    Let''s start off with a pseudo piece of code, and explain each component in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The __virtual__() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By now, you're already familiar with this function, but I want to mention it
    here again. Because execution modules are meant to perform the heavy lifting,
    it is crucial to make sure that they are available before trying to make use of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: There's a good chance you'll need to cross-call multiple functions inside your
    state module. Usually, you'll call at least one function to check for the status
    of the item in question, and at least one more to bring the item into the desired
    configuration. But if they're all in the same execution module, you really only
    need to check for the presence of one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you were going to write a state that used the `http.query` execution module
    to perform lookups and make changes to a web resource. That function should always
    be available, but for the sake of demonstration, we''ll assume that we need to
    check for it. One way to write the function would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a shorter way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting up defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `__virtual__()` function out of the way, we can move on to the stateful
    function itself. First we set up some default variables in a dictionary. In our
    example, and in most state modules, the dictionary is called `ret`. This is by
    convention only, and is not an actual requirement. However, the keys and their
    data types inside the dictionary are a hard requirement. These keys are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (string) – This is the name of the resource that is passed into the
    state. This is also known as the ID from the state. For instance, in the following
    state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The name passed in would be `nginx`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changes` (dictionary) – If the state applies any changes to the Minion, this
    dictionary will contain an entry for each of the changes that was applied. For
    instance, if `pkg.installed` was used to install `nginx`, the `changes` dictionary
    would look like:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no restriction imposed on the type of data stored in `changes`, so
    long as `changes` itself is a dictionary. If changes are made, then this dictionary
    *must* have something in it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result` (boolean) – This field is one of three values: `True`, `False`, or
    `None`. If the specified resource is already in the state that it was meant to
    be in, or it was successfully made to be in that state, this field will be `True`.
    If the resource was not in the correct state, but `salt` was run with `test=True`,
    then this field is set to `None`. If the resource was not in the correct state,
    and Salt was unable to put it into the correct state, then this field will be
    set to `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When performing a state run, such as `state.highstate`, the value of the result
    will affect the color of the output. States that are `True`, but have no `changes`,
    will be green. States that are `True` and have `changes` will be blue. States
    that are `None` will be yellow. States that are `False` will be red.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comment` (string) – This field is entirely freeform: it may contain any comments
    you want, or no comments. However, it is better to have some comment, even as
    short as `The requested resource is already in the desired state`. If the result
    is `None` or `False`, then the `comment` should contain a message that is as helpful
    as possible concerning why the resource is not configured properly, and how that
    may be corrected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The defaults that we use in our example will be good for almost any state:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Checking for truth
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the defaults have been set, the next task is to check the resource and
    see whether or not it is in the desired state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This may be a quick check using a single function in an execution module, or
    it may consist of much more logic requiring several functions to be cross-called.
    Don't add any more code here than is necessary to check the state of the resource;
    remember that all heavy lifting should be performed in the execution module.
  prefs: []
  type: TYPE_NORMAL
- en: If the resource is found to be properly configured, then the `result` is set
    to `True`, a helpful `comment` is added, and the function `return`s. If the resource
    is not properly configured, then we move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for test mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the code makes it past the check for truth, then we can assume that something
    is wrong. But before we make any changes to the system, we need to see whether
    or not `salt` was called with `test=True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If so, we set a helpful `comment` for the user, and then `return` the `ret`
    dictionary. If there is any more logic that happens once it has been determined
    that `salt` is running in `test` mode, then it should only be to give the user
    more helpful information in the comment. No changes should ever be made in `test`
    mode!
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to configure the resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we get past the check for `test` mode, then we know that we can try to make
    changes to correctly configure the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, this section of the code should only contain enough logic to correctly
    configure the resource in question, and then notify the user if it was successful.
    If the change was successful, then we update the `changes` dictionary, add a `comment`
    that describes how those `changes` were achieved, set the `result` to `True`,
    and then `return`.
  prefs: []
  type: TYPE_NORMAL
- en: Notifying about False
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we get past that piece of code, we are now assured that something has gone
    wrong, and that we are unable to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the most important section of code to be helpful to the user, because
    user interaction will likely be required to fix whatever the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: It could be that the SLS file was just poorly written, and that the next state
    run will fix it. It could also be that the state module has a bug that needs to
    be fixed. Or there could be some other situation that is beyond Salt's ability
    to control, such as a web service that is temporarily unavailable. The comment
    should contain as much information as is helpful to track down and fix the problem,
    and no more. This is also the time to set the result to `False` before `return`ing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: checking an HTTP service'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is already a state for contacting web services: the `http.query` state.
    However, it is very general-purpose, and using it directly has limited use. In
    fact, it doesn''t really have the logic to do much more than check whether a URL
    responds as expected. In order to make it more intelligent, we need to add some
    logic on our own.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by setting up our `docstring`, a library import, and a `__virtual__()`
    function with some credentials for a theoretical web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we aren't checking for the existence of the `http.query` function;
    as we said before, it's already there. But this module won't function without
    being able to connect to the web service, so we do a quick check to make sure
    the credentials are in place.
  prefs: []
  type: TYPE_NORMAL
- en: We aren't checking to see if the service itself responds, or if the credentials
    are correct. The `__virtual__()` function is checked when the Minion starts, and
    doing all that checking then is unnecessary and, in the event of downtime, possibly
    inaccurate. It will also slow the Minion from loading. It is better to do that
    checking later, when we actually make the call to the service.
  prefs: []
  type: TYPE_NORMAL
- en: The first stateful function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to set up a state function. For our example, we''re going to
    allow users to make sure that a specific user''s account on that web service is
    locked out. First, we set up our defaults, and then check to see if that user''s
    account has been locked out yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see a problem right away. Making an authenticated web call is a little
    heavy, especially when you have to decode the return data, no matter how you do
    it. We''re going to make another web call in this function, and then more in other
    functions. Let''s break out what we can into another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `_query()` function expects at least one argument: the type of query
    (`action`) that is going to be performed against the API. It''s very common for
    this kind of API to be expected to list all items for that query if a specific
    resource isn''t specified, so we''ve allowed the resource to be blank. We''ve
    also set up another optional parameter called data, which we''ll make use of in
    a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a check for whether the account is locked, and are able to `return
    True` if it is. If we get past that point, we know the account isn''t locked,
    so let''s do our check for `test` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This part is easy enough; we have all of the information that is needed for
    `test` mode, and we don't need to do anything else besides `return` it. Let's
    go ahead and try to apply the correct setting to the account.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `data` option? We used it to pass in a dictionary that sets the
    access value for that user to `locked`. This is also a very common way to modify
    data with a web API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we don''t necessarily know that the setting was applied correctly,
    so let''s do one more check, just to make sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the account is now locked, then we can return that we were successful. If
    the account is still not locked, then we can return a failure message.
  prefs: []
  type: TYPE_NORMAL
- en: Another stateful function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go ahead and add another function, to allow a user account to be unlocked.
    We''ll also take this opportunity to show you the entire module, with all of the
    public and private functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that there''s not much difference between these two functions.
    In fact, really, they do exactly the same thing, but with opposing logic: one
    locks an account and one unlocks an account.'
  prefs: []
  type: TYPE_NORMAL
- en: It is very common for a state module to contain two opposites for the same configuration.
    You will frequently see function names like `installed` and `removed`, `present`
    and `absent`, and `running` and `dead`.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting state modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though the code is more structured, it can be a little tricky to troubleshoot
    state modules. This is because you need to test all four types of return results:'
  prefs: []
  type: TYPE_NORMAL
- en: True – The resource is already correctly configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None – The resource is not correctly configured, and `test` mode is True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: True with changes – The resource was not correctly configured, but now it is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: False – The resource could not be correctly configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes this even trickier is that in the course of troubleshooting, you
    are likely to change configuration to be correct, and then incorrect, and then
    back again several times before the code is right. I suggest breaking it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: test for truth'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your first step, after setting up your defaults, is to check whether the resource
    is correctly configured. This is likely to require you to manually toggle settings
    to make sure it is properly checking both desired and undesired configuration.
    Add two returns: one for `True` and one for `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove those last two lines later, once you know the code is correct.
    You don''t need to set up an entire SLS file to test your state; you can use `state.single`
    to perform a one-off state command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: test mode'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''re sure it''s correctly detecting the current configuration, manually
    set the configuration to an undesired value, and make sure `test` mode is working
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: applying changes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are sure that your code will not try to apply changes without first
    checking for test mode, you can move on to applying changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the trickiest part, for two reasons. First, you''ll end up setting
    and resetting your configuration a lot. This can be tedious at best, but there''s
    no avoiding it. Second, you''ll be both setting the correct configuration, and
    then testing to see if it was set, at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may think that you can split this part up, but before long you're likely
    to realize that in order to make sure the configuration was applied properly,
    you still need to perform the same check as you would normally be performing in
    your own tests, so you might as well get it out of the way now.
  prefs: []
  type: TYPE_NORMAL
- en: Testing opposites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thankfully, if you're writing functions that perform opposite functions, the
    second one tends to go much faster. That's because once you have the first one
    out of the way, you can keep running it to reset the configuration back to the
    undesired value for the second one. In the case of our example, once you are able
    to lock an account, you can easily lock it while testing the unlock functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State modules are more structured than execution modules, but that often makes
    them easier to write. A state's return result can be True (green), None (yellow),
    True with changes (blue), or False (red). State modules frequently contain pairs
    of functions that perform opposing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to write state modules, it''s time to take a look at
    the data that we pass to them. Next up: renderers!'
  prefs: []
  type: TYPE_NORMAL
