- en: Chapter 8. Extending unittest with nose2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用nose2扩展unittest
- en: So far we have been using the `unittest` test runner to run our tests. There
    are a number of other third-party test runners that have been created by the Python
    community. One of the most popular ones is nose2\. nose2 provides additional features
    that improve on the default test runner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`unittest`测试运行器来运行我们的测试。Python社区已经创建了许多其他第三方测试运行器。其中最受欢迎的一个是nose2。nose2提供了额外的功能，这些功能在默认测试运行器的基础上进行了改进。
- en: Getting started with nose2
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用nose2
- en: 'Installing nose2 is a breeze. The easiest way to install it is via pip with
    the following command:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安装nose2非常简单。最简单的方法是使用pip通过以下命令安装它：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us now run our tests using nose2\. From the stock alerter project directory,
    run the `nose2` command (we might have to add it to the path first). nose2 has
    test autodiscovery by default, so just running the command should give the following
    output:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用nose2来运行我们的测试。从stock alerter项目目录中，运行`nose2`命令（我们可能需要先将其添加到路径中）。nose2默认具有测试自动发现功能，因此只需运行命令就应该会得到以下输出：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, the `nose2` command gives the same output as `unittest`. nose2
    which also discovered the same tests and ran them. By default, nose2 autodiscover
    patterns are compatible with `unittest`, so we can just drop in nose2 as a replacement
    runner without changing any code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`nose2`命令给出了与`unittest`相同的输出。nose2也发现了相同的测试并运行了它们。默认情况下，nose2的自动发现模式与`unittest`兼容，因此我们可以直接将nose2作为替换运行器使用，而无需更改任何代码。
- en: Writing tests for nose2
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为nose2编写测试
- en: Apart from picking up the existing tests written with the `unittest` module
    and running them, nose2 also supports new ways of writing tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拾取使用`unittest`模块编写的现有测试并运行它们之外，nose2还支持编写测试的新方法。
- en: To start with, nose2 allows tests to be regular functions. We don't need to
    create a class and inherit it from any base class. As long as the function starts
    with the word `test`, it is considered a test and executed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，nose2允许测试是常规函数。我们不需要创建一个类并从任何基类继承。只要函数以单词`test`开头，它就被认为是测试并执行。
- en: 'We can take the following test:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用以下测试：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And write the above test as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并将上述测试按以下方式编写：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, writing tests this way reduces some of the boilerplate code
    that we had to do before:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，以这种方式编写测试减少了我们之前必须做的某些样板代码：
- en: We no longer have to create a class to hold the tests in
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再需要创建一个类来存放测试
- en: We no longer have to inherit from any base class
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再需要从任何基类继承
- en: We don't even have to import the `unittest` module
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至不需要导入`unittest`模块
- en: We just write the tests as regular functions, and nose2 will autodiscover and
    run the tests.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将测试编写为常规函数，nose2就会自动发现并运行测试。
- en: Apart from moving the test to a regular function, there is one other change
    that we have made, and this is the way we are asserting on the expected result.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将测试移动到常规函数之外，我们还做了一项其他更改，那就是我们断言预期结果的方式。
- en: 'Previously, we did:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们做了以下操作：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the test is a function, we do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试是一个函数时，我们执行以下操作：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why this change? The `unittest.TestCase` class provides a lot of built-in assertion
    methods. When we inherit from this class, we can use those methods in our tests.
    When we write tests as a function, we no longer have access to those methods.
    Fortunately, nose2 supports Python's in-built `assert` statement, so we can just
    use that in our test.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么做这个更改？`unittest.TestCase`类提供了许多内置的断言方法。当我们从这个类继承时，我们可以在测试中使用这些方法。当我们以函数的形式编写测试时，我们就不再能够访问这些方法。幸运的是，nose2支持Python的内置`assert`语句，因此我们可以在测试中使用它。
- en: 'The `assert` statement also supports taking a message parameter like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert`语句也支持像以下这样的消息参数：'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a test fails, the message will be printed to the output as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，消息将按以下方式打印到输出：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setup and teardown
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和清理
- en: 'nose2 also supports setup and teardown for function-style test cases. This
    is done by setting the `setup` and `teardown` attributes on the *function object*.
    It works as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: nose2还支持为函数式测试用例提供设置和清理。这是通过在*函数对象*上设置`setup`和`teardown`属性来实现的。它的工作方式如下：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setup and teardown is limited with function-style tests in the sense that there
    is no way to pass state from the `setup` function to the test case and the teardown
    function. This is the reason why we have to declare that `goog` variable in the
    setup as global. This is the only way we can access it in the test case and the
    teardown function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式测试中，设置和清理是有限的，因为在 `setup` 函数和测试用例以及清理函数之间无法传递状态。这就是为什么我们必须在设置中声明 `goog`
    变量为全局变量的原因。这是我们在测试用例和清理函数中访问它的唯一方法。
- en: Parameterized tests
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化测试
- en: nose2 also supports parameterized tests. Also called data-driven tests, these
    are nothing but running the same test with different combinations of data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: nose2 也支持参数化测试。也称为数据驱动测试，这些测试不过是运行相同的测试，但使用不同的数据组合。
- en: 'Take a look at the following three tests that we wrote earlier:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们之前写的以下三个测试：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By parameterizing the test, we can write it like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参数化测试，我们可以写成如下形式：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `params` decorator allows us to specify a series of different inputs. The
    test is run once with each input. An input is a tuple where each element of the
    tuple is passed to the test function as a parameter. In the example above, the
    test will first be run with *prices=[8, 10, 12], expected_output=True*, then again
    with *prices=[8, 12, 10], expected_output=False*, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`params` 装饰器允许我们指定一系列不同的输入。测试会针对每个输入运行一次。一个输入是一个元组，其中元组的每个元素都作为参数传递给测试函数。在上面的例子中，测试将首先使用
    `prices=[8, 10, 12], expected_output=True` 运行，然后再次使用 `prices=[8, 12, 10], expected_output=False`
    运行，依此类推。'
- en: 'When a test fails, the output looks like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个测试失败时，输出看起来如下：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: nose2 gives the parameter number that failed as `:2` and underneath the exact
    data that was passed to the test.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: nose2 会将失败的参数编号显示为 `:2`，并在其下方显示传递给测试的确切数据。
- en: Parameterized tests are a great way to reduce repetitive tests, where we are
    doing the same sequence of steps, with different data each time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试是一种很好的减少重复测试的方法，其中我们每次都执行相同的步骤序列，但数据各不相同。
- en: Generated tests
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成测试
- en: Apart from parameterized tests, nose2 also supports generated tests. This is
    similar to parameterized tests. The difference is that parameterized tests have
    all the inputs hardcoded while writing the test, whereas they can be created at
    run time in generated tests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了参数化测试之外，nose2 还支持生成测试。这与参数化测试类似。区别在于，参数化测试在编写测试时所有输入都是硬编码的，而生成测试可以在运行时创建。
- en: 'The following is an example to clarify:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，以澄清：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we run the above test, we see that a hundred tests have been run. What
    is going on here? Let us look at it in a little more detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述测试时，我们看到已经运行了一百个测试。这里发生了什么？让我们更详细地看看。
- en: Unlike a regular test function, this one yields a value, making it a generator
    function. The `yield` statement returns the function to be executed followed by
    the data to be passed to the function. Each time through the loop, the test function
    yields, and the yielded function is executed with the corresponding parameters.
    Since the loop runs a hundred times, a hundred tests are generated and executed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规测试函数不同，这个函数会返回一个值，使其成为一个生成器函数。`yield` 语句返回要执行的功能以及传递给函数的数据。每次循环通过时，测试函数都会
    `yield`，并且生成的函数会使用相应的参数执行。由于循环运行了一百次，因此生成了并执行了一百个测试。
- en: 'When a test fails, the following output is shown:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个测试失败时，显示以下输出：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Like with the parameterized tests, the output shows the test number that failed
    along with the exact inputs that were used to execute the test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像参数化测试一样，输出显示了失败的测试编号以及执行测试时使用的确切输入。
- en: Layers
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层
- en: 'If we look at the tests for our `Stock` class, we see that we have created
    three test classes: `StockTest`, `StockTrendTest`, and `StockCrossOverSignalTest`.
    All the three classes have some repetition in the `setUp` code, as shown in the
    following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的 `Stock` 类的测试，我们会看到我们创建了三个测试类：`StockTest`、`StockTrendTest` 和 `StockCrossOverSignalTest`。所有这三个类在
    `setUp` 代码中都有一些重复，如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What if we could share part of the setup between them?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在它们之间共享部分设置会怎样呢？
- en: 'nose2 has another way to write tests called **Layers**. Layers allow us to
    organize our tests hierarchically. The following is an example of some of the
    `Stock` tests rewritten using Layers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: nose2 有另一种编写测试的方法，称为 **层**。层允许我们以分层的方式组织我们的测试。以下是一些使用层重写的 `Stock` 测试的示例：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The entire syntax is new, so let us look at it carefully.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 整个语法都是新的，所以让我们仔细看看。
- en: 'First, we need to import `such`. **Such** is the name of a domain specific
    language that makes it easy to write tests using nose2 layers. The following line
    imports it for us:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入`such`。**Such**是一个特定领域的语言名称，它使得使用nose2层编写测试变得容易。以下行为我们导入了它：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we set up the top most layer as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照以下方式设置顶层：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A layer can contain setup and teardown functions, test cases, and sub-layers.
    Such uses Python's context manager syntax to define a layer. We define the top
    topmost layer using the `such.A` method. It might sound strange to name a method
    as `A`, but the name has been chosen so that reading the line sounds natural to
    an English speaker. `such.A` takes a string as a parameter. This is just a descriptive
    string for the tests to follow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一层可以包含设置和拆卸函数、测试用例和子层。这种用法使用了Python的上下文管理器语法来定义一层。我们使用`such.A`方法定义最顶层。这个方法的名字可能听起来很奇怪，但这个名字被选择是为了让英语使用者读起来自然。`such.A`接受一个字符串作为参数。这只是一个描述字符串，用于描述后续的测试。
- en: The output of `such.A` is assigned to a variable. By convention it is called
    `it`, again the name being chosen so that the following usage will be like English
    sentences.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`such.A`的输出被分配给一个变量。按照惯例，它被称为`it`，再次，这个名字被选择是为了让后续的使用看起来像英语句子。'
- en: 'Having created the topmost layer, we then create the setup function for the
    layer, as shown in the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了最顶层之后，我们接着为层创建设置函数，如下所示：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The name of the function can be anything, we just need to mark it as the setup
    function by decorating it with the `has_setup` decorator. This decorator is a
    method of the `it` object, hence we write `@it.has_setup`. Similarly, we can use
    the `has_teardown` decorator to mark a function to be used for teardown.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称可以是任何东西，我们只需要通过使用`has_setup`装饰器来标记它为设置函数。这个装饰器是`it`对象的一个方法，因此我们写成`@it.has_setup`。同样，我们可以使用`has_teardown`装饰器来标记一个用于拆卸的函数。
- en: In the `setup` function, we can store any stateful information as attributes
    of the `it` object. These can be referenced in sub-layers or in test cases.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup`函数中，我们可以将任何有状态的信息作为`it`对象的属性存储。这些可以在子层或测试用例中引用。
- en: 'Next, we create a sub-layer by calling the having method, as shown in the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用拥有方法创建一个子层，如下所示：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, this is a context manager, so we use it with the `with` statement. Unlike
    the top level layer, we don't need to assign it to any variable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个上下文管理器，所以我们使用`with`语句。与顶层层不同，我们不需要将其分配给任何变量。
- en: 'The sub-layer then defines its own setup function, as shown in the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 子层随后定义自己的设置函数，如下所示：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `setup` function is called in addition to the setup function of the parent
    layer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了父层的设置函数外，还会调用这个`setup`函数。
- en: 'Next, we create a test case, as shown in the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个测试用例，如下所示：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Test cases are marked using the `should` decorator. The decorator takes a description
    string which explains the test.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例使用`should`装饰器进行标记。该装饰器接受一个描述字符串，用于解释测试内容。
- en: 'We continue with the same syntax to create another test, as shown in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用相同的语法创建另一个测试，如下所示：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That ends the sub-layer. Back in the top layer, we create a second sub-layer
    to hold the tests for the `is_increasing_trend` function, as shown in the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就结束了子层。回到顶层，我们创建第二个子层来包含`is_increasing_trend`函数的测试，如下所示：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we call the `createTests` method to convert all this code into test
    cases, as shown in the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`createTests`方法将所有这些代码转换为测试用例，如下所示：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `createTests` method should be called at the end of the topmost layer. It
    takes a single parameter of the current `globals`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在顶层层的末尾调用`createTests`方法。它接受当前`globals`的单个参数。
- en: If the `createTests` method is not called, none of the tests will be executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有调用`createTests`方法，则不会执行任何测试。
- en: 'Let us now run the tests. Layers is actually implemented as a nose2 plugin,
    so we need to use the following command to enable the plugin and run the tests:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来运行测试。层实际上是一个nose2插件，因此我们需要使用以下命令来启用插件并运行测试：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we do this, the three tests written using Layers are executed along with
    all the other tests.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，使用Layers编写的三个测试将与其他所有测试一起执行。
- en: 'We can get nicer output by also enabling the Layer Reporter plugin with the
    following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启用Layer Reporter插件来获得更友好的输出，以下命令：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now get the output like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到以下输出：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The descriptive strings that we gave for the Layers and tests are outputted
    here. When written well, the text should be readable as regular English sentences.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为层和测试提供的描述性字符串在这里输出。当写得好的时候，文本应该可以像常规英语句子一样阅读。
- en: As we can see, Layers allow us to organize tests logically, sharing fixtures
    between parent and child. A layer can have any number of sub-layers and those,
    in turn, can contain further layers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Layers允许我们逻辑地组织测试，在父层和子层之间共享固定值。一个层可以有任意数量的子层，而这些子层反过来又可以包含更多的层。
- en: 'Let us quickly summarize what we have just learned:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下我们刚刚学到的内容：
- en: '`such.A`: This is used as a context manager to create the topmost layer.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`such.A`: 这被用作上下文管理器来创建最顶层。'
- en: '`it.has_setup`: This is a decorator to mark a setup function for a layer.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it.has_setup`: 这是一个装饰器，用于标记层的设置函数。'
- en: '`it.has_teardown`: This is a decorator to mark a teardown function for a layer.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it.has_teardown`: 这是一个装饰器，用于标记层的清理函数。'
- en: '`it.having`: This is used as a context manager to create a sub-layer.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it.having`: 这被用作上下文管理器来创建一个子层。'
- en: '`it.should`: This is a decorator to mark a test case.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it.should`: 这是一个装饰器，用于标记测试用例。'
- en: '`it.createTests`: This is a method that converts all the Layers code into test
    cases. Call it as the last line of code in the topmost layer, passing in `globals()`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it.createTests`: 这是一个方法，它将所有Layers代码转换为测试用例。在顶层代码的最后调用它，传入`globals()`。'
- en: nose2 plugins
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nose2插件
- en: In the previous section, we saw how we needed to enable the Layers plugin before
    we could run our layer tests. nose2 comes with a large set of plugins that enhance
    or extend its behavior. In fact, support for all the parameterized tests and generated
    tests that we saw earlier are actually implemented as nose2 plugins. The difference
    is that parameterized and generated tests are loaded by default, so we didn't
    need to explicitly enable them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了在运行层测试之前我们需要启用Layers插件。nose2附带了一组插件，这些插件增强了或扩展了其行为。实际上，我们之前看到的参数化测试和生成测试的支持实际上都是作为nose2插件实现的。区别在于参数化和生成测试默认加载，所以我们不需要明确启用它们。
- en: In this section, we'll take a look at some of the popular plugins. Keep in mind
    that there are many more plugins that we aren't going to discuss here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一些流行的插件。记住，还有许多其他插件我们没有在这里讨论。
- en: Doctest support
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Doctest支持
- en: If we have not integrated doctests into the unittest framework as described
    in the previous chapter, then we can configure nose2 to autodiscover and run doctests.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有像上一章中描述的那样将doctests集成到unittest框架中，那么我们可以配置nose2来自动发现并运行doctests。
- en: 'Activate the plugin with the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令激活插件：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will autodiscover and run doctests along with all the other kinds of tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动发现并运行doctests，以及其他所有类型的测试。
- en: Writing test results to an XML file
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将测试结果写入XML文件
- en: nose2 has support for writing out test results into an XML file. Many tools
    can read this file format to understand the results of a test run. For example,
    continuous integration tools can find out if all the tests passed, and, if not,
    which tests failed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: nose2支持将测试结果写入XML文件。许多工具可以读取此文件格式以了解测试运行的结果。例如，持续集成工具可以找出所有测试是否通过，如果没有通过，哪些测试失败了。
- en: 'Activate the plugin with the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令激活插件：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will create a file called `nose2-junit.xml` in the current directory.
    The file will contain something like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中创建一个名为`nose2-junit.xml`的文件。该文件将包含类似以下内容：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The root element gives a summary of the entire test run, how many errors, failures,
    and skips there were, the number of tests, and the total time to run all the tests.
    Each child then summarizes a single test. If the test failed, then a traceback
    is included as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素提供了整个测试运行的摘要，包括错误、失败和跳过的数量，测试数量以及运行所有测试的总时间。每个子元素随后总结了一个单独的测试。如果测试失败，还包括跟踪信息。
- en: Measuring test coverage
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量测试覆盖率
- en: nose2 also supports measuring the test coverage. We can use this to identify
    if there are lines or branches of code that do not have tests, or which modules
    have poor test coverage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: nose2还支持测量测试覆盖率。我们可以使用它来识别是否有没有测试的代码行或分支，或者哪些模块的测试覆盖率较差。
- en: 'Before we can use this plugin, we need to install some dependent packages with
    this command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用此插件之前，我们需要使用以下命令安装一些依赖包：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will install two packages—`cov-core` and `coverage`—which are used by this
    plugin.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装两个包——`cov-core`和`coverage`——这些包被此插件使用。
- en: 'Once installed, we can enable the plugin with this command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，我们可以使用以下命令启用插件：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since this plugin is loaded by default, we don''t need to give the `--plugin`
    parameter. Running the above command will give the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此插件默认加载，我们不需要提供`--plugin`参数。运行上述命令将给出以下输出：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The output above shows how many statements are in each module, how many are
    not covered by tests, and the percentage of coverage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出显示了每个模块中有多少条语句，有多少条没有被测试覆盖，以及覆盖率百分比。
- en: 'The plugin also creates a file called .`coverage` that stores the coverage
    results in binary form. This file can be used to get different kinds of reports.
    For example, we can use the following command to get HTML output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件还会创建一个名为`.coverage`的文件，以二进制形式存储覆盖率结果。此文件可用于获取不同类型的报告。例如，我们可以使用以下命令获取HTML输出：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The command will create a directory called `htmlcov`, which contains a set
    of files. If we open up `index.html` in a browser, then we get a fully interactive
    coverage report. We can click on any module and get details on exactly which lines
    were covered and which were not, as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将创建一个名为`htmlcov`的目录，其中包含一组文件。如果我们用浏览器打开`index.html`，那么我们会得到一个完全交互式的覆盖率报告。我们可以点击任何模块，并获取关于哪些行被覆盖以及哪些行没有被覆盖的详细信息，如下面的截图所示：
- en: '![Measuring test coverage](img/3125_08_01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![测量测试覆盖率](img/3125_08_01.jpg)'
- en: Other options for report types are `term` for terminal output, `term-missing`
    to also output the uncovered lines on the terminal, and `annotate`, which creates
    a copy of each of the source files with an annotation on whether the line was
    covered or not.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 报告类型的其他选项有`term`用于终端输出，`term-missing`用于在终端上输出未覆盖的行，以及`annotate`，它为每个源文件创建一个带有注释的副本，说明该行是否被覆盖。
- en: 'Multiple options can be combined like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像以下这样组合多个选项：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Debugging test failures
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试测试失败
- en: Another useful nose2 plugin is the debugger plugin. This plugin will activate
    the Python Debugger (pdb) when a test fails, allowing us to investigate why exactly
    the failure occurred.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的nose2插件是调试器插件。此插件会在测试失败时激活Python调试器（pdb），允许我们调查失败的确切原因。
- en: 'Activate the plugin with the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令激活插件：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When a test fails, we drop into pdb and can use all the pdb commands to investigate
    the failure, as shown in the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，我们会进入pdb，可以使用所有的pdb命令来调查失败原因，如下所示：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: nose2 configuration
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nose2配置
- en: 'Running the various plugins requires using many command line switches. For
    example, if we want to run coverage, as well as doctest and XML output, the command
    is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行各种插件需要使用许多命令行开关。例如，如果我们想运行覆盖率、doctest以及XML输出，命令如下：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is cumbersome, and if we want to run this combination by default, then
    it is very painful to keep repeating the parameters over and over.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这很麻烦，如果我们想默认运行这个组合，那么反复重复参数是非常痛苦的。
- en: To solve this problem, nose2 supports putting all configurations in to a configuration
    file. nose2 will then read the settings from the file, and we won't need to pass
    anything on the command line.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，nose2支持将所有配置放入配置文件中。然后nose2将从文件中读取设置，我们就不需要在命令行上传递任何内容了。
- en: 'Create a file called `nose2.cfg` in the `src` directory with the following
    contents:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`目录中创建一个名为`nose2.cfg`的文件，内容如下：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let us examine these contents.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这些内容。
- en: nose2 uses the normal INI file syntax for its configuration. General configuration
    is put in the `[unittest]` section, while plugin specific options are under their
    own sections. Under each section, options are configured using key-value pairs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: nose2使用正常的INI文件语法进行配置。通用配置放在`[unittest]`部分，而插件特定选项放在各自的章节下。在每个章节下，使用键值对配置选项。
- en: 'We have configured the following above:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面已经配置了以下内容：
- en: '**test-file-pattern**: This is the pattern to search for in the file name when
    identifying test files in autodiscovery.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test-file-pattern**：这是在自动发现中识别测试文件时在文件名中搜索的模式。'
- en: '**test-method-prefix**: This is the prefix to search for to identify test case
    function and method names.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test-method-prefix**：这是用于识别测试用例函数和方法名称的搜索前缀。'
- en: '**plugins**: These are the plugins to load by default. Put each plugin on a
    separate line, referring to the plugin module here. This is equivalent to the
    `--plugin` command line switch. Note that this only loads the plugin, and some
    plugins need to be explicitly turned on (for example, the `coverage` plugin).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**：这些是默认加载的插件。将每个插件放在单独的一行上，在此处引用插件模块。这相当于`--plugin`命令行开关。请注意，这仅加载插件，某些插件需要显式开启（例如，`coverage`插件）。'
- en: '**exclude-plugin**: These are any plugins that need to be turned off. Usually,
    this is applied to plugins that are turned on by default (for example, parameterized
    or generated tests support).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除插件**：这些是需要关闭的任何插件。通常，这应用于默认开启的插件（例如，参数化或生成测试支持）。'
- en: 'We then configure the plugins. Each plugin has its own set of options. The
    one common option is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们配置插件。每个插件都有自己的选项集。一个共同的选项如下：
- en: '**always-on**: Set to `True` if this plugin is turned on by default. For example,
    when the `JUnit` plugin is always on, every test run will create the XML file
    output. Otherwise, we have to use the `--junit-xml` switch on the command line
    to activate it.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终开启**：如果此插件默认开启，则设置为`True`。例如，当`JUnit`插件始终开启时，每次测试运行都会创建XML文件输出。否则，我们必须在命令行上使用`--junit-xml`开关来激活它。'
- en: 'nose2 also supports multiple configuration files. The `--config` switch can
    be used to specify which configuration file to use, as shown in the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: nose2还支持多个配置文件。可以使用`--config`开关来指定要使用的配置文件，如下所示：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This way you can use the default configuration for developer options and create
    specific config files for continuous integration or other uses. For example, you
    might want junitxml and coverage to be always on when running under automated
    tools, but have them off when developers run the tests.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你可以使用开发选项的默认配置，并为持续集成或其他用途创建特定的配置文件。例如，你可能希望在自动化工具运行时始终开启junitxml和覆盖率，但在开发人员运行测试时关闭它们。
- en: nose2 configuration files can also be checked into source control, so that all
    the developers use the same set of options.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: nose2的配置文件也可以被提交到源代码控制中，这样所有开发人员都会使用相同的选项集。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you looked at nose2, a powerful test runner and plugin suite,
    that extends the `unittest` framework. nose2 can be used as a drop-in replacement
    for the `unittest` test runner. It can also be used to extend `unittest` functionality
    with useful plugins. Finally, it can be used to write new types of tests such
    as function tests, parameterized tests, generated tests, and layer-based tests.
    nose2 also supports configuration files, so it can be run consistently between
    developers as well as integrating well with automation tools.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了nose2，一个强大的测试运行器和插件套件，它扩展了`unittest`框架。nose2可以用作`unittest`测试运行器的直接替代品。它还可以用来通过有用的插件扩展`unittest`的功能。最后，它可以用来编写新的测试类型，如函数测试、参数化测试、生成测试和基于层的测试。nose2还支持配置文件，因此它可以在开发人员之间保持一致性运行，并且与自动化工具很好地集成。
- en: In the next chapter, you will take a look at some more advanced testing patterns.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解一些更高级的测试模式。
