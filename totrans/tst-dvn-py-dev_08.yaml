- en: Chapter 8. Extending unittest with nose2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have been using the `unittest` test runner to run our tests. There
    are a number of other third-party test runners that have been created by the Python
    community. One of the most popular ones is nose2\. nose2 provides additional features
    that improve on the default test runner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with nose2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing nose2 is a breeze. The easiest way to install it is via pip with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now run our tests using nose2\. From the stock alerter project directory,
    run the `nose2` command (we might have to add it to the path first). nose2 has
    test autodiscovery by default, so just running the command should give the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `nose2` command gives the same output as `unittest`. nose2
    which also discovered the same tests and ran them. By default, nose2 autodiscover
    patterns are compatible with `unittest`, so we can just drop in nose2 as a replacement
    runner without changing any code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for nose2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from picking up the existing tests written with the `unittest` module
    and running them, nose2 also supports new ways of writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, nose2 allows tests to be regular functions. We don't need to
    create a class and inherit it from any base class. As long as the function starts
    with the word `test`, it is considered a test and executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And write the above test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, writing tests this way reduces some of the boilerplate code
    that we had to do before:'
  prefs: []
  type: TYPE_NORMAL
- en: We no longer have to create a class to hold the tests in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We no longer have to inherit from any base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't even have to import the `unittest` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just write the tests as regular functions, and nose2 will autodiscover and
    run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from moving the test to a regular function, there is one other change
    that we have made, and this is the way we are asserting on the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When the test is a function, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Why this change? The `unittest.TestCase` class provides a lot of built-in assertion
    methods. When we inherit from this class, we can use those methods in our tests.
    When we write tests as a function, we no longer have access to those methods.
    Fortunately, nose2 supports Python's in-built `assert` statement, so we can just
    use that in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `assert` statement also supports taking a message parameter like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a test fails, the message will be printed to the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setup and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'nose2 also supports setup and teardown for function-style test cases. This
    is done by setting the `setup` and `teardown` attributes on the *function object*.
    It works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setup and teardown is limited with function-style tests in the sense that there
    is no way to pass state from the `setup` function to the test case and the teardown
    function. This is the reason why we have to declare that `goog` variable in the
    setup as global. This is the only way we can access it in the test case and the
    teardown function.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: nose2 also supports parameterized tests. Also called data-driven tests, these
    are nothing but running the same test with different combinations of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following three tests that we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By parameterizing the test, we can write it like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `params` decorator allows us to specify a series of different inputs. The
    test is run once with each input. An input is a tuple where each element of the
    tuple is passed to the test function as a parameter. In the example above, the
    test will first be run with *prices=[8, 10, 12], expected_output=True*, then again
    with *prices=[8, 12, 10], expected_output=False*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a test fails, the output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: nose2 gives the parameter number that failed as `:2` and underneath the exact
    data that was passed to the test.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized tests are a great way to reduce repetitive tests, where we are
    doing the same sequence of steps, with different data each time.
  prefs: []
  type: TYPE_NORMAL
- en: Generated tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from parameterized tests, nose2 also supports generated tests. This is
    similar to parameterized tests. The difference is that parameterized tests have
    all the inputs hardcoded while writing the test, whereas they can be created at
    run time in generated tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example to clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we run the above test, we see that a hundred tests have been run. What
    is going on here? Let us look at it in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a regular test function, this one yields a value, making it a generator
    function. The `yield` statement returns the function to be executed followed by
    the data to be passed to the function. Each time through the loop, the test function
    yields, and the yielded function is executed with the corresponding parameters.
    Since the loop runs a hundred times, a hundred tests are generated and executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a test fails, the following output is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Like with the parameterized tests, the output shows the test number that failed
    along with the exact inputs that were used to execute the test.
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look at the tests for our `Stock` class, we see that we have created
    three test classes: `StockTest`, `StockTrendTest`, and `StockCrossOverSignalTest`.
    All the three classes have some repetition in the `setUp` code, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What if we could share part of the setup between them?
  prefs: []
  type: TYPE_NORMAL
- en: 'nose2 has another way to write tests called **Layers**. Layers allow us to
    organize our tests hierarchically. The following is an example of some of the
    `Stock` tests rewritten using Layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The entire syntax is new, so let us look at it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import `such`. **Such** is the name of a domain specific
    language that makes it easy to write tests using nose2 layers. The following line
    imports it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the top most layer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A layer can contain setup and teardown functions, test cases, and sub-layers.
    Such uses Python's context manager syntax to define a layer. We define the top
    topmost layer using the `such.A` method. It might sound strange to name a method
    as `A`, but the name has been chosen so that reading the line sounds natural to
    an English speaker. `such.A` takes a string as a parameter. This is just a descriptive
    string for the tests to follow.
  prefs: []
  type: TYPE_NORMAL
- en: The output of `such.A` is assigned to a variable. By convention it is called
    `it`, again the name being chosen so that the following usage will be like English
    sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having created the topmost layer, we then create the setup function for the
    layer, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The name of the function can be anything, we just need to mark it as the setup
    function by decorating it with the `has_setup` decorator. This decorator is a
    method of the `it` object, hence we write `@it.has_setup`. Similarly, we can use
    the `has_teardown` decorator to mark a function to be used for teardown.
  prefs: []
  type: TYPE_NORMAL
- en: In the `setup` function, we can store any stateful information as attributes
    of the `it` object. These can be referenced in sub-layers or in test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a sub-layer by calling the having method, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is a context manager, so we use it with the `with` statement. Unlike
    the top level layer, we don't need to assign it to any variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sub-layer then defines its own setup function, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This `setup` function is called in addition to the setup function of the parent
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a test case, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Test cases are marked using the `should` decorator. The decorator takes a description
    string which explains the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue with the same syntax to create another test, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That ends the sub-layer. Back in the top layer, we create a second sub-layer
    to hold the tests for the `is_increasing_trend` function, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the `createTests` method to convert all this code into test
    cases, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `createTests` method should be called at the end of the topmost layer. It
    takes a single parameter of the current `globals`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `createTests` method is not called, none of the tests will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now run the tests. Layers is actually implemented as a nose2 plugin,
    so we need to use the following command to enable the plugin and run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, the three tests written using Layers are executed along with
    all the other tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get nicer output by also enabling the Layer Reporter plugin with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now get the output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The descriptive strings that we gave for the Layers and tests are outputted
    here. When written well, the text should be readable as regular English sentences.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Layers allow us to organize tests logically, sharing fixtures
    between parent and child. A layer can have any number of sub-layers and those,
    in turn, can contain further layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us quickly summarize what we have just learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '`such.A`: This is used as a context manager to create the topmost layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it.has_setup`: This is a decorator to mark a setup function for a layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it.has_teardown`: This is a decorator to mark a teardown function for a layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it.having`: This is used as a context manager to create a sub-layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it.should`: This is a decorator to mark a test case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`it.createTests`: This is a method that converts all the Layers code into test
    cases. Call it as the last line of code in the topmost layer, passing in `globals()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nose2 plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how we needed to enable the Layers plugin before
    we could run our layer tests. nose2 comes with a large set of plugins that enhance
    or extend its behavior. In fact, support for all the parameterized tests and generated
    tests that we saw earlier are actually implemented as nose2 plugins. The difference
    is that parameterized and generated tests are loaded by default, so we didn't
    need to explicitly enable them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll take a look at some of the popular plugins. Keep in mind
    that there are many more plugins that we aren't going to discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: Doctest support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have not integrated doctests into the unittest framework as described
    in the previous chapter, then we can configure nose2 to autodiscover and run doctests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the plugin with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will autodiscover and run doctests along with all the other kinds of tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test results to an XML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: nose2 has support for writing out test results into an XML file. Many tools
    can read this file format to understand the results of a test run. For example,
    continuous integration tools can find out if all the tests passed, and, if not,
    which tests failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the plugin with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a file called `nose2-junit.xml` in the current directory.
    The file will contain something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The root element gives a summary of the entire test run, how many errors, failures,
    and skips there were, the number of tests, and the total time to run all the tests.
    Each child then summarizes a single test. If the test failed, then a traceback
    is included as well.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring test coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: nose2 also supports measuring the test coverage. We can use this to identify
    if there are lines or branches of code that do not have tests, or which modules
    have poor test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use this plugin, we need to install some dependent packages with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will install two packages—`cov-core` and `coverage`—which are used by this
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we can enable the plugin with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this plugin is loaded by default, we don''t need to give the `--plugin`
    parameter. Running the above command will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The output above shows how many statements are in each module, how many are
    not covered by tests, and the percentage of coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin also creates a file called .`coverage` that stores the coverage
    results in binary form. This file can be used to get different kinds of reports.
    For example, we can use the following command to get HTML output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will create a directory called `htmlcov`, which contains a set
    of files. If we open up `index.html` in a browser, then we get a fully interactive
    coverage report. We can click on any module and get details on exactly which lines
    were covered and which were not, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Measuring test coverage](img/3125_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other options for report types are `term` for terminal output, `term-missing`
    to also output the uncovered lines on the terminal, and `annotate`, which creates
    a copy of each of the source files with an annotation on whether the line was
    covered or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple options can be combined like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Debugging test failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another useful nose2 plugin is the debugger plugin. This plugin will activate
    the Python Debugger (pdb) when a test fails, allowing us to investigate why exactly
    the failure occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the plugin with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When a test fails, we drop into pdb and can use all the pdb commands to investigate
    the failure, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: nose2 configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the various plugins requires using many command line switches. For
    example, if we want to run coverage, as well as doctest and XML output, the command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is cumbersome, and if we want to run this combination by default, then
    it is very painful to keep repeating the parameters over and over.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, nose2 supports putting all configurations in to a configuration
    file. nose2 will then read the settings from the file, and we won't need to pass
    anything on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `nose2.cfg` in the `src` directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let us examine these contents.
  prefs: []
  type: TYPE_NORMAL
- en: nose2 uses the normal INI file syntax for its configuration. General configuration
    is put in the `[unittest]` section, while plugin specific options are under their
    own sections. Under each section, options are configured using key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have configured the following above:'
  prefs: []
  type: TYPE_NORMAL
- en: '**test-file-pattern**: This is the pattern to search for in the file name when
    identifying test files in autodiscovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**test-method-prefix**: This is the prefix to search for to identify test case
    function and method names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**plugins**: These are the plugins to load by default. Put each plugin on a
    separate line, referring to the plugin module here. This is equivalent to the
    `--plugin` command line switch. Note that this only loads the plugin, and some
    plugins need to be explicitly turned on (for example, the `coverage` plugin).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exclude-plugin**: These are any plugins that need to be turned off. Usually,
    this is applied to plugins that are turned on by default (for example, parameterized
    or generated tests support).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then configure the plugins. Each plugin has its own set of options. The
    one common option is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**always-on**: Set to `True` if this plugin is turned on by default. For example,
    when the `JUnit` plugin is always on, every test run will create the XML file
    output. Otherwise, we have to use the `--junit-xml` switch on the command line
    to activate it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'nose2 also supports multiple configuration files. The `--config` switch can
    be used to specify which configuration file to use, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This way you can use the default configuration for developer options and create
    specific config files for continuous integration or other uses. For example, you
    might want junitxml and coverage to be always on when running under automated
    tools, but have them off when developers run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: nose2 configuration files can also be checked into source control, so that all
    the developers use the same set of options.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you looked at nose2, a powerful test runner and plugin suite,
    that extends the `unittest` framework. nose2 can be used as a drop-in replacement
    for the `unittest` test runner. It can also be used to extend `unittest` functionality
    with useful plugins. Finally, it can be used to write new types of tests such
    as function tests, parameterized tests, generated tests, and layer-based tests.
    nose2 also supports configuration files, so it can be run consistently between
    developers as well as integrating well with automation tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will take a look at some more advanced testing patterns.
  prefs: []
  type: TYPE_NORMAL
