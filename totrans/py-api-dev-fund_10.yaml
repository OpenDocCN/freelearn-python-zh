- en: 10\. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain the application deployment process to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the difference between SaaS, PaaS, and IaaS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up different configurations between development and production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the Heroku cloud platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure Heroku Postgres
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Heroku command-line interface (Heroku CLI) to deploy an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the Postman environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to deploy our application to Heroku and test it
    using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we added the cache and rate limit functions to our
    Smilecook applications. These last two functions are very useful, especially when
    we are dealing with huge volumes of traffic. Caching and rate-limiting can improve
    response speeds and can also raise the security level.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss how we can deploy our application to a cloud
    server. Deploying an application is like publishing a book or releasing a movie.
    It is like releasing our application on the market. Nowadays, a lot of cloud services
    provide free usage quotas. They allow developers to deploy their application to
    their cloud platform for free provided the resource usage is below a certain threshold.
    For our Smilecook application, what we need to do is simply make a few minor changes
    to the code and some configuration files. Everything else will be handled by the
    cloud platform. You will see how simple this is very soon.
  prefs: []
  type: TYPE_NORMAL
- en: We will first make minor modifications to the application code to segregate
    the production and development environment configurations. Then, we will talk
    about the Heroku cloud service platform, on which we are going to deploy the Smilecook
    application. We will walk you through the account registration, configuration,
    and deployment processes in the Heroku cloud service platform.
  prefs: []
  type: TYPE_NORMAL
- en: Once the deployment is done, we will use Postman to test the APIs directly in
    the production environment. Isn't that exciting?! Without further ado, let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is **deployment** for? The API application we wrote earlier just runs the
    code on the local machine. Using one of the ports on the local machine, we can
    send the request from the client to the local server. This is good for development
    purpose. We can quickly test and adjust our application in a development environment.
    However, our local machine is not intended to be a server; others can't access
    it. And they cannot send HTTP requests to APIs hosted on our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to open this API service to external users, we need to host it on
    a server. The server should be connected to the internet, with a domain and URL
    that allow others to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving an application from a local machine to a server that runs on the internet
    is called deployment. This will involve work such as environment setting, dependent
    package installation, and building a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing SaaS, PaaS, and IaaS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the past, it was expensive to set up your own web server. There are lots
    of considerations, including network connectivity, storage, server configuration,
    and OS setup. Nowadays, cloud computing services are here to provide all the infrastructure
    services, which lowers costs significantly, especially for individual developers
    and small- and medium-sized companies. There are three main categories of cloud
    computing services out there. These are **Software as a Service** (**SaaS**),
    **Platform as a Service** (**PaaS**), and **Infrastructure as a Service** (**IaaS**).
    There are pros and cons for each, and these will be discussed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**IaaS**: Users do not need to purchase their own servers, software, network
    devices, and so on. These infrastructures are provided as a service, and users
    do not need to care about setup and maintenance. They still have the ability to
    configure these services, such as installing software and setting up firewall.
    Example of IaaS include **AWS EC2** and **Google Compute Engine** (**GCE**).'
  prefs: []
  type: TYPE_NORMAL
- en: Compared with the past, this IaaS model can greatly reduce the hardware and
    network setup costs, and all other costs relating to space and resources surrounding
    that. Individual developers, or small- and medium-sized companies often do not
    need that many system resources. This model, therefore, allows them to rent the
    infrastructure as a service; they just need to pay for the resources that they
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros: Developers have much more flexibility. IaaS provides the necessary computing
    resources for applications to run on. Developers can easily request additional
    resources, or trim down resources, according to the needs of the application.
    This is easily customizable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: Developers need to spend time learning how to configure the cloud platform
    according to their needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PaaS**: PaaS is somewhere between SaaS and IaaS. There is no need for users
    to manage and maintain infrastructures. Service providers already package all
    these infrastructure and related services together as a platform and rent them
    out as a service to users. Users do not need to worry about the backend setup
    required, nor aspects such as extending the number of servers and load balancing.
    Users (developers) just need to focus on their development and deploy their work
    accordingly to the cloud platform. Example of PaaS include Heroku, Windows Azure,
    and AWS Elastic Beanstalk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros: Reduced setup time. By leveraging the services provided by the platform,
    developers can zero in on development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: There could be an unnecessary charge incurred. Compared to IaaS, PaaS
    is less flexible in the sense that you have less control over the infrastructure
    setup and configuration. As the whole platform is packaged as a service, some
    unused packaged resources could go to waste. In this case, the charge could be
    comparatively higher than IaaS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SaaS**: SaaS basically refers to web applications available on the internet.
    Users are not required to maintain the software. The software is provided as a
    service. A very typical example is Gmail. Example of SaaS include Dropbox, Salesforce,
    and Slack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros: The cost is low as we don''t need to care about hardware purchases and
    other setup costs. If a user has a specific requirement that can be addressed
    by this service, SaaS could be the easiest and most effective solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: Since the vast amount of user data will be stored in the cloud platform,
    there could be some concerns regarding data security. Also, we need to consider
    service availability once the application is deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As individual developers, we need a stable and scalable server for us to deploy
    our application. PaaS is the best option here. It provides the computing platform
    for applications to run on, and developers do not need to worry about hardware
    maintenance since service providers take care of all of this. Hence, it is a time
    and cost-saving solution for developers. Developers can focus on developing good
    software.
  prefs: []
  type: TYPE_NORMAL
- en: The Heroku Platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku is a popular PaaS. We can deploy our APIs there so that they can be accessed
    by anyone in the world. And it doesn't just support Python, but also other programming
    languages, including Ruby and Go.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku provides a free plan for developers to deploy and test their applications
    there. Certainly, they do have paid plans as well, and with many more powerful
    functions that can make our APIs more secure and efficient. Later on, if you need
    these powerful features and system resources for your application, you can consider
    that. But right now, for teaching purposes, a free plan is good enough.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Apart from Heroku, there are other cloud service providers. Some of the market
    leaders in cloud services are **Amazon Web Services** (**AWS**), **Google Cloud
    Platform** (**GCP**), IBM Cloud, Microsoft Azure, and Rackspace Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Handling in Smilecook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications require multiple configurations; at least one is required
    for a production server, and one for development use. There will be differences
    between them, such as the debug mode, secret key, and database URL. We can use
    a default configuration that is always loaded, and a separate configuration for
    the production server and development environment to inherit the default configuration
    depending on the environment. For environment-specific configurations, we will
    create two new classes – `DevelopmentConfig` and `ProductionConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 63: Configuration Handling for the Production and Development Environments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will segregate our application configurations between
    the development and production environments. For configurations such as `DEBUG`,
    we will require different values for the two environments. The same goes for the
    database URL as well. We are therefore going to create two sets of configurations,
    `DevelopmentConfig` and `ProductionConfig`. The former is for development and
    system enhancement in a development environment, while the latter is to be run
    in the production environment. Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in `config.py`, add a default configuration that will be used in all
    environments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `DevelopmentConfig` after the `Config` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new `DevelopmentConfig` class extends the parent `Config` class. The `DEBUG`
    value is set to `True`. That will allow us to see the error messages while we
    are developing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add `ProductionConfig` after the `Development Config` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ProductionConfig` class here also extends the parent `Config` class. Similar
    to the `DevelopmentConfig` class, we have `SECRET_KEY` and `SQLALCHEMY_DATABASE_URI`
    set here. In the production environment, these values are obtained from the environment
    variables. We will teach you how to set these on a cloud platform later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `app.py`, import `os`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app.py`, make the following change to get the configurations dynamically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ENV` environment variable will be obtained via `os.environ.get`. If it
    is `Production`, the production environment configuration will be used. In addition,
    the development environment configuration will be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Right-click on PyCharm and run the application. Because we haven''t set up
    the `ENV` environment variable in the local machine, Flask will pick up `config.DevelopmentConfig`
    and execute it. We can see from the output that **Debug mode: on**:![Figure 10.1:
    Running an application in the development environment'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.1: Running an application in the development environment'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, we have separated the configurations between the production and development
    environments. In the future, if there are common configurations shared among the
    two environments, we will put them in the `Config` class. Otherwise, they should
    be placed under the corresponding `DevelopmentConfig` or `ProductionConfig` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 64: Adding a Staging Configuration Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to facilitate internal testing, in this exercise, we need to add a
    `StagingConfig` class. This configuration will extend the common `Config` class.
    The staging environment will not be much different from production, because it
    is mainly designed to imitate the production environment for testing. And we will
    obtain the secret key and database URI from the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `config.py`, create a `StagingConfig` class that extends `Config`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `app.py`, modify the conditional statements for `StagingConfig`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hence, we have set up the configuration for the staging environment. But it
    is not completed yet, since the environment variables will need to be obtained
    from the cloud server. Next, we will start to work on the cloud platform, **Heroku**.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we deploy to Heroku (the cloud platform), we will first create an account
    and set up the environment there. We will create a new Heroku application. Then,
    we will need to install the Postgres database on Heroku. The installation process
    can be done within the Heroku platform; everything is integrated. Finally, we
    set up the virtual environment variables, such as the database URL and the secret
    key. Once all these precursors are completed, we will then start the deployment
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 65: Creating a New Application in Heroku'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will first register a Heroku account. Then, we will create
    a new app on it. Heroku provides a nice user interface with an easy-to-follow
    setup flow. We just need to click a few buttons and that''s it. As Heroku is a
    PaaS, we don''t need to manage any hardware nor set up the OS. These are all taken
    care of by Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit the Heroku website, [https://www.heroku.com/](https://www.heroku.com/),
    and click **Sign up**:![Figure 10.2: Visiting the Heroku website'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.2: Visiting the Heroku website'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the signup process is complete, click **Log in** and access the dashboard.
    Click **Create new app** to create a new application in Heroku:![Figure 10.3:
    Logging in and accessing the Heroku dashboard'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.3: Logging in and accessing the Heroku dashboard'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type in the app name, and then select the server region (right now, the only
    options are the United States and Europe; please select the one that is closer
    to your target users). Then, click **Create app** to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4: Typing in the app name and selecting the server region'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: Typing in the app name and selecting the server region'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The app name will be used in the application URL provided by Heroku, for example,
    `https://{app_name}.herokuapp.com/`. Users can then access our APIs using this
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the application is created, we can see the app administration screen,
    along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Heroku app administration screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.5: Heroku app administration screen'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The app administration screen provides information for us to understand the
    application status:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview**: For us to see the cost incurred or other collaborators'' activities'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resources**: For managing add-ons and the **Procfile** setting'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy**: For choosing the deployment method'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metrics**: For showing the metrics of the app'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity**: For tracking user activity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access**: For managing collaborator access'
  prefs: []
  type: TYPE_NORMAL
- en: '**Settings**: Includes environment variable configurations, buildpack settings,
    and other advanced features'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the heart of the Heroku platform is the ability to run the applications using
    the lightweight container Dynos. Containerization is a standard way to package
    your application's code, configuration, and dependencies into a single object.
    Containerization can reduce the burden on the managing hardware, virtual machine,
    or environment setup, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application has been created, we will install the Postgres repository
    in Heroku and we will install it directly via Heroku add-ons.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku Add-Ons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heroku has a rich add-ons library. Add-ons are like plugins, which provide tools
    and services for developing, extending, and operating your apps, including data
    stores, monitoring, logging, analytics, and security. For our Smilecook application,
    we will use Heroku Postgres from Heroku, which is a reliable and powerful database
    as a service based on PostgreSQL. The starter tier is free and offers a 10,000-row
    limit and provides an expected uptime of 99.5%. This is suitable for developing
    hobby applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 66: Installing Heroku Postgres'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will install Heroku Postgres. It is more convenient to
    install Postgres from Heroku, compared to installing it from the Postgres official
    website. We only need to go to the **Data Stores** category in **Heroku add-ons**
    and then select **Heroku Postgres** directly to install. Heroku provides a backend
    management interface so that we can see the database status at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **Resources** tab in Heroku, and then right-click on the **Find
    more add-ons** button:![Figure 10.6: Switching to the Resources tab in Heroku'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.6: Switching to the Resources tab in Heroku'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the **Add-ons** page, click on **Data Stores** and select **Heroku Postgres**:![Figure
    10.7: Add-ons page in Heroku'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.7: Add-ons page in Heroku'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, click on **Install Heroku Postgres** to install the add-on in our cloud
    server:![Figure 10.8: Installing the Heroku Postgres add-on'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.8: Installing the Heroku Postgres add-on'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Select the default, **Hobby Dev - Free Plan**. This plan is free. In **App
    to provision to**, put in the app name we used in the previous exercise, and then
    click **Provision add-on**:![Figure 10.9: Selecting the Heroku Postgres add-on
    plan'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.9: Selecting the Heroku Postgres add-on plan'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once that is done, we can check whether **Heroku Postgres** is installed on
    the **Add-ons** page:![Figure 10.10: Checking that Heroku Postgres is installed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.10: Checking that Heroku Postgres is installed'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, click on **Heroku Postgres add-on** to enter the management page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11: Heroku Postgres management page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: Heroku Postgres management page'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The **Overview** allows us to check the database status, utilization rate, and
    so on. **Durability** allows us to manage data security and backup. **Settings**
    stores the database credentials and other advanced settings. **Data clips** allow
    you to query the database data using the SQL command online. You can export or
    share the result there.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is pretty straightforward to install Postgres on Heroku;
    it just takes a few steps. Next, we will work on setting up the environment variables
    in the cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Environment Variables for the Heroku App
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We previously modified `config.py` and added `ProductionConfig` there. Now we
    have to add the environment variables in Heroku, including the secret key and
    database URL. In addition to these, let's not forget the Mailgun API key and the
    Mailgun domain as well. We will set up all of these together in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 67: Setting Up the App Environment Variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will set up the environment variables in the production
    environment. Fortunately, because we are using Heroku Postgres, the database URL
    environment variable has already been set up for us. We only need to set `ENV`,
    `SECRET_KEY`, `MAILGUN KEY`, and `DOMAIN`. Then, once the setting is complete,
    after the `Deploy` code is completed, the application will read the newly added
    environment variables in `App config`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate the secret key using the following two lines of code in the Python
    console in PyCharm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: A secret key should be as random as possible. There are a lot of random generators
    out there that we can leverage. But perhaps the easiest way to do so is to generate
    that in the Python console in PyCharm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go to the **Settings** tab and set up the **ENV**, **MAILGUN_API_KEY**, **MAILGUN_DOMAIN**,
    and **SECRET_KEY** environment variables as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12: Setting up environment variables in Heroku'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: Setting up environment variables in Heroku'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that we have finished the necessary preparatory setup in Heroku, we will
    go straight to the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment Using Heroku Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Heroku provides a guideline on how we can deploy our application. The guide
    can be found in the **Deploy** tab. It is mainly divided into three parts. They
    are **Install the Heroku CLI**, **Create a new Git repository**, and **Deploy
    your application**. The details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Deployment using the Heroku Git guideline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: Deployment using the Heroku Git guideline'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are three parts to the guideline in the **Deploy** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Install the Heroku CLI**'
  prefs: []
  type: TYPE_NORMAL
- en: '`heroku login` – For logging into Heroku using the Heroku CLI tool provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create a new Git repository**'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd my-project/` – Change directory to the `my-project` folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git init` – Initialize `git`, which is a version control system. We will discuss
    this soon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heroku git:remote -a smilecook` – Add the app (Smilecook) repository to the
    remote repository list of the local Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy your application**'
  prefs: []
  type: TYPE_NORMAL
- en: '`git add .` – To add all files and folders to the current directory and subfolder
    to Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git commit -am "make it better"` – Commit a change and insert the commit message
    to `make it better`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git push heroku master` – This will upload the local repository content to
    the remote repository, which is the repository in Heroku. Once it is pushed, Heroku
    will run the app start-up procedure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start deploying our application, there are still a few bits of terminology
    that require explanation.
  prefs: []
  type: TYPE_NORMAL
- en: What is Git?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Git** is a distributed version control system. A version control system is
    mainly a system that can keep track of every version of your source code. Any
    changes in the source code will be recorded in the system. It allows developers
    to easily restore the previous version. No manual backup is required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git also supports collaboration and other advanced features. If you are interested,
    you can go to the official Git website to learn more about it: [https://git-scm.com](https://git-scm.com).'
  prefs: []
  type: TYPE_NORMAL
- en: What is gitignore?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**gitignore** is a file that contains a list of files and folders that Git
    should ignore. Files and folders in this list will not be stored in Git. Usually,
    we will include the environment configs, logs, and so on in this list.'
  prefs: []
  type: TYPE_NORMAL
- en: What is Procfile?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Procfile** is a file that will be executed during the app start-up process
    in Heroku. Developers will put in the commands they want Heroku to run during
    the app start-up process. Usually, we will put the setup scripts and server start-up
    scripts here.'
  prefs: []
  type: TYPE_NORMAL
- en: What is Gunicorn?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Gunicorn** is a Python WSGI HTTP server that is compatible with various web
    applications. It can be used as an interface between web servers and web applications.
    Gunicorn can communicate with multiple web servers or start multiple web applications.
    It is a powerful and fast HTTP server.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the deployment flow as well as some key concepts
    and terminology, we will work on the deployment together in our next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 68: Setting Up the Git and the Heroku CLI'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will deploy our Smilecook application to the production
    environment. We will download and install the Heroku CLI and Git first so that
    we can run the deployment command in the local machine. Then, we will add the
    `gitignore` file to ensure that some files will not be uploaded to Heroku. Finally,
    we will add `main.py` and `Procfile` to the root directory of the project and
    then deploy it to Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the **Heroku CLI** from [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli).
    Pick the version for your OS and download it:![Figure 10.14: Installing the Heroku
    CLI'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.14: Installing the Heroku CLI'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you haven''t installed Git, please install it from [https://git-scm.com/](https://git-scm.com/):![Figure
    10.15: Installing Git'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.15: Installing Git'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At the bottom of PyCharm, open the terminal. Run the `git --version` command
    to confirm that Git has installed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right-click to create a `.gitignore` file in the project. This file will contain
    a list of files or folders that we don''t want to be added to Git:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static/images/avatars/*` – We do not want to include all the testing images
    that we created in the previous chapters to be uploaded to the production environment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`static/images/recipes/*` – We do not want to include all the testing images
    that we created in the previous chapters to be uploaded to the production environment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.idea/` – This is the IDE project-specific settings folder. We don''t need
    it in production.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`venv/` – This is the virtual environment.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log in to your Heroku account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, type in the following `git init` command to initialize Git. This is to
    add version control to our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the Heroku repository to the Git remote repository (please replace `your-heroku-app`
    with the name of your Heroku app).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Before adding in the remote repository, all our changes can only be committed
    to the local repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `requirements.txt`, add in the `gunicorn` package, which is going to be
    our HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `main.py` under the project root folder. This will be executed by Gunicorn
    to start up our web application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right-click to create a file under the project root folder. Name it `Procfile`
    without an extension and then insert the following two commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This `Procfile` file is for Heroku to run during the app start-up process. The
    first line is to ask Heroku to run `flask db upgrade` after every deployment.
    This is designed to ensure that our database schema is always up to date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second line is to have Heroku recognize it as the task that starts the webserver.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `git add .` in the Python console under PyCharm. This will add our source
    code to Git, for version control and deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the `git commit` command to commit our source code. The `-a` parameter
    tells Git to stage files that have been modified or deleted. The `-m` parameter
    is for incorporating the commit message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the application by using `git push` to push the source code to the Heroku
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Heroku will automatically set up the environment. We can see the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.16: Deploying the application to Heroku'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_10_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.16: Deploying the application to Heroku'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the deployment process, if we want to know more about what's happening
    behind the scenes, we can check the application logs by clicking the **More**
    button in the top right-hand corner, and then clicking **VIEW logs**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17: Deploying the application to Heroku'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_10_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.17: Deploying the application to Heroku'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the preceding log, we can see that after the database is upgraded, it will
    run Gunicorn. And finally, you can see the message **State changed from starting
    to up**.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully deployed our Smilecook application to Heroku, which means
    it is ready to serve the public. Later, we will test it using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the future, when there is a new version, we only need to use three commands
    to redeploy the application. First, use `git add .` to add our source code to
    Git, and then use `git commit -am "make it better"`. Lastly, use `git push heroku
    master` to push the source code to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 69: Checking the Heroku Postgres Tables in pgAdmin'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last exercise, we completed deployment. We will now need to check whether
    the tables have been created in the database. So, in this exercise, we are going
    to use `pgAdmin` to connect to Heroku Postgres:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the credentials of the database in Heroku Postgres, go to **Add-ons** >
    **Settings**, then click **View Credentials**, and you will see the following
    screen:![Figure 10.18: Getting the credentials of the database in Heroku Postgres'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.18: Getting the credentials of the database in Heroku Postgres'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Right-click on **Servers** and then create a new server in pgAdmin:![Figure
    10.19: Creating a new server in pgAdmin'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.19: Creating a new server in pgAdmin'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the **General** tab, name the server **Heroku**:![Figure 10.20: Entering
    the name for the server in the General tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.20: Entering the name for the server in the General tab'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the **Connection** tab, enter the credentials, including the **Host name/address**,
    **Port**, **Maintenance database**, **Username**, and **Password**, and then click
    **Save**:![Figure 10.21: Adding credentials to the Connection tab'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.21: Adding credentials to the Connection tab'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, check the database tables in pgAdmin. Go to **Heroku** >> **Databases**
    >> (your database name) >> **Schemas** >> **Public** >> **Tables** to verify this:![Figure
    10.22: Checking the database tables in pgAdmin'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.22: Checking the database tables in pgAdmin'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we can see whether the tables have been created in the database. If you
    can see that the tables have been created successfully, we can continue to the
    next step, which is using Postman to test our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Variables in Postman
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully deployed our project to Heroku. Now you can test them in
    Postman using all the saved requests that we set up before. However, the requests
    we have saved previously in Postman are all running against localhost. Instead
    of changing the URL bit by bit to the production URL, we can leverage the variables
    in Postman. We can set up a `url` variable and assign the production URL to it
    in Postman, then replace the URL with `{{url}}` from the saved request. Postman
    will then substitute `{{url}}` with the production URL for us dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 70: Setting Up Variables in Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will set up variables in Postman so that we can dynamically
    incorporate the appropriate value depending on the environment. We will set up
    the URL as a variable so that when we are testing in the development environment,
    we simply need to change the URL variable to `http://localhost:5000`. And if we
    are testing in a production environment, we can change that to `https://your_heroku_app.herokuapp.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click `Smilecook` as the environment name. Then, create a `url` variable with
    the value `https://your_heroku_app.herokuapp.com`. If the current value is not
    set, it will automatically assume the initial value. Please replace `your_heroku_app`
    with the name of your Heroku app, and then click **Update**:![Figure 10.23: Adding
    an environment variable in Postman'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.23: Adding an environment variable in Postman'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once it is added, verify the variable by clicking on the eye icon in the top
    right-hand corner:![Figure 10.24: Verifying the environment variable in Postman'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.24: Verifying the environment variable in Postman'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the `UserList` request, update the URL to `{{url}}/users` and then click
    `https://your_heroku_app.herokuapp.com/users` when the request is sent):![Figure
    10.25: Using an environment variable in the URL'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.25: Using an environment variable in the URL'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Postman is a very powerful testing tool. It can even allow us to effectively
    test our API endpoints on different environments. In the future, if you want to
    test other API endpoints in the production environment, you just need to change
    the URL in the previously saved requests. In the next activity, we will test your
    knowledge of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 18: Changing access_token to a Variable in Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous exercise, you learned how to change a URL to a variable. In
    this activity, we would like you to do the same for `access_token`:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an access token by using the previously saved **POST Token** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `access_token` as a variable in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test a Smilecook API endpoint that requires the access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 345.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That's great. When you are done with this activity, that means that you have
    already deployed and tested the Smilecook API in production. This is the final
    activity in the book and we are glad that you made it to this point!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will setup the Smilecook frontend website, which will work with the
    APIs that you have just developed.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Front-end Interface to Work with the Smilecook API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please download the `smilecook-vuejs` folder, which contains the frontend website
    source code, from [https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson10/Frontend](https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson10/Frontend):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new app in the Heroku platform, which is for deploying our frontend
    web interface:![Figure 10.26: Creating a new app in Heroku platform'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.26: Creating a new app in the Heroku platform'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once the app is created, we go to the **Settings** tab and then **Config Vars**.
    Here, we are going to set up an environment variable, which will be used to store
    the backend API URL:![Figure 10.27: Setting up an environment variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.27: Setting up an environment variable'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Set the variable name to be `VUE_APP_API_URL`, and insert the backend Smilecook
    API URL here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `smilecook-vuejs` project in PyCharm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the PyCharm console, type in the following command to log in to the Heroku
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, initialize `git` and add the Heroku repository to the `git:remote` repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, add the source code to `git`, commit, and push them to Heroku.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When deployment is complete, you should see the following message on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Type `https://your_heroku_app_name.herokuapp.com/` in the browser; we can see
    that the frontend interface has been set up successfully:![Figure 10.28: Successful
    frontend setup'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_10_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.28: Successful frontend setup'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, you can interact with the Smilecook API using this frontend website interface.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we successfully deployed the Smilecook API to the Heroku cloud
    server. The deployment process is simple as we are leveraging the service provided
    by Heroku. We do not need to worry about purchasing hardware, setting up the server
    OS, connecting the server to the internet, and so on. Everything is provided by
    Heroku. A cloud platform service can quickly help developers to deploy their applications/APIs
    to the internet. This easy deployment process allows developers to focus on development
    and not the infrastructure/platform setup. And once the API is deployed, millions
    of users on the internet can connect to the API through their client-side app.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Heroku is just one of the many cloud services available out there.
    As to which cloud service should be chosen, you should consider important factors
    such as cost, additional services provided, and the scale of our application.
    We do not limit you to a particular platform. In fact, we hope that this book
    is a starting point for your journey as a professional developer. With the fundamental
    knowledge that you have learned, you should be able to explore and further develop
    new skills and use new tools to build more advanced APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We have completed the whole book. Not only have you learned
    what an API is, but you have also developed and deployed a real-life API service,
    Smilecook, yourself. Throughout the entire book, you have learned about setting
    up a development environment, building an API, interacting with a database, object
    serialization, security tokens, interacting with third-party APIs, caching, and
    finally deployment. We have covered many different topics horizontally, and we
    have also explored each topic in-depth vertically. Apart from learning the theory,
    you have also practiced actual coding in the exercises and activities. You also
    tested your work thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Your next steps should involve continuing to learn by working on development
    projects. The most important thing is to have hands-on development experience,
    together with an inquiring mind. Look for a better solution whenever you encounter
    a problem. You should not be satisfied with just getting things done. Instead,
    you should aim at doing things right. That's what will take you to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you enjoyed the learning journey with us. Thank you!
  prefs: []
  type: TYPE_NORMAL
