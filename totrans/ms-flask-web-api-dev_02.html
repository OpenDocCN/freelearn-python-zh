<html><head></head><body>
		<div id="_idContainer021">
			<h1 id="_idParaDest-46" class="chapter-number"><a id="_idTextAnchor047"/><st c="0">2</st></h1>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor048"/><st c="2">Adding Advanced Core Features</st></h1>
			<p><st c="31">After the setup, configuration, and initial development of a Flask web application in </st><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="118">Chapter 1</st></em></span></a><st c="127">, it is time to include other essential components of the Flask framework that will complete a web application. </st><st c="239">These components, such as </st><em class="italic"><st c="265">session handling</st></em><st c="281">, </st><em class="italic"><st c="283">flash messaging</st></em><st c="298">, </st><em class="italic"><st c="300">error handling</st></em><st c="314">, and </st><em class="italic"><st c="320">software logging</st></em><st c="336">, can monitor and manage the interactions between the user and the internal transactions. </st><st c="426">Moreover, Flask can also provide an understanding of how the system will cope with critical issues such as running time, security, smooth performance, and changes to adapt to the ever-changing </st><span class="No-Break"><st c="619">production environment.</st></span></p>
			<p><st c="642">These major web components for building enterprise-grade applications supported by Flask will be the focus of this chapter. </st><st c="767">We will also discuss the various approaches in designing the project structure once these core components become part of </st><span class="No-Break"><st c="888">the application.</st></span></p>
			<p><st c="904">Here are the topics that we will cover in </st><span class="No-Break"><st c="947">this chapter:</st></span></p>
			<ul>
				<li><st c="960">Structuring huge and </st><span class="No-Break"><st c="982">scalable projects</st></span></li>
				<li><st c="999">Applying object-relational </st><span class="No-Break"><st c="1027">mapping (ORM)</st></span></li>
				<li><st c="1040">Configuring the </st><span class="No-Break"><st c="1057">logging mechanism</st></span></li>
				<li><st c="1074">Creating </st><span class="No-Break"><st c="1084">user sessions</st></span></li>
				<li><st c="1097">Applying </st><span class="No-Break"><st c="1107">flash messages</st></span></li>
				<li><st c="1121">Utilizing some advanced </st><span class="No-Break"><st c="1146">Jinja2 features</st></span></li>
				<li><st c="1161">Implementing </st><span class="No-Break"><st c="1175">error-handling solutions</st></span></li>
				<li><st c="1199">Adding </st><span class="No-Break"><st c="1207">static resources</st></span></li>
			</ul>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/><st c="1223">Technical requirements</st></h1>
			<p><st c="1246">This chapter will focus on ordering and product management transactions. </st><st c="1320">The application prototype for this chapter, an </st><em class="italic"><st c="1367">Online Shipping Management System</st></em><st c="1400">, covers some generic product inventory, an ordering module, a basic shipping flow structure, and some parts of the delivery management module. </st><st c="1544">This prototype comes in three different implementations suited for a complex and scalable Flask web application, namely, </st><span class="No-Break"><st c="1665">the following:</st></span></p>
			<ul>
				<li><st c="1679">The </st><strong class="source-inline"><st c="1684">ch02-factory</st></strong><st c="1696"> project that utilizes the application factory </st><span class="No-Break"><st c="1743">design pattern.</st></span></li>
				<li><st c="1758">The </st><strong class="source-inline"><st c="1763">ch02-blueprint</st></strong><st c="1777"> project that uses the </st><span class="No-Break"><st c="1800">Flask blueprint.</st></span></li>
				<li><st c="1816">The </st><strong class="source-inline"><st c="1821">ch02-blueprint-factory</st></strong><st c="1843"> project that uses both the application factory and </st><span class="No-Break"><st c="1895">blueprint structure.</st></span></li>
			</ul>
			<p><st c="1915">Like in </st><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="1924">Chapter 1</st></em></span></a><st c="1933">, the application uses </st><em class="italic"><st c="1956">PostgreSQL</st></em><st c="1966"> as a database, but this time with an ORM called </st><strong class="bold"><st c="2015">SQLAlchemy</st></strong><st c="2025">. All these projects are uploaded </st><span class="No-Break"><st c="2059">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch02"><span class="No-Break"><st c="2062">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch02</st></span></a><span class="No-Break"><st c="2143">.</st></span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/><st c="2144">Structuring huge and scalable projects</st></h1>
			<p><st c="2183">Creating a directory structure for a </st><em class="italic"><st c="2221">simple</st></em><st c="2227"> Flask web application is very handy and easy, especially if there is only one module to build with few software features. </st><st c="2350">But for complex and scalable</st><a id="_idIndexMarker070"/><st c="2378"> enterprise-grade applications with an overwhelming number of features to support, the most common issue is always the </st><em class="italic"><st c="2497">circular </st></em><span class="No-Break"><em class="italic"><st c="2506">import problem</st></em></span><span class="No-Break"><st c="2520">.</st></span></p>
			<p class="callout-heading"><st c="2521">Important note</st></p>
			<p class="callout"><st c="2536">A </st><em class="italic"><st c="2539">circular import problem</st></em><st c="2562"> happens when two or </st><a id="_idIndexMarker071"/><st c="2583">more modules import each other, creating a mutual dependency loop before the application’s full-blown execution. </st><st c="2696">This scenario always causes unexpected application loading errors, missing modules, and even weird </st><span class="No-Break"><st c="2795">runtime problems.</st></span></p>
			<p><st c="2812">Flask as a framework is very Pythonic, which means developers can decide on their approaches to structuring their applications. </st><st c="2941">Unfortunately, not all directory structure designs push through due to circular import problems. </st><st c="3038">However, three design patterns can provide a baseline structure for</st><a id="_idIndexMarker072"/><st c="3105"> Flask projects: the </st><em class="italic"><st c="3126">application factory design</st></em><st c="3152">, the </st><em class="italic"><st c="3158">Blueprint approach</st></em><st c="3176">, and the </st><em class="italic"><st c="3186">combined application factory and </st></em><span class="No-Break"><em class="italic"><st c="3219">Blueprint template</st></em></span><span class="No-Break"><st c="3237">.</st></span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/><st c="3238">Using the application factory</st></h2>
			<p><st c="3268">In </st><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="3272">Chapter 1</st></em></span></a><st c="3281">, the project structure used in our application was composed of modules and packages of various components </st><a id="_idIndexMarker073"/><st c="3388">such as the models, repository, services, templates, and the </st><strong class="source-inline"><st c="3449">main.py</st></strong><st c="3456"> file. </st><st c="3463">The code organization was not within Flask’s standard but was considered a clean </st><span class="No-Break"><st c="3544">directory structure.</st></span></p>
			<p><st c="3564">One approach in building </st><a id="_idIndexMarker074"/><st c="3590">a Flask project is to use the </st><em class="italic"><st c="3620">application factory</st></em><st c="3639">, a method consisting of the instantiation and configuration of the Flask instance. </st><st c="3723">It loads the configuration file into the platform, sets up the necessary extension modules such as SQLAlchemy, and initializes the Flask constructor with parameters, such as </st><strong class="source-inline"><st c="3897">template_folder</st></strong><st c="3912"> and </st><strong class="source-inline"><st c="3917">static_folder</st></strong><st c="3930">, before the </st><strong class="source-inline"><st c="3943">app</st></strong><st c="3946">’s instantiation. </st><st c="3965">With factory application, there is flexibility in dealing with configurations. </st><st c="4044">An application may have a separate factory method for </st><em class="italic"><st c="4098">testing</st></em><st c="4105">, </st><em class="italic"><st c="4107">development</st></em><st c="4118">, and </st><em class="italic"><st c="4124">production</st></em><st c="4134">, depending on the stages the application </st><span class="No-Break"><st c="4176">will undergo.</st></span></p>
			<p><st c="4189">But where to place this method definition? </st><st c="4233">Before implementing this approach, separate all views and their related components from the general application components, such as exception classes and error pages. </st><st c="4400">Place the files in sub-folders, but you may also add more folders underneath to organize the modules further. </st><st c="4510">Afterward, create an </st><strong class="source-inline"><st c="4531">__init__.py</st></strong><st c="4542"> file anywhere inside these sub-folders to implement the application factory method. </st><st c="4627">In our case, the </st><strong class="source-inline"><st c="4644">__init__.py</st></strong><st c="4655"> file of the </st><strong class="source-inline"><st c="4668">app</st></strong><st c="4671"> sub-folder is where we defined the application factory. </st><span class="No-Break"><em class="italic"><st c="4728">Figure 2</st></em></span><em class="italic"><st c="4736">.1</st></em><st c="4738"> shows the directory structure for the </st><strong class="source-inline"><st c="4777">ch02-factory</st></strong><st c="4789"> project that contains the version of the </st><em class="italic"><st c="4831">Online Shipping Management System</st></em><st c="4864"> prototype with the </st><span class="No-Break"><st c="4884">application factory:</st></span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B19383_02_1.jpg" alt="Figure 2.1 – Flask project directory with application factory"/><st c="4904"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5064">Figure 2.1 – Flask project directory with application factory</st></p>
			<p><st c="5125">The </st><strong class="source-inline"><st c="5130">__init__.py</st></strong><st c="5141"> file converts any directory to a package with files and folders importable to other modules. </st><st c="5235">Any module script imported inside the </st><strong class="source-inline"><st c="5273">__init__.py</st></strong><st c="5284"> file exposes the script for import outside the package directory. </st><st c="5351">Likewise, it also allows exposing modules from other packages that are out of reach of the internal modules due to relative path problems. </st><st c="5490">On the other hand, the application automatically loads all imported modules and </st><a id="_idIndexMarker075"/><st c="5570">executes method calls </st><a id="_idIndexMarker076"/><st c="5592">found inside the </st><strong class="source-inline"><st c="5609">__init__.py</st></strong><st c="5620"> file. </st><st c="5627">Thus, placing our application factory inside the </st><strong class="source-inline"><st c="5676">__init__.py</st></strong><st c="5687"> file of the </st><strong class="source-inline"><st c="5700">app</st></strong><st c="5703"> package exposes the function anywhere within the Flask project. </st><st c="5768">The following is the content of our </st><span class="No-Break"><strong class="source-inline"><st c="5804">app/__init__.py</st></strong></span><span class="No-Break"><st c="5819"> file:</st></span></p>
			<pre class="source-code"><st c="5825">
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
import logging
import logging.config
import logging.handlers
import sys
import toml
# Extension modules initialization
db = SQLAlchemy()
def configure_func_logging(log_path):
    logging.getLogger("werkzeug").disabled = True
    console_handler =   logging.StreamHandler(stream=sys.stdout)
    console_handler.setLevel(logging.DEBUG)
    logging.basicConfig(level=logging.DEBUG,  format='%(asctime)s %(levelname)s %(module)s
          %(funcName)s %(message)s',
     datefmt='%Y-%m-%d %H:%M:%S',  handlers=[logging.handlers.RotatingFileHandler(
        log_path, backupCount=3, maxBytes=1024 ),
           console_handler])
def </st><strong class="bold"><st c="6464">create_app(config_file):</st></strong><st c="6488">
    app = Flask(__name__, template_folder='../app/pages', static_folder='../app/resources')
    app.config.from_file(config_file, toml.load)
    db.init_app(app)
    configure_func_logging('log_msg.txt')
    </st><strong class="bold"><st c="6677">with app.app_context():</st></strong><st c="6700">
        from app.views import login
        from app.views import menu
        from app.views import customer
        from app.views import admin
        from app.views import product
        from app.views import order
        from app.views import payment
        from app.views import shipping
    return app</st></pre>			<p><st c="6944">The common and standard name given to an application factory function is </st><strong class="source-inline"><st c="7018">create_app()</st></strong><st c="7030">, but anyone can replace it with something appropriate for their project. </st><st c="7104">In the given snippet, our application factory creates the Flask’s </st><strong class="source-inline"><st c="7170">app</st></strong><st c="7173"> instance, calls </st><strong class="source-inline"><st c="7190">db_init()</st></strong><st c="7199"> of the</st><a id="_idIndexMarker077"/><st c="7206"> SQLAlchemy’s </st><strong class="source-inline"><st c="7220">db</st></strong><st c="7222"> instance to define and configure the ORM with the </st><strong class="source-inline"><st c="7273">app</st></strong><st c="7276"> object, and sets up the logging</st><a id="_idIndexMarker078"/><st c="7308"> mechanism. </st><st c="7320">Since it is in </st><strong class="source-inline"><st c="7335">__init__.py</st></strong><st c="7346">, the </st><strong class="source-inline"><st c="7352">main.py</st></strong><st c="7359"> file must import the factory method to eventually create the object and run the application by calling the </st><strong class="source-inline"><st c="7467">app</st></strong><st c="7470">’s </st><span class="No-Break"><strong class="source-inline"><st c="7474">run()</st></strong></span><span class="No-Break"><st c="7479"> method.</st></span></p>
			<p><st c="7487">To make the application factory method flexible and configurable, add local parameters to it. </st><st c="7582">For instance, it can take a filename as a string parameter to accept a configuration filename, such that when an application runs in development mode, it can take </st><strong class="source-inline"><st c="7745">config_dev.toml</st></strong><st c="7760"> as its configuration file. </st><st c="7788">When shifting the deployment to the production server, it can accept a new filename and replace the existing config with a production configuration file, say </st><strong class="source-inline"><st c="7946">config_prod.toml</st></strong><st c="7962">, to reload all the environment variables intended for the </st><span class="No-Break"><st c="8021">production server.</st></span></p>
			<h3><st c="8039">Utilizing the current_app proxy</st></h3>
			<p><st c="8071">Using the application factory design </st><a id="_idIndexMarker079"/><st c="8109">pattern in structuring the application makes it impossible to access the </st><strong class="source-inline"><st c="8182">app</st></strong><st c="8185"> instance from </st><strong class="source-inline"><st c="8200">main.py</st></strong><st c="8207"> in the views and other components requiring it, without encountering </st><em class="italic"><st c="8277">circular import issues</st></em><st c="8299">. Instead of importing the </st><strong class="source-inline"><st c="8326">app</st></strong><st c="8329"> object in the modules of the </st><strong class="source-inline"><st c="8359">app</st></strong><st c="8362"> directory, we establish the application context in </st><strong class="source-inline"><st c="8414">create_app()</st></strong><st c="8426"> to utilize the proxy </st><strong class="source-inline"><st c="8448">app</st></strong><st c="8451"> object </st><span class="No-Break"><st c="8459">called </st></span><span class="No-Break"><strong class="source-inline"><st c="8466">current_app</st></strong></span><span class="No-Break"><st c="8477">.</st></span></p>
			<p><st c="8478">In Flask, the application context manages configuration variables, view data, loggers, database details, and other custom objects at the application level during a request. </st><st c="8652">There are two ways of creating the </st><span class="No-Break"><st c="8687">application context:</st></span></p>
			<ul>
				<li><st c="8707">Explicitly pushing the application context using the </st><strong class="source-inline"><st c="8761">push()</st></strong><st c="8767"> method, allowing access to the </st><strong class="source-inline"><st c="8799">current_app</st></strong><st c="8810"> from anywhere in the application for </st><span class="No-Break"><st c="8848">every request:</st></span><pre class="source-code"><st c="8862">
         app_ctx = </st><strong class="bold"><st c="8873">app.app_context()</st></strong><st c="8890">
         app_ctx.</st><strong class="bold"><st c="8899">push()</st></strong></pre></li>				<li><st c="8906">Automatically pushing the application context using the </st><strong class="source-inline"><st c="8963">with</st></strong><st c="8967">-block, setting a limit on where to access</st><a id="_idIndexMarker080"/><st c="9010"> the application-level components, such as allowing access to </st><strong class="source-inline"><st c="9072">current_app</st></strong><st c="9083"> from the </st><strong class="source-inline"><st c="9093">views</st></strong><st c="9098"> module only, as depicted in the </st><span class="No-Break"><st c="9131">following example:</st></span><pre class="source-code"><strong class="bold"><st c="9149">with app.app_context():</st></strong><st c="9173">
             from app.views import login
             from app.views import menu
             from app.views import customer
             from app.views import admin
             from app.views import product
             from app.views import order
             from app.views import payment
             from app.views import shipping</st></pre></li>			</ul>
			<p><st c="9406">Instead of accessing the </st><strong class="source-inline"><st c="9432">app</st></strong><st c="9435"> instance from the </st><strong class="source-inline"><st c="9454">__init__.py</st></strong><st c="9465"> file to implement views in the </st><strong class="source-inline"><st c="9497">views.shipping</st></strong><st c="9511"> module, which definitely can cause circular import problems due to the </st><strong class="source-inline"><st c="9583">current_app()</st></strong><st c="9596">’s import to the </st><strong class="source-inline"><st c="9614">views.shipping</st></strong><st c="9628"> module, the application can now allow the use of the </st><strong class="source-inline"><st c="9682">current_app</st></strong><st c="9693"> proxy to build </st><strong class="source-inline"><st c="9709">views.shipping</st></strong><st c="9723"> because of the </st><strong class="source-inline"><st c="9739">with</st></strong><st c="9743">-context block pushing the module script to the application context. </st><st c="9813">The following code shows the use of the proxy object in creating the </st><strong class="source-inline"><st c="9882">add_delivery_officer</st></strong><st c="9902"> view function that inserts delivery officer profile details into </st><span class="No-Break"><st c="9968">the database:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="9981">from flask import current_app</st></strong><st c="10011">
@</st><strong class="bold"><st c="10013">current_app</st></strong><st c="10024">.route('/delivery/officer/add', methods = ['GET', 'POST'])
def add_delivery_officer():
    if request.method == 'POST':
        </st><strong class="bold"><st c="10140">current_app.logger.info('add_delivery_officer</st></strong><strong class="bold"><st c="10185">POST view executed')</st></strong><st c="10206">
        repo = DeliveryOfficerRepository(db)
        officer = DeliveryOfficer(id=int(request.form['id']), firstname=request.form['firstname'], middlename=request.form['middlename'],
          … … … … … …
        result = repo.insert(officer)
        return render_template(
         'shipping/add_delivery_officer_form.html'), 200
    </st><strong class="bold"><st c="10488">current_app.logger.info('add_delivery_officer</st></strong><strong class="bold"><st c="10533">GET view executed')</st></strong><st c="10553">
    return render_template(
       'shipping/add_delivery_officer_form.html'), 200</st></pre>			<p><st c="10625">The </st><strong class="source-inline"><st c="10630">current_app</st></strong><st c="10641"> is part of the </st><strong class="source-inline"><st c="10657">flask</st></strong><st c="10662"> module that can provide all the necessary decorators and utilities for building the view functions and other components, as long as the module scripts are </st><em class="italic"><st c="10818">within the bounds of the application context</st></em><st c="10862"> pushed by </st><strong class="source-inline"><st c="10873">create_app()</st></strong><st c="10885">. In the </st><strong class="source-inline"><st c="10894">add_delivery_officer</st></strong><st c="10914"> view function, the </st><strong class="source-inline"><st c="10934">current_app</st></strong><st c="10945"> provides</st><a id="_idIndexMarker081"/><st c="10954"> the </st><strong class="source-inline"><st c="10959">route()</st></strong><st c="10966"> decorator and the </st><strong class="source-inline"><st c="10985">logger</st></strong><st c="10991"> instance configured by the </st><span class="No-Break"><st c="11019">application factory.</st></span></p>
			<h3><st c="11039">Storing data to the application context</st></h3>
			<p><st c="11079">Now, the application context in</st><a id="_idIndexMarker082"/><st c="11111"> Flask is like a mini-layer created on top of the request context for every request-response transaction. </st><st c="11217">There is always a new context in every request, so all application-level data are short-lived in Flask applications. </st><st c="11334">During this span, we can store data using another application-level proxy object, the </st><strong class="source-inline"><st c="11420">g</st></strong><st c="11421"> component. </st><st c="11433">The following snippet shows how to create and destroy application context </st><span class="No-Break"><st c="11507">data objects:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="11520">def get_database():</st></strong><strong class="bold"><st c="11540">if 'db' not in g:</st></strong><strong class="bold"><st c="11558">g.db = db</st></strong><st c="11568">
        app.logger.info('storing … as context data')
</st><strong class="bold"><st c="11614">@app.teardown_appcontext</st></strong><st c="11638">
def teardown_database(exception):
    </st><strong class="bold"><st c="11673">db = g.pop('db', None)</st></strong><st c="11695">
    app.logger.info('removing … as context data')</st></pre>			<p><st c="11741">The </st><strong class="source-inline"><st c="11746">get_database()</st></strong><st c="11760"> method stores the </st><strong class="source-inline"><st c="11779">db</st></strong><st c="11781"> instance instantiated by </st><strong class="source-inline"><st c="11807">create_app()</st></strong><st c="11819"> into the context through the </st><strong class="source-inline"><st c="11849">g</st></strong><st c="11850"> proxy. </st><st c="11858">Before storing the data, it is always a good practice to first verify whether the object is already in </st><strong class="source-inline"><st c="11961">g</st></strong><st c="11962">. On the other hand, the </st><strong class="source-inline"><st c="11987">teardown_database()</st></strong><st c="12006"> has a </st><strong class="source-inline"><st c="12013">@app.teardown_appcontext</st></strong><st c="12037"> decorator that allows the automatic calling of the method before the request context ends. </st><st c="12129">The </st><strong class="source-inline"><st c="12133">pop()</st></strong><st c="12138"> method of </st><strong class="source-inline"><st c="12149">g</st></strong><st c="12150"> removes or deallocates the data from the context before Flask destroys the whole </st><span class="No-Break"><st c="12232">application context.</st></span></p>
			<p><st c="12252">Accessing </st><strong class="source-inline"><st c="12263">g</st></strong><st c="12264"> for storing data </st><a id="_idIndexMarker083"/><st c="12282">will not always work in the application. </st><st c="12323">The appropriate place to create the context data or call our </st><strong class="source-inline"><st c="12384">get_database()</st></strong><st c="12398"> method is in the </st><strong class="source-inline"><st c="12416">@before_request</st></strong><st c="12431"> method. </st><st c="12440">This method automatically executes before any request transactions start. </st><st c="12514">The context data in </st><strong class="source-inline"><st c="12534">g</st></strong><st c="12535"> will only be accessible to any view function after the execution of the </st><strong class="source-inline"><st c="12608">@before_request</st></strong><st c="12623"> event method. </st><st c="12638">In other words, all resources shared through </st><strong class="source-inline"><st c="12683">g</st></strong><st c="12684"> will be accessible only within the request-response scope. </st><st c="12744">Accessing </st><strong class="source-inline"><st c="12754">g</st></strong><st c="12755"> context data not set in </st><strong class="source-inline"><st c="12780">@before_request</st></strong><st c="12795"> can cause </st><strong class="source-inline"><st c="12806">ValueError</st></strong><st c="12816">. Thus, we invoke our </st><strong class="source-inline"><st c="12838">get_database()</st></strong><st c="12852"> method in the following </st><strong class="source-inline"><st c="12877">@</st></strong><span class="No-Break"><strong class="source-inline"><st c="12878">before_request</st></strong></span><span class="No-Break"><st c="12892"> implementation:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="12908">@app.before_request</st></strong><st c="12928">
def init_request():
    </st><strong class="bold"><st c="12949">get_database()</st></strong></pre>			<p><st c="12963">This will allow the following </st><strong class="source-inline"><st c="12994">list_login</st></strong><st c="13004"> view function to access the database for </st><span class="No-Break"><st c="13046">query transactions:</st></span></p>
			<pre class="source-code"><st c="13065">
@current_app.route('/login/list', methods=['GET'])
def list_login():
     repo = LoginRepository(</st><strong class="bold"><st c="13158">g.db</st></strong><st c="13163">)
     users = repo.select_all()
     session['sample'] = 'trial'
     flash('List of user credentials')
     return render_template('login/login_list.html', users=users) , 200</st></pre>			<p><st c="13320">Although it is an advantage to verify the existence of a context attribute in </st><strong class="source-inline"><st c="13399">g</st></strong><st c="13400"> before accessing it, sometimes accessing the data right away is inevitable, such as in our </st><strong class="source-inline"><st c="13492">list_login</st></strong><st c="13502"> view function </st><a id="_idIndexMarker084"/><st c="13517">that directly passes the </st><strong class="source-inline"><st c="13542">g.db</st></strong><st c="13546"> context object into </st><strong class="source-inline"><st c="13567">LoginRepository</st></strong><st c="13582">. Another approach to accessing the context data is through the </st><strong class="source-inline"><st c="13646">g.set()</st></strong><st c="13653"> method that allows a default value if the data is non-existent, such as using </st><strong class="source-inline"><st c="13732">g.get('db', db)</st></strong><st c="13747"> instead of </st><strong class="source-inline"><st c="13759">g.db</st></strong><st c="13763">, where </st><strong class="source-inline"><st c="13771">db</st></strong><st c="13773"> in the second parameter is a </st><span class="No-Break"><st c="13803">backup connection.</st></span></p>
			<p class="callout-heading"><st c="13821">Important note</st></p>
			<p class="callout"><st c="13836">Both application and request contexts exist only during a request-response life cycle. </st><st c="13924">The application context provides the </st><strong class="source-inline"><st c="13961">current_app</st></strong><st c="13972"> proxy and the </st><strong class="source-inline"><st c="13987">g</st></strong><st c="13988"> variable, while the request context contains the request variables and the view function details. </st><st c="14087">Unlike in other web frameworks, Flask’s application context will not be valid for access after the life cycle destroys the </st><span class="No-Break"><st c="14210">request context.</st></span></p>
			<p><st c="14226">Aside from the application factory, we can also use Flask’s blueprints to establish a </st><span class="No-Break"><st c="14313">project directory.</st></span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/><st c="14331">Using the Blueprint</st></h2>
			<p><strong class="source-inline"><st c="14351">Blueprints</st></strong><st c="14362"> are Flask’s built-in </st><a id="_idIndexMarker085"/><st c="14384">components from its </st><strong class="source-inline"><st c="14404">flask</st></strong><st c="14409"> module. </st><st c="14418">Their core purpose is to organize all related views with the repository, services, templates, and other associated features to form a solid and self-contained structure. </st><st c="14588">The strength of the Blueprint is that it can break down a single huge application into independent </st><a id="_idIndexMarker086"/><st c="14687">business units that can be considered sub-applications but are still dependent on the main application. </st><span class="No-Break"><em class="italic"><st c="14791">Figure 2</st></em></span><em class="italic"><st c="14799">.2</st></em><st c="14801"> shows the organization of the </st><strong class="source-inline"><st c="14832">ch02-blueprint</st></strong><st c="14846"> project, a version of our </st><em class="italic"><st c="14873">Online Shipping Management System</st></em><st c="14906"> that uses Blueprints in building its </st><span class="No-Break"><st c="14944">project structure:</st></span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B19383_02_2.jpg" alt="Figure 2.2 – Flask project directory with Blueprints"/><st c="14962"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15287">Figure 2.2 – Flask project directory with Blueprints</st></p>
			<h3><st c="15339">Defining the Blueprint</st></h3>
			<p><st c="15362">Instead of placing all view files in </st><a id="_idIndexMarker087"/><st c="15400">one folder, the project’s related views are grouped based on business units, then assigned their respective Blueprint sub-projects, namely, </st><strong class="source-inline"><st c="15540">home</st></strong><st c="15544">, </st><strong class="source-inline"><st c="15546">login</st></strong><st c="15551">, </st><strong class="source-inline"><st c="15553">order</st></strong><st c="15558">, </st><strong class="source-inline"><st c="15560">payment</st></strong><st c="15567">, </st><strong class="source-inline"><st c="15569">product</st></strong><st c="15576">, and </st><strong class="source-inline"><st c="15582">shipping</st></strong><st c="15590">. Each Blueprint represents a section with the templates, static resources, repositories, services, and utilities needed to build </st><span class="No-Break"><st c="15720">a sub-application.</st></span></p>
			<p><st c="15738">Now, the </st><strong class="source-inline"><st c="15748">__init__.py</st></strong><st c="15759"> file of each sub-application is very important because this is where the Blueprint object is created and instantiated. </st><st c="15879">The blueprint </st><strong class="source-inline"><st c="15893">home</st></strong><st c="15897">’s </st><strong class="source-inline"><st c="15901">__init__.py</st></strong><st c="15912"> file, for instance, has the following </st><span class="No-Break"><st c="15951">Blueprint definition:</st></span></p>
			<pre class="source-code"><st c="15972">
from flask import Blueprint
</st><strong class="bold"><st c="16001">home_bp = Blueprint('home_bp', __name__,</st></strong><strong class="bold"><st c="16041">template_folder='pages',</st></strong><strong class="bold"><st c="16066">static_folder='resources', static_url_path='static')</st></strong><st c="16119">
import modules.home.views.menu</st></pre>			<p><st c="16150">Meanwhile, the </st><strong class="source-inline"><st c="16166">login</st></strong><st c="16171"> section’s</st><a id="_idIndexMarker088"/><st c="16181"> Blueprint has the </st><strong class="source-inline"><st c="16200">__init__py</st></strong><st c="16210"> file that </st><span class="No-Break"><st c="16221">contains this:</st></span></p>
			<pre class="source-code"><st c="16235">
from flask import Blueprint
</st><strong class="bold"><st c="16264">login_bp = Blueprint('login_bp', __name__,</st></strong><strong class="bold"><st c="16306">template_folder='pages',</st></strong><strong class="bold"><st c="16331">static_folder='resources', static_url_path='static')</st></strong><st c="16384">
import modules.login.views.login
import modules.login.views.admin
import modules.login.views.customer</st></pre>			<p><st c="16486">The constructor of the </st><strong class="source-inline"><st c="16510">Blueprint</st></strong><st c="16519"> class requires two parameters for it to instantiate </st><span class="No-Break"><st c="16572">the class:</st></span></p>
			<ul>
				<li><st c="16582">The first parameter is the </st><em class="italic"><st c="16610">name of Blueprint</st></em><st c="16627">, usually the name of the reference variable of </st><span class="No-Break"><st c="16675">its instance.</st></span></li>
				<li><st c="16688">The second parameter is </st><strong class="source-inline"><st c="16713">__name__</st></strong><st c="16721">, which depicts the </st><em class="italic"><st c="16741">current package</st></em><st c="16756"> of </st><span class="No-Break"><st c="16760">the section.</st></span></li>
			</ul>
			<p><st c="16772">The name of the Blueprint must be unique to the sub-application because it is responsible for its internal routings, which must not have any collisions with the other Blueprints. </st><st c="16952">The Blueprint package, on the other hand, will indicate the root path of </st><span class="No-Break"><st c="17025">the sub-application.</st></span></p>
			<h3><st c="17045">Implementing the Blueprint’s routes</st></h3>
			<p><st c="17081">One purpose of using a Blueprint is to avoid circular import issues in implementing the routes. </st><st c="17178">Rather than accessing the </st><a id="_idIndexMarker089"/><st c="17204">app instance from </st><strong class="source-inline"><st c="17222">main.py</st></strong><st c="17229">, sub-applications can now directly access their respective Blueprint instance to build their routes. </st><st c="17331">The following code shows how the login Blueprint implements its route using its Blueprint instance, the </st><span class="No-Break"><strong class="source-inline"><st c="17435">login_bp</st></strong></span><span class="No-Break"><st c="17443"> object:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="17451">from modules.login import login_bp</st></strong>
<strong class="bold"><st c="17486">@login_bp.route('/admin/add', methods = ['GET', 'POST'])</st></strong><st c="17543">
def add_admin():
    if request.method == 'POST':
        app.logger.info('add_admin POST view executed')
        repo = AdminRepository(db_session)
        … … … … … …
        return render_template('admin_details_form.html', logins=logins), 200
    app.logger.info('add_admin GET view executed')
    logins = get_login_id(1, db_session)
    return render_template('admin_details_form.html', logins=logins), 200</st></pre>			<p><st c="17908">The </st><strong class="source-inline"><st c="17913">login_bp</st></strong><st c="17921"> object is instantiated from </st><strong class="source-inline"><st c="17950">__init__py</st></strong><st c="17960"> of the </st><strong class="source-inline"><st c="17968">login</st></strong><st c="17973"> directory, thus importing it from there. </st><st c="18015">But this route and the rest of the views will only work after registering these Blueprints with the </st><span class="No-Break"><strong class="source-inline"><st c="18115">app</st></strong></span><span class="No-Break"><st c="18118"> instance.</st></span></p>
			<h3><st c="18128">Registering the blueprints</st></h3>
			<p><st c="18155">Blueprint registration happens in the </st><strong class="source-inline"><st c="18194">main.py</st></strong><st c="18201"> file, which is the location of the Flask app. </st><st c="18248">The following snippet is part of the </st><strong class="source-inline"><st c="18285">main.py</st></strong><st c="18292"> file of our </st><strong class="source-inline"><st c="18305">ch02-blueprint</st></strong><st c="18319"> project that shows how to </st><a id="_idIndexMarker090"/><st c="18346">establish the registration </st><span class="No-Break"><st c="18373">procedure correctly:</st></span></p>
			<pre class="source-code"><st c="18393">
from flask import Flask
app = Flask(__name__, template_folder='pages')
app.config.from_file('config.toml', toml.load)
</st><strong class="bold"><st c="18512">from modules.home import home_bp</st></strong>
<strong class="bold"><st c="18544">from modules.login import login_bp</st></strong>
<strong class="bold"><st c="18579">from modules.order import order_bp</st></strong>
<strong class="bold"><st c="18614">from modules.payment import payment_bp</st></strong>
<strong class="bold"><st c="18653">from modules.shipping import shipping_bp</st></strong>
<strong class="bold"><st c="18694">from modules.product import product_bp</st></strong>
<strong class="bold"><st c="18733">app.register_blueprint(home_bp, url_prefix='/ch02')</st></strong>
<strong class="bold"><st c="18785">app.register_blueprint(login_bp, url_prefix='/ch02')</st></strong>
<strong class="bold"><st c="18838">app.register_blueprint(order_bp, url_prefix='/ch02')</st></strong>
<strong class="bold"><st c="18891">app.register_blueprint(payment_bp, url_prefix='/ch02')</st></strong>
<strong class="bold"><st c="18946">app.register_blueprint(shipping_bp, url_prefix='/ch02')</st></strong>
<strong class="bold"><st c="19002">app.register_blueprint(product_bp, url_prefix='/ch02')</st></strong><st c="19057">
from modules.model.db import *
if __name__ == '__main__':
    app.run()</st></pre>			<p><st c="19125">The </st><strong class="source-inline"><st c="19130">register_blueprint()</st></strong><st c="19150"> method from the </st><strong class="source-inline"><st c="19167">app</st></strong><st c="19170"> instance has three parameters, namely, </st><span class="No-Break"><st c="19210">the following:</st></span></p>
			<ul>
				<li><st c="19224">The Blueprint object imported from </st><span class="No-Break"><st c="19260">the sub-application.</st></span></li>
				<li><st c="19280">The </st><strong class="source-inline"><st c="19285">url_prefix</st></strong><st c="19295">, the assigned URL </st><span class="No-Break"><st c="19314">base route.</st></span></li>
				<li><st c="19325">The </st><strong class="source-inline"><st c="19330">url_defaults</st></strong><st c="19342">, the dictionary of parameters required by the views linked to </st><span class="No-Break"><st c="19405">the Blueprint.</st></span></li>
			</ul>
			<p><st c="19419">Registering the Blueprints can also be </st><a id="_idIndexMarker091"/><st c="19459">considered a workaround in providing our Flask applications with a context root. </st><st c="19540">The context root defines the application, and it serves as the base URL that can be used to access the application. </st><st c="19656">In the given snippet, our application was assigned the </st><strong class="source-inline"><st c="19711">/ch02</st></strong><st c="19716"> context root through the </st><strong class="source-inline"><st c="19742">url_prefix</st></strong><st c="19752"> parameter of </st><strong class="source-inline"><st c="19766">register_blueprint()</st></strong><st c="19786">. On the other hand, as shown from the given code, the imports to the Blueprints must be placed below the app instantiation to avoid circular </st><span class="No-Break"><st c="19928">import issues.</st></span></p>
			<p><st c="19942">Another way of building a clean Flask project is by combining the application factory design technique with the </st><span class="No-Break"><st c="20055">Blueprint approach.</st></span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/><st c="20074">Utilizing both the application factory and the Blueprint</st></h2>
			<p><st c="20131">To make the Blueprint structures </st><a id="_idIndexMarker092"/><st c="20165">flexible when managing configuration variables and more organized by utilizing the application context proxies </st><strong class="source-inline"><st c="20276">g</st></strong><st c="20277"> and </st><strong class="source-inline"><st c="20282">current_app</st></strong><st c="20293">, add an </st><strong class="source-inline"><st c="20302">__init__.py</st></strong><st c="20313"> file in the </st><strong class="source-inline"><st c="20326">modules</st></strong><st c="20333"> folder. </st><span class="No-Break"><em class="italic"><st c="20342">Figure 2</st></em></span><em class="italic"><st c="20350">.3</st></em><st c="20352"> shows the project structure of </st><strong class="source-inline"><st c="20384">ch02-blueprint-factory</st></strong><st c="20406"> with the </st><strong class="source-inline"><st c="20416">__init__.py</st></strong><st c="20427"> file in place to implement the factory </st><span class="No-Break"><st c="20467">method definition:</st></span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B19383_02_3.jpg" alt="Figure 2.3 – Flask directory with Blueprints and application factory"/><st c="20485"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="20827">Figure 2.3 – Flask directory with Blueprints and application factory</st></p>
			<p><st c="20895">The </st><strong class="source-inline"><st c="20900">create_app()</st></strong><st c="20912"> factory method can now include the import of the Blueprints and their registration to the app. </st><st c="21008">The rest of its setup is the same as the </st><strong class="source-inline"><st c="21049">ch01</st></strong><st c="21053"> project. </st><st c="21063">The following code shows its </st><span class="No-Break"><st c="21092">entire</st></span><span class="No-Break"><a id="_idIndexMarker093"/></span><span class="No-Break"><st c="21098"> implementation:</st></span></p>
			<pre class="source-code"><st c="21114">
import toml
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()
</st><strong class="bold"><st c="21209">def create_app(config_file):</st></strong><st c="21237">
    app = Flask(__name__, template_folder='../pages', static_folder='../resources')
    app.config.from_file(config_file, toml.load)
    … … … … … …
    … … … … … …
    </st><strong class="bold"><st c="21387">with app.app_context():</st></strong><strong class="bold"><st c="21410">from modules.home import home_bp</st></strong><strong class="bold"><st c="21443">from modules.login import login_bp</st></strong><strong class="bold"><st c="21478">from modules.order import order_bp</st></strong><st c="21513">
       … … … … … …
       … … … … … …
       </st><strong class="bold"><st c="21537">app.register_blueprint(home_bp, url_prefix='/ch02')</st></strong><strong class="bold"><st c="21588">app.register_blueprint(login_bp, url_prefix='/ch02')</st></strong><strong class="bold"><st c="21641">app.register_blueprint(order_bp, url_prefix='/ch02')</st></strong><st c="21694">
       … … … … … …
    return app</st></pre>			<p><st c="21716">The application factory here uses the </st><strong class="source-inline"><st c="21755">with</st></strong><st c="21759">-block to bind the application context only within the </st><span class="No-Break"><st c="21815">Blueprint components.</st></span></p>
			<p><st c="21836">Depending on the scope of the software requirements and the appropriate architecture, any of the given approaches</st><a id="_idIndexMarker094"/><st c="21950"> will be reliable and applicable in building organized, enterprise-grade Flask applications. </st><st c="22043">Adding more packages and other design patterns is possible, but the core structure emphasized in the previous discussions must remain intact to avoid </st><span class="No-Break"><st c="22193">cyclic imports.</st></span></p>
			<p><st c="22208">From project structuring, it is time to discuss the setup indicated in the application factory and </st><strong class="source-inline"><st c="22308">main.py</st></strong><st c="22315"> of the Blueprints, which is about the configuration of SQLAlchemy ORM and Flask’s </st><span class="No-Break"><st c="22398">logging mechanism.</st></span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/><st c="22416">Applying object-relational mapping (ORM)</st></h1>
			<p><st c="22457">The most used </st><strong class="bold"><st c="22472">object-relational mapping</st></strong><st c="22497"> (</st><strong class="bold"><st c="22499">ORM</st></strong><st c="22502">) that can work perfectly with the Flask framework is SQLAlchemy. </st><st c="22569">This </st><a id="_idIndexMarker095"/><st c="22574">ORM is a boilerplated interface that aims to create a database-agnostic data layer to connect to any database engine. </st><st c="22692">But compared to other ORMs, SQLAlchemy has support in optimizing native SQL statements, which makes it popular with many database administrators. </st><st c="22838">When formulating its queries, it only requires Python functions and expressions to pursue </st><span class="No-Break"><st c="22928">CRUD operations.</st></span></p>
			<p><st c="22944">Before using the ORM, the </st><strong class="source-inline"><st c="22971">flask-sqlalchemy</st></strong><st c="22987"> and </st><strong class="source-inline"><st c="22992">psycopg2-binary</st></strong><st c="23007"> extensions for the PostgreSQL database must be installed in the virtual environment using the </st><span class="No-Break"><st c="23102">following command:</st></span></p>
			<pre class="console"><st c="23120">
pip install psycopg2-binary flask-sqlalchemy</st></pre>			<p><st c="23165">What follows next is</st><a id="_idIndexMarker096"/><st c="23186"> the setup of the </st><span class="No-Break"><st c="23204">database connectivity.</st></span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/><st c="23226">Setting up the database connectivity</st></h2>
			<p><st c="23263">Now, we are ready to implement the configuration file for our database setup. </st><st c="23342">Flask 3.x supports the declarative extension of SQLAlchemy, which is the commonly used approach in implementing</st><a id="_idIndexMarker097"/><st c="23453"> SQLAlchemy ORM in most frameworks such </st><span class="No-Break"><st c="23493">as FastAPI.</st></span></p>
			<p><st c="23504">In this approach, the first step is to create the database connectivity by building the SQLAlchemy engine, which manages the connection pooling and the installed dialect. </st><st c="23676">The </st><strong class="source-inline"><st c="23680">create_engine()</st></strong><st c="23695"> function from the </st><strong class="source-inline"><st c="23714">sqlalchemy</st></strong><st c="23724"> module derives the engine object with a </st><strong class="bold"><st c="23765">database URL</st></strong><st c="23777"> (</st><strong class="bold"><st c="23779">DB URL</st></strong><st c="23785">) string as its </st><a id="_idIndexMarker098"/><st c="23802">main parameter. </st><st c="23818">This URL string contains the database name, DB API driver, account credentials, IP address of the database server, and </st><span class="No-Break"><st c="23937">its port.</st></span></p>
			<p><st c="23946">Now, the engine is required to create the session factory through the </st><strong class="source-inline"><st c="24017">sessionmaker()</st></strong><st c="24031"> method. </st><st c="24040">And this session factory becomes the essential parameter to the </st><strong class="source-inline"><st c="24104">session_scoped()</st></strong><st c="24120"> method in extracting the session registry, which provides the session to SQLAlchemy’s CRUD operations. </st><st c="24224">The following is the database configuration found in the </st><strong class="source-inline"><st c="24281">/modules/model/config.py</st></strong><st c="24305"> module of the </st><span class="No-Break"><strong class="source-inline"><st c="24320">ch02-blueprint</st></strong></span><span class="No-Break"><st c="24334"> project:</st></span></p>
			<pre class="source-code"><st c="24343">
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, scoped_session
DB_URL = "postgresql://&lt;username&gt;:&lt;password&gt;@localhost:5433/sms"
</st><strong class="bold"><st c="24558">engine = create_engine(DB_URL)</st></strong>
<strong class="bold"><st c="24588">db_session = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))</st></strong><st c="24678">
Base = declarative_base()
def init_db():
    import modules.model.db</st></pre>			<p><st c="24743">When the sessions are all set, the derivation of the base object from the </st><strong class="source-inline"><st c="24818">declarative_base()</st></strong><st c="24836"> method is </st><a id="_idIndexMarker099"/><st c="24847">the next focus for the model layer implementation. </st><st c="24898">The instance returned by this method will subclass all the SQLAlchemy entity or </st><span class="No-Break"><st c="24978">model classes.</st></span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/><st c="24992">Building the model layer</st></h2>
			<p><st c="25017">Each entity class needs to extend the </st><strong class="source-inline"><st c="25056">Base</st></strong><st c="25060"> instance to derive the necessary properties and methods in mapping the schema table to the ORM platform. </st><st c="25166">It will allow the classes to use the </st><strong class="source-inline"><st c="25203">Column</st></strong><st c="25209"> helper class to</st><a id="_idIndexMarker100"/><st c="25225"> build the properties of the actual column metadata. </st><st c="25278">There are support classes that the models can utilize such as </st><strong class="source-inline"><st c="25340">Integer</st></strong><st c="25347">, </st><strong class="source-inline"><st c="25349">String</st></strong><st c="25355">, </st><strong class="source-inline"><st c="25357">Date</st></strong><st c="25361">, and </st><strong class="source-inline"><st c="25367">DateTime</st></strong><st c="25375"> to define the data types and other constraints of the columns, and </st><strong class="source-inline"><st c="25443">ForeignKey</st></strong><st c="25453"> to establish parent-child table relationships. </st><st c="25501">The following are some model classes from the </st><strong class="source-inline"><st c="25547">/</st></strong><span class="No-Break"><strong class="source-inline"><st c="25548">modules/model/db.py</st></strong></span><span class="No-Break"><st c="25567"> module:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="25575">from sqlalchemy import Time, Column, ForeignKey, Integer, String, Float, Date, Sequence</st></strong>
<strong class="bold"><st c="25663">from sqlalchemy.orm import relationship</st></strong>
<strong class="bold"><st c="25703">from modules.model.config import Base</st></strong>
<strong class="bold"><st c="25741">class Login(Base):</st></strong><strong class="bold"><st c="25760">__tablename__ = 'login'</st></strong><st c="25784">
   id = </st><strong class="bold"><st c="25790">Column</st></strong><st c="25796">(Integer, Sequence('login_id_seq', increment=1), </st><strong class="bold"><st c="25846">primary_key = True</st></strong><st c="25864">)
   username = </st><strong class="bold"><st c="25878">Column</st></strong><st c="25884">(</st><strong class="bold"><st c="25886">String</st></strong><st c="25892">(45))
   password = </st><strong class="bold"><st c="25910">Column</st></strong><st c="25916">(</st><strong class="bold"><st c="25918">String</st></strong><st c="25924">(45))
   user_type = </st><strong class="bold"><st c="25943">Column</st></strong><st c="25949">(</st><strong class="bold"><st c="25951">Integer</st></strong><st c="25958">)
   admins = </st><strong class="bold"><st c="25970">relationship</st></strong><st c="25982">('Admin', </st><strong class="bold"><st c="25993">back_populates="login"</st></strong><st c="26015">, </st><strong class="bold"><st c="26017">uselist=False</st></strong><st c="26030">)
   customer = </st><strong class="bold"><st c="26044">relationship</st></strong><st c="26056">('Customer', </st><strong class="bold"><st c="26070">back_populates="login"</st></strong><st c="26092">, </st><strong class="bold"><st c="26094">uselist=False</st></strong><st c="26107">)
   def __init__(self, username, password, user_type, id = None):
      self.id = id
      self.username = username
      self.password = password
      self.user_type = user_type
   def __repr__(self):
        return f"&lt;Login {self.id} {self.username} {self.password} {self.user_type}&gt;"</st></pre>			<p><st c="26358">Now, the </st><strong class="source-inline"><st c="26368">relationship()</st></strong><st c="26382"> directive in the code links to model classes based on their actual reference and foreign keys. </st><st c="26478">The </st><a id="_idIndexMarker101"/><st c="26482">model class invokes the method and configures it by setting up some parameters, beginning with the name of the entity it must establish a relationship with and the backreference specification. </st><st c="26675">The </st><strong class="source-inline"><st c="26679">back_populates</st></strong><st c="26693"> parameter refers to the complementary attribute names of the related model classes, which express the rows needed to be queried based on some relationship loading technique, typically the lazy type. </st><st c="26893">Using the </st><strong class="source-inline"><st c="26903">backref</st></strong><st c="26910"> parameter instead of </st><strong class="source-inline"><st c="26932">back_populates</st></strong><st c="26946"> is also acceptable. </st><st c="26967">The following </st><strong class="source-inline"><st c="26981">Customer</st></strong><st c="26989"> model class shows its one-to-one relationship with</st><a id="_idIndexMarker102"/><st c="27040"> the </st><strong class="source-inline"><st c="27045">Login</st></strong><st c="27050"> entity model as depicted in their respective calls to the </st><span class="No-Break"><strong class="source-inline"><st c="27109">relationship()</st></strong></span><span class="No-Break"><st c="27123"> directive:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="27134">class Customer(Base):</st></strong><st c="27156">
   __tablename__ = 'customer'
   id = Column(Integer, ForeignKey('login.id'), primary_key = True)
   firstname = Column(String(45))
   lastname = Column(String(45))
   middlename = Column(String(45))
   … … … … … …
   </st><strong class="bold"><st c="27354">login = relationship('Login', back_populates="customer")</st></strong><st c="27410">
   orders = relationship('Orders', back_populates="customer")
   shippings = relationship('Shipping', back_populates="customer")
         …  … … … … …</st></pre>			<p><st c="27545">The return value of the </st><strong class="source-inline"><st c="27570">relationship()</st></strong><st c="27584"> call in </st><strong class="source-inline"><st c="27593">Login</st></strong><st c="27598"> is the scalar object of the filtered </st><strong class="source-inline"><st c="27636">Customer</st></strong><st c="27644"> record. </st><st c="27653">Likewise, the </st><strong class="source-inline"><st c="27667">Customer</st></strong><st c="27675"> model has the joined </st><strong class="source-inline"><st c="27697">Login</st></strong><st c="27702"> instance because of the directive. </st><st c="27738">On the other hand, the method can also return either a </st><strong class="source-inline"><st c="27793">List</st></strong><st c="27797"> collection or scalar value if the relationship is a </st><em class="italic"><st c="27850">one-to-many</st></em><st c="27861"> or </st><em class="italic"><st c="27865">many-to-one</st></em><st c="27876"> type. </st><st c="27883">When setting this setup in the parent model class, the </st><strong class="source-inline"><st c="27938">useList</st></strong><st c="27945"> parameter must be omitted or set to </st><strong class="source-inline"><st c="27982">True</st></strong><st c="27986"> to indicate that it will return a filtered list of records from its child class. </st><st c="28068">However, if </st><strong class="source-inline"><st c="28080">useList</st></strong><st c="28087"> is set to </st><strong class="source-inline"><st c="28098">False</st></strong><st c="28103">, the indicated relationship </st><span class="No-Break"><st c="28132">is </st></span><span class="No-Break"><em class="italic"><st c="28135">one-to-one</st></em></span><span class="No-Break"><st c="28145">.</st></span></p>
			<p><st c="28146">The following </st><strong class="source-inline"><st c="28161">Orders</st></strong><st c="28167"> class creates a </st><em class="italic"><st c="28184">many-to-one</st></em><st c="28195"> relationship with the </st><strong class="source-inline"><st c="28218">Products</st></strong><st c="28226"> and </st><strong class="source-inline"><st c="28231">Customer</st></strong><st c="28239"> models but a </st><em class="italic"><st c="28253">one-to-one</st></em><st c="28263"> relationship </st><a id="_idIndexMarker103"/><st c="28277">with the </st><span class="No-Break"><strong class="source-inline"><st c="28286">Payment</st></strong></span><span class="No-Break"><st c="28293"> model:</st></span></p>
			<pre class="source-code"><st c="28300">
class Orders(Base):
   __tablename__ = 'orders'
   id = Column(Integer, Sequence('orders_id_seq', increment=1), primary_key = True)
   pid = Column(Integer, ForeignKey('products.id'), nullable = False)
   … … … … … …
   product = relationship('Products', back_populates="orders")
   customer = relationship('Customer', back_populates="orders")
   payment = relationship('Payment', back_populates="order", uselist=False)
      … … … … … …
class Payment(Base):
   __tablename__ = 'payment'
   id = Column(Integer, Sequence('payment_id_seq', increment=1), primary_key = True)
   order_no = Column(String, ForeignKey('orders.order_no'), nullable = False)
   … … … … … …
   order = relationship('Orders', back_populates="payment")
   payment_types = relationship('PaymentType', back_populates="payment")
   shipping  = relationship('Shipping', back_populates="payment", uselist=False)</st></pre>			<p><st c="29131">The </st><strong class="source-inline"><st c="29136">main.py</st></strong><st c="29143"> module needs to call the custom method, the </st><strong class="source-inline"><st c="29188">init_db()</st></strong><st c="29197"> method found in the </st><strong class="source-inline"><st c="29218">config.py</st></strong><st c="29227"> module, to</st><a id="_idIndexMarker104"/><st c="29238"> load, and register all these model classes for the </st><span class="No-Break"><st c="29290">repository classes.</st></span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/><st c="29309">Implementing the repository layer</st></h2>
			<p><st c="29343">Each repository class</st><a id="_idIndexMarker105"/><st c="29365"> requires SQLAlchemy’s </st><strong class="source-inline"><st c="29388">Session</st></strong><st c="29395"> instance to implement its CRUD transactions. </st><st c="29441">The following </st><strong class="source-inline"><st c="29455">ProductRepository</st></strong><st c="29472"> code is a sample repository class that manages the </st><span class="No-Break"><strong class="source-inline"><st c="29524">product</st></strong></span><span class="No-Break"><st c="29531"> table:</st></span></p>
			<pre class="source-code"><st c="29538">
from typing import List, Any, Dict
from modules.model.db import Products
from main import app
</st><strong class="bold"><st c="29633">from sqlalchemy.orm import Session</st></strong><st c="29667">
class ProductRepository:
    def __init__(self, </st><strong class="bold"><st c="29712">sess:Session</st></strong><st c="29724">):
        </st><strong class="bold"><st c="29728">self.sess = sess</st></strong><st c="29744">
        app.logger.info('ProductRepository instance created')</st></pre>			<p><strong class="source-inline"><st c="29798">ProductRepository</st></strong><st c="29816">’s constructor is essential in accepting the </st><strong class="source-inline"><st c="29862">Session</st></strong><st c="29869"> instance from the view or service functions and preparing it for internal processing. </st><st c="29956">The first transaction is the </st><strong class="source-inline"><st c="29985">INSERT</st></strong><st c="29991"> product record transaction that uses the </st><strong class="source-inline"><st c="30033">add()</st></strong><st c="30038"> method of the </st><strong class="source-inline"><st c="30053">Session</st></strong><st c="30060">. SQLAlchemy always imposes transaction management in every CRUD operation. </st><st c="30136">Thus, invoking </st><strong class="source-inline"><st c="30151">commit()</st></strong><st c="30159"> of its </st><strong class="source-inline"><st c="30167">Session</st></strong><st c="30174"> object is required after successfully executing the </st><strong class="source-inline"><st c="30227">add()</st></strong><st c="30232"> method. </st><st c="30241">The following </st><strong class="source-inline"><st c="30255">insert()</st></strong><st c="30263"> method shows the correct implementation of an </st><strong class="source-inline"><st c="30310">INSERT</st></strong><st c="30316"> transaction </st><span class="No-Break"><st c="30329">in SQLAlchemy:</st></span></p>
			<pre class="source-code"><st c="30343">
    def insert(self, </st><strong class="bold"><st c="30361">prod:Products</st></strong><st c="30374">) -&gt; bool:
        try:
            </st><strong class="bold"><st c="30391">self.sess.add(prod)</st></strong><strong class="bold"><st c="30410">self.sess.commit()</st></strong><st c="30429">
            app.logger.info('ProductRepository inserted record')
            return True
        except Exception as e:
            app.logger.info(f'ProductRepository insert error: {e}')
        return False</st></pre>			<p><st c="30586">The </st><strong class="source-inline"><st c="30591">Session</st></strong><st c="30598"> object has an </st><strong class="source-inline"><st c="30613">update</st></strong><st c="30619"> method that can perform an </st><strong class="source-inline"><st c="30647">UPDATE</st></strong><st c="30653"> transaction. </st><st c="30667">The following </st><a id="_idIndexMarker106"/><st c="30681">is an </st><strong class="source-inline"><st c="30687">update()</st></strong><st c="30695"> implementation that updates a </st><strong class="source-inline"><st c="30726">product</st></strong><st c="30733"> record based on its primary </st><span class="No-Break"><st c="30762">key ID:</st></span></p>
			<pre class="source-code"><st c="30769">
    def update(self, id:int, details:Dict[str, Any]) -&gt; bool:
        try:
            </st><strong class="bold"><st c="30833">self.sess.query(Products).filter(Products.id ==</st></strong> <strong class="bold"><st c="30880">id).update(details)</st></strong><strong class="bold"><st c="30900">self.sess.commit()</st></strong><st c="30919">
            app.logger.info('ProductRepository updated record')
            return True
        except Exception as e:
            app.logger.info(f'ProductRepository update error: {e}')
        return False</st></pre>			<p><st c="31075">The </st><strong class="source-inline"><st c="31080">Session</st></strong><st c="31087"> also has a </st><strong class="source-inline"><st c="31099">delete()</st></strong><st c="31107"> method that performs record deletion based on a constraint, usually by ID. </st><st c="31183">The following is an SQLAlchemy way of deleting a </st><strong class="source-inline"><st c="31232">product</st></strong><st c="31239"> record based on </st><span class="No-Break"><st c="31256">its ID:</st></span></p>
			<pre class="source-code"><st c="31263">
    def delete(self, id:int) -&gt; bool:
        try:
           </st><strong class="bold"><st c="31303">login = self.sess.query(Products).filter(</st></strong> <strong class="bold"><st c="31344">Products.id == id).delete()</st></strong><strong class="bold"><st c="31372">self.sess.commit()</st></strong><st c="31391">
           app.logger.info('ProductRepository deleted record')
           return True
        except Exception as e:
            app.logger.info(f'ProductRepository delete error: {e}')
        return False</st></pre>			<p><st c="31547">And lastly, the </st><strong class="source-inline"><st c="31564">Session</st></strong><st c="31571"> supports a query transaction implementation through its </st><strong class="source-inline"><st c="31628">query()</st></strong><st c="31635"> method. </st><st c="31644">It can allow </st><a id="_idIndexMarker107"/><st c="31657">the filtering of records using some constraints that will result in retrieving a list or a single one. </st><st c="31760">The following snippet shows a snapshot of these </st><span class="No-Break"><st c="31808">query implementations:</st></span></p>
			<pre class="source-code"><st c="31830">
    def select_all(self) -&gt; List[Any]:
        users = self.sess.query(Products).all()
        app.logger.info('ProductRepository retrieved all record')
        return users
    def select_one(self, id:int) -&gt; Any:
        users =  self.sess.query(Products).filter( Products.id == id).one_or_none()
        app.logger.info('ProductRepository retrieved one record')
        return users
    def select_one_code(self, code:str) -&gt; Any:
        users =  self.sess.query(Products).filter( Products.code == code).one_or_none()
        app.logger.info('ProductRepository retrieved one record by product code')
        return users</st></pre>			<p><st c="32369">Since the </st><strong class="source-inline"><st c="32380">selectall()</st></strong><st c="32391"> query transaction must return a list of </st><strong class="source-inline"><st c="32432">Product</st></strong><st c="32439"> records, it needs to call the </st><strong class="source-inline"><st c="32470">all()</st></strong><st c="32475"> method of the </st><strong class="source-inline"><st c="32490">Query</st></strong><st c="32495"> object. </st><st c="32504">On the other hand, both </st><strong class="source-inline"><st c="32528">select_one()</st></strong><st c="32540"> and </st><strong class="source-inline"><st c="32545">select_one_code()</st></strong><st c="32562"> use </st><strong class="source-inline"><st c="32567">Query</st></strong><st c="32572">’s </st><strong class="source-inline"><st c="32576">one_to_many()</st></strong><st c="32589"> method because they need to return only a single </st><strong class="source-inline"><st c="32639">Product</st></strong><st c="32646"> record based on </st><strong class="source-inline"><st c="32663">select_one()</st></strong><st c="32675">’s primary key or </st><strong class="source-inline"><st c="32694">select_one_code()</st></strong><st c="32711">’s unique </st><span class="No-Break"><st c="32722">key filter.</st></span></p>
			<p><st c="32733">In the </st><strong class="source-inline"><st c="32741">ch02-blueprint</st></strong><st c="32755"> project, each Blueprint module has its repository classes placed in their respective </st><strong class="source-inline"><st c="32841">/repository</st></strong><st c="32852"> directory. </st><st c="32864">Whether these repository classes use the </st><strong class="source-inline"><st c="32905">SQLAlchemy</st></strong><st c="32915"> instance or </st><strong class="source-inline"><st c="32928">Session</st></strong><st c="32935"> of the declarative approach, Flask 3.x has no issues supporting either</st><a id="_idIndexMarker108"/><st c="33006"> of these </st><span class="No-Break"><st c="33016">repository implementations.</st></span></p>
			<p><st c="33043">Service and repository layers are among the components that require a logging mechanism to audit all the process flows occurring within these two layers. </st><st c="33198">Let us now explore how to employ software logging in Flask </st><span class="No-Break"><st c="33257">web applications.</st></span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/><st c="33274">Configuring the logging mechanism</st></h1>
			<p><st c="33308">Flask utilizes the standard logging modules of Python. </st><st c="33364">The app instance has a built-in </st><strong class="source-inline"><st c="33396">logger()</st></strong><st c="33404"> method, which is</st><a id="_idIndexMarker109"/><st c="33421"> pre-configured and can log views, repositories, services, and events. </st><st c="33492">The only problem is that this default logger cannot perform info logging because the default severity level of the configuration is </st><strong class="source-inline"><st c="33624">WARNING</st></strong><st c="33631">. By the way, turn off debug mode when running applications with a logger to avoid </st><span class="No-Break"><st c="33714">logging errors.</st></span></p>
			<p><st c="33729">The Python logging mechanism has the following </st><span class="No-Break"><st c="33777">severity levels:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="33793">Debug</st></strong><st c="33799">: This level has a </st><em class="italic"><st c="33819">severity value of 10</st></em><st c="33839"> and can provide traces of results during the </st><span class="No-Break"><st c="33885">debugging process.</st></span></li>
				<li><strong class="source-inline"><st c="33903">Info</st></strong><st c="33908">: This level has a </st><em class="italic"><st c="33928">severity value of 20</st></em><st c="33948"> and can provide general details about </st><span class="No-Break"><st c="33987">execution flows.</st></span></li>
				<li><strong class="source-inline"><st c="34003">Warning</st></strong><st c="34011">: This level has a </st><em class="italic"><st c="34031">severity value of 30</st></em><st c="34051"> and can inform about areas of the application that may cause problems in the future due to some changes in the platform or </st><span class="No-Break"><st c="34175">API classes.</st></span></li>
				<li><strong class="source-inline"><st c="34187">Error</st></strong><st c="34193">: This level has a </st><em class="italic"><st c="34213">severity value of 40</st></em><st c="34233"> and can track down executions that encountered failures in performing the </st><span class="No-Break"><st c="34308">expected features.</st></span></li>
				<li><strong class="source-inline"><st c="34326">Critical</st></strong><st c="34335">: This level </st><a id="_idIndexMarker110"/><st c="34349">has a </st><em class="italic"><st c="34355">severity value of 50</st></em><st c="34375"> and can show audits of serious issues in </st><span class="No-Break"><st c="34417">the application.</st></span></li>
			</ul>
			<p class="callout-heading"><st c="34433">Important note</st></p>
			<p class="callout"><st c="34448">The log level value or severity value provides a numerical weight on a logging level that signifies the importance of the audited log messages. </st><st c="34593">Usually, the higher the value, the more critical the priority level or log </st><span class="No-Break"><st c="34668">message is.</st></span></p>
			<p><st c="34679">The logger can only log events with a severity level greater than or equal to the severity level of its configuration. </st><st c="34799">For instance, if the logger has a severity level of </st><strong class="source-inline"><st c="34851">WARNING</st></strong><st c="34858">, it can only log transactions with warnings, errors, and critical events. </st><st c="34933">Thus, Flask requires a custom configuration of its </st><span class="No-Break"><st c="34984">logging setup.</st></span></p>
			<p><st c="34998">In all our three projects, we implemented the following ways to configure the </st><span class="No-Break"><st c="35077">Flask logger:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="35090">Approach 1</st></strong><st c="35101">: Set up the logger, handlers, and formatter programmatically using the classes from Python’s logging module, as shown in the </st><span class="No-Break"><st c="35228">following method:</st></span><pre class="source-code"><st c="35245">
def configure_func_logging(log_path):
     </st><strong class="bold"><st c="35284">logging.getLogger("werkzeug").disabled = True</st></strong><st c="35329">
     console_handler =
        logging.</st><strong class="bold"><st c="35356">StreamHandler</st></strong><st c="35370">(stream=sys.stdout)
     console_handler.</st><strong class="bold"><st c="35407">setLevel(logging.DEBUG)</st></strong><st c="35431">
     logging.basicConfig(</st><strong class="bold"><st c="35452">level=logging.DEBUG</st></strong><st c="35472">,
       format='%(asctime)s %(levelname)s %(module)s
            %(funcName)s %(message)s',
       datefmt='%Y-%m-%d %H:%M:%S',
       </st><strong class="bold"><st c="35575">handlers=[logging.handlers.RotatingFileHandler(  log_path, backupCount=3, maxBytes=1024), console_handler])</st></strong></pre></li>				<li><strong class="bold"><st c="35681">Approach 2</st></strong><st c="35692">: Set up </st><strong class="source-inline"><st c="35702">dictConfig</st></strong><st c="35712"> using the</st><a id="_idIndexMarker111"/><st c="35722"> JSON format, as shown in the </st><span class="No-Break"><st c="35752">following snippet:</st></span><pre class="source-code"><st c="35770">
def configure_logger(log_path):
           logging.config.dictConfig({
             'version': 1,
             'formatters': {
              'default': {'format': '%(asctime)s
                %(levelname)s %(module)s %(funcName)s
                %(message)s', 'datefmt': '%Y-%m-%d
                        %H:%M:%S'}
                },
            'handlers': {
              '</st><strong class="bold"><st c="35998">console</st></strong><st c="36006">': {
                </st><strong class="bold"><st c="36012">'level': 'DEBUG',</st></strong><strong class="bold"><st c="36029">'class': 'logging.StreamHandler'</st></strong><st c="36062">,
                'formatter': 'default',
                'stream': 'ext://sys.stdout'
              },
              '</st><strong class="bold"><st c="36121">file</st></strong><st c="36126">': {
                </st><strong class="bold"><st c="36132">'level': 'DEBUG'</st></strong><st c="36148">,
                </st><strong class="bold"><st c="36150">'class':</st></strong><strong class="bold"><st c="36158">'logging.handlers .RotatingFileHandler'</st></strong><st c="36198">,
                'formatter': 'default',
                'filename': log_path,
                'maxBytes': 1024,
                'backupCount': 3
              }
          },
          </st><strong class="bold"><st c="36286">'loggers'</st></strong><st c="36295">: {
            'default': {
                </st><strong class="bold"><st c="36313">'level': 'DEBUG',</st></strong><strong class="bold"><st c="36330">'handlers': ['console', 'file']</st></strong><st c="36362">
            }
        },
        </st><strong class="bold"><st c="36368">'disable_existing_loggers': False</st></strong><st c="36401">
    })</st></pre></li>			</ul>
			<p><st c="36404">In maintaining clean logs, it is always a good practice to disable all default loggers, such as the </st><strong class="source-inline"><st c="36505">werkzeug</st></strong><st c="36513"> logger. </st><st c="36522">In applying </st><em class="italic"><st c="36534">Approach 1</st></em><st c="36544">, disable the server logging by explicitly deselecting the </st><strong class="source-inline"><st c="36603">werkzeug</st></strong><st c="36611"> logger from the working loggers. </st><st c="36645">When using </st><em class="italic"><st c="36656">Approach 2</st></em><st c="36666">, on the other</st><a id="_idIndexMarker112"/><st c="36680"> hand, setting the </st><strong class="source-inline"><st c="36699">disable_existing_loggers</st></strong><st c="36723"> key to </st><strong class="source-inline"><st c="36731">False</st></strong><st c="36736"> disables the </st><strong class="source-inline"><st c="36750">werkzeug</st></strong><st c="36758"> logger and other </st><span class="No-Break"><st c="36776">unwanted ones.</st></span></p>
			<p><st c="36790">All in all, both of the given configurations produce a similar logging mechanism. </st><st c="36873">The </st><strong class="source-inline"><st c="36877">ch02-factory</st></strong><st c="36889"> project of our </st><em class="italic"><st c="36905">Online Shipping Management System</st></em><st c="36938"> applied the programmatical approach, and its </st><strong class="source-inline"><st c="36984">add_payment()</st></strong><st c="36997"> view function has the following implementation </st><span class="No-Break"><st c="37045">with logging:</st></span></p>
			<pre class="source-code"><st c="37058">
@current_app.route('/payment/add', methods = ['GET', 'POST'])
def add_payment():
    if request.method == 'POST':
        </st><strong class="bold"><st c="37169">current_app.logger.info('add_payment POST view</st></strong> <strong class="bold"><st c="37215">executed')</st></strong><st c="37226">
        repo_type = PaymentTypeRepository(db)
        ptypes = repo_type.select_all()
        orders = get_all_order_no(db)
        </st><strong class="bold"><st c="37327">repo = PaymentRepository(db)</st></strong><st c="37355">
        payment = Payment(order_no=request.form['order_no'], mode_payment=int(request.form['mode']),
            ref_no=request.form['ref_no'], date_payment=request.form['date_payment'],
            amount=request.form['amount'])
        result = repo.insert(payment)
        if result == False:
            abort(500)
        return render_template('payment/add_payment_form.html', orders=orders, ptypes=ptypes), 200
    </st><strong class="bold"><st c="37706">current_app.logger.info('add_payment GET view</st></strong> <strong class="bold"><st c="37751">executed')</st></strong><st c="37762">
    repo_type = PaymentTypeRepository(db)
    ptypes = repo_type.select_all()
    orders = get_all_order_no(db)
    return render_template('payment/add_payment_form.html', orders=orders, ptypes=ptypes), 200</st></pre>			<p><st c="37953">Regarding logging the repository layer, the following is a snapshot of </st><strong class="source-inline"><st c="38025">ShippingRepository</st></strong><st c="38043"> that</st><a id="_idIndexMarker113"/><st c="38048"> manages shipment transactions and uses logging to audit all </st><span class="No-Break"><st c="38109">these transactions:</st></span></p>
			<pre class="source-code"><st c="38128">
class ShippingRepository:
    def __init__(self, db):
        self.db = db
        </st><strong class="bold"><st c="38192">current_app.logger.info('ShippingRepository</st></strong> <strong class="bold"><st c="38235">instance created')</st></strong><st c="38254">
    def insert(self, ship:Shipping) -&gt; bool:
        try:
            self.db.session.add(ship)
            self.db.session.commit()
            </st><strong class="bold"><st c="38352">current_app.logger.info('ShippingRepository</st></strong> <strong class="bold"><st c="38395">inserted record')</st></strong><st c="38413">
            return True
        except Exception as e:
              </st><strong class="bold"><st c="38449">current_app.logger.error(f'ShippingRepository</st></strong> <strong class="bold"><st c="38494">insert error: {e}')</st></strong><st c="38514">
        return False
        … … … … … …</st></pre>			<p><st c="38539">The given </st><strong class="source-inline"><st c="38550">insert()</st></strong><st c="38558"> method of the repository uses the </st><strong class="source-inline"><st c="38593">info()</st></strong><st c="38599"> method to log the insert transactions found in the </st><strong class="source-inline"><st c="38651">try</st></strong><st c="38654"> block, while the </st><strong class="source-inline"><st c="38672">error()</st></strong><st c="38679"> method logs the </st><span class="No-Break"><strong class="source-inline"><st c="38696">exception</st></strong></span><span class="No-Break"><st c="38705"> block.</st></span></p>
			<p><st c="38712">Now, every framework has its own way of managing session data, so let us learn how Flask enables its session </st><span class="No-Break"><st c="38822">handling mechanism.</st></span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/><st c="38841">Creating user sessions</st></h1>
			<p><st c="38864">Assigning an uncompromised </st><a id="_idIndexMarker114"/><st c="38892">value to Flask’s </st><strong class="source-inline"><st c="38909">SECRET_KEY</st></strong><st c="38919"> built-in configuration variable pushes the </st><strong class="source-inline"><st c="38963">Session</st></strong><st c="38970"> context into the platform. </st><st c="38998">Here are the ways to generate the </st><span class="No-Break"><st c="39032">secret key:</st></span></p>
			<ul>
				<li><st c="39043">Apply the </st><strong class="source-inline"><st c="39054">uuid4()</st></strong><st c="39061"> method from the </st><span class="No-Break"><strong class="source-inline"><st c="39078">uuid</st></strong></span><span class="No-Break"><st c="39082"> module.</st></span></li>
				<li><st c="39090">Utilize any </st><span class="No-Break"><strong class="source-inline"><st c="39103">openssl</st></strong></span><span class="No-Break"><st c="39110"> utility.</st></span></li>
				<li><st c="39119">Use the </st><strong class="source-inline"><st c="39128">token_urlsafe()</st></strong><st c="39143"> method from the </st><span class="No-Break"><strong class="source-inline"><st c="39160">secrets</st></strong></span><span class="No-Break"><st c="39167"> module.</st></span></li>
				<li><st c="39175">Apply encryption tools such as AES, RSA, </st><span class="No-Break"><st c="39217">and SHA.</st></span></li>
			</ul>
			<p><st c="39225">Our three applications include a separate Python script that runs the </st><strong class="source-inline"><st c="39296">token_urlsafe()</st></strong><st c="39311"> method to generate a random key string with 16 random bytes for the </st><strong class="source-inline"><st c="39380">SECRET_KEY</st></strong><st c="39390"> environment variable. </st><st c="39413">The following snippet shows how our applications set the secret key with the </st><span class="No-Break"><strong class="source-inline"><st c="39490">app</st></strong></span><span class="No-Break"><st c="39493"> instance:</st></span></p>
			<pre class="source-code"><st c="39503">
(config_dev.toml)
</st><strong class="bold"><st c="39522">SECRET_KEY = "SpOn1ZyV4KE2FTlAUrWRZ_h7o5s"</st></strong><st c="39564">
(main.py)
app = Flask(__name__, template_folder='../app/pages', static_folder='../app/resources')
app.config.from_file("</st><strong class="bold"><st c="39685">config_dev.toml</st></strong><st c="39701">", toml.load)</st></pre>			<p><st c="39715">Since our application loads the </st><strong class="source-inline"><st c="39748">config_dev.toml</st></strong><st c="39763"> file using the </st><strong class="source-inline"><st c="39779">from_file()</st></strong><st c="39790"> method of the property config, adding the </st><strong class="source-inline"><st c="39833">SECRET_KEY</st></strong><st c="39843"> environment variable in TOML file with the random key string to the config file will enable the user session automatically. </st><st c="39968">Generally, it is always best practice to set a </st><strong class="source-inline"><st c="40015">SECRET_KEY</st></strong><st c="40025"> for any </st><span class="No-Break"><st c="40034">Flask applications.</st></span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/><st c="40053">Managing session data</st></h2>
			<p><st c="40075">After successfully pushing the session </st><a id="_idIndexMarker115"/><st c="40115">context, our application can readily store data in the session by using the session object imported from the </st><strong class="source-inline"><st c="40224">flask</st></strong><st c="40229"> module. </st><st c="40238">The following </st><strong class="source-inline"><st c="40252">login_db_ath()</st></strong><st c="40266"> view function stores the username in the session after a successful database validation of the </st><span class="No-Break"><st c="40362">user credentials:</st></span></p>
			<pre class="source-code"><st c="40379">
@current_app.route('/login/auth', methods=['GET', 'POST'])
def login_db_auth():
    if request.method == 'POST':
        current_app.logger.info('add_db_auth POST view executed')
        repo = LoginRepository(db)
        username = request.form['username'].strip()
        password = request.form['password'].strip()
        user:Login = repo.select_one_username(username)
        if user == None:
          flash(f'User account { request.form["username"] } does not exist.', 'error')
          return render_template('login/login.html') , 200
        elif not user.password == password:
          flash('Invalid password.', 'error')
          return render_template('login/login.html') , 200
        else:
            </st><strong class="bold"><st c="40980">session['username'] = request.form['username']</st></strong><st c="41026">
            return redirect('/menu')
    current_app.logger.info('add_db_auth GET view executed')
    return render_template('login/login.html') , 200</st></pre>			<p><st c="41157">Calling the </st><strong class="source-inline"><st c="41170">session</st></strong><st c="41177"> object with the</st><a id="_idIndexMarker116"/><st c="41193"> name of the session attribute inside the brackets (e.g., </st><strong class="source-inline"><st c="41251">session["username"]</st></strong><st c="41270">) retrieves the session data at runtime. </st><st c="41312">On the other hand, removing the session requires calling the </st><strong class="source-inline"><st c="41373">pop()</st></strong><st c="41378"> method of the session object. </st><st c="41409">For instance, removing the username requires executing the </st><span class="No-Break"><st c="41468">following code:</st></span></p>
			<pre class="source-code"><st c="41483">
session.pop("username", None)</st></pre>			<p><st c="41513">Validating the session attributes first before removing them or performing other transactions is always a </st><a id="_idIndexMarker117"/><st c="41620">recommendation, and the following snippet will show us how to validate </st><span class="No-Break"><st c="41691">session attributes:</st></span></p>
			<pre class="source-code"><st c="41710">
@app.before_request
def init_request():
    get_database()
    if (( request.endpoint != 'login_db_auth' and  request.endpoint != 'index' and request.endpoint != 'static')  and </st><strong class="bold"><st c="41878">'username' not in session</st></strong><st c="41903">):
        app.logger.info('a user is unauthenticated')
        return redirect('/login/auth')
    elif (( request.endpoint == 'login_db_auth' and  request.endpoint != 'index' and request.endpoint != 'static')  and </st><strong class="bold"><st c="42097">'username' in session</st></strong><st c="42118">):
        app.logger.info('a user is already logged in')
        return redirect('/menu')</st></pre>			<p><st c="42193">As previously discussed, the method with the </st><strong class="source-inline"><st c="42239">@before_request</st></strong><st c="42254"> decorator always executes first before any route function performs. </st><st c="42323">It processes some pre-condition transactions before the request reaches the route. </st><st c="42406">In the given snippet, </st><strong class="source-inline"><st c="42428">@before_request</st></strong><st c="42443"> executes the </st><strong class="source-inline"><st c="42457">get_database()</st></strong><st c="42471"> method and checks whether an authenticated user has already logged into the applications. </st><st c="42562">If there is a logged user, access to any endpoint, except for index and static resources, will always redirect the user to the menu page. </st><st c="42700">Otherwise, it will always redirect the user to the </st><span class="No-Break"><st c="42751">login page.</st></span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/><st c="42762">Clearing all session data</st></h2>
			<p><st c="42788">Instead of removing every session attribute, the </st><strong class="source-inline"><st c="42838">session</st></strong><st c="42845"> object has a </st><strong class="source-inline"><st c="42859">clear()</st></strong><st c="42866"> method that removes all session data in just one call. </st><st c="42922">The following is a </st><strong class="source-inline"><st c="42941">logout</st></strong><st c="42947"> route that deletes all the session</st><a id="_idIndexMarker118"/><st c="42982"> data before redirecting a user to the </st><span class="No-Break"><st c="43021">login page:</st></span></p>
			<pre class="source-code"><st c="43032">
@current_app.route('/logout', methods=['GET'])
def logout():
    </st><strong class="bold"><st c="43094">session.clear()</st></strong><st c="43109">
    current_app.logger.info('logout view executed')
    return redirect('/login/auth')</st></pre>			<p><st c="43188">There is no easy way in Flask to invalidate the session, but </st><strong class="source-inline"><st c="43250">clear()</st></strong><st c="43257"> can help prepare the session for another user to </st><span class="No-Break"><st c="43307">access it.</st></span></p>
			<p><st c="43317">Now, another component that depends much on session handling is flash messaging, which stores messages of string type on </st><span class="No-Break"><st c="43439">a session.</st></span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/><st c="43449">Applying flash messages</st></h1>
			<p><st c="43473">Flash messages are usually seen on validated forms rendering error messages for every text field with an invalid input</st><a id="_idIndexMarker119"/><st c="43592"> value. </st><st c="43600">Sometimes flash messages are headlines or important notifications printed in all caps on a </st><span class="No-Break"><st c="43691">web page.</st></span></p>
			<p><st c="43700">Flask has a flash method that any view function can import to make flash messages. </st><st c="43784">The following authentication process creates a flash message after validating the user credentials from </st><span class="No-Break"><st c="43888">the database:</st></span></p>
			<pre class="source-code"><st c="43901">
@current_app.route('/login/add', methods=['GET', 'POST'])
def add_login():
    if request.method == 'POST':
        current_app.logger.info('add_login POST view executed')
        login = Login(username=request.form['username'], password=request.form['password'], user_type=int(request.form['user_type']) )
        repo = LoginRepository(db)
        result = repo.insert(login)
        if result == True:
            </st><strong class="bold"><st c="44263">flash('Successully added a user', 'success')</st></strong><st c="44307">
        else:
            </st><strong class="bold"><st c="44314">flash(f'Error adding { request.form["username"]</st></strong> <strong class="bold"><st c="44361">}', 'error')</st></strong><st c="44374">
        return render_template('login/login_add.html') , 200
    current_app.logger.info('add_login GET view executed')
    return render_template('login/login_add.html') , 200</st></pre>			<p><st c="44535">The given </st><strong class="source-inline"><st c="44546">add_login()</st></strong><st c="44557"> view function uses </st><strong class="source-inline"><st c="44577">flash()</st></strong><st c="44584"> to create an error message if the credentials accepted by the route </st><a id="_idIndexMarker120"/><st c="44653">are already in the database. </st><st c="44682">But it also sends a notification through </st><strong class="source-inline"><st c="44723">flash()</st></strong><st c="44730"> if the </st><strong class="source-inline"><st c="44738">insert</st></strong><st c="44744"> transaction </st><span class="No-Break"><st c="44757">is successful.</st></span></p>
			<p class="callout-heading"><st c="44771">Important note</st></p>
			<p class="callout"><st c="44786">The Flask flashing system records messages to the user session at the end of every request and retrieves them on the following immediate </st><span class="No-Break"><st c="44924">request transaction.</st></span></p>
			<p><span class="No-Break"><em class="italic"><st c="44944">Figure 2</st></em></span><em class="italic"><st c="44953">.4</st></em><st c="44955"> shows a sample screen result after adding an existing username </st><span class="No-Break"><st c="45019">and password:</st></span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B19383_02_4.jpg" alt="Figure 2.4 – A flash message for an invalid insert transaction"/><st c="45032"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="45153">Figure 2.4 – A flash message for an invalid insert transaction</st></p>
			<p><st c="45215">The Jinja2 template has </st><a id="_idIndexMarker121"/><st c="45240">access to Flask’s </st><strong class="source-inline"><st c="45258">get_flashed_messages()</st></strong><st c="45280"> method that retrieves all the flash messages or just the categorized ones. </st><st c="45356">The following Jinja2 macro of the </st><strong class="source-inline"><st c="45390">/login/login_add.html</st></strong><st c="45411"> template renders the error flash message in </st><span class="No-Break"><em class="italic"><st c="45456">Figure 2</st></em></span><span class="No-Break"><em class="italic"><st c="45464">.4</st></em></span><span class="No-Break"><st c="45466">:</st></span></p>
			<pre class="source-code"><st c="45468">
{% macro render_error_flash(class_id) %}
    </st><strong class="bold"><st c="45510">{% with errors =</st></strong> <strong class="bold"><st c="45526">get_flashed_messages(category_filter=["error"]) %}</st></strong><st c="45577">
        {% if errors %}
            &lt;p id="{{class_id}}" class="w-lg-50"&gt;
            {% for msg in errors %}
                {{ msg }}
            {% endfor %}
            &lt;/p&gt;
        {% endif %}
    {% endwith %}
{% endmacro %}</st></pre>			<p><st c="45724">The </st><strong class="source-inline"><st c="45729">with</st></strong><st c="45733">-block provides the context for checking whether there are error-typed flash messages that need rendering. </st><st c="45841">If there are, a </st><strong class="source-inline"><st c="45857">for</st></strong><st c="45860">-block will retrieve all these retrieved </st><span class="No-Break"><st c="45902">flash messages.</st></span></p>
			<p><st c="45917">On the other hand, Jinja2 </st><a id="_idIndexMarker122"/><st c="45944">can also retrieve uncategorized or generic flash messages from the view functions. </st><st c="46027">The following macro retrieves a flash message from the </st><span class="No-Break"><strong class="source-inline"><st c="46082">list_login()</st></strong></span><span class="No-Break"><st c="46094"> route:</st></span></p>
			<pre class="source-code"><st c="46101">
{%macro render_list_flash()%}
</st><strong class="bold"><st c="46132">    {% with messages = get_flashed_messages() %}</st></strong><st c="46176">
        {% if messages %}
            &lt;h1 class="display-4 "&gt;
                {% for message in messages %}
                    {{ message }}
                {% endfor %}
            &lt;/h1&gt;
        {% endif %}
    {% endwith %}
{%endmacro%}</st></pre>			<p><st c="46320">Given the use of macros in rendering flash messages, let us explore other advanced features of Jinja2 templates of our applications that can provide better </st><span class="No-Break"><st c="46477">template implementation.</st></span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor063"/><st c="46501">Utilizing some advanced Jinja2 features</st></h1>
			<p><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="46541">Chapter 1</st></em></span></a><st c="46551"> introduced the Jinja2 engine and </st><a id="_idIndexMarker123"/><st c="46585">templating, and some of these Jinja constructs were applied to render </st><span class="No-Break"><st c="46655">HTML contents:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="46669">{{ variable }}</st></strong><st c="46684">: The placeholder expression that renders a single-valued object from </st><span class="No-Break"><st c="46755">view functions.</st></span></li>
				<li><strong class="source-inline"><st c="46770">{% statement %</st></strong><st c="46785">}: The expression that implements </st><strong class="source-inline"><st c="46820">if</st></strong><st c="46822">-</st><strong class="source-inline"><st c="46824">else</st></strong><st c="46828">-conditions, </st><strong class="source-inline"><st c="46842">for</st></strong><st c="46845">-loops, </st><strong class="source-inline"><st c="46854">block</st></strong><st c="46859">-expressions </st><a id="_idIndexMarker124"/><st c="46873">for calling layout fragments, </st><strong class="source-inline"><st c="46903">with</st></strong><st c="46907">-blocks for managing context, and </st><span class="No-Break"><st c="46942">macro calls.</st></span></li>
			</ul>
			<p><st c="46954">But some Jinja2 features, such as applying the </st><strong class="source-inline"><st c="47002">with</st></strong><st c="47006">-statement, macros, filters, and comments, can help generate better views for </st><span class="No-Break"><st c="47085">our routes.</st></span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/><st c="47096">Applying with-blocks and macros</st></h2>
			<p><st c="47128">In the </st><em class="italic"><st c="47136">Applying flash messages</st></em><st c="47159"> section, templates used the </st><strong class="source-inline"><st c="47188">{% with %}</st></strong><st c="47198"> statement to extract the flash messages from the view</st><a id="_idIndexMarker125"/><st c="47252"> functions and </st><strong class="source-inline"><st c="47267">{% macro %}</st></strong><st c="47278"> in optimizing our Jinja2 transactions. </st><st c="47318">The </st><strong class="source-inline"><st c="47322">{% with %}</st></strong><st c="47332"> statement sets a context to limit the access or scope of some variables within the </st><strong class="source-inline"><st c="47416">with</st></strong><st c="47420">-block. </st><st c="47429">Access outside the block produces a </st><span class="No-Break"><st c="47465">Jinja2 error.</st></span></p>
			<p><st c="47478">The </st><strong class="source-inline"><st c="47483">{% macro %}</st></strong><st c="47494"> block, on the other hand, pursues modular programming in Jinja2 templating. </st><st c="47571">Every macro has a name and can have local parameters for reusability, and any templates can import and call them like typical methods. </st><st c="47706">The following </st><strong class="source-inline"><st c="47720">/login/login_list.html</st></strong><st c="47742"> template renders the list of user credentials with a call on a macro that outputs an uncategorized </st><span class="No-Break"><st c="47842">flash message:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="47856">{% from "macros/flask_segment.html" import</st></strong> <strong class="bold"><st c="47899">render_list_flash with context</st></strong><st c="47930"> %}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;List Login Accounts&lt;/title&gt;
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css')}}"&gt;
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.min.css')}}"&gt;
        &lt;script src="{{ url_for('static', filename='js/jquery-3.6.4.js') }}"&gt;&lt;/script&gt;
        &lt;script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;section class="position-relative py-4 py-xl-5"&gt;
            &lt;div class="container position-relative"&gt;
                &lt;div class="row d-flex"&gt;
                    &lt;div class="col-md-8 col-xl-6 text-center mx-auto"&gt;
                        </st><strong class="bold"><st c="48527">{{render_list_flash()}}</st></strong><st c="48550">
                       … … … … … …
                     &lt;/div&gt;
                &lt;/div&gt;
                … … … … … …
        &lt;/section&gt;
    &lt;/body&gt;
&lt;/html&gt;</st></pre>			<p><st c="48614">All macros are placed in a </st><a id="_idIndexMarker126"/><st c="48642">template file, like any Jinja2 expressions. </st><st c="48686">In our application, the macros are found in </st><strong class="source-inline"><st c="48730">/macros/flask_segment.html</st></strong><st c="48756">, and any template must import them from this file using the </st><strong class="source-inline"><st c="48817">{% from ...  </st><st c="48829">import ... </st><st c="48840">with context %}</st></strong><st c="48855"> statement before utilizing them. </st><st c="48889">In the given template, </st><strong class="source-inline"><st c="48912">render_list_flash()</st></strong><st c="48931"> is imported first before calling it like a method using the </st><strong class="source-inline"><st c="48992">{{}}</st></strong> <span class="No-Break"><st c="48996">placeholder expression.</st></span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/><st c="49020">Applying filters</st></h2>
			<p><st c="49037">To improve the look and feel and clarity of the rendered data, Jinja2 has several filter operations that can provide additional </st><a id="_idIndexMarker127"/><st c="49166">aesthetics that can make the rendition more appealing to the users. </st><st c="49234">This </st><a id="_idIndexMarker128"/><st c="49239">process is called </st><strong class="bold"><st c="49257">piping</st></strong><st c="49263"> because we use the pipe symbol (</st><strong class="source-inline"><st c="49296">|</st></strong><st c="49298">) to pass the value to these operations. </st><st c="49339">The following </st><strong class="source-inline"><st c="49353">product/list_product.html</st></strong><st c="49378"> page uses filter methods in rendering the list </st><span class="No-Break"><st c="49426">of products:</st></span></p>
			<pre class="source-code"><st c="49438">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;List of Products&lt;/title&gt;
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css')}}"&gt;
        &lt;link rel="stylesheet" href="{{ url_for('static', filename='css/bootstrap.min.css')}}"&gt;
        &lt;script src="{{ url_for('static', filename='js/jquery-3.6.4.js') }}"&gt;&lt;/script&gt;
        &lt;script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table&gt;
        {% for p in prods %}
            &lt;tr&gt;
                &lt;td&gt;{{p.id}}&lt;/td&gt;
                &lt;td&gt;{{p.name|</st><strong class="bold"><st c="49926">trim</st></strong><st c="49931">|</st><strong class="bold"><st c="49933">upper</st></strong><st c="49938">}}&lt;/td&gt;
                &lt;td&gt;{</st><strong class="bold"><st c="49952">{"\u20B1%.2f"|format(</st></strong><st c="49974">p.price</st><strong class="bold"><st c="49982">)</st></strong><st c="49984"> }}&lt;/td&gt;
                &lt;td&gt;{{p.code}}&lt;/td&gt;
            &lt;/tr&gt;
        {% endfor %}
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</st></pre>			<p><st c="50056">The given template uses the trim filter to strip the name data with leading and trailing whitespaces and an upper filter to convert the names to uppercase. </st><st c="50213">Through the format filter, all the price data now </st><a id="_idIndexMarker129"/><st c="50263">includes a Philippine peso currency sign with two decimal places. </st><st c="50329">Jinja2 supports several built-in filters that can help derive other features from, compute, manipulate, modify, compress, expand, and sanitize the raw data from the view functions to render all these details in a more </st><span class="No-Break"><st c="50547">presentable outcome.</st></span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/><st c="50567">Adding comments</st></h2>
			<p><st c="50583">It is always best practice to add comments in every template using the </st><strong class="source-inline"><st c="50655">{# comment #}</st></strong><st c="50668"> expression for sectioning and internal documentation purposes. </st><st c="50732">These comments are not part of the rendition </st><a id="_idIndexMarker130"/><st c="50777">provided by the Jinja2 </st><span class="No-Break"><st c="50800">template engine.</st></span></p>
			<p><st c="50816">Jinja2 expressions are not only applied to route views but also to error pages. </st><st c="50897">Let us now learn how to render error pages in the Flask </st><span class="No-Break"><st c="50953">3.x framework.</st></span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/><st c="50967">Implementing error-handling solutions</st></h1>
			<p><a href="B19383_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="51005">Chapter 1</st></em></span></a><st c="51015"> showcased the use of the </st><strong class="source-inline"><st c="51041">redirect()</st></strong><st c="51051"> method in rendering error pages given a status code, such as the status code </st><strong class="source-inline"><st c="51129">500</st></strong><st c="51132">. We will now discuss a better way of managing exceptions</st><a id="_idIndexMarker131"/><st c="51189"> and status codes, including triggering error pages per </st><span class="No-Break"><st c="51245">status code.</st></span></p>
			<p><st c="51257">Flask applications must always implement an error-handling mechanism using any of the </st><span class="No-Break"><st c="51344">following strategies:</st></span></p>
			<ul>
				<li><st c="51365">Registers a custom error function using the app’s </st><span class="No-Break"><strong class="source-inline"><st c="51416">register_error_handler()</st></strong></span><span class="No-Break"><st c="51440"> method.</st></span></li>
				<li><st c="51448">Creates an error handler using the app’s </st><span class="No-Break"><strong class="source-inline"><st c="51490">errorhandler</st></strong></span><span class="No-Break"><st c="51502"> decorator.</st></span></li>
				<li><st c="51513">Throws a </st><a id="_idIndexMarker132"/><st c="51523">custom </st><span class="No-Break"><strong class="source-inline"><st c="51530">Exception</st></strong></span><span class="No-Break"><st c="51539"> class.</st></span></li>
			</ul>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/><st c="51546">Using the register_error_handler method</st></h2>
			<p><st c="51586">The declarative way to implement an </st><a id="_idIndexMarker133"/><st c="51623">error handler is to create a custom function </st><a id="_idIndexMarker134"/><st c="51668">and register it to the </st><strong class="source-inline"><st c="51691">app</st></strong><st c="51694">’s </st><strong class="source-inline"><st c="51698">register_error_handler()</st></strong><st c="51722"> method. </st><st c="51731">The custom function must have a single local parameter that will accept the injected error message from the platform. </st><st c="51849">It must also return its assigned error page using the </st><strong class="source-inline"><st c="51903">make_response()</st></strong><st c="51918"> and </st><strong class="source-inline"><st c="51923">render_template()</st></strong><st c="51940"> methods with the option of passing the error message as context data to the template for rendering. </st><st c="52041">The following is a snippet that shows </st><span class="No-Break"><st c="52079">the steps:</st></span></p>
			<pre class="source-code"><st c="52089">
def server_error(</st><strong class="bold"><st c="52107">e</st></strong><st c="52109">):
    print(e)
    return make_response(render_template("error/500.html", title="Internal server error"), 500)
app.</st><strong class="bold"><st c="52217">register_error_handler</st></strong><st c="52240">(500, server_error)</st></pre>			<p><st c="52260">The </st><strong class="source-inline"><st c="52265">register_error_handler()</st></strong><st c="52289"> method has </st><span class="No-Break"><st c="52301">two parameters:</st></span></p>
			<ul>
				<li><st c="52316">The status code that will trigger the </st><span class="No-Break"><st c="52355">error handling.</st></span></li>
				<li><st c="52370">The function name of the custom </st><span class="No-Break"><st c="52403">error handler.</st></span></li>
			</ul>
			<p><st c="52417">There should only be one registered custom error handler per </st><span class="No-Break"><st c="52479">status code.</st></span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/><st c="52491">Applying the @errorhandler decorator</st></h2>
			<p><st c="52528">The easiest way to</st><a id="_idIndexMarker135"/><st c="52547"> implement error handlers is to</st><a id="_idIndexMarker136"/><st c="52578"> decorate customer error handlers with the app’s </st><strong class="source-inline"><st c="52627">errorhandler()</st></strong><st c="52641"> decorator. </st><st c="52653">The structure and behavior of the custom method are the same as the previous approach except that it has an </st><strong class="source-inline"><st c="52761">errorhandler</st></strong><st c="52773"> decorator with the assigned status code. </st><st c="52815">The following shows the error handlers implemented</st><a id="_idIndexMarker137"/><st c="52865"> using </st><span class="No-Break"><st c="52872">the decorator:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="52886">@app.errorhandler(404)</st></strong><st c="52909">
def not_found(e):
    return make_response(render_template("error/404.html", title="Page not found"), 404)
</st><strong class="bold"><st c="53013">@app.errorhandler(400)</st></strong><st c="53035">
def bad_request(e):
    return make_response(render_template("error/400.html", title="Bad request"), 400)</st></pre>			<p><st c="53137">Accessing an invalid URL path </st><a id="_idIndexMarker138"/><st c="53168">will auto-render the error page in </st><span class="No-Break"><em class="italic"><st c="53203">Figure 2</st></em></span><em class="italic"><st c="53211">.5</st></em><st c="53213"> because of the given error handler for HTTP status </st><span class="No-Break"><st c="53265">code </st></span><span class="No-Break"><strong class="source-inline"><st c="53270">404</st></strong></span><span class="No-Break"><st c="53273">:</st></span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B19383_02_5.jpg" alt="Figure 2.5 – An error page rendered by the not_found() error handler"/><st c="53275"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="53321">Figure 2.5 – An error page rendered by the not_found() error handler</st></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/><st c="53389">Creating custom exceptions</st></h2>
			<p><st c="53416">Another wise approach is</st><a id="_idIndexMarker139"/><st c="53441"> assigning custom exceptions to error handlers. </st><st c="53489">First, create a custom exception by subclassing </st><strong class="source-inline"><st c="53537">HttpException</st></strong><st c="53550"> from the </st><strong class="source-inline"><st c="53560">werkzeug.exceptions</st></strong><st c="53579"> module. </st><st c="53588">The following shows how to create</st><a id="_idIndexMarker140"/><st c="53621"> custom exceptions for </st><span class="No-Break"><st c="53644">Flask transactions:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="53663">from werkzeug.exceptions import HTTPException</st></strong><st c="53709">
from flask import render_template, Response
class DuplicateRecordException(HTTPException):
    code = 500
    description = 'Record already exists.'
    </st><st c="53851">def get_response(self, environ=None):
        resp = Response()
        resp.response = render_template('error/generic.html',
             ex_message=self.description)
        return resp</st></pre>			<p><st c="54001">View functions and repository methods can throw this custom </st><strong class="source-inline"><st c="54062">DuplicateRecordException</st></strong><st c="54086"> class when an </st><strong class="source-inline"><st c="54101">INSERT</st></strong><st c="54107"> record transaction encounters a primary or unique key duplicate error. </st><st c="54179">It requires setting the two inherited fields from the parent </st><strong class="source-inline"><st c="54240">HTTPException</st></strong><st c="54253"> class, namely the </st><strong class="source-inline"><st c="54272">code</st></strong><st c="54276"> and </st><strong class="source-inline"><st c="54281">description</st></strong><st c="54292"> fields. </st><st c="54301">Once triggered, the exception class can auto-render its error page when it has an overridden </st><strong class="source-inline"><st c="54394">get_response()</st></strong><st c="54408"> method that creates a custom </st><strong class="source-inline"><st c="54438">Response</st></strong><st c="54446"> object to make way for the rendering of its error page with the </st><span class="No-Break"><st c="54511">exception message.</st></span></p>
			<p><st c="54529">But overriding the </st><strong class="source-inline"><st c="54549">get_response()</st></strong><st c="54563"> instance method of the custom exception is just an option. </st><st c="54623">Sometimes, assigning values to the code and description fields is enough, and then we map them to a custom error handler for the rendition of its error page, either through the </st><strong class="source-inline"><st c="54800">@errorhandler</st></strong><st c="54813"> decorator or </st><strong class="source-inline"><st c="54827">register_error_handler()</st></strong><st c="54851">. The following code shows this kind </st><span class="No-Break"><st c="54888">of approach:</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="54900">@app.errorhandler(DuplicateRecordException)</st></strong><st c="54944">
def insert_record_exception(</st><strong class="bold"><st c="54973">e</st></strong><st c="54975">):
    </st><strong class="bold"><st c="54978">return e.get_response()</st></strong></pre>			<p><st c="55001">When the raise command triggers the custom </st><strong class="source-inline"><st c="55045">DuplicateRecordException</st></strong><st c="55069"> class, the event handler will return its overridden </st><strong class="source-inline"><st c="55122">get_response()</st></strong><st c="55136"> method with the mapped Jinja2 error page </st><a id="_idIndexMarker141"/><st c="55178">and the HTTP status code </st><strong class="source-inline"><st c="55203">500</st></strong><st c="55206">. But how about if the exception triggered is a </st><a id="_idIndexMarker142"/><span class="No-Break"><st c="55254">Python-based type?</st></span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/><st c="55272">Managing built-in exceptions</st></h2>
			<p><st c="55301">All the handlers previously </st><a id="_idIndexMarker143"/><st c="55330">presented manage only the Flask exceptions, not the Python-specific exceptions. </st><st c="55410">To include handling of those exceptions</st><a id="_idIndexMarker144"/><st c="55449"> generated by some Python runtime issues, create a dedicated custom method handler that listens to all these exceptions, such as in the </st><span class="No-Break"><st c="55585">following implementation:</st></span></p>
			<pre class="source-code"><st c="55610">
from werkzeug.exceptions import HTTPException
</st><strong class="bold"><st c="55657">@app.errorhandler(Exception)</st></strong><st c="55685">
def handle_built_exception(e):
    if isinstance(e, HTTPException):
        return e
    </st><strong class="bold"><st c="55759">return render_template("error/generic.html",</st></strong> <strong class="bold"><st c="55803">title="Internal server error", e=e), 500</st></strong></pre>			<p><st c="55844">The given error handler filters out all Flask-related exceptions and throws them for Flask handlers to process, but it renders a custom error page for any Python </st><span class="No-Break"><st c="56007">runtime exception.</st></span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/><st c="56025">Triggering the error handlers</st></h2>
			<p><st c="56055">Sometimes it is recommended to explicitly trigger the error handler, especially in projects that utilize Blueprints as</st><a id="_idIndexMarker145"/><st c="56174"> building blocks of their</st><a id="_idIndexMarker146"/><st c="56199"> applications. </st><st c="56214">A Blueprint module is not an independent sub-application that can own a URL context that listens to and calls the precise error handlers directly. </st><st c="56361">So, to avoid some problems in calling the exact error handlers, transactions can invoke the </st><strong class="source-inline"><st c="56453">abort()</st></strong><st c="56460"> method with the proper HTTP status code, such as in the </st><span class="No-Break"><st c="56517">following snippet:</st></span></p>
			<pre class="source-code"><st c="56535">
@current_app.route('/payment/add', methods = ['GET', 'POST'])
def add_payment():
    if request.method == 'POST':
        current_app.logger.info('add_payment POST view executed')
        … … … … … …
        result = repo.insert(payment)
        if result == False:
            </st><strong class="bold"><st c="56766">abort(500)</st></strong><st c="56776">
        return render_template('payment/add_payment_form.html', orders=orders, ptypes=ptypes), 200
    current_app.logger.info('add_payment GET view executed')
    … … … … … …
    return render_template('payment/add_payment_form.html', orders=orders, ptypes=ptypes), 200</st></pre>			<p><st c="57027">For custom or built-in exceptions, transactions can call the </st><strong class="source-inline"><st c="57089">raise()</st></strong><st c="57096"> method to trigger the error handler for the raised exception. </st><st c="57159">The following view function raises the </st><strong class="source-inline"><st c="57198">DuplicateRecordException</st></strong><st c="57222"> class when an issue arises during order </st><span class="No-Break"><st c="57263">record insertion:</st></span></p>
			<pre class="source-code"><st c="57280">
@current_app.route('/orders/add', methods=['GET', 'POST'])
def add_order():
    if request.method == 'POST':
        current_app.logger.info('add_order POST view executed')
        repo = OrderRepository(db)
        … … … … … …
        result = repo.insert(order)
        if result == False:
            </st><strong class="bold"><st c="57529">raise DatabaseException()</st></strong><st c="57554">
        customers = get_all_cid(db)
        products = get_all_pid(db)
        return render_template('order/add_order_form.html', customers=customers, products=products), 200
    current_app.logger.info('add_order GET view executed')
    customers = get_all_cid(db)
    products = get_all_pid(db)
    return render_template('order/add_order_form.html', customers=customers, products=products), 200</st></pre>			<p><st c="57913">All the generic error </st><a id="_idIndexMarker147"/><st c="57936">handlers are placed in the </st><strong class="source-inline"><st c="57963">main.py</st></strong><st c="57970"> module, while the custom and component-specific exception classes are in separate </st><a id="_idIndexMarker148"/><st c="58053">modules outside of the Blueprints for coding standard purposes and </st><span class="No-Break"><st c="58120">easy debugging.</st></span></p>
			<p><st c="58135">Now, error pages and the rest of the Jinja2 templates can also use </st><em class="italic"><st c="58203">CSS</st></em><st c="58206">, </st><em class="italic"><st c="58208">JavaScript</st></em><st c="58218">, </st><em class="italic"><st c="58220">images</st></em><st c="58226">, and other static resources to add look-and-feel features to </st><span class="No-Break"><st c="58288">their content.</st></span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/><st c="58302">Adding static resources</st></h1>
			<p><st c="58326">Static resources provide the user experience for Flask web applications. </st><st c="58400">These static resources include the needed CSS, JavaScript, images, and video files to be used by some template pages. </st><st c="58518">Now, Flask</st><a id="_idIndexMarker149"/><st c="58528"> does not allow adding these files anywhere in the project. </st><st c="58588">Generally, the Flask constructor has a </st><strong class="source-inline"><st c="58627">static_folder</st></strong><st c="58640"> parameter that accepts a relative path of a dedicated directory for </st><span class="No-Break"><st c="58709">these files.</st></span></p>
			<p><st c="58721">In </st><strong class="source-inline"><st c="58725">ch02-factory</st></strong><st c="58737">, </st><strong class="source-inline"><st c="58739">create_app()</st></strong><st c="58751"> configures the Flask instance to allow placing the resources in the </st><strong class="source-inline"><st c="58820">/resources</st></strong><st c="58830"> folder of the main project directory. </st><st c="58869">The following snippet of </st><strong class="source-inline"><st c="58894">create_app()</st></strong><st c="58906"> shows the Flask instantiation with the </st><strong class="source-inline"><st c="58946">resource</st></strong> <span class="No-Break"><st c="58954">folder setup:</st></span></p>
			<pre class="source-code"><st c="58968">
def create_app(config_file):
    app = Flask(__name__, template_folder='../app/pages',
                   </st><strong class="bold"><st c="59052">static_folder='../app/resources'</st></strong><st c="59084">)
    app.config.from_file(config_file, toml.load)
    db.init_app(app)
    configure_func_logging('log_msg.txt')
    … … … … … …</st></pre>			<p><st c="59198">Meanwhile, in the </st><strong class="source-inline"><st c="59217">ch02-blueprint</st></strong><st c="59231"> project, the main project and its Blueprints can have their respective </st><strong class="source-inline"><st c="59303">/resources</st></strong><st c="59313"> directory. </st><st c="59325">The following snippet shows a Blueprint configuration with its own </st><strong class="source-inline"><st c="59392">resources</st></strong> <span class="No-Break"><st c="59401">folder setup:</st></span></p>
			<pre class="source-code"><st c="59415">
shipping_bp = Blueprint('shipping_bp', __name__,
    template_folder='pages',
    </st><strong class="bold"><st c="59490">static_folder='resources'</st></strong><st c="59515">, static_url_path='static')</st></pre>			<p><span class="No-Break"><em class="italic"><st c="59542">Figure 2</st></em></span><em class="italic"><st c="59551">.6</st></em><st c="59553"> shows the location and the content of the </st><strong class="source-inline"><st c="59596">/resources</st></strong><st c="59606"> folder of the main application, while </st><span class="No-Break"><em class="italic"><st c="59645">Figure 2</st></em></span><em class="italic"><st c="59653">.7</st></em><st c="59655"> shows the </st><strong class="source-inline"><st c="59666">/resources</st></strong><st c="59676"> folder of the shipping </st><span class="No-Break"><st c="59700">Blueprint package:</st></span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B19383_02_6.jpg" alt="Figure 2.6 – The location of /resources in the main application"/><st c="59718"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="59837">Figure 2.6 – The location of /resources in the main application</st></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B19383_02_7.jpg" alt="Figure 2.7 – The location of /resources in the shipping Blueprint"/><st c="59900"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="59985">Figure 2.7 – The location of /resources in the shipping Blueprint</st></p>
			<p><st c="60050">The </st><strong class="source-inline"><st c="60055">static</st></strong><st c="60061"> directory is the default and common folder name used to contain the Flask application’s web assets. </st><st c="60162">But in the </st><a id="_idIndexMarker150"/><st c="60173">succeeding chapters, we will use </st><strong class="source-inline"><st c="60206">/resources</st></strong><st c="60216"> instead of </st><strong class="source-inline"><st c="60228">/static</st></strong><st c="60235"> for naming </st><span class="No-Break"><st c="60247">convention purposes.</st></span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/><st c="60267">Accessing the assets in the templates</st></h2>
			<p><st c="60305">To avoid accessing relative paths, Flask manages, accesses, and loads static files or web assets in template pages using </st><strong class="source-inline"><st c="60427">static_url_path</st></strong><st c="60442">, a logical path name used to access web resources from</st><a id="_idIndexMarker151"/><st c="60497"> the </st><strong class="source-inline"><st c="60502">static</st></strong><st c="60508"> folder. </st><st c="60517">Its default path </st><a id="_idIndexMarker152"/><st c="60534">value is </st><strong class="source-inline"><st c="60543">static</st></strong><st c="60549">, but applications can set an appropriate value </st><span class="No-Break"><st c="60597">if needed.</st></span></p>
			<p><st c="60607">Our application uses the Bootstrap 4 framework to apply responsive web design. </st><st c="60687">All its assets are in the </st><strong class="source-inline"><st c="60713">/resources</st></strong><st c="60723"> folder, and the following </st><strong class="source-inline"><st c="60750">menu.html</st></strong><st c="60759"> template shows how to access these assets from </st><span class="No-Break"><st c="60807">the folder:</st></span></p>
			<pre class="source-code"><st c="60818">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;Main Menu&lt;/title&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"&gt;
        &lt;link rel="stylesheet" href="</st><strong class="bold"><st c="61002">{{ url_for('static', filename='css/styles.css')}}</st></strong><st c="61052">"&gt;
        &lt;link rel="stylesheet" href="</st><strong class="bold"><st c="61085">{{ url_for('static', filename='css/bootstrap.min.css')}}</st></strong><st c="61142">"&gt;
        &lt;script src="</st><strong class="bold"><st c="61159">{{ url_for('static', filename='js/jquery-3.6.4.js') }}</st></strong><st c="61214">"&gt;&lt;/script&gt;
        &lt;script src="</st><strong class="bold"><st c="61240">{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}</st></strong><st c="61303">"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="container py-4 py-xl-5"&gt;
            &lt;div class="row mb-5"&gt;
                &lt;div class="col-md-8 col-xl-6 text-center mx-auto"&gt;
                    &lt;h2 class="display-4"&gt;Supply Management System Menu&lt;/h2&gt;
                    &lt;p class="w-lg-50"&gt;&lt;strong&gt;&lt;em&gt;{{ session['username']}}&lt;/em&gt;&lt;/strong&gt; is logged in.&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="row row-cols-1 row-cols-md-2 row-cols-xl-3"&gt;
                &lt;div class="col"&gt;
                    &lt;div class="d-flex p-3"&gt;
                        &lt;div class="px-2"&gt;
                            &lt;h5 class="mb-0 mt-1"&gt;&lt;a href="#"&gt;Add Delivery Officer&lt;/a&gt;&lt;/h5&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="col"&gt;
                    &lt;div class="d-flex p-3"&gt;
             … … … … … …
    &lt;/body&gt;
&lt;/html&gt;</st></pre>			<p><st c="61876">The </st><strong class="source-inline"><st c="61881">url_for()</st></strong><st c="61890"> function, used to</st><a id="_idIndexMarker153"/><st c="61908"> access view endpoints in the </st><a id="_idIndexMarker154"/><st c="61938">templates, is the way to access the static resources from the </st><strong class="source-inline"><st c="62000">/resources</st></strong><st c="62010"> folder using </st><strong class="source-inline"><st c="62024">static_url_path</st></strong><st c="62039"> as the</st><a id="_idIndexMarker155"/> <span class="No-Break"><st c="62046">directory name.</st></span></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/><st c="62062">Summary</st></h1>
			<p><st c="62070">This chapter provided information on additional features of Flask that can support building complete, enterprise-grade, scalable, and complex but manageable Flask web applications. </st><st c="62252">The details about adding error handling in many ways, integrating the Bootstrap framework to the application without using extensions, implementing SQLAlchemy using the declarative and standard approaches, and optimizing the Jinja2 templates using macros, indicate that the Flask framework is a lightweight but powerful solution to building </st><span class="No-Break"><st c="62593">web applications.</st></span></p>
			<p><st c="62610">After learning about creating full-blown web applications with Flask, let us discuss and highlight, in the next chapter, the components and procedures for building API-based applications using the Flask </st><span class="No-Break"><st c="62814">3.x framework.</st></span></p>
		</div>
	<div id="charCountTotal" value="62828"/></body></html>