<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating the Virtual Two-Wheeled ROS Robot</h1>
                
            
            
                
<p>RViz is a 3D visualization tool that can display robot models. It provides a configurable <strong>Graphical User Interface</strong> (<strong>GUI</strong>) that allows the user to display any information they may request for the task being carrying out. RViz can be used for both robot visualization and for debugging specific features while building the <strong>Unified Robot Description Format</strong> (<strong>URDF</strong>) model. This format uses XML to simulate the robot.</p>
<p>To illustrate how to use RViz and URDF, in this chapter, you will build a simple two-wheeled robot, which is the digital twin of GoPiGo3. You will create the URDF file that describes the robot's main components. This file acts as the input for visualization in several ROS tools – not only RViz, but also the Gazebo simulation tool, which also includes a physics engine. Gazebo will be covered in the next chapter, while in this one, you will concentrate your efforts on getting familiar with RViz.</p>
<p>This chapter will teach you how to understand the syntax of URDF files and acquire the skills you'll need in order to systematically test/check features with RViz while building the robot model.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Getting started with RViz for robot visualization</li>
<li>Building a differential drive robot with URDF</li>
<li>Inspecting the GoPiGo3 model in ROS with RViz</li>
<li>Robot frames of reference in the URDF model</li>
<li>Using RViz to check results while building</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>In the previous chapter, you were told how to clone this book's code repository so that it's in the home folder of your laptop. If you didn't do this, from a Terminal on your laptop, clone the repository into your home folder like so:</p>
<pre><strong>$ cd ~</strong><br/><strong>$ git clone https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming</strong> </pre>
<p>Next, only copy the code for this chapter into the ROS workspace. This way, you will have a cleaner ROS environment:</p>
<pre><strong>$ cp -R ~/Hands-On-ROS-for-Robotics-Programming/Chapter4_RViz_basics ~/catkin_ws/src/</strong></pre>
<p>Move to the path of the new files and check that the files are present:</p>
<pre><strong>$ cd ~/catkin_ws/src/Chapter4_RViz_basics</strong><br/><strong>$ ls -la</strong></pre>
<p>This chapter contains a new ROS package named <kbd>rviz_basics</kbd>, so rebuild the workspace so that it is known to your ROS environment:</p>
<pre><strong>$ cd ~/catkin_ws</strong><br/><strong>$ catkin_make</strong></pre>
<p>Check that the package is installing correctly by selecting it and listing its files:</p>
<pre><strong>$ roscd rviz_basics</strong><br/><strong>$ ls -la</strong></pre>
<p>Now, you are ready to complete this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started with RViz for robot visualization</h1>
                
            
            
                
<p>RViz provides a configurable GUI so that you can display specific information about the robot.</p>
<p>To make sure RViz loads a default configuration, place the <kbd>default.rviz</kbd> file inside the <kbd>~/.rviz/</kbd> folder. You will find <kbd>Chapter4_RViz_basics</kbd> in this folder.</p>
<p>You can open the RViz GUI with the following commands:</p>
<pre><strong>T1 $ roscore</strong><br/><strong>T2 $ rviz</strong></pre>
<p>The <kbd>T2</kbd> command, <kbd>rviz</kbd>, is an abbreviation of the official <kbd>$ rosrun rviz rviz</kbd> declaration, where first <kbd>rviz</kbd> refers to the package and the second refers to the node with the same name.</p>
<p>At the moment, the RViz window will be empty, so it will only show a grid at the floor level. In the next section, we will teach you how to build the robot model and get ready to visualize it. Once you've launched it, you will see a window similar to the one shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1379 image-border" src="img/0ef57290-3490-4559-80b7-ebd028fda79c.png" style="width:153.67em;height:88.00em;"/></p>
<p>If you look carefully at the preceding screenshot, you'll see an error message in the left-hand pane. This is due to the fact that a robot model hasn't been loaded. We will develop this model in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building a differential drive robot with URDF</h1>
                
            
            
                
<p>The GoPiGo3 kit is composed of four several subassemblies:</p>
<ul>
<li>The chassis, which is the main structure that all the parts are attached to. This includes the following:
<ul>
<li>Raspberry Pi and GoPiGo3 board</li>
<li>Motors</li>
<li>Battery package</li>
<li>Wheels</li>
<li>Caster</li>
</ul>
</li>
<li>Two wheels – left and right, each one driven by one motor.</li>
<li>A caster, which is a small freewheel attached to the rear part of the chassis that keeps the robot supported on three points: the left and right wheels and the caster itself. Be aware that one freewheel is the minimum to keep the robot rolling on the floor:
<ul>
<li>If the caster were not present, the system would be underconstrained. Then, you would have a self-balancing robot that would have to be continuously actuated by its motors to stay in equilibrium. This is a <em>closed-loop</em> control problem that needs the <strong>Inertial Measurement Unit</strong> (<strong>IMU</strong>) data from its accelerometers and gyroscopes to actuate the motors and keep the robot in equilibrium:</li>
</ul>
</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="img/df78ca2b-2824-473c-a409-6d337c33fdba.png" style="width:28.00em;height:29.83em;"/></p>
<p>Image courtesy: Dexter Industries https://shop.dexterindustries.com/media/catalog/product/cache/4/thumbnail/1800x2400/9df78eab33525d08d6e5fb8d27136e95/b/a/balancebot_remote2-150x150_1_1.jpg</p>
<ol>
<li style="list-style-type: none">
<ul>
<li>If there were two casters, the system would be overconstrained. The robot would be supported on four points – two wheels and two casters – and the position of the second caster would be determined by the other caster and the two wheels. If one of the four wheels/the caster were not in contact with the floor, you would have a lame robot.</li>
</ul>
</li>
</ol>
<p>From the point of view of a simulated model, a differential drive robot such as GoPiGo3 is composed of three parts, each one being a rigid body. Therefore, we will divide the robot into mobile parts: </p>
<ul>
<li>The robot body, which includes the chassis and all the fixed parts attached to it (Raspberry Pi, GoPigo3 board, motors, and the battery package)</li>
<li>Left and right wheels</li>
<li>Caster</li>
</ul>
<p>Going back to ROS, you are going to build a simulated GoPiGo3 with URDF. This is an XML format description that represents robot models at the component level. ROS contains a URDF package (<a href="http://wiki.ros.org/urdf">http://wiki.ros.org/urdf</a>) in order to accept this format of the robot description for simulation purposes.</p>
<p>In the upcoming sections, we are going to illustrate how to describe the four mobile parts of GoPiGo3 in URDF.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overview of URDF for GoPiGo3</h1>
                
            
            
                
<p>First, we're going to give you an overview of building the model, after which we'll walk you through the process step by step. The URDF model of our robot will render like this in RViz:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9286c54f-8be2-4f82-a9ec-694a2916d791.png" style="width:44.92em;height:29.33em;"/></p>
<p>This model corresponds to the following URDF description:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1380 image-border" src="img/73a233ce-0cda-44ba-8b7a-6effa1f01efb.png" style="width:27.25em;height:29.08em;"/></p>
<p>The content of the XML tags has collapsed – which is inferred from the plus signs to the right of the line numbers – to show you that each block corresponds to one part of the robot:</p>
<ul>
<li>The top-level tag is <kbd>&lt;robot&gt;</kbd> and identifies the robot as a whole.</li>
<li>The <kbd>&lt;link&gt;</kbd> tag refers to each mobile part, identified by the <kbd>name</kbd> property. All of the content inside specifies the characteristics of that part:
<ul>
<li><kbd>name="base_link"</kbd> refers to the robot body and, in this case, the chassis and the parts attached to it: the Raspberry Pi, GoPiGo3 board, motors, and the battery package.</li>
<li><kbd>name="caster"</kbd> refers to the caster freewheel, but it is within a <kbd>&lt;visual&gt;</kbd> subtag, meaning it is part of the robot body, not a separate mobile part. Although it is a rolling element, remember that a simulated model tries to catch the properties of its reality with a simple description. Since the caster is merely a support, it does not need to be driven by a motor. For this reason, we can keep it fixed with respect to the robot body, and only deal with three mobile parts (robot body, right wheel, and left wheel) instead of four. If you're wondering about the friction it could produce, then don't worry – later, we'll learn how to set a zero value to make sure it behaves like a freewheel. The <kbd>&lt;visual&gt;</kbd> tag refers to a rigid body representation of a part of the robot without needing to define it as a separate link.</li>
<li><kbd>name="right_wheel"</kbd> refers to the right wheel.</li>
<li><kbd>name="left_wheel"</kbd> refers to the left wheel.</li>
</ul>
</li>
<li>The <kbd>&lt;joint&gt;</kbd> tag represents a junction between two parts. From a mechanical point of view, these joint tags correspond to the bearings that the wheels are mounted on. There is one associated with each wheel link.</li>
</ul>
<p>Next, we will explain the contents of each <kbd>&lt;link&gt;</kbd> and <kbd>&lt;joint&gt;</kbd> tag that's used in this model in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">URDF robot body</h1>
                
            
            
                
<p>A <kbd>&lt;link&gt;</kbd> element, as defined in the URDF XML specification (<a href="http://wiki.ros.org/urdf/XML/link" target="_blank">http://wiki.ros.org/urdf/XML/link</a>), defines a rigid body with inertia, visual features, and collision properties. In this chapter, we will introduce <kbd>&lt;visual&gt;</kbd>. We will leave <kbd>&lt;inertia&gt;</kbd> and <kbd>&lt;collision&gt;</kbd> for later in this book since these properties are only required when performing physics simulation with Gazebo (see <a href="74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml" target="_blank">Chapter 5</a>, <em>Simulating Robot Behavior with Gazebo</em>).</p>
<p>The <kbd>&lt;visual&gt;</kbd> tag describes the visual appearance of the part. Don't confuse this with the <kbd>&lt;collision&gt;</kbd> tag, as that defines the volume to be considered for interference or crash calculation. Often, both may define different volumes, although it is very common that they are in agreement. </p>
<p>Why should they be different? For complex shapes, interference calculations can be heavy in terms of CPU load and time duration. Therefore, it is better to use simple shapes in <kbd>&lt;collision&gt;</kbd> tags, defining them as the envelope of the actual shapes of the parts. For example, for the manipulator in the following screenshot, you could define the <kbd>&lt;visual&gt;</kbd> elements of the arm as the actual shapes – the ones that are shown – and simplify the <kbd>&lt;collision&gt;</kbd> elements to make them the envelope cylinders of the arms to facilitate interference calculation:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/97cd20b5-8c9c-402a-8b84-7f66463881d6.png" style="width:51.58em;height:32.58em;"/></p>
<p>The <kbd>&lt;origin&gt;</kbd> tag specifies the reference frame of the <kbd>&lt;visual&gt;</kbd> element with respect to the reference frame of the link.</p>
<p>The <kbd>&lt;geometry&gt;</kbd> tag describes the visual shape (box, cylinder, sphere, or mesh) and its dimensions.</p>
<p>The <kbd>&lt;material&gt;</kbd> tag sets the appearance of the <kbd>&lt;visual&gt;</kbd> element with <kbd>&lt;color&gt;</kbd> and <kbd>&lt;texture&gt;</kbd>.</p>
<p>Given these tag descriptions, we can easily read about the <kbd>base_link</kbd> element, that is, the robot body, in the following code snippet:</p>
<pre>&lt;?xml version='1.0'?&gt;<br/>&lt;robot name="gopigo3"&gt;<br/><br/>  &lt;!-- Base Link --&gt;<br/>  &lt;link name="base_link"&gt;<br/>    &lt;visual&gt;<br/>      &lt;origin xyz="0 0 0" rpy="0 0 0" /&gt;<br/>      &lt;geometry&gt;<br/>          &lt;box size="0.5 0.5 0.25"/&gt;<br/>      &lt;/geometry&gt;<br/>      &lt;material name="blue"&gt;<br/>        &lt;color rgba="0 0.5 1 1"/&gt;<br/>      &lt;/material&gt;<br/>    &lt;/visual&gt;<br/><br/>    &lt;!-- Caster --&gt;<br/>    &lt;visual name="caster"&gt;<br/>      &lt;origin xyz="0.2 0 -0.125" rpy="0 0 0" /&gt;<br/>      &lt;geometry&gt;<br/>        &lt;sphere radius="0.05" /&gt;<br/>      &lt;/geometry&gt;<br/>    &lt;/visual&gt;<br/><br/>  &lt;/link&gt;<br/>...</pre>
<p>Therefore, the <kbd>base_link</kbd> element consists of the following:</p>
<ul>
<li>A box that's 0.5 m in length and 0.25 m in height.</li>
<li>Its reference frame – located in the geometrical center of the box – coincides with that of the link (zero values in all three linear axes and three rotation axes).</li>
<li>The <kbd>&lt;material&gt;</kbd> tag specifies the blue color as RGBA indexes: Red = 0, Green = 0.5, Blue = 1. The fourth, A = 1, is the alpha channel, which refers to the degree of opacity. A value of 1 means an opaque object, while 0 means that it is transparent.</li>
</ul>
<p>Rendering the link in RViz provides the following simple aspect of a box:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c7714d58-0b3c-4fdb-96dd-402eaa5f62c0.png" style="width:24.08em;height:21.67em;"/></p>
<p>But wait – what is that semi-spherical shape attached to the lower face? That is the caster, the freewheel that we can model as an integral part of the robot body, as was explained previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Caster</h1>
                
            
            
                
<p>The caster description is nested inside the <kbd>&lt;link name="base_link"&gt;</kbd> element. This means that it's a rigid part that's fixed to the robot body. Let's go over what it is:</p>
<ul>
<li>It's a sphere that has a radius of 0.05 m, located at x=0.2 m, z=-0.125 m. Be aware that the <em>Z</em> coordinate is half of the box height (=0.25 m) and negative. This means that the top semi-sphere is embedded within the box and only the other semi-sphere stays visible on the bottom part of the box.</li>
<li>By default, the same color is selected as what was defined for the box.</li>
</ul>
<p>Inspect the following code carefully to ensure you understand it:</p>
<pre>    &lt;!-- Caster --&gt;<br/> &lt;visual name="caster"&gt;<br/> &lt;origin xyz="0.2 0 -0.125" rpy="0 0 0" /&gt;<br/> &lt;geometry&gt;<br/> &lt;sphere radius="0.05" /&gt;<br/> &lt;/geometry&gt;<br/> &lt;/visual&gt;</pre>
<p>This is how the caster will appear in RViz, making the box semitransparent:<br/></p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9aa59cf2-915e-40a2-84a8-6618858ced36.png" style="width:25.33em;height:14.33em;"/></p>
<p>Take note of the position and direction of the <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> axes, and pay attention to their directions. This fact is especially important when matching the axes of the IMU. The following photograph shows how you have to place such a sensor in a physical GoPiGo3 to make sure the IMU axes are parallel to the <kbd>base_link</kbd> frame and have the same directions (see the marked set of axes that are printed on the surface of the sensor):</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1381 image-border" src="img/faee0314-f937-4ed8-a44c-b1a6b33f5c11.png" style="width:36.50em;height:27.42em;"/></p>
<p>Finally, in the following photograph, you can see the whole robot. This will help you make sure that you know where the details in the preceding photograph are located:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4b7d7e6d-2a1b-4547-91a3-3d7e8396f1e2.png" style="width:36.75em;height:31.67em;"/></p>
<p>Next, let's have a look at the URDF model's left and right wheels.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The URDF model's left and right wheels</h1>
                
            
            
                
<p>Given that you already know the basic URDF tags, it is straightforward to read the definition for the right wheel, as shown in the following code snippet:</p>
<pre>  &lt;!-- Right Wheel --&gt;<br/>  &lt;link name="right_wheel"&gt;<br/>    &lt;visual&gt;<br/>      &lt;origin xyz="0 0 0" rpy="1.570795 0 0" /&gt;<br/>      &lt;geometry&gt;<br/>          &lt;cylinder length="0.1" radius="0.2" /&gt;<br/>      &lt;/geometry&gt;<br/>      &lt;material name="black"&gt;<br/>        &lt;color rgba="0.05 0.05 0.05 1"/&gt;<br/>      &lt;/material&gt;<br/>    &lt;/visual&gt;<br/>  &lt;/link&gt;<br/><br/>  &lt;joint name="joint_right_wheel" type="continuous"&gt;<br/>    &lt;parent link="base_link"/&gt;<br/>    &lt;child link="right_wheel"/&gt;<br/>    &lt;origin xyz="0 -0.30 0" rpy="0 0 0" /&gt; <br/>    &lt;axis xyz="0 1 0" /&gt;<br/>  &lt;/joint&gt;</pre>
<p class="CDPAlignLeft CDPAlign">Inside the <kbd>&lt;origin&gt;</kbd> tag, the first component of the <kbd>rpy</kbd> attribute (rotation around the <em>X</em> axis), 1.570795 = π/2, is what sets the wheel to a vertical position. The cylindrical wheel has a 0.2 m radius and is 0.1 m in length.</p>
<p>The new element here is the <kbd>&lt;joint&gt;</kbd> tag (<a href="http://wiki.ros.org/urdf/XML/joint">http://wiki.ros.org/urdf/XML/joint</a>), which is used to specify the kinematics and dynamics of the joint and its safety limits:</p>
<ul>
<li><kbd>type="continuous"</kbd> means a hinge joint that rotates around the axis and has no upper and lower limits.</li>
<li>The parent and child links identify what links are connected by this joint.</li>
<li>The origin specifies the offsets in <em>X</em>, <em>Y</em>, and <em>Z</em> and the three rotations of the child link with respect to the parent link. Then, <kbd>&lt;origin xyz="0 -0.30 0" rpy="0 0 0" /&gt;</kbd> places the joint at Y = -0.30 m. These coordinates are referred to the frame of the parent link:
<ul>
<li><kbd>axis</kbd> defines the rotation axis of the joint with respect to the parent frame. Here, <kbd>&lt;axis xyz="0 1 0" /&gt;</kbd> means that the rotation axis is Y (value 1 in the Y coordinate).</li>
</ul>
</li>
</ul>
<p>The XML description for the left wheel is almost identical. The only change is the position of the joint at Y = 0.30 m (<kbd>&lt;origin xyz="0 0.30 0" ... /&gt;</kbd> ), with an opposite sign to that of the right wheel, that is, <kbd>&lt;origin xyz="0 -0.30 0" ... /&gt;</kbd>:</p>
<pre class="mce-root">  &lt;!-- Left Wheel --&gt;<br/>  &lt;link name="left_wheel"&gt;<br/>    &lt;visual&gt;<br/>      &lt;origin xyz="0 0 0" rpy="1.570795 0 0" /&gt;<br/>      &lt;geometry&gt;<br/>          &lt;cylinder length="0.1" radius="0.2" /&gt;<br/>      &lt;/geometry&gt;<br/>      &lt;material name="black"/&gt;<br/>    &lt;/visual&gt;<br/>  &lt;/link&gt;<br/>  <br/>  &lt;joint name="joint_left_wheel" type="continuous"&gt;<br/>    &lt;parent link="base_link"/&gt;<br/>    &lt;child link="left_wheel"/&gt;<br/>    &lt;origin xyz="0 0.30 0" rpy="0 0 0" /&gt; <br/>    &lt;axis xyz="0 1 0" /&gt;<br/>  &lt;/joint&gt;</pre>
<p class="mce-root">In the next section, you are going to learn how to visualize the URDF description in RViz, the ROS visualization tool.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inspecting the GoPiGo3 model in ROS with RViz</h1>
                
            
            
                
<p>Now, it's time to start working with ROS! You are going to discover <kbd>roslaunch</kbd>, the ROS command that allows us to launch several nodes in one shot, avoiding the need to open separate Terminals, as we did in the previous chapter.</p>
<p>Given that you already cloned the code repository of this book, the files that we will deal with are inside the <kbd>Chapter4_RViz_basics</kbd> folder of the repository, and all of them are part of the <kbd>rviz_basics</kbd> ROS package, as defined within <kbd>package.xml</kbd>. The file structure of this chapter can be seen in the following screenshot of the RoboWare Studio IDE: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c8bda82b-a756-4ca2-8b8a-7ea6ba8f5e21.png" style="width:20.33em;height:21.17em;"/></p>
<p>You can obtain this tree structure in the Terminal by using the <kbd>tree</kbd> bash command:</p>
<pre><strong>$ tree ~/catkin_ws/src/book/Chapter4_RViz_basics</strong></pre>
<p>Bear in mind that it does not come with Ubuntu by default and that you may need to install it:</p>
<pre><strong>$ sudo apt-get update</strong><br/><strong>$ sudo apt-get install tree</strong></pre>
<p>This will result in the following output:</p>
<pre><strong>├── CMakeLists.txt</strong><br/><strong>├── launch</strong><br/><strong>│   ├── gopigoMinimal_rviz.launch</strong><br/><strong>│   └── gopigoMinimal_rviz_simple.launch</strong><br/><strong>├── package.xml</strong><br/><strong>├── README.md</strong><br/><strong>├── rviz</strong><br/><strong>│   ├── default.rviz</strong><br/><strong>│   └── gopigoMinimal.rviz</strong><br/><strong>└── urdf</strong><br/><strong> └── gopigoMinimal.urdf</strong></pre>
<p>This tree organizes the files into a variety of folders, depending on the types of files:</p>
<ul>
<li><kbd>./launch</kbd> groups the files with the <kbd>*.launch</kbd> extension, that is, the different robot configurations and packages that will be used in the runtime environment. Each launch file corresponds to a specific run's setup.</li>
<li><kbd>./rviz</kbd> stores the files of specific RViz configurations, one file for each possible configuration.</li>
<li><kbd>./urdf</kbd> contains the XML URDF file of the robot model we described previously.</li>
</ul>
<p>Make sure this folder is in your workspace and build it with <kbd>catkin</kbd> so that ROS is aware of your new package:</p>
<pre><strong>$ cd ~/catkin_ws</strong><br/><strong>$ catkin_make</strong></pre>
<p>In <a href="f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml" target="_blank">Chapter 3</a>, <em>Getting Started with ROS</em>, in the <em>Using Roboware – creating a workspace and building it</em> section, we explained how to do these operations in the Roboware IDE. Take a look at that chapter and section if you prefer to use a desktop application.</p>
<p>Finally, you can execute <kbd>roslaunch</kbd> from a Terminal with the following snippet:</p>
<pre><strong>$ roslaunch rviz_basics gopigoMinimal_rviz.launch model:=gopigoMinimal</strong></pre>
<p>The RViz window will launch and you will see a simplified GoPiGo3 model, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f2d0c177-822f-472a-b842-13fe34a0e02b.png" style="width:27.25em;height:15.42em;"/></p>
<p>You can inspect the model by rotating it with the mouse while clicking the left button, and zoom in/zoom out by using the mouse wheel or, alternatively, clicking the right button and moving the mouse forward (zoom in) or backward (zoom out).</p>
<p>The left pane of RViz contains two items that are of interest to us. Expand them with a mouse click to inspect them:</p>
<ul>
<li><strong>RobotModel</strong>: Where you can use the ticks to visualize what you need. The items under Links allow us to access individual parts of the GoPiGo URDF model: <kbd>base_link</kbd> (robot body), <kbd>left_wheel</kbd>, and <kbd>right_wheel</kbd>.</li>
<li><strong>TF</strong>: which provides access to the multiple coordinate frames. In our case, there is one frame for each of the parts of GoPiGo3 and one for each of the joints.</li>
</ul>
<p>Next, we'll look at the <kbd>roslaunch</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the roslaunch command</h1>
                
            
            
                
<p>Let's go one step back and use a minimal launch file to understand the syntax of these kinds of scripts:</p>
<pre><strong>$ roslaunch rviz_basics gopigoMinimal_rviz_simple.launch</strong></pre>
<p>As we saw with <kbd>rosrun</kbd>, the structure of the ROS command is very similar:</p>
<ul>
<li>First is the command name itself, <kbd>roslaunch</kbd>.</li>
<li>Second is the package name, <kbd>rviz_basics</kbd>.</li>
<li>The third is the script we will execute, <kbd>gopigoMinimal_rviz_simple.launch</kbd>.</li>
</ul>
<p>The content of the <kbd>gopigoMinimal_rviz_simple.launch</kbd> file looks like this:</p>
<pre>&lt;launch&gt;<br/>   <strong>&lt;!-- set these parameters on Parameter Server --&gt;</strong><br/>   &lt;param name="robot_description" textfile="$(find rviz_basics)/urdf/gopigoMinimal.urdf" /&gt;<br/><br/>   <strong>&lt;!-- Start 3 nodes: joint_state_publisher, robot_state_publisher and rviz --&gt;</strong><br/><br/>   <strong>&lt;!-- Send joint values --&gt;</strong><br/>   &lt;<strong>node</strong> pkg="joint_state_publisher" type="<strong>joint_state_publisher</strong>" name="joint_state_publisher"/&gt;<br/><br/>   <strong>&lt;!-- Combine joint values to TF--&gt;</strong><br/>   &lt;<strong>node</strong> name="robot_state_publisher" pkg="<strong>robot_state_publisher</strong>" type="state_publisher"/&gt;<br/><br/>   &lt;<strong>node</strong> name="rviz" pkg="rviz" type="<strong>rviz</strong>" args="-d $(find rviz_basics)/rviz/gopigoMinimal.rviz" required="true" /&gt;<br/>&lt;/launch&gt;</pre>
<p>The syntax, in XML format, should be familiar to you. In this file, there are three types of tags:</p>
<ul>
<li><kbd>&lt;launch&gt; &lt;/launch&gt;</kbd>: Delimits the block of lines that are part of the <kbd>roslaunch</kbd> description.</li>
</ul>
<ul>
<li><kbd>&lt;node /&gt;</kbd>: This is the sentence that's used to execute a ROS node. It is equivalent to the <kbd>rosrun</kbd> command that we explained in the previous chapter. Due to this, the equivalent command to a <kbd>&lt;node /&gt;</kbd> tagged line is as follows:</li>
</ul>
<pre style="padding-left: 60px">&lt;<strong>node</strong> name="robot_state_publisher" pkg="<strong>robot_state_publisher</strong>" type="state_publisher"/&gt;<br/><br/>is equivalent to...<br/><br/>$ rosrun <strong>robot_joint_state_publisher</strong> state_publisher</pre>
<p style="padding-left: 60px">You can easily infer that the <kbd>pkg</kbd> attribute of the <kbd>&lt;node&gt;</kbd> tag is the package name and that the attribute type refers to the script that contains the code of this node.</p>
<ul>
<li><kbd>&lt;param /&gt;</kbd> stands for parameter and is a new ROS concept. It contains a value that is stored in the ROS parameter server that you can visualize as the place where the robot's characterization is stored. A whole set of parameters defines a specific robot configuration. The ROS parameter server, as explained in the ROS official documentation (<a href="http://wiki.ros.org/Parameter%20Server">http://wiki.ros.org/Parameter%20Server</a>), is as follows:</li>
</ul>
<p>"<em>It is a shared, multi-variate dictionary that is accessible via network APIs. Nodes use this server to store and retrieve parameters at runtime. As it is not designed for high performance, it is best used for static, non-binary data such as configuration parameters.</em>"</p>
<p>In our particular case, we have the following declaration in the launch file:</p>
<pre><strong> &lt;param name="robot_description" textfile="$(find rviz_basics)/urdf/gopigoMinimal.urdf" /&gt;</strong></pre>
<p style="padding-left: 30px">The <kbd>robot_description</kbd> parameter is the path where the URDF file is stored. You will see that such a path contains an environment variable in the <kbd>$(find rviz_basics)</kbd> textfile attribute. This is a very nice feature that ROS provides out of the box so that you don't have to provide absolute or relative paths. The <kbd>find </kbd>command is applied to the <kbd>rviz_basics</kbd> package and returns the absolute path of the package, that is, <kbd>~/catkin_ws/src/book/Chapter4_RViz_basics</kbd>. The <kbd>$</kbd> sign means the value of, in the same way as you would do for system environment variables.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Roboware to execute a launch file</h1>
                
            
            
                
<p>What you did using the <kbd>$ roslaunch <strong>rviz_basics</strong> gopigoMinimal_rviz_simple.launch</kbd> command can be done in the <strong>Roboware</strong> IDE by just placing it on top of the file, right-clicking the mouse to show the contextual menu, and selecting the first item, that is, Run Launch File:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1382 image-border" src="img/775f22fa-eba6-4e6c-9114-4d10795df49b.png" style="width:37.83em;height:32.25em;"/></p>
<p>In the following section, we are going to execute the other launch file, <kbd>gopigoMinimal_rviz_simple.launch</kbd>, which introduces more advanced features. Prior to that, close any open RViz windows or hit <em>Ctrl</em> + <em>C</em> in the Terminal to shut down the running ROS processes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controlling the GoPiGo3 robot's wheels from RViz</h1>
                
            
            
                
<p>The complete version of the robot can be launched with the following command:</p>
<pre><strong>$ roslaunch rviz_basics gopigoMinimal_rviz.launch model:=gopigoMinimal</strong></pre>
<p>What we are doing here is supplying an argument, <kbd>gopigoMinimal</kbd>, from the command line. If you pay attention to the content of the launch file, that is, <kbd>gopigoMinimal_rviz.launch</kbd>, you will find a new section at the beginning of the file tagged with <kbd>&lt;arg  /&gt;</kbd>:</p>
<div><pre>&lt;launch&gt;<br/>    <strong>&lt;!-- values passed by command line input --&gt;</strong><br/>    &lt;arg name="model" default="gopigoMinimal" /&gt;<br/>    &lt;arg name="gui" default="False" /&gt;<br/><br/>    <strong>&lt;!-- set these parameters on Parameter Server --&gt;</strong><br/>    &lt;param name="robot_description" textfile="$(find rviz_basics)/urdf/$(arg model).urdf" /&gt;<br/><br/>    <strong>&lt;!-- Start 3 nodes: joint_state_publisher, robot_state_publisher and rviz --&gt;</strong><br/><br/>    <strong>&lt;!-- Send joint values --&gt;</strong><br/>    &lt;node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher"&gt;<br/>      &lt;param name="/use_gui" value="$(arg gui)"/&gt;<br/>    &lt;/node&gt;<br/>    <strong>&lt;!-- Combine joint values to TF--&gt;</strong><br/>    &lt;node name="robot_state_publisher" pkg="robot_state_publisher" type="state_publisher"/&gt;<br/><br/>    &lt;node name="rviz" pkg="rviz" type="rviz" args="-d $(find rviz_basics)/rviz/$(arg model).rviz" required="true" /&gt;<br/>    &lt;!-- (required = "true") if rviz dies, entire roslaunch will be killed --&gt;<br/>&lt;/launch&gt;<br/></pre>
<p>The values that have been tagged as arguments can be passed from the command line by simply adding the argument name, the <kbd>:=</kbd> sign, and its value after <kbd>&lt;filename&gt;.launch</kbd>:</p>
<pre>&lt;arg name="model" default="gopigoMinimal" /&gt;<br/><br/>is invoked with...<br/><br/>model:=gopigoMinimal</pre></div>
<p>In the <kbd>&lt;arg /&gt;</kbd> tag, you can provide a default value with a default attribute. In our specific case, we wouldn't have needed to add the argument value to the <kbd>roslaunch</kbd> command because the value is the default. Therefore, the result is exactly the same as if you had written the following:</p>
<pre><strong>$ </strong><strong>roslaunch rviz_basics gopigoMinimal_rviz.launch</strong><br/></pre>
<p>In the launch file, there is a second optional argument, <kbd>gui</kbd>:</p>
<div><pre>&lt;arg name="gui" default="False" /&gt;</pre></div>
<p>It is a Boolean value and the default value is <kbd>False</kbd>, that is, nothing different happens. Now, let's say you execute the command while specifying it to be <kbd>True</kbd>:</p>
<pre><strong>$ roslaunch rviz_basics gopigoMinimal_rviz.launch model:=gopigoMinimal gui:=True</strong></pre>
<div><p>If you do this, you will see an additional window to the side of RViz. The exposed GUI allows you to rotate each of the wheels independently with sliders:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b3442b2d-07e9-42b6-a6fe-4de066be8cec.png" style="width:28.00em;height:33.00em;"/></p>
</div>
<p>This interactive functionality is part of the <kbd>joint_state_publisher</kbd> package (<a href="http://wiki.ros.org/joint_state_publisher">http://wiki.ros.org/joint_state_publisher</a>), whose <kbd>joint_state_publisher</kbd> node is invoked from the launch file with the <kbd>gui:=True</kbd> argument. We are going to explain this feature in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the joint_state_publisher package</h1>
                
            
            
                
<p>The section of the launch file that allows us to interactively rotate the wheels using a GUI is as follows:</p>
<pre> &lt;node pkg="joint_state_publisher" type="joint_state_publisher" name="joint_state_publisher"&gt;<br/>   &lt;param name="/use_gui" value="$(arg gui)"/&gt;<br/> &lt;/node&gt;</pre>
<p>The <kbd>joint_state_publisher</kbd> node exposes the <kbd>/use_gui</kbd> parameter to decide whether it should show the <kbd>joint_state_publisher</kbd> window. If it's set to <kbd>True</kbd>, the window is active. If it is, we pass the desired value as a parameter to the node via the <kbd>gui</kbd> argument that's defined in the launch file:</p>
<pre>&lt;arg name="gui" default="False" /&gt;</pre>
<p> Remember the <kbd>roslaunch</kbd> command:</p>
<pre><strong>$ roslaunch rviz_basics gopigoMinimal_rviz.launch model:=gopigoMinimal gui:=True</strong><br/></pre>
<p>The <kbd>gui</kbd> argument is set to <kbd>True</kbd>. The <kbd>/use_gui</kbd> parameter value of <kbd>joint_state_publisher</kbd> is then set to the value of the <kbd>gui</kbd> argument, as expressed with the <kbd>&lt;param name="/use_gui" value="$(arg gui)"/&gt;</kbd> tag inside the <kbd>gopigoMinimal_rviz.launch</kbd> file.</p>
<p>The <kbd>joint_state_publisher</kbd> node launches the widget that allows to interactively rotate each wheel. Finally, issue <kbd>rqt_graph</kbd> from a Terminal to watch the ROS graph:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1384 image-border" src="img/5876be82-f06a-4679-8ad9-e58a665a49bd.png" style="width:38.33em;height:8.67em;"/></p>
<p>The <kbd>/joint_states</kbd> topic is the one that we modify when moving the sliders in the window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Robot frames of reference in the URDF model</h1>
                
            
            
                
<p>It is very important to understand how to place the different reference frames you will use for your robot. First, you have to decide where the <kbd>&lt;joint&gt;</kbd> elements are located in the space. In our case, we have two: one for the right wheel and one for the left wheel. Let's look at the one for the right wheel first:</p>
<div><pre>  &lt;joint name="joint_right_wheel" type="continuous"&gt;<br/>    &lt;parent link="base_link"/&gt;<br/>    &lt;child link="right_wheel"/&gt;<br/>    &lt;origin xyz="0 -0.30 0" rpy="0 0 0" /&gt; <br/>    &lt;axis xyz="0 1 0" /&gt;<br/>  &lt;/joint&gt;</pre></div>
<p>Now, let's look at the one for the left wheel:</p>
<pre> &lt;joint name="joint_left_wheel" type="continuous"&gt;<br/>   &lt;parent link="base_link"/&gt;<br/>   &lt;child link="left_wheel"/&gt;<br/>   &lt;origin xyz="0 0.30 0" rpy="0 0 0" /&gt;<br/>   &lt;axis xyz="0 1 0" /&gt;<br/> &lt;/joint&gt;<br/></pre>
<p>Here, you can see that the <kbd>&lt;origin&gt;</kbd> tags specify the locations:</p>
<ul>
<li>The right joint origin is -0.30 m along the <em>y</em> ground axis (green axis).</li>
<li>The left joint origin is +0.30 m along the <em>y</em> ground axis.</li>
</ul>
<p>As in both cases, regarding the <kbd>rpy="0 0 0"</kbd> attribute, there is no rotation and both coordinate frames are parallel to that of the coordinate frame of the ground. We know that both <kbd>&lt;joint&gt;</kbd> tags are relative to the ground because both have <kbd>base_link</kbd> as the parent link, and you know that the first link of our model, <kbd>base_link</kbd>, is the absolute reference for the robot's overall position and orientation.</p>
<p>In general, <kbd>&lt;origin&gt;</kbd> is the transform from the parent link to the child link. The joint is located at the origin of the child link. The tag <kbd>&lt;axis xyz="0 1 0"&gt;</kbd> specifies the rotation axis. In this case it is <kbd>y</kbd> axis, since it has a value of <kbd>1</kbd>, while <kbd>x</kbd> and <kbd>z</kbd> have <kbd>0</kbd> values.</p>
<p>The frames you can see in the following screenshot are the respective ones for <kbd>base_link</kbd>, <kbd>right_wheel</kbd>, and <kbd>left_wheel</kbd>. They are specified inside the <kbd>&lt;visual&gt;</kbd> tag of each link. In these three cases, in the URDF file, you will see that they follow the following pattern:</p>
<pre>&lt;link name="base_link"&gt;<br/>   &lt;visual&gt;<br/>     &lt;origin xyz="0 0 0" rpy=".. .. .." /&gt;<br/></pre>
<p><kbd>xyz="0 0 0"</kbd> means that they coincide with the joint reference frame:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/54898fed-3237-4ceb-b6f5-2de758016944.png" style="width:20.58em;height:11.75em;"/></p>
<p>In the case of the wheels, we have the following:</p>
<pre>&lt;origin xyz="0 0 0" rpy="1.570795 0 0" /&gt;</pre>
<p>1.570795 = pi/2 = 90° is the rotation around the <em>x</em> axis (red). This is what ensures that the cylinders shaping the wheels are oriented vertically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using RViz to check the model while building</h1>
                
            
            
                
<p>Taking into account all the concepts we have introduced about URDF, we can use the RViz tool to assist us while building the robot model. Some checks that it can provide are as follows:</p>
<ul>
<li>The total size of the robot has to match the dimensions of the actual robot. As you build the model part by part, if you make a mistake regarding a part's dimension, an error will arise when you measure the total size (length, width, and height). You can check this by using the measure tool in the RViz toolbar.</li>
<li>You can also visually check for possible interference between robot parts, especially between the ones that are adjacent and move relative to each other (in respect to one another).</li>
<li>The orientation of the reference frames.</li>
<li>You can visualize the parts that are hidden by others by unchecking the corresponding link in RViz or by changing the <kbd>&lt;color&gt;</kbd> tag in order to apply transparency effects.</li>
</ul>
<p>In the following diagram, you can see that we have extracted a top view from RViz and used transparency to check that all the parts are aligned and relative to each other:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4e1d9b85-0cef-4751-985b-3b775d42d89e.png" style="width:8.08em;height:12.58em;"/></p>
<p>This transparency allows us to check that the caster position is right in the middle of <kbd>base_link</kbd>. Furthermore, the wheels do not interfere with <kbd>base_link</kbd>, and their rotation axes are coaxial.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the aspect of the model in the RViz window</h1>
                
            
            
                
<p>To control the visual aspect of your model in RViz, you can modify some of the parameters in the Displays window, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1385 image-border" src="img/ed9b7538-88b6-4170-a59b-90aa0f70c614.png" style="width:16.58em;height:20.33em;"/></p>
<p>We have marked the basic changes we've made for this chapter in gray:</p>
<ul>
<li><strong>Alpha</strong>: This parameter controls the level of opacity of the whole model. The value <kbd>1</kbd> corresponds to its opaque appearance, while <kbd>0</kbd> is fully transparent, that is, not visible. There is also an Alpha parameter for each link to control the individual opacity of a single part (under the Links subtree, expand to access it).</li>
<li><strong>Show Names</strong>: If ticked, the name of the links will be shown on the screen.</li>
<li><strong>Show Axes</strong>: If ticked, it will show the frame of reference of each link.</li>
<li><strong>Show Arrows</strong>: If ticked, it will show the direction of each joint.</li>
<li><strong>Marker Scale</strong>: The default is <kbd>1</kbd>. Reduce its value so that words are smaller on the screen.</li>
</ul>
<p>To save this set of parameters, go to the File item in the top menu and select Save Config As. Here, you specify the name of the file with the <kbd>.rviz</kbd> extension, which is where your custom settings will be saved.</p>
<p>Be aware that within the same File menu, you have the Save Image option, which will produce a screenshot of the current RViz window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Helpful ROS tools for checking purposes</h1>
                
            
            
                
<p>Finally, you should know that there are two helpful ROS tools if you want to make some checks:</p>
<ul>
<li><kbd>check_urdf</kbd> attempts to parse a URDF file in order to verify the kinematic chain:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ roscd rviz_basics</strong><br/><strong>$ check_urdf ./urdf/gopigoMinimal.urdf</strong></pre>
<p style="padding-left: 60px">The <kbd>roscd</kbd> command changes the prompt to the path of the ROS package whose name you are indicating as an argument, that is, <kbd>rviz_basics</kbd>. The output is as follows, where the current folder is the <kbd>rviz_basics</kbd> path, as requested, that is, <kbd>~/catkin_ws/src/CH4_RVIZ_BASICS</kbd> before the <kbd>$</kbd> sign:</p>
<pre style="padding-left: 60px"><strong>~/catkin_ws/src/CH4_RVIZ_BASICS$ check_urdf ./urdf/gopigoMinimal.urdf</strong><br/><strong>robot name is: gopigoMinimal</strong><br/><strong>---------- Successfully Parsed XML ---------------</strong><br/><strong>root Link: base_link has 2 child(ren)</strong><br/><strong> child(1): left_wheel</strong><br/><strong> child(2): right_wheel</strong></pre>
<p style="padding-left: 60px">Everything is fine!</p>
<ul>
<li><kbd>rqt_tf_tree</kbd> allows us to visualize the <kbd>tf</kbd> information in the GUI environment, like so:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ roslaunch rviz_basics gopigoMinimal_rviz.launch model:=gopigoMinimal </strong><br/><strong>$ rosrun rqt_tf_tree rqt_tf_tree</strong><br/></pre>
<p style="padding-left: 60px">A window will open, showing this aspect graph:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1386 image-border" src="img/ef0c195a-0be8-4ead-beab-50d9fca391f2.png" style="width:41.00em;height:18.33em;"/></p>
<p>The preceding graph tells you that <kbd>base_link</kbd> (robot body part) and the wheels are well connected. The arrows represent the joint elements: <kbd>joint_right_wheel</kbd> and <kbd>joint_left_wheel</kbd>.</p>
<p>Alternatively, you can generate this same output as a PDF file:</p>
<pre><strong>$ rosrun tf view_frames</strong></pre>
<p>Then, you can open the created PDF, like so:</p>
<pre><strong>$ evince frames.pdf</strong></pre>
<p>This second way of doing things is more convenient if you want to share the output with colleagues.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we introduced two essential elements of ROS. One is the URDF format, which is the standard way of describing the virtual model of a robot. The other is RViz, the ROS visualization tool, which lets you inspect your model while building and check the final result.</p>
<p>You have learned about these essential elements by looking at GoPiGo3, where you created a simplified model that includes its chassis, motors, and wheels. We have shown you how to interactively rotate the wheels with a GUI by accessing the <kbd>joint_states</kbd> topic of the <kbd>joint_state_publisher</kbd> node, which belongs to the package with the same name. This package offers a tool for setting and publishing joint state values for a given URDF model. In the case of GoPiGo3, we have two joints: the left wheel and the right wheel. The caster is the third joint, but as it is a freewheel (not driven by a motor), so we don't need to define it as such in the virtual GoPiGo3. Rigidly attaching it to the robot body is sufficient.</p>
<p>In RViz, we can simulate the kinematics of the robot. In the next chapter, we will go one step further and simulate the dynamics. This is something that will require us to complete our URDF model with mass and inertia properties, as well as specify the rolling resistance in the wheels to reproduce all the forces that act on our robot. We will do that with Gazebo, a dynamics simulator that's integrated with ROS. With Gazebo, we can also reproduce the physical environment of the robot (obstacles, ramps, walls, and more).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the format of the URDF model?</li>
</ol>
<p style="padding-left: 60px">A) It is a text file.<br/>
B) JSON.<br/>
C) XML.</p>
<ol start="2">
<li>How many links and joints does the URDF model of GoPiGo3 have?</li>
</ol>
<p style="padding-left: 60px">A) Four links (robot body, caster, left, and right wheels) and two joints<br/>
B) Three links (robot body, left, and right wheels) and two joints<br/>
C) Three links (robot body, left, and right wheels) and three joints</p>
<ol start="3">
<li>Which tag in the URDF model can you use to specify the color of a link?</li>
</ol>
<p style="padding-left: 60px">A) <kbd>&lt;visual&gt;</kbd><br/>
B) <kbd>&lt;geometry&gt;</kbd><br/>C) <strong><kbd>&lt;material&gt;</kbd></strong></p>
<ol start="4">
<li>Is it mandatory to group file types by folders (SRC, URDF, RViz, launch) in an ROS package?</li>
</ol>
<p style="padding-left: 60px">A) No, the only mandatory condition is to put the package under <kbd>~/catkin_ws/src/</kbd>.<br/>
B) It is only recommended to make a clean package structure.<br/>
C) No, but if you do so, you have to declare the locations in the <kbd>package.xml</kbd> configuration file.</p>
<ol start="5">
<li>Do you always need to run <kbd>roscore</kbd> in a Terminal to launch a ROS process?</li>
</ol>
<p style="padding-left: 60px">A) Yes, because the master node launched by <kbd>roscore</kbd> is what keeps the communication between the nodes of the graph.<br/>
B) You can launch the master node implicitly when using <kbd>roslaunch</kbd>.<br/>C) If you have installed the <kbd>roscore</kbd> package, it is mandatory to run the <kbd>roscore</kbd> process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>ROS URDF tutorials: <a href="http://wiki.ros.org/urdf/Tutorials">http://wiki.ros.org/urdf/Tutorials</a>.</li>
<li>ROS visualization tutorials: <a href="http://wiki.ros.org/visualization/Tutorials">http://wiki.ros.org/visualization/Tutorials</a>.</li>
<li><em>ROS Robot Programming: A Handbook Written by TurtleBot3 Developers</em>, YoonSeok Pyo, HanCheol Cho, RyuWoon Jung, and TaeHoon Lim (2017), ROBOTIS Co. Ltd, first edition: <a href="http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf">http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf</a>. Chapter: <em>ROS Tools: RViz and rqt </em>and 10.8 <em>TurtleBot3 Simulation using RViz.</em></li>
</ul>


            

            
        
    </body></html>