<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer060">
    <h1 class="chapterNumber">4</h1>
    <h1 class="chapterTitle" id="_idParaDest-108">The Python Automation Framework – Ansible</h1>
    <p class="normal">The previous two chapters incrementally introduced different ways to interact with network devices. In <em class="chapterRef">Chapter 2</em>, <em class="italic">Low-Level Network Device Interactions</em>, we discussed the Pexpect and Paramiko libraries, which manage an interactive session to control interactions. In <em class="chapterRef">Chapter 3</em>, <em class="italic">APIs and Intent-Driven Networking</em>, we started to think of our network in terms of API and intent. We looked at various APIs that contain a well-defined command structure and provide a structured way of getting feedback from the device. As we moved from <em class="chapterRef">Chapter 2</em>, <em class="italic">Low-Level Network Device Interactions</em>, to <em class="chapterRef">Chapter 3</em>, <em class="italic">APIs and Intent-Driven Networking</em>, we began to think about our intent for the network. We gradually began to express our network as code.</p>
    <p class="normal">In this chapter, let’s expand upon the idea of translating our intention into network requirements. If you have worked on network designs, chances are the most challenging part of the process is not the different pieces of network equipment but rather the qualifying and translating of business requirements into the actual network design. Your network design needs to solve business problems. For example, you might be working within a larger infrastructure team that needs to accommodate a thriving online e-commerce site that experiences slow site response times during peak hours. How do you determine whether the network is the problem? If the slow response on the website was indeed due to network congestion, which part of the network should you upgrade? Can the rest of the system take advantage of the greater speed and feed?</p>
    <p class="normal">The following diagram is an illustration of a simple process of the steps that we might go through when trying to translate our business requirements into a network design:</p>
    <figure class="mediaobject"><img alt="Diagram  Description automatically generated" src="../Images/B18403_04_01.png"/></figure>
    <p class="packt_figref">Figure 4.1: Business logic to network deployment</p>
    <p class="normal">In my opinion, network automation is not just about faster configuration change. It should also solve <a id="_idIndexMarker290"/>business problems while accurately and reliably translating our intention into device behavior. These are the goals that we should keep in mind as we march on our network automation journey. In this chapter, we will look at a Python-based<a id="_idIndexMarker291"/> framework called <strong class="keyWord">Ansible</strong>, which allows us to declare our intention for the network and abstract even more from the API and CLI.</p>
    <p class="normal">In this chapter, we will take a look at the following topics:</p>
    <ul>
      <li class="bulletList">An introduction to Ansible</li>
      <li class="bulletList">The advantages of Ansible</li>
      <li class="bulletList">The Ansible architecture</li>
      <li class="bulletList">Ansible advanced topics</li>
    </ul>
    <p class="normal">Let’s begin by looking at an overview of the Ansible framework. </p>
    <h1 class="heading-1" id="_idParaDest-109">Ansible – A More Declarative Framework</h1>
    <p class="normal">Imagine<a id="_idIndexMarker292"/> yourselves in a hypothetical situation: you woke up one morning in a cold sweat from a nightmare you had about a potential network security breach. You realize your network contains valuable digital assets that should be protected. You have been doing your job as a network administrator, so it is pretty secure, but you want to put more security measures around your network devices just to be sure.</p>
    <p class="normal">To start with, you break the objective down into two actionable items:</p>
    <ul>
      <li class="bulletList">Upgrading the devices to the latest version of the software. The steps include the following:<ol class="numberedList" style="list-style-type: decimal;">
          <li class="numberedList" value="1">Uploading the image to the device</li>
          <li class="numberedList">Instructing the device to boot from the new image</li>
          <li class="numberedList">Proceeding to reboot the device</li>
          <li class="numberedList">Verifying that the device is running with the new software image</li>
        </ol>
      </li>
      <li class="bulletList">Configuring the appropriate access control list on the networking devices, which includes the following:<ol class="numberedList" style="list-style-type: decimal;">
          <li class="numberedList" value="1">Constructing the access list on the device</li>
          <li class="numberedList">Configuring the access list on the interface under the interface configuration section</li>
        </ol>
      </li>
    </ul>
    <p class="normal">Being an <a id="_idIndexMarker293"/>automation-focused network engineer, you want to write scripts to reliably configure the devices and receive feedback from the operations. You begin to research the necessary commands and APIs for each step, validate them in the lab, and finally, deploy them in production. Having done a fair amount of work for OS upgrade and ACL deployment, you hope the scripts are transferable to the next generation of devices.</p>
    <p class="normal">Wouldn’t it be nice if there was a tool that could shorten this design-develop-deployment cycle? In this chapter, we will work with an open-source automation framework called Ansible. It is a framework that can simplify the process of going from business logic to completing the job without getting bogged down with specific network commands. It can configure systems, deploy software, and orchestrate a combination of tasks.</p>
    <p class="normal">Ansible is written in Python and has emerged as one of the leading automation tools for Python developers. It is also one of the most supported automation frameworks by network vendors. In the <em class="italic">‘Python Developers Survey 2020’</em> by JetBrains, Ansible is ranked #1 for configuration management tools:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_04_02.png"/></figure>
    <p class="packt_figref">Figure 4.2: Python Developers Survey 2020 Results (source: https://www.jetbrains.com/lp/python-developers-survey-2020/)</p>
    <p class="normal">Ever since<a id="_idIndexMarker294"/> version 2.10, Ansible has separated the release schedule for <strong class="keyWord">ansible-core</strong> and community packages. It is a bit confusing, so let’s take a look at the differences. </p>
    <h2 class="heading-2" id="_idParaDest-110">Ansible Versions</h2>
    <p class="normal">Prior to version 2.9, Ansible <a id="_idIndexMarker295"/>has a fairly straightforward versioning system, going from 2.5, 2.6, 2.7, and so on (<a href="https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html"><span class="url">https://docs.ansible.com/ansible/latest/roadmap/old_roadmap_index.html</span></a>). Starting from version 2.10, we see the jump from Ansible project 2.10, 3.0, 4.0, and so on (<a href="https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap"><span class="url">https://docs.ansible.com/ansible/latest/roadmap/ansible_roadmap_index.html#ansible-roadmap</span></a>). What gives? The Ansible team wants to separate the core engine, modules, and plugins from the wider community-curated modules and plugins. This allows the core team to move faster with the core features while allowing time for the community to catch up with the maintenance of their code. </p>
    <p class="normal">When we talk about “Ansible,” we are referring to a collection of community packages at that level, say, version 3.0. In the version, it will specify a version of <code class="inlineCode">ansible-core</code> (initially called <code class="inlineCode">ansible-base</code>) it requires. For example, Ansible 3.0 requires ansible-core 2.10 and above, while Ansible 4.0 requires ansible-core 2.11+. In this structure, we can upgrade ansible-core to the latest version while keeping the community packages in an older release if needed.</p>
    <div class="packt_tip">
      <p class="normal">If want to learn more<a id="_idIndexMarker296"/> about the versioning split, Ansible provides a useful Q&amp;A page when they first adopted Ansible 3.0, <a href="https://www.ansible.com/blog/ansible-3.0.0-qa"><span class="url">https://www.ansible.com/blog/ansible-3.0.0-qa</span></a>. </p>
    </div>
    <p class="normal">Let’s move ahead and look at an Ansible example. </p>
    <h1 class="heading-1" id="_idParaDest-111">Our First Ansible Network Example</h1>
    <p class="normal">Ansible is an<a id="_idIndexMarker297"/> IT automation tool. Its main attributes are simplicity and ease of use with minimum moving parts. It manages machines in an agent-less manner (more on this later) and relies on the existing operating system credentials and remote Python software to run its code. Ansible is installed on a centralized machine called<a id="_idIndexMarker298"/> the controlled node and executes on the machine it wishes to control, called<a id="_idIndexMarker299"/> the managed node. </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_04_03.png"/></figure>
    <p class="packt_figref">Figure 4.3: Ansible Architecture (Source: https://docs.ansible.com/ansible/latest/getting_started/index.html)</p>
    <p class="normal">As with most IT infrastructure automation, Ansible started by managing servers. Most servers have Python installed or are capable of running Python code; Ansible would leverage this feature by pushing the code to the managed node and having it run locally on the <a id="_idIndexMarker300"/>managed node. However, as<a id="_idIndexMarker301"/> we know, most network devices are not capable of running native Python code; therefore, when it comes to network automation, the Ansible configuration is run locally first before making the changes to the remote devices. </p>
    <div class="note">
      <p class="normal">For more information on<a id="_idIndexMarker302"/> how network automation is different, check out this document from Ansible, <a href="https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html"><span class="url">https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html</span></a>.</p>
    </div>
    <p class="normal">Let us install Ansible on the control node. </p>
    <h2 class="heading-2" id="_idParaDest-112">The Control Node Installation</h2>
    <p class="normal">We will <a id="_idIndexMarker303"/>install Ansible on the Ubuntu host in our lab. The<a id="_idIndexMarker304"/> only requirements for the control node are Python 3.8 or newer as well as Python’s <code class="inlineCode">pip</code> package management system</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ pip install ansible
</code></pre>
    <p class="normal">We can check the installed Ansible version as well as other package-level information via the ‘—version’ switch: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible --version
ansible [core 2.13.3]
  config file = None
  configured module search path = ['/home/echou/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/echou/Mastering_Python_Networking_Fourth_Edition/venv/lib/python3.10/site-packages/ansible
  ansible collection location = /home/echou/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/echou/Mastering_Python_Networking_Fourth_Edition/venv/bin/ansible
  python version = 3.10.4 (main, Jun 29 2022, 12:14:53) [GCC 11.2.0]
  jinja version = 3.1.2
  libyaml = True 
</code></pre>
    <div class="packt_tip">
      <p class="normal">If you are interested in installing Ansible on specific operation systems using their respective package management systems, please consult the Ansible documentation, <a href="https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html"><span class="url">https://docs.ansible.com/ansible/latest/installation_guide/installation_distros.html</span></a>.</p>
    </div>
    <p class="normal">There is <a id="_idIndexMarker305"/>some important information displayed in the output. The<a id="_idIndexMarker306"/> most important is the Ansible core version (2.13.3) and configuration file (none for now). This is all we need to get started with Ansible, we can start to construct our first automation task. </p>
    <h2 class="heading-2" id="_idParaDest-113">Lab Topology</h2>
    <p class="normal">Ansible <a id="_idIndexMarker307"/>is known to have many different ways to accomplish the same task. For example, we <a id="_idIndexMarker308"/>can define Ansible configuration files in different locations. We can also specify host-specific variables in a variety of places such as an inventory, in playbooks, in roles, and the command line. This is too confusing for people who are just getting started with Ansible. In this chapter, I will use just one way of doing things that makes the most sense to me. Once we learn the basics, we can always consult the documentation to find out other ways to accomplish a task. </p>
    <p class="normal">For the first example, we will use the same lab topology that we have been using and run the task against the two IOSv devices, <code class="inlineCode">lax-edg-r1</code> and <code class="inlineCode">lax-edg-r2</code>. </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_04_04.png"/></figure>
    <p class="packt_figref">Figure 4.4: Lab Topology</p>
    <p class="normal">The first <a id="_idIndexMarker309"/>thing we will need to think about is how to define the hosts we want to <a id="_idIndexMarker310"/>manage. In Ansible, we use an inventory file to define the host we intend to manage. Let us create a file called <code class="inlineCode">hosts</code> and put the following text in the file: </p>
    <pre class="programlisting code"><code class="hljs-code">[ios_devices]
iosv<span class="hljs-string">-1</span>
iosv<span class="hljs-string">-2</span> 
</code></pre>
    <p class="normal">This type of file is in <a id="_idIndexMarker311"/>an INI format (<a href="https://en.wikipedia.org/wiki/INI_file"><span class="url">https://en.wikipedia.org/wiki/INI_file</span></a>), which states I have a group of devices called the <code class="inlineCode">ios_devices</code> with members of <code class="inlineCode">iosv-1</code> and <code class="inlineCode">iosv-2</code>. </p>
    <p class="normal">We should now specify the particular variables associated with each host. </p>
    <h3 class="heading-3" id="_idParaDest-114">The Variable Files</h3>
    <p class="normal">There are<a id="_idIndexMarker312"/> many places we can put the variables associated with a host. Let us create a folder called <code class="inlineCode">host_vars</code> and two files with the names of the files identical to the hosts we specified in the inventory file. The directory and filenames are important because that is how Ansible matches up the variables with the host. Below is an output to show the directory and files within that directory: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>tree host_vars/
host_vars/
├── iosv-1
└── iosv-2
</code></pre>
    <p class="normal">The file is<a id="_idIndexMarker313"/> where we will put the necessary information belonging to the host. For example, we can specify the IP address, username, password, and other information. Here is the output of the <code class="inlineCode">iosv-1</code> file for our lab: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> host_vars/iosv-1 
---
ansible_host: 192.168.2.51
ansible_user: cisco
ansible_ssh_pass: cisco
ansible_connection: network_cli
ansible_network_os: ios
ansbile_become: yes
ansible_become_method: enable
ansible_become_pass: cisco
</code></pre>
    <p class="normal">This file is in YAML format (<a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html"><span class="url">https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html</span></a>). The ‘---’ symbol indicates the start of the document. Below the start symbol, we have many key-value pairs. The keys all start with <code class="inlineCode">ansible</code> and the value is separated from the key with a colon. The <code class="inlineCode">ansible_host</code>, <code class="inlineCode">ansible_user</code>, and <code class="inlineCode">ansible_ssh_pass</code> should be changed to values matching your own lab. How do I know these names? Ansible documentation is our best friend here. Ansible has a standard way of naming these parameters listed in its documentation, <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html"><span class="url">https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html</span></a>. </p>
    <div class="note">
      <p class="normal">Prior to Ansible 2.8, network modules did not have a standard way of naming the parameters, which is very confusing. Since version 2.8, the network modules have become much better at standardizing the parameters with the rest of the Ansible modules.</p>
    </div>
    <p class="normal">Once we have defined the respective files for the host variables, we are ready to construct an Ansible playbook. </p>
    <h3 class="heading-3" id="_idParaDest-115">Our First Playbook</h3>
    <p class="normal">Playbooks <a id="_idIndexMarker314"/>are Ansible’s blueprint to describe what you <a id="_idIndexMarker315"/>would like to do to the managed nodes, using modules. This is where we will be spending the majority of our time as operators when working with Ansible. What are modules? In a simplified view, modules are pre-built codes that we can use to accomplish a certain task. Similar to Python modules, the code can come with the default Ansible installation or it can be installed separately. </p>
    <p class="normal">If we use an analogy of building a tree house with Ansible, the playbook will be the instruction manual, the modules will be the tools we use, and the inventory will be the components we work on.</p>
    <p class="normal">The playbook is designed to be human-readable in YAML format (<a href="https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html"><span class="url">https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html</span></a>). We will write our first playbook, named <code class="inlineCode">ios_config_backup.yml</code>, as follows: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Back</span> <span class="hljs-string">Up</span> <span class="hljs-string">IOS</span> <span class="hljs-string">Device</span> <span class="hljs-string">Configurations</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">all</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">backup</span>
      <span class="hljs-attr">ios_config:</span>
        <span class="hljs-attr">backup:</span> <span class="hljs-literal">yes</span>
</code></pre>
    <p class="normal">Note the <code class="inlineCode">-</code> in front of <code class="inlineCode">name</code>, it specifies a list item in YAML. Everything in the same list item should have the same indentation. We set <code class="inlineCode">gather_facts</code> to <code class="inlineCode">false</code> because most network tasks are executed locally before making the changes to the devices. The <code class="inlineCode">gather_facts</code> were mainly used when the managed nodes were servers to gather server information before any of the tasks were executed. </p>
    <p class="normal">There are two key-value pairs in the list item, <code class="inlineCode">hosts</code> and <code class="inlineCode">tasks</code>. The <code class="inlineCode">hosts</code> variable with the value of <code class="inlineCode">all</code> specifies that we will work on all the hosts in the inventory file. The <code class="inlineCode">tasks</code> key has another list item in the value, which uses the <code class="inlineCode">ios_config</code> module (<a href="https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios-config-module"><span class="url">https://docs.ansible.com/ansible/latest/collections/cisco/ios/ios_config_module.html#ansible-collections-cisco-ios-ios-config-module</span></a>). The <code class="inlineCode">ios_config</code> module is one of the collections of modules installed along with Ansible. It also has a variety of arguments. We use the <code class="inlineCode">backup</code> argument and set it to <code class="inlineCode">yes</code> to indicate we will back up the devices’ <code class="inlineCode">running-config</code>. </p>
    <p class="normal">The next task <a id="_idIndexMarker316"/>we will do is to use the new LibSSH connection plugin for Ansible. By default, Ansible network SSH connections use the Paramiko library. However, the Paramiko library does not guarantee FIPS readiness and is a bit slow when we need to connect to multiple devices. We will install LibSSH as follows: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ pip install ansible-pylibssh
</code></pre>
    <p class="normal">We will specify the usage in a new <code class="inlineCode">ansible.cfg</code> file. We will create the file in the same directory as our playbook with the following content. In the same configuration file, we will also set <code class="inlineCode">host_key_checking</code> to be <code class="inlineCode">false</code>; this is to prevent an error if the host is not initially in the <code class="inlineCode">known_hosts</code> list in the <code class="inlineCode">ssh</code> setup: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-section">[defaults]</span>
<span class="hljs-attr">host_key_checking</span> = <span class="hljs-literal">False</span> 
<span class="hljs-section">[persistent_connection]</span>
<span class="hljs-attr">ssh_type</span> = libssh
</code></pre>
    <p class="normal">Finally, we <a id="_idIndexMarker317"/>can execute the playbook via the <code class="inlineCode">ansible-playbook</code> command with the <code class="inlineCode">-i</code> switch to indicate the inventory file: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>ansible-playbook -i hosts ios_config_backup.yml 
PLAY [Back Up IOS Device Configurations] **************************************************************************************
TASK [backup] *****************************************************************************************************************
changed: [iosv-2]
changed: [iosv-1]
PLAY RECAP ********************************************************************************************************************
iosv-1                     : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
iosv-2                     : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
</code></pre>
    <p class="normal">Just like magic, if we take a look at our working directory where the playbook is executed, we<a id="_idIndexMarker318"/> will see a folder named <code class="inlineCode">backup</code> with the two devices’ running configurations with timestamps! This command can now be scheduled to run via <code class="inlineCode">cron</code> to run nightly to back up all of our devices’ configurations.</p>
    <p class="normal">Congratulations on executing your first Ansible playbook! Even with a playbook as simple as ours, this is a very useful automation task that we were able to accomplish in a short amount of time. We will expand on this playbook in just a bit, but first, let’s take a look at why Ansible is a good fit for network management. Remember that Ansible modules are written in Python; that is one advantage for a Pythonic network engineer, right?</p>
    <h1 class="heading-1" id="_idParaDest-116">The Advantages of Ansible</h1>
    <p class="normal">There are <a id="_idIndexMarker319"/>many infrastructure automation frameworks besides Ansible—namely Chef, Puppet, and SaltStack. Each framework offers its unique features; no one right framework fits all organizations. In this section, let’s take a look at some of the advantages of Ansible and why I believe it is a good tool for network automation.</p>
    <p class="normal">The advantages will be listed with limited comparison to other frameworks to not start a flame war. Other frameworks might adopt some of the same philosophies or certain aspects of Ansible, but rarely do they contain all of the features that I will be mentioning. It is the combination of all the following features and philosophies that makes Ansible ideal for network automation.</p>
    <h2 class="heading-2" id="_idParaDest-117">Agentless</h2>
    <p class="normal">Unlike<a id="_idIndexMarker320"/> some of its peers, Ansible does not require a strict master-client model. No software or agent needs to be installed on the client that communicates back to the server. Outside of the Python interpreter, which many platforms have by default, there is no additional software needed.</p>
    <p class="normal">For network automation modules, instead of relying on remote host agents, Ansible uses SSH or API calls to push the required changes to the remote host. This further reduces the need for a Python interpreter. This is huge for network device management, as network vendors are typically reluctant to put third-party software on their platforms. SSH, on the other hand, already exists on the network equipment. As we saw from <em class="chapterRef">Chapter 3</em>, <em class="italic">APIs and Intent-Driven Networking</em>, newer network devices also provide an API layer, which can also be leveraged by Ansible.</p>
    <p class="normal">Because <a id="_idIndexMarker321"/>there is no agent on the remote host, Ansible uses a <code class="inlineCode">push</code> model to push the changes to the device, as opposed to the <code class="inlineCode">pull</code> model, where the agent pulls the information from the master server. The <code class="inlineCode">push</code> model is more deterministic as everything originates from the control machine. In a <code class="inlineCode">pull</code> model, the timing of the <code class="inlineCode">pull</code> might vary from client to client and therefore results in timing variance.</p>
    <p class="normal">Again, the importance of being agentless cannot be stressed enough when working with the existing network equipment. This is usually one of the major reasons network operators and vendors embrace Ansible.</p>
    <h2 class="heading-2" id="_idParaDest-118">Idempotence</h2>
    <p class="normal">According to Wikipedia, idempotence<a id="_idIndexMarker322"/> is the property of certain operations in mathematics and computer science that can be applied multiple times without <a id="_idIndexMarker323"/>changing the result beyond the initial application (<a href="https://en.wikipedia.org/wiki/Idempotence"><span class="url">https://en.wikipedia.org/wiki/Idempotence</span></a>). In more common terms, it means that running the same procedure repeatedly does not change a system after the first time. Ansible aims to be idempotent, which is good for network operations that require a certain order of operations. In our first playbook example, there is a ‘changed’ value when the playbook is run; this value will be ‘false’ if there was no change made on the remote device. </p>
    <p class="normal">The <a id="_idIndexMarker324"/>advantage of idempotence is best compared to the Pexpect and Paramiko scripts we have written. Remember that these scripts were written to push out commands like an engineer was sitting at the terminal. If you were to execute the script 10 times, the script would make the same changes 10 times. If we write the same task via the Ansible playbook, the existing device configuration will be checked first, and the playbook will only execute if the changes do not exist. If we execute the playbook 10 times, the change will only be applied during the first run, with the next 9 runs suppressing the configuration change.</p>
    <p class="normal">Being idempotent, we can repeatedly execute the playbook without worrying that there will be unnecessary changes <a id="_idIndexMarker325"/>made. This is important as we need to automatically check for state consistency without extra overhead.</p>
    <h2 class="heading-2" id="_idParaDest-119">Simple and Extensible</h2>
    <p class="normal">Ansible is written<a id="_idIndexMarker326"/> in Python and uses YAML for the playbook language, both of which are relatively easy to learn. Remember the Cisco IOS syntax? This is a domain-specific language that is only applicable when you are managing Cisco IOS devices or other similarly structured equipment; it is not a general-purpose language beyond its limited scope. Luckily, unlike some other automation tools, there is no extra <strong class="keyWord">domain-specific language </strong>(<strong class="keyWord">DSL</strong>) to learn for Ansible because YAML and Python are both widely used as general-purpose languages.</p>
    <p class="normal">Ansible<a id="_idIndexMarker327"/> is extensible. As illustrated by the preceding example, Ansible starts with automating server (primarily Linux) workloads in mind. It then branches out to manage Windows machines with PowerShell. As more and more people in the network industry have started to adopt Ansible, network automation is now the main staple in Ansible workgroups. </p>
    <p class="normal">The simplicity and extensibility speak well for future-proofing. The technology world is evolving fast, and we are constantly trying to adapt. Wouldn’t it be great to learn a technology once and continue to use it, regardless of the latest trend? Ansible’s track record speaks well for future technology adaptation.</p>
    <p class="normal">Now that we’ve covered some of the advantages of Ansible, let’s build on what we have learned so far with more features. </p>
    <h1 class="heading-1" id="_idParaDest-120">Ansible Content Collections</h1>
    <p class="normal">Let’s start by listing<a id="_idIndexMarker328"/> out all the modules we have at hand with the default Ansible installation. They<a id="_idIndexMarker329"/> are organized into Content Collections (<a href="https://www.ansible.com/products/content-collections"><span class="url">https://www.ansible.com/products/content-collections</span></a>), sometimes called collections for abbreviation. We can list out the collections via the <code class="inlineCode">ansible-galaxy collection list</code> command. Some of the notable network collections are listed out below: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-galaxy collection list
<span class="hljs-con-meta"># </span>/home/echou/Mastering_Python_Networking_Fourth_Edition/venv/lib/python3.10/site-packages/ansible_collections
Collection                    Version
----------------------------- -------
…
ansible.netcommon             3.1.0  
arista.eos                    5.0.1  
cisco.aci                     2.2.0  
cisco.asa                     3.1.0  
cisco.dnac                    6.5.3  
cisco.intersight              1.0.19 
cisco.ios                     3.3.0  
cisco.iosxr                   3.3.0  
cisco.ise                     2.5.0  
cisco.meraki                  2.10.1 
cisco.mso                     2.0.0  
cisco.nso                     1.0.3  
cisco.nxos                    3.1.0  
cisco.ucs                     1.8.0  
community.ciscosmb            1.0.5  
community.fortios             1.0.0  
community.network             4.0.1  
dellemc.enterprise_sonic      1.1.1  
f5networks.f5_modules         1.19.0 
fortinet.fortimanager         2.1.5  
fortinet.fortios              2.1.7  
mellanox.onyx                 1.0.0   
openstack.cloud               1.8.0  
openvswitch.openvswitch       2.1.0  
vyos.vyos                     3.0.1  
</code></pre>
    <p class="normal">As shown from the list, even<a id="_idIndexMarker330"/> with the default installation, there is a large collection of network-related modules we can use. They range from enterprise software to open-source projects. Taking a look at the list and reading up on the ones that are of interest in your production environment would be a good start. Ansible documentation also provides a full list of all the available collections, <a href="https://docs.ansible.com/ansible/latest/collections/index.html"><span class="url">https://docs.ansible.com/ansible/latest/collections/index.html</span></a>. The collections can also be expanded via the <code class="inlineCode">agalaxy</code> <code class="inlineCode">install</code> command, <a href="https://docs.ansible.com/ansible/latest/user_guide/collections_using.html"><span class="url">https://docs.ansible.com/ansible/latest/user_guide/collections_using.html</span></a>. </p>
    <h1 class="heading-1" id="_idParaDest-121">More Ansible Network Examples </h1>
    <p class="normal">Our first <a id="_idIndexMarker331"/>Ansible network example took us from being a noob to running our first useful network automation task. Let’s try to build from the foundation and learn more features. </p>
    <p class="normal">We will begin by seeing how we can build an inventory file that includes all of our network devices. If you recall, we have two data centers, each with core and edge devices: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_04_05.png"/></figure>
    <p class="packt_figref">Figure 4.5: Full Lab Topology</p>
    <p class="normal">In this example, we will include all of the devices in our inventory file. </p>
    <h2 class="heading-2" id="_idParaDest-122">Inventory Nesting</h2>
    <p class="normal">We can <a id="_idIndexMarker332"/>build an inventory file that includes nesting. For example, we can put together a host file named <code class="inlineCode">hosts_full</code> that includes children from one group to another: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-string">[lax_cor_devices]</span>
lax-cor-r1
<span class="hljs-string">[lax_edg_devices]</span>
lax-edg-r1
lax-edg-r2
<span class="hljs-string">[nyc_cor_devices]</span>
nyc-cor-r1
<span class="hljs-string">[nyc_edg_devices]</span>
nyc-edg-r1
nyc-edg-r2
<span class="hljs-string">[lax_dc:children]</span>
lax_cor_devices
lax_edg_devices
<span class="hljs-string">[nyc_dc:children]</span>
nyc_cor_devices
nyc_edg_devices
<span class="hljs-string">[ios_devices:children]</span>
lax_edg_devices
nyc_edg_devices
<span class="hljs-string">[nxos_devices:children]</span>
nyc_cor_devices
lax_cor_devices
</code></pre>
    <p class="normal">In the file, we<a id="_idIndexMarker333"/> group the devices via both roles and features using the <code class="inlineCode">[&lt;name&gt;:children]</code> format. To work with this new inventory file, we will need to update the <code class="inlineCode">host_vars</code> directory to include the respective names of the devices: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ tree host_vars/
host_vars/
…
├── lax-cor-r1
├── lax-edg-r1
├── lax-edg-r2
├── nyc-cor-r1
├── nyc-edg-r1
└── nyc-edg-r2 
</code></pre>
    <p class="normal">We will also need to change the <code class="inlineCode">ansible_host</code> and <code class="inlineCode">ansible_network_os</code> accordingly, using <code class="inlineCode">lax-cor-r1</code> as an example:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ cat host_vars/lax-cor-r1 
---
ansible_host: 192.168.2.50
…
ansible_network_os: nxos
…
</code></pre>
    <p class="normal">Now we can <a id="_idIndexMarker334"/>use the parent’s group name to include its children. For example, in the <code class="inlineCode">nxos_config_backup.yml</code> playbook, we only specified the parent group of <code class="inlineCode">nxos_devices</code> instead of <code class="inlineCode">all</code>: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Back</span> <span class="hljs-string">Up</span> <span class="hljs-string">NX-OS</span> <span class="hljs-string">Device</span> <span class="hljs-string">Configurations</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">nxos_devices</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">backup</span>
      <span class="hljs-attr">nxos_config:</span>
        <span class="hljs-attr">backup:</span> <span class="hljs-literal">yes</span>
</code></pre>
    <p class="normal">When we execute this playbook, it will automatically include its children, <code class="inlineCode">lax_cor_devices</code> and <code class="inlineCode">nyc_cor_devices</code>. Also note that we use a separate <code class="inlineCode">nxos_config</code> module (<a href="https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module"><span class="url">https://docs.ansible.com/ansible/latest/collections/cisco/nxos/nxos_config_module.html#ansible-collections-cisco-nxos-nxos-config-module</span></a>) to accommodate the new device type. </p>
    <h2 class="heading-2" id="_idParaDest-123">Ansible Conditionals</h2>
    <p class="normal">Ansible conditionals <a id="_idIndexMarker335"/>are similar to conditional statements in programming languages. Ansible uses conditional keywords to only run a task when a given condition is met. In many cases, the execution of a play or task may depend on the value of a fact, variable, or the previous task result. For example, if you have a play to upgrade router images, you want to include a step to make sure the new router image is on the device before you move on to the next play of rebooting the router.</p>
    <p class="normal">In this example, we will look at the <code class="inlineCode">when</code> clause, which is supported for all modules. The <code class="inlineCode">when</code> clause is useful when you need to check the output of a variable or a play execution result and act accordingly. Some of the conditions are as follows:</p>
    <ul>
      <li class="bulletList">Equal to (<code class="inlineCode">eq</code>)</li>
      <li class="bulletList">Not equal to (<code class="inlineCode">neq</code>)</li>
      <li class="bulletList">Greater than (<code class="inlineCode">gt</code>)</li>
      <li class="bulletList">Greater than or equal to (<code class="inlineCode">ge</code>)</li>
      <li class="bulletList">Less than (<code class="inlineCode">lt</code>)</li>
      <li class="bulletList">Less than or equal to (<code class="inlineCode">le</code>)</li>
      <li class="bulletList">Contains</li>
    </ul>
    <p class="normal">Let’s take a look <a id="_idIndexMarker336"/>at the following playbook named <code class="inlineCode">ios_conditional.yml</code>: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">IOS</span> <span class="hljs-string">command</span> <span class="hljs-string">output</span> <span class="hljs-string">for</span> <span class="hljs-string">when</span> <span class="hljs-string">clause</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">ios_devices</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">show</span> <span class="hljs-string">hostname</span>
      <span class="hljs-attr">ios_command:</span>
        <span class="hljs-attr">commands:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">show</span> <span class="hljs-string">run</span> <span class="hljs-string">|</span> <span class="hljs-string">i</span> <span class="hljs-string">hostname</span>
      <span class="hljs-attr">register:</span> <span class="hljs-string">output</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">show</span> <span class="hljs-string">output</span> <span class="hljs-string">with</span> <span class="hljs-string">when</span> <span class="hljs-string">conditions</span>
      <span class="hljs-attr">when:</span> <span class="hljs-string">output.stdout</span> <span class="hljs-string">==</span> [<span class="hljs-string">"hostname nyc-edg-r2"</span>]
      <span class="hljs-attr">debug:</span> 
        <span class="hljs-attr">msg:</span> <span class="hljs-string">'</span><span class="hljs-template-variable">{{ output }}</span><span class="hljs-string">'</span>
</code></pre>
    <p class="normal">In the playbook, there are two tasks. In the first task, we use the <code class="inlineCode">register</code> module to save the output of the command <code class="inlineCode">show</code> <code class="inlineCode">run</code> | <code class="inlineCode">i hostname</code> in a variable called <code class="inlineCode">output</code>. The <code class="inlineCode">output</code> variable contains a <code class="inlineCode">stdout</code> list with the output. We use the <code class="inlineCode">when</code> clause to only show the output when the hostname is <code class="inlineCode">nyc-edg-r2</code>. Let’s execute the playbook: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts_full ios_conditional.yml 
PLAY [IOS command output for when clause] *************************************************************************************
TASK [show hostname] **********************************************************************************************************
ok: [lax-edg-r1]
ok: [nyc-edg-r2]
ok: [lax-edg-r2]
ok: [nyc-edg-r1]
TASK [show output with when conditions] ***************************************************************************************
skipping: [lax-edg-r1]
skipping: [lax-edg-r2]
skipping: [nyc-edg-r1]
ok: [nyc-edg-r2] =&gt; {
    "msg": {
        "changed": false,
        "failed": false,
        "stdout": [
            "hostname nyc-edg-r2"
        ],
        "stdout_lines": [
            [
                "hostname nyc-edg-r2"
            ]
        ]
    }
}
PLAY RECAP ********************************************************************************************************************
lax-edg-r1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
lax-edg-r2                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
nyc-edg-r1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
nyc-edg-r2                 : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker337"/>see the output of <code class="inlineCode">lax-edg-r1</code>, <code class="inlineCode">lax-edg-r2</code>, and <code class="inlineCode">nyc-edg-r1</code> were skipped because they did not meet the condition. Furthermore, we can see the <code class="inlineCode">changed=0</code> output for all the devices. This is in accordance with the idempotency feature of Ansible. </p>
    <h2 class="heading-2" id="_idParaDest-124">Configuration Change</h2>
    <p class="normal">We can <a id="_idIndexMarker338"/>combine the conditional with configuration changes—for example, in the following playbook, <code class="inlineCode">ios_conditional_config.yml</code>: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">IOS</span> <span class="hljs-string">command</span> <span class="hljs-string">output</span> <span class="hljs-string">for</span> <span class="hljs-string">when</span> <span class="hljs-string">clause</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">ios_devices</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">show</span> <span class="hljs-string">hostname</span>
      <span class="hljs-attr">ios_command:</span>
        <span class="hljs-attr">commands:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">show</span> <span class="hljs-string">run</span> <span class="hljs-string">|</span> <span class="hljs-string">i</span> <span class="hljs-string">hostname</span>
      <span class="hljs-attr">register:</span> <span class="hljs-string">output</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">show</span> <span class="hljs-string">output</span> <span class="hljs-string">with</span> <span class="hljs-string">when</span> <span class="hljs-string">conditions</span>
      <span class="hljs-attr">when:</span> <span class="hljs-string">output.stdout</span> <span class="hljs-string">==</span> [<span class="hljs-string">"hostname nyc-edg-r2"</span>]
      <span class="hljs-attr">ios_config:</span> 
        <span class="hljs-attr">lines:</span> 
            <span class="hljs-bullet">-</span> <span class="hljs-string">logging</span> <span class="hljs-string">buffered</span> <span class="hljs-number">30000</span>
</code></pre>
    <p class="normal">We would only change the logging buffer when the condition is met. Here is the output when we execute the playbook for the first time: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts_full ios_conditional_config.yml 
&lt;skip&gt;
TASK [show output with when conditions] ***************************************************************************************
skipping: [lax-edg-r1]
skipping: [lax-edg-r2]
skipping: [nyc-edg-r1]
[WARNING]: To ensure idempotency and correct diff the input configuration lines should be similar to how they appear if
present in the running configuration on device
changed: [nyc-edg-r2]
PLAY RECAP ********************************************************************************************************************
lax-edg-r1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
lax-edg-r2                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
nyc-edg-r1                 : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
nyc-edg-r2                 : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
    <p class="normal">The <code class="inlineCode">nyc-edg-r2</code> device console will show the configuration is changed: </p>
    <pre class="programlisting con"><code class="hljs-con">*Sep 10 01:53:43.132: %SYS-5-LOG_CONFIG_CHANGE: Buffer logging: level debugging, xml disabled, filtering disabled, size (30000)
</code></pre>
    <p class="normal">However, when<a id="_idIndexMarker339"/> we run the playbook for the second time, the same change is NOT applied again because it is already changed: </p>
    <pre class="programlisting con"><code class="hljs-con">&lt;skip&gt;
TASK [show output with when conditions] ***************************************************************************************
skipping: [lax-edg-r1]
skipping: [lax-edg-r2]
skipping: [nyc-edg-r1]
ok: [nyc-edg-r2]
</code></pre>
    <p class="normal">How cool is that? With a simple playbook, we can safely apply a configuration change to only the devices we want to apply the change to with idempotency in check. </p>
    <h2 class="heading-2" id="_idParaDest-125">Ansible Network Facts</h2>
    <p class="normal">Prior to 2.5, Ansible networking shipped with a number of vendor-specific fact modules. As a result, the<a id="_idIndexMarker340"/> naming and usage of the facts were different between vendors. Starting with version 2.5, Ansible started to standardize its network fact modules. The Ansible network fact modules gather information from a system and store the results in facts prefixed with <code class="inlineCode">ansible_net_</code>. The data collected by these modules is documented in the <em class="italic">return values</em> in the module documentation. This is useful as we can gather network facts and only perform tasks based on them. </p>
    <p class="normal">As an example of the <code class="inlineCode">ios_facts</code> module, below is the content of the <code class="inlineCode">ios_facts_playbook</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">IOS</span> <span class="hljs-string">network</span> <span class="hljs-string">facts</span>
  <span class="hljs-attr">connection:</span> <span class="hljs-string">network_cli</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">ios_devices</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Gathering</span> <span class="hljs-string">facts</span> <span class="hljs-string">via</span> <span class="hljs-string">ios_facts</span> <span class="hljs-string">module</span>
      <span class="hljs-attr">ios_facts:</span>
      <span class="hljs-attr">when:</span> <span class="hljs-string">ansible_network_os</span> <span class="hljs-string">==</span> <span class="hljs-string">'ios'</span>
    
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Display</span> <span class="hljs-string">certain</span> <span class="hljs-string">facts</span>
      <span class="hljs-attr">debug:</span> 
        <span class="hljs-attr">msg:</span> <span class="hljs-string">"The hostname is </span><span class="hljs-template-variable">{{ ansible_net_hostname }}</span><span class="hljs-string"> running </span><span class="hljs-template-variable">{{ ansible_net_version }}</span><span class="hljs-string">"</span>
    
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Display</span> <span class="hljs-string">all</span> <span class="hljs-string">facts</span> <span class="hljs-string">for</span> <span class="hljs-string">hosts</span>
      <span class="hljs-attr">debug:</span>
        <span class="hljs-attr">var:</span> <span class="hljs-string">hostvars</span>
</code></pre>
    <p class="normal">We are<a id="_idIndexMarker341"/> introducing a concept of variables in this playbook. The double curly brackets of <code class="inlineCode">{{ }}</code> indicates it is a variable and the value of the variable should be presented for the output. </p>
    <p class="normal">Upon execution of the playbook, here is a partial output:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts_full ios_facts_playbook.yml
…
TASK [Display certain facts] ***************************************************
ok: [lax-edg-r1] =&gt; {
    "msg": "The hostname is lax-edg-r1 running 15.8(3)M2"
}
ok: [lax-edg-r2] =&gt; {
    "msg": "The hostname is lax-edg-r2 running 15.8(3)M2"
}
ok: [nyc-edg-r1] =&gt; {
    "msg": "The hostname is nyc-edg-r1 running 15.8(3)M2"
}
ok: [nyc-edg-r2] =&gt; {
    "msg": "The hostname is nyc-edg-r2 running 15.8(3)M2"
}
…
TASK [Display all facts for hosts] *********************************************
ok: [lax-edg-r1] =&gt; {
    "hostvars": {
        "lax-cor-r1": {
…
            "ansible_facts": {
                "net_api": "cliconf",
                "net_gather_network_resources": [],
                "net_gather_subset": [
                    "default"
                ],
                "net_hostname": "lax-edg-r1",
                "net_image": "flash0:/vios-adventerprisek9-m",
                "net_iostype": "IOS",
                "net_model": "IOSv",
                "net_python_version": "3.10.4",
                "net_serialnum": "98U40DKV403INHIULHYHB",
                "net_system": "ios",
                "net_version": "15.8(3)M2",
                "network_resources": {}
            },
…
</code></pre>
    <p class="normal">We can now leverage <a id="_idIndexMarker342"/>the facts to combine with our conditional clause to customize our operations. </p>
    <h2 class="heading-2" id="_idParaDest-126">Ansible Loops</h2>
    <p class="normal">Ansible provides a<a id="_idIndexMarker343"/> number of looping functions in <a id="_idIndexMarker344"/>the playbook: standard loops, looping over files, sub-elements, <code class="inlineCode">do-until</code>, and many more. In this section, we will look at two of the most commonly used loop forms: standard loops and looping over hash values.</p>
    <h3 class="heading-3" id="_idParaDest-127">Standard Loops </h3>
    <p class="normal">Standard loops<a id="_idIndexMarker345"/> in playbooks are often used to easily perform<a id="_idIndexMarker346"/> similar tasks multiple times. The syntax for standard loops is very easy: the <code class="inlineCode">{{ item }}</code> variable is the placeholder looping over the <code class="inlineCode">loop</code> list. In our next example, <code class="inlineCode">standard_loop.yml</code>, we will loop over the items in the <code class="inlineCode">loop</code> list with the <code class="inlineCode">echo</code> command showing the output from our <code class="inlineCode">localhost</code>.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Echo</span> <span class="hljs-string">Loop</span> <span class="hljs-string">Items</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">"localhost"</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">echo</span> <span class="hljs-string">loop</span> <span class="hljs-string">items</span>
      <span class="hljs-attr">command:</span> <span class="hljs-string">echo</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ item }}</span><span class="hljs-string">"</span>
      <span class="hljs-attr">loop:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'r1'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'r2'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'r3'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'r4'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">'r5'</span>
</code></pre>
    <p class="normal">Let’s go ahead<a id="_idIndexMarker347"/> and execute the playbook:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts_full standard_loop.yml 
PLAY [Echo Loop Items] ********************************************************************************************************
TASK [echo loop items] ********************************************************************************************************
changed: [localhost] =&gt; (item=r1)
changed: [localhost] =&gt; (item=r2)
changed: [localhost] =&gt; (item=r3)
changed: [localhost] =&gt; (item=r4)
changed: [localhost] =&gt; (item=r5)
PLAY RECAP ********************************************************************************************************************
localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0
</code></pre>
    <p class="normal">Using the <a id="_idIndexMarker348"/>same concept, we can systematically add VLANs to our devices. Here is an example of adding three VLANs to a host with a playbook titled <code class="inlineCode">standard_loop_vlan_example.yml</code>: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">Multiple</span> <span class="hljs-string">Vlans</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">"nyc-cor-r1"</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">connection:</span> <span class="hljs-string">network_cli</span>
  <span class="hljs-attr">vars:</span>
    <span class="hljs-attr">vlan_numbers:</span> [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>]
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">add</span> <span class="hljs-string">vlans</span>
      <span class="hljs-attr">nxos_config:</span>
        <span class="hljs-attr">lines:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">vlan</span> {{ <span class="hljs-string">item</span> }}
      <span class="hljs-attr">loop:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ vlan_numbers }}</span><span class="hljs-string">"</span>
      <span class="hljs-attr">register:</span> <span class="hljs-string">output</span>
</code></pre>
    <p class="normal">The playbook<a id="_idIndexMarker349"/> output is as follows: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts_full standard_loop
_vlan_example.yml 
PLAY [Add Multiple Vlans] *****************************************************************************************************
TASK [add vlans] **************************************************************************************************************
changed: [nyc-cor-r1] =&gt; (item=100)
changed: [nyc-cor-r1] =&gt; (item=200)
changed: [nyc-cor-r1] =&gt; (item=300)
[WARNING]: To ensure idempotency and correct diff the input configuration lines should be similar to how they appear if
present in the running configuration on device
PLAY RECAP ********************************************************************************************************************
nyc-cor-r1                 : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
    <p class="normal">As we can see <a id="_idIndexMarker350"/>from the playbook, the loop list can be read from a variable, which gives greater flexibility to the structure of your playbook:</p>
    <pre class="programlisting code"><code class="hljs-code">… 
<span class="hljs-symbol"> vars:</span>
<span class="hljs-symbol">    vlan_numbers:</span> [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>]
<span class="hljs-symbol">  tasks:</span>
    …
<span class="hljs-symbol">     loop:</span> "<span class="hljs-punctuation">{{</span> vlan_numbers <span class="hljs-punctuation">}}</span>"
</code></pre>
    <p class="normal">The standard loop is a great time saver when it comes to performing redundant tasks in a playbook. Let us see how we can loop over a dictionary in the next section. </p>
    <h3 class="heading-3" id="_idParaDest-128">Looping over Dictionaries</h3>
    <p class="normal">When we need <a id="_idIndexMarker351"/>to generate a configuration, we <a id="_idIndexMarker352"/>often have an entity with more than one attribute associated with it. If you think about the VLAN example in the last section, each VLAN would have several unique attributes, such as a description, a gateway IP address, and possibly others. Often, we can use a dictionary to represent the entity to incorporate multiple attributes into it.</p>
    <p class="normal">Let’s expand on the previous example to include a dictionary variable in <code class="inlineCode">standard_loop_vlan_example_2.yml</code>. We defined the dictionary values for three <code class="inlineCode">vlan</code> each with a nested dictionary for the description and the IP address:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">Multiple</span> <span class="hljs-string">Vlans</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">"</span><span class="hljs-string">nyc-cor-r1"</span>
  <span class="hljs-attr">gather_facts:</span> <span class="hljs-literal">false</span>
  <span class="hljs-attr">connection:</span> <span class="hljs-string">network_cli</span>
  <span class="hljs-attr">vars:</span>
    <span class="hljs-attr">vlans:</span> {
        <span class="hljs-attr">"100":</span> {<span class="hljs-attr">"description":</span> <span class="hljs-string">"floor_1"</span>, <span class="hljs-attr">"</span><span class="hljs-attr">ip":</span> <span class="hljs-string">"192.168.10.1"</span>},
        <span class="hljs-attr">"200":</span> {<span class="hljs-attr">"description":</span> <span class="hljs-string">"floor_2"</span>, <span class="hljs-attr">"ip":</span> <span class="hljs-string">"192.168.20.1"</span>},
        <span class="hljs-attr">"300":</span> {<span class="hljs-attr">"description":</span> <span class="hljs-string">"floor_3"</span>, <span class="hljs-attr">"</span><span class="hljs-attr">ip":</span> <span class="hljs-string">"192.168.30.1"</span>}
      }
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">add</span> <span class="hljs-string">vlans</span>
      <span class="hljs-attr">nxos_config:</span>
        <span class="hljs-attr">lines:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">vlan</span> {{ <span class="hljs-string">item.key</span> }}
      <span class="hljs-attr">with_dict:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ vlans }}</span><span class="hljs-string">"</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">configure</span> <span class="hljs-string">vlans</span>
      <span class="hljs-attr">nxos_config:</span>
        <span class="hljs-attr">lines:</span> 
          <span class="hljs-bullet">-</span> <span class="hljs-string">description</span> {{ <span class="hljs-string">item.value.description</span> }}
          <span class="hljs-bullet">-</span> <span class="hljs-string">ip</span> <span class="hljs-string">address</span> {{ <span class="hljs-string">item.value.ip</span> }}<span class="hljs-string">/24</span>
        <span class="hljs-attr">parents:</span> <span class="hljs-string">interface</span> <span class="hljs-string">vlan</span> {{ <span class="hljs-string">item.key</span> }}
      <span class="hljs-attr">with_dict:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ vlans }}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">In the playbook, we configure the first task to add the VLANs by using the key of the items. In the second task, we proceed with configuring the VLAN interfaces using the values within each of the items. Note that we use the <code class="inlineCode">parents</code> parameter to uniquely identify the section the commands should be checked against. This is due to the fact that the description and the IP address are both configured under the <code class="inlineCode">interface vlan &lt;number&gt;</code> subsection in the configuration.</p>
    <p class="normal">Before we execute<a id="_idIndexMarker353"/> the command, we need to make<a id="_idIndexMarker354"/> sure the layer 3 interface feature is enabled on the <code class="inlineCode">nyc-cor-r1</code> device:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">nyc-cor-r1(config)# </span>feature interface-vlan
</code></pre>
    <p class="normal">We can run the playbook as we have done previously. We can see the dictionary being looped through: </p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts_full standard_loop_vlan_example_2.yml 
PLAY [Add Multiple Vlans] ************************************************************************************************
TASK [add vlans] *********************************************************************************************************
changed: [nyc-cor-r1] =&gt; (item={'key': '100', 'value': {'description': 'floor_1', 'ip': '192.168.10.1'}})
changed: [nyc-cor-r1] =&gt; (item={'key': '200', 'value': {'description': 'floor_2', 'ip': '192.168.20.1'}})
changed: [nyc-cor-r1] =&gt; (item={'key': '300', 'value': {'description': 'floor_3', 'ip': '192.168.30.1'}})
[WARNING]: To ensure idempotency and correct diff the input configuration lines should be similar to how they appear if
present in the running configuration on device
TASK [configure vlans] ***************************************************************************************************
changed: [nyc-cor-r1] =&gt; (item={'key': '100', 'value': {'description': 'floor_1', 'ip': '192.168.10.1'}})
changed: [nyc-cor-r1] =&gt; (item={'key': '200', 'value': {'description': 'floor_2', 'ip': '192.168.20.1'}})
changed: [nyc-cor-r1] =&gt; (item={'key': '300', 'value': {'description': 'floor_3', 'ip': '192.168.30.1'}})
PLAY RECAP ***************************************************************************************************************
nyc-cor-r1                 : ok=2    changed=2    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker355"/>verify the end result on the device: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">nyc-cor-r1# </span>sh run
interface Vlan100
  description floor_1
  ip address 192.168.10.1/24
interface Vlan200
  description floor_2
  ip address 192.168.20.1/24
interface Vlan300
  description floor_3
  ip address 192.168.30.1/24
</code></pre>
    <p class="normal">For more loop types of Ansible, feel free to check out the corresponding documentation (<a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html"><span class="url">https://docs.ansible.com/ansible/latest/user_guide/playbooks_loops.html</span></a>). </p>
    <p class="normal">Looping over dictionaries<a id="_idIndexMarker356"/> takes some practice the first few times you use them. But just like standard loops, looping over dictionaries will be an invaluable tool in our tool belt. An Ansible loop is a tool that can save us time and make the playbook more readable. In the next section, we will look at Ansible templates that allow us to make systematic changes to text files commonly used for network device configuration.</p>
    <h2 class="heading-2" id="_idParaDest-129">Templates</h2>
    <p class="normal">Ever<a id="_idIndexMarker357"/> since I started working as a network engineer, I have<a id="_idIndexMarker358"/> always used some kind of network templating system. In my experience, many of the network devices have sections of the network configuration that are identical, especially if these devices serve the same role in the network.</p>
    <p class="normal">Most of the time, when we need to provision a new device, we use the same configuration in the form of a template, replace the necessary fields, and copy the file over to the new device. With Ansible, you can automate all of the work by using the templating feature (<a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_templating.html"><span class="url">https://docs.ansible.com/ansible/latest/user_guide/playbooks_templating.html</span></a>).</p>
    <p class="normal">Ansible uses <a id="_idIndexMarker359"/>Jinja (<a href="https://jinja.palletsprojects.com/en/3.1.x/"><span class="url">https://jinja.palletsprojects.com/en/3.1.x/</span></a>) templating to enable dynamic expressions and access to variables and facts. Jinja has its own syntax and method of <a id="_idIndexMarker360"/>doing loops and conditionals; fortunately, we just need to know the very basics of it for our purpose. The Ansible template module is an important tool that we will be using in our daily tasks, and we will spend more of this section exploring it. We will learn the syntax by gradually building up our playbook from some simple tasks to more complex ones.</p>
    <p class="normal">The basic syntax for <a id="_idIndexMarker361"/>template usage is very simple; we just need to specify the source file and the destination location that we want to copy it to.</p>
    <p class="normal">Let us create a new directory called <code class="inlineCode">Templates</code> and start to create our playbooks. We will create an empty file for now:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ mkdir Templates
(venv) $ cd Templates/
(venv) $ touch file1
</code></pre>
    <p class="normal">Then we will use the following playbook, <code class="inlineCode">template_1.yml</code>, to copy <code class="inlineCode">file1</code> to <code class="inlineCode">file2</code>. Note that the playbook is executed on the control machine only:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Template</span> <span class="hljs-string">Basic</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">localhost</span>
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">copy</span> <span class="hljs-string">one</span> <span class="hljs-string">file</span> <span class="hljs-string">to</span> <span class="hljs-string">another</span>
      <span class="hljs-attr">template:</span>
        <span class="hljs-string">src=/home/echou/Mastering_Python_Networking_Fourth_Edition/Chapter04/Templates/file1</span>
        <span class="hljs-string">dest=/home/echou/Mastering_Python_Networking_Fourth_Edition/Chapter04/Templates/file2</span>
</code></pre>
    <p class="normal">Executing the playbook will create a new file:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts template_1.yml 
PLAY [Template Basic] ****************************************************************************************************
TASK [Gathering Facts] ***************************************************************************************************
ok: [localhost]
TASK [copy one file to another] ******************************************************************************************
changed: [localhost]
PLAY RECAP ***************************************************************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
(venv) $ ls file*
file1  file2
</code></pre>
    <p class="normal">In our<a id="_idIndexMarker362"/> templates, the source files can have any extension, but <a id="_idIndexMarker363"/>since they are processed through the Jinja2 template engine, let’s create a text file called <code class="inlineCode">nxos.j2</code> as the template source. The template will follow the Jinja convention of using double curly braces to specify the variables, as well as using the curly brace plus the percentage sign to specify commands:</p>
    <pre class="programlisting code"><code class="hljs-code">hostname <span class="hljs-template-variable">{{ item.value.hostname }}</span>
feature telnet
feature ospf
feature bgp
feature interface-vlan
<span class="hljs-template-tag">{% </span><span class="hljs-name">if</span><span class="hljs-template-tag"> item.value.netflow_enable %}</span>
feature netflow
<span class="hljs-template-tag">{% </span><span class="hljs-name">endif</span><span class="hljs-template-tag"> %}</span>
username <span class="hljs-template-variable">{{ item.value.username }}</span> password <span class="hljs-template-variable">{{ item.value.password }}</span>  role network-operator
<span class="hljs-template-tag">{% </span><span class="hljs-name">for</span><span class="hljs-template-tag"> vlan_num </span><span class="hljs-keyword">in</span><span class="hljs-template-tag"> item.value.vlans %}</span>
vlan <span class="hljs-template-variable">{{ vlan_num }}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">endfor</span><span class="hljs-template-tag"> %}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">if</span><span class="hljs-template-tag"> item.value.l3_vlan_interfaces %}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">for</span><span class="hljs-template-tag"> vlan_interface </span><span class="hljs-keyword">in</span><span class="hljs-template-tag"> item.value.vlan_interfaces %}</span>
interface <span class="hljs-template-variable">{{ vlan_interface.int_num }}</span>
  ip address <span class="hljs-template-variable">{{ vlan_interface.ip }}</span>/24
<span class="hljs-template-tag">{% </span><span class="hljs-name">endfor</span><span class="hljs-template-tag"> %}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">endif</span><span class="hljs-template-tag"> %}</span>
</code></pre>
    <p class="normal">We can now <a id="_idIndexMarker364"/>put together <a id="_idIndexMarker365"/>a playbook to create network configuration templates based on the <code class="inlineCode">nxos.j2</code> file.</p>
    <h3 class="heading-3" id="_idParaDest-130">The Jinja Template Variables</h3>
    <p class="normal">The <code class="inlineCode">template_2.yml</code> playbook <a id="_idIndexMarker366"/>expands <a id="_idIndexMarker367"/>on the previous template example with the following additions:</p>
    <ul>
      <li class="bulletList">The source file is <code class="inlineCode">nxos.j2</code>.</li>
      <li class="bulletList">The destination filename is now a variable taken from the <code class="inlineCode">nexus_devices</code> variable defined in the playbook.</li>
      <li class="bulletList">Each of the devices within <code class="inlineCode">nexus_devices</code> contains the variables that would be substituted or looped over within the template.</li>
    </ul>
    <p class="normal">The playbook might look more complex than the last one, but if you take out the variable definition portion, it is very similar to our simple template playbook from earlier:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">---</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Template</span> <span class="hljs-string">Looping</span>
  <span class="hljs-attr">hosts:</span> <span class="hljs-string">localhost</span>
  <span class="hljs-attr">vars:</span>
    <span class="hljs-attr">nexus_devices:</span> {
        <span class="hljs-attr">"nx-osv-1":</span> {
            <span class="hljs-attr">"hostname":</span> <span class="hljs-string">"nx-osv-1"</span>,
            <span class="hljs-attr">"username":</span> <span class="hljs-string">"cisco"</span>,
            <span class="hljs-attr">"</span><span class="hljs-attr">password":</span> <span class="hljs-string">"cisco"</span>,
            <span class="hljs-attr">"vlans":</span> [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>],
            <span class="hljs-attr">"l3_vlan_interfaces":</span> <span class="hljs-literal">True</span>,
            <span class="hljs-attr">"vlan_interfaces":</span> [
                {<span class="hljs-attr">"int_num":</span> <span class="hljs-string">"</span><span class="hljs-string">100"</span>, <span class="hljs-attr">"ip":</span> <span class="hljs-string">"192.168.10.1"</span>},
                {<span class="hljs-attr">"int_num":</span> <span class="hljs-string">"200"</span>, <span class="hljs-attr">"ip":</span> <span class="hljs-string">"192.168.20.1"</span>},
                {<span class="hljs-attr">"int_num":</span> <span class="hljs-string">"300"</span>, <span class="hljs-attr">"ip":</span> <span class="hljs-string">"</span><span class="hljs-string">192.168.30.1"</span>}
            ],
            <span class="hljs-attr">"netflow_enable":</span> <span class="hljs-literal">True</span>
        },
        <span class="hljs-attr">"nx-osv-2":</span> {
            <span class="hljs-attr">"hostname":</span> <span class="hljs-string">"nx-osv-2"</span>,
            <span class="hljs-attr">"username":</span> <span class="hljs-string">"cisco"</span>,
            <span class="hljs-attr">"password":</span> <span class="hljs-string">"cisco"</span>,
            <span class="hljs-attr">"</span><span class="hljs-attr">vlans":</span> [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>],
            <span class="hljs-attr">"l3_vlan_interfaces":</span> <span class="hljs-literal">False</span>,
            <span class="hljs-attr">"netflow_enable":</span> <span class="hljs-literal">False</span>
        }
    }
  <span class="hljs-attr">tasks:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">create</span> <span class="hljs-string">router</span> <span class="hljs-string">configuration</span> <span class="hljs-string">files</span>
      <span class="hljs-attr">template:</span>
        <span class="hljs-string">src=/home/echou/Mastering_Python_Networking_Fourth_Edition/Chapter04/Templates/nxos.j2</span>
        <span class="hljs-string">dest=/home/echou/Mastering_Python_Networking_Fourth_Edition/Chapter04/Templates/{{</span> <span class="hljs-string">item.key</span> <span class="hljs-string">}}.conf</span>
      <span class="hljs-attr">with_dict:</span> <span class="hljs-string">"</span><span class="hljs-template-variable">{{ nexus_devices }}</span><span class="hljs-string">"</span>
</code></pre>
    <p class="normal">Let us not <a id="_idIndexMarker368"/>execute the playbook just yet; we still need<a id="_idIndexMarker369"/> to take a look at the <code class="inlineCode">if</code> conditional statements and <code class="inlineCode">for</code> loops enclosed within the <code class="inlineCode">{% %}</code> symbols from the <code class="inlineCode">Jinja2</code> template.</p>
    <h3 class="heading-3" id="_idParaDest-131">Jinja Template Loops</h3>
    <p class="normal">There <a id="_idIndexMarker370"/>are two <code class="inlineCode">for</code> loops in our <code class="inlineCode">nxos.j2</code> template; one <a id="_idIndexMarker371"/>loops over the VLANs and the other loops over the VLAN interfaces:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-template-tag">{% </span><span class="hljs-name">for</span><span class="hljs-template-tag"> vlan_num </span><span class="hljs-keyword">in</span><span class="hljs-template-tag"> item.value.vlans %}</span>
vlan <span class="hljs-template-variable">{{ vlan_num }}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">endfor</span><span class="hljs-template-tag"> %}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">if</span><span class="hljs-template-tag"> item.value.l3_vlan_interfaces %}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">for</span><span class="hljs-template-tag"> vlan_interface </span><span class="hljs-keyword">in</span><span class="hljs-template-tag"> item.value.vlan_interfaces %}</span>
interface <span class="hljs-template-variable">{{ vlan_interface.int_num }}</span>
  ip address <span class="hljs-template-variable">{{ vlan_interface.ip }}</span>/24
<span class="hljs-template-tag">{% </span><span class="hljs-name">endfor</span><span class="hljs-template-tag"> %}</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">endif</span><span class="hljs-template-tag"> %}</span>
</code></pre>
    <p class="normal">If you recall, we <a id="_idIndexMarker372"/>can also loop through a list as well as a dictionary in Jinja. In our example, the <code class="inlineCode">vlans</code> variable is a list, while the <code class="inlineCode">vlan_interfaces</code> variable is a list of dictionaries.</p>
    <p class="normal">The <code class="inlineCode">vlan_interfaces</code> loop is <a id="_idIndexMarker373"/>nested inside a conditional. This is the last thing that we will incorporate into our playbook before we execute the playbook.</p>
    <h3 class="heading-3" id="_idParaDest-132">Jinja Template Conditional</h3>
    <p class="normal">Jinja supports<a id="_idIndexMarker374"/> an <code class="inlineCode">if</code> conditional check. We have<a id="_idIndexMarker375"/> added this conditional statement in two locations within the <code class="inlineCode">nxos.j2</code> template; one is with the <code class="inlineCode">netflow</code> variable and the other is the <code class="inlineCode">l3_vlan_interfaces</code> variable. Only when the condition is <code class="inlineCode">True</code> will we execute the statements within the block:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">skip</span><span class="hljs-tag">&gt;</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">if</span><span class="hljs-template-tag"> item.value.netflow_enable %}</span>
feature netflow
<span class="hljs-template-tag">{% </span><span class="hljs-name">endif</span><span class="hljs-template-tag"> %}</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">skip</span><span class="hljs-tag">&gt;</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">if</span><span class="hljs-template-tag"> item.value.l3_vlan_interfaces %}</span>
<span class="hljs-tag">&lt;</span><span class="hljs-name">skip</span><span class="hljs-tag">&gt;</span>
<span class="hljs-template-tag">{% </span><span class="hljs-name">endif</span><span class="hljs-template-tag"> %}</span>
</code></pre>
    <p class="normal">In the playbook, we have declared <code class="inlineCode">netflow_enable</code> to be <code class="inlineCode">True</code> for <code class="inlineCode">nx-os-v1</code> and <code class="inlineCode">False</code> for <code class="inlineCode">nx-osv-2</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  vars: 
    nexus_devices: {
        <span class="hljs-string">"nx-osv-1"</span>: {
            &lt;<span class="hljs-keyword">skip</span>&gt;
            <span class="hljs-string">"netflow_enable"</span>: <span class="hljs-literal">True</span>
        },
        <span class="hljs-string">"nx-osv-2"</span>: {
            &lt;<span class="hljs-keyword">skip</span>&gt;
            <span class="hljs-string">"netflow_enable"</span>: <span class="hljs-literal">False</span>
        }
    }
</code></pre>
    <p class="normal">Finally, we are ready to run our playbook:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ ansible-playbook -i hosts template_2.yml 
PLAY [Template Looping] **************************************************************************************************
TASK [Gathering Facts] ***************************************************************************************************
ok: [localhost]
TASK [create router configuration files] *********************************************************************************
changed: [localhost] =&gt; (item={'key': 'nx-osv-1', 'value': {'hostname': 'nx-osv-1', 'username': 'cisco', 'password': 'cisco', 'vlans': [100, 200, 300], 'l3_vlan_interfaces': True, 'vlan_interfaces': [{'int_num': '100', 'ip': '192.168.10.1'}, {'int_num': '200', 'ip': '192.168.20.1'}, {'int_num': '300', 'ip': '192.168.30.1'}], 'netflow_enable': True}})
changed: [localhost] =&gt; (item={'key': 'nx-osv-2', 'value': {'hostname': 'nx-osv-2', 'username': 'cisco', 'password': 'cisco', 'vlans': [100, 200, 300], 'l3_vlan_interfaces': False, 'netflow_enable': False}})
PLAY RECAP ***************************************************************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
</code></pre>
    <p class="normal">Do you<a id="_idIndexMarker376"/> remember that the destination files are <a id="_idIndexMarker377"/>named after the <code class="inlineCode">{{ item.key }}.conf?</code> Two files have been created with the device names:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">ls</span> nx-os*
nx-osv-1.conf
nx-osv-2.conf
</code></pre>
    <p class="normal">Let’s check the similarities and differences of the two configuration files to make sure all of our intended changes are in place. Both files should contain the static items, such as <code class="inlineCode">feature ospf</code>, the hostnames<a id="_idIndexMarker378"/> and other variables should be substituted accordingly, and only <code class="inlineCode">nx-osv-1.conf</code> should have <code class="inlineCode">netflow</code> enabled as well as the layer 3 <code class="inlineCode">vlan</code> interface configuration:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> nx-osv-1.conf 
hostname nx-osv-1
feature telnet
feature ospf
feature bgp
feature interface-vlan
feature netflow
username cisco password cisco  role network-operator
vlan 100
vlan 200
vlan 300
interface 100
  ip address 192.168.10.1/24
interface 200
  ip address 192.168.20.1/24
interface 300
  ip address 192.168.30.1/24
</code></pre>
    <p class="normal">Let’s take a <a id="_idIndexMarker379"/>look at the <code class="inlineCode">nx-osv-2.conf</code> file: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> nx-osv-2.conf 
hostname nx-osv-2
feature telnet
feature ospf
feature bgp
feature interface-vlan
username cisco password cisco  role network-operator
vlan 100
vlan 200
vlan 300
</code></pre>
    <p class="normal">Neat, huh? This can certainly save us a ton of time for something that previously required repeated copying and pasting. Personally, the template module was a big game-changer for me. This module alone was enough to motivate me to learn and use Ansible a few years ago.</p>
    <h1 class="heading-1" id="_idParaDest-133">Summary</h1>
    <p class="normal">In this chapter, we took a grand tour of the open-source automation framework Ansible. Unlike Pexpect-based and API-driven network automation scripts, Ansible provides a higher layer of abstraction called a playbook to automate our network devices.</p>
    <p class="normal">Ansible is a full-featured automation framework capable of managing large infrastructures. Our focus is on managing network devices, but Ansible is capable of managing servers, databases, cloud infrastructures, and more. We have only touched the surface of its capabilities. If you feel Ansible is a tool you would like to learn more about, the Ansible documentation is an excellent source of reference. The Ansible community is friendly and welcoming if you would like to get involved. </p>
    <p class="normal">In <em class="chapterRef">Chapter 5</em>,<em class="chapterRef"> </em><em class="italic">Docker Containers for Network Engineers</em>, we will start to learn about Docker and the world of containers. </p>
    <h1 class="heading-1">Join our book community</h1>
    <p class="normal">To join our community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/networkautomationcommunity"><span class="url">https://packt.link/networkautomationcommunity</span></a></p>
    <p class="normal"><img alt="" src="../Images/QR_Code2903617220506617062.png"/></p>
  </div>
</body></html>