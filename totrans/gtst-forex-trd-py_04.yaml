- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trading Application: What’s Inside?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost any application that implements a trading strategy has a number of more
    or less standard components. Let’s first have a quick look at a somewhat generalized
    architecture of a typical trading application and then go into greater detail
    on specific points related to the development of a trading strategy using Python.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014)*, Developing Trading Strategies
    – Why They Are Different*, we saw a very generalized diagram of a typical trading
    application. Now, we are going to consider its blocks in greater detail. We will
    learn how to connect our application to data sources and trading venues, how to
    retrieve data and check its consistency, and consider important points about trading
    logic and orders.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to develop the main components
    of a trading application that is efficient, maintainable, and scalable, and how
    to avoid typical serious problems that arise due to incorrect market data processing,
    mistakes in trading logic, and insufficient understanding of the trade mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Have your app talk to the world – the gloomy world of communication protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data – garbage in, garbage out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trading logic – this is where a small mistake may cost a fortune
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk management – your safety belt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering interfaces – make sure you are understood correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need Python 3.9 or above to run the code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Have your app talk to the world – the gloomy world of communication protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, actually, in this section, I could just say, *“in the world of FX automated
    trading every setup is unique, so go ask your broker.”* Of course, I am not going
    to do this but when it comes to connecting your app to a market maker, **electronic
    communication network** (**ECN**), or any other trading venue, always keep in
    mind what I said at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: As you remember from the previous chapter, the FX market is still the most fragmented
    one from the trading standpoint; so there should be no surprise that its computerized
    infrastructure is also very fragmented. Even though there’s a standard for exchanging
    financial information, many trading venues use their own dialects, which simply
    means extra work in cases where you want to use your application with a different
    broker. At the same time, many trading venues offer their own APIs and protocols
    not compatible with anything else so developers never lose their jobs and are
    perpetually adapting their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Having said all that, let’s start with something that is generally considered
    the only industry standard for communication used in trading applications.
  prefs: []
  type: TYPE_NORMAL
- en: FIX – universal but too flexible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my opinion, despite its hard-to-read syntax, **financial information exchange**
    (**FIX**) is the best choice to start diving into trading communications because
    its messages can at least be read by a human – thus, debugging and learning our
    own mistakes will ensure the steepest learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, FIX is considered a protocol mostly for professional use and
    is not available out of the box to any trader from any broker. One of the possible
    reasons for this discrimination is that FIX allows you to send any instructions
    and the receiving server checks only syntax but not the meaning of the message.
    So, potentially, it may damage not only the trader’s account but even the market
    itself. Therefore, most of the biggest market makers, brokers, and banks require
    professional status from the trader to allow them to use FIX.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s good news: many smaller but ambitious FX brokers today offer
    a lot of formerly institutional-only services to retail traders. This doesn’t
    mean that the quality of their business is low: they simply need turnover and
    it’s clear that automated trading strategies generate it way better than manual
    traders. So, in reality, anyone can get access to institutional liquidity from
    an ECN using FIX.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, who knows, maybe one day you will find yourself working with a
    bank or an investment fund, and then even a general understanding of FIX will
    help you a lot to further your career.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is FIX anyway?
  prefs: []
  type: TYPE_NORMAL
- en: FIX is an attempt to create a really universal standard that could be used in
    virtually any situation when you need to transfer financial-related information.
    It is used by banks, brokers, information agencies, and even insurance companies,
    along with many others. Of course, such a wide variety of use cases assumes a
    great degree of flexibility to customize FIX the way you need, and this degree
    of flexibility paradoxically makes FIX less standard than it aimed to be.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some trading venues may require various tags (basic elements of
    the FIX protocol) as mandatory while others don’t. Some trading venues support
    limit and stop orders, while others acknowledge only market orders. So, it will
    require some refactoring if you want to port your trading app from one broker
    to another because FIX doesn’t *require* any particular order type to be accepted.
    The list may continue but, in essence, the problem is that FIX aims to support
    *any* market but trading venues use only a *subset* of its tags that are relevant
    to their market, frequently adapting the standard to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: I think that it’s best to consider FIX not only as a protocol or API but rather
    as a special language with a simple syntax that allows you to convey virtually
    any meaning. You can also consider it as a framework used to build messages rather
    than applications and the meaning of the message will depend on the context and
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at FIX as a protocol in the first place and consider its layers.
    It will help you understand the way we work with FIX connections.
  prefs: []
  type: TYPE_NORMAL
- en: Basic connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the transport layer, FIX requires a standard socket connection. Again, as
    I mentioned at the beginning of this section, everything is very individual because
    various brokers and trading venues may have different requirements for the way
    clients connect to them. Normally, you must provide the broker or the trading
    venue with an IP address (or range of addresses) to whitelist and connect using
    a **Transmission Control Protocol socket** (**TCP socket**). Others may require
    complex authorization mechanisms and even the mandatory use of a VPN. So, you
    may want to consult your broker or trading venue for details.
  prefs: []
  type: TYPE_NORMAL
- en: Learning basic low-level networking such as how to establish a socket connection
    in Python is not the goal of this book, so if you have never done that before
    I’d recommend starting with an excellent guide from Real Python ([https://realpython.com/python-sockets](https://realpython.com/python-sockets)),
    or if you prefer a *dive or swim* approach based on language in action with lots
    of live examples, you can watch this tutorial from Geeks for Geeks ([https://www.geeksforgeeks.org/socket-programming-python/](https://www.geeksforgeeks.org/socket-programming-python/)).
    The point is, establishing a socket connection in Python is not rocket science
    but rather a simple routine procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a socket connection is established, we’re ready to send and receive some
    meaningful information over it. As with many other protocols, FIX is based on
    messages. A FIX message is a plain text (ASCII) string that in turn consists of
    blocks (substrings) delimited by a non-printable character 0x01 (`SOH`) without
    any special ending characters such as `\n` or `\r`. Each block between delimiters
    follows a simple syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A **tag** is a number and its value can be any string that cannot contain the
    0x01 character for obvious reasons: it will be interpreted as a delimiter. There
    is one important exception though: in the case that the tag means retrieving data,
    any value used as data may be an arbitrary sequence of bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `55=EUR/USD` represents a currency pair, instrument, or symbol
    (remember, they are all synonyms). `40=Limit` means that the message contains
    a limit order (see [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044)*, FX Market
    Overview from a Developer’s Standpoint*, for an explanation of types of orders).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the delimiter character 0x01 is non-printable, many authors use special
    characters to divide tags in a FIX message visually. I’m sure you’ll agree that
    it is easier to read a string that is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, reading the following string is more difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, do not ever use any other delimiter than 0x01 in real FIX messages!
  prefs: []
  type: TYPE_NORMAL
- en: Message structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any FIX message is composed of the following three logical parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard trailer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standard header always consists of the following three tags sent in this
    very order and not any other:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tag 8` – means that the message begins and it contains the version of the
    FIX protocol used by both parties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag 9` – the message body length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag 35` – the message type (for example, `request for quote`, `order`, `logon`,
    or `logout`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard trailer always ends with tag 10, whose value is the message checksum.
    A checksum is a small piece of data that is returned by a hash function – a function
    that processes all bits of a meaningful block of data and compresses it according
    to a special algorithm. Checksums are used to make sure that a block of data (a
    message in our case) was delivered without errors. If you want to learn more about
    checksums, hash functions, and related matters, I’d recommend starting with an
    excellent article on Wikipedia ([https://en.wikipedia.org/wiki/Checksum](https://en.wikipedia.org/wiki/Checksum))
    that also has references for further reading.
  prefs: []
  type: TYPE_NORMAL
- en: According to the FIX standard, a tag must have only one occurrence per message.
    Messages with multiple occurrences of the same tag will be rejected by the target
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: Tags must have a value. In case no value is specified for any tag, the entire
    message will be rejected as well.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with FIX is organized in sessions. A session assumes there are two
    computers involved: the one that sends the message (*sender*, the respective tag
    is called `SenderCompID`) and the one that receives the message (*target*, the
    respective tag is called `TargetCompID`). Normally, the session is initiated by
    a client connecting to a server, for example, a trader connecting to the broker
    or a bank connecting to an ECN.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A session starts by sending a handshake message from the sender’s computer
    to the target computer. In cases where there is a reply from the target computer,
    this message initiates the session. This message type (tag 35) is `Logon (A)`.
    A sample handshake message header will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding message, `XX` stands for the entire message length (see an
    explanation of tag 9 in the *Message* section).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have come to the point where my initial thesis (go and ask your broker
    for details) becomes apparent. The problem is that, apart from these three mandatory
    tags and the ending tag 10, all other tags in a logon message are optional. This
    means that I cannot tell you what you should include there; nor can any other
    author – except for your broker because it is they who decide what should be sent
    and in which sequence. So, the best way of learning it is by referring to the
    documentation obtained from the very trading venue to which you want to send your
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any FIX session ends with a `Logout (5)` message, which in its minimal form
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Constructing messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, I would like to warn you against making a very common mistake
    made by many developers of trading strategies. They think that there’s only a
    limited set of FIX messages that their application may generate; therefore, they
    hardcode them as strings and pick the appropriate one when they need to send an
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not do this! Here are the following reasons why you shouldn’t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, this approach makes your code non-scalable. In cases where you need to
    add a new tag for a new order type, you need to re-write the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, this makes your code non-portable. In cases where you want to use it
    with another broker, this broker can require a particular set of tags in a logon
    message or anywhere else, and again – you will have to re-write your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, even though you may think that you remember the meaning of every FIX
    tag by heart, believe me, this is a dangerous self-delusion!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the reasonable way of constructing a FIX message in Python would be to
    build it block by block using explicit, human-readable names of tags instead of
    just numbers. We’re going to use a native Python dictionary for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by forming a basic FIX dictionary that associates tags with their
    respective names. We will use names as keys and tag numbers as values because
    this is the way we want to build our messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need a function that binds tags together in a message. Don’t forget
    that messages may differ significantly in the number of included tags so we will
    want to use one of Python’s most powerful features – *arbitrary* *keyword argument*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we assume that we pass keyword arguments as pairs of `<tag_name>=VALUE`
    and then use the dictionary to replace human-readable names with standard FIX
    tag numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test our code with the following instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that SOH characters are not visible in this output but if we explicitly
    request the value of the `message` variable, it will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, the non-printable character is clearly visible.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not reasonable to pass the standard header manually each time
    we need to compose the message. So, we need to include it in the function.
  prefs: []
  type: TYPE_NORMAL
- en: With the first tag, `8`, it’s simple. We can store the value in a special variable
    and add it at the last stage of the process of composing a message. The first
    tag always contains only the version of the FIX protocol. But anyway, we should
    calculate the length of the message body and the checksum and include them (the
    length and the checksum) in tags `9` and `10`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: Do not confuse the message body with the message itself! Tag `9` means the length
    of only the message body, that is, between tag `9` and tag `10`. In our example,
    the message body length is `5` (not `4` because the body consists of characters
    `3`, `5`, `=`, `A`, and one non-printable 0x01).
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of implementing the calculation of the body length is restricting
    provision tags in `**kwargs` to just the message body. This can be done in a variety
    of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by using a list that we will call `fix_exceptions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then add tags to our composing message only when they are not in the
    list of exceptions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the new version of our message-composing function will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we test it using the preceding parameters, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tags 8, 9, and 10 are now ignored because they are in the list of exceptions.
    Since tags related to the standard header and standard trailer are ignored, whatever
    is not ignored remains in the message body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we can now calculate its length and add it to the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add tag `8`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, in the following code we sum all ASCII codes of all characters in
    the string, then divide this sum by 256 and take the remainder (we will use the
    `reduce` function here, which is part of `functools`, so should be imported as
    `from functools` `import reduce`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then add it to the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now see the entire upgraded code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s test it with the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will still get the correct output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all tags found in the list of exceptions are ignored and their ridiculous
    values are not included in the message – which is great because otherwise such
    a message will be rejected (in the best case). Moreover, now we can safely omit
    all tags but the body when we call the following function, which will give us
    exactly the same result as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What to do next
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you work with FIX, you definitely need a reference that has a comprehensive
    dictionary of all tags with explanations of their meaning. One of the best resources
    is OnixS (they develop SDKs for direct market access, so no wonder FIX plays the
    central role in their products), which can be found at [https://www.onixs.biz/fix-dictionary.html](https://www.onixs.biz/fix-dictionary.html).
    If you plan to work with FIX professionally, I definitely recommend visiting the
    official website of the FIX community at [https://www.fixtrading.org](https://www.fixtrading.org)
    and checking the *Standards* section, where you can find information on technical
    standards, specifications, and a link to FIX GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to professional utilization of FIX, the most important and de
    facto industry-standard solution is QuickFIX ([https://quickfixengine.org](https://quickfixengine.org)).
    It features implementations of the FIX protocol for many languages, including
    Python, and simplifies the development of messaging and data retrieval for trading
    applications by relieving the developer of the burden of low-level composing FIX
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: There are also several ready-made FIX implementations for Python, of which Simplefix
    ([https://pypi.org/project/simplefix/](https://pypi.org/project/simplefix/)) is
    probably the most straightforward. It doesn’t implement a socket connection or
    any other transport layer functionality, nor does it support logging or ensure
    message persistence. It only serves as a convenient wrapper for encoding and decoding
    FIX messages with easy-to-read functions.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth mentioning another protocol built on top of FIX. It is called
    **FAST**, which stands for **FIX Adapted for STreaming**. In simple terms, this
    protocol is designed to facilitate fast and a large volume of messaging without
    generating excessive processing overhead or latency. If you’re interested in learning
    more about FAST, I’d recommend starting with the official documentation ([https://www.fixtrading.org/standards/fast/](https://www.fixtrading.org/standards/fast/))
    and also having a look at a FIX Fast tutorial at [https://jettekfix.com/education/fix-fast-tutorial/](https://jettekfix.com/education/fix-fast-tutorial/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to compose FIX messages, you just need to fill them with
    meaning. That is, you need to add any trading logic that is most likely based
    on market data, generate orders, transform them into FIX messages, and send them
    to the broker, an ECN, or elsewhere. You also need to be able to receive and understand
    replies to your messages. For example, your broker may respond with `8=8` in the
    message body, which means that your order is successfully filled (message type
    8 means order execution report and value 8 means *order filled*). The broker may
    send you back `8=5` which will mean that your order is rejected and your code
    should be able to handle situations of this kind.
  prefs: []
  type: TYPE_NORMAL
- en: What if your broker doesn’t support FIX or doesn’t provide non-professional
    traders with access to it? At this point, we, unfortunately, return to my statement
    at the very beginning of this chapter*, “in the world of FX automated trading,
    every setup is unique so go ask your broker.”* As we saw previously, even in a
    highly standardized FIX protocol, there is still a certain degree of flexibility
    so it’s always best to read the documentation provided by the very trading venue
    to which you plan to send orders. With proprietary protocols, it’s even worse
    because there is no standard and every broker offers their own API designed the
    way they think is best.
  prefs: []
  type: TYPE_NORMAL
- en: However, the most important thing for you to conclude from this section is that
    any protocol, any API, and any framework only serves to deliver a certain message,
    in most cases a trading order, and to receive the reply. If you design your trading
    application so that you have independent interfaces between data processing, trading
    logic, risk management, and ordering modules, you will be able to switch from
    one protocol to another without rewriting the entire application – and this is
    what we’re going to learn more about in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with the means of exchanging information between
    your application and a trading venue, it’s time to learn *what* we can send and
    retrieve from there. Let’s start with market data.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data – garbage in, garbage out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FIX protocol is universal by design and thus can be used not only for ordering
    but also for data retrieval. However, in most cases, it is not actually used for
    market data transfer; instead, trading venues provide their own proprietary APIs
    to retrieve data from there.
  prefs: []
  type: TYPE_NORMAL
- en: As always, in this *gloomy world* of communication protocols, everything is
    individual and each trading venue offers its own API. However, in general, all
    broker APIs are implemented as REST or Websockets. The former is convenient for
    occasional requests for quotes, while the latter is best for continuous subscriptions
    that allow receiving real-time market data.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples I provide are taken from the API of LMAX, one of the
    key ECNs in the FX market. They are not only great because of their openness to
    any client, big or small, but also because they are one of the very few trading
    venues that publicly disseminate real-time market data – and they do it completely
    free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start working with FX market data you should understand and always
    remember one important thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data in demo environments is always different from that in a* *live environment.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if you receive public data or open a demo account with an ECN
    to receive market data from there, you should be ready to see quotes that are
    slightly different from the *real* market. The good news is that this difference
    is not significant; in our particular example with LMAX, it is normally 0.1 to
    0.5 pips with a probable slight increase in difference closer to the New York
    bank settlement time (5 P.M. New York time – see the *Trading the FX market: what
    and how* section in [*Chapter 3*](B19145_03.xhtml#_idTextAnchor044)*, FX Market
    Overview from a Developer’s Standpoint*). So, even this publicly available data
    is good for most development and even for live trading.'
  prefs: []
  type: TYPE_NORMAL
- en: In cases where you need only a quote here and a quote there from time to time,
    then mostly LMAX's REST API is the way to go for you.
  prefs: []
  type: TYPE_NORMAL
- en: As with any regular REST API, it supports a few endpoints that allow retrieving
    market price data both as the last trade price and as the top of the order book.
    It also supports retrieving information about all instruments (symbols) supported
    by the LMAX demo server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to retrieve such a list, let’s execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will deliver us a JSON with the list of available instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I removed the remainder of the JSON to keep it compact but the rest is just
    repetitions of similar records for other instruments. Let’s parse this answer
    to understand its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`instrument_id`: This is the name of the FX instrument supported by the LMAX
    demo server in the correct notation (note that no slashes **/** are allowed in
    the names, so they are replaced with a dash **-**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asset_class`: Most of the instruments traded at this ECN are currencies but
    there are also **contracts for difference** (**CFDs**) on metals and energies,
    so be careful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quantity_increment`: This is the minimum `quant` of the order size; an increment
    of 1,000.000 euros means that you can send an order to buy or sell 1,003,000 euros
    for just 2,000 EURUSD, but not 1,003,300 or 1,100,301 euros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price_increment`: This is the minimum price fluctuation. 0.00001 means that
    the minimum change can be in the fifth digit to the right of the decimal point
    and the amount of this change is 1 (so-called **fractional pip**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ticker_enabled`: This means that the symbol is available for ordering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To retrieve the entire order book information for the particular symbol, we
    can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The response will contain the list of bids and asks for the depth allowed by
    LMAX for demo accounts again in the form of a plain JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to receive continuous data from the ECN, you may want to use WebSockets
    instead of REST:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to install WebSockets, which you can do using pip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you use Python with an Anaconda distribution, you can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we need to import the WebSocket module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, set the URL to which we’re going to subscribe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the WebSocket and connect it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, form the request as a regular JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Watch the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did all the steps correctly, you’re going to see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This response means that the subscription has been set up and that the subscribed
    instruments are the euro for the entire order book and the Japanese yen for the
    last price data.
  prefs: []
  type: TYPE_NORMAL
- en: As this book is not a tutorial on WebSockets, I recommend reading the very comprehensive
    tutorial at [https://websockets.readthedocs.io/en/stable/intro/index.html](https://websockets.readthedocs.io/en/stable/intro/index.html)
    if you are not familiar with this kind of network connection.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all supported REST API endpoints and WebSocket requests in the
    LMAX official documentation at [https://docs.lmax.com/public-data-api/](https://docs.lmax.com/public-data-api/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Please don’t forget that the preceding examples are for illustrative purposes
    only. I would like to keep this book as broker-agnostic as possible so I can’t
    really recommend any particular broker or an ECN. The example with LMAX is provided
    here only because they have one of the most simple and easy-to-use APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Other brokers and trading venues may have different APIs that are sometimes
    more complex but the key principles of subscribing to data remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we know how to get data from the trading venue, here comes the
    most important part: **data handling**. All procedures you perform with data in
    your trading applications must ensure data consistency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By data consistency in market data, we assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If tick A is received prior to tick B, then the timestamp of tick A should precede
    that of tick B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a gap in time between two adjacent ticks that is substantially greater
    than the average, there must be a clear logical explanation for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is a gap in price between two adjacent ticks that is substantially
    greater than the average, there must be again a clear logical explanation for
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s consider each point in detail in the following sub-sections.
  prefs: []
  type: TYPE_NORMAL
- en: Tick sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you start working with real market data, you will be impressed by the number
    of ticks with incorrect timestamps. There are several explanations for this phenomenon;
    the most understandable is probably that the number of ticks (and we remember
    from [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014) that a tick is an update
    in price, either a new bid, a new ask, or a new trade) is so huge that the exchange’s
    or ECN’s own servers can’t really process all of them in the correct sequence
    and assign the same timestamps to batches of ticks. There are also other reasons
    that are more related to the latency between the exchange’s servers and trading
    servers or client computers. Anyway, regardless of the reason, incorrect timestamps
    are a real problem and before we start working with data, we always have to perform
    a check and correct the timestamps if there’s any inconsistency in them.
  prefs: []
  type: TYPE_NORMAL
- en: There are several techniques that allow fixing the timestamp issue and we will
    consider them in detail in the very next chapter, which is completely dedicated
    to processing and storing market data.
  prefs: []
  type: TYPE_NORMAL
- en: Time gaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically, a time gap is a situation when no market data is received for a considerable
    amount of time. Of course, the question is how to define this *considerable amount*.
    How much is it? A second? A minute? An hour? If there’s no market data update
    in 5 minutes, does it mean that the connection is lost or that there’s simply
    no activity in the market?
  prefs: []
  type: TYPE_NORMAL
- en: If you receive data as live quotes this problem can be solved relatively easily
    by adding heartbeat messages to your implementation of market data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *heartbeat message* is somewhat similar to *ping*: a message with dummy content
    is sent to the server and the server just replies with something that means *“OK,
    I am still alive and can hear you well.”* Such a message is sent automatically
    at equal intervals and is a simple yet robust method of checking the health of
    your connection.'
  prefs: []
  type: TYPE_NORMAL
- en: If you work with FIX, this protocol natively supports heartbeat (message type
    0, tag 35=0). If you work with other APIs – well... as always in this chapter,
    you should refer to your broker’s documentation regarding how they implement heartbeat
    (and what they expect you to use). If no special heartbeat message is reserved
    by the broker, you may want to use any neutral request, such as a request for
    a quote from time to time, and check the response.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of using a special heartbeat message is that it works any
    time the server is up. Even when the market is actually closed and any attempt
    to receive a market quote fails, heartbeat messages will go through and will be
    responded to. So, using heartbeat messages is always the preferred way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If your broker or a trading venue does support heartbeat messages, you may want
    to refrain from using any other type of request just to make sure the connection
    is alive. In certain cases, such an activity can be a reason for a ban with certain
    ECNs.
  prefs: []
  type: TYPE_NORMAL
- en: So, with live quotes, the problem of time gaps can be solved relatively easily
    by adding heartbeat messages. But what do we do in cases where we work with *historical
    data,* that is, not the data representing what’s going on in the market now but
    data indicating what *was going on* in the market some time ago? In this case,
    no heartbeat message is recorded into it (at least I am not aware of any single
    example suggesting otherwise) and if we see two ticks with a pause of 1 hour between
    them, there is always a question of whether this data is consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, such a consistency check is performed in two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we identify the time gaps. The main problem here is how to decide that
    the pause between ticks is long enough to become suspicious. We will look into
    this problem in detail in the next chapter. For now, let’s just assume that any
    pause that is greater than the average plus two sigmas (sigma here stands for
    standard deviation, we consider it in [*Chapter 6*](B19145_06.xhtml#_idTextAnchor101)*,
    Basics of Fundamental Analysis and its Possible Use in FX Trading*) is considered
    *suspicious*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, all *suspicious* pauses are checked against the list of known situations
    when market data can indeed be paused. We exclude all weekends, pauses before
    and after the bank settlement, and the opening of the bank day for some currencies,
    and check the rest against a schedule for known events such as releases of important
    economic news that also may cause interruptions in market quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the remaining list of time gap issues is insignificant (let’s assume for
    clarity that it is at least 10 times as small as the original list), then we believe
    that overall this data is satisfactory to work with. If the amount of unidentified
    time gaps is still significant, it would be best to refrain from using this data.
  prefs: []
  type: TYPE_NORMAL
- en: Price gaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A gap in price is a situation where two adjacent ticks have an abnormal difference
    in price. Of course, like with time gaps, the question is how we define this to
    be *abnormal*. Here, we can use similar techniques as those we used with time
    gaps. If the difference in the price of two adjacent ticks is greater than the
    average plus 2 sigma, then this is a potential price gap.
  prefs: []
  type: TYPE_NORMAL
- en: In cases of price gaps, we frequently use 3 sigmas and more because the goal
    is not really to catch every situation when the price jumps quickly (in the real
    market this may happen quite often, at least a few times a day) but to isolate
    and filter out **non-market prices**.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you remember the illustration of what non-market price looked like in
    [*Chapter 1*](B19145_01.xhtml#_idTextAnchor014)? So, a non-market price is something
    that lies completely, totally outside of any reasonable range, so we can easily
    consider 10, 20, and sometimes even 100 sigmas to filter out these erroneous quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wonder about the source of these non-market prices. There can be multiple
    reasons for non-market prices:'
  prefs: []
  type: TYPE_NORMAL
- en: The most common reason is a so-called **fat finger effect**, simply a mistake
    in the bid or offer sent to the market. Typically, it is 10 times greater or 10
    times less than the previous market price because of an extra 0 in the quote or
    a missing digit. Trades done at these prices are normally reversed in hindsight,
    but the quotes are recorded in the data stream and stored as historical data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some data providers include data not related to trading; for example, I saw
    a case where the exchange included transfers to an insurance fund as market price
    data. Luckily they recorded these *ticks* at zero price – luckily because it is
    then very easy to filter out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In rare cases, there can be glitches in the data provider’s database, software,
    or hardware – erroneous quotes caused by this reason are the hardest to find and
    filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you have successfully connected to the data source, received data, and
    filtered it, it’s time to do something meaningful with it: that is, analyze the
    data and make some trading decisions. This is what we’re going to consider in
    the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Trading logic – this is where a small mistake may cost a fortune
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trading logic is obviously the core of the entire trading app. It is the very
    component that analyzes the market data in search of any pre-defined price-time
    patterns (sometimes other data such as volume and open interest is included, but
    this data is typically not available for the spot market) and generates orders.
    Almost all of the rest of the book will be dedicated to trading logic and various
    approaches to developing trading algorithms but we can’t really move on without
    considering one very typical mistake that already costs many traders millions,
    if not billions, of dollars. I mean the **peek** **ahead** issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The phenomenon of peeking ahead is specific to only the development phase of
    the project when the trading algorithm is optimized or trained using past market
    data, which is called historical data. As you remember from the previous section,
    historical data is something pre-recorded either by yourself or a third party
    such as an exchange, a broker, a data vendor, and so on. This data may contain
    ticks or may be compressed down to 1-second or 1-minute snapshots. Regardless
    of data compression, all data in a cleaned-up dataset is sorted by timestamp and
    there is no situation when any *future* data would go before the *past* data –
    or vice versa, when any past data would be recorded after any future data. Let’s
    look at the following example to see what this means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the timestamps are in the correct order. This piece of data
    means that the closing price of the instrument (which can be found in the sixth
    position of each record) was *first* `1.12941`, *then* `1.12965`, *then* `1.12883`,
    *then* `1.12894,` and *finally* `1.12925`.
  prefs: []
  type: TYPE_NORMAL
- en: When we develop and test a trading algorithm, we *simulate* trading by processing
    past data and making a trading decision based on it. Normally, the simulation
    engine processes pieces of data from a file, a list, or a pandas DataFrame one
    by one to simulate what *would have happened* if our algorithm traded *at that
    time.* So, we *must* make sure that at no point our trading algorithm can receive
    data *from* *the future*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s again look at the preceding example. Imagine that we simulated the behavior
    of our trading algorithm at 13:32\. All we and the algorithm may know at this
    step is that the closing price at that time was 1.12883\. We *cannot* know – and
    the algorithm *cannot* know – that the closing price *would be* 1.12894 one minute
    later. However, if you store prices in a list (or a pandas DataFrame) it is easy
    to refer to the *future* price just by its index. So, I could potentially write
    something such as this (the following example assumes that `current_position`
    is the pointer which iterates through the dataset and `price_data` is the dataset
    itself):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we assume that the `buy` and `sell` methods generate buy and sell
    orders respectively. If we run a simulation using this code, we will have *100%
    of winning trades.* Not a single one will lose money because we compare a price
    *from the future* (lines 2 and 4) with the real price that exists *at the moment
    of simulation*. In our example, it would mean that at 13:32, I *already know what
    the price will be at 13:33* and compare it to the current price. Well, if I really
    could know that... Anyway, no one can see the future and you should make sure
    your algos are no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure you refer to prices one by one without peeking ahead. Use queues
    or refer to timestamps but always avoid referring to data by the index.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we now know, at least at a surface glance, how to communicate with
    the market, how to retrieve data and make sure it’s consistent, and even how to
    avoid the greatest mistake that systematic trading strategies developers can make
    in the trading logic. Now, we should be able to send trading orders and protect
    ourselves against numerous adverse situations.
  prefs: []
  type: TYPE_NORMAL
- en: Risk management – your safety belt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After your algorithm has generated a trading signal, it should go past risk
    management. While trading logic answers the question *to trade or not to trade*,
    risk management answers another question: how much should be put at stake?'
  prefs: []
  type: TYPE_NORMAL
- en: In basic terms, risk management involves analysis of the potential maximum adverse
    excursion per trade, account size, leverage and margin as financial components
    of risk, and macro-economic factors and political events as external and non-market
    risk. Just to give you an example, it would be wise to just switch off trading
    before the Swiss National Bank decision in January 2015 or the presidential elections
    in the US in 2016.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of risk management is really vast and we will go into detail on this
    later in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)*, Types of Orders and
    Their Simulation in Python*, after we have learned more about types of trading
    strategies and orders.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering – make sure you are understood correctly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Last, but by far not least, your trading application will have an ordering
    module. This module performs the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: It maintains the connection to the execution server keeping it alive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It transforms trading signals passed by the risk management module into actual
    orders – using FIX or any proprietary API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It handles all types of responses from the broker or trading venue. These responses
    range from just *OK* to partial fills and rejects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It decides what to do in cases where your order was rejected or filled partially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It resubmits orders, full or in parts, in case it is favored by the trading
    logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that one of the responsibilities of the ordering module
    is maintaining connections – quite like the data handling module. Yes, there’s
    no mistake here, it is absolutely normal that a trading app uses **different**
    connections for data and for orders. Moreover, it is very frequent when data is
    obtained from a data vendor and orders are executed at an exchange or obtained
    from an exchange and executed with a market maker, and so on – in any possible
    combination. So, the ordering module also maintains the connection because this
    connection is different and separate.
  prefs: []
  type: TYPE_NORMAL
- en: As with risk management, we will go into the details of ordering along with
    risk management in [*Chapter 10*](B19145_10.xhtml#_idTextAnchor171)*, Types of
    Orders and Their Simulation* *in Python*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to connect to a broker or data vendor, retrieve
    live market data, understand the requirements for the quality of this data, and
    know all the five core logical blocks of which our future trading application
    will consist.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to discuss the specifics of how we can
    efficiently handle *historical* market data because this is exactly what is required
    for the research and development phase.
  prefs: []
  type: TYPE_NORMAL
