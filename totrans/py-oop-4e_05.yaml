- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: When to Use Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用面向对象编程
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know some principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了许多面向对象编程的标志性特征。我们现在已经了解了一些面向对象设计的原理和范式，并且已经覆盖了Python中面向对象编程的语法。
- en: 'Yet, we don''t know exactly how and, especially, when to utilize these principles
    and syntax in practice. In this chapter, we''ll discuss some useful applications
    of the knowledge we''ve gained, looking at some new topics along the way:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不确切知道如何在实践中具体运用这些原则和语法。在本章中，我们将讨论我们所获得知识的一些有用应用，并在过程中探讨一些新的主题：
- en: How to recognize objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别物体
- en: Data and behaviors, once again
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和行为，再次
- en: Wrapping data behaviors using properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性包装数据行为
- en: The Don't Repeat Yourself principle and avoiding repetition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己原则和避免重复
- en: In this chapter, we'll also address some alternative designs for our case study
    problem. We'll look at ways to partition the sample data into training sets and
    test sets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将讨论针对案例研究问题的一些替代设计方案。我们将探讨如何将样本数据划分为训练集和测试集。
- en: We'll start this chapter with a close look at the nature of objects and their
    internal state. There are cases when there's no state change, and a class definition
    isn't desirable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，仔细研究对象的本质及其内部状态。在某些情况下，没有状态变化，定义一个类可能不是所希望的。
- en: Treat objects as objects
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象视为对象
- en: 'This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We''ve seen examples of this in the case
    studies in previous chapters: first, we identify objects in the problem, and then
    model their data and behaviors.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显；你通常应该在你代码中为问题域中的单独对象提供一个特殊的类。我们在前几章的案例研究中已经看到了这样的例子：首先，我们识别问题中的对象，然后对它们的数据和行为进行建模。
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in short paragraphs
    that, frankly, the authors have constructed explicitly for that purpose. Remember,
    objects are things that have both data and behavior. If we are working only with
    data, we are often better off storing it in a list, set, dictionary, or other
    Python data structure (which we'll be covering thoroughly in *Chapter 7*, *Python
    Data Structures*). On the other hand, if we are working only with behavior, but
    no stored data, a simple function is more suitable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 识别对象是面向对象分析和编程中的一个非常重要的任务。但事实并非总是像在简短的段落中数名词那样简单，坦白地说，作者们明确地为了这个目的构建了这些段落。记住，对象是既有数据又有行为的事物。如果我们只处理数据，我们通常更倾向于将其存储在列表、集合、字典或其他Python数据结构中（我们将在第7章“Python数据结构”中全面介绍）。另一方面，如果我们只处理行为而没有存储数据，一个简单的函数就更为合适。
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of complexity if it doesn't
    help organize our code. On the other hand, the need is not always self-evident.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个对象既有数据也有行为。熟练的 Python 程序员会使用内置的数据结构，除非（或者直到）有明显的需要定义一个类。如果没有帮助组织我们的代码，就没有理由添加额外的复杂性。另一方面，这种需求并不总是显而易见的。
- en: We can often start our Python programs by storing data in a few variables. As
    the program expands, we will later find that we are passing the same set of related
    variables to a set of functions. This is the time to think about grouping both
    variables and functions into a class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以通过在几个变量中存储数据来开始我们的Python程序。随着程序的扩展，我们后来会发现我们正在将同一组相关的变量传递给一组函数。这时，我们应该考虑将变量和函数都组合成一个类。
- en: 'For example, if we are designing a program to model polygons in two-dimensional
    space, we might start with each polygon represented as a list of points. The points
    would be modeled as two tuples (x, y) describing where that point is located.
    This is all data, stored in a set of nested data structures (specifically, a list
    of tuples). We can (and often do) start hacking at the command prompt:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们正在设计一个用于在二维空间中模拟多边形的程序，我们可能会从将每个多边形表示为点的列表开始。这些点将被模拟为两个元组（x，y），描述该点的位置。这全部都是数据，存储在一系列嵌套的数据结构中（具体来说，是一个元组列表）。我们可以（并且经常这样做）从命令提示符开始进行修改：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we need to sum the distances between each point. To do this, we need a function
    to calculate the distance between two points. Here are two such functions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要计算多边形周长的距离，我们需要求出每个点之间的距离之和。为了做到这一点，我们需要一个函数来计算两点之间的距离。这里有两个这样的函数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can exercise the functions to check our work:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以练习使用函数来检查我们的工作：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a start, but it's not completely descriptive of the problem domain.
    We can kind of see what a polygon might be. But we need to read the entire batch
    of code to see how the two functions work together.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开始，但它并不能完全描述问题域。我们可以大致看出多边形可能是什么样子。但我们还需要阅读整个代码块，才能了解这两个函数是如何协同工作的。
- en: 'We can add type hints to help clarify the intent behind each function. The
    result looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加类型提示来帮助明确每个函数背后的意图。结果看起来像这样：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've added two type definitions, `Point` and `Polygon`, to help clarify our
    intentions. The definition of `Point` shows how we'll use the built-in `tuple`
    class. The definition of `Polygon` shows how the built-in `list` class builds
    on the `Point` class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个类型定义，`Point` 和 `Polygon`，以帮助阐明我们的意图。`Point` 的定义展示了我们将如何使用内置的 `tuple`
    类。`Polygon` 的定义展示了内置的 `list` 类是如何建立在 `Point` 类之上的。
- en: 'When writing annotations inside method parameter definitions, we can generally
    use the type name directly, for example, `def method(self, values: list[int])
    -> None:`. For this to work, we need to use `from __future__ import annotations`.
    When defining a new type hint, however, we need to use the names from the `typing`
    module. That''s why the definition of the new `Point` type uses `typing.Tuple`
    in the expression `Tuple[float, float]`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '在方法参数定义内编写注释时，我们通常可以直接使用类型名称，例如，`def method(self, values: list[int]) -> None:`。为了使其生效，我们需要使用`from
    __future__ import annotations`。然而，在定义新的类型提示时，我们需要使用`typing`模块中的名称。这就是为什么新的`Point`类型定义在表达式`Tuple[float,
    float]`中使用了`typing.Tuple`。'
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon` class
    could encapsulate the list of points (data) and the `perimeter` function (behavior).
    Further, a `Point` class, such as we defined in *Chapter 2*, *Objects in Python*,
    might encapsulate the `x` and `y` coordinates and the `distance` method. The question
    is: is it valuable to do this?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为面向对象的程序员，我们清楚地认识到一个`多边形`类可以封装点（数据）列表和`周长`函数（行为）。进一步地，一个如我们在*第二章*中定义的`点`类，可以封装`x`和`y`坐标以及`距离`方法。问题是：这样做有价值吗？
- en: 'For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let''s compare
    them as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前的代码，可能对，也可能不对。凭借我们最近在面向对象原则方面的经验，我们可以用创纪录的时间编写出一个面向对象的版本。让我们如下进行比较：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There seems to be almost twice as much code here as there was in our earlier
    version, although we could argue that the `add_point` method is not strictly necessary.
    We could also try to insist on using `_vertices` to discourage the use of the
    attribute, but the use of leading `_` variable names doesn't seem to really solve
    the problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里似乎有比我们早期版本多近两倍的代码，尽管我们可以争论`add_point`方法并不是严格必要的。我们还可以试图坚持使用`_vertices`来阻止使用属性，但使用以`_`开头变量名似乎并不能真正解决问题。
- en: 'Now, to understand the differences between the two classes a little better,
    let''s compare the two APIs in use. Here''s how to calculate the perimeter of
    a square using the object-oriented code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解这两个类之间的区别，让我们比较一下正在使用的两个API。以下是使用面向对象代码计算正方形周长的方法：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当简洁且易于阅读，你可能这么想，但让我们将其与基于函数的代码进行比较：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Hmm, maybe the object-oriented API isn't so compact! Our first, hacked-in version,
    without type hints or class definitions, is the shortest. How do we know what
    the list of tuples is supposed to represent? How do we remember what kind of object
    we're supposed to pass into the `perimeter` function? We needed some documentation
    to explain how the first set of functions should be used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许面向对象的API并不那么紧凑！我们的第一个，未经优化的版本，没有类型提示或类定义，是最短的。我们怎么知道元组列表应该代表什么？我们怎么记住我们应该传递什么类型的对象到`perimeter`函数中？我们需要一些文档来解释如何使用第一组函数。
- en: The functions annotated with type hints were quite a bit easier to understand,
    as were the class definitions. The relationships among the objects are more clearly
    defined by hints or classes or both.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型提示注解的函数更容易理解，类定义也是如此。通过提示、类或两者结合，对象之间的关系定义得更加清晰。
- en: Code length is not a good indicator of code complexity. Some programmers get
    hung up on complicated *one-liners* that do an incredible amount of work in one
    line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码长度并不是衡量代码复杂度的良好指标。一些程序员会陷入复杂的 *一行代码* 中，这些代码在一行内完成大量的工作。这可以是一项有趣的练习，但结果往往是难以阅读的，即使是第二天原作者也会觉得难以理解。尽量减少代码量通常可以使程序更容易阅读，但不要盲目地假设这种情况总是成立。
- en: No one wins at code golf. Minimizing the volume of code is rarely desirable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码高尔夫比赛中，没有人能获胜。最小化代码的体积通常并不理想。
- en: Luckily, this trade-off isn't necessary. We can make the object-oriented `Polygon` API
    as easy to use as the functional implementation. All we have to do is alter our `Polygon` class
    so that it can be constructed with multiple points.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种权衡并不必要。我们可以使面向对象的`Polygon` API与函数实现一样易于使用。我们只需修改我们的`Polygon`类，使其能够用多个点进行构造。
- en: 'Let''s give it an initializer that accepts a list of `Point` objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给它一个接受`Point`对象列表的初始化器：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the `perimeter()` method, we''ve used the `zip()` function to create pairs
    of vertices, with items drawn from two lists to create a sequence of pairs. One
    list provided to `zip()` is the complete sequence of vertices. The other list
    of vertices starts from vertex 1 (not 0) and ends with the vertex before 1 (that
    is, vertex 0). For a triangle, this will make three pairs: `(v[0], v[1])`, `(v[1],
    v[2])`, and `(v[2], v[0])`. We can then compute the distance between the pairs
    using `Point.distance()`. Finally, we sum the sequence of distances. This seems
    to improve things considerably. We can now use this class like the original hacked-in
    function definitions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`perimeter()`方法，我们使用了`zip()`函数来创建顶点的配对，通过从两个列表中抽取项目来创建一对对的序列。提供给`zip()`的一个列表是顶点的完整序列。另一个顶点列表从顶点1（而不是0）开始，并以顶点1之前的顶点（即顶点0）结束。对于一个三角形，这将产生三个配对：`(v[0],
    v[1])`、`(v[1], v[2])`和`(v[2], v[0])`。然后我们可以使用`Point.distance()`来计算配对之间的距离。最后，我们求和距离序列。这似乎显著提高了事情。现在我们可以像原始的插入函数定义一样使用这个类：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's handy to have the details of the individual method definitions. We've built
    an API that's close to the original, succinct set of definitions. We've added
    enough formality to be confident the code is likely to work before we even start
    putting test cases together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 了解各个方法定义的细节非常方便。我们构建了一个接近原始、简洁定义集的API。我们添加了足够的正式性，以确保在开始编写测试用例之前，代码很可能会正常工作。
- en: 'Let''s take one more step. Let''s allow it to accept tuples too, and we can
    construct the `Point` objects ourselves, if needed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再迈出一步。让我们也允许它接受元组，如果需要的话，我们可以自己构造`Point`对象：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This initializer goes through the list of items (either `Point` or `Tuple[float,
    float]`) and ensures that any non-`Point` objects are converted to `Point` instances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化器遍历项目列表（无论是`Point`还是`Tuple[float, float]`），并确保任何非`Point`对象都被转换为`Point`实例。
- en: If you are experimenting with the above code, you should also define these variant
    class designs by creating subclasses of `Polygon` and overriding the `__init__()` method.
    Extending a class with dramatically different method signatures can raise error
    flags from **mypy**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试上述代码，你应该通过创建`Polygon`的子类并重写`__init__()`方法来定义这些变体类设计。通过扩展具有显著不同方法签名的类可能会触发**mypy**的错误标志。
- en: For an example this small, there's no clear winner between the object-oriented
    and more data-oriented versions of this code. They all do the same thing. If we
    have new functions that accept a polygon argument, such as `area(polygon)` or
    `point_in_polygon(polygon, x, y)`, the benefits of the object-oriented code become
    increasingly obvious. Likewise, if we add other attributes to the polygon, such
    as `color` or `texture`, it makes more and more sense to encapsulate that data
    into a single class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个小例子，面向对象和更数据导向的代码版本之间并没有明显的胜者。它们都做了同样的事情。如果我们有接受多边形参数的新函数，例如 `area(polygon)`
    或 `point_in_polygon(polygon, x, y)`，面向对象的代码的优势就越来越明显。同样，如果我们给多边形添加其他属性，比如 `color`
    或 `texture`，将那些数据封装到一个单独的类中就越来越有意义了。
- en: The distinction is a design decision, but in general, the more important a set
    of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 区分是一个设计决策，但一般来说，一组数据的重要性越高，它就越有可能拥有针对该数据的多个特定功能，并且使用具有属性和方法类的做法就越有用。
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use *one time only*. On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculating the perimeter,
    area, and intersection with other polygons, moving or scaling them, and so on),
    we have almost certainly identified a class of related objects. The class definition
    becomes more important as the number of instances increases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个决定时，考虑一下这个类将如何被使用也是有益的。如果我们只是在解决一个更大的问题的情况下尝试计算一个多边形的周长，使用一个函数可能编写起来最快，并且仅使用一次会更容易 *仅限一次使用*。另一方面，如果我们的程序需要以多种方式操作许多多边形（计算周长、面积、与其他多边形的交集、移动或缩放等），我们几乎肯定已经识别出一系列相关对象。随着实例数量的增加，类的定义变得越来越重要。
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in *Chapter 1*, *Object-Oriented Design*, association and composition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意对象之间的交互。寻找继承关系；没有类，继承关系就难以优雅地建模，所以请确保使用它们。寻找我们在*第一章*，*面向对象设计*中讨论的其他类型的关系，包括关联和组合。
- en: Composition can, technically, be modeled using only data structures – for example,
    we can have a list of dictionaries holding tuple values – but it is sometimes
    less complicated to create a few classes of objects, especially if there is behavior
    associated with the data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，可以使用数据结构来建模组合 - 例如，我们可以有一个包含元组值的字典列表 - 但有时创建几个对象类会更简单，尤其是如果数据关联有行为的话。
- en: One size does not fit all. The built-in, generic collections and functions work
    well for a large number of simple cases. A class definition works well for a large
    number of more complex cases. The boundary is hazy at best.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有情况都适用单一尺寸。内置的通用集合和函数对于大量简单情况工作良好。对于大量更复杂的情况，类定义工作得很好。最佳情况下，这个边界是模糊的。
- en: Adding behaviors to class data with properties
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类数据中添加具有属性的函数
- en: Throughout this book, we've focused on the separation of behavior and data.
    This is very important in object-oriented programming, but we're about to see
    that, in Python, the distinction is uncannily blurry. Python is very good at blurring
    distinctions; it doesn't exactly help us to *think outside the box*. Rather, it
    teaches us to stop thinking about the box.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直关注行为和数据分离的概念。这在面向对象编程中非常重要，但我们很快就会看到，在Python中，这种区别显得异常模糊。Python非常擅长模糊化区别；它并不真正帮助我们跳出思维定式。相反，它教导我们停止考虑思维定式。
- en: 'Before we get into the details, let''s discuss some bad object-oriented design
    principles. Many object-oriented developers teach us to never access attributes
    directly. They insist that we write attribute access like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们讨论一些不良的面向对象设计原则。许多面向对象开发者教导我们永远不要直接访问属性。他们坚持认为我们应该这样编写属性访问：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The instance variables are prefixed with an underscore to suggest that they
    are private (other languages would actually force them to be private). Then, the
    `get` and `set` methods provide access to each variable. This class would be used
    in practice as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量以下划线开头，以表示它们是私有的（其他语言实际上会强制它们成为私有）。然后，`get` 和 `set` 方法提供了对每个变量的访问。在实际应用中，此类将如下使用：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The above example is not nearly as readable as the direct access version that
    Python favors:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的阅读性远不如Python所青睐的直接访问版本：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s how this class works. It''s slightly simpler:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课的工作原理是这样的。它稍微简单一些：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, why would anyone insist upon the method-based syntax?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有人会坚持基于方法的语法呢？
- en: The idea of setters and getters seems helpful for encapsulating the class definitions.
    Some Java-based tools can generate all the getters and setters automagically,
    making them almost invisible. Automating their creation doesn't make them a great
    idea. The most important historical reason for having getters and setters was
    to make the separate compilation of binaries work out in a tidy way. Without a
    need to link separately compiled binaries, this technique doesn't always apply
    to Python.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器和获取器的概念似乎有助于封装类定义。一些基于Java的工具可以自动生成所有的获取器和设置器，使它们几乎不可见。自动化它们的创建并不使它们成为一个伟大的想法。拥有获取器和设置器最重要的历史原因是为了使二进制的独立编译以一种整洁的方式进行。在没有必要单独链接编译的二进制文件的情况下，这种技术并不总是适用于Python。
- en: One ongoing justification for getters and setters is that, someday, we may want
    to add extra code when a value is set or retrieved. For example, we could decide
    to cache a value to avoid complex computations, or we might want to validate that
    a given value is a suitable input.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用获取器和设置器的一个持续的理由是，将来我们可能需要在设置或检索值时添加额外的代码。例如，我们可能会决定缓存一个值以避免复杂的计算，或者我们可能想要验证给定的值是否是一个合适的输入。
- en: 'For example, we could decide to change the `set_name()` method as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以决定将`set_name()`方法修改如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we had written our original code for direct attribute access, and then later
    changed it to a method like the preceding one, we''d have a problem: anyone who
    had written code that accessed the attribute directly would now have to change
    their code to access a method. If they didn''t then change the access style from
    attribute access to a function call, their code would be broken.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们最初为直接属性访问编写了代码，然后后来将其更改为前面提到的方法，我们就会遇到问题：任何编写了直接访问属性代码的人现在都必须更改他们的代码以访问方法。如果他们没有将访问方式从属性访问更改为函数调用，他们的代码就会出错。
- en: The mantra that we should make all attributes private, accessible through methods,
    doesn't make much sense in Python. The Python language lacks any real concept
    of private members! We can see the source; we often say "We're all adults here."
    What can we do? We can make the syntax distinction between attribute and method
    less visible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将所有属性设置为私有，并通过方法访问这一信条在Python中并没有太多意义。Python语言缺乏任何真正的私有成员概念！我们可以查看源代码；我们经常说“我们都是成年人。”我们能做什么呢？我们可以使属性和方法之间的语法区别不那么明显。
- en: 'Python gives us the `property` function to make methods that *look* like attributes.
    We can therefore write our code to use direct member access, and if we ever unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了`property`函数来创建看起来像属性的**方法**。因此，我们可以编写代码以使用直接成员访问，如果我们意外地需要修改实现，在获取或设置该属性的值时进行一些计算，我们可以这样做而不必改变接口。让我们看看它是如何表现的：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compared to the earlier class, we first change the `name` attribute into a (semi-)private
    `_name` attribute. Then, we add two more (semi-)private methods to get and set
    that variable, performing our validation when we set it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期版本相比，我们首先将`name`属性改为（半）私有属性`_name`。然后，我们添加了两个（半）私有方法来获取和设置该变量，并在设置变量时执行我们的验证。
- en: Finally, we have the `property` construction at the bottom. This is the Python
    magic. It creates a new attribute on the `Color` class called `name`. It sets
    this attribute to be a **property**. Under the hood, a `property` attribute delegates
    the real work to the two methods we just created. When used in an access context
    (on the right side of the `=` or `:=`), the first function gets the value. When
    used in an update context (on the left side of `=` or `:=`), the second function
    sets the value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在底部有`property`构造。这是Python的魔法。它为`Color`类创建了一个新的属性，名为`name`。它将此属性设置为`property`类型。在底层，`property`属性将实际工作委托给了我们刚才创建的两个方法。当在访问上下文中使用（`=`或`:=`的右侧）时，第一个函数获取值。当在更新上下文中使用（`=`或`:=`的左侧）时，第二个函数设置值。
- en: 'This new version of the `Color` class can be used in exactly the same way as
    the earlier version, yet it now performs validation when we set the `name` attribute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Color`类的新版本可以像早期版本一样使用，但现在在设置`name`属性时，它现在会执行验证：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property`-based object, the previous code would still work.
    If it attempts to set an empty `property` value, this is behavior we wanted to
    forbid. Success!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们之前编写了用于访问`name`属性的代码，然后将其更改为使用基于`property`的对象，那么之前的代码仍然会工作。如果它尝试设置一个空的`property`值，这是我们想要禁止的行为。成功！
- en: Bear in mind that, even with the `name` property, the previous code is not 100%
    safe. People can still access the `_name` attribute directly and set it to an
    empty string if they want to. But if they access a variable we've explicitly marked
    with an underscore to suggest it is private, they're the ones that have to deal
    with the consequences, not us. We established a formal contract, and if they elect
    to break the contract, they own the consequences.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使有`name`属性，之前的代码也不是100%安全的。人们仍然可以直接访问`_name`属性并将其设置为空字符串，如果他们想这么做的话。但如果是访问我们明确用下划线标记的变量，即暗示它是私有的，那么处理后果的是他们，而不是我们。我们建立了一个正式的契约，如果他们选择违反契约，那么他们必须承担相应的后果。
- en: Properties in detail
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细属性
- en: Think of the `property` function as returning an object that proxies any requests
    to get or set the attribute value through the method names we have specified.
    The `property` built-in is like a constructor for such an object, and that object
    is set as the public-facing member for the given attribute.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将`property`函数视为返回一个对象，该对象通过我们指定的方法名代理对属性值的获取或设置请求。`property`内置函数就像这样一个对象的构造函数，而这个对象被设置为给定属性的公共成员。
- en: 'This `property` constructor can actually accept two additional arguments, a `delete` function
    and a docstring for the property. The `delete` function is rarely supplied in
    practice, but it can be useful for logging the fact that a value has been deleted,
    or possibly to veto deleting if we have reason to do so. The docstring is just
    a string describing what the property does, no different from the docstrings we
    discussed in *Chapter 2*, *Objects in Python*. If we do not supply this parameter,
    the docstring will instead be copied from the docstring for the first argument:
    the `getter` method.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`property`构造函数实际上可以接受两个额外的参数，一个`delete`函数和一个用于属性的文档字符串。在实际情况中，`delete`函数很少被提供，但它可以用来记录一个值已被删除的事实，或者如果我们有理由这么做，可能用来阻止删除。文档字符串只是一个描述属性功能的字符串，与我们在*第二章*，*Python中的对象*中讨论的文档字符串没有区别。如果我们不提供这个参数，文档字符串将默认从第一个参数的文档字符串中复制过来：即`getter`方法。
- en: 'Here is a silly example that states whenever any of the methods are called:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个愚蠢的例子，它声明了每次调用任何方法时：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `state` attribute has a type hint, `str`, but no initial value.
    It can be deleted, and only exists for part of the life of a `NorwegianBlue`.
    We need to provide a hint to help **mypy** understand what the type should be.
    But we don't assign a default value because that's the job of the `setter` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`state` 属性有一个类型提示，`str`，但没有初始值。它可以被删除，并且只存在于 `NorwegianBlue` 生命的一部分。我们需要提供一个提示来帮助
    **mypy** 理解类型应该是什么。但我们不分配默认值，因为那是 `setter` 方法的职责。
- en: 'If we actually use an instance of this class, it does indeed print out the
    correct strings when we ask it to:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际使用这个类的实例，当我们要求它打印时，它确实会打印出正确的字符串：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Further, if we look at the help text for the `Silly` class (by issuing `help(Silly)` at
    the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们查看`Silly`类的帮助文本（通过在解释器提示符中输入`help(Silly)`），它会显示我们`silly`属性的定制文档字符串：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the `getter` and `setter`
    functions. If we want to supply a docstring for a property, we can define it on
    the `getter` function; the property proxy will copy it into its own docstring.
    The `delete` function is often left empty because object attributes are so rarely
    deleted.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一切正如我们计划的那样进行。在实践中，属性通常只使用前两个参数定义：`getter`和`setter`函数。如果我们想为属性提供一个文档字符串，我们可以在`getter`函数上定义它；属性代理会将其复制到自己的文档字符串中。`delete`函数通常留空，因为对象属性很少被删除。
- en: Decorators – another way to create properties
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器 – 创建属性的另一种方法
- en: We can create properties using decorators. This makes the definitions easier
    to read. Decorators are a ubiquitous feature of Python syntax, with a variety
    of purposes. For the most part, decorators modify the function definition that
    they precede. We'll look at the decorator design pattern more broadly in *Chapter
    11*, *Common Design Patterns*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用装饰器来创建属性。这使得定义更容易阅读。装饰器是 Python 语法的一个普遍特性，具有多种用途。大部分情况下，装饰器会修改它们之前定义的函数。我们将在第
    11 章，*常见设计模式*中更广泛地探讨装饰器设计模式。
- en: 'The `property` function can be used with the decorator syntax to turn a `get` method
    into a `property` attribute, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 函数可以与装饰器语法一起使用，将一个 `get` 方法转换为一个 `property` 属性，如下所示：'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This applies the `property` function as a decorator to the function that follows.
    It is equivalent to the previous `silly = property(_get_state)` syntax. The main
    difference, from a readability perspective, is that we get to mark the `silly` method
    as a property at the top of the method, instead of after it is defined, where
    it can be easily overlooked. It also means we don't have to create private methods
    with underscore prefixes just to define a property.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`property`函数作为装饰器应用于后面的函数。这与之前的`silly = property(_get_state)`语法等效。从可读性的角度来看，主要区别在于我们可以在方法顶部将`silly`方法标记为属性，而不是在定义之后，这样就不容易被忽略。这也意味着我们不需要创建带有下划线前缀的私有方法来定义属性。
- en: 'Going one step further, we can specify a `setter` function for the new property
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们可以为新的属性指定一个`setter`函数，如下所示：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This syntax, `@silly.setter`, looks odd compared with `@property`, although
    the intent should be clear. First, we decorate the `silly` method as a getter.
    Then, we decorate a second method with exactly the same name by applying the `setter` attribute
    of the originally decorated `silly` method! This works because the `property` function
    returns an object; this object also has its own `setter` attribute, which can
    then be applied as a decorator to other methods. Using the same name for the get
    and set methods helps to group together the multiple methods that access one common
    attribute.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与`@property`相比，这种语法`@silly.setter`看起来有些奇怪，尽管意图应该是清晰的。首先，我们将`silly`方法装饰为一个获取器。然后，我们通过应用原始装饰的`silly`方法的`setter`属性，装饰了一个具有完全相同名称的第二个方法！这是因为`property`函数返回一个对象；这个对象也有自己的`setter`属性，然后可以将它作为装饰器应用于其他方法。使用相同的名称为获取和设置方法有助于将访问一个公共属性的多个方法组合在一起。
- en: 'We can also specify a `delete` function with `@silly.deleter`. Here''s what
    it looks like:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`@silly.deleter`指定一个`delete`函数。下面是它的样子：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We cannot specify a docstring using `property` decorators, so we need to rely
    on the decorator copying the docstring from the initial getter method. This class
    operates *exactly* the same as our earlier version, including the help text. You'll
    see the decorator syntax in widespread use. The function syntax is how it actually
    works under the hood.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`property`装饰器来指定文档字符串，因此我们需要依赖于装饰器从初始获取器方法复制文档字符串。这个类操作起来与我们的早期版本完全相同，包括帮助文本。您将看到广泛使用的装饰器语法。函数语法是它实际上在底层是如何工作的。
- en: Deciding when to use properties
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定何时使用属性
- en: With the built-in `property` blurring the division between behavior and data,
    it can be confusing to know when to choose an attribute, or a method, or a property.
    In the `Color_VP` class example we saw earlier, we added argument value validation
    to setting an attribute. In the `NorwegianBlue` class example, we wrote detailed
    log entries when attributes were set and deleted. There are also other factors
    to take into account when deciding to use a property.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置的`property`模糊了行为和数据之间的界限，因此在选择属性、方法或属性时可能会感到困惑。在之前提到的`Color_VP`类示例中，我们在设置属性时添加了参数值验证。在`NorwegianBlue`类示例中，当设置和删除属性时，我们编写了详细的日志条目。在决定使用属性时，还有其他因素需要考虑。
- en: In Python, data, properties, and methods are all attributes of a class. The
    fact that a method is callable does not distinguish it from other types of attributes;
    indeed, we'll see in *Chapter 8*, *The Intersection of Object-Oriented and Functional
    Programming*, that it is possible to create normal objects that can be called
    like functions. We'll also discover that functions and methods are themselves
    ordinary objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，数据、属性和方法都是类的属性。一个方法是否可调用并不能将其与其他类型的属性区分开来；实际上，我们将在第8章“面向对象编程与函数式编程的交汇”中看到，可以创建出可以像函数一样调用的普通对象。我们还将发现函数和方法本身也是普通对象。
- en: 'The fact that methods are callable attributes, and properties are also attributes,
    can help us make this decision. We suggest the following principles:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是可调用的属性，而属性也是属性，这一事实可以帮助我们做出这个决定。我们建议以下原则：
- en: Use methods to represent actions; things that can be done to, or performed by,
    the object. When you call a method, even with only one argument, it should *do* something.
    Method names are generally verbs.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法来表示动作；可以作用于对象或由对象执行的事情。当你调用一个方法时，即使只有一个参数，它也应该*做*一些事情。方法名通常是动词。
- en: Use attributes or properties to represent the state of the object. These are
    the nouns, adjectives, and prepositions that describe an object.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性或特性来表示对象的状态。这些是描述对象的名词、形容词和介词。
- en: Default to ordinary (non-property) attributes, initialized in the `__init__()`
    method. These must be computed eagerly, which is a good starting point for any
    design.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认为普通（非属性）属性，在`__init__()`方法中初始化。这些必须在急切模式下计算，这对于任何设计都是一个良好的起点。
- en: Use properties for attributes in the exceptional case when there's a computation
    involved with setting or getting (or deleting) an attribute. Examples include
    data validation, logging, and access controls. We'll look at cache management
    in a moment. We can also use properties for lazy attributes, where we want to
    defer the computation because it's costly and rarely needed.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置或获取（或删除）属性时涉及计算的特殊情况下，请使用属性。例如，包括数据验证、日志记录和访问控制。我们稍后会看看缓存管理。我们还可以使用属性来处理延迟属性，因为我们希望延迟计算，因为这种计算成本高昂且很少需要。
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更现实的例子。自定义行为的一个常见需求是缓存一个难以计算或查找代价高昂的值（例如，需要网络请求或数据库查询）。目标是本地存储该值，以避免重复调用昂贵的计算。
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then, we can locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在属性上自定义获取器来实现这一点。第一次检索值时，我们执行查找或计算。然后，我们可以在我们的对象上本地缓存该值作为私有属性（或在专门的缓存软件中），下次请求该值时，我们返回存储的数据。以下是我们可以如何缓存网页的示例：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll only read the website content once, when `self._content` has the initial
    value of `None`. After that, we''ll return the value most recently read for the
    site. We can test this code to see that the page is only retrieved once:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会读取网站内容一次，当`self._content`的初始值为`None`时。之后，我们将返回最近读取的网站值。我们可以测试这段代码以验证页面只被检索一次：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果？
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It took about 1.388 seconds to retrieve a page from the `ccphilips.net` web
    host. The second fetch – from a laptop's RAM – takes 0.01 milliseconds! This is
    sometimes written as 10 μs, 10 microseconds. Since this is the last digit, we
    can suspect it's subject to rounding, and the time may be only half that, perhaps
    as little as 5 μs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ccphilips.net`网站主机检索一页需要大约1.388秒。第二次获取——从笔记本电脑的RAM中——仅需0.01毫秒！这有时被写作10 μs，即10微秒。由于这是最后一位数字，我们可以怀疑它可能受到四舍五入的影响，因此时间可能只有一半，也许少到5
    μs。
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义获取器对于需要根据其他对象属性动态计算属性的属性也非常有用。例如，我们可能想要计算一个整数列表的平均值：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This small class inherits from `list`, so we get list-like behavior for free.
    We added a property to the class, and – hey, presto! – our list can have an average
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小类继承自`list`，因此我们免费获得了类似列表的行为。我们给这个类添加了一个属性，然后——嘿，魔术般地！——我们的列表可以这样计算平均值：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, we could have made this a method instead, but if we do, then we ought
    to call it `calculate_average()`, since methods represent actions. But a property
    called `average` is more suitable, and is both easier to type and easier to read.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以将其做成一个方法，但如果我们这样做，那么我们应该将其命名为 `calculate_average()`，因为方法代表动作。但是，一个名为
    `average` 的属性更为合适，它既容易输入也容易阅读。
- en: We can imagine a number of similar reductions, including minimum, maximum, standard
    deviation, median, and mode, all being properties of a collection of numbers.
    This can simplify a more complex analysis by encapsulating these summaries into
    the collection of data values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象出许多类似的缩减，包括最小值、最大值、标准差、中位数和众数，这些都是数字集合的性质。通过将这些摘要封装到数据值集合中，这可以简化更复杂的分析。
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义设置器对于验证很有用，正如我们之前所看到的，但它们也可以用来代理一个值到另一个位置。例如，我们可以在`WebPage`类中添加一个内容设置器，每当值被设置时，它会自动登录到我们的网络服务器并上传一个新的页面。
- en: Manager objects
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理员对象
- en: We've been focused on objects and their attributes and methods. Now, we'll take
    a look at designing higher-level objects; the kind of objects that manage other
    objects – the objects that tie everything together. These are sometimes called
    Façade objects because they present a pleasant, easy-to-use façade over some underlying
    complexity. See *Chapter 12*, *Advanced Design Patterns*, for an additional look
    at the Façade design pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直专注于对象及其属性和方法。现在，我们将探讨设计更高级的对象；这类对象管理其他对象——将一切联系在一起的对象。这些对象有时被称为外观对象，因为它们在底层复杂性之上提供了一个令人愉悦、易于使用的界面。请参阅*第12章*，*高级设计模式*，以了解外观设计模式的更多内容。
- en: Most of the previous examples tend to model concrete ideas. Management objects
    are more like office managers; they don't do the actual visible work out on the
    floor, but without them, there would be no communication between departments,
    and nobody would know what they are supposed to do (although, this can be true
    anyway if the organization is badly managed!). Analogously, the attributes on
    a management class tend to refer to other objects that do the visible work; the
    behaviors on such a class delegate to those other classes at the right time, and
    pass messages between them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数之前的例子倾向于模拟具体的概念。管理对象更像是办公室经理；他们并不在地板上实际进行可见的工作，但如果没有他们，部门之间将没有沟通，没有人会知道他们应该做什么（尽管，如果组织管理不善，这也可能是真的！）类似地，管理类上的属性往往指的是那些进行可见工作的其他对象；这类对象的行为会在适当的时候委托给那些其他类，并在它们之间传递消息。
- en: A manager relies on composite design. We assemble a manager class by knitting
    other objects together. The overall behavior of the manager emerges from the interaction
    of objects. To an extent, a manager is also an Adapter among the various interfaces.
    See *Chapter 12*, *Advanced Design Patterns*, for an additional look at the Adapter
    design pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 经理依赖于组合设计。我们通过将其他对象编织在一起来组装一个经理类。经理的整体行为来自于对象的交互。在一定程度上，经理在各种接口之间也是一个适配器。参见
    *第12章*，*高级设计模式*，以了解适配器设计模式的更多内容。
- en: As an example, we'll write a program that does a find-and-replace action for
    text files stored in a compressed archive file, either a ZIP archive or a TAR
    archive. We'll need objects to represent the archive file as a whole and each
    individual text file (luckily, we don't have to write these classes, as they're
    available in the Python standard library).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个程序，用于对存储在压缩归档文件中的文本文件执行查找和替换操作，无论是ZIP归档还是TAR归档。我们需要对象来代表整个归档文件以及每个单独的文本文件（幸运的是，我们不需要编写这些类，因为它们在Python标准库中已有提供）。
- en: 'An overall manager object will be responsible for ensuring the following three
    steps occur:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个总体管理对象将负责确保以下三个步骤发生：
- en: Unzipping the compressed file to examine each member
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩压缩文件以检查每个成员
- en: Performing the find-and-replace action on text members
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本成员上执行查找和替换操作
- en: Zipping up the new files with the untouched as well as changed members
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件压缩，包括未更改和已更改的成员
- en: Note that we have to choose between an eager and a lazy approach to the three
    steps of this process. We can eagerly unzip (or untar) the entire archive, process
    all the files, and then build a new archive. This tends to use a lot of disk space.
    An alternative is to lazily extract items one at a time from the archive, perform
    the find-and-replace, and then build a new compressed archive as we go. The lazy
    approach doesn't require as much storage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须在这三个步骤中选择一种急切或懒惰的方法。我们可以急切地解压（或解tar）整个存档，处理所有文件，然后构建一个新的存档。这通常会占用大量磁盘空间。另一种方法是懒惰地从存档中逐个提取项目，执行查找和替换，然后在进行过程中构建一个新的压缩存档。懒惰的方法不需要那么多的存储空间。
- en: This design will knit together elements of the `pathlib`, `zipfile`, and the
    regular expression (`re`) module. The initial design will be focused on the job
    at hand. Later in this chapter, we'll rethink this design as new requirements
    surface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计将整合`pathlib`、`zipfile`以及正则表达式（`re`）模块的元素。初始设计将专注于当前任务。在本章的后续部分，随着新需求的浮现，我们将重新思考此设计。
- en: 'The class is initialized with the archive file''s name. We don''t do anything
    else upon creation. We''ll define a method with a good, clear verb in its name
    that does any processing:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类初始化时使用存档文件的名称。创建时我们不做其他任何事情。我们将定义一个方法，其名称中包含一个良好、清晰的动词，用于执行任何处理：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given the archive, the filename pattern to match, and the strings to work with,
    the object will have everything it needs. We might provide arguments like `ZipReplace(Path("sample.zip"),
    "*.md", "xyzzy", "xyzzy")`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 给定存档、要匹配的文件名模式和要处理的字符串，该对象将拥有它所需的一切。我们可能会提供类似 `ZipReplace(Path("sample.zip"),
    "*.md", "xyzzy", "xyzzy")` 的参数。
- en: 'The overall manager method for the find-and-replace operation revises a given
    archive. This method of the `ZipReplace` class (started above) uses two other
    methods and delegates most of the real work to other objects:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查找和替换操作的整体管理方法修订了一个给定的存档。这个`ZipReplace`类（如上所述）的方法使用了另外两种方法，并将大部分实际工作委托给其他对象：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `make_backup()` method will use the `pathlib` module to rename the old ZIP
    file so it's obviously the backup copy, untouched. This backup copy is input to
    the `copy_and_transform()` method. The original name will be the final output,
    also. This makes it look like the file was updated "in place." In fact, a new
    file was created, but the old name will be assigned to the new content.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_backup()` 方法将使用 `pathlib` 模块重命名旧的 ZIP 文件，使其显然是备份副本，未被修改。这个备份副本将被输入到 `copy_and_transform()`
    方法中。原始名称也将是最终的输出。这使得看起来文件是在原地更新的。实际上，创建了一个新文件，但旧名称将被分配给新的内容。'
- en: We create two context managers (a special kind of manager) to control the open
    files. An open file is entangled with operating system resources. In the case
    of a ZIP file or TAR archive, there are summaries and checksums that need to be
    properly written when the file is closed. Using a context manager assures that
    this additional work is done, and done properly, in spite of any exceptions being
    raised. All file operations should be wrapped in a `with` statement to leverage
    Python's context manager and handle proper cleanup. We'll look at this again in
    *Chapter 9*, *Strings, Serialization, and File Paths*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个上下文管理器（一种特殊的管理器）来控制打开的文件。打开的文件与操作系统资源相互纠缠。在ZIP文件或TAR存档的情况下，当文件关闭时，需要正确地写入摘要和校验和。使用上下文管理器可以确保即使抛出任何异常，这项额外的工作也会被正确地完成。所有文件操作都应该用`with`语句包装，以利用Python的上下文管理器并处理适当的清理。我们将在*第9章*，*字符串、序列化和文件路径*中再次探讨这个问题。
- en: The `copy_and_transform()` method uses methods of the two `ZipFile` instances
    and the `re` module to transform members of the original file. Since a backup
    was made of the original file, this will build the output file from the backup
    file. It examines each member of the archive, performing a number of steps, including
    expanding the compressed data, doing the transformation with a `transform()` method,
    and compressing to write to the output file, and then cleaning up the temporary
    file (and directories).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy_and_transform()` 方法使用两个 `ZipFile` 实例的方法和 `re` 模块来转换原始文件中的成员。由于已经备份了原始文件，这将从备份文件构建输出文件。它检查存档中的每个成员，执行一系列步骤，包括展开压缩数据，使用
    `transform()` 方法进行转换，并将压缩数据写入输出文件，然后清理临时文件（和目录）。'
- en: 'Obviously, we could do all of these steps in one method of a class, or indeed
    do the whole thing in one complex script, without ever creating an object. There
    are several advantages to separating the steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以在一个类的方法中完成所有这些步骤，或者实际上在一个复杂的脚本中完成所有这些步骤，而不需要创建任何对象。将步骤分开有几个优点：
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method name describes what the method does, and
    less additional documentation is required to understand what is going on.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：每个步骤的代码都包含在一个独立的单元中，易于阅读和理解。方法名称描述了该方法的功能，因此不需要额外的文档就能理解正在发生的事情。'
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `copy_and_transform()` method, reusing all
    the supporting methods because they apply to any file irrespective of the kind
    of archive.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果一个子类想要使用压缩的TAR文件而不是ZIP文件，它可以覆盖`copy_and_transform()`方法，重用所有支持的方法，因为它们适用于任何文件，无论其归档类型为何。'
- en: '**Partitioning**: An external class could create an instance of this class
    and use `make_backup()` or the `copy_and_transform()` methods directly, bypassing
    the `find_and_replace()` manager.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区**：外部类可以创建此类的实例，并直接使用 `make_backup()` 或 `copy_and_transform()` 方法，绕过 `find_and_replace()`
    管理器。'
- en: 'These two methods of the `ZipReplace` class (started above) make the backup
    copy and create the new file by reading from the backup and writing new items
    after they''ve been modified:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZipReplace` 类（如上所述）的这两种方法通过从备份中读取并在修改后写入新项目来创建备份副本和创建新文件：'
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `make_backup()` method applies a common strategy to avoid damaging a file.
    The original file is renamed to preserve it, and a new file is created that will
    have the original file's name. This method is designed to be independent of the
    file type or other processing details.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_backup()` 方法应用了一种常见的策略来避免损坏文件。原始文件会被重命名以保留它，并且会创建一个新的文件，该文件将具有原始文件的名字。此方法旨在与文件类型或其他处理细节无关。'
- en: 'The `copy_and_transform()` function method builds the new archive out of members
    extracted from the original archive. It performs a number of steps for each member
    of the archive:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy_and_transform()` 函数方法从原始存档中提取成员来构建新的存档。它为存档的每个成员执行一系列步骤：'
- en: Extract this file from the original archive.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从原始存档中提取此文件。
- en: If the item is not a directory (this is unlikely, but still possible), and the
    name matches the wild-card pattern, we want to transform it. This is a three-step
    process.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该项目不是一个目录（这不太可能，但仍然有可能），并且名称与通配符模式匹配，我们希望对其进行转换。这是一个三步的过程。
- en: Read the file's text.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件的文本。
- en: Transform the file, using the `sub()` function of the `re` module.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`re`模块的`sub()`函数转换文件。
- en: Write the text, replacing the extracted file. This is where we create a copy
    of the content.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本写入，替换提取的文件。这是我们创建内容副本的地方。
- en: Compress the file – either an untouched file or a transformed file – into the
    new archive.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件（无论是未修改的文件还是已转换的文件）压缩成新的存档。
- en: We unlink the temporary copy. If there are no links left to the file, it will
    be deleted by the operating system.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们断开临时副本的链接。如果没有其他链接指向该文件，操作系统将会将其删除。
- en: We clean up any temporary directories created by the extraction process.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们清理提取过程创建的任何临时目录。
- en: The `copy_and_transform()` method's operations span the `pathlib`, `zipfile`,
    and `re` modules. Wrapping these operations up into a manager that uses context
    managers gives us a tidy package with a small interface.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy_and_transform()` 方法所执行的操作涵盖了 `pathlib`、`zipfile` 和 `re` 模块。将这些操作封装到一个使用上下文管理器的管理器中，为我们提供了一个接口小巧的整洁包。'
- en: 'We can create a main script to use the `ZipReplace` class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个主脚本以使用`ZipReplace`类：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've provided the archive (`sample.zip`), the file matching pattern (`*.md`),
    the string to replace (`xyzzy`), and the final replacement (`plover's egg`). This
    will perform a complex series of file operations. A more practical approach is
    to use the `argparse` module to define the **command-line interface** (**CLI**)
    for this application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了存档文件(`sample.zip`)，文件匹配模式(`*.md`)，要替换的字符串(`xyzzy`)，以及最终的替换内容(`plover's
    egg`)。这将执行一系列复杂的文件操作。一个更实用的方法是使用`argparse`模块为这个应用程序定义**命令行界面**（**CLI**）。
- en: For brevity, the details are sparsely documented. Our current focus is on object-oriented
    design; if you are interested in the inner details of the `zipfile` module, refer
    to the documentation in the standard library, either online or by typing `import
    zipfile` and `help(zipfile)` into your interactive interpreter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，细节部分被简要地记录。我们目前的重点是面向对象设计；如果您对`zipfile`模块的内部细节感兴趣，请参考标准库中的文档，无论是在线还是通过在您的交互式解释器中输入`import
    zipfile`和`help(zipfile)`。
- en: Of course, an instance of the `ZipReplace` class does not have to be created
    from the command line; our class could be imported into another module (to perform
    batch ZIP file processing), or accessed as part of a GUI interface or even a higher-level
    manager object that knows where to get ZIP files (for example, to retrieve them
    from an FTP server or back them up to an external disk).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ZipReplace` 类的实例不必从命令行创建；我们的类可以被导入到另一个模块中（以执行批量 ZIP 文件处理），或者作为 GUI 界面的一部分，甚至是一个更高级的管理对象的一部分，该对象知道如何获取
    ZIP 文件（例如，从 FTP 服务器检索或将其备份到外部磁盘）。
- en: The benefit of the Façade and Adapter design patterns is to encapsulate complexity
    into a more useful class design. These composite objects tend to be less like
    physical objects, and enter the realm of conceptual objects. When we step away
    from objects that have a close parallel with the real world, the methods are actions
    that change the state of those concepts; care is required because the simple analogies
    start to disappear in the haze of ideas. It helps when the foundation is a set
    of concrete data values and well-defined behaviors.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Façade 和 Adapter 设计模式的益处在于将复杂性封装到一个更有用的类设计中。这些组合对象往往不像物理对象那样，而是进入了概念对象的领域。当我们远离与真实世界有紧密对应关系的对象时，方法就是改变这些概念状态的行为；需要小心谨慎，因为简单的类比在思想的迷雾中开始消失。当基础是一组具体的数据值和定义良好的行为时，这会很有帮助。
- en: A good example to bear in mind is the World Wide Web. A *web server* provides
    *content* to *browsers*. The content can include JavaScript that behaves like
    a desktop application which reaches out to other web servers to present content.
    These conceptual relationships are implemented by tangible transfers of bytes.
    It also includes a browser to paint pages of text, images, video, or sound. The
    foundation is transfers of bytes, a tangible action. In a classroom setting, it's
    possible to have developers pass sticky notes and rubber balls to each other to
    represent requests and responses.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得记住的好例子是万维网。一个 *web服务器* 为 *浏览器* 提供内容。内容可以包括像桌面应用程序一样行为的JavaScript，它连接到其他web服务器以展示内容。这些概念关系通过实际的字节传输来实现。它还包括一个浏览器来绘制文本、图像、视频或声音的页面。其基础是字节传输，这是一个实际的动作。在课堂环境中，开发者们可以通过传递粘性便签和橡胶球来代表请求和响应。
- en: This example works nicely. When we're confronted with additional requirements,
    we need to find a way to build new, related features without duplicating code.
    We'll talk about this engineering imperative first, then look at the revised design.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子工作得很好。当我们面临额外需求时，我们需要找到一种方法来构建新的、相关的功能，而不重复代码。我们首先讨论这个工程必要性，然后查看修订后的设计。
- en: Removing duplicate code
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除重复代码
- en: Often, the code in management-style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss some design principles.
    Specifically, why is duplicate code a bad thing?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，管理风格类如`ZipReplace`中的代码相当通用，可以以多种方式应用。可以使用组合或继承来帮助将此代码集中在一个地方，从而消除重复代码。在我们查看任何此类示例之前，让我们讨论一些设计原则。特别是，为什么重复代码是一件坏事？
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy and paste the old code and change whatever needs to
    be changed (variable names, logic, comments) to make it work in the new location.
    Alternatively, if we're writing new code that seems similar, but not identical,
    to code elsewhere in the project, it is often easier to write fresh code with
    similar behavior, rather than figuring out how to extract the overlapping functionality.
    We sometimes call this copy-pasta programming because the result is a big mass
    of tangled noodles of code, like a bowl of spaghetti.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因，但它们都归结为可读性和可维护性。当我们编写一个与早期代码相似的新代码时，最简单的事情就是复制粘贴旧代码，并更改需要更改的内容（变量名、逻辑、注释），使其在新位置工作。或者，如果我们正在编写看起来与项目中的其他代码相似，但又不完全相同的新代码，那么编写具有相似行为的全新代码通常比找出如何提取重叠功能要容易得多。我们有时称这种编程为复制粘贴编程，因为结果是大量纠缠在一起的代码团块，就像一碗意大利面一样。
- en: But as soon as someone trying to understand the code comes across duplicate
    (or nearly duplicate) code blocks, they now have an *additional* barrier to understanding.
    There's an intellectual friction created by a number of side-bar questions. Are
    they truly identical? If not, how is one section different from the other? What
    parts are the same? Under what conditions is one section called? When do we call
    the other? You might argue that you're the only one reading your code, but if
    you don't touch that code for eight months, it will be as incomprehensible to
    you as it is to a fresh coder. When we're trying to read two similar pieces of
    code, we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当试图理解代码的人遇到重复（或几乎重复）的代码块时，他们现在又遇到了一个*额外的*理解障碍。由于一系列的辅助问题而产生了一种智力摩擦。它们真的是完全相同的吗？如果不是，一个部分与另一个部分有什么不同？哪些部分是相同的？在什么条件下调用一个部分？我们什么时候调用另一个？你可能认为只有你在阅读你的代码，但如果你八个月都没有接触过那段代码，它对你来说将和对于一个新手程序员一样难以理解。当我们试图阅读两段相似的代码时，我们必须理解它们为什么不同，以及它们是如何不同的。这浪费了读者的时间；代码应该首先被编写成易于阅读的。
- en: '[*Dusty here, stepping out of formal author mode*] I once had to try to understand
    someone''s code that had three identical copies of the same 300 lines of very
    poorly written code. I had been working with the code for a month before I finally
    comprehended that the three *identical* versions were actually performing slightly
    different tax calculations. Some of the subtle differences were intentional, but
    there were also obvious areas where someone had updated a calculation in one function
    without updating the other two. The number of subtle, incomprehensible bugs in
    the code could not be counted. I eventually replaced all 900 lines with an easy-to-read
    function of 20 lines or so.'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[*Dusty here, stepping out of formal author mode*] 我曾经不得不尝试理解一段代码，这段代码有三个完全相同的300行糟糕的代码副本。我在这个代码上工作了整整一个月，才最终明白这三个*相同*的版本实际上执行的是略微不同的税务计算。其中一些细微的差异是有意为之，但也有明显的地方，有人在更新了一个函数中的计算时，没有更新其他两个函数。代码中细微、难以理解的错误数量无法计数。我最终用大约20行的易读函数替换了所有900行。'
- en: 'As the preceding story suggests, keeping two similar pieces of code up to date
    can be a nightmare. We have to remember to update both sections whenever we update
    one of them, and we have to remember how multiple sections differ so we can modify
    our changes when we are editing each of them. If we forget to update all sections,
    we will end up with extremely annoying bugs that usually manifest themselves as:
    "*But I fixed that already, why is it still happening?*"'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的故事所暗示的那样，保持两段相似代码的更新可能是一场噩梦。我们每次更新其中一段时，都必须记得更新两个部分，而且我们还得记得多个部分之间的差异，以便在编辑每个部分时修改我们的更改。如果我们忘记更新所有部分，最终可能会遇到极其烦人的错误，通常表现为：“*我已经修复了那个问题，为什么它还在发生？*”
- en: The key factor here is the time spent in troubleshooting, maintenance, and enhancement
    compared with the time spent initially creating the code. Software that's in use
    for more than a few weeks will have a lot more eyeballs on it than the time spent
    creating it. The tiny bit of time we "save" by copying and pasting existing code
    is more than wasted when we have to maintain it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的因素是解决故障、维护和改进所花费的时间与最初创建代码所花费的时间相比。软件在使用几周以上的时间内，其受到的关注将远远超过创建它所花费的时间。当我们不得不维护它时，通过复制粘贴现有代码所节省的那一点点时间，实际上是被浪费的。
- en: One of the author's personal bests was an application that was in use for almost
    seventeen years. If other developers and users wasted one extra day each year
    trying to sort out some confusing part of the code, it means the author should
    have spent at least two more weeks improving the code to head off this future
    maintenance cost.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作者个人最佳成就之一是一款使用了近十七年的应用程序。如果其他开发者和用户每年浪费额外的一天试图整理代码中的某些令人困惑的部分，这意味着作者本应至少再花上两周时间改进代码，以避免未来的维护成本。
- en: Code is both read and modified many more times and much more often than it is
    written. Comprehensible code should always be a priority.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被读取和修改的次数远多于被编写的次数，可读的代码始终应该是首要考虑的。
- en: 'This is why programmers, especially Python programmers (who tend to value elegant
    code more than average developers), follow what is known as the **Don''t Repeat
    Yourself** (**DRY**) principle. Our advice for beginner programmers is to never
    use the copy-and-paste feature of their editor. To intermediate programmers: think
    thrice before hitting Ctrl + C.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员，尤其是Python程序员（他们往往比普通开发者更重视代码的优雅性），会遵循所谓的**不要重复自己**（**DRY**）原则。我们给初学者的建议是永远不要使用编辑器的复制粘贴功能。对于中级程序员：在按下 Ctrl + C 之前三思。
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a strictly object-oriented solution,
    but it is frequently optimal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该做什么来避免代码重复呢？最简单的解决方案通常是把代码移动到一个接受参数的函数中，以处理那些不同的部分。这并不是一个严格面向对象的解决方案，但它通常是最佳选择。
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily replace it with a function that accepts a parameter
    for the directory to which it should be unzipped. This may make the function itself
    slightly longer. The size of a function – measured as lines of code – isn't a
    good metric for readability. No one wins at code golf.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有两个将 ZIP 文件解压到两个不同目录的代码片段，我们可以轻松地用一个接受参数的函数来替换它，该参数指定了应该解压到的目录。这可能会使函数本身稍微长一些。函数的大小——以代码行数来衡量——并不是衡量可读性的好指标。在代码高尔夫比赛中，没有人能获胜。
- en: Good names and docstrings are essential. Each class, method, function, variable,
    property, attribute, module, and package name should be chosen thoughtfully. When
    writing docstrings, don't explain how the code works (the code should do that).
    Be sure to focus on what the code's purpose is, what the preconditions are for
    using it, and what will be true after the function or method has been used.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好的名称和文档字符串是必不可少的。每个类、方法、函数、变量、属性、属性、模块和包名都应该经过深思熟虑的选择。在编写文档字符串时，不要解释代码是如何工作的（代码应该做到这一点）。务必关注代码的目的、使用它的先决条件以及函数或方法使用后将会是什么情况。
- en: 'The moral of the story is: always make the effort to refactor your code to
    be easier to read, instead of writing bad code that may seem easier to write.
    Now we can look at the revised design to the `ZipReplace` class definition.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义是：总是努力重构你的代码，使其更易于阅读，而不是编写看似更容易编写但质量较差的代码。现在我们可以查看`ZipReplace`类定义的修订版设计。
- en: In practice
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实践中
- en: Let's explore two ways we can reuse our existing code. After writing our code
    to replace strings in a ZIP file full of text files, we are later contracted to
    scale all the images in a ZIP file to a size suitable for mobile devices. While
    resolutions vary, 640 x 960 is about the smallest we need. It looks like we could
    use a very similar paradigm to what we used in `ZipReplace`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索两种我们可以重用现有代码的方法。在编写代码以替换一个包含文本文件的ZIP文件中的字符串之后，我们后来被委托将ZIP文件中的所有图片缩放到适合移动设备的尺寸。虽然分辨率各不相同，但640
    x 960大约是我们需要的最小尺寸。看起来我们可以使用与我们在`ZipReplace`中使用的非常相似的方法。
- en: Our first impulse might be to save a copy of that module and change the `find_replace`
    method to `scale_image` or something similar in the copy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一反应可能是保存该模块的副本，并将副本中的`find_replace`方法更改为`scale_image`或类似的名称。
- en: 'This processing will rely on the Pillow library to open an image file, scale
    it, and save it. The Pillow image processing tools can be installed with the following
    command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此处理将依赖于Pillow库来打开图像文件，调整其大小，并将其保存。可以使用以下命令安装Pillow图像处理工具：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will provide some great image-processing tools.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供一些优秀的图像处理工具。
- en: As we noted above in the *Removing duplicate code* section of this chapter,
    this copy-and-paste programming approach is suboptimal. What if someday we want
    to change the `unzip` and `zip` methods to also open TAR files? Or maybe we'll
    want to use a guaranteed unique directory name for temporary files. In either
    case, we'd have to change it in two different places!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们上文在本章的*移除重复代码*部分所述，这种复制粘贴的编程方法并不是最佳选择。如果我们有一天想要将`unzip`和`zip`方法修改为也能打开TAR文件呢？或者我们可能希望为临时文件使用一个保证唯一的目录名。在任何一种情况下，我们都不得不在两个不同的地方进行修改！
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First, we''ll modify our original `ZipReplace` class into a superclass for processing
    ZIP files in a variety of ways:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示一个基于继承的解决方案来解决这个问题。首先，我们将修改我们的原始`ZipReplace`类，使其成为一个超类，用于以多种方式处理ZIP文件：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We dropped the three parameters to `__init__()`, `pattern`, `find`, and `replace`,
    that were specific to `ZipReplace`. Then, we renamed the `find_replace()` method
    to `process_files()`. We decomposed the complex `copy_and_transform()` method
    and made it call several other methods to do the real work. This includes a placeholder
    for a `transform()` method. These name changes help demonstrate the more generalized
    nature of our new class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`__init__()`、`pattern`、`find`和`replace`这四个特定于`ZipReplace`的参数移除，并将`find_replace()`方法重命名为`process_files()`。我们将复杂的`copy_and_transform()`方法分解，使其调用其他几个方法来完成实际工作。这包括一个用于`transform()`方法的占位符。这些名称更改有助于展示我们新类更通用的特性。
- en: This new `ZipProcessor` class is a subclass of `ABC`, an abstract base class,
    allowing us to provide placeholders instead of methods. (More on ABCs to come
    in *Chapter 6*, *Abstract Base Classes and Operator Overloading*.) This abstract
    class doesn't actually define a `transform()` method. If we try to create an instance
    of the `ZipProcessor` class, the missing `transform()` method will raise an exception.
    The formality of an `@abstractmethod` decoration makes it clear that there's a
    piece missing, and the piece must have the expected shape.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `ZipProcessor` 类是 `ABC` 的子类，其中 `ABC` 是一个抽象基类，允许我们提供占位符而不是方法。（关于抽象基类的内容将在
    *第6章*，*抽象基类和运算符重载* 中详细介绍。）这个抽象类实际上并没有定义一个 `transform()` 方法。如果我们尝试创建 `ZipProcessor`
    类的实例，缺失的 `transform()` 方法将引发异常。`@abstractmethod` 装饰的正式性使得缺失的部分一目了然，并且这部分必须具有预期的形状。
- en: 'Now, before we move on to our image processing application, let''s create a
    version of our original `ZipReplace` class. This will be based on the `ZipProcessor`
    class to make use of this parent class, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续到图像处理应用之前，让我们创建一个原始`ZipReplace`类的版本。这个版本将基于`ZipProcessor`类，以便利用这个父类，如下所示：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code is shorter than the original version, since it inherits its ZIP processing
    abilities from the parent class. We first import the base class we just wrote
    and make `TextTweaker` extend that class. Then, we use `super()` to initialize
    the parent class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比原始版本更短，因为它从父类继承了ZIP处理能力。我们首先导入我们刚刚编写的基类，并让`TextTweaker`扩展这个类。然后，我们使用`super()`来初始化父类。
- en: 'We need two extra parameters, and we''ve used a technique called a *fluent
    interface* to provide the two parameters. The `find_and_replace()` method updates
    the state of the object, then returns the `self` object. This lets us use the
    class with a line of code like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个额外的参数，并且我们已经使用了一种称为*流畅接口*的技术来提供这两个参数。`find_and_replace()`方法更新对象的状态，然后返回`self`对象。这使得我们可以使用这个类，如下所示的一行代码：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We've created an instance of the class, used the `find_and_replace()` method
    to set some of the attributes, then used the `process_files()` method to start
    the processing. This is called a "fluent" interface because a number of methods
    are used to help clarify the parameters and their relationships.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类的实例，使用了`find_and_replace()`方法来设置一些属性，然后使用了`process_files()`方法来开始处理。这被称为“流畅”接口，因为使用了多个方法来帮助明确参数及其关系。
- en: We've done a fair amount of work to recreate a program that is functionally
    not different from the one we started with! But having done that work, it is now
    much easier for us to write other classes that operate on files in a ZIP archive,
    such as the (hypothetically requested) photo scaler.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了大量工作来重新创建一个在功能上与我们最初开始时没有区别的程序！但是完成这项工作后，我们现在写其他操作ZIP存档中文件的类要容易得多，例如（假设请求的）照片缩放器。
- en: Further, if we ever want to improve or bug fix the ZIP functionality, we can
    do it for all subclasses at once by changing only the one `ZipProcessor` base
    class. Therefore maintenance will be much more effective.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想要改进或修复ZIP功能中的错误，我们只需更改一个`ZipProcessor`基类，就可以一次性对所有子类进行操作。因此，维护工作将更加高效。
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 看看现在创建一个利用`ZipProcessor`功能进行图片缩放的类是多么简单：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file, scale it, and save it back. The `ZipProcessor` class takes
    care of the zipping and unzipping without any extra work on our part. This seems
    to be a huge win.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个类有多简单！我们之前所做的所有工作都得到了回报。我们只需打开每个文件，调整其大小，然后保存回去。`ZipProcessor` 类会处理压缩和解压缩，而不需要我们做任何额外的工作。这似乎是一个巨大的胜利。
- en: Creating reusable code isn't easy. It generally requires more than one use case
    to make it clear what parts are generic and what parts are specific. Because we
    need concrete examples, it pays to avoid over-engineering to strive for imagined
    reuse. This is Python and things can be very flexible. Rewrite as needed to cover
    the cases as they arrive on the scene.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可重用的代码并不容易。通常需要超过一个用例来明确哪些部分是通用的，哪些部分是特定的。因为我们需要具体的例子，所以避免过度设计，努力追求想象中的重用是值得的。这是Python，事物可以非常灵活。根据需要重写，以覆盖场景中出现的各种情况。
- en: Case study
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: In this chapter, we'll continue developing elements of the case study. We want
    to explore some additional features of object-oriented design in Python. The first
    is what is sometimes called "syntactic sugar," a handy way to write something
    that offers a simpler way to express something fairly complex. The second is the
    concept of a manager for providing a context for resource management.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续开发案例研究的元素。我们希望探索Python面向对象设计的一些附加功能。第一个有时被称为“语法糖”，这是一种方便的方式来编写一些提供更简单方式表达相对复杂内容的方法。第二个是管理者的概念，它为资源管理提供上下文。
- en: In *Chapter 4*, *Expecting the Unexpected*, we built an exception for identifying
    invalid input data. We used the exception for reporting when the inputs couldn't
    be used.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第四章*，*意料之外*中，我们为识别无效输入数据建立了一个异常。当输入数据无法使用时，我们使用这个异常来报告。
- en: 'Here, we''ll start with a class to gather data by reading the file with properly
    classified training and test data. In this chapter, we''ll ignore some of the
    exception-handling details so we can focus on another aspect of the problem: partitioning
    samples into testing and training subsets.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从一个类开始，通过读取经过适当分类的训练和测试数据文件来收集数据。在本章中，我们将忽略一些异常处理细节，以便我们能够专注于问题的另一个方面：将样本划分为测试集和训练集。
- en: Input validation
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入验证
- en: The `TrainingData` object is loaded from a source file of samples, named `bezdekIris.data`.
    Currently, we don't make a large effort to validate the contents of this file.
    Rather than confirm the data contains correctly formatted samples with numeric
    measurements and a proper species name, we simply create `Sample` instances, and
    hope nothing goes wrong. A small change to the data could lead to unexpected problems
    in obscure parts of our application. By validating the input data right away,
    we can focus on the problems and provide a focused, actionable report back to
    the user. Something like "Row 42 has an invalid petal_length value of '1b.25'"
    with the line of data, the column, and the invalid value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrainingData` 对象是从名为 `bezdekIris.data` 的样本源文件中加载的。目前，我们并没有对文件内容进行大量验证。我们不是确认数据是否包含格式正确、具有数值测量和适当物种名称的样本，而是简单地创建
    `Sample` 实例，并希望一切顺利。数据的一点点变化可能会导致我们应用程序中不为人知的部分出现意外问题。通过立即验证输入数据，我们可以专注于问题，并向用户提供专注的、可操作的报告。例如，“第42行有一个无效的
    petal_length 值 ''1b.25''”，并附带数据行、列和无效值。'
- en: A file with training data is processed in our application via the `load()` method
    of `TrainingData`. Currently, this method requires an iterable sequence of dictionaries;
    each individual sample is read as a dictionary with the measurements and the classification.
    The type hint is `Iterable[dict[str, str]]`. This is one way the `csv` module
    works, making it very easy to work with. We'll return to additional details of
    loading the data in *Chapter 8*, *The Intersection of Object-Oriented and Functional
    Programming*, and *Chapter 9*, *Strings, Serialization, and File Paths*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，通过`TrainingData`的`load()`方法处理带有训练数据的文件。目前，此方法需要一个字典的可迭代序列；每个单独的样本都被读取为一个包含测量和分类的字典。类型提示为`Iterable[dict[str,
    str]]`。这是`csv`模块工作的一种方式，使得与它一起工作变得非常容易。我们将在第8章“面向对象编程与函数式编程的交汇点”和第9章“字符串、序列化和文件路径”中返回到加载数据的更多细节。
- en: Thinking about the possibility of alternative formats suggests the `TrainingData` class
    should not depend on the `dict[str, str]` row definition suggested by CSV file
    processing. While expecting a dictionary of values for each row is simple, it
    pushes some details into the `TrainingData` class that may not belong there. Details
    of the source document's representation have nothing to do with managing a collection
    of training and test samples; this seems like a place where object-oriented design
    will help us disentangle the two ideas.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可能存在其他格式，这表明`TrainingData`类不应该依赖于CSV文件处理所建议的`dict[str, str]`行定义。虽然期望每行的值是一个字典很简单，但它将一些细节推入了`TrainingData`类，这些细节可能并不属于那里。源文档表示的细节与管理和测试样本集合无关；这似乎是面向对象设计将帮助我们解开这两个想法的地方。
- en: 'In order to support multiple sources of data, we will need some common rules
    for validating the input values. We''ll need a class like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个数据源，我们需要一些通用的规则来验证输入值。我们需要一个像这样的类：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This builds an instance of the `Sample` superclass from the input fields read
    by a CSV `DictReader` instance. The `sample_iter()` method uses a series of conversion
    expressions to translate input data from each column into useful Python objects.
    In this example, the conversions are simple, and the implementation is a bunch
    of `float()` functions to convert CSV string data into Python objects. We can
    imagine more complex conversions might be present for other problem domains.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从CSV `DictReader`实例读取的输入字段构建`Sample`超类的一个实例。`sample_iter()`方法使用一系列转换表达式将每列的输入数据转换为有用的Python对象。在这个例子中，转换是简单的，实现是一系列`float()`函数，用于将CSV字符串数据转换为Python对象。我们可以想象，对于其他问题域可能存在更复杂的转换。
- en: The `float()` functions – when confronted with bad data – will raise a `ValueError`.
    While this is helpful, a bug in a distance formula may also raise a `ValueError`,
    leading to possible confusion. It's slightly better for our application to produce
    unique exceptions; this makes it easier to identify a root cause for a problem.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`float()` 函数在遇到不良数据时将引发一个 `ValueError`。虽然这很有帮助，但距离公式中的错误也可能引发一个 `ValueError`，从而导致可能的混淆。对于我们的应用程序来说，产生独特的异常要稍微好一些；这使得更容易识别问题的根本原因。'
- en: The target type, `Sample`, is provided as a class-level variable, `target_class`.
    This lets us introduce a new subclass of `Sample` by making one relatively visible
    change. This isn't required, but a visible dependency like this provides a way
    to disentangle classes from each other.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 目标类型`Sample`作为一个类级别变量`target_class`提供，这使得我们可以通过一个相对明显的修改来引入`Sample`的新子类。这不是必需的，但像这样的可见依赖关系提供了一种将类彼此分离的方法。
- en: 'We''ll follow *Chapter 4*, *Expecting the Unexpected*, and define a unique
    exception definition. This is a better way to help disentangle our application''s
    errors from ordinary bugs in our Python code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循*第4章*，*意料之外*，并定义一个独特的异常定义。这是帮助我们将应用程序的错误与Python代码中的普通错误区分开来的更好方法：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To make use of this, we mapped the various `float()` problems signaled by `ValueError`
    exceptions to our application's `BadSampleRow` exception. This can help someone
    distinguish between a bad CSV source file and a bad computation due to a bug in
    a *k*-NN distance computation. While both can raise `ValueError` exceptions, the
    CSV processing exception is wrapped into an application-specific exception to
    disambiguate the context.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这一点，我们将由 `ValueError` 异常信号的各种 `float()` 问题映射到我们应用程序的 `BadSampleRow` 异常。这有助于区分一个坏的
    CSV 源文件和由于 *k*-NN 距离计算中的错误导致的坏计算。虽然两者都可能引发 `ValueError` 异常，但 CSV 处理异常被封装为特定于应用程序的异常，以消除歧义。
- en: We've done the exception transform by wrapping the creation of an instance of
    the target class in a `try:` statement. Any `ValueError` that's raised here will
    become a `BadSampleRow` exception. We've used a `raise...from...` so that the
    original exception is preserved to help with the debugging.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将目标类实例的创建包裹在`try:`语句中来执行异常转换。在这里引发的任何`ValueError`都将变为`BadSampleRow`异常。我们使用了`raise...from...`来保留原始异常，以便于调试。
- en: Once we have valid input, we have to decide whether the object should be used
    for training or testing. We'll turn to that problem next.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了有效的输入，我们必须决定该对象是用于训练还是测试。我们将在下一节讨论这个问题。
- en: Input partitioning
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入分区
- en: The `SampleReader` class we just introduced uses a variable to identify what
    kind of objects to create. The `target_class` variable provides a class to use.
    Note that we need to be a little careful in the ways we refer to `SampleReader.target_class`
    or `self.target_class`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍的`SampleReader`类使用一个变量来标识要创建哪种类型的对象。`target_class`变量提供了一个要使用的类。请注意，我们在引用`SampleReader.target_class`或`self.target_class`时需要稍微小心一些。
- en: A simple expression like `self.target_class(sepal_length=, ... etc.)` looks
    like a method evaluation. Except, of course, `self.target_class` is not a method;
    it's another class. To make sure Python doesn't assume that `self.target_class()`
    refers to a method, we've assigned it to a local variable called `target_class`.
    Now we can use `target_class(sepal_length=, … etc.)` and there's no ambiguity.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个像 `self.target_class(sepal_length=, ... etc.)` 这样简单的表达式看起来像是一个方法调用。当然，`self.target_class`
    不是一个方法；它是一个另一个类。为了确保 Python 不会假设 `self.target_class()` 指的是一个方法，我们将其分配给一个名为 `target_class`
    的局部变量。现在我们可以使用 `target_class(sepal_length=, … etc.)` 而不会有歧义。
- en: This is pleasantly Pythonic. We can create subclasses of this reader to create
    different kinds of samples from the raw data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常符合Python的风格。我们可以创建这个读取器的子类，从而从原始数据中创建不同类型的样本。
- en: This `SampleReader` class definition exposes a problem. A single source of raw
    sample data needs to be partitioned into two separate subclasses of `KnownSample`;
    it's either a `TrainingSample` or a `TestingSample`. There's a tiny difference
    in behavior between these two classes. A `TestingSample` is used to confirm the
    *k*-NN algorithm works, and is used to compare an algorithmic classification against
    the expert Botanist-assigned species. This is not something a `TrainingSample`
    needs to do.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`SampleReader`类定义暴露了一个问题。单个原始样本数据源需要被分割成两个独立的`KnownSample`子类；它要么是`TrainingSample`要么是`TestingSample`。这两个类之间有细微的行为差异。`TestingSample`用于确认*k*-NN算法是否工作，并用于将算法分类与专家植物学家指定的物种进行比较。这不是`TrainingSample`需要做的事情。
- en: 'Ideally, a single reader would emit a mixture of the two classes. The design
    so far only allows for instances of a single class to be created. We have two
    paths forward to provide the needed functionality:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，单个读者会发出两种类型的混合。到目前为止的设计仅允许创建单个类别的实例。我们有两条前进路径来提供所需的功能：
- en: A more sophisticated algorithm for deciding what class to create. The algorithm
    would likely include an `if` statement to create an instance of one object or
    another.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更复杂的算法用于决定创建哪个类。该算法可能包括一个`if`语句来创建一个对象实例或另一个对象实例。
- en: A simplified definition of `KnownSample`. This single class can handle immutable
    training samples separately from mutable testing samples that can be classified
    (and reclassified) any number of times.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KnownSample`的简化定义。这个单一类可以分别处理不可变的训练样本和可变测试样本，后者可以被分类（并重新分类）任意多次。'
- en: 'Simplification seems to be a good idea. Less complexity means less code and
    fewer places for bugs to hide. The second alternative suggests we can separate
    three distinct aspects of a sample:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 简化似乎是一个好主意。更少的复杂性意味着更少的代码和更少的地方让错误隐藏。第二个选择建议我们可以将样本的三个不同方面分开：
- en: The "raw" data. This is the core collection of measurements. They are immutable.
    (We'll address this design variation in *Chapter 7*, *Python Data Structures*.)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"原始"数据。这是核心的测量集合。它们是不可变的。（我们将在*第7章*，*Python数据结构*中讨论这种设计变化。）'
- en: The Botanist-assigned species. This is available for training or testing data,
    but not part of an unknown sample. The assigned species, like the measurements,
    is immutable.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由植物学家指定的物种。这适用于训练或测试数据，但不属于未知样本的一部分。指定的物种，就像测量值一样，是不可变的。
- en: An algorithmically assigned classification. This is applied to the testing and
    unknown samples. This value can be seen as mutable; each time we classify a sample
    (or reclassify a test sample), the value changes.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法分配的分类。这应用于测试样本和未知样本。这个值可以看作是可变的；每次我们分类一个样本（或重新分类一个测试样本），这个值都会改变。
- en: This a profound change to the design created so far. Early in a project, this
    kind of change can be necessary. Way back in *Chapters 1* and *2*, we decided
    to create a fairly sophisticated class hierarchy for various kinds of samples.
    It's time to revisit that design. This won't be the last time we think through
    this. The essence of good design is to create and dispose of a number of bad designs
    first.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对迄今为止设计的一个深刻改变。在项目早期，这种改变可能是必要的。早在*第一章*和*第二章*，我们决定为各种样本创建一个相当复杂的类层次结构。是时候回顾那个设计了。这不会是我们最后一次思考这个问题。优秀设计的本质是首先创造和淘汰许多不良设计。
- en: The sample class hierarchy
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本类层次结构
- en: We can rethink our earlier designs from several points of view. One alternative
    is to separate the essential `Sample` class from the additional features. It seems
    like we can identify four additional behaviors for each `Sample` instance, shown
    in the following table.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从几个不同的角度重新思考我们早期的设计。一个替代方案是将必要的`Sample`类与附加功能分离。看起来我们可以为每个`Sample`实例识别出四种附加行为，如下表所示。
- en: '|  | Known | Unknown |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  | 已知 | 未知 |'
- en: '| --- | --- | --- |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Unclassified** | Training data | Sample waiting to be classified |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **未分类** | 训练数据 | 待分类的样本 |'
- en: '| **Classified** | Testing data | Classified sample |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **分类** | 测试数据 | 分类样本 |'
- en: We've omitted a detail from the **Classified** row. Each time we do a classification,
    a specific hyperparameter is associated with the resulting classified sample.
    It would be more accurate to say it's a sample classified by a specific `Hyperparameter`
    object. But this might be too much clutter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从**分类**行中省略了一个细节。每次我们进行分类时，都会有一个特定的超参数与生成的分类样本相关联。更准确地说，这是一个由特定的`超参数`对象进行分类的样本。但这可能会过于杂乱。
- en: The distinction between the two cells in the **Unknown** column is minute. The
    distinction is so minor as to be essentially irrelevant to most processing. An **Unknown** sample will
    be waiting to be classified for – at most – a few lines of code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在**未知**列中的两个单元格之间的区别非常微小。这种区别如此微小，以至于对大多数处理来说几乎无关紧要。一个**未知**样本将等待被分类，最多只需要几行代码。
- en: If we rethink this, we may be able to create fewer classes and still reflect
    the object state and behavior changes correctly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新思考这个问题，我们可能能够创建更少的类，同时仍然正确地反映对象状态和行为的变化。
- en: There can be two subclasses of `Sample` with a separate `Classification` object.
    Here's a diagram.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample`可以有两大子类，每个子类都有一个独立的`Classification`对象。下面是一个图示。'
- en: '![Diagram  Description automatically generated](img/B17070_05_01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_05_01.png)'
- en: 'Figure 5.1: Sample class diagram'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：示例类图
- en: 'We''ve refined the class hierarchy to reflect two essentially different kinds
    of samples:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经细化了类层次结构，以反映两种本质上不同的样本：
- en: A `KnownSample` instance can be used for testing or training. The difference
    between other classes is implemented in the method that does classification. We
    can make this depend on a `purpose` attribute, shown with a small square (or sometimes
    a "`-`") as a prefix. Python doesn't have private variables, but this marker can
    be helpful as a design note. The public attributes can be shown with a small circle
    (or a "`+`" to save space) as a prefix.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`KnownSample`实例可用于测试或训练。与其他类别的区别在于实现分类的方法。我们可以使这取决于一个`purpose`属性，用一个小方块（或有时用一个"`-`"作为前缀）来表示。Python没有私有变量，但这个标记可以作为设计笔记很有帮助。公共属性可以用一个小圆圈（或用一个"`+`"来节省空间）作为前缀来表示。
- en: When the purpose has a value of `Training`, the `classify()` method will raise
    an exception. The sample cannot be re-classified; that would invalidate the training.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当目的的值为`Training`时，`classify()`方法将引发异常。样本不能被重新分类；那样将使训练无效。
- en: When the purpose has a value of `Testing`, the `classify()` method will work
    normally, applying a given `Hyperparameter` to compute a species.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当目的的值为`Testing`时，`classify()`方法将正常工作，应用给定的`Hyperparameter`来计算一个物种。
- en: An `UnknownSample` instance can be used for user classification. The classification
    method here does not depend on the value of the `purpose` attribute, and always
    performs classification.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`UnknownSample`实例可用于用户分类。这里的分类方法不依赖于`purpose`属性值，并且始终执行分类。
- en: Let's look at implementing these behaviors with the `@property` decorator we
    learned about in this chapter. We can use `@property` to fetch computed values
    as if they were simple attributes. We can also use `@property` to define attributes
    that cannot be set.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用本章所学的`@property`装饰器来实现这些行为。我们可以使用`@property`来获取计算值，就像它们是简单的属性一样。我们还可以使用`@property`来定义不能设置的属性。
- en: The purpose enumeration
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目的列举
- en: 'We''ll start by enumerating a domain of `purpose` values:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先列举一个`目的`值域：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This definition creates a namespace with three objects we can use in our code:
    `Purpose.Classification`, `Purpose.Testing`, and `Purpose.Training`. For example,
    we can use `if sample.purpose == Purpose.Testing:` to identify a testing sample.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义创建了一个命名空间，其中包含三个我们可以在代码中使用的对象：`Purpose.Classification`、`Purpose.Testing`和`Purpose.Training`。例如，我们可以使用`if
    sample.purpose == Purpose.Testing:`来识别一个测试样本。
- en: We can convert to `Purpose` objects from input values using `Purpose(x)` where `x` is
    an integer value, 0, 1, or 2\. Any other value will raise a `ValueError` exception.
    We can convert back to numeric values, also. For example, `Purpose.Training.value` is `1`.
    This use of numeric codes can fit well with external software that doesn't deal
    well with an enumeration of Python objects.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Purpose(x)`从输入值转换为`Purpose`对象，其中`x`是一个整数值，0、1或2。任何其他值都会引发一个`ValueError`异常。我们也可以将其转换回数值。例如，`Purpose.Training.value`的值为`1`。这种使用数值代码的方式可以很好地与那些不擅长处理Python对象枚举的外部软件兼容。
- en: 'We''ll decompose the `KnownSample` subclass of the `Sample` class into two
    parts. Here''s the first part. We initialize a sample with the data required by
    the `Sample.__init__()` method plus two additional values, the `purpose` numeric
    code, and the assigned species:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Sample`类的`KnownSample`子类分解为两部分。以下是第一部分。我们使用`Sample.__init__()`方法所需的数据初始化一个样本，并额外添加两个值，即`purpose`数值代码和分配的物种：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We validate the `purpose` parameter's value to be sure it decodes to either
    `Purpose.Training` or `Purpose.Testing`. If the `purpose` value isn't one of the
    two allowed values, we'll raise a `ValueError` exception because the data is unusable.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证`purpose`参数的值，以确保它解码为`Purpose.Training`或`Purpose.Testing`之一。如果`purpose`的值不是这两个允许的值之一，我们将引发一个`ValueError`异常，因为数据不可用。
- en: We've created an instance variable, `self._classification`, with a leading `_` name.
    This is a convention that suggests the name is not for general use by clients
    of this class. It's not "private," since there's no notion of privacy in Python.
    We could call it "concealed" or perhaps "watch out for surprises here."
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个实例变量，`self._classification`，其名称以`_`开头。这是一个约定，表明该名称不供此类客户端的通用使用。它不是“私有”的，因为在Python中没有隐私的概念。我们可以称之为“隐藏”或者“也许在这里留意惊喜”。
- en: Instead of a large, opaque wall available in some languages, Python uses a low,
    decorative floral border that sets this variable apart from the others. You can
    march right through the floral `_` character to look at the value closely, but
    you probably shouldn't.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些语言中可用的大型、不透明的墙不同，Python 使用一个低矮的装饰性花卉边框来区分这个变量与其他变量。你可以直接穿过花卉边框的 `_` 字符来近距离查看值，但你可能不应该这样做。
- en: 'Here''s the first `@property` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是第一个 `@property` 方法：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This defines a method that will be visible as an attribute name. Here''s an
    example of creating a sample for testing purposes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个将作为属性名称可见的方法。以下是一个创建用于测试目的示例的例子：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we evaluate `s2.classification`, this will call the method. This function
    makes sure this is a sample to be used for testing, and returns the value of the
    "concealed" instance variable `self._classification`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`s2.classification`时，这将调用该方法。此函数确保这是一个用于测试的样本，并返回“隐藏”的实例变量`self._classification`的值。
- en: If this is a `Purpose.Training` sample, the property will raise an `AttributeError`
    exception because any application that checks the value of the classification
    for a training sample has a bug in it that needs to be fixed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个`Purpose.Training`样本，该属性将引发一个`AttributeError`异常，因为任何检查训练样本分类值的应用程序中都有一个需要修复的错误。
- en: Property setters
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性设置器
- en: 'How do we set the classification? Do we really execute the statement `self._classification`
    `= h.classify(self)`? The answer is no – we can create a property that updates
    the "concealed" instance variable. This is a bit more complex than the example
    above:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何设置分类？我们真的执行了`self._classification = h.classify(self)`这个语句吗？答案是：不是——我们可以创建一个属性来更新“隐藏”的实例变量。这比上面的例子要复杂一些：
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The initial `@property` definition for `classification` is called a "getter."
    It gets the value of an attribute. (The implementation uses the `__get__()` method
    of a descriptor object that was created for us.) The `@property` definition for `classification` also
    creates an additional decorator, `@classification.setter`. The method decorated
    by the setter is used by assignment statements.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`classification`的初始`@property`定义被称为“获取器”。它获取一个属性值。（实现使用为我们创建的描述符对象的`__get__()`方法。）`classification`的`@property`定义还创建了一个额外的装饰器`@classification.setter`。由设置器装饰的方法被赋值语句使用。'
- en: Note that the method names for these two properties are both `classification`.
    This is the attribute name to be used.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个属性的名称都是`分类`。这是需要使用的属性名称。
- en: Now a statement like `s2.classification = h.classify(self)` will change the
    classification from a particular `Hyperparameter` object. This assignment statement
    will use the method to examine the purpose of this sample. If the purpose is testing,
    the value will be saved. If the purpose is not `Purpose.Testing`, then attempting
    to set a classification raises an `AttributeError` exception, and identifies a
    place where something's wrong in our application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像这样的语句`s2.classification = h.classify(self)`会将分类从特定的`Hyperparameter`对象中改变。这个赋值语句将使用该方法来检查这个样本的目的。如果目的是测试，则值将被保存。如果目的不是`Purpose.Testing`，那么尝试设置分类将引发`AttributeError`异常，并标识出我们应用程序中出错的地点。
- en: Repeated if statements
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复的if语句
- en: We have a number of `if` statements checking for specific `Purpose` values.
    This is a suggestion that this design is not optimal. The variant behavior is
    not encapsulated in a single class; instead, multiple behaviors are combined into
    a class.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个检查特定`Purpose`值的`if`语句。这表明这种设计可能不是最优的。变体行为并没有封装在一个单独的类中；相反，多个行为被组合到一个类中。
- en: The presence of a `Purpose` enumeration and `if` statements to check for the
    enumerated values is a suggestion that we have multiple classes. The "simplification"
    here isn't desirable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个`目的`枚举和用于检查枚举值的`if`语句，这表明我们可能有多个类。这里的“简化”并不令人满意。
- en: In the *Input partitioning* section of this case study, we suggested there were
    two paths forward. One was to try and simplify the classes by setting the `purpose` attribute
    to separate testing from training data. This seems to have added `if` statements,
    without really simplifying the design.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究的*输入分区*部分，我们建议有两条前进路径。一条是尝试通过将`purpose`属性设置为将测试数据与训练数据分开来简化类。这似乎增加了`if`语句，但实际上并没有简化设计。
- en: This means we'll have to search for a better partitioning algorithm in a later
    chapter's case study. For now, we have the capability of creating valid data,
    but we also have code that's cluttered with `if` statements. The reader is encouraged
    to try alternative designs to examine the resulting code to see what seems simpler
    and easier to read.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将在后续章节的案例研究中寻找更好的分区算法。目前，我们有能力创建有效数据，但我们也有代码中充斥着`if`语句的情况。鼓励读者尝试不同的设计方案，以检查生成的代码，看看哪种看起来更简单、更容易阅读。
- en: Recall
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'Here are some of the key points in this chapter:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键点如下：
- en: When we have both data and behavior, this is the sweet spot for object-oriented
    design. We can leverage Python's generic collections and ordinary functions for
    many things. When it becomes complex enough that we need to be sure that pieces
    are all defined together, then we need to start using classes.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们同时拥有数据和行为时，这就是面向对象设计的最佳状态。我们可以利用Python的泛型集合和普通函数来完成许多事情。当事情变得足够复杂，以至于我们需要确保所有部分都一起定义时，那么我们就需要开始使用类了。
- en: 'When an attribute value is a reference to another object, the Pythonic approach
    is to allow direct access to the attribute; we don''t write elaborate setter and
    getter functions. When an attribute value is computed, we have two choices: we
    can compute it eagerly or lazily. A property lets us be lazy and do the computation
    just in time.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性值是另一个对象的引用时，Python 的一种方法是允许直接访问该属性；我们不需要编写复杂的设置器和获取器函数。当属性值是计算得出的，我们有两种选择：我们可以立即计算它，或者延迟计算。属性允许我们延迟计算，仅在需要时进行。
- en: We'll often have cooperating objects; the behavior of the application emerges
    from the cooperation. This can often lead to manager objects that combine behaviors
    from component class definitions to create an integrated, working whole.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们经常会遇到协作对象；应用程序的行为是从协作中产生的。这通常会导致管理对象，它们将组件类定义中的行为组合起来，以创建一个集成、工作的整体。
- en: Exercises
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在面向对象的Python程序中，对象、数据和方法之间可以相互交互的各种方式。通常情况下，你的第一个想法应该是如何将这些原则应用到自己的工作中。你是否有任何杂乱的脚本，可以使用面向对象的管理器重写？浏览一下你的一些旧代码，寻找那些不是动作的方法。如果名称不是一个动词，尝试将其重写为一个属性。
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining, not code so old that you never want to touch
    it again. That will help to keep you interested when you do the improvements!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你在任何语言中编写的代码。它是否违反了DRY原则？有没有任何重复的代码？你是否复制粘贴了代码？你是否因为不想理解原始代码而编写了两个相似的代码版本？现在回顾一下你最近编写的代码，看看你是否可以使用继承或组合来重构重复的代码。尽量选择一个你仍然感兴趣维护的项目，而不是那些你再也不想触碰的旧代码。这有助于你在进行改进时保持兴趣！
- en: Now, look back over some of the examples we looked at in this chapter. Start
    with the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since `an_old_time`)
    to determine whether the cache has expired.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下本章中我们讨论的一些示例。从一个使用属性来缓存检索数据的缓存网页示例开始。这个示例的一个明显问题是缓存永远不会刷新。给属性的getter方法添加一个超时，只有当页面在超时之前被请求时，才返回缓存的页面。你可以使用`time`模块（`time.time()
    - an_old_time`返回自`an_old_time`以来经过的秒数）来确定缓存是否已过期。
- en: Also look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 还要看看基于继承的`ZipProcessor`。在这里使用组合而不是继承可能是合理的。你不需要在`ZipReplace`和`ScaleZip`类中扩展类，而是可以将这些类的实例传递给`ZipProcessor`构造函数，并调用它们来完成处理部分。实现这一点。
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important. If you find you prefer inheritance over composition,
    you need to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得哪个版本更容易使用？哪个更优雅？哪个更容易阅读？这些问题都是主观的；每个人的答案都不同。然而，知道答案是很重要的。如果你发现你更喜欢继承而非组合，你需要注意在日常编码中不要过度使用继承。如果你更喜欢组合，确保不要错过创建基于优雅继承解决方案的机会。
- en: Finally, add some error handlers to the various classes we created in the case
    study. How should one bad sample be handled? Should the model be inoperable? Or
    should the row be skipped? There are profound data science and statistical consequences
    to a seemingly small technical implementation choice. Can we define a class that
    permits either alternative behavior?
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给我们在案例研究中创建的各种类添加一些错误处理器。如何处理一个不良样本？模型应该失效吗？还是应该跳过这一行？看似微小的技术实现选择实际上有着深刻的数据科学和统计后果。我们能否定义一个允许两种不同行为的类？
- en: In your daily coding, pay attention to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常编码中，请注意复制和粘贴命令。每次你在编辑器中使用它们时，考虑一下是否改善你程序的组织结构是个好主意，这样你就可以只保留你即将复制的代码的一个版本。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behaviors, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality,
    and inheritance and composition can be applied to reduce code duplication.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于识别对象，尤其是那些不是立即显而易见的对象；那些管理和控制的对象。对象应具备数据和行为，但属性可以被用来模糊两者之间的区别。DRY原则是代码质量的重要指标，继承和组合可以用来减少代码重复。
- en: In the next chapter, we'll look at Python's methods for defining abstract base
    classes. This lets us define a class that's a kind of template; it must be extended
    with subclasses that add narrowly-defined implementation features. This lets us
    build families of related classes, confident that they will work together properly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Python定义抽象基类的方法。这使我们能够定义一种模板式的类；它必须通过添加具有狭窄定义的实现特性来扩展为子类。这使我们能够构建一系列相关的类，并确信它们能够正确地协同工作。
