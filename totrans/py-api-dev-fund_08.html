<html><head></head><body>
		<div>
			<div id="_idContainer133" class="Content">
			</div>
		</div>
		<div id="_idContainer134" class="Content">
			<h1 id="_idParaDest-149"><a id="_idTextAnchor355"/>8. Pagination, Searching, and Ordering</h1>
		</div>
		<div id="_idContainer135" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Implement the pagination function using Flask-SQLAlchemy</li>
				<li class="bullets">Serialize the paginated result using marshmallow for the frontend display</li>
				<li class="bullets">Build the API with search function</li>
				<li class="bullets">Sort and order the returned records in your own way</li>
				<li class="bullets">Test all these features using Postman</li>
			</ul>
			<p>This chapter covers pagination and how to change the order in which recipes are listed, as well as how to add search functionality for recipes and ingredients.</p>
		</div>
		<div id="_idContainer144" class="Content">
			<h2 id="_idParaDest-150"><a id="_idTextAnchor356"/>Introduction</h2>
			<p>In the previous chapter, we implemented the <strong class="inline">user avatar</strong> and <strong class="inline">recipe cover image upload</strong> functions. We worked on the image compression function to improve the performance of image loading speed. Once an image has been uploaded, users can retrieve the URL of the image through an API.</p>
			<p>In this chapter, we will work on paginating recipe data. We will explain why we need to perform pagination. This is an important step in optimizing our API. We will also discuss some more important functions, including searching and ordering, which I am sure you have come across in other online applications.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor357"/>Pagination</h2>
			<p>In the testing environment, we may only have a few developers putting recipes on the Smilecook platform. There are only a handful of recipes there and performance is never a concern. However, in the production environment, that is, after the platform has been launched for public use, there could be thousands of users sharing recipes on the platform. If you consider social media platforms such as Facebook, then the volume will be even bigger.</p>
			<p>That's why we need to introduce pagination. Pagination means instead of querying the whole population of records from the database, we just query a handful of them. When the user wants to see more, they can always go to the next page. For example, when you're browsing a shopping site, usually, you will view the items for sale a page at a time. Each page may display 40 items, and you have to navigate to subsequent pages to view all the items that are available. This is the nature of pagination.</p>
			<p>The number of records that are shown per page is limited by the page's size. This way, there will be a huge saving in server loading time and data transfer time, and, most importantly, it will enhance the user's navigation experience.</p>
			<p>The good thing here is that we are using a web framework to build our API. This kind of common function has already been thought of. We just need to use Flask-SQLAlchemy to help us build a paginated API.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor358"/>Paginated APIs</h2>
			<p>A paginated API means that when you query the API, only the data records on the current page will be returned. It also includes other information, such as the total number of records, the total number of pages, links to other pages, and so on. The following is a sample response from a paginated API. It is a serialized pagination object, so it is in JSON format:</p>
			<p class="snippet">{</p>
			<p class="snippet">    "links": {</p>
			<p class="snippet">        "first": "http://localhost:5000/recipes?per_page=2&amp;page=1",</p>
			<p class="snippet">        "last": "http://localhost:5000/recipes?per_page=2&amp;page=5",</p>
			<p class="snippet">        "prev": "http://localhost:5000/recipes?per_page=2&amp;page=1",</p>
			<p class="snippet">        "next": "http://localhost:5000/reci<a id="_idTextAnchor359"/>pes?per_page=2&amp;page=3"</p>
			<p class="snippet">    },</p>
			<p class="snippet">    "page": 2,</p>
			<p class="snippet">    "pages": 5,</p>
			<p class="snippet">    "per_page": 2,</p>
			<p class="snippet">    "total": 9,</p>
			<p class="snippet">    "data": [</p>
			<p class="snippet">        {</p>
			<p class="snippet">            "data": "data"</p>
			<p class="snippet">        },</p>
			<p class="snippet">        {</p>
			<p class="snippet">            "data": "data"</p>
			<p class="snippet">        }</p>
			<p class="snippet">    ]</p>
			<p class="snippet">}</p>
			<p>Here, you can see the following attributes in the HTTP response:</p>
			<ul>
				<li><strong class="inline">first</strong>: The link to the first page</li>
				<li><strong class="inline">last</strong>: The link to the last page</li>
				<li><strong class="inline">prev</strong>: The link to the previous page</li>
				<li><strong class="inline">next</strong>: The link to the next page</li>
				<li><strong class="inline">page</strong>: The current page</li>
				<li><strong class="inline">pages</strong>: The total number of pages</li>
				<li><strong class="inline">per_page</strong>: The number of records per page</li>
				<li><strong class="inline">total</strong>: The total number of records</li>
				<li><strong class="inline">data</strong>: The actual data records on this page</li>
			</ul>
			<p>These attributes are automatically generated by the pagination object in Flask-SQLAlchemy. We just need to serialize the pagination object using marshmallow so that we can return the result in JSON format to the frontend client.</p>
			<h3 id="_idParaDest-153"><a id="_idTextAnchor360"/>Exercise 50: Implementing Pagination on the Published Recipes Retrieval Function</h3>
			<p>Now that we've discussed the importance of pagination, we want to add this functionality to our Smilecook platform. We'll begin to work on that in this exercise. Let's get started:</p>
			<ol>
				<li>Create <strong class="inline">pagination.py</strong> in the <strong class="inline">schema</strong> folder and import the necessary modules and functions:<p class="snippet">from flask import request</p><p class="snippet">from marshmallow import Schema, fields</p><p class="snippet">from urllib.parse import urlencode</p></li>
				<li>Create the <strong class="inline">PaginationSchema</strong> class:<p class="snippet">class PaginationSchema(Schema):</p><p class="snippet">    class Meta:</p><p class="snippet">        ordered = True</p><p class="snippet">    links = fields.Method(serialize='get_pagination_links')</p><p class="snippet">    page = fields.Integer(dump_only=True)</p><p class="snippet">    pages = fields.Integer(dump_only=True)</p><p class="snippet">    per_page = fields.Integer(dump_only=True)</p><p class="snippet">    total = fields.Integer(dump_only=True)</p><p>In this step, we can see that <strong class="inline">PaginationSchema</strong> inherits from <strong class="inline">marshmallow.Schema</strong>. <strong class="inline">PaginationSchema</strong> is used to serialize the pagination object from Flask-SQLAlchemy. The <strong class="inline">links</strong> attribute is a custom field, which means that we can specify how we are going to serialize it. The <strong class="inline">get_pagination_links</strong> function will be created in <em class="italics">step 4</em>.</p><h4>Note</h4><p class="callout">We've explained the other attributes here already. These attributes are required in the HTTP response, and so we need to add them to the schema.</p><p class="callout"><a id="_idTextAnchor361"/>We can have a different key name in the final JSON response. For example, if we want to show <strong class="inline">total_count</strong> as the key name instead of <strong class="inline">total</strong>, we can use the <strong class="inline">attribute</strong> parameter like this: <strong class="inline">total_count = fields.Integer(dump_only=True, attribute='total')</strong>.</p></li>
				<li>Add the following <strong class="inline">get_url</strong> method to <strong class="inline">PaginationSchema</strong>:<p class="snippet">    @staticmethod</p><p class="snippet">    def get_url(page):</p><p class="snippet">        query_args = request.args.to_dict()</p><p class="snippet">        query_args['page'] = page</p><p class="snippet">        return '{}?{}'.format(request.base_url, urlencode(query_args))</p><p>The <strong class="inline">PaginationSchema.get_url</strong> method is used to generate the URL of the page based on the page number. It is taking in the page number parameter and adding that to the <strong class="inline">request</strong> argument's dictionary. Finally, it encodes and returns the new URL, including the page number, as an argument. </p><h4>Note</h4><p class="callout">An example of this is if <strong class="inline">request.base_url</strong> is <strong class="inline">http://localhost:5000/recipes</strong>, and <strong class="inline">urlencode (query_args)</strong> is giving us <strong class="inline">per_page=2&amp;page=1</strong>. The format function will stitch them together and return the new URL, that is, <strong class="inline">http://localhost:5000/recipes?per_page=2&amp;page=1</strong>.</p></li>
				<li>Add the <strong class="inline">get_pagination_links</strong> method to <strong class="inline">PaginationSchema</strong>:<p class="snippet">    def get_pagination_links(self, paginated_objects):</p><p class="snippet">        pagination_links = {</p><p class="snippet">            'first': self.get_url(page=1),</p><p class="snippet">            'last': self.get_url(page=paginated_objects.pages)</p><p class="snippet">        }</p><p class="snippet">        if paginated_objects.has_prev:</p><p class="snippet">            pagination_links['prev'] = self.get_url(page=paginated_objects.prev_num)</p><p class="snippet">        if paginated_objects.has_next:</p><p class="snippet">            pagination_links['next'] = self.get_url(page=paginated_objects.next_num)</p><p class="snippet">        return pagination_links</p><p>The <strong class="inline">PaginationSchema.get_pagination_links</strong> method is used to generate URL links to different pages. It gets the page's information from <strong class="inline">paginated_objects</strong> and relies on the <strong class="inline">get_url</strong> method we built in <em class="italics">step 3</em> to generate the links.</p></li>
				<li>Next, import <strong class="inline">PaginationSchema</strong> in <strong class="inline">schemas/recipe.py</strong>:<p class="snippet">from schemas.pagination import PaginationSchema</p></li>
				<li><a id="_idTextAnchor362"/>Delete the following code in <strong class="inline">schemas/recipe.py</strong>:<p class="snippet">    @post_dump(pass_many=True)</p><p class="snippet">    def wrap(self, data, many, **kwargs):</p><p class="snippet">        if many:</p><p class="snippet">            return {'data': data}</p><p class="snippet">        return data</p><p>This part of the code has been removed because we are building a pagination function. We no longer need to wrap multiple data records with the <strong class="inline">data</strong> key.</p></li>
				<li>Define <strong class="inline">RecipePaginationSchema</strong>, which inherits from <strong class="inline">PaginationSchema</strong> in <strong class="inline">schema/pagination.py</strong>:<p class="snippet">class RecipePaginationSchema(PaginationSchema):</p><p class="snippet">    data = fields.Nested(RecipeSchema, attribute='items', many=True)</p><p>As you may recall, the attribute name in the final JSON response will be <strong class="inline">data</strong> here, because that is how it has been defined in <strong class="inline">RecipePaginationSchema</strong>. <strong class="inline">attribute = 'items'</strong> means that it is getting the source data from the <strong class="inline">items</strong> to attribute in <strong class="inline">the pagination</strong> objects.</p></li>
				<li>Now, import <strong class="inline">acs</strong> and <strong class="inline">desc</strong> from <strong class="inline">sqlalchemy</strong> into <strong class="inline">model/recipe.py</strong> and modify the <strong class="inline">get_all_published</strong> method:<p class="snippet">from sqlalchemy import asc, desc</p><p class="snippet">    @classmethod</p><p class="snippet">    def get_all_published(cls, page, per_page):</p><p class="snippet">        return cls.query.filter_by(is_publish=True).order_by(desc(cls.created_at)).paginate(page=page, per_page=per_page)</p><p>The <strong class="inline">get_all_published</strong> method we built here is used to leverage the <strong class="inline">paginate</strong> method from Flask-SQLAlchemy. We will filter and order the records, then the paginate method takes the <strong class="inline">page</strong> and <strong class="inline">per_page</strong> parameters and generates a pagination object.</p></li>
				<li>Import <strong class="inline">fields, use_kwargs</strong> and <strong class="inline">RecipePaginationSchema</strong> into <strong class="inline">resources/recipe.py</strong>:<p class="snippet">from webargs import fields</p><p class="snippet">from webargs.flaskparser import use_kwargs</p><p class="snippet">from schemas.recipe import RecipeSchema, RecipePaginationSchema</p></li>
				<li>Declare the <strong class="inline">recipe_pagination_schema</strong> attribute in <strong class="inline">resources/recipe.py</strong> in order to serialize the paginated recipes:<p class="snippet">recipe_pagination_schema = RecipePaginationSchema()</p></li>
				<li>Modify the <strong class="inline">RecipeListResource.get</strong> method in <strong class="inline">resources/recipe.py</strong> in order to return the paginated recipes:<p class="snippet">class RecipeListResource(Resource):</p><p class="snippet">        @use_kwargs({'page': fields.Int(missing=1),</p><p class="snippet">                           'per_page': fields.Int(missing=20)})</p><p class="snippet">    def get(self, page, per_page):</p><p class="snippet">        paginated_recipes = Recipe.get_all_published(page, per_page)</p><p class="snippet">        return recipe_pagination_schema.dump(paginated_recipes).data, HTTPStatus.OK</p><p>Here, we have added the <strong class="inline">@user_kwargs</strong> decorator to the <strong class="inline">RecipeListResource.get</strong> method. The default value for the <strong class="inline">page</strong> parameter is 1, while the default value for the <strong class="inline">per_page</strong> parameter is 20. This means that if nothing is passed in, we will be getting the first page with the first 20 recipe records.</p></li>
			</ol>
			<p>Then, we pass these two parameters into the <strong class="inline">get_all_published</strong> method to get the pagination object back. Finally, the paginated recipes will be serialized and returned to the frontend client.</p>
			<p>Here, we have successfully implemented the pagination function and displayed the result. In the next exercise, we will test the pagination functions.</p>
			<h3 id="_idParaDest-154"><a id="_idTextAnchor363"/>Exercise 51: Testing the Pagination Functions</h3>
			<p>In this exercise, we will test the pagination functions that we have just built. We will be creating eight recipes in our Smilecook application, and we will publish all of them. Then, we will simulate a user scenario in which we will get back all the recipes, page by page. Let's get started:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Then, select the <strong class="bold">POST Token</strong> request and <strong class="bold">Send</strong> a request. This is to login to a user account. The result is shown in the following screenshot:<div id="_idContainer136" class="IMG---Figure"><img src="image/C15309_08_01.jpg" alt="Figure 8.1: Sending the POST Token request&#13;&#10;"/></div><h6>Figure 8.1: Sending the POST Token request</h6></li>
				<li>Create eight recipes by running the following <strong class="inline">httpie</strong> command in the PyCham console. The <strong class="inline">{token}</strong> placeholder should be replaced with the access token we obtained in <em class="italics">step 2</em>:<p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Vegetable Paella" description="This is a lovely vegetable paella" num_of_servings=5 cook_time=60 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Minestrone Soup" description="This is a lovely minestrone soup" num_of_servings=4 cook_time=60 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Thai Red Curry" description="This is a lovely thai red curry" </p><p class="snippet">num_of_servings=4 cook_time=40 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Coconut Fried Rice" description="This is a lovely coconut fried rice" num_of_servings=2 cook_time=30 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Vegetable Fried Rice" description="This is a lovely vegetable fried rice" num_of_servings=2 cook_time=30 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Burrito Bowls" description="This is a lovely coconut fried rice" num_of_servings=5 cook_time=60 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Fresh Huevos Rancheros" description="This is a lovely fresh huevos rancheros" num_of_servings=4 cook_time=40 directions="This is how you make it"</p><p class="snippet">http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Bean Enchiladas" description="This is a lovely coconut fried rice" num_of_servings=4 cook_time=60 directions="This is how you make it"</p><h4>Note</h4><p class="callout">You can also create the recipes one by one using Postman. We are using the <strong class="inline">httpie</strong> command here because it's faster.</p></li>
				<li>Publish all eight recipes using the following <strong class="inline">httpie</strong> command. Replace the <strong class="inline">{token}</strong> placeholder with the access token. Make sure that the recipe IDs in the URLs are referring to the recipes we created in the previous step:<p class="snippet">http PUT localhost:5000/recipes/6/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/7/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/8/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/9/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/10/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/11/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/12/publish "Authorization: Bearer {token}"</p><p class="snippet">http PUT localhost:5000/recipes/13/publish "Authorization: Bearer {token}"</p><p>N<a id="_idTextAnchor364"/>ow we have created and published eight recipes. Next, we will get the recipes back page by page with a page size of two recipes.</p></li>
				<li>Click on <strong class="bold">GET RecipeList</strong> and select the <strong class="bold">Params</strong> tab. Then, put a key-value pair (<strong class="inline">per_page</strong>, <strong class="inline">2</strong>) into <strong class="bold">Query Params</strong> and <strong class="bold">Send</strong> the request. The result is shown in the following screenshot:<div id="_idContainer137" class="IMG---Figure"><img src="image/C15309_08_02.jpg" alt="Figure 8.2: Adding the key-value pair to Query Params and sending the request&#13;&#10;"/></div><h6>Figure 8.2: Adding the key-value pair to Query Params and sending the request</h6><p>In the details of the recipe, we can see that there are links with the URLs of the <strong class="inline">first</strong>, <strong class="inline">last</strong>, and <strong class="inline">next</strong> pages. We can't see <strong class="inline">prev</strong> here because we are on the first page. There is a total of five pages, and we have two records per page. You can also see the <strong class="bold">sorted</strong> recipe details in the HTTP response.</p></li>
				<li>Next, let's test whether the links in the recipes are working properly. We just need to click on the <strong class="inline">next</strong> URL link, which will open a new tab in Postman with the request URL populated (<strong class="inline">http://localhost:5000/recipes?per_page=2&amp;page=2</strong>). Then, we just need to click on <strong class="bold">Send</strong> to send the request. The result is shown in the following screenshot:<div id="_idContainer138" class="IMG---Figure"><img src="image/C15309_08_03.jpg" alt="Figure 8.3: Testing the links in the recipes&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 8.3: Testing the links in the recipes</h6>
			<p>Here, we can see that there are links to the <strong class="inline">first</strong>, <strong class="inline">last</strong>, <strong class="inline">next</strong>, and <strong class="inline">prev</strong> pages. We can also see that we are currently on page 2. All the recipe data is there as well.</p>
			<p>We have successfully created our pagination function. Now, I will leave it to your capable hands to test it.</p>
			<p>The<a id="_idTextAnchor365"/> benefit of pagination is that you are able to segregate thousands of records into pages. Data is retrieved in a page by page manner, and that will reduce the server's workload. But what if the user is setting a page size of, say, 100,000? How can we prevent a user from exploiting the system loophole? What we can do is pass the <strong class="inline">max_per_page</strong> parameter for pagination. That will limit the maximum page size the user can set. If the user is setting a page size bigger than the maximum page size, then the maximum page size will be used.</p>
			<h3 id="_idParaDest-155">Act<a id="_idTextAnchor366"/><a id="_idTextAnchor367"/>ivity 13: Implementing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p>We implemented and tested the pagination function on our all published recipe retrieval APIs in the previous exercise. In this activity, we will work on the pagination function in the user-specific recipe retrieval API. The corresponding API can be found in <strong class="inline">UserRecipeListResource</strong>, which is used to get the recipes from a specific author. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Modify the <strong class="inline">get_all_by_user</strong> method in <strong class="inline">model/recipe.py</strong>.</li>
				<li>Import <strong class="inline">RecipePaginationSchema</strong> into <strong class="inline">resources/user.py</strong>.</li>
				<li>Declare the <strong class="inline">recipe_pagination_schema</strong> attribute in <strong class="inline">resources/user.py</strong>.</li>
				<li>Modify the <strong class="inline">UserRecipeListResource.get</strong> method in <strong class="inline">resources/user.py</strong>.</li>
				<li>Add the <strong class="inline">@user_kwargs</strong> decorator for <strong class="inline">UserRecipeListResource.get</strong>. It takes a few parameters, including <strong class="inline">page</strong>, <strong class="inline">per_page</strong>, and <strong class="inline">visibility</strong>.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 332.</p></li>
			</ol>
			<p>Now, you should have completed the pagination function for the user recipe. Let's follow the same routine and test the function in the next activity.</p>
			<h3 id="_idParaDest-156">Act<a id="_idTextAnchor368"/><a id="_idTextAnchor369"/>ivity 14: Testing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p>In this activity, we will test the user recipe pagination function that we just built. We published eight recipes in the previous exercise. We will use them here as our test subjects. We are going to create a request in Postman and test whether we can get them back, page by page. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Get all the recipes by the author from the previous exercise using Postman, page by page, with a page size of two.</li>
				<li>Click the next URL in the <strong class="inline">links</strong> to query for the next two records.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 334.</p></li>
			</ol>
			<h2 id="_idParaDest-157">Rec<a id="_idTextAnchor370"/>ipe Searching</h2>
			<p>In the previous exercises, we implemented the <strong class="inline">pagination</strong> function and also saw the benefits of using it. This can greatly reduce the number of recipes that are going back to users in one go. From the user's perspective, they can browse through different pages to look for the recipe they want. </p>
			<p>A better way for the user to look for a recipe is by searching. The search function is an essential function on the internet. Look at the search giant Google; their search engine brings in huge amounts of revenue. Of course, we are not going to implement anything of the scale of Google in our Smilecook application. We will be just doing a simple text matching search here.</p>
			<p>In the next exercise, we will implement the search function in our Smilecook platform. We will build a recipe searching API that allows the client to provide a <strong class="inline">q</strong> parameter to search for specific recipes by name or recipe description. This can be done by using the <strong class="inline">LIKE</strong> comparison operator. The <strong class="inline">LIKE</strong> operator works by matching the search string with the target string. We can use <strong class="inline">%</strong> in the search string as a wildcard. If it's not a exact match here it is more like a <strong class="inline">SIMILAR TO</strong> matching. So, the <strong class="inline">%Chicken%</strong> search string will match with the <strong class="inline">Hainanese Chicken Rice</strong> string.</p>
			<p>Perhaps a better choice of comparison operator would be <strong class="inline">ILIKE</strong>. <strong class="inline">LIKE</strong> is case-sensitive, while <strong class="inline">ILIKE</strong> is case-insensitive. For example, we can't match <strong class="inline">Thai Red Curry</strong> with <strong class="inline">%curry%</strong> using the <strong class="inline">LIKE</strong> operator. You can see that <strong class="inline">C</strong> is uppercase here. However, if we use <strong class="inline">ILIKE</strong>, it will match perfectly fine. </p>
			<p>Take a look at the following table to see how the comparison operator works:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/C15309_08_04.jpg" alt="Figure 8.4: Comparison operators&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 8.4: Comparison operators</h6>
			<p>In our Smilecook platform, we don't want our search to be that strict. The search should be case-insensitive. Now, let's see how we can add this function to our Smilecook platform.</p>
			<h3 id="_idParaDest-158"><a id="_idTextAnchor371"/>Exercise 52: Implementing the Search Function</h3>
			<p>Having learned about the recipe searching concept, we want to implement this as a function in our Smilecook platform. To do this, we will be adding a <strong class="inline">q</strong> parameter that will pass the search string into the API. Then, we will use the search string to look for the recipes we require. Let's get started:</p>
			<ol>
				<li value="1">Import <strong class="inline">or_</strong> from <strong class="inline">sqlalchemy</strong> into <strong class="inline">models/recipe.py</strong>:<p class="snippet">from sqlalchemy import asc, desc, or_</p></li>
				<li>Modify the <strong class="inline">Recipe.get_all_published</strong> method in <strong class="inline">models/recipe.py</strong> so that it gets all the published recipes that satisfy the search criteria:<p class="snippet">  @classmethod</p><p class="snippet">    def get_all_published(cls, q, page, per_page):</p><p class="snippet">        keyword = '%{keyword}%'.format(keyword=q)</p><p class="snippet">        return cls.query.filter(or_(cls.name.ilike(keyword),</p><p class="snippet">                cls.description.ilike(keyword)),</p><p class="snippet">                cls.is_publish.is_(True)).\</p><p class="snippet">                order_by(desc(cls.created_at)).paginate(page=page, per_page=per_page)</p><p>The preceding code is used to assign the search pattern to the variable <strong class="inline">keyword</strong>. Then, it searches the <strong class="inline">name</strong> and <strong class="inline">description</strong> fields by this keyword.</p></li>
				<li>Modify <strong class="inline">RecipeListResource</strong> in <strong class="inline">resources/recipe.py</strong>:<p class="snippet">class RecipeListResource(Resource):</p><p class="snippet">    @use_kwargs({'q': fields.Str(missing='),</p><p class="snippet">                                   'page': fields.Int(missing=1),</p><p class="snippet">                                   'per_page': fields.Int(missing=20)})</p><p class="snippet">    def get(self, q, page, per_page):</p><p class="snippet">        paginated_recipes = Recipe.get_all_published(q, page, per_page)</p><p class="snippet">        return recipe_pagination_schema.dump(paginated_recipes).data, HTTPStatus.OK</p><p>We added the <strong class="inline">q</strong> parameter to the <strong class="inline">user_kwargs</strong> decorator and the <strong class="inline">get</strong> function. The default for this <strong class="inline">q</strong> value is an empty string. The <strong class="inline">q</strong> parameter will also be passed into the <strong class="inline">get_all_published</strong> function.</p></li>
			</ol>
			<p>Now we are done with the search function. Next, we are going to test this function.</p>
			<h3 id="_idParaDest-159"><a id="_idTextAnchor372"/>Exercise 53: Testing the Search Function</h3>
			<p>In this exercise, we will be testing the search function that we have just built. We will test by searching for recipes that contain the <strong class="inline">fried rice</strong> string in the name or description. Let's get started:</p>
			<ol>
				<li value="1">Click on the <strong class="inline">RecipeList</strong> request and select the <strong class="bold">Params</strong> tab.</li>
				<li>Insert the first key-value pair (<strong class="inline">q</strong>, <strong class="inline">fried rice</strong>).</li>
				<li>Insert the second key-value pair (<strong class="inline">per_page</strong>, <strong class="inline">2</strong>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div id="_idContainer140" class="IMG---Figure"><img src="image/C15309_08_05.jpg" alt="Figure 8.5: Searching for recipes that contain the &quot;fried rice&quot; string in the name or description&#13;&#10;"/></div><h6>Figure 8.5: Searching for recipes that contain the "fried rice" string in the name or description</h6><p>Here, we can see four fried rice recipe records, divided into two pages.</p></li>
				<li>Next, test whether the links in the recipes are still working properly. We just need to click on the next URL link, which will open a new tab in Postman with the request URL populated (<strong class="inline">http://localhost:5000/recipes?q=fried+rice&amp;per_page=2&amp;page=2</strong>). Then, we just need to click on <strong class="bold">Send</strong> to send the request. The result is shown in the following screenshot:<div id="_idContainer141" class="IMG---Figure"><img src="image/C15309_08_06.jpg" alt="Figure 8.6: Testing whether the links in the recipes are working&#13;&#10;"/></div></li>
			</ol>
			<h6><a id="_idTextAnchor373"/>Figure 8.6: Testing whether the links in the recipes are working</h6>
			<p>From the result, we can that we are now on <strong class="inline">page 2</strong>. The recipe records are also sorted by creation time. The latest recipe is placed on the top.</p>
			<p>So far, we have created the pagination and searching functions. This is a great achievement, but we are not done yet. We need to continue enhancing our Smilecook application. Without further ado, let's move on.</p>
			<h2 id="_idParaDest-160">So<a id="_idTextAnchor374"/>rting and Ordering</h2>
			<p>Sorting is another important feature that helps user navigation. Again, when we build any application, we need to keep the user experience in mind. Our application could eventually store millions of recipes, so we need to provide an easy way for our users to navigate the recipes and find the recipe they want.</p>
			<p>Previously, the recipes that we sent back were sorted by time by default. Let's implement some other sorting criteria in our Smilecook application. We can still keep the default sorting criteria such as time, but we want to allow the user to define the searching criteria they want; for example, they can specify that they want the recipes to be sorted by cooking time. This is a possibility as the user may want to cook a quick meal, which means they will only be interested in recipes with short cooking times.</p>
			<p>For our Smilecook application, sorting and ordering can be done by adding the <strong class="inline">sort</strong> and <strong class="inline">order</strong> parameters. We can put the sorting criteria (for example, <strong class="inline">created_at</strong>, <strong class="inline">cook_time</strong>, or <strong class="inline">num_of_servings</strong>) into the <strong class="inline">sort</strong> parameter, and we can use <strong class="inline">created_at</strong> as the default. The <strong class="inline">order</strong> parameter is used to specify whether it is <strong class="inline">asc</strong> (ascending order) or <strong class="inline">desc</strong> (descending order). We can put <strong class="inline">desc</strong> as the default.</p>
			<p>In terms of the syntax, if we want our SQLAlchemy query result to be sorted in ascending order, we can do the following:</p>
			<p class="snippet">Import asc        </p>
			<p class="snippet">    </p>
			<p class="snippet">sort_logic_asc = asc(getattr(cls, sort))</p>
			<p class="snippet">cls.query.filter(cls.is_publish=True).order_by(sort_logic_asc)</p>
			<p>If we want it to be sorted in descending order, we can just use <strong class="inline">desc</strong>:</p>
			<p class="snippet">Import desc        </p>
			<p class="snippet">    </p>
			<p class="snippet">sort_logic_desc = desc(getattr(cls, sort))</p>
			<p class="snippet">cls.query.filter(cls.is_publish=True).order_by(sort_logic_desc)</p>
			<h4>Note</h4>
			<p class="callout">Instead of <strong class="inline">cls.is_published=True</strong>, you can also use the SQLAlchemy column operator, that is, <strong class="inline">cls.is_published.is_(True)</strong>. You will get the same result.</p>
			<p>In the next exercise, we will implement the sorting and ordering functions in our Smilecook platform. This will make our application more user-friendly.</p>
			<h3 id="_idParaDest-161">Ex<a id="_idTextAnchor375"/>ercise 54: Implementing Sorting and Ordering</h3>
			<p>In this exercise, we will implement the sorting and ordering functions in our Smilecook platform. We will be adding the <strong class="inline">sort</strong> and <strong class="inline">order</strong> parameters to the get all published recipes API so that users can perform sorting and ordering on the published recipes. Let's get started:</p>
			<ol>
				<li value="1">In <strong class="inline">resources/recipe.py</strong>, use the <strong class="inline">use_kwargs</strong> <strong class="inline">method</strong> in the decorator to add two parameters (<strong class="inline">sort</strong>, <strong class="inline">order</strong>) to the <strong class="inline">RecipeListResource.get</strong> method. Set the default values for these two parameters to <strong class="inline">created_at</strong> and <strong class="inline">desc</strong>, respectively:<p class="snippet">@use_kwargs({'q': fields.Str(missing='),</p><p class="snippet">                        'page': fields.Int(missing=1),</p><p class="snippet">                        'per_page': fields.Int(missing=20),</p><p class="snippet">                        'sort': fields.Str(missing='created_at'),</p><p class="snippet">                        'order': fields.Str(missing='desc')})</p><p class="snippet">def get(self, q, page, per_page, sort, order):</p></li>
				<li>Restrict the <strong class="inline">sort</strong> parameter to accept only the <strong class="inline">created_at</strong>, <strong class="inline">cook_time</strong>, and <strong class="inline">num_of_servings</strong> values. If other values are passed in, then we'll default to <strong class="inline">created_at</strong>:<p class="snippet">        if sort not in ['created_at', 'cook_time', 'num_of_servings']:</p><p class="snippet">            sort = 'created_at'</p></li>
				<li>Restrict the <strong class="inline">order</strong> parameter to accept only the <strong class="inline">asc</strong> and <strong class="inline">desc</strong> values. If other values are passed in, then we'll default to <strong class="inline">desc</strong>:<p class="snippet">        if order not in ['asc', 'desc']:</p><p class="snippet">            order = 'desc'</p></li>
				<li>Pass the <strong class="inline">sort</strong> and <strong class="inline">order</strong> parameters into the <strong class="inline">get_all_published</strong> function:<p class="snippet">        paginated_recipes = Recipe.get_all_published(q, page, per_page, sort, order)</p></li>
				<li>Modify the <strong class="inline">get_all_published</strong> method in <strong class="inline">models/recipe.py</strong> so that it looks as follows. It takes in two additional parameters, that is, <strong class="inline">sort</strong> and <strong class="inline">order</strong>, to define the logic:<p class="snippet">    @classmethod</p><p class="snippet">    def get_all_published(cls, q, page, per_page, sort, order):</p><p class="snippet">        keyword = '%{keyword}%'.format(keyword=q)</p><p class="snippet">        if order == 'asc':</p><p class="snippet">            sort_logic = asc(getattr(cls, sort))</p><p class="snippet">        else:</p><p class="snippet">            sort_logic = desc(getattr(cls, sort))</p><p class="snippet">        return cls.query.filter(or_(cls.name.ilike(keyword),</p><p class="snippet">                                    cls.description.ilike(keyword)),</p><p class="snippet">                                cls.is_publish.is_(True)).\</p><p class="snippet">            order_by(sort_logic).paginate(page=page, per_page=per_page)</p></li>
			</ol>
			<p>Here, we have created the sorting and ordering functions. Not many changes were made to the code. Next, we are going to test our implementation using Postman.</p>
			<h3 id="_idParaDest-162">Ex<a id="_idTextAnchor376"/>ercise 55: Testing the Sorting and Ordering Feature</h3>
			<p>In the previous exercise, we created customized ordering functions. Users should be able to order the recipe records in our Smilecook platform by their specified column, and in either ascending or descending order. In this exercise, we will test whether that is really the case. We will pass the <strong class="inline">sort</strong> and <strong class="inline">order</strong> parameters into Postman and verify them. Let's get started:</p>
			<ol>
				<li value="1">We will send a request to get all the recipe records back. Then, sort the data by <strong class="inline">cook_time</strong> in ascending order. First, click on the <strong class="inline">RecipeList</strong> request and select the <strong class="bold">Params</strong> tab.</li>
				<li>Insert the first key-value pair (<strong class="inline">sort</strong>, <strong class="inline">cook_time</strong>).</li>
				<li>Insert the second key-value pair (<strong class="inline">order</strong>, <strong class="inline">desc</strong>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div id="_idContainer142" class="IMG---Figure"><img src="image/C15309_08_07.jpg" alt="Figure 8.7: Sending a request to get all the recipe records back&#13;&#10;"/></div><h6>Figure 8.7: Sending a request to get all the recipe records back</h6><p>From the preceding search result, we can see that the recipe's <strong class="inline">cook_time</strong> is sorted in ascending order. The first recipe's <strong class="inline">cook_time</strong> is 20 minutes, whereas the second one is 30 minutes.</p></li>
				<li>Send a request to get all the recipe records back. Then, sort the data by <strong class="inline">num_of_servings</strong> in descending order. Click on <strong class="inline">RecipeList</strong> and select the <strong class="bold">Params</strong> tab.</li>
				<li>Insert the first key-value pair (<strong class="inline">sort</strong>, <strong class="inline">num_of_servings</strong>).</li>
				<li>Insert the second key-value pair (<strong class="inline">order</strong>, <strong class="inline">desc</strong>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div id="_idContainer143" class="IMG---Figure"><img src="image/C15309_08_08.jpg" alt="Figure 8.8: Sending a request and sorting the data by num_of_servings in descending order&#13;&#10;"/></div><h6>Figure 8.8: Sending a request and sorting the data by num_of_servings in descending order</h6></li>
				<li>From the preceding search result, we can see that the recipe's <strong class="inline">num_of_servings</strong> has been sorted in descending order. The first recipe's <strong class="inline">num_of_servings</strong> is for five people, whereas the second one is for four people.</li>
			</ol>
			<p>Now, you have finished developing and testing all the functions you have learned about in this chapter. Next, we will complete an activity to ensure you have the flexibility to use what we have learned so far.</p>
			<h3 id="_idParaDest-163"><a id="_idTextAnchor377"/>Activity 15: Searching for Recipes with Specific Ingredients</h3>
			<p>In this activity, we will search the recipes using a specific attribute. We will add a new <strong class="inline">ingredients</strong> attribute and then pass in parameters to search through the recipe. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add the ingredients attribute to the <strong class="inline">Recipe</strong> model.</li>
				<li>Run Flask-Migrate to update the database.</li>
				<li>Add the <strong class="inline">ingredients</strong> attribute to <strong class="inline">RecipeSchema</strong>.</li>
				<li>Modify the <strong class="inline">RecipeResource.patch</strong> method to support the <strong class="inline">ingredients</strong> attribute update.</li>
				<li>Modify the <strong class="inline">Recipe.get_all_published</strong> method so that you can search through the ingredients.</li>
				<li>Create two recipes with the <strong class="inline">ingredients</strong> attribute and publish them.</li>
				<li>Search for the recipes using the <strong class="inline">ingredients</strong> attribute.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 336.</p></li>
			</ol>
			<p>Congratulations! You have completed this activity. Now, please work on the assessments to test your understanding of this chapter.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor378"/>Summary</h2>
			<p>We have implemented a lot of great features in this chapter that allows users to find the recipe information they want in a simple and efficient manner. The pagination function we implemented allows the user to quickly find out how many recipes there are in total and navigate them page by page. It also saves the server's resources as it doesn't need to render thousands of recipes in one go. </p>
			<p>The search function is another time-saving feature. Users can now look for the recipes they want by performing a simple search. We have also completed the sorting and ordering functions in the Smilecook application, which provide a better browsing experience for users. </p>
			<p>So far, we have created almost all of the user functions we need. Our Smilecook platform development is nearing its end. In the next chapter, we will work on internal system optimization, such as HTTP caching and rate-limiting.</p>
		</div>
	</body></html>