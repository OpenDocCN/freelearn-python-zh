<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-149"><a id="_idTextAnchor355"/>8. Pagination, Searching, and Ordering</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Implement the pagination function using Flask-SQLAlchemy</li>
				<li class="bullets">Serialize the paginated result using marshmallow for the frontend display</li>
				<li class="bullets">Build the API with search function</li>
				<li class="bullets">Sort and order the returned records in your own way</li>
				<li class="bullets">Test all these features using Postman</li>
			</ul>
			<p>This chapter covers pagination and how to change the order in which recipes are listed, as well as how to add search functionality for recipes and ingredients.</p>
		</div>
		<div><h2 id="_idParaDest-150"><a id="_idTextAnchor356"/>Introduction</h2>
			<p>In the previous chapter, we implemented the <code>user avatar</code> and <code>recipe cover image upload</code> functions. We worked on the image compression function to improve the performance of image loading speed. Once an image has been uploaded, users can retrieve the URL of the image through an API.</p>
			<p>In this chapter, we will work on paginating recipe data. We will explain why we need to perform pagination. This is an important step in optimizing our API. We will also discuss some more important functions, including searching and ordering, which I am sure you have come across in other online applications.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor357"/>Pagination</h2>
			<p>In the testing environment, we may only have a few developers putting recipes on the Smilecook platform. There are only a handful of recipes there and performance is never a concern. However, in the production environment, that is, after the platform has been launched for public use, there could be thousands of users sharing recipes on the platform. If you consider social media platforms such as Facebook, then the volume will be even bigger.</p>
			<p>That's why we need to introduce pagination. Pagination means instead of querying the whole population of records from the database, we just query a handful of them. When the user wants to see more, they can always go to the next page. For example, when you're browsing a shopping site, usually, you will view the items for sale a page at a time. Each page may display 40 items, and you have to navigate to subsequent pages to view all the items that are available. This is the nature of pagination.</p>
			<p>The number of records that are shown per page is limited by the page's size. This way, there will be a huge saving in server loading time and data transfer time, and, most importantly, it will enhance the user's navigation experience.</p>
			<p>The good thing here is that we are using a web framework to build our API. This kind of common function has already been thought of. We just need to use Flask-SQLAlchemy to help us build a paginated API.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor358"/>Paginated APIs</h2>
			<p>A paginated API means that when you query the API, only the data records on the current page will be returned. It also includes other information, such as the total number of records, the total number of pages, links to other pages, and so on. The following is a sample response from a paginated API. It is a serialized pagination object, so it is in JSON format:</p>
			<pre>{
    "links": {
        "first": "http://localhost:5000/recipes?per_page=2&amp;page=1",
        "last": "http://localhost:5000/recipes?per_page=2&amp;page=5",
        "prev": "http://localhost:5000/recipes?per_page=2&amp;page=1",
        "next": "http://localhost:5000/reci<a id="_idTextAnchor359"/>pes?per_page=2&amp;page=3"
    },
    "page": 2,
    "pages": 5,
    "per_page": 2,
    "total": 9,
    "data": [
        {
            "data": "data"
        },
        {
            "data": "data"
        }
    ]
}</pre>
			<p>Here, you can see the following attributes in the HTTP response:</p>
			<ul>
				<li><code>first</code>: The link to the first page</li>
				<li><code>last</code>: The link to the last page</li>
				<li><code>prev</code>: The link to the previous page</li>
				<li><code>next</code>: The link to the next page</li>
				<li><code>page</code>: The current page</li>
				<li><code>pages</code>: The total number of pages</li>
				<li><code>per_page</code>: The number of records per page</li>
				<li><code>total</code>: The total number of records</li>
				<li><code>data</code>: The actual data records on this page</li>
			</ul>
			<p>These attributes are automatically generated by the pagination object in Flask-SQLAlchemy. We just need to serialize the pagination object using marshmallow so that we can return the result in JSON format to the frontend client.</p>
			<h3 id="_idParaDest-153"><a id="_idTextAnchor360"/>Exercise 50: Implementing Pagination on the Published Recipes Retrieval Function</h3>
			<p>Now that we've discussed the importance of pagination, we want to add this functionality to our Smilecook platform. We'll begin to work on that in this exercise. Let's get started:</p>
			<ol>
				<li>Create <code>pagination.py</code> in the <code>schema</code> folder and import the necessary modules and functions:<pre>from flask import request
from marshmallow import Schema, fields
from urllib.parse import urlencode</pre></li>
				<li>Create the <code>PaginationSchema</code> class:<pre>class PaginationSchema(Schema):
    class Meta:
        ordered = True
    links = fields.Method(serialize='get_pagination_links')
    page = fields.Integer(dump_only=True)
    pages = fields.Integer(dump_only=True)
    per_page = fields.Integer(dump_only=True)
    total = fields.Integer(dump_only=True)</pre><p>In this step, we can see that <code>PaginationSchema</code> inherits from <code>marshmallow.Schema</code>. <code>PaginationSchema</code> is used to serialize the pagination object from Flask-SQLAlchemy. The <code>links</code> attribute is a custom field, which means that we can specify how we are going to serialize it. The <code>get_pagination_links</code> function will be created in <em class="italics">step 4</em>.</p><h4>Note</h4><p class="callout">We've explained the other attributes here already. These attributes are required in the HTTP response, and so we need to add them to the schema.</p><p class="callout"><a id="_idTextAnchor361"/>We can have a different key name in the final JSON response. For example, if we want to show <code>total_count</code> as the key name instead of <code>total</code>, we can use the <code>attribute</code> parameter like this: <code>total_count = fields.Integer(dump_only=True, attribute='total')</code>.</p></li>
				<li>Add the following <code>get_url</code> method to <code>PaginationSchema</code>:<pre>    @staticmethod
    def get_url(page):
        query_args = request.args.to_dict()
        query_args['page'] = page
        return '{}?{}'.format(request.base_url, urlencode(query_args))</pre><p>The <code>PaginationSchema.get_url</code> method is used to generate the URL of the page based on the page number. It is taking in the page number parameter and adding that to the <code>request</code> argument's dictionary. Finally, it encodes and returns the new URL, including the page number, as an argument. </p><h4>Note</h4><p class="callout">An example of this is if <code>request.base_url</code> is <code>http://localhost:5000/recipes</code>, and <code>urlencode (query_args)</code> is giving us <code>per_page=2&amp;page=1</code>. The format function will stitch them together and return the new URL, that is, <code>http://localhost:5000/recipes?per_page=2&amp;page=1</code>.</p></li>
				<li>Add the <code>get_pagination_links</code> method to <code>PaginationSchema</code>:<pre>    def get_pagination_links(self, paginated_objects):
        pagination_links = {
            'first': self.get_url(page=1),
            'last': self.get_url(page=paginated_objects.pages)
        }
        if paginated_objects.has_prev:
            pagination_links['prev'] = self.get_url(page=paginated_objects.prev_num)
        if paginated_objects.has_next:
            pagination_links['next'] = self.get_url(page=paginated_objects.next_num)
        return pagination_links</pre><p>The <code>PaginationSchema.get_pagination_links</code> method is used to generate URL links to different pages. It gets the page's information from <code>paginated_objects</code> and relies on the <code>get_url</code> method we built in <em class="italics">step 3</em> to generate the links.</p></li>
				<li>Next, import <code>PaginationSchema</code> in <code>schemas/recipe.py</code>:<pre>from schemas.pagination import PaginationSchema</pre></li>
				<li><a id="_idTextAnchor362"/>Delete the following code in <code>schemas/recipe.py</code>:<pre>    @post_dump(pass_many=True)
    def wrap(self, data, many, **kwargs):
        if many:
            return {'data': data}
        return data</pre><p>This part of the code has been removed because we are building a pagination function. We no longer need to wrap multiple data records with the <code>data</code> key.</p></li>
				<li>Define <code>RecipePaginationSchema</code>, which inherits from <code>PaginationSchema</code> in <code>schema/pagination.py</code>:<pre>class RecipePaginationSchema(PaginationSchema):
    data = fields.Nested(RecipeSchema, attribute='items', many=True)</pre><p>As you may recall, the attribute name in the final JSON response will be <code>data</code> here, because that is how it has been defined in <code>RecipePaginationSchema</code>. <code>attribute = 'items'</code> means that it is getting the source data from the <code>items</code> to attribute in <code>the pagination</code> objects.</p></li>
				<li>Now, import <code>acs</code> and <code>desc</code> from <code>sqlalchemy</code> into <code>model/recipe.py</code> and modify the <code>get_all_published</code> method:<pre>from sqlalchemy import asc, desc
    @classmethod
    def get_all_published(cls, page, per_page):
        return cls.query.filter_by(is_publish=True).order_by(desc(cls.created_at)).paginate(page=page, per_page=per_page)</pre><p>The <code>get_all_published</code> method we built here is used to leverage the <code>paginate</code> method from Flask-SQLAlchemy. We will filter and order the records, then the paginate method takes the <code>page</code> and <code>per_page</code> parameters and generates a pagination object.</p></li>
				<li>Import <code>fields, use_kwargs</code> and <code>RecipePaginationSchema</code> into <code>resources/recipe.py</code>:<pre>from webargs import fields
from webargs.flaskparser import use_kwargs
from schemas.recipe import RecipeSchema, RecipePaginationSchema</pre></li>
				<li>Declare the <code>recipe_pagination_schema</code> attribute in <code>resources/recipe.py</code> in order to serialize the paginated recipes:<pre>recipe_pagination_schema = RecipePaginationSchema()</pre></li>
				<li>Modify the <code>RecipeListResource.get</code> method in <code>resources/recipe.py</code> in order to return the paginated recipes:<pre>class RecipeListResource(Resource):
        @use_kwargs({'page': fields.Int(missing=1),
                           'per_page': fields.Int(missing=20)})
    def get(self, page, per_page):
        paginated_recipes = Recipe.get_all_published(page, per_page)
        return recipe_pagination_schema.dump(paginated_recipes).data, HTTPStatus.OK</pre><p>Here, we have added the <code>@user_kwargs</code> decorator to the <code>RecipeListResource.get</code> method. The default value for the <code>page</code> parameter is 1, while the default value for the <code>per_page</code> parameter is 20. This means that if nothing is passed in, we will be getting the first page with the first 20 recipe records.</p></li>
			</ol>
			<p>Then, we pass these two parameters into the <code>get_all_published</code> method to get the pagination object back. Finally, the paginated recipes will be serialized and returned to the frontend client.</p>
			<p>Here, we have successfully implemented the pagination function and displayed the result. In the next exercise, we will test the pagination functions.</p>
			<h3 id="_idParaDest-154"><a id="_idTextAnchor363"/>Exercise 51: Testing the Pagination Functions</h3>
			<p>In this exercise, we will test the pagination functions that we have just built. We will be creating eight recipes in our Smilecook application, and we will publish all of them. Then, we will simulate a user scenario in which we will get back all the recipes, page by page. Let's get started:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">Collections</strong> tab.</li>
				<li>Then, select the <strong class="bold">POST Token</strong> request and <strong class="bold">Send</strong> a request. This is to login to a user account. The result is shown in the following screenshot:<div><img src="img/C15309_08_01.jpg" alt="Figure 8.1: Sending the POST Token request&#13;&#10;"/></div><h6>Figure 8.1: Sending the POST Token request</h6></li>
				<li>Create eight recipes by running the following <code>httpie</code> command in the PyCham console. The <code>{token}</code> placeholder should be replaced with the access token we obtained in <em class="italics">step 2</em>:<pre>http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Vegetable Paella" description="This is a lovely vegetable paella" num_of_servings=5 cook_time=60 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Minestrone Soup" description="This is a lovely minestrone soup" num_of_servings=4 cook_time=60 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Thai Red Curry" description="This is a lovely thai red curry" 
num_of_servings=4 cook_time=40 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Coconut Fried Rice" description="This is a lovely coconut fried rice" num_of_servings=2 cook_time=30 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Vegetable Fried Rice" description="This is a lovely vegetable fried rice" num_of_servings=2 cook_time=30 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Burrito Bowls" description="This is a lovely coconut fried rice" num_of_servings=5 cook_time=60 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Fresh Huevos Rancheros" description="This is a lovely fresh huevos rancheros" num_of_servings=4 cook_time=40 directions="This is how you make it"
http POST localhost:5000/recipes "Authorization: Bearer {token}" name="Bean Enchiladas" description="This is a lovely coconut fried rice" num_of_servings=4 cook_time=60 directions="This is how you make it"</pre><h4>Note</h4><p class="callout">You can also create the recipes one by one using Postman. We are using the <code>httpie</code> command here because it's faster.</p></li>
				<li>Publish all eight recipes using the following <code>httpie</code> command. Replace the <code>{token}</code> placeholder with the access token. Make sure that the recipe IDs in the URLs are referring to the recipes we created in the previous step:<pre>http PUT localhost:5000/recipes/6/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/7/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/8/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/9/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/10/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/11/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/12/publish "Authorization: Bearer {token}"
http PUT localhost:5000/recipes/13/publish "Authorization: Bearer {token}"</pre><p>N<a id="_idTextAnchor364"/>ow we have created and published eight recipes. Next, we will get the recipes back page by page with a page size of two recipes.</p></li>
				<li>Click on <code>per_page</code>, <code>2</code>) into <code>first</code>, <code>last</code>, and <code>next</code> pages. We can't see <code>prev</code> here because we are on the first page. There is a total of five pages, and we have two records per page. You can also see the <strong class="bold">sorted</strong> recipe details in the HTTP response.</p></li>
				<li>Next, let's test whether the links in the recipes are working properly. We just need to click on the <code>next</code> URL link, which will open a new tab in Postman with the request URL populated (<code>http://localhost:5000/recipes?per_page=2&amp;page=2</code>). Then, we just need to click on <strong class="bold">Send</strong> to send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_03.jpg" alt="Figure 8.3: Testing the links in the recipes&#13;&#10;"/></div></li>
			</ol>
			<h6>Figure 8.3: Testing the links in the recipes</h6>
			<p>Here, we can see that there are links to the <code>first</code>, <code>last</code>, <code>next</code>, and <code>prev</code> pages. We can also see that we are currently on page 2. All the recipe data is there as well.</p>
			<p>We have successfully created our pagination function. Now, I will leave it to your capable hands to test it.</p>
			<p>The<a id="_idTextAnchor365"/> benefit of pagination is that you are able to segregate thousands of records into pages. Data is retrieved in a page by page manner, and that will reduce the server's workload. But what if the user is setting a page size of, say, 100,000? How can we prevent a user from exploiting the system loophole? What we can do is pass the <code>max_per_page</code> parameter for pagination. That will limit the maximum page size the user can set. If the user is setting a page size bigger than the maximum page size, then the maximum page size will be used.</p>
			<h3 id="_idParaDest-155">Act<a id="_idTextAnchor366"/><a id="_idTextAnchor367"/>ivity 13: Implementing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p>We implemented and tested the pagination function on our all published recipe retrieval APIs in the previous exercise. In this activity, we will work on the pagination function in the user-specific recipe retrieval API. The corresponding API can be found in <code>UserRecipeListResource</code>, which is used to get the recipes from a specific author. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Modify the <code>get_all_by_user</code> method in <code>model/recipe.py</code>.</li>
				<li>Import <code>RecipePaginationSchema</code> into <code>resources/user.py</code>.</li>
				<li>Declare the <code>recipe_pagination_schema</code> attribute in <code>resources/user.py</code>.</li>
				<li>Modify the <code>UserRecipeListResource.get</code> method in <code>resources/user.py</code>.</li>
				<li>Add the <code>@user_kwargs</code> decorator for <code>UserRecipeListResource.get</code>. It takes a few parameters, including <code>page</code>, <code>per_page</code>, and <code>visibility</code>.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 332.</p></li>
			</ol>
			<p>Now, you should have completed the pagination function for the user recipe. Let's follow the same routine and test the function in the next activity.</p>
			<h3 id="_idParaDest-156">Act<a id="_idTextAnchor368"/><a id="_idTextAnchor369"/>ivity 14: Testing Pagination on the User-Specific Recipe Retrieval API</h3>
			<p>In this activity, we will test the user recipe pagination function that we just built. We published eight recipes in the previous exercise. We will use them here as our test subjects. We are going to create a request in Postman and test whether we can get them back, page by page. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Get all the recipes by the author from the previous exercise using Postman, page by page, with a page size of two.</li>
				<li>Click the next URL in the <code>links</code> to query for the next two records.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 334.</p></li>
			</ol>
			<h2 id="_idParaDest-157">Rec<a id="_idTextAnchor370"/>ipe Searching</h2>
			<p>In the previous exercises, we implemented the <code>pagination</code> function and also saw the benefits of using it. This can greatly reduce the number of recipes that are going back to users in one go. From the user's perspective, they can browse through different pages to look for the recipe they want. </p>
			<p>A better way for the user to look for a recipe is by searching. The search function is an essential function on the internet. Look at the search giant Google; their search engine brings in huge amounts of revenue. Of course, we are not going to implement anything of the scale of Google in our Smilecook application. We will be just doing a simple text matching search here.</p>
			<p>In the next exercise, we will implement the search function in our Smilecook platform. We will build a recipe searching API that allows the client to provide a <code>q</code> parameter to search for specific recipes by name or recipe description. This can be done by using the <code>LIKE</code> comparison operator. The <code>LIKE</code> operator works by matching the search string with the target string. We can use <code>%</code> in the search string as a wildcard. If it's not a exact match here it is more like a <code>SIMILAR TO</code> matching. So, the <code>%Chicken%</code> search string will match with the <code>Hainanese Chicken Rice</code> string.</p>
			<p>Perhaps a better choice of comparison operator would be <code>ILIKE</code>. <code>LIKE</code> is case-sensitive, while <code>ILIKE</code> is case-insensitive. For example, we can't match <code>Thai Red Curry</code> with <code>%curry%</code> using the <code>LIKE</code> operator. You can see that <code>C</code> is uppercase here. However, if we use <code>ILIKE</code>, it will match perfectly fine. </p>
			<p>Take a look at the following table to see how the comparison operator works:</p>
			<div><div><img src="img/C15309_08_04.jpg" alt="Figure 8.4: Comparison operators&#13;&#10;"/>
				</div>
			</div>
			<h6>Figure 8.4: Comparison operators</h6>
			<p>In our Smilecook platform, we don't want our search to be that strict. The search should be case-insensitive. Now, let's see how we can add this function to our Smilecook platform.</p>
			<h3 id="_idParaDest-158"><a id="_idTextAnchor371"/>Exercise 52: Implementing the Search Function</h3>
			<p>Having learned about the recipe searching concept, we want to implement this as a function in our Smilecook platform. To do this, we will be adding a <code>q</code> parameter that will pass the search string into the API. Then, we will use the search string to look for the recipes we require. Let's get started:</p>
			<ol>
				<li value="1">Import <code>or_</code> from <code>sqlalchemy</code> into <code>models/recipe.py</code>:<pre>from sqlalchemy import asc, desc, or_</pre></li>
				<li>Modify the <code>Recipe.get_all_published</code> method in <code>models/recipe.py</code> so that it gets all the published recipes that satisfy the search criteria:<pre>  @classmethod
    def get_all_published(cls, q, page, per_page):
        keyword = '%{keyword}%'.format(keyword=q)
        return cls.query.filter(or_(cls.name.ilike(keyword),
                cls.description.ilike(keyword)),
                cls.is_publish.is_(True)).\
                order_by(desc(cls.created_at)).paginate(page=page, per_page=per_page)</pre><p>The preceding code is used to assign the search pattern to the variable <code>keyword</code>. Then, it searches the <code>name</code> and <code>description</code> fields by this keyword.</p></li>
				<li>Modify <code>RecipeListResource</code> in <code>resources/recipe.py</code>:<pre>class RecipeListResource(Resource):
    @use_kwargs({'q': fields.Str(missing='),
                                   'page': fields.Int(missing=1),
                                   'per_page': fields.Int(missing=20)})
    def get(self, q, page, per_page):
        paginated_recipes = Recipe.get_all_published(q, page, per_page)
        return recipe_pagination_schema.dump(paginated_recipes).data, HTTPStatus.OK</pre><p>We added the <code>q</code> parameter to the <code>user_kwargs</code> decorator and the <code>get</code> function. The default for this <code>q</code> value is an empty string. The <code>q</code> parameter will also be passed into the <code>get_all_published</code> function.</p></li>
			</ol>
			<p>Now we are done with the search function. Next, we are going to test this function.</p>
			<h3 id="_idParaDest-159"><a id="_idTextAnchor372"/>Exercise 53: Testing the Search Function</h3>
			<p>In this exercise, we will be testing the search function that we have just built. We will test by searching for recipes that contain the <code>fried rice</code> string in the name or description. Let's get started:</p>
			<ol>
				<li value="1">Click on the <code>RecipeList</code> request and select the <strong class="bold">Params</strong> tab.</li>
				<li>Insert the first key-value pair (<code>q</code>, <code>fried rice</code>).</li>
				<li>Insert the second key-value pair (<code>per_page</code>, <code>2</code>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_05.jpg" alt="Figure 8.5: Searching for recipes that contain the &quot;fried rice&quot; string in the name or description&#13;&#10;"/></div><h6>Figure 8.5: Searching for recipes that contain the "fried rice" string in the name or description</h6><p>Here, we can see four fried rice recipe records, divided into two pages.</p></li>
				<li>Next, test whether the links in the recipes are still working properly. We just need to click on the next URL link, which will open a new tab in Postman with the request URL populated (<code>http://localhost:5000/recipes?q=fried+rice&amp;per_page=2&amp;page=2</code>). Then, we just need to click on <strong class="bold">Send</strong> to send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_06.jpg" alt="Figure 8.6: Testing whether the links in the recipes are working&#13;&#10;"/></div></li>
			</ol>
			<h6><a id="_idTextAnchor373"/>Figure 8.6: Testing whether the links in the recipes are working</h6>
			<p>From the result, we can that we are now on <code>page 2</code>. The recipe records are also sorted by creation time. The latest recipe is placed on the top.</p>
			<p>So far, we have created the pagination and searching functions. This is a great achievement, but we are not done yet. We need to continue enhancing our Smilecook application. Without further ado, let's move on.</p>
			<h2 id="_idParaDest-160">So<a id="_idTextAnchor374"/>rting and Ordering</h2>
			<p>Sorting is another important feature that helps user navigation. Again, when we build any application, we need to keep the user experience in mind. Our application could eventually store millions of recipes, so we need to provide an easy way for our users to navigate the recipes and find the recipe they want.</p>
			<p>Previously, the recipes that we sent back were sorted by time by default. Let's implement some other sorting criteria in our Smilecook application. We can still keep the default sorting criteria such as time, but we want to allow the user to define the searching criteria they want; for example, they can specify that they want the recipes to be sorted by cooking time. This is a possibility as the user may want to cook a quick meal, which means they will only be interested in recipes with short cooking times.</p>
			<p>For our Smilecook application, sorting and ordering can be done by adding the <code>sort</code> and <code>order</code> parameters. We can put the sorting criteria (for example, <code>created_at</code>, <code>cook_time</code>, or <code>num_of_servings</code>) into the <code>sort</code> parameter, and we can use <code>created_at</code> as the default. The <code>order</code> parameter is used to specify whether it is <code>asc</code> (ascending order) or <code>desc</code> (descending order). We can put <code>desc</code> as the default.</p>
			<p>In terms of the syntax, if we want our SQLAlchemy query result to be sorted in ascending order, we can do the following:</p>
			<pre>Import asc        
    
sort_logic_asc = asc(getattr(cls, sort))
cls.query.filter(cls.is_publish=True).order_by(sort_logic_asc)</pre>
			<p>If we want it to be sorted in descending order, we can just use <code>desc</code>:</p>
			<pre>Import desc        
    
sort_logic_desc = desc(getattr(cls, sort))
cls.query.filter(cls.is_publish=True).order_by(sort_logic_desc)</pre>
			<h4>Note</h4>
			<p class="callout">Instead of <code>cls.is_published=True</code>, you can also use the SQLAlchemy column operator, that is, <code>cls.is_published.is_(True)</code>. You will get the same result.</p>
			<p>In the next exercise, we will implement the sorting and ordering functions in our Smilecook platform. This will make our application more user-friendly.</p>
			<h3 id="_idParaDest-161">Ex<a id="_idTextAnchor375"/>ercise 54: Implementing Sorting and Ordering</h3>
			<p>In this exercise, we will implement the sorting and ordering functions in our Smilecook platform. We will be adding the <code>sort</code> and <code>order</code> parameters to the get all published recipes API so that users can perform sorting and ordering on the published recipes. Let's get started:</p>
			<ol>
				<li value="1">In <code>resources/recipe.py</code>, use the <code>use_kwargs</code> <code>method</code> in the decorator to add two parameters (<code>sort</code>, <code>order</code>) to the <code>RecipeListResource.get</code> method. Set the default values for these two parameters to <code>created_at</code> and <code>desc</code>, respectively:<pre>@use_kwargs({'q': fields.Str(missing='),
                        'page': fields.Int(missing=1),
                        'per_page': fields.Int(missing=20),
                        'sort': fields.Str(missing='created_at'),
                        'order': fields.Str(missing='desc')})
def get(self, q, page, per_page, sort, order):</pre></li>
				<li>Restrict the <code>sort</code> parameter to accept only the <code>created_at</code>, <code>cook_time</code>, and <code>num_of_servings</code> values. If other values are passed in, then we'll default to <code>created_at</code>:<pre>        if sort not in ['created_at', 'cook_time', 'num_of_servings']:
            sort = 'created_at'</pre></li>
				<li>Restrict the <code>order</code> parameter to accept only the <code>asc</code> and <code>desc</code> values. If other values are passed in, then we'll default to <code>desc</code>:<pre>        if order not in ['asc', 'desc']:
            order = 'desc'</pre></li>
				<li>Pass the <code>sort</code> and <code>order</code> parameters into the <code>get_all_published</code> function:<pre>        paginated_recipes = Recipe.get_all_published(q, page, per_page, sort, order)</pre></li>
				<li>Modify the <code>get_all_published</code> method in <code>models/recipe.py</code> so that it looks as follows. It takes in two additional parameters, that is, <code>sort</code> and <code>order</code>, to define the logic:<pre>    @classmethod
    def get_all_published(cls, q, page, per_page, sort, order):
        keyword = '%{keyword}%'.format(keyword=q)
        if order == 'asc':
            sort_logic = asc(getattr(cls, sort))
        else:
            sort_logic = desc(getattr(cls, sort))
        return cls.query.filter(or_(cls.name.ilike(keyword),
                                    cls.description.ilike(keyword)),
                                cls.is_publish.is_(True)).\
            order_by(sort_logic).paginate(page=page, per_page=per_page)</pre></li>
			</ol>
			<p>Here, we have created the sorting and ordering functions. Not many changes were made to the code. Next, we are going to test our implementation using Postman.</p>
			<h3 id="_idParaDest-162">Ex<a id="_idTextAnchor376"/>ercise 55: Testing the Sorting and Ordering Feature</h3>
			<p>In the previous exercise, we created customized ordering functions. Users should be able to order the recipe records in our Smilecook platform by their specified column, and in either ascending or descending order. In this exercise, we will test whether that is really the case. We will pass the <code>sort</code> and <code>order</code> parameters into Postman and verify them. Let's get started:</p>
			<ol>
				<li value="1">We will send a request to get all the recipe records back. Then, sort the data by <code>cook_time</code> in ascending order. First, click on the <code>RecipeList</code> request and select the <strong class="bold">Params</strong> tab.</li>
				<li>Insert the first key-value pair (<code>sort</code>, <code>cook_time</code>).</li>
				<li>Insert the second key-value pair (<code>order</code>, <code>desc</code>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_07.jpg" alt="Figure 8.7: Sending a request to get all the recipe records back&#13;&#10;"/></div><h6>Figure 8.7: Sending a request to get all the recipe records back</h6><p>From the preceding search result, we can see that the recipe's <code>cook_time</code> is sorted in ascending order. The first recipe's <code>cook_time</code> is 20 minutes, whereas the second one is 30 minutes.</p></li>
				<li>Send a request to get all the recipe records back. Then, sort the data by <code>num_of_servings</code> in descending order. Click on <code>RecipeList</code> and select the <strong class="bold">Params</strong> tab.</li>
				<li>Insert the first key-value pair (<code>sort</code>, <code>num_of_servings</code>).</li>
				<li>Insert the second key-value pair (<code>order</code>, <code>desc</code>).</li>
				<li>Send the request. The result is shown in the following screenshot:<div><img src="img/C15309_08_08.jpg" alt="Figure 8.8: Sending a request and sorting the data by num_of_servings in descending order&#13;&#10;"/></div><h6>Figure 8.8: Sending a request and sorting the data by num_of_servings in descending order</h6></li>
				<li>From the preceding search result, we can see that the recipe's <code>num_of_servings</code> has been sorted in descending order. The first recipe's <code>num_of_servings</code> is for five people, whereas the second one is for four people.</li>
			</ol>
			<p>Now, you have finished developing and testing all the functions you have learned about in this chapter. Next, we will complete an activity to ensure you have the flexibility to use what we have learned so far.</p>
			<h3 id="_idParaDest-163"><a id="_idTextAnchor377"/>Activity 15: Searching for Recipes with Specific Ingredients</h3>
			<p>In this activity, we will search the recipes using a specific attribute. We will add a new <code>ingredients</code> attribute and then pass in parameters to search through the recipe. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add the ingredients attribute to the <code>Recipe</code> model.</li>
				<li>Run Flask-Migrate to update the database.</li>
				<li>Add the <code>ingredients</code> attribute to <code>RecipeSchema</code>.</li>
				<li>Modify the <code>RecipeResource.patch</code> method to support the <code>ingredients</code> attribute update.</li>
				<li>Modify the <code>Recipe.get_all_published</code> method so that you can search through the ingredients.</li>
				<li>Create two recipes with the <code>ingredients</code> attribute and publish them.</li>
				<li>Search for the recipes using the <code>ingredients</code> attribute.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 336.</p></li>
			</ol>
			<p>Congratulations! You have completed this activity. Now, please work on the assessments to test your understanding of this chapter.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor378"/>Summary</h2>
			<p>We have implemented a lot of great features in this chapter that allows users to find the recipe information they want in a simple and efficient manner. The pagination function we implemented allows the user to quickly find out how many recipes there are in total and navigate them page by page. It also saves the server's resources as it doesn't need to render thousands of recipes in one go. </p>
			<p>The search function is another time-saving feature. Users can now look for the recipes they want by performing a simple search. We have also completed the sorting and ordering functions in the Smilecook application, which provide a better browsing experience for users. </p>
			<p>So far, we have created almost all of the user functions we need. Our Smilecook platform development is nearing its end. In the next chapter, we will work on internal system optimization, such as HTTP caching and rate-limiting.</p>
		</div>
	</body></html>