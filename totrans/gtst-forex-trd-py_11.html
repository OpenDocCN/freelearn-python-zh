<html><head></head><body>
<div id="_idContainer119">
<h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/><span class="koboSpan" id="kobo.2.1">Backtesting and Theoretical Performance</span></h1>
<p><span class="koboSpan" id="kobo.3.1">It’s been a long and, hopefully, interesting – although difficult at times – journey. </span><span class="koboSpan" id="kobo.3.2">It took us ten chapters to get familiar with all the essentials of market structure and the key concepts that create the foundation of systematic and algo trading. </span><span class="koboSpan" id="kobo.3.3">Now, we have approached the conclusion of this entire book. </span><span class="koboSpan" id="kobo.3.4">It’s time to bring all the pieces together and start developing our first trading application that can be used in both research </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and production.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">We are going to develop a universal prototype that you will be able to use and reuse by just re-writing some parts without modifying the entire structure. </span><span class="koboSpan" id="kobo.5.2">We will trace all the paths from receiving a tick to placing an order – while checking the consistency of all our actions. </span><span class="koboSpan" id="kobo.5.3">We will learn how to keep parts of the trading application synchronized and see why it’s so important to do so. </span><span class="koboSpan" id="kobo.5.4">And finally, we will collect some very basic statistics of a sample trading strategy and calculate its theoretical performance – the most essential logical point in the entire research and </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">development process.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Trading app architecture – revised </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and improved</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Multithreading – convenient but full </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">of surprises</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Trading application with a live </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">data feed</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Backtesting – speed up </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">the research</span></span></li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/><span class="koboSpan" id="kobo.17.1">Trading app architecture – revised and improved</span></h1>
<p><span class="koboSpan" id="kobo.18.1">In </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Developing Trading Strategies – Why They Are Different</span></em><span class="koboSpan" id="kobo.22.1">, we proposed a </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.23.1">generalized architecture of a trading application. </span><span class="koboSpan" id="kobo.23.2">In brief, it consists of the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.25.1">Data receiver</span></strong><span class="koboSpan" id="kobo.26.1">: Something </span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.27.1">that retrieves live data from the market or historical data stored locally; see </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.28.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.29.1">, </span><em class="italic"><span class="koboSpan" id="kobo.30.1">Retrieving and Handling Market Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.31.1">with Python</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.32.1">Data cleanup</span></strong><span class="koboSpan" id="kobo.33.1">: A component </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.34.1">that eliminates non-market prices; see </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.36.1">, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Developing Trading Strategies – Why They </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.38.1">Are Different</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.39.1">Trading logic</span></strong><span class="koboSpan" id="kobo.40.1">: The </span><em class="italic"><span class="koboSpan" id="kobo.41.1">brains</span></em><span class="koboSpan" id="kobo.42.1"> of </span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.43.1">the trading app that make trading decisions (see </span><a href="B19145_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.45.1">, </span><em class="italic"><span class="koboSpan" id="kobo.46.1">Basics of Fundamental Analysis and Its Possible Use in FX Trading</span></em><span class="koboSpan" id="kobo.47.1">, </span><a href="B19145_07.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.48.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.49.1">, </span><em class="italic"><span class="koboSpan" id="kobo.50.1">Technical Analysis and Its Implementation in Python</span></em><span class="koboSpan" id="kobo.51.1">, and </span><a href="B19145_09.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.52.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.53.1">, </span><em class="italic"><span class="koboSpan" id="kobo.54.1">Trading Strategies and Their Core Elements</span></em><span class="koboSpan" id="kobo.55.1">), frequently with integrated pre-trade </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">risk management</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Ordering interface</span></strong><span class="koboSpan" id="kobo.58.1">: A component that receives trading signals from the trading </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.59.1">logic, converts them into orders, and keeps track of their execution; see </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.60.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.61.1">, </span><em class="italic"><span class="koboSpan" id="kobo.62.1">Types of Orders and Their Simulation </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.63.1">in Python</span></em></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Post-trade risk management</span></strong><span class="koboSpan" id="kobo.65.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">open positions management</span></strong><span class="koboSpan" id="kobo.67.1">, such as keeping </span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.68.1">track of the running </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.69.1">loss and liquidating losing positions or </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">all positions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.71.1">Anyway, this simplified architecture lists the essential components but does not say anything about how they communicate with each other. </span><span class="koboSpan" id="kobo.71.2">Of course, it is possible to use a linear architecture where all the components are implemented as dependent pieces of code executed </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.72.1">one after another in sequence. </span><span class="koboSpan" id="kobo.72.2">Such a solution is simple, but has </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">significant drawbacks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">You won’t be able to add more trading logic components to run multiple strategies </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">in parallel</span></span></li>
<li><span class="koboSpan" id="kobo.76.1">You won’t be able to send orders to multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">trading venues</span></span></li>
<li><span class="koboSpan" id="kobo.78.1">You won’t be able to receive information about the actual consolidated market position in the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">trading logic</span></span></li>
<li><span class="koboSpan" id="kobo.80.1">You won’t be able to reuse the same code (at least in parts) for both development </span><a id="_idIndexMarker720"/><span class="No-Break"><span class="koboSpan" id="kobo.81.1">and production</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.82.1">Let’s stop for a while at these </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">four disadvantages.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">Regarding the first two points, you may probably say that you’re not going to run multiple strategies and trade at multiple trading venues as we’re only making our first steps into algo trading, and doing that cross-venue and cross-trading logic is more of an institutional activity. </span><span class="koboSpan" id="kobo.84.2">I could argue that, in reality, it’s more than normal for private traders to do all that, but these two points are less important than the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">remaining two.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">To understand </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.87.1">the importance of the third point, we have to introduce a new term: </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">consolidated </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.89.1">market position</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Imagine that you have several strategies and all of them trade in the same market – say, EURUSD. </span><span class="koboSpan" id="kobo.91.2">The first one bought 100,000 euros, the second one sold 80,000, and the third one bought 50,000. </span><span class="koboSpan" id="kobo.91.3">Why has this happened? </span><span class="koboSpan" id="kobo.91.4">It’s quite a common situation: for example, you run a short-term </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.92.1">mean reversion strategy, longer-term breakout, and long-term trend following strategies (see </span><a href="B19145_09.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.93.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.94.1">, </span><em class="italic"><span class="koboSpan" id="kobo.95.1">Trading Strategies and Their Core Elements</span></em><span class="koboSpan" id="kobo.96.1">); they generate trading signals independently, but so long as they all trade the same market, they all contribute to the amount of the asset currently traded. </span><span class="koboSpan" id="kobo.96.2">This amount is called the consolidated </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">market position.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">In our example, the individual positions per strategy are 100,000 long, 80,000 short, and another 50,000 long, so the consolidated position is </span><em class="italic"><span class="koboSpan" id="kobo.99.1">70,000 long</span></em><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">This is your real market exposure and all position sizing calculations should rely on </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">this figure.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">But what about the entry price for such a </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">consolidated position?</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">In </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.105.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.106.1">, </span><em class="italic"><span class="koboSpan" id="kobo.107.1">Types of Orders and Their Simulation in Python</span></em><span class="koboSpan" id="kobo.108.1">, we explored the average execution price for an order that was executed in parts. </span><span class="koboSpan" id="kobo.108.2">The same approach can be used to calculate the average entry price for the consolidated market position. </span><span class="koboSpan" id="kobo.108.3">Let’s do this simple math for our example with three </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">open positions.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Suppose that the first (100,000 long) position was opened at 1.0552, the second (80,000 short) at 1.0598, and the third (50,000 long) at 1.0471. </span><span class="koboSpan" id="kobo.110.2">First, we calculate the sum of these prices multiplied by the respective trading size. </span><span class="koboSpan" id="kobo.110.3">Don’t forget that short positions (which effectively reduce the consolidated market position) should be accounted for as </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">negative numbers:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">S = 100000 * 1.0552 – 80000 * 1.0598 + 50000 * 1.0471 = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">73091</span></strong></span></p>
<p><span class="koboSpan" id="kobo.114.1">Now, we divide the sum, </span><em class="italic"><span class="koboSpan" id="kobo.115.1">S</span></em><span class="koboSpan" id="kobo.116.1">, by the actual consolidated market position, </span><em class="italic"><span class="koboSpan" id="kobo.117.1">MP</span></em><span class="koboSpan" id="kobo.118.1">, which equals </span><em class="italic"><span class="koboSpan" id="kobo.119.1">70,000</span></em><span class="koboSpan" id="kobo.120.1">, and we get the average </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">entry price:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<span class="koboSpan" id="kobo.122.1"><img alt="" src="image/Formula_B19145_11_001.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.123.1">In our example, the consolidated average price is approximately 1.0442. </span><span class="koboSpan" id="kobo.123.2">At first glance, it looks ridiculous </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.124.1">as it is way lower than the lowest of the actual traded prices. </span><span class="koboSpan" id="kobo.124.2">But it’s really easy to make sure </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">it’s correct.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Imagine that the current market price is 1.0523. </span><span class="koboSpan" id="kobo.126.2">Let’s calculate the running </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">profit or loss</span></strong><span class="koboSpan" id="kobo.128.1"> (typically referred to as running </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">PnL</span></strong><span class="koboSpan" id="kobo.130.1"> or running </span><strong class="bold"><span class="koboSpan" id="kobo.131.1">P/L</span></strong><span class="koboSpan" id="kobo.132.1">; see </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.134.1">, </span><em class="italic"><span class="koboSpan" id="kobo.135.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.136.1">, the </span><em class="italic"><span class="koboSpan" id="kobo.137.1">Trade mechanics – again some terminology</span></em><span class="koboSpan" id="kobo.138.1"> section) for each position: it’s just the distance between the current price and the entry price multiplied by the trading size. </span><span class="koboSpan" id="kobo.138.2">The first position running PnL at 1.0523 equals (1.0523 – 1.0552) * 100,000 = -$290, the second position running PnL equals (1.0523 – 1.0598) * -80,000 = $600, and the third position running PnL equals (1.0523 – 1.0471) * 50,000 = $260. </span><span class="koboSpan" id="kobo.138.3">Thus, for the consolidated market position, the running PnL </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">equals $570.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Now, let’s do the same math with the price and the size of only one consolidated market position. </span><span class="koboSpan" id="kobo.140.2">Given it was </span><em class="italic"><span class="koboSpan" id="kobo.141.1">opened</span></em><span class="koboSpan" id="kobo.142.1"> at 1.0442 and the current market price is 1.0523, its running PnL is (1.0523 – 1.0442) * 70,000 = $567, which is not exactly equal to $570 only because we rounded the average price to the 4th digit. </span><span class="koboSpan" id="kobo.142.2">So, we can indeed use the average price and the resulting trading size of the consolidated market position instead of calculating the PnL for each </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">position separately.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.144.1">Note for nerds</span></p>
<p class="callout"><span class="koboSpan" id="kobo.145.1">Such a </span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.146.1">consolidated position calculated as the average of all orders with their respective trade volume is often called the </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">Volume Weighted Average Price</span></strong><span class="koboSpan" id="kobo.148.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.149.1">VWAP</span></strong><span class="koboSpan" id="kobo.150.1">). </span><span class="koboSpan" id="kobo.150.2">However, the VWAP is normally only used to evaluate a position that was accumulated by multiple entries to the same direction, and so long as we are discussing the net position as the result of trades taken to both sides, I prefer using </span><em class="italic"><span class="koboSpan" id="kobo.151.1">consolidated</span></em><span class="koboSpan" id="kobo.152.1">, although it’s not a </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">regular term.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">A consolidated market position is extremely important to correctly implement risk management. </span><span class="koboSpan" id="kobo.154.2">If you don’t know this position, you have no idea about your running profit or loss, so you don’t know when to liquidate a losing position – which may end up with a disastrous loss. </span><span class="koboSpan" id="kobo.154.3">Moreover, you may not know even how much to liquidate, and open a new position instead of only covering </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">a loss.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Even if you run only one strategy in one market, it is no less important to know the exact market position as it exists in the real market: don’t forget that a certain order may not be executed or executed at a price different as expected due to several reasons (see </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.157.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.158.1">, </span><em class="italic"><span class="koboSpan" id="kobo.159.1">Types of Orders and Their Simulation in Python</span></em><span class="koboSpan" id="kobo.160.1">). </span><span class="koboSpan" id="kobo.160.2">So, if you don’t let your code provide feedback from the broker to the trading logic, you may have a hard time managing </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">your positions.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">The fourth </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.163.1">disadvantage is hopefully more evident: if we can suggest an architecture that is flexible, modular, and reusable, then it has an advantage over something that should be modified entirely every time you want just to switch a </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">data source.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">So, with all these considerations in mind, what can we suggest to make the architecture of our trading app meet all the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">requirements mentioned?</span></span></p>
<p><span class="koboSpan" id="kobo.167.1">We already know the solution, and we used it quite successfully in </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.168.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.169.1">, </span><em class="italic"><span class="koboSpan" id="kobo.170.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">This solution is to use </span><em class="italic"><span class="koboSpan" id="kobo.172.1">threads</span></em><span class="koboSpan" id="kobo.173.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.174.1">queues</span></em><span class="koboSpan" id="kobo.175.1"> to make the components of the app work independently. </span><span class="koboSpan" id="kobo.175.2">I strongly recommend that you refresh your memory regarding threads and queues by referring to the </span><em class="italic"><span class="koboSpan" id="kobo.176.1">Working with saved and live data – keep your app universal</span></em><span class="koboSpan" id="kobo.177.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">that chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">Now, let’s redraw the app architecture diagram, this time at a bit lower level, closer to the transport layer, not just </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">business logic.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">As always, we will start from the beginning: receiving live (tick) </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">market data.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.183.1">Market data component</span></h2>
<p><span class="koboSpan" id="kobo.184.1">This component </span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.185.1">should be able to receive </span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.186.1">ticks from virtually any source, clean it up, translate them into the single format used throughout our app, and put them into the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">data queue:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.188.1"><img alt="Figure 11.1 – Tick data receiving component" src="image/B19145_11_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.189.1">Figure 11.1 – Tick data receiving component</span></p>
<p><span class="koboSpan" id="kobo.190.1">The beauty </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.191.1">of this approach is that as soon as the tick is sent to </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.192.1">the tick queue, we can forget about it. </span><span class="koboSpan" id="kobo.192.2">This process is now isolated from the rest of the app, and should we need to change the data vendor or the broker, we can do that by rewriting the respective module without making a single change in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Many strategies require tick data. </span><span class="koboSpan" id="kobo.194.2">For example, arbitrage strategies (see </span><a href="B19145_09.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.196.1">, </span><em class="italic"><span class="koboSpan" id="kobo.197.1">Trading Strategies and Their Core Elements</span></em><span class="koboSpan" id="kobo.198.1">) can work using </span><em class="italic"><span class="koboSpan" id="kobo.199.1">only</span></em><span class="koboSpan" id="kobo.200.1"> tick data. </span><span class="koboSpan" id="kobo.200.2">However, the majority of trading strategies use logic based on compressed data, not ticks. </span><span class="koboSpan" id="kobo.200.3">So, we need to add a component that can aggregate ticks into bars (see </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.201.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.202.1">, </span><em class="italic"><span class="koboSpan" id="kobo.203.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.204.1">, the </span><em class="italic"><span class="koboSpan" id="kobo.205.1">Data compression – keep the amounts to the reasonable </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.206.1">minimum</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1"> section).</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.208.1">Data aggregation component</span></h2>
<p><span class="koboSpan" id="kobo.209.1">This module </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.210.1">should be able to </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.211.1">not only aggregate live tick data into bars. </span><span class="koboSpan" id="kobo.211.2">When we develop a strategy, we normally use historical market data stored locally already in a compressed form, so there’s no need to waste time aggregating ticks during a test run. </span><span class="koboSpan" id="kobo.211.3">Thus, we must add the following part to our </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">app architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.213.1"><img alt="Figure 11.2 – Reading bars from storage or forming bars from ticks" src="image/B19145_11_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.214.1">Figure 11.2 – Reading bars from storage or forming bars from ticks</span></p>
<p><span class="koboSpan" id="kobo.215.1">Again, as in </span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.216.1">the previous case, this process is isolated </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.217.1">from the rest of the application, so we can implement it once and forget about it until we need to modify something in the way we aggregate ticks </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">into bars.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Next, we should implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">trading logic.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.221.1">Trading logic component</span></h2>
<p><span class="koboSpan" id="kobo.222.1">This component may use both tick and bar data as input and produce orders as output. </span><span class="koboSpan" id="kobo.222.2">This output </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.223.1">should go into the order execution </span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.224.1">control component of our trading app, so it’s quite natural to use another queue again: the ordering queue that would isolate the order execution component from the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">However, besides just sending orders out, we need another connection between the trading logic and the order execution components. </span><span class="koboSpan" id="kobo.226.2">This connection should provide feedback from the execution of the order to the trading logic. </span><span class="koboSpan" id="kobo.226.3">How do we establish such </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">a connection?</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">The first idea that probably comes to mind at this point is to use yet another queue. </span><span class="koboSpan" id="kobo.228.2">However, in this case, it’s not convenient. </span><span class="koboSpan" id="kobo.228.3">Queues are great when you want to trigger a certain process as soon as data is in the queue – in other words, they are ideal for event-driven processes. </span><span class="koboSpan" id="kobo.228.4">But market position or equity values do not trigger any process by themselves: they are only used by various components of the trading app as auxiliary values. </span><span class="koboSpan" id="kobo.228.5">Therefore, instead of a queue, we will create an object that will store all the required data about the implemented trading strategy and share this object across all components of our </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">trading app.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">This object can contain any strategy metadata, such as market position, equity time series (see below), running PnL, realized profit or loss, various statistical metrics, and </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">so on:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.232.1"><img alt="Figure 11.3 – Prototype of an object that stores trading strategy metadata" src="image/B19145_11_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.233.1">Figure 11.3 – Prototype of an object that stores trading strategy metadata</span></p>
<p><span class="koboSpan" id="kobo.234.1">Last price means the quote received with the previous tick (or bar) and it serves to calculate the running PnL between two ticks (or bars): if the position is </span><em class="italic"><span class="koboSpan" id="kobo.235.1">long</span></em><span class="koboSpan" id="kobo.236.1"> and the price has </span><em class="italic"><span class="koboSpan" id="kobo.237.1">increased</span></em><span class="koboSpan" id="kobo.238.1">, then the running PnL has also </span><em class="italic"><span class="koboSpan" id="kobo.239.1">increased</span></em><span class="koboSpan" id="kobo.240.1">, if the position is </span><em class="italic"><span class="koboSpan" id="kobo.241.1">short</span></em><span class="koboSpan" id="kobo.242.1"> and the price has </span><em class="italic"><span class="koboSpan" id="kobo.243.1">decreased</span></em><span class="koboSpan" id="kobo.244.1">, then the running PnL nevertheless </span><em class="italic"><span class="koboSpan" id="kobo.245.1">increased</span></em><span class="koboSpan" id="kobo.246.1">, and so on. </span><span class="koboSpan" id="kobo.246.2">If we sum all changes in the running PnL on every tick or bar from the moment when the strategy started until the present, then we will get the overall profit and loss, which is frequently referred to </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.247.1">by traders as </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">equity</span></strong><span class="koboSpan" id="kobo.249.1">. </span><span class="koboSpan" id="kobo.249.2">This is a bit of professional slang because formally, the equity is the value attributable to the owners of a business (see, for example, </span><a href="https://corporatefinanceinstitute.com/resources/valuation/equity/"><span class="koboSpan" id="kobo.250.1">https://corporatefinanceinstitute.com/resources/valuation/equity/</span></a><span class="koboSpan" id="kobo.251.1"> for details), but in algo trading, </span><em class="italic"><span class="koboSpan" id="kobo.252.1">equity</span></em><span class="koboSpan" id="kobo.253.1"> frequently means just the realized profit and loss, plus the value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">open position.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">We can also </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.256.1">save the equity value on </span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.257.1">each tick or bar, thus creating a time series. </span><span class="koboSpan" id="kobo.257.2">This time series is normally referred to as the equity curve and works as the most common illustration of the trading strategy’s performance: the way the strategy behaved in the past and when and how much money it made (or lost). </span><span class="koboSpan" id="kobo.257.3">This information can also be used by the trading logic, along with market price data and </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">market position.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">We also included two </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.260.1">money management-related parameters: </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">initial capital</span></strong><span class="koboSpan" id="kobo.262.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">leverage</span></strong><span class="koboSpan" id="kobo.264.1">. </span><span class="koboSpan" id="kobo.264.2">These values </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.265.1">can be used to check if we have sufficient funds to trade and also to determine the actual trading size for </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">our orders.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Now that we’ve added such a universal object that transfers strategy metadata between the trading logic and the order execution component, we can add the trading logic component to our </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">architectural diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.269.1"><img alt="Figure 11.4 – Trading logic and common trading strategy parameters container" src="image/B19145_11_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.270.1">Figure 11.4 – Trading logic and common trading strategy parameters container</span></p>
<p><span class="koboSpan" id="kobo.271.1">The last </span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.272.1">mandatory component </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.273.1">to be added is the order </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">execution component.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.275.1">Order execution component</span></h2>
<p><span class="koboSpan" id="kobo.276.1">This component </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.277.1">not only implements an ordering interface </span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.278.1">with the broker or emulates the execution of orders locally. </span><span class="koboSpan" id="kobo.278.2">It will also do some basic analysis of the strategy’s performance – for the needs of the trading logic. </span><span class="koboSpan" id="kobo.278.3">It should process the order, send it to a broker or emulate it locally, receive the execution status, process this status (for example, if the order was rejected, decide what to do: cancel or submit again), calculate the running PnL, and build the equity curve. </span><span class="koboSpan" id="kobo.278.4">Let’s add it to </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">our diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<span class="koboSpan" id="kobo.280.1"><img alt="Figure 11.5 – Order execution control module and its interaction with the trading strategy properties object" src="image/B19145_11_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.281.1">Figure 11.5 – Order execution control module and its interaction with the trading strategy properties object</span></p>
<p><span class="koboSpan" id="kobo.282.1">Let’s see </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.283.1">how it works. </span><span class="koboSpan" id="kobo.283.2">First, we receive </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.284.1">an order or orders from the order queue. </span><span class="koboSpan" id="kobo.284.2">These orders were generated and put into the queue by the trading logic. </span><span class="koboSpan" id="kobo.284.3">Then, we send an order to the broker or emulate its execution locally and receive the order status. </span><span class="koboSpan" id="kobo.284.4">If the order was executed, then we update the PnL and add another data point to the equity time series. </span><span class="koboSpan" id="kobo.284.5">If the order was rejected, we return it to the order queue and the whole process starts </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">over automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Note that the strategy metadata (market position, equity, and so on) is updated with every processed order. </span><span class="koboSpan" id="kobo.286.2">This ensures the ultimate precision in making trading decisions and controlling the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">market exposure.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">Great! </span><span class="koboSpan" id="kobo.288.2">We now </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.289.1">have a general view of the entire trading app architecture. </span><span class="koboSpan" id="kobo.289.2">And the most pleasant thing is that it is split into small, relatively </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.290.1">simple components. </span><span class="koboSpan" id="kobo.290.2">We know how these components should communicate with each other, we know the data formats, and we know the sequence in which they should operate, so it seems we know everything we need to implement a </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">trading application.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">But before we start coding, I’d like to emphasize two advantages of the suggested architecture that are very hard </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">to overvalue.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.294.1">Advantages of the modular architecture</span></h2>
<p><span class="koboSpan" id="kobo.295.1">First of all, this architecture makes sure that </span><strong class="bold"><span class="koboSpan" id="kobo.296.1">your trading app will never peek ahead</span></strong><span class="koboSpan" id="kobo.297.1"> during the research phase (while using historical data). </span><span class="koboSpan" id="kobo.297.2">At this point, I recommend </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.298.1">that you refresh your </span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.299.1">memory regarding peeking ahead, which was considered in detail in </span><a href="B19145_04.xhtml#_idTextAnchor073"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.300.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.301.1">, </span><em class="italic"><span class="koboSpan" id="kobo.302.1">Trading Application – What’s Inside?</span></em><span class="koboSpan" id="kobo.303.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.304.1">Trading logic – this is where a small mistake may cost a fortune</span></em><span class="koboSpan" id="kobo.305.1"> section – I am sure you will appreciate the suggested architecture of our </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">trading app.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Second, this architecture provides for a flexible modular code that conforms to the concept of a universal trading application: you can quickly switch data sources and trading venues and use the same application both for research </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">and production.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">It seems like we have covered everything we need to start coding our first trading application. </span><span class="koboSpan" id="kobo.309.2">However, there is one point of extreme importance that is surprisingly too frequently missed by so many developers: the problem of thread synchronization. </span><span class="koboSpan" id="kobo.309.3">To understand this problem and find out the right solutions to it, let’s do a brief </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">lyrical digression</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.311.1">about multithreading.</span></span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.312.1">Multithreading – convenient but full of surprises</span></h1>
<p><span class="koboSpan" id="kobo.313.1">We already </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.314.1">worked with multithreading (see </span><a href="B19145_05.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.315.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.316.1">, </span><em class="italic"><span class="koboSpan" id="kobo.317.1">Retrieving and Handling Market Data with Python</span></em><span class="koboSpan" id="kobo.318.1">, the </span><em class="italic"><span class="koboSpan" id="kobo.319.1">Universal data connector</span></em><span class="koboSpan" id="kobo.320.1"> section), and we found that using multiple threads makes life way easier when we develop modular scalable applications. </span><span class="koboSpan" id="kobo.320.2">However, we never explored how multithreading is implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">in Python.</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">Two concepts are </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.323.1">frequently confused: </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">multiprocessing</span></strong><span class="koboSpan" id="kobo.325.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">multithreading</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">The difference between them is that the former uses the concept of isolated processes, each </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.328.1">of them having a </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">global interpreter lock</span></strong><span class="koboSpan" id="kobo.330.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.331.1">GIL</span></strong><span class="koboSpan" id="kobo.332.1">), thus enabling parallel execution using separate physical or logical processors </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.333.1">or processor cores (so-called </span><strong class="bold"><span class="koboSpan" id="kobo.334.1">true parallelism</span></strong><span class="koboSpan" id="kobo.335.1">), whereas the latter runs a single process that doesn’t care about the number of processors or cores: it executes threads in small portions, allowing each thread to run for several milliseconds and then switching to another one. </span><span class="koboSpan" id="kobo.335.2">Of course, from a human perspective, it does look like processes are running in parallel. </span><span class="koboSpan" id="kobo.335.3">In most cases, we don’t even think about which thread is executed at which moment. </span><span class="koboSpan" id="kobo.335.4">But when implementing event-driven processes, it becomes critical to know what happens first: for example, if we try to generate an order before market data is received, it may end with an error in the </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">best case.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">To learn how real multithreading works, let’s write some simple code with three threads emulating the respective components of our </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">trading application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
from threading import Thread
import time
def t1(): # A thread that emulates data receiving
    while True:
        print('Receive data')
        time.sleep(1)
def t2(): # A thread that emulates trading logic
    while True:
        print('Trading logic')
        time.sleep(1)
def t3(): # A thread that emulates order execution
    while True:
        print('Processing orders')
        time.sleep(1)
thread1 = Thread(target=t1)
thread2 = Thread(target=t2)
thread3 = Thread(target=t3)
thread1.start()
thread2.start()
thread3.start()</span></pre>
<p><span class="koboSpan" id="kobo.340.1">Since we start </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.341.1">the threads one by one (1, 2, and then 3), we may expect to see messages stating </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Receive data</span></strong><span class="koboSpan" id="kobo.343.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Trading logic</span></strong><span class="koboSpan" id="kobo.345.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Processing orders</span></strong><span class="koboSpan" id="kobo.347.1"> and repeating in this same order. </span><span class="koboSpan" id="kobo.347.2">However, when we run the code, we will see </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">something different:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
Receive data
Trading logic
Processing orders
Receive dataProcessing orders
Trading logic
Processing ordersReceive data
Trading logic
Processing orders
Receive data
Trading logic
Trading logic
Processing orders
Receive data
Trading logicProcessing orders
Receive data
Processing ordersReceive data
Trading logic</span></pre>
<p><span class="koboSpan" id="kobo.350.1">We can see that while on average the number of messages of each kind is more or less the same, the order in </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.351.1">which they appear is almost random, making the output chaotic. </span><span class="koboSpan" id="kobo.351.2">This happens because, by default, no thread has any priority and each runs a small portion as soon as </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">it can.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Of course, such a behavior is not suitable for a trading app: we want to make sure that we first receive a tick, then process it, then generate an order, and finally send it for execution – in this very order and not </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">any other!</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">There are several solutions to this problem. </span><span class="koboSpan" id="kobo.355.2">We will use two: using data streams as events for synching and using </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">threading.Event()</span></strong><span class="koboSpan" id="kobo.357.1"> objects to switch between threads. </span><span class="koboSpan" id="kobo.357.2">We will consider each approach in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">upcoming sections.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Let’s start by implementing a version of the trading app that works with live tick data, and then see how we can easily transform it into a powerful backtesting tool (if you don’t clearly remember the meaning of backtesting, just jump back to </span><a href="B19145_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.360.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.361.1">, </span><em class="italic"><span class="koboSpan" id="kobo.362.1">Using Python for Trading Strategies</span></em><span class="koboSpan" id="kobo.363.1">, the </span><em class="italic"><span class="koboSpan" id="kobo.364.1">What is paper trading and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.365.1">backtesting?</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1"> section).</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.367.1">Trading application with live data feed</span></h1>
<p><span class="koboSpan" id="kobo.368.1">As always, we </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.369.1">start by doing </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">some imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
import json
import threading
import queue
from datetime import datetime
from websocket import create_connection</span></pre>
<p><span class="koboSpan" id="kobo.372.1">Next, we create </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.373.1">a class that contains the strategy metadata (see the </span><em class="italic"><span class="koboSpan" id="kobo.374.1">Trading logic </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.375.1">component</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1"> section):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.377.1">
class tradingSystemMetadata:
    def __init__(self):
        self.initial_capital = 10000
        self.leverage = 30
        self.market_position = 0
        self.equity = 0
        self.last_price = 0
        self.equity_timeseries = []</span></pre>
<p><span class="koboSpan" id="kobo.378.1">Now, we prepare three (!) tick </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">data queues:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.380.1">
tick_feed_0 = queue.Queue()
tick_feed_1 = queue.Queue()
tick_feed_2 = queue.Queue()</span></pre>
<p><span class="koboSpan" id="kobo.381.1">Why three? </span><span class="koboSpan" id="kobo.381.2">This is one of the solutions to the thread synching problem explained in the </span><em class="italic"><span class="koboSpan" id="kobo.382.1">Multithreading – convenient but full of </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.383.1">surprises</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The first queue (</span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">tick_feed_0</span></strong><span class="koboSpan" id="kobo.387.1">) connects the market data receiver with the ticks aggregation component, which forms bars. </span><span class="koboSpan" id="kobo.387.2">This component is activated every time a new tick is in the first queue. </span><span class="koboSpan" id="kobo.387.3">After the component has finished, it puts the same tick into the second </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">queue (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">tick_feed_1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">).</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">tick_feed_1</span></strong><span class="koboSpan" id="kobo.392.1"> connects the ticks aggregator with the trading logic, and the trading logic is invoked only when there’s a new tick in </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">tick_feed_1</span></strong><span class="koboSpan" id="kobo.394.1">. </span><span class="koboSpan" id="kobo.394.2">But it may enter this queue only after the first component has finished working! </span><span class="koboSpan" id="kobo.394.3">So, trading logic cannot be invoked earlier than a new tick is processed. </span><span class="koboSpan" id="kobo.394.4">Then, similarly, the trading logic components put the same tick into the third </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">queue (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">tick_feed_2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">).</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">tick_feed_2</span></strong><span class="koboSpan" id="kobo.399.1"> connects the trading logic with the order execution component, and this component is invoked no earlier than there’s a new tick in </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">tick_feed_2</span></strong><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">So, using three </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.402.1">queues to connect components one to another ensures the correct sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">of operations.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.404.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.405.1">This method of synching threads would work only if the interval between ticks is greater than the round trip time for all threads triggered by it to finish working. </span><span class="koboSpan" id="kobo.405.2">This is valid for most data feeds as normally, we receive no more than 10 ticks per second, and the round trip processing time is typically around 0.0001 seconds. </span><span class="koboSpan" id="kobo.405.3">This approach won’t work with heavy load exchange market data received via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">ITCH</span></strong><span class="koboSpan" id="kobo.407.1"> protocol, which sometimes receives over 10,000 ticks per second. </span><span class="koboSpan" id="kobo.407.2">However, this is specific to institutional trading and we don’t consider solutions of this kind in </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Next, we must add a queue to process aggregated market data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">bar_feed</span></strong><span class="koboSpan" id="kobo.411.1">), a queue to store orders (</span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">orders_stream</span></strong><span class="koboSpan" id="kobo.413.1">), create an instance of the system metadata class, and specify the parameters required to connect to a data feed (in our example, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">LMAX</span></strong><span class="koboSpan" id="kobo.415.1"> as the source of </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">market data):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
bar_feed = queue.Queue()
orders_stream = queue.Queue()
System = tradingSystemMetadata()
url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"
subscription_msg = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]}]}'</span></pre>
<p><span class="koboSpan" id="kobo.418.1">Now, we can reuse the code that we developed in </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.419.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.420.1">, </span><em class="italic"><span class="koboSpan" id="kobo.421.1">Data Visualization in FX Trading with Python</span></em><span class="koboSpan" id="kobo.422.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.423.1">Plotting live tick </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.424.1">data</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1"> section:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
def LMAX_connect(url, subscription_msg):
    ws = create_connection(url)
    ws.send(subscription_msg)
    while True:
        tick = json.loads(ws.recv())</span></pre>
<p><span class="koboSpan" id="kobo.427.1">Now, we have to put the tick into the first tick queue. </span><span class="koboSpan" id="kobo.427.2">But before we do that, we have to check the consistency of the received market data. </span><span class="koboSpan" id="kobo.427.3">We discussed non-market prices in </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.428.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.429.1">, </span><em class="italic"><span class="koboSpan" id="kobo.430.1">Developing Trading Strategies – Why They Are Different</span></em><span class="koboSpan" id="kobo.431.1">, so let’s just quickly refresh it: a non-market price is </span><em class="italic"><span class="koboSpan" id="kobo.432.1">too far</span></em><span class="koboSpan" id="kobo.433.1"> from the market. </span><span class="koboSpan" id="kobo.433.2">Of course, sometimes, it’s difficult to judge whether it is </span><em class="italic"><span class="koboSpan" id="kobo.434.1">too far</span></em><span class="koboSpan" id="kobo.435.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.436.1">not so far</span></em><span class="koboSpan" id="kobo.437.1">, but in essence, we can at least filter out ticks </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.438.1">in which the difference between the bid and ask (also known as spread) is several times greater than normal. </span><span class="koboSpan" id="kobo.438.2">Events of this sort are quite infrequent, but I was lucky to capture one of these moments while plotting tick charts (see </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.439.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.440.1">, </span><em class="italic"><span class="koboSpan" id="kobo.441.1">Data Visualization in FX Trading with Python</span></em><span class="koboSpan" id="kobo.442.1">). </span><span class="koboSpan" id="kobo.442.2">The following figure illustrates such a </span><em class="italic"><span class="koboSpan" id="kobo.443.1">bad tick</span></em><span class="koboSpan" id="kobo.444.1"> in which the bid is way lower than it </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">should be:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<span class="koboSpan" id="kobo.446.1"><img alt="Figure 11.6 – Non-market price" src="image/B19145_11_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.447.1">Figure 11.6 – Non-market price</span></p>
<p><span class="koboSpan" id="kobo.448.1">To filter out at least bad ticks of this sort, let’s add a simple check: if the spread is greater than 10 pips, then skip </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">this tick:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.450.1">
        if 'instrument_id' in tick.keys():
            bid = float(tick['bids'][0]['price'])
            ask = float(tick['asks'][0]['price'])
            if ask - bid &lt; 0.001:
        tick_feed_0.put(tick)</span></pre>
<p><span class="koboSpan" id="kobo.451.1">Next, we need to </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.452.1">implement the ticks aggregator. </span><span class="koboSpan" id="kobo.452.2">In our example, let’s form 10-second bars so that we can test our app and check if everything works correctly faster (without waiting for 1 minute or 1-hour bars </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">to complete).</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">We will use only bid data to form bars for simplicity. </span><span class="koboSpan" id="kobo.454.2">Why is this possible? </span><span class="koboSpan" id="kobo.454.3">Because most of the time (except for the time around important news releases, bank settlement time, and the end/beginning of the week), the spread (the difference between the bid and ask) is more or less constant. </span><span class="koboSpan" id="kobo.454.4">So, if we want to emulate the real execution of orders, then we can use real bid and ask in the tick data stream, but for the trade logic, we can use bars built with only one price. </span><span class="koboSpan" id="kobo.454.5">Of course, for strategies of a certain kind, such as arbitrage, both bid and ask data are essential (and sometimes last trade along with the two), but now, we’re building a prototype that you will be able to customize the way you want when you are familiar with the approach </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">in general.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">For aggregating ticks into bars, we used almost the same code from </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.457.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.458.1">, </span><em class="italic"><span class="koboSpan" id="kobo.459.1">Data Visualization in FX Trading with Python</span></em><span class="koboSpan" id="kobo.460.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.461.1">Plotting live tick data</span></em><span class="koboSpan" id="kobo.462.1"> section, so not much commenting is </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">required here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
data_resolution = 10
def getBarRealtime(resolution):
    last_sample_ts = datetime.now()
    bar = {'Open': 0, 'High': 0, 'Low': 0, 'Close': 0}
    while True:
        tick = tick_feed_0.get(block=True)
        if 'instrument_id' in tick.keys():
            ts = datetime.strptime(tick['timestamp'], "%Y-%m-%dT%H:%M:%S.%fZ")
            bid = float(tick['bids'][0]['price'])
            delta = ts - last_sample_ts
            bar['High'] = max([bar['High'], bid])
            bar['Low'] = min([bar['Low'], bid])
            bar['Close'] = bid</span></pre>
<p><span class="koboSpan" id="kobo.465.1">We created a bar, received a tick, and updated the bar’s high, low, and close values. </span><span class="koboSpan" id="kobo.465.2">Now, as soon as </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.466.1">the time since the bar’s open is greater than or equal to 10 seconds, we start a </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">new bar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
        if delta.seconds &gt;= resolution - 1:
            if bar['Open'] != 0:
                bar_feed.put(bar)
                last_sample_ts = ts
                bar = {'Open': bid, 'High': bid, 'Low': bid, 'Close': bid}
        tick_feed_1.put(tick)</span></pre>
<p><span class="koboSpan" id="kobo.469.1">Note the last line of this function. </span><span class="koboSpan" id="kobo.469.2">It puts the same tick that’s received into </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">tick_feed_1</span></strong><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">This is done to trigger the next component, the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">trading logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
def tradeLogic():
    while True:
        tick = tick_feed_1.get()
        try:
            bar = bar_feed.get(block=False)
            print('Got bar: ', bar)</span></pre>
<p><span class="koboSpan" id="kobo.474.1">Now, it’s time to add some </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">trading logic.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.476.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.477.1">For testing purposes, we don’t care whether our test strategy is profitable or not – we only want to generate as many orders as possible to watch the </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">emulated execution.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">So, let’s implement the following </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">simple logic:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.481.1">If the bar closes up (</span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">close &gt; open</span></strong><span class="koboSpan" id="kobo.483.1">), </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">then sell</span></span></li>
<li><span class="koboSpan" id="kobo.485.1">If the bar closes down (</span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">close &lt; open</span></strong><span class="koboSpan" id="kobo.487.1">), </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">then buy</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.489.1">With this "</span><em class="italic"><span class="koboSpan" id="kobo.490.1">strategy"</span></em><span class="koboSpan" id="kobo.491.1">, we may </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.492.1">expect many orders to be generated quickly, so we will be able to test our app without waiting for </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">too long:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.494.1">
            ####################################
            #      trade logic starts here      #
            ####################################
            open = bar['Open']
            close = bar['Close']
            if close &gt; open and System.market_position &gt;= 0:</span></pre>
<p><span class="koboSpan" id="kobo.495.1">Here, we are checking that the bar’s closing price is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Open</span></strong><span class="koboSpan" id="kobo.497.1"> and also that the current consolidated market position is positive. </span><span class="koboSpan" id="kobo.497.2">We’re doing this because we don’t want to open multiple positions in the same direction. </span><span class="koboSpan" id="kobo.497.3">In other words, if we are already long in the market, we only wait for a short position to open, and </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">vice versa:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.499.1">
                order = {}
                order['Type'] = 'Market'
                order['Price'] = close
                order['Side'] = 'Sell'</span></pre>
<p><span class="koboSpan" id="kobo.500.1">The following </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">if...else</span></strong><span class="koboSpan" id="kobo.502.1"> statement checks whether we are opening the position for the first time. </span><span class="koboSpan" id="kobo.502.2">If we are, then we don’t have any current market position at the time of order generation, so in our example, the trading size is 10,000. </span><span class="koboSpan" id="kobo.502.3">But if there is already an open position and we want to open a new position in the opposite direction, then </span><em class="italic"><span class="koboSpan" id="kobo.503.1">we should first close the existing position</span></em><span class="koboSpan" id="kobo.504.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.505.1">then open the new one</span></em><span class="koboSpan" id="kobo.506.1">, which effectively requires twice the trading size. </span><span class="koboSpan" id="kobo.506.2">We have to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">10000</span></strong><span class="koboSpan" id="kobo.508.1"> to close and </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">10000</span></strong><span class="koboSpan" id="kobo.510.1"> to open a new position, which means a trading size of 2 * 10,000 = </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">20,000:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
                if System.market_position == 0:
                    order['Size'] = 10000
                else:
                    order['Size'] = 20000</span></pre>
<p><span class="koboSpan" id="kobo.513.1">Finally, we must </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.514.1">put the order into the </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">order queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
                orders_stream.put(order)
                print(order) # added for testing</span></pre>
<p><span class="koboSpan" id="kobo.517.1">Now, we must do exactly the opposite for the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">buy order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.519.1">
            if close &lt; open and System.market_position &lt;= 0:
                order = {}
                order['Type'] = 'Market'
                order['Price'] = close
                order['Side'] = 'Buy'
                if System.market_position == 0:
                    order['Size'] = 10000
                else:
                    order['Size'] = 20000
                orders_stream.put(order)
                print(order)
            ####################################
            #      trade logic ends here      #
            ####################################
        except:
            pass
        tick_feed_2.put(tick)</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.520.1">Why do we use 10,000 base currency as the trading size?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.521.1">If we trade EURUSD, a currency pair quoted with 4 or 5 digits, then buying or selling 10,000 euro (see </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.522.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.523.1">, </span><em class="italic"><span class="koboSpan" id="kobo.524.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.525.1">, the </span><em class="italic"><span class="koboSpan" id="kobo.526.1">Naming conventions</span></em><span class="koboSpan" id="kobo.527.1"> section) would mean that 1 pip costs $1. </span><span class="koboSpan" id="kobo.527.2">Therefore, we can interpret the results of our tests both as in money and in pips. </span><span class="koboSpan" id="kobo.527.3">Since the FX market is highly leveraged (see the same in the </span><em class="italic"><span class="koboSpan" id="kobo.528.1">Trade mechanics – again some terminology</span></em><span class="koboSpan" id="kobo.529.1"> section in </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.530.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.531.1">, </span><em class="italic"><span class="koboSpan" id="kobo.532.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.533.1">), it’s more convenient to calculate all PnL in pips and then scale it </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">using leverage.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">Note that </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.536.1">this function uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">try...except</span></strong><span class="koboSpan" id="kobo.538.1"> statement. </span><span class="koboSpan" id="kobo.538.2">The reason is that we use two queues: </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">tick_feed_1</span></strong><span class="koboSpan" id="kobo.540.1"> to receive ticks and </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">bar_feed</span></strong><span class="koboSpan" id="kobo.542.1"> to receive actual bars. </span><span class="koboSpan" id="kobo.542.2">However, ticks are only used in this function to trigger its execution (see the detailed explanation at the very beginning of this section), while bars are used to make actual trading decisions. </span><span class="koboSpan" id="kobo.542.3">The problem is that bars normally arrive far less frequently than ticks, so we can’t wait until there’s a bar in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">bar_feed</span></strong><span class="koboSpan" id="kobo.544.1"> queue; otherwise, the normal execution of our app would be interrupted. </span><span class="koboSpan" id="kobo.544.2">That’s why we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">block = False</span></strong><span class="koboSpan" id="kobo.546.1"> attribute when reading from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">bar_feed</span></strong><span class="koboSpan" id="kobo.548.1"> queue. </span><span class="koboSpan" id="kobo.548.2">However, if there’s a new tick in </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">tick_feed_1</span></strong><span class="koboSpan" id="kobo.550.1">, but there’s no bar in </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">bar_feed</span></strong><span class="koboSpan" id="kobo.552.1">, then the attempt to read from there would raise an exception. </span><span class="koboSpan" id="kobo.552.2">Therefore, we catch this exception and – in our current implementation – just do nothing, waiting for a new bar to arrive in </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">The final component of our trading app is order execution. </span><span class="koboSpan" id="kobo.554.2">We invoke this function by a tick received in </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">tick_feed_2</span></strong><span class="koboSpan" id="kobo.556.1">, where it’s put </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">tradeLogic()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.560.1">
def processOrders():
    while True:
        tick = tick_feed_2.get(block = True)
        current_price = float(tick['bids'][0]['price'])</span></pre>
<p><span class="koboSpan" id="kobo.561.1">With every received tick, we update the equity value of the trading system. </span><span class="koboSpan" id="kobo.561.2">Remember that </span><em class="italic"><span class="koboSpan" id="kobo.562.1">equity</span></em><span class="koboSpan" id="kobo.563.1"> in traders’ slang means the sum of all PnL values calculated on each tick or bar. </span><span class="koboSpan" id="kobo.563.2">If we have a long position and the current price is greater than the previous price, then the equity value increases on this tick/bar. </span><span class="koboSpan" id="kobo.563.3">The opposite is also true: if we have a short position and the current price is less than the previous price, then the equity value also increases on </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">this tick/bar.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">I believe you’ve got it: if we’re long and the price decreases or if we’re short and the price increases, then the equity decreases on this tick or bar. </span><span class="koboSpan" id="kobo.565.2">To calculate the actual equity value </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.566.1">on the current tick, we multiply the difference in price between the current and the previous ticks by the market </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">position value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
        System.equity += (current_price - System.last_price) * System.market_position
        System.equity_timeseries.append(System.equity)
        System.last_price = current_price
        print(tick['timestamp'], current_price, System.equity) # for testing purposes</span></pre>
<p><span class="koboSpan" id="kobo.569.1">Now, we start scanning the order queue and executing orders as they appear there. </span><span class="koboSpan" id="kobo.569.2">Note that we again use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">block = False</span></strong><span class="koboSpan" id="kobo.571.1"> attribute, so we never wait for an order in the order queue: if there’s no order by the time a new tick is received, we just go ahead and proceed with the </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">main loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.573.1">
        while True:
            try:
                order = orders_stream.get(block = False)</span></pre>
<p><span class="koboSpan" id="kobo.574.1">After we’ve received an order, we should do the risk management check: whether we have sufficient funds to execute this order. </span><span class="koboSpan" id="kobo.574.2">To calculate the available funds, we should add the current equity (positive or negative) to the initial capital and subtract the margin required for the currently open market position, which is the value of this market position divided by </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">the leverage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
                available_funds = (System.initial_capital + System.equity) * System.leverage - System.market_position / System.leverage</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.577.1">How to calculate available funds</span></p>
<p class="callout"><span class="koboSpan" id="kobo.578.1">The calculation of available funds that we are using in our code is not 100% correct. </span><span class="koboSpan" id="kobo.578.2">The problem is that it is possible to have a huge position in the market with some positive running PnL. </span><span class="koboSpan" id="kobo.578.3">In this case, our formula would say we have sufficient funds, but in reality, until this huge position is closed, we may not have enough money in the trading account. </span><span class="koboSpan" id="kobo.578.4">So, to be perfectly precise with this calculation, we should have introduced yet another variable to the system metadata that would account only for realized PnL (calculated by closed positions). </span><span class="koboSpan" id="kobo.578.5">However, we are not going to do this now, again for simplicity and </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">transparency’s sake.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Now, if the order </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.581.1">size is less than the available funds in the trading account, we can execute the order. </span><span class="koboSpan" id="kobo.581.2">A bit later, we will write a separate function that emulates the order execution. </span><span class="koboSpan" id="kobo.581.3">In production, this function can be replaced by an actual call to the </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">broker’s API:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
                if order['Size'] &lt; available_funds:
                    emulateBrokerExecution(tick, order)</span></pre>
<p><span class="koboSpan" id="kobo.584.1">After attempting to execute the order, its status is changed either to </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">'Executed'</span></strong><span class="koboSpan" id="kobo.586.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">'Rejected'</span></strong><span class="koboSpan" id="kobo.588.1"> (or any other status returned by your broker), so let’s decide what to do with it. </span><span class="koboSpan" id="kobo.588.2">Of course, if the order was successfully executed, we only update the strategy metadata (and print the result for </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">testing purposes):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
                if order['Status'] == 'Executed':
                    System.last_price = order['Executed Price']
                    print('Executed at ', str(System.last_price), 'current price = ', str(current_price), 'order price = ', str(order['Executed Price']))
                    if order['Side'] == 'Buy':
                        System.market_position = System.market_position + order['Size']
                    if order['Side'] == 'Sell':
                        System.market_position = System.market_position – order['Size']</span></pre>
<p><span class="koboSpan" id="kobo.591.1">If the order was rejected, we return it to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">order queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
                elif order['Status'] == 'Rejected':
                    orders_stream.put(order)</span></pre>
<p><span class="koboSpan" id="kobo.594.1">Again, let me reiterate that, in reality, you may need more complex order handling, but it will depend </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.595.1">on both the type of strategy you’re going to run and the types of order statuses provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">your broker.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">Finally, we will just add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">except</span></strong><span class="koboSpan" id="kobo.599.1"> clause so that nothing happens if there’s no order in the </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">order queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
            except:
                order = 'No order'
                break</span></pre>
<p><span class="koboSpan" id="kobo.602.1">We’re almost there! </span><span class="koboSpan" id="kobo.602.2">All we need to add now is the function that emulates the order execution at the broker. </span><span class="koboSpan" id="kobo.602.3">For the first version of our emulator, we will implement only the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">market orders:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
def emulateBrokerExecution(tick, order):
    if order['Type'] == 'Market':
        if order['Side'] == 'Buy':</span></pre>
<p><span class="koboSpan" id="kobo.605.1">It’s time for the final preflight check: making sure the market has sufficient liquidity before sending </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">the order!</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.607.1">
            current_liquidity = float(tick['asks'][0]['quantity'])</span></pre>
<p><span class="koboSpan" id="kobo.608.1">Don’t confuse bids and asks! </span><span class="koboSpan" id="kobo.608.2">If we buy, we check the liquidity at the offer (ask) and execute at the ask price, while if we sell, we </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">use bids:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
            price = float(tick['asks'][0]['price'])
            if order['Size'] &lt;= current_liquidity:
                order['Executed Price'] = price
                order['Status'] = 'Executed'
            else:
                order['Status'] = 'Rejected'
        if order['Side'] == 'Sell':
            current_liquidity = float(tick['bids'][0]['quantity'])
            if order['Size'] &lt;= current_liquidity:
                order['Executed Price'] = price
                order['Status'] = 'Executed'
            else:
                order['Status'] = 'Rejected'</span></pre>
<p><span class="koboSpan" id="kobo.611.1">Now, let’s review </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.612.1">the components of the trading application we have added </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">so far:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.614.1">Strategy metadata object (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">class tradingSystemMetadata</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.617.1">Queues for price data and orders (</span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">tick_feed_0</span></strong><span class="koboSpan" id="kobo.619.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">tick_feed_1</span></strong><span class="koboSpan" id="kobo.621.1">,  </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">tick_feed_2</span></strong><span class="koboSpan" id="kobo.623.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">bar_feed</span></strong><span class="koboSpan" id="kobo.625.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">orders_stream</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.629.1">A function that connects to the data source (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">LMAX_connect(url, subscription_msg)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.632.1">A function that forms bars from </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">ticks (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">getBarRealtime()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.636.1">A function that makes trading </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">decisions (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">tradeLogic()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.640.1">A function that processes </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">orders (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">processOrders()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.644.1">A function that emulates order execution at the broker (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">emulateBrokerExecution(tick, order)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.647.1">All we have to add to the very end of our code is a block that initializes and starts all </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">four threads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
data_receiver_thread = threading.Thread(target = LMAX_connect, args = (url, subscription_msg))
incoming_price_thread = threading.Thread(target = getBarRealtime, args = (data_resolution,))
trading_thread = threading.Thread(target = tradeLogic)
ordering_thread = threading.Thread(target = processOrders)
data_receiver_thread.start()
incoming_price_thread.start()
trading_thread.start()</span></pre>
<p><span class="koboSpan" id="kobo.650.1">We have just developed our first trading app! </span><span class="koboSpan" id="kobo.650.2">It’s time to run it and check if it’s doing what we expect. </span><span class="koboSpan" id="kobo.650.3">I will run it and wait until the second order is executed (because I want to make sure </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.651.1">that I submit correct orders both in case the strategy has an open position in the market and in case there’s no open position). </span><span class="koboSpan" id="kobo.651.2">If you repeated all these steps correctly, you should see an output like </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
2022-12-12T12:03:20.000Z 1.05658 0.0
... </span><span class="koboSpan" id="kobo.653.2">(7 ticks omitted from output to save space)
2022-12-12T12:03:28.000Z 1.05664 0.0</span></pre>
<p><span class="koboSpan" id="kobo.654.1">We started at </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">12:03:20</span></strong><span class="koboSpan" id="kobo.656.1">, so we received nine ticks (remember, LMAX doesn’t send actual ticks, but 1-second snapshots of market data). </span><span class="koboSpan" id="kobo.656.2">At the 10th second, we form </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">a bar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.658.1">
Got bar:  {'Open': 1.05658, 'High': 1.05668, 'Low': 1.05658, 'Close': 1.05666}</span></pre>
<p><span class="koboSpan" id="kobo.659.1">The bar’s close is greater than the bar’s open, so according to our test strategy logic, it is a signal to sell – and indeed, there’s an order that immediately follows </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">the bar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
{'Type': 'Market', 'Price': 1.05666, 'Side': 'Sell', 'Size': 10000}</span></pre>
<p><span class="koboSpan" id="kobo.662.1">Note that the order size is </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">10000</span></strong><span class="koboSpan" id="kobo.664.1"> because we opened the position for the very first time and we don’t have open positions in the market yet. </span><span class="koboSpan" id="kobo.664.2">We check the 10th tick to make sure that its price equals the closing price of the bar and the </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">order price:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.666.1">
2022-12-12T12:03:29.000Z 1.05666 0.0</span></pre>
<p><span class="koboSpan" id="kobo.667.1">Now, we can see the </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">execution report:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
Executed at  1.05666 current price =  1.05666 order price =  1.05666</span></pre>
<p><span class="koboSpan" id="kobo.670.1">So far, so good. </span><span class="koboSpan" id="kobo.670.2">Let’s wait for the next bar </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">to form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.672.1">
2022-12-12T12:03:30.000Z 1.05663 0.2999999999997449
... </span><span class="koboSpan" id="kobo.672.2">(7 ticks omitted from output to save space)
Got bar:  {'Open': 1.05666, 'High': 1.05666, 'Low': 1.05663, 'Close': 1.05665}</span></pre>
<p><span class="koboSpan" id="kobo.673.1">We’re lucky: the very </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.674.1">next bar closed in the opposite direction (close is less than open), so it’s time to generate a </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">buy order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.676.1">
{'Type': 'Market', 'Price': 1.05665, 'Side': 'Buy', 'Size': 20000}</span></pre>
<p><span class="koboSpan" id="kobo.677.1">Note that the order size this time is </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">20000</span></strong><span class="koboSpan" id="kobo.679.1">: we need to close the currently open position of </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">10000</span></strong><span class="koboSpan" id="kobo.681.1"> and then open a new one with the remaining </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">10000</span></strong><span class="koboSpan" id="kobo.683.1">. </span><span class="koboSpan" id="kobo.683.2">Let’s check the tick price to make sure that the bar’s closing price and the order price </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">are correct:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.685.1">
2022-12-12T12:03:38.000Z 1.05665 0.09999999999843467</span></pre>
<p><span class="koboSpan" id="kobo.686.1">Great, everything looks good. </span><span class="koboSpan" id="kobo.686.2">Now, let’s proceed to </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">order execution...</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.688.1">
Executed at  1.05672 current price =  1.05665 order price =  1.05672</span></pre>
<p><span class="koboSpan" id="kobo.689.1">Stop. </span><span class="koboSpan" id="kobo.689.2">What’s that? </span><span class="koboSpan" id="kobo.689.3">The last tick’s price was </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">1.05665</span></strong><span class="koboSpan" id="kobo.691.1">, but the order is executed at </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">1.05672</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">! </span><span class="koboSpan" id="kobo.693.2">Why?</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">This happens because we form bars using only bid prices and execute orders at actual market prices – bid for sell orders and ask for buy orders. </span><span class="koboSpan" id="kobo.694.2">The first order was a sell, so we used the bid price and all prices (bar, tick, order, and execution) coincided. </span><span class="koboSpan" id="kobo.694.3">But the second order was a buy, but we still used only the bid price to form a bar – that’s why we had the execution price greater than the bar’s </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">closing price.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.696.1">The importance of market spread</span></p>
<p class="callout"><span class="koboSpan" id="kobo.697.1">This issue perfectly illustrates the importance of taking spread (the difference between the bid and ask prices) into consideration when running tests. </span><span class="koboSpan" id="kobo.697.2">So many developers forget about it and run their testing using only bid prices – for simplicity, you know. </span><span class="koboSpan" id="kobo.697.3">These tests are not adequate for the real market, and quite frequently generate trade logic that is profitable only when you can buy and sell at the same price, effectively assuming the spread to be zero at all times. </span><span class="koboSpan" id="kobo.697.4">Now, you know how to avoid this trap and make sure your tests are </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">always realistic.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">Before we </span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.700.1">move on, let’s quickly review our code and see whether it meets the requirements outlined in </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.701.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.702.1">, </span><em class="italic"><span class="koboSpan" id="kobo.703.1">Developing Trading Strategies – Why They </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.704.1">Are Different</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.706.1">It filters the incoming tick data feed and excludes </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">non-market prices</span></span></li>
<li><span class="koboSpan" id="kobo.708.1">It is event-driven – it generates and executes orders as soon as the trade logic confirms </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">a trade</span></span></li>
<li><span class="koboSpan" id="kobo.710.1">It does some basic risk management checks – position size, leverage, and </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">available funds</span></span></li>
<li><span class="koboSpan" id="kobo.712.1">It is capable of emulating bad order execution and handling </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">these situations</span></span></li>
<li><span class="koboSpan" id="kobo.714.1">And probably the main benefit: this code will never – never! </span><span class="koboSpan" id="kobo.714.2">– peek ahead, neither in testing nor in production (see </span><a href="B19145_04.xhtml#_idTextAnchor073"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.715.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.716.1">, </span><em class="italic"><span class="koboSpan" id="kobo.717.1">Trading Application – What’s Inside?</span></em><span class="koboSpan" id="kobo.718.1">, the </span><em class="italic"><span class="koboSpan" id="kobo.719.1">Trading logic – this is where a small mistake may cost a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.720.1">fortune</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.721.1"> section)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.722.1">So, we have developed a robust application suitable for serious production! </span><span class="koboSpan" id="kobo.722.2">Of course, it can be improved further, but its core will remain almost unchanged. </span><span class="koboSpan" id="kobo.722.3">However, we don’t have a tested strategy to run. </span><span class="koboSpan" id="kobo.722.4">How can we develop such </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">a strategy?</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">This is when we can use the concept of backtesting, which we mentioned earlier, almost at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">this book.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.726.1">Backtesting – speeding up the research</span></h1>
<p><span class="koboSpan" id="kobo.727.1">The process </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.728.1">of developing a trading strategy (I mean the trading logic, not the application) is an </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">infinite loop:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.730.1">Suggest </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">a hypothesis.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.732.1">Code it.</span></span></li>
<li><span class="koboSpan" id="kobo.733.1">Run </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">a test.</span></span></li>
<li><span class="koboSpan" id="kobo.735.1">If the result is not satisfactory, tweak the parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">and repeat.</span></span></li>
<li><span class="koboSpan" id="kobo.737.1">If nothing helps, look for an </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">alternative hypothesis.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.739.1">The question is: what kind of application shall we use for testing in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.740.1">step 3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">?</span></span></p>
<p><span class="koboSpan" id="kobo.742.1">Of course, we could use </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.743.1">our existing trading app, draft some strategy logic, and then run it in test mode, as we’ve just done, collecting orders and analyzing the equity time series. </span><span class="koboSpan" id="kobo.743.2">But then a single test may take days, weeks, and even months if we want to test the strategy under different market conditions. </span><span class="koboSpan" id="kobo.743.3">Do you think it’s a bit too long? </span><span class="koboSpan" id="kobo.743.4">I agree. </span><span class="koboSpan" id="kobo.743.5">That’s why, for research and development purposes, we </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">use backtesting.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">We discussed backtesting in </span><a href="B19145_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.746.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.747.1">, </span><em class="italic"><span class="koboSpan" id="kobo.748.1">Using Python for Trading Strategies</span></em><span class="koboSpan" id="kobo.749.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.750.1">Paper trading, and backtesting – an essential part of systemic trader’s risk management</span></em><span class="koboSpan" id="kobo.751.1"> section. </span><span class="koboSpan" id="kobo.751.2">In essence, instead of emulating the execution of orders using live data streams, we emulate the data stream itself using pre-saved historical market data. </span><span class="koboSpan" id="kobo.751.3">In this case, we can dramatically speed up the testing because computers can process dozens of thousands of ticks or bars per second, compressing months of live testing into minutes or seconds of backtesting. </span><span class="koboSpan" id="kobo.751.4">Of course, due to its nature, backtesting cannot guarantee the future performance of a strategy, just because it tests using past data. </span><span class="koboSpan" id="kobo.751.5">But regardless, it helps us understand the strategy’s behavior under various market conditions. </span><span class="koboSpan" id="kobo.751.6">Generally speaking, if a backtest shows that the emulated equity was mostly growing in the past, then we may suppose that it continues growing in the future, and vice versa: if we saw that the emulated equity was only decreasing over time, or oscillating around zero at best, then we should be very cautious with such a strategy as it’s hard to imagine why it would suddenly start making money when put </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.753.1">I hope you got the idea: we are going to run our code using saved data, not live, so we can process 1,000 or 10,000, or even more seconds of historical data in </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">1 second.</span></span></p>
<p><span class="koboSpan" id="kobo.755.1">Now, I believe you will appreciate the approach we followed when developing our code: if you have pre-saved tick historical data, then </span><em class="italic"><span class="koboSpan" id="kobo.756.1">all you need to do is modify the only function</span></em><span class="koboSpan" id="kobo.757.1"> – the one that receives ticks from the data provider – and have it receive data from a </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">local file.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.759.1">That’s it.</span></span></p>
<p><span class="koboSpan" id="kobo.760.1">Isn’t it impressive? </span><span class="koboSpan" id="kobo.760.2">Yes, you can use the same code for both research and production, thus reducing the probability of making an error to </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">almost zero.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">However, you can’t always get hold of historical tick data. </span><span class="koboSpan" id="kobo.762.2">Moreover, for strategies that use bars with a higher time frame (such as 1 hour, 4 hours, 1 day, 1 week, and so on), it would be a waste of time waiting until our application forms each bar from ticks. </span><span class="koboSpan" id="kobo.762.3">So, we may want to make </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.763.1">the following modifications to </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">our code:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.765.1">It should now be able to read data from a local file instead of receiving it from a </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">data vendor</span></span></li>
<li><span class="koboSpan" id="kobo.767.1">It should be able to process already compressed data (bars) without receiving tick data </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">at all</span></span></li>
<li><span class="koboSpan" id="kobo.769.1">It should be able to emulate order execution, which may happen within the duration of a single bar (for example, if the strategy bases its logic on 1-hour bars, then we should be able to emulate order execution between hh:00 and hh:59, where hh stands for the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">hours’ value).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.771.1">Looking at the architecture of our existing code, it seems like quite a straightforward task. </span><span class="koboSpan" id="kobo.771.2">However, there is </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">one caveat.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">Do you remember how we used tick data in the existing code? </span><span class="koboSpan" id="kobo.773.2">Yes, we aggregated it into bars, but besides that, ticks were served as a system clock that synchronized the components of the entire application. </span><span class="koboSpan" id="kobo.773.3">How do we synchronize them in case we don’t use tick data </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">at all?</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">Here, we can use another method of controlling the execution of threads – </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">using events.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.777.1">Syncing threads using events</span></h2>
<p><span class="koboSpan" id="kobo.778.1">Let’s quickly </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.779.1">jump back to the code that we drafted in the </span><em class="italic"><span class="koboSpan" id="kobo.780.1">Multithreading – convenient but full of surprises</span></em><span class="koboSpan" id="kobo.781.1"> section earlier in this chapter. </span><span class="koboSpan" id="kobo.781.2">The problem with that code was that each thread was running </span><em class="italic"><span class="koboSpan" id="kobo.782.1">when possible</span></em><span class="koboSpan" id="kobo.783.1">, thus producing output at random to a certain degree. </span><span class="koboSpan" id="kobo.783.2">And we want all three threads to work one by one – </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">t1</span></strong><span class="koboSpan" id="kobo.785.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">t2</span></strong><span class="koboSpan" id="kobo.787.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">t3</span></strong><span class="koboSpan" id="kobo.789.1">, and then again </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">t1</span></strong><span class="koboSpan" id="kobo.791.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.793.1">The threading module in Python provides several very efficient methods to solve the problem of controlling threads. </span><span class="koboSpan" id="kobo.793.2">One of them is using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">Event()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.795.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.796.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">threading.Event()</span></strong><span class="koboSpan" id="kobo.798.1"> object is placed inside the thread’s code and it works like a traffic light. </span><span class="koboSpan" id="kobo.798.2">It has two possible states: set or cleared. </span><span class="koboSpan" id="kobo.798.3">When the event is set, the thread works as normal. </span><span class="koboSpan" id="kobo.798.4">When the event is cleared, the </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">thread stops.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">Besides just clearing and setting the events, it is possible to instruct the thread to </span><em class="italic"><span class="koboSpan" id="kobo.801.1">wait</span></em><span class="koboSpan" id="kobo.802.1"> until the event is set. </span><span class="koboSpan" id="kobo.802.2">In this case, the thread waits for the event and as soon as it’s set again, it </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">resumes working.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">If we want threads </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.805.1">to run in a particular order, then we should stick to the </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">following guidelines:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.807.1">We need as many events as there </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">are threads</span></span></li>
<li><span class="koboSpan" id="kobo.809.1">An event controlling a specific thread should be cleared </span><em class="italic"><span class="koboSpan" id="kobo.810.1">inside</span></em><span class="koboSpan" id="kobo.811.1"> this thread but set </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.812.1">outside</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.813.1"> it</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.814.1">Now, let’s make some modifications to </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.816.1">First, we need </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">three events:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.818.1">
f1, f2, f3 = threading.Event(), threading.Event(), threading.Event()</span></pre>
<p><span class="koboSpan" id="kobo.819.1">In our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">f1</span></strong><span class="koboSpan" id="kobo.821.1"> will control the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">t1</span></strong><span class="koboSpan" id="kobo.823.1"> thread, </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">f2</span></strong><span class="koboSpan" id="kobo.825.1"> will control </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">t2</span></strong><span class="koboSpan" id="kobo.827.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">f3</span></strong><span class="koboSpan" id="kobo.829.1"> will </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">control </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">t3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.833.1">Next, to the very end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">t1()</span></strong><span class="koboSpan" id="kobo.835.1"> function, we do the </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">following actions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.837.1">We clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">f1</span></strong><span class="koboSpan" id="kobo.839.1"> event (which controls the </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">first thread)</span></span></li>
<li><span class="koboSpan" id="kobo.841.1">We set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">f2</span></strong><span class="koboSpan" id="kobo.843.1"> event (which gives the green light to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">t2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.845.1"> thread)</span></span></li>
<li><span class="koboSpan" id="kobo.846.1">We set thread </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">t1</span></strong><span class="koboSpan" id="kobo.848.1"> to wait for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">f1</span></strong><span class="koboSpan" id="kobo.850.1"> event to be </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">set again</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.852.1">The modified code will look </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">like follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.854.1">
def t1():
    while True:
        print('Receive data')
        time.sleep(1)
        f1.clear()
        f2.set()
        f1.wait()</span></pre>
<p><span class="koboSpan" id="kobo.855.1">We modify </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.856.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">t2()</span></strong><span class="koboSpan" id="kobo.858.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">t3()</span></strong><span class="koboSpan" id="kobo.860.1"> functions in the same way (so that each thread controls its next neighbor) and run all </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">three threads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.862.1">
def t2():
    while True:
        print('Trading logic')
        time.sleep(1)
        f2.clear()
        f3.set()
        f2.wait()
def t3():
    while True:
        print('Processing orders')
        time.sleep(1)
        f3.clear()
        f1.set()
        f3.wait()
thread1 = threading.Thread(target=t1)
thread2 = threading.Thread(target=t2)
thread3 = threading.Thread(target=t3)
thread1.start()
thread2.start()
thread3.start()</span></pre>
<p><span class="koboSpan" id="kobo.863.1">Now, we can </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.864.1">enjoy the output in the perfectly </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">correct order:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.866.1">
Trading logic
Processing orders
Receive data
Trading logic
Processing orders
Receive data
Trading logic
Processing orders
Receive data</span></pre>
<p><span class="koboSpan" id="kobo.867.1">...and </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">so on.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.869.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.870.1">It is possible that for the first two execution loops, the output may still go in an incorrect order: this may happen until two events are cleared and awaited, and only one event </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">is set.</span></span></p>
<p><span class="koboSpan" id="kobo.872.1">Now that we’re familiar with </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">threading.Event()</span></strong><span class="koboSpan" id="kobo.874.1"> objects, it’s time to modify our trading application for backtesting purposes. </span><span class="koboSpan" id="kobo.874.2">For clarity and ease of use, I will reproduce its entire code here and point to the exact places where we made </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">any modifications.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.876.1">Backtesting platform with a historical data feed</span></h2>
<p><span class="koboSpan" id="kobo.877.1">As </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.878.1">always, we start with </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">several imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.880.1">
import csv
import threading
import queue
import time
from datetime import datetime</span></pre>
<p><span class="koboSpan" id="kobo.881.1">Then, we reuse </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.882.1">the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">tradingSystemMetadata</span></strong><span class="koboSpan" id="kobo.884.1"> class and only add three events to the control threads. </span><span class="koboSpan" id="kobo.884.2">We name them </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">F1</span></strong><span class="koboSpan" id="kobo.886.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">F2</span></strong><span class="koboSpan" id="kobo.888.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">F3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.890.1"> (flags):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
class tradingSystemMetadata:
    def __init__(self):
        self.initial_capital = 10000
        self.leverage = 30
        self.market_position = 0
        self.equity = 0
        self.last_price = 0
        self.equity_timeseries = []
        self.F1, self.F2, self.F3 = threading.Event(), threading.Event(), threading.Event()</span></pre>
<p><span class="koboSpan" id="kobo.892.1">Next, we need data and order queues. </span><span class="koboSpan" id="kobo.892.2">Since we no longer use tick data to sync threads, there’s no need to have multiple tick data queues – we only need one queue for bars and another one </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">for orders:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
bar_feed = queue.Queue()
orders_stream = queue.Queue()</span></pre>
<p><span class="koboSpan" id="kobo.895.1">Next, we must create an instance of the system metadata object and read the historical data from the file into </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">all_data</span></strong><span class="koboSpan" id="kobo.897.1">. </span><span class="koboSpan" id="kobo.897.2">We must also start the stopwatch (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">time.perf_counter()</span></strong><span class="koboSpan" id="kobo.899.1"> method) to keep track of time spent on various operations – just out </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">of curiosity.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">Note that we read the data using </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">csv.DictReader()</span></strong><span class="koboSpan" id="kobo.903.1"> so that we receive each bar as a dictionary – this ensures maximum compatibility with the production code that we developed earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">this chapter:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.905.1">
System = tradingSystemMetadata()
start_time = time.perf_counter()
f = open("&lt;your_file_path&gt;/LMAX EUR_USD 1 Minute.txt")
csvFile = csv.DictReader(f)
all_data = list(csvFile)
end_time = time.perf_counter()
print(f'Data read in {round(end_time - start_time, 0)} second(s).')</span></pre>
<p><span class="koboSpan" id="kobo.906.1">Next, we need </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.907.1">a modified function that takes bars from the read data one by one, converts necessary fields from </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">str</span></strong><span class="koboSpan" id="kobo.909.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">float</span></strong><span class="koboSpan" id="kobo.911.1">, and puts the bar into the queue. </span><span class="koboSpan" id="kobo.911.2">We must also break the execution of this loop after the first 10 bars for </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">debugging purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.913.1">
def getBar():
    counter = 0
    for bar in all_data:
        bar['Open'] = float(bar['Open'])
        bar['High'] = float(bar['High'])
        bar['Low'] = float(bar['Low'])
        bar['Close'] = float(bar['Close'])
        bar_feed.put(bar)
        counter += 1
        if counter == 10:
            break
        System.F1.clear()
        System.F2.set()
        System.F1.wait()
    print('Finished reading data')</span></pre>
<p><span class="koboSpan" id="kobo.914.1">Note the three flags (</span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">System.F1</span></strong><span class="koboSpan" id="kobo.916.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.917.1">System.F2</span></strong><span class="koboSpan" id="kobo.918.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">System.F3</span></strong><span class="koboSpan" id="kobo.920.1">) at the end of the function: they control the execution of threads and make sure that first, we read a bar, then we generate an order and, finally, we execute – or, rather, emulate – the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">this order.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">Also, note that </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.923.1">we do not check data consistency and do not exclude any data points: when we work with saved historical data, we assume this data is </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">already clean.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">Next goes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">tradeLogic()</span></strong><span class="koboSpan" id="kobo.927.1"> function. </span><span class="koboSpan" id="kobo.927.2">The best news here is that its main logical part remains completely unchanged – no modification is required between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">trade logic starts here</span></strong><span class="koboSpan" id="kobo.929.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">trade logic ends here</span></strong><span class="koboSpan" id="kobo.931.1"> comments in the original code! </span><span class="koboSpan" id="kobo.931.2">We only modify this function at its beginning and at </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">its end.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">At its beginning, we must add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">try...except</span></strong><span class="koboSpan" id="kobo.935.1"> statement that will terminate the respective thread when all the data has been processed. </span><span class="koboSpan" id="kobo.935.2">To do that, we must set the timeout attribute of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">get()</span></strong><span class="koboSpan" id="kobo.937.1"> method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">1</span></strong><span class="koboSpan" id="kobo.939.1">. </span><span class="koboSpan" id="kobo.939.2">This means that </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">get()</span></strong><span class="koboSpan" id="kobo.941.1"> will wait for </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">1</span></strong><span class="koboSpan" id="kobo.943.1"> second for a new bar to appear in the queue, and if no bar is there after 1 second, then an exception is generated. </span><span class="koboSpan" id="kobo.943.2">On exception, we just break the loop and effectively terminate </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">the thread:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.945.1">
def tradeLogic():
    while True:
        try:
            bar = bar_feed.get(block=True, timeout=1)
        except:
            break
        ####################################
        #     trade logic starts here      #
        ####################################
        ####################################
        #       trade logic ends here      #
        ####################################
        bar_feed.put(bar)
        System.F2.clear()
        System.F3.set()
        System.F2.wait()</span></pre>
<p><span class="koboSpan" id="kobo.946.1">We omitted the entire trade logic because it is indeed identical to what we used in our first version of the </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">trading app.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">Note that at </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.949.1">end of the function code, we return the bar into the queue: its data will be required by the orders processing component. </span><span class="koboSpan" id="kobo.949.2">And as in the case of the previous function, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">F3</span></strong><span class="koboSpan" id="kobo.951.1"> flag, giving the green light to the next operation (orders processing), clear </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">F2</span></strong><span class="koboSpan" id="kobo.953.1">, and stop the trade logic thread until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">F2</span></strong><span class="koboSpan" id="kobo.955.1"> flag </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">is set.</span></span></p>
<p><span class="koboSpan" id="kobo.957.1">Next, we must rewrite the order execution emulator quite substantially: the difference between the production and backtesting versions is that while backtesting, we only work with compressed data, so checking order execution on every tick no longer </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">makes sense.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.959.1">Emulating order execution during backtesting</span></h2>
<p><span class="koboSpan" id="kobo.960.1">Let’s start by </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.961.1">emulating market orders since they’re the easiest to implement, and stick to the </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">following guidelines:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.963.1">We assume that a market order can be generated by the trade logic only at the bar’s </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">closing time</span></span></li>
<li><span class="koboSpan" id="kobo.965.1">We emulate the execution of a market order only at the bar’s </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">closing price</span></span></li>
<li><span class="koboSpan" id="kobo.967.1">We assume that the liquidity in the market is always sufficient and therefore we don’t have to check it before executing </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">an order</span></span></li>
<li><span class="koboSpan" id="kobo.969.1">We assume that the actual execution price was the same as the requested order price as we don’t have real-time tick data to test </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">the execution</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.971.1">With all these considerations in mind, the modified </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">emulateBrokerExecution</span></strong><span class="koboSpan" id="kobo.973.1"> function will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">much simpler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.975.1">
def emulateBrokerExecution(bar, order):
    if order['Type'] == 'Market':
        order['Status'] = 'Executed'
        if order['Side'] == 'Buy':
            order['Executed Price'] = bar['Close']
        if order['Side'] == 'Sell':
            order['Executed Price'] = bar['Close']</span></pre>
<p><span class="koboSpan" id="kobo.976.1">We do not add </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.977.1">any flags here as this function is called from inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">processOrders</span></strong><span class="koboSpan" id="kobo.979.1"> function. </span><span class="koboSpan" id="kobo.979.2">Let’s add this function: you will see that its logic looks very much like the one we used previously, with live </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">tick data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.981.1">
def processOrders():
    while True:
        try:
            bar = bar_feed.get(block = True, timeout = 1)
        except:
            break</span></pre>
<p><span class="koboSpan" id="kobo.982.1">We started with a similar </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">try...except</span></strong><span class="koboSpan" id="kobo.984.1"> statement that terminates the execution of the thread when there’s no more data in the bars queue. </span><span class="koboSpan" id="kobo.984.2">Next, we make the same updates to the system metadata as we did previously; the only difference is that we use the bar’s closing price instead of the last </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">tick price:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.986.1">
        System.equity += (bar['Close'] - System.last_price) * System.market_position
        System.equity_timeseries.append(System.equity)
        System.last_price = bar['Close']</span></pre>
<p><span class="koboSpan" id="kobo.987.1">The orders processing logic is again quite similar to the tick-driven code, with the main difference being the absence of risk management checks (whether we have sufficient funds to trade) and rejected </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.988.1">orders handling: during backtesting, we assume that all orders </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">are executed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.990.1">
        while True:
            try:
                order = orders_stream.get(block = False)
                emulateBrokerExecution(bar, order)
                if order['Status'] == 'Executed':
                    System.last_price = order['Executed Price']
                    if order['Side'] == 'Buy':
                        System.market_position = System.market_position + order['Size']
                    if order['Side'] == 'Sell':
                        System.market_position = System.market_position - order['Size']
            except:
                order = 'No order'
                break
        System.F3.clear()
        System.F1.set()
        System.F3.wait()</span></pre>
<p><span class="koboSpan" id="kobo.991.1">At the end of the function’s code, we again add the respective flags to control the execution order of </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">the threads.</span></span></p>
<p><span class="koboSpan" id="kobo.993.1">Well, this is it! </span><span class="koboSpan" id="kobo.993.2">All we must do now is check the time spent on the backtest (just for fun) and start </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">the threads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.995.1">
start_time = time.perf_counter()
incoming_price_thread = threading.Thread(target = getBar)
trading_thread = threading.Thread(target = tradeLogic)
ordering_thread = threading.Thread(target = processOrders)
incoming_price_thread.start()
trading_thread.start()
ordering_thread.start()</span></pre>
<p><span class="koboSpan" id="kobo.996.1">But how do we check that the code produces </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">correct results?</span></span></p>
<p><span class="koboSpan" id="kobo.998.1">Of course, we could </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.999.1">add several print statements, as we did with the live trading application, but the goal of backtesting is different: we want to process as much data as possible within as brief a period as possible, and then analyze the collected data. </span><span class="koboSpan" id="kobo.999.2">5 years’ worth of 1-minute bars of historical data makes over 2 million data points, so if we just print the updated equity value on each bar, it would make over 2 million prints – which would take forever because </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">print()</span></strong><span class="koboSpan" id="kobo.1001.1"> is one of the slowest instructions. </span><span class="koboSpan" id="kobo.1001.2">So, how do systematic traders analyze the </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">strategy’s performance?</span></span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.1003.1">Equity curve and statistics</span></h2>
<p><span class="koboSpan" id="kobo.1004.1">When running a backtest with the code we’ve just written, we save some basic statistical data: the equity </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.1005.1">value updated on every tick or bar. </span><span class="koboSpan" id="kobo.1005.2">If we plot </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.1006.1">the equity time series, we get an </span><strong class="bold"><span class="koboSpan" id="kobo.1007.1">equity curve</span></strong><span class="koboSpan" id="kobo.1008.1">: a visual representation </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.1009.1">of the dynamics of the trading system’s profits </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.1010.1">and losses over time. </span><span class="koboSpan" id="kobo.1010.2">Such a chart is the first thing to check after the backtest </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">is complete:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1012.1">If the equity curve shows growth over time, then there is a chance (but not a guarantee!) that the strategy may also perform well in </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">the future</span></span></li>
<li><span class="koboSpan" id="kobo.1014.1">If the equity curve exhibits steady systematical loss over time, it again may not be really bad: consider inverting the rules of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">trade logic</span></span></li>
<li><span class="koboSpan" id="kobo.1016.1">If the equity curve oscillates around zero, it’s probably the worst case as this strategy logic is unlikely to make any money in </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">the future</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1018.1">Let’s add code for plotting the equity curve to our code after the backtest is complete. </span><span class="koboSpan" id="kobo.1018.2">We will use the techniques that we discussed in </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1019.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1020.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1021.1">Data Visualization in FX Trading with Python</span></em><span class="koboSpan" id="kobo.1022.1">, so I recommend refreshing your memory about using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">matplotlib</span></strong><span class="koboSpan" id="kobo.1024.1"> at </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">this point.</span></span></p>
<p><span class="koboSpan" id="kobo.1026.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">matplotlib</span></strong><span class="koboSpan" id="kobo.1028.1"> main </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.1029.1">loop cannot be run in a thread (at least easily), so we must </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.1030.1">add charting in the main thread (like we did when plotting </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.1031.1">live bar charts in </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1032.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1033.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1034.1">Data Visualization in FX Trading with Python</span></em><span class="koboSpan" id="kobo.1035.1">) and keep </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.1036.1">an eye on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">incoming_price_feed</span></strong><span class="koboSpan" id="kobo.1038.1"> thread: while it’s alive, we just wait and do nothing, but as soon as it finishes working, we plot the </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">equity curve.</span></span></p>
<p><span class="koboSpan" id="kobo.1040.1">So, we just add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">import matplotlib.pyplot as plt</span></strong><span class="koboSpan" id="kobo.1042.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">imports</span></strong><span class="koboSpan" id="kobo.1044.1"> section at the beginning of the code and the following simple infinite loop to its end, once all the threads have </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">been started:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1046.1">
while True:
    if incoming_price_thread.is_alive():
        time.sleep(1)
    else:
        end_time = time.perf_counter()
        print(f'Backtest complete in {round(end_time - start_time, 0)} second(s).')
        plt.plot(System.equity_timeseries)
        plt.show()
        break</span></pre>
<p><span class="koboSpan" id="kobo.1047.1">If you did everything correctly and used the same historical data file as I did, you will see a chart like </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<span class="koboSpan" id="kobo.1049.1"><img alt="Figure 11.7 – Equity curve of the sample strategy, built on the first 10 bars" src="image/B19145_11_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1050.1">Figure 11.7 – Equity curve of the sample strategy, built on the first 10 bars</span></p>
<p><span class="koboSpan" id="kobo.1051.1">This looks great, but how </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.1052.1">can we make sure that this result is correct? </span><span class="koboSpan" id="kobo.1052.2">If a backtester emulates the </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.1053.1">performance incorrectly, we can’t </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.1054.1">rely on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">backtesting results.</span></span></p>
<p><span class="koboSpan" id="kobo.1056.1">Fortunately, it’s not </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.1057.1">difficult to check this result. </span><span class="koboSpan" id="kobo.1057.2">As you may remember, we intentionally used a very simplistic test strategy that generates orders on almost every bar. </span><span class="koboSpan" id="kobo.1057.3">So, we can rebuild a similar equity curve manually, for example using MS Excel or OpenOffice, and compare it with the chart generated by our </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">backtesting app.</span></span></p>
<p><span class="koboSpan" id="kobo.1059.1">Let’s open the data file and remove the unnecessary columns (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1060.1">UpVolume</span></strong><span class="koboSpan" id="kobo.1061.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">DownVolume</span></strong><span class="koboSpan" id="kobo.1063.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">TotalVolume</span></strong><span class="koboSpan" id="kobo.1065.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">UpTicks</span></strong><span class="koboSpan" id="kobo.1067.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">DownTicks</span></strong><span class="koboSpan" id="kobo.1069.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">TotalTicks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<span class="koboSpan" id="kobo.1073.1"><img alt="Figure 11.8 – First 10 bars of the source data file" src="image/B19145_11_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1074.1">Figure 11.8 – First 10 bars of the source data file</span></p>
<p><span class="koboSpan" id="kobo.1075.1">Next, we must </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.1076.1">reproduce the strategy logic: if the bar closes up (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">close &gt; open</span></strong><span class="koboSpan" id="kobo.1078.1">), then </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.1079.1">we buy; if the bar closes down, we sell. </span><span class="koboSpan" id="kobo.1079.2">We will </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.1080.1">add a new </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.1081.1">column that contains the direction of </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">our trade:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<span class="koboSpan" id="kobo.1083.1"><img alt="Figure 11.9 – Determining the direction of simulated trade" src="image/B19145_11_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1084.1">Figure 11.9 – Determining the direction of simulated trade</span></p>
<p><span class="koboSpan" id="kobo.1085.1">Then, we must add a column where we calculate the actual PnL per bar by multiplying the difference between the bars’ closing prices by the direction and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">trading size:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<span class="koboSpan" id="kobo.1087.1"><img alt="Figure 11.10 – Calculating returns per bar" src="image/B19145_11_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1088.1">Figure 11.10 – Calculating returns per bar</span></p>
<p><span class="koboSpan" id="kobo.1089.1">And finally, we must </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.1090.1">calculate </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.1091.1">the cumulative </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.1092.1">sum of per-bar </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.1093.1">returns, which is effectively the equity </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">time series:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<span class="koboSpan" id="kobo.1095.1"><img alt="Figure 11.11 – Calculating the equity time series" src="image/B19145_11_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1096.1">Figure 11.11 – Calculating the equity time series</span></p>
<p><span class="koboSpan" id="kobo.1097.1">Now, if we plot the equity curve by creating a line chart based on data in column I, we will see </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<span class="koboSpan" id="kobo.1099.1"><img alt="Figure 11.12 – Manual reconstruction of the equity curve in LibreOffice" src="image/B19145_11_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1100.1">Figure 11.12 – Manual reconstruction of the equity curve in LibreOffice</span></p>
<p><span class="koboSpan" id="kobo.1101.1">We can see </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.1102.1">that the equity curve is identical to what was plotted by our code – and this </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.1103.1">means that our backtest is reliable! </span><span class="koboSpan" id="kobo.1103.2">Having checked it only once, we can now trust its results any time we do </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">a test.</span></span></p>
<p><span class="koboSpan" id="kobo.1105.1">I bet you are </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.1106.1">dying to see a long-term performance report for our </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.1107.1">great strategy, not limited to just 10 bars. </span><span class="koboSpan" id="kobo.1107.2">Remember, 1 bar in our source data file is 1 minute, so 10 minutes worth of a backtest is not representative. </span><span class="koboSpan" id="kobo.1107.3">Let’s run the test for the first 1 million bars, which would equate to approximately 32 months’ worth of history. </span><span class="koboSpan" id="kobo.1107.4">We only need to modify one line in the code: replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">10</span></strong><span class="koboSpan" id="kobo.1109.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">1000000</span></strong><span class="koboSpan" id="kobo.1111.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">if counter == 1000000:</span></strong><span class="koboSpan" id="kobo.1113.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">getBar()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">Now, we also can estimate the backtesting speed as per the output in the console. </span><span class="koboSpan" id="kobo.1116.2">On my (by far not the latest) laptop (Macbook Pro 2012 with a quad-core Core i7 processor, SSD drive, and 16 GB of memory), it took 12 seconds to read the data from the file and 93 seconds to process 1 million bars. </span><span class="koboSpan" id="kobo.1116.3">Not bad: we can emulate 32 months in less than </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">2 minutes!</span></span></p>
<p><span class="koboSpan" id="kobo.1118.1">What about the equity curve from such a long-term perspective? </span><span class="koboSpan" id="kobo.1118.2">Here </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">you are:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<span class="koboSpan" id="kobo.1120.1"><img alt="Figure 11.13 – Theoretical performance (equity curve) of the sample strategy calculated using the first 1,000,000 data points" src="image/B19145_11_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1121.1">Figure 11.13 – Theoretical performance (equity curve) of the sample strategy calculated using the first 1,000,000 data points</span></p>
<p><span class="koboSpan" id="kobo.1122.1">Wow! </span><span class="koboSpan" id="kobo.1122.2">Looks like the Holy Grail of trading! </span><span class="koboSpan" id="kobo.1122.3">Is it possible that such a primitive strategy can indeed generate </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.1123.1">such steady returns over such a </span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">long period?</span></span></p>
<p><span class="koboSpan" id="kobo.1125.1">Generally speaking, every time </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.1126.1">you get such an optimistic result, focus on finding </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.1127.1">errors. </span><span class="koboSpan" id="kobo.1127.2">In our case, it is doubtful that we made an </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.1128.1">error in the trading logic – it’s too primitive and we tested it manually. </span><span class="koboSpan" id="kobo.1128.2">So, what is it that we probably missed in our backtesting that led to this unrealistically great result? </span><span class="koboSpan" id="kobo.1128.3">Or maybe this result is </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">indeed realistic?</span></span></p>
<p><span class="koboSpan" id="kobo.1130.1">Of course and unfortunately, it </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">is not.</span></span></p>
<p><span class="koboSpan" id="kobo.1132.1">Let’s go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">emulateBrokerExecution</span></strong><span class="koboSpan" id="kobo.1134.1"> function again. </span><span class="koboSpan" id="kobo.1134.2">We assume that any order is executed on the bar’s close – which is fine as we don’t have tick data for backtesting. </span><span class="koboSpan" id="kobo.1134.3">But our code makes no difference between the execution of buy and sell orders: they are both executed at the same price, in our example – bid. </span><span class="koboSpan" id="kobo.1134.4">But when testing the live trading application earlier in this chapter, we saw that executing orders at actual prices (bid for sell orders and ask for buy orders) may make quite a difference in PnL. </span><span class="koboSpan" id="kobo.1134.5">So, as we don’t have ask prices in our historical data, let’s emulate it: we will add a typical spread to the bar’s closing price, thus accounting for the difference between the bid </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">and ask:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
        if order['Side'] == 'Buy':
            order['Executed Price'] = bar['Close'] + 0.00005</span></pre>
<p><span class="koboSpan" id="kobo.1137.1">In reality, the spread </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.1138.1">in EURUSD may vary from as low as 0 to as much </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.1139.1">as 0.0010 and even greater (usually before the release of important </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.1140.1">economic news; see </span><a href="B19145_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1141.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.1142.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1143.1">Basics of Fundamental Analysis and Its Possible Use in FX Trading</span></em><span class="koboSpan" id="kobo.1144.1">), but it’s safe to assume that 1/2 pip is </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.1145.1">more or less adequate to emulate the </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">average spread.</span></span></p>
<p><span class="koboSpan" id="kobo.1147.1">Let’s run the backtest again and see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">equity curve:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<span class="koboSpan" id="kobo.1149.1"><img alt="Figure 11.14 – More realistic emulated equity curve of the test strategy" src="image/B19145_11_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1150.1">Figure 11.14 – More realistic emulated equity curve of the test strategy</span></p>
<p><span class="koboSpan" id="kobo.1151.1">What a radical difference! </span><span class="koboSpan" id="kobo.1151.2">Now, instead of steadily gaining money, the strategy is steadily losing </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.1152.1">money, and is doing so very, very quickly: it lost $100,000 in less </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.1153.1">than 3 years by trading only one so-called mini-lot (10,000 </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">base currency).</span></span></p>
<p><span class="koboSpan" id="kobo.1155.1">How has </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">this happened?</span></span></p>
<p><span class="koboSpan" id="kobo.1157.1">Although the </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.1158.1">strategy </span><em class="italic"><span class="koboSpan" id="kobo.1159.1">made money</span></em><span class="koboSpan" id="kobo.1160.1"> on paper without accounting for the spread, on average, it produced </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.1161.1">a ridiculously small amount of paper money </span><em class="italic"><span class="koboSpan" id="kobo.1162.1">per trade</span></em><span class="koboSpan" id="kobo.1163.1">: it was </span><em class="italic"><span class="koboSpan" id="kobo.1164.1">less than the spread</span></em><span class="koboSpan" id="kobo.1165.1">. </span><span class="koboSpan" id="kobo.1165.2">As soon as we correctly emulated the execution of orders at the bid and ask, the Holy Grail vanished into thin air and the sad truth </span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1">was revealed.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1167.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1168.1">This story should always be kept in mind when you do any market research and develop any strategy. </span><span class="koboSpan" id="kobo.1168.2">Always make sure that you emulate the real market conditions to the best possible extent – to avoid getting too optimistic theoretical results and quite painful disappointment </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.1170.1">The greatest </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.1171.1">news after </span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.1172.1">all this is that you now have </span><a id="_idIndexMarker827"/><span class="koboSpan" id="kobo.1173.1">a tool </span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.1174.1">you can rely on: our </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">backtesting platform.</span></span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.1176.1">Summary – where do we go now?</span></h1>
<p><span class="koboSpan" id="kobo.1177.1">Congratulations on getting so far in our studies! </span><span class="koboSpan" id="kobo.1177.2">I know that this chapter was very long, but hopefully not boring. </span><span class="koboSpan" id="kobo.1177.3">We covered virtually all aspects of developing live trading applications and backtesters, so now, you are well equipped with powerful tools that should help you develop great </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">trading strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.1179.1">Let’s quickly summarize what we learned in this chapter and outline </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">some vistas.</span></span></p>
<p><span class="koboSpan" id="kobo.1181.1">We now fully understand all four essential components of any trading app: receiving data, processing it, generating orders, and controlling </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">their execution.</span></span></p>
<p><span class="koboSpan" id="kobo.1183.1">We are also familiar with the most typical technical issues, such as incorrectly emulating order execution or processing non-market prices, and we also know how to work </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">around them.</span></span></p>
<p><span class="koboSpan" id="kobo.1185.1">Then, we learned how to synchronize multiple threads by using queues and threading event objects, and we know how to make sure that every component of the trading app runs exactly at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">expected moment.</span></span></p>
<p><span class="koboSpan" id="kobo.1187.1">Next, we learned how to rebuild parts of strategy performance manually to check the correctness of a test or live orders generation and execution. </span><span class="koboSpan" id="kobo.1187.2">Now, we can be 100% sure that we can rely on the code </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">we wrote.</span></span></p>
<p><span class="koboSpan" id="kobo.1189.1">We even created our first Holy Grail of trading – and immediately broke it into pieces by critically reviewing the code, thus learning the main lesson of systematic trading: not the tiniest detail can be missed, intentionally or occasionally, and you should check your results twice before going to production to avoid very unpleasant surprises when trading with </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">real money.</span></span></p>
<p><span class="koboSpan" id="kobo.1191.1">Now, let’s point out where we can go further in </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">our development.</span></span></p>
<p><span class="koboSpan" id="kobo.1193.1">First, at the moment, our platform only supports market orders. </span><span class="koboSpan" id="kobo.1193.2">Yes, from the previous chapter, you may remember that in many cases, market orders are preferred and that we can always emulate orders of all other types with market orders only. </span><span class="koboSpan" id="kobo.1193.3">However, at least for development purposes, it would be great to add emulation for limit and </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">stop orders.</span></span></p>
<p><span class="koboSpan" id="kobo.1195.1">In its present form, the code does not implement any risk management, neither at the position nor the strategy level. </span><span class="koboSpan" id="kobo.1195.2">It is essential to add at least basic stop-loss orders that will protect the trading account from an unexpected </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">catastrophic scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.1197.1">It would also be great to calculate at least some very basic statistics about the strategy’s performance: at the moment, we can only analyze the equity time series, but we want to know more about the average trade value, number of trades, percent of profitable trades, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.1199.1">And of course, we can complicate the platform further by adding multiple strategies, grouping them into portfolios, and achieving the highest level of sophistication by adding multiple incoming live data streams. </span><span class="koboSpan" id="kobo.1199.2">Although this is definitely outside the scope of this book, let me encourage you to be bold and curious, as any true researcher should be, and play with the existing code and try improving it –you will see that, in the long run, your efforts will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">highly rewarded.</span></span></p>
<p><span class="koboSpan" id="kobo.1201.1">The remaining chapters of this book are dedicated to implementing trading strategies of specific types. </span><span class="koboSpan" id="kobo.1201.2">We will add a few components to the backtesting platform we created in this chapter, but no significant changes will be made. </span><span class="koboSpan" id="kobo.1201.3">Instead, we will focus on developing the strategic logic and analyzing its </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">theoretical performance.</span></span></p>
</div>


<div class="Content" id="_idContainer120">
<h1 id="_idParaDest-201"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.1.1">Part 4: Strategies, Performance Analysis, and Vistas</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In previous parts, we gained sufficient knowledge to be able to develop a robust trading platform suitable for both backtesting and – with minimal modifications – live trading. </span><span class="koboSpan" id="kobo.2.2">We even coded a dummy strategy and as expected found that it could not make money if not </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">tested properly.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.4.1">Part 4</span></em><span class="koboSpan" id="kobo.5.1"> explains how to build a profitable trading strategy, from searching for trading ideas to implementing them in code. </span><span class="koboSpan" id="kobo.5.2">We will also learn how to generate the most important strategy performance data and analyze it to make the final verdict on whether such a strategy can be used in real life or not. </span><span class="koboSpan" id="kobo.5.3">Then, we will see how to correctly implement limit and stop orders and consider another trading strategy, based on a completely different trading idea. </span><span class="koboSpan" id="kobo.5.4">Finally, the last chapter suggests a few guidelines for further self-development in algorithm trading, with links to useful and </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">valuable resources.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This part comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following chapters:</span></span></p>
<ul>
<li><a href="B19145_12.xhtml#_idTextAnchor203"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 12</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Sample Strategy – Trend-Following</span></em></li>
<li><a href="B19145_13.xhtml#_idTextAnchor215"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">To Trade or Not to Trade – Performance Analysis</span></em></li>
<li><a href="B19145_14.xhtml#_idTextAnchor231"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 14</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Where to Go Now?</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer121">
</div>
</div>
</body></html>