<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor186"/>11</h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/>Backtesting and Theoretical Performance</h1>
<p>It’s been a long and, hopefully, interesting – although difficult at times – journey. It took us ten chapters to get familiar with all the essentials of market structure and the key concepts that create the foundation of systematic and algo trading. Now, we have approached the conclusion of this entire book. It’s time to bring all the pieces together and start developing our first trading application that can be used in both research and production.</p>
<p>We are going to develop a universal prototype that you will be able to use and reuse by just re-writing some parts without modifying the entire structure. We will trace all the paths from receiving a tick to placing an order – while checking the consistency of all our actions. We will learn how to keep parts of the trading application synchronized and see why it’s so important to do so. And finally, we will collect some very basic statistics of a sample trading strategy and calculate its theoretical performance – the most essential logical point in the entire research and development process.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Trading app architecture – revised and improved</li>
<li>Multithreading – convenient but full of surprises</li>
<li>Trading application with a live data feed</li>
<li>Backtesting – speed up the research</li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/>Trading app architecture – revised and improved</h1>
<p>In <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Developing Trading Strategies – Why They Are Different</em>, we proposed a <a id="_idIndexMarker712"/>generalized architecture of a trading application. In brief, it consists of the following components:</p>
<ul>
<li><strong class="bold">Data receiver</strong>: Something <a id="_idIndexMarker713"/>that retrieves live data from the market or historical data stored locally; see <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data </em><em class="italic">with Python</em></li>
<li><strong class="bold">Data cleanup</strong>: A component <a id="_idIndexMarker714"/>that eliminates non-market prices; see <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Developing Trading Strategies – Why They </em><em class="italic">Are Different</em></li>
<li><strong class="bold">Trading logic</strong>: The <em class="italic">brains</em> of <a id="_idIndexMarker715"/>the trading app that make trading decisions (see <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in FX Trading</em>, <a href="B19145_07.xhtml#_idTextAnchor114"><em class="italic">Chapter 7</em></a>, <em class="italic">Technical Analysis and Its Implementation in Python</em>, and <a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em>), frequently with integrated pre-trade risk management</li>
<li><strong class="bold">Ordering interface</strong>: A component that receives trading signals from the trading <a id="_idIndexMarker716"/>logic, converts them into orders, and keeps track of their execution; see <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation </em><em class="italic">in Python</em></li>
<li><strong class="bold">Post-trade risk management</strong> and <strong class="bold">open positions management</strong>, such as keeping <a id="_idIndexMarker717"/>track of the running <a id="_idIndexMarker718"/>loss and liquidating losing positions or all positions</li>
</ul>
<p>Anyway, this simplified architecture lists the essential components but does not say anything about how they communicate with each other. Of course, it is possible to use a linear architecture where all the components are implemented as dependent pieces of code executed <a id="_idIndexMarker719"/>one after another in sequence. Such a solution is simple, but has significant drawbacks:</p>
<ul>
<li>You won’t be able to add more trading logic components to run multiple strategies in parallel</li>
<li>You won’t be able to send orders to multiple trading venues</li>
<li>You won’t be able to receive information about the actual consolidated market position in the trading logic</li>
<li>You won’t be able to reuse the same code (at least in parts) for both development <a id="_idIndexMarker720"/>and production</li>
</ul>
<p>Let’s stop for a while at these four disadvantages.</p>
<p>Regarding the first two points, you may probably say that you’re not going to run multiple strategies and trade at multiple trading venues as we’re only making our first steps into algo trading, and doing that cross-venue and cross-trading logic is more of an institutional activity. I could argue that, in reality, it’s more than normal for private traders to do all that, but these two points are less important than the remaining two.</p>
<p>To understand <a id="_idIndexMarker721"/>the importance of the third point, we have to introduce a new term: <strong class="bold">consolidated </strong><strong class="bold">market position</strong>.</p>
<p>Imagine that you have several strategies and all of them trade in the same market – say, EURUSD. The first one bought 100,000 euros, the second one sold 80,000, and the third one bought 50,000. Why has this happened? It’s quite a common situation: for example, you run a short-term <a id="_idIndexMarker722"/>mean reversion strategy, longer-term breakout, and long-term trend following strategies (see <a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em>); they generate trading signals independently, but so long as they all trade the same market, they all contribute to the amount of the asset currently traded. This amount is called the consolidated market position.</p>
<p>In our example, the individual positions per strategy are 100,000 long, 80,000 short, and another 50,000 long, so the consolidated position is <em class="italic">70,000 long</em>. This is your real market exposure and all position sizing calculations should rely on this figure.</p>
<p>But what about the entry price for such a consolidated position?</p>
<p>In <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation in Python</em>, we explored the average execution price for an order that was executed in parts. The same approach can be used to calculate the average entry price for the consolidated market position. Let’s do this simple math for our example with three open positions.</p>
<p>Suppose that the first (100,000 long) position was opened at 1.0552, the second (80,000 short) at 1.0598, and the third (50,000 long) at 1.0471. First, we calculate the sum of these prices multiplied by the respective trading size. Don’t forget that short positions (which effectively reduce the consolidated market position) should be accounted for as negative numbers:</p>
<p><code>S = 100000 * 1.0552 – 80000 * 1.0598 + 50000 * 1.0471 = </code><code>73091</code></p>
<p>Now, we divide the sum, <em class="italic">S</em>, by the actual consolidated market position, <em class="italic">MP</em>, which equals <em class="italic">70,000</em>, and we get the average entry price:</p>
<div><div><img alt="" src="img/Formula_B19145_11_001.jpg"/>
</div>
</div>
<p>In our example, the consolidated average price is approximately 1.0442. At first glance, it looks ridiculous <a id="_idIndexMarker723"/>as it is way lower than the lowest of the actual traded prices. But it’s really easy to make sure it’s correct.</p>
<p>Imagine that the current market price is 1.0523. Let’s calculate the running <strong class="bold">profit or loss</strong> (typically referred to as running <strong class="bold">PnL</strong> or running <strong class="bold">P/L</strong>; see <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>, the <em class="italic">Trade mechanics – again some terminology</em> section) for each position: it’s just the distance between the current price and the entry price multiplied by the trading size. The first position running PnL at 1.0523 equals (1.0523 – 1.0552) * 100,000 = -$290, the second position running PnL equals (1.0523 – 1.0598) * -80,000 = $600, and the third position running PnL equals (1.0523 – 1.0471) * 50,000 = $260. Thus, for the consolidated market position, the running PnL equals $570.</p>
<p>Now, let’s do the same math with the price and the size of only one consolidated market position. Given it was <em class="italic">opened</em> at 1.0442 and the current market price is 1.0523, its running PnL is (1.0523 – 1.0442) * 70,000 = $567, which is not exactly equal to $570 only because we rounded the average price to the 4th digit. So, we can indeed use the average price and the resulting trading size of the consolidated market position instead of calculating the PnL for each position separately.</p>
<p class="callout-heading">Note for nerds</p>
<p class="callout">Such a <a id="_idIndexMarker724"/>consolidated position calculated as the average of all orders with their respective trade volume is often called the <strong class="bold">Volume Weighted Average Price</strong> (<strong class="bold">VWAP</strong>). However, the VWAP is normally only used to evaluate a position that was accumulated by multiple entries to the same direction, and so long as we are discussing the net position as the result of trades taken to both sides, I prefer using <em class="italic">consolidated</em>, although it’s not a regular term.</p>
<p>A consolidated market position is extremely important to correctly implement risk management. If you don’t know this position, you have no idea about your running profit or loss, so you don’t know when to liquidate a losing position – which may end up with a disastrous loss. Moreover, you may not know even how much to liquidate, and open a new position instead of only covering a loss.</p>
<p>Even if you run only one strategy in one market, it is no less important to know the exact market position as it exists in the real market: don’t forget that a certain order may not be executed or executed at a price different as expected due to several reasons (see <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation in Python</em>). So, if you don’t let your code provide feedback from the broker to the trading logic, you may have a hard time managing your positions.</p>
<p>The fourth <a id="_idIndexMarker725"/>disadvantage is hopefully more evident: if we can suggest an architecture that is flexible, modular, and reusable, then it has an advantage over something that should be modified entirely every time you want just to switch a data source.</p>
<p>So, with all these considerations in mind, what can we suggest to make the architecture of our trading app meet all the requirements mentioned?</p>
<p>We already know the solution, and we used it quite successfully in <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>. This solution is to use <em class="italic">threads</em> and <em class="italic">queues</em> to make the components of the app work independently. I strongly recommend that you refresh your memory regarding threads and queues by referring to the <em class="italic">Working with saved and live data – keep your app universal</em> section of that chapter.</p>
<p>Now, let’s redraw the app architecture diagram, this time at a bit lower level, closer to the transport layer, not just business logic.</p>
<p>As always, we will start from the beginning: receiving live (tick) market data.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>Market data component</h2>
<p>This component <a id="_idIndexMarker726"/>should be able to receive <a id="_idIndexMarker727"/>ticks from virtually any source, clean it up, translate them into the single format used throughout our app, and put them into the data queue:</p>
<div><div><img alt="Figure 11.1 – Tick data receiving component" src="img/B19145_11_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Tick data receiving component</p>
<p>The beauty <a id="_idIndexMarker728"/>of this approach is that as soon as the tick is sent to <a id="_idIndexMarker729"/>the tick queue, we can forget about it. This process is now isolated from the rest of the app, and should we need to change the data vendor or the broker, we can do that by rewriting the respective module without making a single change in the rest of the code.</p>
<p>Many strategies require tick data. For example, arbitrage strategies (see <a href="B19145_09.xhtml#_idTextAnchor152"><em class="italic">Chapter 9</em></a>, <em class="italic">Trading Strategies and Their Core Elements</em>) can work using <em class="italic">only</em> tick data. However, the majority of trading strategies use logic based on compressed data, not ticks. So, we need to add a component that can aggregate ticks into bars (see <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, the <em class="italic">Data compression – keep the amounts to the reasonable </em><em class="italic">minimum</em> section).</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>Data aggregation component</h2>
<p>This module <a id="_idIndexMarker730"/>should be able to <a id="_idIndexMarker731"/>not only aggregate live tick data into bars. When we develop a strategy, we normally use historical market data stored locally already in a compressed form, so there’s no need to waste time aggregating ticks during a test run. Thus, we must add the following part to our app architecture:</p>
<div><div><img alt="Figure 11.2 – Reading bars from storage or forming bars from ticks" src="img/B19145_11_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Reading bars from storage or forming bars from ticks</p>
<p>Again, as in <a id="_idIndexMarker732"/>the previous case, this process is isolated <a id="_idIndexMarker733"/>from the rest of the application, so we can implement it once and forget about it until we need to modify something in the way we aggregate ticks into bars.</p>
<p>Next, we should implement the trading logic.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>Trading logic component</h2>
<p>This component may use both tick and bar data as input and produce orders as output. This output <a id="_idIndexMarker734"/>should go into the order execution <a id="_idIndexMarker735"/>control component of our trading app, so it’s quite natural to use another queue again: the ordering queue that would isolate the order execution component from the rest of the application.</p>
<p>However, besides just sending orders out, we need another connection between the trading logic and the order execution components. This connection should provide feedback from the execution of the order to the trading logic. How do we establish such a connection?</p>
<p>The first idea that probably comes to mind at this point is to use yet another queue. However, in this case, it’s not convenient. Queues are great when you want to trigger a certain process as soon as data is in the queue – in other words, they are ideal for event-driven processes. But market position or equity values do not trigger any process by themselves: they are only used by various components of the trading app as auxiliary values. Therefore, instead of a queue, we will create an object that will store all the required data about the implemented trading strategy and share this object across all components of our trading app.</p>
<p>This object can contain any strategy metadata, such as market position, equity time series (see below), running PnL, realized profit or loss, various statistical metrics, and so on:</p>
<div><div><img alt="Figure 11.3 – Prototype of an object that stores trading strategy metadata" src="img/B19145_11_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Prototype of an object that stores trading strategy metadata</p>
<p>Last price means the quote received with the previous tick (or bar) and it serves to calculate the running PnL between two ticks (or bars): if the position is <em class="italic">long</em> and the price has <em class="italic">increased</em>, then the running PnL has also <em class="italic">increased</em>, if the position is <em class="italic">short</em> and the price has <em class="italic">decreased</em>, then the running PnL nevertheless <em class="italic">increased</em>, and so on. If we sum all changes in the running PnL on every tick or bar from the moment when the strategy started until the present, then we will get the overall profit and loss, which is frequently referred to <a id="_idIndexMarker736"/>by traders as <strong class="bold">equity</strong>. This is a bit of professional slang because formally, the equity is the value attributable to the owners of a business (see, for example, <a href="https://corporatefinanceinstitute.com/resources/valuation/equity/">https://corporatefinanceinstitute.com/resources/valuation/equity/</a> for details), but in algo trading, <em class="italic">equity</em> frequently means just the realized profit and loss, plus the value of the open position.</p>
<p>We can also <a id="_idIndexMarker737"/>save the equity value on <a id="_idIndexMarker738"/>each tick or bar, thus creating a time series. This time series is normally referred to as the equity curve and works as the most common illustration of the trading strategy’s performance: the way the strategy behaved in the past and when and how much money it made (or lost). This information can also be used by the trading logic, along with market price data and market position.</p>
<p>We also included two <a id="_idIndexMarker739"/>money management-related parameters: <strong class="bold">initial capital</strong> and <strong class="bold">leverage</strong>. These values <a id="_idIndexMarker740"/>can be used to check if we have sufficient funds to trade and also to determine the actual trading size for our orders.</p>
<p>Now that we’ve added such a universal object that transfers strategy metadata between the trading logic and the order execution component, we can add the trading logic component to our architectural diagram:</p>
<div><div><img alt="Figure 11.4 – Trading logic and common trading strategy parameters container" src="img/B19145_11_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Trading logic and common trading strategy parameters container</p>
<p>The last <a id="_idIndexMarker741"/>mandatory component <a id="_idIndexMarker742"/>to be added is the order execution component.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>Order execution component</h2>
<p>This component <a id="_idIndexMarker743"/>not only implements an ordering interface <a id="_idIndexMarker744"/>with the broker or emulates the execution of orders locally. It will also do some basic analysis of the strategy’s performance – for the needs of the trading logic. It should process the order, send it to a broker or emulate it locally, receive the execution status, process this status (for example, if the order was rejected, decide what to do: cancel or submit again), calculate the running PnL, and build the equity curve. Let’s add it to our diagram:</p>
<div><div><img alt="Figure 11.5 – Order execution control module and its interaction with the trading strategy properties object" src="img/B19145_11_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Order execution control module and its interaction with the trading strategy properties object</p>
<p>Let’s see <a id="_idIndexMarker745"/>how it works. First, we receive <a id="_idIndexMarker746"/>an order or orders from the order queue. These orders were generated and put into the queue by the trading logic. Then, we send an order to the broker or emulate its execution locally and receive the order status. If the order was executed, then we update the PnL and add another data point to the equity time series. If the order was rejected, we return it to the order queue and the whole process starts over automatically.</p>
<p>Note that the strategy metadata (market position, equity, and so on) is updated with every processed order. This ensures the ultimate precision in making trading decisions and controlling the actual market exposure.</p>
<p>Great! We now <a id="_idIndexMarker747"/>have a general view of the entire trading app architecture. And the most pleasant thing is that it is split into small, relatively <a id="_idIndexMarker748"/>simple components. We know how these components should communicate with each other, we know the data formats, and we know the sequence in which they should operate, so it seems we know everything we need to implement a trading application.</p>
<p>But before we start coding, I’d like to emphasize two advantages of the suggested architecture that are very hard to overvalue.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>Advantages of the modular architecture</h2>
<p>First of all, this architecture makes sure that <strong class="bold">your trading app will never peek ahead</strong> during the research phase (while using historical data). At this point, I recommend <a id="_idIndexMarker749"/>that you refresh your <a id="_idIndexMarker750"/>memory regarding peeking ahead, which was considered in detail in <a href="B19145_04.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Trading Application – What’s Inside?</em>, in the <em class="italic">Trading logic – this is where a small mistake may cost a fortune</em> section – I am sure you will appreciate the suggested architecture of our trading app.</p>
<p>Second, this architecture provides for a flexible modular code that conforms to the concept of a universal trading application: you can quickly switch data sources and trading venues and use the same application both for research and production.</p>
<p>It seems like we have covered everything we need to start coding our first trading application. However, there is one point of extreme importance that is surprisingly too frequently missed by so many developers: the problem of thread synchronization. To understand this problem and find out the right solutions to it, let’s do a brief <strong class="bold">lyrical digression</strong> about multithreading.</p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/>Multithreading – convenient but full of surprises</h1>
<p>We already <a id="_idIndexMarker751"/>worked with multithreading (see <a href="B19145_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Retrieving and Handling Market Data with Python</em>, the <em class="italic">Universal data connector</em> section), and we found that using multiple threads makes life way easier when we develop modular scalable applications. However, we never explored how multithreading is implemented in Python.</p>
<p>Two concepts are <a id="_idIndexMarker752"/>frequently confused: <strong class="bold">multiprocessing</strong> and <strong class="bold">multithreading</strong>. The difference between them is that the former uses the concept of isolated processes, each <a id="_idIndexMarker753"/>of them having a <strong class="bold">global interpreter lock</strong> (<strong class="bold">GIL</strong>), thus enabling parallel execution using separate physical or logical processors <a id="_idIndexMarker754"/>or processor cores (so-called <strong class="bold">true parallelism</strong>), whereas the latter runs a single process that doesn’t care about the number of processors or cores: it executes threads in small portions, allowing each thread to run for several milliseconds and then switching to another one. Of course, from a human perspective, it does look like processes are running in parallel. In most cases, we don’t even think about which thread is executed at which moment. But when implementing event-driven processes, it becomes critical to know what happens first: for example, if we try to generate an order before market data is received, it may end with an error in the best case.</p>
<p>To learn how real multithreading works, let’s write some simple code with three threads emulating the respective components of our trading application:</p>
<pre class="source-code">
from threading import Thread
import time
def t1(): # A thread that emulates data receiving
    while True:
        print('Receive data')
        time.sleep(1)
def t2(): # A thread that emulates trading logic
    while True:
        print('Trading logic')
        time.sleep(1)
def t3(): # A thread that emulates order execution
    while True:
        print('Processing orders')
        time.sleep(1)
thread1 = Thread(target=t1)
thread2 = Thread(target=t2)
thread3 = Thread(target=t3)
thread1.start()
thread2.start()
thread3.start()</pre>
<p>Since we start <a id="_idIndexMarker755"/>the threads one by one (1, 2, and then 3), we may expect to see messages stating <code>Receive data</code>, <code>Trading logic</code>, and <code>Processing orders</code> and repeating in this same order. However, when we run the code, we will see something different:</p>
<pre class="source-code">
Receive data
Trading logic
Processing orders
Receive dataProcessing orders
Trading logic
Processing ordersReceive data
Trading logic
Processing orders
Receive data
Trading logic
Trading logic
Processing orders
Receive data
Trading logicProcessing orders
Receive data
Processing ordersReceive data
Trading logic</pre>
<p>We can see that while on average the number of messages of each kind is more or less the same, the order in <a id="_idIndexMarker756"/>which they appear is almost random, making the output chaotic. This happens because, by default, no thread has any priority and each runs a small portion as soon as it can.</p>
<p>Of course, such a behavior is not suitable for a trading app: we want to make sure that we first receive a tick, then process it, then generate an order, and finally send it for execution – in this very order and not any other!</p>
<p>There are several solutions to this problem. We will use two: using data streams as events for synching and using <code>threading.Event()</code> objects to switch between threads. We will consider each approach in detail in the upcoming sections.</p>
<p>Let’s start by implementing a version of the trading app that works with live tick data, and then see how we can easily transform it into a powerful backtesting tool (if you don’t clearly remember the meaning of backtesting, just jump back to <a href="B19145_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Using Python for Trading Strategies</em>, the <em class="italic">What is paper trading and </em><em class="italic">backtesting?</em> section).</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor195"/>Trading application with live data feed</h1>
<p>As always, we <a id="_idIndexMarker757"/>start by doing some imports:</p>
<pre class="source-code">
import json
import threading
import queue
from datetime import datetime
from websocket import create_connection</pre>
<p>Next, we create <a id="_idIndexMarker758"/>a class that contains the strategy metadata (see the <em class="italic">Trading logic </em><em class="italic">component</em> section):</p>
<pre class="source-code">
class tradingSystemMetadata:
    def __init__(self):
        self.initial_capital = 10000
        self.leverage = 30
        self.market_position = 0
        self.equity = 0
        self.last_price = 0
        self.equity_timeseries = []</pre>
<p>Now, we prepare three (!) tick data queues:</p>
<pre class="source-code">
tick_feed_0 = queue.Queue()
tick_feed_1 = queue.Queue()
tick_feed_2 = queue.Queue()</pre>
<p>Why three? This is one of the solutions to the thread synching problem explained in the <em class="italic">Multithreading – convenient but full of </em><em class="italic">surprises</em> section.</p>
<p>The first queue (<code>tick_feed_0</code>) connects the market data receiver with the ticks aggregation component, which forms bars. This component is activated every time a new tick is in the first queue. After the component has finished, it puts the same tick into the second queue (<code>tick_feed_1</code>).</p>
<p><code>tick_feed_1</code> connects the ticks aggregator with the trading logic, and the trading logic is invoked only when there’s a new tick in <code>tick_feed_1</code>. But it may enter this queue only after the first component has finished working! So, trading logic cannot be invoked earlier than a new tick is processed. Then, similarly, the trading logic components put the same tick into the third queue (<code>tick_feed_2</code>).</p>
<p><code>tick_feed_2</code> connects the trading logic with the order execution component, and this component is invoked no earlier than there’s a new tick in <code>tick_feed_2</code>. So, using three <a id="_idIndexMarker759"/>queues to connect components one to another ensures the correct sequence of operations.</p>
<p class="callout-heading">Important note</p>
<p class="callout">This method of synching threads would work only if the interval between ticks is greater than the round trip time for all threads triggered by it to finish working. This is valid for most data feeds as normally, we receive no more than 10 ticks per second, and the round trip processing time is typically around 0.0001 seconds. This approach won’t work with heavy load exchange market data received via the <code>ITCH</code> protocol, which sometimes receives over 10,000 ticks per second. However, this is specific to institutional trading and we don’t consider solutions of this kind in this book.</p>
<p>Next, we must add a queue to process aggregated market data (<code>bar_feed</code>), a queue to store orders (<code>orders_stream</code>), create an instance of the system metadata class, and specify the parameters required to connect to a data feed (in our example, we use <code>LMAX</code> as the source of market data):</p>
<pre class="source-code">
bar_feed = queue.Queue()
orders_stream = queue.Queue()
System = tradingSystemMetadata()
url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"
subscription_msg = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]}]}'</pre>
<p>Now, we can reuse the code that we developed in <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading with Python</em>, in the <em class="italic">Plotting live tick </em><em class="italic">data</em> section:</p>
<pre class="source-code">
def LMAX_connect(url, subscription_msg):
    ws = create_connection(url)
    ws.send(subscription_msg)
    while True:
        tick = json.loads(ws.recv())</pre>
<p>Now, we have to put the tick into the first tick queue. But before we do that, we have to check the consistency of the received market data. We discussed non-market prices in <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Developing Trading Strategies – Why They Are Different</em>, so let’s just quickly refresh it: a non-market price is <em class="italic">too far</em> from the market. Of course, sometimes, it’s difficult to judge whether it is <em class="italic">too far</em> or <em class="italic">not so far</em>, but in essence, we can at least filter out ticks <a id="_idIndexMarker760"/>in which the difference between the bid and ask (also known as spread) is several times greater than normal. Events of this sort are quite infrequent, but I was lucky to capture one of these moments while plotting tick charts (see <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading with Python</em>). The following figure illustrates such a <em class="italic">bad tick</em> in which the bid is way lower than it should be:</p>
<div><div><img alt="Figure 11.6 – Non-market price" src="img/B19145_11_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Non-market price</p>
<p>To filter out at least bad ticks of this sort, let’s add a simple check: if the spread is greater than 10 pips, then skip this tick:</p>
<pre class="source-code">
        if 'instrument_id' in tick.keys():
            bid = float(tick['bids'][0]['price'])
            ask = float(tick['asks'][0]['price'])
            if ask - bid &lt; 0.001:
        tick_feed_0.put(tick)</pre>
<p>Next, we need to <a id="_idIndexMarker761"/>implement the ticks aggregator. In our example, let’s form 10-second bars so that we can test our app and check if everything works correctly faster (without waiting for 1 minute or 1-hour bars to complete).</p>
<p>We will use only bid data to form bars for simplicity. Why is this possible? Because most of the time (except for the time around important news releases, bank settlement time, and the end/beginning of the week), the spread (the difference between the bid and ask) is more or less constant. So, if we want to emulate the real execution of orders, then we can use real bid and ask in the tick data stream, but for the trade logic, we can use bars built with only one price. Of course, for strategies of a certain kind, such as arbitrage, both bid and ask data are essential (and sometimes last trade along with the two), but now, we’re building a prototype that you will be able to customize the way you want when you are familiar with the approach in general.</p>
<p>For aggregating ticks into bars, we used almost the same code from <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading with Python</em>, in the <em class="italic">Plotting live tick data</em> section, so not much commenting is required here:</p>
<pre class="source-code">
data_resolution = 10
def getBarRealtime(resolution):
    last_sample_ts = datetime.now()
    bar = {'Open': 0, 'High': 0, 'Low': 0, 'Close': 0}
    while True:
        tick = tick_feed_0.get(block=True)
        if 'instrument_id' in tick.keys():
            ts = datetime.strptime(tick['timestamp'], "%Y-%m-%dT%H:%M:%S.%fZ")
            bid = float(tick['bids'][0]['price'])
            delta = ts - last_sample_ts
            bar['High'] = max([bar['High'], bid])
            bar['Low'] = min([bar['Low'], bid])
            bar['Close'] = bid</pre>
<p>We created a bar, received a tick, and updated the bar’s high, low, and close values. Now, as soon as <a id="_idIndexMarker762"/>the time since the bar’s open is greater than or equal to 10 seconds, we start a new bar:</p>
<pre class="source-code">
        if delta.seconds &gt;= resolution - 1:
            if bar['Open'] != 0:
                bar_feed.put(bar)
                last_sample_ts = ts
                bar = {'Open': bid, 'High': bid, 'Low': bid, 'Close': bid}
        tick_feed_1.put(tick)</pre>
<p>Note the last line of this function. It puts the same tick that’s received into <code>tick_feed_1</code>. This is done to trigger the next component, the trading logic:</p>
<pre class="source-code">
def tradeLogic():
    while True:
        tick = tick_feed_1.get()
        try:
            bar = bar_feed.get(block=False)
            print('Got bar: ', bar)</pre>
<p>Now, it’s time to add some trading logic.</p>
<p class="callout-heading">Note</p>
<p class="callout">For testing purposes, we don’t care whether our test strategy is profitable or not – we only want to generate as many orders as possible to watch the emulated execution.</p>
<p>So, let’s implement the following simple logic:</p>
<ul>
<li>If the bar closes up (<code>close &gt; open</code>), then sell</li>
<li>If the bar closes down (<code>close &lt; open</code>), then buy</li>
</ul>
<p>With this "<em class="italic">strategy"</em>, we may <a id="_idIndexMarker763"/>expect many orders to be generated quickly, so we will be able to test our app without waiting for too long:</p>
<pre class="source-code">
            ####################################
            #      trade logic starts here      #
            ####################################
            open = bar['Open']
            close = bar['Close']
            if close &gt; open and System.market_position &gt;= 0:</pre>
<p>Here, we are checking that the bar’s closing price is greater than <code>Open</code> and also that the current consolidated market position is positive. We’re doing this because we don’t want to open multiple positions in the same direction. In other words, if we are already long in the market, we only wait for a short position to open, and vice versa:</p>
<pre class="source-code">
                order = {}
                order['Type'] = 'Market'
                order['Price'] = close
                order['Side'] = 'Sell'</pre>
<p>The following <code>if...else</code> statement checks whether we are opening the position for the first time. If we are, then we don’t have any current market position at the time of order generation, so in our example, the trading size is 10,000. But if there is already an open position and we want to open a new position in the opposite direction, then <em class="italic">we should first close the existing position</em> and <em class="italic">then open the new one</em>, which effectively requires twice the trading size. We have to use <code>10000</code> to close and <code>10000</code> to open a new position, which means a trading size of 2 * 10,000 = 20,000:</p>
<pre class="source-code">
                if System.market_position == 0:
                    order['Size'] = 10000
                else:
                    order['Size'] = 20000</pre>
<p>Finally, we must <a id="_idIndexMarker764"/>put the order into the order queue:</p>
<pre class="source-code">
                orders_stream.put(order)
                print(order) # added for testing</pre>
<p>Now, we must do exactly the opposite for the buy order:</p>
<pre class="source-code">
            if close &lt; open and System.market_position &lt;= 0:
                order = {}
                order['Type'] = 'Market'
                order['Price'] = close
                order['Side'] = 'Buy'
                if System.market_position == 0:
                    order['Size'] = 10000
                else:
                    order['Size'] = 20000
                orders_stream.put(order)
                print(order)
            ####################################
            #      trade logic ends here      #
            ####################################
        except:
            pass
        tick_feed_2.put(tick)</pre>
<p class="callout-heading">Why do we use 10,000 base currency as the trading size?</p>
<p class="callout">If we trade EURUSD, a currency pair quoted with 4 or 5 digits, then buying or selling 10,000 euro (see <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>, the <em class="italic">Naming conventions</em> section) would mean that 1 pip costs $1. Therefore, we can interpret the results of our tests both as in money and in pips. Since the FX market is highly leveraged (see the same in the <em class="italic">Trade mechanics – again some terminology</em> section in <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>), it’s more convenient to calculate all PnL in pips and then scale it using leverage.</p>
<p>Note that <a id="_idIndexMarker765"/>this function uses a <code>try...except</code> statement. The reason is that we use two queues: <code>tick_feed_1</code> to receive ticks and <code>bar_feed</code> to receive actual bars. However, ticks are only used in this function to trigger its execution (see the detailed explanation at the very beginning of this section), while bars are used to make actual trading decisions. The problem is that bars normally arrive far less frequently than ticks, so we can’t wait until there’s a bar in the <code>bar_feed</code> queue; otherwise, the normal execution of our app would be interrupted. That’s why we use the <code>block = False</code> attribute when reading from the <code>bar_feed</code> queue. However, if there’s a new tick in <code>tick_feed_1</code>, but there’s no bar in <code>bar_feed</code>, then the attempt to read from there would raise an exception. Therefore, we catch this exception and – in our current implementation – just do nothing, waiting for a new bar to arrive in the queue.</p>
<p>The final component of our trading app is order execution. We invoke this function by a tick received in <code>tick_feed_2</code>, where it’s put by <code>tradeLogic()</code>:</p>
<pre class="source-code">
def processOrders():
    while True:
        tick = tick_feed_2.get(block = True)
        current_price = float(tick['bids'][0]['price'])</pre>
<p>With every received tick, we update the equity value of the trading system. Remember that <em class="italic">equity</em> in traders’ slang means the sum of all PnL values calculated on each tick or bar. If we have a long position and the current price is greater than the previous price, then the equity value increases on this tick/bar. The opposite is also true: if we have a short position and the current price is less than the previous price, then the equity value also increases on this tick/bar.</p>
<p>I believe you’ve got it: if we’re long and the price decreases or if we’re short and the price increases, then the equity decreases on this tick or bar. To calculate the actual equity value <a id="_idIndexMarker766"/>on the current tick, we multiply the difference in price between the current and the previous ticks by the market position value:</p>
<pre class="source-code">
        System.equity += (current_price - System.last_price) * System.market_position
        System.equity_timeseries.append(System.equity)
        System.last_price = current_price
        print(tick['timestamp'], current_price, System.equity) # for testing purposes</pre>
<p>Now, we start scanning the order queue and executing orders as they appear there. Note that we again use the <code>block = False</code> attribute, so we never wait for an order in the order queue: if there’s no order by the time a new tick is received, we just go ahead and proceed with the main loop:</p>
<pre class="source-code">
        while True:
            try:
                order = orders_stream.get(block = False)</pre>
<p>After we’ve received an order, we should do the risk management check: whether we have sufficient funds to execute this order. To calculate the available funds, we should add the current equity (positive or negative) to the initial capital and subtract the margin required for the currently open market position, which is the value of this market position divided by the leverage:</p>
<pre class="source-code">
                available_funds = (System.initial_capital + System.equity) * System.leverage - System.market_position / System.leverage</pre>
<p class="callout-heading">How to calculate available funds</p>
<p class="callout">The calculation of available funds that we are using in our code is not 100% correct. The problem is that it is possible to have a huge position in the market with some positive running PnL. In this case, our formula would say we have sufficient funds, but in reality, until this huge position is closed, we may not have enough money in the trading account. So, to be perfectly precise with this calculation, we should have introduced yet another variable to the system metadata that would account only for realized PnL (calculated by closed positions). However, we are not going to do this now, again for simplicity and transparency’s sake.</p>
<p>Now, if the order <a id="_idIndexMarker767"/>size is less than the available funds in the trading account, we can execute the order. A bit later, we will write a separate function that emulates the order execution. In production, this function can be replaced by an actual call to the broker’s API:</p>
<pre class="source-code">
                if order['Size'] &lt; available_funds:
                    emulateBrokerExecution(tick, order)</pre>
<p>After attempting to execute the order, its status is changed either to <code>'Executed'</code> or <code>'Rejected'</code> (or any other status returned by your broker), so let’s decide what to do with it. Of course, if the order was successfully executed, we only update the strategy metadata (and print the result for testing purposes):</p>
<pre class="source-code">
                if order['Status'] == 'Executed':
                    System.last_price = order['Executed Price']
                    print('Executed at ', str(System.last_price), 'current price = ', str(current_price), 'order price = ', str(order['Executed Price']))
                    if order['Side'] == 'Buy':
                        System.market_position = System.market_position + order['Size']
                    if order['Side'] == 'Sell':
                        System.market_position = System.market_position – order['Size']</pre>
<p>If the order was rejected, we return it to the same order queue:</p>
<pre class="source-code">
                elif order['Status'] == 'Rejected':
                    orders_stream.put(order)</pre>
<p>Again, let me reiterate that, in reality, you may need more complex order handling, but it will depend <a id="_idIndexMarker768"/>on both the type of strategy you’re going to run and the types of order statuses provided by your broker.</p>
<p>Finally, we will just add the <code>except</code> clause so that nothing happens if there’s no order in the order queue:</p>
<pre class="source-code">
            except:
                order = 'No order'
                break</pre>
<p>We’re almost there! All we need to add now is the function that emulates the order execution at the broker. For the first version of our emulator, we will implement only the execution of market orders:</p>
<pre class="source-code">
def emulateBrokerExecution(tick, order):
    if order['Type'] == 'Market':
        if order['Side'] == 'Buy':</pre>
<p>It’s time for the final preflight check: making sure the market has sufficient liquidity before sending the order!</p>
<pre class="source-code">
            current_liquidity = float(tick['asks'][0]['quantity'])</pre>
<p>Don’t confuse bids and asks! If we buy, we check the liquidity at the offer (ask) and execute at the ask price, while if we sell, we use bids:</p>
<pre class="source-code">
            price = float(tick['asks'][0]['price'])
            if order['Size'] &lt;= current_liquidity:
                order['Executed Price'] = price
                order['Status'] = 'Executed'
            else:
                order['Status'] = 'Rejected'
        if order['Side'] == 'Sell':
            current_liquidity = float(tick['bids'][0]['quantity'])
            if order['Size'] &lt;= current_liquidity:
                order['Executed Price'] = price
                order['Status'] = 'Executed'
            else:
                order['Status'] = 'Rejected'</pre>
<p>Now, let’s review <a id="_idIndexMarker769"/>the components of the trading application we have added so far:</p>
<ul>
<li>Strategy metadata object (<code>class tradingSystemMetadata</code>)</li>
<li>Queues for price data and orders (<code>tick_feed_0</code>, <code>tick_feed_1</code>,  <code>tick_feed_2</code>, <code>bar_feed</code>, and <code>orders_stream</code>)</li>
<li>A function that connects to the data source (<code>LMAX_connect(url, subscription_msg)</code>)</li>
<li>A function that forms bars from ticks (<code>getBarRealtime()</code>)</li>
<li>A function that makes trading decisions (<code>tradeLogic()</code>)</li>
<li>A function that processes orders (<code>processOrders()</code>)</li>
<li>A function that emulates order execution at the broker (<code>emulateBrokerExecution(tick, order)</code>)</li>
</ul>
<p>All we have to add to the very end of our code is a block that initializes and starts all four threads:</p>
<pre class="source-code">
data_receiver_thread = threading.Thread(target = LMAX_connect, args = (url, subscription_msg))
incoming_price_thread = threading.Thread(target = getBarRealtime, args = (data_resolution,))
trading_thread = threading.Thread(target = tradeLogic)
ordering_thread = threading.Thread(target = processOrders)
data_receiver_thread.start()
incoming_price_thread.start()
trading_thread.start()</pre>
<p>We have just developed our first trading app! It’s time to run it and check if it’s doing what we expect. I will run it and wait until the second order is executed (because I want to make sure <a id="_idIndexMarker770"/>that I submit correct orders both in case the strategy has an open position in the market and in case there’s no open position). If you repeated all these steps correctly, you should see an output like the following:</p>
<pre class="source-code">
2022-12-12T12:03:20.000Z 1.05658 0.0
... (7 ticks omitted from output to save space)
2022-12-12T12:03:28.000Z 1.05664 0.0</pre>
<p>We started at <code>12:03:20</code>, so we received nine ticks (remember, LMAX doesn’t send actual ticks, but 1-second snapshots of market data). At the 10th second, we form a bar:</p>
<pre class="source-code">
Got bar:  {'Open': 1.05658, 'High': 1.05668, 'Low': 1.05658, 'Close': 1.05666}</pre>
<p>The bar’s close is greater than the bar’s open, so according to our test strategy logic, it is a signal to sell – and indeed, there’s an order that immediately follows the bar:</p>
<pre class="source-code">
{'Type': 'Market', 'Price': 1.05666, 'Side': 'Sell', 'Size': 10000}</pre>
<p>Note that the order size is <code>10000</code> because we opened the position for the very first time and we don’t have open positions in the market yet. We check the 10th tick to make sure that its price equals the closing price of the bar and the order price:</p>
<pre class="source-code">
2022-12-12T12:03:29.000Z 1.05666 0.0</pre>
<p>Now, we can see the execution report:</p>
<pre class="source-code">
Executed at  1.05666 current price =  1.05666 order price =  1.05666</pre>
<p>So far, so good. Let’s wait for the next bar to form:</p>
<pre class="source-code">
2022-12-12T12:03:30.000Z 1.05663 0.2999999999997449
... (7 ticks omitted from output to save space)
Got bar:  {'Open': 1.05666, 'High': 1.05666, 'Low': 1.05663, 'Close': 1.05665}</pre>
<p>We’re lucky: the very <a id="_idIndexMarker771"/>next bar closed in the opposite direction (close is less than open), so it’s time to generate a buy order:</p>
<pre class="source-code">
{'Type': 'Market', 'Price': 1.05665, 'Side': 'Buy', 'Size': 20000}</pre>
<p>Note that the order size this time is <code>20000</code>: we need to close the currently open position of <code>10000</code> and then open a new one with the remaining <code>10000</code>. Let’s check the tick price to make sure that the bar’s closing price and the order price are correct:</p>
<pre class="source-code">
2022-12-12T12:03:38.000Z 1.05665 0.09999999999843467</pre>
<p>Great, everything looks good. Now, let’s proceed to order execution...</p>
<pre class="source-code">
Executed at  1.05672 current price =  1.05665 order price =  1.05672</pre>
<p>Stop. What’s that? The last tick’s price was <code>1.05665</code>, but the order is executed at <code>1.05672</code>! Why?</p>
<p>This happens because we form bars using only bid prices and execute orders at actual market prices – bid for sell orders and ask for buy orders. The first order was a sell, so we used the bid price and all prices (bar, tick, order, and execution) coincided. But the second order was a buy, but we still used only the bid price to form a bar – that’s why we had the execution price greater than the bar’s closing price.</p>
<p class="callout-heading">The importance of market spread</p>
<p class="callout">This issue perfectly illustrates the importance of taking spread (the difference between the bid and ask prices) into consideration when running tests. So many developers forget about it and run their testing using only bid prices – for simplicity, you know. These tests are not adequate for the real market, and quite frequently generate trade logic that is profitable only when you can buy and sell at the same price, effectively assuming the spread to be zero at all times. Now, you know how to avoid this trap and make sure your tests are always realistic.</p>
<p>Before we <a id="_idIndexMarker772"/>move on, let’s quickly review our code and see whether it meets the requirements outlined in <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Developing Trading Strategies – Why They </em><em class="italic">Are Different</em>:</p>
<ul>
<li>It filters the incoming tick data feed and excludes non-market prices</li>
<li>It is event-driven – it generates and executes orders as soon as the trade logic confirms a trade</li>
<li>It does some basic risk management checks – position size, leverage, and available funds</li>
<li>It is capable of emulating bad order execution and handling these situations</li>
<li>And probably the main benefit: this code will never – never! – peek ahead, neither in testing nor in production (see <a href="B19145_04.xhtml#_idTextAnchor073"><em class="italic">Chapter 4</em></a>, <em class="italic">Trading Application – What’s Inside?</em>, the <em class="italic">Trading logic – this is where a small mistake may cost a </em><em class="italic">fortune</em> section)</li>
</ul>
<p>So, we have developed a robust application suitable for serious production! Of course, it can be improved further, but its core will remain almost unchanged. However, we don’t have a tested strategy to run. How can we develop such a strategy?</p>
<p>This is when we can use the concept of backtesting, which we mentioned earlier, almost at the beginning of this book.</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Backtesting – speeding up the research</h1>
<p>The process <a id="_idIndexMarker773"/>of developing a trading strategy (I mean the trading logic, not the application) is an infinite loop:</p>
<ol>
<li>Suggest a hypothesis.</li>
<li>Code it.</li>
<li>Run a test.</li>
<li>If the result is not satisfactory, tweak the parameters and repeat.</li>
<li>If nothing helps, look for an alternative hypothesis.</li>
</ol>
<p>The question is: what kind of application shall we use for testing in <em class="italic">step 3</em>?</p>
<p>Of course, we could use <a id="_idIndexMarker774"/>our existing trading app, draft some strategy logic, and then run it in test mode, as we’ve just done, collecting orders and analyzing the equity time series. But then a single test may take days, weeks, and even months if we want to test the strategy under different market conditions. Do you think it’s a bit too long? I agree. That’s why, for research and development purposes, we use backtesting.</p>
<p>We discussed backtesting in <a href="B19145_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Using Python for Trading Strategies</em>, in the <em class="italic">Paper trading, and backtesting – an essential part of systemic trader’s risk management</em> section. In essence, instead of emulating the execution of orders using live data streams, we emulate the data stream itself using pre-saved historical market data. In this case, we can dramatically speed up the testing because computers can process dozens of thousands of ticks or bars per second, compressing months of live testing into minutes or seconds of backtesting. Of course, due to its nature, backtesting cannot guarantee the future performance of a strategy, just because it tests using past data. But regardless, it helps us understand the strategy’s behavior under various market conditions. Generally speaking, if a backtest shows that the emulated equity was mostly growing in the past, then we may suppose that it continues growing in the future, and vice versa: if we saw that the emulated equity was only decreasing over time, or oscillating around zero at best, then we should be very cautious with such a strategy as it’s hard to imagine why it would suddenly start making money when put to production.</p>
<p>I hope you got the idea: we are going to run our code using saved data, not live, so we can process 1,000 or 10,000, or even more seconds of historical data in 1 second.</p>
<p>Now, I believe you will appreciate the approach we followed when developing our code: if you have pre-saved tick historical data, then <em class="italic">all you need to do is modify the only function</em> – the one that receives ticks from the data provider – and have it receive data from a local file.</p>
<p>That’s it.</p>
<p>Isn’t it impressive? Yes, you can use the same code for both research and production, thus reducing the probability of making an error to almost zero.</p>
<p>However, you can’t always get hold of historical tick data. Moreover, for strategies that use bars with a higher time frame (such as 1 hour, 4 hours, 1 day, 1 week, and so on), it would be a waste of time waiting until our application forms each bar from ticks. So, we may want to make <a id="_idIndexMarker775"/>the following modifications to our code:</p>
<ul>
<li>It should now be able to read data from a local file instead of receiving it from a data vendor</li>
<li>It should be able to process already compressed data (bars) without receiving tick data at all</li>
<li>It should be able to emulate order execution, which may happen within the duration of a single bar (for example, if the strategy bases its logic on 1-hour bars, then we should be able to emulate order execution between hh:00 and hh:59, where hh stands for the hours’ value).</li>
</ul>
<p>Looking at the architecture of our existing code, it seems like quite a straightforward task. However, there is one caveat.</p>
<p>Do you remember how we used tick data in the existing code? Yes, we aggregated it into bars, but besides that, ticks were served as a system clock that synchronized the components of the entire application. How do we synchronize them in case we don’t use tick data at all?</p>
<p>Here, we can use another method of controlling the execution of threads – using events.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Syncing threads using events</h2>
<p>Let’s quickly <a id="_idIndexMarker776"/>jump back to the code that we drafted in the <em class="italic">Multithreading – convenient but full of surprises</em> section earlier in this chapter. The problem with that code was that each thread was running <em class="italic">when possible</em>, thus producing output at random to a certain degree. And we want all three threads to work one by one – <code>t1</code>, <code>t2</code>, <code>t3</code>, and then again <code>t1</code>, and so on.</p>
<p>The threading module in Python provides several very efficient methods to solve the problem of controlling threads. One of them is using <code>Event()</code> objects.</p>
<p>A <code>threading.Event()</code> object is placed inside the thread’s code and it works like a traffic light. It has two possible states: set or cleared. When the event is set, the thread works as normal. When the event is cleared, the thread stops.</p>
<p>Besides just clearing and setting the events, it is possible to instruct the thread to <em class="italic">wait</em> until the event is set. In this case, the thread waits for the event and as soon as it’s set again, it resumes working.</p>
<p>If we want threads <a id="_idIndexMarker777"/>to run in a particular order, then we should stick to the following guidelines:</p>
<ul>
<li>We need as many events as there are threads</li>
<li>An event controlling a specific thread should be cleared <em class="italic">inside</em> this thread but set <em class="italic">outside</em> it</li>
</ul>
<p>Now, let’s make some modifications to the code.</p>
<p>First, we need three events:</p>
<pre class="source-code">
f1, f2, f3 = threading.Event(), threading.Event(), threading.Event()</pre>
<p>In our example, <code>f1</code> will control the <code>t1</code> thread, <code>f2</code> will control <code>t2</code>, and <code>f3</code> will control <code>t3</code>.</p>
<p>Next, to the very end of the <code>t1()</code> function, we do the following actions:</p>
<ul>
<li>We clear the <code>f1</code> event (which controls the first thread)</li>
<li>We set the <code>f2</code> event (which gives the green light to the <code>t2</code> thread)</li>
<li>We set thread <code>t1</code> to wait for the <code>f1</code> event to be set again</li>
</ul>
<p>The modified code will look like follows:</p>
<pre class="source-code">
def t1():
    while True:
        print('Receive data')
        time.sleep(1)
        f1.clear()
        f2.set()
        f1.wait()</pre>
<p>We modify <a id="_idIndexMarker778"/>the <code>t2()</code> and <code>t3()</code> functions in the same way (so that each thread controls its next neighbor) and run all three threads:</p>
<pre class="source-code">
def t2():
    while True:
        print('Trading logic')
        time.sleep(1)
        f2.clear()
        f3.set()
        f2.wait()
def t3():
    while True:
        print('Processing orders')
        time.sleep(1)
        f3.clear()
        f1.set()
        f3.wait()
thread1 = threading.Thread(target=t1)
thread2 = threading.Thread(target=t2)
thread3 = threading.Thread(target=t3)
thread1.start()
thread2.start()
thread3.start()</pre>
<p>Now, we can <a id="_idIndexMarker779"/>enjoy the output in the perfectly correct order:</p>
<pre class="source-code">
Trading logic
Processing orders
Receive data
Trading logic
Processing orders
Receive data
Trading logic
Processing orders
Receive data</pre>
<p>...and so on.</p>
<p class="callout-heading">Note</p>
<p class="callout">It is possible that for the first two execution loops, the output may still go in an incorrect order: this may happen until two events are cleared and awaited, and only one event is set.</p>
<p>Now that we’re familiar with <code>threading.Event()</code> objects, it’s time to modify our trading application for backtesting purposes. For clarity and ease of use, I will reproduce its entire code here and point to the exact places where we made any modifications.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>Backtesting platform with a historical data feed</h2>
<p>As <a id="_idIndexMarker780"/>always, we start with several imports:</p>
<pre class="source-code">
import csv
import threading
import queue
import time
from datetime import datetime</pre>
<p>Then, we reuse <a id="_idIndexMarker781"/>the same <code>tradingSystemMetadata</code> class and only add three events to the control threads. We name them <code>F1</code>, <code>F2</code> and <code>F3</code> (flags):</p>
<pre class="source-code">
class tradingSystemMetadata:
    def __init__(self):
        self.initial_capital = 10000
        self.leverage = 30
        self.market_position = 0
        self.equity = 0
        self.last_price = 0
        self.equity_timeseries = []
        self.F1, self.F2, self.F3 = threading.Event(), threading.Event(), threading.Event()</pre>
<p>Next, we need data and order queues. Since we no longer use tick data to sync threads, there’s no need to have multiple tick data queues – we only need one queue for bars and another one for orders:</p>
<pre class="source-code">
bar_feed = queue.Queue()
orders_stream = queue.Queue()</pre>
<p>Next, we must create an instance of the system metadata object and read the historical data from the file into <code>all_data</code>. We must also start the stopwatch (the <code>time.perf_counter()</code> method) to keep track of time spent on various operations – just out of curiosity.</p>
<p>Note that we read the data using <code>csv.DictReader()</code> so that we receive each bar as a dictionary – this ensures maximum compatibility with the production code that we developed earlier in this chapter:</p>
<pre class="source-code">
System = tradingSystemMetadata()
start_time = time.perf_counter()
f = open("&lt;your_file_path&gt;/LMAX EUR_USD 1 Minute.txt")
csvFile = csv.DictReader(f)
all_data = list(csvFile)
end_time = time.perf_counter()
print(f'Data read in {round(end_time - start_time, 0)} second(s).')</pre>
<p>Next, we need <a id="_idIndexMarker782"/>a modified function that takes bars from the read data one by one, converts necessary fields from <code>str</code> into <code>float</code>, and puts the bar into the queue. We must also break the execution of this loop after the first 10 bars for debugging purposes:</p>
<pre class="source-code">
def getBar():
    counter = 0
    for bar in all_data:
        bar['Open'] = float(bar['Open'])
        bar['High'] = float(bar['High'])
        bar['Low'] = float(bar['Low'])
        bar['Close'] = float(bar['Close'])
        bar_feed.put(bar)
        counter += 1
        if counter == 10:
            break
        System.F1.clear()
        System.F2.set()
        System.F1.wait()
    print('Finished reading data')</pre>
<p>Note the three flags (<code>System.F1</code>, <code>System.F2</code>, and <code>System.F3</code>) at the end of the function: they control the execution of threads and make sure that first, we read a bar, then we generate an order and, finally, we execute – or, rather, emulate – the execution of this order.</p>
<p>Also, note that <a id="_idIndexMarker783"/>we do not check data consistency and do not exclude any data points: when we work with saved historical data, we assume this data is already clean.</p>
<p>Next goes the <code>tradeLogic()</code> function. The best news here is that its main logical part remains completely unchanged – no modification is required between the <code>trade logic starts here</code> and <code>trade logic ends here</code> comments in the original code! We only modify this function at its beginning and at its end.</p>
<p>At its beginning, we must add a <code>try...except</code> statement that will terminate the respective thread when all the data has been processed. To do that, we must set the timeout attribute of the <code>get()</code> method to <code>1</code>. This means that <code>get()</code> will wait for <code>1</code> second for a new bar to appear in the queue, and if no bar is there after 1 second, then an exception is generated. On exception, we just break the loop and effectively terminate the thread:</p>
<pre class="source-code">
def tradeLogic():
    while True:
        try:
            bar = bar_feed.get(block=True, timeout=1)
        except:
            break
        ####################################
        #     trade logic starts here      #
        ####################################
        ####################################
        #       trade logic ends here      #
        ####################################
        bar_feed.put(bar)
        System.F2.clear()
        System.F3.set()
        System.F2.wait()</pre>
<p>We omitted the entire trade logic because it is indeed identical to what we used in our first version of the trading app.</p>
<p>Note that at <a id="_idIndexMarker784"/>end of the function code, we return the bar into the queue: its data will be required by the orders processing component. And as in the case of the previous function, we set the <code>F3</code> flag, giving the green light to the next operation (orders processing), clear <code>F2</code>, and stop the trade logic thread until the <code>F2</code> flag is set.</p>
<p>Next, we must rewrite the order execution emulator quite substantially: the difference between the production and backtesting versions is that while backtesting, we only work with compressed data, so checking order execution on every tick no longer makes sense.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>Emulating order execution during backtesting</h2>
<p>Let’s start by <a id="_idIndexMarker785"/>emulating market orders since they’re the easiest to implement, and stick to the following guidelines:</p>
<ul>
<li>We assume that a market order can be generated by the trade logic only at the bar’s closing time</li>
<li>We emulate the execution of a market order only at the bar’s closing price</li>
<li>We assume that the liquidity in the market is always sufficient and therefore we don’t have to check it before executing an order</li>
<li>We assume that the actual execution price was the same as the requested order price as we don’t have real-time tick data to test the execution</li>
</ul>
<p>With all these considerations in mind, the modified <code>emulateBrokerExecution</code> function will now look much simpler:</p>
<pre class="source-code">
def emulateBrokerExecution(bar, order):
    if order['Type'] == 'Market':
        order['Status'] = 'Executed'
        if order['Side'] == 'Buy':
            order['Executed Price'] = bar['Close']
        if order['Side'] == 'Sell':
            order['Executed Price'] = bar['Close']</pre>
<p>We do not add <a id="_idIndexMarker786"/>any flags here as this function is called from inside the <code>processOrders</code> function. Let’s add this function: you will see that its logic looks very much like the one we used previously, with live tick data:</p>
<pre class="source-code">
def processOrders():
    while True:
        try:
            bar = bar_feed.get(block = True, timeout = 1)
        except:
            break</pre>
<p>We started with a similar <code>try...except</code> statement that terminates the execution of the thread when there’s no more data in the bars queue. Next, we make the same updates to the system metadata as we did previously; the only difference is that we use the bar’s closing price instead of the last tick price:</p>
<pre class="source-code">
        System.equity += (bar['Close'] - System.last_price) * System.market_position
        System.equity_timeseries.append(System.equity)
        System.last_price = bar['Close']</pre>
<p>The orders processing logic is again quite similar to the tick-driven code, with the main difference being the absence of risk management checks (whether we have sufficient funds to trade) and rejected <a id="_idIndexMarker787"/>orders handling: during backtesting, we assume that all orders are executed:</p>
<pre class="source-code">
        while True:
            try:
                order = orders_stream.get(block = False)
                emulateBrokerExecution(bar, order)
                if order['Status'] == 'Executed':
                    System.last_price = order['Executed Price']
                    if order['Side'] == 'Buy':
                        System.market_position = System.market_position + order['Size']
                    if order['Side'] == 'Sell':
                        System.market_position = System.market_position - order['Size']
            except:
                order = 'No order'
                break
        System.F3.clear()
        System.F1.set()
        System.F3.wait()</pre>
<p>At the end of the function’s code, we again add the respective flags to control the execution order of the threads.</p>
<p>Well, this is it! All we must do now is check the time spent on the backtest (just for fun) and start the threads:</p>
<pre class="source-code">
start_time = time.perf_counter()
incoming_price_thread = threading.Thread(target = getBar)
trading_thread = threading.Thread(target = tradeLogic)
ordering_thread = threading.Thread(target = processOrders)
incoming_price_thread.start()
trading_thread.start()
ordering_thread.start()</pre>
<p>But how do we check that the code produces correct results?</p>
<p>Of course, we could <a id="_idIndexMarker788"/>add several print statements, as we did with the live trading application, but the goal of backtesting is different: we want to process as much data as possible within as brief a period as possible, and then analyze the collected data. 5 years’ worth of 1-minute bars of historical data makes over 2 million data points, so if we just print the updated equity value on each bar, it would make over 2 million prints – which would take forever because <code>print()</code> is one of the slowest instructions. So, how do systematic traders analyze the strategy’s performance?</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Equity curve and statistics</h2>
<p>When running a backtest with the code we’ve just written, we save some basic statistical data: the equity <a id="_idIndexMarker789"/>value updated on every tick or bar. If we plot <a id="_idIndexMarker790"/>the equity time series, we get an <strong class="bold">equity curve</strong>: a visual representation <a id="_idIndexMarker791"/>of the dynamics of the trading system’s profits <a id="_idIndexMarker792"/>and losses over time. Such a chart is the first thing to check after the backtest is complete:</p>
<ul>
<li>If the equity curve shows growth over time, then there is a chance (but not a guarantee!) that the strategy may also perform well in the future</li>
<li>If the equity curve exhibits steady systematical loss over time, it again may not be really bad: consider inverting the rules of the trade logic</li>
<li>If the equity curve oscillates around zero, it’s probably the worst case as this strategy logic is unlikely to make any money in the future</li>
</ul>
<p>Let’s add code for plotting the equity curve to our code after the backtest is complete. We will use the techniques that we discussed in <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading with Python</em>, so I recommend refreshing your memory about using <code>matplotlib</code> at this point.</p>
<p>The <code>matplotlib</code> main <a id="_idIndexMarker793"/>loop cannot be run in a thread (at least easily), so we must <a id="_idIndexMarker794"/>add charting in the main thread (like we did when plotting <a id="_idIndexMarker795"/>live bar charts in <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading with Python</em>) and keep <a id="_idIndexMarker796"/>an eye on the <code>incoming_price_feed</code> thread: while it’s alive, we just wait and do nothing, but as soon as it finishes working, we plot the equity curve.</p>
<p>So, we just add <code>import matplotlib.pyplot as plt</code> to the <code>imports</code> section at the beginning of the code and the following simple infinite loop to its end, once all the threads have been started:</p>
<pre class="source-code">
while True:
    if incoming_price_thread.is_alive():
        time.sleep(1)
    else:
        end_time = time.perf_counter()
        print(f'Backtest complete in {round(end_time - start_time, 0)} second(s).')
        plt.plot(System.equity_timeseries)
        plt.show()
        break</pre>
<p>If you did everything correctly and used the same historical data file as I did, you will see a chart like the following:</p>
<div><div><img alt="Figure 11.7 – Equity curve of the sample strategy, built on the first 10 bars" src="img/B19145_11_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Equity curve of the sample strategy, built on the first 10 bars</p>
<p>This looks great, but how <a id="_idIndexMarker797"/>can we make sure that this result is correct? If a backtester emulates the <a id="_idIndexMarker798"/>performance incorrectly, we can’t <a id="_idIndexMarker799"/>rely on the backtesting results.</p>
<p>Fortunately, it’s not <a id="_idIndexMarker800"/>difficult to check this result. As you may remember, we intentionally used a very simplistic test strategy that generates orders on almost every bar. So, we can rebuild a similar equity curve manually, for example using MS Excel or OpenOffice, and compare it with the chart generated by our backtesting app.</p>
<p>Let’s open the data file and remove the unnecessary columns (<code>UpVolume</code>, <code>DownVolume</code>, <code>TotalVolume</code>, <code>UpTicks</code>, <code>DownTicks</code>, and <code>TotalTicks</code>).</p>
<div><div><img alt="Figure 11.8 – First 10 bars of the source data file" src="img/B19145_11_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – First 10 bars of the source data file</p>
<p>Next, we must <a id="_idIndexMarker801"/>reproduce the strategy logic: if the bar closes up (<code>close &gt; open</code>), then <a id="_idIndexMarker802"/>we buy; if the bar closes down, we sell. We will <a id="_idIndexMarker803"/>add a new <a id="_idIndexMarker804"/>column that contains the direction of our trade:</p>
<div><div><img alt="Figure 11.9 – Determining the direction of simulated trade" src="img/B19145_11_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Determining the direction of simulated trade</p>
<p>Then, we must add a column where we calculate the actual PnL per bar by multiplying the difference between the bars’ closing prices by the direction and the trading size:</p>
<div><div><img alt="Figure 11.10 – Calculating returns per bar" src="img/B19145_11_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Calculating returns per bar</p>
<p>And finally, we must <a id="_idIndexMarker805"/>calculate <a id="_idIndexMarker806"/>the cumulative <a id="_idIndexMarker807"/>sum of per-bar <a id="_idIndexMarker808"/>returns, which is effectively the equity time series:</p>
<div><div><img alt="Figure 11.11 – Calculating the equity time series" src="img/B19145_11_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Calculating the equity time series</p>
<p>Now, if we plot the equity curve by creating a line chart based on data in column I, we will see the following:</p>
<div><div><img alt="Figure 11.12 – Manual reconstruction of the equity curve in LibreOffice" src="img/B19145_11_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Manual reconstruction of the equity curve in LibreOffice</p>
<p>We can see <a id="_idIndexMarker809"/>that the equity curve is identical to what was plotted by our code – and this <a id="_idIndexMarker810"/>means that our backtest is reliable! Having checked it only once, we can now trust its results any time we do a test.</p>
<p>I bet you are <a id="_idIndexMarker811"/>dying to see a long-term performance report for our <a id="_idIndexMarker812"/>great strategy, not limited to just 10 bars. Remember, 1 bar in our source data file is 1 minute, so 10 minutes worth of a backtest is not representative. Let’s run the test for the first 1 million bars, which would equate to approximately 32 months’ worth of history. We only need to modify one line in the code: replace <code>10</code> with <code>1000000</code> in <code>if counter == 1000000:</code> in the <code>getBar()</code> function.</p>
<p>Now, we also can estimate the backtesting speed as per the output in the console. On my (by far not the latest) laptop (Macbook Pro 2012 with a quad-core Core i7 processor, SSD drive, and 16 GB of memory), it took 12 seconds to read the data from the file and 93 seconds to process 1 million bars. Not bad: we can emulate 32 months in less than 2 minutes!</p>
<p>What about the equity curve from such a long-term perspective? Here you are:</p>
<div><div><img alt="Figure 11.13 – Theoretical performance (equity curve) of the sample strategy calculated using the first 1,000,000 data points" src="img/B19145_11_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Theoretical performance (equity curve) of the sample strategy calculated using the first 1,000,000 data points</p>
<p>Wow! Looks like the Holy Grail of trading! Is it possible that such a primitive strategy can indeed generate <a id="_idIndexMarker813"/>such steady returns over such a long period?</p>
<p>Generally speaking, every time <a id="_idIndexMarker814"/>you get such an optimistic result, focus on finding <a id="_idIndexMarker815"/>errors. In our case, it is doubtful that we made an <a id="_idIndexMarker816"/>error in the trading logic – it’s too primitive and we tested it manually. So, what is it that we probably missed in our backtesting that led to this unrealistically great result? Or maybe this result is indeed realistic?</p>
<p>Of course and unfortunately, it is not.</p>
<p>Let’s go back to the <code>emulateBrokerExecution</code> function again. We assume that any order is executed on the bar’s close – which is fine as we don’t have tick data for backtesting. But our code makes no difference between the execution of buy and sell orders: they are both executed at the same price, in our example – bid. But when testing the live trading application earlier in this chapter, we saw that executing orders at actual prices (bid for sell orders and ask for buy orders) may make quite a difference in PnL. So, as we don’t have ask prices in our historical data, let’s emulate it: we will add a typical spread to the bar’s closing price, thus accounting for the difference between the bid and ask:</p>
<pre class="source-code">
        if order['Side'] == 'Buy':
            order['Executed Price'] = bar['Close'] + 0.00005</pre>
<p>In reality, the spread <a id="_idIndexMarker817"/>in EURUSD may vary from as low as 0 to as much <a id="_idIndexMarker818"/>as 0.0010 and even greater (usually before the release of important <a id="_idIndexMarker819"/>economic news; see <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in FX Trading</em>), but it’s safe to assume that 1/2 pip is <a id="_idIndexMarker820"/>more or less adequate to emulate the average spread.</p>
<p>Let’s run the backtest again and see the equity curve:</p>
<div><div><img alt="Figure 11.14 – More realistic emulated equity curve of the test strategy" src="img/B19145_11_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – More realistic emulated equity curve of the test strategy</p>
<p>What a radical difference! Now, instead of steadily gaining money, the strategy is steadily losing <a id="_idIndexMarker821"/>money, and is doing so very, very quickly: it lost $100,000 in less <a id="_idIndexMarker822"/>than 3 years by trading only one so-called mini-lot (10,000 base currency).</p>
<p>How has this happened?</p>
<p>Although the <a id="_idIndexMarker823"/>strategy <em class="italic">made money</em> on paper without accounting for the spread, on average, it produced <a id="_idIndexMarker824"/>a ridiculously small amount of paper money <em class="italic">per trade</em>: it was <em class="italic">less than the spread</em>. As soon as we correctly emulated the execution of orders at the bid and ask, the Holy Grail vanished into thin air and the sad truth was revealed.</p>
<p class="callout-heading">Note</p>
<p class="callout">This story should always be kept in mind when you do any market research and develop any strategy. Always make sure that you emulate the real market conditions to the best possible extent – to avoid getting too optimistic theoretical results and quite painful disappointment in production.</p>
<p>The greatest <a id="_idIndexMarker825"/>news after <a id="_idIndexMarker826"/>all this is that you now have <a id="_idIndexMarker827"/>a tool <a id="_idIndexMarker828"/>you can rely on: our backtesting platform.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/>Summary – where do we go now?</h1>
<p>Congratulations on getting so far in our studies! I know that this chapter was very long, but hopefully not boring. We covered virtually all aspects of developing live trading applications and backtesters, so now, you are well equipped with powerful tools that should help you develop great trading strategies.</p>
<p>Let’s quickly summarize what we learned in this chapter and outline some vistas.</p>
<p>We now fully understand all four essential components of any trading app: receiving data, processing it, generating orders, and controlling their execution.</p>
<p>We are also familiar with the most typical technical issues, such as incorrectly emulating order execution or processing non-market prices, and we also know how to work around them.</p>
<p>Then, we learned how to synchronize multiple threads by using queues and threading event objects, and we know how to make sure that every component of the trading app runs exactly at the expected moment.</p>
<p>Next, we learned how to rebuild parts of strategy performance manually to check the correctness of a test or live orders generation and execution. Now, we can be 100% sure that we can rely on the code we wrote.</p>
<p>We even created our first Holy Grail of trading – and immediately broke it into pieces by critically reviewing the code, thus learning the main lesson of systematic trading: not the tiniest detail can be missed, intentionally or occasionally, and you should check your results twice before going to production to avoid very unpleasant surprises when trading with real money.</p>
<p>Now, let’s point out where we can go further in our development.</p>
<p>First, at the moment, our platform only supports market orders. Yes, from the previous chapter, you may remember that in many cases, market orders are preferred and that we can always emulate orders of all other types with market orders only. However, at least for development purposes, it would be great to add emulation for limit and stop orders.</p>
<p>In its present form, the code does not implement any risk management, neither at the position nor the strategy level. It is essential to add at least basic stop-loss orders that will protect the trading account from an unexpected catastrophic scenario.</p>
<p>It would also be great to calculate at least some very basic statistics about the strategy’s performance: at the moment, we can only analyze the equity time series, but we want to know more about the average trade value, number of trades, percent of profitable trades, and so on.</p>
<p>And of course, we can complicate the platform further by adding multiple strategies, grouping them into portfolios, and achieving the highest level of sophistication by adding multiple incoming live data streams. Although this is definitely outside the scope of this book, let me encourage you to be bold and curious, as any true researcher should be, and play with the existing code and try improving it –you will see that, in the long run, your efforts will be highly rewarded.</p>
<p>The remaining chapters of this book are dedicated to implementing trading strategies of specific types. We will add a few components to the backtesting platform we created in this chapter, but no significant changes will be made. Instead, we will focus on developing the strategic logic and analyzing its theoretical performance.</p>
</div>


<div><h1 id="_idParaDest-201"><a id="_idTextAnchor202"/>Part 4: Strategies, Performance Analysis, and Vistas</h1>
<p>In previous parts, we gained sufficient knowledge to be able to develop a robust trading platform suitable for both backtesting and – with minimal modifications – live trading. We even coded a dummy strategy and as expected found that it could not make money if not tested properly.</p>
<p><em class="italic">Part 4</em> explains how to build a profitable trading strategy, from searching for trading ideas to implementing them in code. We will also learn how to generate the most important strategy performance data and analyze it to make the final verdict on whether such a strategy can be used in real life or not. Then, we will see how to correctly implement limit and stop orders and consider another trading strategy, based on a completely different trading idea. Finally, the last chapter suggests a few guidelines for further self-development in algorithm trading, with links to useful and valuable resources.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B19145_12.xhtml#_idTextAnchor203"><em class="italic">Chapter 12</em></a>, <em class="italic">Sample Strategy – Trend-Following</em></li>
<li><a href="B19145_13.xhtml#_idTextAnchor215"><em class="italic">Chapter 13</em></a>, <em class="italic">To Trade or Not to Trade – Performance Analysis</em></li>
<li><a href="B19145_14.xhtml#_idTextAnchor231"><em class="italic">Chapter 14</em></a>, <em class="italic">Where to Go Now?</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>