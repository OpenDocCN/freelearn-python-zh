<html><head></head><body>
  <div><h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-37" class="chapterTitle">Discovering Quart</h1>
    <p class="normal"><strong class="keyword">Quart</strong> was started <a id="_idIndexMarker083"/>in 2017 as an evolution of the popular <strong class="keyword">Flask</strong> framework. Quart shares many of the same design decisions as Flask, and so a lot of the advice for one will work with the other. This book will focus on Quart to allow us to support asynchronous operations and to explore features such as WebSockets and HTTP/2 support.</p>
    <p class="normal">Quart and Flask are not the only Python frameworks. There is a long history of projects aimed at providing services on the web, such as <strong class="keyword">Bottle</strong>, <strong class="keyword">cherrypy</strong>, and <strong class="keyword">Django</strong>. All of these tools are used around the web, and they all share a similar goal: to offer the Python community simple tools for building web applications quickly.</p>
    <p class="normal">The smaller frameworks, such as Quart and Bottle, are often called microframeworks; however, the term can be a bit misleading. It does not mean you can only create micro-applications. Using those tools, you can build any application, large or small. The prefix "micro" means that the framework tries to make as few decisions as possible. It lets you freely organize your application code and use whichever libraries you want.</p>
    <p class="normal">A microframework acts as the glue code that delivers requests to your system and sends back responses. It does not enforce any particular paradigm on your project.</p>
    <p class="normal">A typical example of this philosophy is when you need to interact with a SQL database. A framework such as Django is batteries-included and provides everything you need to build your web app, including an <strong class="keyword">Object-Relational Mapper</strong> (<strong class="keyword">ORM</strong>) to bind objects with database query results. </p>
    <p class="normal">If you want to use an alternative ORM such as SQLAlchemy in Django to benefit from some of its great features, you'd be choosing a difficult path that would involve rewriting a lot of the Django library you are hoping to make use of, because of the tight integration Django has with the ORM it comes with. For certain applications, that's a good thing, but not necessarily for producing a microservice.</p>
    <p class="normal">Quart, on the other hand, does not have a built-in library to interact with your data, leaving you free to choose your own. The framework will only attempt to make sure it has enough hooks to be extended by external libraries to provide various kinds of features. In other words, using an ORM in Quart, and making sure you're doing the right thing with SQL sessions and transactions, will mostly consist of adding a package such as SQLAlchemy to your project. If you don't like how a particular library integrates, you're free to use another one or to build your own integration. Quart can also make use of the more common Flask extensions, although there is a performance risk there as they are unlikely to be asynchronous and could block your application's work.</p>
    <p class="normal">Of course, that's not a silver bullet. Being completely free in your choices also means that it is easier to make poor decisions and build an application that relies on defective libraries, or one that is not well designed. But fear not! This chapter will make sure you know what Quart has to offer, and how to organize your code for building microservices.</p>
    <p class="normal">This chapter covers the following topics:</p>
    <ul>
      <li class="bullet">Making sure we have Python</li>
      <li class="bullet">How Quart handles requests</li>
      <li class="bullet">Quart's built-in features</li>
      <li class="bullet">A microservice skeleton</li>
    </ul>
    <p class="normal">The goal of this chapter is to give you all the information needed to build microservices with Quart. By doing so, it inevitably duplicates some of the information you can find in Quart's official documentation, but focuses on providing interesting details and anything relevant when building microservices. Quart and Flask have good online documentation.</p>
    <p class="normal">Make sure you take a look at Quart's and Flask's documentation, listed respectively:</p>
    <ul>
      <li class="bullet"><a href="https://pgjones.gitlab.io/quart/index.html">https://pgjones.gitlab.io/quart/index.html</a></li>
      <li class="bullet"><a href="https://flask.palletsprojects.com/ ">https://flask.palletsprojects.com/</a></li>
    </ul>
    <p class="normal">Both should serve as a great complement to this chapter. The source code is located at <a href="https://gitlab.com/pgjones/quart">https://gitlab.com/pgjones/quart</a>.</p>
    <p class="normal">This is worth being aware of, as the source code is always the ultimate truth when you need to understand how the software works.</p>
    <h1 id="_idParaDest-38" class="title">Making sure we have Python</h1>
    <p class="normal">Before we start <a id="_idIndexMarker084"/>digging into its features, we should make sure that we have Python installed and working!</p>
    <p class="normal">You might see some documentation or posts online that mention <em class="italic">Python version 2</em>. There was a long transition from Python 2 to Python 3, and had this book been written a few years earlier, we would be discussing the merits of each. However, Python 3 is fully capable of everything the majority of people need to do, and Python 2 stopped being supported by the core Python team in 2020. This book uses the latest Python 3.9 stable release for all its code examples, but they are likely to work on Python 3.7 or later, as that's the minimum version that Quart requires in order to work.</p>
    <div><p class="Information-Box--PACKT-">If your computer does not have at least Python 3.7, you can download a new version from Python's own website, where installation instructions are provided: <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>.</p>
    </div>
    <p class="normal">You will find it easier if all the code examples in this book are run in a virtual environment, or<a id="_idIndexMarker085"/> virtualenv (<a href="https://docs.python.org/3/library/venv.html">https://docs.python.org/3/library/venv.html</a>). A virtual environment is Python's way of keeping each project separate, as it means you can install Quart and any other libraries you need; it will only affect the application you are currently <a id="_idIndexMarker086"/>working on. Other applications and projects can have different libraries, or different versions of the same library, without them getting in the way of each other. Using a virtualenv also means that you can easily recreate your project's dependencies somewhere else, which will be very useful when we deploy a microservice in a later chapter.</p>
    <p class="normal">Some code editors, such as PyCharm or Visual Studio, may manage a virtual environment for you. Every code example in the book runs in a terminal, and so we will use a terminal to create our virtualenv. This also shows how things work in more detail than viewing a program's output on the web, or in log files, and will be helpful when fixing any problems in the future.</p>
    <p class="normal">In a terminal, such as a macOS Terminal application, or a Windows Subsystem for Linux, change to the directory you would like to work in and run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">python -m venv my-venv
</code></pre>
    <p class="normal">Depending on how you installed Python, you may need to use <code class="Code-In-Text--PACKT-">python3</code> to create the virtual environment.</p>
    <p class="normal">This creates a new virtual environment called <code class="Code-In-Text--PACKT-">my-venv</code> in the current directory. You could give it another path if you like, but it's important to remember where it is. To use the virtual environment, you must activate it:</p>
    <pre class="programlisting con"><code class="hljs-con">source my-venv/bin/activate
</code></pre>
    <p class="normal">For most of the command-line examples in this book, we assume you are running on Linux, as that is what most services online use, so it is good to be familiar with it. This means that most of the commands will also work on macOS or on Windows using the Windows Subsystem for Linux. It's also possible to run Docker containers on all these systems, and we will describe containers later on when we discuss deploying your microservice.</p>
    <p class="normal">Now, let's install Quart so that we can run our example code:</p>
    <pre class="programlisting con"><code class="hljs-con">pip install quart
</code></pre>
    <p class="normal">To stop using the<a id="_idIndexMarker087"/> virtual environment without closing the terminal, you can type <code class="Code-In-Text--PACKT-">deactivate</code>. For now, though, let's keep the virtualenv active and look at how Quart will work.</p>
    <h1 id="_idParaDest-39" class="title">How Quart handles requests</h1>
    <p class="normal">The framework <a id="_idIndexMarker088"/>entry point is the <code class="Code-In-Text--PACKT-">Quart</code> class in the <code class="Code-In-Text--PACKT-">quart.app</code> module. Running a Quart application means <a id="_idIndexMarker089"/>running one single instance of this class, which will take care of handling <a id="_idIndexMarker090"/>incoming <strong class="keyword">Asynchronous Server Gateway Interface</strong> (<strong class="keyword">ASGI</strong>) and <strong class="keyword">Web Server Gateway Interface</strong> (<strong class="keyword">WSGI</strong>) requests, dispatch them to the right code, and then return a response. Remember that in <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding Microservices</em>, we discussed ASGI and WSGI, and how they define the interface between a web server and a Python application.</p>
    <p class="normal">The Quart class offers a <code class="Code-In-Text--PACKT-">route</code> method, which can decorate your functions. When you decorate a function this way, it becomes a view and is registered in the routing system. </p>
    <p class="normal">When a request arrives, it will be to a specific endpoint—usually a web address (such as <a href="https://duckduckgo.com/?q=quart">https://duckduckgo.com/?q=quart</a>) or part of an address, such as <code class="Code-In-Text--PACKT-">/api</code>. The routing system is how Quart connects an endpoint to the view—the bit of code that will run to process the request.</p>
    <p class="normal">Here's a very basic example of a fully functional Quart application:</p>
    <pre class="programlisting code"><code class="hljs-code"># quart_basic.py
from quart import Quart
app = Quart(__name__)
@app.route("/api")
def my_microservice():
    return {"Hello": "World!"}
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">All the code samples are available on GitHub at <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples</a>.</p>
    <p class="normal">We see that our function returns a dictionary, and Quart knows that this should be encoded as a JSON object to be transferred. However, only querying the <code class="Code-In-Text--PACKT-">/api</code> endpoint returns the value. Every other endpoint would return a 404 Error, indicating that it can't find the resource you requested because we haven't told it about any!</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__name__</code> variable, whose value will be <code class="Code-In-Text--PACKT-">__main__</code> when you run that single Python module, is the name of the application package. It's used by Quart to create a new logger with that name to format all the log messages, and to find where the file is located on the disk. Quart will use the directory as the root for helpers, such as the configuration that<a id="_idIndexMarker091"/> is associated with your app, and to determine default locations for the <code class="Code-In-Text--PACKT-">static</code> and <code class="Code-In-Text--PACKT-">templates</code> directories, which we will discuss later.</p>
    <p class="normal">If you run that module in a terminal, the <code class="Code-In-Text--PACKT-">Quart</code> app will run its own development web server, and start listening to incoming connections on port <code class="Code-In-Text--PACKT-">5000</code>. Here, we assume that you are still in the virtual environment created earlier and that the code above is in a file called <code class="Code-In-Text--PACKT-">quart_basic.py</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python quart_basic.py 
 * Serving Quart app 'quart_basic'
 * Environment: production
 * Please use an ASGI server (e.g. Hypercorn) directly in production
 * Debug mode: False
 * Running on http://localhost:5000 (CTRL + C to quit)
[2020-12-10 14:05:18,948] Running on http://localhost:5000 (CTRL + C to quit)
</code></pre>
    <p class="normal">Visiting <code class="Code-In-Text--PACKT-">http://localhost:5000/api</code> in your browser or with the <code class="Code-In-Text--PACKT-">curl</code> command will return a valid JSON response with the right headers:</p>
    <pre class="programlisting con"><code class="hljs-con">$ curl -v http://localhost:5000/api 
*   Trying localhost...
...
&lt; HTTP/1.1 200
&lt; content-type: application/json
&lt; content-length: 18
&lt; date: Wed, 02 Dec 2020 20:29:19 GMT
&lt; server: hypercorn-h11
&lt;
* Connection #0 to host localhost left intact
{"Hello":"World!"}* Closing connection 0
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">curl</code> command is going to be used a lot in this book. If you are under Linux or macOS, it should be pre-installed; refer to <a href="https://curl.haxx.se/">https://curl.haxx.se/</a>.</p>
    <p class="normal">If you are not developing your application on the same computer as the one that you are testing it on, you may need to adjust some of the settings, such as which IP addresses it should use to listen for connections. When we discuss deploying a microservice, we <a id="_idIndexMarker092"/>will cover some of the better ways of changing its configuration, but for now, the <code class="Code-In-Text--PACKT-">app.run</code> line can be changed to use a different <code class="Code-In-Text--PACKT-">host</code> and <code class="Code-In-Text--PACKT-">port</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">app.run(host="0.0.0.0", port=8000)
</code></pre>
    <p class="normal">While many web frameworks explicitly pass a <code class="Code-In-Text--PACKT-">request</code> object to your code, Quart provides a global <code class="Code-In-Text--PACKT-">request</code> variable, which points to the current <code class="Code-In-Text--PACKT-">request</code> object it built for the incoming HTTP request.</p>
    <p class="normal">This design decision makes the code for the simpler views very concise. As in our example, if you don't have to look at the request content to reply, there is no need to have it around. As long as your view returns what the client should get and Quart can serialize it, everything happens as you would hope. For other views, they can just import that variable and use it.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">request</code> variable is global, but it is unique to each incoming request and is thread-safe. Let's add some <code class="Code-In-Text--PACKT-">print</code> method calls here and there so that we can see what's happening under the hood. We will also explicitly make a <code class="Code-In-Text--PACKT-">Response</code> object using <code class="Code-In-Text--PACKT-">jsonify</code>, instead of letting Quart do that for us, so that we can examine it:</p>
    <pre class="programlisting code"><code class="hljs-code"># quart_details.py
from quart import Quart, request, jsonify
app = Quart(__name__)
@app.route("/api", provide_automatic_options=False)
async def my_microservice():
    print(dir(request))
    response = jsonify({"Hello": "World!"})
    print(response)
    print(await response.get_data())
    return response
if __name__ == "__main__":
    print(app.url_map)
    app.run()
</code></pre>
    <p class="normal">Running that new version in conjunction with the <code class="Code-In-Text--PACKT-">curl</code> command in another terminal, you get a lot of details, including the following:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python quart_details.py 
QuartMap([&lt;QuartRule '/api' (HEAD, GET, OPTIONS) -&gt; my_microservice&gt;,
 &lt;QuartRule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;])
Running on http://localhost:5000 (CTRL + C to quit)
  
[… '_load_field_storage', '_load_form_data', '_load_json_data', '_send_push_promise', 'accept_charsets', 'accept_encodings', 'accept_languages', 'accept_mimetypes', 'access_control_request_headers', 'access_control_request_method', 'access_route', 'args', 'authorization', 'base_url', 'blueprint', 'body', 'body_class', 'body_timeout', 'cache_control', 'charset', 'content_encoding', 'content_length', 'content_md5', 'content_type', 'cookies', 'data', 'date', 'dict_storage_class', 'encoding_errors', 'endpoint', 'files', 'form', 'full_path', 'get_data', 'get_json', 'headers', 'host', 'host_url', 'http_version', 'if_match', 'if_modified_since', 'if_none_match', 'if_range', 'if_unmodified_since', 'is_json', 'is_secure', 'json', 'list_storage_class', 'max_forwards', 'method', 'mimetype', 'mimetype_params', 'on_json_loading_failed', 'origin', 'parameter_storage_class', 'path', 'pragma', 'query_string', 'range', 'referrer', 'remote_addr', 'root_path', 'routing_exception', 'scheme', 'scope', 'send_push_promise', 'url', 'url_charset', 'url_root', 'url_rule', 'values', 'view_args']
Response(200)
b'{"Hello":"World!"}'
</code></pre>
    <p class="normal">Let's explore <a id="_idIndexMarker093"/>what's happening here:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">Routing</code>: When the service starts, Quart creates the <code class="Code-In-Text--PACKT-">QuartMap</code> object, and we can see here what it knows about endpoints and the associated views.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">Request</code>: Quart creates a <code class="Code-In-Text--PACKT-">Request</code> object and <code class="Code-In-Text--PACKT-">my_microservice</code> is showing us that it is a <code class="Code-In-Text--PACKT-">GET</code> request to <code class="Code-In-Text--PACKT-">/api</code>.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">dir()</code> shows us which methods and variables are in a class, such as <code class="Code-In-Text--PACKT-">get_data()</code> to retrieve any data that was sent with the request.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">Response</code>: A <code class="Code-In-Text--PACKT-">Response</code> object to be sent back to the client; in this case, <code class="Code-In-Text--PACKT-">curl</code>. It has an HTTP response code of <code class="Code-In-Text--PACKT-">200</code>, indicating that everything is fine, and its data is the 'Hello world' dictionary<a id="_idIndexMarker094"/> we told it to send.</li>
    </ul>
    <h2 id="_idParaDest-40" class="title">Routing</h2>
    <p class="normal">Routing happens<a id="_idIndexMarker095"/> in <code class="Code-In-Text--PACKT-">app.url_map</code>, which is an instance of the <code class="Code-In-Text--PACKT-">QuartMap</code> class that uses a library called <code class="Code-In-Text--PACKT-">Werkzeug</code>. That class uses regular expressions to determine whether a function decorated by <code class="Code-In-Text--PACKT-">@app.route</code> matches the incoming request. The routing only looks at the path you provided in the route call to see whether it matches the client's request.</p>
    <p class="normal">By default, the mapper will only accept <code class="Code-In-Text--PACKT-">GET</code>, <code class="Code-In-Text--PACKT-">OPTIONS</code>, and <code class="Code-In-Text--PACKT-">HEAD</code> methods on a declared route. Sending an HTTP request to a valid endpoint with an unsupported method will return a <code class="Code-In-Text--PACKT-">405 Method Not Allowed</code> response together with a list of supported methods in the <code class="Code-In-Text--PACKT-">allow</code> header:</p>
    <pre class="programlisting con"><code class="hljs-con">$ curl -v -XDELETE  http://localhost:5000/api
**   Trying 127.0.0.1...
* TCP_NODELAY set
* Connected to localhost (127.0.0.1) port 5000 (#0)
&gt; DELETE /api HTTP/1.1
&gt; Host: localhost:5000
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 405
&lt; content-type: text/html
&lt; allow: GET, OPTIONS, HEAD
&lt; content-length: 137
&lt; date: Wed, 02 Dec 2020 21:14:36 GMT
&lt; server: hypercorn-h11
&lt;
&lt;!doctype html&gt;
&lt;title&gt;405 Method Not Allowed&lt;/title&gt;
&lt;h1&gt;Method Not Allowed&lt;/h1&gt;
Specified method is invalid for this resource
* Connection #0 to host 127.0.0.1 left intact
    * Closing connection 0
</code></pre>
    <p class="normal">If you want to support specific methods allowing you to <code class="Code-In-Text--PACKT-">POST</code> to an endpoint or <code class="Code-In-Text--PACKT-">DELETE</code> some data, you can pass them to the <code class="Code-In-Text--PACKT-">route</code> decorator with the <code class="Code-In-Text--PACKT-">methods</code> argument, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">@app.route('/api', methods=['POST', 'DELETE', 'GET']) 
def my_microservice(): 
    return {'Hello': 'World!'}
</code></pre>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">OPTIONS</code> and <code class="Code-In-Text--PACKT-">HEAD</code> methods are implicitly added in all rules since it is automatically managed by the request handler. You can deactivate this behavior by giving the <code class="Code-In-Text--PACKT-">provide_automatic_options=False</code> argument to the <code class="Code-In-Text--PACKT-">route</code> function. This can be useful when you want to add custom headers to the response when <code class="Code-In-Text--PACKT-">OPTIONS</code> is called, such as <a id="_idIndexMarker096"/>when dealing with <strong class="keyword">Cross-Origin Resource Sharing</strong> (<strong class="keyword">CORS</strong>), in which<a id="_idIndexMarker097"/> you need to add several <code class="Code-In-Text--PACKT-">Access-Control-Allow-*</code> headers.</p>
    <p class="normal">For more information regarding <code class="Code-In-Text--PACKT-">HTTP</code> request methods, a good resource is the Mozilla Developer Network: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a>.</p>
    <h3 id="_idParaDest-41" class="title">Variables and converters</h3>
    <p class="normal">A common <a id="_idIndexMarker098"/>requirement <a id="_idIndexMarker099"/>for an API is the ability to specify exactly which data we want to request. For example, if you have a system where each person has a unique number to identify them, you might want to create a function that handles all requests sent to the <code class="Code-In-Text--PACKT-">/person/N</code> endpoint, so that <code class="Code-In-Text--PACKT-">/person/3</code> only deals with ID number <code class="Code-In-Text--PACKT-">3</code>, and <code class="Code-In-Text--PACKT-">/person/412 </code>only affects the person with ID <code class="Code-In-Text--PACKT-">412</code>.</p>
    <p class="normal">You can do this with variables in the <code class="Code-In-Text--PACKT-">route</code>, using the <code class="Code-In-Text--PACKT-">&lt;VARIABLE_NAME&gt;</code> syntax. This notation is pretty standard (<code class="Code-In-Text--PACKT-">Bottle</code> also uses it), and allows you to describe endpoints with dynamic values. If we create a <code class="Code-In-Text--PACKT-">route</code> such as <code class="Code-In-Text--PACKT-">/person/&lt;person_id&gt;</code>, then, when Quart calls your function, it converts the value it finds in the URL to a function argument with the same name:</p>
    <pre class="programlisting code"><code class="hljs-code">@app.route('/person/&lt;person_id&gt;') 
def person(person_id): 
    return {'Hello': person_id}
 
$ curl localhost:5000/person/3 
{"Hello": "3"} 
</code></pre>
    <p class="normal">If you have several routes that match the same URL, the mapper uses a particular set of rules to determine which one it calls. <code class="Code-In-Text--PACKT-">Quart</code> and <code class="Code-In-Text--PACKT-">Flask</code> both use <code class="Code-In-Text--PACKT-">Werkzeug</code> to organize their routing; this is the implementation description taken from Werkzeug's routing module:</p>
    <ol>
      <li class="numbered">Rules without any arguments come first for performance. This is because we expect them to match faster and some common rules usually don't have any arguments (index pages, and so on).</li>
      <li class="numbered">The more complex rules come first, so the second argument is the negative length of the number of weights.</li>
      <li class="numbered">Lastly, we order by the actual weights.</li>
    </ol>
    <p class="normal">Werkzeug's rules have, therefore, weights that are used to sort them, and this is not used or made visible in Quart. So, it boils down to picking views with more variables first, and then the others, in order of appearance, when Python imports the different modules. The rule of thumb is to make sure that every declared route in your app is unique, otherwise<a id="_idIndexMarker100"/> tracking which one gets picked will give you a<a id="_idIndexMarker101"/> headache.</p>
    <p class="normal">This also means that our new route will not respond to queries sent to <code class="Code-In-Text--PACKT-">/person</code>, or <code class="Code-In-Text--PACKT-">/person/3/help</code>, or any other variation—only to <code class="Code-In-Text--PACKT-">/person/</code> followed by some set of characters. Characters include letters and punctuation, though, and we have already decided that <code class="Code-In-Text--PACKT-">/api/apiperson_id</code> is a number! This is where converters are useful.</p>
    <p class="normal">We can tell the <code class="Code-In-Text--PACKT-">route</code> that a variable has a specific type. Since <code class="Code-In-Text--PACKT-">/api/apiperson_id</code> is an integer, we can use <code class="Code-In-Text--PACKT-">&lt;int:person_id&gt;</code>, as in the previous example, so that our code only responds when we give a number, and not when we give a name. You can also see that instead of the string <code class="Code-In-Text--PACKT-">"3"</code>, <code class="Code-In-Text--PACKT-">person_id</code> is a number, with no quotes:</p>
    <pre class="programlisting code"><code class="hljs-code">@app.route('/person/&lt;int:person_id&gt;') 
def person(person_id): 
    return {'Hello': person_id}
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">$ curl localhost:5000/person/3 
{ 
  "Hello": 3 
} 
$ curl localhost:5000/person/simon
&lt;!doctype html&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
Nothing matches the given URI
</code></pre>
    <p class="normal">If we had two routes, one for <code class="Code-In-Text--PACKT-">/person/&lt;int:person_id&gt;</code> and one for <code class="Code-In-Text--PACKT-">/person/&lt;person_id&gt;</code> (with different function names!), then the more specific one, which needs an integer, would get all the requests that had a number in the right place, and the other function would get the remaining requests.</p>
    <p class="normal">Built-in converters are <code class="Code-In-Text--PACKT-">string</code> (the default is a Unicode string), <code class="Code-In-Text--PACKT-">int</code>, <code class="Code-In-Text--PACKT-">float</code>, <code class="Code-In-Text--PACKT-">path</code>, <code class="Code-In-Text--PACKT-">any</code>, and <code class="Code-In-Text--PACKT-">uuid</code>.</p>
    <p class="normal">The path converter is like the default converter, but includes forward slashes, so that a request to a URL, <code class="Code-In-Text--PACKT-">/api/some/path/like/this</code>, would match the route <code class="Code-In-Text--PACKT-">/api/&lt;path:my_path&gt;</code>, and the function would get an argument called <code class="Code-In-Text--PACKT-">my_path</code> containing <code class="Code-In-Text--PACKT-">some/path/like/this</code>. If you are familiar with regular expressions, it's similar to matching <code class="Code-In-Text--PACKT-">[^/].*?</code>.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">int</code> and <code class="Code-In-Text--PACKT-">float</code> are for integers and floating-point—decimal—numbers. The <code class="Code-In-Text--PACKT-">any</code> converter allows<a id="_idIndexMarker102"/> you to combine several values. It can be a bit confusing<a id="_idIndexMarker103"/> to use at first, but it might be useful if you need to route several specific strings to the same place. A route of <code class="Code-In-Text--PACKT-">/&lt;any(about, help, contact):page_name&gt;</code> will match requests to <code class="Code-In-Text--PACKT-">/about</code>, <code class="Code-In-Text--PACKT-">/help</code>, or <code class="Code-In-Text--PACKT-">/contact</code>, and which one was chosen will be in the <code class="Code-In-Text--PACKT-">page_name</code> variable passed to the function.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">uuid</code> converter matches the UUID strings, such as those that you get from Python's <code class="Code-In-Text--PACKT-">uuid</code> module, providing unique identifiers. Examples of all these converters in action are also in the code samples for this chapter on GitHub.</p>
    <p class="normal">It's quite easy to create your custom converter. For example, if you want to match user IDs with usernames, you could create a converter that looks up a database and converts the integer into a username. To do this, you need to create a class derived from the <code class="Code-In-Text--PACKT-">BaseConverter</code> class, which implements two methods: the <code class="Code-In-Text--PACKT-">to_python()</code> method to convert the value to a Python object for the view, and the <code class="Code-In-Text--PACKT-">to_url()</code> method to go the other way (used by <code class="Code-In-Text--PACKT-">url_for()</code>, which is described in the next section):</p>
    <pre class="programlisting code"><code class="hljs-code"># quart_converter.py
from quart import Quart, request 
from werkzeug.routing import BaseConverter, ValidationError
_USERS = {"1": "Alice", "2": "Bob"}
_IDS = {val: user_id for user_id, val in _USERS.items()}
class RegisteredUser(BaseConverter):
    def to_python(self, value):
        if value in _USERS:
            return _USERS[value]
        raise ValidationError()
    def to_url(self, value):
        return _IDS[value]
app = Quart(__name__)
app.url_map.converters["registered"] = RegisteredUser
@app.route("/api/person/&lt;registered:name&gt;")
def person(name):
    return {"Hello": name}
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">ValidationError</code> method is raised in case the conversion fails, and the mapper will consider that <a id="_idIndexMarker104"/>the <code class="Code-In-Text--PACKT-">route</code> simply does not match that request. Let's try a <a id="_idIndexMarker105"/>few calls to see how that works in practice:</p>
    <pre class="programlisting con"><code class="hljs-con">$ curl localhost:5000/api/person/1 
{ 
  "Hello hey": "Alice" 
}
 
$ curl localhost:5000/api/person/2 
{ 
  "Hello hey": "Bob" 
}
 
$ curl localhost:5000/api/person/3 
 
&lt;!doctype html&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
Nothing matches the given URI
</code></pre>
    <div><p class="Information-Box--PACKT-">Be aware that the above is just an example of demonstrating the power of converters—an API that handles personal information in this way could give a lot of information away to malicious people. It can also be painful to change all the routes when the code evolves, so it is best to only use this sort of technique when necessary.</p>
    </div>
    <p class="normal">The best practice for routing is to keep it as static and straightforward as possible. This is especially true as moving all the endpoints requires changing all of the software that connects to them! It is often a good idea to include a version in the URL for an endpoint so that it is <a id="_idIndexMarker106"/>immediately <a id="_idIndexMarker107"/>clear that the behavior will be different between, for example, <code class="Code-In-Text--PACKT-">/v1/person</code> and <code class="Code-In-Text--PACKT-">/v2/person</code>.</p>
    <h3 id="_idParaDest-42" class="title">The url_for function</h3>
    <p class="normal">The last <a id="_idIndexMarker108"/>interesting feature of Quart's routing system is <a id="_idIndexMarker109"/>the <code class="Code-In-Text--PACKT-">url_for()</code> function. Given any view, it will return its actual URL. Here's an example of using Python interactively:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from quart_converter import app 
&gt;&gt;&gt; from quart import url_for 
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; async def run_url_for():
...     async with app.test_request_context("/", method="GET"):
...         print(url_for('person', name='Alice')) 
... 
&gt;&gt;&gt; loop = asyncio.get_event_loop()
&gt;&gt;&gt; loop.run_until_complete(run_url_for())
/api/person/1  
</code></pre>
    <p class="normal">The previous example uses the <strong class="keyword">Read-Eval-Print Loop</strong> (<strong class="keyword">REPL</strong>), which you can get by running the Python executable directly. There is also some extra code there to set up an asynchronous program because here, Quart is not doing that for us.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">url_for</code> feature is quite useful in templates when you want to display the URLs of some views—depending on the execution context. Instead of hardcoding some links, you can just point the function name to <code class="Code-In-Text--PACKT-">url_for</code> to get it.</p>
    <h2 id="_idParaDest-43" class="title">Request</h2>
    <p class="normal">When a <a id="_idIndexMarker110"/>request comes in, Quart calls the view and uses a Request Context to make sure that each request has an isolated environment, specific to that request. We saw an example of that in the code above, where we were testing things using the helper method, <code class="Code-In-Text--PACKT-">test_request_context()</code>. In other words, when you access the global request object in your view, you are guaranteed that it is unique to the handling of your specific request.</p>
    <p class="normal">As we saw earlier when calling <code class="Code-In-Text--PACKT-">dir(request)</code>, the <code class="Code-In-Text--PACKT-">Request</code> object contains a lot of methods when it comes to getting information about what is happening, such as the address of the computer making the request, what sort of request it is, and other information such as authorization headers. Feel free to experiment with some of these request methods using the example code as a starting point.</p>
    <p class="normal">In the following example, an HTTP Basic Authentication request that is sent by the client is always converted to a base64 form when sent to the server. Quart will detect the Basic prefix and will parse <a id="_idIndexMarker111"/>it into <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> fields in the <code class="Code-In-Text--PACKT-">request.authorization</code> attribute:</p>
    <pre class="programlisting code"><code class="hljs-code"># quart_auth.py
from quart import Quart, request
app = Quart(__name__)
@app.route("/")
def auth():
    print("Quart's Authorization information")
    print(request.authorization)
    return ""
if __name__ == "__main__":
    app.run()
</code></pre>
    <pre class="programlisting con"><code class="hljs-con">$ python quart_auth.py 
* Running on http://localhost:5000/ (Press CTRL+C to quit) 
Quart's Authorization information
{'username': 'alice', 'password': 'password'} 
[2020-12-03 18:34:50,387] 127.0.0.1:55615 GET / 1.1 200 0 3066
$ curl http://localhost:5000/ --user alice:password
</code></pre>
    <p class="normal">This behavior makes it easy to implement a pluggable authentication system on top of the <code class="Code-In-Text--PACKT-">request</code> object. Other common request elements, such as cookies and files, are all accessible via other attributes, as we will discover throughout this book.</p>
    <h2 id="_idParaDest-44" class="title">Response</h2>
    <p class="normal">In many of<a id="_idIndexMarker112"/> the previous examples, we have simply returned a Python dictionary and left Quart to produce a response for us that the client will understand. Sometimes, we have called <code class="Code-In-Text--PACKT-">jsonify()</code> to ensure that the result is a JSON object. </p>
    <p class="normal">There are other ways to make a response for our web application, along with some other values that are automatically converted to the proper object for us. We could return any of the following, and Quart would do the right thing:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">Response()</code>: Creates a <code class="Code-In-Text--PACKT-">Response</code> object manually.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">str</code>: A string will be encoded as a text/html object in the response. This is especially useful for HTML pages.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">dict</code>: A dictionary will be encoded as application/json using <code class="Code-In-Text--PACKT-">jsonify()</code>.</li>
      <li class="bullet">A generator or asynchronous generator object can be returned so that data can be streamed to the client.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">(response, status)</code> tuple: The response will be converted to a <code class="Code-In-Text--PACKT-">response</code> object if it matches one of the preceding data types, and the status will be the HTTP response code used.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">(response, status, headers)</code> tuple: The response will be converted, and the <code class="Code-In-Text--PACKT-">response</code> object will use a dictionary provided as headers that should be added to the response.</li>
    </ul>
    <p class="normal">In most cases, a <a id="_idIndexMarker113"/>microservice will be returning data that some other software will interpret and choose how to display, and so we will be returning Python dictionaries or using <code class="Code-In-Text--PACKT-">jsonify()</code> if we want to return a list or other object that can be serialized as JSON.</p>
    <p class="normal">Here's an example with YAML, another popular way of representing data: the <code class="Code-In-Text--PACKT-">yamlify()</code> function will return a <code class="Code-In-Text--PACKT-">(response, status, headers)</code> tuple, which will be converted by Quart into a proper <code class="Code-In-Text--PACKT-">Response</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code"># yamlify.py
from quart import Quart
import yaml  # requires PyYAML
app = Quart(__name__)
def yamlify(data, status=200, headers=None):
    _headers = {"Content-Type": "application/x-yaml"}
    if headers is not None:
        _headers.update(headers)
    return yaml.safe_dump(data), status, _headers
@app.route("/api")
def my_microservice():
    return yamlify(["Hello", "YAML", "World!"])
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">The way Quart handles requests can be summarized as follows:</p>
    <ol>
      <li class="numbered" value="1">When the application starts, any function decorated with <code class="Code-In-Text--PACKT-">@app.route()</code> is registered as a view and stored in <code class="Code-In-Text--PACKT-">app.url_map</code>.</li>
      <li class="numbered">A call is dispatched to the right view depending on its endpoint and method.</li>
      <li class="numbered">A <code class="Code-In-Text--PACKT-">Request</code> object is created in a local, isolated execution context.</li>
      <li class="numbered">A <code class="Code-In-Text--PACKT-">Response</code> object wraps the content to send back.</li>
    </ol>
    <p class="normal">These four steps<a id="_idIndexMarker114"/> are roughly all you need to know to start building apps using Quart. The next section will summarize the most important built-in features that Quart offers, alongside this request-response mechanism.</p>
    <h1 id="_idParaDest-45" class="title">Quart's built-in features</h1>
    <p class="normal">The previous section <a id="_idIndexMarker115"/>gave us a good understanding of how Quart processes a request, and that's good enough to get you started. There are more helpers that will prove useful. We'll discover the following main ones in this section:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">session</code> object: Cookie-based data</li>
      <li class="bullet"><strong class="keyword">Globals</strong>: Storing data in the <code class="Code-In-Text--PACKT-">request</code> context</li>
      <li class="bullet"><strong class="keyword">Signals</strong>: Sending and intercepting events</li>
      <li class="bullet"><strong class="keyword">Extensions and middleware</strong>: Adding features</li>
      <li class="bullet"><strong class="keyword">Templates</strong>: Building text-based content</li>
      <li class="bullet"><strong class="keyword">Configuring</strong>: Grouping your running options in a <code class="Code-In-Text--PACKT-">config</code> file</li>
      <li class="bullet"><strong class="keyword">Blueprints</strong>: Organizing your code in namespaces</li>
      <li class="bullet"><strong class="keyword">Error handling and debugging</strong>: Dealing with errors in your app</li>
    </ul>
    <h2 id="_idParaDest-46" class="title">The session object</h2>
    <p class="normal">Like <a id="_idIndexMarker116"/>the <code class="Code-In-Text--PACKT-">request</code> object, Quart creates a <code class="Code-In-Text--PACKT-">session</code> object, which is unique to the <code class="Code-In-Text--PACKT-">request</code> context. It's a dict-like object, which Quart serializes into a cookie on the user side. The data contained in the session mapping is dumped into a JSON mapping, then compressed using <code class="Code-In-Text--PACKT-">zlib</code> to make it smaller, and finally encoded in base64.</p>
    <p class="normal">When the <code class="Code-In-Text--PACKT-">session</code> gets serialized, the <strong class="keyword">itsdangerous</strong> (<a href="https://pythonhosted.org/itsdangerous/">https://pythonhosted.org/itsdangerous/</a>) library signs the content using a <code class="Code-In-Text--PACKT-">secret_key</code> value defined in the application. The signing uses <strong class="keyword">HMAC</strong> (<a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">https://en.wikipedia.org/wiki/Hash-based_message_authentication_code</a>) and SHA1.</p>
    <p class="normal">This signature, which is added to the data as a suffix, ensures that the client cannot tamper with the data that is stored in a cookie unless they know the secret key to sign the session value. Note that the data itself is not encrypted. Quart will let you customize the signing algorithm to use, but HMAC + SHA1 is good enough when you need to store data in cookies.</p>
    <p class="normal">However, when you're building microservices that are not producing HTML, you rarely rely on cookies as they are specific to web browsers. However, the idea of keeping a volatile key-value storage for each user can be extremely useful for speeding up some of the server-side work. For instance, if you need to perform some database look-ups to get some<a id="_idIndexMarker117"/> information pertaining to a user every time they connect, caching this information in a <code class="Code-In-Text--PACKT-">session</code>-like object on the server side and retrieving the values based on their authentication details makes a lot of sense.</p>
    <h2 id="_idParaDest-47" class="title">Globals</h2>
    <p class="normal">As discussed<a id="_idIndexMarker118"/> earlier in this chapter, Quart provides a mechanism for storing global variables that are unique to a particular <code class="Code-In-Text--PACKT-">request</code> context. That is used for <code class="Code-In-Text--PACKT-">request</code> and <code class="Code-In-Text--PACKT-">session</code>, but is also available to store any custom object.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">quart.g</code> variable contains all globals, and you can set whatever attributes you want on it. In Quart, the <code class="Code-In-Text--PACKT-">@app.before_request</code> decorator can be used to point to a function that the app will call every time a request is made, just before it dispatches the <code class="Code-In-Text--PACKT-">request</code> to a view.</p>
    <p class="normal">It's a typical pattern in Quart to use <code class="Code-In-Text--PACKT-">before_request</code> to set values in the globals. That way, all the functions that are called within the request context can interact with the special global variable called <code class="Code-In-Text--PACKT-">g</code> and get the data. In the following example, we copy the <code class="Code-In-Text--PACKT-">username</code> provided when the client performs an HTTP Basic Authentication in the <code class="Code-In-Text--PACKT-">user</code> attribute:</p>
    <pre class="programlisting code"><code class="hljs-code"># globals.py
from quart import Quart, g, request
app = Quart(__name__)
@app.before_request
def authenticate():
    if request.authorization:
        g.user = request.authorization["username"]
    else:
        g.user = "Anonymous"
@app.route("/api")
def my_microservice():
    return {"Hello": g.user}
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">When a client requests the <code class="Code-In-Text--PACKT-">/api</code> view, the <code class="Code-In-Text--PACKT-">authenticate</code> function will set <code class="Code-In-Text--PACKT-">g.user</code> depending on <a id="_idIndexMarker119"/>the headers provided:</p>
    <pre class="programlisting con"><code class="hljs-con">$ curl http://localhost:5000/api 
{ 
  "Hello": "Anonymous" 
} 
$ curl http://localhost:5000/api --user alice:password 
{ 
  "Hello": "alice" 
} 
</code></pre>
    <p class="normal">Any data you may think of that's specific to a <code class="Code-In-Text--PACKT-">request</code> context, and that would be usefully shared throughout your code, can be added to <code class="Code-In-Text--PACKT-">quart.g</code>.</p>
    <h2 id="_idParaDest-48" class="title">Signals</h2>
    <p class="normal">Sometimes in<a id="_idIndexMarker120"/> an application, we want to send a message from one place to another, when components are not directly connected. One way in which we can send <a id="_idIndexMarker121"/>such messages is to use signals. Quart integrates with <code class="Code-In-Text--PACKT-">Blinker</code> (<a href="https://pythonhosted.org/blinker/">https://pythonhosted.org/blinker/</a>), which is a signal library that lets you subscribe a function to an event.</p>
    <p class="normal">Events are instances of the <code class="Code-In-Text--PACKT-">AsyncNamedSignal</code> class, which is based on the <code class="Code-In-Text--PACKT-">blinker.base.NamedSignal</code> class. It is created with a unique label, and Quart instantiates 10 of them in version 0.13. Quart triggers signals at critical moments during the processing of a request. Since <code class="Code-In-Text--PACKT-">Quart</code> and <code class="Code-In-Text--PACKT-">Flask</code> use the same system, we can refer to the following full list: <a href="http://flask.pocoo.org/docs/latest/api/#core-signals-list">http://flask.pocoo.org/docs/latest/api/#core-signals-list</a>.</p>
    <p class="normal">Registering to a particular event is done by calling the signal's <code class="Code-In-Text--PACKT-">connect</code> method. Signals are triggered when some code calls the signal's <code class="Code-In-Text--PACKT-">send</code> method. The <code class="Code-In-Text--PACKT-">send</code> method accepts extra arguments to pass data to all the registered functions.</p>
    <p class="normal">In the following example, we register the finished function to the <code class="Code-In-Text--PACKT-">request_finished</code> signal. That function<a id="_idIndexMarker122"/> will receive the <code class="Code-In-Text--PACKT-">response</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code"># signals.py
from quart import Quart, g, request_finished
from quart.signals import signals_available
app = Quart(__name__)
def finished(sender, response, **extra):
    print("About to send a Response")
    print(response)
request_finished.connect(finished)
@app.route("/api")
async def my_microservice():
    return {"Hello": "World"}
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">signal</code> feature is provided by <code class="Code-In-Text--PACKT-">Blinker</code>, which is installed by default as a dependency when you install <code class="Code-In-Text--PACKT-">Quart</code>.</p>
    <p class="normal">Some signals implemented in Quart are not useful in microservices, such as the ones occurring when the framework renders a template. However, there are some interesting signals that Quart triggers throughout the <code class="Code-In-Text--PACKT-">request</code> life, which can be used to log what's going on. For instance, the <code class="Code-In-Text--PACKT-">got_request_exception</code> signal is triggered when an exception occurs<a id="_idIndexMarker123"/> before the framework does something with it. That's how <strong class="keyword">Sentry</strong>'s (<a href="https://sentry.io">https://sentry.io</a>) Python client hooks itself in to log exceptions.</p>
    <p class="normal">It can also be interesting to implement custom signals in your apps when you want to trigger some of your features with events and decouple the code. For example, if your microservice produces PDF reports, and you want to have the reports cryptographically signed, you could trigger a <code class="Code-In-Text--PACKT-">report_ready</code> signal, and have a signer register to that event.</p>
    <p class="normal">One important aspect of the signals implementation is that the registered functions are not called in any particular order, and so if there are dependencies between the functions that get called, this may cause trouble. If you need to do more complex or time-consuming work, then <a id="_idIndexMarker124"/>consider using a <code class="Code-In-Text--PACKT-">queue</code> such as <strong class="keyword">RabbitMQ</strong> (<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a>) or one provided by a cloud platform such as Amazon Simple Queue Service or Google PubSub to send a message to another service. These message queues offer far more options than a basic signal and allow two components to communicate<a id="_idIndexMarker125"/> easily without even necessarily being on the same computer. We will cover an example of message queues in <em class="chapterRef">Chapter 6</em>, <em class="italic">Interacting with Other Services</em>.</p>
    <h2 id="_idParaDest-49" class="title">Extensions and middleware</h2>
    <p class="normal">Quart extensions<a id="_idIndexMarker126"/> are <a id="_idIndexMarker127"/>simply Python projects that, once installed, provide a package or a module named <code class="Code-In-Text--PACKT-">quart_something</code>. They can be useful for avoiding having to reinvent anything when wanting to do things such as authentication or sending an email.</p>
    <p class="normal">Because Quart can support some of the extensions available to <code class="Code-In-Text--PACKT-">Flask</code>, you can often find something to help in Flask's list of extensions: Search for <code class="Code-In-Text--PACKT-">Framework::Flask</code> in the Python package<a id="_idIndexMarker128"/> index at <a href="https://pypi.org/">https://pypi.org/</a>. To use <code class="Code-In-Text--PACKT-">Flask</code> extensions, you must first import a <code class="Code-In-Text--PACKT-">patch</code> module to ensure that it will work. For example, to import Flask's <code class="Code-In-Text--PACKT-">login</code> extension, use the following commands:</p>
    <pre class="programlisting code"><code class="hljs-code">import quart.flask_patch
import flask_login
</code></pre>
    <p class="normal">The most up-to-date list of Flask extensions that are known to work with Quart will be at the address below. This is a good place to start looking when searching for extra features that your microservice needs: <a href="http://pgjones.gitlab.io/quart/how_to_guides/flask_extensions.html">http://pgjones.gitlab.io/quart/how_to_guides/flask_extensions.html</a>.</p>
    <p class="normal">The other mechanism for extending Quart is to use ASGI or WSGI middleware. These extend the application by wrapping themselves around an endpoint and changing the data that goes in and comes out again.</p>
    <p class="normal">In the example that follows, the middleware fakes an <code class="Code-In-Text--PACKT-">X-Forwarded-For</code> header, so the Quart application thinks it's behind a proxy such as <code class="Code-In-Text--PACKT-">nginx</code>. This is useful in a testing environment when you want to make sure your application behaves properly when it tries to get the remote IP address, since the <code class="Code-In-Text--PACKT-">remote_addr</code> attribute will get the IP of the proxy, and not the real client. In this example, we have to create a new <code class="Code-In-Text--PACKT-">Headers</code> object, as the existing one is immutable:</p>
    <pre class="programlisting code"><code class="hljs-code"># middleware.py
from quart import Quart, request
from werkzeug.datastructures import Headers
class XFFMiddleware:
    def __init__(self, app, real_ip="10.1.1.1"):
        self.app = app
        self.real_ip = real_ip
    async def __call__(self, scope, receive, send):
        if "headers" in scope and "HTTP_X_FORWARDED_FOR" not in scope["headers"]:
            new_headers = scope["headers"].raw_items() + [
                (
                    b"X-Forwarded-For",
                    f"{self.real_ip}, 10.3.4.5, 127.0.0.1".encode(),
                )
            ]
            scope["headers"] = Headers(new_headers)
        return await self.app(scope, receive, send)
app = Quart(__name__)
app.asgi_app = XFFMiddleware(app.asgi_app)
@app.route("/api")
def my_microservice():
    if "X-Forwarded-For" in request.headers:
        ips = [ip.strip() for ip in request.headers["X-Forwarded-For"].split(",")]
        ip = ips[0]
    else:
        ip = request.remote_addr
    return {"Hello": ip}
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">Notice <a id="_idIndexMarker129"/>that <a id="_idIndexMarker130"/>we use <code class="Code-In-Text--PACKT-">app.asgi_app</code> here to wrap the ASGI application. <code class="Code-In-Text--PACKT-">app.asgi_app</code> is where the application is stored to let people wrap it in this way. The <code class="Code-In-Text--PACKT-">send</code> and <code class="Code-In-Text--PACKT-">receive</code> parameters are channels through which we can communicate. It's worth remembering that if the middleware returns a response to the client, then the rest of the <code class="Code-In-Text--PACKT-">Quart</code> app will never see the request!</p>
    <p class="normal">In most situations, we won't have to write our own middleware, and it will be enough to include<a id="_idIndexMarker131"/> an <a id="_idIndexMarker132"/>extension to add a feature that someone else has produced.</p>
    <h2 id="_idParaDest-50" class="title">Templates</h2>
    <p class="normal">Sending back JSON <a id="_idIndexMarker133"/>or YAML documents is easy enough, as we have seen in the examples so far. It's also true that most microservices produce machine-readable data and if a human needs to read it, the frontend must format it properly, using, for example, JavaScript on a web page. In some cases, though, we might need to create documents with some layout, whether it's an HTML page, a PDF report, or an email.</p>
    <p class="normal">For anything that's text-based, Quart integrates<a id="_idIndexMarker134"/> a template engine called <strong class="keyword">Jinja</strong> (<a href="https://jinja.palletsprojects.com/">https://jinja.palletsprojects.com/</a>). You will often find examples showing Jinja being used to create HTML documents, but it works with any text-based document. Configuration management tools such as Ansible use Jinja to create configuration files from a template so that a computer's settings can be kept up to date automatically.</p>
    <p class="normal">Most of the time, Quart will use Jinja to produce HTML documents, email messages, or some other piece of communication meant for a human—such as an SMS message or a bot that talks to people on tools such as Slack or Discord. Quart provides helpers such as <code class="Code-In-Text--PACKT-">render_template</code>, which generate responses by picking a Jinja template, and provides the output given some data.</p>
    <p class="normal">For example, if your microservice sends emails instead of relying on the standard library's email package to produce the email content, which can be cumbersome, you could use Jinja. The following example email template should be saved as <code class="Code-In-Text--PACKT-">email_template.j2</code> in order for the later code examples to work:</p>
    <pre class="programlisting code"><code class="hljs-code">Date: {{date}} 
From: {{from}} 
Subject: {{subject}} 
To: {{to}} 
Content-Type: text/plain 
 
Hello {{name}}, 
 
We have received your payment! 
 
Below is the list of items we will deliver for lunch: 
 
{% for item in items %}- {{item['name']}} ({{item['price']}} Euros) 
{% endfor %} 
 
Thank you for your business! 
 
-- 
My Fictional Burger Place
</code></pre>
    <p class="normal">Jinja uses double brackets for marking variables that will be replaced by a value. Variables can be anything that is passed to Jinja at execution time. You can also use Python's <code class="Code-In-Text--PACKT-">if</code> and <code class="Code-In-Text--PACKT-">for</code> blocks directly in your templates with the <code class="Code-In-Text--PACKT-">{% for x in y % }... {% endfor %}</code> and <code class="Code-In-Text--PACKT-">{% if x %}...{% endif %}</code> notations.</p>
    <p class="normal">The following is a Python <a id="_idIndexMarker135"/>script that uses the email template to produce an entirely valid <code class="Code-In-Text--PACKT-">RFC 822</code> message, which you can send via SMTP:</p>
    <pre class="programlisting code"><code class="hljs-code"># email_render.py
from datetime import datetime
from jinja2 import Template
from email.utils import format_datetime
def render_email(**data):
    with open("email_template.j2") as f:
        template = Template(f.read())
    return template.render(**data)
data = {
    "date": format_datetime(datetime.now()),
    "to": "bob@example.com",
    "from": "shopping@example-shop.com",
    "subject": "Your Burger order",
    "name": "Bob",
    "items": [
        {"name": "Cheeseburger", "price": 4.5},
        {"name": "Fries", "price": 2.0},
        {"name": "Root Beer", "price": 3.0},
    ],
}
print(render_email(**data))
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">render_email</code> function uses the <code class="Code-In-Text--PACKT-">Template</code> class to generate the email using the data provided.</p>
    <p class="normal">Jinja is a powerful tool and comes with many features that would take too much space to describe here. If you need to do some templating work in your microservices, it is a good choice, also<a id="_idIndexMarker136"/> being present in Quart. Check out the following for<a id="_idIndexMarker137"/> full documentation on Jinja's features: <a href="https://jinja.palletsprojects.com/">https://jinja.palletsprojects.com/</a>.</p>
    <h2 id="_idParaDest-51" class="title">Configuration</h2>
    <p class="normal">When building <a id="_idIndexMarker138"/>applications, you will need to expose options to run them, such as the information needed to connect to a database, the contact email address to use, or any other variable that is specific to a deployment.</p>
    <p class="normal">Quart uses a mechanism similar to Django in its configuration approach. The <code class="Code-In-Text--PACKT-">Quart</code> object comes with an object called <code class="Code-In-Text--PACKT-">config</code>, which contains some built-in variables, and which can be updated when you start your <code class="Code-In-Text--PACKT-">Quart</code> app via your configuration objects. For example, you can define a <code class="Code-In-Text--PACKT-">Config</code> class in a Python-format file as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># prod_settings.py
class Config:
    DEBUG = False
    SQLURI = "postgres://username:xxx@localhost/db"
</code></pre>
    <p class="normal">It can then be loaded from your <code class="Code-In-Text--PACKT-">app</code> object using <code class="Code-In-Text--PACKT-">app.config.from_object</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from quart import Quart
&gt;&gt;&gt; import pprint
&gt;&gt;&gt; pp = pprint.PrettyPrinter(indent=4)
&gt;&gt;&gt; app = Quart(__name__) 
&gt;&gt;&gt; app.config.from_object('prod_settings.Config') 
&gt;&gt;&gt; pp.pprint(app.config) 
{   'APPLICATION_ROOT': None,
    'BODY_TIMEOUT': 60,
    'DEBUG': False,
    'ENV': 'production',
    'JSONIFY_MIMETYPE': 'application/json',
    'JSONIFY_PRETTYPRINT_REGULAR': False,
    'JSON_AS_ASCII': True,
    'JSON_SORT_KEYS': True,
    'MAX_CONTENT_LENGTH': 16777216,
    'PERMANENT_SESSION_LIFETIME': datetime.timedelta(days=31),
    'PREFER_SECURE_URLS': False,
    'PROPAGATE_EXCEPTIONS': None,
    'RESPONSE_TIMEOUT': 60,
    'SECRET_KEY': None,
    'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(seconds=43200),
    'SERVER_NAME': None,
    'SESSION_COOKIE_DOMAIN': None,
    'SESSION_COOKIE_HTTPONLY': True,
    'SESSION_COOKIE_NAME': 'session',
    'SESSION_COOKIE_PATH': None,
    'SESSION_COOKIE_SAMESITE': None,
    'SESSION_COOKIE_SECURE': False,
    'SESSION_REFRESH_EACH_REQUEST': True,
    'SQLURI': 'postgres://username:xxx@localhost/db',
    'TEMPLATES_AUTO_RELOAD': None,
    'TESTING': False,
    'TRAP_HTTP_EXCEPTIONS': False}
</code></pre>
    <p class="normal">However, there are<a id="_idIndexMarker139"/> two significant drawbacks when using Python modules as configuration files. Firstly, since these configuration modules are Python files, it can be tempting to add code to them as well as simple values. By doing so, you will have to treat those modules like the rest of the application code; this can be a complicated way to ensure that it always produces the right value, especially if the configuration is produced with a template! Usually, when an application is deployed, the configuration is managed separately from the code.</p>
    <p class="normal">Secondly, if another team is in charge of managing the configuration file of your application, they will need to edit the Python code to do so. While this is usually fine, it makes it increase the chance that some problems will be introduced, as it assumes that the other people are familiar with Python and how your application is structured. It is often good practice to make sure that someone who just needs to change the configuration doesn't also need to know how the code works.</p>
    <p class="normal">Since Quart exposes its configuration via <code class="Code-In-Text--PACKT-">app.config</code>, it is quite simple to load additional options from a JSON, YAML, or other popular text-based configuration formats. All of the following examples are equivalent:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from quart import Quart
&gt;&gt;&gt; import yaml
&gt;&gt;&gt; from pathlib import Path 
&gt;&gt;&gt; app = Quart(__name__)
&gt;&gt;&gt; print(Path("prod_settings.json").read_text())
{
    "DEBUG": false,
    "SQLURI":"postgres://username:xxx@localhost/db"
} 
&gt;&gt;&gt; app.config.from_json("prod_settings.json")
&gt;&gt;&gt; app.config["SQLURI"]
'postgres://username:xxx@localhost/db'
&gt;&gt;&gt; print(Path("prod_settings.yml").read_text())
---
DEBUG: False
SQLURI: "postgres://username:xxx@localhost/db"
&gt;&gt;&gt; app.config.from_file("prod_settings.yml", yaml.safe_load)
</code></pre>
    <p class="normal">You can<a id="_idIndexMarker140"/> give <code class="Code-In-Text--PACKT-">from_file</code> a function to use to understand the data, such as <code class="Code-In-Text--PACKT-">yaml.safe_load</code>, <code class="Code-In-Text--PACKT-">toml.load</code>, and <code class="Code-In-Text--PACKT-">json.load</code>. If you prefer the INI format with <code class="Code-In-Text--PACKT-">[sections]</code> along with <code class="Code-In-Text--PACKT-">name = value</code>, then many extensions exist to help, and the standard library's <code class="Code-In-Text--PACKT-">ConfigParser</code> is also straightforward.</p>
    <h2 id="_idParaDest-52" class="title">Blueprints</h2>
    <p class="normal">When you write <a id="_idIndexMarker141"/>microservices that have more than a single endpoint, you will end up with a number of different decorated functions—remember those are functions with a decorator above, such as <code class="Code-In-Text--PACKT-">@app.route</code>. The first logical step to organize your code is to have one module per endpoint, and when you create your app instance, make sure they get imported so that Quart registers the views.</p>
    <p class="normal">For example, if your microservice manages a company's employees database, you could have one endpoint to interact with all employees, and one with teams. You could organize your application into these three modules:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">app.py</code>: To contain the <code class="Code-In-Text--PACKT-">Quart</code> app object, and to run the app</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">employees.py</code>: To provide all the views related to employees</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">teams.py</code>: To provide all the views related to teams</li>
    </ul>
    <p class="normal">From there, employees and teams can be seen as a subset of the app, and might have a few specific utilities and configurations. This is a standard way of structuring any Python application.</p>
    <p class="normal">Blueprints take this logic a step further by providing a way to group your views into namespaces, making the structure used in separate files and giving it some special framework assistance. You can create a <code class="Code-In-Text--PACKT-">Blueprint</code> object that looks like a <code class="Code-In-Text--PACKT-">Quart</code> app object, and then use it to arrange some views. The initialization process can then register blueprints with <code class="Code-In-Text--PACKT-">app.register_blueprint</code> to make sure that all the views defined in the blueprint are part of the app. A possible implementation of the employee's<a id="_idIndexMarker142"/> blueprint could be as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># blueprints.py
from quart import Blueprint
teams = Blueprint("teams", __name__)
_DEVS = ["Alice", "Bob"]
_OPS = ["Charles"]
_TEAMS = {1: _DEVS, 2: _OPS}
@teams.route("/teams")
def get_all():
    return _TEAMS
@teams.route("/teams/&lt;int:team_id&gt;")
def get_team(team_id):
    return _TEAMS[team_id]
</code></pre>
    <p class="normal">The main module (<code class="Code-In-Text--PACKT-">app.py</code>) can then import this file, and register its blueprint with <code class="Code-In-Text--PACKT-">app.register_blueprint(teams)</code>. This mechanism is also interesting when you want to reuse a generic set of views in another application or several times in the same application—it's easy to imagine a situation where, for example, both the inventory management area and a sales area might want to have the same ability to look at current stock levels.</p>
    <h2 id="_idParaDest-53" class="title">Error handling</h2>
    <p class="normal">When something <a id="_idIndexMarker143"/>goes wrong in your application, it is important to be able to control what responses the clients will receive. In HTML web apps, you usually get specific HTML pages when you encounter a <code class="Code-In-Text--PACKT-">404</code> (Resource not found) or <code class="Code-In-Text--PACKT-">5xx</code> (Server error), and that's how Quart works out of the box. But when building microservices, you need to have more control of what should be sent back to the client—that's where custom error handlers are useful.</p>
    <p class="normal">The other important feature is the ability to debug your code when an unexpected error occurs; Quart comes <a id="_idIndexMarker144"/>with a built-in debugger, which can be activated when your app runs in debug mode.</p>
    <h3 id="_idParaDest-54" class="title">Custom error handler</h3>
    <p class="normal">When your code <a id="_idIndexMarker145"/>does not handle an exception, Quart returns an HTTP <code class="Code-In-Text--PACKT-">500</code> response without providing any specific information, like the traceback. Producing a generic error is a safe default behavior to avoid leaking any private information to users in the body of the error. The default <code class="Code-In-Text--PACKT-">500</code> response is a simple HTML page along with the right status code:</p>
    <pre class="programlisting con"><code class="hljs-con">$ curl http://localhost:5000/api 
&lt;!doctype html&gt;
&lt;title&gt;500 Internal Server Error&lt;/title&gt;
&lt;h1&gt;Internal Server Error&lt;/h1&gt;
Server got itself in trouble
</code></pre>
    <p class="normal">When implementing microservices using JSON, it is good practice to make sure that every response sent to clients, including any exception, is JSON-formatted. Consumers of your microservice will expect every response to be machine-parseable. It's far better to tell a client that you had an error and have it set up to process that message and show it to a human than to give a client something it doesn't understand and have it raise its own errors.</p>
    <p class="normal">Quart lets you customize the app error handling via a couple of functions. The first one is the <code class="Code-In-Text--PACKT-">@app.errorhandler</code> decorator, which works like <code class="Code-In-Text--PACKT-">@app.route</code>. But instead of providing an endpoint, the decorator links a function to a specific error code.</p>
    <p class="normal">In the following example, we use it to connect a function that will return a JSON-formatted error when Quart returns a <code class="Code-In-Text--PACKT-">500</code> server response (any code exception):</p>
    <pre class="programlisting code"><code class="hljs-code"># error_handler.py
from quart import Quart
app = Quart(__name__)
@app.errorhandler(500)
def error_handling(error):
    return {"Error": str(error)}, 500
@app.route("/api")
def my_microservice():
    raise TypeError("Some Exception")
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">Quart will call this error view no matter what exception the code raises. However, in case your application issues an HTTP <code class="Code-In-Text--PACKT-">404</code> or any other <code class="Code-In-Text--PACKT-">4xx</code> or <code class="Code-In-Text--PACKT-">5xx</code> response, you will be back to the default HTML responses that Quart sends. To make sure your app sends JSON for <a id="_idIndexMarker146"/>every <code class="Code-In-Text--PACKT-">4xx</code> and <code class="Code-In-Text--PACKT-">5xx</code> response, we need to register that function to each error code.</p>
    <pre>error_handling </code>function to every error using <code class="Code-In-Text--PACKT-">app.register_error_handler</code>, which is similar to the <code class="Code-In-Text--PACKT-">@app.errorhandler</code> decorator:</pre>
    <pre class="programlisting code"><code class="hljs-code"># catch_all_errors.py
from quart import Quart, jsonify, abort
from werkzeug.exceptions import HTTPException, default_exceptions
def jsonify_errors(app):
    def error_handling(error):
        if isinstance(error, HTTPException):
            result = {
                "code": error.code,
                "description": error.description,
                "message": str(error),
            }
        else:
            description = abort.mapping[ error.code].description
            result = {"code":  error.code, "description": description, "message": str(error)}
        resp = jsonify(result)
        resp.status_code = result["code"]
        return resp
    for code in default_exceptions.keys():
        app.register_error_handler(code, error_handling)
    return app
app = Quart(__name__)
app = jsonify_errors(app)
@app.route("/api")
def my_microservice():
   raise TypeError("Some Exception")
if __name__ == "__main__":
    app.run()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">jsonify_errors</code> function <a id="_idIndexMarker147"/>modifies a <code class="Code-In-Text--PACKT-">Quart</code> app instance and sets up the custom JSON error handler for every <code class="Code-In-Text--PACKT-">4xx</code> and <code class="Code-In-Text--PACKT-">5xx</code> error that might occur.</p>
    <h1 id="_idParaDest-55" class="title">A microservice skeleton</h1>
    <p class="normal">So far in <a id="_idIndexMarker148"/>this chapter, we have looked at how Quart works, and at most of the built-in features it provides—all of which we will be using throughout this book. One topic we have not yet covered is how to organize the code in your projects, and how to instantiate your <code class="Code-In-Text--PACKT-">Quart</code> app. Every example so far has used a single Python module and the <code class="Code-In-Text--PACKT-">app.run()</code> call to run the service.</p>
    <p class="normal">Having everything in a module is possible, but will create a lot of headaches unless your code is just a few lines. Since we will want to release and deploy the code, it's better to have it inside a Python package so that we can use standard packaging tools such as <code class="Code-In-Text--PACKT-">pip</code> and <code class="Code-In-Text--PACKT-">setuptools</code>.</p>
    <p class="normal">It is also a good idea to organize views into blueprints, and have one module per blueprint. This lets us keep better track of what each bit of code does, and re-use code whenever possible.</p>
    <p class="normal">Lastly, the <code class="Code-In-Text--PACKT-">run()</code> call can be removed from the code since Quart provides a generic run command that looks for an application using information from the <code class="Code-In-Text--PACKT-">QUART_APP</code> environment variable. Using that runner offers extra options, such as the ability to configure the host and port that will be used to run the app without going into the settings each time.</p>
    <p class="normal">The microservice project on GitHub was created for this book and is a generic Quart project that you can use to start a microservice. It implements a simple layout, which works well for building microservices. You can install and run, and then modify it. The project can be found at <a href="https://github.com/PythonMicroservices/microservice-skeleton">https://github.com/PythonMicroservices/microservice-skeleton</a>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">microservice</code> project skeleton contains the following structure:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">setup.py</code>: Distutils' setup file, which is used to install and release the project.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">Makefile</code>: A Makefile that contains a few useful targets to make, build, and run the project.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">settings.yml</code>: The application default settings in a YAML file.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">requirements.txt</code>: The project dependencies following the <code class="Code-In-Text--PACKT-">pip</code> format produced by <code class="Code-In-Text--PACKT-">pip freeze</code>.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">myservices/</code>: The <a id="_idIndexMarker149"/>actual package<ul>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">__init__.py</code></li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">app.py</code>: The app module, which contains the app itself</li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">views/</code>: A directory containing the views organized in blueprints
          <ul>
            <li class="bullet-l2"><code class="Code-In-Text--PACKT-">__init__.py</code></li>
            <li class="bullet-l2"><code class="Code-In-Text--PACKT-">home.py</code>: The home blueprint, which serves the root endpoint</li>
          </ul></li>
          <li class="bullet-l2">
            <code class="Code-In-Text--PACKT-">tests/:</code> The directory containing all the tests
          
          <ul>
            <li class="bullet-l2"><code class="Code-In-Text--PACKT-">__init__.py</code></li>
            <li class="bullet-l2"><code class="Code-In-Text--PACKT-">test_home.py</code>: Tests for the home blueprint views</li>
          </ul></li>
        </ul>
      </li>
    </ul>
    <p class="normal">In the following code, the <code class="Code-In-Text--PACKT-">app.py</code> file instantiates a <code class="Code-In-Text--PACKT-">Quart</code> app using a helper function called <code class="Code-In-Text--PACKT-">create_app</code> to register the blueprints and update the settings:</p>
    <pre class="programlisting code"><code class="hljs-code">import os
from myservice.views import blueprints
from quart import Quart
_HERE = os.path.dirname(__file__)
_SETTINGS = os.path.join(_HERE, "settings.ini")
def create_app(name=__name__, blueprints=None, settings=None):
    app = Quart(name)
    # load configuration
    settings = os.environ.get("QUART_SETTINGS", settings)
    if settings is not None:
        app.config.from_pyfile(settings)
    # register blueprints
    if blueprints is not None:
        for bp in blueprints:
            app.register_blueprint(bp)
    return app
app = create_app(blueprints=blueprints, settings=_SETTINGS)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">home.py</code> view uses a <a id="_idIndexMarker150"/>blueprint to create a simple route that doesn't return anything:</p>
    <pre class="programlisting code"><code class="hljs-code">from quart import Blueprint
home = Blueprint("home", __name__)
@home.route("/")
def index():
    """Home view.
    This view will return an empty JSON mapping.
    """
    return {}
</code></pre>
    <p class="normal">This example application can run via Quart's built-in command line, using the package name:</p>
    <pre class="programlisting con"><code class="hljs-con">$ QUART_APP=myservice quart run
 * Serving Quart app 'myservice.app'
 * Environment: production
 * Please use an ASGI server (e.g. Hypercorn) directly in production
 * Debug mode: False
 * Running on http://localhost:5000 (CTRL + C to quit)
[2020-12-06 20:17:28,203] Running on http://127.0.0.1:5000 (CTRL + C to quit)
</code></pre>
    <p class="normal">From there, building JSON views for your microservice consists of adding modules to microservices/views, and their corresponding tests.</p>
    <h1 id="_idParaDest-56" class="title">Summary</h1>
    <p class="normal">This chapter gave us a detailed overview of the Quart framework and how it can be used to build microservices. The main things to remember are:</p>
    <ul>
      <li class="bullet">Quart wraps a simple request-response mechanism around the ASGI protocol, which lets you write your applications in almost vanilla Python.</li>
      <li class="bullet">Quart is easy to extend and can use Flask extensions if required.</li>
      <li class="bullet">Quart comes with some useful built-in features: blueprints, globals, signals, a template engine, and error handlers.</li>
      <li class="bullet">The microservice project is a Quart skeleton, which will be used to write microservices throughout this book. </li>
    </ul>
    <p class="normal">The next chapter will focus on development methodology: how to continuously code, test, and document your microservices.</p>
  </div>
</body></html>