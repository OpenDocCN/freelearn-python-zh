- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Testing and TDD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和TDD
- en: No matter how good a developer is, they'll write code that doesn't always perform
    correctly. This is unavoidable, as no developer is perfect. But it's also because
    the expected results are sometimes not the ones that one would think of while
    immersed in coding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论开发者多么优秀，他们都会编写出不一定总是正确执行的代码。这是不可避免的，因为没有任何开发者是完美的。但这也因为预期的结果有时并不是在编码过程中会想到的。
- en: Designs rarely go as expected and there's always a discussion going back and
    forth while they are being implemented, until refining them and getting them correct.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计很少按预期进行，在实施过程中总会有来回讨论，直到它们被精炼并变得正确。
- en: Everyone has a plan until they get punched in the mouth. – Mike Tyson
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个人都有自己的计划，直到他们被打得满嘴是血。 —— 迈克·泰森
- en: Writing software is notoriously difficult because of its extreme plasticity,
    but at the same time, we can use software to double-check that the code is doing
    what it is supposed to do.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件因其极端的灵活性而闻名地困难，但与此同时，我们可以使用软件来双重检查代码是否正在执行其应有的操作。
- en: Be aware that, as with any other code, tests can have bugs as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，就像任何其他代码一样，测试也可能有错误。
- en: Writing tests allows you to detect problems while the code is fresh and with
    some sane skepticism to verify that the expected results are the actual results.
    We will see during the chapter how to write tests easily, as well as different
    strategies to write different tests for capturing different kinds of problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试可以在代码新鲜时检测到问题，并带有一些合理的怀疑来验证预期的结果是否是实际的结果。在本章中，我们将看到如何轻松编写测试，以及不同的策略来编写不同类型的测试，以捕获不同种类的问题。
- en: We will describe how to work under TDD, a methodology that works by defining
    the tests first, to ensure that the validation is as independent of the actual
    code implementation as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述如何在TDD（测试驱动开发）下工作，这是一种通过首先定义测试来确保验证尽可能独立于实际代码实现的方法。
- en: We will also show how to create tests in Python using common unit test frameworks,
    the standard `unittest` module, and the more advanced and powerful `pytest`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将展示如何使用常见的单元测试框架、标准`unittest`模块以及更高级和强大的`pytest`在Python中创建测试。
- en: Note this chapter is a bit longer than others, mostly due to the need to present
    example code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章比其他章节要长一些，主要是因为需要展示示例代码。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing the code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码
- en: Different levels of testing
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的测试级别
- en: Testing philosophy
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试哲学
- en: Test-Driven Development
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Introduction to unit testing in Python
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python单元测试简介
- en: Testing external dependencies
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试外部依赖
- en: Advanced pytest
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级pytest
- en: Let's start with some basic concepts about testing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些关于测试的基本概念开始。
- en: Testing the code
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'The first question when discussing testing the code is a simple one: What exactly
    do we mean by testing the code?'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论代码测试时的第一个问题很简单：我们究竟指的是什么测试代码？
- en: While there are multiple answers to that, in the broadest sense, the answer
    could be "*any procedure that probes the application to check that it works correctly
    before it reaches the final customers.*" In this sense, any formal or informal
    testing procedure will fulfil the definition.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对此有多种答案，但从最广泛的意义上讲，答案可能是“*任何在最终客户到达之前检查应用程序是否正确工作的程序。*”在这个意义上，任何正式或非正式的测试程序都将满足定义。
- en: The most relaxed approach, which is sometimes seen in small applications with
    one or two developers, is to not create specific tests but to do informal "full
    application runs" checking that a newly implemented feature works as expected.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最轻松的方法，有时在只有一个或两个开发者的小型应用程序中可以看到，就是不去创建特定的测试，而是进行非正式的“完整应用程序运行”，检查新实现的功能是否按预期工作。
- en: This approach may work for small, simple applications, but the main problem
    is ensuring that older features remain stable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能适用于小型、简单的应用程序，但主要问题是确保旧功能保持稳定。
- en: 'But, for high-quality software that is big and complex enough, we need to be
    a bit more careful about the testing. So, let''s try to come up with a more precise
    definition of testing: *Testing is any documented procedure, preferably automated,
    that, from a known setup, checks the different elements of the application work
    correctly before it reaches the final customers.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于大型且复杂的、高质量的软件，我们需要对测试更加小心。所以，让我们尝试给出一个更精确的测试定义：*测试是任何记录在案的程序，最好是自动化的，它从一个已知的设置出发，检查应用程序的不同元素在到达最终客户之前是否正确工作。*
- en: 'If we check the differences with the previous definition, there are several
    key words. Let''s check each of them to see the different details:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将与之前定义的差异进行检查，有几个关键词。让我们逐一检查它们，看看不同的细节：
- en: '**Documented**: Compared with the previous version, the aim should be that
    the tests are documented. This allows you to reproduce them precisely if necessary
    and allows you to compare them to discover blind spots.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已记录的**：与之前的版本相比，目标应该是测试应该被记录下来。这样，如果需要的话，你可以精确地重新执行它们，并且可以比较它们以发现盲点。'
- en: There are multiple ways that a test can be documented, either by specifying
    a list of steps to run and expected results or by creating code that runs the
    test. The main idea is that a test can be analyzed, be run several times by different
    people, be changed if necessary, and have a clear design and result.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试可以有多种记录方式，要么指定要运行的步骤和预期结果列表，要么创建运行测试的代码。主要思想是测试可以被分析，可以被不同的人多次运行，如果需要的话可以更改，并且有一个清晰的设计和结果。
- en: '**Preferably automated**:Testsshould be able to be run automatically, with
    as little human intervention as possible. This allows you to trigger Continuous
    Integration techniques to run many tests over and over, creating a "safety net"
    that is able to catch unexpected errors as early as possible. We say "preferably"
    because perhaps some tests are impossible or very costly to totally automate.
    In any case, the objective should be to have the vast majority of tests automated,
    to allow computers to do the heavy lifting and save precious human time. There
    are also multiple software tools that allow you to run tests, which can help.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最好是自动化的**：测试应该能够自动运行，尽可能减少人为干预。这允许你触发持续集成技术，反复运行许多测试，创建一个“安全网”，能够尽早捕捉到意外错误。我们说“最好是”是因为也许有些测试是完全不可能或非常昂贵的自动化。无论如何，目标应该是让绝大多数测试自动化，让计算机承担繁重的工作，节省宝贵的人类时间。也有多种软件工具可以帮助你运行测试。'
- en: '**From a known setup**: To be able to run tests in isolation, we need to know
    what the status of the system should be before running the test. That ensures
    that the result of a test will not create a certain state that could interfere
    with the next test. Before and after a test, certain cleanup may be required.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从已知设置开始**：为了能够独立运行测试，我们需要知道在运行测试之前系统的状态应该是什么。这确保了测试的结果不会创建一个可能会干扰下一个测试的特定状态。在测试前后，可能需要进行一些清理工作。'
- en: This can make running tests in batches slower, compared with not worrying about
    the initial or end status, but it will create a solid foundation to avoid problems.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与不考虑初始或最终状态相比，这可能会使批量运行测试的速度变慢，但它将创建一个坚实的基础，以避免问题。
- en: As a general rule, and especially in automated tests, the order in which the
    tests are executed should be irrelevant, to avoid cross-contamination. This is
    easier said than done, and in some cases, the order of tests can create problems.
    For example, test A creates an entry that test B reads. If test B is run in isolation,
    it will fail as it expects the entry created by A. These cases should be fixed,
    as they can greatly complicate debugging. Also, being able to run tests independently
    allows them to be parallelized.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，尤其是在自动化测试中，测试执行的顺序应该是无关紧要的，以避免交叉污染。这说起来容易做起来难，在某些情况下，测试的顺序可能会造成问题。例如，测试A创建了一个条目，测试B读取。如果测试B单独运行，它将失败，因为它期望A创建的条目。这些情况应该得到修复，因为它们可能会极大地复杂化调试。此外，能够独立运行测试也允许它们并行化。
- en: '**Different elements of the application**: Most tests should not address the
    whole application, but smaller parts of it. We will talk more later about the
    different levels of testing, but tests should be specific about what are they
    testing and cover different elements, as tests covering more ground will be costlier.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序的不同元素**：大多数测试不应该针对整个应用程序，而应该针对其较小的部分。我们稍后会更多地讨论不同的测试级别，但测试应该具体说明它们正在测试什么，并覆盖不同的元素，因为覆盖更多范围的测试将更昂贵。'
- en: A key element of testing is to have a good return on investment. Designing and
    running tests takes time, and that time needs to be well spent. Any test needs
    to be maintained, which should be worth it. Over the whole chapter, we will be
    commenting on this important aspect of testing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一个关键要素是获得良好的投资回报率。设计和运行测试需要时间，这些时间需要被充分利用。任何测试都需要维护，这应该是值得的。在整个章节中，我们将讨论测试的这个重要方面。
- en: There's an important kind of testing that we are not covering with this definition,
    which is called *exploratory testing*. These tests are typically run by QA engineers,
    who use the final application without a clear preconceived idea but try to pre-emptively
    find problems. If the application has a customer-facing UI, this style of testing
    can be invaluable in detecting inconsistencies and problems that are not detected
    in the design phase.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种重要的测试类型我们没有在这个定义中涵盖，这被称为*探索性测试*。这些测试通常由质量保证工程师运行，他们使用最终应用程序而没有明确的先入之见，但试图预先发现问题。如果应用程序有一个面向客户的用户界面，这种测试风格在检测设计阶段未检测到的不一致和问题方面可能非常有价值。
- en: For example, a good QA engineer will be able to say that the color of a button
    on page X is not the same as the button on page Y, or that the button is not evident
    enough to perform an action, or that to perform a certain action there's a prerequisite
    that's not evident or possible with the new interface. Any **user experience**
    (**UX**) check will probably fall into this category.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个优秀的质量保证工程师能够说出页面X上的按钮颜色与页面Y上的按钮颜色不同，或者按钮不够明显以至于无法执行操作，或者执行某个特定操作有一个不明显或在新界面中不可能的前提条件。任何**用户体验**（**UX**）检查都可能属于这一类别。
- en: By its nature, this kind of testing cannot be "designed" or "documented," as
    it ultimately comes down to interpretation and a good eye to understand whether
    the application *feels correct*. Once a problem is detected, then it can be documented
    to be avoided.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这种测试不能“设计”或“文档化”，因为它最终取决于解释和良好的洞察力来理解应用程序是否“感觉正确”。一旦发现问题，就可以记录下来以避免。
- en: While this is certainly useful and recommended, this style of testing is more
    an art than an engineering practice and we won't be discussing it in detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实很有用且被推荐，但这种测试风格更多的是一种艺术而不是工程实践，我们不会详细讨论它。
- en: This general definition helps to start the discussion, but we can be more concrete
    about the different tests defined by how much of the system is under test, during
    each test.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一般定义有助于开始讨论，但我们可以更具体地讨论通过测试时系统受测试的部分来定义的不同测试。
- en: Different levels of testing
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的测试级别
- en: As we described before, tests should cover different elements of the system.
    This means that a test can address a small or big part of the system (or the whole
    system), trying to reduce its range of action.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所描述的，测试应该覆盖系统的不同元素。这意味着一个测试可以针对系统的小部分或大部分（或整个系统），试图缩小其作用范围。
- en: When testing a small part of the system, we reduce the complexity of the test
    and scope. We need to call only that small part of the system, and the setup is
    easier to start with. In general, the smaller the element to test, the faster
    and easier it is to test it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试系统的小部分时，我们减少了测试的复杂性和范围。我们只需要调用系统的那一小部分，并且设置更容易开始。一般来说，要测试的元素越小，测试的速度越快，越容易。
- en: 'We will define three different levels or kinds of tests, from small to big
    scopes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义三个不同级别或种类的测试，从小范围到大范围：
- en: '**Unit tests**, for tests that check only part of a service'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**，用于检查服务的一部分'
- en: '**Integration tests**, for tests that check a single service as a whole'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**，用于检查单个服务作为一个整体'
- en: '**System tests**, for tests that check multiple services working together'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**，用于检查多个服务协同工作的情况'
- en: Names can actually vary quite a lot. In this book, we won't be very strict with
    definitions, instead defining soft limits and suggesting finding a balance that
    works for your specific project. Don't be shy to take decisions on the proper
    level for each test and define your own nomenclature, and always keep in mind
    how much effort it takes to create tests to be sure that they are always worth
    it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 名称可能实际上有很大差异。在这本书中，我们不会对定义过于严格，而是定义软限制，并建议找到适合您特定项目的平衡点。不要害羞，对每个测试的适当级别做出决定，并定义自己的命名法，同时始终牢记创建测试所需的努力，以确保它们总是值得的。
- en: The definition of the levels can be a little blurred. For example, integration
    and unit tests can be defined side by side, and the difference between them could
    be more academic in that case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 级别的定义可能有些模糊。例如，集成测试和单元测试可以并列定义，在这种情况下，它们之间的区别可能更多地体现在学术上。
- en: Let's start describing each of the levels in more detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地描述每个级别的细节。
- en: Unit tests
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: The smallest kind of test is also the one where most effort is typically invested,
    the *unit test*. This kind of test checks the behavior of a small unit of code,
    not the whole system. This unit of code could be as small as a single function
    or test a single API endpoint, and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最小类型的测试也是通常投入最多努力的测试，即*单元测试*。这种测试检查的是一小段代码的行为，而不是整个系统。这个代码单元可能小到只是一个单个函数，或者测试一个单个API端点，等等。
- en: As we said above, there's a lot of debate on how big a unit test should actually
    be, based on what the "unit" is and whether it is actually a unit. For example,
    in some cases, people will only call a test a unit test if it involves a single
    function or class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面所说的，关于单元测试应该有多大，基于“单元”是什么以及它是否实际上是一个单元，存在很多争议。例如，在某些情况下，人们只有在测试涉及单个函数或类时才会将其称为单元测试。
- en: Because a unit test checks a small part of the functionality, it can be very
    easy to set up and quick to run. Therefore, making new unit tests is quick and
    can thoroughly test the system, checking that the small individual pieces that
    make the whole system work as expected.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单元测试检查的是功能的一个小部分，因此它可以非常容易地设置并快速运行。因此，创建新的单元测试既快又能够彻底测试系统，确保构成整个系统的小部分能够按预期工作。
- en: The objective of unit tests is to check in depth the behavior of a defined feature
    of a service. Any external requests or elements should be simulated, meaning that
    they are defined as part of the test. We will cover unit tests in more detail
    later in the chapter, as they are the key elements of the TDD approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目的是深入检查服务中定义的功能的行为。任何外部请求或元素都应该被模拟，这意味着它们被定义为测试的一部分。我们将在本章的后面更详细地介绍单元测试，因为它们是TDD方法的关键元素。
- en: Integration tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: The next level is the integration test. This is checking the whole behavior
    of a service or a couple of services.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个层次是集成测试。这是检查一个服务或几个服务的整体行为。
- en: The main goal of integration testing is to be sure that the different services
    or different modules inside the same service can work with each other. While in
    unit tests, external requests are simulated, integration tests use the real service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的主要目标是确保不同的服务或同一服务内的不同模块可以相互工作。在单元测试中，外部请求是模拟的，而集成测试使用的是真实的服务。
- en: The simulation of external APIs may still be required. For example, simulating
    an external payment provider for the tests. But, in general, as many real services
    should be used for integration tests as possible, as the point of the test is
    to test that the different services work together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可能仍然需要模拟外部API。例如，模拟外部支付提供者进行测试。但，总的来说，尽可能多地使用真实服务进行集成测试，因为测试的目的在于测试不同的服务是否能够协同工作。
- en: It's important to note that, commonly, different services will be developed
    by different developers or even different teams, and they can diverge in their
    understanding of how a particular API is implemented, even in the event of a well-defined
    spec.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，通常情况下，不同的服务将由不同的开发者或甚至不同的团队开发，他们对于特定API实现的理解可能会有所不同，即使在定义良好的规范下也是如此。
- en: The setup in integration tests is more complex than in unit tests, as more elements
    need to be properly set up. This makes integration tests slower and more expensive
    than unit tests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的设置比单元测试更复杂，因为需要正确设置更多的元素。这使得集成测试比单元测试更慢、更昂贵。
- en: Integration tests are great to check that different services work in unison,
    but there are some limitations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试非常适合检查不同的服务是否能够协同工作，但也有一些局限性。
- en: Integration tests are normally not as thorough as unit tests, focusing on checking
    basic functionality and following a *happy path*. A happy path is a concept in
    testing meaning that the test case should produce no errors or exceptions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常不如单元测试彻底，它们主要关注检查基本功能并遵循*快乐路径*。快乐路径是测试中的一个概念，意味着测试用例应该不会产生错误或异常。
- en: Expected errors and exceptions are normally tested in unit tests, since they
    are also elements that can fail. That doesn't mean that every single integration
    test should follow a happy path; some integration errors may be worth checking,
    but in general, a happy path tests the expected general behavior of the feature.
    They will compose the bulk of the integration tests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 预期错误和异常通常在单元测试中进行测试，因为它们也是可能失败的因素。但这并不意味着每个集成测试都应该遵循快乐路径；一些集成错误可能值得检查，但总的来说，快乐路径测试的是预期的通用行为。它们将构成大部分的集成测试。
- en: System tests
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试
- en: The final level is the system level. System tests check that all the different
    services work correctly together.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一级是系统级。系统测试检查所有不同的服务是否能够正确协同工作。
- en: A requirement for this kind of test is that there are actually multiple services
    in the system. If not, they are not different from tests at the lower levels.
    The main objective of these tests is to check that the different services can
    cooperate, and the configuration is correct.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这类测试的一个要求是系统中实际上存在多个服务。如果不是这样，它们与低级别的测试没有区别。这些测试的主要目标是检查不同的服务能否协同工作，并且配置是否正确。
- en: System tests are slow and difficult to implement. They require the whole system
    to be set up, with all the different services properly configured. Creating that
    environment can be complicated. Sometimes, it's so difficult that the only way
    of actually performing any system tests is to run them in the live environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试缓慢且难以实施。它们需要整个系统设置好，所有不同的服务都正确配置。创建这样的环境可能很复杂。有时，这太难了，唯一实际执行系统测试的方法是在实时环境中运行它们。
- en: The environment configuration is an important part of what these tests check.
    That may make them important to run on each environment that is under test, including
    the live environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 环境配置是这些测试检查的重要部分。这可能会使它们在测试每个环境时都变得很重要，包括实时环境。
- en: While this is not ideal, sometimes it is unavoidable and can help to improve
    confidence after deployments, to ensure that the new code is working correctly.
    In that case, given the constraints, only a minimum amount of tests should be
    run, as the live environment is critical. The tests to run should also exercise
    the maximum amount of common functionality and services to detect any critical
    problem as fast as possible. This set of tests is sometimes called *acceptance
    tests* or *smoke tests*. They may be run manually, as a way of ensuring that everything
    looks correct.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不理想，但有时这是不可避免的，并且有助于在部署后提高信心，确保新代码能够正确运行。在这种情况下，考虑到限制条件，应该只运行最少量的测试，因为实时环境至关重要。要运行的测试还应该测试最大量的常用功能和服务，以便尽可能快地检测到任何关键问题。这组测试有时被称为**验收测试**或**冒烟测试**。它们可以手动运行，作为一种确保一切看起来正确的手段。
- en: Of course, smoke tests can be run not only on the live environment and can work
    as a way to ensure that other environments are working correctly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，冒烟测试不仅可以在实时环境中运行，还可以作为一种确保其他环境正常工作的手段。
- en: Smoke tests should be very clear, well documented, and designed carefully to
    cover the most critical parts of the whole system. Ideally, they should also be
    read-only, so they don't leave useless data after their execution.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试应该非常清晰、有良好的文档记录，并且精心设计以涵盖整个系统的最关键部分。理想情况下，它们还应该是只读的，这样它们在执行后不会留下无用的数据。
- en: Testing philosophy
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试哲学
- en: 'A key element of everything involved with testing is another question: *Why
    test?* What are we trying to achieve with it?'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试相关的所有事情中的一个关键问题是：**为什么要测试？**我们试图通过它达到什么目标？
- en: As we've seen, testing is a way of ensuring that the behavior of the code is
    the expected one. The objective of testing is to detect possible problems (sometimes
    called *defects*) before the code is published and used by real users.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，测试是一种确保代码行为符合预期的方式。测试的目标是在代码发布和真实用户使用之前检测可能的问题（有时称为**缺陷**）。
- en: There's a subtle difference between *defects* and *bugs*. Bugs are a kind of
    defect where the software behaves in a way that it's not expected to. For example,
    certain input produces an unexpected error. Defects are more general. A defect
    could be that a button is not visible enough, or that the logo on a page is not
    the correct one. In general, tests are way better at detecting bugs than other
    defects, but remember what we said about exploratory testing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺陷**和**错误**之间有一个细微的差别。错误是一种缺陷，指的是软件的行为不符合预期。例如，某些输入会产生意外的错误。缺陷更为普遍。一个缺陷可能是指按钮不够明显，或者页面上显示的标志不是正确的。一般来说，测试在检测错误方面比检测其他缺陷更有效，但请记住我们之前提到的探索性测试。'
- en: A defect that goes undetected and gets deployed into a live system is pretty
    expensive to repair. First of all, it needs to be detected. In a live application
    with a lot of activity, detecting a problem can be difficult (though we will talk
    about it in *Chapter 16*, *Ongoing Architecture*), but even worse, it will normally
    be detected by a user of the system using the application. It's possible that
    the user won't properly communicate the problem back, so the problem is still
    present, creating problems or limiting activity. The detecting user might abandon
    the system, or at the very least their confidence in the system will decrease.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未被发现的缺陷被部署到实际系统中去修复的成本相当高。首先，它需要被发现。在一个活动频繁的实际应用中，发现问题可能很困难（尽管我们将在*第16章*，*持续架构*中讨论），但更糟糕的是，它通常是由使用该应用的用户检测到的。用户可能无法正确地传达问题，因此问题仍然存在，造成问题或限制活动。检测问题的用户可能会放弃系统，或者至少他们对系统的信心会下降。
- en: Any reputational cost will be bad, but it can also be difficult to extract enough
    information from the user to know exactly what happened and how to fix it. This
    makes the cycle between detecting the problem and fixing it long.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何声誉损失都将是不利的，但同时也可能很难从用户那里提取足够的信息来确切了解发生了什么以及如何修复它。这使得从发现问题到修复问题的周期变得很长。
- en: Any testing system will improve the ability to fix defects earlier. Not only
    can we create a specific test that simulates exactly the same problem, but we
    can also create a framework that executes tests regularly to have a clear approach
    to how to detect and fix problems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何测试系统都会提高早期修复缺陷的能力。我们不仅可以创建一个模拟确切相同问题的特定测试，还可以创建一个定期执行测试的框架，以明确的方法来检测和修复问题。
- en: Different testing levels have different effects on this cost. In general, any
    problem that can be detected at the unit test level is going to be cheaper to
    fix there, and the cost increases from there. Designing and running a unit test
    is easier and faster than doing the same with an integration test, and an integration
    test is cheaper than a system test.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的测试级别对这种成本有不同的影响。一般来说，任何可以在单元测试级别检测到的问题，在那里修复的成本都会更低，成本从那里开始增加。设计和运行单元测试比集成测试更容易、更快，而集成测试的成本比系统测试低。
- en: The different test levels could be understood as different layers capturing
    possible problems. Each layer will capture different problems if they appear.
    The closer to the start of the process (design and unit tests while coding), the
    cheaper it is to create a dense net that will detect and alert for problems. The
    cost of fixing a problem increases the farther away it is from the controlled
    environment at the start of the process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的测试级别可以理解为不同的层级，它们捕捉可能的问题。如果问题出现，每个层级都会捕捉不同的问题。越接近过程的开始（编码时的设计和单元测试），创建一个能够检测和警告问题的密集网络就越便宜。问题修复的成本随着它远离过程开始时的控制环境而增加。
- en: '![Diagram'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图解'
- en: Description automatically generated](img/B17580_10_01.png)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B17580_10_01.png)
- en: 'Figure 10.1: The cost of fixing defects increases the later they get detected'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：修复缺陷的成本随着发现时间的延迟而增加
- en: Some defects are impossible to detect at the unit test level, like the integration
    of different parts. That's where the next level comes into play. As we've seen,
    the worst scenario is not detecting a problem and it affecting real users on the
    live system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些缺陷在单元测试级别是无法检测到的，比如不同部分的集成。这就是下一个级别发挥作用的地方。正如我们所见，最糟糕的情况是没有发现问题，它影响了实际系统上的真实用户。
- en: But having tests is not only a good way of capturing problems once. Because
    a test can still remain, and be run on new code changes, it also creates a safety
    net while developing to be sure that creating new code or modifying the code does
    not affect the old functionality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但拥有测试不仅是一次捕捉问题的好方法。因为测试可以保留下来，并在新的代码更改上运行，它还在开发过程中提供了一个安全网，以确保创建新代码或修改代码不会影响旧功能。
- en: This is one of the best arguments for running tests automatically and constantly,
    as per Continuous Integration practices. The developer can focus on the feature
    being developed, while the Continuous Integration tool will run every test, alerting
    early if there's a problem with some test. A problem with previously introduced
    functionality that is failing is called a *regression*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最有力的论据之一，即按照持续集成实践自动和持续地运行测试。开发者可以专注于正在开发的功能，而持续集成工具将运行每个测试，如果某个测试出现问题，会提前警告。之前引入的功能出现问题而失败的称为*回归*。
- en: Regression problems are quite common, so having good test coverage is great
    to prevent them going undetected. Specific tests covering previous functionality
    to ensure that it keeps running as expected can be introduced. These are regression
    tests, and sometimes they are added after we have detected a regression problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 回归问题相当常见，因此拥有良好的测试覆盖率以防止它们未被检测到是非常好的。可以引入覆盖先前功能的特定测试，以确保它按预期运行。这些是回归测试，有时在检测到回归问题后添加。
- en: Another benefit of having good tests that check the behavior of the system is
    that the code itself can be changed heavily, knowing that the behavior will remain
    the same. These changes can be made to restructure the code, clean it, and in
    general improve it. These changes are called *refactoring* the code, changing
    how the code is written without changing the expected behavior of it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有良好的测试来检查系统的行为的好处之一是，代码本身可以大量更改，因为我们知道行为将保持不变。这些更改可以用来重构代码、清理它，并在一般情况下改进它。这些更改被称为*重构*代码，即在不改变代码预期行为的情况下改变代码的编写方式。
- en: Now, we should answer the question "what is a good test?" As we discussed, writing
    a test is not free, there's an effort involved, and we need to be sure that it's
    worth it. How can we create good ones?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该回答“什么是好的测试？”这个问题。正如我们讨论的，编写测试不是免费的，需要付出努力，我们需要确保它是值得的。我们如何创建好的测试？
- en: How to design a great test
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何设计一个优秀的测试
- en: Designing good tests requires a certain mindset. The objective while designing
    the code that covers certain functionality is to make the code fulfill that functionality
    while at the same time being efficient, writing clear code that could even be
    described as elegant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的测试需要一定的思维模式。在设计覆盖特定功能的代码时，目标是使代码实现该功能，同时保持高效，编写清晰、甚至可以说是优雅的代码。
- en: The objective of the test is to be sure that the functionality sticks to the
    expected behavior, and that all the different problems that can arise produce
    results that make sense.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的目标是确保功能符合预期行为，并且所有可能出现的不同问题都会产生有意义的输出。
- en: 'Now, to be able to really put the functionality to the test, the mindset should
    be to stress the code as much as possible. For example, let''s imagine a function
    `divide(A, B)`, that divides two integers between -100 and 100: `A` between `B`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了真正测试功能，心态应该是尽可能多地压榨代码。例如，让我们想象一个函数 `divide(A, B)`，它将两个介于 -100 和 100 之间的整数
    A 除以 B：`A` 介于 `B` 之间。
- en: 'While approaching the test, we need to check what the limits are of this, trying
    to check that the function is performing properly with the expected behavior.
    For example, the following tests could be created:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近测试时，我们需要检查这个测试的极限是什么，试图检查函数是否以预期的行为正确执行。例如，可以创建以下测试：
- en: '| Action | Expected behavior | Comments |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 预期行为 | 备注 |'
- en: '| `divide(10, 2)` | `return 5` | Basic case |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `divide(10, 2)` | `return 5` | 基本情况 |'
- en: '| `divide(-20, 4)` | `return -5` | Divide one negative and one positive integer
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `divide(-20, 4)` | `return -5` | 除以一个负整数和一个正整数 |'
- en: '| `divide(-10, -5)` | `return 2` | Divide two negative integers |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `divide(-10, -5)` | `return 2` | 除以两个负整数 |'
- en: '| `divide(12, 2)` | `return 5` | Not exact division |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `divide(12, 2)` | `return 5` | 非精确除法 |'
- en: '| `divide(100, 50)` | `return 2` | Maximum value of A |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `divide(100, 50)` | `return 2` | A的最大值 |'
- en: '| `divide(101, 50)` | `Produce an input error` | Value of A exceeding the maximum
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `divide(101, 50)` | `产生输入错误` | A的值超过最大值 |'
- en: '| `divide(50, 100)` | `return 0` | Maximum value of B |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `divide(50, 100)` | `return 0` | B的最大值 |'
- en: '| `divide(50, 101)` | `Produce an input error` | Value of B exceeding the maximum
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `divide(50, 101)` | `产生输入错误` | B的值超过最大值 |'
- en: '| `divide(10, 0)` | `Produce an exception` | Divide by zero |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `divide(10, 0)` | `产生异常` | 除以零 |'
- en: '| `divide(''10'', 2)` | `Produce an input error` | Invalid format for parameter
    A |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `divide(''10'', 2)` | `产生输入错误` | 参数A的格式无效 |'
- en: '| `divide(10, ''2'')` | `Produce an input error` | Invalid format for parameter
    B |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `divide(10, ''2'')` | `产生输入错误` | 参数B的格式无效 |'
- en: 'Note how we are testing different possibilities:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何测试不同的可能性：
- en: The usual behavior of all the parameters is correct, and the division works
    correctly. This includes both positive and negative numbers, exact division, and
    inexact division.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数的常规行为都是正确的，除法操作也是正确的。这包括正数和负数，精确除法和非精确除法。
- en: 'Values within the maximum and minimum values: We check that the maximum values
    are hit and correct, and the next value is properly detected.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最大值和最小值之间的值：我们检查最大值是否被正确击中，并且下一个值被正确检测。
- en: 'Division by zero: A known limitation on functionality that should produce a
    predetermined response (exception).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除以零：功能上已知的一个限制，应该产生一个预定的响应（异常）。
- en: Wrong input format.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的输入格式。
- en: 'We can really create a lot of test cases for simple functionality! Note that
    all these cases can be expanded. For example, we can add `divide(-100, 50)` and
    `divide(100, -50)` cases. In those cases, the question is the same: are those
    tests adding better detection of problems?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以为简单的功能真正创建很多测试用例！请注意，所有这些情况都可以扩展。例如，我们可以添加`divide(-100, 50)`和`divide(100,
    -50)`的情况。在这些情况下，问题是相同的：这些测试是否增加了对问题的更好检测？ '
- en: The best test is the test that really stresses the code and ensures that it's
    working as expected, trying very hard to cover the most difficult use cases. Making
    the tests ask difficult questions of the code under test is the best way of preparing
    your code for the real action. A system under load will see all kinds of combinations,
    so the best preparation for that is to create tests that try as hard as possible
    to find problems, to be able to solve them before moving to the next phase.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的测试是真正对代码施加压力并确保其按预期工作的测试，尽力覆盖最困难的用例。让测试向被测试的代码提出困难的问题，是让你的代码为实际操作做好准备的最佳方式。在负载下的系统将看到各种组合，因此最好的准备是创建尽可能努力寻找问题的测试，以便在进入下一阶段之前解决这些问题。
- en: This is analogous to football training, where a series of very demanding exercises
    are presented to be sure that the trainee will be able to perform later, during
    the match. Be sure that your training regime is hard enough to properly prepare
    for demanding matches!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于足球训练，一系列非常苛刻的练习被提出，以确保受训者能够在比赛中进行表现。确保你的训练计划足够艰难，以便为高强度的比赛做好准备！
- en: The proper balance between the number of tests and not having tests that cover
    functionality already checked by an existing test (for example, creating a big
    table dividing numbers with a lot of divisions) may depend greatly on the code
    under test and practices in your organization. Some critical areas may require
    more thorough testing as a failure there could be more important.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试数量和避免重复测试已由现有测试覆盖的功能（例如，创建一个大的表格，用很多除法来划分数字）之间找到适当的平衡，可能很大程度上取决于被测试的代码和你们组织中的实践。某些关键区域可能需要更彻底的测试，因为那里的失败可能更重要。
- en: For example, any external API should test any input with care and be really
    defensive about that, as external users may abuse external APIs. For example,
    testing what happens when strings are input in integer fields, infinity or `NaN`
    (Not a Number) values are added, payload limits are exceeded, the maximum size
    of a list or page is exceeded, etc.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何外部API都应该仔细测试任何输入，并对此进行真正的防御，因为外部用户可能会滥用外部API。例如，测试当在整数字段中输入字符串时会发生什么，添加了无穷大或`NaN`（非数字）值，超出了有效负载限制，列表或页面的最大大小被超过等情况。
- en: By comparison, interfaces that are mostly internal will require less testing,
    as the internal code is less likely to abuse the API. For example, if the `divide`
    function is only internal, it might not be required to test that the input format
    is incorrect, just to check that the limits are respected.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，大部分内部接口将需要较少的测试，因为内部代码不太可能滥用API。例如，如果`divide`函数仅是内部的，可能不需要测试输入格式是否错误，只需检查是否尊重了限制。
- en: Note that tests are done independently from the implementation of the code.
    A test definition is done purely from an external view of the function to test,
    without requiring knowing what's inside. This is called *black-box testing*. A
    heathy test suite always starts with this approach.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试是在代码实现独立进行的。测试定义纯粹是从外部视角对要测试的函数进行，而不需要了解其内部结构。这被称为*黑盒测试*。一个健康的测试套件总是从这种方法开始。
- en: A critical ability to develop as a developer writing tests is to detach from
    the knowledge of the code itself and approach tests independently.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编写测试的开发者，一个关键的能力是脱离对代码本身的知识，独立地对待测试。
- en: Testing can be so detached that it may use independent people just to create
    the tests, like a QA team performing tests. Unfortunately, this is not a possible
    approach for unit tests, which will likely be created by the same developers that
    write the code itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以如此独立，以至于可能需要独立的人员来创建测试，就像一个QA团队进行测试一样。不幸的是，这种方法对于单元测试来说是不可能的，单元测试很可能会由编写代码的同一开发者创建。
- en: In some cases, this external approach won't be enough. If the developer knows
    that there's some specific area where there could be problems, it may be good
    to complement it with tests that check functionality that is not apparent from
    an external point of view.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种外部方法可能不足以。如果开发者知道存在一些可能存在问题的特定区域，那么补充一些检查功能性的测试可能是个好主意，这些功能性从外部视角看可能不明显。
- en: For example, a function that calculates a result based on some input may have
    an internal point where the algorithm changes to calculate it using different
    models. This information doesn't need to be known by the external user, but it
    will be good to add a couple of checks that the transition works correctly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个基于某些输入计算结果的函数可能有一个内部点，其中算法改变以使用不同的模型来计算。外部用户不需要知道这些信息，但添加一些检查以验证转换是否正确将是有益的。
- en: This kind of testing is called *white-box testing*, in comparison to the black-box
    approach discussed early.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试被称为*白盒测试*，与之前讨论的黑盒方法相对。
- en: It's important to remember that, in a test suite, white-box tests should always
    be secondary to black-box tests. The main objective is to test the functionality
    from an external perspective. White-box testing may be a good addition, especially
    in some aspects, but it should have a lower priority.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在测试套件中，白盒测试应该始终是次要的黑盒测试。主要目标是测试从外部视角的功能性。白盒测试可能是一个很好的补充，特别是在某些方面，但它应该有较低的优先级。
- en: Developing the ability to be able to create good black-box tests is important
    and should be transmitted to the team.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 发展能够创建良好黑盒测试的能力非常重要，并且应该传达给团队。
- en: Black-box testing tries to avoid a common problem where the same developer writes
    both the code and the test and then checks that the interpretation of the feature
    implemented in the code works as expected, instead of checking that it works as
    it should when looking from an external endpoint. We will take a look later at
    TDD, which tries to ensure tests are created without the implementation in mind
    by writing the tests before writing the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试试图避免一个常见问题，即同一个开发者编写了代码和测试，然后检查代码中实现的功能的解释是否按预期工作，而不是检查从外部端点看它是否按预期工作。我们稍后会看看TDD，它试图通过在编写代码之前编写测试来确保测试的创建不考虑实现。
- en: Structuring tests
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化测试
- en: In terms of structure, especially for unit tests, a nice way to structure tests
    is using the **Arrange Act Assert** (**AAA**) pattern.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构方面，特别是对于单元测试，使用**安排-行动-断言**（**AAA**）模式来结构化测试是一个很好的方法。
- en: 'This pattern means the test is in three different phases:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式意味着测试分为三个不同的阶段：
- en: '**Arrange**: Prepare the environment for the tests. This includes all the setup
    to get the system right at the point before performing the next step, at a stable
    moment.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：为测试准备环境。这包括所有设置，以确保在执行下一步之前系统处于稳定状态。'
- en: '**Act**: Perform the action that is the objective of the test.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动**：执行测试的目标行为。'
- en: '**Assert**: Check that the result of the action is the expected one.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：检查行为的结果是预期的。'
- en: 'The test gets structured as a sentence like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试被结构化为一个句子，如下所示：
- en: '**GIVEN**(Arrange)an environment known, the**ACTION**(Act)produces the specified
    **RESULT** (Assert)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**给定**（安排）一个已知的环境，**行动**（行动）产生指定的**结果**（断言）'
- en: This pattern is also sometimes called *GIVEN*, *WHEN*, *THEN* as each step can
    be described in those terms.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式有时也被称为*给定*、*当*、*然后*，因为每个步骤都可以用这些术语来描述。
- en: Note that this structure aims for all the tests to be independent, and for each
    to test a single thing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种结构旨在使所有测试都独立，并且每个测试都测试一个单独的东西。
- en: A common different pattern is to group act steps in tests, testing multiple
    functionalities in a single test. For example, test that writing a value is correct
    and then check that the search for the value returns the proper value. This won't
    follow the AAA pattern. Instead, to follow the AAA pattern, two tests should be
    created, the first one to validate that the write works correctly and the second
    where the value is created as part of the setup in the Arrange step before doing
    the search.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的不同模式是在测试中分组行动步骤，在一个测试中测试多个功能。例如，测试写入值是否正确，然后检查搜索该值是否返回正确的值。这不会遵循AAA模式。相反，为了遵循AAA模式，应该创建两个测试，第一个测试验证写入是否正确，第二个测试在搜索之前，将值作为在安排步骤中的设置部分创建。
- en: Note that this structure can be used whether the tests are executed through
    code or run manually, though they'll be used more for automated tests. When running
    them manually, the Arrange stage can take a long time to produce for each test,
    leading to a lot of time spent on that. Instead, manual tests are normally grouped
    together in the pattern that we describe above, executing a series of Act and
    Assert and using the input in the previous stage as setup for the next. This creates
    a dependency in requiring to run tests in a specific sequence, which is not great
    for unit test suites, but it can be better for smoke tests or other environments
    where the Arrange step is very expensive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论测试是通过代码执行还是手动运行，这种结构都可以使用，尽管它们更多地用于自动化测试。当手动运行时，Arrange阶段可能需要花费很长时间才能为每个测试生成，导致在该阶段花费大量时间。相反，手动测试通常按照我们上面描述的模式分组，执行一系列的Act和Assert，并使用前一个阶段的输入作为下一个阶段的设置。这创建了一个依赖性，需要按照特定的顺序运行测试，这对单元测试套件来说不是很好，但可能对烟雾测试或其他环境中Arrange步骤非常昂贵的情况更好。
- en: In the same way, if the code to test is purely functional (meaning that only
    the input parameters are the ones that determine its state, like the `divide`
    example above), the Arrange step is not required.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要测试的代码是纯函数式的（意味着只有输入参数决定了其状态，如上面的`divide`示例），则不需要Arrange步骤。
- en: Let's see an example of code created with this structure. Imagine that we have
    a method that we want to test, called `method_to_test`. The method is part of
    a class called `ClassToTest`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这种结构创建的代码示例。假设我们有一个想要测试的方法，称为`method_to_test`。该方法属于名为`ClassToTest`的类。
- en: '[PRE0]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of the steps is very clearly defined. The first one prepares, in this case,
    an object in the class that we want to test. Note that we may need to add some
    parameters or some preparation so the object is in a known starting point so the
    next steps work as expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都非常清晰地定义。第一个步骤是准备，在这种情况下，是我们想要测试的类中的一个对象。请注意，我们可能需要添加一些参数或一些准备，以便对象处于一个已知的起始点，以便下一个步骤按预期工作。
- en: The Act step just generates the action that is under test. In this case, call
    the `method_to_test` method for the prepared object with the proper parameter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Act步骤仅生成要测试的动作。在这种情况下，使用适当的参数调用准备好的对象的`method_to_test`方法。
- en: Finally, the Assert step is very straightforward and just checks the response
    is the expected one.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Assert步骤非常直接，只是检查响应是否是预期的。
- en: In general, both the Act and Assert steps are simple to define and write. The
    Arrange step is where most of the effort of the test will normally be.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Act和Assert步骤都很容易定义和编写。Arrange步骤通常是测试中需要的大部分努力所在。
- en: Another common pattern that appears using the AAA pattern for tests is to create
    common functions for testing in Arrange steps. For example, creating a basic environment,
    which could require a complex setup, and then having multiple copies where the
    Act and Assert steps are different. This reduces the repetition of code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AAA模式进行测试时出现的另一个常见模式是在Arrange步骤中创建用于测试的通用函数。例如，创建一个基本环境，这可能需要复杂的设置，然后有多个副本，其中Act和Assert步骤不同。这减少了代码的重复。
- en: 'For example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE1]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will see later how we can structure multiple tests that are very similar
    to avoid repetition, which is a problem when having big test suites. Having big
    test suites is important to create good test coverage, as we saw above.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到如何结构化多个非常相似的测试，以避免重复，这在拥有大型测试套件时是一个问题。拥有大型测试套件对于创建良好的测试覆盖率很重要，如我们上面所看到的。
- en: Repetition in tests is, up to a certain point, unavoidable and even healthy
    to a certain degree. When changing the behavior of some part of the code because
    there are changes, the tests need to be changed accordingly to accommodate the
    changes. This change helps to weigh the size of the changes and avoid making big
    changes lightly, as the tests will work as a reminder of the affected functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，重复在某种程度上是不可避免的，甚至在某种程度上是有益的。当因为某些更改而更改代码的一部分的行为时，测试需要相应地更改以适应这些更改。这种更改有助于衡量更改的大小，并避免轻率地做出大的更改，因为测试将作为受影响功能的一个提醒。
- en: Nonetheless, mindless repetition is not great, and we will see later some options
    to reduce the amount of code to be repeated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无意义的重复并不好，我们稍后会看到一些减少重复代码量的选项。
- en: Test-Driven Development
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: A very popular technique to approach programming is **Test-Driven Development**
    or **TDD**. TDD consists of putting tests at the center of the developing experience.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: This builds on some of the ideas that we exposed earlier in the chapter, though
    working on them with a more consistent view.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The TDD flow to develop software works as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: New functionality is decided on to be added to the code.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new test is written to define the new functionality. Note that this is done
    *before* the code.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test suite is run to show that it's failing.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new functionality is then added to the main code, focusing on simplicity.
    Only the required feature, without extra details, should be added.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The test suite is run to show that the new test is working. This may need to
    be done several times until the code is ready.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new functionality is ready! Now the code can be refactored to improve it,
    avoiding duplication, rearranging elements, grouping it with previously existing
    code, etc.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cycle can start again for any new functionality.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, TDD is based on three main ideas:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the tests before writing the code**: This prevents the problem of creating
    a test that is too tightly coupled with the current implementation, forcing the
    developer to think about the test and the feature before jumping into writing
    it. It also forces the developer to check that the test actually fails before
    the feature is written, being sure that a problem later on will be detected. This
    is similar to the black box testing approach that we described earlier in the
    *How to design a great test* section.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run the tests constantly**: A critical part of the process is running the
    whole test suite to check that all the functionality in the system is correct.
    This is done over and over, every time that a new test is created, but also while
    the functionality is being written. Running the tests is an essential part of
    developing in TDD. This ensures that all functionality is always checked and that
    the code works as expected at all times so any bug or discrepancy can be solved
    quickly.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Work in very small increments**: Focus on the task at hand, so each step
    builds and grows a test suite that is big and covers the whole functionality of
    the code in depth.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This big test suite creates a safety net that allows you to perform refactors
    of the code often, big and small, therefore improving the code constantly. Small
    increments mean small tests that are specific and need to be thought about before
    adding the code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: An extension of this idea is a focus on writing only the code that's required
    for the task at hand and not more. This is sometimes referred to as the **YAGNI**
    principle (**You Ain't Gonna Need It**). The intention of this principle is to
    prevent overdesigning or creating code for "foreseeable requests in the future,"
    which, in practice, have a high probability of never materializing and, even worse,
    makes the code more difficult to change in other directions. Given that software
    development is notoriously difficult to plan in advance, the emphasis should be
    on keeping things small and not getting too far ahead of yourself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的一个扩展是只编写完成任务所需的代码，而不是更多。这有时被称为**YAGNI**原则（**You Ain't Gonna Need It**）。这个原则的目的是防止过度设计或为“可预见的未来请求”编写代码，实际上这些请求有很大概率永远不会实现，而且更糟糕的是，这会使代码在其他方向上更难以更改。鉴于软件开发在事先规划上众所周知地困难，重点应该放在保持事物的小规模上，不要过于超越自己。
- en: These three ideas interact constantly during the development cycle, and it keeps
    the tests at the center of the development process, hence the name of the practice.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个想法在开发周期中不断相互作用，并使测试始终处于开发过程的核心，因此这种实践被称为“测试驱动开发”。
- en: Another important advantage of TDD is that putting the focus so heavily on the
    tests means that how the code is going to be tested is thought about from the
    start, which helps in designing code that's easily testable. Also, reducing the
    amount of code to write, focusing on it being strictly required to pass the test
    reduces the probability of overdesign. The requirement to create small tests and
    work in increments also tends to generate modular code, in small units that are
    combined together but are able to be tested independently.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的另一个重要优势是，如此重视测试意味着从一开始就会考虑代码的测试方式，这有助于设计易于测试的代码。此外，减少要编写的代码量，专注于它是否严格必要以通过测试，这降低了过度设计的发生概率。创建小型测试并在增量中工作的要求也倾向于生成模块化代码，这些代码以小单元组合在一起，但能够独立进行测试。
- en: 'The general flow is to be constantly working with new failing tests, making
    them pass and then refactoring, sometimes called the "*red/green/refactor*" pattern:
    red when the test is failing and green when all tests are passing.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的流程是持续地与新的失败测试一起工作，让它们通过，然后进行重构，这有时被称为“*红/绿/重构*”模式：当测试失败时为红色，当所有测试都通过时为绿色。
- en: Refactoring is a critical aspect of the TDD process. It is strongly encouraged,
    to constantly improve the quality of the existing code. One of the best outcomes
    of this way of working is the generation of very extensive test suites that cover
    each detail of the code functionality, meaning that refactoring code can be done
    knowing that there's a solid ground that is going to capture any problems introduced
    by changing the code and adding bugs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是TDD过程中的一个关键方面。强烈鼓励不断改进现有代码的质量。这种方式工作的最佳结果之一是生成非常广泛的测试套件，覆盖代码功能的所有细节，这意味着重构代码时可以知道有一个坚实的基础，可以捕捉到代码更改引入的任何问题，并添加错误。
- en: Improving the code's readability, usability, and so on, by refactoring is known
    to have a good impact in terms of improving the morale of developers and increasing
    the pace at which changes can be introduced, as the code is kept in good shape.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构来提高代码的可读性、可用性等，这在提高开发者的士气和加快引入变更的速度方面有着良好的影响，因为这样可以保持代码的良好状态。
- en: In general, and not only in TDD, allowing time to clean up old code and improve
    it is critical to maintain a good pace for changes. Old code that is stale tends
    to be more and more difficult to work with, and over time it will require way
    more effort to change it to make more changes. Encouraging healthy habits to care
    about the current state of the code and allowing time to perform maintenance improvements
    is critical for the long-term sustainability of any software system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，不仅在TDD中，留出时间清理旧代码并改进它对于保持良好的变更节奏至关重要。陈旧的旧代码往往越来越难以处理，随着时间的推移，将其更改以进行更多变更将需要更多的努力。鼓励健康的习惯，关注代码的当前状态，并留出时间进行维护性改进，对于任何软件系统的长期可持续性至关重要。
- en: Another important aspect of TDD is the requirement of speedy tests. As tests
    are always running following TDD practices, the total execution time is quite
    important. The time that it takes for each test should be considered carefully,
    as the growing size of the test suite will make it take longer to run.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的另一个重要方面是快速测试的要求。由于测试始终在TDD实践中运行，因此总执行时间非常重要。每个测试所需的时间应仔细考虑，因为测试套件的增长将使运行时间更长。
- en: There's a general threshold where focus gets lost, so running tests taking longer
    than around 10 seconds will make them not "part of the same operation," risking
    the developer thinking about other stuff.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个普遍的阈值，超过这个阈值注意力就会分散，因此运行时间超过大约10秒的测试将使它们不再是“同一操作的一部分”，这会风险开发者去想其他事情。
- en: Obviously, running the whole test suite in under 10 seconds will be extremely
    difficult, especially as the number of tests grows. A full unit test suite for
    a complex application can consist of 10,000 tests or more! In real life, there
    are multiple strategies that can help alleviate this fact.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在10秒内运行整个测试套件将非常困难，尤其是在测试数量增加的情况下。一个复杂应用的完整单元测试套件可能包含10,000个测试或更多！在现实生活中，有多种策略可以帮助缓解这一事实。
- en: The whole test suite doesn't need to be run all the time. Instead, any test
    runner should allow you to select a range of tests to run, allowing you to reduce
    the number of tests to run on each run while the feature is in development. This
    means running only the tests that are relevant for the same module, for example.
    It can even mean running a single test, in certain cases, to speed up the result.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 整个测试套件并不需要一直运行。相反，任何测试运行器都应该允许你选择要运行的测试范围，允许你在开发功能时减少每次运行要运行的测试数量。这意味着只运行与同一模块相关的测试，例如。在某些情况下，甚至可以运行单个测试来加快结果。
- en: Of course, at some point, the whole test suite should be run. TDD is actually
    aligned with Continuous Integration, as it is also based on running tests, this
    time automatically once the code is checked out into a repo. The combination of
    being able to run a few tests locally to ensure that things are working correctly
    while developing with the whole test suite running in the background once the
    code is committed to the repo is great.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在某个时候，应该运行整个测试套件。TDD实际上与持续集成相一致，因为它也基于运行测试，这次是在代码被检出到仓库后自动运行。能够在本地运行一些测试以确保开发过程中一切正常，同时在将代码提交到仓库后，在后台运行整个测试套件，这种组合是非常好的。
- en: Anyway, as the time taken to run tests is important in TDD, observing the duration
    of tests is important, and generating tests that can run quickly is key to being
    able to work in the TDD way. This is mainly achieved by creating tests that cover
    small portions of the code, and therefore the time to set up can be kept under
    control.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在TDD中，运行测试所需的时间很重要，观察测试的持续时间很重要，生成可以快速运行的测试是能够以TDD方式工作的关键。这主要通过创建覆盖代码小部分的测试来实现，因此可以保持设置时间在可控范围内。
- en: TDD practices work best with unit tests. Integration and system tests may require
    a big setup that is not compatible with the speed and tight feedback loop required
    for TDD to work.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: TDD实践与单元测试配合得最好。集成和系统测试可能需要一个大的设置，这与TDD工作所需的速度和紧密的反馈循环不兼容。
- en: Fortunately, as we saw before, unit testing is where the bulk of testing is
    typically focused on most projects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如我们之前所看到的，单元测试通常是大多数项目中测试的重点。
- en: Introducing TDD into new teams
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将TDD引入新团队
- en: Introducing TDD practices in an organization can be tricky, as they change the
    way to perform actions that are quite basic, and go a bit against the usual way
    of working (writing tests after writing the code).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个组织中引入TDD实践可能很棘手，因为它们改变了执行基本操作的方式，并且与通常的工作方式（在写代码后编写测试）有些相悖。
- en: When considering introducing TDD into a team, it's good to have an advocate
    that can act as a point of contact for the rest of the team and solve the questions
    and problems that may arise through creating tests.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑将TDD引入一个团队时，有一个可以充当团队其他成员的联系人并解决可能通过创建测试而出现的问题的倡导者是很好的。
- en: TDD is very popular in environments where pair programming is also common, so
    it's another possibility to have someone drive a session while training the other
    developers and introducing the practice.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: TDD在结对编程也普遍的环境中非常受欢迎，因此，在培训其他开发人员并引入这一实践的同时，让某人驱动一个会话是另一种可能性。
- en: Remember, the key element of TDD is the mindset of forcing the developer to
    think first about how a particular feature is going to be tested before starting
    to think about the implementation. This mindset doesn't come naturally and needs
    to be trained and practiced.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，TDD的关键要素是迫使开发者首先思考如何测试特定的功能，然后再开始考虑实现。这种心态不是自然而然产生的，需要训练和实践。
- en: It may be challenging to apply TDD techniques with already existing code, as
    pre-existing code can be difficult to test in this configuration, especially if
    the developers are new to the practice. TDD works great for new projects, though,
    as a test suite for new code will be created at the same time as the code. A mixed
    approach of starting a new module inside an existing project, so most code is
    new and can be designed using TDD techniques, reduces the problem of dealing with
    legacy code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有代码中应用TDD技术可能具有挑战性，因为在这种配置下，预存的代码可能难以测试，尤其是如果开发者对这种实践不熟悉。然而，对于新项目来说，TDD效果很好，因为新代码的测试套件将与代码同时创建。在现有项目中启动一个新模块的混合方法，因此大部分代码都是新的，可以使用TDD技术进行设计，这减少了处理遗留代码的问题。
- en: If you want to see if TDD can be effective for new code, try to start small,
    using some small project with a small team to be sure that it's not too disruptive
    and that the principles can be properly digested and applied. There are some developers
    that really love to use TDD principles, as it fits their personality and how they
    approach the process of developing. Remember that this is not necessarily how
    everyone will feel and that starting with these practices requires time, and perhaps
    it won't be possible to apply them 100% as the previous code might limit it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看TDD是否对新代码有效，尝试从小处开始，使用一些小型项目和小型团队来确保它不会过于破坏性，并且原则可以正确消化和应用。有些开发者非常喜欢使用TDD原则，因为它符合他们的个性和他们处理开发过程的方式。记住，这并不一定适合每个人，并且开始这些实践需要时间，也许不可能100%地应用它们，因为之前的代码可能会限制它。
- en: Problems and limitations
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题与局限性
- en: TDD practices are very popular and widely followed in the industry, though they
    have their limits. One is the problem of big tests that take too long to run.
    These tests may be unavoidable in certain situations.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: TDD实践在业界非常流行且被广泛遵循，尽管它们有其局限性。其中一个是运行时间过长的大测试问题。在某些情况下，这些测试可能是不可避免的。
- en: Another is the difficulty of fully taking this approach if it is not done from
    the beginning, as parts of the code will already be written, and perhaps new tests
    should be added, violating the rule of creating the tests before the code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果这不是从一开始就做的，那么完全采用这种方法可能会有困难，因为代码的部分已经编写，可能还需要添加新的测试，违反了在编写代码之前创建测试的规则。
- en: Another problem is designing new code while the features to be implemented are
    fluid and not fully defined. This requires experimentation, for example, to design
    a function to return a color that contrasts with an input color, for example,
    to present a contrast color based on a theme selectable by the user. This function
    may require inspection to see if it "looks right," which can require tweaking
    that's difficult to achieve with a preconfigured unit test.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在要实现的功能不流动且未完全定义的情况下设计新代码。这需要实验，例如，设计一个函数来返回与输入颜色形成对比的颜色，例如，根据用户可选择的主题呈现对比颜色。这个函数可能需要检查它是否“看起来合适”，这可能需要调整，而使用预配置的单元测试很难实现。
- en: Not a problem specifically with TDD, but something to be careful about is to
    remember to avoid dependencies between tests. This can happen with any test suite,
    but given the focus on creating new tests, it's a likely problem if the team is
    starting with TDD practices. Dependencies can be introduced by requiring tests
    to run in a particular order, as the tests can contaminate the environment. This
    is normally not done on purpose, but it's done inadvertently while writing multiple
    tests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是TDD特有的问题，但需要注意的一点是，要记住避免测试之间的依赖关系。这可能在任何测试套件中发生，但鉴于对创建新测试的关注，如果团队从TDD实践开始，这很可能是一个问题。依赖关系可能通过要求测试以特定顺序运行而引入，因为测试可能会污染环境。这通常不是故意为之，但在编写多个测试时无意中发生。
- en: A typical effect on that will be that some tests fail if run independently,
    as their dependencies are not run in that case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的效果是，如果独立运行，某些测试可能会失败，因为在这种情况下没有运行它们的依赖关系。
- en: In any case, remember that TDD is not necessarily something that it's all or
    nothing, but a set of ideas and practices that can help you design code that's
    well tested and high quality. Not every single test in the system needs to be
    designed using TDD, but a lot of them can be.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，请记住，TDD 并不一定是一切或无的东西，而是一套可以帮助你设计经过良好测试和高质量代码的想法和实践。系统中并非每个测试都需要使用 TDD 来设计，但其中很多可以。
- en: Example of the TDD process
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD 流程的示例
- en: 'Let''s imagine that we need to create a function that:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们需要创建一个函数，它：
- en: For values lower than 0, returns zero
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于小于0的值，返回零
- en: For values greater than 10, returns 100
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大于10的值，返回100
- en: For values between, it returns the power of two of the value. Note that for
    the edges, it returns the power of two of the input (0 for 0 and 100 for 10)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于介于两者之间的值，它返回该值的2的幂。注意，对于边缘，它返回输入的2的幂（0对应于0，100对应于10）
- en: To write the code in full TDD fashion, we start with the smallest possible test.
    Let's create the smallest skeleton and the first test.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要以全 TDD 风格编写代码，我们从可能的最小测试开始。让我们创建最小的骨架和第一个测试。
- en: '[PRE2]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We run the test, and get an error with the test failing. Right now, we will
    use pure Python code, but later in the chapter, we'll see how to run tests more
    efficiently.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行测试，并且测试失败时出现错误。现在，我们将使用纯Python代码，但稍后在本章中，我们将看到如何更有效地运行测试。
- en: '[PRE3]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The implementation of the use case is quite straightforward.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 用例的实现相当直接。
- en: '[PRE4]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Yes, we are actually returning a hardcoded value, but that's really all that
    is required to pass the first tests. Let's run the tests now and you'll see no
    errors.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们实际上返回了一个硬编码的值，但这确实是通过第一个测试所必需的全部。现在让我们运行测试，你将看到没有错误。
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But now we add tests for the lower edge. While these are two lines, they can
    be considered the same test, as they're checking that the edge is correct.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们添加了对较低边缘的测试。虽然这两行，但它们可以被认为是同一个测试，因为它们检查边缘是否正确。
- en: '[PRE6]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's run the tests again.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行测试。
- en: '[PRE7]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to add code to handle the lower edge.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加代码来处理较低的边缘。
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When running the test, we see that it's running the tests correctly. Let's add
    parameters now to handle the upper edge.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，我们看到它正在正确地运行测试。现在让我们添加参数来处理上边缘。
- en: '[PRE9]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This triggers the corresponding error.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这触发了相应的错误。
- en: '[PRE10]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's add the higher edge.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加更高的边缘。
- en: '[PRE11]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This runs correctly. We are not confident that all the code is fine, and we
    really want to be sure that the intermediate section is correct, so we add another
    test.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这运行正确。我们并不确信所有代码都正确，我们真的想确保中间部分是正确的，所以我们添加了另一个测试。
- en: '[PRE12]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Aha! Now it shows an error, due to the initial hardcoding.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！现在显示了一个错误，这是由于初始的硬编码造成的。
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So let's fix it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们修复它。
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This runs all the tests correctly. Now, with the safety net of the tests, we
    think we can refactor the code a little bit to clean it up.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这运行了所有的测试并且正确无误。现在，有了测试的安全网，我们认为我们可以稍微重构一下代码来清理它。
- en: '[PRE15]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can run the tests all through the process and be sure that the code is correct.
    The final result may be different based on what the team considers good code or
    what is more explicit, but we have our test suite that will ensure that the tests
    are consistent, and the behavior is correct.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在整个过程中运行测试，并确保代码是正确的。最终结果可能基于团队认为的好代码或更明确的内容而有所不同，但我们有我们的测试套件，这将确保测试是一致的，行为是正确的。
- en: The function here is quite small, but this shows what the flow is when writing
    code in the TDD style.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数相当小，但这显示了以 TDD 风格编写代码时的流程。
- en: Introduction to unit testing in Python
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 单元测试简介
- en: There are multiple ways to run tests in Python. One, as we have seen above,
    a bit crude, is to execute code with multiple asserts. A common one is the standard
    library `unittest`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中运行测试有多种方式。一种，如我们上面所见，有点粗糙，是执行带有多个断言的代码。一种常见的方式是标准库 `unittest`。
- en: Python unittest
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python unittest
- en: '`unittest` is a module included in the Python standard library. It is based
    on the concept of creating a testing class that groups several testing methods.
    Let''s write a new file with the tests written in the proper format, called `test_unittest_example.py`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 是 Python 标准库中的一个模块。它基于创建一个测试类来分组多个测试方法的概念。让我们写一个新文件，用适当的格式编写测试，命名为
    `test_unittest_example.py`。'
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's analyze the different elements. The first ones are the imports on top.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析不同的元素。首先是顶部的导入。
- en: '[PRE17]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We import the `unittest` module and the function to test. The most important
    part comes next, which defines the tests.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `unittest` 模块和要测试的函数。最重要的部分接下来，它定义了测试。
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The class `TestTDDExample` groups the different tests. Notice that it's inheriting
    from `unittest.TestCase`. Then, methods that start with `test_` will produce the
    independent tests. Here, we will show one. Internally, it calls the function and
    compares the result with 0, using the `self.assertEqual` function.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestTDDExample`类将不同的测试分组。请注意，它继承自`unittest.TestCase`。然后，以`test_`开头的方法将产生独立的测试。在这里，我们将展示一个。内部，它调用函数并使用`self.assertEqual`函数将结果与0进行比较。'
- en: Notice that `test_seven` is defined incorrectly. We do this to produce an error
    when running it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`test_seven`定义不正确。我们这样做是为了在运行时产生错误。
- en: Finally, we add this code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加这段代码。
- en: '[PRE19]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This runs the tests automatically if we run the file. So, let''s run the file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行文件，它会自动运行测试。所以，让我们运行这个文件：
- en: '[PRE20]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, it has run all six tests, and shows any errors. Here, we can
    clearly see the problem. If we need more detail, we can run with `-v showing`
    showing each of the tests that are being run:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它已运行所有六个测试，并显示了任何错误。在这里，我们可以清楚地看到问题。如果我们需要更多细节，我们可以使用`-v showing`选项运行，显示正在运行的每个测试：
- en: '[PRE21]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can also run a single test or combination of them using the `-k` option,
    which searches for matching tests.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`-k`选项运行单个测试或它们的组合，该选项会搜索匹配的测试。
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`unittest` is extremely popular and can accept a lot of options, and it''s
    compatible with virtually every framework in Python. It''s also very flexible
    in terms of ways of testing. For example, there are multiple methods to compare
    values, like `assertNotEqual` and `assertGreater`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`非常受欢迎，可以接受很多选项，并且与Python中的几乎每个框架都兼容。它在测试方式上也非常灵活。例如，有多种方法可以比较值，如`assertNotEqual`和`assertGreater`。'
- en: There's a specific assert function that works differently, which is `assertRaises`,
    used to detect when the code generates an exception. We will take a look at it
    later when testing mocking external calls.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特定的断言函数工作方式不同，即`assertRaises`，用于检测代码生成异常的情况。我们将在测试模拟外部调用时稍后查看它。
- en: It also has `setUp` and `tearDown` methods to execute code before and after
    the execution of each test in the class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有`setUp`和`tearDown`方法，用于在每个测试执行前后执行代码。
- en: 'Be sure to take a look at the official documentation: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保查看官方文档：[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)。
- en: While `unittest` is probably the most popular test framework, it's not the most
    powerful one. Let's take a look at it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`unittest`可能是最受欢迎的测试框架，但它并不是最强大的。让我们来看看它。
- en: Pytest
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pytest
- en: Pytest simplifies writing tests even further. One common complaint about `unittest`
    is that it forces you to set a lot of `assertCompare` calls that are not obvious.
    It also needs to structure the tests, adding a bit of boilerplate code, like the
    `test` class. Other problems are not as obvious, but when creating big test suites,
    the setup of different tests can start to get complicated.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest进一步简化了编写测试的过程。关于`unittest`的一个常见抱怨是它强制您设置许多不是显而易见的`assertCompare`调用。它还需要对测试进行结构化，添加一些样板代码，如`test`类。其他问题可能不那么明显，但创建大型测试套件时，不同测试的设置可能会变得复杂。
- en: A common pattern is to create classes that inherit from other test classes.
    Over time, that can grow legs of its own.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是创建继承自其他测试类的类。随着时间的推移，这可能会发展出自己的特性。
- en: Pytest instead simplifies the running and defining of tests, and captures all
    the relevant information using standard `assert` statements that are easier to
    read and recognize.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest简化了测试的运行和定义，并使用更易于阅读和识别的标准`assert`语句捕获所有相关信息。
- en: In this section, we will use `pytest` in the simplest way. Later in the chapter,
    we will cover more interesting cases.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以最简单的方式使用`pytest`。在章节的后面部分，我们将介绍更多有趣的案例。
- en: Be sure to install `pytest` through pip in your environment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保通过pip在您的环境中安装`pytest`。
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's see how to run the tests defined in the `unittest`, in the file `test_pytest_example.py`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在`test_pytest_example.py`文件中运行定义的测试。
- en: '[PRE24]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you compare it with the equivalent code in `test_unittest_example.py`, the
    code is significantly leaner. When running it with `pytest`, it also shows more
    detailed, colored information.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将其与`test_unittest_example.py`中的等效代码进行比较，代码会显著更简洁。当使用`pytest`运行时，它也会显示更详细、带颜色的信息。
- en: '[PRE25]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with `unittest`, we can see more information with `-v` and run a selection
    of tests with `-k`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与`unittest`一样，我们可以使用`-v`选项看到更多信息，并使用`-k`选项运行测试的选择。
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And it's totally compatible with `unittest` defined tests, which allows you
    to combine both styles or migrate them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Another great feature of `pytest` is easy autodiscovery to find files that start
    with `test_` and run inside all the tests. If we try it, pointing at the current
    directory, we can see it runs both `test_unittest_example.py` and `test_pytest_example.py`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will continue talking about more features of `pytest` during the chapter,
    but first, we need to go back to how to define tests when the code has dependencies.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Testing external dependencies
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building unit tests, we talked about how it's based around the concept
    of isolating a unit in the code to test it independently.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: This isolation concept is key, as we want to focus on small sections of the
    code to create small, clear tests. Creating small tests also helps in keeping
    the tests fast.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In our example above, we tested a purely functional function, `parameter_tdd`,
    that had no dependencies. It was not using any external library or any other function.
    But inevitably, at some point, you'll need to test something that depends on something
    else.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The question in this case is *should the other component be part of the test
    or not?*
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: This is not an easy question to answer. Some developers think that all unit
    tests should be purely about a single function or method, and therefore, any dependency
    should not be part of the test. But, on a more practical level, there are sometimes
    pieces of code that form a unit that it's easier to test in conjunction than separately.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, think about a function that:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: For values lower than 0, returns zero.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For values greater than 100, returns 10.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For values between, it returns the square root of the value. Note that for the
    edges, it returns the square root of them (0 for 0 and 10 for 100).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very similar to the previous function, `parameter_tdd,` but this time
    we need the help of an external library to produce the square root of a number.
    Let's take a look at the code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: It's divided into two files. `dependent.py` contains the definition of the function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The code is pretty similar to the code in the `parameter_tdd` example. The module
    `math.sqrt` returns the square root of a number.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: And the tests are in `test_dependent.py`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, we are completely using the external library and testing it at
    the same time that we are testing our code. For this simple example, this is a
    perfectly valid option, though that may not be the case for other cases.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The code is available in GitHub at [https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_10_testing_and_tdd](https://github.com/PacktPublishing/Python-Architecture-Patterns/tree/main/chapter_10_testing_and_tdd).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: For example, the external dependency could be making external HTTP calls that
    need to be captured to prevent making them while running tests and to have control
    over the returned values, or other big pieces of functionality that should be
    tested in isolation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: To detach a function from its dependencies, there are two different approaches.
    We will show them using `parameter_dependent` as a baseline.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Again, in this case, the tests work perfectly fine with the dependency included,
    as it's simple and doesn't produce side effects like external calls, etc.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: We will see next how to mock the external calls.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mocking is a practice that internally replaces the dependencies, replacing them
    with fake calls, under the control of the test itself. This way, we can introduce
    a known response for any external dependency, and not call the actual code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Internally, mocking is implemented using what is known as *monkey-patching*,
    which is the dynamic replacement of existing libraries with alternatives. While
    this can be achieved in different ways in different programming languages, it's
    especially popular in dynamic languages like Python or Ruby. Monkey-patching can
    be used for other purposes than testing, though it should be used with care, as
    it can change the behavior of libraries and can be quite disconcerting for debugging.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: To be able to mock the code, in our test code, we need to prepare the mock as
    part of the Arrange step. There are different libraries to mock calls, but the
    easiest is to use the `unittest.mock` library included as part of the standard
    library.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest usage of `mock` is to patch an external library:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `patch` decorator intercepts the calls to the defined library, `math.sqrt`,
    and replaces it with a `mock` object that passes to the function, here called
    `mock_sqrt`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: This object is a bit special. It basically allows any calls, accesses almost
    any method or attributes (except predefined ones), and keeps returning a mock
    object. This makes the mock object something really flexible that will adapt to
    whatever code surrounds it. When necessary, the returning value can be set calling
    `.return_value`, as we show in the first line.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: We are, in essence, saying that calls to `mock_sqrt` will return the value 5\.
    So, we are preparing the output of the external call, so we can control it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check that we called the mock `mock_sqrt` once, with the input (`25`)
    using the method `assert_called_once_with`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, we are:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the mock so it replaces `math.sqrt`
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the value that it will return when called
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking that the call works as expected
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-checking that the mock was called with the right value
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other tests, for example, we can check that the mock was not called, indicating
    that the external dependence wasn't called.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There are multiple `assert` functions that allow you to detect how the mock
    has been used. Some examples:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'The `called` attribute returning `True` or `False` based on whether the mock
    has been called or not, allowing you to write:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `call_count` attribute returning the number of times a mock has been called.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assert_called_with()` method to check the number of times that it has been
    called. It will raise an exception if the last call is not produced in the specified
    way.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `assert_any_call()` method to check whether any of the calls have been produced
    in the specified way.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that information, the full file for testing, `test_dependent_mocked_test.py`,
    will be like this.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the mock needs to return different values, you can define the `side_effect`
    attribute of the mock as a list or tuple. `side_effect` is similar to `return_value`,
    but it has a few differences, as we'll see.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`side_effect` can also be used to produce an exception, if needed.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `with` section asserts that the expected `Exception` is raised in the block.
    If not, it shows an error.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: In `unittest`, checking a raised exception can be done with a similar `with`
    block.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '`with self.assertRaises(ValueError):`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '`parameter_dependent(25)`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Mocking is not the only way to handle dependencies for tests. We will see a
    different approach next.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While mocking replaces the dependency without the original code noticing, by
    patching it externally, dependency injection is a technique to make that dependency
    explicit when calling the function under test, so it can be replaced with a testing
    substitute.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In essence, it's a way of designing the code that makes dependencies explicit
    by requiring them as input parameters.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection, while useful for testing, is not only aimed at that. By
    adding the dependencies explicitly, it also reduces the need for a function to
    know how to initialize a particular dependency, instead relying on the interface
    of the dependency. It creates a separation between "initializing" a dependency
    (which should be taken care of externally) and "using" it (which is the only part
    that the dependent code will do). This differentiation will become clearer later
    when we see an OOP example.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this changes the code under test.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how now the `sqrt` function is an input parameter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: If we want to use the `parameter_dependent` function in a normal scenario, we
    will have to produce the dependency, for example.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And if we want to perform tests, we can do it by replacing the `math.sqrt`
    function with a specific function, and then using it. For example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can also provoke an error if calling the dependency to ensure that in some
    tests the dependency is not used, for example.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note how this approach is more explicit than mocking. The code to test becomes,
    in essence, totally functional as it doesn't have external dependencies.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in OOP
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dependency injection can also be used with OOP. In this case, we can start with
    code that is like this.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we can see, the `settings` class stores different elements that are required
    on where the data will be stored. The model receives some data and then saves
    it. The code in operation will require minimal initialization.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The model receives some data and then saves it. The code in operation requires
    minimal initialization, but at the same time, it's not explicit.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'To use dependency injection principles, the code will need to be written in
    this way:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, every value that is a dependency is provided explicitly. In the
    definition of the code, the `settings` module is not present anywhere, but instead,
    that will be specified when the class is instantiated. The code will now need
    to define the configuration directly.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can compare how to test both cases, as seen in the file `test_dependency_injection_test.py`.
    The first test is mocking, as we saw before, the `write` method of the `Writer`
    class to assert that it has been called correctly.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Compared to that, the dependency injection example doesn't require a mock through
    monkey-patching. It just creates its own `Writer` that simulates the interface.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This second style is more verbose, but it shows some of the differences when
    writing code in this way:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: No monkey-patching mock is required. Monkey-patching can be quite fragile, as
    it's meddling with internal code that's not supposed to be exposed. While in testing
    this interference is not the same as doing it for regular code running, it's still
    something that can be messy and have unintended effects, especially if the internal
    code changes in some unforeseen way.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that mocks will likely involve, at some point, relating to second-level
    dependencies, which can start having strange or complicated effects requiring
    you to spend time handling that extra complexity.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The way of writing the code is different in itself. Code produced with dependency
    injection is, as we've seen, more modular and composed of smaller elements. This
    tends to create smaller and more combinable modules that play along together,
    with fewer unknown dependencies, as they are always explicit.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful, though, as this requires a certain amount of discipline and mental
    framing to produce truly loosely coupled modules. If this is not considered when
    designing the interfaces, the resulting code will instead be artificially divided,
    resulting in tightly coupled code across different modules. Developing this discipline
    requires certain training; do not expect it to come naturally to all developers.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code can sometimes be more difficult to debug, as the configuration will
    be separated from the rest of the code, sometimes making it difficult to understand
    the flow of the code. The complexity can be produced at the interaction of classes,
    which may be more difficult to understand and test. Typically, the upfront effort
    to develop code in this style is a bit greater as well.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection is a very popular technique in certain software circles
    and programming languages. Mocking is more difficult in less dynamic languages
    than Python, and also different programming languages have their own sets of ideas
    on how to structure code. For example, dependency injection is very popular in
    Java, where there are specific tools to work in this style.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Advanced pytest
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we've described the basic functionalities for `pytest`, we barely scratched
    the surface in terms of the number of possibilities that it presents to help generate
    testing code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Pytest is a big and comprehensive tool. It is worth learning how to use it.
    Here, we will only scratch the surface. Be sure to check the official documentation
    at [https://docs.pytest.org/](https://docs.pytest.org/).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Without being exhaustive, we will see some useful possibilities of the tool.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Grouping tests
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is useful to group tests together so they are related to specific
    things, like modules, or to run them in unison. The simplest way of grouping tests
    together is to join them into a single class.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: For example, going back to the test examples before, we could structure tests
    into two classes, as we see in `test_group_classes.py`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is an easy way to divide tests and allows you to run them independently:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Another possibility is to use markers. Markers are indicators that can be added
    through a decorator in the tests, for example, in `test_markers.py`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: See that we are defining a decorator, `@pytest.mark.edge`, on all the tests
    that checks the edge of the values.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: If we execute the tests, we can use the parameter `-m` to run only the ones
    with a certain tag.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The warning `PytestUnknownMarkWarning: Unknown pytest.mark.edge` is produced
    if the marker `edge` is not registered.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the GitHub code includes the `pytest.ini` code. You won't see
    the warning if the `pytest.ini` file is present, for example, if you clone the
    whole repo.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: This is very useful for finding typos, like accidentally writing `egde` or similar.
    To avoid this warning, you'll need to add a `pytest.ini` config file with the
    definition of the markers, like this.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, running the tests shows no warning.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that markers can be used across the full test suite, including multiple
    files. That allows for making markers to identify common patterns across the tests,
    for example, creating a quick test suite with the most important tests to run
    with the marker `basic`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: There are also some predefined markers with some built-in features. The most
    common ones are `skip` (which will skip the test) and `xfail` (which will reverse
    the test, meaning that it expects it to fail).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Using fixtures
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of fixtures is the preferred way to set up tests in `pytest`. A fixture,
    in essence, is a context created to set up a test.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures are used as input for the test functions, so they can be set up and
    create specific environments for the test to be created.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's take a look at a simple function that counts the number of
    occurrences of a character in a string.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That's a pretty simple loop that iterates through the string and counts the
    matching characters.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to using the function `.count()` for a string, but this is
    included to present a working function. It could be refactored afterward!
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: A regular test to cover the functionalities could be as follows.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Pretty straightforward. Now let's see how we can define a fixture to define
    a setup, in case we want to replicate it.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'First of all, the fixture is decorated with `pytest.fixture` to mark it as
    such. A fixture is divided into three steps:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**: Here, we simply defined a string, but this will probably be the
    biggest part, where the values are prepared.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return the value**: If we use the `yield` functionality, we will be able
    to go to the next step; if not, the fixture will finish here.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Teardown and clean up values**: Here, we simply delete the variable as an
    example, though this will happen automatically later.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we will see a more complex fixture. Here, we are just presenting the
    concept.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Defining the fixture this way will allow us to reuse it easily in different
    test functions, just using the name as the input parameter.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note how the `prepare_string` parameter is automatically providing the value
    that we defined with `yield`. If we run the tests, we can see the effect. Even
    more, we can use the parameter `--setup-show` to see the setup and tear down all
    of the fixtures.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This fixture was very simple and did not do anything that couldn't be done defining
    the string, but fixtures can be used to connect to a database or prepare files,
    taking into account that they can clean them up at the end.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: For example, complicating the same example a bit, instead of counting from a
    string, it should count from a file, so the function needs to open a file, read
    it, and count the characters. The function will be like this.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The fixture should then create a file, return it, and then remove it as part
    of the teardown. Let's take a look at it.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that in the filename, we define the name adding the timestamp when it's
    generated. This means that each of the files that will be generated by this fixture
    will be unique.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The file then gets created and the data is written.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The name of the file, which, as we've seen, is unique, gets yielded. Finally,
    the file is deleted in the teardown.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The tests are similar to the previous ones, as most of the complexity is stored
    in the fixture.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When running it, we see it works as expected, and we can check that the teardown
    step deletes the testing files after each test.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Fixtures don't need to be defined in the same file. They can also be stored
    in a special file called `conftest.py`, which will automatically be shared by
    `pytest` across all the tests.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixtures can also be combined, they can be set to be used automatically, and
    there are already built-in fixtures to work with temporal data and directories
    or capture output. There are also a lot of plugins for useful fixtures in PyPI,
    installable as third-party modules, covering functionality like connecting to
    databases or interacting with other external resources. Be sure to check the Pytest
    documentation and to search before implementing your own fixture to see if you
    can leverage an already existing module: [https://docs.pytest.org/en/latest/explanation/fixtures.html#about-fixtures](https://docs.pytest.org/en/latest/explanation/fixtures.html#about-fixtures).'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we only scratched the surface in terms of the possibilities
    of `pytest`. It is a fantastic tool and one that I encourage you to learn about.
    It will pay off greatly to efficiently run tests and design them in the best possible
    way. Testing is a critical part of a project and it's one of the development stages
    where developers spend most of their time.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the whys and hows of tests to describe how
    a good testing strategy is required to produce high-quality software and prevent
    problems once the code is in use by customers.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: We started by describing the general principles behind testing, how to make
    tests that provide more value than their cost, and the different levels of testing
    to ensure this. We saw the three main levels of tests, which we called unit tests
    (parts of a single component), system tests (the whole system), and integration
    tests in the middle (a whole component or several components, but not all).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: We continued by describing different strategies to ensure that our tests are
    great ones, and how to structure them using the Arrange-Act-Assert pattern, for
    ease of writing and understanding them after they are written.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Later, we described in detail the principles behind Test-Driven Development,
    a technique that puts tests at the center of development, which mandates writing
    the tests before the code, working in small increments, and running the tests
    over and over to create a good test suite that protects against unexpected behavior.
    We also analyzed the limits and caveats of working in a TDD fashion and provided
    an example of what the flow looks like.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: We continued by presenting ways of creating unit tests in Python, both using
    the standard `unittest` module and by introducing the more powerful `pytest`.
    We also presented a section with advanced usage of `pytest` to show a bit of what
    this great third-party module is capable of.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: We described how to test external dependencies, something that is critically
    important when writing unit tests to isolate functionality. We also described
    how to mock dependencies and how to work under the dependency injection principles.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
