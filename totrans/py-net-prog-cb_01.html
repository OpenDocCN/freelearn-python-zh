<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 1. Sockets, IPv4, and Simple Client/Server Programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Sockets, IPv4, and Simple Client/Server Programming</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Printing your machine's name and IPv4 address</li><li class="listitem" style="list-style-type: disc">Retrieving a remote machine's IP address</li><li class="listitem" style="list-style-type: disc">Converting an IPv4 address to different formats</li><li class="listitem" style="list-style-type: disc">Finding a service name, given the port and protocol</li><li class="listitem" style="list-style-type: disc">Converting integers to and from host to network byte order</li><li class="listitem" style="list-style-type: disc">Setting and getting the default socket timeout</li><li class="listitem" style="list-style-type: disc">Handling socket errors gracefully</li><li class="listitem" style="list-style-type: disc">Modifying a socket's send/receive buffer size</li><li class="listitem" style="list-style-type: disc">Changing a socket to the blocking/non-blocking mode</li><li class="listitem" style="list-style-type: disc">Reusing socket addresses</li><li class="listitem" style="list-style-type: disc">Printing the current time from the Internet time server</li><li class="listitem" style="list-style-type: disc">Writing a SNTP client</li><li class="listitem" style="list-style-type: disc">Writing a simple echo client/server application</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>This chapter introduces Python's core networking library through some simple recipes. Python's <code class="literal">socket</code> module has both class-based and instances-based utilities. The difference between a class-based and instance-based method is that the former doesn't need an instance of a socket object. This is a very intuitive approach. For example, in order to print your machine's IP address, you don't need a socket object. Instead, you can just call the socket's class-based methods. On the other hand, if you need to send some data to a server application, it is more intuitive that you create a socket object to perform that explicit operation. The recipes presented in this chapter can be categorized into three groups as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first few recipes, the class-based utilities have been used in order to extract some useful information about host, network, and any target service.</li><li class="listitem" style="list-style-type: disc">After that, some more recipes have been presented using the instance-based utilities. Some common socket tasks, including manipulating the socket timeout, buffer size, blocking mode, and so on, have been demonstrated.</li><li class="listitem" style="list-style-type: disc">Finally, both class-based and instance-based utilities have been used to construct some clients, which perform some practical tasks, for example, synchronizing the machine time with an Internet server or writing a generic client/server script.</li></ul></div><p>You can use these demonstrated approaches to write your own client/server application.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Printing your machine's name and IPv4 address"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Printing your machine's name and IPv4 address</h1></div></div></div><p>Sometimes, you need to quickly<a id="id0" class="indexterm"/> discover some information about your machine, <a id="id1" class="indexterm"/>for example, the host name, IP address, number of network interfaces, and so on. This is very easy to achieve using Python scripts.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting ready</h2></div></div></div><p>You need to install Python on your machine before you start coding. Python comes preinstalled in most of the Linux distributions. For Microsoft Windows operating system, you can download binaries from the Python<a id="id2" class="indexterm"/> website: <a class="ulink" href="http://www.python.org/download/">http://www.python.org/download/</a></p><p>You may consult the documentation of your OS to check and review your Python setup. After installing Python on your machine, you can try opening the Python interpreter from the command line by typing <code class="literal">python</code>. This will show the interpreter prompt, <code class="literal">&gt;&gt;&gt;</code>, which should be similar to the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ python </strong></span>
<span class="strong"><strong>Python 2.7.1+ (r271:86832, Apr 11 2011, 18:05:24) </strong></span>
<span class="strong"><strong>[GCC 4.5.2] on linux2 </strong></span>
<span class="strong"><strong>Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; </strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How to do it...</h2></div></div></div><p>As this recipe is very short, you can try this in the Python interpreter interactively.</p><p>First, we need to import the Python <code class="literal">socket</code> library with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import socket</strong></span>
</pre></div><p>Then, we call the <code class="literal">gethostname()</code> method<a id="id3" class="indexterm"/> from the <code class="literal">socket</code> library and store the result in a variable as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; host_name = socket.gethostname()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Host name: %s" %host_name</strong></span>
<span class="strong"><strong>Host name: debian6</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "IP address: %s" %socket.gethostbyname(host_name)</strong></span>
<span class="strong"><strong>IP address: 127.0.1.1</strong></span>
</pre></div><p>The entire activity can be wrapped in a free-standing function, <code class="literal">print_machine_info()</code>, which uses the built-in socket class methods.</p><p>We call our function from the usual Python <code class="literal">__main__</code> block. During runtime, Python assigns values to some internal variables such as <code class="literal">__name__</code>. In this case, <code class="literal">__name__</code> refers to the name of the calling process. When running this script from the command line, as shown in the following<a id="id4" class="indexterm"/> command, the name will be <code class="literal">__main__</code>, but it will be different if the module is imported from another script. This means that when the module is called <a id="id5" class="indexterm"/>from the command line, it will automatically run our <code class="literal">print_machine_info</code> function<a id="id6" class="indexterm"/>; however, when imported separately, the user will need to explicitly call the function.</p><p>Listing 1.1 shows how to get our machine info, as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter -1 
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications.

import socket

def print_machine_info():
    host_name = socket.gethostname()
    ip_address = socket.gethostbyname(host_name)
    print "Host name: %s" % host_name
    print "IP address: %s" % ip_address

if __name__ == '__main__':
    print_machine_info()</pre></div><p>In order to run this recipe, you can use the provided source file from the command line as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_1_local_machine_info.py</strong></span>
</pre></div><p>On my machine, the following output is shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Host name: debian6</strong></span>
<span class="strong"><strong>IP address: 127.0.0.1</strong></span>
</pre></div><p>This output will be different on your machine depending on the system's host configuration.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How it works...</h2></div></div></div><p>The import socket statement imports one of Python's core networking libraries. Then, we use the two utility functions<a id="id7" class="indexterm"/>, <code class="literal">gethostname()</code> and <code class="literal">gethostbyname(host_name)</code>. <a id="id8" class="indexterm"/>You can type <code class="literal">help(socket.gethostname)</code> to see the online help information from within the command line. Alternately, you can<a id="id9" class="indexterm"/> type the following address in your web<a id="id10" class="indexterm"/> browser at <a class="ulink" href="http://docs.python.org/3/library/socket.html">http://docs.python.org/3/library/socket.html</a>. You can refer to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gethostname(...)</strong></span>
<span class="strong"><strong>    gethostname() -&gt; string </strong></span>
<span class="strong"><strong>    Return the current host name. </strong></span>

<span class="strong"><strong>gethostbyname(...) </strong></span>
<span class="strong"><strong>   gethostbyname(host) -&gt; address </strong></span>
<span class="strong"><strong>    Return the IP address (a string of the form '255.255.255.255') for a host.</strong></span>
</pre></div><p>The first function takes no parameter and returns the current or localhost name. The second function takes a single <code class="literal">hostname</code> parameter<a id="id11" class="indexterm"/> and returns its IP address.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Retrieving a remote machine's IP address"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Retrieving a remote machine's IP address</h1></div></div></div><p>Sometimes, you need to<a id="id12" class="indexterm"/> translate a machine's hostname into its <a id="id13" class="indexterm"/>corresponding IP address, for example, a quick domain name lookup. This recipe introduces a simple function to do that.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>How to do it...</h2></div></div></div><p>If you need to know the IP address of a remote machine, you can use a built-in library function, <code class="literal">gethostbyname()</code>. In this case, you need to pass the remote hostname as its parameter.</p><p>In this case, we need to call the <code class="literal">gethostbyname()</code> class function. Let's have a look inside this short code snippet.</p><p>Listing 1.2 shows how to get a remote machine's IP address as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 1
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket

def get_remote_machine_info():
    remote_host = 'www.python.org'
    try:
        print "IP address: %s" %socket.gethostbyname(remote_host)
    except socket.error, err_msg:
        print "%s: %s" %(remote_host, err_msg)
    
if __name__ == '__main__':
    get_remote_machine_info()</pre></div><p>If you run the preceding code it gives the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_2_remote_machine_info.py </strong></span>
<span class="strong"><strong>IP address of www.python.org: 82.94.164.162</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How it works...</h2></div></div></div><p>This recipe wraps the <code class="literal">gethostbyname()</code> method inside a user-defined function called <code class="literal">get_remote_machine_info()</code>.<a id="id14" class="indexterm"/> In this recipe, <a id="id15" class="indexterm"/>we introduced the notion of exception handling. As you can see, we wrapped the main function call inside a <code class="literal">try-except</code> block. This means<a id="id16" class="indexterm"/> that if some error occurs during the execution of this function, this error will be dealt with by this <code class="literal">try-except</code> block.</p><p>For example, let's change the <code class="literal">remote_host</code> value and replace <a class="ulink" href="http://www.python.org">www.python.org</a> with something non-existent, for example, <code class="literal">www.pytgo.org</code>. Now run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_2_remote_machine_info.py </strong></span>
<span class="strong"><strong>www.pytgo.org: [Errno -5] No address associated with hostname</strong></span>
</pre></div><p>The <code class="literal">try-except</code> block catches the error and shows the user an error message that there is no IP address associated with the hostname, <code class="literal">www.pytgo.org</code>.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting an IPv4 address to different formats"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Converting an IPv4 address to different formats</h1></div></div></div><p>When you would like to deal with low-level network functions, sometimes, the usual string notation of IP addresses are<a id="id17" class="indexterm"/> not very useful. They need to be converted to the packed 32-bit binary formats.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it...</h2></div></div></div><p>The Python socket library has utilities to deal with the various IP address formats. Here, we will use two of them: <code class="literal">inet_aton()</code> and <code class="literal">inet_ntoa()</code>.</p><p>Let us create the <code class="literal">convert_ip4_address()</code> function<a id="id18" class="indexterm"/>, where <code class="literal">inet_aton()</code> and <code class="literal">inet_ntoa()</code> will be used for the IP address conversion. We will use two sample IP addresses, <code class="literal">127.0.0.1</code> and <code class="literal">192.168.0.1</code>.</p><p>Listing 1.3 shows <code class="literal">ip4_address_conversion</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 1
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket
from binascii import hexlify

def convert_ip4_address():
    for ip_addr in ['127.0.0.1', '192.168.0.1']:
        packed_ip_addr = socket.inet_aton(ip_addr)
        unpacked_ip_addr = socket.inet_ntoa(packed_ip_addr)
        print "IP Address: %s =&gt; Packed: %s, Unpacked: %s"\
	 %(ip_addr, hexlify(packed_ip_addr), unpacked_ip_addr)
    
if __name__ == '__main__':
    convert_ip4_address()</pre></div><p>Now, if you run this recipe, you will see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_3_ip4_address_conversion.py </strong></span>

<span class="strong"><strong>IP Address: 127.0.0.1 =&gt; Packed: 7f000001, Unpacked: 127.0.0.1</strong></span>
<span class="strong"><strong>IP Address: 192.168.0.1 =&gt; Packed: c0a80001, Unpacked: 192.168.0.1</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works...</h2></div></div></div><p>In this recipe, the two IP addresses have been converted from a string to a 32-bit packed format using a <code class="literal">for-in</code> statement. <a id="id19" class="indexterm"/>Additionally, the Python <code class="literal">hexlify</code> function<a id="id20" class="indexterm"/> is called from the <code class="literal">binascii</code> module. This helps to represent the binary data in a hexadecimal format.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Finding a service name, given the port and protocol"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Finding a service name, given the port and protocol</h1></div></div></div><p>If you would like to discover<a id="id21" class="indexterm"/> network services, it may<a id="id22" class="indexterm"/> be helpful to determine what network services run on which ports using either the TCP or UDP protocol.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Getting ready</h2></div></div></div><p>If you know the port number of a network service, you can find the service name using the <code class="literal">getservbyport()</code> socket class function<a id="id23" class="indexterm"/> from the socket library. You can optionally give the protocol name when calling this function.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How to do it...</h2></div></div></div><p>Let us define a <code class="literal">find_service_name()</code> function<a id="id24" class="indexterm"/>, where the <code class="literal">getservbyport()</code> socket class function will be called with a few ports, for example, <code class="literal">80, 25</code>. We can use Python's <code class="literal">for-in</code> loop construct.</p><p>Listing 1.4 shows <code class="literal">finding_service_name</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter -  1
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.

import socket

def find_service_name():
    protocolname = 'tcp'
    for port in [80, 25]:
        print "Port: %s =&gt; service name: %s" %(port, socket.getservbyport(port, protocolname))
    print "Port: %s =&gt; service name: %s" %(53, socket.getservbyport(53, 'udp'))
    
if __name__ == '__main__':
    find_service_name()</pre></div><p>If you run this script, you will see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_4_finding_service_name.py </strong></span>

<span class="strong"><strong>Port: 80 =&gt; service name: http</strong></span>
<span class="strong"><strong>Port: 25 =&gt; service name: smtp</strong></span>
<span class="strong"><strong>Port: 53 =&gt; service name: domain</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How it works...</h2></div></div></div><p>In this recipe, <code class="literal">for-in</code> statement<a id="id25" class="indexterm"/> is used to iterate over a sequence of variables.  So for each iteration we use  one IP address to convert them<a id="id26" class="indexterm"/> in their packed and unpacked format.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting integers to and from host to network byte order"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Converting integers to and from host to network byte order</h1></div></div></div><p>If you ever need to write a low-level network application, it may be necessary to handle the low-level data transmission<a id="id27" class="indexterm"/> over the wire between two machines. This operation requires some sort of conversion of data from the<a id="id28" class="indexterm"/> native host operating system to the network format and vice versa. This is because each one has its own specific representation of data.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How to do it...</h2></div></div></div><p>Python's socket library has utilities for converting from a network byte order to host byte order and vice versa. You may want to become familiar with them, for example, <code class="literal">ntohl()</code>/<code class="literal">htonl()</code>.</p><p>Let us define the <code class="literal">convert_integer()</code> function<a id="id29" class="indexterm"/>, where the <code class="literal">ntohl()</code>/<code class="literal">htonl()</code> socket class functions are used to convert IP address formats.</p><p>Listing 1.5 shows <code class="literal">integer_conversion</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
import socket
def convert_integer():
    data = 1234
    # 32-bit
    print "Original: %s =&gt; Long  host byte order: %s, Network byte order: %s"\
    %(data, socket.ntohl(data), socket.htonl(data))
    # 16-bit
    print "Original: %s =&gt; Short  host byte order: %s, Network byte order: %s"\
    %(data, socket.ntohs(data), socket.htons(data))
if __name__ == '__main__':
    convert_integer()</pre></div><p>If you run this recipe, you will see the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_5_integer_conversion.py </strong></span>
<span class="strong"><strong>Original: 1234 =&gt; Long  host byte order: 3523477504, Network byte order: 3523477504</strong></span>
<span class="strong"><strong>Original: 1234 =&gt; Short  host byte order: 53764, Network byte order: 53764</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How it works...</h2></div></div></div><p>Here, we take an integer and show how to convert it between network and host byte orders. The <code class="literal">ntohl()</code> socket class function<a id="id30" class="indexterm"/> converts from the network byte order to host byte order in a long format.<a id="id31" class="indexterm"/> Here, <code class="literal">n</code> represents network <a id="id32" class="indexterm"/>and <code class="literal">h</code> represents host; <code class="literal">l</code> represents long and <code class="literal">s</code> represents short, that is 16-bit.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Setting and getting the default socket timeout"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Setting and getting the default socket timeout</h1></div></div></div><p>Sometimes, you need to<a id="id33" class="indexterm"/> manipulate the default values of certain properties <a id="id34" class="indexterm"/>of a socket library,<a id="id35" class="indexterm"/> for example, the socket timeout.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it...</h2></div></div></div><p>You can make an<a id="id36" class="indexterm"/> instance of a socket object and call a <code class="literal">gettimeout()</code> method to get the default timeout value and the <code class="literal">settimeout()</code> method to set a specific timeout value. This is very useful in developing custom server applications.</p><p>We first create a socket object inside a <code class="literal">test_socket_timeout()</code> function<a id="id37" class="indexterm"/>. Then, we can use the getter/setter instance methods to manipulate timeout values.</p><p>Listing 1.6 shows <code class="literal">socket_timeout</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 1
# This program is optimized for Python 2.7. It may run on any   
# other Python version with/without modifications

import socket

def test_socket_timeout():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print "Default socket timeout: %s" %s.gettimeout()
    s.settimeout(100)
    print "Current socket timeout: %s" %s.gettimeout()    
    
if __name__ == '__main__':
    test_socket_timeout()</pre></div><p>After running the preceding script, you can see how this modifies the default socket timeout as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_6_socket_timeout.py </strong></span>
<span class="strong"><strong>Default socket timeout: None</strong></span>
<span class="strong"><strong>Current socket timeout: 100.0</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>In this code snippet, we have first created a socket object by passing the socket family and socket type as the first and second <a id="id38" class="indexterm"/>arguments of the socket constructor. Then, you<a id="id39" class="indexterm"/> can get the socket timeout value by calling <code class="literal">gettimeout()</code> and alter the value by calling the <code class="literal">settimeout()</code> method. The timeout value passed to the <code class="literal">settimeout()</code> method can be in seconds (non-negative float) or <code class="literal">None</code>. This method is used for manipulating <a id="id40" class="indexterm"/>the<a id="id41" class="indexterm"/> blocking-socket operations. Setting a timeout of <code class="literal">None</code> disables timeouts on socket operations.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Handling socket errors gracefully"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Handling socket errors gracefully</h1></div></div></div><p>In any networking application, it is very common that one end is trying to connect, but the other party is not responding<a id="id42" class="indexterm"/> due to networking media failure or any other reason. The Python socket library has an elegant method of handing these errors via the <code class="literal">socket.error</code> exceptions. In this recipe, a few examples are presented.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it...</h2></div></div></div><p>Let us create a few try-except code blocks and put one potential error type in each block. In order to get a user input, the <code class="literal">argparse</code> module can be used. This module is more powerful than simply parsing command-line arguments using <code class="literal">sys.argv</code>. In the try-except blocks, put typical socket operations, for example, create a socket object, connect to a server, send data, and wait for a reply.</p><p>The following recipe illustrates the concepts in a few lines of code.</p><p>Listing 1.7 shows <code class="literal">socket_errors</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 1
# This program is optimized for Python 2.7. It may run on any   
# other Python version with/without modifications.

import sys
import socket
import argparse 


def main():
    # setup argument parsing
    parser = argparse.ArgumentParser(description='Socket Error Examples')
    parser.add_argument('--host', action="store", dest="host", required=False)
    parser.add_argument('--port', action="store", dest="port", type=int, required=False)
    parser.add_argument('--file', action="store", dest="file", required=False)
    given_args = parser.parse_args()
    host = given_args.host
    port = given_args.port
    filename = given_args.file
    
    # First try-except block -- create socket 
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    except socket.error, e:
        print "Error creating socket: %s" % e
        sys.exit(1)
    
    # Second try-except block -- connect to given host/port
    try:
        s.connect((host, port))
    except socket.gaierror, e:
        print "Address-related error connecting to server: %s" % e
        sys.exit(1)
    except socket.error, e:
        print "Connection error: %s" % e
        sys.exit(1)
    
    # Third try-except block -- sending data
    try:
        s.sendall("GET %s HTTP/1.0\r\n\r\n" % filename)
    except socket.error, e:
        print "Error sending data: %s" % e
        sys.exit(1)
    
    while 1:
        # Fourth tr-except block -- waiting to receive data from remote host
        try:
            buf = s.recv(2048)
        except socket.error, e:
            print "Error receiving data: %s" % e
            sys.exit(1)
        if not len(buf):
            break
        # write the received data
        sys.stdout.write(buf) 
    
if __name__ == '__main__':
    main()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How it works...</h2></div></div></div><p>In Python, passing <a id="id43" class="indexterm"/>command-line arguments to a script and parsing them in the script can be done using the <code class="literal">argparse</code> module. This is available in Python 2.7. For earlier versions of Python, this module is available separately in <span class="strong"><strong>Python Package Index</strong></span> (<span class="strong"><strong>PyPI</strong></span>). <a id="id44" class="indexterm"/>You can install this via <code class="literal">easy_install</code> or <code class="literal">pip</code>.</p><p>In this recipe, three arguments are set up: a hostname, port number, and filename. The usage of this script is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_7_socket_errors.py –host=&lt;HOST&gt; --port=&lt;PORT&gt; --file=&lt;FILE&gt;</strong></span>
</pre></div><p>If you try with a non-existent host, this script will print an address error as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_7_socket_errors.py --host=www.pytgo.org --port=8080 --file=1_7_socket_errors.py </strong></span>
<span class="strong"><strong>Address-related error connecting to server: [Errno -5] No address associated with hostname</strong></span>
</pre></div><p>If there is no service on a specific port and if you try to connect to that port, then this will throw a connection timeout error as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_7_socket_errors.py --host=www.python.org --port=8080 --file=1_7_socket_errors.py </strong></span>
</pre></div><p>This will return the following error since the host, <a class="ulink" href="http://www.python.org">www.python.org</a>, is not listening on port 8080:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Connection error: [Errno 110] Connection timed out</strong></span>
</pre></div><p>However, if you send an arbitrary request to a correct request to a correct port, the error may not be caught in the <a id="id45" class="indexterm"/>application level. For example, running the following script returns no error, but the HTML output tells us what's wrong with this script:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_7_socket_errors.py --host=www.python.org --port=80 --file=1_7_socket_errors.py</strong></span>

<span class="strong"><strong>HTTP/1.1 404 Not found</strong></span>
<span class="strong"><strong>Server: Varnish</strong></span>
<span class="strong"><strong>Retry-After: 0</strong></span>
<span class="strong"><strong>content-type: text/html</strong></span>
<span class="strong"><strong>Content-Length: 77</strong></span>
<span class="strong"><strong>Accept-Ranges: bytes</strong></span>
<span class="strong"><strong>Date: Thu, 20 Feb 2014 12:14:01 GMT</strong></span>
<span class="strong"><strong>Via: 1.1 varnish</strong></span>
<span class="strong"><strong>Age: 0</strong></span>
<span class="strong"><strong>Connection: close</strong></span>

<span class="strong"><strong>&lt;html&gt;</strong></span>
<span class="strong"><strong>&lt;head&gt;</strong></span>
<span class="strong"><strong>&lt;title&gt; &lt;/title&gt;</strong></span>
<span class="strong"><strong>&lt;/head&gt;</strong></span>
<span class="strong"><strong>&lt;body&gt;</strong></span>
<span class="strong"><strong>unknown domain: &lt;/body&gt;&lt;/html&gt;</strong></span>
</pre></div><p>In the preceding example, four try-except blocks have been used. All blocks use <code class="literal">socket.error</code> except the second block, which uses <code class="literal">socket.gaierror</code>. This is used for address-related errors. There <a id="id46" class="indexterm"/>are two other types of exceptions: <code class="literal">socket.herror</code> is used for legacy C API, and if you use the <code class="literal">settimeout()</code> method in a socket, <code class="literal">socket.timeout</code> will be raised when a timeout occurs on that socket.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Modifying socket's send/receive buffer sizes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Modifying socket's send/receive buffer sizes</h1></div></div></div><p>The default socket buffer size may not be suitable in many circumstances. In such circumstances, you can change the default socket buffer size to a more suitable value.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it...</h2></div></div></div><p>Let us manipulate the default socket buffer size<a id="id47" class="indexterm"/> using a socket object's <code class="literal">setsockopt()</code> method.</p><p>First, define two constants: <code class="literal">SEND_BUF_SIZE</code>/<code class="literal">RECV_BUF_SIZE</code> and then wrap a socket instance's call to the <code class="literal">setsockopt()</code> method in a function. It is also a good idea to check the value of the buffer size before modifying it. Note that we need to set up the send and receive buffer size separately.</p><p>Listing 1.8 shows how to modify socket send/receive buffer sizes<a id="id48" class="indexterm"/> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications

import socket

SEND_BUF_SIZE = 4096
RECV_BUF_SIZE = 4096

def modify_buff_size():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )
    
    # Get the size of the socket's send buffer
    bufsize = sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)
    print "Buffer size [Before]:%d" %bufsize
    
    sock.setsockopt(socket.SOL_TCP, socket.TCP_NODELAY, 1)
    sock.setsockopt(
            socket.SOL_SOCKET,
            socket.SO_SNDBUF,
            SEND_BUF_SIZE)
    sock.setsockopt(
            socket.SOL_SOCKET,
            socket.SO_RCVBUF,
            RECV_BUF_SIZE)
    bufsize = sock.getsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF)
    print "Buffer size [After]:%d" %bufsize

if __name__ == '__main__':
    modify_buff_size()</pre></div><p>If you run the preceding script, it will show the changes in the socket's buffer size. The following output may be different on your machine depending on your operating system's local settings:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_8_modify_buff_size.py </strong></span>
<span class="strong"><strong>Buffer size [Before]:16384</strong></span>
<span class="strong"><strong>Buffer size [After]:8192</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>You can call the <code class="literal">getsockopt()</code> <a id="id49" class="indexterm"/>and <code class="literal">setsockopt()</code> methods on a socket object to retrieve and modify the socket object's properties respectively. The <code class="literal">setsockopt()</code> method takes three arguments: <code class="literal">level</code>, <code class="literal">optname</code>, and <code class="literal">value</code>. Here, <code class="literal">optname</code> takes the option name and <code class="literal">value</code> is the<a id="id50" class="indexterm"/> corresponding <a id="id51" class="indexterm"/>value of that option. For the first argument, the needed symbolic constants can be found in the socket module (<code class="literal">SO_*etc.</code>).</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Changing a socket to the blocking/non-blocking mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Changing a socket to the blocking/non-blocking mode</h1></div></div></div><p>By default, TCP sockets are placed in a blocking mode. This means the control is not returned to your program<a id="id52" class="indexterm"/> until some specific operation is complete. For example, if you call the <code class="literal">connect()</code> API, the connection blocks your program until the operation is complete. On many occasions, you don't want to keep your program waiting forever, either for a response from the server or for any error to stop the operation. For example, when you write a web browser client that connects to a web server, you should consider a stop functionality that can cancel the connection process in the middle of this operation. This can be achieved by placing the socket in the non-blocking mode.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How to do it...</h2></div></div></div><p>Let us see what options are available under Python. In Python, a socket can be placed in the blocking or non-blocking mode. In the non-blocking mode, if any call to API, for example, <code class="literal">send()</code> or <code class="literal">recv()</code>, encounters any problem, an error will be raised. However, in the blocking mode, this will not stop the operation. We can create a normal TCP socket and experiment with both the blocking and non-blocking operations.</p><p>In order to manipulate the<a id="id53" class="indexterm"/> socket's blocking nature, we need to create a socket object first.</p><p>We can then call <code class="literal">setblocking(1)</code> to set up blocking or <code class="literal">setblocking(0)</code> to unset blocking. Finally, we bind the socket to a specific port and listen for incoming connections.</p><p>Listing 1.9 shows how the socket changes to blocking or non-blocking mode as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications

import socket

def test_socket_modes():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setblocking(1)
    s.settimeout(0.5)
    s.bind(("127.0.0.1", 0))
    
    socket_address = s.getsockname()
    print "Trivial Server launched on socket: %s" %str(socket_address)
    while(1):
        s.listen(1)

if __name__ == '__main__':
    test_socket_modes()</pre></div><p>If you run this recipe, it will launch a trivial server that has the blocking mode enabled as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_9_socket_modes.py </strong></span>
<span class="strong"><strong>Trivial Server launched on socket: ('127.0.0.1', 51410)</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How it works...</h2></div></div></div><p>In this recipe, we enable blocking on a socket by setting the value <code class="literal">1</code> in the <code class="literal">setblocking()</code> method<a id="id54" class="indexterm"/>. Similarly, you can unset the value <code class="literal">0</code> in this method to make it non-blocking.</p><p>This feature will be reused in<a id="id55" class="indexterm"/> some later recipes, where its real purpose will be elaborated.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Reusing socket addresses"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Reusing socket addresses</h1></div></div></div><p>You want to run a socket server always on a specific port even after it is closed intentionally or unexpectedly. <a id="id56" class="indexterm"/>This is useful in some cases where your client program always connects to that specific server port. So, you don't need to change the server port.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How to do it...</h2></div></div></div><p>If you run a Python socket server on a specific port and try to rerun it after closing it once, you won't be able to use the same port. It will usually throw an error like the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "1_10_reuse_socket_address.py", line 40, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    reuse_socket_addr()</strong></span>
<span class="strong"><strong>  File "1_10_reuse_socket_address.py", line 25, in reuse_socket_addr</strong></span>
<span class="strong"><strong>    srv.bind( ('', local_port) )</strong></span>
<span class="strong"><strong>  File "&lt;string&gt;", line 1, in bind</strong></span>
<span class="strong"><strong>socket.error: [Errno 98] Address already in use</strong></span>
</pre></div><p>The remedy to this problem is to enable the socket reuse option, <code class="literal">SO_REUSEADDR</code>.</p><p>After creating a socket object, we can query the state of address reuse, say an old state. Then, we call the <code class="literal">setsockopt()</code> method to alter the<a id="id57" class="indexterm"/> value of its address reuse state. Then, we follow the usual steps of binding to an address and listening for incoming client connections. In this example, we catch the <code class="literal">KeyboardInterrupt</code> exception so that if you issue <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span>, then the Python script gets terminated without showing any exception message.</p><p>Listing 1.10 shows how to<a id="id58" class="indexterm"/> reuse socket addresses as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications

import socket
import sys

def reuse_socket_addr():
    sock = socket.socket( socket.AF_INET, socket.SOCK_STREAM )

    # Get the old state of the SO_REUSEADDR option
    old_state = sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR )
    print "Old sock state: %s" %old_state

    # Enable the SO_REUSEADDR option
    sock.setsockopt( socket.SOL_SOCKET, socket.SO_REUSEADDR, 1 )
    new_state = sock.getsockopt( socket.SOL_SOCKET, socket.SO_REUSEADDR )
    print "New sock state: %s" %new_state

    local_port = 8282
    
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind( ('', local_port) )
    srv.listen(1)
    print ("Listening on port: %s " %local_port)
    while True:
        try:
            connection, addr = srv.accept()
            print 'Connected by %s:%s' % (addr[0], addr[1])
        except KeyboardInterrupt:
            break
        except socket.error, msg:
            print '%s' % (msg,)

if __name__ == '__main__':
    reuse_socket_e addr()</pre></div><p>The output from this recipe will be similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_10_reuse_socket_address.py </strong></span>
<span class="strong"><strong>Old sock state: 0</strong></span>
<span class="strong"><strong>New sock state: 1</strong></span>
<span class="strong"><strong>Listening on port: 8282 </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How it works...</h2></div></div></div><p>You may run this script from <a id="id59" class="indexterm"/>one console window and try to connect to this server from another console window<a id="id60" class="indexterm"/> by typing <code class="literal">telnet localhost 8282</code>. After you close the server program, you can rerun it again on the same port. However, if you comment out the line that sets the <code class="literal">SO_REUSEADDR</code>, the server will not run for the second time.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Printing the current time from the Internet time server"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Printing the current time from the Internet time server</h1></div></div></div><p>Many programs rely on the accurate<a id="id61" class="indexterm"/> machine time, such as the <code class="literal">make</code> command in UNIX. Your machine time may be different and need synchronizing<a id="id62" class="indexterm"/> with another time server in your network.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Getting ready</h2></div></div></div><p>In order to synchronize your machine time with one of the Internet time servers<a id="id63" class="indexterm"/>, you can write a Python client for that. For this, <code class="literal">ntplib</code> will be used. Here, the client/server conversation will be done using <span class="strong"><strong>Network Time Protocol</strong></span> (<span class="strong"><strong>NTP</strong></span>). <a id="id64" class="indexterm"/>If <code class="literal">ntplib</code> is not installed on your machine, you can get it from <code class="literal">PyPI</code> with the following command using <code class="literal">pip</code> or <code class="literal">easy_install</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install ntplib</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it...</h2></div></div></div><p>We create an instance of <code class="literal">NTPClient</code> and then we call the <code class="literal">request()</code> method on it by passing the NTP server address.</p><p>Listing 1.11shows how to print the current time from the Internet time server is as follows:</p><div class="informalexample"><pre class="programlisting"> #!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications

import ntplib
from time import ctime

def print_time():
    ntp_client = ntplib.NTPClient()
    response = ntp_client.request('pool.ntp.org')
    print ctime(response.tx_time)

if __name__ == '__main__':
    print_time()</pre></div><p>In my machine, this recipe shows the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_11_print_machine_time.py </strong></span>
<span class="strong"><strong>Thu Mar 5 14:02:58 2012</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works...</h2></div></div></div><p>Here, an NTP client has been<a id="id65" class="indexterm"/> created and an NTP request has been sent<a id="id66" class="indexterm"/> to one of the Internet NTP servers, <code class="literal">pool.ntp.org</code>. The <code class="literal">ctime()</code> function<a id="id67" class="indexterm"/> is used for printing the response.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing a SNTP client"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>Writing a SNTP client</h1></div></div></div><p>Unlike the previous recipe, sometimes, <a id="id68" class="indexterm"/>you don't need to get the precise time from the NTP server. You can use a simpler version of NTP called simple network time protocol.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>How to do it...</h2></div></div></div><p>Let us create a plain SNTP client without using any third-party library.</p><p>Let us first define two constants: <code class="literal">NTP_SERVER</code> and <code class="literal">TIME1970. NTP_SERVER</code> is the server address to which our client will connect, and <code class="literal">TIME1970</code> is the reference time on January 1, 1970 (also called <span class="emphasis"><em>Epoch</em></span>). You may find the value of the Epoch time or convert to the Epoch time at <a class="ulink" href="http://www.epochconverter.com/">http://www.epochconverter.com/</a>. The actual client creates a UDP socket (<code class="literal">SOCK_DGRAM</code>) to connect to the server following the UDP protocol. The client then needs to send the SNTP protocol data (<code class="literal">'\x1b' + 47 * '\0'</code>) in a packet. Our UDP client sends and receives data using the <a id="id69" class="indexterm"/>
<code class="literal">sendto()</code> and<a id="id70" class="indexterm"/> <code class="literal">recvfrom()</code> methods.</p><p>When the server returns the time information in a packed array, the client needs a specialized <code class="literal">struct</code> module to unpack the data. The only interesting data is located in the 11th element of the array. Finally, we need to subtract the reference value, <code class="literal">TIME1970</code>, from the unpacked value to get the actual current time.</p><p>Listing 1.11 shows how to <a id="id71" class="indexterm"/>write an SNTP client as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications
import socket
import struct
import sys
import time

NTP_SERVER = "0.uk.pool.ntp.org"
TIME1970 = 2208988800L

def sntp_client():
    client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    data = '\x1b' + 47 * '\0'
    client.sendto(data, (NTP_SERVER, 123))
    data, address = client.recvfrom( 1024 )
    if data:
        print 'Response received from:', address
    t = struct.unpack( '!12I', data )[10]
    t -= TIME1970
    print '\tTime=%s' % time.ctime(t)

if __name__ == '__main__':
    sntp_client()</pre></div><p>This recipe prints the current time from the Internet time server received with the SNTP protocol as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_12_sntp_client.py </strong></span>
<span class="strong"><strong>Response received from: ('87.117.251.2', 123) </strong></span>
<span class="strong"><strong>      Time=Tue Feb 25 14:49:38 2014 </strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How it works...</h2></div></div></div><p>This SNTP client creates a socket connection and sends the protocol data. After receiving the response from the NTP server (in this case, <code class="literal">0.uk.pool.ntp.org</code>), it unpacks the data with <code class="literal">struct</code>. Finally, it subtracts<a id="id72" class="indexterm"/> the reference time, which is January 1, 1970, and prints the time using the <code class="literal">ctime()</code> built-in method in the Python time module.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing a simple echo client/server application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec21"/>Writing a simple echo client/server application</h1></div></div></div><p>After testing with basic socket <a id="id73" class="indexterm"/>APIs in Python, let us create a socket server and client now. Here, you will have the chance to utilize your basic knowledge gained in the previous recipes.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How to do it...</h2></div></div></div><p>In this example, a server will echo whatever it receives from the client. We will use the Python <code class="literal">argparse</code> module to specify the TCP port from a command line. Both the server and client script will take this argument.</p><p>First, we create the server. We start by creating a TCP socket object. Then, we set the reuse address so that we can run the server as many times as we need. We bind the socket to the given port on our local machine. In the listening stage, we make sure we listen to multiple clients in a queue using the backlog argument to the <code class="literal">listen()</code> method<a id="id74" class="indexterm"/>. Finally, we wait for the client to be connected and send some data to the server. When the data is received, the server echoes back the data to the client.</p><p>Listing 1.13a shows how to write a simple echo client/server application as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications.

import socket
import sys
import argparse

host = 'localhost'
data_payload = 2048
backlog = 5 

def echo_server(port):
    """ A simple echo server """
    # Create a TCP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Enable reuse address/port 
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    # Bind the socket to the port
    server_address = (host, port)
    print "Starting up echo server  on %s port %s" % server_address
    sock.bind(server_address)
    # Listen to clients, backlog argument specifies the max no. of queued connections
    sock.listen(backlog) 
    while True: 
        print "Waiting to receive message from client"
        client, address = sock.accept() 
        data = client.recv(data_payload) 
        if data:
            print "Data: %s" %data
            client.send(data)
            print "sent %s bytes back to %s" % (data, address)
        # end connection
        client.close() 
   
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Socket Server Example')
    parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args() 
    port = given_args.port
    echo_server(port)</pre></div><p>On the client-side code, we create a client socket using the port argument and connect to the server. Then, the client <a id="id75" class="indexterm"/>sends the message, <code class="literal">Test message. This will be echoed</code> to the server, and the client immediately receives the message back in a few segments. Here, two try-except blocks are constructed to catch any exception during this interactive session.</p><p>Listing 1-13b shows the echo client as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter – 1
# This program is optimized for Python 2.7. It may run on any
# other Python version with/without modifications.

import socket
import sys

import argparse

host = 'localhost'

def echo_client(port):
    """ A simple echo client """
    # Create a TCP/IP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Connect the socket to the server
    server_address = (host, port)
    print "Connecting to %s port %s" % server_address
    sock.connect(server_address)
    
    # Send data
    try:
        # Send data
        message = "Test message. This will be echoed"
        print "Sending %s" % message
        sock.sendall(message)
        # Look for the response
        amount_received = 0
        amount_expected = len(message)
        while amount_received &lt; amount_expected:
            data = sock.recv(16)
            amount_received += len(data)
            print "Received: %s" % data
    except socket.errno, e:
        print "Socket error: %s" %str(e)
    except Exception, e:
        print "Other exception: %s" %str(e)
    finally:
        print "Closing connection to the server"
        sock.close()
    
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Socket Server Example')
    parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args() 
    port = given_args.port
    echo_client(port)</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How it works...</h2></div></div></div><p>In order to see the client/server interactions, launch the following server script in one console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_13a_echo_server.py --port=9900 </strong></span>
<span class="strong"><strong>Starting up echo server  on localhost port 9900 </strong></span>

<span class="strong"><strong>Waiting to receive message from client </strong></span>
</pre></div><p>Now, run the client from<a id="id76" class="indexterm"/> another terminal as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 1_13b_echo_client.py --port=9900 </strong></span>
<span class="strong"><strong>Connecting to localhost port 9900 </strong></span>
<span class="strong"><strong>Sending Test message. This will be echoed </strong></span>
<span class="strong"><strong>Received: Test message. Th </strong></span>
<span class="strong"><strong>Received: is will be echoe </strong></span>
<span class="strong"><strong>Received: d </strong></span>
<span class="strong"><strong>Closing connection to the server</strong></span>
</pre></div><p>Upon connecting to the localhost, the client server will also print the following message:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Data: Test message. This will be echoed </strong></span>
<span class="strong"><strong>sent Test message. This will be echoed bytes back to ('127.0.0.1', 42961) </strong></span>
<span class="strong"><strong>Waiting to receive message from client</strong></span>
</pre></div></div></div></div>
</body></html>