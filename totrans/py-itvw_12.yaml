- en: Chapter 12. Sebastian Raschka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Sebastian Raschka](img/B08180_20_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sebastian Raschka received his doctorate in Quantitative Biology and Biochemistry
    and Molecular Biology in 2017, from Michigan State University. His research activities
    included the development of new deep learning architectures to solve problems
    in the field of biometrics. Sebastian is the bestselling author of *Python Machine
    Learning*, which received the ACM Best of Computing award in 2016\. He contributes
    to many open source projects including scikit-learn. Methods that Sebastian implemented
    are being used in real-world machine learning applications such as Kaggle. He
    is passionate about helping people to develop data-driven solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion themes: Python for AI/machine learning, v2.7/v3.x.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Catch up with Sebastian Raschka here: @rasbt**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Mike Driscoll**: Could you give a little background information about yourself?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka**: Of course! My name probably already gives it away, but
    I was born and raised in Germany, where I lived for more than two decades, until
    I had the urge to go on an adventure and study in the US.'
  prefs: []
  type: TYPE_NORMAL
- en: I received my undergraduate degree from Heinrich-Heine University in Düsseldorf.
    I remember one day walking to the cafeteria and stumbling upon a flyer regarding
    a study abroad program with Michigan State University (MSU). I was super intrigued
    and thought that this might be a worthwhile experience. So not long after that,
    I studied for two years at MSU and received a Bachelor Plus/International degree.
  prefs: []
  type: TYPE_NORMAL
- en: During those two semesters, I made many friends at MSU and thought that the
    scientific environment would provide an excellent opportunity for me to grow as
    a scientist, which is why I applied for grad school at MSU. I should say that
    this chapter of my life came with a happy ending, as I obtained my Ph.D. in December
    2017\. So that's my academic career.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''During my time as a graduate student, I got heavily
    involved in open source in the context of data science and machine learning.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: During my time as a graduate student, I got heavily involved in open source
    in the context of data science and machine learning. Also, I am a passionate blogger
    and writer. Some people may have stumbled upon my book, *Python Machine Learning*,
    which was very well-received by both people from academia and the industry.
  prefs: []
  type: TYPE_NORMAL
- en: With my book, I tried to bridge the gap between purely practical (that is, coding)
    books and purely theoretical (i.e., math-heavy) works. Based on all of the feedback
    that I received, *Python Machine Learning* turned out to be super useful to a
    broad audience. The book was translated into seven languages and is currently
    used as a textbook at the Loyola University Chicago, the University of Oxford,
    and many others.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Do you contribute to any open source projects?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: Yes, besides my writings, I am contributing to open source projects
    such as scikit-learn, TensorFlow and PyTorch. I also have my own little open source
    projects that I work on in my free time, including mlxtend and BioPandas.'
  prefs: []
  type: TYPE_NORMAL
- en: mlxtend is a Python library with useful tools for the day-to-day data science
    tasks. It aims to fill the gap in the Python data science system, by providing
    tools that are not yet available in other packages. For example, the stacking
    classifiers and regressors, as well as the sequential feature selection algorithms,
    are very popular in the Kaggle community.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the frequent pattern mining algorithms, including Apriori and algorithms
    for deriving association rules, are super handy. Most recently, I added a lot
    of non-parametric functions, for evaluating machine learning classifiers from
    bootstrapping, to McNemar's tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''To stay most productive, I didn''t want to learn a whole
    new API for each little side project.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The BioPandas project arose from the need to work with molecular structures
    from different file formats more conveniently. During my Ph.D., many projects
    involved working with protein structures, or structures of small (drug-like) molecules.
    There are many tools out there for that, but each has its own little sublanguage.
    To stay most productive, I didn't want to learn a whole new API for each little
    side project.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind BioPandas is to parse structural files into pandas DataFrames,
    a library and format that most data scientists are already familiar with. Once
    the structures are in a DataFrame format, we can use all of the power of pandas
    that is at our disposal, including its super flexible selection syntax.
  prefs: []
  type: TYPE_NORMAL
- en: A virtual screening tool that I recently developed, screenlamp, makes heavy
    use of BioPandas as its core engine. I could screen databases with more than 12
    million molecules efficiently, which led to the successful discovery of potent
    G protein-coupled receptor signaling inhibitors, with applications to aquatic
    invasive species control, in collaboration with experimental biologists at MSU.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''Semi-adversarial networks are a deep learning architecture
    that I developed with my collaborators in the iPRoBe Lab at MSU.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Besides all of my involvement in computational biology, one of my other passion
    projects involves semi-adversarial networks. Semi-adversarial networks are a deep
    learning architecture that I developed with my collaborators in the iPRoBe Lab
    at MSU, which we successfully applied in the context of privacy concerns in the
    field of biometrics.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we applied this architecture to perturb face images in such a
    way that they looked almost identical to the original input images, while soft
    biometric attributes, such as gender, were inaccessible by gender predictors.
    The overall goal is to prevent nasty things like profiling, based on soft biometric
    attributes, without a user's consent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: So why did you become a programmer?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: I would say that the primary driving factor for becoming a programmer
    was to be able to implement my ''crazy'' research ideas.'
  prefs: []
  type: TYPE_NORMAL
- en: In computational biology, we already have many tools at our disposal that we
    can use without the need to program ourselves. However, using existing tools (depending
    on the research task) can also be a bit limiting. If we want to try something
    new, especially if we want to develop new methods, then there is no way around
    learning how to program.
  prefs: []
  type: TYPE_NORMAL
- en: Like most people, I started with simple Bash scripting in a Linux shell. At
    some point, I realized that this wasn't quite enough, or not efficient enough.
    During my undergraduate studies in Germany, I took a bioinformatics class in Perl.
  prefs: []
  type: TYPE_NORMAL
- en: When I saw what was possible with Perl, this was quite an eye-opening experience.
    Later, when I was conducting statistical analyses and preparing data visualizations
    based on the data that I collected, I also got into R. Not long after that, I
    got into Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Why Python?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: Well, I mentioned that I started with Perl and R. However, one
    thing that most programmers have in common is that we consult the internet on
    a regular basis to look for useful pointers, and other tips and tricks for achieving
    certain subtasks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''I stumbled upon many different resources that were written
    in Python and I thought that it would be worthwhile learning this language.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suffice it to say, I stumbled upon many different resources that were written
    in Python and I thought that it would be worthwhile learning this language. At
    some point, I moved away from Perl entirely and did all of my coding in Python:
    custom scripts for data collection, parsing and analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: I also have to mention that I did all of the statistical analyses and plotting
    in R. Actually, not too long ago, when I was revisiting an old project, I stumbled
    upon my old Frankenstein-esque scripts (Bash scripts and makefiles), which were
    running Python and R in tandem.
  prefs: []
  type: TYPE_NORMAL
- en: Now, back in 2012, when the scientific computing stack was growing quickly,
    I stumbled upon NumPy, SciPy, matplotlib and scikit-learn. I realized that everything
    that I did in R, I could also do in Python. I could avoid switching back and forth
    between languages in my projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''I really enjoy being part of and interacting with the
    vivid Python community.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Looking back, picking up Python was probably one of the best decisions that
    I made. Without Python, it wouldn't have been possible for me to be so productive.
    But besides research and work, I really enjoy being part of and interacting with
    the vivid Python community. Whether I am interacting with people via Twitter,
    or meeting people at conferences like PyData and SciPy, it's always a fun experience.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Python is one of the languages that is being used in AI and machine
    learning right now. Could you explain what makes it so popular?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: I think there are two main reasons, which are very related. The
    first reason is that Python is super easy to read and learn.'
  prefs: []
  type: TYPE_NORMAL
- en: I would argue that most people working in machine learning and AI want to focus
    on trying out their ideas in the most convenient way possible. The focus is on
    research and applications, and programming is just a tool to get you there. The
    more comfortable a programming language is to learn, the lower the entry barrier
    is for more math and stats-oriented people.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''I would argue that most people working in machine learning
    and AI want to focus on trying out their ideas in the most convenient way possible.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python is also super readable, which helps with keeping up-to-date with the
    status quo in machine learning and AI, for example, when reading through code
    implementations of algorithms and ideas. Trying new ideas in AI and machine learning
    often requires implementing relatively sophisticated algorithms and the more transparent
    the language, the easier it is to debug.
  prefs: []
  type: TYPE_NORMAL
- en: The second main reason is that while Python is a very accessible language itself,
    we have a lot of great libraries on top of it that make our work easier. Nobody
    would like to spend their time on reimplementing basic algorithms from scratch
    (except in the context of studying machine learning and AI). The large number
    of Python libraries which exist help us to focus on more exciting things than
    reinventing the wheel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''The large number of Python libraries which exist, help
    us to focus on more exciting things than reinventing the wheel.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By the way, Python is also an excellent wrapper language for working with more
    efficient C/C++ implementations of algorithms and CUDA/cuDNN, which is why existing
    machine learning and deep learning libraries run efficiently in Python. This is
    also super important for working in the fields of machine learning and AI.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, I would say that Python is a great language that lets researchers
    and practitioners focus on machine learning and AI and provides less of a distraction
    than other languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Were there any moments where things may have gone another way,
    but surreptitiously ended up the way that they did?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: That''s a good question. Maybe the fact that Python was popular
    among the Linux community, but worked very well on Windows as well. This was likely
    a big contributor to Python becoming so popular today.'
  prefs: []
  type: TYPE_NORMAL
- en: There are relatively similar languages out there like Ruby. The Ruby on Rails
    project was (and still is) super popular. If projects like Django hadn't started,
    Python might have become less popular as an all-rounder, which may have led to
    fewer resources and open source contributions being devoted to developing Python.
    In turn, Python may have been less popular as a language for machine learning
    and AI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''If Travis Oliphant hadn''t started the NumPy project...I
    think fewer scientists would have picked up Python as a scientific programming
    language.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If Travis Oliphant hadn't started the NumPy project (it was called Numeric back
    then in 1995), I think fewer scientists would have picked up Python as a scientific
    programming language early in their careers. We would all still be using MATLAB.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: So is Python just the right tool at the right time, or is there
    another reason that it''s become so important in AI and machine learning?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: I think that''s a bit of a chicken or the egg problem.'
  prefs: []
  type: TYPE_NORMAL
- en: To untangle it, I would say that Python is convenient to use, which led to its
    wide adoption. The community has developed many useful packages in the context
    of scientific computing. Many machine learning and AI developers prefer Python
    as a general programming language for scientific computing, and they have developed
    libraries on top of it, like Theano, MXNet, TensorFlow and PyTorch.
  prefs: []
  type: TYPE_NORMAL
- en: 'On an interesting side note, having been active in the machine learning and
    deep learning communities, there was one thing that I heard very often: "The Torch
    library is awesome, but it is written in Lua, and I don''t want to spend my time
    learning yet another language." Note that we have PyTorch now.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mike Driscoll: Do you think this opens the door for any Python programmer
    to start experimenting with AI?**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Raschka**: I do think so! It depends on how we interpret AI, but regarding
    deep learning and reinforcement learning, there are many convenient packages with
    Python wrappers out there.'
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most popular example at the moment would be TensorFlow. Personally,
    I use both TensorFlow and PyTorch in my current research projects. I have been
    using TensorFlow since it was released in 2015 and like it overall. However, it
    is a bit less flexible when trying out unusual research ideas, which is why I
    recently got more into PyTorch. PyTorch itself is more flexible and its syntax
    is closer to Python; in fact, PyTorch describes itself as "a deep learning framework
    that puts Python first."
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: What could be done to make Python a better language for AI and
    machine learning?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: While Python is a language that is very convenient to use and
    nicely interfaces with C/C++ code, we have to keep in mind that it is not the
    most efficient language.'
  prefs: []
  type: TYPE_NORMAL
- en: Computational efficiency is why C/C++ is still the programming language of choice
    for several machine learning and AI developers. Also, Python is not supported
    on most mobile and embedded devices. Here we have to distinguish between research,
    development and production.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''The convenience of Python comes at a price, which is
    performance.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The convenience of Python comes at a price, which is performance. On the other
    hand, speed and computational efficiency comes with a trade-off in terms of productivity.
    In practice, I think that it's usually best to split tasks when working in a team,
    for instance, having people who specialize in research and trying new ideas, and
    people who specialize in taking prototypes to production.
  prefs: []
  type: TYPE_NORMAL
- en: I am mainly a researcher and haven't run into this problem yet, but I have also
    heard that Python is not good for production. I think this is mainly due to existing
    infrastructure, however, and the tools that are supported by the servers, so it's
    not really Python's fault per se.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''Python doesn''t scale as well as other languages such
    as Java or C++.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, due to its nature as a high-level and general-purpose programming
    language, Python doesn't scale as well as other languages such as Java or C++,
    although they are more tedious to use. For instance, spending too much time in
    the Python runtime, when working with TensorFlow, can be a real performance killer.
    Improving the general efficiency of Python (I don't think this is really possible
    though while keeping Python as convenient as it is) would be beneficial to AI
    and machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''Improving the general efficiency of Python...would be
    beneficial to AI and machine learning.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While Python provides a great environment for rapid prototyping, it is sometimes
    a little bit too forgiving and dynamic types allow you to make mistakes more easily.
    I think the recent introduction of type hints may help to improve this issue to
    some extent. Also, keeping type hints optional is a great idea, because while
    it helps with larger code bases, it can also be an annoyance for smaller coding
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: What are you most excited about in Python today?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: I am super excited that I can do anything that I need in Python.
    I can spend my time efficiently on research and problem solving, without the need
    to spend most of my days learning new tools and programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''I am super happy with the status quo of Python. I am
    excited about the continued development of the fundamental data science libraries
    like NumPy.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sure, sometimes it's good to look beyond the Python ecosystem, to see what's
    out there and what could potentially be useful. However, overall, I am super happy
    with the status quo of Python. I am excited about the continued development of
    the fundamental data science libraries like NumPy, which received a large grant
    from the Moore Foundation to focus on improving the library even further.
  prefs: []
  type: TYPE_NORMAL
- en: Also, I recently saw a conference talk on the redesign of pandas, pandas 2,
    which will make this already great library even more efficient, without changing
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The one thing I am probably most excited about, though, is the great community
    around Python. It's great to feel part of the Python community and to be in the
    same boat regarding advancing the landscape of tools and science. I can share
    knowledge, learn from others and share my excitement with likeminded people.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''It''s great to feel part of the Python community and
    to be in the same boat regarding advancing the landscape of tools and science.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Driscoll**: What do you think about the long life of Python 2.7? Should people
    move over?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: That''s a good question. Personally, I always recommend using
    the latest version of Python. However, I also realize that this is not always
    possible for everyone.'
  prefs: []
  type: TYPE_NORMAL
- en: If your project involves working on or with an older Python 2.7 code base, then
    it may not be feasible to make the switch in terms of resources. Regarding the
    long life of Python 2.7, we all know that Python 2.7 will not be officially maintained
    after 2020\. One thing that might happen is that a subcommunity will take over
    the maintenance of Python 2.7.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''One thing that might happen is that a subcommunity will
    take over the maintenance of Python 2.7.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I also wonder whether it would be worthwhile to spend the energy and resources
    maintaining Python 2.7 after 2020 as a side project, versus taking the time to
    port Python 2.7 code bases over to Python 3.x. The long-term maintenance of Python
    2.7 will always remain uncertain.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I always install the latest version of Python when it comes out
    and do all of my coding in Python 3\. However, most of my projects also support
    Python 2.7\. The reason is that there are still many people using Python 2.7 who
    cannot switch, and I don't want to exclude anyone. So if it does not require any
    major hassle or clunky workarounds, then I write my code in a way that is compatible
    with both Python 2.7 and 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sebastian Raschka: ''There are still many people using Python 2.7 who cannot
    switch and I don''t want to exclude anyone.''**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Driscoll**: What changes would you like to see in future Python releases?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Raschka**: My apologies, but my answer is a rather boring one: I am quite
    happy with Python''s current set of features and don''t have anything significant
    on my wish list.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing that I and multiple other people are sometimes complaining about is
    Python's Global Interpreter Lock (GIL). However, for my needs, it's typically
    not an issue. For instance, I like control over when to do multithreading or multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: I wrote my little multiprocessing wrappers (in the mputil package) to evaluate
    Python generators lazily, which was an issue concerning memory consumption when
    I was working with vanilla *Pool* classes from Python's multiprocessing standard
    library. Besides, there are great libraries out there, like joblib, which make
    multiprocessing and threading super convenient.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, most libraries that I use for the heavy lifting when it comes
    to doing computations in parallel (Dask, TensorFlow, and PyTorch) already support
    multiprocessing and use Python more as a glue language as I mentioned earlier,
    so that computational efficiency is never really an issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Driscoll**: Thank you, Sebastian Raschka.'
  prefs: []
  type: TYPE_NORMAL
