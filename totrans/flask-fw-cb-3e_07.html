<html><head></head><body>
<div id="_idContainer050">
<h1 class="chapter-number" id="_idParaDest-205"><a id="_idTextAnchor385"/><a id="_idTextAnchor386"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-206"><a id="_idTextAnchor387"/><span class="koboSpan" id="kobo.2.1">RESTful API Building</span></h1>
<p><span class="koboSpan" id="kobo.3.1">An </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Application Programming Interface</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">API</span></strong><span class="koboSpan" id="kobo.7.1">) can be summarized as a developer’s interface</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.8.1"> with an application. </span><span class="koboSpan" id="kobo.8.2">Just as end users have a visible frontend user interface with which they can work on and talk to the application, developers also need an interface to it. </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">Representational State Transfer</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.11.1">REST</span></strong><span class="koboSpan" id="kobo.12.1">) is not a protocol or a standard. </span><span class="koboSpan" id="kobo.12.2">It is just a software</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.13.1"> architectural style or a set of suggestions defined for writing applications, the aim of which is to simplify the interfaces within and without the application. </span><span class="koboSpan" id="kobo.13.2">When web service APIs are written in a way that adheres to the REST definitions, then they are known as RESTful APIs. </span><span class="koboSpan" id="kobo.13.3">Being RESTful keeps</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.14.1"> the API decoupled from the internal application details. </span><span class="koboSpan" id="kobo.14.2">This results in ease of scalability and keeps things simple. </span><span class="koboSpan" id="kobo.14.3">The uniform interface ensures that each and every request </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">is documented.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.16.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.17.1">It is a topic of debate as to whether REST or simple object access protocol (SOAP) is better. </span><span class="koboSpan" id="kobo.17.2">This is actually a subjective question, as it depends on what needs to be done. </span><span class="koboSpan" id="kobo.17.3">Each has its own benefits and should be chosen based on the requirements of </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">REST calls for segregating your API into logical resources, which can be accessed and manipulated using HTTP requests, where each request consists of one of the following methods – </span><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">GET</span></strong><span class="koboSpan" id="kobo.21.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">POST</span></strong><span class="koboSpan" id="kobo.23.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">PUT</span></strong><span class="koboSpan" id="kobo.25.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">PATCH</span></strong><span class="koboSpan" id="kobo.27.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">DELETE</span></strong><span class="koboSpan" id="kobo.29.1"> (there can be more, but these are the ones used most frequently). </span><span class="koboSpan" id="kobo.29.2">Each of these methods has a specific meaning. </span><span class="koboSpan" id="kobo.29.3">One of the key implied principles of REST is that the logical grouping of resources should be easily understandable and, hence, provide simplicity along </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">with portability.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">We have a resource called </span><strong class="source-inline"><span class="koboSpan" id="kobo.32.1">product</span></strong><span class="koboSpan" id="kobo.33.1">, as used in our book hitherto. </span><span class="koboSpan" id="kobo.33.2">Now, let’s see how we can logically map our API calls to the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">resource segregation:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">GET /products/1</span></strong><span class="koboSpan" id="kobo.36.1">: This gets the product with an ID </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">1</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">GET /products</span></strong><span class="koboSpan" id="kobo.40.1">: This gets the list </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">of products</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">POST /products</span></strong><span class="koboSpan" id="kobo.43.1">: This creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">new product</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">PUT /products/1</span></strong><span class="koboSpan" id="kobo.46.1">: This replaces or recreates the product with an ID </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">1</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">PATCH /products/1</span></strong><span class="koboSpan" id="kobo.50.1">: This partially updates the product with an ID </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">1</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">DELETE /products/1</span></strong><span class="koboSpan" id="kobo.54.1">: This deletes the product with an ID </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">1</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.59.1">Creating a class-based </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">REST interface</span></span></li>
<li><span class="koboSpan" id="kobo.61.1">Creating an extension-based </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">REST interface</span></span></li>
<li><span class="koboSpan" id="kobo.63.1">Creating a complete </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">RESTful A</span><a id="_idTextAnchor388"/><span class="koboSpan" id="kobo.65.1">PI</span></span></li>
</ul>
<h1 id="_idParaDest-207"><span class="koboSpan" id="kobo.66.1">Creating a class-based REST interfa</span><a id="_idTextAnchor389"/><span class="koboSpan" id="kobo.67.1">ce</span></h1>
<p><span class="koboSpan" id="kobo.68.1">We saw how class-based views</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.69.1"> work in Flask, using the concept of pluggable views, in the </span><em class="italic"><span class="koboSpan" id="kobo.70.1">Writing class-based views</span></em><span class="koboSpan" id="kobo.71.1"> recipe in </span><a href="B19111_04.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.72.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.73.1">, </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Working with Views</span></em><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">In this recipe, we will now see how we can use the same to create views, which will provide a REST interface to </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">our applicati</span><a id="_idTextAnchor390"/><span class="koboSpan" id="kobo.77.1">on.</span></span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor391"/><span class="koboSpan" id="kobo.78.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.79.1">Let’s take a simple view that will handle the REST-style calls to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.81.1"> mod</span><a id="_idTextAnchor392"/><span class="koboSpan" id="kobo.82.1">el.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor393"/><span class="koboSpan" id="kobo.83.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.84.1">We simply have to modify our views for product handling to extend the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">MethodView</span></strong><span class="koboSpan" id="kobo.86.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.90.1">
import json
from flask.views import MethodView
class ProductView(MethodView):
    def get(self, id=None, page=1):
        if not id:
            products = Product.query.paginate(page,
              10).items
            res = {}
            for product in products:
                res[product.id] = {
                    'name': product.name,
                    'price': product.price,
                    'category': product.category.name
                }
        else:
            product =
              Product.query.filter_by(id=id).first()
            if not product:
                abort(404)
                res = json.dumps({
                    'name': product.name,
                    'price': product.price,
                    'category': product.category.name
                })
        return res</span></pre>
<p><span class="koboSpan" id="kobo.91.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">get()</span></strong><span class="koboSpan" id="kobo.93.1"> method searches for the product and sends back</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.94.1"> a JSON result. </span><span class="koboSpan" id="kobo.94.2">Similarly, we can write the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">post()</span></strong><span class="koboSpan" id="kobo.96.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">put()</span></strong><span class="koboSpan" id="kobo.98.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">delete()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.100.1">methods too:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
def post(self):
    # Create a new product.
</span><span class="koboSpan" id="kobo.101.2">    # Return the ID/object of the newly created product.
</span><span class="koboSpan" id="kobo.101.3">    return
def put(self, id):
    # Update the product corresponding provided id.
</span><span class="koboSpan" id="kobo.101.4">    # Return the JSON corresponding updated product.
</span><span class="koboSpan" id="kobo.101.5">    return
def delete(self, id):
    # Delete the product corresponding provided id.
</span><span class="koboSpan" id="kobo.101.6">    # Return success or error message.
</span><span class="koboSpan" id="kobo.101.7">    return</span></pre>
<p><span class="koboSpan" id="kobo.102.1">Many of us would question why we have no routing here. </span><span class="koboSpan" id="kobo.102.2">To include routing, we have to do </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.104.1">
product_view =  ProductView.as_view('product_view')
app.add_url_rule('/products/', view_func=product_view,
    methods=['GET', 'POST'])
app.add_url_rule('/products/&lt;int:id&gt;',
    view_func=product_view,
    methods=['GET', 'PUT', 'DELETE'])</span></pre>
<p><span class="koboSpan" id="kobo.105.1">The first statement here converts the class to an actual view function internally that can be used with the routing system. </span><span class="koboSpan" id="kobo.105.2">The next two statements are the URL rules corresponding to the calls that can </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">be m</span><a id="_idTextAnchor394"/><span class="koboSpan" id="kobo.107.1">ade.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor395"/><span class="koboSpan" id="kobo.108.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.109.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">MethodView</span></strong><span class="koboSpan" id="kobo.111.1"> class identified the type of HTTP method</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.112.1"> in the sent request and converted the name to lowercase. </span><span class="koboSpan" id="kobo.112.2">Then, it matched this to the methods defined in the class and called the matched method. </span><span class="koboSpan" id="kobo.112.3">So, if we make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">GET</span></strong><span class="koboSpan" id="kobo.114.1"> call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">ProductView</span></strong><span class="koboSpan" id="kobo.116.1">, it will automatically be mapped to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">get()</span></strong><span class="koboSpan" id="kobo.118.1"> method and </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">processed accordi</span><a id="_idTextAnchor396"/><span class="koboSpan" id="kobo.120.1">ngly.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor397"/><span class="koboSpan" id="kobo.121.1">Creating an extension-based REST interface</span></h1>
<p><span class="koboSpan" id="kobo.122.1">In the previous</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.123.1"> recipe, </span><em class="italic"><span class="koboSpan" id="kobo.124.1">Creating a class-based REST interface</span></em><span class="koboSpan" id="kobo.125.1">, we saw how to create a REST interface</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.126.1"> using pluggable views. </span><span class="koboSpan" id="kobo.126.2">In this recipe, we will use an extension called </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">Flask- RESTful</span></strong><span class="koboSpan" id="kobo.128.1">, which is written over the same pluggable views we used in the previous recipe, but which handles a lot of nuances</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.129.1"> by itself to allow us developers to focus on actual API development. </span><span class="koboSpan" id="kobo.129.2">It is also independent of </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.131.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">ORM</span></strong><span class="koboSpan" id="kobo.133.1">), so there are no strings attached to the ORM we may want</span><a id="_idTextAnchor398"/> <span class="No-Break"><span class="koboSpan" id="kobo.134.1">to use.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor399"/><span class="koboSpan" id="kobo.135.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.136.1">First, we will begin with the installation of </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">the extension:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
$ pip install flask-restful</span></pre>
<p><span class="koboSpan" id="kobo.139.1">We will modify the catalog application from the last recipe to add a REST interface using </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">this ex</span><a id="_idTextAnchor400"/><span class="koboSpan" id="kobo.141.1">tension.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor401"/><span class="koboSpan" id="kobo.142.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.143.1">As always, start with changes to the application’s configuration in </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">my_app/__init__.py</span></strong><span class="koboSpan" id="kobo.145.1">, which will look something like the following lines </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.147.1">
from flask_restful import Api
api = Api(app)</span></pre>
<p><span class="koboSpan" id="kobo.148.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">app</span></strong><span class="koboSpan" id="kobo.150.1"> is our Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">application object/instance.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">Next, create the API inside</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.153.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">views.py</span></strong><span class="koboSpan" id="kobo.155.1"> file. </span><span class="koboSpan" id="kobo.155.2">Here, we will just try to understand how to lay out the skeleton of the API. </span><span class="koboSpan" id="kobo.155.3">Actual methods and handlers will be covered in the </span><em class="italic"><span class="koboSpan" id="kobo.156.1">Creating a complete RESTful </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.157.1">API</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1"> recipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
from flask_restful import Resource
from my_app import api
class ProductApi(Resource):
    def get(self, id=None):
        # Return product data
        return 'This is a GET response'
    def post(self):
        # Create a new product
        return 'This is a POST response'
    def put(self, id):
        # Update the product with given id
        return 'This is a PUT response'
    def delete(self, id):
        # Delete the product with given id
        return 'This is a DELETE response'</span></pre>
<p><span class="koboSpan" id="kobo.160.1">The preceding API structure is self-explanatory. </span><span class="koboSpan" id="kobo.160.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
api.add_resource(
    ProductApi,
    '/api/product',
    '/api/product/&lt;int:id&gt;'
)</span></pre>
<p><span class="koboSpan" id="kobo.163.1">Here, we created the routing for </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">ProductApi</span></strong><span class="koboSpan" id="kobo.165.1">, and we can specify multiple routes </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">as n</span><a id="_idTextAnchor402"/><span class="koboSpan" id="kobo.167.1">ecessary.</span></span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor403"/><span class="koboSpan" id="kobo.168.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.169.1">We will see how this REST interface</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.170.1"> works on the Python shell using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">requests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.172.1"> library.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.173.1">Information</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">requests</span></strong><span class="koboSpan" id="kobo.175.1"> is a very popular Python library that makes the rendering of HTTP requests very easy. </span><span class="koboSpan" id="kobo.175.2">It can simply be installed by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">$ pip install </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">requests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.178.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">The command will show the </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">following information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
&gt;&gt;&gt; import requests
&gt;&gt;&gt; res = requests.get('http://127.0.0.1:5000/api/product')
&gt;&gt;&gt; res.json()
'This is a GET response'
&gt;&gt;&gt; res = requests.post('http://127.0.0.1:5000/api/product')
&gt;&gt;&gt; res.json()
'This is a POST response'
&gt;&gt;&gt; res = requests.put('http://127.0.0.1:5000/api/product/1')
&gt;&gt;&gt; res.json()
'This is a PUT response'
&gt;&gt;&gt; res = requests.delete('http://127.0.0.1:5000/api/product/1')
&gt;&gt;&gt; res.json()
'This is a DELETE response'</span></pre>
<p><span class="koboSpan" id="kobo.182.1">In the preceding snippet, we saw that all our requests are properly routed to the respective methods; this</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.183.1"> is evident from the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">respons</span><a id="_idTextAnchor404"/><span class="koboSpan" id="kobo.185.1">e received.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor405"/><span class="koboSpan" id="kobo.186.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.187.1">Refer to the following recipe, </span><em class="italic"><span class="koboSpan" id="kobo.188.1">Creating a complete RESTful API</span></em><span class="koboSpan" id="kobo.189.1">, to see the API skeleton from this recipe co</span><a id="_idTextAnchor406"/><span class="koboSpan" id="kobo.190.1">me </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">to life.</span></span></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor407"/><span class="koboSpan" id="kobo.192.1">Creating a complete RESTful API</span></h1>
<p><span class="koboSpan" id="kobo.193.1">In this recipe, we will convert</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.194.1"> the API structure created in the last recipe, </span><em class="italic"><span class="koboSpan" id="kobo.195.1">Creating an extension-based REST interface</span></em><span class="koboSpan" id="kobo.196.1">, into a full-fledged </span><a id="_idTextAnchor408"/><span class="No-Break"><span class="koboSpan" id="kobo.197.1">RESTful API.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor409"/><span class="koboSpan" id="kobo.198.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.199.1">We will take the API skeleton from the last recipe as a basis to create a completely functional SQLAlchemy-independent RESTful API. </span><span class="koboSpan" id="kobo.199.2">Although we will use SQLAlchemy as the ORM for demonstration purposes, this recipe can be written in a similar fashion for any ORM or </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">underlyi</span><a id="_idTextAnchor410"/><span class="koboSpan" id="kobo.201.1">ng database.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor411"/><span class="koboSpan" id="kobo.202.1">How to do it…</span></h2>
<p><span class="koboSpan" id="kobo.203.1">The following lines of code are the complete RESTful API for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Product</span></strong><span class="koboSpan" id="kobo.205.1"> model. </span><span class="koboSpan" id="kobo.205.2">These code snippets will go into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Start with imports and </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">add </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">parser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
import json
from flask_restful import Resource, reqparse
parser = reqparse.RequestParser()
parser.add_argument('name', type=str)
parser.add_argument('price', type=float)
parser.add_argument('category', type=dict)</span></pre>
<p><span class="koboSpan" id="kobo.213.1">In the preceding</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.214.1"> snippet, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">parser</span></strong><span class="koboSpan" id="kobo.216.1"> for the arguments that we expected to have in our requests for </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">POST</span></strong><span class="koboSpan" id="kobo.218.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">PUT</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">The request expects each of the arguments to have a value. </span><span class="koboSpan" id="kobo.220.3">If a value is missing for any argument, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">None</span></strong><span class="koboSpan" id="kobo.222.1"> is used as </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">the value.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Write the method as shown in the following code block to </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">fetch products:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
class ProductApi(Resource):
    def get(self, id=None, page=1):
        if not id:
            products = Product.query.paginate(page=page,
              per_page=10).items
        else:
            products = [Product.query.get(id)]
        if not products:
            abort(404)
        res = {}
        for product in products:
            res[product.id] = {
                'name': product.name,
                'price': product.price,
                'category': product.category.name
            }
        return json.dumps(res)</span></pre>
<p><span class="koboSpan" id="kobo.227.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">get()</span></strong><span class="koboSpan" id="kobo.229.1"> method corresponds</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.230.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">GET</span></strong><span class="koboSpan" id="kobo.232.1"> requests and returns a paginated list of products if no </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">id</span></strong><span class="koboSpan" id="kobo.234.1"> is passed; otherwise, it returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">corresponding product.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Create the following method to add a </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">new product:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
    def post(self):
        args = parser.parse_args()
        name = args['name']
        price = args['price']
        categ_name = args['category']['name']
        category =
          Category.query.filter_by(name=categ_name).first()
        if not category:
            category = Category(categ_name)
        product = Product(name, price, category)
        db.session.add(product)
        db.session.commit()
        res = {}
        res[product.id] = {
            'name': product.name,
            'price': product.price,
            'category': product.category.name,
        }
        return json.dumps(res)</span></pre>
<p><span class="koboSpan" id="kobo.239.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">post()</span></strong><span class="koboSpan" id="kobo.241.1"> method will lead to the creation of a new product by making a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1"> request.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">Write the following method to update</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.245.1"> or essentially replace an existing </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">product record:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.247.1">
    def put(self, id):
        args = parser.parse_args()
        name = args['name']
        price = args['price']
        categ_name = args['category']['name']
        category =
          Category.query.filter_by(name=categ_name).first()
        Product.query.filter_by(id=id).update({
            'name': name,
            'price': price,
            'category_id': category.id,
        })
        db.session.commit()
        product = Product.query.get_or_404(id)
        res = {}
        res[product.id] = {
            'name': product.name,
            'price': product.price,
            'category': product.category.name,
        }
        return json.dumps(res)</span></pre>
<p><span class="koboSpan" id="kobo.248.1">In the preceding code, we updated</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.249.1"> an existing product using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">PUT</span></strong><span class="koboSpan" id="kobo.251.1"> request. </span><span class="koboSpan" id="kobo.251.2">Here, we should provide all the arguments even if we intend to change a few of them. </span><span class="koboSpan" id="kobo.251.3">This is because of the conventional way in which </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">PUT</span></strong><span class="koboSpan" id="kobo.253.1"> has been defined to work. </span><span class="koboSpan" id="kobo.253.2">If we want to have a request where we intend to pass only those arguments that we intend to update, then we should use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">PATCH</span></strong><span class="koboSpan" id="kobo.255.1"> request. </span><span class="koboSpan" id="kobo.255.2">I would urge you to try that </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">by yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Delete a product using the </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">following method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.259.1">
    def delete(self, id):
        product = Product.query.filter_by(id=id)
        product.delete()
        db.session.commit()
        return json.dumps({'response': 'Success'})</span></pre>
<p><span class="koboSpan" id="kobo.260.1">Last, but not least, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">DELETE</span></strong><span class="koboSpan" id="kobo.262.1"> request, which will simply delete the product that matches the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1"> passed.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">The following is a definition of all the possible routes that our API </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">can accommodate:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
api.add_resource(
    ProductApi,
    '/api/product',
    '/api/product/&lt;int:id&gt;',
    '/api/product/&lt;int:i</span><a id="_idTextAnchor412"/><span class="koboSpan" id="kobo.268.1">d&gt;/&lt;int:page&gt;'
)</span></pre>
<h2 id="_idParaDest-219"><a id="_idTextAnchor413"/><span class="koboSpan" id="kobo.269.1">How it works…</span></h2>
<p><span class="koboSpan" id="kobo.270.1">To test and see how this works, we can send a number of requests using the Python shell by means of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">requests</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.273.1">
&gt;&gt;&gt; import requests
&gt;&gt;&gt; import json
&gt;&gt;&gt; res = requests.get('http://127.0.0.1:5000/api/product')
&gt;&gt;&gt; res.json()
{'message': 'The requested URL was not found on the server. </span><span class="koboSpan" id="kobo.273.2">If you entered the URL manually please check your spelling and try again.'}</span></pre>
<p><span class="koboSpan" id="kobo.274.1">We made a </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">GET</span></strong><span class="koboSpan" id="kobo.276.1"> request to fetch the list of products, but there is no record of this. </span><span class="koboSpan" id="kobo.276.2">Let’s create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">product now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
&gt;&gt;&gt; d = {'name': u'iPhone', 'price': 549.00, 'category':
...    {'name':'Phones'}}
&gt;&gt;&gt; res = requests.post('http://127.0.0.1:5000/api/product', data=json.
</span><span class="koboSpan" id="kobo.278.2">...    dumps(d), headers={'Content-Type': 'application/json'})
&gt;&gt;&gt; res.json()
'{"1": {"name": "iPhone", "price": 549.0, "category": "Phones"}}'</span></pre>
<p><span class="koboSpan" id="kobo.279.1">We sent a </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">POST</span></strong><span class="koboSpan" id="kobo.281.1"> request to create a product with some data. </span><span class="koboSpan" id="kobo.281.2">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">headers</span></strong><span class="koboSpan" id="kobo.283.1"> argument in the request. </span><span class="koboSpan" id="kobo.283.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">POST</span></strong><span class="koboSpan" id="kobo.285.1"> request sent in Flask-RESTful should have this header. </span><span class="koboSpan" id="kobo.285.2">Now, we should look for the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">products again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.287.1">
&gt;&gt;&gt; res = requests.get('http://127.0.0.1:5000/api/product')
&gt;&gt;&gt; res.json()
'{"1": {"name": "iPhone", "price": 549.0, "category": "Phones"}}'</span></pre>
<p><span class="koboSpan" id="kobo.288.1">If we look for the products again via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">GET</span></strong><span class="koboSpan" id="kobo.290.1"> request, we can see that we now have a newly created product in </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">I will leave it to you to try to incorporate</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.293.1"> other API requests </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">by themselves.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.295.1">Important</span></p>
<p class="callout"><span class="koboSpan" id="kobo.296.1">An important facet of RESTful APIs</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.297.1"> is the use of token-based authentication to allow only limited and authenticated users to be able to use and make calls to the API. </span><span class="koboSpan" id="kobo.297.2">I urge you to explore this on your own. </span><span class="koboSpan" id="kobo.297.3">We covered the basics of user authentication in </span><a href="B19111_06.xhtml#_idTextAnchor328"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.298.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.299.1">, </span><em class="italic"><span class="koboSpan" id="kobo.300.1">Authenticating in Flask</span></em><span class="koboSpan" id="kobo.301.1">, which will serve as a basis for </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">this concept.</span></span></p>
</div>
</body></html>