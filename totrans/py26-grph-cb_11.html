<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 11. GUI Construction: Part 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. GUI Construction: Part 2</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Grid Layout Geometry Manager</li><li class="listitem" style="list-style-type: disc">The Pack Geometry Manager</li><li class="listitem" style="list-style-type: disc">Radio buttons to select one from many</li><li class="listitem" style="list-style-type: disc">Check buttons (Tick boxes) to select some of many</li><li class="listitem" style="list-style-type: disc">Keystroke event handling</li><li class="listitem" style="list-style-type: disc">Scrollbar</li><li class="listitem" style="list-style-type: disc">Frames</li><li class="listitem" style="list-style-type: disc">Custom DIY Controller Widgets (a slimmer slider)</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec01"/>Introduction</h1></div></div></div><p>In this chapter, we provide more recipes for the<span class="strong"><strong> Graphical User Interfaces(GUI)</strong></span>. The recipes in the previous chapter were devised as basic ways of interacting with your code while it is running. In this chapter we extend these ideas and try to tie them together.</p><p>We start by exploring the characteristics of the two layout geometry managers. Throughout this book, up until this chapter we have used the grid manager as it seems to be the one that gives us most control over the appearance of the GUI.</p><p>One choice we are forced to make when we write Tkinter code that uses widgets is how we are going to arrange the widgets inside the master widget that contains them. There are two layout geometry managers to choose from: the pack and the grid. The pack manager is the easiest to use until you have your own ideas of how you want the furniture arranged in your house, with furniture and house being useful metaphors for widget and containing widget. The grid manager gives you absolute control of layout.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The Grid Layout Geometry Manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec02"/>The Grid Layout Geometry Manager</h1></div></div></div><p>We look at code that lays out 16 labeled buttons in a planned manner. According to the label on each button, there is only one place it should be within a North, South, East, West reference system.<a id="id299" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec01"/>Getting ready</h2></div></div></div><p>Both grid and pack have navigation reference schemes. The easiest way to understand in terms of how our GUIs are going to appear is the grid that specifies the positioning of our widget using a clear row, column scheme as illustrated in the following screenshot:</p><div class="mediaobject"><img src="images/3845_11_01.jpg" height="141" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec02"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual manner. The result is shown in the following screenshot:<a id="id300" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_11_02.jpg" height="69" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting"># grid_button_array_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Pack Geometry Manager")
butn_NW = Button(root, bg='blue',text="NorthWest").grid(row=0, \ column=0)
butn_NW1 = Button(root, bg='blue',text="Northwest").grid(row=0, \ column=1)
butn_NE1 = Button(root, bg='blue',text="Northeast").grid(row=0, \ column=2)
butn_NE = Button(root, bg='blue',text="NorthEast").grid(row=0, \ column=3)
butn_N1W = Button(root, bg='sky blue',text="norWest").grid(row=1, \ column=0)
Grid Layout Geometry Managerexamplebutn_N1W1 = Button(root, bg='sky blue',text="norwest").grid(row=1, \ column=1)
butn_S1E1 = Button(root, bg='pale green',text="soueast").grid(row=1, column=2)
butn_S1E = Button(root, bg='pale green',text="souEast").grid(row=1, column=3)
butn_SW = Button(root, bg='green',text="SouthWest").grid(row=2, \column=0)
butn_SW1 = Button(root, bg='green',text="SothuWest").grid(row=2, \ column=1)
butn_SE1 = Button(root, bg='green',text="SouthEast").grid(row=2, \ column=2)
butn_SE = Button(root, bg='green',text="SouthEast").grid(row=2, \ column=3)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec03"/>How it works...</h2></div></div></div><p>The Grid Layout Manager is explicit in interpreting layout instructions. There is no ambiguity and the results are easy to understand. Fortunately, for us users, one of the entrenched philosophies of the Python language is that wherever possible the interpreter should be kind and forgiving to mildly careless programming. For instance, say for example, we assigned the grid layout of all the buttons to the same address. For example, say we assigned all the buttons as<code class="literal"> grid(row=5, column=5)</code>. The result would be what appeared to be a single button inside the window. In fact, the layout manager would place all the buttons on top of one another, with the first one at the bottom and the last one on top. If we destroyed them one at a time in reverse order we would see this sequence unfolding.<a id="id302" class="indexterm"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec04"/>There's more...</h2></div></div></div><p>Just remember that we never mix pack and grid layout managers in the same program. If you do, your program will freeze as each of the managers attempts to obey conflicting instructions.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The Pack Geometry Manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec03"/>The Pack Geometry Manager</h1></div></div></div><p>We attempt to achieve the same result as shown in the previous screenshot without complete success because pack tries to arrange widgets in a single strip. The limited flexibility pack offers is that it allows us to decide where the strip should begin.<a id="id303" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec05"/>Getting ready</h2></div></div></div><p>The Pack Layout Manager uses a navigator's compass scheme illustrated as follows:</p><div class="mediaobject"><img src="images/3845_11_03.jpg" height="99" alt="Getting ready"/></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec06"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way. The result is shown in the following screenshot:<a id="id304" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_11_04.jpg" height="100" alt="How to do it..."/></div><div class="informalexample"><pre class="programlisting"># pack_button_array_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Pack Geometry Manager")
butn_NW = Button(root, bg='blue',text="NorthWest").pack(side=LEFT)
butn_NW1 = Button(root, bg='blue',text="Northwest").pack(side=LEFT)
butn_NE1 = Button(root, bg='blue',text="Northeast").pack(side=LEFT)
butn_NE = Button(root, bg='blue',text="NorthEast").pack(side=LEFT)
butn_N1W = Button(root, bg='sky blue',text="norWest").pack()
butn_N1W1 = Button(root, bg='sky blue',text="norwest").pack()
butn_S1E1 = Button(root, bg='pale green',text="soueast").pack(side=BOTTOM)
Pack Geometry Managerexamplebutn_S1E = Button(root, bg='pale green',text="souEast").pack(side=BOTTOM)
butn_SW = Button(root, bg='green',text="SouthWest").pack(side=RIGHT)
butn_SW1 = Button(root, bg='green',text="SothuWest").pack(side=RIGHT)
butn_SE1 = Button(root, bg='green',text="SouthEast").pack(side=RIGHT)
butn_SE = Button(root, bg='green',text="SouthEast").pack(side=RIGHT)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec07"/>How it works...</h2></div></div></div><p>The pack geometry packs widgets either in rows or in columns. If we try to do both, the results are difficult to predict as shown in the previous screenshot.<a id="id306" class="indexterm"/>
</p><p>What it does is it starts at one edge, which you may specify, and then just lays the widgets one-by-one next to each other in the same order that they appear in our code. If you do not specify an edge to start on the default is TOP so the widgets will be laid out as a single column.</p><p>There are also parameters that specify whether the widget should be padded out to fill available space. We can get this detail from:</p><p>
<a class="ulink" href="http://effbot.org/tkinterbook/pack.htm">http://effbot.org/tkinterbook/pack.htm</a>
<a id="id307" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Radiobuttons to select one from many"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec04"/>Radiobuttons to select one from many</h1></div></div></div><p>We use radiobuttons to make one choice from a selection of choices. Each button in the set is linked to the same variable. As one button is left-clicked with the mouse, the value associated with that particular button gets assigned as the value of the variable.<a id="id308" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_11_05.jpg" height="57" alt="Radiobuttons to select one from many"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec08"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.<a id="id309" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># radiobuttons_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk( )
root.title("Radiobuttons")
var_1 = StringVar( )
rad_1 = Radiobutton(root, text='violent', variable = var_1, \ value="action").grid(row=0, column=0)
rad_2 = Radiobutton(root, text='love', variable = var_1, \ value="romance").grid(row=0, column=1)
rad_2 = Radiobutton(root, text='conflict', variable = var_1, \ value="war").grid(row=0, column=2)
def callback_1():
v_1 = var_1.get()
print v_1
button_1= Button(root, command=callback_1).grid(row=4, column=0)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec09"/>How it works...</h2></div></div></div><p>We have specified a special Tkinter string variable that we name as<code class="literal"> var_1</code>. We can assign one of three possible string values depending on which radio button is clicked. A normal button is used to display the value<code class="literal"> var_1</code> has at any time.<a id="id310" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Checkbuttons (Tickboxes) to select some of many"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec05"/>Checkbuttons (Tickboxes) to select some of many</h1></div></div></div><p>Tickboxes always have a value. They are the opposite of radiobuttons they allow more than one choice to be made from a group. Each Tickbox is associated with a different variable name.<a id="id311" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_11_06.jpg" width="65" alt="Checkbuttons (Tickboxes) to select some of many"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec10"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.<a id="id312" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># checkbox_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import tkMessageBox
root = Tk()
root.title("Checkboxes")
check_var1 = IntVar()
check_var2 = IntVar()
check_var3 = StringVar()
check_var4 = StringVar()
def change_it():
print "Why do you want to change things?"
Ck_1 = Checkbutton(root, text = "Dog", variable = check_var1, \ command=change_it, \
onvalue = 1, offvalue = 0, height=3, \
width = 10).grid(row=0, column=0)
Ck_2 = Checkbutton(root, text = "Cat", variable = check_var2, \
onvalue = 1, offvalue = 0, height=6, \
width = 10).grid(row=1, column=0)
Ck_3 = Checkbutton(root, text = "Rat", variable = check_var3, \
onvalue = "fly me", offvalue = "keep walking", \ height=9, \
width = 10).grid(row=2, column=0)
Ck_4 = Checkbutton(root, text = "Frog", variable = check_var4, \
onvalue = "to the moon", offvalue = "to Putney road", \height=12, \
width = 10).grid(row=3, column=0)
def callback_1():
v_1 = check_var1.get()
v_2 = check_var2.get()
v_3 = check_var3.get()
v_4 = check_var4.get()
print v_1, v_2, v_3, v_4
button_1= Button(root, command=callback_1).grid(row=4, column=0)
root.mainloop()
<a id="id313" class="indexterm"/>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec11"/>How it works...</h2></div></div></div><p>There are four checkboxes (tickboxes) and therefore four variables. Two are integer and two are strings. Whenever the button at the bottom is clicked, all four values are displayed.<a id="id314" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Key-stroke event handling"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec06"/>Key-stroke event handling</h1></div></div></div><p>In GUI terminology, an<span class="strong"><strong> Event Handler</strong></span> is a term for a function that executes when an external event such as a key or a mouse being clicked occurs. An equivalent term used in this book, is a<code class="literal"> callback</code> function. We recognize a<code class="literal"> callback</code> function because it has the word event as an argument in the function definition.<a id="id315" class="indexterm"/>
</p><p>Here we make an event handler that reacts to key strokes.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec12"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.<a id="id316" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># keypress_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.title("Key symbol Getter")
def key_was_pressed(event):
print 'keysym=%s' % (event.keysym)
text_1 = Text(root, width=20, height=5, highlightthickness=15)
text_1.grid(row=0, column=0)
text_1.focus_set()
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec13"/>How it works...</h2></div></div></div><p>We have made a textbox to show which key was clicked when a keyboard "event" occurs. We have chosen to display and verify our key presses inside a textbox, which does not react to function key presses. If we used a Label widget instead, we would see the<code class="literal"> function</code> key displayed as expected. In other words the function<code class="literal"> event.keypress</code> correctly senses all keystrokes even if they are not represented by normal characters.<a id="id317" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Scrollbar"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec07"/>Scrollbar</h1></div></div></div><p>A scrollbar provides a way to move a viewing window across a larger image or text area using a mouse-controlled slider. It can be used with Listboxes, Canvasses, Entry widgets, or Text widgets. In this example, we use a vertical scrollbar to move a GIF image up and down behind a scrollbar's viewing window.<a id="id318" class="indexterm"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec14"/>How to do it...</h2></div></div></div><p>A two-way connection needs to be made between the canvas and the scrollbar:<a id="id319" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The canvas's<code class="literal"> yscrollcommand</code> option has to be connected to the vertical scrollbar's<code class="literal"> .set</code> method, and</li><li class="listitem" style="list-style-type: disc">The scrollbar's<code class="literal"> command</code> option has to connected to the canvas's<code class="literal"> .yview</code> method.</li></ul></div><p>Execute the program shown in the usual way.<a id="id320" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">scrollbar_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
frame_1 = Frame(root, bd=2, relief=SUNKEN)
frame_1.grid(row=0, column=0)
pic_1 = PhotoImage(file="/constr/pics1/table_glass_vase.gif")
yscrollbar = Scrollbar(frame_1, orient=VERTICAL, \ bg="skyblue",activebackground="blue")
yscrollbar.grid(row=0, column=1, sticky=N+S)
canvas_1 = Canvas(frame_1, bd=0, scrollregion=(0, 0, 2100, 2000), # The extent of the scrollable area.
yscrollcommand=yscrollbar.set, # Link to the # scrollbar.
)
canvas_1.grid(row=0, column=0)
canvas_1.create_image(0 ,0 ,anchor=NW, image= pic_1)
yscrollbar.config(command=canvas_1.yview) # Link to the #canvas.
mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec15"/>How it works...</h2></div></div></div><p>The two-way connection between canvas and scrollbar is achieved by the option<code class="literal"> yscrollcommand=yscrollbar.set</code> in the<code class="literal"> canvas_1 = Canvas(… configuration</code> command and in the scrollbar configuration option<code class="literal"> yscrollbar.config(command=canvas_1.yview)</code>.<a id="id321" class="indexterm"/>
</p><p>In Python, we cannot refer to any variable before it has been defined, and this is why the<code class="literal"> yscrollbar.config</code> statement cannot be used before the<code class="literal"> yscrollbar</code> has been declared.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec16"/>There's more...</h2></div></div></div><p>The above example, for simplicity, only has a vertical scrollbar. If we want to include a horizontal scrollbar we would insert the statements:</p><div class="informalexample"><pre class="programlisting">xscrollbar = Scrollbar(frame_1, orient=HORIZONTAL, bg="orange",activebackground="red")
xscrollbar.grid(row=1, column=0),
canvas_1 = Canvas(frame_1, bd=0, scrollregion=(0, 0, 2100, 2000), # The extent of the area across which can be scrolled.
xscrollcommand=xscrollbar.set,
yscrollcommand=yscrollbar.set,
</pre></div><p>After the canvas declarations, add the following line of code:</p><p>
<code class="literal">xscrollbar.config(command=canvas_1.xview)</code>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Custom DIY controller widgets"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec08"/>Custom DIY controller widgets</h1></div></div></div><p>We construct our own widget from basic graphic elements on a canvas. The existing slide control widget available from Tkinter looks a bit large and cumbersome sometimes. If we need a more neat and compact slide-type user input device we can manufacture our own.<a id="id322" class="indexterm"/>
</p><p>The choice made here is to assemble the essential slider functions as graphic and text elements on a Tkinter canvas.</p><div class="mediaobject"><img src="images/3845_11_07.jpg" width="97" alt="Custom DIY controller widgets"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec17"/>How to do it...</h2></div></div></div><p>What we see in the following code are three similar groups of code separated by double lines and a<code class="literal"> callback</code> function that focuses on one of the three segments depending on the value of a variable named<code class="literal"> focus_flag</code>. Execute the program shown in the usual way.</p><div class="informalexample"><pre class="programlisting"># mini_slider_widget_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
import math
root = Tk()
root.title("A 3 color linear slider control gadget")
cw = 200 # canvas width
ch = 200 # canvas height
chart_1 = Canvas(root, width=cw, height=ch, background="#ffffff")
chart_1.grid(row=1, column=1)
#============================================
# Mini slider canvas widget
focus_flag = 0 # 0-&gt; uncommited, 1 -&gt; slider #1, 2 -&gt; slider #2 etc.
x_1 = 50 # Position of slider #1 base.
y_1 = 150
x_2 = 80 # Position of slider #2 base.
y_2 = 150
x_3 = 110 # Position of slider #3 base.
y_3 = 150
length_1 = 100 # Length of slider #1 (pixels) - constant.
length_2 = 110
length_3 = 120
slide_1 = y_1 # Position of slider handle #1 - variable.
slide_2 = y_2
slide_3 = y_3
#==============================================
def separation(x_now, y_now, x_dot, y_dot): # distance # measurement
# Distance to points - used to find out if the mouse clicked # inside a circle
sum_squares = (x_now - x_dot)**2 + (y_now -y_dot)**2
distance= int(math.sqrt(sum_squares)) # get #pythagorean distance
widgetsconstructingreturn( distance)
#==============================================
def canv_slider(xn, yn, length, kula):
# Draw the background slider gadgets.
y_top = yn -length
chart_1.create_line(xn, yn, xn, y_top, fill="gainsboro", width = 6)
chart_1.create_rectangle(xn - 5, yn -3, xn + 5, yn + 3, fill=kula, tag="knob_active")
chart_1.create_text(xn, yn + 10, text='zero',font=('verdana', 8))
chart_1.create_text(xn, y_top - 10, text='max',font=('verdana', 8))
canv_slider(x_1, y_1, length_1, "red")
canv_slider(x_2, y_2, length_2, "green")
canv_slider(x_3, y_3, length_3, "blue")
#==============================================
def dyn_slider(xn, yn, slide_val, kula, tagn):
# Draw the dynamic slider position.
chart_1.delete(tagn)
chart_1.create_line(xn, yn, xn, slide_val, fill=kula, width=4, tag =tagn)
chart_1.create_rectangle(xn - 5, slide_val -3 , xn + 5,slide_val + 3, fill=kula, tag=tagn)
chart_1.create_text(xn + 15, slide_val, text=str(slide_val), font=('verdana', 6),tag =tagn)
#==============================================
def callback_1(event):
# LEFT CLICK event processor.
global x_1, y_1, x_2, y_2, x_3, y_3, focus_flag
global slide_1, slide_2, slide_3
# Measure distances to identify which point has been clicked on.
d1 = separation(event.x, event.y, x_1, slide_1)
d2 = separation(event.x, event.y, x_2, slide_2)
d3 = separation(event.x, event.y, x_3, slide_3)
if d1 &lt;= 5:
focus_flag = 1
if d2 &lt;= 5:
focus_flag = 2
if d3 &lt;= 5:
focus_flag = 3
def callback_2(event):
widgetsconstructing# LEFT DRAG event processor.
global length_1, length_2, length_3
global x_1, y_1, x_2, y_2, x_3, y_3, focus_flag
global slide_1, slide_2, slide_3
pos_x = event.x
slide_val = event.y
if focus_flag == 1 and slide_val &lt;= y_1 and slide_val &gt;= y_1 - length_1\
and pos_x &lt;= x_1 + 10 and pos_x &gt;= x_1 - 10:
dyn_slider(x_1, y_1, slide_val, "red", "slide_red")
slide_1 = slide_val
if focus_flag == 2 and slide_val &lt;= y_2 and slide_val &gt;= y_2 - length_2\
and pos_x &lt;= x_2 + 10 and pos_x &gt;= x_2 - 10:
dyn_slider(x_2, y_2, slide_val, "green", "slide_green")
slide_2 = slide_val
if focus_flag == 3 and slide_val &lt;= y_3 and slide_val &gt;= y_3 - length_3\
and pos_x &lt;= x_3 + 10 and pos_x &gt;= x_3 - 10:
dyn_slider(x_3, y_3, slide_val, "blue", "slide_blue" )
slide_3 = slide_val
#==============================
chart_1.bind("&lt;Button-1&gt;", callback_1)
chart_1.bind("&lt;B1-Motion&gt;", callback_2)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec18"/>How it works...</h2></div></div></div><p>This is an array of numerical input gadgets that give users feedback using the length of a colored bar as well as a numerical readout.<a id="id325" class="indexterm"/>
</p><p>The function<code class="literal"> callback_1</code> reacts to a click of the left mouse while<code class="literal"> callback_2</code> responds to the mouse being dragged while the button is held down. Which of the three sets of controls is controlled by a mouse left-click is determined by measuring the position of the mouse when the left button is clicked. This measurement is performed by the function<code class="literal"> separation(x_now, y_now, x_dot, y_dot)</code>. It measures the distance between where the mouse is clicked and each of the slide control rectangles. If it is close (within 5 pixels) to a control rectangle, then the value of<code class="literal"> focus_flag</code> is set to an integer that we associate with that position.</p><p>It works on a similar principle to the official Tkinter scale/slider widget.</p><p>It is useful when you want to place a slide controller onto a canvas.</p><p>They occupy less screen area than the Ttkinter scale widget.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec19"/>There's more...</h2></div></div></div><p>If we need only one canvas slider widget and not three it is a simple matter to comment-out or delete any lines of code dealing with two of the widgets.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Organizing widgets inside frames"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec09"/>Organizing widgets inside frames</h1></div></div></div><p>We use Tkinter frames to group bunches of related widgets together. When we have done this, we only have to think about how we want the frames arranged because their contents are already taken care of.<a id="id326" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_11_08.jpg" width="213" alt="Organizing widgets inside frames"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec20"/>How to do it...</h2></div></div></div><p>Execute the program shown in the usual way.<a id="id327" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"># frame_1.py
#&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
from Tkinter import *
root = Tk()
root.config(bg="black")
root.title("It's a Frame-up")
#================================================
# frame_1 and her motley little family
frame_1 = Frame(root, bg="red", border = 4, relief="raised")
frame_1.grid(row=0, column=0, columnspan=2)
redbutton_1 = Button(frame_1, text="Red",bg ="orange", fg="red")
redbutton_1.grid(row=0, column=1)
greenbutton_1 = Button(frame_1, text="Brown",bg ="pink", fg="brown")
greenbutton_1.grid(row=1, column=2)
bluebutton_1 = Button(frame_1, text="Blue",bg ="yellow", fg="blue")
bluebutton_1.grid(row=0, column=3)
#================================================
# frame _2 and her neat blue home
frame_2 = Frame(root, bg="blue", border = 10, relief="sunken")
frame_2.grid(row=1, column=0)
redbutton_2 = Button(frame_2, text="Green",bg ="brown", fg="green")
redbutton_2.grid(row=0, column=1)
greenbutton_2 = Button(frame_2, text="Brown",bg ="green", fg="brown")
greenbutton_2.grid(row=2, column=2)
bluebutton_2 = Button(frame_2, text="Pink",bg ="gray", fg="black")
bluebutton_2.grid(row=3, column=3)
#================================================
# frame_3 with her friendly green home
frame_3 = Frame(root, bg="green", border = 20, relief="groove")
frame_3.grid(row=1, column=1)
redbutton_3 = Button(frame_3, text="Purple",bg ="white", fg="red")
redbutton_3.grid(row=0, column=3)
greenbutton_3 = Button(frame_3, text="Violet",bg ="cyan", fg="violet")
greenbutton_3.grid(row=2, column=2)
bluebutton_3 = Button(frame_3, text="Cyan",bg ="purple", fg="blue")
bluebutton_3.grid(row=3, column=0)
root.mainloop()
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec21"/>How it works...</h2></div></div></div><p>The position of frames is specified relative to the "root" window.<a id="id328" class="indexterm"/>
</p><p>Inside each frame, the widgets that belong to it are arranged without reference to anything outside that frame.</p><p>For instance, the specification<code class="literal"> redbutton_1.grid(row=0, column=1)</code> places the<code class="literal"> red_button</code> in<code class="literal"> row=0</code> and<code class="literal"> column=1</code> in the grid geometry that is the universe of the red frame<code class="literal"> frame_1</code>. The red button is completely unaware of the world outside her frame.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec22"/>There's more...</h2></div></div></div><p>For the first time we have changed the background color of the root Tkinter window from the default  gray one to black.</p></div></div></div>


  <div id="sbo-rt-content"><div class="appendix" title="Appendix appA. Quick tips for running Python programs in Microsoft Windows"><div class="titlepage"><div><div><h1 class="title"><a id="appA"/>Appendix appA. Quick tips for running Python programs in Microsoft Windows</h1></div></div></div><div class="section" title="Running Python programs in Microsoft Windows"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec01"/>Running Python programs in Microsoft Windows</h1></div></div></div><p>In a Linux-operating system, Python is usually already installed. It already has Tkinter, math, and many other libraries installed. You do not have to modify any system search path variables like<code class="literal"> Path</code> to run Python.<a id="id329" class="indexterm"/>
</p><p>Microsoft Windows may throw up some obstacles but it is not too difficult to overcome them. The Python Windows installer will install everything it needs in a Windows directory<code class="literal"> C:\Python27</code>, if it is version 2.7. Python version 2.6 would get stored in<code class="literal"> C:\Python26</code>.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Where will we find the windows installer?"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec02"/>Where will we find the windows installer?</h1></div></div></div><p>We will find it at<a class="ulink" href="http://www.python.org/download/"> www.python.org/download/</a>. When the<a class="ulink" href="http://www.python.org/download/"> www.python.org/download/</a> page opens up, select<span class="strong"><strong> Python 2.7 Windows installer (Windows binary does not include source)</strong></span>.<a id="id330" class="indexterm"/>
</p><p>This will download a file named<code class="literal"> Python-2.7.msi</code> into our windows<code class="literal"> Downloads</code> folder. We just have to double-click on this file and Python version 2.7 will install itself onto our system at<code class="literal"> C:\Python27</code>.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Do we have to use Python version 2.7?"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec03"/>Do we have to use Python version 2.7?</h1></div></div></div><p>No, the code in this book should work on Python versions 2.4, 2.5, 2.6, and 2.7. It has been run by various people on these versions. It will not run on Python version 3.0 and higher without changes required by the new Python syntax. For instance, print has to be changed to print (stuff-to-be printed).</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Why do we get &quot;python is not recognized…&quot;?"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec04"/>Why do we get "python is not recognized…"?</h1></div></div></div><p>This happens because the Windows operating system does not know where to find Python when you type<code class="literal"> python</code> into a command window as shown in the following screenshot:<a id="id331" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3845_appendix_01.jpg" width="476" alt="Why do we get &quot;python is not recognized…&quot;?"/></div><p>There are three ways around this problem:<a id="id332" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Type in the full pathname for both python and the target program we want to run. In this example, we have used the python program named<code class="literal"> entry_box_1.py</code>. It has been stored inside a folder named<code class="literal"> constr</code> as described in the first example<span class="emphasis"><em> Running a Shortest Python Program</em></span> in the first chapter. The following screenshot shows the command-line dialog.<code class="literal"> george</code> is the name of the user logged into Windows.<div class="mediaobject"><img src="images/3845_appendix_02.jpg" width="482" alt="Why do we get &quot;python is not recognized…&quot;?"/></div></li><li class="listitem">Work inside the<code class="literal"> Python27</code> folder. What we do is<code class="literal"> cd.</code>. and<code class="literal"> cd.</code>. again. Then<code class="literal"> cd</code> into folder<code class="literal"> Python27</code>. Then we can just type<code class="literal"> python \constr\entry_box_1.py</code> into the command-line as shown in the following screenshot:<a id="id333" class="indexterm"/><div class="mediaobject"><img src="images/3845_appendix_03.jpg" width="482" alt="Why do we get &quot;python is not recognized…&quot;?"/></div></li><li class="listitem">Change the Windows system variable that informs Windows where to search for executable files. We do this by typing<code class="literal"> set PATH=%PATH%;C:\Python27</code> into the command-line window. From now on, we can just type<code class="literal"> python \constr\entry_box_.py</code> from within any folder. The dialog that achieves this is shown in the following screenshot:<a id="id334" class="indexterm"/><p>screenshot:</p></li></ol></div></div></div>
</body></html>