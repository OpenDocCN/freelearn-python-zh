["```py\n>>> n = 1000\n>>> a = list(range(n))\n>>> b = dict.fromkeys(range(n))\n\n>>> for i in range(100):\n...     assert i in a  # takes n=1000 steps\n...     assert i in b  # takes 1 step \n```", "```py\n>>> def o_one(items):\n...     return 1  # 1 operation so O(1)\n\n>>> def o_n(items):\n...     total = 0\n...     # Walks through all items once so O(n)\n...     for item in items:\n...         total += item\n...     return total\n\n>>> def o_n_squared(items):\n...     total = 0\n...     # Walks through all items n*n times so O(n**2)\n...     for a in items:\n...         for b in items:\n...             total += a * b\n...     return total\n\n>>> n = 10\n>>> items = range(n)\n>>> o_one(items)  # 1 operation\n1\n>>> o_n(items)  # n = 10 operations\n45\n>>> o_n_squared(items)  # n*n = 10*10 = 100 operations\n2025 \n```", "```py\n>>> def remove(items, value):\n...     new_items = []\n...     found = False\n...     for item in items:\n...         # Skip the first item which is equal to value\n...         if not found and item == value:\n...             found = True\n...             continue\n...         new_items.append(item)\n...\n...     if not found:\n...         raise ValueError('list.remove(x): x not in list')\n...\n...     return new_items\n\n>>> def insert(items, index, value):\n...     new_items = []\n...     for i, item in enumerate(items):\n...         if i == index:\n...             new_items.append(value)\n...         new_items.append(item)\n...     return new_items\n>>> items = list(range(10))\n>>> items\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> items = remove(items, 5)\n>>> items\n[0, 1, 2, 3, 4, 6, 7, 8, 9]\n\n>>> items = insert(items, 2, 5)\n>>> items\n[0, 1, 5, 2, 3, 4, 6, 7, 8, 9] \n```", "```py\n>>> primes = set((1, 2, 3, 5, 7))\n\n# Classic solution\n>>> items = list(range(10))\n>>> for prime in primes:\n...     items.remove(prime)\n>>> items\n[0, 4, 6, 8, 9]\n\n# List comprehension\n>>> items = list(range(10))\n>>> [item for item in items if item not in primes]\n[0, 4, 6, 8, 9]\n\n# Filter\n>>> items = list(range(10))\n>>> list(filter(lambda item: item not in primes, items))\n[0, 4, 6, 8, 9] \n```", "```py\n>>> def in_(items, value):\n...     for item in items:\n...         if item == value:\n...             return True\n...     return False\n\n>>> def min_(items):\n...     current_min = items[0]\n...     for item in items[1:]:\n...         if current_min > item:\n...             current_min = item\n...     return current_min\n\n>>> def max_(items):\n...     current_max = items[0]\n...     for item in items[1:]:\n...         if current_max < item:\n...             current_max = item\n...     return current_max\n\n>>> items = range(5)\n>>> in_(items, 3)\nTrue\n>>> min_(items)\n0\n>>> max_(items)\n4 \n```", "```py\n>>> def most_significant(value):\n...     while value >= 10:\n...         value //= 10\n...     return value\n\n>>> most_significant(12345)\n1\n>>> most_significant(99)\n9\n>>> most_significant(0)\n0 \n```", "```py\n>>> def add(collection, key, value):\n...     index = most_significant(key)\n...     collection[index].append((key, value))\n\n>>> def contains(collection, key):\n...     index = most_significant(key)\n...     for k, v in collection[index]:\n...         if k == key:\n...             return True\n...     return False\n\n# Create the collection of 10 lists\n>>> collection = [[], [], [], [], [], [], [], [], [], []]\n# Add some items, using key/value pairs\n>>> add(collection, 123, 'a')\n>>> add(collection, 456, 'b')\n>>> add(collection, 789, 'c')\n>>> add(collection, 101, 'c')\n\n# Look at the collection\n>>> collection\n[[], [(123, 'a'), (101, 'c')], [], [],\n [(456, 'b')], [], [], [(789, 'c')], [], []]\n\n# Check if the contains works correctly\n>>> contains(collection, 123)\nTrue\n>>> contains(collection, 1)\nFalse \n```", "```py\n# All output in the table below is generated using this function\n>>> def print_set(expression, set_):\n...     'Print set as a string sorted by letters'\n...     print(expression, ''.join(sorted(set_)))\n\n>>> spam = set('spam')\n>>> print_set('spam:', spam)\nspam: amps\n\n>>> eggs = set('eggs')\n>>> print_set('eggs:', eggs)\neggs: egs \n```", "```py\n# The set function takes a sequence as argument so the double ( is required.\n>>> current_users = set((\n...     'a',\n...     'b',\n...     'd',\n... ))\n\n>>> new_users = set((\n...     'b',\n...     'c',\n...     'd',\n...     'e',\n... ))\n\n>>> to_insert = new_users - current_users\n>>> sorted(to_insert)\n['c', 'e']\n>>> to_delete = current_users - new_users\n>>> sorted(to_delete)\n['a']\n>>> unchanged = new_users & current_users\n>>> sorted(unchanged)\n['b', 'd'] \n```", "```py\n>>> spam = 1, 2, 3\n>>> eggs = 4, 5, 6\n\n>>> data = dict()\n>>> data[spam] = 'spam'\n>>> data[eggs] = 'eggs'\n\n>>> import pprint  # Using pprint for consistent and sorted output\n\n>>> pprint.pprint(data)\n{(1, 2, 3): 'spam', (4, 5, 6): 'eggs'} \n```", "```py\n>>> spam = 1, 'abc', (2, 3, (4, 5)), 'def'\n>>> eggs = 4, (spam, 5), 6\n\n>>> data = dict()\n>>> data[spam] = 'spam'\n>>> data[eggs] = 'eggs'\n\n>>> import pprint  # Using pprint for consistent and sorted output\n\n>>> pprint.pprint(data)\n{(1, 'abc', (2, 3, (4, 5)), 'def'): 'spam',\n (4, ((1, 'abc', (2, 3, (4, 5)), 'def'), 5), 6): 'eggs'} \n```", "```py\n# Assign using tuples on both sides\n>>> a, b, c = 1, 2, 3\n>>> a\n1\n\n# Assign a tuple to a single variable\n>>> spam = a, (b, c)\n>>> spam\n(1, (2, 3))\n\n# Unpack a tuple to two variables\n>>> a, b = spam\n>>> a\n1\n>>> b\n(2, 3) \n```", "```py\n# Unpack with variable length objects which assigns a list instead\n# of a tuple\n>>> spam, *eggs = 1, 2, 3, 4\n>>> spam\n1\n>>> eggs\n[2, 3, 4]\n\n# Which can be unpacked as well of, course\n>>> a, b, c = eggs\n>>> c\n4\n\n# This works for ranges as well\n>>> spam, *eggs = range(10)\n>>> spam\n0\n>>> eggs\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# And it works both ways\n>>> a, b, *c = a, *eggs\n>>> a, b\n(2, 1)\n>>> c\n[2, 3, 4, 5, 6, 7, 8, 9] \n```", "```py\n>>> def eggs(*args):\n...     print('args:', args)\n\n>>> eggs(1, 2, 3)\nargs: (1, 2, 3) \n```", "```py\n>>> def spam_eggs():\n...     return 'spam', 'eggs'\n\n>>> spam, eggs = spam_eggs()\n>>> spam\n'spam'\n>>> eggs\n'eggs' \n```", "```py\n>>> spam: int\n>>> __annotations__['spam']\n<class 'int'>\n\n>>> spam = 'not a number'\n>>> __annotations__['spam']\n<class 'int'> \n```", "```py\n>>> import dataclasses\n\n>>> @dataclasses.dataclass\n... class Sandwich:\n...     spam: int\n...     eggs: int = 3\n\n>>> Sandwich(1, 2)\nSandwich(spam=1, eggs=2)\n\n>>> sandwich = Sandwich(4)\n>>> sandwich\nSandwich(spam=4, eggs=3)\n>>> sandwich.eggs\n3\n>>> dataclasses.asdict(sandwich)\n{'spam': 4, 'eggs': 3}\n>>> dataclasses.astuple(sandwich)\n(4, 3) \n```", "```py\n>>> help(dataclasses.dataclass)\nHelp on ... dataclass(..., *, init=True, repr=True, eq=True,\norder=False, unsafe_hash=False, frozen=False) ... \n```", "```py\n>>> def __init__(self, spam, eggs=3):\n...    self.spam = spam\n...    self.eggs = eggs \n```", "```py\n>>> import typing\n\n>>> @dataclasses.dataclass\n... class Group:\n...     name: str\n...     parent: 'Group' = None\n\n>>> @dataclasses.dataclass\n... class User:\n...     username: str\n...     email: str = None\n...     groups: typing.List[Group] = None\n\n>>> users = Group('users')\n>>> admins = Group('admins', users)\n>>> rick = User('rick', groups=[admins])\n>>> gvr = User('gvanrossum', 'guido@python.org', [admins])\n\n>>> rick.groups\n[Group(name='admins', parent=Group(name='users', parent=None))]\n\n>>> rick.groups[0].parent\nGroup(name='users', parent=None) \n```", "```py\n>>> import builtins\n\n>>> builtin_vars = vars(builtins)\n\n>>> key = 'something to search for'\n\n>>> if key in locals():\n...     value = locals()[key]\n... elif key in globals():\n...     value = globals()[key]\n... elif key in builtin_vars:\n...     value = builtin_vars[key]\n... else:\n...     raise NameError(f'name {key!r} is not defined')\nTraceback (most recent call last):\n...\nNameError: name 'something to search for' is not defined \n```", "```py\n>>> mappings = locals(), globals(), vars(builtins)\n\n>>> for mapping in mappings:\n...     if key in mapping:\n...         value = mapping[key]\n...         break\n... else:\n...     raise NameError(f'name {key!r} is not defined')\nTraceback (most recent call last):\n...\nNameError: name 'something to search for' is not defined \n```", "```py\n>>> import collections\n\n>>> mappings = collections.ChainMap(\n...     locals(), globals(), vars(builtins))\n>>> mappings[key]\nTraceback (most recent call last):\n...\nKeyError: 'something to search for' \n```", "```py\n>>> import json\n>>> import pathlib\n>>> import argparse\n>>> import collections\n\n>>> DEFAULT = dict(verbosity=1)\n\n>>> config_file = pathlib.Path('config.json')\n>>> if config_file.exists():\n...     config = json.load(config_file.open())\n... else:\n...     config = dict()\n\n>>> parser = argparse.ArgumentParser()\n>>> parser.add_argument('-v', '--verbose', action='count',\n...                     dest='verbosity')\n_CountAction(...)\n\n>>> args, _ = parser.parse_known_args()\n>>> defined_args = {k: v for k, v in vars(args).items() if v}\n>>> combined = collections.ChainMap(defined_args, config, DEFAULT)\n>>> combined['verbosity']\n1\n\n>>> args, _ = parser.parse_known_args(['-vv'])\n>>> defined_args = {k: v for k, v in vars(args).items() if v}\n>>> combined = collections.ChainMap(defined_args, config, DEFAULT)\n>>> combined['verbosity']\n2 \n```", "```py\nnodes = [\n    ('a', 'b'),\n    ('a', 'c'),\n    ('b', 'a'),\n    ('b', 'd'),\n    ('c', 'a'),\n    ('d', 'a'),\n    ('d', 'b'),\n    ('d', 'c'),\n] \n```", "```py\n>>> graph = dict()\n>>> for from_, to in nodes:\n...     if from_ not in graph:\n...         graph[from_] = []\n...     graph[from_].append(to)\n\n>>> import pprint\n\n>>> pprint.pprint(graph)\n{'a': ['b', 'c'],\n 'b': ['a', 'd'],\n 'c': ['a'],\n 'd': ['a', 'b', 'c']} \n```", "```py\n>>> import collections\n\n>>> graph = collections.defaultdict(list)\n>>> for from_, to in nodes:\n...     graph[from_].append(to)\n\n>>> import pprint\n\n>>> pprint.pprint(graph)\ndefaultdict(<class 'list'>,\n            {'a': ['b', 'c'],\n             'b': ['a', 'd'],\n             'c': ['a'],\n             'd': ['a', 'b', 'c']}) \n```", "```py\n>>> counter = collections.defaultdict(int)\n>>> counter['spam'] += 5\n>>> counter\ndefaultdict(<class 'int'>, {'spam': 5}) \n```", "```py\nimport collections\ndef tree(): return collections.defaultdict(tree) \n```", "```py\n>>> import json\n>>> import collections\n\n>>> def tree():\n...     return collections.defaultdict(tree)\n\n>>> colours = tree()\n>>> colours['other']['black'] = 0x000000\n>>> colours['other']['white'] = 0xFFFFFF\n>>> colours['primary']['red'] = 0xFF0000\n>>> colours['primary']['green'] = 0x00FF00\n>>> colours['primary']['blue'] = 0x0000FF\n>>> colours['secondary']['yellow'] = 0xFFFF00\n>>> colours['secondary']['aqua'] = 0x00FFFF\n>>> colours['secondary']['fuchsia'] = 0xFF00FF\n\n>>> print(json.dumps(colours, sort_keys=True, indent=4))\n{\n    \"other\": {\n        \"black\": 0,\n        \"white\": 16777215\n    },\n    \"primary\": {\n        \"blue\": 255,\n        \"green\": 65280,\n        \"red\": 16711680\n    },\n    \"secondary\": {\n        \"aqua\": 65535,\n        \"fuchsia\": 16711935,\n        \"yellow\": 16776960\n    }\n} \n```", "```py\n>>> import enum\n\n>>> class Color(enum.Enum):\n...     red = 1\n...     green = 2\n...     blue = 3\n\n>>> Color.red\n<Color.red: 1>\n>>> Color['red']\n<Color.red: 1>\n>>> Color(1)\n<Color.red: 1>\n>>> Color.red.name\n'red'\n>>> Color.red.value\n1\n>>> isinstance(Color.red, Color)\nTrue\n>>> Color.red is Color['red']\nTrue\n>>> Color.red is Color(1)\nTrue \n```", "```py\n>>> for color in Color:\n...     color\n<Color.red: 1>\n<Color.green: 2>\n<Color.blue: 3>\n\n>>> colors = dict()\n>>> colors[Color.green] = 0x00FF00\n>>> colors\n{<Color.green: 2>: 65280} \n```", "```py\n>>> import enum\n\n>>> class Spam(enum.Enum):\n...     EGGS = 'eggs'\n\n>>> Spam.EGGS == 'eggs'\nFalse \n```", "```py\n>>> import enum\n\n>>> class Spam(str, enum.Enum):\n...     EGGS = 'eggs'\n\n>>> Spam.EGGS == 'eggs'\nTrue \n```", "```py\n>>> import heapq\n\n>>> heap = [1, 3, 5, 7, 2, 4, 3]\n>>> heapq.heapify(heap)\n>>> heap\n[1, 2, 3, 7, 3, 4, 5]\n\n>>> while heap:\n...     heapq.heappop(heap), heap\n(1, [2, 3, 3, 7, 5, 4])\n(2, [3, 3, 4, 7, 5])\n(3, [3, 5, 4, 7])\n(3, [4, 5, 7])\n(4, [5, 7])\n(5, [7])\n(7, []) \n```", "```py\n 1\n 2   3\n7 3 4 5 \n```", "```py\n>>> def heapsort(iterable):\n...     heap = []\n...     for value in iterable:\n...         heapq.heappush(heap, value)\n...\n...     while heap:\n...         yield heapq.heappop(heap)\n\n>>> list(heapsort([1, 3, 5, 2, 4, 1]))\n[1, 1, 2, 3, 4, 5] \n```", "```py\n>>> import bisect\n\n# Using the regular sort:\n>>> sorted_list = []\n>>> sorted_list.append(5)  # O(1)\n>>> sorted_list.append(3)  # O(1)\n>>> sorted_list.append(1)  # O(1)\n>>> sorted_list.append(2)  # O(1)\n>>> sorted_list.sort()  # O(n * log(n)) = 4 * log(4) = 8\n>>> sorted_list\n[1, 2, 3, 5]\n\n# Using bisect:\n>>> sorted_list = []\n>>> bisect.insort(sorted_list, 5)  # O(n) = 1\n>>> bisect.insort(sorted_list, 3)  # O(n) = 2\n>>> bisect.insort(sorted_list, 1)  # O(n) = 3\n>>> bisect.insort(sorted_list, 2)  # O(n) = 4\n>>> sorted_list\n[1, 2, 3, 5] \n```", "```py\n>>> sorted_list = [1, 2, 5]\n\n>>> def contains(sorted_list, value):\n...     for item in sorted_list:\n...         if item > value:\n...             break\n...         elif item == value:\n...             return True\n...     return False\n\n>>> contains(sorted_list, 2)  # Need to walk through 2 items, O(n) = 2\nTrue\n>>> contains(sorted_list, 4)  # Need to walk through 3 items, O(n) = 3\nFalse\n>>> contains(sorted_list, 6)  # Need to walk through 3 items, O(n) = 3\nFalse \n```", "```py\n>>> import bisect\n\n>>> sorted_list = [1, 2, 5]\n>>> def contains(sorted_list, value):\n...     i = bisect.bisect_left(sorted_list, value)\n...     return i < len(sorted_list) and sorted_list[i] == value\n\n>>> contains(sorted_list, 2)  # Found it after the first step, O(log(n)) = 1\nTrue\n>>> contains(sorted_list, 4)  # No result after 2 steps, O(log(n)) = 2\nFalse\n>>> contains(sorted_list, 6)  # No result after 2 steps, O(log(n)) = 2\nFalse \n```", "```py\nsorted_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\nStep 1: 4 > 7                       ^\nStep 2: 4 > 3           ^\nStep 3: 4 > 5                 ^\nStep 4: 4 > 5              ^ \n```", "```py\n>>> import bisect\n>>> import collections\n\n>>> class SortedList:\n...     def __init__(self, *values):\n...         self._list = sorted(values)\n...     \n...     def index(self, value):\n...         i = bisect.bisect_left(self._list, value)\n...         if i < len(self._list) and self._list[i] == value:\n...             return index\n...\n...     def delete(self, value):\n...         del self._list[self.index(value)]\n...\n...     def add(self, value):\n...         bisect.insort(self._list, value)\n...\n...     def __iter__(self):\n...         for value in self._list:\n...             yield value\n...\n...     def __exists__(self, value):\n...         return self.index(value) is not None\n\n>>> sorted_list = SortedList(1, 3, 6, 2)\n>>> 3 in sorted_list\nTrue\n>>> 5 in sorted_list\nFalse\n>>> sorted_list.add(5)\n>>> 5 in sorted_list\nTrue\n>>> list(sorted_list)\n[1, 2, 3, 5, 6] \n```", "```py\n>>> class Borg:\n...     _state = {}\n...     def __init__(self):\n...         self.__dict__ = self._state\n\n>>> class SubBorg(Borg):\n...     pass\n\n>>> a = Borg()\n>>> b = Borg()\n>>> c = Borg()\n>>> a.a_property = 123\n>>> b.a_property\n123\n>>> c.a_property\n123 \n```", "```py\n>>> class Singleton:\n...     def __new__(cls):\n...         if not hasattr(cls, '_instance'):\n...             cls._instance = super(Singleton, cls).__new__(cls)\n...\n...         return cls._instance\n\n>>> class SubSingleton(Singleton):\n...     pass\n\n>>> a = Singleton()\n>>> b = Singleton()\n>>> c = SubSingleton()\n>>> a.a_property = 123\n>>> b.a_property\n123\n>>> c.a_property\n123 \n```", "```py\n>>> class Sandwich:\n...     def __init__(self, spam):\n...         self.spam = spam\n...\n...     @property\n...     def spam(self):\n...         return self._spam\n...\n...     @spam.setter\n...     def spam(self, value):\n...         self._spam = value\n...         if self._spam >= 5:\n...             print('You must be hungry')\n...\n...     @spam.deleter\n...     def spam(self):\n...         self._spam = 0\n\n>>> sandwich = Sandwich(2)\n>>> sandwich.spam += 1\n>>> sandwich.spam += 2\nYou must be hungry \n```", "```py\n>>> a = dict(x=1, y=2)\n>>> b = dict(y=1, z=2)\n\n>>> c = a.copy()\n>>> c\n{'x': 1, 'y': 2}\n>>> c.update(b)\n\n>>> a\n{'x': 1, 'y': 2}\n>>> b\n{'y': 1, 'z': 2}\n>>> c\n{'x': 1, 'y': 1, 'z': 2} \n```", "```py\n>>> a = dict(x=1, y=2)\n>>> b = dict(y=1, z=2)\n\n>>> a | b\n{'x': 1, 'y': 1, 'z': 2} \n```", "```py\nsome_function(**(default_arguments | given_arguments)) \n```"]