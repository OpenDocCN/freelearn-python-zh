- en: Chapter 4.  Throttling, Filtering, Testing, and Deploying an API with Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the additional features included in Django and
    Django REST Framework to improve our RESTful API. We will also write and execute
    unit tests and learn a few things related to deployment. We will cover the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding throttling classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring throttling policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing throttle policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding filtering, searching and ordering classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring filtering, searching, and ordering for views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing filtering, searching and ordering features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter, search, and order in the browsable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a first round of unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit tests and checking testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving testing coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding strategies for deployments and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding throttling classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven't established any limits on the usage of our API, and therefore,
    both authenticated and unauthenticated users can compose and send as many requests
    as they want to. We only took advantage of the pagination features available in
    Django REST Framework to specify how we wanted large results sets to be split
    into individual pages of data. However, any user can compose and send thousands
    of requests to be processed without any kind of limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use throttling to configure the following limitations of the usage
    of our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unauthenticated users**: A maximum of five requests per hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authenticated users**: A maximum of 20 requests per hour.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we want to configure a maximum of 100 requests per hour to the
    game categories related views, no matter whether the user is authenticated or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Django REST Framework provides the following three throttling classes in the
    `rest_framework.throttling` module. All of them are subclasses of the `SimpleRateThrottle`
    class, which is a subclass of the `BaseThrottle` class. The classes allow us to
    set the maximum number of requests per period that are computed based on different
    mechanisms to determine the previous request information used to specify the scope.
    The previous request information for throttling is stored in the cache and the
    classes override the `get_cache_key` method that determines the scope.
  prefs: []
  type: TYPE_NORMAL
- en: '`AnonRateThrottle`: This class limits the rate of request that an anonymous
    user can make. The IP address of the request is the unique cache key, and therefore,
    all the requests coming from the same IP address will accumulate the total number
    of requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserRateThrottle`: This class limits the rate at which a specific user can
    make requests. For authenticated users, the authenticated user ID is the unique
    cache key. For anonymous users, the IP address of the request is the unique cache
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScopedRateThrottle`: This class limits the rate of request for specific parts
    of the API identified with the value assigned to the `throttle_scope` property.
    The class is useful when we want to restrict access to specific parts of the API
    with different rates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring throttling policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use a combination of the three throttling classes, discussed earlier,
    to achieve our previously explained goals. Make sure you quit Django's development
    server. Remember that you just need to press ***Ctrl*** + ***C*** in the Terminal
    or Command Prompt window in which it is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `gamesapi/settings.py` file and add the highlighted lines to the dictionary
    named `REST_FRAMEWORK` with two key-value pairs that configure the global default
    throttling classes and their rates. The code file for the sample is included in
    the `restful_python_chapter_04_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `DEFAULT_THROTTLE_CLASSES` settings key specifies a global
    setting with a tuple of string whose values indicate the default classes that
    we want to use for throttling-`AnonRateThrottle` and `UserRateThrottle`. The `DEFAULT_THROTTLE_RATES`
    settings key specifies a dictionary with default throttle rates. The value specified
    for the `'anon'` key indicates that we want a maximum of five requests per hour
    for anonymous users. The value specified for the `'user'` key indicates that we
    want a maximum of 20 requests per hour for authenticated users. The value specified
    for the `'game-categories'` key indicates that we want a maximum of `30` requests
    per hour for the scope with that name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximum rate is a string that specifies the number of requests per period
    with the following format: `''number_of_requests/period''`, where period can be
    any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sec`: second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: minute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min`: minute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h`: hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hour`: hour'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`day`: day'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will configure throttling policies for the class-based views related
    to game categories. We will override the value for the `throttle_scope` and `throttle_classes`
    class attributes for the `GameCategoryList` and `GameCategoryDetail` classes.
    First, we have to add the following `import` statement after the last import in
    the `views.py` file. The code file for the sample is included in the `restful_python_chapter_04_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the new code for the `GameCategoryList` class in the
    `views.py` file. The new lines are highlighted. The code file for the sample is
    included in the `restful_python_chapter_04_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the new code for the `GameCategoryDetail` class in
    the `views.py` file. The new lines are highlighted in the following code. The
    code file for the sample is included in the `restful_python_chapter_04_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the same lines in the two classes. We set `''game-categories''` as
    the value for the `throttle_scope` class attribute and we included `ScopedRateThrottle`
    in the tuple that defines the value for `throttle_classes`. This way, the two
    class-based views will use the settings specified for the `''game-categories''`
    scope and the `ScopeRateThrottle` class for throttling. These views will be able
    to serve 30 requests per hour and won''t take into account the global settings
    that apply to the default classes that we use for throttling: `AnonRateThrottle`
    and `UserRateThrottle`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before Django runs the main body of a view, it performs the checks for each
    throttle class specified in the throttle classes. In the views related to the
    game categories, we wrote code that overrides the default settings. If a single
    throttle check fails, the code will raise a `Throttled` exception and Django won't
    execute the main body of the view. The cache is responsible of storing previous
    requests' information for throttling checking.
  prefs: []
  type: TYPE_NORMAL
- en: Testing throttling policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can launch Django's development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django") *,* *Developing RESTful APIs with Django*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve all the player''s
    scores without authentication credentials six times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the features of the shell in macOS or Linux to run the previous
    command six times with just a single line. We can also run the command in a Cygwin
    terminal in Windows. We can execute the next line in a bash shell. However, we
    will see all the results one after the other and you will have to scroll to understand
    what happened with each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that we must execute six times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that is executed six times with
    a single line in a bash shell in macOS or Linux, or a Cygwin terminal in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Django won''t process the sixth request because `AnonRateThrottle` is configured
    as one of the default throttle classes and its throttle settings specify five
    requests per hour. Thus, we will receive a `429 Too many requests` status code
    in the response header and a message indicating that the request was throttled
    and the time in which the server will be able to process an additional request.
    The `Retry-After` key in the response header provides the number of seconds that
    it is necessary to wait until the next request: `3189`. The following lines show
    a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will compose and send an HTTP request to retrieve the player's scores
    with authentication credentials, that is, with the `superuser` name and his password.
    We will execute the same request six times. Remember to replace `superuser` with
    the name you used for the `superuser` and `password` with the password you configured
    for this user in [Chapter 3](ch03.html "Chapter 3.  Improving and Adding Authentication
    to an API With Django") *,* *Improving and Adding Authentication to an API with
    Django:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also run the previous command six times with just a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command that we must execute six times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command that is executed six times with
    a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Django will process the sixth request because we have composed and sent six authenticated
    requests with the same user, `UserRateThrottle` is configured as one of the default
    throttle classes and its throttle settings specify 20 requests per hour.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the previous commands 15 times more, we will accumulate 21 requests
    and we will will receive a `429 Too many requests` status code in the response
    header and a message indicating that the request was throttled and the time in
    which the server will be able to process an additional request after the last
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve all the game categories
    thirty times without the authentication credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also run the previous command thirty times with just a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command that we must execute thirty
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command that is executed thirty times
    with a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Django will process the thirty requests because we have composed and sent 30
    unauthenticated requests to a URL that is identified with the `'game-categories'`
    throttle scope and uses the `ScopedRateThrottle` class for throttle permission
    control. The throttle settings for the throttle scope identified with `'game-categories'`
    are configured with 30 requests per hour.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the previous command once again, we will accumulate 31 requests and
    we will receive a `429 Too many requests` status code in the response header and
    a message indicating that the request was throttled and the time in which the
    server will be able to process an additional request after the last execution.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding filtering, searching, and ordering classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We took advantage of the pagination features available in Django REST Framework
    to specify how we wanted large results sets to be split into individual pages
    of data. However, we have always been working with the entire queryset as the
    result set. Django REST Framework makes it easy to customize filtering, searching,
    and sorting capabilities to the views we have already coded.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will install the `django-filter` package in our virtual environment.
    This way, we will be able to use field filtering features that we can easily customize
    in Django REST Framework. Make sure that you quit the Django''s development server.
    Remember that you just need to press ***Ctrl*** + ***C*** in the terminal or Command
    Prompt window in which it is running. Then, we just need to run the following
    command to install the `django-filter` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The last lines for the output will indicate that the `django-filter` package
    has been successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we will install the `django-cripsy-forms` package in our virtual
    environment. This package enhances how the browsable API renders the different
    filters. Run the following command to install the `django-cripsy-forms` package:
    We just need to run the following command to install this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate that the `django-crispy-forms`
    package has been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `gamesapi/settings.py` file and add the highlighted lines to the `REST_FRAMEWORK`
    dictionary. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The value for the `''DEFAULT_FILTER_BACKENDS` settings key specifies a global
    setting with a tuple of string whose values indicate the default classes that
    we want to use for filter backends. We will use the following three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rest_framework.filters.DjangoFilterBackend`: This class provides field filtering
    capabilities. It uses the previously installed `django-filter` package. We can
    specify the set of fields we want to be able to filter against or create a `rest_framework.filters.FilterSet`
    class with more customized settings and associate it with the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest_framework.filters.SearchFilter`: This class provides single query parameter-based
    searching capabilities and it is based on Django admin''s search function. We
    can specify the set of fields we want to include for the search and the client
    will be able to filter items by making queries that search these fields with a
    single query. It is useful when we want to make it possible for a request to search
    multiple fields with a single query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rest_framework.filters.OrderingFilter`: This class allows the client to control
    how the results are ordered with a single-query parameter. We can also specify
    the fields that can be ordered against.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also configure the filter backends by including any of the previously
    enumerated classes in a tuple and assign it to the `filter_backends` class attribute
    for the generic view classes. However, in this case, we will use the default configuration
    for all our class-based views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `''crispy_forms''` to the installed apps in the `settings.py` file, specifically,
    to the `INSTALLED_APPS` string list. The following code shows the lines we must
    add as the highlighted code. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have to be careful with the fields we configure to be available in the filtering,
    searching, and ordering features. The configuration will have an impact on the
    queries executed on the database, and therefore, we must ensure that we have the
    appropriate database optimizations considering the queries that will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring filtering, searching, and ordering for views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to the `gamesapi/games` folder and open the `views.py` file. Add the following
    code after the last line that declares the imports but before the declaration
    of the `UserList` class. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following highlighted lines to the `GameCategoryList` class declared
    in the `views.py` file. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `filter_fields` attribute specifies a tuple of string whose values indicate
    the field names that we want to be able to filter against. Under the hoods, Django
    REST Framework will automatically create a `rest_framework.filters.FilterSet`
    class and associate it to the `GameCategoryList` view. This way, we will be able
    to filter against the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: The `search_fields` attribute specifies a tuple of string whose values indicate
    the text-type field names that we want to include in the search feature. In this
    case, we want to search only against the name field and perform a starts-with
    match. The `'^'` included as a prefix of the field name indicates that we want
    to restrict the search behavior to a starts-with match.
  prefs: []
  type: TYPE_NORMAL
- en: The `ordering_fields` attribute specifies a tuple of string whose values indicate
    the field names that the client can specify to sort the results. In case the client
    doesn't specify a field for ordering, the response will use the default ordering
    fields indicated in the model related to the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted lines to the `GameList` class declared in the
    `views.py` file. The new lines specify the fields to be used in the filter, search,
    and ordering features. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we specified many field names in the `filter_fields` attribute.
    We included `'game_category'` and `'owner'` in the string tuple, and therefore,
    the client will be able to include the id values for any of these two fields in
    the filter. We will take advantage of other options for related models, which
    will later allow us to filter the related models by field. This way, we will understand
    the different customizations available.
  prefs: []
  type: TYPE_NORMAL
- en: The `ordering_fields` attribute specifies two field names for the tuple of string,
    and therefore, the client will be able to order the results by either `name` or
    `release_date`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted lines to the `PlayerList` class declared in the
    `views.py` file. The new lines specify the fields to be used in the filter, search,
    and ordering features. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines to create the new `PlayerScoreFilter` class in the
    `views.py` file but before the declaration of the `PlayerScoreList` class. The
    code file for the sample is included in the `restful_python_chapter_04_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PlayerScoreFilter` is a subclass of the `rest_framework.filters.FilterSet`
    class. We want to customize settings for the fields that we will use for filtering
    in the `PlayerScoreList` class-based view, and therefore, we created the new `PlayerScoreFilter`
    class. The class declares the following six class attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min_score`: It is a `django_filters.NumberFilter` instance that allows the
    client to filter the player scores whose `score` numeric value is greater than
    or equal to the specified number. The value for `name` indicates the field to
    which the numeric filter is applied, `''score''`, and the `lookup_expr` value
    indicates the lookup expression, `''gte''`, which means greater than or equal
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_score`: It is a `django_filters.NumberFilter` instance that allows the
    client to filter the player scores whose `score` numeric value is less than or
    equal to the specified number. The value for `name` indicates the field to which
    the numeric filter is applied, `''score''`, and the `lookup_expr` value indicates
    the lookup expression, `''lte''`, which means less than or equal to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from_score_date`: It is a `django_filters.DateTimeFilter` instance that allows
    the client to filter the player scores whose `score_datedatetime` value is greater
    than or equal to the specified `datetime` value. The value for `name` indicates
    the field to which the datetime filter is applied, `''score_date''`, and the `lookup_expr`
    value indicates the lookup expression, `''gte''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to_score_date`: It is a `django_filters.DateTimeFilter` instance that allows
    the client to filter the player scores whose `score_datedatetime` value is less
    than or equal to the specified `datetime` value. The value for `name` indicates
    the field to which the `datetime` filter is applied, `''score_date''`,and the
    `lookup_expr` value indicates the lookup expression, `''lte''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`player_name`: It is a `django_filters.AllValuesFilte`r: It is an instance
    that allows the client to filter the player scores whose player''s name matches
    the specified string value. The value for `name` indicates the field to which
    the filter is applied, `''player__name''`. Note that the value has a double underscore
    (`__`) and you can read it as the `name` field for the `player` model or simply
    replace the double underscore with a dot and read `player.name`. The name uses
    Django''s double underscore syntax. However, we don''t want the client to use
    `player__name` to specify the filter for the player''s name. Thus, the instance
    is stored in the class attribute named `player_name`, with just a single underscore
    between player and name. The browsable API will display a dropdown with all the
    possible values for the player''s name to use as a filter. The dropdown will only
    include the players'' names that have registered scores because we used the `AllValuesFilter`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`game_name`: This is a `django_filters.AllValuesFilter` instance that allows
    the client to filter the player scores whose game''s name matches the specified
    string value. The value for `name` indicates the field on which the filter is
    applied, `''game__name''`. The name uses the previously explained Django''s double
    underscore syntax. As happened with `player_name`, we don''t want the client to
    use `game__name` to specify the filter for the game''s name, and therefore, we
    stored the instance in the class attribute named `game_name`, with just a single
    underscore between game and name. The browsable API will display a dropdown with
    all the possible values for the game''s name to use as a filter. The dropdown
    will only include the game''s names that have registered scores because we used
    the `AllValuesFilter` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the `PlayerScoreFilter` class declares a `Meta` inner class that
    declares two attributes: `model` and `fields`. The `model` attribute specifies
    the model related to the filter set, that is, the `PlayerScore` class. The `fields`
    attribute specifies a tuple of string whose values indicate the field names and
    filter names that we want to include in the filters for the related model. We
    included `''scores''` and the names for all the previously declared filters. The
    string `''scores''` refers to the `score` field name and we want to apply the
    default numeric filter that will be built under the hoods to allow the client
    to filter by an exact match on the `score` field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following highlighted lines to the `PlayerScoreList` class
    declared in the `views.py` file. The code file for the sample is included in the
    `restful_python_chapter_04_02` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter_class` attribute specifies the `FilterSet` subclass that we want
    to use for this class-based view: `PlayerScoreFilter`. In addition, we specified
    the two field names that the client will be able to use for ordering in the `ordering_fields`
    tuple of string.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing filtering, searching, and ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can launch Django's development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"), *Developing RESTful APIs with Django*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run any of the previous commands, the development server will start
    listening at port `8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will compose and send an HTTP request to retrieve all the game categories
    whose name matches `3D RPG`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the single game category whose
    name matches the specified name in the filter. The following lines only show the
    JSON body without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will compose and send an HTTP request to retrieve all the games whose related
    category id is equal to `3` and the value for the played field is equal to `True`.
    We want to sort the results by `release_date` in descending order, and therefore,
    we specify `-release_date` in the value for `ordering`. The hyphen (`-`) before
    the field name specifies the ordering feature to use descending order instead
    of the default ascending order. Make sure you replace `3` with the pk value of
    the previously retrieved game category named `3D RPG`. The played field is a `bool`
    field, and therefore, we have to use Python-valid `bool` values (`True` and `False`)
    when specifying the desired values for the `bool` field in the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the two games that match the
    specified criteria in the filter. The following lines only show the JSON body
    without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GameList` class, we specified `''game_category''` as one of the strings
    in the `filter_fields` tuple of string. Thus, we had to use the game category
    id in the filter. Now, we will use a filter on the game''s name related to a registered
    score. The `PlayerScoreFilter` class provides us a filter to the name of the related
    game in `game_name`. We will combine the filter with another filter on the player''s
    name related to a registered score. The `PlayerScoreFilter` class provides us
    a filter to the name of the related player in `player_name`. Both conditions specified
    in the criteria must be met, and therefore, the filters are combined with the
    `AND` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the score that matches the
    specified criteria in the filters. The following lines only show the JSON body
    without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We will compose and send an HTTP request to retrieve all the scores that match
    the following criteria. The results will be ordered by `score_date` in descending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: The `score` value is between 30,000 and 150,000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `score_date` is between 2016-06-21 and 2016-06-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the three games that match
    the specified criteria in the filters. We overrode the default ordering specified
    in the model with the specified ordering in the request. The following lines only
    show the JSON body without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding requests, all the responses didn't have more than one page.
    In case the response requires more than one page, the values for the `previous`
    and `next` keys will display the URLs that include the combination of the filters,
    search, ordering and pagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will compose and send an HTTP request to retrieve all the games whose `name`
    starts with `''S''`. We will use the search feature that we configured to restrict
    the search behavior to a starts-with match on the `name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show a sample response with the two games that match the
    specified search criteria, that is, those games whose name starts with `''S''`.
    The following lines only show the JSON body without the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can change the search and ordering parameter''s default names: `''search''`
    and `''ordering''`. We just need to specify the desired names in the `SEARCH_PARAM`
    and the `ORDERING_PARAM` settings.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering, searching, and ordering in the Browsable API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can take advantage of the browsable API to easily test filter, search, and
    order features through a web browser. Open a web browser and enter `http://localhost:8000/player-scores/`.
    In case you use another computer or device to run the browser, replace `localhost` with
    the IP of the computer that is running the Django development server. The browsable
    API will compose and send a `GET` request to `/player-scores/` and will display
    the results of its execution, that is, the headers and the JSON player scores
    list. You will notice that there is a new **Filters** button located on the left-hand
    side of the **OPTIONS** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Filters** and the browsable API will display the **Filters** dialog
    box with the appropriate controls for each filter that you can apply below **Field
    Filters** and the different ordering options below **Ordering**. The following
    screenshot shows the **Filters** dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering, searching, and ordering in the Browsable API](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Both the **Player name** and **Game name** dropdowns will only include the
    related player''s and game''s names that have registered scores because we used
    the `AllValuesFilter` class for both filters. After we enter all the values for
    the filters, we can select the desired ordering option or click **Submit**. The
    browsable API will compose and send the appropriate HTTP request and will render
    a web page with the results of its execution. The results will include the HTTP
    request that was made to the Django server. The following screenshot shows an
    example of the result of executing the next request, that is, the request we built
    using the browsable API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![Filtering, searching, and ordering in the Browsable API](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will install the `coverage` and `django-nose` packages in our virtual
    environment. We will make the necessary configurations to use the `django_nose.NoseTestRunner`
    class to run all the tests we code and we will use the necessary configurations
    to improve the accuracy of the test coverage measurements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you quit Django''s development server. Remember that you just
    need to press **Ctrl** + **C** in the terminal or the Command Prompt window in
    which it is running. We just need to run the following command to install the
    `coverage` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The last few lines of the output indicate that the `django-nose` package has
    been successfully installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to run the following command to install the `django-nose` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The last few lines of the output indicate that the `django-nose` package has
    been successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `''django_nose''` to the installed apps in the `settings.py` file, specifically,
    to the `INSTALLED_APPS` string list. The following code shows the lines we need
    to add as highlighted code. The code file for the sample is included in the `restful_python_chapter_04_03`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `gamesapi/settings.py` file and add the following lines to configure
    the `django_nose.NoseTestRunner` class as our test runner and specify the default
    command-line options that we will use when we run our tests. The code file for
    the sample is included in the `restful_python_chapter_04_03` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NOSE_ARGS` settings specify the following command-line options for the
    nose test suite runner and for coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--with-coverage`: This option specifies that we always want to generate a
    test coverage report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cover-erase`: This option makes sure the the test runner deletes the coverage
    test results from the previous run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cover-inclusive`: This option includes all the Python files under the working
    directory in the coverage report. This way, we make sure that we discover holes
    in test coverage when we don''t import all the files in our test suite. We will
    create a test suite that won''t import all the files, and therefore, this option
    is very important to have an accurate test coverage report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cover-package=games`: This option indicates the module that we want to cover:
    `games`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, create a new text file named `.coveragerc` within the `gamesapi` root
    folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `coverage` utility won't take into account many things related
    to the generated migrations when providing us with the test coverage report. We
    will have a more accurate test coverage report with this settings file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a first round of unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write the first round of unit tests. Specifically, we will write
    unit tests related to the game category class-based views: `GameCategoryList`
    and `GameCategoryDetail`. Open the existing `games/test.py` file and replace the
    existing code with the following lines that declare many `import` statements and
    the `GameCategoryTests` class. The code file for the sample is included in the
    `restful_python_chapter_04_04` folder, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `GameCategoryTests` class is a subclass of `rest_framework.test.APITestCase`.
    The class declares the `create_game_category` method that receives the desired
    `name` for the new game category as an argument. The method builds the URL and
    the data dictionary to compose and send an HTTP `POST` method to the view associated
    with the `gamecategory-list` view name and returns the response generated by this
    request. The code uses `self.client` to access the `APIClient` instance that allows
    us to easily compose and send HTTP requests for testing. In this case, the code
    calls the `post` method with the built `url`, the `data` dictionary, and the desired
    format for the data-`'json'`. Many test methods will call the `create_game_category`
    method to create a game category and then compose and send other HTTP requests
    to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test_create_and_retrieve_game_category` method tests whether we can create
    a new `GameCategory` and then retrieve it. The method calls the `create_game_category`
    method explained earlier and then uses `assertEqual` to check for the following
    expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: The `status_code` for the response is HTTP 201 Created (`status.HTTP_201_CREATED`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total number of `GameCategory` objects retrieved from the database is `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the following methods to the `GameCategoryTests` class we created in the
    `games/test.py` file. The code file for the sample is included in the `restful_python_chapter_04_04`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the following methods that start whose name start with the `test_`
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_create_duplicated_game_category`: Tests whether the unique constraints
    don''t make it possible for us to create two game categories with the same name.
    The second time we compose and send an HTTP POST request with a duplicate category
    name, we must receive an `HTTP 400 Bad Request` status code (`status.HTTP_400_BAD_REQUEST`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_retrieve_game_categories_list`: Tests whether we can retrieve a specific
    game category by its primary key or id'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_update_game_category`: Tests whether we can update a single field for
    a game category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_filter_game_category_by_name`: Tests whether we can filter a game category
    by name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that each test that requires a specific condition in the database must
    execute all the necessary code for the database to be in this specific condition.
    For example, in order to update an existing game category, first we must create
    a new game category and then we can update it. Each test method will be executed
    without data from the previously executed test methods in the database, that is,
    each test will run with a database cleaned of data from previous tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last three methods in the preceding list check the data included in the
    response JSON body by inspecting the `data` attribute for the response. For example,
    the first line checks whether the value for `count` is equal to `1` and the next
    lines check whether the `name` key for the first element in the `results` array
    is equal to the value hold in the `new_game_category_name` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `test_filter_game_category_by_name` method calls the `django.utils.http.urlencode`
    function to generate an encoded URL from the `filter_by_name` dictionary that
    specifies the field name and the value we want to use to filter the retrieved
    data. The following lines show the code that generates the URL and saves it in
    the `url` variable. If `game_cagory_name1` is `'First game category name'`, the
    result of the call to the `urlencode` function will be `'name=First+game+category+name'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Running unit tests and checking testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, run the following command to create a test database, run all the migrations
    and use the Django nose test running to execute all the tests we created. The
    test runner will execute all the methods for our `GameCategoryTests` class that
    start with the `test_` prefix and will display the results.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests won't make changes to the database we have been using when working
    on the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we configured many default command-line options that will be
    used without the need to enter them in our command-line. Run the following command
    within the same virtual environment we have been using. We will use the `-v 2`
    option to use the verbosity level 2 because we want to check all the things that
    the test runner is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The output provides the details indicating that the test runner executed 5
    tests and all of them passed. After the details about the migrations are executed,
    the output displays the comments we included for each method in the `GameCategoryTests`
    class that started with the `test_` prefix and represented a test to be executed.
    The following list shows the description included in the comments and the method
    that they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensures we can create a new GameCategory and then retrieve it: `test_create_and_retrieve_game_category`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensures we can create a new GameCategory: `test_create_duplicated_game_category`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensures we can filter a game category by name: `test_retrieve_game_categories_list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensures we can retrieve a game cagory: `test_update_game_category`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ensures we can update a single field for a game category: `test_filter_game_category_by_name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The test code coverage measurement report provided by the `coverage` package
    uses the code analysis tools and the tracing hooks included in the Python standard
    library to determine which lines of code are executable and which of these lines
    have been executed. The report provides a table with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The Python module name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stmts`: The count of executable statements for the Python module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Miss`: The number of executable statements missed, that is, the ones that
    weren''t executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cover`: The coverage of executable statements, expressed as a percentage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We definitely have a very low coverage for `models.py` based on the measurements
    shown in the report. In fact, we just wrote a few tests related to the `GameCategory`
    model, and therefore, it makes sense that the coverage is really low for the models:'
  prefs: []
  type: TYPE_NORMAL
- en: We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will use the information from the last execution and will display
    the missing statements. The next lines show a sample output that correspond to
    the previous execution of the unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Open the `index.html` HTML file generated in the `htmlcov` folder with your
    web browser. The following picture shows an example report that coverage generated
    in HTML format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests and checking testing coverage](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click or tap on `games/models.py` and the web browser will render a web page
    that displays the statements that were run, the missing ones and the excluded,
    with different colors. We can click or tap on the **run**, **missing,** and **excluded**
    buttons to show or hide the background color that represents the status for each
    line of code. By default, the missing lines of code will be displayed with a pink
    background. Thus, we must write unit tests that target these lines of code to
    improve our tests coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running unit tests and checking testing coverage](img/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Improving testing coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to the player class based views: `PlayerList`
    and `PlayerDetail`. Open the existing `games/test.py` file and insert the following
    lines after the last line that declares imports. We need a new `import` statement
    and we will declare the new `PlayerTests` class. The code file for the sample
    is included in the `restful_python_chapter_04_05` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayerTests` class is a subclass of `rest_framework.test.APITestCase`.
    The class declares the `create_player` method that receives the desired `name`
    and `gender` for the new player as arguments. The method builds the url and the
    data dictionary to compose and send an HTTP `POST` method to the view associated
    with the `player-list` view name and returns the response generated by this request.
    Many test methods will call the `create_player` method to create a player and
    then compose and send other HTTP requests to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class declares the following methods that start whose name start with the
    `test_` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_create_and_retrieve_player`: Tests whether we can create a new `Player`
    and then retrieve it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_create_duplicated_player`: Tests whether the unique constraints don''t
    make it possible for us to create two players with the same name. The second time
    we compose and send an HTTP POST request with a duplicate player name, we must
    receive an HTTP 400 Bad Request status code (`status.HTTP_400_BAD_REQUEST`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_retrieve_player_list`: Tests whether we can retrieve a specific game
    category by its primary key or id.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just coded a few tests related to players to improve test coverage and notice
    the impact on the test coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command within the same virtual environment we have
    been using. We will use the `-v 2` option to use the verbosity level 2 because
    we want to check all the things that the test runner is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the last lines of the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The output provides details that indicate that the test runner executed 8 tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage from 3% in the previous
    run to 6%. The additional tests we wrote execute code for the `Player` model,
    and therefore, there is an impact in the coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just created a few unit tests to understand how we can code them. However,
    of course, it would be necessary to write more tests to provide an appropriate
    coverage of all the featured and execution scenarios included in the API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding strategies for deployments and scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest drawbacks related to Django and Django REST Framework is
    that each HTTP request is blocking. Thus, whenever the Django server receives
    an HTTP request, it doesn't start working on any other HTTP requests in the incoming
    queue until the server sends the response for the first HTTP request it received.
  prefs: []
  type: TYPE_NORMAL
- en: However, one of the greatest advantages of RESTful Web Services is that they
    are stateless, that is, they shouldn't keep a client state on any server. Our
    API is a good example of a stateless RESTful Web Service. Thus, we can make the
    API run on as many servers as necessary to achieve our scalability goals. Obviously,
    we must take into account that we can easily transform the database server in
    our scalability bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowadays, we have a huge number of cloud-based alternatives to deploy a RESTful
    web service that uses Django and Django REST Framework and make it extremely scalable.
    Just to mention a few examples, we have Heroku, PythonAnywhere, Google App Engine,
    OpenShift, AWS Elastic Beanstalk, and Windows Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Each platform includes detailed instructions to deploy our application. All
    of them will require us to generate the `requirements.txt` file that lists the
    application dependencies together with their versions. This way, the platforms
    will be able to install all the necessary dependencies listed in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `pip freeze`, to generate the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the contents of a sample generated `requirements.txt`
    file. However, bear in mind that many packages increase their version number quickly
    and you might see different versions in your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We always have to make sure that we profile the API and the database before
    we deploy our first version of the RESTful Web Service. It is very important to
    make sure that the generated queries run properly on the underlying database and
    that the most popular queries do not end up in sequential scans. It is usually
    necessary to add the appropriate indexes to the tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have been using basic HTTP authentication. In case we decide to use this
    authentication or other mechanisms, we must make sure that the API runs under
    HTTPS in production environments. In addition, we must make sure that we change
    the following line in the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We must always turn off the debug mode in production, and therefore, we must
    replace the previous line with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ScopedRateThrottle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that a specific user can make.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests for specific parts of the API identified with the
    value assigned to the `throttle_scope` property.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that an anonymous user can make.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `UserRateThrottle` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that a specific user can make.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests for specific parts of the API identified with the
    value assigned to the `throttle_scope` property.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits the rate of requests that an anonymous user can make.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `DjangoFilterBackend` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides single query parameter based searching capabilities and it is based
    on the Django admin's search function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Allows the client to control how the results are ordered with a single query
    parameter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides field filtering capabilities.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `SearchFilter` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides single query parameter based searching capabilities and it is based
    on the Django admin's search function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Allows the client to control how the results are ordered with a single query
    parameter.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides field filtering capabilities.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a subclass of `APITestCase`, `self.client` is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APIClient` instance that allows us to easily compose and send HTTP requests
    for testing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APITestClient` instance that allows us to easily compose and send HTTP
    requests for testing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APITestCase` instance that allows us to easily compose and send HTTP requests
    for testing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took advantage of the features included in Django REST Framework
    to define throttling policies. We used filtering, searching, and ordering classes
    to make it easy to configure filters, search queries, and desired order for the
    results in HTTP requests. We used the browsable API feature to test these new
    features included in our API.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote the first round of unit tests, measured test coverage, and then we
    wrote additional unit tests to improve test coverage. Finally, we understood many
    considerations for deployment and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we built a complex API with Django REST Framework and tested it, we
    will move to another popular Python web framework, Flask, which is what we are
    going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
