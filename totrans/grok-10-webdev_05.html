<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Forms</h1></div></div></div><p>We have seen how easy it is to create a small application, such as the to-do list manager that we have developed over the past couple of chapters. We will now take a look at one of the many ways that Grok can help us develop more complex applications.</p><p>Until now, we have been working with simple one-or two-field forms. When we changed our model in the previous chapter, we had to go back and edit the HTML for the forms as well. With a couple of fields this requires little work, but when we have complex models with perhaps a dozen fields or more, it would be great if we didn't have to modify two files whenever we make a change.</p><p>Fortunately, Grok has a mechanism for automating the creation and processing of forms. We'll see how it works in this chapter, along with a few other form-related subjects:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is an interface</li><li class="listitem" style="list-style-type: disc">What is a schema</li><li class="listitem" style="list-style-type: disc">How interfaces and schemas are used to generate forms automatically, using Grok's form components</li><li class="listitem" style="list-style-type: disc">How to create, add, and edit forms</li><li class="listitem" style="list-style-type: disc">How to filter fields and prevent them from appearing in a form</li><li class="listitem" style="list-style-type: disc">How to change form templates and presentation</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec01"/>A quick demonstration of automatic forms</h1></div></div></div><p>Let's start by showing how this works, before getting into the details. To do that, we'll add a project model to our application. A project can have any number of lists associated with it, so that related to-do lists can be grouped together. For now, let's consider the project model by itself. Add the following lines to the<code class="literal"> app.py</code> file, just after the<code class="literal"> Todo</code> application class definition. We'll worry later about how this fits into the application as a whole.<a id="id136" class="indexterm"/>
</p><div><pre class="programlisting">class IProject(interface.Interface):
name = schema.TextLine(title=u'Name',required=True)
kind = schema.Choice(title=u'Kind of project',
values=['personal','business'])
description = schema.Text(title=u'Description')
class AddProject(grok.Form):
grok.context(Todo)
form_fields = grok.AutoFields(IProject)
</pre></div><p>We'll also need to add a couple of imports at the top of the file:<a id="id137" class="indexterm"/>
</p><div><pre class="programlisting">from zope import interface
from zope import schema
</pre></div><p>Save the file, restart the server, and go to the URL <a class="ulink" href="http://localhost:8080/todo/addproject">http://localhost:8080/todo/addproject</a>. The result should be similar to the following screenshot:</p><div><img src="img/7481_05_01.jpg" alt="A quick demonstration of automatic forms"/></div><p>OK, where did the HTML for the form come from? We know that<code class="literal"> AddProject</code> is some sort of a view, because we used the<code class="literal"> grok.context</code> class annotation to set its context and name. Also, the name of the class, but in lowercase, was used in the URL, like in previous view examples.</p><p>The important new thing is how the form fields were created and used. First, a class named<code class="literal"> IProject</code> was defined. The interface defines the fields on the form, and the<code class="literal"> grok.AutoFields</code> method assigns them to the<code class="literal"> Form</code> view class. That's how the view knows which HTML form controls to generate when the form is rendered.</p><p>We have three fields:<code class="literal"> name, description</code>, and<code class="literal"> kind</code>. Later in the code, the<code class="literal"> grok.AutoFields</code> line takes this<code class="literal"> IProject</code> class and turns these fields into form fields.<a id="id138" class="indexterm"/>
</p><p>That's it. There's no need for a template or a<code class="literal"> render</code> method. The<code class="literal"> grok.Form</code> view takes care of generating the HTML required to present the form, taking the information from the value of the<code class="literal"> form_fields</code> attribute that the<code class="literal"> grok.AutoFields</code> call generated.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Interfaces</h1></div></div></div><p>The<code class="literal"> I</code> in the class name stands for Interface. We imported the<code class="literal"> zope.interface</code> package at the top of the file, and the<code class="literal"> Interface</code> class that we have used as a base class for<code class="literal"> IProject</code> comes from this package.<a id="id139" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec01"/>Example of an interface</h2></div></div></div><p>An<strong> interface</strong> is an object that is used to specify and describe the external behavior of objects. In a sense, the interface is like a contract. A class is said to implement an interface when it includes all of the methods and attributes defined in an interface class. Let's see a simple example:<a id="id140" class="indexterm"/>
</p><div><pre class="programlisting">from zope import interface
class ICaveman(interface.Interface):
weapon = interface.Attribute('weapon')
def hunt(animal):
"""Hunt an animal to get food"""
def eat(animal):
"""Eat hunted animal"""
def sleep()
"""Rest before getting up to hunt again"""
</pre></div><p>Here, we are describing how cavemen behave. A caveman will have a weapon, and he can hunt, eat, and sleep. Notice that the<code class="literal"> weapon</code> is an<em> attribute</em> something that belongs to the object, whereas<code class="literal"> hunt, eat</code>, and<code class="literal"> sleep</code> are<em> methods</em>.</p><p>Once the interface is defined, we can create classes that implement it. These classes are committed to include all of the attributes and methods of their interface class. Thus, if we say:</p><div><pre class="programlisting">class Caveman(object):
interface.implements(ICaveman)
</pre></div><p>Then we are promising that the<code class="literal"> Caveman</code> class will implement the methods and attributes described in the<code class="literal"> ICaveman</code> interface:</p><div><pre class="programlisting">weapon = 'ax'
def hunt(animal):
find(animal)
hit(animal,self.weapon)
def eat(animal):
cut(animal)
bite()
def sleep():
snore()
rest()
</pre></div><p>Note that though our example class implements all of the interface methods, there is no enforcement of any kind made by the Python interpreter. We could define a class that does not include any of the methods or attributes defined, and it would still work.<a id="id141" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec02"/>Interfaces in Grok</h2></div></div></div><p>In Grok, a model can implement an interface by using the<code class="literal"> grok.implements</code> method. For example, if we decided to add a project model, it could implement the<code class="literal"> IProject</code> interface as follows:<a id="id142" class="indexterm"/>
</p><div><pre class="programlisting">class Project(grok.Container):
grok.implements(IProject)
</pre></div><p>Due to their descriptive nature, interfaces can be used for documentation. They can also be used for enabling component architectures, but we'll see about that later on. What is of more interest to us right now is that they can be used for generating forms automatically.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Schemas</h1></div></div></div><p>The way to define the form fields is to use the<code class="literal"> zope.schema</code> package. This package includes many kinds of field definitions that can be used to populate a form.<a id="id143" class="indexterm"/>
</p><p>Basically, a schema permits detailed descriptions of class attributes that are using fields. In terms of a form which is what is of interest to us here a schema represents the data that will be passed to the server when the user submits the form. Each field in the form corresponds to a field in the schema.</p><p>Let's take a closer look at the schema we defined in the last section:</p><div><pre class="programlisting">class IProject(interface.Interface):
name = schema.TextLine(title=u'Name',required=True)
kind = schema.Choice(title=u'Kind of project',
required=False,
values=['personal','business'])
description = schema.Text(title=u'Description',
required=False)
</pre></div><p>The schema that we are defining for<code class="literal"> IProject</code> has three fields. There are several kinds of fields, which are listed in the following table. In our example, we have defined a<code class="literal"> name</code> field, which will be a required field, and will have the label<code class="literal"> Name</code> beside it. We also have a<code class="literal"> kind</code> field, which is a list of options from which the user must pick one. Note that the default value for<code class="literal"> required</code> is<code class="literal"> True</code>, but it's usually best to specify it explicitly, to avoid confusion. You can see how the list of possible values is passed statically by using the<code class="literal"> values</code> parameter. Finally,<code class="literal"> description</code> is a text field, which means it will have multiple lines of text.<a id="id144" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec03"/>Available schema attributes and field types</h2></div></div></div><p>In addition to<code class="literal"> title, values</code>, and<code class="literal"> required</code>, each schema field can have a number of properties, as detailed in the following table:<a id="id145" class="indexterm"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">title</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A short summary or label.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">description</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A description of the field.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">required</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Indicates whether a field requires a value to exist.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">readonly</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If<code class="literal"> True</code>, the field's value cannot be changed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">default</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The field's default value may be<code class="literal"> None</code>, or a valid field value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">missing_value</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If input for this field is missing, and that's OK, then this is the value to use.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">order</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The<code class="literal"> order</code> attribute can be used to determine the order in which fields in a schema are defined. If one field is created after another (in the same thread), its order will be greater.</p>
</td></tr></tbody></table></div><p>In addition to the field attributes described in the preceding table, some field types provide additional attributes. In the previous example, we saw that there are various field types, such as<code class="literal"> Text, TextLine</code>, and<code class="literal"> Choice</code>. There are several other field types available, as shown in the following table. We can create very sophisticated forms just by defining a schema in this way, and letting Grok generate them.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Field type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th><th style="text-align: left" valign="bottom">
<p>Parameters</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Bool</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Boolean field.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Bytes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a byte string (such as the python<code class="literal"> str)</code>. The value might be constrained to be within length limits.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ASCII</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a 7-bit ASCII string. No characters &gt; DEL (chr(127)) are allowed. The value might be constrained to be within length limits.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">BytesLine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a byte string without new lines.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ASCIILine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a 7-bit ASCII string without new lines.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Text</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a Unicode string.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">SourceText</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field for the source text of an object.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TextLine</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a Unicode string without new lines.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Password</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a Unicode string without new lines, which is set as the password.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing an Integer value.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Float</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a Float.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Decimal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a Decimal.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">DateTime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a DateTime.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Date</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a date.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Timedelta</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a timedelta.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Time</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing time.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">URI</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A field containing an absolute URI.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Id</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A field containing a unique identifier. A unique identifier is either an absolute URI or a dotted name. If it's a dotted name, it should have a module or package name as a prefix.</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="bottom">
<p>Field type</p>
</td><td style="text-align: left" valign="bottom">
<p>Description</p>
</td><td style="text-align: left" valign="bottom">
<p>Parameters</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Choice</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field whose value is contained in a predefined set.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">values:</code> A list of text choices for the field.</p>
<p>
<code class="literal">vocabulary:</code> A Vocabulary object that will dynamically produce the choices.</p>
<p>
<code class="literal">source:</code> A different, newer way to produce dynamic choices.</p>
<p>Note: only one of the three should be provided. More information about sources and vocabularies is provided later in this book.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Tuple</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a value that implements the API of a conventional Python tuple.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">value_type:</code> Field value items must conform to the given type, expressed via a field.</p>
<p>
<code class="literal">Unique</code>. Specifies whether the members of the collection must be unique.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">List</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a value that implements the API of a conventional Python list.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">value_type:</code> Field value items must conform to the given type, expressed via a field.</p>
<p>
<code class="literal">Unique</code>. Specifies whether the members of the collection must be unique.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Set</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a value that implements the API of a conventional Python standard library<code class="literal"> sets.Set</code> or a Python 2.4+ set.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">value_type:</code> Field value items must conform to the given type, expressed via a field.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">FrozenSet</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a value that implements the API of a conventional Python 2.4+ frozenset.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">value_type:</code> Field value items must conform to the given type, expressed via a field.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Object</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing an object value.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Schema:</code> The interface that defines the fields comprising the object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Dict</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Field containing a conventional dictionary. The<code class="literal"> key_type</code> and<code class="literal"> value_type</code> fields allow specification of restrictions for keys and values contained in the dictionary.</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">key_type:</code> Field keys must conform to the given type, expressed via a field.</p>
<p>
<code class="literal">value_type:</code> Field value items must conform to the given type, expressed via a field.</p>
</td></tr></tbody></table></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Form fields and widgets</h1></div></div></div><p>Schema fields are perfect for defining data structures, but when dealing with forms sometimes they are not enough. In fact, once you generate a form using a schema as a base, Grok turns the schema fields into form fields. A<strong> form field</strong> is like a schema field but has an extended set of methods and attributes. It also has a default associated widget that is responsible for the appearance of the field inside the form.<a id="id146" class="indexterm"/>
</p><p>Rendering forms requires more than the fields and their types. A form field needs to have a user interface, and that is what a widget provides. A<code class="literal"> Choice</code> field, for example, could be rendered as a<code class="literal">&lt;select&gt;</code> box on the form, but it could also use a collection of checkboxes, or perhaps radio buttons. Sometimes, a field may not need to be displayed on a form, or a writable field may need to be displayed as text instead of allowing users to set the field's value.<a id="id147" class="indexterm"/>
</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec05"/>Form components</h1></div></div></div><p>Grok offers four different components that automatically generate forms. We have already worked with the first one of these,<code class="literal"> grok.Form</code>. The other three are specializations of this one:<a id="id148" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">grok.AddForm</code> is used to add new model instances.<a id="id149" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">grok.EditForm</code> is used for editing an already existing instance.<a id="id150" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">grok.DisplayForm</code> simply displays the values of the fields.</li></ul></div><p>A Grok form is itself a specialization of a<code class="literal"> grok.View</code>, which means that it gets the same methods as those that are available to a view. It also means that a model does not actually need a view assignment if it already has a form. In fact, simple applications can get away by using a form as a view for their objects. Of course, there are times when a more complex view template is needed, or even when fields from multiple forms need to be shown in the same view. Grok can handle these cases as well, which we will see later on.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec04"/>Adding a project container at the root of the site</h2></div></div></div><p>To get to know Grok's form components, let's properly integrate our project model into our to-do list application. We'll have to restructure the code a little bit, as currently the to-do list container is the root object of the application. We need to have a project container as the root object, and then add a to-do list container to it.<a id="id151" class="indexterm"/>
</p><p>Luckily, we already structured the code properly in the last chapter, so we won't need to make many changes now. To begin, let's modify the top of<code class="literal"> app.py</code>, immediately before the<code class="literal"> TodoList</code> class definition, to look like this:<a id="id152" class="indexterm"/>
</p><div><pre class="programlisting">import grok
from zope import interface, schema
class Todo(grok.Application, grok.Container):
def __init__(self):
super(Todo, self).__init__()
self.title = 'To-Do list manager'
self.next_id = 0
def deleteProject(self,project):
del self[project]
</pre></div><p>First, we import<code class="literal"> zope.interface</code> and<code class="literal"> zope.schema</code>. Notice how we keep the<code class="literal"> Todo</code> class as the root application class, but now it can contain projects instead of lists. We also omitted the<code class="literal"> addProject</code> method, because the<code class="literal"> grok.AddForm</code> instance is going to take care of that. Other than that, the<code class="literal"> Todo</code> class is almost the same.<a id="id153" class="indexterm"/>
</p><div><pre class="programlisting">class IProject(interface.Interface):
title = schema.TextLine(title=u'Title',required=True)
kind = schema.Choice(title=u'Kind of project',values=['personal', 'business'])
description = schema.Text(title=u'Description',required=False)
next_id = schema.Int(title=u'Next id',default=0)
</pre></div><p>We then have the interface definition for<code class="literal"> IProject</code>, where we add the<code class="literal"> title, kind, description</code>, and<code class="literal"> next_id</code> fields. These were the fields that we previously added during the call to the<code class="literal"> __init__</code> method at the time of product initialization.<a id="id154" class="indexterm"/>
</p><div><pre class="programlisting">class Project(grok.Container):
grok.implements(IProject)
def addList(self,title,description):
id = str(self.next_id)
self.next_id = self.next_id+1
self[id] = TodoList(title,description)
def deleteList(self,list):
del self[list]
</pre></div><p>The key thing to notice in the<code class="literal"> Project</code> class definition is that we use the<code class="literal"> grok.implements</code> class declaration to see that this class will implement the schema that we have just defined.</p><div><pre class="programlisting">class AddProjectForm(grok.AddForm):
grok.context(Todo)
grok.name('index')
form_fields = grok.AutoFields(Project)
label = "To begin, add a new project"
@grok.action('Add project')
def add(self,**data):
project = Project()
self.applyData(project,**data)
id = str(self.context.next_id)
self.context.next_id = self.context.next_id+1
self.context[id] = project
return self.redirect(self.url(self.context[id]))
</pre></div><p>The actual form view is defined after that, by using<code class="literal"> grok.AddForm</code> as a base class. We assign this view to the main<code class="literal"> Todo</code> container by using the<code class="literal"> grok.context</code> annotation. The name<code class="literal"> index</code> is used for now, so that the default page for the application will be the 'add form' itself.</p><p>Next, we create the form fields by calling the<code class="literal"> grok.AutoFields</code> method. Notice that this time the argument to this method call is the<code class="literal"> Project</code> class directly, rather than the interface. This is possible because the<code class="literal"> Project</code> class was associated with the correct interface when we previously used<code class="literal"> grok.implements</code>.<a id="id155" class="indexterm"/>
</p><p>After we have assigned the fields, we set the<code class="literal"> label</code> attribute of the form to the text:<strong> To begin, add a new project</strong>. This is the title that will be shown on the form.</p><p>In addition to this new code, all occurrences of<code class="literal"> grok.context(Todo)</code> in the rest of the file need to be changed to<code class="literal"> grok.context(Project)</code>, as the to-do lists and their views will now belong to a project and not to the main<code class="literal"> Todo</code> application. For details, take a look at the source code of this book for Chapter 5.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec05"/>Form actions</h2></div></div></div><p>If you carefully look at the screenshot shown in the<em> A quick demonstration of automatic forms</em> section, you will see that the form has no submit buttons. In Grok, every form can have one or more actions, and for each action the form will have a submit button. The Grok<code class="literal"> action</code> decorator is used to mark the methods of the form class that will be used as actions. In this case, the<code class="literal"> add</code> method is decorated with it and the value of the text parameter, in this case<code class="literal"> Add project</code>, will be used as the text on the button. To change the text on the button, simply modify the string passed to the decorator:<a id="id156" class="indexterm"/>
</p><div><pre class="programlisting">@grok.action('Add project')
def add(self,**data):
project = Project()
self.applyData(project,**data)
id = str(self.context.next_id)
self.context.next_id = self.context.next_id+1
self.context[id] = project
return self.redirect(self.url(self.context[id]))
</pre></div><p>The<code class="literal"> add</code> method receives all of the filled form fields in the<code class="literal"> data</code> parameter, and then creates a<code class="literal"> Project</code> instance. Next, it sets the attributes of<code class="literal"> project</code> to the values in the form by calling the<code class="literal"> applyData</code> method of the form. Finally, it adds the new project to the<code class="literal"> Todo</code> instance and redirects the user to the project page.<a id="id157" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec06"/>Trying out the application</h2></div></div></div><p>When you try out the application, there are two things to notice. First, when the add project form is displayed, the<code class="literal"> next_id</code> field, which is used to name the projects, is shown. We could even edit it if we like. Obviously, we don't want this behavior.</p><p>Second, once the project has been created and we get redirected to the project page, everything works as before, even though we didn't touch the templates. With the approach that we tried in Chapter 3, using hidden values and list indexes, we would have had to modify the<code class="literal"> index.pt</code> template in lots of places. Now that we have a structure based on models, the views and methods that were registered for them don't need to change, even though the containment hierarchy is different.</p><p>Another important thing to notice is that the add project form has no design or styling at all. This is because the form building mechanism uses a common template, which we haven't styled yet.</p><div><img src="img/7481_05_02.jpg" alt="Trying out the application"/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Filtering fields</h1></div></div></div><p>Remember that currently we have the<code class="literal"> next_id</code> field of the project shown on the form. We don't want it there, so how do we remove it? Fortunately for us, the list of fields generated by the<code class="literal"> grok.AutoFields</code> method can easily be filtered.<a id="id158" class="indexterm"/>
</p><p>We can either select precisely the fields we need, using the<code class="literal"> select</code> method:</p><div><pre class="programlisting">form_fields = grok.AutoFields(Project).select('title','kind', 'description')
</pre></div><p>Or we can omit specific fields by using the<code class="literal"> omit</code> method:</p><div><pre class="programlisting">form_fields = grok.AutoFields(Project).omit('next_id')
</pre></div><p>In both cases, we pass the IDs of the fields as strings to the selected method. Now the<code class="literal"> next_id</code> field is not there anymore, as you can see in the next screenshot.</p><p>Filtering fields can be useful not just for removing unwanted fields such as<code class="literal"> next_id</code>. We can also have specialized forms for editing only a part of a schema, or for showing specific fields, depending on user information or input.<a id="id159" class="indexterm"/>
</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec07"/>Using grok.EditForm</h1></div></div></div><p>The form that we just made is intended to add a new project to the application, but what if we need to edit an existing project? In this case, we need a form that knows how to get the existing values of all of the fields on the form, and display them when editing. Another difference is that the add project form was assigned to the main Todo application, but an edit form would use as a context the actual project that it would be modifying.<a id="id160" class="indexterm"/>
</p><p>That's why Grok has another kind of form component for editing. Using<code class="literal"> grok.EditForm</code> is even easier than<code class="literal"> grok.AddForm</code>. Here's all the code that we need to add to our application in order to be able to edit projects:</p><div><pre class="programlisting">class EditProjectForm(grok.EditForm):
grok.context(Project)
grok.name('edit')
form_fields = grok.AutoFields(Project).omit('next_id')
label = "Edit the project"
</pre></div><p>As mentioned earlier, the context for this form is the<code class="literal"> Project</code> class, which we set by using the<code class="literal"> grok.context</code> class annotation. We give this form the name<code class="literal"> edit</code>, so that it will be possible to just append that word to a project URL to get its edit view. As we discussed in the previous section, it is a good idea to eliminate the display of the<code class="literal"> next_id</code> field from the form, so we use the<code class="literal"> omit</code> method to do that. Finally, we set a label for the form and we are then ready to test it.</p><p>Start the application. If you haven't created a project already, please do so.Then, go to the URL: <a class="ulink" href="http://localhost:8080/todo/0/edit">http://localhost:8080/todo/0/edit</a>. Edit the project fields and then click on the<strong> Apply</strong> button. You should see a screen similar to the one shown in following screenshot:</p><div><img src="img/7481_05_03.jpg" alt="Using grok.EditForm"/></div><p>Notice how we didn't include a redirect after rendering the form, so that when we click on the<strong> Apply</strong> button we go back to the same form, but with a message telling us that the object was updated along with the date of modification. If we wanted, we could add an 'edit' action, by using the<code class="literal"> action</code> decorator and a redirect, just like we did for the add form.<a id="id161" class="indexterm"/>
</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Modifying individual form fields</h1></div></div></div><p>Having the add and edit forms created automatically by Grok is neat, but there are cases where we will need to make small modifications in how a form is rendered. Grok allows us to modify specific field attributes easily to make that happen.<a id="id162" class="indexterm"/>
</p><p>Remember that each form field will be rendered by a widget, which could be thought of as views for specific fields. These views usually accept a number of parameters to allow the user to customize the appearance of the form in one way or another.</p><p>Just before being rendered, Grok's form components always call a method named<code class="literal"> setUpWidgets</code>, which we can override in order to make modifications to the fields and their attributes.</p><p>In the add and edit project forms, the title of the project, which is of type<code class="literal"> TextLine</code>, has a widget that displays the<code class="literal">&lt;input&gt;</code> tag used to capture its value with a length of 20 characters. Many project names could be longer than that, so we want to extend the length to 50 characters. Also, the text area for the description is too long for a project summary, so we'll cut it to five rows instead. Let's use the<code class="literal"> setUpWidgets</code> method for this. Add the following lines to both the<code class="literal"> AddProjectForm</code> and<code class="literal"> EditProjectForm</code> classes:<a id="id163" class="indexterm"/>
</p><div><pre class="programlisting">def setUpWidgets(self, ignore_request=False):
super(EditProjectForm,self).setUpWidgets(ignore_request)
self.widgets['title'].displayWidth = 50
self.widgets['description'].height = 5
</pre></div><p>Take care to substitute<code class="literal"> EditProjectForm</code> for<code class="literal"> AddProjectForm</code> on the super call when adding the method to its appropriate class. The<code class="literal"> setUpWidgets</code> method is fairly simple. We first call the super class to make sure that we get the correct properties in the form before trying to modify them. Next, we modify any properties that we want for the field. In this case, we access the<code class="literal"> widgets</code> property to get at the widgets for the fields that we defined, and change the values that we want.<a id="id164" class="indexterm"/>
</p><p>Another thing that requires explanation is the<code class="literal"> ignore_request</code> parameter that is passed to the<code class="literal"> setUpWidgets</code> method. If this is set to<code class="literal"> False</code>, as we have defined it, then this means that any field values present in the<code class="literal"> HTTP</code> request will be applied to the corresponding fields. A value of<code class="literal"> True</code> means that no values should be changed during this call.</p><p>Restart the application and you will see that the edit and add forms now present the widgets using the properties that we modified.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Form validation</h1></div></div></div><p>Now we have working forms for adding and editing projects. In fact, the forms can do more than we have shown so far. For example, if we go to the add form and try to submit it without filling in the required<code class="literal"> title</code> field, we'll get the form back, instead of being redirected. No project will be created, and an error message will be visible on the screen, warning us that the field can't be empty.<a id="id165" class="indexterm"/>
</p><p>This validation happens automatically, but we can also add our own constraints by using the<code class="literal"> constraint</code> parameter, when defining a field in the schema. For example, suppose that we absolutely need to have more than two words in the title. We can do that very easily. Just add the following lines before the interface definition:</p><div><pre class="programlisting">def check_title(value):
return len(value.split())&gt;2
</pre></div><p>Next, modify the title field definition to look like this:</p><div><pre class="programlisting">title = schema.TextLine(title=u'Title', required=True, constraint=check_title)
</pre></div><p>We first defined a function that will receive the field value as a parameter, and must return<code class="literal"> True</code> if the value is valid, or<code class="literal"> False</code> otherwise. We then assign this function to the<code class="literal"> constraint</code> parameter, when defining the field in the interface. This is all very simple, but it allows us to add validations for whatever conditions we need to meet in our form data.</p><p>There are cases where a simple constraint is not enough to validate a field. For instance, imagine that what we need is that whenever the kind of the project is 'business', the description can't be empty. In this case, a constraint will not do, as whether or not the description field is valid depends on the value of another field.<a id="id166" class="indexterm"/>
</p><p>A constraint that involves more than one field is known as an<strong> invariant</strong> in Grok. To define one, the<code class="literal"> @interface.invariant</code> decorator is used. For the hypothetical case described earlier, we can use the following definition, which we'll add inside the<code class="literal"> Interface</code> definition:<a id="id167" class="indexterm"/>
</p><div><pre class="programlisting">@interface.invariant
def businessNeedsDescription(project):
if project.kind=='business' and not project.description:
raise interface.Invalid( "Business projects require a description")
</pre></div><p>Now, when we try to add a project of kind 'business', Grok will complain if the description is empty. Look at the next screenshot for reference:</p><div><img src="img/7481_05_04.jpg" alt="Form validation"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec10"/>Customizing the form template</h1></div></div></div><p>Earlier, we commented on the fact that our new project forms have no styling or design applied, and therefore they look markedly different from the rest of our application. It's time to change that.<a id="id168" class="indexterm"/>
</p><p>The disadvantage of using automatic form generation is that the default template must be fairly generic to be useful in multiple applications. However, Grok allows us to set a custom template for editing the form. All we need to do is set the<code class="literal"> template</code> attribute in the form:</p><div><pre class="programlisting">template = grok.PageTemplateFile('custom_edit_form.pt')
</pre></div><p>Of course, for this to work we also have to provide the named template inside our application directory (not inside<code class="literal"> app_templates)</code>. For now, let's just add a stylesheet and a class to the generic edit template that comes with Grok. There is nothing special here, so we will just take the default edit form template and add the same stylesheet that we defined previously. Please look at the source code of this book, if you want to see the rest of the template.</p><div><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
&lt;title tal:content="context/title"&gt;To-Do list manager&lt;/title&gt;
&lt;link rel="stylesheet" type="text/css" tal:attributes="href static/styles.css" /&gt;
&lt;/head&gt;
</pre></div><p>That's all that's needed in order to have our custom template for editing the form. Take a look at the next screenshot to see how it looks. Of course, we would have to further modify it to get it to look just like we want. We could even leave only the fields that we wanted, placed in an irregular arrangement, but the reason that we used the original template and modified it just a little is so that you can look at it and be careful with the sections where the validation messages are shown and the actions are generated. We'll have more to say about this in future chapters.<a id="id169" class="indexterm"/>
</p><div><img src="img/7481_05_05.jpg" alt="Customizing the form template"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec11"/>Summary</h1></div></div></div><p>We have seen how to automatically generate forms by using schemas, and how it's possible to customize their rendering. In addition, we learned a little bit about some Zope Framework libraries, such as<code class="literal"> zope.schema</code> and<code class="literal"> zope.interface</code>.</p></div></div>
</body></html>