- en: Chapter 2. Drawing Fundamental Shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: A straight line and the coordinate system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a dashed line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lines of varying styles with arrows and endcaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A two-segment line with a sharp bend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line with a curved bend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing intricate stored shapes - the curly vine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing a rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing overlapping rectangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing concentric squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A circle from an oval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A circle from an arc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three ellipses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A star polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The art of cloning stars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphics are all about pictures and drawings. In computer programs, a line is
    not drawn by a hand, holding a pencil, but by the manipulation of numbers on a
    screen. This chapter provides the fine-grained detail or atomic structure for
    the rest of the book. Here we lay down the most basic graphic building blocks
    in their simplest form. The most useful options are presented inside self-contained
    programs. You can if you want, use the code without understanding in detail how
    it works. You can learn by doing. You can learn by playing and play is the serious
    work that unskilled animals do in order to learn almost everything they need for
    survival.
  prefs: []
  type: TYPE_NORMAL
- en: You can cut and paste the code and it should just work without modification.
    The code is easily modified and you are encouraged to tinker with it and tweak
    the parameters inside the drawing methods. The more you tinker with it, the more
    you will understand.
  prefs: []
  type: TYPE_NORMAL
- en: The area of screen where lines and shapes are drawn is the canvas in Python.
    It is created when the Tkinter method `canvas()` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Central to using numbers to describe lines and shapes is a coordinate system
    that says where a line or shape starts and where it ends. In Tkinter, as in most
    computer graphic systems, the top-left is the start of the screen or canvas and
    bottom-right is the end where the largest numbers describe location. This system
    is shown in the next figure, which is the universal computer screen coordinate
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/3845OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A straight line and the coordinate system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw a straight line on a canvas. It is important to understand that the start
    of the coordinate system is always at the top left-hand corner of the canvas as
    shown in the previous figure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a text editor type the lines below that appear between the two `#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`
    divider/separators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this as a file named `line_1.py`, inside the directory called `constr`
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, open up an X terminal or DOS window if you are using MS Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change directory (command `cd /constr)` into the directory `constr` - where
    `line_1.py` is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `python line_1.py` and your program will execute. The result should look
    like the following screenshot:![How to do it...](img/3845_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have written the coordinates for our line differently from the way we did
    in the previous chapter because we want to introduce symbolic assignments into
    the `create_line()` method. This is a preliminary step to making our code re-usable.
    There is more than one way to specify the points that define the location of line.
    The neatest way is to define a Python list or tuple by name and then just insert
    this name of the list as the argument of the `create_line()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to draw two lines, one from (x=50, y=25) to (x= 220,
    y=44) and the second line between(x=11, y=22) and (x=44, y=33) then we could write
    the following lines in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`line_1 = 50, 25, 220, 44 #` this is a tuple and can NEVER change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line_2 = [11, 22, 44, 33] #` this is a list and can be changed anytime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canvas_1.create_line(line_1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canvas_1.create_line(line_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that although `line_1 = 50, 25, 220, 44` is syntactically correct Python,
    it is considered to be poor Python grammar. It is better to write `line_1 = (
    50, 25, 220, 44)` because this is more explicit and therefore clearer to someone
    reading the code. Another point to note is that `canvas_1` is an arbitrary name
    I have given to the particular instance of a canvas of a certain size. You can
    give it any name you like.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most shapes can be made up of pieces of lines joined together in a multitude
    of ways. An extremely useful attribute that Tkinter offers is the ability to transform
    sequences of straight lines into smooth curves. This attribute of lines can be
    used in surprising ways and is illustrated in recipe 6.
  prefs: []
  type: TYPE_NORMAL
- en: Draw a dashed line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A straight dashed line, three pixels thick is drawn.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in the previous example are used. The only change is in
    the name of the Python program. This time you should use the name `dashed_line.py`
    instead of `line_1.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new things here are the addition of some style specifications for the line.
  prefs: []
  type: TYPE_NORMAL
- en: '`dash=( 3,5)` says that there should be three solid pixels followed by five
    blank pixels and `width = 3` specifies that the line should be 3 pixels thick.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can specify a limitless variety of dash-space patterns. A dash-space pattern
    specified as `dash = (5, 3, 24, 2, 3, 11)` would result in a line with three patterns
    repeated over and over throughout the length of the line. The pattern would consist
    of five solid pixels followed by three blank pixels. Then there would be 24 solid
    pixels followed by only two blank pixels. The third variation would be three solid
    followed by 11 blank pixels and then the whole set of three patterns would begin
    again. The list of dash-blank pairs can go on as long as you like. The even-numbered
    length specifications will specify the length of solid pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dash attribute is quirky on different operating systems. For instance on
    a Linux operating system it behaves as it should by obeying the directives for
    line and space distances but on MS Windows there is no respect for solid-dash
    directives if they exceed ten pixels in size
  prefs: []
  type: TYPE_NORMAL
- en: Lines of varying styles with arrows and endcaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Four lines are drawn in different styles. We see how attributes like color and
    end shape can be obtained. A Python `for loop` is used to make an interesting
    pattern using the specifications of the dash attribute. In addition the color
    of the canvas background has been made green.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used again.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `4lines.py` when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: Arrows and endcaps have been introduced into the line specifications.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw a line you only need to give the start point and the end point.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the result of execution on Ubuntu Linux
  prefs: []
  type: TYPE_NORMAL
- en: In this example we have saved a bit of work by re-using previous line position
    specifications. See the next two screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the result of execution on MS Windows XP.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is where you may see the difference between Linux's and MS Windows's ability
    to draw dashed lines using Tkinter. The solid portion of the dash was specified
    as 19 pixels long. On the Linux (Ubuntu9.10) platform this specification was respected
    but Windows disregarded the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: A two segment line with a sharp bend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lines do not have to be straight. A more general type of line can be made up
    of many straight segments joined together. You simply decide where you want the
    points that join sections of the multi-segment line and the order in which they
    should be joined.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions are the same as for recipe 1\. Just use the name `sharp_bend.py`
    when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: Just make a list of the `x,y` pairs defining each point and place them in the
    sequence that you want them connected in. The list can be as long as you like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For clarity only three points have been defined: first =(x1,y1), second =(x2,y2)
    and third = (x3, y3). However, there is no limit to the number of sequential points
    that could be specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the line with a sharp bend.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ultimately you could have complicated figures stored as long sequences of points
    in files on some storage device. For example, you might want to produce something
    like a cartoon strip.
  prefs: []
  type: TYPE_NORMAL
- en: You could construct a library of body parts and face features seen from different
    angles. There could be a selection of different mouth and eye shapes. The daily
    chore of assembling your comic strip could be partially automated. One of the
    things you would need to think about would be how to scale the component parts
    to be larger or smaller and also how to position them in different places and
    even rotate them to different angles. All these ideas are developed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In particular see the next examples of how complex shapes can be stored and
    manipulated in a relatively compact form. The **SVG** (**Scaled Vector Graphics**)
    standard for drawing manipulation, particularly on web pages, uses a similar but
    different convention for representing shapes. Because both SVG and Tkinter are
    well defined it means that you can construct code for converting from one form
    to the other.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of this are shown in [Chapter 6](ch06.html "Chapter 6. Working with
    Pictures"),
  prefs: []
  type: TYPE_NORMAL
- en: A line with a curved bend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most interesting lines are curved. Change the straight, two-segment line
    of the previous example into a smooth curve that fits parallel to the ends of
    each segment. Tkinter makes the curve out of 12 straight segments. 12 segments
    is the default number. However, you can change it to any other sensible number.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Substitute the line `canvas_1.create_line(x1,y1, x2,y2, x3,y3)` with the line
    `canvas_1.create_line(x1,y1, x2,y2, x3,y3, smooth="true")`.
  prefs: []
  type: TYPE_NORMAL
- en: The line is now curved. This is immensely useful when making drawings we only
    need to specify a minimal number of points and Tkinter fits a curved shape to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program output for `smooth="true"` attribute is shown in the next screenshot.
    The `smooth='true'` attribute hides a large amount of serious mathematical curve
    manufacture taking place under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: To fit a curve to a pair of intersecting lines requires the curve and the lines
    to run parallel at the beginning and end but in the middle an entirely different
    process known as **spline fitting** is used. The consequence of this is that this
    kind of curvaceous smoothing is computationally expensive and if you do too much
    of it your program execution slows down. This has implications for what kinds
    of action can be successfully animated.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we do later is to use the curve attribute to make more pleasing and exciting
    shapes. Ultimately you could accumulate for yourself a library of shapes. If you
    did this you would be re-creating some vector graphics that are freely available
    from the web. Look at [www.openclipart.org](http://www.openclipart.org). The pictures
    which are freely downloadable from this site are in SVG (Scaled Vector Graphics)
    format. If you look at the code of these pictures in a text editor you will see
    lines of code that are vaguely similar to the way these Tkinter programs specify
    the points. Some techniques for extracting useful shapes from existing SVG pictures
    will be demonstrated in [Chapter 6](ch06.html "Chapter 6. Working with Pictures"),
  prefs: []
  type: TYPE_NORMAL
- en: Drawing intricate shapes the curly vine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The task here is to draw a complicated shape in such a way that you can use
    it as a framework to produce unlimited variety and beauty.
  prefs: []
  type: TYPE_NORMAL
- en: We start out with a pencil and paper and draw a curly growing vine shape and
    transfer it in the simplest and most direct way into some code that will draw
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very important example because it reveals the essential elegance
    of both Python and Tkinter. The central inspiring design philosophy of Python
    is captured in two words: simplicity and clarity. This is what makes Python one
    of the best computer coding languages ever conceived.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When they want to create a fresh design, most graphic artists start with a pencil
    and paper sketch because of the uncluttered subconscious freedom it gives. For
    this example, a complex curve was needed the kind of organic design used in framing
    pictures in antique books.
  prefs: []
  type: TYPE_NORMAL
- en: The smooth line was drawn with a pencil on paper and marked off at roughly,
    evenly spaced intervals with X's. Using a millimeter marked ruler the distance
    from each x to the left edge and the bottom of the paper was measured approximately.
    High accuracy is not needed because the curved nature of the line compensates
    for small imperfections.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These measurements, 32 each in the x and y directions for a Tkinter canvas were
    typed into separate lists. One called `x_vine` for the x coordinates and `y_vine`
    for the y coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Besides this hand-crafted way of creating the raw shape, the rest of the procedure
    is identical for all the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The result is shown in the next screenshot which is a smoothed line of 32 straight
    segments.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The essential trick in this task is to create a list of numbers that is in precisely
    the correct form to place into a `create_line()` method. It has to be an unbroken
    sequence, comma-separated, of pairs of matched x and y position coordinates of
    the complex curve we want to draw.
  prefs: []
  type: TYPE_NORMAL
- en: So first we create an empty list `Q[]` to which we are going to append alternate
    values of the x and y coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to leave the original lists `x_vine` and `y_vine` intact (for
    re-use elsewhere perhaps) we create working copies using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally the magic interleaved merging into one list with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `for in range()` combination and the block of code following it work cyclically
    through the code starting at `i=0`, increasing one by one each until the last
    value `len(X)` is reached. Then the block of code is exited and execution continues
    below the block. `Len(X)` is a function that gives back ('returns' in programmers'
    parlance) the number of elements in `X. Q` emerges from this perfect for immediate
    drawing in `create_line(Q)`.
  prefs: []
  type: TYPE_NORMAL
- en: If you leave out the `smooth='true'` attribute you will see the original join
    points that came from the original paper draw and measure process.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some interesting effects like curling smoke, charcoal, and glowing neon are
    produced by copying and transforming the curly vine in various ways in [Chapter
    6](ch06.html "Chapter 6. Working with Pictures"),
  prefs: []
  type: TYPE_NORMAL
- en: Draw a rectangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw a basic rectangle by specifying its position, shape, and color attributes
    as named variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `rectangle.py` when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot showing a basic rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When drawing rectangles, circles, ellipses and arcs you specify the start point
    (the bottom-left corner) and then the end point (top-right corner) of the bounding
    box surrounding the figure being drawn. In the case of rectangles and squares,
    the bounding box coincides with the figure. But in the case of circles, ellipses,
    and arcs the bounding box is of course larger.
  prefs: []
  type: TYPE_NORMAL
- en: With this recipe we have tried a new way of defining the shape of the rectangle.
    We give the start point as `[x_start, y_start]` and then we just state the width
    and height that we want as `[x_width, y_height]`. This way the end point is `[x_start
    + x_width, y_start + y_height]`. This way you only need to state what the new
    start point is if you want to create a multiplicity of rectangles having the same
    height and width.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next example, we use a common shape to draw a series of similar but different
    rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Draw overlapping rectangles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw three overlapping rectangles by changing the numerical values defining
    their position, shape, and color variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before the instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `3rectangles.py` when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, which shows overlapping rectangles
    drawn in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The height and width of the rectangles have been kept the same but their start
    positions have been shifted to different positions. In addition a common-named
    variable called `kula` has been used as a common attribute in each `create-rectangle()`
    method. In between drawing each rectangle a new value is assigned to `kula` to
    give each successive rectangle a different color.
  prefs: []
  type: TYPE_NORMAL
- en: Just a short comment on color here. Ultimately colors used in Tkinter code are
    number values with each numerical value specifying how much red, green, and blue
    to mix together. However, inside the Tkinter libraries are collections of romantically
    named colors like 'rose pink', 'lime green', and 'cornflower blue'. Each named
    color is assigned a specific numerical value that creates the color suggested
    by the name. Sometimes you will see some of these referred to as web colors. Sometimes
    you assign a name to a color only to have the Python interpreter reject it as
    unrecognized or use only shades of grey. This tricky topic is sorted out in [Chapter
    5](ch05.html "Chapter 5. The Magic of Color"),
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way the attributes of drawn shapes have been specified may appear to be
    long winded. The programs would be shorter and neater if we just put the absolute
    numerical values of the parameters inside the methods that draw the functions.
    In the preceding example, we could have expressed the rectangles as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are good reasons for specifying attribute values outside of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to make reusable code that can be used repeatedly regardless of
    specific values of variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the code self-explanatory when you use `x_start` instead of a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It lets you change the values of attributes in a controlled systematic manner.
    There are many examples of this later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw concentric squares
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw three concentric squares by changing the numerical values defining its
    position, shape, and color variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `3concentric_squares.py` when you write, save, and execute
    this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_9A.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this recipe, we have specified where we want the geometric center of the
    rectangles located. This is at the position `[x_center, y_center]` in each instance.
    You need to do this whenever you want to draw shapes that are concentric. Generally
    it is always awkward to try and position the center of some drawn figure by manipulating
    the bottom-right corner. It does of course mean that there is a small amount of
    arithmetic in calculating where the bottom-left and top-right corners of the bounding
    box are but this is a small price to pay for the artistic freedom you gain. You
    only have to use this technique once and it is at your beck and call forever.
  prefs: []
  type: TYPE_NORMAL
- en: A circle from an oval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to draw a circle is to use the Tkinter's `create_oval()` method
    from the canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in the first recipe should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `circle_1.py` when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, showing a basic circle.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A circle is just an ellipse whose height and width are equal. In the example
    here, we have created a circle with the a very compact-looking statement: `canvas_1.create_oval(xy)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The compactness comes from the trick of specifying the dimension attributes
    as a Python tuple `xy = 20, 20, 420, 420` . It actually would be better in other
    instances to use a list such as `xy = [ 20, 20, 420, 420 ]` because a list allows
    you to alter the value of the individual member variables, whereas a tuple is
    an unchangeable sequence of constant values. Tuples are referred to as immutable.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing a circle as a special case of an oval is definitely the best way to
    draw circles. An inexperienced user of Tkinter may be tempted into using an arc
    to do the job. This is a mistake because as shown in the next recipe the behavior
    of the `create_arc()` method does not allow an unblemished circle to be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: A circle from an arc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to make a circle is to use the `create_arc()` method. This method
    may appear to be a more natural way to make circles but it does not allow you
    to quite complete the circle. If you do try to the circle disappears.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in the first example should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `arc_circle.py` when you write, save and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, showing a failed circle resulting
    from `create_arc()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generally the `create_arc()` method is not the best method of making complete
    circles because an attempt to go from 0 to 360 degrees results in the disappearance
    of the circle from view. Rather use the `create_oval()` method. However, there
    are occasions when you need the properties of the `create_arc()` method to be
    able to create a particular distribution of color. See the color wheel in the
    later chapters for a good example of this.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `create_arc()` method is well suited to the production of the pie charts
    favored in corporate presentations. The `create_arc()` method draws a segment
    of a circle with the ends of the arc joined to the center by radial lines. But
    if we just want to draw a circle those radial lines are unwanted.
  prefs: []
  type: TYPE_NORMAL
- en: Three arc ellipses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three elliptic arcs are drawn.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `3arc_ellipses.py` when you write, save, and execute this
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, showing well-behaved `create_arc()`
    ellipses.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The point to note here is that just like rectangles and ovals; the overall shape
    of the drawn object is governed by the shape of the bounding box. Start and finish
    (that is extent) angles are expressed in conventional degrees. Note that if trigonometry
    functions are going to be used then the circular measure has to be radians and
    not degrees.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `create_arc()` method has been made user-friendly by requiring angular measurements
    in degrees rather than radians because most people can visualize degree amounts
    more easily than radians. But you need to know this is NOT the case with angular
    measurement in any function used by the math module. All the trigonometric functions
    like sine, cosine, and tangent use radian angular measurement which are only a
    minor convenience. The math module provides easy to use conversion functions.
  prefs: []
  type: TYPE_NORMAL
- en: Polygons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw a polygon. A polygon is a closed, multi-sided figure. These sides are made
    up of straight line segments. The specification of points is identical to that
    of multi-segment lines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `triangle_polygon.py` when you write, save, and execute this
    program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, showing a polygon triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `create_polygon()` method draws a sequence of straight line segments between
    the points specified as the arguments of the method. The final point is automatically
    joined to the first point to close the figure. As the figure is closed you can
    fill the interior with color.
  prefs: []
  type: TYPE_NORMAL
- en: A star polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw a five-pointed star using named variables to specify the polygon attributes
    so that all the points or vertexes or tips of the star are defined with reference
    to a single start position. We refer to this position as the anchor position.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `star_polygon.py` when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, a polygon star.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first position of the star is the point `[x_anchor, y_anchor]`. All the
    other points are positive or negative additions to the position of the anchor
    point. This concept was introduced in the recipes for the three superimposed rectangles.
    This idea of drawing complicated shapes with reference to a point defined as a
    pair of named variables is very useful and is used extensively in the second half
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: To improve code readability, the pairs of x and y variables defining each point
    are laid out vertically making use of the line continuation character \ (backslash).
  prefs: []
  type: TYPE_NORMAL
- en: Cloning and resizing stars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A technique of simultaneous re-positioning and resizing a set of stars is shown.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The instructions used in recipe 1 should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Just use the name `clone_stars.py` when you write, save, and execute this program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results are given in the next screenshot, showing a string of stars with
    changing size.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3845_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to the variable and conveniently re-assigned anchor point of the
    polygon star we have now introduced an amplification factor that can change the
    size of any particular star without distorting it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last three examples have illustrated some important and fundamental ideas
    used to draw pre-defined shapes in any size and in any position. It was important
    to separate these effects in different examples at this stage so that the separate
    actions are easy to understand. Later on, where the effects are used in combination,
    it becomes difficult to wrap your head around what is happening, particularly
    if extra transformations like rotation are involved. If we animate code that generates
    images it can be much easier to understand geometric relationships. By animate,
    I mean the display of successive images separated by short-time intervals similar
    to the way images in movies are manipulated. Such time-regulated animation, surprisingly,
    offers methods of examining the behavior of image-generating code in a way that
    is much more intuitive and clear to the human brain. This idea is developed in
    the later chapters.
  prefs: []
  type: TYPE_NORMAL
