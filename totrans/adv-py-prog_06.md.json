["```py\n        def sum_sq(a):\n            result = 0\n            N = len(a)\n            for i in range(N):\n                result += a[i]\n            return result\n    ```", "```py\n        from numba import nb\n        @nb.jit\n        def sum_sq(a):\n            ...\n    ```", "```py\n        import numpy as np\n        x = np.random.rand(10000)\n        # Original\n        %timeit sum_sq.py_func(x)\n        4.3 ms ± 81.6 µs per loop\n        # Numba\n        %timeit sum_sq(x)\n        12.8 µs ± 5.41 µs per loop\n    ```", "```py\n        %timeit (x**2).sum()\n        9.44 µs ± 93.7 ns per loop\n    ```", "```py\n        sum_sq.signatures\n        # Output:\n        # []\n    ```", "```py\n        x = np.random.rand(1000).astype('float64')\n        sum_sq(x)\n        sum_sq.signatures\n        # Result:\n        # [(array(float64, 1d, C),)]\n        x = np.random.rand(1000).astype('float32')\n        sum_sq(x)\n        sum_sq.signatures\n        # Result:\n        # [(array(float64, 1d, C),), (array(float32, 1d, \n            C),)]\n    ```", "```py\n        @nb.jit((nb.float64[:],))\n        def sum_sq(a):\n    ```", "```py\n        sum_sq(x.astype('float32'))\n        # TypeError: No matching definition for argument \n          type(s) \n        array(float32, 1d, C)\n    ```", "```py\n        @nb.jit(\"float64(float64[:])\")\n        def sum_sq(a):\n    ```", "```py\n        @nb.jit([\"float64(float64[:])\",\n                 \"float64(float32[:])\"])\n        def sum_sq(a):\n    ```", "```py\n        sum_sq.inspect_types()\n    ```", "```py\n        # --- LINE 4 --- \n        #  label  0\n        #   a = arg(0, name=a)  :: array(float64, 1d, A)\n        #   $2load_global.0 = global(len: <built-in  \\\n              function len>) :: Function (<built-in  \\\n                function len>)\n        #   N = call $2load_global.0(a, func= \\\n              $2load_global.0, args=[Var(a, \\\n                <ipython-in put-19-4687c4bff0ac>:4)], \\\n                  kws=(), vararg=None)  :: (array( \\\n                    float64, 1d, A),) -> int64\n        N = len(a)\n    ```", "```py\n        @nb.jit\n        def concatenate(strings):\n            result = ''\n            for s in strings:\n                result += s\n            return result\n    ```", "```py\n        concatenate(['hello', 'world'])\n        concatenate.signatures\n        # Output: concatenate (reflected \n          list(unicode_type)<iv=None>,)\n        concatenate.inspect_types()\n    ```", "```py\n\n        # --- LINE 3 --- \n        # label 0\n        #   strings = arg(0, name=strings)  :: reflected \\\n         list(unicode_type)<iv=None>\n        #   result = const(str, )  :: Literal[str]()\n        result = ''\n    ```", "```py\n    x = ['hello'] * 1000\n    %timeit concatenate.py_func(x)\n    81.9 µs ± 1.25 µs per loop\n    %timeit concatenate(x)\n    1.27 ms ± 23.3 µs per loop\n```", "```py\n        import numpy as np\n        def cantor(a, b):\n            return  int(0.5 * (a + b)*(a + b + 1) + b)\n    ```", "```py\n        @np.vectorize\n        def cantor(a, b):\n            return  int(0.5 * (a + b)*(a + b + 1) + b)\n        cantor(np.array([1, 2]), 2)\n        # Result:\n        # array([ 8, 12])\n    ```", "```py\n        # Pure Python\n        %timeit cantor_py(x1, x2)\n        2.4 ms ± 23.7 µs per loop\n        # Numba\n        %timeit cantor(x1, x2)\n        9.1 µs ± 204 ns per loop\n        # NumPy\n        %timeit (0.5 * (x1 + x2)*(x1 + x2 + 1) + \\\n          x2).astype(int)\n        33.2 µs ± 1.12 µs per loop\n    ```", "```py\n        a = np.random.rand(3, 3)\n        b = np.random.rand(3, 3)\n        c = np.matmul(a, b)\n        c.shape\n        # Result:\n        # (3, 3)\n    ```", "```py\n        a = np.random.rand(10, 3, 3)\n        b = np.random.rand(10, 3, 3)\n        c = np.matmul(a, b)\n        c.shape\n        # Output\n        # (10, 3, 3)\n    ```", "```py\n        a = np.random.rand(10, 3, 3)\n        b = np.random.rand(3, 3) # Broadcasted to shape  \n         (10, 3, 3)\n        c = np.matmul(a, b)\n        c.shape\n        # Result:\n        # (10, 3, 3)\n    ```", "```py\n        @nb.guvectorize(['float64[:], float64[:], \\\n          float64[:]'], '(n), (n) -> ()')\n        def euclidean(a, b, out):\n            N = a.shape[0]\n            out[0] = 0.0\n            for i in range(N):\n                out[0] += (a[i] - b[i])**2\n    ```", "```py\n        a = np.random.rand(2)\n        b = np.random.rand(2)\n        c = euclidean(a, b) # Shape: (1,)\n        a = np.random.rand(10, 2)\n        b = np.random.rand(10, 2)\n        c = euclidean(a, b) # Shape: (10,)\n        a = np.random.rand(10, 2)\n        b = np.random.rand(2)\n        c = euclidean(a, b) # Shape: (10,)\n    ```", "```py\n        a = np.random.rand(10000, 2)\n        b = np.random.rand(10000, 2)\n        %timeit ((a - b)**2).sum(axis=1)\n        153 µs ± 13.2 µs per loop\n        %timeit euclidean(a, b)\n        47.1 µs ± 3.19 µs per loop\n    ```", "```py\n        class Node:\n            def __init__(self, value):\n                self.next = None\n                self.value = value\n    ```", "```py\n    class LinkedList:\n\n        def __init__(self):\n            self.head = None\n\n        def push_front(self, value):\n            if self.head == None:\n                self.head = Node(value)\n            else:\n                # We replace the head\n                new_head = Node(value)\n                new_head.next = self.head\n                self.head = new_head\n```", "```py\n            def show(self):\n                node = self.head\n                while node is not None:\n                    print(node.value)\n                    node = node.next\n    ```", "```py\n        lst = LinkedList()\n        lst.push_front(1)\n        lst.push_front(2)\n        lst.push_front(3)\n        lst.show()\n        # Output:\n        # 3\n        # 2\n        # 1\n    ```", "```py\n        @nb.jit\n        def sum_list(lst):\n            result = 0\n            node = lst.head\n            while node is not None: \n                result += node.value\n                node = node.next\n            return result\n    ```", "```py\n        lst = LinkedList()\n        [lst.push_front(i) for i in range(10000)]\n\n        %timeit sum_list(lst)\n        1.73 ms ± 159 µs per loop\n        %timeit sum_list.py_func(lst)\n        1.01 ms ± 175 µs per loop\n    ```", "```py\n    node_type = nb.deferred_type()\n    node_spec = [\n        ('next', nb.optional(node_type)),\n        ('value', nb.int64)\n    ]\n    @nb.jitclass(node_spec)\n    class Node:\n        # Body of Node is unchanged\n    node_type.define(Node.class_type.instance_type)\n```", "```py\n        ll_spec = [\n            ('head', nb.optional(Node.class_type. \\\n              instance_type))\n        ]\n        @jitclass(ll_spec)\n        class LinkedList:\n            # Body of LinkedList is unchanged\n    ```", "```py\n        lst = LinkedList()\n        [lst.push_front(i) for i in range(10000)]\n        %timeit sum_list(lst)\n        106 µs ± 2.64 µs per loop\n        %timeit sum_list.py_func(lst)\n        2.42 ms ± 51.8 µs per loop\n    ```", "```py\n    a = [[0, 1, 2], \n         [3, 4], \n         [5, 6, 7, 8]]\n    @nb.jit\n    def sum_sublists(a):\n        result = []\n        for sublist in a:\n            result.append(sum(sublist))\n        return result\n    sum_sublists(a)\n    # NumbaWarning: Compilation is falling back to object \n      mode WITH looplifting enabled because Function \n        \"sum_sublists\" failed type inference...\n```", "```py\n    @nb.jit\n    def sum_sublists(a):\n        result = [0]\n        for sublist in a:\n            result.append(sum(sublist))\n        return result[1:]\n```", "```py\n$ /path/to/bin/pypy -m ensurepip\n$ /path/to/bin/pypy -m pip install virtualenv\n$ /path/to/bin/virtualenv my-pypy-env\n```", "```py\n$ source my-pypy-env/bin/activate\n```", "```py\n(my-pypy-env) $ pip install numpy matplotlib\n```", "```py\n(my-pypy-env) $ deactivate\n```", "```py\n$ python -m timeit --setup \"from simul import benchmark\" \n  \"benchmark()\"\n10 loops, best of 3: 886 msec per loop\n```", "```py\n$ export MPLBACKEND='agg'\n```", "```py\n$ source my-pypy-env/bin/activate\n(my-pypy-env) $ python -m timeit --setup \"from simul import \n  benchmark\" \"benchmark()\"\nWARNING: timeit is a very unreliable tool. use perf or \nsomething else for real measurements\n10 loops, average of 7: 106 +- 0.383 msec per loop (using \nstandard deviation)\n```", "```py\n(my-pypy-env) $ pip install perf\n(my-pypy-env) $ python -m perf timeit --setup 'from simul \n  import benchmark' 'benchmark()'\n.......\nMedian +- std dev: 97.8 ms +- 2.3 ms\n```"]