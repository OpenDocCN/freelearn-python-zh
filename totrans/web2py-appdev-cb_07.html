<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Web Services</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem"><p>Consuming a web2py JSON service with jQuery</p></li><li class="listitem"><p>Consuming a JSON-RPC service</p></li><li class="listitem"><p>JSON-RPC from JavaScript</p></li><li class="listitem"><p>Making amf3 RPC calls from Flex using pyamf</p></li><li class="listitem"><p>PayPal integration in web2py</p></li><li class="listitem"><p>PayPal web payments standard</p></li><li class="listitem"><p>Getting Flickr photos</p></li><li class="listitem"><p>Sending e-mails with Boto through<strong> Amazon Web Services</strong> (AWS)</p></li><li class="listitem"><p>Making GIS maps using mapscript</p></li><li class="listitem"><p>Google groups and Google code feeds reader</p></li><li class="listitem"><p>Creating SOAP web services</p></li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter is not about creating web services (that subject is discussed in the official web2py manual); it's about consuming web services. The most common web services use protocols, such as JSON, JSON-RPC, XML, XMLRPC, and/or SOAP. web2py supports them all, but the integration can be quite tricky. Here, we provide examples of integration with Flex, Paypal, Flickr, and GIS.</p></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec02"/>Consuming a web2py JSON service with jQuery</h1></div></div></div><p>This is a simple example of how to retrieve JSON data from the server, and consume it with jQuery.<a id="id226" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec01"/>How to do it...</h2></div></div></div><p>There are many ways to return JSON form web2py, but here we consider the case of a JSON service, for example:</p><div><pre class="programlisting">
def consumer():
	return dict()
	
@service.json
def get_days():
	return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
		"Friday", "Saturday"]
		
def call():
	return service()
</pre></div><p>Here the function<code class="literal"> consumer</code> doesn't really do anything; it just returns an empty dictionary to render the view, which will consume the service.<code class="literal"> get_days</code> defines the service, and the function call exposes all registered services.<code class="literal"> get_days</code> does not need to be in the controller, and can be in a model.<code class="literal"> call</code> is always in the<code class="literal"> default.py</code> scaffolding controller.<a id="id227" class="indexterm"/>
</p><p>Now, we create a view for the consumer actions:</p><div><pre class="programlisting">
{{extend 'layout.html'}}

&lt;div id="target"&gt;&lt;/div&gt;

&lt;script&gt;
	jQuery.getJSON("{{=URL('call',args=['json','get_days'])}}",
		function(msg){
	jQuery.each(msg, function(){ jQuery("#target").
		append(this + "&lt;br /&gt;"); } )
	});
&lt;/script&gt;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec02"/>How it works...</h2></div></div></div><p>The first argument of<code class="literal"> jQuery.getJSON</code> is the URL of the following service:</p><p>
<code class="literal">http://127.0.0.1:8000/app/default/call/json/get_days</code>
</p><p>This always follows the pattern:<code class="literal"> http://&lt;domain&gt;/&lt;app&gt;/&lt;controller&gt;/call/&lt;type&gt;/&lt;service&gt;</code>
</p><p>The URL is in between<code class="literal"> {{...}}</code>, because it is resolved at the server-side, while everything else is executed at the client-side.</p><p>The second argument of<code class="literal"> jQuery.getJSON</code> is a callback, which will be passed the JSON response. In our case, the callback loops over each item in the response (a list of week days as strings), and appends each string, followed by a<code class="literal">&lt;br/&gt;</code> to the<code class="literal">&lt;div id="target"&gt;</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec03"/>There's more...</h2></div></div></div><p>If you enable generic URLs, you can implement<code class="literal"> json</code> services as a regular action.<a id="id228" class="indexterm"/>
</p><div><pre class="programlisting">
response.generic_pattern = ['get_days.json']
def get_days():
	return ["Sunday", "Monday", "Tuesday", "Wednesday",
		"Thursday", "Friday", "Saturday"]
</pre></div><p>In this case, you do not need to use the<code class="literal"> call</code> action, and you can rewrite the view for the consumer action as follows:</p><div><pre class="programlisting">
{{extend 'layout.html'}}

&lt;div id="target"&gt;&lt;/div&gt;
	&lt;script&gt;
		jQuery.getJSON(
			"{{=URL('get_days.json')}}",
			function(msg){
			jQuery.each(
				msg,
				function(){
						jQuery("#target").append(this + "&lt;br /&gt;");
				}
			);
		}
	);
&lt;/script&gt;
</pre></div><p>In this way, the URL is shorter. So, why use the<code class="literal"> @service.json</code> instead of the latter method? There are two reasons. The first is that in the former case, you can expose the same function suing also JSON-RPC, XMLRPC, SOAP, and AMF services, using the corresponding decorators. While in the latter case, this would be more complex. The second reason is that, using<code class="literal"> @service.json, GET</code> variables are automatically parsed and passed as variables to the service function. For example:</p><div><pre class="programlisting">
@service.json
def concat(a,b):
	return a+b
</pre></div><p>This can be called equivalently with the following:</p><p>
<code class="literal">http://127.0.0.1:8000/app/default/call/json/concat?a=hello&amp;b=world</code>
</p><p>
<code class="literal">http://127.0.0.1:8000/app/default/call/json/concat/hello/world</code>
</p><p>
<code class="literal">http://127.0.0.1:8000/app/default/call/json/concat/hello?b=world</code>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec03"/>Consuming a JSON-RPC service</h1></div></div></div><p>While, before, we considered the case of a JSON service, we are now interested in a<strong> JSON-RPC</strong> service. This is more complex, because the variables (<code class="literal"> request</code> and<code class="literal"> response)</code> have a more strict format dictated by the protocol.<a id="id229" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec04"/>Getting ready</h2></div></div></div><p>We can create a JSON-RPC service in pure web2py, but it's more likely that we will consume it from a different Python program. For this purpose, we will assume a standard<code class="literal"> jsonrpc</code> library, which can be found at the following URL:</p><p>
<a class="ulink" href="http://https://github.com/bmjames/python-jsonrpc">https://github.com/bmjames/python-jsonrpc</a>
</p><p>You can install it with the following command:</p><div><pre class="programlisting"><strong>easy_install jsonrpc</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec05"/>How do do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First of all, we need to create the<code class="literal"> service</code>. We will consider the same example that we used before, but we change its decorator:</p><div><pre class="programlisting">
	from gluon.tools import Service
	service = Service(globals())
	@service.jsonrpc
	def concat(a,b):
	return a+b
def call():
	return service()
</pre></div></li><li class="listitem"><p>Now, to call it, we need a JSON-RPC client library from a separate (non web2py) Python program:</p><div><pre class="programlisting">
from jsonrpc.proxy import JSONRPCProxy
proxy = JSONRPCProxy(
	'http://127.0.0.1:8000',path='/app/default/call/jsonrpc')
print proxy.call('concat','hello','world')
</pre></div></li></ol></div><div><div><div><div><h3 class="title"><a id="ch07lvl2sec06"/>There's more...</h3></div></div></div><p>There are other JSON-RPC libraries out there, for example<a class="ulink" href="http://json-rpc.org/wiki/python-json-rpc"> http://json-rpc.org/wiki/python-json-rpc</a>, which uses the following syntax closer to the<code class="literal"> xmlrpclib</code> syntax:</p><div><pre class="programlisting">
from jsonrpc import ServerProxy
proxy = ServerProxy(
	'http://127.0.0.1:8000/app/default/call/jsonrpc')
print proxy.concat('hello','world')
</pre></div><p>Notice that in this latter case, the method name becomes an attribute. The two libraries are incompatible, but have the same name. Make sure you know which one you are using.</p><p>web2py includes its own JSON-RPC client library in<code class="literal"> gluon/contrib/simplejsonrpc.py</code>, and its API is compatible with the previous example:<a id="id230" class="indexterm"/>
</p><div><pre class="programlisting">
def test_concat():
	from gluon.contrib.simplejsonrpc import ServerProxy
	proxy = ServerProxy(
		'http://127.0.0.1:8000/%s/default/call/jsonrpc' %
		request.application)
	return proxy.concat('hello','world')
</pre></div></div></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec04"/>JSON-RPC from JavaScript</h1></div></div></div><p>There are many good reasons you'd want to use JSON-RPC as transport protocol in your web applications between the client and the server. This is particularly useful to create a rich client interface, as JSON-RPC is faster than XML-RPC, because it is less verbose and is easier to parse by the JavaScript code. JSON-RPC is better than just JSON, because it is an RPC protocol, which means that it will handle error propagation for you.<a id="id231" class="indexterm"/>
</p><p>In this recipe, we provide an example of how to do it.</p><p>You can read an article for the same at the following URL, which is written by<em> Luke Kenneth Casson Leighton</em>, author of the excellent<em> Pyjamas library:</em>
</p><p>
<a class="ulink" href="http://www.advogato.org/article/993.html">http://www.advogato.org/article/993.html</a>
</p><p>This recipe is based on code posted here:</p><p>
<a class="ulink" href="http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip">http://otomotion.org/BasicJSONRPC/static/BasicJSONRPC-application.zip</a>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec07"/>Getting ready</h2></div></div></div><p>This recipe is based on the<code class="literal"> json-xml-rpc</code> library, which is available at:</p><p>
<a class="ulink" href="http://code.google.com/p/json-xml-rpc">http://code.google.com/p/json-xml-rpc</a>
</p><p>It is an RPC JavaScript client implementation used in this example to connect to web2py's actions, using its native JSON-RPC support.</p><p>It's not a perfect approach, but it supplies a level of decoupling between the server and the client that makes me want to look past its small defects. This enlightening article, by<em> Luke Kenneth Casson Leighton</em>, goes into more detail about the approach (see the section<em> Full-blown JavaScript-led Development)</em>. This is also the method used by frameworks such as<strong> GWT</strong> (<a class="ulink" href="http://code.google.com/webtoolkit/">http://code.google.com/webtoolkit/</a>) and<strong> PyJamas</strong> (<a class="ulink" href="http://pyjs.org/">http://pyjs.org/</a>).<a id="id232" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec08"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>We will create two controllers and one view. The first controller will simply load the rich client interface defined in the view. The second controller defines the JSON-RPC methods. There's no real reason not to use a single controller for both purposes, but it is a better design to keep the two functionalities in separate files.</p><p>The first controller can be <code class="literal">default.py</code>, and we can use the usual trivial action:
</p><div><pre class="programlisting">def index(); return dict()
</pre></div><p>In the <code class="literal">view views/default/index.html</code>, we are going to simply add the following code:
</p><div><pre class="programlisting">
{{
	response.files.append(URL('static','js/jquery.js'))
	response.files.append(URL('static','js/rpc.js'))
	response.files.append(URL('static','js/BasicJSONRPC.js'))
}}
{{extend 'layout.html'}}
</pre></div><p>The <code class="literal">BasicJSONRPC.py</code> controller contains nothing more than the reference to the view.
</p><div><pre class="programlisting">
def index():
	response.view = "BasicJSONRPC.html"
	return dict()
	
def BasicJSONRPC():
	response.view = "BasicJSONRPC.html"
	return dict()
</pre></div><p>The <code class="literal">BasicJSONRPCData.py</code> controller is where the real meets the live. We'll start simple.
</p><div><pre class="programlisting">
import math

from gluon.tools import Service

service = Service(globals())

def call():
	return service()
	
@service.jsonrpc

def systemListMethods():

	#Could probably be rendered dynamically

	return ["SmallTest"];
	
@service.jsonrpc

def SmallTest(a, b):

	return a + b
</pre></div><p>The <code class="literal">systemListMethods</code> action is required by the <code class="literal">json-xml-rpc</code> library. By default, the library actually calls <code class="literal">system.ListMethods</code>, which can't be supported by Python. We thus remove the period in the call inside the RPC library. The Python function just needs to return an array of strings of all the possible methods to call.
</p></li><li class="listitem"><p>Now that we have the controller ready, we can move on to the client portion. The URL to access the RPC methods is something like the following:</p><p><code class="literal">http://localhost/Application/Controller/call/jsonrpc
</code>
</p></li><li class="listitem"><p>Using this URL and the<code class="literal"> json-xml-rpc</code> library, we create a JavaScript<code class="literal"> DataController</code> object, which we'll use for all future procedure calls.<a id="id233" class="indexterm"/>
</p><div><pre class="programlisting">
var ConnectionCreationTime = null;
var DataController = null;
var Connected = false;

function InitDataConnection() {
	Connected = false;
	// replace with the correct service url
	var url = http://localhost/Application/Controller/call/jsonrpc
	// var url = GetConnectionURL();
	try {
		// Here we connect to the server and build
		// the service object (important)
		DataController = new rpc.ServiceProxy(url);
		Connected = true;
	} catch(err) {
		Log("Connection Error: " + err.message);
		Connected = false;
	}
	var now = new Date();
	ConnectionCreated = now;
}
</pre></div></li><li class="listitem"><p>By default, the<code class="literal"> json-xml-rpc</code> library creates the<code class="literal"> DataController</code> for asynchronous calls. Since you don't want your JavaScript to be blocked during your requests,<strong> asynchronous calls</strong> is the desired behavior. If you'd, however, like to run a quick test of of your remote methods, you can run the following lines of JavaScript from the Firebug console:</p><div><pre class="programlisting"><strong>http://getfirebug.com

InitDataConnection();
rpc.setAsynchronous(DataController,false);
DataController.SmallTest(1,2);</strong>
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">json-xml-rpc</code> documentation, located at <a class="ulink" href="http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript">http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript</a>, gives the details of how to run asynchronous calls.
<a id="id234" class="indexterm"/>
</p><div><pre class="programlisting">
function RunSmallTest() {
	if(Connected == false)
		Log("Cannot RunSmallTest unless connected");
	else {
		var a = GetAValue();
		var b = GetBValue();
		Log("Calling remote method SmallTest using values a="
			+ a + " and b=" + b);
		DataController.SmallTest({params:[a,b],
			onSuccess:function(sum){
		Log("SmallTest returned " + sum);
		},
		onException:function(errorObj){
			Log("SmallTest failed: " + errorObj.message);
		},
		onComplete:function(responseObj){
			Log("Call to SmallTest Complete");
		}
		});
		Log("Asynchronous call sent");
	}
}
</pre></div></li><li class="listitem"><p>Dictionaries and arrays can be returned by your Python functions, as demonstrated by our<code class="literal"> BiggerTest</code> function:<a id="id235" class="indexterm"/>
</p><div><pre class="programlisting">
@service.jsonrpc
def BiggerTest(a, b):
	results = dict()
	results["originalValues"] = [a,b]
	results["sum"] = a + b
	results["difference"] = a - b
	results["product"] = a * b
	results["quotient"] = float(a)/b
	results["power"] = math.pow(a,b)
	return results
</pre></div><div><h3 class="title">Note</h3><p>Don't forget to update the<code class="literal"> systemListMethods</code> function to include any new functions.</p></div></li></ul></div></li><li class="listitem"><p>At this step, you should be able to test remote calls and see the results using JavaScript (called synchronously in Firebug console):</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; InitDataConnection();
POST http://127.0.0.1:8000/BasicJSONRPC/BasicJSONRPCData/call/
jsonrpc 	200 OK 	 20ms 		rpc.js (line 368)
&gt;&gt;&gt; rpc.setAsynchronous(DataController,false);
&gt;&gt;&gt; var results = DataController.BiggerTest(17,25);
POST http://127.0.0.1:8000/BasicJSONRPC/BasicJSONRPCData/call/
jsonrpc 	200 OK 	20ms 	rpc.js 		(line 368)
&gt;&gt;&gt; results.originalValues
[17, 25]
&gt;&gt;&gt; results.originalValues[1]
25
&gt;&gt;&gt; results.sum
42
&gt;&gt;&gt; results.difference
-8
&gt;&gt;&gt; results.quotient
0.68</strong>
</pre></div></li><li class="listitem"><p>Authentication works too, as cookies are posted with every request, and web2py is thus able to parse the session ID cookie for JSON-RPC calls. Security requirements can be added to your remote functions, by securing the call function (not the individual service function; that is important):<a id="id236" class="indexterm"/>
</p><div><pre class="programlisting">
@auth.requires_login()
def call():
	return service()
</pre></div></li><li class="listitem"><p>If you were to also set<code class="literal"> @auth.requires_login</code> on the main<code class="literal"> BasicJSONRPC.py</code> controller, your users would log in when they first load the page, and all subsequent RPC calls will be correctly authenticated. The problem with this, comes with<strong> timeouts</strong>. If a user lets the page idle until timeout occurs, she or he can still trigger RPC calls to the server. Authentication will then fail and the default web2py value of<code class="literal"> auth.settings.login_url, /default/user/login</code> will be called as a view. The problem is that since a view is not a valid JSON-RPC message, the<code class="literal"> json-xml-rpc</code> library will discard it and fail. You can catch the error, but it's not easy to identify it. The simplest solution I've found, and I'm hoping that others will find a better one, is to set the value of<code class="literal"> auth.settings.login_url</code> to an action in the RPC controller, which returns nothing but a simple string.</p></li><li class="listitem"><p>In<code class="literal"> db.py</code>, set:</p><div><pre class="programlisting">auth.settings.login_url = URL("BasicJSONRPC", 'Login')
</pre></div></li><li class="listitem"><p><code class="literal"> Login</code> is a non JSON-RPC action (since we don't want it to require authentication), which returns an easily recognizable string:</p><div><pre class="programlisting">
def Login():
	return "Not logged in"
</pre></div></li><li class="listitem"><p>We can then detect authentication failure from the client-side, by running a check whenever an RPC call fails. In the<code class="literal"> onException</code> handler of the asynchronous call (see<code class="literal"> RunSmallTest)</code>, replace with the following code to handle authentication:<a id="id237" class="indexterm"/>
</p><div><pre class="programlisting">
onException:function(errorObj){
	if(errorObj.message.toLowerCase().indexOf(
		"badly formed json string: not logged in") &gt;= 0)
			PromptForAuthentication();
	else
		Log("SmallTest failed: " + errorObj.message);
}
</pre></div><p>The obvious flaw in this approach is that we've lost the very practical login view for regular HTML views. Therefore, while authentication works for RPC calls, it breaks it for HTML views.
</p></li><li class="listitem"><p>We can now simplify our calls.</p><p>Although it's not possible to really simplify the syntax used by the json-xml-rpc library to make an asynchronous call, it is, however, possible to somewhat automate many parts of it, for calls that simply get or update client-side data objects. This is especially useful if you're trying to handle errors and authentication in a consistent way. We can use the following client wrapper function to make asynchronous calls:
</p><div><pre class="programlisting">
function LoadDataObject(objectName,params,
	responseObject,errorObject) {
	Log("Loading data object \"" + objectName + "\"")
	eval("" + objectName + " = \"Loading\"");
	eval(objectName +"Ready = false");
	if(responseObject === undefined) {
		if(Connected != true) {
			Log("Not connected, connecting...");
			InitDataConnection();
		}
		var listUndefined = eval("DataController." +
			objectName + " !== undefined")
		if(Connected == true &amp;&amp; listUndefined == true) {
			var paramsString = "";
		for(var i in params) {
			paramsString += "params[" + i + "],";
		}
		//Removing trailing coma
		paramsString = paramsString.substring(0,
			(paramsString.length - 1));
		eval(
			"DataController."
				+ objectName
				+ "({params:["
				+ paramsString
				+ "], onSuccess:function(response){LoadDataObject(\"" + objectName + "\",["
				+ paramsString + "],response)}, onException:function(error){
				Log(\"Error detected\"); LoadDataObject(\""
				+ objectName
				+ "\",["
				+ paramsString
				+ "],null, error);}, onComplete:function(responseObj){
				Log(\"Finished loading "
				+ objectName
		+ "\");} });" );
		}
		else {
			eval(objectName + " = \"Could not connect\"");
			eval(objectName + "Ready = false");
			Log("Could not connect. Either server error " +
			"or calling non existing method ("
			+ objectName + ")");
		}
	} else {
		if(errorObject === undefined) {
			eval(objectName + " = responseObject");
			eval(objectName +"Ready = true");
		}
		else {
			Log("Failed to Load Data Object " +
			objectName + ": " + errorObject.message)
			eval(objectName + " = errorObject");
			eval(objectName + "Ready = false");
		}
	}
}
</pre></div><p>The function can be reused for any number of data objects. The requirements are:
<a id="id238" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>Define a<code class="literal"> data object</code> variable that has the same name as the RPC function (for example:<code class="literal"> UserList)</code>
</p></li><li class="listitem"><p>Define another variable with its name followed by<code class="literal"> Ready</code> (for example:<code class="literal"> UserListReady)</code>
</p></li><li class="listitem"><p>Call the wrapper function, by passing the name of the RPC action as a string, and an array containing any required parameter values (for example:<code class="literal"> LoadDataObject("UserList", ["admins",false])</code>
</p></li></ul></div></li></ol></div><p>During the call, the<code class="literal"> ready</code> variable will be set to<code class="literal"> false</code>, and the<code class="literal"> data object</code> variable will be set to the string<code class="literal"> Loading</code>. If an error occurs, the<code class="literal"> ready</code> variable will remain<code class="literal"> false</code>, and the<code class="literal"> data object</code> variable will be set to the error object. You can poll the two variables if necessary.<a id="id239" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec09"/>There's more...</h2></div></div></div><p>The<code class="literal"> json-xml-rpc</code> library is a single JavaScript file, which can be obtained by downloading the<strong> rpc-client-JavaScript</strong> ZIP file from the following Google-hosted code site:</p><p>
<a class="ulink" href="http://code.google.com/p/json-xml-rpc/downloads/list">http://code.google.com/p/json-xml-rpc/downloads/list</a>
</p><p>It has excellent documentation, which is located at the following URL:</p><p>
<a class="ulink" href="http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript">http://code.google.com/p/json-xml-rpc/wiki/DocumentationForJavaScript</a>
</p><p>There is, however, a bug in their code. In<em> revision 36</em>, we had to change<em> lines 422</em> to<em> 424:</em>
</p><div><pre class="programlisting">
//Handle errors returned by the server
if(response.error !== undefined){
	var err = new Error(response.error.message);
</pre></div><p>To the following</p><div><pre class="programlisting">
//Handle errors returned by the server
if(response.error &amp;&amp; response.error !== undefined){
	var err = new Error(response.error.message);
</pre></div><p>We also had to remove the periods in the calls to<code class="literal"> system.ListMethods</code> on<em> lines 151</em> and<em> 154</em>, so that a<code class="literal"> systemListMethods</code> function could be supported by Python.</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec05"/>Making amf3 RPC calls from Flex using pyamf</h1></div></div></div><p>Unlike the example in<em> The Official web2py Book</em>, in this recipe we show you how to communicate with an<code class="literal"> mxml</code> Flex application as opposed to Flash.<a id="id240" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec10"/>Getting ready</h2></div></div></div><p>First of all, you must install<strong> pyamf</strong> and make it visible to web2py (which initially comes without pyamf). For this purpose, visit the pyamf download page, located at the following URL, and get a ZIP file of the latest stable release:<a id="id241" class="indexterm"/>
</p><p>
<a class="ulink" href="http://www.pyamf.com/community/download.html">http://www.pyamf.com/community/download.html</a>
</p><p>Unzip and install it according to instructions in<code class="literal"> INSTALL.txt</code>. I suggest using the following command, in order to avoid possible problems:</p><div><pre class="programlisting"><strong>python setup.py install --disable-ext</strong>
</pre></div><p>This will place a<code class="literal"> .egg</code> package (something like<code class="literal"> PyAMF-0.5.1-py2.6.egg)</code> in Python's installation folder, under<code class="literal"> \Lib\site-packages</code> (for example,<code class="literal"> C:\Python26\Lib\site-packages)..egg</code> is basically a ZIP archive (such as<code class="literal"> .jar</code> to Java), so open it and extract the<code class="literal"> pyamf</code> folder. Go to the web2py installation folder, and find the<code class="literal"> library.zip</code> archive. Add<code class="literal"> pyamf</code> to this archive. That's it! Now, web2py will run<code class="literal"> pyamf</code> transparently to you.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec11"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p><strong> Python code:</strong> Let's assume that you are developing an application called<code class="literal"> app</code>, and the web2py server runs on the localhost (127.0.0.1:8000). Add a new controller called<code class="literal"> rpc.py</code>, and add the following code to the controller:<a id="id242" class="indexterm"/>
</p><div><pre class="programlisting">
from gluon.tools import Service
service = Service(globals())

def call():
	session.forget()
	return service()
	
@service.amfrpc3("mydomain")
def test():
	return "Test!!!"
</pre></div><p>Notice that mydomain is important. You can use a different domain name, but you have to be consistent. Don't forget it!
</p></li><li class="listitem"><p><strong> Flex mxml/AS3 code:</strong> Now, create a new<strong> Flex</strong> application, and replace its content with the following code:</p><div><pre class="programlisting">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
	&lt;mx:Application  layout="absolute"&gt;
		&lt;mx:Script&gt;
			&lt;![CDATA[
				import mx.rpc.events.FaultEvent;
				import mx.rpc.events.ResultEvent;
				import mx.controls.Alert;
				
				private function resultHandler(
					event:ResultEvent):void
					{
						trace(event.result.toString());
					}
					private function faultHandler(
						event:FaultEvent):void
						{
							trace(event.fault.message);
						}
			]]&gt;
	&lt;/mx:Script&gt;
	&lt;mx:RemoteObject
		id="amfService"
		endpoint="http://127.0.0.1:8000/app/rpc/call/amfrpc3"
		destination="mydomain"
	showBusyCursor="true"&gt;
		&lt;mx:method name="test" result="resultHandler(event)"
			fault="faultHandler(event)"/&gt;
	&lt;/mx:RemoteObject&gt;
	&lt;mx:Button x="250" y="150" label="Fire"
		click="amfService.test();"/&gt;
&lt;/mx:Application&gt;
</pre></div></li><li class="listitem"><p><code class="literal"> code_xml:</code> Pay attention to the definition of the<code class="literal"> RemoteObject. Endpoint</code> is a service URL. It doesn't include the RPC method name, which should be specified in the<code class="literal"> name</code> attribute of the<code class="literal"> mx:method</code> object.<code class="literal"> /call/amfrpc3</code> is a standard URL suffix, and it shouldn't be altered. It is important to specify the destination attribute it's the same ID that appears in the controller in the<code class="literal"> @service.amfrpc3(...)</code> decorator.</p></li><li class="listitem"><p><strong> Setting</strong>
<code class="literal"> crossdomain.xml:</code> Notice that in order for Flex to be able to invoke RPC services from a different domain, one needs to expose an appropriate<code class="literal"> crossdomain.xml</code> file at the top-level of the server of that domain. For example:<a id="id243" class="indexterm"/>
</p><div><pre class="programlisting">http://mydomain.com:8000/crossdomain.xml
</pre></div><p>To do this, create <code class="literal">crossdomain.xml</code> inside the <code class="literal">static/</code> folder of the application (web2py doesn't support public resources, so we will do some routing), and add an appropriate access policy. For example, <strong>full access</strong> (not desirable for security reasons):
</p><div><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE cross-domain-policy SYSTEM
	"http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd"&gt;
&lt;cross-domain-policy&gt;
	&lt;allow-access-from domain="*" /&gt;
&lt;/cross-domain-policy&gt;
</pre></div><p>Now go to the web2py installation folder, and create a routes.py file with the following content:
</p><div><pre class="programlisting">routes_in = (('/crossdomain.xml', '/app/static/crossdomain.xml'),)
</pre></div><p>This file instructs the web2py server to redirect all requests in crossdomain.xml, to its location at the application's static resources. Don't forget to close and run the process of the server, in order for it to reload the routing information.
<a id="id244" class="indexterm"/>
</p></li></ol></div></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec06"/>PayPal integration in Web2py</h1></div></div></div><p>This recipe is meant to be an introduction to<strong> Paypal</strong> integration in web2py. It by no means covers all the possible integrations with Paypal, and is mostly centered on what PayPal names<strong> Standard Integration</strong>. The examples given are proven at the time of writing this, but they should be taken only as a starting point rather than a reference. For that, please use both PayPal's and web2py's documentation.<a id="id245" class="indexterm"/>
</p><div><h3 class="title"><a id="note05"/>Note</h3><p>PayPal offers different levels of integration, which, depending on what you need to do, might be better suited for your needs. It is important that you get to know at least the basic integration concepts that PayPal provides before starting to program anything, so that you can plan in advance what is best suited to your needs.</p></div><p>That said, let me try to give you a rough idea of the different levels involved, before going any further, so as to better understand the little area that this recipe covers. It is, however, an area which most of the small-sized and middle-sized projects may fall into.</p><p>In broad lines, there are three levels of integration that one can achieve with PayPal:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<strong>Express checkout:</strong> Within a seller account in PayPal, you can create buttons with information related to each item that you may be selling (name, description, item number, and pricing). You can have up to 1000 different buttons or items defined in this way. After that, it is a matter of setting the buttons on the HTML, to go along with the application. Regarding web2py, it is really simple to just copy the code that PayPal creates for each button in a text field in your product<code class="literal"> db</code>, and then just present it on the screen whenever it's needed. Using this method, one can opt for different purchase experiences including straight checkout or cart management (managed by PayPal), which would let you add or remove items from within the checkout screen in PayPal. I don't like this method, unless you would be selling very, very few item codes, as it may get to be a pain to maintain your articles in PayPal. If you are selling a few services or whatever with a small set of prices, it might very well be worth it, as you don't have to work much from the programming point of view, and it's really simple to set up.<a id="id246" class="indexterm"/>
</p></li><li class="listitem"><p>
<strong>Standard integration:</strong> This is the one that we will be covering in this article. It basically lets you manage your own product database, and so on, and sends all the data to PayPal at the moment of payment, so that the whole checkout process is managed at PayPal. After the transaction has been completed, you can choose (as per configuration of your profile in your PayPal seller account) whether the customer is redirected back to your domain (you can set up a default URL to return to, or send that URL dynamically each time you send the data for the checkout, but the functionality needs to be activated in your seller account). The following two things need to be mentioned here, which I feel are part of the standard integration, although they are not required in order to have your basic site working:<a id="id247" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>
<strong>Payment Data Transfer (PDT):</strong> This would be the process by which the customer is sent back to your domain, which lets you capture the transaction data (payment confirmation data from PayPal), and shows it in a confirmation screen in your own domain, with any further information you may want to show, or redirect the customer to continue his shopping. It is not completely safe, as nothing guarantees that the customer will be redirected; this may well happen, because in some cases, PayPal doesn't execute the redirection, but forces the customer to click on an extra button to return to your domain, so as to give the opportunity to the customer to join PayPal. This happens whenever the customer pays by credit card and not using his PayPal account.</p></li><li class="listitem"><p>
<strong>Instant Payment Notification (IPN):</strong> This is a messaging service that connects to your domain to send the information of each transaction processed at Paypal. It doesn't stop sending the message until you acknowledge its reception (or four days pass without acknowledgement). This is the safest way to collect all the data from all the transactions processed at PayPal, and trigger any internal process that you may have. Usually, you will want to do the shipping of your products at this point.</p></li></ul></div></li><li class="listitem"><p>
<strong>Detailed integration:</strong> In here, I am really grouping a number of other methods ands APIs, that I will not be detailing; some of them for very specific uses. The only method that I would like to mention more specifically is<strong> Name Value Pairs (NVP)</strong> , as I feel that it gives you a very simple programing interface with which you can do very detailed processes controlling all your data, and all your transaction flow from your domain. Using NVP, you can, for example, capture all the data related to a payment in your domain, and only at that point, send all the information to PayPal to process the payment (as opposed to processing the checkout, which is what we are doing with the previous items). You have a good example as to how to implement this at<a class="ulink" href="http://web2py.com/appliances/default/show/28"> http://web2py.com/appliances/default/show/28</a>, or go to the main web page, and find it under free applications,<strong> PayPalEngine</strong>, developed by<em> Matt Sellers</em>. You should, however, check the detailed documentation at PayPal, as the process involves many steps, in order to ensure the maximum security of your transactions.</p></li></ul></div><p>So basically, in express checkout, PayPal manages your cart (and master data), the checkout process, and of course, payments. With standard integration, PayPal manages checkout and payments, and with further detailed integration, you can make it so that it manages only the payments.<a id="id248" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec12"/>How to do it...</h2></div></div></div><p>Before moving on, all the technical documentation regarding integration with PayPal can be found at:<a id="id249" class="indexterm"/>
</p><p>
<a class="ulink" href="http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&amp;content_ID=developer/library_documentation">https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&amp;content_ID=developer/library_documentation</a>
</p><p>A link to this URL, in case this changes, can be found by clicking on the documentation link at:</p><p>
<a class="ulink" href="http://https://developer.paypal.com/">https://developer.paypal.com/</a>
</p><p>So, moving on to how to use the standard integration, the first thing you should do is create yourself a sandbox account. You do this at<code class="literal"> https://developer.paypal.com/</code>. Create yourself an account, and once logged in, create at least two test accounts: a<code class="literal"> seller</code> and a<code class="literal"> buyer</code> respectively. There is a good guide on all the necessary steps called<strong> PP sandbox user guide</strong>, which you can find at the documentation link provided before, or on an HTML version at<a class="ulink" href="http://https://cms.paypal.com/us/cgi-bin/?"> https://cms.paypal.com/us/cgi-bin/? cmd=_render-content&amp;content_ID=developer/howto_testing_sandbox</a>. Everything on how to set your account up and start running, is described there.</p><p>Once you have that set up and running, you will have your seller ID and e-mail (you can use any of them to identify yourself to PayPal on the code below, although I prefer the ID, if only to avoid possible spam).</p><p>OK, so now, we can already create the<strong> checkout button</strong> that will take our customers to the PayPal site with all our cart data. Before moving further, you can find all documentation related to this point at the documentation link provided before, under the<em> Website Payments Standard Integration Guide</em>, or directly in an HTML format at:</p><p>
<a class="ulink" href="http://https://cms.paypal.com/us/cgi-bin/?">https://cms.paypal.com/us/cgi-bin/? cmd=_render-content&amp;content_ID=developer/howto_html_wp_standard_overview</a>
</p><p>Check the information about<em> Third-Party Shopping Carts</em>. Anyway, creating the button to send all the information is actually very simple. All that is needed is the following code in your checkout page view:</p><div><pre class="programlisting">
&lt;form action="https://www.sandbox.paypal.com/cgi-bin/webscr"
		method="post"&gt;
		&lt;!-- Select the correct button depending on country etc.
		If you can do it with pre-generated buttons (with prices included
			etc)
			then so much the better for security --&gt;
		&lt;input type="hidden" name="business" value="{{=paypal_id}}" /&gt;
	&lt;input type="image" src=
		"https://www.sandbox.paypal.com/es_XC/i/btn/btn_buynowCC_LG.gif"
		border="0" name="submit" alt="PayPal - The safer, easier way to pay
		online!"&gt;
	&lt;img alt="" border="0" src=
		"https://www.sandbox.paypal.com/es_XC/i/scr/pixel.gif" width="1"
		height="1"&gt;
	&lt;form action="http://www.sandbox.paypal.com/cgi-bin/webscr"
		method="post" /&gt;
	&lt;input type="hidden" name="cmd" value="_cart" /&gt;
	&lt;input type="hidden" name="upload" value="1" /&gt;
	&lt;input type="hidden" name="charset" value="utf-8"&gt;
	&lt;input type="hidden" name="currency_code" value="EUR" /&gt;
	&lt;input type="hidden" name="display" value="1"/&gt;
	&lt;input type="hidden" name="shopping_url"
		value="http://www.micropolixshop.com/giftlist/default/glist"/&gt;
	&lt;!-- Not really necessary, only if want to allow
		continue Shopping --&gt;
	&lt;input type="hidden" name="notify_url" value=
		"http://www.micropolixshop.com/giftlist/default/ipn_handler"/&gt;
	&lt;!-- Or leave blank and setup default url at paypal --&gt;
	&lt;input type="hidden" name="return"
		value="http://www.micropolixshop.com/giftlist/default/confirm"/&gt;
	&lt;!-- Or leave blank and setup default url at paypal --&gt;
	&lt;input type="hidden" name="custom" value="{{=session.event_code}}"/&gt;
	{{k=1}}
	{{for id,product in products.items():}}
	&lt;input type="hidden" name="item_number_{{=k}}"
		value="{{=product.ext_code}}"/&gt;
	&lt;input type="hidden" name="item_name_{{=k}}"
		value="{{=product.name}}"/&gt;
	&lt;input type="hidden" name="quantity_{{=k}}"
		value="{{=session.cart[str(id)]}}"/&gt;
	&lt;input type="hidden" name="discount_rate_{{=k}}" value="15"/&gt;
	&lt;!-- ie, wants a 15% on all articles always --&gt;
	&lt;input type="hidden" name="tax_{{=k}}"
		value="{{=product.price*product.tax_rate}}"/&gt;
	&lt;input type="hidden" name="amount_{{=k}}"
		value="{{=product.price}}"/&gt;
	{{k+=1}}
	{{pass}}
&lt;/form&gt;
</pre></div><p>A couple of comments regarding the listing<code class="literal"> lst:CheckoutButton:</code>
<a id="id250" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>In all cases, to move from sandbox to production, the URL to use only needs to change from<a class="ulink" href="http://https://www.sandbox.paypal.com"> https://www.sandbox.paypal.com</a> to<a class="ulink" href="http://https://www.paypal.com"> https://www.paypal.com</a>.</p></li><li class="listitem"><p>You can create the buttons using the<code class="literal"> create new button</code> functionality at your seller account, and then re-use the code. It would let you to choose the language and the type of button to use. That way, you will get the correct link to the image to be used for your PayPal button.</p></li><li class="listitem"><p>The field<code class="literal"> cmd</code> with<code class="literal"> value _cart</code> is very important. Read the documentation to see the possible values of this field, depending on what you want to do. I am assuming a cart scenario on this example.</p></li><li class="listitem"><p>The fields<code class="literal"> shopping_url, notify_url</code>, and<code class="literal"> return</code> can be omitted, if you set up your seller account profile. If you set it up here, this takes precedence over the default values set up in your seller account.</p></li><li class="listitem"><p>The field<code class="literal"> custom</code>, I think, is rather important, as it is one of the few fields that lets you introduce data not shown to the customer, that may allow you to track any extra information. It is per transaction (not per item). In this case, I choose to use an internal event code to track all purchases related to an event (special<code class="literal"> promotion</code>, if you like or whatever).</p></li><li class="listitem"><p>As you can see, I created a loop with all the cart items to do the checkout, by passing a dictionary with all the product data. I have the information of the items purchased in the session. They get named and numbered following the PayPal rules.</p></li><li class="listitem"><p>Regarding the discount, even though you set the discounts per item, PayPal, only shows a discount total. I don't know if this is different in the Pro version.</p></li></ul></div><p>For more information, you should check the documentation named before, which includes a list of all the fields available to you (which include shipping charges, and so on).</p><p>
<strong>Checkout confirmation/payment data transfer:</strong> Once the customer finishes paying through PayPal, he will be redirected to your website, automatically, if it is set up in the account and he is already a PayPal user (otherwise he will have to click on a button to return to your site). This section shows you how to set your application so that it will receive the payment data confirmation from PayPal, and show a confirmation to your customer.<a id="id251" class="indexterm"/>
</p><p>You can read detailed documentation on this subject here:</p><p>
<a class="ulink" href="http://https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&amp;content_ID=developer/howto_html_paymentdatatransfer">https://cms.paypal.com/us/cgi-bin/?cmd=_render-content&amp;content_ID=developer/howto_html_paymentdatatransfer</a>
</p><p>Here, you can see how to set it up in detail, so that you know where to get your token from, which you need to identify yourself to PayPal, to confirm and get the data. In any case, refer to the following figure representing a<em> Diagram of the Basic flow of a PDT transaction</em> (picture taken from PayPal docs), so as to give you a detailed view of the process flow:<a id="id252" class="indexterm"/>
</p><div><img src="img/5467OS_07_diag1.jpg" alt="How to do it..."/></div><p>In the listing<code class="literal"> lst:generic-def</code>, I included a number of generic functions that I have used in setting up the interface. The<code class="literal"> Connection</code> class definition is a modified version of a generic connection example that I found while surfing the web, but I cannot really recall where. The<code class="literal"> add_to_cart, remove_from_cart, empty_cart</code>, and<code class="literal"> checkout</code> that I included as an example of how to set up your cart, which are taken from<strong> EStore</strong>, can be found at<a class="ulink" href="http://www.web2py.com/appliances/default/show/24"> http://www.web2py.com/appliances/default/show/24</a>.</p><p>Again, please understand that the different methods are oversimplified here, to try to explain in a few lines the different possibilities:</p><div><pre class="programlisting">
# db.py file
#####################################################################
# Global Variables definition
#####################################################################
domain='www.sandbox.paypal.com'
protocol='https://'
user=None
passwd=None
realm=None
headers = {'Content-Type':'application/x-www-form-urlencoded'}
# This token should also be set in a table so that the seller can set
#it up
# dynamically and not through the code. Same goes for the PAGINATE.
paypal_token="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
PAGINATE = 20
#####################################################################

# default.py file
#####################################################################
# coding: utf8

import datetime
import string

if not session.cart: session.cart, session.balance={},0
app=request.application

#### Setup PayPal login email (seller id) in the session
#### I store paypal_id in a table
session.paypal_id=myorg.paypal_id
import urllib2, urllib
import datetime

class Connection:
	def __init__(self, base_url, username, password, realm = None,
		header = {}):
		self.base_url = base_url
		self.username = username
		self.password = password
		self.realm = realm
		self.header = header
		
	def request(self, resource, data = None, args = None):
		path = resource
		
		if args:
			path += "?" + (args)
			
		# create a password manager
		password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
		
		if self.username and self.password:
			# Add the username and password.
				password_mgr.add_password(self.realm, self.base_url,
					self.username, self.password)
					
		handler = urllib2.HTTPBasicAuthHandler(password_mgr)
		
		# create "opener" (OpenerDirector instance)
		opener = urllib2.build_opener(handler)
		
		# Install the opener.
		# Now all calls to urllib2.urlopen use our opener.
		urllib2.install_opener(opener)
		#Create a Request
		req=urllib2.Request(self.base_url + path, data, self.header)
		# use the opener to fetch a URL
		error = ''
		try:
			ret=opener.open(req)
		except urllib2.HTTPError, e:
			ret = e
			error = 'urllib2.HTTPError'
		except urllib2.URLError, e:
			ret = e
			error = 'urllib2.URLError'
			
		return ret, error
		
	def add_to_cart():
		"""
			Add data into the session.cart dictionary
			Session.cart is a dictionary with id product_id and value = quantity
			Session.balance is a value with the total of the transaction.
			After updating values, redirect to checkout
		"""
		pid=request.args[0]
		product=db(db.product.id==pid).select()[0]
		product.update_record(clicked=product.clicked+1)
		try: qty=session.cart[pid]+1
		except: qty=1
		session.cart[pid]=qty
		session.balance+=product.price
		redirect(URL('checkout'))
	
	def remove_from_cart():
		"""
			allow add to cart
		"""
		pid = request.args[0]
		product=db(db.product.id==pid).select()[0]
		if session.cart.has_key(pid):
			session.balance-=product.price
			session.cart[pid]-=1
			if not session.cart[pid]: del session.cart[pid]
		redirect(URL('checkout'))
		
	def empty_cart():
		"""
			allow add to cart
		"""
		session.cart, session.balance={},0
		redirect(URL('checkout'))
		
	def checkout():
		"""
			Checkout
		"""
		pids = session.cart.keys()
		cart={}
		products={}
		for pid in pids:
			products[pid]=db(db.product.id==pid).select()[0]
		return dict(products=products,paypal_id=session.paypal_id)
</pre></div><p>Finally, confirm, at the listing<code class="literal"> lst:confirm</code>, will process the information sent from PayPal, with the four step process described in the previous diagram of the basic flow of a PDT transaction, steps 2,3,4, and 5.<a id="id253" class="indexterm"/>
</p><div><pre class="programlisting">
def confirm():
	"""
		This is set so as to capture the transaction data from PayPal
		It captures the transaction ID from the HTTP GET that PayPal
			sends.
		And using the token from vendor profile PDT, it does a form post.
		The data from the http get comes as vars Name Value Pairs.
	"""
	if request.vars.has_key('tx'):
		trans = request.vars.get('tx')
		# Establish connection.
		conn = Connection(base_url=protocol+domain, username=user,
			password = passwd, realm = realm, header = headers)
		data = "cmd=_notify-synch&amp;tx="+trans+"&amp;at="+paypal_token
		resp,error=conn.request('/cgi-bin/webscr', data)
		data={}
		if error=='':
			respu = resp.read()
			respuesta = respu.splitlines()
			data['status']=respuesta[0]
			if respuesta[0]=='SUCCESS':
				for r in respuesta[1:]:
					key,val = r.split('=')
					data[key]=val
				msg=''
				if data.has_key('memo'): msg=data['memo']
				form = FORM("Quiere dejar un mensaje con los regalos?",
					INPUT(_name=T('message'),_type="text",_value=msg),
					INPUT(_type="submit"))
				if form.accepts(request,session):
					email=data['payer_email'].replace('%40','@')
					id = db.gift_msg.insert(buyer=data['payer_email'],
						transact=trans,msg=form.vars.message)
					response.flash=T('Your message will be passed on to the
						recipient')
					redirect(URL('index'))
					
				return dict(data=data,form=form)
		return dict(data=data)
	else:
		data['status']='FAIL'
else:
	redirect(URL('index'))
return dict(trans=trans)
</pre></div><p>Just for the sake of completeness, I am adding a very basic example of<code class="literal"> confirm.html</code>, which you can see in the listing<code class="literal"> lst:confirmhtml</code>.<a id="id254" class="indexterm"/>
</p><div><pre class="programlisting">
{{extend 'layout.html'}}

{{if data['status'] == 'SUCCESS':}}
&lt;p&gt;&lt;h3&gt;{{=T('Your order has been received.')}}&lt;/h3&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;b&gt;{{=T('Details')}}&lt;/b&gt;&lt;br&gt;
&lt;li&gt;
	{{=T('Name:')}} {{=data['first_name']}} {{=data['last_name']}}
&lt;/li&gt;
&lt;li&gt;'
	{{=T('Purchases for event:')}}: {{=data['transaction_subject']}}
&lt;/li&gt;
&lt;li&gt;
	{{=T('Amount')}}: {{=data['mc_currency']}} {{=data['mc_gross']}}
&lt;/li&gt;
&lt;hr&gt;
{{=form}}
{{else:}}
{{=T('No confirmation received from PayPal. This can be due to a
	number of reasons; please check your email to see if the
	transaction was successful.')}}
{{pass}}

{{=T('Your transaction has finished, you should receive an email of
	your purchase.')}}&lt;br&gt;
{{=T('If you have an account at PayPal, you can check your
	transaction details at')}}
	&lt;a href='https://www.paypal.es'&gt;www.paypal.es&lt;/a&gt;
</pre></div><p>
<strong>Instant Payment Notification (IPN)</strong> : As mentioned before, one cannot trust the PDT process to receive the information from all transactions, as a great number of things can happen. Thus, you need to implement an additional process, if you need to do additional processing of the information from your sales, or if you want to keep a local database of the actual sales processed.</p><p>This is done with IPN. You can find all the related documentation at the documentation site URL given previously. You will need to turn on the IPN functionality at your seller account, as well as give a default URL to receive those messages, which should be equal to the view in which you process them. In the case of this example, it would be:<a class="ulink" href="http://www.yourdomain.com/yourapp/default/ipn_handler">http://www.yourdomain.com/yourapp/default/ipn_handler</a>&gt;.</p><p>The process is quite similar to that of PDT; even the variables are the same. The main difference is that IPNs are sent from PayPal, until you acknowledge them. The view for this function,<code class="literal"> default/ipn_handler.html</code>, can very well be left blank. I am also including the table definition for logging the messages from PayPal.</p><p>Anyway, you can find in the listing<code class="literal"> lst:ipnhandler</code>, an example of how to set them up:</p><div><pre class="programlisting">
#### At models/db.py
#####################################################################
db.define_table('ipn_msgs',
	Field('trans_id',label=T('transaction id')),
	Field('timestamp','datetime',label=T('timestamp')),
	Field('type',label=T('type')),
	Field('msg','text',label=T('message')),
	Field('processed','boolean',label=T('processed')),
	Field('total','double',label=T('total')),
	Field('fee','double',label=T('fee')),
	Field('currency',length=3,label=T('currency')),
	Field('security_msg',label=T('security message'))
)

#### At controllers/default.py
#####################################################################
def ipn_handler():
	"""
		Manages the ipn connection with PayPal
		Ask PayPal to confirm this payment, return status and detail strings
	"""
	parameters = None
	parameters = request.vars
	if parameters:
		parameters['cmd'] = '_notify-validate'
		params = urllib.urlencode(parameters)
		conn = Connection(base_url=protocol+domain, username=user,
			password = passwd, realm = realm, header = headers)
		resp,error =conn.request('/cgi-bin/webscr', params)
		timestamp=datetime.datetime.now()
		# We are going to log all messages confirmed by PayPal.
		if error =='':
		ipn_msg_id = db.ipn_msgs.insert(trans_id=parameters['txn_id'],
			timestamp=timestamp,type=resp.read(),msg=params,
			total=parameters['mc_gross'],fee=parameters['mc_fee'],
			currency=parameters['mc_currency'])
		# But only interested in processing messages that have payment
		#status completed and are VERIFIED by PayPal.
		if parameters['payment_status']=='Completed':
			process_ipn(ipn_msg_id,parameters)
</pre></div><p>The only thing missing would be to process the information received, and check for errors or possible fraud attempts. You can see an example function in the listing<code class="literal"> lst:processipn</code>. Although this is probably something that would change quite a bit from one project to the next, I hope that it may serve you as a rough guide.</p><div><pre class="programlisting">
def process_ipn(ipn_msg_id,param):
	"""
		We process the parameters sent from IPN PayPal, to correctly
		store the confirmed sales in the database.
		param -- request.vars from IPN message from PayPal
	"""
	# Check if transaction_id has already been processed.
	query1 = db.ipn_msgs.trans_id==param['txn_id']
	query2 = db.ipn_msgs.processed == True
	rows = db(query1 &amp; query2).select()
	if not rows:
		trans = param['txn_id']
		payer_email = param['payer_email']
		n_items = int(param['num_cart_items'])
		pay_date = param['payment_date']
		total = param['mc_gross']
		curr = param['mc_currency']
		event_code = param['custom']
		if param.has_key('memo'): memo=param['memo']
		event_id = db(db.event.code==event_code).select(db.event.id)
		if not event_id:
			db.ipn_msgs[ipn_msg_id]=dict(security_msg=T('Event does not
				exist'))
		else:
			error=False
			for i in range(1,n_items+1):
				product_code = param['item_number'+str(i)]
				qtty = param['quantity'+str(i)]
				line_total = float(param['mc_gross_'+str(i)]) +
					float(param['mc_tax'+str(i)])
				product=db(db.product.ext_code==product_code).
					select(db.product.id)
				if not product:
					db.ipn_msgs[ipn_msg_id]=dict(security_msg=T('Product code
						does not exist'))
					error=True
				else:
					db.glist.insert(event=event_id[0],product=product[0],
						buyer=payer_email,transact=trans,
						purchase_date=pay_date,quantity_sold=qtty,
						price=line_total,observations=memo)
			if not error: db.ipn_msgs[ipn_msg_id]=dict(processed=True)
</pre></div><p>Hope that this section helped you to set up your PayPal site using web2py, or at least, helped you understand the basic concepts behind setting up one, and the different possibilities that you have available.</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec07"/>PayPal web payments standard</h1></div></div></div><p>This recipe shows an implementation of the PayPal web payments standard, using both encrypted requests and IPN for a secure process workflow. Note that in this recipe, web2py version 1.77.3 is used. Hopefully, it still works in the latest web2py versions.<a id="id255" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec13"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>To implement our integration with PayPal, I started with putting together the code that generates an encrypted form post to PayPal, for all of our cart actions. If you do this, and you configure PayPal to only accept signed requests, then the user cannot tamper with your form and change the price of an item. To do this, I installed the<strong> M2Crypto</strong> module on our system, and created a module that will do the signing of the PayPal forms. Note that this does not work on the Google App Engine, because M2Crypto does not run on GAE.<a id="id256" class="indexterm"/>
</p><p>I have yet to find a replacement for it that runs on the App Engine, so you cannot use this PayPal payments recipe in that environment.
</p><p>The encryption module (<code class="literal">crypt.py</code>) uses the certificate to sign the data and then encrypts it, as shown in the following code:
<a id="id257" class="indexterm"/>
</p><div><pre class="programlisting">
from M2Crypto import BIO, SMIME, X509, EVP

def paypal_encrypt(attributes, sitesettings):
	"""
	Takes a list of attributes for working with PayPal (in our
	case adding to the shopping cart), and encrypts them for
	secure transmission of item details and prices.
	@type attributes: dictionary
	@param attributes: a dictionary of the PayPal request
		attributes. An
		example attribute set is:
		
		&gt;&gt;&gt; attributes = {"cert_id":sitesettings.paypal_cert_id,
			"cmd":"_cart",
			"business":sitesettings.cart_business,
			"add":"1",
			"custom":auth.user.id,
			"item_name":"song 1 test",
			"item_number":"song-1",
			"amount":"0.99",
			"currency_code":"USD",
			"shopping_url":'http://'+\
				Storage(globals()).request.env.http_host+\
				URL(args=request.args),
			"return":'http://'+\
				Storage(globals()).request.env.http_host+\
				URL('account', 'downloads'),
		}
		
	@type sitesettings: SQLStorage
	@param sitesettings: The settings stored in the database.
		this method
		requires I{tenthrow_private_key}, I{tenthrow_public_cert},
	  and I{paypal_public_cert} to function
	@rtype: string
	@return: encrypted attribute string
"""

plaintext = ''

for key, value in attributes.items():
	plaintext += u'%s=%s\n' % (key, value)
	
plaintext = plaintext.encode('utf-8')

# Instantiate an SMIME object.
s = SMIME.SMIME()

# Load signer's key and cert. Sign the buffer.
s.pkey = EVP.load_key_string(sitesettings.tenthrow_private_key)
s.x509 = X509.load_cert_string(
	sitesettings.tenthrow_public_cert)
	
#s.load_key_bio(BIO.openfile(settings.MY_KEYPAIR),
# 			BIO.openfile(settings.MY_CERT))

p7 = s.sign(BIO.MemoryBuffer(plaintext),
	flags=SMIME.PKCS7_BINARY)
	
# Load target cert to encrypt the signed message to.
#x509 = X509.load_cert_bio(BIO.openfile(settings.PAYPAL_CERT))
x509 = X509.load_cert_string(sitesettings.paypal_public_cert)

sk = X509.X509_Stack()
sk.push(x509)
s.set_x509_stack(sk)

# Set cipher: 3-key triple-DES in CBC mode.
s.set_cipher(SMIME.Cipher('des_ede3_cbc'))

# Create a temporary buffer.
tmp = BIO.MemoryBuffer()

# Write the signed message into the temporary buffer.
p7.write_der(tmp)

# Encrypt the temporary buffer.
p7 = s.encrypt(tmp, flags=SMIME.PKCS7_BINARY)

# Output p7 in mail-friendly format.
out = BIO.MemoryBuffer()
p7.write(out)

return out.read()
</pre></div></li><li class="listitem"><p>Then, we construct forms in our view, and encrypt them:<a id="id258" class="indexterm"/>
</p><div><pre class="programlisting">
{{from applications.tenthrow.modules.crypt import * }}

{{ 		attributes = {"cert_id":sitesettings.paypal_cert_id,
	"cmd":"_cart",
	"business":sitesettings.cart_business,
	"add":"1",
	"custom":auth.user.id,
	"item_name":artist_name + ": " + song['name'],
	"item_number":"song-"+str(song['cue_point_id']),
	"amount":song['cost'],
	"currency_code":"USD",
	"shopping_url":full_url('http',r=request,args=request.args),
	"return":full_url('https', r=request, c='account', \
	f='alldownloads'),
   }
	encattrs = paypal_encrypt(attributes, sitesettings)
  }}
  &lt;form target="_self"
	action="{{=sitesettings.cart_url}}" method="post"
	name="song{{=song['cue_point_id']}}"&gt;
	&lt;!-- Identify your business so that you can collect the
		payments. --&gt;
	&lt;input type="hidden" name="cmd" value="_s-xclick"
		class="unform"/&gt;
	&lt;input type="hidden" name="encrypted" value="{{=encattrs}}"
		class="unform"/&gt;
	&lt;a onclick="document.song{{=song['cue_point_id']}}.submit()"
		class="trBtn"&gt;
		&lt;img src="img/trIconDL.png')}}"
			alt="Download {{=(song['name'])}}" class="original"/&gt;
		&lt;img src="img/trIconDL_Hover.png')}}"
			alt="Download {{=(song['name'])}}" class="hover"/&gt;
	&lt;/a&gt;
	&lt;img alt="" border="0" width="1" height="1"
		src="img/pixel.gif"
		class="unform"/&gt;
  &lt;/form&gt;
</pre></div><p>Note that the above code calls a method full_url(), which is defined as follows:
<a id="id259" class="indexterm"/>
</p><div><pre class="programlisting">
def full_url(scheme="http",
	a=None,
	c=None,
	f=None,
	r=None,
	args=[],
	vars={},
	anchor='',
	path = None
):
	"""
		Create a fully qualified URL. The URL will use the same host
		that the request
		was made from, but will use the specified scheme.
		Calls
		C{gluon.html.URL()} to construct the relative path to the
		host.
		
		if &lt;scheme&gt;_port is set in the settings table, append the port
		to the domain of the created URL
		
		@param scheme: scheme to use for the fully-qualified URL.
			(default to 'http')
		@param a: application (default to current if r is given)
		@param c: controller (default to current if r is given)
		@param f: function (default to current if r is given)
		@param r: request
		@param args: any arguments (optional)
		@param vars: any variables (optional)
		@param anchor: anchorname, without # (optional)
		@param path: the relative path to use. if used overrides
			a,c,f,args, and
			vars (optional)
	"""
	port = ''
	if sitesettings.has_key(scheme+"_port") and
		sitesettings[scheme+"_port"]:
			port = ":" + sitesettings[scheme+"_port"]
		if scheme == 'https' and sitesettings.has_key("https_scheme"):
			scheme = sitesettings.https_scheme
		url = scheme +'://' + \
			r.env.http_host.split(':')[0] + port
		if path:
			url = url + path
		else:
			url = url+URL(a=a, c=c, f=f, r=r, args=args, vars=vars,
				anchor=anchor)
		return url
</pre></div></li><li class="listitem"><p>Then, I need to be able to process our IPN responses from PayPal. The following code does just that. You'll see that I only process purchase requests. I also left in the code that is specific to our database, about how I code product IDs, and then use that product ID to create records in our database. Based on the existence of those purchase records in our database, I allow the user to download the files that they purchased. So, the user cannot download their purchase until the IPN message is processed. This is usually 5 to 30 seconds after they submitted the order. Most of the time, the messages are received and processed before PayPal redirects the user back to our site. Our<code class="literal"> paypal.py</code> controller will have a function to process the instant payment notification, as described in the following code section, (note that we have<code class="literal"> openanything</code> in our modules directory. Visit<a class="ulink" href="http://diveintopython.org/">http://diveintopython.org/</a> for the latest version):<a id="id260" class="indexterm"/>
</p><div><pre class="programlisting">
from applications.app.modules.openanything import *

def ipn():
	"""
	This controller processes Instant Payment Notifications from
	PayPal.
	It will verify messages, and process completed cart transaction
	messages
	only. all other messages are ignored for now.
	
	For each item purchased in the cart, the song_purchases table
	will be
	updated with the purchased item information, allowing the user 
	to
	download the item.
	
	logs are written to /tmp/ipnresp.txt
	
	the PayPal IPN documentation is available at:
	https://cms.paypal.com/cms_content/US/en_US/files/developer/
		IPNGuide.pdf
	"""
	"""
	sample PayPal IPN call:
	
	last_name=Smith&amp;
	txn_id=597202352&amp;
	receiver_email=seller%40paypalsandbox.com&amp;
	payment_status=Completed&amp;tax=2.02&amp;
	mc_gross1=12.34&amp;
	payer_status=verified&amp;
	residence_country=US&amp;
	invoice=abc1234&amp;
	item_name1=something&amp;
	txn_type=cart&amp;
	item_number1=201&amp;
	quantity1=1&amp;
	payment_date=16%3A52%3A59+Jul.+20%2C+2009+PDT&amp;
	first_name=John&amp;
	mc_shipping=3.02&amp;
	charset=windows-1252&amp;
	custom=3&amp;
	notify_version=2.4&amp;
	test_ipn=1&amp;
	receiver_id=TESTSELLERID1&amp;
	business=seller%40paypalsandbox.com&amp;
	mc_handling1=1.67&amp;
	payer_id=TESTBUYERID01&amp;
	verify_sign=AFcWxV21C7fd0v3bYYYRCpSSRl31AtrKNnsnrW3-8M8R-
		P38QFsqBaQM&amp;
	mc_handling=2.06&amp;
	mc_fee=0.44&amp;
	mc_currency=USD&amp;
	payer_email=buyer%40paypalsandbox.com&amp;
	payment_type=instant&amp;
	mc_gross=15.34&amp;
	mc_shipping1=1.02
"""

#@todo: come up with better logging mechanism
logfile = "/tmp/ipnresp.txt"

verifyurl = "https://www.paypal.com/cgi-bin/webscr"
if request.vars.test_ipn != None and request.vars.test_ipn ==
	'1':
	verifyurl = "https://www.sandbox.paypal.com/cgi-bin/webscr"
	
	params = dict(request.vars)
	params['cmd'] = '_notify-validate'
	resp = fetch(verifyurl, post_data=params)
	
#the message was not verified, fail
if resp['data'] != "VERIFIED":
	#@todo: figure out how to fail
	f = open(logfile, "a")
	f.write("Message not verified:\n")
	f.write(repr(params) + "\n\n")
	f.close()
	return None
...
if request.vars.txn_type != "cart":
	#for now ignore non-cart transaction messages
	f = open(logfile, "a")
	f.write("Not a cart message:\n")
	f.write(repr(params) + "\n\n")
	f.close()
	return None
...
if request.vars.payment_status != 'Completed':
	#ignore pending transactions
	f = open(logfile, "a")
	f.write("Ignore pending transaction:\n")
	f.write(repr(params) + "\n\n")
	f.close()
	return None
...
#check id not recorded
if len(db(db.song_purchases.transaction_id==request.
	vars.txn_id).select())&gt;0:
	#transaction already recorded
	f = open(logfile, "a")
	f.write("Ignoring recorded transaction:\n")
	f.write(repr(params) + "\n\n")
	f.close()
	return None
	
		#record transaction
		num_items = 1
		if request.vars.num_cart_items != None:
			num_items = request.vars.num_cart_items
			
		for i in range(1, int(num_items)+1):
			#i coded our item_number to be a tag and an ID. the ID is
			# a key to a table in our database.
			tag, id = request.vars['item_number'+str(i)].split("-")
			if tag == "song":
				db.song_purchases.insert(auth_user=request.vars.custom,
				cue_point=id,
				transaction_id=request.vars.txn_id,
				date=request.vars.payment_date.replace('.', ''))
				
			elif tag == "song_media":
				db.song_purchases.insert(auth_user=request.vars.custom,
					song_media=id,
					transaction_id=request.vars.txn_id,
					date=request.vars.payment_date.replace('.', ''))
					
			elif tag == "concert":
				db.concert_purchases.insert(auth_user=request.vars.custom,
					playlist=id,
					transaction_id=request.vars.txn_id,
					date=request.vars.payment_date.replace('.', ''))
			else:
				#@TODO: this is an error, what should we do here?
				f = open(logfile, "a")
				f.write("Ignoring bad item number: " + \
					request.vars['item_number'+str(i)] + "\n")
				f.write(repr(params) + "\n\n")
				f.close()
				
		f = open(logfile, "a")
		f.write("Processed message:\n")
		f.write(repr(params) + "\n\n")
		f.close()
	return None
</pre></div></li></ol></div><p>That's all, folks!<a id="id261" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec08"/>Getting Flickr photos</h1></div></div></div><p>This recipe can be used to get a list of Flickr photos passing the photoset ID.<a id="id262" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec14"/>Getting ready</h2></div></div></div><p>First you need to generate an<strong> APIKEY</strong>, which you can do on the Flickr developers page:<a id="id263" class="indexterm"/>
</p><p>
<a class="ulink" href="http://www.flickr.com/services/api/misc.api_keys.html">http://www.flickr.com/services/api/misc.api_keys.html</a>
</p><p>After that, you need to create a function to fetch the Flickr API. Generally, this is created in models, but you can do that in modules too.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec15"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>Create a function in any of your model files. We will create one called<code class="literal"> models/plugin_flickr.py</code>, as follows:<a id="id264" class="indexterm"/>
</p><div><pre class="programlisting">
def plugin_flickr(key, photoset=None, per_page=15, page=1):
	from urllib2 import urlopen
	from xml.dom.minidom import parse as domparse
	apiurl = 'http://api.flickr.com/services/rest/?method=flickr.
		photosets.getPhotos&amp;api_key=%(apikey)s&amp;photoset_id=
		%(photoset)s&amp;privacy_filter=1&amp;per_page=%(per_page)s&amp;page=
		%(page)s&amp;extras=url_t,url_m,url_o,url_sq'

	dom = domparse(urlopen(apiurl % dict(photoset=photoset,
		per_page=per_page, page=page, apikey=key)))
		
	photos = []
	
	for node in dom.getElementsByTagName('photo'):
		photos.append({
		'id':node.getAttribute('id'),
		'title':node.getAttribute('title'),
		'thumb':node.getAttribute('url_t'),
		'medio':node.getAttribute('url_m'),
		'original':node.getAttribute('url_o'),
		'square':node.getAttribute('url_sq'),
		})
	
	return photos
</pre></div></li><li class="listitem"><p>Now you can call that function from any controller or view. For example, in a controller action, as follows:<a id="id265" class="indexterm"/>
</p><div><pre class="programlisting">
def testflickr():
	photos = plugin_flickr(
		key='YOUR_API_KEY',
		photoset='THE_PHOTOSET_ID',
		per_page=15,
		page=1)
	return dict(photos=photos)
</pre></div></li><li class="listitem"><p>In the associated<code class="literal"> views/defaul/testflickr.html</code>, you can add the following:</p><div><pre class="programlisting">
{{extend 'layout.html'}}

{{for photo in photos:}}
	{{=IMG(_src=photo['square'])}}
{{pass}}
</pre></div><p>The final product will look like the one shown in the following screenshot:
</p></li></ol></div><div><img src="img/5467OS_07_40.jpg" alt="How to do it..."/></div></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec09"/>Sending e-mails with Boto through Amazon Web Services (AWS)</h1></div></div></div><p>
<strong>Amazon Simple Email Service</strong> is a nice way to send e-mails without needing to operate your own mail server. This code utilizes the<code class="literal"> Boto</code> library, which is a Python interface for AWS.<a id="id266" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec16"/>Getting ready</h2></div></div></div><div><ol class="orderedlist"><li class="listitem"><p>First of all, you need to sign up for AWS at<a class="ulink" href="http://aws.amazon.com"> http://aws.amazon.com</a>.</p></li><li class="listitem"><p>Then, enable Simple Email Service at<a class="ulink" href="http://aws.amazon.com/ses/"> http://aws.amazon.com/ses/</a>.</p></li><li class="listitem"><p>You need to obtain your Amazon<code class="literal"> AWS-KEY</code> and<code class="literal"> AWS-SECRET-KEY</code> from<a class="ulink" href="http://https://aws-portal.amazon.com/gp/aws/developer/account/index.html"> https://aws-portal.amazon.com/gp/aws/developer/account/index.html</a>.</p></li><li class="listitem"><p>Finally, you need to install Boto in your<code class="literal"> web2py/site-packages</code> folder, or anywhere in your path, so that web2py can find and import it. You can find Boto on GitHub:<a class="ulink" href="http://https://github.com/boto/boto"> https://github.com/boto/boto</a>.</p></li></ol></div><p>Before you get<strong> production</strong> access to Amazon's mail servers, you have to pre-register every sender's and recipient's e-mail address that you want to use (up to 100). This is OK for development and testing, but, of course, would not work in production. To register an e-mail address, execute the following code, replacing<code class="literal"> AWS-KEY</code> and<code class="literal"> AWS-SECRET-KEY</code> with your own keys, and<code class="literal"> myemail@address.com</code> with the e-mail address that you want to register.</p><p>From the web2py shell or any other Python shell, run the following:</p><div><pre class="programlisting">
from boto.ses.connection import SESConnection
	def verify_email_address():
		conn = SESConnection('', '')
		m = conn.verify_email_address('myemail@address.com')
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec17"/>How to do it...</h2></div></div></div><p>Assuming that everything is installed and configured, as explained before, sending e-mails is easy:<a id="id267" class="indexterm"/>
</p><div><pre class="programlisting">
def test_send_emails():
	aws_key = 'YOUR_AWS_KEY'
	aws_secret_key = 'YOUR_SECRET_KEY'
	from boto.ses.connection import SESConnection
	conn = SESConnection(aws_key, aws_secret_key)
	return conn.send_email(source='myemail@address.com',
		subject='Subject',
		body='Body.',
		to_addresses='recipient@email.com',
		cc_addresses=None,
		bcc_addresses=None,
		format='text',
		reply_addresses=None,
		return_path=None)
</pre></div></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec10"/>Making GIS amps using mapscript</h1></div></div></div><p>
<strong>MapServer</strong> is an open source platform for publishing spatial data and interactive mapping applications to the web. Originally developed in the mid-1990s at the University of Minnesota, MapServer is released under an MIT-style license, and runs on all major platforms.<a id="id268" class="indexterm"/>
</p><p>This recipe will show you how to publish geo-referenced maps using the MapServer web service, using a library called<code class="literal"> mapscript</code>.<a id="id269" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec18"/>Getting ready</h2></div></div></div><p>First, you need to install<code class="literal"> mapscript</code> from:</p><p>
<a class="ulink" href="http://pypi.python.org/pypi/mapscript/5.4.2.1">http://pypi.python.org/pypi/mapscript/5.4.2.1</a>.</p><p>You can do it by typing the following command:</p><div><pre class="programlisting"><strong>easy_install mapscript</strong>
</pre></div><p>We will also assume you have a map called<code class="literal"> private/test2.map</code> in your application folder. A<code class="literal"> .map</code> file looks in an<code class="literal"> ascii</code> file that describes a map (coordinates, type, points with tags, and so on), and looks like the following:</p><div><pre class="programlisting">
MAP
	NAME "sample"
	EXTENT -180 -90 180 90 # Geographic
	SIZE 800 400
	IMAGECOLOR 128 128 255
END # MAP
</pre></div><p>You can read more about map files here:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<a class="ulink" href="http://mapserver.org/introduction.html">http://mapserver.org/introduction.html</a>
</p></li><li class="listitem"><p>
<a class="ulink" href="http://mapserver.org/mapfile/index.html#mapfile">http://mapserver.org/mapfile/index.html#mapfile</a>
</p></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec19"/>How to do it...</h2></div></div></div><p>GIS maps are exposed through WXS services. Here, we show you a simple action that provides a service to publish a map stored in the file<code class="literal"> private/test2.map:</code>
<a id="id270" class="indexterm"/>
</p><div><pre class="programlisting">
def wxs():
	import mapscript
	import os
	path_map = os.path.join(request.folder, 'private', request.args(0))
	if not request.vars:
		return ''
	req = mapscript.OWSRequest()
	for v in request.vars:
		req.setParameter(v, request.vars[v])
		
	map = mapscript.mapObj(path_map)
	mapscript.msIO_installStdoutToBuffer()
	map.OWSDispatch(req)
	
	content_type = mapscript.msIO_stripStdoutBufferContentType()
	content = mapscript.msIO_getStdoutBufferBytes()
	response.header = "Content-Type","%s; charset=utf-8"%content_type
	return content
</pre></div><p>This service can be consumed by QGis (<a class="ulink" href="http://www.qgis.org/">http://www.qgis.org/</a>), or any other Web MapService client (<a class="ulink" href="http://en.wikipedia.org/wiki/Web_Map_Service">http://en.wikipedia.org/wiki/Web_Map_Service</a>), or a Web Feature Service client (<a class="ulink" href="http://en.wikipedia.org/wiki/Web_Feature_Service">http://en.wikipedia.org/wiki/Web_Feature_Service</a>).<a id="id271" class="indexterm"/>
</p><p>The URL to pass to QGIS is:</p><p>
<code class="literal">http://localhost:8000/mapas/default/wxs/test2.map</code>
</p><p>Here,<code class="literal"> test2.map</code> points to our map file (stored in the file,<code class="literal"> private/test2.map</code>, served by the<code class="literal"> wxs</code> function as described before).<a id="id272" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec11"/>Google groups and Google code feeds reader</h1></div></div></div><p>In this recipe, we will implement a simple feed reader to retrieve messages from Google Groups and Google Code using RSS.<a id="id273" class="indexterm"/>
</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec20"/>How to do it...</h2></div></div></div><p>We will create a file<code class="literal"> models/plugin_feedreader.py</code>, with the following code:</p><div><pre class="programlisting">
def plugin_feedreader(name, source='google-group'):
	"""parse group feeds"""
	from gluon.contrib import feedparser
	if source=='google-group':
		URL = "http://groups.google.com/group/%(name)s/
			feed/rss_v2_0_msgs.xml"
			
	elif source=='google-code':
		URL = "http://code.google.com/feeds/p/%(name)s/hgchanges/basic"
		
	else:
		URL = source
		
	url = URL % dict(name=name)
	g = feedparser.parse(url)
	html = UL(*[LI(A(entry['title'],_href=entry['link']))\
		for entry in g['entries'][0:5]])
	return XML(html)
</pre></div><p>Now, in any controller, you can embed the latest Google group information:</p><div><pre class="programlisting">{{=plugin_feedreader('web2py', source='google-group')}}
</pre></div><p>Or read the latest Google code source updates:</p><div><pre class="programlisting">{{=plugin_feedreader('web2py', source='google-code')}}
</pre></div></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec12"/>Creating SOAP web services</h1></div></div></div><p>
<strong>Simple Object Access Protocol  (SOAP)</strong> is a complex XML-based inter-process communication standard for web service implementation. It is widely used with legacy applications (especially JAVA and .NET languages), and supports type declaration and<strong> Web Service Definition File (WSDL)</strong> .<a id="id274" class="indexterm"/>
</p><p>web2py already supports a common infrastructure to expose web services in a simple way, using the<strong> Service</strong> tool (rss, json, jsonrpc, xmlrpc, jsonrpc, amfrpc, and amfrpc3).</p><p>The<code class="literal"> PySimpleSOAP</code> library included in<code class="literal"> gluon/contribs</code> (since version #1.82.1), aims to add SOAP support, extending the current philosophy.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec21"/>How to do it...</h2></div></div></div><p>Serving operations using SOAP is as easy as decorating a function using<code class="literal"> @service.soap</code>, declaring the following:<a id="id275" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>Exposed operation method (camel case by convention)</p></li><li class="listitem"><p>Return types</p></li><li class="listitem"><p>Parameters types</p></li></ul></div><p>Types are declared using a dictionary, mapping the parameter/result name with the standard Python conversion functions (str,<strong> int, float, bool</strong>, and so on).</p><p>For example, create an application (such as<code class="literal"> webservices)</code>, and in a controller (sample.py), add the following code:</p><div><pre class="programlisting">
from gluon.tools import Service
service = Service(globals())

@service.xmlrpc
@service.soap('AddStrings',returns={'AddResult':str},
							args={'a':str, 'b':str})
							
@service.soap('AddIntegers',returns={'AddResult':int},
							args={'a':int, 'b':int})
def add(a,b):
	"Add two values"
	return a+b
	
@service.xmlrpc
@service.soap('SubIntegers',returns={'SubResult':int},
							args={'a':int, 'b':int})
def sub(a,b):
	"Substract two values"
	return a-b
	
def call():
	return service()
</pre></div><p>Additionally, web2py can dynamically generate help web pages (list of operations, xml message examples), and the WSDL XML:</p><div><ul class="itemizedlist"><li class="listitem"><p>List of operations:<a class="ulink" href="http://127.0.0.1:8000/webservices/sample/call/soap"> http://127.0.0.1:8000/webservices/sample/call/soap</a>
<a id="id276" class="indexterm"/>
</p></li><li class="listitem"><p>Operation help (for the<code class="literal"> SubIntegers</code> method, in this case):<a class="ulink" href="http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers"> http://127.0.0.1:8000/webservices/sample/call/soap?op=SubIntegers</a>
<a id="id277" class="indexterm"/>
</p></li><li class="listitem"><p>Service description (WSDL ):<a class="ulink" href="http://127.0.0.1:8000/webservices/sample/call/soap?wsdl"> http://127.0.0.1:8000/webservices/sample/call/soap?wsdl</a>
<a id="id278" class="indexterm"/>
</p></li></ul></div><p>Sample operations list page:<a id="id279" class="indexterm"/>
</p><div><pre class="programlisting">
Welcome to Web2Py SOAP webservice gateway

The following operations are available

See WSDL for webservice description

AddIntegers: Add two values
SubIntegers: Substract two values
AddStrings: Add two values
Notes: WSDL is linked to URL retriving the full xml. Each operation
is linked to its help page.
</pre></div><p>Sample operation help page:<a id="id280" class="indexterm"/>
</p><div><pre class="programlisting">
AddIntegers

Add two values

Location: http://127.0.0.1:8000//webservices/sample/call/soap
Namespace: http://127.0.0.1:8000/webservices/sample/soap
SoapAction?: -N/A by now-
Sample SOAP XML Request Message:

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;soap:Envelope
	&gt;
	&lt;soap:Body&gt;
		&lt;AddIntegers
			&gt;
		&lt;a&gt;
			&lt;!--integer--&gt;
		&lt;/a&gt;
		&lt;b&gt;
			&lt;!--integer--&gt;
		&lt;/b&gt;
	&lt;/AddIntegers&gt;
	&lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
Sample SOAP XML Response Message:

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
	&lt;soap:Envelope
		&gt;
	&lt;soap:Body&gt;
		&lt;AddIntegersResponse
			&gt;
			&lt;AddResult&gt;
				&lt;!--integer--&gt;
			&lt;/AddResult&gt;
		&lt;/AddIntegersResponse&gt;
	&lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
<a id="id281" class="indexterm"/>
</pre></div><p>You can test the web service exposed by web2py using this library:</p><div><pre class="programlisting">
def test_soap_sub():
from gluon.contrib.pysimplesoap.client import SoapClient, SoapFault
# create a SOAP client
client = SoapClient(wsdl="http://localhost:8000/webservices/
	sample/call/soap?WSDL")
	
# call SOAP method
response = client.SubIntegers(a=3,b=2)

try:
	result = response['SubResult']
	
except SoapFault:
	result = None
return dict(xml_request=client.xml_request,
	xml_response=client.xml_response,
	result=result)
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec22"/>There's more...</h2></div></div></div><p>
<strong>pysimplesoap</strong> is included with recent releases of web2py, as it is being actively maintained. You can frequently check the version to find enhancements, to extend this recipe.<a id="id282" class="indexterm"/>
</p><p>Although there are several python SOAP libraries, this one is designed to be as simple as possible, and is totally integrated with web2py.</p><p>For more information, supported features, and platforms, have a look at the following link:<a id="id283" class="indexterm"/>
</p><p>
<a class="ulink" href="http://code.google.com/p/pysimplesoap/wiki/Web2Py">http://code.google.com/p/pysimplesoap/wiki/Web2Py</a>
</p><div><h3 class="title"><a id="note06"/>Note</h3><p>To view help pages for the latest web2py versions, you should create a view, sample/call.html, in this example, as in new versions of web2py, for security reasons, generic views are not exposed by default</p></div><div><pre class="programlisting">{{extend 'layout.html'}}
{{for tag in body:}}
{{=tag}}
{{pass}}
</pre></div></div></div></div></div>
</body></html>