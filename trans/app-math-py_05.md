处理树和网络

网络是包含*n**odes*和节点对之间的*edges*的对象。它们可以用来表示各种真实世界的情况，如分布和调度。在数学上，网络对于可视化组合问题非常有用，并且构成了一个丰富而迷人的理论。

当然，有几种不同类型的网络。我们将主要处理简单的网络，其中边连接两个不同的节点（因此没有自环），任何两个节点之间最多只有一条边，并且所有边都是双向的。*树*是一种特殊类型的网络，其中没有循环；也就是说，没有节点列表，其中每个节点都通过一条边连接到下一个节点，并且最后一个节点连接到第一个节点。树在理论上特别简单，因为它们用尽可能少的边连接了许多节点。*完全网络*是一种网络，其中每个节点都通过一条边连接到其他每个节点。

网络可以是有向的，其中每条边都有源节点和目标节点，或者可以携带额外的属性，如权重。在某些应用中，加权网络特别有用。还有一些网络，我们允许两个给定节点之间有多条边。

在本章中，我们将学习如何创建、操作和分析网络，然后应用网络算法来解决各种问题。

在文献中，特别是在数学文本中，网络更常被称为*图*。节点有时被称为*顶点*。我们更倾向于使用术语网络，以避免与图常用于表示函数图的更常见用法混淆。

在本章中，我们将涵盖以下配方：

+   在 Python 中创建网络

+   可视化网络

+   获取网络的基本特征

+   为网络生成邻接矩阵

+   创建有向和加权网络

+   在网络中查找最短路径

+   量化网络中的聚类

+   给网络着色

+   查找最小生成树和支配集

让我们开始吧！

# 技术要求

在本章中，我们将主要使用 NetworkX 包来处理树和网络。可以使用您喜欢的软件包管理器（如`pip`）安装此软件包：

```py
          python3.8 -m pip install networkx

```

通常，我们按照官方 NetworkX 文档中建立的约定，将其别名为`nx`导入：

```py
import networkx as nx
```

本章的代码可以在 GitHub 存储库的`Chapter 05`文件夹中找到：[`github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005`](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2005)。

查看以下视频以查看代码的实际操作：[`bit.ly/2WJQt4p`](https://bit.ly/2WJQt4p)。

# 在 Python 中创建网络

为了解决可以表示为网络问题的多种问题，我们首先需要一种在 Python 中创建网络的方法。为此，我们将利用 NetworkX 包及其提供的例程和类来创建、操作和分析网络。

在这个示例中，我们将创建一个代表网络的 Python 对象，并向该对象添加节点和边。

## 准备工作

正如我们在*技术要求*部分中提到的，我们需要导入 NetworkX 包，并使用以下`import`语句将其别名为`nx`：

```py
import networkx as nx
```

## 如何做...

按照以下步骤创建简单图的 Python 表示形式：

1.  我们需要创建一个将存储构成图的节点和边的新`Graph`对象：

```py
G = nx.Graph()
```

1.  接下来，我们需要使用`add_node`方法为网络添加节点：

```py
G.add_node(1)
G.add_node(2)
```

1.  为了避免重复调用此方法，我们可以使用`add_nodes_from`方法从可迭代对象（如列表）中添加节点：

```py
G.add_nodes_from([3, 4, 5, 6])
```

1.  接下来，我们需要使用`add_edge`方法或`add_edges_from`方法在我们添加的节点之间添加边，分别向网络添加单个边或边的列表（作为元组）：

```py
G.add_edge(1, 2)  # edge from 1 to 2
G.add_edges_from([(2, 3), (3, 4), (3, 5), (3, 6), (4, 5), (5, 6)])
```

1.  最后，通过访问`nodes`和`edges`属性，我们可以检索图中当前节点和边的视图：

```py
print(G.nodes)
print(G.edges)
# [1, 2, 3, 4, 5, 6]
# [(1, 2), (2, 3), (3, 4), (3, 5), (3, 6), (4, 5), (5, 6)]
```

## 工作原理...

NetworkX 软件包添加了几个类和例程，用于使用 Python 创建、操作和分析网络。`Graph`类是表示不包含任何给定节点之间多条边的网络的最基本类，其边是无向的（双向的）。

创建一个空的`Graph`对象后，我们可以使用本示例中描述的方法添加新节点和边。在这个示例中，我们创建了保存整数值的节点。然而，节点可以保存除`None`之外的任何可散列的 Python 对象。此外，可以通过传递给`add_node`方法的关键字参数向节点添加关联数据。在使用`add_nodes_from`方法时，还可以添加属性，方法是提供包含节点对象和属性字典的元组列表。`add_nodes_from`方法用于批量添加节点，而`add_node`用于将单个节点附加到现有网络。

网络中的边是包含两个（不同的）节点的元组。在简单网络中，例如基本的`Graph`类表示的网络中，任何两个给定节点之间最多只能有一条边。边是通过`add_edge`或`add_edges_from`方法添加的，分别向网络添加单个边或边的列表。与节点一样，边可以通过属性字典保存任意关联数据。特别是，可以通过在添加边时提供`weight`属性来添加权重。我们将在*创建有向和加权网络*中提供有关加权图的更多细节。

`nodes`和`edges`属性分别保存构成网络的节点和边。`nodes`属性返回一个`NodesView`对象，它是节点及其关联数据的类似字典的接口。类似地，`edges`属性返回一个`EdgeView`对象。这可以用于检查单个边及其关联数据。

## 还有更多...

`Graph`类表示*简单网络*，这些网络是指节点之间最多只有一条边相连，并且边是无向的。我们将在*创建有向和加权网络*中讨论有向网络。有一个单独的类用于表示节点对之间可以有多条边的网络，称为`MultiGraph`。所有网络类型都允许自环，这在文献中有时不允许在“简单网络”中，在那里简单网络通常指的是没有自环的无向网络。

所有网络类型都提供了各种方法来添加节点和边，以及检查当前节点和边。还有一些方法可以将网络复制到其他类型的网络中，或者提取子网络。NetworkX 软件包中还有几个实用程序例程，用于生成标准网络并将子网络添加到现有网络中。

NetworkX 还提供了各种例程，用于将网络读取和写入不同的文件格式，例如 GraphML、JSON 和 YAML。例如，我们可以使用`nx.write_graphml`例程将网络写入 GraphML 文件，并使用`nx.read_graphml`例程进行读取。

# 可视化网络

分析网络的常见第一步是绘制网络，这可以帮助我们识别网络的一些显著特征。（当然，绘图可能会产生误导，因此我们不应过分依赖它们进行分析。）

在这个示例中，我们将描述如何使用 NetworkX 软件包中的网络绘图工具来可视化网络。

## 准备工作

对于本示例，我们需要按照*技术要求*部分中描述的方式导入 NetworkX 包，并且还需要 Matplotlib 包。像往常一样，我们使用以下`import`语句将`pyplot`模块导入为`plt`：

```py
import matplotlib.pyplot as plt
```

## 如何做...

以下步骤概述了如何使用 NetworkX 的绘图例程绘制简单的网络对象：

1.  首先，我们创建一个简单的示例网络来绘制：

```py
G = nx.Graph()

G.add_nodes_from(range(1, 7))
G.add_edges_from([
    (1, 2), (2, 3), (3, 4), (3, 5), 
    (3, 6), (4, 5), (5, 6)
])
```

1.  接下来，我们为其创建新的 Matplotlib`Figure`和`Axes`对象，准备使用`plt`的`subplots`例程绘制网络：

```py
fig, ax = plt.subplots()
```

1.  现在，我们可以创建一个布局，用于在图上放置节点。对于这个图，我们将使用`shell_layout`例程使用壳布局：

```py
layout = nx.shell_layout(G)
```

1.  我们可以使用`draw`例程在图上绘制网络。由于我们已经创建了 Matplotlib 的`Figure`和`Axes`，我们将提供`ax`关键字参数。我们还将使用`with_labels`关键字参数为节点添加标签，并使用`pos`参数指定我们刚刚创建的布局：

```py
nx.draw(G, ax=ax, pos=layout, with_labels=True)
ax.set_title("Simple network drawing")
```

生成的绘图如下图所示：

![](img/4b625495-d1f5-44db-9a3e-dbb369a33298.png)图 5.1：使用壳布局排列的简单网络的绘图

## 工作原理...

`draw`例程是专门用于绘制网络的专用绘图例程。我们创建的布局指定了每个节点将被放置的坐标。我们使用了*壳布局*，它将节点排列在同心圆的布局中，这由网络的节点和边确定。默认情况下，`draw`例程会创建一个随机布局。

`draw`例程有许多关键字参数，用于自定义绘制网络的外观。在本示例中，我们添加了`with_labels`关键字参数，根据节点所持有的对象在图中标记节点。节点持有整数，这就是为什么前面的图中的节点被标记为整数。

我们还使用`plt.subplots`例程单独创建了一组坐标轴。这并不是严格必要的，因为如果没有提供，`draw`例程将自动创建新的图和坐标轴。

## 还有更多...

NetworkX 包提供了几种生成布局的例程，类似于我们在本示例中使用的`shell_layout`例程。布局简单地是一个由节点索引的字典，其元素是节点应该被绘制的位置的*x*和*y*坐标。NetworkX 用于创建布局的例程表示了对大多数情况有用的常见布局，但如果需要，您也可以创建自定义布局。不同布局创建例程的完整列表在 NetworkX 文档中提供。还有一些快捷绘图例程，它们将使用特定布局而无需单独创建布局；例如，`draw_shell`例程将使用与本示例中给出的`draw`调用等效的壳布局绘制网络。

`draw`例程接受许多关键字参数来自定义图形的外观。例如，有关键字参数来控制节点的大小、颜色、形状和透明度。我们还可以添加箭头（用于有向边）和/或仅从网络中绘制特定的节点和边。

# 获取网络的基本特征

网络具有各种基本特征，除了节点和边的数量之外，这些特征对于分析图形是有用的。例如，节点的*度*是以该节点为起点（或终点）的边的数量。较高的度表明该节点与网络的其余部分连接更好。

在本示例中，我们将学习如何访问基本属性并计算与网络相关的各种基本度量。

## 准备工作

像往常一样，我们需要将 NetworkX 包导入为`nx`。我们还需要将 Matplotlib 的`pyplot`模块导入为`plt`。

## 如何做...

按照以下步骤访问网络的各种基本特征：

1.  创建一个我们将在本示例中分析的示例网络，如下所示：

```py
G = nx.Graph()
G.add_nodes_from(range(10))
G.add_edges_from([
    (0, 1), (1, 2), (2, 3), (2, 4), 
    (2, 5), (3, 4), (4, 5), (6, 7),
    (6, 8), (6, 9), (7, 8), (8, 9)
])
```

1.  接下来，将网络绘制并将节点布置在圆形布局中是一个良好的做法：

```py
fig, ax = plt.subplots()
nx.draw_circular(G, ax=ax, with_labels=True)
ax.set_title("Simple network")
```

可以在下图中看到生成的图。正如我们所看到的，网络分为两个不同的部分：

![](img/c4e518ea-19a9-4785-bb2c-00494cf4da5a.png)图 5.2：以圆形排列绘制的简单网络。在这个网络中可以看到两个不同的组件

1.  接下来，我们使用`nx.info`例程显示有关网络的一些基本信息：

```py
print(nx.info(G))
# Name: 
# Type: Graph
# Number of nodes: 10
# Number of edges: 12
# Average degree: 2.4000
```

1.  现在，我们使用`Graph`对象的`degree`属性来检索特定节点的度：

```py
for i in [0, 2, 7]:
    degree = G.degree[i]
    print(f"Degree of {i}: {degree}")
# Degree of 0: 1
# Degree of 2: 4
# Degree of 7: 2
```

1.  我们可以使用`connected_components`例程获取网络的连接组件，它返回一个我们可以转换为列表的生成器：

```py
components = list(nx.connected_components(G))
print(components)
# [{0, 1, 2, 3, 4, 5}, {8, 9, 6, 7}]
```

1.  我们使用`density`例程计算网络的*密度*，它返回一个介于 0 和 1 之间的浮点数。这代表了满足节点的边与节点可能的总边数之间的比例：

```py
density = nx.density(G)
print("Density", density)
# Density 0.26666666666666666
```

1.  最后，我们可以使用`check_planarity`例程确定网络是否*平面*——意味着没有两条边需要绘制交叉——：

```py
is_planar, _ = nx.check_planarity(G)
print("Is planar", is_planar)
# Is planar True
```

## 工作原理...

`info`例程生成网络的一个小总结，包括网络的类型（在本示例中是简单的`Graph`类型），节点和边的数量，以及网络中节点的平均度。可以使用`degree`属性访问网络中节点的实际度，该属性提供类似字典的接口来查找每个节点的度。

如果一组节点中的每个节点都通过边或一系列边连接到其他节点，则称为连接的。网络的*连接组件*是连接的最大节点集。任何两个不同的连接组件显然是不相交的。每个网络可以分解为一个或多个连接的组件。我们在本示例中定义的网络有两个连接的组件，`{0, 1, 2, 3, 4, 5}`和`{8, 9, 6, 7}`。这些在前面的图中清晰可见，第一个连接的组件绘制在第二个连接的组件上方。在这个图中，我们可以沿着网络的边从一个组件中的任何节点到达另一个组件中的任何节点；例如，从 0 到 5。

网络的*密度*衡量了网络中边的数量与网络中节点数量给出的总可能边数之间的比率。完全网络的密度为 1，但一般情况下，密度会小于 1。

如果网络可以在平面表面上绘制而不交叉，则网络是*平面*的。非平面网络的最简单示例是具有五个节点的完全网络。至多具有四个节点的完全网络是平面的。通过在纸上绘制这些网络的方式进行一些实验，将会发现一个不包含交叉边的图。此外，任何包含至少五个节点的完全图的网络都不是平面的。平面网络在理论上很重要，因为它们相对简单，但在应用中出现的网络中它们较少。

## 还有更多...

除了网络类中的方法之外，NetworkX 包中还有许多其他例程可用于访问网络中节点和边的属性。例如，`nx.get_node_attributes`从网络中的每个节点获取一个命名属性。

# 生成网络的邻接矩阵

在图的分析中，一个强大的工具是邻接矩阵，它的条目*a[ij]* = 1，如果有一条边从节点*i*到节点*j*，否则为 0。对于大多数网络，邻接矩阵将是稀疏的（大多数条目为 0）。对于非定向的网络，矩阵也将是对称的（*a[ij]* =**a**[ji]*）。还有许多其他可以与网络相关联的矩阵。我们将在本教程的*更多内容...*部分简要讨论这些。**

**在这个教程中，我们将生成网络的邻接矩阵，并学习如何从这个矩阵中获得网络的一些基本属性。

## 准备工作

在这个教程中，我们将需要将 NetworkX 包导入为`nx`，将 NumPy 模块导入为`np`。

## 如何做...

以下步骤概述了如何为网络生成邻接矩阵，并从这个矩阵中推导出网络的一些简单属性：

1.  首先，我们将生成一个网络，然后在整个教程中使用它。我们将生成一个具有五个节点和五条边的随机网络，同时使用一个种子以便重现：

```py
G = nx.dense_gnm_random_graph(5, 5, seed=12345)
```

1.  要生成邻接矩阵，我们使用 NetworkX 的`adjacency_matrix`例程。这默认返回一个稀疏矩阵，因此我们还将使用`todense`方法将其转换为完整的 NumPy 数组以进行演示：

```py
matrix = nx.adjacency_matrix(G).todense()
print(matrix)
# [[0 0 1 0 0]
#  [0 0 1 1 0]
#  [1 1 0 0 1]
#  [0 1 0 0 1]
#  [0 0 1 1 0]]
```

1.  对邻接矩阵进行*n*次幂运算可以得到从一个节点到另一个节点的长度为*n*的路径数：

```py
paths_len_4 = np.linalg.matrix_power(matrix, 4)
print(paths_len_4)
# [[ 3 5  0  0 5]
#  [ 5 9  0  0 9]
#  [ 0 0 13 10 0]
#  [ 0 0 10  8 0]
#  [ 5 9  0  0 9]]
```

## 它是如何工作的...

`dense_gnm_random_graph`例程生成一个（密集的）随机网络，从所有具有*n*个节点和*m*条边的网络家族中均匀选择。在这个教程中，*n=5*，*m=5*。密集前缀表示这个例程使用的算法应该比对于节点数相对较大的密集网络的替代`gnm_random_graph`更快。

网络的邻接矩阵很容易生成，特别是在图相对较小的情况下，尤其是在稀疏形式下。对于更大的网络，这可能是一个昂贵的操作，因此可能不太实际，特别是如果你将其转换为完整矩阵，就像我们在这个教程中看到的那样。一般来说，你不需要这样做，因为我们可以简单地使用`adjacency_matrix`例程生成的稀疏矩阵和 SciPy `sparse`模块中的稀疏线性代数工具。

矩阵的幂提供了关于给定长度的路径数的信息。通过追踪矩阵乘法的定义，这很容易看出。请记住，当两个给定节点之间存在边（长度为 1 的路径）时，邻接矩阵的条目为 1。

## 更多内容...

网络的邻接矩阵的特征值提供了关于网络结构的一些额外信息，例如网络色数的上下界。（有关网络着色的更多信息，请参见*着色网络*教程。）有一个单独的例程用于计算邻接矩阵的特征值。例如，我们可以使用`adjacency_spectrum`例程生成网络的邻接矩阵的特征值。与网络相关的矩阵的特征值的方法通常被称为*谱方法*。

与网络相关的还有其他矩阵，如*关联矩阵*和*拉普拉斯矩阵*。网络的关联矩阵是一个*M × N*矩阵，其中*M*是节点数，*N*是边数。如果节点*i*出现在边*j*中，则该矩阵的第*i-j*个条目为 1，否则为 0。网络的拉普拉斯矩阵被定义为*L = D - A*矩阵，其中*D*是包含网络中节点度数的对角线矩阵，*A*是网络的邻接矩阵。这些矩阵对于分析网络很有用。

# 创建定向和加权网络

简单的网络，比如前面的教程中描述的那些，用于描述边的方向不重要且边的权重相等的网络是有用的。实际上，大多数网络都携带额外的信息，比如权重或方向。

在这个教程中，我们将创建一个有向且带权重的网络，并探索这种网络的一些基本属性。

## 准备工作

对于这个教程，我们将需要 NetworkX 包，以通常的方式导入为`nx`，导入为`plt`的 Matplotlib`pyplot`模块，以及导入为`np`的 NumPy 包。

## 如何操作...

以下步骤概述了如何创建一个带权重的有向网络，以及如何探索我们在前面教程中讨论的一些属性和技术：

1.  为了创建一个有向网络，我们使用 NetworkX 中的`DiGraph`类，而不是简单的`Graph`类：

```py
G = nx.DiGraph()
```

1.  像往常一样，我们使用`add_node`或`add_nodes_from`方法向网络添加节点：

```py
G.add_nodes_from(range(5))
```

1.  要添加加权边，我们可以使用`add_edge`方法并提供`weight`关键字参数，或者使用`add_weighted_edges_from`方法：

```py
G.add_edge(0, 1, weight=1.0)
G.add_weighted_edges_from([
    (1, 2, 0.5), (1, 3, 2.0), (2, 3, 0.3), (3, 2, 0.3),
    (2, 4, 1.2), (3, 4, 0.8)
])
```

1.  接下来，我们用箭头绘制网络，以指示每条边的方向。我们还为这个图提供了自己的位置：

```py
fig, ax = plt.subplots()
pos = {0: (-1, 0), 1: (0, 0), 2: (1, 1), 3: (1, -1), 4: (2, 0)}
nx.draw(G, ax=ax, pos=pos, with_labels=True)
ax.set_title("Weighted, directed network")
```

可以在下图中看到得到的图：

![](img/6fc068a8-7008-4108-935e-59128098ca32.png)图 5.3：一个带权重的有向网络

1.  有向矩阵的邻接矩阵的创建方式与简单网络相同，但是得到的矩阵不会是对称的：

```py
adj_mat = nx.adjacency_matrix(G).todense()
print(adj_mat)
# [[0\. 1\. 0\. 0\. 0\. ]
# [0\. 0\. 0.5 2\. 0\. ]
# [0\. 0\. 0\. 0.3 1.2]
# [0\. 0\. 0.3 0\. 0.8]
# [0\. 0\. 0\. 0\. 0\. ]]
```

## 工作原理...

`DiGraph`类表示一个有向网络，其中在添加边时节点的顺序很重要。在这个教程中，我们添加了两条连接节点 2 和 3 的边，每个方向一条。在简单网络（`Graph`类）中，添加第二条边不会增加额外的边。然而，在有向网络（`DiGraph`类）中，添加边时给出的节点的顺序决定了方向。

关于加权边，除了添加附加到边的`weight`属性之外，没有什么特别之处。（可以通过关键字参数向网络中的边或节点附加任意数据。）`add_weighted_edges_from`方法只是将相应的权重值（元组中的第三个值）添加到相关的边上。权重可以添加到任何网络中的任何边，而不仅仅是本教程中显示的有向网络。

在绘制有向网络时，`draw`例程会自动向边添加箭头。可以通过传递`arrows=False`关键字参数来关闭这种行为。有向或带权重网络的邻接矩阵也与简单网络不同。在有向网络中，矩阵通常不对称，因为边可能只存在一个方向而不是另一个方向。对于带权重的网络，条目可以不同于 1 或 0，而是对应边的权重。

## 还有更多...

带权重的网络出现在许多应用中，比如用距离或速度描述交通网络。您还可以使用网络来通过为网络中的边提供“容量”（作为权重或其他属性）来研究网络中的流动。NetworkX 有几个工具用于分析网络中的流动，比如通过`nx.maximum_flow`例程找到网络中的最大流量。

有向网络为网络添加了方向信息。许多现实世界的应用产生了具有单向边的网络，比如工业流程或供应链网络中的网络。这种额外的方向信息对许多处理网络的算法都有影响，我们将在本章中看到。

# 在网络中查找最短路径

网络出现的一个常见问题是在网络中找到两个节点之间的最短路径或者更准确地说是最高奖励的路径。例如，这可能是两个城市之间的最短距离，其中节点代表城市，边代表连接城市对的道路。在这种情况下，边的权重将是它们的长度。

在这个示例中，我们将在一个带权重的网络中找到两个节点之间的最短路径。

## 准备工作

对于这个示例，我们将需要导入 NetworkX 包，通常使用`nx`作为名称，导入 Matplotlib 的`pyplot`模块作为`plt`，以及从 NumPy 导入一个随机数生成器对象：

```py
from numpy.random import default_rng
rng = default_rng(12345) # seed for reproducibility
```

## 如何做...

按照以下步骤在网络中找到两个节点之间的最短路径：

1.  首先，我们将使用`gnm_random_graph`和一个`seed`创建一个随机网络，用于这个演示：

```py
G = nx.gnm_random_graph(10, 17, seed=12345)
```

1.  接下来，我们将以圆形排列的方式绘制网络，以查看节点之间的连接方式：

```py
fig, ax = plt.subplots()
nx.draw_circular(G, ax=ax, with_labels=True)
ax.set_title("Random network for shortest path finding")
```

生成的图可以在下面的图片中看到。在这里，我们可以看到从节点 7 到节点 9 没有直接的边：

![](img/5fd59d73-0edf-44a2-b3bc-ad06f989d549.png)图 5.4：一个随机生成的具有 10 个节点和 17 条边的网络

1.  现在，我们需要给每条边添加权重，以便在最短路径方面有些路线更可取：

```py
for u, v in G.edges:
    G.edges[u, v]["weight"] = rng.integers(5, 15)
```

1.  接下来，我们将使用`nx.shortest_path`例程计算从节点 7 到节点 9 的最短路径：

```py
path = nx.shortest_path(G, 7, 9, weight="weight")
print(path)
# [7, 5, 2, 9]
```

1.  我们可以使用`nx.shortest_path_`来找到这条最短路径的长度

长度`routine`：

```py
length = nx.shortest_path_length(G, 7, 9, weight="weight")
print("Length", length)
# Length 32
```

## 它是如何工作的...

`shortest_path`例程计算每对节点之间的最短路径。或者，当提供源节点和目标节点时，就像我们在这个示例中所做的那样，它计算两个指定节点之间的最短路径。我们提供了可选的`weight`关键字参数，这使算法根据边的“权重”属性找到最短路径。这个参数改变了“最短”的含义，默认是“最少的边”。

找到两个节点之间最短路径的默认算法是 Dijkstra 算法，这是计算机科学和数学课程的基础。它是一个很好的通用算法，但效率并不是特别高。其他寻路算法包括 A*算法。使用 A*算法并提供额外的启发式信息来指导节点选择可以获得更高的效率。

## 还有更多...

有许多算法可以在网络中找到两个节点之间的最短路径。还有一些变体用于找到最大加权路径。

关于在网络中找到路径的问题还有一些相关问题，比如*旅行推销员问题*和*路线检查问题*。在旅行推销员问题中，我们找到一个循环（从同一个节点开始和结束的路径），访问网络中的每个节点，总权重最小（或最大）。在路线检查问题中，我们寻找通过网络中每条边并返回到起点的最短循环（按权重计算）。已知旅行推销员问题是 NP 难题，但路线检查问题可以在多项式时间内解决。

图论中一个著名的问题是 Königsberg 的桥，它要求在网络中找到一条路径，该路径恰好穿过网络中的每条边一次。事实证明，正如欧拉证明的那样，在 Königsberg 桥问题中找到这样的路径是不可能的。穿过每条边恰好一次的路径称为*欧拉回路*。如果一个网络允许欧拉回路，则称为*欧拉*。事实上，当且仅当每个节点的度都是偶数时，网络才是欧拉的。Königsberg 桥问题的网络表示如下图所示。这里的边代表河流上的不同桥梁，而节点代表不同的陆地。我们可以看到所有四个节点的度都是奇数，这意味着不能有一条穿过每条边恰好一次的路径：

![](img/7112954f-14cd-4a8f-bd16-4b169cb53854.png)图 5.5：表示 Königsberg 桥问题的网络

边代表节点之间的桥梁。

# 在网络中量化聚类

与网络相关的各种量度可以衡量网络的特性。例如，节点的聚类系数衡量了附近节点之间的互连性（这里，附近意味着通过边连接）。实际上，它衡量了邻近节点接近形成一个完整网络或*团*的程度。

节点的聚类系数衡量了与该节点相邻的节点之间通过边连接的比例；也就是说，两个相邻的节点与给定节点形成一个三角形。我们计算三角形的数量，并将其除以可能形成的总三角形数量，考虑到节点的度。从数值上看，简单无权重网络中节点*u*的聚类系数由以下方程给出：

![](img/7175e9d6-ae3e-4e69-8065-dd93d7cc68a4.png)

这里，*T[u]*是*u*处的三角形数，分母是*u*处可能的三角形总数。如果*u*的度（*u*的边数）为 0 或 1，则将*c[u]*设为 0。

在这个示例中，我们将学习如何计算网络中节点的聚类系数。

## 准备工作

对于这个示例，我们需要导入 NetworkX 包作为`nx`，并导入 Matplotlib `pyplot`模块作为`plt`。

## 如何做...

以下步骤向您展示了如何计算网络中节点的聚类系数：

1.  首先，我们需要创建一个样本网络来使用：

```py
G = nx.Graph()
complete_part = nx.complete_graph(4)
cycle_part = nx.cycle_graph(range(4, 9))
G.update(complete_part)
G.update(cycle_part)
G.add_edges_from([(0, 8), (3, 4)])
```

1.  接下来，我们将绘制网络，以便比较我们将要计算的聚类系数。这将使我们能够看到这些节点在网络中的出现方式：

```py
fig, ax = plt.subplots()
nx.draw_circular(G, ax=ax, with_labels=True)
ax.set_title("Network with different clustering behavior")
```

结果图可以在下图中看到：

![](img/7d9a21b9-1aff-4fe9-aef8-c38936faeb8f.png)图 5.6：用于测试聚类的示例网络

1.  现在，我们可以使用`nx.clustering`例程计算网络中节点的聚类系数：

```py
cluster_coeffs = nx.clustering(G)
```

1.  `nx.clustering`例程的输出是网络中节点的字典。因此，我们可以按如下方式打印一些选定的节点：

```py
for i in [0, 2, 6]:
    print(f"Node {i}, clustering {cluster_coeffs[i]}")
# Node 0, clustering 0.5
# Node 2, clustering 1.0
# Node 6, clustering 0
```

1.  可以使用`nx.average_clustering`例程计算网络中所有节点的平均聚类系数：

```py
av_clustering = nx.average_clustering(G)
print(av_clustering)
# 0.3333333333333333
```

## 它是如何工作的...

节点的聚类系数衡量了该节点的邻域接近形成一个完整网络（所有节点彼此连接）。在这个示例中，我们可以看到我们有三个不同的计算值：0 的聚类系数为 0.5，2 的聚类系数为 1.0，6 的聚类系数为 0。这意味着连接到节点 2 的节点形成了一个完整的网络，这是因为我们设计了我们的网络。 （节点 0-4 按设计形成一个完整的网络。）节点 6 的邻域离完整很远，因为它的邻居之间没有相互连接的边。

平均聚类值是网络中所有节点的聚类系数的简单平均值。它与全局聚类系数（使用 NetworkX 中的`nx.transitivity`例程计算）不完全相同，但它确实让我们了解整个网络接近完全网络的程度。全局聚类系数衡量了三角形的数量与三元组的数量之比 - 由至少两条边连接的三个节点组成 - 在整个网络上。

平均聚类之间的差异非常微妙。全局聚类系数衡量了整个网络的聚类程度，但平均聚类系数衡量了网络在局部平均聚类的程度。这种差异最好在风车网络中看到，它由一个单一节点围绕着偶数个节点的圆圈组成。所有节点都连接到中心，但圆圈上的节点只以交替模式连接。外部节点的局部聚类系数为 1，而中心节点的局部聚类系数为 1/(2*N-1*)，其中*N*表示连接到中心节点的三角形的数量。然而，全局聚类系数为 3/(2*N*-1)。

## 还有更多...

聚类系数与网络中的*团*相关。团是一个完全的子网络（所有节点都通过一条边连接）。网络理论中的一个重要问题是找到网络中的最大团，这在一般情况下是一个非常困难的问题（这里，最大意味着“不能再扩大”）。

# 着色网络

网络在调度问题中也很有用，您需要将活动安排到不同的时间段中，以确保没有冲突。例如，我们可以使用网络来安排课程，以确保选择不同选项的学生不必同时上两节课。在这种情况下，节点将代表不同的课程，边将指示有学生同时上两门课。我们用来解决这类问题的过程称为*网络着色*。这个过程涉及为网络中的节点分配尽可能少的颜色，以便相邻的两个节点没有相同的颜色。

在本教程中，我们将学习如何着色网络以解决简单的调度问题。

## 准备工作

对于本教程，我们需要导入 NetworkX 包为`nx`，导入 Matplotlib 的`pyplot`模块为`plt`。

## 如何做...

按照以下步骤解决网络着色问题：

1.  首先，我们将创建一个示例网络，用于本教程：

```py
G = nx.complete_graph(3)
G.add_nodes_from(range(3, 7))
G.add_edges_from([
    (2, 3), (2, 4), (2, 6), (0, 3), (0, 6), (1, 6),
    (1, 5), (2, 5), (4, 5)
])
```

1.  接下来，我们将绘制网络，以便在生成着色时能够理解。为此，我们将使用`draw_circular`例程：

```py
fig, ax = plt.subplots()
nx.draw_circular(G, ax=ax, with_labels=True)
ax.set_title("Scheduling network")
```

生成的绘图如下图所示：

![](img/fa56224e-7a2e-46d1-9e84-914d97c8c558.png)图 5.7：简单调度问题的示例网络

1.  我们将使用`nx.greedy_color`例程生成着色：

```py
coloring = nx.greedy_color(G)
print("Coloring", coloring)
# Coloring {2: 0, 0: 1, 1: 2, 5: 1, 6: 3, 3: 2, 4: 2}
```

1.  要查看此着色中使用的实际颜色，我们将从`coloring`字典生成一组值：

```py
different_colors = set(coloring.values())
print("Different colors", different_colors)
# Different colors {0, 1, 2, 3}
```

## 它是如何工作的...

`nx.greedy_color`例程使用多种可能的策略对网络进行着色。默认情况下，它按照从最大到最小的顺序按度数工作。在我们的情况下，它首先为度为 6 的节点 2 分配颜色 0，然后为度为 4 的节点 0 分配颜色 1，依此类推。对于这个序列中的每个节点，选择第一个可用的颜色。这不一定是着色网络的最有效算法。

显然，通过为每个节点分配不同的颜色，可以给任何网络上色，但在大多数情况下，需要更少的颜色。在本教程中，网络有七个节点，但只需要四种颜色。所需的最小颜色数称为网络的*色数*。

## 还有更多...

网络的着色问题有几种变体。其中一种变体是*列表着色问题*，在这个问题中，我们寻找一个网络的着色，其中每个节点从可能颜色的预定义列表中选择一个颜色。这个问题显然比一般的着色问题更困难。

一般着色问题有一些令人惊讶的结果。例如，每个平面网络最多可以用四种不同的颜色着色。这是图论中著名的*四色定理*，由 Appel 和 Haken 在 1977 年证明。

# 找到最小生成树和支配集

网络在各种问题中都有应用。两个明显的领域是通信和分配。例如，我们可能希望找到一种在覆盖从特定点到许多城市（节点）的道路网络中最小距离的分配方式。对于这样的问题，我们需要查看最小生成树和支配集。

在这个教程中，我们将在网络中找到一个最小生成树和一个支配集。

## 准备工作

对于这个教程，我们需要将 NetworkX 包导入为`nx`，将 Matplotlib 的`pyplot`模块导入为`plt`。

## 如何做...

按照以下步骤找到网络的最小生成树和支配集：

1.  首先，我们将创建一个样本网络进行分析：

```py
G = nx.gnm_random_graph(15, 22, seed=12345)
```

1.  接下来，和往常一样，在进行任何分析之前，我们将绘制网络：

```py
fig, ax = plt.subplots()
pos = nx.circular_layout(G)
nx.draw(G, pos=pos, ax=ax, with_labels=True)
ax.set_title("Network with minimum spanning tree overlaid")
```

1.  最小生成树可以使用`nx.minimum_`来计算

生成树`例程：

```py
min_span_tree = nx.minimum_spanning_tree(G)
print(list(min_span_tree.edges))
# [(0, 13), (0, 7), (0, 5), (1, 13), (1, 11),
#   (2, 5), (2, 9), (2, 8), (2, 3), (2, 12),
#   (3, 4), (4, 6), (5, 14), (8, 10)]
```

1.  接下来，我们将在绘图上叠加最小生成树的边：

```py
nx.draw_networkx_edges(min_span_tree, pos=pos, ax=ax, width=1.5,
   edge_color="r")
```

1.  最后，我们将使用`nx.dominating_set`例程为网络找到一个支配集-一个集合，其中网络中的每个节点都与支配集中的至少一个节点相邻：

```py
dominating_set = nx.dominating_set(G)
print("Dominating set", dominating_set)
# Dominating set {0, 1, 2, 4, 10, 14}
```

可以在下图中看到叠加了最小生成树的网络的绘图：

![](img/3e8ca1be-4fd3-4ce2-9121-76182b51937e.png)图 5.8：叠加了最小生成树的网络绘制

## 它是如何工作的...

网络的*生成树*是网络中包含所有节点的树。*最小*生成树是包含尽可能少的边的生成树，或者说具有最低的总权重。最小生成树对于网络上的分配问题非常有用。一种简单的找到最小生成树的算法是简单地选择边（如果网络是加权的，则首先选择最小权重的边），以便不会创建循环，直到不再可能为止。

网络的*支配集*是一个顶点集，其中网络中的每个节点都与支配集中的至少一个节点相邻。支配集在通信网络中有应用。我们经常有兴趣找到最小的支配集，但这在计算上是困难的。事实上，测试是否存在一个比给定大小更小的支配集是 NP 完全的。然而，对于某些类别的图形，有一些有效的算法可以找到最小的支配集。非正式地说，问题在于一旦你确定了一个最小大小支配集的候选者，你必须验证是否存在比它更小的支配集。如果你事先不知道所有可能的支配集，这显然是非常困难的。

# 进一步阅读

有几本经典的图论著作，包括 Bollobás 和 Diestel 的书：

+   * Diestel, R., 2010. Graph Theory. 3rd ed. Berlin: Springer.*

+   * Bollobás, B., 2010. Modern Graph Theory. New York, NY: Springer.***
