# 强加密

强加密甚至可以对抗决心坚定的对手，比如敌对军事机构，如果做得正确的话。强加密的两种主要方法是AES和RSA，它们都得到了美国政府的批准。你不需要有编程经验来学习这个，也不需要任何特殊的计算机；任何能运行Python的计算机都可以完成这些项目。而且你不需要太多的数学，因为我们不打算发明新的加密技术，只是学习如何使用标准的现有的那些，这些不需要任何比基本代数更高级的东西。

在本章中，我们将涵盖以下内容：

+   AES强加密

+   ECB和CBC模式

+   填充预言攻击

+   RSA强加密

+   接下来呢？

# AES强加密

在这一部分，我们将看一下**高级加密标准**（**AES**），私钥加密，密钥和块大小，如何影响AES，以及Python和混淆和扩散。

AES是美国国家标准技术研究所批准的加密标准，被认为非常安全。它甚至被批准用于保管机密军事信息。它是私钥加密，这是几千年来一直在使用的加密类型，发送方和接收方都使用相同的密钥。它是块密码，因此输入数据必须放在长度为128位的块中，明文块用密钥加密，产生密文块：

![](../images/00070.jpeg)

有三种密钥大小：128、192和256位。最常见的AES类型是128位密钥大小，这就是我们在这个例子中要使用的。在Python中，使用起来非常容易。

首先，你需要从`crypto cipher`导入`AES`模块，然后你需要一个16字节的密钥和明文，这是16字节的整数倍。然后你将用密钥创建一个新的AES对象，然后用密码加密计算它。这会给你一个16字节的字符串，可能是不可打印的，所以最好将其编码为十六进制以打印出来；当然，如果你解密它，你会回到原始的明文。这具有许多理想的加密属性，其中之一是混淆。如果你改变密钥的一位，它会改变整个密文。

因此，如果我们将密钥改为`kex`，你会看到所有的密文都改变了。这就是你想要的。两个非常相似的密钥会产生完全不同的结果，因此你无法找到任何模式来推断密钥的信息。

同样，扩散是一种理想的属性，如果你用相同的密钥对同一明文进行两次加密，但你改变了明文的一位，整个密文再次改变。看下面的例子：

![](../images/00071.jpeg)

在这里，我们有字节，得到相同的`433`结尾于`6a8`。如果我们把最后一个字母改成`t`，你会发现它以`90c`开头，以`5d2`结尾；也就是说，它完全改变了。

让我们在Python中看一下：

1.  打开终端窗口并启动`python`。我们将输入以下命令，如截图所示：

![](../images/00072.jpeg)

1.  我们导入`AES`模块，有一个16字节的密钥和一个16字节的明文。我们创建了一个AES对象，对其进行了加密，然后我们在这里打印出了十六进制值：

![](../images/00073.jpeg)

1.  现在，我们改变密钥：

![](../images/00074.jpeg)

我们来到密钥行，将其改为`z`，然后再次进行操作，用该密钥创建一个新的AES对象。进行加密并再次打印出结果，你会看到一切都不同了。

现在它以`b`开头，以`4`结尾，完全改变了。

1.  现在，我们将保留密钥不变，改变明文。让我们把`t`改成`F`。现在如果我们加密它并以十六进制打印出结果，一切又都改变了；尽管这与上面的密钥相同：

![](../images/00075.jpeg)

因此，这显示了混淆和扩散，这是可取的特性。在下一节中，我们将讨论ECB和CBC模式。

# ECB和CBC模式

我们将比较**电子密码本**（**ECB**）和**密码块链接**（**CBC**）并向您展示如何在Python中实现AES CBC。

# ECB

在ECB方法中，每个明文块都分别使用密钥加密，因此如果你有两个相同的明文块，它们将产生相同的密文：

![](../images/00076.jpeg)

如果你有一张图片，上面有大片的纯色，比如灰色和黑色，然后你加密它，你会得到不同的颜色，但图案不会改变：

![](../images/00077.jpeg)

这不好。你仍然可以看到这是一只企鹅的图片，这不是大多数人对加密的期望。你期望加密隐藏数据，以便查看加密数据的攻击者无法知道消息是什么，而这里这种属性是不存在的。

因此，CBC被认为是这个问题的最佳解决方案。

# CBC

除了密钥，你还需要添加一个初始化向量，它在加密之前与明文进行异或运算。然后对于下一个块，你取加密产生的密文，并将其用作第二个块的初始化向量。第三个块的输出被用作第三个块的初始化向量。因此，即使每个块中的输入明文相同，每个块中的密文也会不同：

![](../images/00078.jpeg)

这导致更多的混淆：

![](../images/00079.jpeg)

你可以看到企鹅现在完全看不见，所有字节都是随机的，所以这几乎是每个目的的首选。

要在Python中执行它，这是我们之前在EBC模式下执行的AES的方法。默认情况下，你不需要指定模式。

如果你想使用CBC模式，你可以输入以下命令：

![](../images/00080.jpeg)

AES模式CBC当你创建密码对象时。你还需要提供一个初始化向量，它可以是16字节，就像密钥一样。如果你加密16字节的文本块，由于初始化向量，结果中没有明显的差异，但它只是一个十六进制块。要看到这种效果，你需要使明文更长。当你加密它时，你会得到一个十六进制的块。这就是ECB模式，它并没有消除数据中的所有模式。这是具有相同重复输入的CBC模式。正如你所看到的，输出没有模式，并且无论你走多远，都不会重复。因此，它更有效地隐藏了数据。

让我们来看看。我们在终端中启动Python，然后添加这段代码：

![](../images/00081.jpeg)

因此，你可以看到16字节的密钥和16字节的AES明文在ECB模式下。我们对其进行加密并打印答案。

如果我们想要使它更长，我们添加这个：

![](../images/00082.jpeg)

你可以在Python中对字符串对象进行乘法运算，如果你只是打印它出来，你会看到它只是同样的东西三次。

现在我们可以加密`plain3`：

![](../images/00083.jpeg)

当我们打印出来时，它将在33处有重复的模式。现在，如果我们改变模式，我们需要一个`iv`：

![](../images/00084.jpeg)

我们只需要16个字节，所以我们将16个字节添加到`iv`。接下来，我们创建一个新的`AES`对象。现在，在`iv`中，我们再次加密`plain3`，然后再次打印出结果。

你可以看到它有`61f`，你可以看到不再有重复。因此，如果你真的想要模糊输入，这是一种更有效的加密方式。

# 填充预言攻击

在本节中，我们将看到PKCS＃7系统中填充的工作原理，然后向您展示带有“PADDING ERROR”消息的系统。此外，我们还将处理填充预言攻击，这使得可能制作解码我们想要的20个明文的密文。

这是加密例程：

![](../images/00085.jpeg)

我们将有三个数据块，每个块长16字节。我们将使用AES在CBC模式下加密数据，因此初始化向量和密钥就会出现。你会产生三个密文块，第一个块之后的每一个块都使用前一个加密例程的输出作为初始化向量与明文进行异或。

这是PKCS#7填充的工作方式：

+   如果需要一个字节的填充，使用`01`

+   如果需要两个字节的填充，使用`0202`

+   如果需要三个字节的填充，使用`030303`

+   等等...

如果我们这里的消息只有47个字节长，那么我们无法填满最后一个块，所以我们必须添加一个字节的填充。你可以使用各种数字作为填充，但在这个系统中，我们使用一个二进制值1，如果你需要一个字节的填充，如果你需要两个字节，你就用两个字节，如果你需要三个字节的填充，你就用三个字节。这意味着，如果我们解密它，我们将得到三个密文块。我们解密它，我们将得到47字节的消息：

![](../images/00086.jpeg)

这里的最后一个字节将始终是填充字节，即`0-1`，二进制值为`1`。

这是一个易受攻击的系统的示例。这只是使用我们以前制作的相同技术，我们只是用AES和CBC模式加密东西，你可以保存在`pador.py`中，然后你可以导入它以使其易于使用和更加现实。已经有真实的系统使用了这个。所以，我们导入，加密和解密方法，以便我们可以输入一个47个字节的消息并对其进行加密。我们将得到一个长长的十六进制输出。

如果我们解密它，我们将得到我们原始的输入加上一个字节的`0`1。x01是Python表示法，表示二进制值为`1`的单个字节。如果你修改输入，保持前47个字节不变，并将最后一个字节更改为`A`或`65`并解密它，你将得到一个填充错误。这个错误消息看起来可能无害，但实际上它可能完全颠覆加密。

让我们来看看：

1.  打开终端并启动`python`。

1.  我们将输入以下命令：

![](../images/00087.jpeg)

1.  我们将加密和解密例程。你可以看到我们有明文。当我们加密47个字节的明文时，我们得到一个长长的二进制块：

```py
941dc2865db9204c40dd6f0898cbe0086fc6d915e288ed4ef223766a02967b81c6c431778a40f517e9e4aa86856e0a3b68297e102b1ec93713bf89750cdfa80e
```

1.  当我们解密时，我们得到以下结果：

![](../images/00088.jpeg)

我们可以看到，它实际上在末尾添加了一个字节的填充。

现在，我们应该做变形的。如果我们将我们修改后的文本设置为原始明文，直到第47个字符，然后我们在末尾添加`"A"`，当我们解密它时，我们得到`'PADDING ERROR'`：

![](../images/00089.jpeg)

这是我们可以利用来颠覆系统的错误消息。所以，填充预言攻击的工作方式如下更改：

1.  将密文`[16:31]`更改为任何字节

1.  更改密文`[31]`直到填充有效。

1.  中间`[47]`必须是`1`

这是CBC的图示：

![](../images/00090.jpeg)

保持密文的前16个字节不变。将其更改为任何你喜欢的东西，比如全A，然后解密。会发生的是，因为你改变了第二个块中的字节，第二个块将变成随机字符，第三个块也是如此。但除非最后一个块的最后一个字节是1，否则会出现填充错误。所以，你可以用穷举法。你将一个字节更改为所有256个可能的值，直到该字节变为`1`，当发生这种情况时，你就知道这个值是`1`。你知道这个值，因为它没有给你一个填充错误消息，你可以对它们进行异或运算，以确定这个中间值。因此，逐个字节向左进行，你可以确定这些中间值。如果你知道它们，你可以输入密文，使得你喜欢的任何东西出现在第三个块中。因此，即使你不知道密钥或初始化向量，你也可以打败加密。

这是执行此操作的代码：

![](../images/00091.jpeg)

并将得到以下输出：

![](../images/00092.jpeg)

我们将密文设置为原始密文的前16个字节，然后是15个`A`。然后，我们改变下一个字节的所有可能的`256`个值，并且保持第三个数据块不变。之后，我们查看何时不再出现填充错误，那将是`234`，因此中间值是`234`异或一：

1.  现在，如果我们想要得到下一个字节，我们必须安排两个字节的填充，两者都将是`2`，如下所示：

![](../images/00093.jpeg)

因此，密文的最后两个字节`46`和`47`都将是两。因此，我们将密文`31`设置为创建两个所需的值。现在我们知道中间值，我们可以计算它。

1.  我们改变密文`30`直到填充有效，这将确定中间的下一个字节：

![](../images/00094.jpeg)

1.  保持第一个块不变，并添加14个字节的变化下一个字节的填充。保持所选值为`233`的字节，这样你就知道解密输出的最后一个字节将是`2`，当填充错误消息消失时，你可以拿这个数字，与`2`异或，得到中间值的下一个值。因此，现在我们可以制作消息。我们必须重复这个过程更多次以获得更多字节，但是对于这个演示，我们将只接受一个字母长的消息。我们将制作一个以`A`开头，后面跟着一个二进制值为`1`的有效填充。这是我们的目标，为了做到这一点，我们只需要将密文`30`和`31`设置为这些选择的值：

+   `ciphertext[30] = ord("A") ^ 113`

+   `ciphertext[31] = 16 235`

1.  因为我们知道中间值是`113`和`235`，我们只需要用我们想要的值异或这些中间值。

1.  我们将创建一个解密为以`A`结尾和二进制`1`的消息的密文，让我们看看它是如何进行的。现在，这个有点复杂，所以我们选择在文本编辑器中保存一些文本，这样我们可以逐个阶段地进行：

![](../images/00095.jpeg)

1.  这是我们的Python代码：

```py
>>> from pador import encr, decr 

>>> prefix = c[0:16] + "A"*14
>>> for i in range(256):
...   mod = prefix + chr(i) + chr(233) + c[32:]
...   if decr(mod) != "PADDING ERROR":
...     print i, "is correctly padded"
```

1.  好的，我们导入了库，我们已经有了。在这里，我们保持前16个字节不变，并用15个`A`填充。然后，我们有一个循环，改变下一个字节的每个可能的值，并保持第三个数据块不变。我们运行循环，直到不再出现填充错误。这告诉我们`234`是给我们正确填充的值：

```py
234 is correctly padded
```

1.  因此，我们将`234`带到`1`，这告诉我们中间值，所有的缩进都被切断了，所以是`234`异或`1`。这告诉我们值是`235`。这是中间值。对于下一个位，使用非常相似的过程，所以现在我们有14个字节的填充。我们将改变下一个字节，接下来的字节是`233`，始终选择为`2`。因此，当我们通过这个循环运行时，它在`115`处被正确填充：

```py
...
115 is correctly padded
```

1.  因此，`115`异或`2`是`113`：

```py
>>> 115 ^ 2
113
```

因此，`113`是中间值的下一个字节。

1.  现在我们知道这两个数字`235`和`113`，我们可以控制明文的最后两个字节。现在我们将保持输入数据的第一个块不变。我们有14个字节的填充：

```py
>>> prefix = c[0:16] + "A"*14 
>>> c30 = ord("A") ^ 113 
>>> c31 = 1 ^ 235 mod = prefix + chr(c30) + chr(c31) + c[32:] 
>>> decr(mod)
```

1.  我们选择用两个字节`235`和`113`来制作`A`和一个二进制`1`。当我们创建修改后的密文并解密它时，我们得到以下消息：

```py
"This simple sent\xc6\x8d\x12;y.\xdc\xa2\xb4\xa9)7c\x95b\xd1I\xd0(\xbb\x1f\x8d\xebRlY'\x17\xf6wA\x01"
```

数据的第一个块没有被修改。第二个块和大部分第三个块已经改变为随机字符，但我们控制了最后两个字节，我们可以让它们说我们想要的任何东西。因此，我们能够创建一个解密至少部分为我们选择的两个值的密文，即使我们不知道密钥或初始化向量。

# 使用RSA进行强加密

在本节中，我们将介绍公钥加密、RSA算法以及在Python中的实现。

# 公钥加密

在公钥加密中，我们解决了这个问题：例如，谷歌想要从用户那里接收机密数据，例如密码和信用卡号，但他们没有安全的通信渠道；他们拥有的是公共互联网，发送的任何数据都可能被任意数量的攻击者窃听。因此，没有办法交付共享的秘密密钥，对称加密算法，例如AES，无法解决这个问题。这就是公钥加密的作用。

谷歌创建了一对密钥。他们保持私钥保密，不告诉任何人，并且公开公钥，以便任何人都可以知道。想要向谷歌发送秘密信息的人可以用公钥加密它们，然后通过不安全的渠道发送，因为唯一能解密的是谷歌，谷歌拥有私钥。邮箱的工作原理就是这样。任何人都可以去邮箱把信放在顶部槽里，但底部的门是锁着的，只有拥有私钥的邮递员才能把信拿出来。私钥和公钥必须有关联，但它们必须通过单向函数相关联，以便从私钥轻松计算出公钥，这是谷歌在首次设置密钥对时必须做的。但是从公钥计算出私钥必须非常困难，因此公开公钥是安全的，没有人会找到私钥。

# RSA算法

有各种单向函数可以用于此目的，但在RSA中，该函数是分解一个大数：

+   私钥`d`由两个大素数`p`和`q`组成

+   公钥是`n = p * q`的乘积，以及任意值`e`

+   如果`p`和`q`很大，将`n`分解为`p`和`q`是非常困难的

如果将两个素数`p`和`q`相乘以创建它们的乘积`n`，那么将`n`分解为`p`和`q`是一个众所周知的困难问题。如果`p`和`q`足够大，这几乎是不可能的。这就是单向函数。你可以轻松地将`p`和`q`相乘以创建公钥`n`，但是公钥的知识不能用于实际确定`p`和`q`：

+   **公钥**：这是两个数字`(n,e)`

+   `e`可以是任何素数，通常是`65537`

+   **加密**：`y = x^(e)mod n`

+   **解密**：`x = y^d mod n`

+   `x`是明文，`y`是密文

因此，公钥是`n`，它是两个素数的乘积和另一个任意数`e`，通常只是这个值`65,537`。任何希望秘密发送明文`x`的人，将其提升到`e`的幂，模`n`，并将其加密的内容发送到不安全的渠道，例如互联网，给接收者。接收者有私钥，因此可以找到解密密钥`d`，并将密文取模`n`，然后变成解密的消息。解密密钥是这样计算的：

+   `phin = (p-1) * (q-1)`

+   `d*e = 1 mod phin`

由于Google知道`p`和`q`的秘密，他们可以计算出这个数字`phin`，即`p - 1`乘以`q - 1`，然后他们选择一个解密密钥，使得`d`乘以`e`对`Phi`的`n`取模等于`1`。其他人无法进行这种计算，因为他们不知道`p`和`q`的值。因此，在Python中，您可以导入`RSA`模块，然后生成任意长度的密钥。在这个例子中，我们使用了`2048`位，这是当前国家标准研究所的推荐。然后，他们有一个公钥。有一条要加密的消息，你加密它，结果是这个非常长的密文，长度为`2048`位。密文很长，计算速度很慢，所以你通常不会用这种方法发送长消息。在RSA中，你只需要发送一个秘密密钥，然后你使用AES来加密之后的所有内容，以加快计算速度。本章介绍了一种称为教科书RSA的东西，其中包含许多基本要素，但实际上并不足够安全，因为你必须添加一个在RFC 8017中指定的填充。这会向消息添加哈希值、掩码和填充，并保护密钥免受一些攻击。让我们在Python中看一下这个。

# Python中的实现

这是我们如何在Python中实现我们所讨论的内容：

1.  我们启动`python`，然后添加以下代码：

![](../images/00096.jpeg)

1.  所示的最后一步大约需要2到4秒钟才能生成密钥；这是因为它必须找到两个大素数，而这些是非常困难的计算：

![](../images/00097.jpeg)

1.  它必须猜一个数字并测试它，通常情况下，它必须为每个大素数尝试超过一百次猜测，因此这个过程非常耗时。但是，这是自动发生的，现在我们可以用密钥加密消息，生成这个非常长的密文：

![](../images/00098.jpeg)

1.  现在，我们可以测试一下，看看我们是否改变了消息的一个比特，或者将明文的最后一个字母改为`f`。如果我们加密这个，结果将类似于以下内容：

```py
>>> plain = 'encrypt this messagf'
>>> ciphertext = publicKey.encrypt(plain, 0) [0
... ciphertext = publicKey.encrypt(plain, 0) [0
keyboardInterrupt
>>> ciphertext = publicKey.encrypt(plain, 0) [0]
>>> print ciphertext.encode ("hex")
```

1.  现在，我们打印结果：

![](../images/00099.jpeg)

正如您所看到的，所有的`4ac`都变成了`1dc`，然后结束于`578`到`633`。这是强加密的理想特性。输入的任何更改都会改变所有输出，剪辑大约一半的位数。

# 挑战-用类似的因子破解RSA

在本节中，我们将涵盖诸如大整数-在Python和`decimal`库中的主题。我们还将看一个大数因式分解的例子，然后为您提供两个挑战来解决。

# Python中的大整数

Python可以进行乘法和除法-并且可以完全精确地进行任意大的整数的乘法和除法：

![](../images/00100.jpeg)

如果我们有`1001`，然后计算`1001`的平方，我们当然会得到正确的答案；即使我们取一个像`10**100 + 1`这样的数字，它也能正确地得到这个数字的一百位数，每一端都是`1`。现在，如果我们再对这个数字求平方，它也能正确地得到它的一百位数，每一端都是`1`。

因此，对于简单的整数运算，Python的精度是无限的。但是，如果我们想要平方根，我们需要导入`math`库：

![](../images/00101.jpeg)

正如您在前面的代码中所看到的，`math`库不保留任意数量的位数。如果我们取`10 **100 + 1`并对其求平方，然后取平方根，我们得到的不是`10 **100 + 1`。我们得到的是`10 ** 100`，这意味着它舍入到了少于`100`位数的一些数字，对于许多目的来说这是可以接受的。但是，对于我们想要做的事情来说不够，我们想要因式分解大整数。

为了做到这一点，您使用`decimal`库，并按照所示导入它：

![](../images/00102.jpeg)

正如你所看到的，我们已经导入了`decimal`库，并将`a`的值设置为`10 **100+ 1`。这里`b`等于a的平方，然后不是使用`math`库计算`b`的平方根，而是使用`decimal`库计算`b`的十进制值。使用它的平方根方法，这会再次给出错误的答案，因为默认情况下，`decimal`库会四舍五入。但是如果将精度设置得更高，你将得到完全正确的答案，这就是为什么`decimal`库对我们的目的更好。这个`getcontext().prec`命令让我们设置它保留足够的位数，以便我们想要的精度。

好的，所以，在一般情况下，你无法分解一个大数，这就是RSA安全的原因。但是，如果在使用数字时出现错误，并且以某种方式可以预测，那么RSA就可以被破解：

![](../images/00103.jpeg)

这里的错误是使用两个彼此接近的质数因子，而不是为这两个质数因子选择独立的随机数。因此，这个大数字是两个质数因子的乘积，因此你可以将其分解。因此，如果我们将该数字放入一个名为`n`的值中，我们将精度设置为`50`位并计算平方根。我们发现平方根是`1`后面跟着许多个零，然后以`83`结束+一个分数。

现在，如果这个数字是两个质数的乘积，并且这两个质数彼此接近，一个数字必须小于平方根，另一个数字必须大于平方根。

因此，如果我们从平方根开始，每次向后跳两个数字，尝试接近平方根的数字，我们最终会找到质数因子，我们找到了：

![](../images/00104.jpeg)

当然，我们可以向后跳两步，因为偶数肯定不是质数，所以我们不需要测试偶数。

正如我们所看到的，现在我们找到了一个数字，其中`n`模这个数字的结果为零，因此这是一个质数因子。

我们可以通过将`n`除以第一个质数来得到另一个质数因子：

![](../images/00105.jpeg)

因此，这里是原始数字`n`，它是两个质数的乘积，我们有其中一个质数；`q`是`n`除以`p`，你可以看到。为了测试它，如果我们计算`p*q`，我们会再次得到原始数字。因此，我们已经将一个大数字分解为`p`和`q`，这就足够破解RSA了。

所以，让我们在Python中尝试一下。转到终端并运行`python`：

![](../images/00106.jpeg)

所以，我们有`n`等于所示的大数字。我们将这个数字导入`decimal`库，并将位置设置为`50`位。现在，如果我们取平方根，我们得到`1`后面跟着许多个零，然后是`83`，然后是一个分数。然后，我们复制平方根的整数部分：

![](../images/00107.jpeg)

现在我们将`p`设置在该数字的范围内，如下所示：

```py
>>> for p in range(100000000000000000083, 100000000000000000030, -2):
```

这开始了一个循环，我们所要做的就是打印：

```py
...  print p, n%p
...
```

它将计算`n`模`p`，结果将为零。如果这是一个整数倍数，按两次*Enter*运行循环：

![](../images/00108.jpeg)

所以，我们可以看到这个数字是`p`：

```py
100000000000000000039 0
```

如果我们复制那个数字，我们可以将`p`设置为那个数字，然后将`q`设置为`n`除以`p`：

```py
>>> p = 100000000000000000039
>>> q = n/p
```

如果我们打印，我们将得到以下结果：

![](../images/00109.jpeg)

你可以看到`n`与`p*q`匹配。所以，我们现在已经将那个长数字分解为了它的互补质数。

这是第一个挑战：

![](../images/00110.jpeg)

这是第二个挑战：

![](../images/00111.jpeg)

在这两种情况下，你都能够将它们分解。

# 接下来呢？

**物联网**（**IoT**）有着光明的未来，很快将连接数十亿的设备。对于物联网，安全一直是一个主要关注点。但好消息是，加密为保护物联网免受黑客攻击提供了各种选择；因此，这是物联网即将到来的时代的关键。

# 物联网中的加密

当我们谈论在物联网中使用加密时，我们谈论的是在通信堆栈的许多层上使用加密。如果我们看一下OSI模型，我们可以看到加密在第2层及以上使用，链接在第2层操作，网络在第3层操作，传输在第4层操作：

![](../images/00112.jpeg)

在应用层，加密也用于通过认证和加密来保护通信。在我们开始描述物联网协议的特定加密方法之前，让我们先谈谈现有无线协议的利用工具的现成性。随着物联网的成熟，要记住有许多工具可用于利用物联网无线通信协议，这些工具将继续迅速跟上支持物联网引入的新技术。

例如，看看1989年推出的Wi-Fi 802.11，2004年推出的AirCrack工具至今仍然是一款受欢迎且得到良好支持的工具。还有许多工具可用于利用蓝牙通信和蜂窝通信。

除此之外，驱动加密的密钥必须在设备（模块）级别以及整个企业范围内得到安全管理。让我们来探讨其中一些。

# ZigBee加密密钥

ZigBee使用许多密钥进行加密操作：

+   **链路密钥**：这是基于制造商预先配置的主密钥建立的。链路密钥提供了两个ZigBee节点之间的点对点安全连接。链路密钥还用于建立派生密钥，包括数据密钥、密钥传输密钥和密钥装载密钥

+   **密钥传输密钥**：这个密钥是在使用链路密钥和1字节字符串0x00作为输入字符串执行专门的密钥散列函数的结果

# ZigBee密钥管理的复杂性

如前所述，密钥管理是具有挑战性的。让我们来看看密钥管理有多具有挑战性。例如，以ZigBee协议为例。在ZigBee网络中可以使用三种主要类型的密钥。主密钥通常由供应商预先安装，并保护两个ZigBee节点之间的交换，因为它们生成链路密钥。链路密钥支持节点之间的通信，网络密钥支持广播通信。

密钥管理功能可能内置于实用程序的媒体管理软件中，例如，也可能作为独立软件提供。然而，所有这些密钥在它们的整个生命周期中都需要得到充分的安全保护。

# 蓝牙-LE

蓝牙低功耗协议采用加密技术来配对设备以建立未来的关系。蓝牙-LE在这些加密过程中使用各种密钥，包括**长期密钥**（LTK），用于生成链路层加密的128位密钥，以及**连接签名解析密钥**（CSRK），用于在ATT层对数据进行数字签名。

通过这一切，我们来到了本书的结尾。加密应用应该根据威胁环境进行定制。加密是基于强大、精心设计的算法，并与通信堆栈的所有层相关联。它无处不在，对物联网系统的安全至关重要。

# 总结

在本章中，我们介绍了AES，这是当今常用的最强大的私钥系统，以及它的两种模式，ECB和CBC。我们还介绍了针对CBC的填充预言攻击，这是可能的，当错误消息给予攻击者比他们应该获得的更多有关加密过程的信息时。

最后，我们介绍了RSA，这是当今用于通过互联网发送秘密的主要公钥算法，我们还研究了一个挑战，即在两个素数相似而不是独立和随机选择的情况下我们是如何破解RSA的。我们还研究了加密技术的未来以及它如何帮助保护物联网设备。
