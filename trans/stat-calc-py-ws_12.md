# 12.使用Python进行中级微积分

概述

在本章结束时，你将能够解决涉及变量变化的方程的问题。在本章中，你将使用数值方法来模拟人口和温度，并使用微分方程来计算它们的过去值或预测它们的未来值。当你知道数字在特定范围内时，你将学会使用二分搜索来*猜测和检查*，以获得非常准确的解决方案。你还将模拟物体移动的情况，并在给定它们的速度微分方程时解决它们的未来位置。

# 介绍

数学学生经常抱怨代数和几何中出现的问题没有现实世界的应用，比如因式分解多项式或者角的二等分，但对于微分方程却不能这样说。使用本章中将学到的工具，你将能够用微分方程模拟和解决物理、电子和工程中的真实问题。Python是数学家和科学家的完美工具，他们想要进行数字计算和解决问题，但又不想为此再获得计算机科学学位。Python是最受欢迎的编程语言之一，因为它易于使用且没有不必要的抽象。

到了17世纪，数学家们用数学方程模拟了物体的运动，并把目光投向了外层空间的行星。牛顿模拟了它们的运动，他提出的方程不仅涉及未知数，还涉及这些数字的变化。例如，他的方程不仅包含一个未知角度，还包含这个角度的变化（它的角速度），甚至是角度变化的变化（它的加速度）！当时没有工具来解决这些方程，所以他不得不自己发明这些工具。这些工具后来被称为微积分。

# 微分方程

在数学课上解方程通常涉及一个未知数*x*。方程隐藏了这个值，但给了你一些提示，告诉你如何找到这个值，比如![1](image/B15968_12_InlineEquation1.png)。但是要解微分方程，你只能得到关于函数的导数的信息，然后期望你找到这个函数。可能是像下面这样简单的东西：

![图12.1：找到导数为2的函数

](image/B15968_12_01.jpg)

图12.1：找到导数为2的函数

这意味着*找到一个导数为2的函数*。这也可以写成如下形式：

![图12.2：表示函数导数的另一种方式

](image/B15968_12_02.jpg)

图12.2：表示函数导数的另一种方式

通过简单的积分，我们可以找到适用于这个方程的函数，因为我们知道函数*y = 2x*的导数是2。事实上，许多相关函数，比如*y = 2x + 1*，*y = 2x + 2*，*y = 2x + 3*等等，它们的导数都是2。所以，我们写出一个一般形式，即*y = 2x + C*。

当我们没有太多线索时，事情就变得更加复杂，就像在这个方程中：

![图12.3：函数值为函数本身的导数

](image/B15968_12_03.jpg)

图12.3：函数值为函数本身的导数

这是要求一个导数为函数本身的函数。

为了理解微分方程是如何使用的，让我们从简单的函数开始，以及涉及到现实世界中的东西，比如金钱。

# 利息计算

微分方程研究中有一个关键工具起源于中世纪的利息计算研究。让我们来看下面的练习。

## 练习12.01：计算利息

一个储蓄账户每年支付2%的利息。如果投资了3500美元，5年后账户中有多少钱？

简单利息的公式如下：

![图12.4：简单利息公式

](image/B15968_12_04.jpg)

图12.4：简单利息公式

在这里，*I*是利息，*P*是本金或原始投资金额，*r*是利率或增长率，*t*是投资金额已投资的时间。根据这个公式，金额的利息为*I = (3500)(0.02)(5) = 350美元*。按照以下步骤完成此练习：

1.  这是一个很好的机会来开始一个程序，它将接受初始金额、利率和时间，并使用前面的公式输出利息收入：

```py
    def amount(p0,rate,t):
        """Returns the amount after t
        years starting at p0 and growing
        at the given rate per year"""
        return p0*rate*t
    ```

1.  如您在`amount`函数的文档字符串中所看到的，它将接受一个起始金额和增长率，并返回给定年数后的投资金额。让我们看看1-5年内的利息收入：

```py
    for i in range(1,6):
        print(i,amount(3500,0.02,i))
    ```

以下是输出：

```py
    1 70.0
    2 140.0
    3 210.0
    4 280.0
    5 350.0
    ```

但这并不是利息的真正工作方式。每年几次，我们计算该年份的利息收入，将其加到本金中，新的本金更高。下一次的利息计算是在更高的数字上，因此称为*复利*。给定*每年n次复利*的*t*年后的金额的公式如下：

![图12.5：计算t年后的金额公式

](image/B15968_12_05.jpg)

图12.5：计算t年后的金额公式

1.  让我们将`amount`函数更改为以下内容：

```py
    def amount(p0,rate,t,comps):
        """Returns the amount after t
        years starting at p0 and growing
        at the given rate per year
        compounded comps times per year"""
        for i in range(int(t*comps)):
            p0 += p0*rate/comps
        return p0
    ```

在这个函数中，我们添加了按复利次数给出的年份的利息收入。如果我们每年只计算一次复利，看起来是这样的：

```py
    for i in range(1,6):
        print(i,amount(3500,0.02,i,1))
    ```

这就是我们得到的：

```py
    1 3570.0
    2 3641.4
    3 3714.228
    4 3788.51256
    5 3864.2828112
    ```

因此，在5年结束时，我们赚了364美元，而不仅仅是350美元。即使利率相同，复利更频繁也会使金额增长更快。如果我们将复利更改为每年12次（每月复利），我们将在5年后得到3867美元，比年复利多一点。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3dUWz7C](https://packt.live/3dUWz7C)。

您也可以在[https://packt.live/3iqUKCO](https://packt.live/3iqUKCO)上在线运行此示例。

## 练习12.02：计算复利-第1部分

在一个年利率为5.5%的储蓄账户中投资了2000美元，按月复利。要将金额增长到8000美元需要多长时间？按照以下步骤来解决这个问题：

1.  我们将使用我们从上一个练习中的`amount`函数打印出投资的前5年：

```py
    for i in range(1,6):
        print(i,amount(2000,0.055,i,12))
    ```

输出如下：

```py
    1 2112.815720771071
    2 2231.9951349686903
    3 2357.8972049231984
    4 2490.9011412619493
    5 2631.4075450724245
    ```

1.  5年后，金额只有2631美元。要达到8000美元，我们必须走20或30年：

```py
    for i in [5,10,15,20,25,30]:
        print(i,amount(2000,0.055,i,12))
    ```

输出如下：

```py
    5 2631.4075450724245
    10 3462.1528341320413
    15 4555.167544964467
    20 5993.251123444263
    25 7885.343112872511
    30 10374.775681348801
    ```

在25到30年之间的某个时候，我们将达到8000美元。更精确的方法是更聪明地猜测。

1.  我们将范围减半，并根据我们得到的结果猜测更高或更低。例如，25年和30年的平均值是27.5，因此我们输入以下内容：

```py
    print(amount(2000,0.055,27.5,12))
    ```

以下是输出：

```py
    9044.814313545687
    ```

因此，我们将在27.5年内达到9000美元。达到8000美元的时间必须少于这个时间。

1.  我们将计算25和27.5的平均值并将其代入：

```py
    def average(a,b):
        return (a+b)/2
    print(amount(2000,0.055,average(25,27.5),12))
    ```

以下是输出：

```py
    8445.203624219383
    ```

1.  让我们编写一个程序，直到找到答案为止。这称为**二分搜索**。让我们创建一个`bin_search`函数，它将使用我们正在使用的函数的名称，我们正在搜索的范围的下限和上限以及目标输出（在本例中为8000）作为参数：

```py
    def bin_search(f,lower,upper,target):
        for i in range(20):
            avg = average(lower,upper)
    ```

1.  这是关键的一行。它将平均值插入函数中，使用所有其他必需的参数，并将输出分配给`guess`变量。我们将检查该变量是否等于我们的目标，或者我们是否需要猜测更高或更低：

```py
            guess = f(2000,0.055,avg,12)
            if guess == target:
                return guess
            if guess > target:
                upper = avg
            else:
                lower = avg
        return avg
    ```

1.  我们将我们范围的下限和上限以及我们的目标数字代入我们的函数，以获得我们的近似值：

```py
    bin_search(amount,25,30,8000)
    ```

输出如下：

```py
    25.333333015441895
    ```

1.  看起来我们将在**25年零4个月**内达到8000美元。让我们检查一下：

```py
    amount(2000,0.055,25.334,12)
    ```

果然，复利后的余额超过了8000美元：

```py
    8030.904658737448
    ```

我们将再次使用二分搜索，但现在，让我们使用我们的代码来找到一个在微分方程中经常出现的相当重要的数学常数。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3iq95PV](https://packt.live/3iq95PV)

您还可以在[https://packt.live/2BpdbHI](https://packt.live/2BpdbHI)上在线运行此示例

## 练习12.03：计算复利-第2部分

如果您以100%的利率投资$1，连续复利1年，您会赚多少？

请记住，复利的频率越高，最终金额就越高。您认为会是多少？$1.50？$2？本金、利率和时间都是1，但`comps`变量是什么？按照以下步骤完成这个练习：

1.  为了近似连续复利，我们将每秒复利一次（每年*365*24*60*60*次）：

```py
    print(amount(1,1,1,365*24*60*60))
    ```

输出如下：

```py
    2.7182817853606362
    ```

大约是$2.72。这个数字，2.71828…，是自然对数的底数*e*。它对于模拟自然界中的人口非常有用，因为动物、植物和微生物不会等到月底才繁殖-它们是持续不断地繁殖。因此，当利息连续复利或人口自然增长时，我们将使用这个公式：

![图12.6：计算复利的公式

](image/B15968_12_06.jpg)

图12.6：计算复利的公式

1.  让我们创建一个函数来快速完成这个任务。首先，我们需要从`math`模块中导入*e*以进行连续复利：

```py
    from math import e
    ```

1.  创建一个`pert`函数，它将插入初始金额或人口、增长率和时间，并返回最终金额：

```py
    def pert(P,r,t):
        return P*e**(r*t)
    ```

我们将在本章中多次使用这个函数。现在，让我们回答更多的投资问题。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2D2Q1r0](https://packt.live/2D2Q1r0)

您还可以在[https://packt.live/31G5pDQ](https://packt.live/31G5pDQ)上在线运行此示例

## 练习12.04：计算复利-第3部分

一个人以每月复利的18%年利率借了$5,000。1年后这个人会欠多少钱？按照以下步骤完成这个练习：

1.  我们可以将其放入我们的函数调用中：

```py
    amount(5000,0.18,1,12)
    ```

输出如下：

```py
    5978.090857307678
    ```

为了比较，让我们看看如果利息是连续复利会发生什么。

1.  我们将使用我们的`pert`函数输入`P = 5000`，`r = 0.18`和`t = 1`作为值：

```py
    print("Continuous:",pert(5000,0.18,1))
    ```

得到的金额如下：

```py
    5986.096815609051
    ```

注意

要访问此特定部分的源代码，请参阅[https://packt.live/31ES5Qi](https://packt.live/31ES5Qi)

您还可以在[https://packt.live/3f5j0s4](https://packt.live/3f5j0s4)上在线运行此示例

## 练习12.05：成为百万富翁

如果您以每日复利8%的年利率投资$1,000，要成为百万富翁需要多长时间？如果初始金额是$10,000呢？按照以下步骤完成这个练习：

1.  首先，让我们定义`bin_search`函数，如下所示：

```py
    def bin_search(f,lower,upper,target):
        for i in range(20):
            avg = average(lower,upper)
            #Be sure to change this line
            #if the principal, rate or
            #compounding changes:
            guess = f(1000,0.08,avg,365)
            if guess == target:
                return guess
            if guess > target:
                upper = avg
            else:
                lower = avg
        return avg
    ```

1.  让我们猜一些野生的猜测，看看如果$1,000投资这些年，我们会得到多少：

```py
    for i in [10,20,30,40,50]:
        print(i,amount(1000,0.08,i,365))
    ```

这是输出：

```py
    10 2225.34584963113
    20 4952.164150470476
    30 11020.277938941583
    40 24523.929773205105
    50 54574.22533744746
    ```

1.  50年后，您仍然只有$54,000，而不是一百万。但是100年后，您将拥有近300万：

```py
    amount(1000,0.08,100,365)
    ```

这是输出：

```py
    2978346.0711824815
    ```

1.  答案必须在50和100之间。看起来是我们二分搜索的任务：

```py
    print(bin_search(amount,50,100,1000000))
    ```

我们得到以下输出：

```py
    86.3588809967041
    ```

1.  这表明在86.36年后，我们将拥有100万美元。如果初始投资是$10,000，那么在`bin_search`函数中更新`guess`变量：

```py
            guess = f(10000,0.08,avg,365)
    ```

这是我们将打印所需输出的方法：

```py
    for i in [10,15,20,30,40,50,60]:
        print(i,amount(10000,0.08,i,365))
    ```

输出如下：

```py
    10 22253.458496311334
    15 33196.803971077774
    20 49521.64150470513
    30 110202.77938941623
    40 245239.2977320514
    50 545742.2533744735
    60 1214465.2585152255
    ```

1.  因此，我们在50到60年之间就能达到100万美元。让我们在我们的二分搜索函数中将`1000`改为`10000`并检查一下：

```py
    print(bin_search(amount,50,60,1000000))
    ```

我们得到以下输出：

```py
    57.57260322570801
    ```

超过57.57年才能达到一百万美元。

因此，我们开始学习微分方程是通过研究复利来学习的。一定金额的钱每年、每月或每天都会有利息率。初始金额

注意

要访问此特定部分的源代码，请参阅[https://packt.live/31ycoPg](https://packt.live/31ycoPg)

您也可以在[https://packt.live/2NMT9sX](https://packt.live/2NMT9sX)上在线运行此示例

现在，我们将同样的推理扩展到人、动物、细菌和热量的数量，这些数量不断变化，或者说是*连续*的。

# 人口增长

微分方程对于找到特定时间的人口、动物和细菌的数量的公式非常有用；例如：

![图12.7：计算时间t的微分方程

](image/B15968_12_07.jpg)

图12.7：计算时间t的微分方程

这个微分方程意味着*y*的变化速率与*y*成比例，或者说人口的增长与其数量成比例。这就是人口增长率的定义：人口的一部分或百分比。解决方案类似于涉及连续复利的利息问题：

![图12.8：计算变化率的微分方程

](image/B15968_12_08.jpg)

图12.8：计算变化率的微分方程

## 练习12.06：计算人口增长率-第1部分

在1980年代，肯尼亚的年人口增长率为4%。以这个速度，人口翻倍需要多长时间？按照以下步骤完成这个练习：

1.  无论初始人口是多少，我们都在寻找使因子*e*rt等于2的*t*。我们可以使用我们的`pert`函数和二项式搜索函数，稍作调整：

```py
    def bin_search(f,lower,upper,target):
        for i in range(40):
            avg = average(lower,upper)
            guess = f(1,0.04,avg)
            if guess == target:
                return guess
            if guess > target:
                upper = avg
            else:
                lower = avg
        return avg
    ```

1.  我们正在寻找时间*t*，以4%的增长率将我们的初始人口从1增加到2。我们估计这个时间会在1到100年之间：

```py
    print(bin_search(pert,1,100,2))
    ```

输出如下：

```py
    17.32867951408025
    ```

我们可以用代数来验证这一点。我们取方程两边的对数并解出*t*：

![图12.9：解决时间(t)的方程

](image/B15968_12_09.jpg)

图12.9：解决时间(t)的方程

1.  这意味着在17年多一点的时间内，肯尼亚的人口将翻倍。我们可以用我们的`amount`函数来验证这一点。1989年，肯尼亚的人口为2100万：

```py
    print(amount(21000000,0.04,17.3,1000000))
    ```

以下是输出：

```py
    41951845.46179989
    ```

是的，每年使用一百万次复利，人口在17.3年内增长到了将近4200万。

作为对此的回应，肯尼亚政府大力推广*计划生育*。这有效果吗？

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2BxsfCT](https://packt.live/2BxsfCT)

您也可以在[https://packt.live/2Zuoy9c](https://packt.live/2Zuoy9c)上在线运行此示例

## 练习12.07：计算人口增长率-第2部分

2010年，肯尼亚的人口为4200万。到2019年，人口为5250万。该范围的年人口增长率是多少？

我们可以再次使用二分搜索函数，返回给定初始人口（以百万计）、时间*t*和9年后的目标人口（以百万计）的增长因子*r*。

在`bin_search`函数中，将时间更改为`9`：

```py
        guess = f(1,avg,9)
```

然后，我们将找到这9年的年增长率。我们知道它在0到2之间：

```py
print(bin_search(pert,0,2,52.5/42))
```

打印出的值如下：

```py
0.024793727925498388
```

计划生育项目一定是有效的！肯尼亚将其人口增长率降低到了2.5%。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3eWKzDW](https://packt.live/3eWKzDW)

您也可以在[https://packt.live/31EKPUq](https://packt.live/31EKPUq)上在线运行此示例

# 放射性材料的半衰期

与人口问题类似，半衰期问题涉及一个群体，但其中一半是放射性材料的原子，其中一半的原子随着时间变成了不同物质的原子。例如，碳-14衰变成氮-14，大约需要5730年才能使一半的碳衰变。这使得*放射性碳测年*成为从考古学到检测伪造艺术品的关键工具。

## 练习12.08：测量放射性衰变

镭-226的半衰期为1600年。在给定样本中，800年内将消失多少镭？

意思是“物质的衰变速率与物质的数量成比例”的微分方程表达如下：

![图12.10：用于计算物质衰变速率的微分方程

](image/B15968_12_10.jpg)

图12.10：用于计算物质衰变速率的微分方程

解决方案与我们的人口问题类似，只是衰减因子是负的，因为数量减少：

![图12.11：使用负衰变因子计算变化率

](image/B15968_12_11.jpg)

图12.11：使用负衰变因子计算变化率

这意味着最终金额等于时间的初始金额，*e*，乘以衰减因子，*r*，和时间，*t*的乘积。我们可以像解决人口问题一样使用我们的二分搜索函数。我们正在寻找在1,600年内使我们的人口减半的增长率*r*。按照以下步骤完成这个练习：

1.  在`bin_search`函数中的`guess =`行中将`t`更改为`1600`：

```py
            guess = f(1,avg,1600)
    ```

1.  然后，搜索增长因子，我们认为它将在-2和0之间。我们的目标金额是起始金额的一半：

```py
    print(bin_search(pert,-2,0,0.5))
    ```

以下是输出：

```py
    -0.0004332169864937896
    ```

1.  这就是镭-226的衰变因子*r*。我们要做的就是将其插入我们的`pert`函数中，以找出800年后剩下的样本的百分比：

```py
    pert(1,-0.0004332,800)
    ```

以下是输出：

```py
    0.7071163910309745
    ```

因此，大约71%的样本在800年后仍然存在。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2YSzQ84](https://packt.live/2YSzQ84)

您还可以在[https://packt.live/2ByUwJj](https://packt.live/2ByUwJj)上在线运行此示例

## 练习12.09：测量历史文物的年龄

对一块布进行了放射性碳测年。这意味着科学家们测量了有多少碳-14（半衰期5730年）衰变成了更稳定的同位素。他们发现剩下的碳-14的数量是碳-13的10倍。这块布有多大年龄？

如果碳-14需要5730年使其数量减半，我们需要找到我们的Pert公式的速率*r*：

![图12.12：Pert公式

](image/B15968_12_12.jpg)

图12.12：Pert公式

按照以下步骤完成这个练习：

1.  我们使用我们的二分搜索函数来解决*r*：

```py
    def bin_search(f,lower,upper,target):
        for i in range(40):
            avg = average(lower,upper)
    ```

1.  这是更改的那一行。如果我们在`pert`函数中放入一个起始金额为`1`，*r*将是`avg`，`5730`将是目标时间：

```py
            guess = f(1,avg,5730)
            if guess == target:
                return guess
            if guess > target:
                upper = avg
            else:
                lower = avg
        return avg
    print(bin_search(pert,-2,0,0.5))
    ```

以下是输出：

```py
    -0.00012096809405193198
    ```

*r = -0.000120968*，因此我们的Pert公式变为如下：

![图12.13：在Pert公式中替换r的新值

](image/B15968_12_13.jpg)

图12.13：在Pert公式中替换r的新值

这意味着*x*克的碳-14衰变了，剩下的是10x克，是整个样本的10倍。因此，衰变量是整个样本的1/11或0.091。结束金额是1-0.091。这使我们的Pert方程如下：

![图12.14：带有结束金额的Pert方程

](image/B15968_12_14.jpg)

图12.14：带有结束金额的Pert方程

1.  我们方程中唯一未知的是*t*，因此我们正在更改我们的`bin_search`函数，以便有策略地猜测和检查正确的*t*。返回到您的`bin_search`函数；开头应该是这样的：

```py
    def bin_search(f,lower,upper,target):
        for i in range(40):
            avg = average(lower,upper)
    ```

1.  这是我们正在更改的行。我们将1代入原始量，长小数是我们的*r*，时间范围的平均值用于时间。目标是样本的0.091，这将保持猜测和平均值，直到返回确切的年数以达到目标值：

```py
            guess = f(1,-0.000120968,avg)
            if guess == target:
                return guess
    ```

1.  由于它是一个递减函数，如果猜测小于目标值，我们将会超过目标值，`upper`数字将被替换为平均值：

```py
            if guess < target:
                upper = avg
            else:
                lower = avg
        return avg
    print(bin_search(pert,1,100000,0.91))
    print(pert(1,-0.000120968,5730))
    ```

1.  请注意，我们更改了`if guess < target:`行。我们正在寻找从1到0.91的衰减量所需的年数，以给定的速率。我们怀疑它在1到100,000年之间。第二个`print`行只是检查我们的`pert`函数确认在5,730年后，剩余量正好是原始量的一半。当我们运行代码时，这是输出：

```py
    779.633287019019
    0.5000002702800457
    ```

根据我们的计算，这块布大约有**780年**的历史。

因此，我们最初编写此代码是为了测量投资中剩余的金额，该投资以给定的利率增长一段时间。在本节中，我们将此应用于物体中放射性物质的剩余量，该物质以已知速率衰变，时间未知。这就是科学家计算考古文物年龄的方法。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3eOJJJv](https://packt.live/3eOJJJv)。

您也可以在[https://packt.live/38mESgn](https://packt.live/38mESgn)上在线运行此示例。

接下来，我们将使用相同的思路，但将其应用于物体的温度变化，比如一杯咖啡或人体的温度。

# 牛顿冷却定律

你是否曾经想过在警察节目中带着乳胶手套的**犯罪现场调查员**（**CSI**）如何判断受害者的死亡时间？艾萨克·牛顿被认为是发现物质冷却遵循微分方程的人：

![图12.15：温度变化速率的微分方程

](image/B15968_12_15.jpg)

图12.15：温度变化速率的微分方程

看看这个微分方程与我们以前看到的微分方程略有不同？这不是物质温度变化速率与物质温度成比例，而是说“物质温度变化速率与物质温度与环境温度之间的差值成比例”。因此，如果一杯热咖啡放在热的房间里，它的温度变化速度会比放在非常冷的房间里慢。同样，我们知道警察节目中受害者的体温起始温度：98.6°F。

## 练习12.10：计算死亡时间

一名调查员到达犯罪现场并测量环境和尸体的温度。如果环境温度为65°，尸体温度为80°，调查员记录时间并等待一小时。尸体温度与环境温度的差为15度。一个小时后，环境温度仍为65°，尸体进一步冷却至75°。温度差现在为10度。受害者是何时死亡的？

有了这些信息，她可以建立以下方程：

![图12.16：计算死亡时间的方程

](image/B15968_12_16.jpg)

图12.16：计算死亡时间的方程

按照以下步骤完成这个练习：

1.  我们可以使用二分搜索来找出温度的衰减率。我们需要导入`e`并确保我们有`pert`和`average`函数：

```py
    from math import e
    def pert(P,r,t):
        return P*e**(r*t)
    def average(a,b):
        return (a+b)/2
    ```

1.  我们的`bin_search`函数的第一部分与以前相同：

```py
    def bin_search(f,lower,upper,target):
        for i in range(40):
            avg = average(lower,upper)
    ```

1.  这里的重要变化是：我们的原始量（温度差）为15度，我们想知道*r*，即我们Pert公式中的变化率：

```py
            guess = f(15,avg,1)
            if guess == target:
                return guess
            if guess > target:
                upper = avg
            else:
                lower = avg
        return avg
    print(bin_search(pert,-2,0,10))
    ```

这是输出：

```py
    -0.4054651081078191
    ```

这就是这种情况的衰减速率，所以我们知道了尸体温度与环境温度之间的初始差异（98.6-65），以及最终差异（10）和衰减速率。这是情况的图表：

![图12.17：冷却体的图表

](image/B15968_12_17.jpg)

图12.17：冷却体的图表

我们只需要知道差异衰减到10所需的小时数。我们的方程如下：

![图12.18：差异衰减到10所需的小时数

](image/B15968_12_18.jpg)

图12.18：差异衰减到10所需的小时数

1.  我们改变我们的二分搜索函数来获取时间：

```py
    def bin_search(f,lower,upper,target):
        for i in range(40):
            avg = average(lower,upper)
            guess = f(33.6,-.4055,avg)
            if guess == target:
                return guess
            if guess > target:
                upper = avg
            else:
                lower = avg
        return avg
    ```

但是，如果时间太短，差异将太大。绕过这个最简单的方法是将更高的*t*作为函数调用的*较低*部分，将较低的*t*作为搜索范围的*上限*。

1.  调查员推断时间必须在0到5小时之间：

```py
    print(bin_search(pert,5,0,10))
    ```

输出将如下：

```py
    2.9887570258370033
    ```

几乎正好3小时。这看起来接近前图中曲线的*y*值为10的时间。

1.  让我们在我们的`pert`函数中检查一下。从*r = -0.4055*和*t = 3.0*开始，差异为33.6度。希望最终得到10：

```py
    pert(33.6,-0.4055,3)
    ```

以下是输出：

```py
    9.954513505592326
    ```

所以，现在，当明星侦探在凌晨2:30到达现场时，调查员可以说，“死亡时间大约是晚上11:30。”

注意

要访问此特定部分的源代码，请参阅[https://packt.live/38jN68K.](https://packt.live/38jN68K )

您还可以在[https://packt.live/3gefegi.](https://packt.live/3gefegi )上在线运行此示例

## 练习12.11：计算温度变化的速率

一杯温度为175°F的咖啡放在一个72°F的房间里。我们等待15分钟，测量咖啡的温度，发现它已经变成了140°F。按照这个速度，从开始算起1小时后它的温度会是多少？按照以下步骤完成这个练习：

1.  差异从103°（175-72）开始。在0.25小时内，它变为68°（140-72）。现在，我们可以建立一个方程：![图12.19：计算咖啡温度差异的方程

](image/B15968_12_19.jpg)

图12.19：计算咖啡温度差异的方程

1.  我们可以改变我们的二分搜索函数以反映这种情况。将`guess=`行更改为`bin_search`函数中的以下内容：

```py
            guess = f(103,avg,0.25)
    ```

1.  运行它，找出在-2和0之间的*r*将给我们带来68°的差异：

```py
    print(bin_search(pert,-2,0,68))
    ```

这是输出：

```py
    -1.6608851322143892
    ```

1.  太快了！将其放入我们的Pert公式中，*P = 103*和*t=1*：

```py
    pert(103,-1.6608851322143892,1)
    ```

以下是输出：

```py
    19.566987911888482
    ```

这是1小时的差异。如果房间温度为72°，那意味着咖啡将是*72 + 19.5 = 91.5°*。

注意

访问此特定部分的源代码，请参阅[https://packt.live/3gl5p0i.](https://packt.live/3gl5p0i )

您还可以在[https://packt.live/2YTdCmw.](https://packt.live/2YTdCmw )上在线运行此示例

# 混合问题

在代数中，有一些需要计算的文字问题，您必须计算出需要添加多少材料到混合物中才能获得特定的浓度或数量。在微积分中，自然，问题必须更难：例如，混合物正在改变；材料正在进入混合物，材料正在流出。您必须找出在特定时间后有多少混合物或溶剂。让我们看看以下练习，以更好地理解这个概念。

## 练习12.12：解决混合问题-第1部分

一个罐子里含有82加仑的卤水，其中溶解了18磅的盐。每分钟以5加仑的速度流入罐子的卤水中含有每加仑3磅的溶解盐。这种混合物通过搅拌保持均匀，以每分钟2加仑的速度流出罐子。39分钟后罐子里有多少盐？

正如你可以想象的，这种问题会导致一些复杂的微分方程，只有经过几页的代数运算，你才能得到一个方程（通常涉及到* e*的某个幂），然后你可以将时间代入并得到最终的数量。然而，使用编程，我们只需从给定的起始溶液开始，并添加和减去问题所需的任何材料。这只是一个跟踪溶液和溶质的问题。按照以下步骤完成这个练习：

1.  让我们创建一个函数，以找出在`t`分钟后的盐含量，给定我们的初始条件：

```py
    def salt_content(t):
        salt = 18 #pounds
        brine = 82 #gallons
    ```

1.  然后，每分钟都会添加5加仑的卤水，其中含有15磅（每加仑3磅盐*每加仑*）的盐：

```py
        for i in range(t):
            brine += 5
            salt += 15
    ```

1.  现在，每分钟流出2加仑的卤水，但其中含有多少盐呢？这要求我们找出每加仑卤水的浓度：![图12.20：计算每加仑卤水浓度的公式

](image/B15968_12_20.jpg)

图12.20：计算每加仑卤水浓度的公式

这可以很容易地转换为代码，如下所示：

```py
            concentration = salt/brine
    ```

1.  因此，每分钟离开罐子的盐将是流出的溶液加仑数乘以盐的浓度：

```py
            salt_out = 2*concentration
            salt -= salt_out
            brine -= 2
    ```

1.  循环结束后，我们可以打印出卤水和盐的最终数量：

```py
        print(i,brine,salt)
    ```

1.  为了解决我们的问题，我们只需运行我们的`salt_content`函数，*t=39*：

```py
    salt_content(39)
    ```

输出如下：

```py
    38 199 469.2592152141211
    ```

这意味着在39分钟后，我们最终得到469磅盐。这个数字非常接近解析解，但并不完全相同。我们该怎么做才能得到更准确的结果呢？记住，自然对数的底数*e*的背后思想是模拟值的恒定变化，而我们只是每分钟计算一次我们溶液的变化。

1.  让我们引入一个名为`frac`的变量，它将让我们计算分钟的变化：

```py
    def salt_content(t,frac=0.001):
        salt = 18 #pounds
        brine = 82 #gallons
    ```

1.  参数中的`frac=0.001`值表示我们将每分钟计算一千次变化。这意味着我们将循环的次数乘以1,000，或者1/`frac`，我们将我们的数量变化乘以`frac`：

```py
        for i in range(int(t/frac)):
            brine += 5*frac
            salt += 15*frac
            concentration = salt/brine
            salt_out = 2*concentration*frac
            salt -= salt_out
            brine -= 2*frac
        print(i,brine,salt)
    salt_content(39)
    ```

输出变成了以下内容：

```py
    38999 198.99999999966812 470.74539697793307
    ```

470.7磅盐甚至更接近解析解，使用更小的分钟分数并不会改变输出太多。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2BlX2Tn](https://packt.live/2BlX2Tn)。

您也可以在[https://packt.live/3dSrEcm](https://packt.live/3dSrEcm)上在线运行此示例。

让我们在其他问题上使用这个函数。

## 练习12.13：解决混合问题-第2部分

一个罐子里含有10,000升浓度为每100升1千克盐的卤水溶液。每秒以20升的速度流入罐中含有每100升2千克盐的卤水。混合物（均匀）以每秒10升的速度流出。找出在5分钟内罐中有多少盐。按照以下步骤完成这个练习：

1.  因此，我们需要进行一些简单的算术运算来找出我们的初始盐量，但是每100升1千克盐是10,000升中的100千克盐，而流入罐中的20升中是0.4千克盐。这是我们的新函数：

```py
    def salt_content(t,frac=.001):
        salt = 100
        brine = 10000
        for i in range(int(t/frac)):
            brine += 20*frac
            salt += 0.4*frac
            concentration = salt/brine
            salt_out = 10*concentration*frac
            salt -= salt_out
            brine -= 10*frac
        return salt
    ```

现在，让我们调用`salt_content`函数：

```py
    print(salt_content(5*60))
    ```

当我们调用函数时，输出如下：

```py
    183.0769053279811
    ```

（记住，我们所有的数字都是以秒为单位的，我们想要5分钟，因此是`5*60`参数。）

输出告诉我们，在5分钟内溶液中有183千克盐。这非常接近解析解。

1.  我们可以通过将硬编码的数字更改为变量来简化我们的任务，因此当我们遇到不同初始卤水量的问题时，例如，我们只需在函数调用中输入不同的数字。我们需要变量来表示初始卤水量（或任何溶液）、溶质的初始量（到目前为止，我们一直在使用盐）、卤水的流入速度、盐的流入速度和卤水的流出速度。以下是如何更改函数的方法：

```py
    def salt_content(t,salt_0,brine_0,salt_in,brine_in,v_out,frac=.001):
        salt = salt_0 #pounds
        brine = brine_0 #gallons
        for i in range(int(t/frac)):
            brine += brine_in * frac
            salt += salt_in* frac
            concentration = salt/brine
            salt_out = v_out*concentration* frac
            salt -= salt_out
            brine -= v_out* frac
        return salt
    ```

1.  现在，要解决最后一个问题，我们的函数调用将有更多的参数：

```py
    salt_content(300,100,10000,0.4,20,10)
    ```

输出如下：

```py
    183.0769053279811
    ```

如您所见，输出应与*步骤1*中的相同。让我们将其应用到更多问题上。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3gkTWOd.](https://packt.live/3gkTWOd )

您还可以在[https://packt.live/3eSWF17.](https://packt.live/3eSWF17 )上在线运行此示例

## 练习12.14：解决混合问题-第3部分

一个大桶中含有100升糖水混合物，含有900克糖。每分钟以5克糖每升的速度进入大桶的糖水混合物为2升。另一个含有每升10克糖的混合物以每分钟1升的速度流入大桶。大桶保持混合，所得的混合物以每分钟3升的速度从大桶中排出。在1小时内找出大桶中的糖量。按照以下步骤完成此练习：

1.  这里唯一的诀窍是总溶液进入速度为每分钟3升，总溶质进入速度为每分钟20克。以下是函数调用：

```py
    salt_content(60,900,100,20,3,3)
    ```

1.  输出将如下所示：

```py
    705.2374486274181
    ```

溶质的量为705克。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2YRWNIl.](https://packt.live/2YRWNIl )

您还可以在[https://packt.live/2YRWKfD.](https://packt.live/2YRWKfD )上在线运行此示例

## 练习12.15：解决混合问题-第4部分

如果我们添加纯水会怎样？这会让它更难还是更容易？让我们试试这个。

一个罐子中含有1200升水和18克盐的卤水混合物。淡水以每分钟15升的速度进入罐子，并且罐子被搅拌以保持均匀。一根管子以每分钟10升的速度排出混合物。15分钟后罐子中有多少盐？按照以下步骤完成此练习：

1.  我们可以使用我们的`salt_content`函数，但`盐`变量将设置为`0`。这使得以下函数调用：

```py
    print(salt_content(15,18,1200,0,15,10))
    ```

1.  15分钟后的盐含量输出如下：

```py
    15.944648402124784
    ```

盐含量从18克减少到15.9克。

注意

访问此特定部分的源代码，请参阅[https://packt.live/2ZsLTIs.](https://packt.live/2ZsLTIs )

您还可以在[https://packt.live/2AnLrT8.](https://packt.live/2AnLrT8 )上在线运行此示例

因此，我们已经看到了通常需要大量代数操作才能找到情况的方程的微分方程的几个主题，以便（大概）我们可以插入一个变量并获得所寻找的温度、位置或数量。使用Python进行建模和运行模拟已经为我们节省了大量的代数，并且仍然为我们提供了非常准确的答案。

# 欧拉方法

在大学数学课程中，您学习了所有这些代数方法来求导数和积分以及解决微分方程。我们没有提到拉普拉斯变换，这是解决微分方程的更复杂的方法。现在，关于微分方程的肮脏秘密是，除非您主修工程学，否则学校不会告诉您的是，您在现实生活中遇到的大多数微分方程都没有*解析解*。

好消息是，数百年来一直有避免混乱代数的数值方法，随着计算机的发明，这些方法已经成为标准。即使存在解析解，数值方法对于实际目的几乎与解析方法一样准确，并且只需花费一小部分时间即可获得解决方案。

欧拉方法的思想非常简单：

1.  从已知点开始。

1.  使用微分方程在此点计算导数。这是曲线在此点处的方向。

1.  向计算出的方向迈出一小步。

1.  重复直到达到所需范围的末尾。

## 练习12.16：使用欧拉方法解决微分方程

给定微分方程![2](image/B15968_12_InlineEquation4.png)。您想知道在特定值*x*处函数*y=f(x)*的输出。您在图上给出了一个点：*f(0) = 1*。这意味着，“在每个点上，这个函数的导数是该点的y值。”请记住，导数是图上的点朝向或方向。欧拉方法是从初始值开始，即在这种情况下，在(0,1)，并使用微分方程计算到下一个点的方向。**微分方程**（**DE**）规定斜率是*y*值，因此我们在正*x*方向上迈出一小步：

![图12.21：朝着正确方向迈出小步（希望如此）

](image/B15968_12_21.jpg)

图12.21：朝着正确方向迈出小步（希望如此）

导数如下：

![图12.22：函数的导数

](image/B15968_12_22.jpg)

图12.22：函数的导数

因此，*ΔY*变为以下内容：

![图12.23：计算ΔY的公式

](image/B15968_12_23.jpg)

图12.23：计算ΔY的公式

这是导数和步长的乘积。要找到下一个*y*值，我们将*ΔY*添加到先前的*y*值。在新点上，我们重复这个过程：计算这一点的函数斜率，乘以步长，然后加到当前的*y*值上。按照以下步骤进行：

1.  让我们编写一个Python函数来做到这一点：

```py
    def euler(x0,y0,target_x,stepsize):
        x,y = x0,y0
        while x<target_x:
            slope = y #from diff eq
            x += stepsize
            y += stepsize*slope
            print(x,y)
        return y
    ```

1.  因此，我们知道初始的`x`和`y`。我们想知道`x=2`时的`y`；步长可以是½：

```py
    print(euler(0,1,2,0.5))
    ```

以下是输出：

```py
    0.5 1.5
    1.0 2.25
    1.5 3.375
    2.0 5.0625
    5.0625
    ```

1.  我们不再需要`euler`函数内的`print`语句，因此将其注释掉：

```py
            #print(x,y)
    ```

1.  第一行是计算斜率的结果，即*y*值1，乘以步长½，然后向上移动该距离。如果导数为负，我们将向下移动。在第二行，我们将*y*值1.5乘以步长0.5，得到0.75。我们从0.75上升到2.25等等。在x方向上采取小步骤，直到达到目标x值2，我们最终得到*y*值5.0625。我们不再需要打印出每一步，但让我们将步长减半10次：

```py
    for n in [0.5**i for i in range(10)]:
        print(n,euler(0,1,2,n))
    ```

以下是输出：

```py
    1.0 4.0
    0.5 5.0625
    0.25 5.9604644775390625
    0.125 6.583250172027423
    0.0625 6.958666757218805
    0.03125 7.166276152788222
    0.015625 7.275669793128417
    0.0078125 7.3318505987410365
    0.00390625 7.3603235532692795
    0.001953125 7.374657160341845
    ```

因此，步长越小，我们似乎越接近7.37。这是近似路径的图形：

![图12.24：使用较小的步长获得更好的近似

](image/B15968_12_24.jpg)

图12.24：使用较小的步长获得更好的近似

第四条曲线（右侧的曲线）是我们近似路径的步长为1的路径。第三个图形的步长为½，第二条曲线为¼，第一条曲线为1/8。我们选择![a](image/B15968_12_InlineEquation2.png)微分方程，因为我们知道代数解。

当*x*为2时，*e*2 *= 7.389*。添加*y=e*x*的实际曲线（左侧的第一条曲线），我们可以看到步长越小，近似值越接近实际曲线：

![图12.25：实际曲线添加到第一条曲线的左侧

](image/B15968_12_25.jpg)

图12.25：实际曲线添加到第一条曲线的左侧

但是最后的近似值，步长为0.001953125，需要在0和2之间进行1,024步。很容易理解为什么在计算机发明之前，欧拉方法不如代数方法受欢迎。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2VEQiaa](https://packt.live/2VEQiaa)。

您还可以在[https://packt.live/2ByZvtv](https://packt.live/2ByZvtv)上在线运行此示例。

## 练习12.17：使用欧拉方法评估函数

在**初始值问题**（**IVP**）上使用欧拉方法和步长0.001：

![图12.26：欧拉方法在初始VP上

](image/B15968_12_26.jpg)

图12.26：欧拉方法在初始VP上

在这里，*y(0) = 1*，以便计算近似解*y(x)*，当*x=0.3*时：

1.  在`euler`函数中，在`slope=`行中输入微分方程：

```py
    def euler(x0,y0,target_x,stepsize):
        x,y = x0,y0
        while x<target_x:
            slope = x+y**2 #from diff eq
            x += stepsize
            y += stepsize*slope
        return y
    ```

1.  在函数调用中输入适当的参数：

```py
    print(euler(0,1,0.3,0.001))
    ```

输出应该如下所示：

```py
    1.48695561935322
    ```

这意味着通过从我们已知的点(0,1)开始，按微分方程指定的方向迈出微小步骤，我们能够预测1.49是对应于x值0.3的近似*y*值。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3inHj6S.](https://packt.live/3inHj6S )

您也可以在[https://packt.live/2VFLEbF.](https://packt.live/2VFLEbF )上在线运行此示例

## Runge-Kutta方法

由于Euler方法仅基于每个点的导数，它存在一个问题，即始终超出或低于真实曲线。毫不奇怪，在Euler方法被发明的几个世纪以来，已经对其进行了改进以抵消其缺点。其中一种改进是**Runge-Kutta**（**RK**）方法，它将四个近似值平均在一起，其中之一是Euler方法，使用区间的开始，另一个使用区间的结束，另外两个近似值使用区间的中点。当这些近似值平均在一起时，中点的近似值被赋予更高的权重。

以下是当DE给出时的方程，*f(x,y)*，起始*x*和*y*，*x*0和*y*0，以及步长*h*：

![图12.27：给出f(x,y)时的方程

](image/B15968_12_27.jpg)

图12.27：给出f(x,y)时的方程

对于下一个*y*，我们将前面四个近似值平均在一起，*k*2和*k*3的权重加倍：

![图12.28：对前4个近似值进行平均的公式

](image/B15968_12_28.jpg)

图12.28：对前4个近似值进行平均的公式

然后，当然，*x*增加了*h*：

![图12.29：将x增加h

](image/B15968_12_29.jpg)

图12.29：将x增加h

这是一大堆代码，但它的功能令人印象深刻。

## 练习12.18：实现Runge-Kutta方法

在IVP上使用Runge-Kutta方法和步长0.2：

![图12.30：步长为0.2的Runge-Kutta方法

](image/B15968_12_30.jpg)

图12.30：步长为0.2的Runge-Kutta方法

1.  首先，我们定义微分方程。让我们称之为`deriv(x,y)`：

```py
    def deriv(x,y):
        return x**2 + y**2
    ```

1.  现在，我们将定义Runge-Kutta方法，称之为`rk4`：

```py
    def rk4(x0,y0,target_x,h):
        while x0 <= target_x:
            print(x0,y0)
            k1 = h*deriv(x0,y0)
            k2 = h*deriv(x0 + h/2, y0 + k1/2)
            k3 = h*deriv(x0 + h/2, y0 + k2/2)
            k4 = h*deriv(x0 + h, y0 + k3)
            #These are the values that are fed back into the function:
            y0 = y0 + (1/6)*(k1 + 2*k2 + 2*k3 + k4)
            x0 = x0 + h
    ```

1.  当我们从*y(0) = 0*开始，并且我们想要使用步长为0.2来计算*y(1)*时，这就是我们所说的：

```py
    rk4(0,0,1,0.2)
    ```

我们的进展如下打印出来：

```py
    0 0
    0.2 0.0026668666933346665
    0.4 0.021360090381533078
    0.6 0.0724512003541295
    0.8 0.17409018097333867
    1.0 0.35025754914481283
    ```

1.  使用相同的步长解决相同的问题，但使用Euler方法的准确性较低。在`euler`函数中，将`slope=`行更改为匹配新微分方程：

```py
            slope = x**2 + y**2
    ```

1.  现在，我们使用Euler方法打印出解决方案：

```py
    print(euler(0,0,1,0.2))
    ```

以下是输出：

```py
    0.2428567456277198
    ```

这与Runge-Kutta解决方案并不十分接近。然而，在计算机出现之前，Runge-Kutta改进可能更有用，因为我们可以简单地减小Euler方法中的步长并获得更好的近似值。这是步长为0.001的Euler方法的相同输出：

```py
    print(euler(0,0,1,0.001))
    ```

以下是输出：

```py
    0.34960542576393877
    ```

这只是对用于解方程的*数值方法*的简要介绍，不是通过代数来解决，而是通过将起始点输入计算机程序并按微分方程指示的方向迈出小步来解决。这是微积分的一个庞大领域，特别是现在免费软件和编程语言，再加上快速的计算机处理器，使以前费力的计算变得轻松。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3eWxF95.](https://packt.live/3eWxF95 )

您也可以在[https://packt.live/3dUlkkg.](https://packt.live/3dUlkkg )上在线运行此示例

## 追踪曲线

微积分中的一个重要话题是追踪曲线，这是一个代理追逐移动目标所经过的路径。由于追逐者直接朝向目标移动，然后目标移动，这种情况导致了各种微分方程。代数可能会变得非常丑陋，这就是微积分教授喜欢这个话题的原因。然而，正如我们所知，微分方程通常是关于寻找一般代数解的，也就是一个函数，而不是一个数字。理论上，我们可以将值代入函数中，以找到特定时间的粒子位置或房间的温度。使用Python，我们通过对情况进行建模并找到数值解来跳过代数步骤。我们在一般性上失去了一些东西，但在计算的便利性上获得了一些东西。

## 练习12.19：找到捕食者捕捉猎物的位置

一只兔子从(0,0)开始，以每秒1单位的正*y*方向奔跑。一只狐狸从(20,0)开始追逐兔子，奔跑速度是兔子的1.5倍。狐狸在什么*y*值处追到兔子？

执行以下步骤：

1.  首先，我们需要从`math`模块中获取一些函数来测量距离和角度：

```py
    from math import sqrt, atan2,sin,cos
    ```

1.  我们将编写一个函数，使用毕达哥拉斯定理来测量捕食者位置和猎物位置之间的距离：

```py
    def dist(x1,y1,x2,y2):
        """Returns distance from (x1,y1) to (x2,y2)"""
        return sqrt((x1-x2)**2 + (y1-y2)**2)
    ```

1.  关键在于猎物和捕食者位置之间*y*的变化与*x*的变化代表我们想要的角度的正切。我们知道它们的位置，因此我们使用反正切函数`atan2`来计算角度，使得捕食者直接指向猎物。我们真正想知道的是如何改变捕食者的*x*和*y*坐标，使其朝着猎物移动1单位。为了使捕食者朝着猎物转向，我们需要找到两点之间的角度，如下图所示：![图12.31：捕食者和猎物之间的角度

](image/B15968_12_31.jpg)

图12.31：捕食者和猎物之间的角度

1.  一旦我们知道变化，我们就可以将向量乘以我们想要的任何速度：

```py
    def towards(x1,y1,x2,y2):
        """Returns unit vector in [x,y] format from point
        1 to point 2"""
        dx,dy = x2-x1,y2-y1
        angle = atan2(dy,dx)
        return [cos(angle),sin(angle)]
    ```

我们计算`x`和`y`的变化，使用`arctangent`函数计算角度，然后我们使用余弦和正弦来找到捕食者*x*和*y*坐标的相应变化，使其朝着猎物走一步。

1.  现在，追逐可以开始了。我们将捕食者和猎物放在它们所在的位置。然后，我们开始一个循环，其中我们将猎物移动一单位（或更准确的增量）：

```py
    def chase():
        predator_x,predator_y = 20,0
        predator_v = 1.5 #prey is 1
        prey_x,prey_y = 0,0
        inc = 0.001
        while dist(predator_x,predator_y,prey_x,prey_y) > 0.001:
            prey_y += 1*inc
            p_vec = towards(predator_x,predator_y,\
                            prey_x,prey_y)
            predator_x += predator_v*p_vec[0]*inc
            predator_y += predator_v*p_vec[1]*inc
            #print(dist(predator_x,predator_y,prey_x,prey_y))
        return predator_y
    ```

1.  现在，我们运行追逐并打印出捕食者捕捉猎物的*y*值：

```py
    y = chase()
    print("Y:",y)
    print("dist:",dist(1,1,4,5))
    print("towards:",towards(1,1,2,2.732))
    ```

输出如下：

```py
    Y: 23.997299988652507
    dist: 5.0
    towards: [0.5000110003630132, 0.8660190526287391]
    ```

这非常接近理论值24。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3f6x44Z.](https://packt.live/3f6x44Z )

您还可以在[https://packt.live/2NO1A7v.](https://packt.live/2NO1A7v )上在线运行此示例

## 练习12.20：使用乌龟可视化追踪曲线

在这个练习中，我们将可视化捕食者和猎物的路径，这被称为*追踪曲线*。Python中有一个内置模块，基于Logo编程语言的虚拟乌龟，可以根据我们编写的代码轻松创建可以在屏幕上四处走动的虚拟代理。按照以下步骤完成这个练习：

1.  首先，我们从`turtle`模块导入函数：

```py
    from turtle import *
    ```

1.  我们根据所需的左下点设置屏幕的大小，我们将其设置为(-30，-30)，并设置右上点，我们将其设置为(40,40)：

```py
    setworldcoordinates(-30,-30,40,40)
    ```

1.  设置捕食者和猎物意味着创建一个`Turtle`对象并设置其颜色、位置和速度。乌龟在行走时会留下路径，所以我们告诉它`penup`，以防止它在到达起始位置之前绘制。然后，我们告诉它`pendown`，这样它就会开始绘制：

```py
    #set up predator
    predator = Turtle()
    predator.color("red")
    predator.penup()
    predator.setpos(20,0)
    predator.pendown()
    predator.speed(0)
    ```

1.  我们通过使乌龟变成绿色并赋予它乌龟的形状来设置猎物：

```py
    #set up prey
    prey = Turtle()
    prey.color("green")
    prey.shape("turtle")
    prey.setheading(90)
    prey.speed(0)
    ```

1.  `pursue`函数应该看起来很熟悉，但它有内置函数来计算距离，甚至指向另一个乌龟：

```py
    def pursue():
        inc = 0.05
        while predator.distance(prey)>0.05:
            predator.setheading(predator.towards(prey))
            prey.forward(inc)
            predator.forward (1.5*inc)
        print("y:",predator.ycor())
    ```

1.  我们将执行`pursue`函数，然后一旦它打印输出，我们会告诉程序完成，这样图形窗口就不会冻结：

```py
    pursue()
    done()
    ```

1.  如果你运行这个，你可以观看追逐。这是最终输出应该看起来像的：![图12.32：捕食者的路径是一个对数曲线

](image/B15968_12_32.jpg)

图12.32：捕食者的路径是一个对数曲线

1.  **扩展**：将猎物的路径改为圆形。在使猎物向前移动的行后，添加这行：

```py
    prey.left(.3)
    ```

这将使猎物每一步左转一小部分度数。但是如果每次转弯都是一样的，最终会形成一个圆。结果路径看起来像这样：

![图12.33：当猎物沿着圆形路径逃离时的追逐曲线

](image/B15968_12_33.jpg)

图12.33：当猎物沿着圆形路径逃离时的追逐曲线

注意

要访问此特定部分的源代码，请参阅[https://packt.live/3dWHDG6。](https://packt.live/3dWHDG6 )

这一部分目前没有在线交互式示例，需要在本地运行。

## 位置、速度和加速度

微分方程经常用于研究抛射体的路径，这可以说是微积分的起源。牛顿发明了微积分工具来解决由他对行星运动的研究得出的微分方程，并且表明地球上的自由落体物体受到与轨道行星相同的物理定律的约束。

## 练习12.21：计算抛射体离地面的高度

一个球以初速度29米/秒向上抛出。它在击中地面之前要多久？按照以下步骤完成这个练习：

1.  在代数课上，我们被引导使用方程来计算抛射体的高度：![图12.34：计算抛射体高度的公式

](image/B15968_12_34.jpg)

图12.34：计算抛射体高度的公式

这里，*h*0是初始高度，*v*0是初始向上速度，*t*是经过的秒数，*g*是重力加速度，大约32英尺或9.8米每秒。但是抛射体不使用方程来计算它们的位置；它们只是沿着它们的导数指示的方向运动。

1.  让我们模拟一下：

```py
    v = 29
    g = 9.8
    h = 0
    t = 0
    ```

因此，对于第一秒，球将以29米/秒的速度向上抛出，但会受到每秒9.8米的重力减速，这意味着一秒后，它只有*29 - 9.8 = 19.2*米/秒。因此，一秒后，球应该在空中19.2米高。我们每秒重复一次，直到它的高度为0。

1.  `height`函数应该是这样的：

```py
    def height(v0,h0,t):
        """Calculates the height a projectile given the
        initial height and velocity and the elapsed time."""
        v,h = v0,h0
        for i in range(1,t+1):
            v -= g
            h += v
        return h
    ```

1.  速度和高度被分配它们的起始值，*v*0和*h*0，然后速度通过*g*和加速度（由于重力）进行更新，然后高度*h*通过速度进行更新。我们每秒重复计算并检查球的高度何时返回到零：

```py
    for j in range(1,10):
        print(j,round(height(v,h,j),1))
    ```

以下是输出：

```py
     –
    1 19.2
    2 28.6
    3 28.2
    4 18.0
    5 -2.0
    6 -31.8
    7 -71.4
    8 -120.8
    9 -180.0
    ```

看起来球在4到5秒之间击中地面。但是当我们将*t = 5*放入前面的公式中时，我们得到以下结果：

![图12.35：替换计算抛射体高度公式中的值

](image/B15968_12_35.jpg)

图12.35：替换计算抛射体高度公式中的值

1.  5秒后，球应该仍然在空中22.5米。我们的代码有什么问题？正如您现在应该知道的那样，球不仅每秒改变一次速度。它的速度不断变化。就像复利一样，我们需要每秒计算新的速度。对于Python来说很容易。我们只需引入一个`inc`变量来增加时间。请记住，这会增加我们循环计算的次数，因此`for i in range`行也会改变。然后，*g*和*v*乘以增量。我们将每半秒重新计算一次：

```py
    def height(v0,h0,t):
        """Calculates the height a projectile given the
        initial height and velocity and the elapsed time."""
        inc = 0.5
        v,h = v0,h0
        for i in range(int(t/inc)):
            v -= g*inc
            h += v*inc
        return h
    ```

1.  使用相同的代码运行此代码：

```py
    for j in range(1,7):
        print(j,round(height(v,h,j),1))
    ```

输出现在如下：

```py
    1 21.7
    2 33.5
    3 35.6
    4 27.8
    5 10.3
    6 -17.1
    ```

1.  球在空中停留的时间更长，在5秒时，它在空中的高度为10.3米。如果我们使增量非常小，它应该在5秒时更接近22.5米。将`inc`更改为0.001，再次运行，您将获得以下输出：

```py
    1 24.1
    2 38.4
    3 42.9
    4 37.6
    5 22.5
    6 -2.4
    ```

1.  要回答球何时触地的问题，我们将不得不在5秒和6秒之间进行二分搜索。与以前的搜索一样，我们使用我们的`bin_search`函数，并更改`guess =`行以反映我们*猜测*的数字：

```py
    def bin_search(f,lower,upper,target):
        def average(a,b):
            return (a+b)/2
        for i in range(40):
            avg = average(lower,upper)
            guess = f(29,0,avg)
            if guess == target:
                return avg
            if guess < target:
                upper = avg
            else:
                lower = avg
        return avg
    ```

1.  我们只需要更改`height`函数的参数的`guess =`行。最后一个参数*t*是我们正在搜索的内容，因此我们正在平均。二分搜索函数将在5和6之间插入值，并返回返回0的*t*值：

```py
    print(bin_search(height,5,6,0))
    ```

以下是输出：

```py
    5.918000000000575
    ```

现在，我们解决二次方程：

*29t – 4.9t*2 *= 0*

对于*t*，我们得到*t = 0*和*t = 5.9184*。当然，我们扔出球之前，球的高度为0，第二个值非常接近我们得到的值。函数的图形如下所示。忽略空气阻力，粒子高度随时间的图形遵循抛物线路径：

![图12.36：没有空气阻力的抛射物路径

](image/B15968_12_36.jpg)

图12.36：没有空气阻力的抛射物路径

这是对我们代码的测试，因为我们有一个很好的公式来检查我们的输出。现在，我们将继续进行更难的关于速度和加速度的微积分问题，其中没有公式可以帮助我们检查答案。

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2VEAkN4](https://packt.live/2VEAkN4)。

您还可以在[https://packt.live/2Bzpz7Z](https://packt.live/2Bzpz7Z)上在线运行此示例。

## 计算带空气阻力的抛射物高度的示例

数学学生被迫研究从代数到微积分的完美抛物线路径中行进的粒子。不幸的是，这不是真实粒子的行进方式。在现实生活中，物体穿过空气或水等介质，并根据介质的密度、其横截面积和其他因素而减速。这导致了一个复杂的施加在抛射物上的力的方程。简而言之，*抛射物上的力是由于重力加速度和与其速度的平方成比例的减速*。方程如下：

*F = mg - kv*2

有空气阻力，我们需要知道抛射物的质量*m*。由于重力加速度*g*为9.8 m/s2。变量*k*是至少三个不同因素的组合，但值*k = 0.27*对于这种情况产生了现实结果。

与上一个练习一样，我们计算加速度并使用它来更新速度。然后，我们根据速度更新抛射物的位置。

抛射物上的力由两部分组成：由于重力的通常加速度和阻力分量。让我们编写一个Python函数来计算：

```py
def force(v,mass,g,k,inc):
    """Returns the downward force on a
    projectile"""
    gravity = mass*g*inc
    drag = k*(v**2)*inc
    if v > 0:
        return gravity + drag
    return gravity - drag
```

很多时候，我们的值都乘以`inc`，增量变量，这样我们可以采取更小的步骤来获得更好的近似值，就像我们以前做的那样。`gravity`和`drag`变量直接来自力的方程。请注意，如果速度大于0，抛射物正在向上运动，因此向下的力是重力和阻力力的总和。否则，抛射物正在向下运动，因此重力的力仍然向下，但阻力正在减速，因此我们使用重力和阻力的差异。

现在，我们将调整我们在上一个练习中的`height`函数，以计算高度等于0所需的时间，并添加对我们的`force`函数的调用：

```py
def height(v0,h0):
    """Calculates the time it takes a projectile given the 
    initial height and velocity to hit the ground."""
    inc = 0.001
    v,h = v0,h0
    t = 0
    while h >= 0:
        v -= force(v,1,9.8,0,inc) #test with k=0
        h += v*inc
        t += inc
    return round(t,1),round(v,1)
```

在这个函数中，是`v -=`这一行在起重要作用。速度将受到向下的力的影响。当我们使用*k = 0*运行时，我们应该得到与上一个问题中相同的时间和结束速度，没有空气阻力：

```py
print(height(29,0))
```

输出如下：

```py
(5.9, -29.0)
```

是的；在上一个练习中，抛射物需要5.9秒才能到达地面。当没有空气阻力且结束高度与初始高度相同时，结束速度将与初始速度相同，只是方向相反，因此为-29米/秒。

现在，让我们使用更现实的值*k*，`0.27`，看看粒子到达地面需要多长时间，以及它将以多快的速度运行。你有什么预测？

将`height`函数中的`v -=`行更改为以下内容：

```py
        v -= force(v,1,9.8,0.27,inc)
```

当您运行程序时，输出将如下所示：

```py
(2.2, -5.9)
```

因此，抛射物只用了2.2秒就上升并下降，最终速度为-5.9米/秒。如果我们将具有和没有空气阻力的抛射物的高度图进行对比，我们会发现在有空气阻力的情况下高度要少得多：

![图12.37：带空气阻力的抛射物的高度（内曲线）

](image/B15968_12_37.jpg)

图12.37：带空气阻力的抛射物的高度（内曲线）

这确实是很大的阻力。尝试使用不同的*k*值，即阻力常数，以获得不同的结束时间和结束速度。这引出了数学和科学中一个非常有趣的概念，即**终端速度**，当抛射物上下的力相等时，它不再加速。

## 练习12.22：计算终端速度

如果您的抛射物从3000米的初始高度开始并从飞机上跳下（向下速度为0），它会达到什么速度？它会简单地继续加速直到抛射物撞击地面吗？

将质量更改为80公斤，这是人类的平均体重，*k*更改为`0.27`。按照以下步骤完成此练习：

1.  确保您有来自上一个示例的`force`函数。

1.  修改您的`height`函数，使其看起来像这样：

```py
    def height(v0,h0): 
        """Calculates the velocity of a projectile given the  
        initial height and velocity and the elapsed time.""" 
        inc = 0.001
        v,h = v0,h0 
        t = 0
        for i in range(500): 
    ```

1.  这是一个重要的行，我们在其中告诉`force`函数质量、*k*的值等等：

```py
            v -= force(v,80,9.8,0.27,inc)
            h += v*inc
            if i % 50 == 0:
                print("v:",round(v,1))
            t += inc
    ```

1.  我们进行了500次循环，但只在每50次循环时打印出速度。让我们用这行来运行它：

```py
    height(0,3000)
    ```

这是我们收到的输出：

```py
    v: -0.8
    v: -34.1
    v: -48.6
    v: -52.6
    v: -53.6
    v: -53.8
    v: -53.9
    v: -53.9
    v: -53.9
    v: -53.9
    ```

速度从0开始，变得越来越负，直到停止减少。它在大约54米/秒左右稳定下来（为负，因为它向下），这大约是每小时120英里，人体在自由落体中的终端速度。这是随时间变化的速度图：

![图12.38：带空气阻力的自由落体物体的速度

](image/B15968_12_38.jpg)

图12.38：带空气阻力的自由落体物体的速度

注意

要访问此特定部分的源代码，请参阅[https://packt.live/2NNmWBM。](https://packt.live/2NNmWBM )

您还可以在[https://packt.live/2BUuXCp](https://packt.live/2BUuXCp)上在线运行此示例。

现在，让我们完成一个活动，测试我们在本章学到的知识。

## 活动12.01：找到粒子的速度和位置

在*x-y*平面上移动的粒子的速度矢量具有以下分量：

![图12.39：粒子速度矢量的微分方程

](image/B15968_12_39.jpg)

图12.39：粒子速度矢量的微分方程

找到曲线的切线水平的所有时间（和坐标），然后找到*t=1*时粒子的速度。

执行以下步骤完成此活动：

1.  编写*dx/dt*和*dy/dt*的函数。

1.  循环遍历输出，找到导数为0的位置，找到导数从正变负或反之的值。然后，使用二分搜索找到更精确的近似值。

1.  创建一个`position`函数，并使用循环按照之前给出的导数（*位置的变化*）来改变粒子的位置，以便在所需的经过时间停止，并打印出*x-y*坐标。

1.  将您在*步骤2*中找到的时间插入`position`函数中，以找到导数为0时粒子的*x-y*坐标。

1.  您被要求在时间*t=1*时粒子的速度。使用您得到的微分方程找到粒子速度的垂直和水平分量，并找到以这些分量作为腿的直角三角形的斜边。

注意

此活动的解决方案可在第702页找到。

# 总结

微积分是一套非常强大的工具，用于模拟真实情况，从热量传递到行星运动。它使我们能够计算函数在瞬间的变化率和复杂曲线下的面积（这些任务仅使用代数和几何的工具似乎是不可能的）。在本章中，我们能够处理值的变化率（导数）作为一个值本身，并使用Python循环和函数计算出一些非常精确的结果。模拟导致微分方程的情况，比如抛射物的路径，正是推动第一台电子计算机的发展。

数学课程可能仍然强调对方程的代数解，甚至微分方程，但正如我们在本章中所看到的，使用计算机是模拟现实生活情况的一种简单方法，比如捕食者追逐猎物。我们改变了变量，比如投资中的资金量，混合物中的盐量，以及捕食者的朝向，重复计算了数千次，每一步重新计算数量和距离，得到了非常精确的结果。Python是设置一些起始条件并让程序运行直到抛射物击中地面或达到终端速度的完美工具。Python还帮助我们避免了繁琐的代数运算，并让我们通过创建一个简单的模型来*蛮力*得到答案，比如一个下落的物体或一个捕食者追逐猎物。这是*简单*的，因为我们不必重复数千次计算——计算机会做。此外，这些数值方法已经用于没有简单代数解的微分方程，甚至适用于那些有解的方程。希望本章已经证明了使用计算机来模拟和分析复杂的现实情况的力量。

现在，您已经学会了如何利用Python的循环、变量、条件、函数和列表来解决统计学、概率论和微积分中的复杂问题。您还学会了如何计时执行代码并绘制输出。您使用了Python的最先进的数值包`numpy`来加速计算并操纵数组，适用于各种应用。您还看到Python编程被应用于太阳下的每一个数学主题，现在您将能够将其应用于未来遇到的任何现实生活情况。

JMK95

GEA39
