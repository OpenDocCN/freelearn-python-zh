# 6. 使用 Python 进行矩阵和马尔可夫链

概述

在本章中，我们打算使用 Python 深入研究矩阵及其应用。我们将探讨不同的矩阵操作技术，这将帮助我们有效地在实际应用中使用它们来构建有用的工具。

在本章结束时，您将了解矩阵并能对其进行操作。您将使用转移矩阵实现矩阵的一种应用，称为马尔可夫链，然后使用马尔可夫链和马尔可夫性质来解决现实世界问题。

# 介绍

矩阵是数字或表达式按行和列排列并被视为单个实体的矩形数组。由于我们将矩阵视为单个对象，如果我们对其进行操作，它将应用于其中的每个元素：

![图 6.1：一个简单的 m×n 矩阵，其中 m 行 n 列](img/B15968_06_01.jpg)

图 6.1：一个简单的 m×n 矩阵，其中 m 行 n 列

一个简单的线性单维数组很少能满足我们生活中与空间和时间相关的几乎所有属性都需要超过一个维度。紧凑性是使用矩阵的主要原因之一。当矩阵是封闭和有界的，或者简单地其点彼此之间的距离固定时，矩阵是紧凑的。主要基于这两个原因，矩阵在几乎每个领域都有应用，包括从图论、线性变换和概率论到物理学的不同分支，如量子力学和电磁学等基本数学概念。

马尔可夫链模型及其变体是这样一个应用，将矩阵、极限和概率的概念联系在一起，以产生在不确定性占主导地位的现实世界问题中的结果。在数学空间中，每当存在不确定性时，决策都是基于概率的；这构成了马尔可夫链的基础。这些使用一种特定类型的矩阵，称为转移矩阵，来构建状态图。马尔可夫链实际上是一个无记忆过程，主要基于当前状态来决定下一个状态的结果。我们在一些非常重要的用例中发现它们的应用，包括页面排名算法、自动完成应用程序和文本生成器。我们将在本章后面更详细地研究这些概念，为此，我们首先需要了解矩阵。

# 单矩阵上的矩阵操作

在本章中，我们将学习不同的矩阵操作方式以及如何在 Python 中实现它们。广义上理解矩阵的工作意味着理解二维或多维数组的基本原理。一旦我们对二维矩阵的基础有了很好的理解，有兴趣的人可以深入研究矩阵的高级研究，其中包括稀疏矩阵、向量空间、特征值和特征向量等特殊类型的矩阵，这可能涉及超过两个维度。

Python 中的矩阵可以使用列表或数组来实现。在 Python 中，嵌套列表可以很好地工作，但 Python 有一个强大的包，使矩阵实现变得更容易，称为 NumPy。SciPy 是另一个帮助进行矩阵操作的包，但通常更适合于更大的矩阵计算。在本章中，我们将在整个章节中使用这两个模块。

## 矩阵的基本操作

在这一点上，假设您已经安装了 Python 及其默认库以运行基本的 Python 程序。

一旦您安装好了这个包，让我们定义我们的第一个矩阵：

```py
# Importing Numpy package
import numpy as np
# Initializing and printing matrix z
x = np.array([[1, 2], [3, 4]])
print(x)
```

这个矩阵与下面的矩阵`z`相同，只是更好地表示，并且在可能的情况下，作为一个良好的实践是可取的：

```py
# Initializing and printing matrix z
z = np.array([[1, 2],\
              [3, 4]])
print(type(z))
```

请注意，在前面的代码中，我们已经打印了变量`z`的类型。你能猜到输出是什么吗？输出应该如下所示：

```py
<type 'numpy.ndarray'>
```

`ndarray`是 NumPy 使用的标准数组格式。数组对象是同质的、多维的，并且具有与其分配相关联的数据类型对象。

例如，让我们取矩阵`z`中的一个元素，这个矩阵我们之前定义过：

```py
# Printing the data types for matrix-z
print(z)
print(type(z))
print(z[0][1])
print(type(z[0][1]))
```

这将产生以下输出：

```py
[[1 2]
 [3 4]]
[[5 6]
 [7 8]]
<type 'numpy.ndarray'>
2
<type 'numpy.int64'>
[Finished in 0.221s]
```

我们发现给定矩阵的元素是`int64`类型，即 64 位整数类型。其他数据类型包括`np.float32`、`np.complex`、`np.bool`、`np.object`、`np.string_`和`np.unicode_`。

目前，知道我们几乎每个数据结构都是使用 Python 版本 3.8 和 NumPy 版本 1.17 就足够了。截至出版日期，NumPy 有一个特殊的类叫做`matrix`类，它几乎做了与`ndarray`相同的事情。唯一的区别是`matrix`类保持其 2D 性质，并且内置了一些操作符，比如`*`表示乘法，`**`表示幂。虽然`matrix`类可能会派上用场并且可以被探索，但官方的 NumPy 文档建议使用普通的`ndarray`而不是`np.matrix`，因为后者可能会在将来被移除。因此，值得注意的是，在这个上下文中，术语`ndarray`可以被视为与术语`matrix`同义，并且在本章中可以互换使用。

让我们继续使用`ndarray`。假设我们有一个单独的矩阵，我们将看到一些我们可以对其进行的简单操作。我们可以使用之前定义的相同矩阵`z`。

让我们打印元素的总和：

```py
# Sum of all elements of the matrix
print(z)
print(np.sum(z))
```

这将产生以下输出：

```py
[[1 2]
 [3 4]]
10
[Finished in 0.237s]
```

这很简单。现在让我们看看我们可以做的其他事情。

让我们找到`z`矩阵的最大值、最小值、平均值和标准差：

```py
# Value of the largest integer in the matrix
print("Max ", np.max(z))
# Value of the smallest integer in the matrix
print("Min ", np.min(z))
# Mean of elements in the matrix
print("Mean ", np.mean(z))
# Standard deviation
print("Standard deviation ", np.std(z))
```

这将产生以下输出：

```py
('Max ', 4)
('Min ', 1)
('Mean ', 2.5)
('Standard deviation ', 1.1180339887498949)
[Finished in 0.207s]
```

还有许多其他操作可以在`ndarray`上执行，包括常见的数学函数，如 sin、cos、log 和平方根，以及统计函数，如寻找相关系数和累积和，我们很快将使用其中一些。

## 检查矩阵

现在，我们将处理一些有用的函数，这些函数可以帮助我们更多地了解我们正在使用的任何数组。让我们继续使用到目前为止一直在使用的相同矩阵/`ndarray` `z`：

1.  让我们打印一个矩阵的信息：

```py
    # 1\. Information about a matrix
    print("Information: ")
    print(np.info(z))
    ```

输出将如下所示：

```py
    Information: 
    class:  ndarray
    shape:  (2, 2)
    strides:  (16, 8)
    itemsize:  8
    aligned:  True
    contiguous:  True
    fortran:  False
    data pointer: 0x7ff57665fef0
    byteorder:  little
    byteswap:  False
    type: int64
    None
    ```

1.  现在，为了确定矩阵的形状，请写下以下代码：

```py
    # 2\. Gives the shape of the matrix
    print("Shape: ")
    print(np.shape(z))
    ```

输出将如下所示：

```py
    Shape: 
    (2, 2)
    ```

1.  要检查矩阵是 2D 还是 3D 矩阵，请写下以下代码：

```py
    # 3\. Dimensions of the matrix
    print("Dimensions: ")
    print(np.ndim(z))
    ```

输出将如下所示：

```py
    Dimensions: 
    2
    ```

1.  要打印矩阵的数据类型，请使用以下代码：

```py
    # 4\. Data type of the matrix
    print("Data type of elements")
    print(z.dtype.name)
    ```

输出将如下所示：

```py
    Data type of elements
    int64
    ```

1.  要打印矩阵的长度，请使用以下代码：

```py
    print("Length of the ndarray: ")
    print(len(z))
    ```

输出将如下所示：

```py
    Length of the ndarray: 
    2
    ```

正如我们所看到的，`info`函数已经显示了我们调用的另外两个函数的值，即 shape 和 type。然而，这些函数只能起到有限的作用，有时这就是所需的。正如我们所知，多维`ndarray`是一个数组的数组，而 NumPy 数组的`len`函数将始终是第一维的长度。如果`z`是一个 2D 矩阵，那么`len(z)`将是`z`中的行数。

在接下来的练习中，我们将创建一个矩阵。我们可以用嵌套列表创建一个矩阵，但是这个问题将详细说明矩阵在现实世界中是如何打包和利用的。

## 练习 6.01：计算阳光到达地球所需的时间

在这个练习中，我们将计算阳光到达地球所需的时间。

正如我们所知，地球围绕太阳在椭圆轨道上运行。因此，地球和太阳之间的距离会发生变化，这将改变光到达地球所需的时间。我们可以使用三个主要方程来处理这个问题。

计算时间的数学公式如下：

![图 6.2：计算时间的公式](img/B15968_06_02.jpg)

图 6.2：计算时间的公式

我们需要计算地球和太阳之间的距离*r*：

![图 6.3：计算距离的公式](img/B15968_06_03.jpg)

图 6.3：计算距离的公式

在前述方程中，*a*的值为 149,600,000 千米，这是半长轴距离，*e*为 0.0167，这是地球轨道的离心率，*θ*是从近日点开始的角度。

需要计算前述方程中所需的因变量*θ*，计算如下：

![图 6.4：计算因变量的公式](img/B15968_06_04.jpg)

图 6.4：计算因变量的公式

请注意这里*n*是从 1 月 3 日近日点开始的天数。为了简化问题，我们将其视为一年的开始。

不要被这些方程式所困扰，它们只是简单的常数数学乘法，可以轻松通过一个称为`math`的巧妙 Python 库解决。

现在让我们开始练习：

1.  首先，导入`math`和`numpy`库：

```py
    import math
    import numpy as np
    ```

我们稍后将使用这些库。

1.  接下来，定义两个常数并使用大写字母，这是命名这些常数的标准 Python 做法：

```py
    def earth_sun_distance():
        # Semi-major axis between earth and sun
        A = 149600000
        # Eccentricity of earth
        E = 0.0167
        l = []
    ```

`A`在这里是地球和太阳之间的半长轴距离。

`E`被称为地球的离心率。

`l`是我们初始化用于存储值的列表。

1.  让我们跳到代码的主要部分。对于 365 天中的每一天，计算`theta`，因为每年的每一天它都不同。然后，计算地球到太阳的距离，最后将该距离附加到列表中：

```py
        # Calculating the distance between earth and sun
        for i in range(365):
            theta = (2 * math.pi * i) / 365.25
            r = A*(1 - E**2) / (1 - (E * math.cos(theta)))
            l.append(r)
        return l
    ```

请注意我们之前导入的`math`库中的`math.pi`和`math.cos`函数的使用。

1.  计算所需的时间（以秒为单位），假设光速为恒定值 299,792 千米/秒：

```py
    # Calculating the time taken
    S = 299792
    t = np.divide(l, S)
    ```

在这里，我们首先利用 NumPy 数组的功能，使用`divide`函数，它将值应用于列表的所有成员，而无需使用循环。我们将其值存储在`t`中，它会自动转换为 NumPy 数组。

1.  最后，我们在这里做了两件事。首先，我们使用另一个有用的 Python 函数`zip()`，它将两个列表的相应元素绑在一起，然后我们使用`np.asarray()`函数，将元组列表转换为 NumPy 数组：

```py
    sunny = np.asarray(list(zip(l, t)))
    print("Earth sun distance: \n", sunny)
    ```

运行程序以查看输出：

```py
    Earth sun distance:
    [[  1.52098320e+08   5.07346160e+02]
     [  1.52097938e+08   5.07344885e+02]
     [  1.52096791e+08   5.07341061e+02]
     [  1.52094881e+08   5.07334688e+02]
     [  1.52092207e+08   5.07325770e+02]
     [  1.52088771e+08   5.07314309e+02]
     ...
     [  1.52072354e+08   5.07259546e+02]
     [  1.52078259e+08   5.07279242e+02]
     [  1.52083406e+08   5.07296411e+02]
     [  1.52087793e+08   5.07311046e+02]
     [  1.52091420e+08   5.07323143e+02]
     [  1.52094284e+08   5.07332697e+02]
     [  1.52096385e+08   5.07339707e+02]
     [  1.52097723e+08   5.07344168e+02]]
    [Finished in 0.197s]
    ```

现在，我们以系统化的表格格式拥有了地球和太阳之间的距离值以及光线到达地球所需的时间。我们可以继续向我们的矩阵添加其他参数，这就是使用矩阵和 NumPy 数组的灵活性。

请注意，这些值绝不准确，我们为简单起见做了一些安全假设，但这仍然是矩阵可以用于几乎任何事情的很好的例证。还要注意，这里反映的值是 Python 中使用的科学计数法格式，并且可以根据需要轻松转换为浮点数或其他类型。左边的值是以千米为单位，右边的值是以 507.346...秒的形式。

1.  将结果附加如下：

```py
    d = []
    for i in range(1,len(l) - 1):
        d.append(l[i]-l[i-1])
    print(d)
    ```

输出的一部分如下：

```py
    [-382.2014582455158, -1146.4797523021698, -1910.3842301666737,
     -2673.6658524870872, -3436.075836390257, -4197.365758448839,
     -4957.287656396627, -5715.5941315591335, -6472.038449823856,
     -7226.374643236399, -7978.357610076666, -8727.743215203285,
     -9474.288]
    ```

注意

要访问此特定部分的源代码，请参阅[`packt.live/3irS3Bk.`](https://packt.live/3irS3Bk )

您也可以在[`packt.live/3abV9pe`](https://packt.live/3abV9pe)上在线运行此示例。

## 矩阵中的运算和乘法

现在我们了解了如何执行简单的操作，让我们执行一系列操作，例如调整大小、重塑和转置，形成一个新的矩阵。

当矩阵中的行和列的索引交换时，沿对角线翻转它们，这被称为矩阵的转置。现在让我们来看看如何转置矩阵。这可以通过三种不同的方式完成，如下所示：

```py
print("matrix z: ")
print(z)
# Transpose matrix
# Method 1
print("new matrix: ")
print(np.transpose(z))
# Method 2
print(z.transpose())
# Method 3
t = z.transpose()
print(t)
```

如果您运行此代码，输出将如下所示：

```py
matrix z: 
[[1 2]
 [3 4]]
new matrix: 
[[1 3]
 [2 4]]
[[1 3]
 [2 4]]
[[1 3]
 [2 4]]
[Finished in 0.207s]
```

在方法 3 中，我们将转置矩阵的值分配给一个新变量。

我们现在将看到的函数是在执行矩阵操作时最常用的函数之一。

我们将处理的第一个函数是展平。将矩阵转换为单行的过程称为**矩阵的展平**：

```py
# Flatten the array
y = z.ravel()
print(y)
```

这将产生以下输出：

```py
[1 2 3 4]
```

现在让我们看一下各种比较运算符：

```py
# Comparison operators on matrix
print(z == 3)
```

在这种情况下，矩阵中的所有值都与基本值（在本例中为`3`）进行比较，并且布尔结果针对矩阵中的相应索引显示。输出如下：

```py
[[False False]
 [ True False]]
```

要检查`z`的值是否小于`3`，请使用以下代码：

```py
print(z < 3 )
```

输出如下：

```py
[[ True  True]
 [False False]]
```

`reshape`是一个函数，用于根据函数内部传递的行和列的值来改变矩阵的维度。要重塑矩阵，请使用以下代码：

```py
# Reshaping the matrix
r = z.reshape(4,1)
print(r)
```

这将产生以下输出：

```py
[[1]
 [2]
 [3]
 [4]]
```

要调整矩阵的大小，请使用以下代码：

```py
# Resizing the matrix
resize = np.resize(z,(3,3))
print(resize)
```

这将产生以下输出：

```py
 [[1 2 3]
 [4 1 2]
 [3 4 1]]
[Finished in 0.205s]
```

请注意，当我们使用`resize`函数时，值会被迭代重复，直到满足大小，即使可能并未添加原始矩阵中的所有值。还要注意，通常使用`reshape`函数代替`ravel`函数来展平矩阵。

## 矩阵中的轴

这个相对简单的主题易于理解，但同样容易误解，因此我们需要独立处理它。对于 Python 中的数组，为具有多个维度的任何矩阵或数组定义轴。在处理复杂的数据科学和数据操作问题时，我们经常需要处理超过两个维度的数据，这很难可视化并且容易混淆。为了简化这一点，矩阵中的维度由轴表示。

简单地说，2D 矩阵将有两个轴，水平和垂直，但在这种情况下，它们将以数字形式表示或命名。第一个轴称为*轴 0*，沿着行向下垂直运行，第二个称为*轴 1*，沿着列水平运行。

我们之前使用的一组函数可以用于沿着单个轴运行，这在大型数据集的情况下减少了计算的开销。让我们处理一些例子。为了清晰起见，我们将创建一个稍大一些的矩阵：

```py
import numpy as np
z = np.array([[1, 5, 9, 4],\
              [8, 3, 7, 6]])
print(z.max(axis = 0))
print(z.max(axis = 1))
```

这将产生以下输出：

```py
[8 5 9 6]
[9 8]
[Finished in 0.198s]
```

这里发生的是沿着*每个*轴计算最大值。在返回的第一个数组中，比较是`1`和`8`，`5`和`3`，`9`和`7`，以及`4`和`6`，因为这些是沿着轴 0 的唯一两个元素。类似地，在轴 1 的情况下，比较是沿着子数组的四个元素进行的，并返回最大元素。

让我们再举一个例子：

```py
print(z.sum(axis = 1))
```

你能猜到结果吗？让我们看一下输出：

```py
[19 24]
[Finished in 0.255s]
```

现在让我们看一个最后的、更复杂的例子：

```py
print(np.concatenate((z[1], z[0]), axis=0))
```

这将产生以下输出：

```py
[8 3 7 6 1 5 9 4]
[Finished in 0.252s]
```

我们所做的首先是使用一个接受两个数组的连接函数。取出的两个数组分别是数组`z`的第一个和第二个元素，分别是`[8 3 7 6]`和`[1 5 9 4]`。由于这两个数组各自具有单个维度，我们沿着轴 0 取它们。如果我们在这里输入轴 1，NumPy 将抛出`AxisError`，如下所示：

```py
print(np.concatenate((z[1], z[0]), axis=1))
```

这将产生以下输出：

```py
Traceback (most recent call last):
  File "/matrix.py", line 9, in <module>
    print(np.concatenate((z[1], z[0]), axis=1))
numpy.core._internal.AxisError: axis 1 is out of bounds for array of dimension 1
```

## 练习 6.02：矩阵搜索

在这个练习中，我们将在按升序排序的矩阵中搜索给定的输入值，无论是按行还是按列。这将帮助我们理解在矩阵内部遍历的一般规则，特别是如果我们不使用 NumPy 数组。

为了给出一个提示，我们将在矩阵上实现二分搜索。即使您以前没有处理过二分搜索，这也足够容易理解。

目标是根据值是否存在于矩阵中返回`True`或`False`值：

1.  让我们定义我们要搜索的输入矩阵：

```py
    matrix = [[7, 10, 15, 18],\
              [25, 29, 35, 47],\
               [56, 78, 85, 104]]
    ```

1.  现在，让我们定义并编写一个名为`matrixsearch()`的函数，它将以此矩阵作为输入，以及我们要搜索的值。我们首先将处理边缘情况，即矩阵为空或目标值为非零的情况：

```py
    def matrixsearch(matrix, value):
        # Check for edge cases
        if value is None or not matrix:
             return False
    ```

1.  接下来，我们将定义四个变量：

```py
    # Initialize the variables
        row = len(matrix)
        col = len(matrix[0])
        start = 0
        end   = row * col - 1
    ```

请注意这里`row`和`column`变量的初始化方式。在任何矩阵中，它们的初始化方式都是一样的，值得理解。`start`和`end`变量被初始化为矩阵中的第一个和最后一个值，因为矩阵已经排序，可以被视为一个单一的列表，从起始到对角线的另一端。

1.  现在是程序的实际逻辑，我们将把它分解成几个步骤来帮助理解。在从起始到结束的循环中，首先我们找到矩阵的中点（将矩阵视为一个列表）：

```py
        while start <= end:
            mid = int((start + end) / 2)
    ```

1.  然后，我们定义一个名为`pointer`的变量，它由我们找到的这个中间值的值初始化：

```py
            pointer = matrix[int(mid/col)][int(mid%col)]
            print(int(mid/col), int(mid%col))
    ```

请注意，`/`用于除法，`%`在这里用作模数。因此，在第一次迭代中，它们的值将分别为（1,1）。

1.  现在，我们来到二分查找的核心部分，我们通过与我们拥有的值进行比较来增加或减少我们的指针。如果我们找到该值，我们返回`True`，否则我们将继续循环，直到我们找到或者在最后找不到任何东西时返回`False`：

```py
            if pointer == value:
                return True
            elif pointer < value:
                start = mid + 1
            else:
                end = mid - 1
        return False
    sol = matrixsearch(matrix, 78)
    print(sol)
    ```

输出将如下所示：

```py
    1 1
    2 0
    2 2
    2 1
    True
    ```

在这个练习中，我们使用 NumPy 实现了对矩阵的二分查找，并且根据矩阵的值，我们的代码返回了`True`。

注意

要访问此特定部分的源代码，请参阅[`packt.live/3eVd0Ch`](https://packt.live/3eVd0Ch)。

您也可以在[`packt.live/2ZusZkj`](https://packt.live/2ZusZkj)上在线运行此示例。

## 多个矩阵

到目前为止，我们已经学会了在拥有单个矩阵时执行操作和操作。接下来，我们将处理多个矩阵。Python 中矩阵的组合在当今的数据科学中最常用，因为它需要存储和处理大型数组。让我们从一个简单的例子开始。我们将取两个矩阵`z`和`x`，并将值相乘如下：

```py
import numpy as np
z = np.array([[1, 2],\
              [3, 4]])
x = np.array([[4, 5],\
              [7, 8]])
print(np.multiply(x,z))
print(np.multiply(z,x))
```

如果运行上述代码，您将看到以下输出：

```py
[[ 4 10]
 [21 32]]
[[ 4 10]
 [21 32]]
[Finished in 0.206s]
```

输出显示，直观地，两个矩阵的相应元素相乘得到一个乘积值。这只是元素级的乘法，或者在数学上称为 Hadamard 乘积。

现在让我们稍微改变矩阵`x`：

```py
import numpy as np
z = np.array([[1, 2],\
              [3, 4]])
x = np.array([[4, 5, 6],\
              [7, 8, 9]])
print("Multiplying with a number: ")
print(np.multiply(3,x))
print(np.multiply(x,3))
print("Multiplication between matrices of different sizes: ")
print(np.multiply(x,z))
print(np.multiply(z,x))
```

现在，输出将如下所示：

```py
Multiplying with a number: 
[[12 15 18]
 [21 24 27]]
[[12 15 18]
 [21 24 27]]
Multiplication between matrices of different sizes: 
Traceback (most recent call last):
    File "/Users/…/matrix operations.py", line 52, in <module>
    print(np.multiply(x,z))
ValueError: operands could not be broadcast together with shapes (2,3) (2,2) 
[Finished in 0.204s]
```

我们得到的是`ValueError`，这是由于 NumPy 中数组的广播属性导致的。

### 广播

重要的是要理解广播的概念，以便我们知道在使用数组进行矩阵运算时允许什么，不允许什么。

简而言之，广播是 NumPy 处理两个具有不同形状的数组的方式。一般规则是，在两者中较小的数组将以某种方式在较大的数组上进行广播，使它们兼容。根据官方文档，广播的一般规则如下：

+   它从尾部维度开始向前工作。

+   当它们中的一个为 1 时，或者当它们两个相等时，比较的两个维度是相等的。

注意

您也可以参考官方文档[`docs.scipy.org/doc/numpy/user/basics.broadcasting.html`](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)。

因此，正如我们在前面的例子中看到的，当乘以相同维度的矩阵和标量变量时，乘法运算完美地进行。另一方面，如果两个矩阵的维度不同，将抛出`ValueError`，因为 NumPy 无法有效地将较小矩阵的值广播到较大矩阵上。这种广播主要是在内部完成的，以使数组更快速和更节省内存。它提供了一种将数组向量化以在 C 中实现循环而不是 Python 的方法，这有效地使其更快。在这里需要记住的一件重要的事情是，在一对 NumPy 数组的情况下，操作是基于逐元素的。为了克服维度的问题，采用的两种主要方法是`reshape`和`newaxis`。在我们结束之前，让我们看一下广播概念的另一个变化：

```py
import numpy as np
z = np.array([[1,2],\
              [3]])
x = np.array([[4,5]])
print(np.multiply(x,z))
```

猜猜输出会是什么样子？让我们来看看：

```py
[[list([1, 2, 1, 2, 1, 2, 1, 2]) list([3, 3, 3, 3, 3])]]
[Finished in 0.244s]
```

由于这里的数组`z`不是一个常规的方形数组，NumPy 在内部不将其解释为矩阵，而是将其视为常规对象行，并对其进行逐元素乘法。因此，`z[0]`乘以`x[0]`，`z[1]`乘以`x[1]`，以产生在这种情况下恰好是一个列表的对象。

# 多个矩阵的操作

我们现在将执行两个或多个矩阵之间的操作，并查看将帮助我们实现这一目标的函数。我们将涵盖如何编写矩阵的逆、逻辑运算符、点积、特征值和特征向量、外积以及矩阵的行列式。

应该注意到，矩阵还有许多其他用途，官方的 NumPy 文档是一个非常好的资源，可以根据用户的需求引用信息。我们将要涵盖的大部分主题都是 NumPy 库的线性代数包的一部分。对于我们将要涵盖的每个主题，物理学和数学中都有更广泛的应用，但应该足够了解它们在理解矩阵方面起着非常重要的作用。

注意

有关 NumPy 库的更多信息，请参阅[`docs.scipy.org/doc/numpy/reference/`](https://docs.scipy.org/doc/numpy/reference/)。

## 单位矩阵

单位矩阵在对角线上有 1，在其他地方都是 0。我们将使用 NumPy 的`linalg`函数创建单位矩阵：

```py
import numpy as np
from numpy.linalg import inv
def identity():
    print(np.identity(3))
```

输出将如下所示：

```py
[[ 1\.  0\.  0.]
 [ 0\.  1\.  0.]
 [ 0\.  0\.  1.]]
[Finished in 0.206s]
```

## 单位矩阵

`eye`函数类似于单位矩阵，唯一的区别是可以偏移矩阵的值。这意味着它将从第 k 行开始创建一个单位矩阵，如下所示：

```py
def eye():
    print(np.eye(3, k = 1))
```

输出将如下所示：

```py
[[ 0\.  1\.  0.]
 [ 0\.  0\.  1.]
 [ 0\.  0\.  0.]]
[Finished in 0.277s]
```

## 矩阵的逆

逆或乘法逆是当你将其与原始矩阵相乘时产生单位矩阵的矩阵。矩阵的逆在应用于 3D 几何和图形时最常用：

```py
def inverse():
    z = np.array([[1,2],\
                  [3,4]])
    z_inv = inv(z)
    product = np.dot(z, z_inv)
    print(z_inv)
    print(product)
```

这将产生以下输出：

```py
# Output of print(z_inv)
[[-2\.   1\. ]
 [ 1.5 -0.5]]
# Output of print(product)
 [[  1.00000000e+00   0.00000000e+00]
 [  8.88178420e-16   1.00000000e+00]]
[Finished in 0.202s]
```

我们这里有两个输出。第一个是所谓的矩阵的逆，第二个是我们将逆乘以原始矩阵，使用`dot`函数产生单位矩阵。显示的值是浮点数，不应该成为一个问题。

## 逻辑运算符

我们将在这里创建两个列表，包含二进制的`True`（1）或`False`（0）值。我们将使用 NumPy 的内置`logical_and()`函数对它们进行`AND`操作的输出：

```py
def and_op():
    m1 = [True, False, False]
    m2 = [True, False, True]
    print(np.logical_and(m1, m2))
```

输出将如下所示：

```py
[ True False False]
[Finished in 0.253s]
```

非常简单。你也可以使用 1 和 0 代替`True`和`False`，它仍然会给出相同的结果。实际上，只要不是 0，它就被视为`True`。让我们看一个使用 1 和 0 的例子：

```py
def and_op():
    m1 = [0, 1, 0]
    m2 = [1, 1, 0]
    print(np.logical_and(m1, m2))
```

输出将如下所示：

```py
[False  True False]
[Finished in 0.192s]
```

使用`logical_or`、`logical_not`和`logical_xor`函数也可以对其他逻辑函数进行同样的操作。

## 外函数或向量积

`np.outer`是用于生成向量或两个矩阵的叉积的函数：

```py
def vector():
    horizontal = np.array([[1,3,2]])
    vertical = np.array([[2],\
                         [0],\
                         [1]])
    print("Output for dimension 1 x 1: ")
    print(horizontal.dot(vertical))
    print("Output for dimension 3 x 3: ")
    print(vertical.dot(horizontal))
    print("Output using outer for getting cross product: ")
    print(np.outer(vertical.ravel(), horizontal.ravel()))
    print(np.outer(horizontal.ravel(), vertical.ravel()))
```

这将产生以下输出：

```py
Output for dimension 1 x 1: 
[[4]]
Output for dimension 3 x 3: 
[[2 6 4]
 [0 0 0]
 [1 3 2]]
Output using outer for getting cross product: 
[[2 6 4]
 [0 0 0]
 [1 3 2]]
[[2 0 1]
 [6 0 3]
 [4 0 2]]
[Finished in 0.289s]
```

到目前为止，我们已经学会了使用矩阵的各种方法。我们使用的方法列表绝对不是限制性的，随时需要进行某种操作时，深入探索库始终是一个好习惯。值得再次提到的是，根据工作领域的要求，有几种特定类型的矩阵具有有限的使用情况。

# 使用矩阵解决线性方程

线性方程是代数的基本组成部分，任何学过基本初等数学的人都知道它们是如何工作的。让我们简要地介绍一下它们，然后我们可以看看如何在 Python 中使用矩阵轻松解决它们。

线性方程通常以以下形式出现：

![图 6.5：计算线性方程的公式](img/B15968_06_05.jpg)

图 6.5：计算线性方程的公式

这里，*a*1、*a*2、..、*a*n 是系数，*x*1、*x*2、.. *x*n 是变量。

这些具有两个变量的线性方程可以在二维空间图中表示，其中*x*是水平维度，*y*是垂直维度。

让我们快速举一个具有两个变量的线性方程的例子。假设方程是*y = 2x + 6*。这种表示被称为**斜率-截距**形式，格式为*y = mx + c*，其中*m*是斜率，*c*是方程的*y*截距。

这里，*m=2*，*c=6*，并且可以通过绘制不同的*x*和*y*值在图表上画出一条线：

![图 6.6：在二维空间中表示 y = 2x + 6](img/B15968_06_06.jpg)

图 6.6：在二维空间中表示 y = 2x + 6

不详细讨论，我们可以想象平面上可能有另一条线，它要么与该线平行，要么与该线相交。线性方程的目的是找到这些线的交点，并根据交点的值找到变量*x*和*y*的值。随着维度的增加，可视化变得困难，但基本上概念是相同的。矩阵极大地简化了解这些方程的过程。通常有两个矩阵，一个包含*x*和*y*的系数，另一个包含变量*x*和*y*。它们的点积产生了结果矩阵，即先前提到的常数或*y*截距。一旦我们快速进行了一次练习，就很容易理解。

## 练习 6.03：使用矩阵执行线性方程

我们现在将使用矩阵来解决一个线性方程问题。

约翰出差三天，心情不错，准备花光所有的钱。他随身携带了三种货币面额。第一天，约翰在他喜欢的最新电子平板上花了 435 美元，其中*a*面额的`37`，*b*面额的`20`，*c*面额的`12`。第二天，他去跳伞，分别花了*a*、*b*和*c*面额的`15`、`32`和`4`，总共 178 美元。第三天，他决定去看戏，花了 70 美元，分别是*a*、*b*和*c*面额的`5`、`40`和`2`。你能告诉各个面额的值是多少吗？

从问题中我们可以看出，有三个方程和三个未知变量需要计算。

1.  让我们使用 NumPy 数组将三天的已知值放入矩阵中：

```py
    import numpy as np
    # Input
    z = np.array([[37, 20, 12],\
                  [15, 32, 4],\
                  [5,  40, 2]])
    ```

我们现在有了需要处理的矩阵。有几种方法可以解决这个问题。本质上，这就是我们需要做的：

*Ax = b*

其中*A*是我们知道值的矩阵，*x*是具有未知变量的矩阵，*b*是结果矩阵。

1.  结果的*b*矩阵如下。这些是约翰在三天内的花费金额：

```py
    r = np.array([[435],[178],[70]])
    ```

有几种方法可以在 Python 中解决这个问题：

**方法 1**：通过计算 x = A-1b 来找到*x*：

1.  让我们首先使用我们之前学到的函数来计算矩阵 A 的逆：

```py
    print(np.linalg.inv(z))
    ```

注意

我们将使用矩阵的点积而不是纯乘法，因为这些不是标量变量。

输出如下：

```py
    [[-0.06282723  0.28795812 -0.19895288]
     [-0.0065445   0.0091623   0.02094241]
     [ 0.28795812 -0.90314136  0.57853403]]
    ```

这里不需要理解这个矩阵，因为这只是一个中间步骤。

1.  然后，我们取两个矩阵的点积来产生一个矩阵`X`，这是我们的输出：

```py
    X = np.linalg.inv(z).dot(r)
    print(X)
    ```

输出如下：

```py
    [[10\.  ]
     [ 0.25]
     [ 5\.  ]]
    ```

**方法 2**：使用`linalg`包中的内置方法：

1.  甚至可以使用另一个名为`solve()`的 NumPy 函数更轻松地完成相同的事情。让我们在这里将输出变量命名为`y`。

```py
    y = np.linalg.solve(z,r)
    print(y)
    ```

这产生了以下输出：

```py
    [[10\.  ]
     [ 0.25]
     [ 5\.  ]]
    ```

而且在一行代码中，我们就能够用 Python 解决线性方程。我们可以推断和理解，使用 Python 可以轻松解决具有大量未知变量的类似方程。

因此，我们可以看到使用方法 1 和方法 2 后的输出是相同的，即$10、25 美分和$5，这些是我们试图确定的相应面额。

如果我们接收约翰的开销信息是迭代的而不是一次性的呢？

1.  让我们首先添加我们收到的有关约翰开销的信息：

```py
    a = np.array([[37, 20, 12]])
    ```

1.  然后，让我们也添加有关约翰其他两笔开销的信息：

```py
    b = np.array([[15, 32, 4]])
    c = np.array([[5,  40, 2]])
    ```

1.  我们可以轻松地使用`concat()`函数将这些数组绑定在一起形成一个矩阵：

```py
    u = np.concatenate((a, b, c), axis=0)
    print(u)
    ```

这产生了以下输出：

```py
    [[37 20 12]
     [15 32  4]
     [ 5 40  2]]
    [Finished in 0.188s]
    ```

这是我们用于前面程序的相同输入。

同样，如果我们有更多这样的数据，我们可以应用循环来形成一个更大的矩阵，然后用它来解决问题。

注意

要访问此特定部分的源代码，请参考[`packt.live/3eStF9N.`](https://packt.live/3eStF9N )

您也可以在[`packt.live/38rZ6Fl`](https://packt.live/38rZ6Fl)上在线运行此示例。

# 转移矩阵和马尔可夫链

现在，我们将看一下矩阵的一个应用，这是一个独立的研究领域。马尔可夫链利用转移矩阵、概率和极限来解决现实世界的问题。现实世界很少像我们为解决它们创建的数学模型那样完美。一辆汽车可能想要从 A 点到 B 点，但在现实中，距离和速度可能是不够的参数。一只过马路的猫可能会完全改变计算出的汽车行驶时间。股市可能在几天内似乎遵循可预测的模式，但在夜间发生了一个事件，完全崩溃了。这个事件可能是一些全球性事件、政治声明或公司报告的发布。当然，我们在数学和计算模型方面的发展还没有达到我们可以预测每一个这些事件结果的地步，但我们可以尝试并确定某些事件发生的概率比其他事件更高。以前面的例子为例，如果公司报告将在特定日期发布，那么我们可以预期某只股票会受到影响，并且我们可以根据对公司进行的市场分析来对此进行建模。

马尔可夫链就是这样一种模型，其中依赖于马尔可夫性质的变量只考虑*当前状态*来预测下一个状态的结果。因此，从本质上讲，马尔可夫链是一个无记忆过程。它们利用转换状态图和转换矩阵进行表示，用于映射在给定当前事件的情况下发生某一事件的概率。当我们称之为无记忆过程时，很容易将其与与过去事件无关的东西混淆，但实际情况并非如此。当我们举例说明它们是如何工作时，事情就容易理解得多了。在我们开始使用马尔可夫链之前，让我们首先深入了解转换状态和矩阵的工作原理，以及它们为什么被使用。

## 马尔可夫链的基础知识

为了保持简单，让我们将概念分解成片段，并从我们已有的信息中逐步学习它们，然后才能将它们放在一起理解这些概念。

### 随机模型与确定性模型

当我们试图解决现实世界中的问题时，我们经常遇到超出我们控制范围的情况，很难制定。模型旨在模拟给定系统的功能方式。虽然我们可以在我们的模型中考虑系统的大部分元素，但许多方面无法被*确定*，因此根据它们发生的可能性进行模拟。这就是概率介入的地方。我们试图找到在一组情况下发生特定事件的概率。我们使用的模型有两种主要类型，确定性和随机性。确定性模型是具有一组参数值和函数的模型，并且可以形成可预测的数学方程，并提供可预测的输出。随机模型包括随机性，即使它们具有初始值和方程，它们也提供可能性的定量值。在随机模型中，不会有固定的答案，而是某些事件发生的可能性大于其他事件。线性规划是确定性模型的一个很好的例子，而天气预测是一个随机模型。

### 过渡状态图

广义上，这些构成了面向对象编程的基础，您可以根据给定的事件和条件描述对象可能具有的所有可能状态。*状态*是在满足某个先前条件时对象在某一特定时刻的状态。让我们举个例子来说明这一点：

![图 6.7：风扇的状态转移图](img/B15968_06_07.jpg)

图 6.7：风扇的状态转移图

这是台式风扇调节器的状态转移图，通常情况下，每次我们顺时针旋转它，它都会改变状态，直到它转回“关闭”位置。

在这里，台式风扇的状态在速度方面发生变化，而动作是扭转。在这种情况下，它是基于事件的，而在其他一些情况下，它将基于满足的条件。

让我们以使用与我们将要实施的内容一致的马尔可夫链进行文本生成的示例。我们将回顾一个儿歌的前两行：

*汉普蒂·韦尔壁上坐着，*

*汉普蒂·韦尔摔了个大跟头。*

首先，让我们准备一个包含句子中所有单词频率的频率表：

![图 6.8：韵文中单词的频率表](img/B15968_06_08.jpg)

图 6.8：韵文中单词的频率表

标记是存在的单词数，而键是唯一单词。因此，值将如下所示：

*标记 = 12*

*键=9*

我们甚至可能不需要我们在这里学到的一切，但一旦您决定实施更复杂的问题，这将是重要的。每个转换图都有一个起始状态和结束状态，因此我们将在这里添加这两个状态作为关键：

![图 6.9：起始和结束状态的频率表](img/B15968_06_09.jpg)

图 6.9：起始和结束状态的频率表

然后我们准备一个状态图表来显示从一个状态到下一个状态的转换。在这种情况下，需要显示哪个词将跟随当前词。因此，我们将形成如下的成对关系：

![图 6.10：词对](img/B15968_06_10.jpg)

图 6.10：词对

如果我们按照关键词而不是标记来压缩这个，我们会看到一些关键词有多个转换，如下所示：

![图 6.11：一些关键词有多个转换](img/B15968_06_11.jpg)

图 6.11：一些关键词有多个转换

这不仅是为了减少状态转换，还为我们正在做的事情增加意义，我们很快就会看到。整个目的是确定哪些词可以与其他词配对。我们现在准备绘制我们的状态转换图。

我们将所有唯一的关键字添加为状态，并显示这些单词可以转换到哪些状态：

![图 6.12：状态转换图](img/B15968_06_12.jpg)

图 6.12：状态转换图

如果我们看前面的图表，我们可以根据给定的条件跟随任何单词来完成韵脚。剩下的是关键词在给定单词之后出现的概率。为此，请看下面的图表，我们可以很直观地看到概率如何根据它们的频率在关键词之间分配。请注意，Humpty 总是跟在 Dumpty 后面，因此概率为 1：

![图 6.13：带概率的状态转换图](img/B15968_06_13.jpg)

图 6.13：带概率的状态转换图

现在我们已经讨论了状态转换图，我们将继续绘制转换矩阵。

### 转换矩阵

在马尔可夫过程中，我们需要以数学格式显示状态转换的概率，为此使用转换矩阵。行和列简单地是转换图的状态。转换矩阵中的每个值显示从一个状态到另一个状态的转换概率。可以想象，这种矩阵中的许多值将为 0。对于前面讨论的问题，转换矩阵将有 9 个状态和许多 0。我们将以一个更简单的转换图为例，并找到其相应的矩阵：

![图 6.14：具有状态 1、2 和 3 的状态图](img/B15968_06_14.jpg)

图 6.14：具有状态 1、2 和 3 的状态图

当我们看这个图表时，我们看到了三个转换状态。请注意，我们在这里没有明确包括起始和结束状态，但在某些情况下可能是必要的。外向箭头表示从一个状态到下一个状态的转换。一旦我们有了图表，就很容易绘制矩阵。写行和列等于图表的状态。在这种情况下，将是 3。然后，第 0 行将显示第 1 个状态的转换，第 1 行将显示第二个状态，依此类推。一般来说，矩阵中的每一行表示一个状态的转换概率。

让我们先看矩阵，然后我们可以讨论一些其他事情：

![图 6.15：转换矩阵](img/B15968_06_15.jpg)

图 6.15：转换矩阵

除了行的属性，我们还可以观察到另一件事。给定行中所有概率的总和将始终等于 1。在这里，第一行的总和将是 1/5 + 2/5 + 2/5 = 5/5 = 1。这是因为这些状态是穷尽的。

如果两个给定状态之间没有转换，那么矩阵中的状态值将为 0。我们可以通过比较矩阵中的值的数量和图表中可以看到的状态转换的数量来验证这一点。在这种情况下，它们都等于 7。

## 练习 6.04：查找状态转换的概率

给定一个包含四个状态`A`、`B`、`C`和`D`的数组，这些状态是随机生成的，让我们找到这四个状态之间的转移概率。我们将找到每个状态转移的概率，并从中形成一个转移矩阵。

让我们从给定的输入数组在 Python 中生成一个转移矩阵。我们将在未来推断相同的概念，用于创建马尔可夫链。

1.  使用 Python 中的`random`包生成一个包含字符`A`、`B`、`C`和`D`的随机状态数组。然后，我们将通过创建一个名为`LEN_STR`的常量来定义我们想要的元素数量，在这种情况下，我们将其设置为`50`：

```py
    # Generate random letters from 4 states A B C D
    import random
    tokens = []
    LEN_STR = 50
    for i in range(LEN_STR):
        tokens.append(random.choice("ABCD"))
    print(tokens)
    LEN_TOKENS = len("ABCD")
    ```

这产生了以下输出：

```py
    ['C', 'A', 'A', 'B', 'A', 'A', 'D', 'C', 'B', 'A', 'B',  'A', 'A', 'D', 'A', 'A', 'C', 'B', 'C', 'D', 'D', 'C',  'C', 'B', 'A', 'D', 'D', 'C', 'A', 'A', 'D', 'C', 'A',  'D', 'A', 'A', 'A', 'C', 'B', 'D', 'D', 'C', 'A', 'A',  'B', 'A', 'C', 'A', 'D', 'D']
    ```

注意

我们从字符串的长度生成的另一个常量`LEN_TOKENS`的使用将指示问题中将存在的状态的数量。

1.  接下来，我们将找到字母的相对值并将它们转换为整数，主要是因为整数更容易进行计算：

```py
    # Finding the relative values with ordinal values of 
    # ASCII characters
    relative_value = [(ord(t) - ord('A')) for t in tokens]
    print(relative_value)
    ```

这产生了以下输出：

```py
    [2, 0, 0, 1, 0, 0, 3, 2, 1, 0, 1, 0, 0, 3, 0, 0, 2, 1, 
     2, 3, 3, 2, 2, 1, 0, 3, 3, 2, 0, 0, 3, 2, 0, 3, 0, 0, 
     0, 2, 1, 3, 3, 2, 0, 0, 1, 0, 2, 0, 3, 3]
    ```

这里我们使用基数值是为了方便，但我们也可以使用字典或其他方法来做到这一点。如果你不知道，`ord()`函数在这里返回字符串中字符的 ASCII 值。例如，`A`和`D`的 ASCII 值分别为`65`和`68`。

1.  现在，找到这些 ASCII 值之间的差异，并将它们放入一个名为`ti`的列表中。我们也可以直接更新令牌列表，但为了清晰起见，我们将它们分开保持在不同的列表中：

```py
    #create Matrix of zeros
    m = [[0]*LEN_TOKENS for j in range(LEN_TOKENS)]
    print(m)
    # Building the frequency table(matrix) from the given data
    for (i,j) in zip(relative_value, relative_value [1:]):
        m[i][j] += 1
    print(list(zip(relative_value, relative_value [1:])))
    print(m)
    ```

这产生了以下输出：

```py
    [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
    [(2, 0), (0, 0), (0, 1), (1, 0), (0, 0), (0, 3), (3, 2),  (2, 1), (1, 0), (0, 1), (1, 0), (0, 0), (0, 3), (3, 0),  (0, 0), (0, 2), (2, 1), (1, 2), (2, 3), (3, 3), (3, 2),  (2, 2), (2, 1), (1, 0), (0, 3), (3, 3), (3, 2), (2, 0),  (0, 0), (0, 3), (3, 2), (2, 0), (0, 3), (3, 0), (0, 0),  (0, 0), (0, 2), (2, 1), (1, 3), (3, 3), (3, 2), (2, 0),  (0, 0), (0, 1), (1, 0), (0, 2), (2, 0), (0, 3), (3, 3)]
    [[8, 3, 3, 6], [5, 0, 1, 1], [5, 4, 1, 1], [2, 0, 5, 4]]
    ```

我们现在根据我们之前生成的`LEN_TOKENS`常量的大小初始化了一个零矩阵，并用它来构建一个零矩阵。

在第二部分中，我们正在创建成对的元组，就像我们在之前的问题中所做的那样，并根据两个状态之间的转换次数更新转移矩阵的频率。这个的输出是前面代码中的最后一行。

注意

我们选择迭代地更新矩阵*m*的值，而不是创建新的矩阵。

1.  我们现在将生成概率，这仅仅是给定行中的相对频率。就像在第一行中，从 A 到 A 的转换是 8，从 A 到任何状态的总转换次数是 20。所以，在这种情况下，概率将是*8/20 = 0.4*：

```py
    # Finding the Probability
    for state in m:
        total = sum(state)
        if total > 0:
            state[:] = [float(f)/sum(state) for f in state]
    ```

代码对每一行都是这样的，如果`sum`函数大于`0`，我们就找到概率。请注意这里使用`float`函数是为了避免在某些 Python 版本中进行类型转换为`int`。另外，请注意使用`state[:]`，它创建了一个浅拷贝，从而防止内部类型转换冲突。

1.  现在，让我们通过添加以下代码来打印`state`对象：

```py
    for state in m:
          print(state)
    ```

在这里，我们遍历矩阵中的行并打印出值，这就是我们的转移矩阵。

这产生了以下输出：

```py
    [0.4, 0.15, 0.15, 0.3]
    [0.7142857142857143, 0.0, 0.14285714285714285,  0.14285714285714285]
    [0.45454545454545453, 0.36363636363636365,  0.09090909090909091, 0.09090909090909091]
    [0.18181818181818182, 0.0, 0.45454545454545453,  0.36363636363636365]
    ```

因此，我们能够构建一个描述状态转移的转移矩阵，它显示了从一个状态转移到下一个状态的概率。因此，`A`找到`A`作为下一个字母的可能性是`0.4`，`A`转到`B`的概率是`0.15`，依此类推。

注意

要访问此特定部分的源代码，请参阅[`packt.live/31Ejr9c.`](https://packt.live/31Ejr9c )

您也可以在[`packt.live/3imNsAb.`](https://packt.live/3imNsAb )上在线运行此示例。

### 马尔可夫链和马尔可夫性质

转换状态和矩阵基本上涵盖了大部分马尔可夫链。此外，还有一些值得理解的东西。如前所述，当变量仅依赖于当前状态来确定其下一个状态时，马尔可夫性质适用。形成的概率模型可能确定当前状态的结果的可能性，但过去的状态被视为独立的，不会影响结果。以抛硬币为例；我们可以创建一个关于正面或反面概率的图表，但这不会决定结果。

马尔可夫性质本质上应该满足两个标准：

+   它应该只依赖于当前状态。

+   它应该是特定的离散时间。

在不至于混淆的情况下，模型中考虑的时间要么是离散的，要么是连续的。抛硬币可以被视为离散时间事件，因为它有明确的结果，比如正面或反面。另一方面，天气模式或股票市场是连续时间事件；例如，天气在一天中是变化的，没有开始和结束时间来衡量其变化。为了处理这样的连续事件，我们需要使用分箱等技术使它们变得离散。简而言之，分箱意味着根据数量或时间将数据分组成固定数量。由于马尔可夫链是无记忆的，它本质上成为了一个离散时间和状态空间过程。

有一些专门用于特定目的的特殊矩阵。例如，稀疏矩阵在数据科学中被广泛使用，因为它们在内存和计算上都很高效。我们没有过多地处理矩阵内的元素操作，因为这本质上就像处理一个列表的列表，但在未来花一些时间进行这方面的工作是值得的。

除了马尔可夫链，还有一些随机过程的模型。这些包括自回归模型、泊松模型、高斯模型、移动平均模型等。每种模型都以不同的方式处理随机性，Python 中几乎所有模型都有支持库。即使在马尔可夫链中，还涉及到涉及多维矩阵或二阶矩阵、隐马尔可夫模型、MCMC 或马尔可夫链蒙特卡洛方法等复杂的主题。你必须自己决定你想深入研究的程度。

## 活动 6.01：使用马尔可夫链构建文本预测器

这项活动的目标是基于我们所学的知识构建我们自己的文本预测器。我们将获取一位著名领导人的演讲文本，并基于演讲内容使用马尔可夫链模型和状态转换构建文本预测器。执行以下步骤来实现这个目标：

1.  首先，找到一位著名人物的演讲的合适且足够大的文本，比如科学家或政治或精神领袖。为了开始，样本文本文件`churchill.txt`已经添加到 GitHub 仓库中，网址为[`packt.live/38rZy6v`](https://packt.live/38rZy6v)。

1.  生成一个描述状态转换的列表，显示给定单词与其后跟随的单词之间的相关性。

1.  整理你制作的列表，并通过将跟随给定单词的单词分组在不同位置形成哈希表。例如，这些后续单词将分组形成*John: [cannot, completely, thought, …]*：

*John cannot…, John completely…, and John thought ..,*

1.  使用随机单词生成器生成并为第一个单词分配一个值。

1.  最后，创建一个随机生成器，根据我们声明的转换状态创建一个句子。

提示

这项活动需要一些你应该熟悉的 Python 方法。

为了开始，你可以使用`open('churchill.txt').read()`从文本文件中读取演讲文本，然后使用`split()`将其分割成单词列表。

然后，您可以遍历列表，并将元素附加到新列表中，该列表将存储关键字和其后的单词。

然后，使用字典为新列表中的每个元组形成键值对。

可以使用`np.random()`函数生成随机词语语料库。

句子的形成来自于连接我们生成的列表的元素。

注意

此活动的解决方案可在第 677 页找到。

通过这种方式，我们制作了自己的文本预测器。这样的文本预测器可以被认为是在文本生成领域的广阔和快速增长的领域中的基础步骤。它远非完美；这有几个原因，其中一些如下：

+   我们选择的文本样本通常比我们选择的文本大得多。我们的文本包含约 22,000 个单词，而在实践中，数百万个单词被作为数据输入。

+   在停用词、标点和句子的开头/结尾方面，使用 NLP 的适当规则进行了更好的调节。

+   我们使用简单的随机生成器来选择我们的单词，而实际模型使用概率和统计模型来生成更准确的输出。

话虽如此，我们已经完成了我们的第一个文本预测器，更复杂的文本预测器基本上是基于我们所描述的方式。

尽管这绝对不能被认为是流畅的，但我们仍然只用了几行代码编写了我们的第一个文本预测器，这是一个很好的开始。

# 摘要

在本章中，我们能够涵盖矩阵的主题，这对于许多主题都是基础，无论是在数学中还是在使用 Python 中。今天的数据科学主要基于矩阵的有效使用。我们研究了它们在马尔可夫链的形式中的应用，尽管这是一个重要的主题，但在应用矩阵的领域下，还有许多可以探索的主题。

接下来，我们将深入了解统计学的世界。我们将首先使用更正式和系统化的方法来理解统计学的基本知识，然后理解概率和变量的作用，最后将这些概念联系起来以实施统计建模。

YKA34

LHL39
