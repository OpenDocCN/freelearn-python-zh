几何问题

本章描述了关于二维几何的几个问题的解决方案。几何是数学的一个分支，涉及点、线和其他图形（形状）的特征，这些图形之间的相互作用以及这些图形的变换。在本章中，我们将重点关注二维图形的特征以及这些对象之间的相互作用。

在 Python 中处理几何对象时，我们必须克服几个问题。最大的障碍是表示问题。大多数几何对象占据二维平面中的一个区域，因此不可能存储区域内的每个点。相反，我们必须找到一种更紧凑的方式来表示可以存储为相对较少的点的区域。例如，我们可以存储沿对象边界的一些点，从而可以重建边界和对象本身。此外，我们将几何问题重新表述为可以使用代表性数据回答的问题。

第二个最大的问题是将纯几何问题转化为可以使用软件理解和解决的形式。这可能相对简单-例如，找到两条直线相交的点是解决矩阵方程的问题-或者可能非常复杂，这取决于所提出的问题类型。解决这些问题的常见技术是使用更简单的对象表示所讨论的图形，并使用每个简单对象解决（希望）更容易的问题。然后，这应该给我们一个关于原始问题的解决方案的想法。

我们将首先向您展示如何可视化二维形状，然后学习如何确定一个点是否包含在另一个图形中。然后，我们将继续查看边缘检测、三角剖分和寻找凸包。最后，我们将通过构造贝塞尔曲线来结束本章。

本章包括以下教程：

+   可视化二维几何形状

+   寻找内部点

+   在图像中查找边缘

+   对平面图形进行三角剖分

+   计算凸包

+   构造贝塞尔曲线

让我们开始吧！

# 技术要求

对于本章，我们将像往常一样需要`numpy`包和`matplotlib`包。我们还需要 Shapely 包和`scikit-image`包，可以使用您喜欢的软件包管理器（如`pip`）进行安装：

```py
          python3.8 -m pip install numpy matplotlib shapely scikit-image

```

该章节的代码可以在 GitHub 存储库的`Chapter 08`文件夹中找到：[`github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008`](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2008)。

查看以下视频以查看代码实际操作：[`bit.ly/3hpeKEF`](https://bit.ly/3hpeKEF)。

# 可视化二维几何形状

本章的重点是二维几何，因此我们的第一个任务是学习如何可视化二维几何图形。这里提到的一些技术和工具可能适用于三维几何图形，但通常需要更专门的软件包和工具。

*几何图形*，至少在本书的上下文中，是指边界是一组线和曲线的任何点、线、曲线或封闭区域（包括边界）的集合。简单的例子包括点和线（显然）、矩形、多边形和圆。

在本教程中，我们将学习如何使用 Matplotlib 可视化几何图形。

## 准备工作

对于本教程，我们需要导入 NumPy 包作为`np`，导入 Matplotlib `pyplot`模块作为`plt`。我们还需要从 Matplotlib `patches`模块导入`Circle`类和从 Matplotlib `collections`模块导入`PatchCollection`类。可以使用以下命令完成这些操作：

```py
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle
from matplotlib.collections import PatchCollection
```

我们还需要本章的代码库中的`swisscheese-grid-10411.csv`数据文件。

## 如何做...

以下步骤向您展示了如何可视化一个二维几何图形：

1.  首先，我们从本书的代码库中的`swisscheese-grid-10411.csv`文件加载数据：

```py
data = np.loadtxt("swisscheese-grid-10411.csv")
```

1.  我们创建一个代表绘图区域的新补丁对象。这将是一个圆（圆盘），其中心在原点，半径为`1`。我们创建一个新的轴集，并将这个补丁添加到其中：

```py
fig, ax = plt.subplots()
outer = Circle((0.0, 0.0), 1.0, zorder=0, fc="k")
ax.add_patch(outer)
```

1.  接下来，我们从*步骤 1*中加载的数据创建一个`PatchCollection`对象，其中包含了一些其他圆的中心和半径。然后我们将这个`PatchCollection`添加到*步骤 2*中创建的轴上：

```py
col = PatchCollection(
    (Circle((x, y), r) for x, y, r in data),
    facecolor="white", zorder=1, linewidth=0.2, 
    ls="-", ec="k"
)
ax.add_collection(col)
```

1.  最后，我们设置*x-*和*y-*轴的范围，以便整个图像都能显示出来，然后关闭轴线：

```py
ax.set_xlim((-1.1, 1.1))
ax.set_ylim((-1.1, 1.1))
ax.set_axis_off()
```

结果图像是一个*瑞士奶酪*，如下所示：

![](img/6aa2a020-6280-49a0-8606-c12f34d067ce.png)图 8.1：瑞士奶酪的绘图

## 它是如何工作的...

这个食谱的关键是`Circle`和`PatchCollection`对象，它们代表了 Matplotlib `Axes`上的绘图区域的区域。在这种情况下，我们创建了一个大的圆形补丁，它位于原点，半径为`1`，具有黑色的面颜色，并使用`zorder=0`将其放在其他补丁的后面。这个补丁被添加到`Axes`对象中使用`add_patch`方法。

下一步是创建一个对象，它将呈现从 CSV 文件中加载的数据所代表的圆。这些数据包括中心（*x*，*y*）和半径*r*的值，用于表示个别圆的中心和半径（总共 10,411 个）。`PatchCollection`对象将一系列补丁组合成一个单一的对象，可以添加到`Axes`对象中。在这里，我们为我们的数据中的每一行添加了一个`Circle`，然后使用`add_collection`方法将其添加到`Axes`对象中。请注意，我们已经将面颜色应用到整个集合，而不是每个单独的`Circle`成员。我们将面颜色设置为白色（使用`facecolor="w"`参数），边缘颜色设置为黑色（使用`ec="k"`），边缘线宽设置为 0.2（使用`linewidth=0.2`），边缘样式设置为连续线。所有这些放在一起，就得到了我们的图像。

我们在这里创建的图像被称为“瑞士奶酪”。这些最初是由爱丽丝·罗斯在 1938 年在有理逼近理论中使用的；随后它们被重新发现，并且类似的构造自那时以来已经被多次使用。我们使用这个例子是因为它由一个大的个体部分和一个大量的较小的个体部分组成。罗斯的瑞士奶酪是平面上具有正面积但没有拓扑内部的一个集合的例子。（这样一个集合甚至能存在是相当惊人的！）更重要的是，有一些连续函数在这个瑞士奶酪上是不能被有理函数逼近的。这个特性使得类似的构造在*均匀* *代数*理论中非常有用。

`Circle`类是更一般的`Patch`类的子类。还有许多其他`Patch`类，代表不同的平面图形，比如`Polygon`和`PathPatch`，它们代表了由路径（曲线或曲线集合）所界定的区域。这些可以用来生成可以在 Matplotlib 图中呈现的复杂补丁。集合可以用来同时应用设置到多个补丁对象上，这在本例中特别有用，因为你有大量的对象都将以相同的样式呈现。

## 还有更多...

Matplotlib 中有许多不同的补丁类型。在本教程中，我们使用了`Circle`补丁类，它表示坐标轴上的圆形区域。还有`Polygon`补丁类，它表示多边形（规则或其他）。还有`PatchPath`对象，它们是由不一定由直线段组成的曲线包围的区域。这类似于许多矢量图形软件包中可以构造阴影区域的方式。

除了 Matplotlib 中的单个补丁类型外，还有许多集合类型，它们将许多补丁聚集在一起，以便作为单个对象使用。在本教程中，我们使用了`PatchCollection`类来收集大量的`Circle`补丁。还有更多专门的补丁集合，可以用来自动生成这些内部补丁，而不是我们自己生成它们。

## 另请参阅

在数学中，可以在以下传记文章中找到关于瑞士奶酪的更详细的历史：*Daepp,U., Gauthier, P., Gorkin, P. and Schmieder, G., 2005\. Alice in Switzerland: The life and mathematics of Alice Roth. The Mathematical Intelligencer, 27(1), pp.41-54*。

# 查找内部点

在编程环境中处理二维图形的一个问题是，您不可能存储所有位于图形内的点。相反，我们通常存储表示图形的远少于的点。在大多数情况下，这将是一些点（通过线连接）来描述图形的边界。这在内存方面是有效的，并且可以使用 Matplotlib`Patches`轻松在屏幕上可视化它们。但是，这种方法使确定点或其他图形是否位于给定图形内变得更加困难。这是许多几何问题中的一个关键问题。

在本教程中，我们将学习如何表示几何图形并确定点是否位于图形内。

## 做好准备

对于本教程，我们需要将`matplotlib`包（整体）导入为`mpl`，将`pyplot`模块导入为`plt`：

```py
import matplotlib as mpl
import matplotlib.pyplot as plt
```

我们还需要从 Shapely 包的`geometry`模块中导入`Point`和`Polygon`对象。Shapely 包包含许多用于表示、操作和分析二维几何图形的例程和对象：

```py
from shapely.geometry import Polygon, Point
```

## 如何操作...

以下步骤向您展示如何创建多边形的 Shapely 表示，然后测试点是否位于此多边形内：

1.  创建一个样本多边形进行测试：

```py
polygon = Polygon(
    [(0, 2), (-1, 1), (-0.5, -1), (0.5, -1), (1, 1)],
)
```

1.  接下来，我们在新图上绘制多边形。首先，我们需要将多边形转换为可以添加到图中的 Matplotlib`Polygon`补丁：

```py
fig, ax = plt.subplots()
poly_patch = mpl.patches.Polygon(polygon.exterior, ec="k", 
   lw="1", alpha=0.5)
ax.add_patch(poly_patch)
ax.set(xlim=(-1.05, 1.05), ylim=(-1.05, 2.05))
ax.set_axis_off()
```

1.  现在，我们需要创建两个测试点，其中一个将位于多边形内，另一个将位于多边形外：

```py
p1 = Point(0.0, 0.0)
p2 = Point(-1.0, -0.75)
```

1.  我们在多边形上方绘制并注释这两个点，以显示它们的位置：

```py
ax.plot(0.0, 0.0, "k*")
ax.annotate("p1", (0.0, 0.0), (0.05, 0.0))
ax.plot(-0.8, -0.75, "k*")
ax.annotate("p2", (-0.8, -0.75), (-0.8 + 0.05, -0.75))

```

1.  最后，我们使用`contains`方法测试每个点是否位于多边形内，然后将结果打印到终端：

```py
print("p1 inside polygon?", polygon.contains(p1))
print("p2 inside polygon?", polygon.contains(p2))
```

结果显示，第一个点`p1`包含在多边形内，而第二个点`p2`不包含。这也可以在下图中看到，清楚地显示了一个点包含在阴影多边形内，而另一个点不包含：

![](img/986dab1f-d3fe-4f7f-bd62-c1f3be844745.png)

图 8.2：多边形区域内外的点

## 工作原理... 

Shapely`Polygon`类是多边形的表示，它将其顶点存储为点。外边界包围的区域-存储顶点之间的五条直线-对我们来说是明显的，并且很容易被眼睛识别，但是“在”边界内的概念很难以一种计算机容易理解的方式定义。甚至很难给出关于“在”给定曲线内的含义的正式数学定义。

确定点是否位于简单闭合曲线内有两种主要方法 - 即从同一位置开始并结束且不包含任何自交点的曲线。第一种方法使用数学概念称为*绕数*，它计算曲线“绕”点的次数，以及*射线交叉计数*方法，其中我们计算从点到无穷远处的点的射线穿过曲线的次数。幸运的是，我们不需要自己计算这些数字，因为我们可以使用 Shapely 包中的工具来为我们执行这些计算。这就是多边形的`contains`方法所做的。（在底层，Shapely 使用 GEOS 库执行此计算。）

Shapely 的`Polygon`类可用于计算与这些平面图形相关的许多数量，包括周长和面积。`contains`方法用于确定点或一组点是否位于对象表示的多边形内（该类有关多边形的表示存在一些限制）。实际上，您可以使用相同的方法来确定一个多边形是否包含在另一个多边形内，因为正如我们在这个示例中看到的，多边形由一组简单的点表示。

# 在图像中找到边缘

在图像中找到边缘是减少包含大量噪音和干扰的复杂图像为包含最突出轮廓的非常简单图像的好方法。这可以作为我们分析过程的第一步，例如在图像分类中，或者作为将线轮廓导入计算机图形软件包的过程。

在这个示例中，我们将学习如何使用`scikit-image`包和 Canny 算法来找到复杂图像中的边缘。

## 准备工作

对于这个示例，我们需要将 Matplotlib 的`pyplot`模块导入为`plt`，从`skimage.io`模块导入`imread`例程，以及从`skimage.feature`模块导入`canny`例程：

```py
import matplotlib.pyplot as plt
from skimage.io import imread
from skimage.feature import canny
```

## 如何做到...

按照以下步骤学习如何使用`scikit-image`包在图像中找到边缘：

1.  从源文件加载图像数据。这可以在本章的 GitHub 存储库中找到。关键是，我们传入`as_gray=True`以以灰度加载图像：

```py
image = imread("mandelbrot.png", as_gray=True)
```

以下是原始图像，供参考。集合本身由白色区域显示，如您所见，边界由较暗的阴影表示，非常复杂：

![](img/6d107141-bb61-4843-8ca0-d1a230b5eac4.png)

图 8.3：使用 Python 生成的 Mandelbrot 集合的绘图

1.  接下来，我们使用`canny`例程，需要从`scikit-image`包的`features`模块导入。对于这个图像，`sigma`值设置为 0.5：

```py
edges = canny(image, sigma=0.5)
```

1.  最后，我们将`edges`图像添加到一个新的图中，使用灰度（反转）色图：

```py
fig, ax = plt.subplots()
ax.imshow(edges, cmap="gray_r")
ax.set_axis_off()
```

已检测到的边缘可以在以下图像中看到。边缘查找算法已经识别出 Mandelbrot 集合边界的大部分可见细节，尽管并不完美（毕竟这只是一个估计）：

![](img/347a3855-99bf-42f3-bcd7-19d0ec8fc398.png)图 8.4：使用 scikit-image 包的 Canny 边缘检测算法找到的 Mandelbrot 集合的边缘

## 它是如何工作的...

`scikit-image`包提供了各种用于操作和分析从图像中导出的数据的实用程序和类型。正如其名称所示，`canny`例程使用 Canny 边缘检测算法来找到图像中的边缘。该算法使用图像中的强度梯度来检测边缘，其中梯度较大。它还执行一些过滤以减少它找到的边缘中的噪音。

我们提供的`sigma`关键字值是应用于图像的高斯平滑的标准偏差，用于计算边缘检测。这有助于我们去除图像中的一些噪音。我们设置的值（0.5）小于默认值（1），但在这种情况下可以提供更好的分辨率。较大的值会遮盖 Mandelbrot 集边界的一些细节。

# 对平面图形进行三角剖分

正如我们在第三章中看到的，*微积分和微分方程*，我们经常需要将连续区域分解为更小、更简单的区域。在之前的示例中，我们将实数区间缩小为一系列长度较小的小区间。这个过程通常称为**离散化**。在本章中，我们正在处理二维图形，因此我们需要这个过程的二维版本。为此，我们将一个二维图形（在这个示例中是一个多边形）分解为一系列更小和更简单的多边形。所有多边形中最简单的是三角形，因此这是二维离散化的一个很好的起点。找到一组"铺砌"几何图形的三角形的过程称为*三角剖分*。

在这个示例中，我们将学习如何使用 Shapely 包对多边形（带有孔）进行三角剖分。

## 准备工作

在这个示例中，我们需要将 NumPy 包导入为`np`，将 Matplotlib 包导入为`mpl`，并将`pyplot`模块导入为`plt`。

```py
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
```

我们还需要从 Shapely 包中获取以下项目：

```py
from shapely.geometry import Polygon
from shapely.ops import triangulate
```

## 如何做...

以下步骤向您展示了如何使用 Shapely 包对带有孔的多边形进行三角剖分：

1.  首先，我们需要创建一个代表我们希望进行三角剖分的图形的`Polygon`对象：

```py
polygon = Polygon(
    [(2.0, 1.0), (2.0, 1.5), (-4.0, 1.5), (-4.0, 0.5), 
       (-3.0, -1.5), (0.0, -1.5), (1.0, -2.0), (1.0, -0.5), 
         (0.0, -1.0), (-0.5, -1.0), (-0.5, 1.0)],

    holes=[np.array([[-1.5, -0.5], [-1.5, 0.5], [-2.5, 0.5], 
       [-2.5, -0.5]])]
)
```

1.  现在，我们应该绘制图形，以便了解我们将在其中工作的区域：

```py
fig, ax = plt.subplots()
plt_poly = mpl.patches.Polygon(polygon.exterior, 
   ec="k", lw="1", alpha=0.5, zorder=0)
ax.add_patch(plt_poly)
plt_hole = mpl.patches.Polygon(polygon.interiors[0], 
   ec="k", fc="w")
ax.add_patch(plt_hole)
ax.set(xlim=(-4.05, 2.05), ylim=(-2.05, 1.55))
ax.set_axis_off()
```

可以在下图中看到这个多边形。正如我们所看到的，这个图形中有一个"孔"，必须仔细考虑：

![](img/38ff179a-35af-43ac-bae1-da8027ddc87c.png)

图 8.5：带有孔的示例多边形

1.  我们使用`triangulate`例程生成多边形的三角剖分。这个三角剖分包括外部边缘，这是我们在这个示例中不想要的：

```py
triangles = triangulate(polygon)
```

1.  为了去除位于原始多边形外部的三角形，我们需要使用内置的`filter`例程，以及`contains`方法（在本章前面已经看到）：

```py
filtered = filter(lambda p: polygon.contains(p), triangles) 
```

1.  将三角形绘制在原始多边形上，我们需要将 Shapely 三角形转换为 Matplotlib `Patch`对象，然后将其存储在`PatchCollection`中：

```py
patches = map(lambda p: mpl.patches.Polygon(p.exterior), filtered)
col = mpl.collections.PatchCollection(patches, fc="none", ec="k")
```

1.  最后，我们将三角形补丁的集合添加到之前创建的图形中：

```py
ax.add_collection(col)
```

在原始多边形上绘制的三角剖分可以在下图中看到。在这里，我们可以看到每个顶点都连接到另外两个顶点，形成了覆盖整个原始多边形的三角形系统：

![](img/b0ca0510-f765-40e0-b147-23a9e82355b2.png)图 8.6：带有孔的示例多边形的三角剖分

## 它是如何工作的...

`triangulate`例程使用一种称为*Delaunay 三角剖分*的技术将一组点连接到一组三角形中。在这种情况下，这组点是多边形的顶点。Delaunay 方法以这样一种方式找到这些三角形，即没有任何点包含在任何三角形的外接圆内。这是该方法的技术条件，但这意味着三角形被有效地选择，因为它避免了非常长、细的三角形。得到的三角剖分利用了原始多边形中存在的边缘，并连接了一些外部边缘。

为了去除原多边形外的三角形，我们使用内置的`filter`例程，它通过移除标准函数失败的项目来创建一个新的可迭代对象。这与 Shapely `Polygon`对象上的`contains`方法一起使用，以确定每个三角形是否位于原始图形内。正如我们之前提到的，我们需要将这些 Shapely 项目转换为 Matplotlib 补丁，然后才能将它们添加到图中。

## 还有更多...

三角剖分通常用于将复杂的几何图形简化为一组三角形，这些三角形对于某种计算任务来说要简单得多。然而，它们也有其他用途。三角剖分的一个特别有趣的应用是解决“艺术画廊问题”。这个问题涉及找到必要的“守卫”艺术画廊的最大数量。三角剖分是 Fisk 对艺术画廊定理的简单证明的重要部分，这个定理最初是由 Chvátal 证明的。

假设这个食谱中的多边形是一个艺术画廊的平面图，并且一些守卫需要放置在顶点上。一点工作就会表明，你需要在多边形的顶点处放置三个守卫，整个博物馆才能被覆盖。在下面的图像中，我们绘制了一个可能的布局：

![](img/267a0779-deb3-449c-b481-3cde9a5ce205.png)

图 8.7：在顶点上放置守卫的艺术画廊问题的一个可能解决方案。

点由点表示，并且它们相应的视野范围被阴影表示。

每个顶点都放置了一个守卫，并且他们的视野范围由相应的阴影区域表示。在这里，你可以看到整个多边形至少被一种颜色覆盖。艺术画廊问题的解决方案——实际上是原问题的一个变体——告诉我们，最多需要四名守卫。

## 另请参阅

关于艺术画廊问题的更多信息可以在 O'Rourke 的经典著作中找到：*ORourke, J. (1987). Art gallery theorems and algorithms. New York: Oxford University Press.*

# 计算凸包

如果图形内的每一对点都可以使用一条直线连接，并且这条直线也包含在图形内，那么几何图形被称为*凸*。凸体的简单例子包括点、直线、正方形、圆（圆盘）、正多边形等。图 8.5 中显示的几何图形不是凸的，因为孔的对面的点不能通过保持在图形内的直线连接起来。

从某种角度来看，凸图形是简单的，这意味着它们在各种应用中都很有用。一个特别的问题涉及找到包含一组点的最小凸集。这个最小凸集被称为这组点的*凸包*。

在这个食谱中，我们将学习如何使用 Shapely 包找到一组点的凸包。

## 准备工作

对于这个食谱，我们需要导入 NumPy 包作为`np`，导入 Matplotlib 包作为`mpl`，并导入`plt`模块：

```py
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
```

我们还需要从 NumPy 导入默认的随机数生成器。我们可以这样导入：

```py
from numpy.random import default_rng
rng = default_rng(12345)
```

最后，我们需要从 Shapely 导入`MultiPoint`类：

```py
from shapely.geometry import MultiPoint
```

## 操作方法...

按照以下步骤找到一组随机生成点的凸包：

1.  首先，我们生成一个二维数组的随机数：

```py
raw_points = rng.uniform(-1.0, 1.0, size=(50, 2))
```

1.  接下来，我们创建一个新图形，并在这个图形上绘制这些原始样本点：

```py
fig, ax = plt.subplots()
ax.plot(raw_points[:, 0], raw_points[:, 1], "k.")
ax.set_axis_off()
```

这些随机生成的点可以在下图中看到。这些点大致分布在一个正方形区域内：

![](img/a5d0f401-8381-489e-915c-cb61b0cf5d5f.png)图 8.8：平面上的一组点

1.  接下来，我们构建一个`MultiPoint`对象，收集所有这些点并将它们放入一个单一对象中：

```py
points = MultiPoint(raw_points)
```

1.  现在，我们使用`convex_hull`属性获取这个`MultiPoint`对象的凸包：

```py
convex_hull = points.convex_hull
```

1.  然后，我们创建一个 Matplotlib`Polygon`补丁，可以在我们的图中绘制，以显示找到的凸包的结果：

```py
patch = mpl.patches.Polygon(convex_hull.exterior, alpha=0.5,
   ec="k", lw=1.2)
```

1.  最后，我们将`Polygon`补丁添加到图中，以显示凸包： 

```py
ax.add_patch(patch)
```

随机生成的点的凸包可以在下图中看到：

![](img/1e11e76a-2124-4912-8fbb-b0b5b4ce95a8.png)图 8.9：平面上一组点的凸包

## 工作原理...

Shapely 包是围绕 GEOS 库的 Python 包装器，用于几何分析。Shapely 几何对象的`convex_hull`属性调用 GEOS 库中的凸包计算例程，从而产生一个新的 Shapely 对象。从这个教程中，我们可以看到一组点的凸包是一个多边形，其顶点是离“中心”最远的点。

# 构造贝塞尔曲线

*贝塞尔曲线*，或*B 样条*，是一族曲线，在矢量图形中非常有用-例如，它们通常用于高质量的字体包中。这是因为它们由少量点定义，然后可以用来廉价地计算沿曲线的大量点。这允许根据用户的需求来缩放细节。

在本教程中，我们将学习如何创建一个表示贝塞尔曲线的简单类，并计算沿其路径的若干点。

## 准备工作

在本教程中，我们将使用导入为`np`的 NumPy 包，导入为`plt`的 Matplotlib `pyplot`模块，以及 Python 标准库`math`模块中导入为`binom`的`comb`例程：

```py
from math import comb as binom
import matplotlib.pyplot as plt
import numpy as np
```

## 如何做...

按照以下步骤定义一个表示贝塞尔曲线的类，该类可用于计算沿曲线的点：

1.  第一步是设置基本类。我们需要为实例属性提供控制点（节点）和一些相关的数字：

```py
class Bezier:
    def __init__(self, *points):
        self.points = points
        self.nodes = n = len(points) - 1
        self.degree = l = points[0].size
```

1.  仍然在`__init__`方法中，我们生成贝塞尔曲线的系数，并将它们存储在实例属性的列表中：

```py
        self.coeffs = [binom(n, i)*p.reshape((l, 1)) for i, 
           p in enumerate(points)]
```

1.  接下来，我们定义一个`__call__`方法，使类可调用。我们将实例中的节点数加载到本地变量中，以便清晰明了：

```py
    def __call__(self, t):
        n = self.nodes
```

1.  接下来，我们重新整理输入数组，使其包含单行：

```py
        t = t.reshape((1, t.size))
```

1.  现在，我们使用实例的`coeffs`属性中的每个系数生成值数组的列表：

```py
        vals = [c @ (t**i)*(1-t)**(n-i) for i, 
           c in enumerate(self.coeffs)]
```

1.  最后，我们对*步骤 5*中构造的所有数组进行求和，并返回结果数组：

```py
       return np.sum(vals, axis=0)
```

1.  现在，我们将通过一个示例来测试我们的类。我们将为此示例定义四个控制点：

```py
p1 = np.array([0.0, 0.0])
p2 = np.array([0.0, 1.0])
p3 = np.array([1.0, 1.0])
p4 = np.array([1.0, 3.0])
```

1.  接下来，我们为绘图设置一个新的图形，并用虚线连接线绘制控制点：

```py
fig, ax = plt.subplots()
ax.plot([0.0, 0.0, 1.0, 1.0], [0.0, 1.0, 1.0, 3.0], "*--k")
ax.set(xlabel="x", ylabel="y", title="Bezier curve with 
    4 nodes, degree 3")
```

1.  然后，我们使用*步骤 7*中定义的四个点创建我们的`Bezier`类的新实例：

```py
b_curve = Bezier(p1, p2, p3, p4)
```

1.  现在，我们可以使用`linspace`创建 0 到 1 之间等间距点的数组，并计算沿着贝塞尔曲线的点：

```py
t = np.linspace(0, 1)
v = b_curve(t)
```

1.  最后，我们在之前绘制的控制点上绘制这条曲线：

```py
ax.plot(v[0,:], v[1, :])
```

我们绘制的贝塞尔曲线可以在下图中看到。正如你所看到的，曲线从第一个点（0, 0）开始，结束于最终点（1, 3）：

![](img/c99f6f7e-92bd-41b2-ad90-1825adbf5281.png)图 8.10：使用四个节点构造的三次贝塞尔曲线

## 工作原理...

贝塞尔曲线由一系列控制点描述，我们以递归方式构造曲线。一个点的贝塞尔曲线是一个保持在该点的常数曲线。具有两个控制点的贝塞尔曲线是这两个点之间的线段：

![](img/7831c8c4-15ee-4b9b-9510-6984e970b044.png)

当我们添加第三个控制点时，我们取对应点之间的线段，这些点是由一个较少点构成的贝塞尔曲线的曲线。这意味着我们使用以下公式构造具有三个控制点的贝塞尔曲线：

![](img/073ba1c8-7fa9-44af-b3fd-ac9851a2c20f.png)

这种构造可以在下图中看到：

![](img/5a5c45d4-8528-4e6e-b677-9358fa883cf8.png)图 8.11：使用递归定义构造二次贝塞尔曲线。黑色虚线显示了两条线性贝塞尔曲线。

这种构造方式继续定义了任意数量控制点上的贝塞尔曲线。幸运的是，在实践中我们不需要使用这种递归定义，因为我们可以将公式展开成曲线的单一公式，即以下公式：

![](img/9674263f-1838-4821-9319-4120c125c796.png)

在这里，**p**[*i*]元素是控制点，*t*是一个参数，而

![](img/b65b100a-f769-42f8-bc75-dc5b79d02475.png)

是二项式系数。请记住，*t*参数是生成曲线点的变化量。我们可以分离前述求和中涉及*t*的项和不涉及*t*的项。这定义了我们在*步骤 2*中定义的系数，每个系数由以下代码片段给出：

```py
binom(n, i)*p.reshape((l, 1))
```

我们在这一步中对每个点`p`进行了 reshape，以确保它被排列为列向量。这意味着每个系数都是一个列向量（作为 NumPy 数组），由二项式系数缩放的控制点组成。

现在，我们需要指定如何在不同的*t*值上评估贝塞尔曲线。这就是我们利用 NumPy 包中的高性能数组操作的地方。在形成系数时，我们将控制点 reshape 为列向量。在*步骤 4*中，我们将输入*t*值 reshape 为行向量。这意味着我们可以使用矩阵乘法运算符将每个系数乘以相应的（标量）值，具体取决于输入的*t*。这就是*步骤 5*中列表推导式中发生的情况。在下一行中，我们将*l×1*数组乘以*1×N*数组，得到一个*l×N*数组：

```py
c @ (t**i)*(1-t)**(n-i)
```

我们为每个系数都得到一个这样的数组。然后，我们可以使用`np.sum`例程来对这些*l×N*数组中的每一个进行求和，以得到贝塞尔曲线上的值。在本示例中，输出数组的顶行包含曲线的*x*值，底行包含曲线的*y*值。在指定`axis=0`关键字参数时，我们必须小心确保`sum`例程对我们创建的列表进行求和，而不是对该列表包含的数组进行求和。

我们定义的类是使用贝塞尔曲线的控制点进行初始化的，然后用于生成系数。曲线值的实际计算是使用 NumPy 完成的，因此这种实现应该具有相对良好的性能。一旦创建了这个类的特定实例，它的功能就非常像一个函数，正如你所期望的那样。但是，这里没有进行类型检查，所以我们只能用 NumPy 数组作为参数来调用这个“函数”。

## 还有更多...

贝塞尔曲线是使用迭代构造定义的，其中具有*n*个点的曲线是使用连接由第一个和最后一个*n-1*点定义的曲线来定义的。使用这种构造跟踪每个控制点的系数将很快导致我们用来定义前述曲线的方程。这种构造还导致贝塞尔曲线的有趣和有用的几何特性。

正如我们在这个配方的介绍中提到的，贝塞尔曲线出现在许多涉及矢量图形的应用程序中，比如字体。它们也出现在许多常见的矢量图形软件包中。在这些软件包中，通常会看到*二次贝塞尔曲线*，它们由三个点的集合定义。然而，你也可以通过提供两个端点以及这些点上的梯度线来定义一个二次贝塞尔曲线。这在图形软件包中更常见。生成的贝塞尔曲线将沿着梯度线离开每个端点，并在这些点之间平滑地连接曲线。

我们在这里构建的实现对于小型应用程序来说性能相对较好，但对于涉及在大量*t*值上渲染具有大量控制点的曲线的应用程序来说是不够的。对于这一点，最好使用一个用编译语言编写的低级软件包。例如，`bezier` Python 软件包使用编译的 Fortran 后端进行计算，并提供比我们在这里定义的类更丰富的接口。

当然，贝塞尔曲线可以自然地扩展到更高的维度。结果是一个贝塞尔曲面，使它们成为非常有用的通用工具，用于高质量、可伸缩的图形。

# 进一步阅读

+   计算几何中一些常见算法的描述可以在以下书籍中找到：*Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P., 2007\. Numerical recipes: the art of scientific computing**. 3rd ed. Cambridge: Cambridge University Press*。

+   有关计算几何中一些问题和技术的更详细描述，请查阅以下书籍：*O'Rourke, J., 1994\. Computational geometry in C**. Cambridge: Cambridge University Press*。
