# 5. 用 Python 进行更多数学

概述

在本章结束时，你将能够掌握序列和级数的基本概念，并编写实现这些概念的 Python 函数。你将了解基本三角函数及其应用之间的关系，比如著名的毕达哥拉斯定理。你将练习向量微积分，并通过在 Python 中进行向量代数来了解它的适用性。最后，你会感到高兴，因为复数并不比其他类型的数字差；它们与三角学密切相关，并且对现实世界的应用很有用。

# 介绍

在上一章中，我们用 Python 介绍了函数和代数，从基本函数开始，然后进行变换和解方程。在本章中，我们将介绍序列和级数，在现实世界中有许多应用，比如金融，也是理解微积分的基础。此外，我们还将探讨三角学、向量和复数，以便更好地理解数学世界。

任何出色的 Python 程序员的核心技能包括对背景数学的深刻理解以及有效地应用它们。把向量和复数看作是我们*数学工具箱*的有价值扩展，它们将有助于有效地描述、量化和解决来自金融、科学、商业和社会领域的现实问题。

序列和级数等在利润、损失、股利或其他支付定期发生的情况中出现。三角学和三角函数对解决地理空间问题至关重要，而向量在物理学和工程学、机器学习等领域得到广泛应用，其中多个不同的值被分组在一起，方向的概念至关重要。复数是一些最基本的概念，在电磁学、光学、量子力学和计算机科学等领域有广泛的应用。

# 序列和级数

如果你参加一个电视节目，其中 1 万美元的问题是“给定数字 2、4、8、16 和 32，序列中接下来是什么？”，你最好的猜测是什么？如果你的回答是 64，那么恭喜你——你刚刚更接近理解数学抽象中的一个关键概念：序列。**序列**就像普通意义上的顺序一样，是一种事物相互跟随的特定顺序。在这里，*事物*（在大多数情况下）是相关的整数或实数。元素的顺序很重要。元素也被称为序列的成员或术语。

例如，在你参与的电视节目的前述序列中，每个术语都是前一个数字乘以 2 得到的；这个序列没有结束，因为可以无限产生整数数字。在其他情况下，序列中的元素可以出现多次。想想一年中每个月的天数，或者随机事件的结果序列，比如抛硬币的结果。自古印度以来就已知的一个著名序列是斐波那契数列——1、1、2、3、5、8、13……这个序列中，每个*新*术语都是前两个术语的和。

也就是说，我们需要知道至少两个术语才能推导出其他任何术语。换句话说，我们需要读取前两个数字（在前述序列中是 1 和 1，但通常是任意两个数字）才能推导和预测第三个数字。我们知道一些序列，比如斐波那契数列，其中包含一些内在的逻辑；我们可以遵循一个基本规则，并推导出序列的任何术语。

在本章中，我们将重点关注基本序列，也称为**级数**，这些序列在应用数学和编程的许多领域中反复出现，属于三种基本类别之一：等差、等比和递归。这些不是唯一的可能性；然而，它们是最受欢迎的序列家族，并且说明了它们所蕴含的逻辑。

一系列数字{αn} = {α1, α2, α3, ..., αΝ, ...}是一个有序的术语（元素或成员）的集合，对于这个集合有一个规则，将每个自然数 n = 1, 2, 3, ..., N 与序列中的一个术语关联起来。序列的长度（即其术语的数量）可以是有限的或无限的，因此相应地称为有限或无限序列。

一个**级数**是一个按照以下方式求和的数学序列：

![Figure 5.1: 级数方程](img/B15968_05_01.jpg)

图 5.1：级数方程

这也可以使用求和符号进行求和，如下所示：

![图 5.2：无限级数的方程](img/B15968_05_02.jpg)

图 5.2：无限级数的方程

在前面的情况下，我们的级数是无限的（即，它是无限序列的所有项的和）。然而，一个级数，就像一个序列一样，也可以是有限的。为什么一个总和会有无限个项？因为事实证明，在许多情况下，通过应用已知的公式进行计算更有效。此外，即使序列是无限的，求和也可以收敛到一个数字（不是无穷大）或某个函数。由于这个原因，级数可以被认为是已知函数的*构建块*，它们的术语可以用来表示越来越复杂的函数，从而使得对它们的性质的研究变得直观。级数和序列在数学、物理、工程、金融等领域中无处不在，并且自古以来就为人所知。它们出现并且作为无限和的定义在导数和其他函数中特别有用。

## 等差数列

像大多数数学概念一样，序列无处不在我们的日常生活中。你可能以前没有想过，但每次你乘坐出租车时，后台都会运行一个序列来计算你的乘车总费用。有一个初始费用，每公里（或英里）增加一个固定金额。因此，在任何给定时刻，都有一个实际的对应数字（到目前为止的乘车费用）。所有这些小计的有序集合形成一个序列。同样，随着你的成长，你的身高是一个随时间（天或月）变化的实数序列（以厘米或英寸表示的身高）。这两个例子都构成了随时间非递减的序列——换句话说，每个术语要么大于等于任何先前的术语，但从不小于。然而，这两个例子之间存在微妙的差异：随着我们的成长，我们增加身高的速度不同（儿童增长速度快，青少年增长速度慢，成年人增长速度为零），而出租车费用增加的速度是恒定的。这导致我们需要引入一种特殊类别的序列——等差数列，其定义如下。

任意两个连续项之间的差是恒定的序列称为**等差**。因此，等差数列的公式如下：*α*n+1*- α*n *= d*

在这里，*d*是常数，必须对所有*n*成立。当然，很明显，如果你知道参数*d*和一些（任何）项*α*n*，那么项*α*n+1 可以通过前面的关系直接找到。通过重复，所有项*α*n+2，*α*n+3 ...，以及项*α*n-1，*α*n-2 都可以找到。换句话说，如果你知道参数*d*和序列的第一项*α*1，那么所有项（即唯一确定的）的序列都是已知的。给出我们序列的第*n*项的一般公式如下：

*α*n *= α*1 *+ (n – 1)d*

在这里，*d*被称为公差。

相反，要测试一个通用序列是否是等差数列，只需检查其项的所有成对差异*α*n+1 – *α*n，并查看这些是否是相同的常数。在相应的等差数列中，前面序列的和变成了下面的形式：

*Σ*nj *α*j *= Σ*nj *[ α*1 *+ (j – 1)d ] = n(α*1 *+ α*n*)/2*

这意味着通过知道长度*n*，序列的第一个和最后一个项，我们可以确定从*α*1 到*α*n 的所有项的和。请注意，和（*α*1 + *α*n）给出整个序列的算术平均数的两倍，因此该序列不过是算术平均数的*n*倍。

现在，我们知道算术序列的主要逻辑和组成部分。现在，让我们看一些具体的例子。目前，我们不需要在 Python 中导入任何特定的库，因为我们将创建自己的函数。让我们提醒自己，这些函数总是需要以`def`开头，后面跟着一个空格，函数名（任何我们喜欢的东西），以及函数在括号内接受的参数列表，后面跟着一个分号。接下来的行是缩进的（向右缩进四个空格），并且是函数的逻辑，也就是函数的算法或方法。例如，考虑以下例子：

```py
def my_function(arg1, arg2):
    '''Write a function that adds two numbers 
       and returns their sum'''
    result = arg1 + arg2
    return result
```

在最终语句`result`之后，返回的是函数的返回值。因此，例如，如果我们正在编写前面的`my_function`定义，该定义接收两个输入数字`arg1`和`arg2`，那么我们可以将它传递给一个新变量，比如以下变量：

```py
summed = my_function(2,9)
print(summed)
```

输出将如下所示：

```py
11
```

在这里，`summed`是一个新变量，它正是由`my_function`返回（生成）的。请注意，如果在函数定义中缺少`return`语句，则语法仍然正确，函数仍然可以被调用。但是，`summed`变量将等于`None`。

现在，如果我们想创建一个（任何）数字序列，我们应该在我们的函数内包含一个迭代。在 Python 中，可以通过`for`或`while`循环来实现这一点。让我们看一个例子，一个函数输出一个`n`个和的序列：

```py
def my_sequence(arg1, arg2, n):
    '''Write a function that adds two numbers n times and 
       prints their sum'''
    result = 0
    for i in range(n):
        result = result + arg1 + arg2
        print(result)
```

在这里，我们初始化变量 result（为零），然后迭代地将`arg1 + arg2`加到它上面。这个迭代发生了`n`次，其中`n`也是我们新函数`my_sequence`的一个参数。每次循环（跟在`for`语句后面的）执行时，`result`增加了`arg1 + arg2`，然后打印在屏幕上。为简单起见，我们在这里省略了`return`语句。在这里，我们使用了 Python 内置的`range()`方法，它生成一个整数序列，从 0 开始，以给定的停止整数之前的一个数结束（我们提供的数字）。让我们调用我们的函数：

```py
my_sequence(2,9,4)
```

我们将获得以下输出：

```py
11
22
33
44
```

如果我们使用了`while`循环，我们将得到相同的结果：

```py
def my_sequence(arg1, arg2, n):
    '''Write a function that adds two numbers n times 
       and prints their sum'''
    i = 0
    result = 0
    while i < n:
        result = result + arg1 + arg2
        i += 1
        print(result)
```

如果我们调用`my_sequence`函数，我们将得到与先前相同输入的相同输出。

## 生成器

在 Python 中进行顺序操作的另一个有趣选项是使用生成器。**生成器**是类似于函数的对象，返回一组可迭代的项目，一次一个值。简单地说，如果一个函数包含至少一个`yield`语句，它就成为一个生成器函数。使用生成器而不是函数的好处是，我们可以根据需要（这里是无限次数）调用生成器，而不会使系统的内存过载。在某些情况下，它们可以是无价的工具。要获取一系列项的一个项，我们使用`next()`方法。首先，让我们定义我们的函数：

```py
def my_generator(arg1, arg2, n):
    '''Write a generator function that adds 
       two numbers n times and prints their sum'''
    i = 0
    result = 0
    while i < n:
        result = result + arg1 + arg2
        i += 1
        yield result
```

现在，让我们多次调用`next()`方法：

```py
my_gen = my_generator(2,9,4)
next(my_gen)
```

以下是输出：

```py
11
```

第二次调用该方法：

```py
next(my_gen)
```

以下是输出：

```py
22
```

第三次调用它：

```py
next(my_gen)
```

以下是输出：

```py
33
```

第四次调用该方法：

```py
next(my_gen)
```

以下是输出：

```py
44
```

因此，我们得到了与上一个示例相同的结果，但是一次一个。如果我们重复调用`next()`方法，我们将收到错误消息，因为我们已经*耗尽*了我们的生成器：

```py
next(my_gen)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
StopIteration
```

现在，我们准备在 Python 代码中实现我们学到的序列关系。

## 练习 5.01：确定算术序列和算术级数的第 n 项

在这个练习中，我们将使用一个简单的 Python 函数创建有限和无限的算术序列。作为输入，我们希望提供序列的第一项`a1`，公差`d`和序列的长度`n`。我们的目标是获得以下内容：

+   序列的一个项（第*n*项）。

+   完整的数字序列。

+   算术序列的*n*项的和，以便将其与先前给出的算术级数的结果进行比较。

为了计算前面的目标，我们需要提供序列的第一项`a1`，公差`d`和序列的长度`n`作为输入。让我们实现这个练习：

1.  首先，我们想要编写一个函数，根据通用公式*α*n *= α*1 *+ (n – 1)d* 返回第*n*项：

```py
    def a_n(a1, d, n):
        '''Return the n-th term of the arithmetic sequence.
        :a1: first term of the sequence. Integer or real.
        :n: the n-th term in sequence
        returns: n-th term. Integer or real.'''
        an = a1 + (n - 1)*d
        return an
    ```

通过这样做，我们获得了序列的第*n*项，而无需知道任何其他前面的项。例如，让我们用参数`(4, 3, 10)`调用我们的函数：

```py
    a_n(4, 3, 10)
    ```

我们将得到以下输出：

```py
    31
    ```

1.  现在，让我们编写一个函数，它将初始项`a1`递增`d`，`n`次，并将所有项存储在列表中：

```py
    def a_seq(a1, d, n):
        '''Obtain the whole arithmetic sequence up to n.
        :a1: first term of the sequence. Integer or real.
        :d: common difference of the sequence. Integer or real.
        :n: length of sequence
        returns: sequence as a list.'''
        sequence = []
        for _ in range(n):
            sequence.append(a1)
            a1 = a1 + d
        return sequence
    ```

1.  要检查结果列表，请添加以下代码：

```py
    a_seq(4, 3, 10)
    ```

输出如下：

```py
    [4, 7, 10, 13, 16, 19, 22, 25, 28, 31]
    ```

在这里，我们得到了一个长度为 10 的算术序列，从`4`开始，增加 3。

1.  现在，让我们生成无限序列。我们可以使用之前介绍的 Python 生成器来实现这一点：

```py
    def infinite_a_sequence(a1, d):
        while True:
            yield a1
            a1 = a1 + d
    for i in infinite_a_sequence(4,3):
        print(i, end=" ")
    ```

如果运行上述代码，您会注意到我们必须手动中止执行；否则，`for`循环将永远打印出序列的元素。使用 Python 生成器的另一种方法是，如前所述，直接在生成器对象（这里是`infinite_a_sequence()`）上调用`next()`方法。

1.  让我们通过调用`sum()` Python 方法来计算我们序列的项的和：

```py
    sum(a_seq(4, 3, 10))
    ```

输出如下：

```py
    175
    ```

1.  最后，实现*α*n *= α*1 *+ (n – 1)d* 公式，这给我们算术级数，以便我们可以将其与我们的求和结果进行比较：

```py
    def a_series(a1, d, n):
        result = n * (a1 + a_n(a1, d, n)) / 2
        return result
    ```

1.  运行函数，如下：

```py
    a_series(4, 3, 10)
    ```

输出如下：

```py
    175.0
    ```

注意

要访问此特定部分的源代码，请参阅[`packt.live/2D2S52c.`](https://packt.live/2D2S52c )

您还可以在[`packt.live/31DjRfO.`](https://packt.live/31DjRfO )上在线运行此示例

有了这个，我们通过使用序列或级数得到了相同的结果，得到了算术序列元素的总和。能够用两种独立的数学方法交叉验证给定结果的能力对于所有级别的程序员来说都是非常有用的，并且是科学验证的核心。此外，了解不同的方法（在这里，我们用来得到级数结果的两种方法），以及每种方法的优势（以及劣势）对于在高级水平上编写代码至关重要。

我们将学习另一种不同但同样基本的序列类别：几何序列。

## 几何序列

传染病从一个人传播到另一个或更多人，取决于给定社区的人口密度。在像大流行这样的情况下，对于一种中等传染性的疾病，平均每个患病者每天感染两个人是现实的。因此，如果在第 1 天只有一个感染者，第 2 天将有两个新感染者，第 3 天，对于每个先前感染的两个人，另外两个人将感染疾病，使新感染者的数量增加到四个。同样，在第 4 天，会出现八个新病例，依此类推。我们可以看到疾病扩展的速度并不是恒定的，因为新病例的数量取决于给定时刻现有病例的数量，这解释了大流行是如何呈指数增长和传播的。

前面的数字（1, 2, 4, 8...）形成一个序列。请注意，现在，算术序列的要求没有得到满足：两个连续项之间的差异不是恒定的。然而，比率是恒定的。这说明了前面的序列是一种特殊类型的序列，称为**几何**，并且被定义为一个序列或一组有序数字，其中任意两个连续项的比率是恒定的。

在数学的简洁语言中，我们可以将前面的行为写成*α*n+1 *= r α*n。

在这里，*α*n 是第*n*天的*病例*数量，*α*n+1 是第*n+1*天的新病例数量，*r>0*是定义增长速度（或减速速度）的系数。这被称为公比。前面的公式是通用的，这意味着它适用于所有成员*n*。因此，如果它对*n*成立，那么它对*n-1*，*n-2*等也成立。通过递归地处理前面的关系，我们可以轻松地得到*α*n *= r*n-1*α*方程。

在这里，我们给出了几何序列的第*n*项，一旦给出了第一项*α=α*1 和公比*r*。术语*α*被称为**比例因子**。

请注意，*r*可以有任何非零值。如果*r>1*，每一代，*α*n+1 都比前一代大，因此序列是不断增加的，而如果*r<1*，则相反：随着*n*的增加，*α*n+1 趋于零。因此，在传染病的初始例子中，*r>1*意味着传播是增加的，而*r<1*则导致传播减少。

让我们编写一个 Python 函数，根据*α*n *= r*n-1*α*的公式计算几何函数的第*n*项：

```py
def n_geom_seq(r, a, n):
    an = r**(n-1) * a 
    return an 
```

该函数中的输入是`r`，公比，`a`，比例因子，和`n`，我们想要找到的第*n*项。让我们用一些参数调用这个函数，`(2, 3, 10)`：

```py
n_geom_seq(2, 3, 10) 
```

输出如下：

```py
1536
```

同样，对于算术序列的情况，我们将几何级数定义为序列长度*n*的项的总和：

![图 5.3：几何序列](img/B15968_05_03.jpg)

图 5.3：几何序列

或者，我们可以这样表达：

![图 5.4：几何序列的另一种表达](img/B15968_05_04.jpg)

图 5.4：几何序列的另一种表达

为了更好地理解几何级数，让我们看看它在 Python 中是如何工作并进行可视化的。我们需要定义一个函数，接受`r`、`a`和`n`（就像之前一样）作为输入，并计算第二个公式，即到第*n*项的级数：

```py
def sum_n(r, a, n):
    sum_n = a*(1 - r**n) / (1 - r) 
    return sum_n
```

现在，像之前一样，为参数`(2, 3, 10)`调用函数：

```py
sum_n(2, 3, 10)
```

输出如下：

```py
3069.0
```

看一下几何序列的以下示例图，其中值对*r>1*递增：

![图 5.5：几何序列 r>1 递增](img/B15968_05_05.jpg)

图 5.5：几何序列 r>1 递增

看一下几何序列的以下示例图，其中值对*r<1*递减：

![图 5.6：几何序列 r<1 递减](img/B15968_05_06.jpg)

图 5.6：几何序列 r<1 递减

在本节中，我们已经看到了几何序列的进展以及如何在 Python 中轻松找到它的项，以及几何级数。我们现在准备在练习中实现我们所学到的内容，以便更好地理解序列及其应用。

## 练习 5.02：编写一个函数来找到序列的下一个项

培养皿中细菌数量以几何序列增加。给定每天的细菌数量，跨越一定天数*n*，编写一个函数，计算第*n+1*天的细菌数量。按照以下步骤完成这个练习：

1.  编写一个函数，接受可变数量的参数（`*args`）并计算任何元素与其前一个元素之间的比率（从第二个元素开始）。然后，检查找到的所有比率是否相同，并返回它们的唯一值。否则，函数返回`-1`（序列没有唯一的公共比率）：

```py
    def find_ratio(*args):
        arg0=args[0]
        ratios = []
        for arg in args[1:]:
            ratio = round(arg/arg0,8)
            arg0=arg
            ratios.append(ratio)
        if len(set(ratios)) == 1:
            return ratio
        else:
            return -1
    ```

1.  现在，检查`find_ratio`函数的两种不同情况。首先，让我们使用以下序列：

```py
    find_ratio(1,2,4,8,16,32,64,128,256,512)
    ```

输出如下：

```py
    2.0
    ```

1.  现在，让我们使用以下序列：

```py
    find_ratio(1,2,3)
    ```

输出如下：

```py
    -1
    ```

如前面的输出所示，`find_ratio`函数打印出比率，如果存在的话，或者如果序列不是几何序列，则打印`-1`。

1.  现在，编写第二个函数，读取一个序列并打印出下一个项将是什么。为此，读取一个（逗号分隔的）数字列表，找到它们的比率，然后预测下一个项：

```py
    def find_next(*args):
        if find_ratio(*args) == -1:
            raise ValueError('The sequence you entered' \
                             'is not a geometric sequence. '\
                             'Please check input.')
        else:
            return args[-1]*find_ratio(*args)
    ```

请注意，我们要通过调用我们之前编写的`find_ratio()`函数来检查序列是否具有公共比率。如果没有，就引发一个错误；如果有，就找到下一个项并返回它。

1.  通过使用以下序列来检查它是否有效：

```py
    find_next(1,2,4)
    ```

以下是前面代码的输出：

```py
    8.0
    ```

1.  现在，尝试使用不同的序列：

```py
    find_next(1.36,0.85680,0.539784,0.34006392)
    ```

输出如下：

```py
    0.2142402696
    ```

它有效。在第一种情况下，明显的结果`8.0`被打印出来。在第二种情况下，找到并打印出了递减的几何序列的不太明显的结果。总之，我们能够编写一个函数，检测几何序列，找到它的比率，并用它来预测下一个序列项。这在现实生活中非常有用，比如需要验证复利利率的情况。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2NUyT8N`](https://packt.live/2NUyT8N)。

您也可以在[`packt.live/3dRMwQV`](https://packt.live/3dRMwQV)上在线运行此示例。

在前面的章节中，我们看到序列，无论是等差还是等比，都可以用两种等价的方式来定义。我们看到序列的第*n*项是通过知道序列的给定项（通常是第一项，但不一定）和公差或公比来确定的。更有趣的是，我们看到序列的第*n*项可以通过知道第*(n-1)*项来找到，而第*(n-1)*项又可以通过知道第*(n-2)*项来找到，依此类推。因此，这里有一个有趣的模式，决定了我们研究的两种序列类型，实际上超出了它们。事实证明，我们可以概括这种行为，并以纯粹递归的方式定义序列，而不一定是等差或等比的。现在，让我们继续下一节，我们将了解递归序列。

## 递归序列

**递归序列**是一个元素序列，*υ*n，通过递归关系产生，也就是说，每个元素都是唯一地从前面的元素产生出来的。

*υ*n 可以依赖于一个或多个在它之前的元素。例如，我们在本章前面看到的斐波那契数列是一个递归序列，其中知道第*n*项需要知道第*(n-1)*项和第*(n-2)*项。另一方面，阶乘只需要前面的元素。具体来说，它由递归关系定义，*n! = n(n-1)! , n > 0*，和初始条件，*0! = 1*。

让我们将前面的公式转换成 Python 代码：

```py
def factorial(n):
    if n == 0 or n ==1:
        return 1
    elif n == 2:
        return 2
    else:
        return n*factorial(n - 1)
```

前面的代码是阶乘函数的递归实现：为了计算*n*的结果，我们调用*n-1*的函数，然后*n-1*调用*n-2*的函数，依此类推，直到*n=2*。

如果我们对*n=11*的情况执行前面的函数，我们得到以下结果：

```py
factorial(11)
```

输出如下：

```py
39916800
```

请注意，到目前为止我们看到的前两类序列（等差和等比）是互斥的，但是递归序列不是，也就是说，序列既可以是递归的，也可以是等差的或等比的。按照惯例，我们用术语*递归*来表示这些类型的序列，与等比和等差不同，它们不能以非递归的方式表示。

现在我们已经探讨了递归序列的基本概念，我们可以在 Python 中实现这一点，并编写计算递归定义的任何序列的任意数量的元素的代码。

## 练习 5.03：创建自定义递归序列

在这个练习中，我们将使用我们在前一节中解释的概念创建一个自定义的递归序列。给定序列的前三个元素，*P*n，也就是*P*1*=1*，*P*2*=7*，和*P*3*=2*，找出递归定义的序列的接下来七个项，关系为*P*n+3*= (3*P*n+1 *- P*n+2*)/(P*n *– 1)*。按照以下步骤完成这个练习：

1.  定义一个 Python 函数，它是递归的，并实现了前面给出的序列的第*n*个元素的关系：

```py
    def p_n(n):
        if n < 1:
            return -1
        elif n == 1:
            return 1
        elif n == 2:
            return 7
        elif n == 3:
            return 2
        else:
            pn = (3*p_n(n-2) - p_n(n-1) )/ (p_n(n-3) + 1)
            return pn
    ```

在这里，我们首先定义了基本情况，也就是在简介中给出的已知结果：如果*n=1*，那么*P=1*，如果*n=2*，那么*P=7*，如果*n=3*，那么*P=2*。我们还包括了*n<1*的情况。这是无效的输入，惯例上，我们的函数返回值为`-1`。这使得我们的函数*有界*，并且受到保护，不会进入无限循环和无效输入。一旦处理了这些情况，我们就定义了递归关系。

1.  现在，让我们测试我们的函数，并打印出序列的前 10 个值（三个对应于基本情况，另外七个是我们要找的）：

```py
    for i in range(1,11):
        print(p_n(i))
    ```

输出如下：

```py
    1
    7
    2
    9.5
    -0.4375
    9.645833333333334
    -1.0436507936507937
    53.29982363315697
    -5.30073825572847
    -3784.586609737289
    ```

从前面的输出中可以看出，我们的函数有效，并返回了序列的已知值（*P*1 *= 1*，*P*2 *= 7*，和*P*3 *= 2*）以及我们正在寻找的下一个项（*P_1*到*P_10*）。

1.  作为奖励，让我们使用`matplotlib`模块绘制我们的发现。我们将创建一个包含序列前九个值的列表，然后用`pyplot`绘制它：

```py
    from matplotlib import pyplot as plt
    plist = []
    for i in range(1,40):
        plist.append(p_n(i))

    plt.plot(plist, linestyle='--', marker='o', color='b')
    plt.show()
    ```

输出如下：

![图 5.7：使用 matplotlib 库创建的图表](img/B15968_05_07.jpg)

图 5.7：使用 matplotlib 库创建的图表

注意

要访问本节的源代码，请参阅[`packt.live/2D3vlPF`](https://packt.live/2D3vlPF)。

您也可以在[`packt.live/3eY05Q4`](https://packt.live/3eY05Q4)上在线运行此示例。

我们可以看到，一个简单而明确定义的递归关系可以导致明显随机或混沌的结果。实际上，如果您继续绘制前述序列的项，很快就会注意到在项的模式中没有明显的规律，它们在 0 周围广泛且不对称地振荡。这促使我们得出结论，即使定义了一个递归序列并预测了它的第 n 项是直接的，相反的情况并不总是成立。正如我们所看到的，鉴于一个序列（一系列数字），检查它是否形成等差数列、等比数列或两者都不是，是非常简单的。然而，要回答一个给定的序列是否由递归关系导出——更不用说这个递归是什么——是一个非平凡的任务，在大多数情况下都无法回答。

在本节中，我们介绍了序列是什么，为什么它们很重要，以及它们与数学中另一个重要概念的联系：级数。我们研究了三种一般类型的序列，即等差、等比和递归，并看到它们如何可以在 Python 中通过几个简单的步骤实现。在下一节中，我们将深入研究三角学，并学习如何使用 Python 轻松解决三角学问题。

# 三角学

三角学是研究三角形，特别是它们的角与边的关系。三角形的三条边（边）中的两条的比值提供了关于特定角的信息，并且对于这样一对边，我们给它一个特定的名称，并称之为函数。三角学和数学的美妙之处在于这些函数，它们诞生于三角形内部，在三角形不存在的任何其他情况下都有（抽象的）意义，并且作为独立的数学对象运行。因此，诸如正切、余弦和正弦之类的函数在大多数数学、物理和工程领域都可以找到，而无需参考三角形。

让我们看看最基本的三角函数及其用法。

## 基本三角函数

我们将从定义一个直角三角形（或简称直角三角形）开始，三角形 ABC。它的一个角（下图中的角 BCA）是一个**直角**，即 90 度角。直角的对边称为**斜边**（下图中的边*h*），而其他两边（*a*和*b*）称为腿。它们也被称为相对于各自角的*对边*和*邻边*。例如，边*b*是相邻于下图中的右下角的（角 CAB 或*θ*），而当我们提到顶角（角 CBA）时，它是对边：

![图 5.8：直角三角形](img/B15968_05_08.jpg)

图 5.8：直角三角形

最常见的三角函数是通过前面的图表定义的，并且定义如下：

![图 5.9：三角函数](img/B15968_05_09.jpg)

图 5.9：三角函数

对于正切函数，也成立 *tanθ = sinθ/cosθ*。

此外，对于任何角度θ，以下恒等式始终成立：*sinθ*2 *+ cosθ*2 *= 1*。

根据构造，三角函数是周期性的。这意味着，无论三角形的边的大小如何，前述函数都会在每 2π重复一次。这将在下一个练习中变得明显，我们将在其中绘制它们。正弦和余弦函数的范围是区间[-1,1]。这意味着它们可以获得的最小值是-1，最大值是 1，无论输入θ是什么。

最后但并非最不重要的，直角三角形的边是通过著名的毕达哥拉斯定理连接的：*h*2 *= a*2 *+ b*2

在 Python 代码中，毕达哥拉斯定理的一个简单实现是编写一个函数，利用`math`模块的平方根（`sqrt`）方法，计算*h*，给定*a*和*b*；例如：

```py
from math import sqrt
def hypotenuse(a,b):
    h = sqrt(a**2 + b**2)
    return h
```

对*a=3*和*b=4*调用此函数会给我们以下结果：

```py
hypotenuse(a = 3, b = 4)
```

输出如下：

```py
5.0
```

现在，让我们看一些具体的例子，以便我们能够掌握这些想法。

## 练习 5.04：绘制直角三角形

在这个练习中，我们将编写 Python 函数，用于绘制给定点*p*1 和*p*2*的直角三角形。直角三角形将对应于三角形腿的端点。我们还将计算非直角的三角函数。让我们绘制基本的三角函数：

1.  导入`numpy`和`pyplot`库：

```py
    import numpy as np
    from matplotlib import pyplot as plt
    ```

现在，编写一个函数，当给定两边*p*1 和*p*2 时，使用毕达哥拉斯定理返回斜边：

```py
    def find_hypotenuse(p1, p2):
        p3 = round( (p1**2 + p2**2)**0.5, 8)
        return p3
    ```

1.  现在，让我们编写另一个函数，实现`sin`、`cos`和`tan`函数的关系。输入是给定角的邻边、对边和斜边的长度，结果是三角函数值的元组：

```py
    def find_trig(adjacent, opposite, hypotenuse):
        '''Returns the tuple (sin, cos, tan)'''
        return opposite/hypotenuse, adjacent/hypotenuse, \
               opposite/adjacent
    ```

1.  现在，编写绘制三角形的函数。为简单起见，将直角放在坐标轴的原点（0,0），第一个输入点沿*x*轴放在（p1,0），第二个输入点沿*y*轴放在（0,p2）：

```py
    def plot_triangle(p1, p2, lw=5):
        x = [0, p1, 0]
        y = [0, 0, p2]
        n = ['0', 'p1', 'p2']
        fig, ax = plt.subplots(figsize=(p1,p2))
        # plot points
        ax.scatter(x, y,  s=400, c="#8C4799", alpha=0.4)
        ax.annotate(find_hypotenuse(p1,p2),(p1/2,p2/2))

        # plot edges
        ax.plot([0, p1], [0, 0], lw=lw, color='r')
        ax.plot([0, 0], [0, p2], lw=lw, color='b')
        ax.plot([0, p1], [p2, 0], lw=lw, color='y')
        for i, txt in enumerate(n):
            ax.annotate(txt, (x[i], y[i]), va='center')
    ```

在这里，我们创建了包含点的列表`x`和`y`，还有一个标签列表`n`。然后，我们创建了一个`pyplot`对象，首先绘制点，然后绘制边。最后两行用于注释我们的绘图；即，在我们的点旁边添加标签（从列表`n`中）。

1.  我们需要选择两个点来定义一个三角形。然后，我们需要调用我们的函数来显示绘图：

```py
    p01 = 4
    p02 = 4
    print(find_trig(p01,p02,find_hypotenuse(p01,p02)))
    plot_triangle(p01,p02)
    ```

第一行打印三角函数`sin`、`cos`和`tan`的值。然后，我们绘制我们的三角形，在这种情况下是等腰三角形，因为它有两条相等长度的边。

输出将如下所示：

![图 5.10：绘制等腰三角形](img/B15968_05_10.jpg)

图 5.10：绘制等腰三角形

结果是预期的和正确的——在四舍五入误差后——因为这种特定形状的几何形状很简单（一个等腰直角三角形，两个角相等于π/4）。然后，我们检查了结果（请注意，在 NumPy 中，π的值可以直接调用`np.pi`）。

1.  最后，为了对`sin`和`cos`三角函数有一个总体概述，让我们绘制它们：

```py
    x = np.linspace(0, 10, 200)
    sin = np.sin(x)
    cos = np.cos(x)
    plt.xticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi, \
                5*np.pi/2, 3*np.pi], \
               ['0','','\u03C0','','2\u03C0','','3\u03C0'])
    plt.plot(x, sin, marker='o', label='sin')
    plt.plot(x, cos, marker='x', label='cos')
    plt.legend(loc="upper left")
    plt.ylim(-1.1, 1.6)
    plt.show()
    ```

输出将如下所示：

![图 5.11：正弦和余弦三角函数的绘图](img/B15968_05_11.jpg)

图 5.11：正弦和余弦三角函数的绘图

在这个练习中，我们启动了对三角学领域的探索，并看到如何在 Python 中得到有用的可视化。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2Zz0TnU`](https://packt.live/2Zz0TnU)

您也可以在[`packt.live/2AoxS63`](https://packt.live/2AoxS63)上在线运行此示例

有了这个，我们已经建立了主要的三角函数，并看到它们如何在角度和相关的三角函数值之间提供操作，由 sin、cos 或 tan 函数给出。此外，我们看到这三个函数是周期性的，即每 2π重复一次，而前两个是有界的，即它们可以取的值永远不会超出区间[-1,1]。这些值可以直接在 Python 或科学口袋计算器中找到。然而，在许多情况下，需要进行反向过程：如果我给出 sin、cos 或 tan 的值，我能找到角度吗？这样的函数存在吗？我们将在下一节中回答这些问题。

## 反三角函数

反三角函数是三角函数的反函数，与它们的对应函数一样有用。反函数是一个*反转*原始函数操作或结果的函数。请记住，三角函数接受角度作为输入值，并输出纯数（比值）。反三角函数则相反：它们接受纯数作为输入，并给出角度作为输出。因此，例如，如果一个点π被映射到点-1（如 cos 函数所做的那样），那么它的反函数需要完全相反。这种映射需要对反函数定义的每个点都成立。

*sin(x)*函数的反函数称为*arcsin(x)*：如果*y=sin(x)*，那么*x=arcsin(y)*。请记住*sin*是一个周期函数，因此许多不同的*x*被映射到相同的*y*。因此，反函数会将一个点映射到几个不同的点。这是不允许的，因为它与函数的定义相冲突。为了避免这个缺点，我们需要限制我们的*arcsin*（以及类似地*arccos*）的定义域为区间[-1,1]，而映射*y=arcsin(x)*和*y=arccos(x)*则限制在范围[-π/2,π/2]和[0, π]。

我们可以定义三个基本的反三角函数如下：

+   *arcsin(x) = y，使得 arcsin(sin(x)) = x*

+   *arccos(x) = y，使得 arccos(cos(x)) = x*

+   *arctan(x) = y，使得 arctan(tan(x)) = x*

在 Python 中，这些函数可以从`math`模块或`numpy`库中调用。由于大多数 Python 实现的三角反函数返回弧度，我们可能希望将结果转换为度数。我们可以通过将弧度乘以 180 然后除以π来实现这一点。

让我们看看这如何在代码中编写。请注意，输入`x`表示为-1 和 1 之间的纯数，而输出表示为弧度。让我们导入所需的库并声明`x`的值：

```py
from math import acos, asin, atan, cos
x = 0.5
```

现在，要打印余弦的反函数，添加以下代码：

```py
print(acos(x))
```

输出如下：

```py
1.0471975511965979
```

要打印正弦的反函数，添加以下代码：

```py
print(asin(x))
```

输出如下：

```py
0.5235987755982989
```

要打印正切的反函数，添加以下代码：

```py
print(atan(x))
```

输出如下：

```py
0.4636476090008061
```

让我们尝试为`acos`函数添加一个超出范围[-1,1]的输入：

```py
x = -1.2
print(acos(x))
```

我们将会得到一个错误，如下所示：

```py
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
```

`asin`也会发生类似的情况。这是可以预料到的，因为不存在任何角度*φ*可以返回`-1.2`作为 cos（或 sin）。然而，这个输入在`atan`函数中是允许的：

```py
x = -1.2
print(atan(x))
```

输出如下：

```py
-0.8760580505981934
```

最后，让我们来看看反函数`arccos(cos(x))`的反函数给我们带来了什么：

```py
print(acos(cos(0.2)))
```

输出如下：

```py
0.2
```

正如预期的那样，我们检索到`cos`函数的输入值。

反三角函数在数学、物理和工程学中有各种应用。例如，可以使用反三角函数来计算积分。不定积分如下：

![图 5.12：反三角函数](img/B15968_05_12.jpg)

图 5.12：反三角函数

在这里，*a*是一个参数，*C*是一个常数，积分立即可以通过反三角函数得到解决。

## 练习 5.05：使用反三角函数找到通往宝藏的最短路径

在这个练习中，您将获得一张指向**B**的秘密地图，几个世纪以来一些宝贵的宝藏一直在那里。您在点**A**，指令很明确：您必须向南导航 20 公里，然后向西导航 33 公里，以便到达宝藏。然而，直线段**AB**是最短的。您需要找到地图上的角度**θ**，以便您的导航正确定位：

![图 5.13：点 A、B 和 C 的图形表示](img/B15968_05_13.jpg)

图 5.13：点 A、B 和 C 的图形表示

我们需要找到角**θ**，即线段**AB**和**AC**之间的角度。按照以下步骤进行：

1.  导入`atan`（arctan 或反正切）函数：

```py
    from math import atan, pi
    ```

1.  使用`BC`和`AC`找到*θ*的正切：

```py
    AC = 33
    BC = 20
    tan_th = BC/AC
    print(tan_th)
    ```

输出如下：

```py
    0.6060606060606061
    ```

1.  然后，通过取反正切函数来找到角度。其参数是*θ*的正切：

```py
    theta = atan(tan_th)
    ```

1.  将其转换为度并打印出值：

```py
    theta_degrees = theta*180/pi
    print(theta_degrees)
    ```

输出如下：

```py
    31.218402764346372
    ```

因此，答案是我们需要转动 31.22 度才能正确导航。

1.  作为奖励分，计算我们将沿着路径`AB`行进的距离。这只是由勾股定理给出的：

*AB*2 *= AC*2 *+ BC*2

在 Python 中，使用以下代码：

```py
    AB = (AC**2 + BC**2)**0.5
    print(AB)
    ```

输出如下：

```py
    38.58756276314948
    ```

课程将是 38.59 公里。

在 Python 中通过调用`find_hypotenuse()`函数很容易计算。正如预期的那样，这比路径*AC + BC = 53*公里要短得多。

注意

要访问此特定部分的源代码，请参考[`packt.live/31CF4qr。`](https://packt.live/31CF4qr )

您还可以在[`packt.live/38jfVlI`](https://packt.live/38jfVlI )上在线运行此示例。

## 练习 5.06：找到与对象的最佳距离

您正在参观当地的竞技场观看您最喜欢的节目，您站在竞技场的中间。除了主舞台外，还有一个观看屏幕，这样人们就可以观看并不会错过节目的细节。屏幕底部距离您的眼睛高 3 米，屏幕本身高 7 米。视野角是通过观看屏幕的底部和顶部形成的。找到最佳距离*x*，使视野角最大化：

![图 5.14：眼睛和屏幕之间形成的视野角](img/B15968_05_14.jpg)

图 5.14：眼睛和屏幕之间形成的视野角

这是一个稍微复杂的问题，需要一些代数，但我们将把它分解成简单的步骤并解释逻辑。首先注意问题的情节如何引导我们并帮助我们找到解决方案。这个明显复杂的现实世界问题转化为一个更抽象和简单的几何图像。按照以下步骤完成此练习：

1.  计算*x*。这是三角形的底边，也是角*θ*1（也是*θ=θ*1*+θ*2）的邻边。答案*x*将由观看角*θ*2 或等效地，*tan(θ*2*)*最大化的条件给出。从*屏幕*的前述图中，我们可以立即得出三个角度的以下关系：*θ*1（内角）、*θ*2（外角）和*θ=θ*1*+θ*2：

*tan(θ*1*) = 对边/邻边 = 3/x*

*tan(θ) = tan(θ*1*+θ*2*) = 对边/邻边 = (7+3)/x .*

现在，使用代数来处理这两个关系，并得到*θ*2 的条件。

1.  两个角的正切和的已知身份如下：![图 5.15：两个角的正切的公式](img/B15968_05_15.jpg)

图 5.15：两个角的正切的公式

通过在后一个关系中代入我们找到的*tan(θ)*和*tan(θ*1*)*，并经过代数运算，我们得到以下结果：

*tan(θ*2*) = 7x/(30+x*2*) 或*

*θ*2 *= arctan(7x/(30+x*2*)).*

换句话说，我们已经结合了问题的要素，并发现角度*θ*1 应该随着距离*x*的变化而变化，这是前一行给出的函数*x*的函数。

1.  让我们绘制这个函数，看看它是如何变化的。首先，加载必要的库：

```py
    from matplotlib import pyplot as plt
    import numpy as np
    ```

1.  然后，通过使用`numpy`的`arctan`方法，通过定义域`x`和值`y`来绘制函数。这些可以使用`pyplot`的`plot()`方法轻松绘制，如下所示：

```py
    x = np.linspace(0.1, 50, 2000)
    y = np.arctan(7*x / (30+x**2) )
    plt.plot(x,y)
    plt.show()
    ```

输出将如下所示：

![图 5.16：使用 arctan 方法绘制函数的图形](img/B15968_05_16.jpg)

图 5.16：使用 arctan 方法绘制函数的图形

从前面的图表中，我们可以看到函数获得了最大值。

1.  确定函数的最大值`y`和位置`x`，以及发生这种情况的位置：

```py
    ymax = max(y)
    xmax = x[list(y).index(ymax)]
    print(round(xmax,2), round(ymax,2))
    ```

输出如下：

```py
    5.47 0.57
    ```

1.  最后，将找到的角度转换为度数：

```py
    ymax_degrees = round(ymax * 180 / np.pi, 2)
    print(ymax_degrees)
    ```

输出如下：

```py
    32.58
    ```

因此，观察角度*θ*2 在 32.58 度时达到最大值，并且当我们站在距屏幕 5.47 米的地方时发生。我们使用三角函数和反三角函数，在 Python 中实现它们，并找到了一个来自现实生活中*几何*设置的问题的答案。这更加清楚地说明了几何和三角学概念如何被有用地和轻松地编码以提供预期的结果。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2VB3Oez`](https://packt.live/2VB3Oez)

您也可以在[`packt.live/2VG9x2T`](https://packt.live/2VG9x2T)上在线运行此示例。

现在，我们将继续研究数学中的另一个核心概念，它在代数、物理学、计算机科学和应用数据科学中有着广泛的应用：向量。

# 向量

**向量**是具有大小（大小）和方向（方向）的抽象数学对象。向量由一个箭头表示，它有一个基（尾部）和一个头。箭头的头部显示向量的方向，而箭头的长度显示它的大小。

**标量**与向量相反，是一个单独的数字。它是一个非向量，即一个纯整数、实数或复数（我们稍后会看到），它没有元素，因此没有方向。

向量通常用粗体字母**A**、带箭头的字母或普通字母表示，如果在讨论中关于符号的表示没有歧义。向量**A**的大小被写成*|A|*或简单地写成*A*。现在，让我们来看看各种向量运算。

### 向量运算

简而言之，向量是由两个、三个或更多个数字组成的集合（可以想象成列表或数组），形成一个数学对象。这个对象存在于一个特定的几何空间中，称为向量空间，具有一些属性，如度量属性和维度。向量空间可以是二维的（想象一下你的书页上的平面），三维的（我们周围的普通欧几里德空间），或者在数学和物理学中的许多抽象情况下更高维度的。用于识别向量的元素或数字等于空间的维度。现在我们已经定义了一个向量空间——向量的游乐场——我们可以用一组坐标轴（通常的*x*、*y*和*z*轴）来装备它，标记原点并测量空间。在这样一个明确定义的空间中，我们需要确定一组数字（两个、三个或更多）来唯一定义一个向量，因为向量被假定从坐标轴的原点开始。向量的元素可以是整数、有理数、实数或（很少）复数。在 Python 中，它们通常由列表或 NumPy 数组表示。

与实数类似，向量上定义了一组线性运算。在两个向量 A = (a1, a2, a3)和 B = (b1, b2, b3)之间，我们可以定义以下内容：

![图 5.17：点 A、B 和 C 及它们在执行向量运算时的关系](img/B15968_05_17.jpg)

图 5.17：执行向量操作时点 A、B 和 C 及其关系

现在让我们看看可以对这些向量执行的各种操作：

+   **加法**作为导致向量*C = A + B = (a*1 *+ b*1*, a*2 *+ b*2*, a*3 *+ b*3*)*的操作。

+   **减法**作为导致向量*C = A - B = (a*1 *- b*1*, a*2 *- b*2*, a*3 *- b*3*)*的操作。

+   *点积*（或内积或标量）*C = b. b = a*1 *b*1 *+ a*2 *b*2 *+ a*3 *b*3。

+   向量*C = A x B*的**叉积**（或外积），它垂直于由*A*和*B*定义的平面，并具有元素（*a*2*b*3 *- a*3*b*2*, a*3*b*1 *- a*1*b*3*, a*1*b*2 *– a*2*b*1）。

+   向量*A*和*B*的**逐元素**或 Hadamard *乘积*是向量*C*，其元素是*A*和*B*的元素的成对乘积；即*C = (a*1 *b*1*, a*2 *b*2*, a*3 *b*3)*。

我们可以在 Python 代码中定义并使用前述公式如下：

```py
import numpy as np
A = np.array([1,2,3]) # create vector A
B = np.array([4,5,6]) # create vector B
```

然后，要找到`A`和`B`的和，输入以下代码：

```py
A + B
```

输出如下：

```py
array([5, 7, 9])
```

要计算差异，输入以下代码：

```py
A - B
```

输出如下：

```py
array([-3, -3, -3])
```

要找到逐元素乘积，输入以下代码：

```py
A*B
```

输出如下：

```py
array([ 4, 10, 18])
```

要找到点积，使用以下代码：

```py
A.dot(B)
```

输出如下：

```py
32
```

最后，叉积可以计算如下：

```py
np.cross(A,B)
```

输出如下：

```py
array([-3,  6, -3])
```

请注意，向量加法、减法和点积是可结合和可交换的操作，而叉积是可结合但不可交换的。换句话说，a x b 不等于 b x a，而是 b x a，这就是为什么它被称为**反交换**。

此外，向量*A*可以乘以标量*λ*。在这种情况下，您只需将每个向量元素乘以相同的数字，即标量：*λ A = λ (a*1*, a*2*, a*3*) = (λ a*1*, λ a*2*, λ a*3)

向量之间的另一个重要操作是点积，因为它可以说是数学、计算机科学及其应用中最常见的操作。点积是一种有趣的操作，它在实数领域中没有类似物。实际上，它需要两个向量作为输入，以产生单个标量作为输出。这意味着操作的结果（标量）与其成分（向量）的类型不同，因此通常不存在逆操作（*点除法*）。

根据定义，它如下所示：

![图 5.18：θ角的图形表示*](img/B15968_05_18.jpg)

图 5.18：θ角的图形表示

这可以用以下方程表示：

*A.B = |A| |B| cos(θ)*

这里，*θ*是向量*A*和*B*之间的角度。

让我们看一些典型的情况：

+   如果*A*和*B*是正交的，则点积消失：

如果且仅当*θ = angle(A,B) = π/2*时，*A.B = 0*，因为*|A|*和*|B|*不为零。

+   如果*A*和*B*共线且共方向，则*θ = 0*，*cos(θ)=1*和*A.B = |A| |B|*。如果它们共线且方向相反，则*θ = π*，*cos(θ)=-1*，*A.B = -|A| |B|*。

+   它遵循对向量与自身的点积的定义：*A.A = |A| |A|或|A| = √(A.A)*

+   它直接遵循*A.B = |A| |B| cos(θ)*，其中两个向量之间的角度如下给出：*θ = arccos(A.B / |A| |B|)*

这里，*arccos*是我们在前一节中看到的反余弦函数。

例如，我们可以编写一个 Python 程序，利用`numpy`和前面给出的关系计算任意两个给定向量之间的角度*θ*：

```py
import numpy as np
from math import acos
A = np.array([2,10,0])
B = np.array([9,1,-1])
```

要找到每个向量的范数（大小），我们可以使用以下代码：

```py
Amagn = np.sqrt(A.dot(A))
Bmagn = np.sqrt(B.dot(B))
```

作为替代方案，您还可以使用以下代码：

```py
Amagn = np.linalg.norm(A)
Bmagn = np.linalg.norm(B)
```

打印它们的值：

```py
print(Amagn, Bmagn)
```

您将得到以下输出：

```py
10.198039027185569
9.1104335791443
```

这两种替代方案都会导致相同的结果，您可以通过再次打印`Amagn`和`Bmagn`来立即检查。

最后，我们可以按如下方式找到角度*θ*：

```py
theta = acos(A.dot(B) / (Amagn * Bmagn))
print(theta)
```

输出如下：

```py
1.2646655256233297
```

现在，让我们看一个练习，我们将执行刚学到的各种向量运算。

## 练习 5.07：可视化向量

在这个练习中，我们将编写一个在二维空间中绘制两个向量的函数。我们将不得不找到它们的和以及它们之间的角度。

执行以下步骤完成这个练习：

1.  导入必要的库，即`numpy`和`matplotlib`：

```py
    import numpy as np
    import matplotlib.pyplot as plt
    ```

1.  创建一个函数，接受两个向量作为输入，每个向量作为一个列表，绘制它们，并可选择绘制它们的和向量：

```py
    def plot_vectors(vec1, vec2, isSum = False):

        label1 = "A"; label2 = "B"; label3 = "A+B"
        orig = [0.0, 0.0]  # position of origin of axes
    ```

`vec1`和`vec2`列表中分别包含两个实数。每对数字表示相应向量的端点（头部）坐标，而原点设置为（0,0）。标签设置为`"A"`、`"B"`和`"A+B"`，但您可以更改它们，甚至将它们设置为`plot_vectors`函数的变量（或不带）默认值。布尔变量`isSum`默认设置为`False`，和`vec1+vec2`将不会被绘制，除非显式设置为`True`。

1.  接下来，我们将坐标放在一个`matplotlib.pyplot`对象上：

```py
        ax = plt.axes()
        ax.annotate(label1, [vec1[0]+0.5,vec1[1]+0.5] )   
        # shift position of label for better visibility
        ax.annotate(label2, [vec2[0]+0.5,vec2[1]+0.5] )
        if isSum: 
            vec3 = [vec1[0]+vec2[0], vec1[1]+vec2[1]]     
            # if isSum=True calculate the sum of the two vectors
            ax.annotate(label3, [vec3[0]+0.5,vec3[1]+0.5] )

        ax.arrow(*orig, *vec1, head_width=0.4, head_length=0.65)
        ax.arrow(*orig, *vec2, head_width=0.4, head_length=0.65, \
                 ec='blue')
        if isSum:
            ax.arrow(*orig, *vec3, head_width=0.2, \
                     head_length=0.25, ec='yellow')
            # plot the vector sum as well

        plt.grid()
        e=3 
        # shift limits by e for better visibility
        plt.xlim(min(vec1[0],vec2[0],0)-e, max(vec1[0],\
                     vec2[0],0)+e) 
        # set plot limits to the min/max of coordinates
        plt.ylim(min(vec1[1],vec2[1],0)-e, max(vec1[1],\
                     vec2[1],0)+e) 
        # so that all vectors are inside the plot area
    ```

在这里，我们使用 annotate 方法向我们的向量添加标签，以及 arrow 方法来创建我们的向量。星号运算符`*`用于解包列表`orig`和`vec1`、`vec2`中的参数，以便它们可以从`arrow()`方法中正确读取。`plt.grid()`在绘图的背景上创建一个网格，以引导眼睛，这是可选的。添加`e`参数是为了使绘图限制足够宽，绘图可读。

1.  接下来，给我们的图表加上标题并绘制它：

```py
        plt.title('Vector sum',fontsize=14)
        plt.show()
        plt.close()
    ```

1.  现在，我们将编写一个函数，计算两个输入向量之间的角度，如前所述，借助点（内）积：

```py
    def find_angle(vec1, vec2, isRadians = True, isSum = False):
        vec1 = np.array(vec1)
        vec2 = np.array(vec2)

        product12 = np.dot(vec1,vec2)
        cos_theta = product12/(np.dot(vec1,vec1)**0.5 * \
                               np.dot(vec2,vec2)**0.5 )
        cos_theta = round(cos_theta, 12)
        theta = np.arccos(cos_theta)

        plot_vectors(vec1, vec2, isSum=isSum)
        if isRadians:
            return theta
        else:
            return 180*theta/np.pi
    ```

首先，我们将我们的输入列表映射到`numpy`数组，以便我们可以使用这个模块的方法。我们计算点积（命名为`product12`），然后将其除以`vec1`的大小与`vec2`的大小的乘积。回想一下，向量的大小由其与自身的点积的平方根（或`**0.5`）给出。根据点积的定义，我们知道这个数量是两个向量之间角度的余弦。最后，在四舍五入余弦以避免输入错误后，利用`numpy`的`arccos`方法计算角度。

1.  我们希望将我们编写的两个函数`find_angle`和`plot_vectors`结合起来，并在后者内部调用前者。我们还希望给用户选择以弧度（`isRadians=True`）或度数（`isRadians=False`）打印角度结果的选项。现在我们准备尝试我们的函数。首先，让我们尝试使用两个垂直向量：

```py
    ve1 = [1,5]
    ve2 = [5,-1]
    find_angle(ve1, ve2, isRadians = False, isSum = True)
    ```

输出如下：

![图 5.19：两个垂直向量的绘图](img/B15968_05_19.jpg)

图 5.19：两个垂直向量的绘图

图看起来不错，结果是 90 度，如预期。

1.  现在，让我们尝试使用相同的函数创建两个共线向量：

```py
    ve1 = [1,5]
    ve2 = [0.5,2.5]
    find_angle(ve1, ve2, isRadians = False, isSum = True)
    ```

输出如下：

![图 5.20：两个共线向量的绘图](img/B15968_05_20.jpg)

图 5.20：两个共线向量的绘图

输出为 0 度，如预期。

1.  最后，再次使用相同的函数，让我们创建两个通用向量：

```py
    ve1 = [1,5]
    ve2 = [-3,-5]
    find_angle(ve1, ve2, isRadians = False, isSum = True)
    ```

输出如下：

![图 5.21：两个通用向量的绘图](img/B15968_05_21.jpg)

图 5.21：两个通用向量的绘图

总之，我们已经学习了向量作为生活在向量空间中的数学对象。我们学会了如何在 Python 中构造和表示向量以及如何可视化它们。向量遵循一些简单的规则，并且可以进行操作。在处理实数时，加法和减法遵循完全相同的逻辑。乘法有些更复杂，并且定义了不同类型的乘积。最常见的乘积是内积或点积，由于其简单的几何表示，在数学和物理界广受欢迎。我们学会了如何在 Python 中计算任意两个向量的点积，并且利用我们对点积的知识（以及一些 NumPy 方法）找到了这对向量之间的角度。简而言之，在二维空间中，向量是一对形成有趣属性的数字。

注意

要访问此特定部分的源代码，请参阅[`packt.live/2Zxu7n5.`](https://packt.live/2Zxu7n5 )

您还可以在[`packt.live/2YPntJQ.`](https://packt.live/2YPntJQ )上在线运行此示例

接下来，我们将学习如何将一对两个数字组合成一个更令人兴奋的对象，即复数。

# 复数

自古代数字系统以来，数学思想一直在发展，关于数字及其关系的数学思想也在历史上从具体到抽象不断演变。例如，自然数集合的概念是为了让我们周围世界中的所有物体直接对应于该集合中的某个数字。随着算术和代数的发展，人们意识到除了自然数或整数之外，还需要小数和有理数，因此引入了小数和有理数。同样，在毕达哥拉斯时代，人们发现有理数无法解决我们当时所知的几何构造的所有数学问题。这是因为引入了无理数——从其他数字的平方根得出并且没有比率表示的数字。

复数是实数的扩展，并包括一些特殊的数字，可以解决一些实数无法解决的方程。

这样的数字实际上是存在的，并且有符号*i*。它被称为虚数或虚数单位，尽管它并不虚构；它和我们见过的所有其他数字一样真实，并且正如我们将看到的那样，具有一些非常美丽的性质。

## 复数的基本定义

我们将虚数*i*定义如下：

*i*2 *= -1*

任何由实数和虚数（部分）组成的数字都称为**复数**。例如，考虑以下数字：

*z = 3 – i*

*z = 14/11 + i 3*

*z = -√5 – i 2.1*

所有前述的数字都是复数。它们的实部表示为*Re(z)*，虚部表示为*Im(z)*。对于前述的例子，我们得到以下结果：

*Re(z) = 3 , Im(z) = -1*

*Re(z) = 14/11 , Im(z) = 3*

*Re(z) = -√5 , Im(z) = -2.1*

让我们看一些使用代码的例子。在 Python 中，虚数单位用字母*j*表示，复数写成如下形式：

```py
c = <real> + <imag>*1j,
```

这里，`<real>`和`<imag>`都是实数。同样，复数可以定义如下：

```py
c = complex(<real>, <imag>).
```

在代码中，它变成了如下形式：

```py
a = 1
b = -3
z = complex(a, b)
print(z)
```

输出如下：

```py
(1-3j)
```

我们还可以使用`real`和`imag`函数来分离任何复数`z`的实部和虚部。首先，让我们使用`real`函数：

```py
print(z.real)
```

输出如下：

```py
1.0
```

现在，使用`imag`函数：

```py
print(z.imag)
```

输出如下：

```py
-3.0
```

换句话说，任何复数都可以被分解并写成*z=Re(z) + i Im(z)*。因此，一个复数是两个实数的一对，并且可以被视为生活在二维空间中的向量。因此，向量的几何和代数，如前一节所讨论的，也可以在这里应用。

接受复数作为输入的方法和函数可以在`cmath`模块中找到。该模块包含复数的数学函数。那里的函数接受整数、浮点数或复数作为输入参数。

*复共轭*被定义为与复数*z*具有相同实部和相反虚部的复数*z**（也*z̄*）；也就是说，如果*z = x+iy*，那么*z* = x -iy*。注意，乘积*zz**是实数*x*2*+y*2，这给出了*z*的模的平方：

*zz* = z*z = |z|*2

复数被绘制在复平面上，类似于向量（如下图所示）。这是由实部在*x*轴上和虚部在*y*轴上形成的平面。复共轭只是相对于实轴的向量的反射：

![图 5.22：复数的绘图](img/B15968_05_22.jpg)

图 5.22：复数的绘图

复数*z*可以被视为具有坐标(x, y)的向量。或者，我们可以将其写成具有极坐标(r, φ)的向量。复共轭*z**或*z̄*是一个与*z*相同的向量，但相对于*x*轴反射。

如果一个复数的实部和虚部都是零，那么这个复数就是零。可以对两个复数*z = x+iy*和*w = u+iv*执行以下操作：

+   **加法**：*z+w = (x+u) + i(y+v)*

+   **减法**：*z-w = (x-u) + i(y-v)*

+   **乘法**：*z w = (x+iy)(u+iv) = (xu-yv) + i(xv + yu)*

+   **除法**：*z/w = (x+iy)/(u+iv) = (ux+vy)+i(uy-xv) / (u2+v2)*

## 极坐标表示和欧拉公式

复数很容易被视为复平面上的向量。因此，它有一个大小，由向量的大小确定，以及一个方向，由与*x*（实）轴形成的角度*φ*确定。要确定这两个数，我们需要找到*z=x+iy*的绝对值（或模），*r*：

*r = |z| = √x*2*+y*2

它的角度（也称为参数*arg*或*相位*），*φ*，如下：

*φ = arg(z) = arctan(x+iy) = arctan(y/x)*

这两个关系都源自复向量的几何关系。第一个关系简单地是勾股定理的应用，而第二个来自对角度*φ*应用正切关系。

通过检查向量的图形表示（见前面的图），我们可以看到以下内容：

*cos(φ) = x/r 和*

*sin(φ) = y/r*

或

*x = r cos(φ) 和*

*y = r sin(φ)*

通过用*z = x+iy*替换这些，我们得到以下结果：

*z = r (cos(φ) + i sin(φ))*

我们可以在 Python 中编写一些代码，一旦给定了(*x*, *y*)(笛卡尔坐标)，就可以找到(*r*, *φ*)(极坐标)，反之亦然：

```py
def find_polar(z):
    from math import asin
    x = z.real
    y = z.imag
    r = (x**2 + y**2)**0.5
    phi = asin(y/r)
    return r, phi
find_polar(1-3j)
```

输出如下：

```py
(3.1622776601683795, -1.2490457723982544)
```

同样，我们可以使用`cmath`模块中的`polar`方法：

```py
import cmath
z = 1-3j
cmath.polar(z)
```

输出如下：

```py
(3.1622776601683795, -1.2490457723982544)
```

注意

不允许输入(0,0)，因为这会导致除以零。

因此，复数可以用它的模，*r*，和相位，*φ*，来表示，而不是用它的横坐标（*x*，实部）和纵坐标（*y*，虚部）。模，*r*，是一个实数，非负数，相位，*φ*，在区间[-π,π]内：对于纯实数，它是*0*和*π*，对于纯虚数，它是*π/2*或*-π/2*。后者的表示被称为极坐标，而前者被称为矩形或笛卡尔；它们是等价的。也可以用以下表示：

*z = r e*iφ *= r (cos(φ) + i sin(φ))*

这是自然对数的底。这被称为欧拉公式。特殊情况*φ=π*给出了以下结果：

*e*iπ *+ 1 = 0*

这就是欧拉恒等式。

使用欧拉公式的好处在于，复数乘法和除法获得了简单的几何表示。要乘（除）两个复数*z*1 和*z*2，我们只需将它们各自的模相乘（除）并加上（减去）它们的幅角：

*z*1 ** z*2 *= r e*iφ *= r*1 ** r*2 *e*i(φ1+φ2)

现在，让我们在 Python 中使用一些复数进行数学运算。我们将编写两个复数的加法、减法、乘法和除法：

```py
def complex_operations2(c1, c2):
    print('Addition =', c1 + c2)
    print('Subtraction =', c1 - c2)
    print('Multiplication =', c1 * c2)
    print('Division =', c1 / c2)
```

现在，让我们尝试这些函数对一对通用的复数*c1=10+2j/3*和*c2=2.9+1j/3*：

```py
complex_operations2(10+2j/3, 2.9+1j/3)
```

输出如下：

```py
Addition = (12.9+1j)
Subtraction = (7.1+0.3333333333333333j)
Multiplication = (28.77777777777778+5.266666666666666j)
Division = (3.429391054896336-0.16429782240187768j)
```

我们可以对纯实数和纯虚数做同样的操作：

```py
complex_operations2(1, 1j)
```

输出如下：

```py
Addition = (1+1j)
Subtraction = (1-1j)
Multiplication = 1j
Division = -1j
```

从最后一行，我们很容易看出*1/i = -i*，这与虚数单位的定义一致。`cmath`库还为复数提供了有用的函数，如`phase`和`polar`，以及带有复数参数的三角函数：

```py
import cmath
def complex_operations1(c):
    modulus = abs(c)
    phase = cmath.phase(c)
    polar = cmath.polar(c)
    print('Modulus =', modulus)
    print('Phase =', phase)
    print('Polar Coordinates =', polar)
    print('Conjugate =',c.conjugate())
    print('Rectangular Coordinates =', \
           cmath.rect(modulus, phase))
complex_operations1(3+4j)
```

输出如下：

```py
Modulus = 5.0
Phase = 0.9272952180016122
Polar Coordinates = (5.0, 0.9272952180016122)
Conjugate = (3-4j)
Rectangular Coordinates = (3.0000000000000004+3.9999999999999996j)
```

因此，计算给定复数的模、相位或共轭变得非常简单。请注意，最后一行给出了复数的直角（或笛卡尔）形式，给定其模和相位。

现在我们已经了解了复数的算术和表示方式，让我们继续看一个涉及逻辑的练习，并结合我们在前几节中使用和学习的内容。

## 练习 5.08：复数的条件乘法

在这个练习中，您将编写一个函数，该函数读取一个复数`c`，如果复数的幅角大于零，则将其乘以自身，如果幅角小于零，则取`c`的平方根，如果幅角等于零，则不执行任何操作。绘制并讨论您的发现：

1.  导入必要的库，并且可以选择地抑制任何警告（这不是必需的，但如果您希望保持输出整洁，这是有帮助的，因为警告取决于您使用的库的版本）：

```py
    import cmath
    from matplotlib import pyplot as plt
    import warnings
    warnings.filterwarnings("ignore")
    ```

1.  现在，定义一个函数，该函数使用 Matplotlib 的`pyplot`函数来绘制输入复数`c`的向量：

```py
    def plot_complex(c, color='b', label=None):

        ax = plt.axes()
        ax.arrow(0, 0, c.real, c.imag, head_width=0.2, \
                 head_length=0.3, color=color)
        ax.annotate(label, xy=(0.6*c.real, 1.15*c.imag))
        plt.xlim(-3,3)
        plt.ylim(-3,3)
        plt.grid(b=True, which='major') #<-- plot grid lines
    ```

1.  现在，创建一个函数，读取输入复数`c`，通过调用之前定义的函数绘制它，然后根据输入的相位研究不同的情况。绘制操作前后的相位以及结果，以便将结果向量与输入向量进行比较：

```py
    def mult_complex(c, label1='old', label2='new'):

        phase = cmath.phase(c)
        plot_complex(c, label=label1)

        if phase == 0:
            result = -1
        elif phase < 0:
            print('old phase:', phase)
            result = cmath.sqrt(c)
            print('new phase:', cmath.phase(result))
            plot_complex(result, 'red', label=label2)
        elif phase > 0:
            print('old phase:', phase)
            result = c*c
            print('new phase:', cmath.phase(result))
            plot_complex(result, 'red', label=label2)
        return result
    ```

请注意，对于负相位，我们取`c`的平方根（使用`math.sqrt()`方法），而对于正相位，我们取`c`的平方。

1.  现在，转换一个位于复平面上半部的数字：

```py
    mult_complex(1 + 1.2j)
    ```

输出如下：

![图 5.23：位于复平面上半部的数字的绘图](img/B15968_05_23.jpg)

图 5.23：位于复平面上半部的数字的绘图

这里，一个具有正幅角*φ*（蓝色向量）的复数正在被转换（或映射）为一个具有更大模的新复数（红色向量），并且新的幅角是先前值的两倍。这是预期的：记住欧拉公式*c=r e*iφ的极坐标表示？很明显，平方*c*2 是一个具有原始幅角*φ*和模*r*2 两倍的数字。

1.  接下来，转换一个位于复平面下半部的数字：

```py
    mult_complex(1-1.2j)
    ```

输出如下：

![图 5.24：位于复平面下半部的数字的绘图](img/B15968_05_24.jpg)

图 5.24：位于复平面下半部的数字的绘图

在这种情况下，计算了平方根。与第一个例子类似，新转换的向量的模是原始向量的模的平方根，幅角是原始幅角的一半。

注意

有趣的事实：在两种情况下，向量都是逆时针旋转的。

1.  编写一个`while`迭代，调用`mult_complex()`函数*n*次，以检查如果我们保持向量旋转会发生什么：

```py
    c0 = 1+1.2j
    n = 0
    while n < 6:
        c0 = mult_complex(c0, None, str(n))
        n+=1
    ```

输出如下：

![图 5.25：旋转向量的绘图](img/B15968_05_25.jpg)

图 5.25：旋转向量的绘图

通过这样，我们看到了向量和向量代数如何用于可视化几何运算。特别是，除法和乘法复数的结果是获得几何表示，这在处理大量数据和可视化时非常有用。

注意

要访问此特定部分的源代码，请参阅[`packt.live/31yU8W1`](https://packt.live/31yU8W1)。

您也可以在[`packt.live/2BXWJOw`](https://packt.live/2BXWJOw)上在线运行此示例。

## 活动 5.01：使用级数计算您的退休计划

在许多国家，一些雇主提供退休计划（也称为 401(k)）。这些计划允许您直接从工资中捐款，因此是一种轻松有效的储蓄和投资退休的方式。您的任务是编写一些代码，根据捐款金额和持续时间计算和绘制您的月度回报。

退休计划会像等比数列一样随时间累积。这是一种投资：您每月存钱，以便以后每月收取，带有附加值或利息。计算退休回报的主要*要素*是您当前的余额，每月的捐款，雇主匹配（雇主的捐款），退休年龄，回报率（您从 401(k)投资中预期的平均年回报），预期寿命和任何其他费用。在现实情况下，会引入*上限*：雇主匹配（通常在 50%至 100%之间）不能超过您年薪的 6%。同样，员工的捐款在一年内不能超过一定金额（通常为 18K），无论工资有多高。

执行以下步骤以完成此活动：

1.  确定我们问题的变量。这些将是我们函数的变量。确保仔细阅读活动描述，并*内化*已知和要计算的内容。

1.  识别序列并编写一个函数，计算某一年*n*的退休计划价值。该函数应接受当前余额、年薪、年份*n*等输入，并返回每年的捐款、雇主匹配和退休总价值的元组。

1.  识别级数并编写一个函数，计算*n*年后退休计划的累积价值。当前函数应读取输入，调用前一个函数计算每年计划的价值，并对所有（每年）储蓄进行求和。为了可视化目的，应将捐款（每年）、雇主匹配（每年）和总价值（每年）作为列表返回到一个元组中。

1.  对各种选择的值运行函数，并确保其正常运行。

1.  使用 Matplotlib 绘制结果。

注意

此活动的解决方案可在第 672 页找到。

# 摘要

在本章中，您已经得到了关于序列、级数、三角学、向量和复数等最核心数学概念的一般性和有益的阐述，更重要的是，我们使用具体而简短的例子在 Python 中实现了它们。作为一个现实生活的例子，我们研究了一个退休计划以及我们储蓄随时间的变化。然而，许多其他情况可以模拟成序列或级数，并通过应用向量或复数进行研究。这些概念和方法在物理学、工程学、数据科学等领域被广泛应用。线性代数，即对向量、矩阵和张量的研究，严重依赖于对几何和向量概念的理解，并几乎无处不在地出现在数据科学和神经网络的研究中。另一方面，几何和三角学明确地用于模拟物理运动（例如在视频游戏中）以及地理空间应用中的更高级概念。然而，对这些概念有背景知识使得使用和应用数据科学方法更加具体和可理解。

在下一章中，我们将讨论矩阵以及如何将它们应用于解决现实世界的问题。我们还将研究马尔可夫链，它们用于将与概率、矩阵和极限相关的概念联系在一起。

NDN74

ETB65
