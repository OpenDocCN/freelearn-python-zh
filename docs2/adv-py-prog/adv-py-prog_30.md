# 评估

# 第一章

1.  重要性顺序：功能、正确性和效率。

1.  当检查的条件不满足时，`assert`语句会引发错误。因此，这些语句用于测试中，我们确定程序是否按预期计算并输出值。

1.  基准是一个小但具有代表性的用例，可以用来估计程序的速度。基准可以用来比较程序的不同版本，以查看新实现是否提高了效率。

1.  在 IPython 或 Jupyter 笔记本中，`timeit`魔法命令，当放置在代码片段之前，将会运行该代码多次并记录每次运行的运行时间。命令的输出将显示记录时间的摘要统计，以便我们可以估计我们感兴趣的代码的平均运行时间。

1.  `cProfile`的输出包括以下内容：

    1.  `ncalls`：函数被调用的次数。

    1.  `tottime`：函数中不考虑对其他函数调用的总耗时。

    1.  `cumtime`：函数中的时间，包括其他函数调用。

    1.  `percall`：函数单次调用的耗时，可以通过将总时间或累积时间除以调用次数获得。

    1.  `filename:lineno`：文件名和相应的行号。当调用 C 扩展模块时，此信息不可用。

1.  `dis`模块分析低级字节码并显示 Python 代码是如何转换的。当我们对与特定语句相对应的低级指令数量感兴趣时，这很有帮助。

1.  使用 IPython，我们可以按以下方式分析函数：

    ```py
    In [1]: %load_ext line_profiler
    In [2]: from exercise import close, benchmark
    In [3]: %lprun -f close benchmark()
    Function: close at line 5
    Line #      Hits         Time  Per Hit   % Time  Line 
    Contents
    =========================================================
    =====
         5                                           def 
    close(particles, eps=1e-5):
         6         1          6.0      6.0     66.7      p0, 
    p1 = particles
         7
         8         1          2.0      2.0     22.2      x_
    dist = abs(p0.x - p1.x)
         9         1          1.0      1.0     11.1      y_
    dist = abs(p0.y - p1.y)
        10
        11         1          0.0      0.0      0.0      
    return x_dist < eps and y_dist < eps
    ```

可能令人惊讶的是，`close()`函数的执行时间中有三分之二用于解包和`p0`以及`p1`。

# 第二章

1.  以下每个用例最合适的数据结构如下：

    1.  将项映射到另一组项（集合在最一般的意义上）：字典。

    1.  访问、修改和追加元素：列表。

    1.  维护唯一元素集合：集合。

    1.  跟踪集合（在最一般的意义上）的最小/最大值：堆。

    1.  在序列的端点追加和移除元素（在最一般的意义上）：双端队列。

    1.  根据某些相似性标准进行快速搜索（例如，自动完成引擎所使用）：Trie 树。

1.  缓存是一种设计，我们将昂贵的计算结果存储在临时位置，这可以是内存、磁盘或远程位置。记忆化专门指在应用程序中存储和重用先前函数调用的结果。因此，记忆化是一种缓存形式。

1.  紧凑性和生成器在底层进行了优化，因此它们通常比显式的 for 循环更高效。它们在代码中也更紧凑，更易读。

1.  字典将是一个更合适的数据结构。如果数字表示计数，那么`Counter`数据结构将是使用最佳的数据结构。

# 第三章

1.  NumPy 提供了对多维数组的有效操作，例如创建数组、访问元素（索引）和沿特定轴进行切片，以及优化的数学运算。

1.  使用 pandas，你可以对数据进行“映射”操作，分组、聚合和总结数据。

1.  NumPy 无法处理带标签的数据，而 pandas 无法处理多维数据。`xarray`结合了这两个库的最佳特性，为 API 提供了处理多维、带标签数据的能力。

# 第四章

1.  静态类型允许编译器生成特定类型的优化，使编译后的代码更高效。

1.  内存视图属于 Cython 的接口，这有助于它更容易地与不同的数据类型（如`byte`、`bytearray`或`array.array`）一起工作。具体来说，它提供了一个通用接口，简化了访问存储在这些不同数据类型中的值的流程。

1.  为了分析 Cython，我们可以使用注解视图来识别难以发现的与解释器相关的调用，以及熟悉的`cProfile`工具。

# 第五章

1.  JIT 编译器在运行时而不是在运行代码之前进行编译。这使得预期将多次运行的代码变得更加高效，因为不再需要重新编译。

1.  我们使用`nb.jit`函数的签名来指定函数处理的数据类型，这允许对特定数值数据类型进行进一步优化。当 Numba 遇到其他不受支持的类型时，它简单地将其注册为通用的`pyobject`类型。

1.  追踪 JIT 编译指的是识别程序中最密集的循环、跟踪涉及的运算，并编译相应的优化、无解释器的代码的过程。这允许我们积极优化代码中最不高效的部分。

# 第六章

1.  典型机器学习流程的主要组件是预测模型（模型假设、参数）、损失函数以及模型参数的优化以最小化损失函数。

1.  损失函数可以通过梯度下降来最小化，其中我们计算损失相对于当前模型参数的梯度，并调整这些值以与梯度的反方向。JAX 可以使用`grad`来组合这个梯度损失函数。

1.  在我们的例子中，我们利用核从给定的特征中创建非线性特征。核的朴素实现难以向量化，这可能导致效率低下的循环。JAX 可以自动向量化这些核来解决此问题。

# 第七章

1.  从高层次来看，异步编程旨在避免空闲等待不可用资源。这通常涉及与缓慢且不可预测的资源交互。

1.  回调是一个将在给定的时间后调用的函数。另一方面，未来是一个更方便的抽象，帮助我们跟踪请求的资源及其可用性。与回调相比，未来通常更容易使用。

1.  一个响应式应用应该是响应的、弹性的、有弹性的和消息驱动的。

# 第八章

1.  由于**全局解释器锁**（**GIL**），多线程不可能加快 Python 代码的执行速度。在本章中，我们探讨了不同的多进程方法；也就是说，使用多个进程来运行代码。

1.  使用`Process`接口，我们可以通过继承它来获得更底层的控制。另一方面，`Pool`接口提供了一个方便的方法，通过`apply`和`map`方法在进程间分配任务。

1.  Theano 和 TensorFlow 通过利用特殊操作，如矩阵乘法，自动将我们的代码转换为并行版本。

# 第九章

1.  **HTML**代表**超文本标记语言**，它是开发网页和应用程序的标准和最常用的语言。

1.  通过互联网（更具体地说，是**万维网**（**WWW**））进行的通信的大部分（更具体地说，是**万维网**（**WWW**））都使用 HTTP。在 HTTP 中，请求方法用于传达有关请求的数据以及应从服务器返回的数据的信息。

1.  HTTP 响应状态码是三位数，表示服务器与其客户端之间通信的状态。它们分为五个类别，每个类别指示一个特定的状态。

1.  `requests`模块通过 HTTP 请求管理 Python 程序与 Web 服务器之间的通信。

1.  Ping 测试是一种通常由网络管理员使用的工具，以确保他们的网站对客户端仍然可用。Ping 测试通过向网站发送请求并分析返回的响应状态码来完成此操作。

1.  向一个 Web 服务器发送不同请求的过程以及解析下载的 HTML 源代码的处理是跨不同请求独立的。

1.  在开发执行并发 Web 请求的应用程序时，应考虑以下因素：

    1.  服务条款和数据收集政策

    1.  错误处理

    1.  定期更新你的程序

    1.  避免过度抓取

# 第十章

1.  图像处理是分析和管理数字图像文件的任务，以创建图像的新版本或从中提取重要数据。

1.  数字图像的最小单位是像素，它通常包含一个 RGB 值：一个介于 0 到 255 之间的整数的元组。

1.  灰度化是将图像转换为灰度颜色的处理过程，只考虑每个像素的强度，即可用光量。它通过将传统的三维颜色数据映射到一维灰度数据来减少图像像素矩阵的维度。

1.  阈值化将图像中的每个像素替换为白色像素，如果像素的强度大于先前指定的阈值，如果像素的强度小于该阈值，则替换为黑色像素。在执行图像的阈值化后，该图像的每个像素只能持有两种可能值，显著降低了图像数据复杂性。

1.  当涉及到图像处理时，通常涉及大量的计算密集型处理过程，因为每个图像都是一个整数元组的矩阵。然而，这些过程可以独立执行，这表明整个任务应该被并行化。

1.  并发图像处理的一些良好实践如下：

    1.  选择正确的方法（众多方法中的一种）

    1.  生成适当数量的进程

    1.  并发处理输入/输出

# 第十一章

1.  通信通道用于表示不同系统之间的物理布线连接以及促进计算机网络数据逻辑通信。后者与计算相关，并且更符合异步编程的概念。异步编程可以提供补充高效促进通信通道进程的功能。

1.  媒体层包含相当低级的操作，这些操作与通信通道的底层过程交互，而主机层处理高级数据通信和操作。

1.  传输层通常被视为媒体层和主机层之间的概念过渡。它负责在不同系统之间的端到端连接上发送数据。

1.  在服务器端，`asyncio`模块结合了传输的抽象与异步程序实现的实现。具体来说，通过其`BaseTransport`和`BaseProtocol`类，`asyncio`提供了不同的方式来自定义通信通道的底层架构。

1.  与`aiohttp`模块以及特别地`aiohttp.ClientSession`一起，`asyncio`通过异步发送请求和读取返回的响应，在客户端通信过程中提供了效率和灵活性。

1.  `aiofiles`模块可以与`asyncio`和`aiohttp`一起工作，帮助促进异步的文件读写。

# 第十二章

1.  不同锁对象之间缺乏（或处理不当）的协调可能导致死锁，在这种情况下，无法取得进展，程序被锁定在其当前状态。

1.  在就餐哲学家问题中，由于每位哲学家只用左手拿着一个叉子，他们无法继续进食或放下他们持有的叉子。哲学家唯一能够进食的方式是他们的邻居哲学家放下他们的叉子，而这只有在他们能够进食的情况下才可能；这创造了一个永远无法满足的条件的循环。本质上，这种情况是死锁的本质，其中系统的所有元素都卡在原地，无法取得任何进展。

1.  死锁还定义了并发程序在发生死锁时必须同时满足的必要条件。这些条件最初由计算机科学家爱德华·G·科夫曼（Edward G. Coffman Jr）提出，因此被称为科夫曼条件。这些条件如下：

    1.  至少必须有一个资源处于不可共享状态。这意味着该资源被某个个体进程（或线程）持有，并且不能被其他人访问；在任何给定时间，资源只能被单个进程（或线程）访问和持有。这种条件也被称为互斥。

    1.  存在一个进程（或线程）同时访问一个资源并等待另一个被其他进程（或线程）持有的资源。换句话说，这个进程（或线程）需要访问两个资源来执行其指令，其中一个它已经持有，另一个它正在等待从其他进程（或线程）那里获得。这种条件被称为持有和等待。

    1.  只有在存在特定指令要求进程（或线程）这样做的情况下，资源才能由持有它们的进程（或线程）释放。也就是说，除非进程（或线程）自愿并主动释放资源，否则资源将保持在一个不可共享的状态。这就是不可抢占条件。

    1.  最后一个条件被称为循环等待。正如其名所示，这个条件指定了一个存在一组进程（或线程）的集合，其中集合中的第一个进程（或线程）正在等待第二个进程（或线程）释放一个资源，而第二个进程（或线程）反过来又需要等待第三个进程（或线程）；最后，集合中的最后一个进程（或线程）正在等待第一个进程（或线程）。

1.  如果进程（或线程）要按照预定的、静态的顺序访问资源，而不是任意访问资源，那么它们获取和等待资源的循环性质将被消除。然而，如果你在你的并发程序的资源上放置足够的锁，它的执行将完全变为顺序执行，并且，结合并发编程功能的开销，它的速度甚至比程序的纯顺序版本还要差。

1.  通过忽略锁，我们的程序资源在并发程序的不同进程/线程之间有效地变得可共享，从而消除了四个 Coffman 条件中的第一个：互斥。然而，这样做可以被视为完全误解了问题。我们知道，锁被用来确保进程和线程以系统化、协调的方式访问程序中的共享资源，以避免误操作数据。在并发程序中移除任何锁定机制意味着现在不受访问限制的共享资源被无序操作（因此被破坏）的可能性显著增加。

1.  在活锁情况下，并发程序中的进程（或线程）可以切换它们的状态，但它们只是简单地无限地来回切换，无法取得任何进展。

# 第十三章

1.  饥饿是并发系统中的一个问题，其中进程（或线程）无法获得执行所需的必要资源，这意味着它无法取得任何进展。

1.  大多数情况下，一组协调不良的调度指令是导致饥饿的主要原因。饥饿的一些高级原因可能包括以下内容：

    1.  优先级高的进程（或线程）在 CPU 中的执行流程中占主导地位，因此低优先级的进程（或线程）不允许执行它们的指令。

    1.  优先级高的进程（或线程）会主导对不可共享资源的使用，因此低优先级的进程（或线程）不允许执行它们的指令。这种情况与第一种情况类似，但解决的是访问资源的优先级，而不是执行本身的优先级。

    1.  优先级低的进程（或线程）正在等待资源以执行它们的指令，但一旦资源可用，优先级更高的进程（或线程）会立即获得访问权限，因此低优先级的进程（或线程）会无限期地等待。

1.  死锁情况也可能导致饥饿，因为饥饿的定义指出，如果一个进程（或线程）存在，它无法取得任何进展，因为它无法获得必要的进程，那么该进程（或线程）正在经历饥饿。这一点在哲学家就餐问题中也得到了说明。

1.  读者-写者问题要求一个调度算法，以便读者和写者可以适当地、高效地访问文本文件，而不会误操作/损坏包含的数据。

1.  第一种方法允许多个读者同时访问文本文件，因为读者只是读取文本文件，并不修改其中的数据。第一种方法的问题在于，当一个读者正在访问文本文件而写者正在等待文件解锁时，如果另一个读者开始执行并想要访问文件，它将优先于已经等待的写者。此外，如果越来越多的读者不断请求访问文件，写者将无限期地等待。

1.  此方法实现了以下规范：一旦写者请求访问文件，任何读者都不应该能够跳过队列中的写者并在此之前访问文件。与我们在读者-写者问题的第一个解决方案中看到的情况相反，此解决方案优先考虑写者，因此读者会遭受饥饿。

1.  此方法在读者和写者上都实现了锁。因此，所有线程都将受到锁的常数约束，从而在各个线程之间实现平等优先级。

1.  解决饥饿的一些常见方法包括以下内容：

    1.  提高低优先级线程的优先级。

    1.  实现一个先进先出（FIFO）线程队列。

    1.  实现一个优先队列，同时逐渐提高在队列中等待时间较长的线程的优先级。

    1.  如果一个线程能够多次访问共享资源，则应给予较低的优先级。

# 第十四章

1.  临界区指示在并发应用程序中由多个进程或线程访问的共享资源，这可能导致意外的，甚至错误的行为。

1.  当两个或更多线程/进程同时访问和修改共享资源时，就会发生竞态条件，导致数据被错误处理和损坏。

1.  竞态条件的根本原因是多个线程/进程同时读取和修改共享资源。当所有线程/进程完成它们的执行后，只有最后一个线程/进程的结果被注册。

1.  由于竞态条件发生在多个线程或进程同时访问和写入共享资源时，因此解决方案是隔离不同线程/进程的执行，尤其是在与共享资源交互时。使用锁，我们可以将并发程序中的共享资源转换为临界区，其数据完整性得到保证。

1.  使用锁有几个缺点：在一个并发程序中实现足够的锁，整个程序可能会完全变为顺序执行；锁不会锁定任何东西。

1.  竞态条件在现实生活中的系统和应用程序中引起的问题如下：

    1.  安全性：竞态条件既可以被利用作为安全漏洞（为外部代理提供非法访问系统的权限），也可以用作随机密钥生成，用于安全过程。

    1.  操作系统：当两个代理（用户和应用程序）与相同的内存空间交互时发生的竞态条件可能导致不可预测的行为。

    1.  网络：在网络中，竞态条件可能导致多个用户在网络中获得强大的权限。

# 第十五章

1.  C++ 通过将值写入变量的内存位置来将变量与其值关联起来；Python 的变量通过引用指向它们持有的值的内存位置。因此，Python 需要为其内存空间中的每个值维护一个引用计数。

1.  为了避免竞态条件，从而防止值引用计数被破坏，GIL 被实现为在任何给定时间只能由一个线程访问和修改计数。

1.  GIL 有效地防止了多个线程同时利用 CPU 并执行 CPU 密集型指令。这意味着如果多个线程是 CPU 密集型的并且打算并发执行，它们将按顺序执行。

1.  在你的 Python 应用程序中处理 GIL 有几种方法；即，实现多进程而不是多线程，并利用其他替代的 Python 解释器。

# 第十六章

1.  工厂模式使得跟踪程序中创建的对象变得容易。另一个好处在于代码的分离，即创建对象的代码和对象使用的代码。

1.  工厂模式有两种形式：工厂方法和抽象方法。前者用于处理单个对象的创建，而后者是一组工厂方法。

1.  你应该首先从工厂方法开始，因为它比另一个方法简单。如果你发现自己需要很多工厂方法，那么你应该开始考虑将它们分组到不同的抽象方法中。

# 第十七章

1.  构建器模式有助于管理包含许多需要依次创建的单独组件的对象。该模式还允许你多次重复使用构建过程，因为它将对象的构建与对象本身解耦。

1.  许多应用程序，如 HTML 页面生成器、文档转换器和 UI 表单创建器，都是使用构建器模式实现的。

1.  构建器模式使用一个导演通过多个步骤依次创建一个对象，而工厂模式通过单个步骤创建一个对象。

# 第十八章

1.  原型模式帮助我们通过克隆现有对象（或原型）来创建对象。这可以通过 Python 中的 `copy` 函数轻松实现。

1.  数据库中的对象需要根据应用程序及其用户多次复制。如果没有原型，这可能会是一个昂贵的操作。

1.  单例模式在我们要实现一个只能有一个实例的类时非常有用。例如，当我们想维护 Python 程序的全局状态时，这很有用。

1.  单例模式可用于控制对共享资源的并发访问，从而防止许多基于并发的错误和故障。

# 第二十章

1.  装饰器模式以透明和可读的方式动态指定对象的用法和职责。

1.  Python 有一个内置的装饰器功能，允许程序员扩展函数、方法或类的功能。

1.  使用装饰器模式，我们可以用最少的代码实现记忆化，正如我们在正文中所看到的，这有助于保持斐波那契数计算的快速和代码的可读性。

# 第二十一章

1.  桥接模式在需要在不同对象之间共享实现时非常有用，而无需实现单个专门的类。这通常通过一个抽象类来实现，该抽象类泛化了不同的用例，或者通过单个专门的类本身来实现。

1.  适配器通常用于使两个不兼容的接口兼容，而桥接模式则抽象出不同类的泛化。

1.  我们定义了一个抽象的内容获取器类，从中两个专门的类继承：本地文件获取器和 URL 获取器。

# 第二十二章

1.  外观模式有助于隐藏应用程序的内部实现，仅暴露必要的接口。当我们与大型代码库一起工作，但用户只需要与我们代码的一小部分交互时，这一点尤为重要。

1.  当我们需要对应用程序进行更改时，外观模式提供的抽象有助于保持客户端代码的分离和安全，这在使客户端不受待处理的软件更改的影响时非常有用。

1.  操作系统类作为外观工作，隐藏了客户端代码对不同的服务器类的访问。

# 第二十三章

1.  飞舞模式旨在通过在相似对象之间共享资源来将内存使用量保持在最低，从而最小化内存使用。

1.  MVC 模式通过模型、视图和控制器的组合泛化不同应用程序中的常见结构。这有助于防止后端逻辑与用户界面混合。

1.  代理模式在需要运行必要代码以访问重要对象之前非常有用。

# 第二十四章

1.  责任链模式优雅地处理程序需要处理的未知数量的请求或事件。这在基于事件的逻辑中非常有用，例如购买应用程序和运输系统。

1.  在我们的系统中，如果一个对象不知道如何处理给定的请求，它将请求沿着链传递。正如我们所看到的，`close`事件不能直接由`SendDialog`和`MsgText`处理，而是传递给`MainWindow`。

1.  责任链模式在存在多个请求时可能并不适用，但它们可能由单个对象处理。这使得模式所做的一切记账工作都变得无用。

# 第二十五章

1.  命令模式有助于封装操作逻辑（复制、粘贴、撤销、重做等）在对象中。这导致了对每个操作要采取的逻辑步骤的更好抽象和管理，例如分组多个操作和实现宏。

1.  命令模式抽象出操作的实现，因此任何执行它的客户端代码都不需要了解其实现的细节。

1.  在我们的示例中，我们在`os`模块提供的各种功能之上实现了一个抽象。一个特定功能是其撤销功能。此外，由于命令具有一致的接口，分组可以轻松完成。

# 第二十六章

1.  观察者模式维护一个对目标对象状态感兴趣的对象列表，并在后者发生变化时通知前者。

1.  虽然 MVC 模式可能在模型变化时实现更新视图的相同功能逻辑，但观察者模式在维护和管理特定发布者的订阅者列表方面更为有效，这使得例如添加或删除订阅者变得容易。

1.  我们实现了数据格式化器，以不同的方式显示对象。在这里，我们有多个订阅格式化器，它们对发布默认格式化器感兴趣。当默认格式化器更新时，订阅者会被通知并执行各自的逻辑。
