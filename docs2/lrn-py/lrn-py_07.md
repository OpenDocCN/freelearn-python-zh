# 第七章. 测试、性能分析和处理异常

|   | *"没有测试的代码是有意设计成有缺陷的。" |   |
| --- | --- | --- |
|   | --*雅各布·卡普兰-莫斯* |

雅各布·卡普兰-莫斯是 Django Web 框架的核心开发者之一。我们将在下一章中探讨它。我非常同意他的这句话。我相信没有测试的代码不应该部署到生产环境中。

为什么测试如此重要？好吧，首先，它们为你提供了可预测性。或者至少，它们帮助你实现高可预测性。不幸的是，总有一些漏洞会悄悄地进入我们的代码。但我们肯定希望我们的代码尽可能可预测。我们不希望的是惊喜，我们的代码以一种不可预测的方式运行。你会高兴地知道，检查你度假时乘坐的飞机传感器的软件有时会发疯吗？不，可能不会。

因此我们需要测试我们的代码，我们需要检查其行为是否正确，当它处理边缘情况时是否按预期工作，当与之通信的组件出现问题时它不会挂起，性能是否在可接受的范围内，等等。

本章全部关于这个主题，确保你的代码准备好面对可怕的外部世界，即足够快，并且能够处理意外或异常情况。

我们将探讨测试，包括对**测试驱动开发**（**TDD**）的简要介绍，这是我最喜欢的作业方法之一。然后，我们将探索异常的世界，最后我们将简要谈谈性能和性能分析。深呼吸，我们开始吧...

# 测试你的应用程序

有许多不同种类的测试，实际上如此之多，以至于公司通常有一个专门的部门，称为**质量保证**（**QA**），由那些整天测试公司开发人员生产的软件的个人组成。

为了开始进行初步分类，我们可以将测试分为两大类：白盒测试和黑盒测试。

**白盒测试**是那些锻炼代码内部结构的测试，它们检查到非常细粒度的程度。另一方面，**黑盒测试**是那些将正在测试的软件视为一个盒子内的，忽略其内部结构的测试。甚至盒子内使用的科技或语言对黑盒测试来说也不重要。它们所做的是将输入连接到盒子的一端，并验证另一端的输出，这就是全部。

### 注意

还有一个介于两者之间的类别，称为**灰盒测试**，它以与黑盒方法相同的方式测试系统，但对我们使用的算法和数据结构有一些了解，并且只有部分访问源代码的权限。

在这些类别中有很多不同种类的测试，每种测试都服务于不同的目的。仅为了给你一个概念，这里有一些例子：

+   **前端测试**确保应用程序的客户端暴露了应该暴露的信息，所有链接、按钮、广告等需要展示给客户的内容。它还可能验证是否可以通过用户界面走一条特定的路径。

+   **场景测试**利用故事（或场景）帮助测试人员解决复杂问题或测试系统的一部分。

+   **集成测试**验证应用程序的各个组件在通过接口发送消息时一起工作的行为。

+   **冒烟测试**在您部署应用程序的新更新时特别有用。它们检查应用程序最基本、最重要的部分是否仍然按预期工作，并且它们没有**着火**。这个术语来自工程师通过确保没有冒烟来测试电路的时候。

+   **验收测试**，或**用户验收测试**（**UAT**），是开发者与产品负责人（例如，在敏捷开发环境中）一起进行的工作，以确定委托的工作是否正确完成。

+   **功能测试**验证软件的功能或功能。

+   **破坏性测试**通过模拟系统故障来摧毁系统的一部分，以确定系统剩余部分的表现如何。这类测试通常由需要提供极其可靠服务的公司广泛进行，例如亚马逊等。

+   **性能测试**旨在验证系统在特定数据负载或流量下的表现如何，以便工程师可以更好地了解系统中的瓶颈，这些瓶颈可能在重负载情况下使系统崩溃，或者那些阻止可扩展性的瓶颈。

+   **可用性测试**和与之密切相关的**用户体验**（**UX**）测试旨在检查用户界面是否简单、易于理解和使用。它们旨在为设计师提供反馈，以改善用户体验。

+   **安全性和渗透测试**旨在验证系统抵御攻击和入侵的能力。

+   **单元测试**帮助开发者以稳健和一致的方式编写代码，提供对编码错误、重构错误等的初步反馈和防御。

+   **回归测试**在更新后向开发者提供有关系统中被损害的功能的有用信息。系统被认为有回归的原因包括旧错误重新出现、现有功能受损或引入了新问题。

关于测试已经写了许多书籍和文章，如果你对了解所有不同类型的测试感兴趣，我必须向你指出这些资源。在本章中，我们将专注于单元测试，因为它们是软件构建的基石，构成了开发者编写的绝大多数测试。

测试是一种*艺术*，恐怕你无法从书中学习到这种艺术。你可以学习所有的定义（你应该这样做），并尽可能多地收集有关测试的知识，但我向你保证，只有在你在这个领域工作足够长的时间后，你才能正确地测试你的软件。

当你在重构一小段代码时遇到困难，因为每次你触摸到的东西都会使测试失败，你会学会编写不那么僵化和限制性的测试，这些测试仍然可以验证你的代码的正确性，同时，也让你有自由和乐趣去玩弄它，按照你的意愿塑造它。

当你频繁被要求修复代码中的意外错误时，你会学会如何更彻底地编写测试，如何提出一个更全面的边缘情况列表，以及应对这些情况的策略，以防它们变成错误。

当你花费太多时间阅读测试并尝试重构它们以更改代码中的一个小功能时，你会学会编写更简单、更短、更专注的测试。

我可以继续说“当你……你学习……”，但我想你明白我的意思。你需要亲自动手，积累经验。我的建议？尽可能多地学习理论，然后尝试使用不同的方法进行实验。此外，尝试向经验丰富的程序员学习；这非常有效。

## 测试的结构

在我们专注于单元测试之前，让我们看看什么是测试，以及它的目的是什么。

**测试**是一段代码，其目的是验证我们系统中的某个东西。这可能意味着我们正在调用一个函数，传递两个整数，或者一个对象有一个名为`donald_duck`的属性，或者当你在一个 API 上下单后，一分钟内你可以在数据库中看到它被分解成基本元素。

一个测试通常由三个部分组成：

+   **准备**：这是你设置场景的地方。你准备所有需要的数据、对象、服务，确保它们在需要的地方准备好使用。

+   **执行**：这是你执行检查逻辑的地方。你使用在准备阶段设置的数据和接口执行操作。

+   **验证**：这是你验证结果并确保它们符合你的预期的地方。你检查函数的返回值，或者某些数据是否在数据库中，某些数据不在，某些数据已更改，已发起请求，发生了某些事情，调用了某个方法，等等。

## 测试指南

就像软件一样，测试可以是好的或坏的，中间有各种不同的程度。为了编写好的测试，以下是一些指导原则：

+   **尽可能保持简单**：违反一些良好的编码规则，如硬编码值或重复代码，是可以接受的。测试首先需要尽可能的可读和易于理解。当测试难以阅读或理解时，你永远无法确定它们是否确实确保了你的代码正在正确执行。

+   **测试应验证一件事，且仅一件事**：保持测试简短并集中非常重要。编写多个测试来测试单个对象或函数是完全可行的。只需确保每个测试只有一个且仅有一个目的。

+   **测试在验证数据时不应做任何不必要的假设**：一开始这可能难以理解，但假设你在测试一个函数的返回值，它是一个无序的数字列表（如 `[2, 3, 1]`）。如果列表中的顺序是随机的，在测试中你可能想对其进行排序并与 `[1, 2, 3]` 进行比较。如果你这样做，你将在函数调用结果的顺序上引入额外的假设，这是不好的做法。你应该总是找到一种方法来验证事物，而不会引入任何假设或任何不属于你用测试描述的使用案例中的特性。

+   **测试应测试“是什么”，而不是“如何”**：测试应专注于检查函数应该做什么，而不是它是如何做的。例如，关注它正在计算一个数字的平方根（“是什么”），而不是关注它是如何调用 `math.sqrt` 来实现的（“如何”）。除非你正在编写性能测试或你有特定的需求来验证某些动作是如何执行的，否则尽量避免这种类型的测试，专注于“是什么”。测试“如何”会导致测试过于严格，并使得重构变得困难。此外，当你专注于“如何”时，你必须编写的测试类型更有可能在频繁修改软件时降低你的测试代码库的质量（关于这一点稍后还会讨论）。

+   **测试在准备阶段应假设尽可能少的内容**：假设你有 10 个测试，它们正在检查一个函数如何操作数据结构。假设这个数据结构是一个包含五个键/值对的字典。如果你在每个测试中都放入完整的字典，那么当你需要更改该字典中的任何内容时，你也必须修改所有十个测试。另一方面，如果你尽可能减少测试数据，你会发现，大多数情况下，大多数测试只检查数据的部分版本，而只有少数测试使用完整的版本。这意味着当你需要更改数据时，你只需要修改那些实际在测试它的测试。

+   **测试应该尽可能快地运行**：一个良好的测试代码库可能会比被测试的代码本身更长。这取决于具体情况和开发者，但无论长度如何，你最终会有数百甚至数千个测试要运行，这意味着它们运行得越快，你就能越快回到编写代码。例如，在使用 TDD 时，你会非常频繁地运行测试，所以速度是至关重要的。

+   **测试应该使用尽可能少的资源**：这样做的原因是，任何检查你代码的开发者都应该能够运行你的测试，无论他们的机器有多强大。这可能是一个瘦虚拟机，或者是一个被忽视的 Jenkins 服务器，但你的测试应该在不消耗太多资源的情况下运行。

    ### 注意

    **Jenkins** 服务器是一个运行 Jenkins 的机器，Jenkins 是一种能够执行各种任务（包括自动运行测试）的软件。Jenkins 在那些采用持续集成、极限编程等实践的公司中经常被使用。

## 单元测试

现在你已经了解了测试是什么以及为什么我们需要它，让我们最终介绍开发者的最佳拍档：**单元测试**。

在我们继续举例之前，让我提醒你一些注意事项：我会尽量给你讲解单元测试的基础知识，但我不会严格遵循任何特定的思想或方法论。多年来，我尝试了许多不同的测试方法，最终形成了自己的做事方式，这种方式一直在不断进化。用布鲁斯·李的话来说：

> *"吸收有用的，摒弃无用的，添加你自己的特色"。*

### 编写单元测试

为了解释如何编写单元测试，让我们用一个简单的代码片段来帮助自己：

`data.py`

```py
def get_clean_data(source):
    data = load_data(source)
    cleaned_data = clean_data(data)
    return cleaned_data
```

函数 `get_clean_data` 负责从 `source` 获取数据，对其进行清理，并将其返回给调用者。我们如何测试这个函数？

做这件事的一种方法是在调用它之后，确保 `load_data` 只被调用了一次，并且它的唯一参数是 `source`。然后我们必须验证 `clean_data` 也只被调用了一次，并且它的参数是 `load_data` 的返回值。最后，我们还需要确保 `clean_data` 的返回值与 `get_clean_data` 函数返回的值相同。

为了做到这一点，我们需要设置源代码并运行这段代码，这可能会成为一个问题。单元测试的黄金法则之一是*任何跨越你应用程序边界的元素都需要被模拟*。我们不希望与真实的数据源进行交互，也不希望实际运行与不在我们应用程序中包含的任何东西通信的真实函数。一些例子包括数据库、搜索服务、外部 API、文件系统中的文件等等。

我们需要这些限制来作为盾牌，这样我们就可以始终安全地运行测试，而不必担心在真实数据源中破坏某些东西。

另一个原因是，单个开发者可能很难在自己的机器上重现整个架构。这可能需要设置数据库、API、服务、文件和文件夹等，这可能很困难，耗时，有时甚至不可能。

### 注意

简单来说，**应用程序编程接口**（**API**）是一套用于构建软件应用的工具。API 通过其操作、输入和输出以及底层类型来表示软件组件。例如，如果你创建的软件需要与数据提供者服务进行接口，那么你很可能需要通过他们的 API 来获取数据。

因此，在我们的单元测试中，我们需要以某种方式模拟所有这些事物。单元测试需要由任何开发者运行，而无需在他们的机器上设置整个系统。

另一种不同的方法，当可能这样做时，我总是更喜欢使用，那就是在不使用假对象的情况下模拟实体，而是使用专门的测试对象。例如，如果你的代码与数据库进行交互，而不是伪造所有与数据库交互的函数和方法，并编程假对象使其返回真实对象的结果，我更愿意创建一个测试数据库，设置我需要的表和数据，然后修补连接设置，以便我的测试运行的是真实代码，针对测试数据库，从而不会造成任何损害。内存数据库是这些情况下的绝佳选择。

### 注意

允许你为测试创建数据库的应用之一是 Django。在`django.test`包中，你可以找到一些工具，这些工具可以帮助你编写测试，这样你就不必模拟与数据库的对话。通过这种方式编写测试，你还可以检查事务、编码以及所有其他与数据库相关的编程方面。这种方法的另一个优点在于，你可以检查那些可能从一个数据库到另一个数据库发生变化的事物。

然而，有时仍然不可能，我们需要使用假对象，因此让我们来谈谈它们。

### 模拟对象和修补

首先，在 Python 中，这些假对象被称为**mocks**。在版本 3.3 之前，`mock`库是一个第三方库，基本上每个项目都会通过`pip`安装，但从版本 3.3 开始，它已经被包含在标准库的`unittest`模块中，这是理所当然的，鉴于其重要性和普及程度。

用模拟对象或函数（或一般地，任何数据结构）替换真实对象或函数的行为被称为**修补**。`mock` 库提供了 `patch` 工具，它可以作为一个函数或类装饰器，甚至作为一个上下文管理器（更多内容请参阅第八章，*边缘 – GUI 和脚本*），你可以用它来模拟事物。一旦你用合适的模拟替换了你不需要运行的所有东西，你就可以将它们传递到测试的第二阶段，并运行你正在执行的代码。执行后，你将能够检查这些模拟以验证你的代码是否正确工作。

### 断言

验证阶段是通过使用断言来完成的。**断言**是一个函数（或方法），你可以用它来验证对象之间的相等性，以及其他条件。当条件不满足时，断言将引发一个异常，这将使你的测试失败。你可以在 `unittest` 模块文档中找到一个断言列表，以及它们在 nose 第三方库中的对应 Python 版本，该库提供了一些相对于纯 `unittest` 模块的优势，从改进的测试发现策略开始（这是测试运行器检测和发现你应用程序中的测试的方式）。

### 一个经典的单元测试示例

模拟、修补和断言是我们编写测试时将使用的基本工具。所以，最后，让我们看看一个例子。我将编写一个函数，该函数接受一个整数列表，并过滤掉所有非正数。

`filter_funcs.py`

```py
def filter_ints(v):
    return [num for num in v if is_positive(num)]

def is_positive(n):
    return n > 0
```

在前面的例子中，我们定义了 `filter_ints` 函数，它基本上使用列表推导来保留 `v` 中所有正数，丢弃零和负数。我希望，到现在为止，任何进一步的代码解释都是侮辱性的。

然而，有趣的是开始思考我们如何测试它。好吧，我们为什么不调用 `filter_ints` 并传递一个数字列表，并确保对每个数字调用 `is_positive` 呢？当然，我们还需要测试 `is_positive`，但我稍后会向你展示如何做。现在，让我们为 `filter_ints` 编写一个简单的测试。

### 注意

为了确保我们处于同一页面上，我将本章的代码放入一个名为 `ch7` 的文件夹中，该文件夹位于我们项目的根目录下。在 `ch7` 的同一级别，我创建了一个名为 `tests` 的文件夹，其中我放置了一个名为 `test_ch7` 的文件夹。在这个文件夹中，我有一个测试文件，名为 `test_filter_func.py`。

基本上，在 `tests` 文件夹中，我将重新创建我正在测试的代码的树结构，将所有内容前缀为 `test_`。这样，查找测试就非常容易，同时也能保持它们的整洁。

`tests/test_ch7/test_filter_funcs.py`

```py
from unittest import TestCase  # 1
from unittest.mock import patch, call  # 2
from nose.tools import assert_equal  # 3
from ch7.filter_funcs import filter_ints  # 4

class FilterIntsTestCase(TestCase):  # 5

    @patch('ch7.filter_funcs.is_positive')  # 6
    def test_filter_ints(self, is_positive_mock):  # 7
        # preparation
        v = [3, -4, 0, 5, 8]

        # execution
        filter_ints(v)  # 8

        # verification
        assert_equal(
            [call(3), call(-4), call(0), call(5), call(8)],
            is_positive_mock.call_args_list
        )  # 9
```

哇，这么少的代码，却说了这么多。首先：`#1`。`TestCase`类是我们用来运行测试的封装实体的基类。它不仅仅是一个裸容器；它为您提供了编写测试的更简单的方法。

在`#2`中，我们从`unittest.mock`模块中导入`patch`和`call`。`patch`负责用`Mock`实例替换对象，从而在执行阶段完成后，让我们能够检查它。`call`为我们提供了一个很好的方式来表达一个（例如，函数）调用。

在`#3`中，您可以看到我更倾向于使用`nose`提供的断言，而不是`unittest`模块自带的断言。举个例子，如果我没有使用`nose`，`assert_equal(...)`将变为`self.assertEqual(...)`。我不喜欢为任何断言输入`self.`，如果有可能避免，我也不特别喜欢驼峰命名法，因此我总是更喜欢使用`nose`来进行断言。

`assert_equal`是一个接受两个参数（以及一个可选的第三个参数，用作消息）并验证它们是否相同的函数。如果它们相等，则不会发生任何事情，但如果它们不同，则会引发`AssertionError`异常，告诉我们有问题。当我编写测试时，我总是将预期值作为第一个参数，将实际值作为第二个参数。这个约定在阅读测试时节省了我很多时间。

在`#4`中，我们导入我们想要测试的函数，然后（`#5`）我们继续创建一个类，我们的测试将在这个类中运行。这个类的每个以`test_`开头的方法都将被解释为一个测试。如您所见，我们需要用`patch`装饰`test_filter_ints`（`#6`）。理解这部分内容至关重要，我们需要在对象实际使用的地方进行补丁。在这种情况下，路径非常简单：`ch7.filter_func.is_positive`。

### 小贴士

补丁操作可能非常复杂，所以我强烈建议您阅读模拟文档中的“在哪里打补丁”部分：[`docs.python.org/3/library/unittest.mock.html#where-to-patch`](https://docs.python.org/3/library/unittest.mock.html#where-to-patch)。

当我们使用`patch`装饰一个函数时，就像在我们的例子中那样，测试签名中会多出一个参数（`#7`），我喜欢将其称为补丁函数名称，加上一个`_mock`后缀，以便清楚地表明该对象已被补丁（或模拟）。）

最后，我们到达测试的主体，我们有一个非常简单的准备阶段，在这个阶段中，我们设置一个列表，其中至少包含所有整数类别（负数、零和正数）的代表。

然后，在`#8`中，我们执行执行阶段，运行`filter_ints`函数，但不收集其结果。如果一切如预期进行，伪造的`is_positive`函数必须已经对`v`中的每个整数进行了调用。

我们可以通过比较调用对象列表与模拟的`call_args_list`属性（`#9`）来验证这一点。这个属性是自对象创建以来在对象上执行的所有调用的列表。

让我们运行这个测试。首先，确保你已经安装了`nose`（`$ pip freeze`会告诉你你是否已经安装了它）：

```py
$ pip install nose

```

然后，切换到项目的根目录（我的项目名为`learning.python`），并按如下方式运行测试：

```py
$ nosetests tests/test_ch7/
.
------------------------------------------------------------
Ran 1 test in 0.006s
OK

```

输出显示了单个点（每个点代表一个测试），一条分隔线，以及运行整个测试套件所需的时间。最后还显示`OK`，这意味着我们的测试都是成功的。

### 使测试失败

好的，为了好玩，让我们让其中一个失败。在测试文件中，将最后的调用从`call(8)`改为`call(9)`，然后再次运行测试：

```py
$ nosetests tests/test_ch7/
F
============================================================
FAIL: test_filter_ints (test_filter_funcs.FilterIntsTestCase)
------------------------------------------------------------
Traceback (most recent call last):
 File "/usr/lib/python3.4/unittest/mock.py", line 1125, in patched
 return func(*args, **keywargs)
 File "/home/fab/srv/learning.python/tests/test_ch7/test_filter_funcs.py", line 21, in test_filter_ints
 is_positive_mock.call_args_list
AssertionError: [call(3), call(-4), call(0), call(5), call(9)] != [call(3), call(-4), call(0), call(5), call(8)]
------------------------------------------------------------
Ran 1 test in 0.008s
FAILED (failures=1)

```

哇，我们激怒了这个怪物！尽管如此，信息量仍然很大。这告诉你，测试`test_filter_ints`（包括它的路径）已经运行并且失败了（顶部的大`F`，之前是点所在的位置）。它提供了一个`Traceback`，告诉你，在`test_filter_funcs.py`模块的第 21 行，当我们断言`is_positive_mock.call_args_list`时，存在差异。测试期望调用列表以`call(9)`实例结束，但实际列表以`call(8)`结束。这简直太棒了。

如果你有一个这样的测试，你能想象如果你不小心重构并引入了错误会发生什么吗？好吧，你的测试会崩溃！它们会告诉你*你搞砸了某些东西，这里是详细信息*。所以，你去检查你破坏了什么。

### 接口测试

让我们添加另一个测试来检查返回值。这是类中的另一个方法，所以我不需要再次复制整个代码：

`tests/test_ch7/test_filter_funcs.py`

```py
def test_filter_ints_return_value(self):
    v = [3, -4, 0, -2, 5, 0, 8, -1]

    result = filter_ints(v)

    assert_list_equal([3, 5, 8], result)
```

这个测试与之前的测试略有不同。首先，我们不能模拟`is_positive`函数，否则我们就无法检查结果。其次，我们不是检查调用，而是检查输入数据时函数的结果。

我更喜欢这个测试，而不是之前的那个。这种类型的测试被称为**接口测试**，因为它检查我们正在测试的函数的接口（输入和输出的集合）。它不使用任何模拟，这就是为什么我比之前更常用这种技术。让我们运行新的测试套件，然后看看为什么我比那些带模拟的测试更喜欢接口测试。

```py
$ nosetests tests/test_ch7/
..
------------------------------------------------------------
Ran 2 tests in 0.006s
OK

```

两个测试都运行良好（我在第一个测试中将那个`9`改回了`8`，当然）。

### 比较带和不带模拟的测试

现在，让我们看看为什么我真的不喜欢模拟，只有在没有选择的情况下才使用它们。让我们以这种方式重构代码：

`filter_funcs_refactored.py`

```py
def filter_ints(v):
    v = [num for num in v if num != 0]  # 1
    return [num for num in v if is_positive(num)]
```

`is_positive`的代码与之前相同。但`filter_ints`中的逻辑现在已改变，这样`is_positive`就不会用`0`调用，因为它们都在`#1`中被过滤掉了。这导致了一个有趣的结果，所以让我们再次运行测试：

```py
$ nosetests tests/test_ch7/test_filter_funcs_refactored.py 
F.
============================================================
FAIL: test_filter_ints (test_filter_funcs_refactored.FilterIntsTestCase)
------------------------------------------------------------
... omit ...
AssertionError: [call(3), call(-4), call(0), call(5), call(8)] != [call(3), call(-4), call(5), call(8)]
------------------------------------------------------------
Ran 2 tests in 0.002s
FAILED (failures=1)

```

一个测试通过了，但另一个测试，即使用模拟的`is_positive`函数的测试失败了。`AssertionError`消息显示我们现在需要修改预期调用列表，移除`call(0)`，因为它不再执行了。

这并不好。我们既没有改变函数的接口，也没有改变其行为。函数仍然遵守其*原始契约*。通过用模拟对象测试它，我们所做的是限制了自己。实际上，我们现在必须修改测试以使用新的逻辑。

这只是一个简单的例子，但它展示了整个模拟机制中的一个重要缺陷。*你必须确保你的模拟与被替换的代码保持最新和同步*，否则你可能会遇到前面提到的问题，甚至更糟。你的测试可能不会失败，因为它们使用的是模拟对象，它们的表现良好，但真正的问题在于，现在不再同步的它们实际上失败了。

所以*只有在必要时才使用模拟*，只有在没有其他测试方法时才使用。当你跨越测试中的应用边界时，尝试使用替代品，比如测试数据库或模拟 API，只有在不可能的情况下才求助于模拟。它们非常强大，但如果不正确处理，也非常危险。

因此，让我们移除第一个测试，只保留第二个，这样我就可以向你展示你在编写测试时可能会遇到的其他问题。整个测试模块现在看起来是这样的：

`tests/test_ch7/test_filter_funcs_final.py`

```py
from unittest import TestCase
from nose.tools import assert_list_equal
from ch7.filter_funcs import filter_ints

class FilterIntsTestCase(TestCase):
    def test_filter_ints_return_value(self):
        v = [3, -4, 0, -2, 5, 0, 8, -1]
        result = filter_ints(v)
        assert_list_equal([3, 5, 8], result)
```

如果我们运行它，它将通过。

简单聊聊三角剖分。现在让我问你：如果我将我的`filter_ints`函数改为这样，会发生什么？

`filter_funcs_triangulation.py`

```py
def filter_ints(v):
    return [3, 5, 8]
```

如果你运行测试套件，我们现有的测试仍然会通过！你可能觉得我疯了，但我展示这个是因为我想讨论一个叫做**三角剖分**的概念，这在进行 TDD 接口测试时非常重要。

整个想法是通过从不同的角度（比如从一个三角形的三个顶点之一到其他两个顶点）定位，以使我们的代码无法作弊，并暴露出错误。我们可以简单地修改测试如下：

`tests/test_ch7/test_filter_funcs_final_triangulation.py`

```py
def test_filter_ints_return_value(self):
    v1 = [3, -4, 0, -2, 5, 0, 8, -1]
    v2 = [7, -3, 0, 0, 9, 1]

    assert_list_equal([3, 5, 8], filter_ints(v1))
    assert_list_equal([7, 9, 1], filter_ints(v2))
```

我已经将执行部分直接移动到断言中，你可以看到我们现在从两个不同的角度定位我们的函数，从而要求真实代码必须包含在其中。我们的函数再也不能作弊了。

三角剖分是一种非常强大的技术，它教会我们始终尝试从许多不同的角度来测试我们的代码，以覆盖所有可能的边缘情况，从而暴露任何问题。

### 边界和粒度

现在让我们为`is_positive`函数添加一个测试。我知道它只有一行，但它为我们提供了讨论两个非常重要的概念的机会：**边界**和**粒度**。

函数主体中的那个`0`是一个**边界**，不等式中的`>`是我们对这个边界的行为。通常，当你设置一个边界时，你会将空间分成三个区域：边界之前的部分，边界之后的部分，以及边界本身。在例子中，边界之前我们找到负数，边界是元素`0`，边界之后我们找到正数。我们需要测试这些区域中的每一个，以确保我们正确地测试了函数。那么，让我们看看一个可能的解决方案（我将把这个测试添加到类中，但不会展示重复的代码）：

`tests/test_ch7/test_filter_funcs_is_positive_loose.py`

```py
def test_is_positive(self):
    assert_equal(False, is_positive(-2))  # before boundary
    assert_equal(False, is_positive(0))  # on the boundary
    assert_equal(True, is_positive(2))  # after the boundary
```

你可以看到，我们正在为边界周围的每个不同区域练习一个数字。你认为这个测试好吗？在你继续阅读之前，先思考一下。

答案是否定的，这个测试并不好。至少不够好。如果我改变`is_positive`函数的主体，使其读取`return n > 1`，我预期我的测试会失败，但它不会。`-2`仍然是`False`，`0`也是，而`2`仍然是`True`。为什么会这样呢？这是因为我们没有正确考虑粒度。我们处理的是整数，那么从一个整数移动到下一个整数时的最小粒度是多少？是 1。因此，当我们考虑边界时，只考虑这三个区域是不够的。我们需要以可能的最小粒度来做这件事。让我们改变一下测试：

`tests/test_ch7/test_filter_funcs_is_positive_correct.py`

```py
def test_is_positive(self):
    assert_equal(False, is_positive(-1))
    assert_equal(False, is_positive(0))
    assert_equal(True, is_positive(1))
```

啊，现在好多了。现在如果我们改变`is_positive`的主体，使其读取`return n > 1`，第三个断言将会失败，这正是我们想要的。你能想到一个更好的测试吗？

`tests/test_ch7/test_filter_funcs_is_positive_better.py`

```py
def test_is_positive(self):
    assert_equal(False, is_positive(0))
    for n in range(1, 10 ** 4):
        assert_equal(False, is_positive(-n))
        assert_equal(True, is_positive(n))
```

这个测试甚至更好。我们测试了前十个整数（正数和负数）以及`0`。这基本上为我们提供了比仅仅跨越边界更好的覆盖率。所以，请记住这一点。在边界周围以最小的粒度进行近距离观察，但也要尝试扩展，在最佳覆盖率和执行速度之间找到一个良好的折衷方案。我们很想检查前十亿个整数，但我们不能等待几天来运行我们的测试。

### 一个更有趣的例子

好的，这是我能够给你的最温和的介绍了，所以让我们继续到更有趣的部分。让我们编写并测试一个函数，它可以扁平化嵌套字典结构。在过去的几年里，我非常紧密地与 Twitter 和 Facebook API 合作。处理这样庞大的数据结构并不容易，尤其是它们通常非常嵌套。结果发现，以一种你可以工作而不丢失原始结构信息的方式扁平化它们要容易得多，然后可以从扁平结构重新创建嵌套结构。为了给你一个例子，我们想要的是这样的：

`data_flatten.py`

```py
nested = {
    'fullname': 'Alessandra',
    'age': 41,
    'phone-numbers': ['+447421234567', '+447423456789'],
    'residence': {
        'address': {
            'first-line': 'Alexandra Rd',
            'second-line': '',
        },
        'zip': 'N8 0PP',
        'city': 'London',
        'country': 'UK',
    },
}

flat = {
    'fullname': 'Alessandra',
    'age': 41,
    'phone-numbers': ['+447421234567', '+447423456789'],
    'residence.address.first-line': 'Alexandra Rd',
    'residence.address.second-line': '',
    'residence.zip': 'N8 0PP',
    'residence.city': 'London',
    'residence.country': 'UK',
}
```

类似于 `flat` 的结构更容易操作。在编写扁平化函数之前，让我们做一些假设：键是字符串，除非是字典，否则我们保留每个数据结构不变，如果是字典，则进行扁平化处理，我们使用点作为分隔符，但希望能够将不同的分隔符传递给我们的函数。以下是代码：

`data_flatten.py`

```py
def flatten(data, prefix='', separator='.'):
    """Flattens a nested dict structure. """
    if not isinstance(data, dict):
        return {prefix: data} if prefix else data

    result = {}
    for (key, value) in data.items():
        result.update(
            flatten(
                value,
                _get_new_prefix(prefix, key, separator),
                separator=separator))
    return result

def _get_new_prefix(prefix, key, separator):
    return (separator.join((prefix, str(key)))
            if prefix else str(key))
```

上述示例并不困难，但也不是显而易见的，所以让我们来分析一下。首先，我们检查 `data` 是否是字典。如果不是字典，那么它就是不需要扁平化的数据；因此，我们简单地返回 `data`，或者如果 `prefix` 不是空字符串，则返回一个包含一个键/值对的字典：`prefix`/`data`。

如果 `data` 是一个字典，我们准备一个空的 `result` 字典来返回，然后解析 `data` 的项目列表，我相信你会记得，它们是 2-元组 *(键，值)*。对于每一对 *(键，值)*，我们递归地调用 `flatten`，并用那个调用返回的内容更新 `result` 字典。递归在遍历嵌套结构时非常出色。

乍一看，你能理解 `_get_new_prefix` 函数的作用吗？让我们再次使用内外部技术。我看到一个三元运算符，当 `prefix` 是空字符串时返回 `key` 的字符串表示。另一方面，当 `prefix` 是非空字符串时，我们使用 `separator` 将 `prefix` 与 `key` 的字符串表示形式 `join`。请注意，在 `join` 调用内部的括号不是多余的，我们需要它们。你能想出为什么吗？

让我们为这个函数写几个测试用例：

`tests/test_ch7/test_data_flatten.py`

```py
# ... imports omitted ...
class FlattenTestCase(TestCase):

    def test_flatten(self):
        test_cases = [
            ({'A': {'B': 'C', 'D': [1, 2, 3], 'E': {'F': 'G'}},
 'H': 3.14,
 'J': ['K', 'L'],
 'M': 'N'},
             {'A.B': 'C',
              'A.D': [1, 2, 3],
              'A.E.F': 'G',
              'H': 3.14,
              'J': ['K', 'L'],
              'M': 'N'}),
            (0, 0),
            ('Hello', 'Hello'),
            ({'A': None}, {'A': None}),
        ]
        for (nested, flat) in test_cases:
            assert_equal(flat, flatten(nested))

    def test_flatten_custom_separator(self):
        nested = {'A': {'B': {'C': 'D'}}}
        assert_equal(
            {'A#B#C': 'D'}, flatten(nested, separator='#'))
```

让我们从 `test_flatten` 开始。我定义了一个包含 2-元组 `(nested, flat)` 的列表，每个都代表一个测试用例（我突出显示了 `nested` 以便于阅读）。我有一个包含三个嵌套级别的字典，然后是一些较小的数据结构，当传递给 `flatten` 函数时它们不会改变。这些测试用例可能不足以覆盖所有边缘情况，但它们应该能给你一个关于如何构建此类测试的好主意。通过简单的 `for` 循环，我遍历每个测试用例，并断言 `flatten(nested)` 的结果等于 `flat`。

### 小贴士

关于这个示例，有一点要说的是，当你运行它时，它会显示已经运行了两个测试。这实际上是不正确的，因为即使技术上只有一个测试在运行，其中一个测试中我们有多个测试用例。最好以它们被识别为单独的方式运行。这可以通过使用像 `nose-parameterized` 这样的库来实现，我鼓励你查看。它位于 [`pypi.python.org/pypi/nose-parameterized`](https://pypi.python.org/pypi/nose-parameterized)。

我还提供了一个额外的测试用例，以确保自定义分隔符功能正常工作。正如你所看到的，我只使用了一个数据结构，它要小得多。我们不需要再次做大，也不需要测试其他边缘情况。记住，测试应该确保一件事，而且只有一件事，`test_flatten_custom_separator`只是负责验证我们是否可以向`flatten`函数提供不同的`separator`。

如果我有足够的空间，我可以继续谈论测试，大概还能写一本书，但不幸的是，我们得在这里停下来。我没有告诉你关于**doctests**（使用 Python 交互式 shell 风格编写的文档中的测试）以及关于这个主题可能说的另外五十万件事情。你必须自己发现这些。

查看一下`unittest`模块、`nose`和`nose-parameterized`库以及`pytest`（[`pytest.org/`](http://pytest.org/)）的文档，这样你就能顺利了。根据我的经验，对于新手来说，模拟和补丁似乎很难掌握，所以请给自己一点时间来消化这些技术。尝试并逐渐学习它们。

# 测试驱动开发

让我们简要地谈谈**测试驱动开发**或**TDD**。这是一种由 Kent Beck 重新发现的方法论，他写了《通过示例进行测试驱动开发》，*Addison Wesley – 2002*，如果你想了解这个主题的基础知识，我强烈建议你阅读这本书，我对这个主题非常着迷。

> *TDD 是一种基于持续重复非常短的开发周期的软件开发方法*。

首先，开发者编写一个测试用例，并运行它。测试用例旨在检查代码中尚未包含的功能。可能是要添加的新功能，或者是要删除或修改的内容。运行测试用例会使它失败，因此这个阶段被称为**红色**。

当测试失败时，开发者编写最少的代码来使其通过。当运行测试成功时，我们就进入了所谓的**绿色**阶段。在这个阶段，可以编写一些欺骗性的代码，只是为了使测试通过（这就是为什么你会使用三角测量法）。这种技术被称为，*假装直到你做到*。

这个循环的最后一部分是开发者负责代码和测试（分别在不同的时间）并进行重构，直到它们达到期望的状态。这个最后阶段被称为**重构**。

因此，**TDD 的咒语**是，**红色-绿色-重构**。

起初，在编写代码之前编写测试用例感觉真的很奇怪，我必须承认我花了一些时间才习惯这种方式。但是，如果你坚持下去，并强迫自己学习这种稍微有些反直觉的工作方式，在某个时刻，几乎神奇的事情就会发生，你将看到你的代码质量以一种在其他情况下不可能的方式提高。

当你在编写测试之前编写代码时，你必须同时注意代码需要做什么以及如何做。另一方面，当你先编写测试再编写代码时，你可以专注于“做什么”的部分，在编写测试时集中精力。当你编写代码之后，你主要需要关注的是如何实现测试所要求的内容。这种关注点的转变允许你的大脑在单独的时刻集中精力在“做什么”和“如何做”的部分，从而产生一个让你惊讶的大脑能力提升。

从采用这种技术中还可以获得其他一些好处：

+   **你将更有信心地进行重构**：因为当你接触代码时，你知道如果你搞砸了，至少会破坏一个测试。此外，你将在重构阶段处理架构设计，此时有测试作为守护者将允许你享受对代码进行按摩，直到它达到让你满意的状态。

+   **代码将更加易于阅读**：在我们这个时代，编码已经成为一种社会活动，每个专业开发者花费在阅读代码上的时间远多于编写代码。

+   **代码将更加松散耦合，更容易测试和维护**：这仅仅是因为先编写测试迫使你更深入地思考其结构。

+   **先编写测试需要你对业务需求有更好的理解**：这是交付实际所需内容的基本要求。如果你的需求理解缺乏信息，你会发现编写测试极具挑战性，这种情况就像一个哨兵一样提醒你。

+   **所有内容都经过单元测试意味着代码将更容易调试**：此外，小测试是提供替代文档的完美选择。英语可能会误导，但五行简单的 Python 代码在一个简单的测试中很难被误解。

+   **更高的速度**：编写测试和代码比先编写代码然后花费时间调试要快。如果你不编写测试，你可能会更快地交付代码，但随后你必须追踪并解决错误（而且，请放心，肯定会有错误）。编写代码然后调试所花费的总时间通常比使用 TDD（测试驱动开发）开发代码的时间要长，在编写代码之前就有测试运行，确保其中的错误数量将远低于其他情况。

另一方面，这种技术的缺点主要是：

+   **整个公司都需要相信它**：否则你将不得不不断地与你的老板争论，而你的老板可能不会理解为什么你交付的时间如此之长。事实是，短期内你交付的时间可能会更长，但长期来看，TDD 会给你带来很多好处。然而，由于它不像短期那样触手可及，因此很难看到长远的影响。在我的职业生涯中，我与固执的老板进行了斗争，以便能够使用 TDD 进行编码。有时这很痛苦，但总是值得的，我从未后悔过，因为最终，结果的质量总是受到赞赏。

+   **如果你没有理解业务需求，这将在你编写的测试中反映出来，因此也会反映在代码中**：这种问题直到你进行用户验收测试（UAT）之前很难被发现，但你可以做的一件事是与另一位开发者结对编程。结对编程不可避免地需要讨论业务需求，这有助于在编写测试之前更好地了解它们。

+   **编写糟糕的测试很难维护**：这是一个事实。带有太多模拟或额外假设或结构不良数据的测试很快就会成为一种负担。不要让这让你气馁；只需继续实验，改变你编写测试的方式，直到你找到一种不需要你在每次触摸代码时做大量工作的方法。

我对 TDD（测试驱动开发）的热情如此之高，以至于当我去面试工作时，我总是询问我即将加入的公司是否采用 TDD。如果答案是“不”，对我来说这可能是一个决定性的因素。我鼓励你尝试并使用它。一直用到你在脑海中有所领悟。我保证你不会后悔。

# 异常

尽管我还没有正式向你介绍它们，但到现在为止，我期望你至少对什么是**异常**有一个模糊的概念。在前几章中，我们看到了当迭代器耗尽时，对其调用`next`会引发`StopIteration`异常。当我们尝试访问一个不在有效范围内的列表位置时，我们遇到了`IndexError`。当我们尝试访问一个没有该属性的对象的属性时，我们遇到了`AttributeError`，当我们用键和字典做同样的事情时，我们遇到了`KeyError`。我们还在运行测试时遇到了`AssertionError`。

现在，是我们讨论异常的时候了。

有时候，即使一个操作或一段代码是正确的，也可能存在某些可能导致错误的情况。例如，如果我们正在将用户输入从`string`转换为`int`，用户可能会不小心输入一个字母代替数字，这使得我们无法将该值转换为数字。在除法操作中，我们可能事先不知道是否尝试除以零。在打开文件时，它可能不存在或已损坏。

当在执行过程中检测到错误时，它被称为 **异常**。异常并不一定是致命的；事实上，我们已经看到 `StopIteration` 在 Python 生成器和迭代器机制中是深度集成的。通常情况下，如果你不采取必要的预防措施，异常会导致你的应用程序崩溃。有时，这是期望的行为，但在其他情况下，我们希望防止和控制这些问题。例如，我们可能提醒用户他们正在尝试打开的文件已损坏或丢失，这样他们可以修复它或提供另一个文件，而无需应用程序因这个问题而死亡。让我们看看几个异常的例子：

`exceptions/first.example.py`

```py
>>> gen = (n for n in range(2))
>>> next(gen)
0
>>> next(gen)
1
>>> next(gen)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> print(undefined_var)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'undefined_var' is not defined
>>> mylist = [1, 2, 3]
>>> mylist[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> mydict = {'a': 'A', 'b': 'B'}
>>> mydict['c']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'c'
>>> 1 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

如你所见，Python 的外壳相当宽容。我们可以看到 `Traceback`，这样我们就有关于错误的信息，但程序并没有死亡。这是一种特殊的行为，一个常规程序或脚本如果没有处理异常，通常会死亡。

要处理异常，Python 提供了 `try` 语句。当你进入 `try` 子句时，Python 会监视一个或多个不同类型的异常（根据你的指令），如果发生异常，它会允许你做出反应。`try` 语句由 `try` 子句组成，它开启了语句；一个或多个 `except` 子句（都是可选的），用于定义捕获异常时应该做什么；一个 `else` 子句（可选的），当 `try` 子句在没有抛出任何异常的情况下退出时执行；以及一个 `finally` 子句（可选的），其代码无论在其他子句中发生什么都会执行。`finally` 子句通常用于清理资源。注意顺序，这很重要。此外，`try` 后面必须至少跟一个 `except` 子句或一个 `finally` 子句。让我们看一个例子：

`exceptions/try.syntax.py`

```py
def try_syntax(numerator, denominator):
    try:
        print('In the try block: {}/{}'
              .format(numerator, denominator))
        result = numerator / denominator
    except ZeroDivisionError as zde:
        print(zde)
    else:
        print('The result is:', result)
        return result
    finally:
        print('Exiting')

print(try_syntax(12, 4))
print(try_syntax(11, 0))
```

上述示例定义了一个简单的 `try_syntax` 函数。我们执行两个数字的除法。如果我们用 `denominator = 0` 调用函数，我们准备捕获 `ZeroDivisionError` 异常。最初，代码进入 `try` 块。如果 `denominator` 不是 `0`，则计算 `result`，执行在离开 `try` 块后，在 `else` 块中继续。我们打印 `result` 并返回它。看看输出，你会在返回 `result` 之前注意到，这是函数的退出点，Python 执行了 `finally` 子句。

当 `denominator` 为 `0` 时，情况会发生变化。我们进入 `except` 块并打印 `zde`。`else` 块没有执行，因为在 `try` 块中抛出了异常。在（隐式地）返回 `None` 之前，我们仍然执行 `finally` 块。看看输出，看看它对你是否有意义：

```py
$ python exceptions/try.syntax.py 
In the try block: 12/4
The result is: 3.0
Exiting
3.0
In the try block: 11/0
division by zero
Exiting
None

```

当您执行一个 `try` 块时，您可能想要捕获多个异常。例如，当尝试解码一个 JSON 对象时，您可能会遇到 `ValueError`（不规则的 JSON），或者如果您提供给 `json.loads()` 的数据类型不是字符串，则可能发生 `TypeError`。在这种情况下，您可以像这样结构化您的代码：

`exceptions/json.example.py`

```py
import json
json_data = '{}'
try:
    data = json.loads(json_data)
except (ValueError, TypeError) as e:
    print(type(e), e)
```

此代码将捕获 `ValueError` 和 `TypeError`。尝试将 `json_data = '{}'` 改为 `json_data = 2` 或 `json_data = '{{'`，您将看到不同的输出。

### 注意

**JSON** 代表 **JavaScript Object Notation**，它是一种开放标准格式，使用人类可读的文本来传输由键/值对组成的数据对象。它是当在应用程序之间移动数据时广泛使用的交换格式，尤其是在数据需要以语言或平台无关的方式处理时。

如果您想以不同的方式处理多个异常，只需添加更多的 `except` 子句，如下所示：

`exceptions/multiple.except.py`

```py
try:
    # some code
except Exception1:
    # react to Exception1
except (Exception2, Exception3):
    # react to Exception2 and Exception3
except Exception3:
    # react to Exception3
...
```

请记住，异常是在定义该异常类或其基类的第一个块中处理的。因此，当您堆叠多个 `except` 子句时，请确保将特定的异常放在顶部，将通用的异常放在底部。在面向对象术语中，子类在顶部，基类在底部。此外，请记住，当抛出异常时，只有一个 `except` 处理器被执行。

您还可以编写 **自定义异常**。为了做到这一点，您只需从任何其他异常类继承即可。Python 内置的异常太多，无法在此列出，因此我必须将您指向官方文档。需要知道的一个重要事项是，每个 Python 异常都源自 `BaseException`，但您的自定义异常不应直接从该类继承。这样做的原因是，处理此类异常也会捕获来自 `BaseException` 的 **系统退出异常**，如 `SystemExit` 和 `KeyboardInterrupt`，这可能导致严重问题。在灾难发生时，您希望能够通过 *Ctrl* + *C* 从应用程序中退出。

您可以通过从 `Exception` 继承来轻松解决问题，`Exception` 继承自 `BaseException`，但它的子类不包括任何退出系统的异常，因为它们在内置异常层次结构中是兄弟关系（参见 [`docs.python.org/3/library/exceptions.html#exception-hierarchy`](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)）。

使用异常进行编程可能会非常棘手。你可能会无意中静音错误，或者捕获那些本不应该处理的异常。为了安全起见，请记住以下几点指南：只将可能引发你想要处理的异常（s）的代码放入`try`子句中。当你编写`except`子句时，尽可能具体，不要仅仅求助于`except Exception`，因为这很容易。使用测试来确保你的代码以尽可能少的异常处理方式处理边缘情况。不指定任何异常的`except`语句会捕获任何异常，因此使你的代码面临与从`BaseException`派生自定义异常时相同的风险。

你几乎可以在网上找到有关异常的几乎所有信息。一些程序员大量使用它们，而另一些则很少使用（我属于后者）。通过参考他人的源代码来找到自己处理它们的方式。有许多有趣的项目开源了，你可以在 GitHub ([`github.com`](https://github.com)) 或 Bitbucket ([`bitbucket.org/`](https://bitbucket.org/)) 上找到它们。

在我们讨论**分析**之前，让我向你展示一个异常的非传统用法，只是为了给你一些东西来帮助你扩展对这些异常的看法。它们不仅仅是简单的错误。

`exceptions/for.loop.py`

```py
n = 100
found = False
for a in range(n):
    if found: break
    for b in range(n):
        if found: break
        for c in range(n):
            if 42 * a + 17 * b + c == 5096:
                found = True
                print(a, b, c)  # 79 99 95
```

如果你处理数字，前面的代码是一个非常常见的习语。你必须遍历几个嵌套的范围，并寻找满足条件的特定组合`a`、`b`和`c`。在示例中，条件是一个简单的线性方程，但想象一下比这更酷的东西。让我烦恼的是，我不得不在每个循环的开始检查是否找到了解决方案，以便在找到时尽可能快地跳出循环。跳出逻辑干扰了其他代码，我不喜欢它，所以我为这个问题想出了一个不同的解决方案。看看它，看看你是否可以将其适应到其他情况。

`e` `xceptions/for.loop.py`

```py
class ExitLoopException(Exception):
 pass

try:
    n = 100
    for a in range(n):
        for b in range(n):
            for c in range(n):
                if 42 * a + 17 * b + c == 5096:
                    raise ExitLoopException(a, b, c)
except ExitLoopException as ele:
    print(ele)  # (79, 99, 95)
```

你能看出这有多优雅吗？现在，突破逻辑完全由一个简单的异常来处理，其名称甚至暗示了其目的。一旦找到结果，我们就抛出它，然后立即控制权交给处理它的`except`子句。这是值得深思的。这个例子间接地展示了如何抛出自己的异常。查阅官方文档，深入了解这个主题的美丽细节。

# 分析 Python

有几种不同的方法可以分析 Python 应用程序。分析意味着在跟踪几个不同参数的同时运行应用程序，如函数被调用的次数、在其中花费的时间量等。分析可以帮助我们找到应用程序中的瓶颈，这样我们就可以只改进真正减慢我们速度的部分。

如果你查看标准库官方文档中的性能分析部分，你会看到有几个不同的性能分析接口实现：`profile` 和 `cProfile`。

+   `cProfile` 被推荐给大多数用户，它是一个具有合理开销的 C 扩展，使其适合分析长时间运行的程序。

+   `profile` 是一个纯 Python 模块，其接口被 `cProfile` 模拟，但会给被分析程序增加显著的开销。

此接口执行 **确定性性能分析**，这意味着所有函数调用、函数返回和异常事件都会被监控，并在这些事件之间进行精确的时间测量。另一种方法，称为 **统计性能分析**，随机采样有效指令指针，并推断时间花费在哪里。

后者通常涉及更少的开销，但只提供近似结果。此外，由于 Python 解释器运行代码的方式，确定性性能分析并不会增加人们想象中的那么多开销，所以我会给你一个使用命令行中的 `cProfile` 的简单示例。

我们将使用以下代码计算毕达哥拉斯三元组（我知道，你可能错过了它们...）。

`profiling/triples.py`

```py
def calc_triples(mx):
    triples = []
    for a in range(1, mx + 1):
        for b in range(a, mx + 1):
            hypotenuse = calc_hypotenuse(a, b)
            if is_int(hypotenuse):
                triples.append((a, b, int(hypotenuse)))
    return triples

def calc_hypotenuse(a, b):
    return (a**2 + b**2) ** .5

def is_int(n):  # n is expected to be a float
    return n.is_integer()

triples = calc_triples(1000)
```

脚本非常简单；我们用 `a` 和 `b` 迭代区间 [1, *mx*]（通过设置 `b >= a` 来避免重复的配对）并检查它们是否属于直角三角形。我们使用 `calc_hypotenuse` 来获取 `a` 和 `b` 的斜边，然后，使用 `is_int` 检查它是否为整数，这意味着 (*a*, *b*, *c*) 是一个毕达哥拉斯三元组。当我们对这个脚本进行性能分析时，我们得到表格形式的信息。列包括 `ncalls`、`tottime`、`percall`、`cumtime`、`percall` 和 `filename:lineno(function)`。它们代表我们对函数的调用次数、在其中花费的时间等等。我会裁剪一些列以节省空间，所以如果你自己运行性能分析，不要担心如果你得到不同的结果。

```py
$ python -m cProfile profiling/triples.py
1502538 function calls in 0.750 seconds
Ordered by: standard name
ncalls  tottime  percall filename:lineno(function)
500500    0.469    0.000 triples.py:14(calc_hypotenuse)
500500    0.087    0.000 triples.py:18(is_int)
 1    0.000    0.000 triples.py:4(<module>)
 1    0.163    0.163 triples.py:4(calc_triples)
 1    0.000    0.000 {built-in method exec}
 1034    0.000    0.000 {method 'append' of 'list' objects}
 1    0.000    0.000 {method 'disable' of '_lsprof.Profil...
500500    0.032    0.000 {method 'is_integer' of 'float' objects}

```

即使只有这么有限的数据，我们仍然可以从中推断出一些关于此代码的有用信息。首先，我们可以看到我们选择的算法的时间复杂度随着输入大小的平方增长。我们进入内循环体的次数正好是 *mx (mx + 1) / 2*。我们用 `mx = 1000` 运行脚本，这意味着我们在内层 `for` 循环中进入了 `500500` 次。在这个循环中发生三件事，我们调用 `calc_hypotenuse`，调用 `is_int`，如果条件满足，我们将元素添加到 `triples` 列表中。

查看性能分析报告，我们发现算法在 `calc_hypotenuse` 函数中花费了 `0.469` 秒，这比在 `is_int` 函数中花费的 `0.087` 秒多得多，尽管它们被调用的次数相同，所以让我们看看是否可以稍微提升 `calc_hypotenuse` 的性能。

实际上，我们可以。正如我之前在书中提到的，幂运算符`**`相当昂贵，在`calc_hypotenuse`中我们使用了它三次。幸运的是，我们可以轻松地将其中两个转换为简单的乘法，如下所示：

`profiling/triples.py`

```py
def calc_hypotenuse(a, b):
    return (a*a + b*b) ** .5
```

这个简单的更改应该会改善情况。如果我们再次运行性能分析，我们会看到现在`0.469`已经下降到`0.177`。不错！这意味着现在我们花费在`calc_hypotenuse`函数内部的时间大约只有之前的 37%。

让我们看看我们是否可以通过这样改变来改进`is_int`：

`profiling/triples.py`

```py
def is_int(n):
    return n == int(n)
```

这个实现是不同的，其优势在于它也适用于`n`是整数的情况。然而，当我们对它进行性能分析时，我们发现`is_int`函数内部的时间已经上升到`0.141`秒。这意味着它大约翻了一番，与之前相比。在这种情况下，我们需要恢复到之前的实现。

当然，这个例子很简单，但足以展示如何对应用程序进行性能分析。了解针对函数执行的调用次数可以帮助我们更好地理解算法的时间复杂度。例如，你不会相信有多少程序员没有意识到那两个`for`循环是与输入大小的平方成比例运行的。

有一点需要提及：根据你使用的系统，结果可能会有所不同。因此，能够在一个尽可能接近软件部署系统的系统上对软件进行性能分析，如果不是实际上在那个系统上，这非常重要。

## 何时进行性能分析？

性能分析非常酷，但我们需要知道何时进行性能分析，以及我们需要以何种程度来处理从性能分析中获得的结果。

Donald Knuth 曾经说过，“过早优化是万恶之源”，虽然我不会如此极端地表达，但我同意他的观点。毕竟，我怎能不同意这位给我们带来了《计算机程序设计艺术》、《TeX》以及我在大学时研究过的最酷算法的人呢？

所以，首先也是最重要的：*正确性*。你希望你的代码能够正确地交付结果，因此编写测试，寻找边缘情况，并以你认为合理的方式对你的代码进行压力测试。不要过于保护，不要把事情放在脑后，因为你认为它们不太可能发生。要彻底。

其次，注意编码的最佳实践。记住可读性、可扩展性、松散耦合、模块化和设计。应用面向对象编程（OOP）原则：封装、抽象、单一职责、开闭原则等。深入了解这些概念。它们将为你打开新的视野，并扩展你对代码的思考方式。

第三，像野兽一样重构代码！童子军规则说：“总是要使你离开的地方比找到的时候更干净。”将这个规则应用到你的代码上。

最后，当所有上述事项都得到妥善处理之后，然后且仅在此之后，你才开始关注性能分析。

运行你的性能分析器并识别瓶颈。当你对需要解决的瓶颈有了概念后，先从最严重的一个开始。有时，修复一个瓶颈会引起连锁反应，从而改变代码其余部分的工作方式。这取决于你的代码是如何设计和实现的，有时这种影响很小，有时则更多。因此，先从最大的问题开始。

Python 之所以如此受欢迎，其中一个原因是它可以以许多不同的方式实现。所以，如果你发现自己在使用纯 Python 时遇到困难，没有什么能阻止你卷起袖子，买上几百升咖啡，然后用 C 语言重写那些慢速的代码。保证会很有趣！

# 摘要

在本章中，我们探讨了测试、异常和性能分析的世界。

我试图给你一个相当全面的测试概述，特别是单元测试，这是开发者主要进行的测试类型。我希望我已经成功地传达了测试不是完美定义的东西，你可以从书中学习。在感到舒适之前，你需要大量地实验。在程序员必须做出的学习和实验努力中，我认为测试是最值得的之一。

我们简要地看到了如何防止我们的程序因为运行时发生的错误，称为异常，而死亡。而且，为了避开常规内容，我给你提供了一个使用异常跳出嵌套`for`循环的不太常规的例子。这并非唯一的情况，我相信随着你作为程序员成长，你还会发现其他情况。

最后，我们非常简要地提到了性能分析，通过一个简单的例子和一些指导方针。我想为了完整性而讨论性能分析，这样你至少可以尝试一下。

我们现在即将进入第八章，*边缘 – GUI 和脚本*，我们将在这里动手处理脚本和 GUI，并希望有所发现。

### 注意

我知道我在本章中给了你很多提示，但没有提供链接或方向。我恐怕这是出于选择。作为一个程序员，在工作中不会有哪一天不需要在文档页面、手册、网站等地方查找东西。我认为对于程序员来说，能够有效地搜索所需信息是至关重要的，所以我希望你能原谅我这种额外的训练。毕竟，这一切都是为了你的利益。
