# 4

# 交易应用：里面有什么？

几乎任何实现交易策略的应用程序都有一些或多或少标准的组件。让我们首先快速看一下典型交易应用的一种较为通用的架构，然后我们将更详细地探讨与使用 Python 开发交易策略相关的具体点。

在*第一章**，开发交易策略——为什么它们不同*中，我们看到了一个典型的交易应用的非常通用的图。现在，我们将更详细地考虑其模块。我们将学习如何将我们的应用程序连接到数据源和交易场所，如何检索数据并检查其一致性，以及考虑有关交易逻辑和订单的重要点。

到本章结束时，您将了解如何开发高效、可维护和可扩展的交易应用的主要组件，以及如何避免由于市场数据处理错误、交易逻辑错误和对交易机制理解不足而出现的典型严重问题。

在本章中，我们将涵盖以下主题：

+   让你的应用与世界对话——那阴暗的通信协议世界

+   检索数据——垃圾进，垃圾出

+   交易逻辑——这里的一个小错误可能代价巨大

+   风险管理——你的安全带

+   订单接口——确保你被正确理解

# 技术要求

您需要 Python 3.9 或更高版本来运行本章中的代码。

# 让你的应用与世界对话——那阴暗的通信协议世界

嗯，实际上，在这一节中，我可以说，“在 FX 自动化交易的世界里，每个设置都是独特的，所以去问你的经纪人。”当然，我不会这样做，但当涉及到将您的应用程序连接到做市商、**电子通信网络**（**ECN**）或任何其他交易场所时，请始终记住我在本节开头所说的话。

如您从上一章所记得的，外汇市场在交易方面仍然是分割最严重的；因此，其计算机化基础设施也非常分割。尽管有交换金融信息的标准，但许多交易场所使用自己的方言，这意味着如果您想使用您的应用程序与不同的经纪人合作，将需要额外的工作。同时，许多交易场所提供自己的 API 和协议，这些协议与其他任何东西都不兼容，因此开发者永远不会失业，并且永远在适应他们的应用程序。

说了这么多，让我们从通常被认为是用于交易应用中唯一的行业标准通信开始。

## FIX – 通用但过于灵活

在我看来，尽管其语法难以阅读，**金融信息交换**（**FIX**）仍然是开始深入研究交易通信的最佳选择，因为其消息至少可以被人类阅读——因此，调试和学习我们的错误将确保学习曲线最陡峭。

不幸的是，FIX 被认为主要是一种专业用途的协议，并且任何经纪商的任何交易者都无法直接使用。这种歧视的一个可能原因是 FIX 允许你发送任何指令，而接收服务器只检查语法，而不检查消息的含义。因此，它可能不仅会损害交易者的账户，甚至可能损害市场本身。因此，大多数最大的做市商、经纪商和银行都要求交易者具有专业状态，才能允许他们使用 FIX。

然而，有好消息：如今，许多规模虽小但雄心勃勃的 FX 经纪商向零售交易者提供了许多以前仅限于机构的交易服务。这并不意味着他们的服务质量低：他们只是需要交易量，而很明显，自动化交易策略比人工交易者能更好地产生交易量。因此，实际上，任何人都可以通过 ECN 使用 FIX 获取机构流动性。

此外，谁知道呢，也许有一天你会发现自己在与银行或投资基金合作，那时即使对 FIX 的一般了解也会对你的职业发展大有裨益。

那么，FIX 究竟是什么呢？

FIX 试图创建一个真正通用的标准，几乎在任何需要传输金融相关信息的场合都可以使用。它被银行、经纪商、信息机构甚至保险公司等许多其他机构使用。当然，如此广泛的应用场景假设了极大的灵活性，以便根据需要定制 FIX，而这种灵活性反讽地使得 FIX 不如它所期望的那样标准化。

例如，一些交易场所可能要求各种标签（FIX 协议的基本元素）为强制性的，而其他则不要求。一些交易场所支持限价和止损订单，而其他只认可市价订单。因此，如果你想将你的交易应用从一个经纪商迁移到另一个经纪商，可能需要进行一些重构，因为 FIX 并不*要求*接受任何特定的订单类型。列表可以继续，但本质上问题是 FIX 旨在支持*任何*市场，但交易场所只使用其标签的*子集*，这些标签与其市场相关，经常根据他们的需求调整标准。

我认为最好将 FIX 不仅仅视为一种协议或 API，而更应将其视为一种具有简单语法的特殊语言，它允许你传达几乎任何含义。你也可以将其视为一个用于构建消息而不是应用的框架，而消息的含义将取决于上下文和环境。

让我们先看看 FIX 作为一种协议，并考虑其层。这将帮助你理解我们如何与 FIX 连接工作。

### 基本连接

在传输层，FIX 需要一个标准的套接字连接。再次，正如我在本节开头提到的，一切都非常个性化，因为不同的经纪人和交易场所可能对客户端连接到他们的方式有不同的要求。通常，你必须向经纪商或交易场所提供一个 IP 地址（或地址范围）以进行白名单并使用**传输控制协议套接字**（**TCP 套接字**）进行连接。其他人可能需要复杂的授权机制，甚至强制使用 VPN。因此，你可能需要咨询你的经纪商或交易场所以获取详细信息。

学习基本的低级网络，例如如何在 Python 中建立套接字连接，并不是这本书的目标，所以如果你以前从未做过，我建议从 Real Python 的一个优秀指南开始（[`realpython.com/python-sockets`](https://realpython.com/python-sockets)），或者如果你更喜欢基于实际操作语言并包含大量实例的“深入”或“游泳”方法，你可以观看 Geeks for Geeks 的这篇教程（[`www.geeksforgeeks.org/socket-programming-python/`](https://www.geeksforgeeks.org/socket-programming-python/)）。重点是，在 Python 中建立套接字连接并不是火箭科学，而是一个简单的常规程序。

### 标签

一旦建立了套接字连接，我们就可以通过它发送和接收一些有意义的信息。与许多其他协议一样，FIX 基于消息。FIX 消息是一个纯文本（ASCII）字符串，它由非打印字符 0x01（`SOH`）分隔的块（子字符串）组成，没有像`\n`或`\r`这样的特殊结束字符。每个分隔符之间的块遵循简单的语法：

```py
TAG=VALUE
```

**标签**是一个数字，其值可以是任何不包含 0x01 字符的字符串，这是出于明显的理由：它将被解释为分隔符。不过，有一个重要的例外：如果标签意味着检索数据，那么用作数据的任何值都可以是任意字节序列。

例如，`55=EUR/USD`代表一个货币对、工具或符号（记住，它们都是同义词）。`40=Limit`表示消息包含一个限价订单（参见*第三章**，从开发者的角度来看的 FX 市场概述*，以了解订单类型）。

由于分隔符字符 0x01 是非打印的，许多作者使用特殊字符在 FIX 消息中视觉上分隔标签。我相信你会同意，以下结构的字符串更容易阅读：

```py
8=FIX.4.4|9=73|35=A|34=1092|49=TESTSND|52=20220728-07:30:59.643|56=TESTTGT|198=0|108=60|10=133
```

相反，阅读以下字符串更困难：

```py
8=FIX.4.49=7335=A34=109249=TESTSND52=20220728-07:30:59.64356=TESTTGT198=0108=6010=133
```

然而，在真实的 FIX 消息中，永远不要使用除 0x01 之外的任何其他分隔符！

### 消息结构

任何 FIX 消息都由以下三个逻辑部分组成：

+   标准头

+   主体

+   标准尾迹

标准头始终由以下三个标签按此顺序发送，而不是其他任何顺序：

+   `标签 8` – 表示消息开始，并包含双方使用的 FIX 协议版本。

+   `标签 9` – 消息体长度

+   `标签 35` – 消息类型（例如，`报价请求`、`订单`、`登录`或`登出`）

标准拖车总是以标签 10 结束，其值是消息校验和。校验和是哈希函数返回的一小段数据——一种处理有意义数据块的所有位并根据特殊算法压缩它的函数。校验和用于确保数据块（在我们的情况下是消息）在无错误的情况下被传递。如果您想了解更多关于校验和、哈希函数和相关内容的信息，我建议从维基百科上一篇优秀的文章开始，该文章还提供了进一步阅读的参考文献（[`en.wikipedia.org/wiki/Checksum`](https://en.wikipedia.org/wiki/Checksum)）。

根据 FIX 标准，每个标签在每个消息中只能出现一次。具有相同标签多次出现的消息将被目标计算机拒绝。

标签必须有一个值。如果没有为任何标签指定值，整个消息将被拒绝。

### 会话

使用 FIX 进行工作是有组织的会话。会话假设有两个计算机参与：发送消息的计算机（*发送方*，相应的标签称为`SenderCompID`）和接收消息的计算机（*目标*，相应的标签称为`TargetCompID`）。通常，会话是由客户端连接到服务器开始的，例如，交易员连接到经纪人或银行连接到 ECN。

会话是通过从发送方的计算机向目标计算机发送握手消息开始的。在目标计算机有回复的情况下，这条消息启动会话。这种消息类型（标签 35）是`登录（A）`。一个示例握手消息头将如下所示：

```py
8=FIX.4.4|9=XX|35=A
```

在前面的消息中，`XX`代表整个消息长度（见*消息*部分中标签 9 的解释）。

现在，我们已经到了一个地方，我的初步论点（去询问你的经纪人详情）变得明显。问题是，除了这三个强制标签和结束标签 10 之外，登录消息中的所有其他标签都是可选的。这意味着我无法告诉你应该包括什么；也没有其他作者可以告诉你——除非是你的经纪人，因为是他们决定应该发送什么以及发送的顺序。所以，最好的学习方法是参考从你想要发送消息的交易所获得的文档。

任何 FIX 会话都以`登出（5）`消息结束，其最小形式如下所示：

```py
8=FIX.4.4|9=5|35=5|10=166
```

### 构造消息

在这一点上，我想警告你避免许多交易策略开发者犯的一个非常常见的错误。他们认为他们的应用程序可能生成的 FIX 消息集是有限的；因此，他们将它们作为字符串硬编码，并在需要发送订单时选择合适的消息。

不要这样做！以下是不应该这样做的原因：

+   首先，这种方法使得你的代码不可扩展。在需要为新的订单类型添加新标签的情况下，你需要重写整个应用程序。

+   第二，这使得你的代码不可移植。在你想用另一个经纪人使用它的情况下，这个经纪人可能需要在登录消息或任何其他地方要求特定的标签集，再次——你将不得不重写你的应用程序。

+   最后，即使你认为你能够记住每个 FIX 标签的含义，相信我，这只是一个危险的自我欺骗！

因此，在 Python 中构建 FIX 消息的合理方式是分块构建，使用标签的显式、可读性强的名称而不是仅仅使用数字。我们将为此目的使用原生的 Python 字典：

1.  让我们从构建一个基本的 FIX 字典开始，将标签与它们相应的名称关联起来。我们将使用名称作为键，标签号作为值，因为这是我们构建消息的方式：

    ```py
    fixdict = {}
    ```

    ```py
    fixdict["start"]="8"
    ```

    ```py
    fixdict["body_len"] = "9"
    ```

    ```py
    fixdict["checksum"] = "10"
    ```

    ```py
    fixdict["msg_type"] = "35"
    ```

1.  现在，我们需要一个函数来在消息中将标签绑定在一起。不要忘记，消息中包含的标签数量可能会有很大差异，因此我们希望使用 Python 最强大的功能之一——*任意* *关键字参数*：

    ```py
    def compose_message(fix_dictionary, **kwargs):
    ```

    ```py
        msg = ""
    ```

    ```py
        for arg in kwargs:
    ```

    ```py
            msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"
    ```

    ```py
        return msg
    ```

在这里，我们假设我们将关键字参数作为`<tag_name>=VALUE`的配对传递，然后使用字典将可读性强的名称替换为标准的 FIX 标签号。

1.  让我们用以下指令测试我们的代码：

    ```py
    message = compose_message(fixdict, start="FIX.4.4", body_len="25", msg_type="A", checksum="56")
    ```

我们将得到以下结果：

```py
8=FIX.4.49=2535=A10=56
```

注意，SOH 字符在此输出中不可见，但如果我们明确请求`message`变量的值，它将返回以下输出：

```py
In[28]: message
Out[28]: '8=FIX.4.4\x019=25\x013
5=A\x0110=56\x01'
```

在这里，不可打印的字符清晰可见。

然而，每次我们需要组合消息时手动传递标准头是不合理的。因此，我们需要将其包含在函数中。

对于第一个标签`8`，很简单。我们可以在一个特殊变量中存储值，并在消息组合过程的最后阶段添加它。第一个标签总是只包含 FIX 协议的版本。但无论如何，我们应该计算消息体的长度和校验和，并将它们（长度和校验和）分别包含在标签`9`和`10`中。

重要

不要将消息体与消息本身混淆！标签`9`表示只有消息体的长度，即从标签`9`到标签`10`。在我们的例子中，消息体的长度是`5`（不是`4`，因为主体由字符`3`、`5`、`=`、`A`和一个不可打印的 0x01 组成）。

实现计算消息体长度的最简单方法是将 `**kwargs` 中的提供标签限制仅为消息体。这可以通过多种方式完成：

1.  让我们先使用一个我们将称之为 `fix_exceptions` 的列表：

    ```py
    fix_exceptions = ["8", "9", "10"]
    ```

1.  我们只有在标签不在异常列表中时才会将标签添加到我们的编写消息中：

    ```py
    if fix_dictionary[arg] not in fix_exceptions:
    ```

1.  现在，我们消息编写函数的新版本将看起来像这样：

    ```py
    def compose_message(fix_dictionary, fix_exceptions, **kwargs):
    ```

    ```py
        msg = ""
    ```

    ```py
        for arg in kwargs:
    ```

    ```py
            if fix_dictionary[arg] not in fix_exceptions:
    ```

    ```py
                msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"
    ```

    ```py
        return msg
    ```

如果我们使用前面的参数进行测试，我们将得到以下输出：

```py
35=A
```

标签 8、9 和 10 现在被忽略，因为它们在异常列表中。由于与标准头和标准尾相关的标签被忽略，因此未被忽略的内容保留在消息体中。

1.  太好了，我们现在可以计算它的长度并将其添加到消息中：

    ```py
    msg = fix_dictionary["body_len"] + "=" + str(len(msg)) + msg
    ```

1.  现在，让我们添加标签 `8`：

    ```py
    msg = fix_dictionary["start"] + "FIX.4.4"
    ```

1.  最后，在以下代码中，我们计算字符串中所有字符的 ASCII 码之和，然后将这个和除以 256 并取余数（这里我们将使用 `reduce` 函数，它是 `functools` 的一部分，因此应该作为 `from functools import reduce` 导入）：

    ```py
    checksum = reduce(lambda x, y: x + y, list(map(ord, msg)) % 256)
    ```

然后我们将它添加到消息中：

```py
msg += fix_dictionary["checksum"] + "=" + str(checksum)
```

现在我们来看看整个升级后的代码：

```py
from functools import reduce
fixdict = {}
fixdict["start"]="8"
fixdict["body_len"] = "9"
fixdict["checksum"] = "10"
fixdict["msg_type"] = "35"
exceptions = ["8", "9", "10"]
def compose_message(fix_dictionary, fix_exceptions, **kwargs):
    msg = ""
    for arg in kwargs:
        if fix_dictionary[arg] not in fix_exceptions:
            msg += fix_dictionary[arg] + "=" + kwargs[arg] + "\001"
    msg = fix_dictionary["body_len"] + "=" + str(len(msg)) + msg
    msg = fix_dictionary["start"] + "=" + "FIX.4.4" + msg
    checksum = reduce(lambda x, y: x + y, list(map(ord, msg))) % 256
    msg += fix_dictionary["checksum"] + "=" + str(checksum)
    return msg
```

现在，让我们用以下输入来测试它：

```py
message = compose_message(fixdict, exceptions, start="wrong version", body_len="10000", msg_type="A", checksum="78909")
```

我们仍然会得到正确的结果：

```py
8=FIX.4.49=535=A10=178
```

注意，列表中找到的所有标签都被忽略，并且它们的荒谬值不会包含在消息中——这很好，因为否则这样的消息将被拒绝（在最好的情况下）。此外，现在当我们调用以下函数时，我们可以安全地省略除消息体之外的所有标签，这将给出与之前完全相同的结果：

```py
message = compose_message(fixdict, exceptions, msg_type="5")
```

### 接下来要做什么

如果你与 FIX 一起工作，你肯定需要一个包含所有标签的全面字典及其含义解释的参考。其中一个最好的资源是 OnixS（他们开发直接市场接入的 SDK，因此 FIX 在他们产品中扮演核心角色毫不奇怪），可以在[`www.onixs.biz/fix-dictionary.html`](https://www.onixs.biz/fix-dictionary.html)找到。如果你计划专业地与 FIX 一起工作，我强烈建议访问 FIX 社区官方网站[`www.fixtrading.org`](https://www.fixtrading.org)，并检查“标准”部分，在那里你可以找到有关技术标准、规范以及 FIX GitHub 的链接。

当谈到 FIX 的专业应用时，最重要且事实上的行业标准解决方案是 QuickFIX ([`quickfixengine.org`](https://quickfixengine.org))。它为包括 Python 在内的许多语言实现了 FIX 协议，通过减轻开发者编写低级 FIX 消息的负担，简化了交易应用的消息和数据检索开发。

对于 Python，也有几个现成的 FIX 实现，其中 Simplefix ([`pypi.org/project/simplefix/`](https://pypi.org/project/simplefix/)) 可能是最直接的。它不实现套接字连接或任何其他传输层功能，也不支持日志记录或确保消息持久性。它仅作为编码和解码 FIX 消息的方便包装器，提供易于阅读的函数。

还值得一提的是另一个建立在 FIX 之上的协议。它被称为**FAST**，代表**FIX Adapted for STreaming**。简单来说，这个协议旨在在不产生过多的处理开销或延迟的情况下，促进快速和大量消息的传输。如果你对学习更多关于 FAST 感兴趣，我建议从官方文档([`www.fixtrading.org/standards/fast/`](https://www.fixtrading.org/standards/fast/))开始，并查看[`jettekfix.com/education/fix-fast-tutorial/`](https://jettekfix.com/education/fix-fast-tutorial/)上的 FIX Fast 教程。

现在你已经知道了如何编写 FIX 消息，你只需要填充它们的意义。也就是说，你需要添加任何基于市场数据的交易逻辑，生成订单，将它们转换为 FIX 消息，并发送给经纪人、ECN 或其他地方。你还需要能够接收并理解对你消息的回复。例如，你的经纪人可能在消息体中响应`8=8`，这意味着你的订单已成功成交（消息类型 8 表示订单执行报告，值 8 表示*订单成交*）。经纪人可能会发送`8=5`给你，这意味着你的订单被拒绝，你的代码应该能够处理这种情况。

如果你的经纪人不支持 FIX 或不向非专业交易者提供访问权限怎么办？在这种情况下，我们不幸地回到了本章开头我的声明，“在 FX 自动化交易的世界里，每个设置都是独特的，所以去问问你的经纪人。”*正如我们之前看到的，即使在高度标准化的 FIX 协议中，仍然存在一定程度上的灵活性，因此最好阅读你计划发送订单的交易所提供的文档。对于专有协议，情况更糟，因为没有标准，每个经纪人都会提供他们自己设计的 API，他们认为这是最好的方式。

然而，从本节中最重要的结论是，任何协议、任何 API 和任何框架都只用于传递某种信息，在大多数情况下是交易订单，并接收回复。如果你设计你的交易应用，使得数据处理、交易逻辑、风险管理以及订单模块之间有独立的接口，你将能够从一种协议切换到另一种协议，而无需重写整个应用——这正是本书将要深入探讨的内容。

现在我们对您的应用程序和交易场所之间交换信息的方式更加熟悉，是时候学习我们可以发送和从那里检索什么了。让我们从市场数据开始。

# 获取数据——垃圾进，垃圾出

FIX 协议在设计上具有通用性，因此不仅可以用于订单，还可以用于数据检索。然而，在大多数情况下，它实际上并不用于市场数据传输；相反，交易场所提供自己的专有 API 来从那里检索数据。

始终如一，在这个通信协议的*阴暗世界*中，一切都是个性化的，每个交易场所都提供自己的 API。然而，总的来说，所有经纪商的 API 都是实现为 REST 或 Websockets。前者适用于偶尔的报价请求，而后者最适合连续订阅，以便接收实时市场数据。

我提供的以下示例是从 FX 市场中的关键 ECN 之一 LMAX 的 API 中提取的。它们之所以出色，不仅是因为它们对任何客户，无论大小都开放，而且还因为它们是极少数公开传播实时市场数据的交易场所之一——而且他们完全免费。

在你开始使用 FX 市场数据之前，你应该理解和始终记住一个重要的事情：

*演示环境中的数据始终与真实环境中的数据不同。*

这意味着，如果你从 ECN 接收公开数据或开设一个演示账户以从那里接收市场数据，你应该准备好看到与*真实*市场略有不同的报价。好消息是这种差异并不显著；在我们的特定例子中，LMAX 通常是 0.1 到 0.5 个点，在纽约银行结算时间（纽约时间下午 5 点）附近可能会有轻微的差异增加（参见*第三章**，从开发者的角度来看的*FX 市场概述*）。因此，即使是公开可用的数据，对于大多数开发和甚至实时交易来说都是好的。

在你需要时不时地获取这里和那里的报价的情况下，那么 LMAX 的 REST API 通常是你的选择。

就像任何常规 REST API 一样，它支持一些端点，允许以最后交易价格和订单簿顶部价格的形式检索市场价格数据。它还支持检索 LMAX 演示服务器支持的所有工具（符号）的信息。

为了检索这样一个列表，让我们执行以下操作：

```py
curl -i -X GET "https://public-data-api.london-demo.lmax.com/v1/instruments"
```

响应将为我们提供一个包含可用工具列表的 JSON：

```py
[{"instrument_id":"eur-usd","symbol":"EUR/USD","security_id":"4001","currency":"USD","unit_of_measure":"EUR","asset_class":"CURRENCY","quantity_increment":"1000.0000","price_increment":"0.000010","ticker_enabled":true},...]
```

我移除了剩余的 JSON 以保持其紧凑性，但其余部分只是其他工具的类似记录的重复。让我们解析这个答案来了解其组成部分：

+   `instrument_id`：这是 LMAX 演示服务器支持的 FX 工具的正确名称（注意，名称中不允许有斜杠 **/**，因此它们被替换为破折号 **-**）。

+   `asset_class`：在这个 ECN 上交易的大多数工具是货币，但也有金属和能源的**差价合约**（**CFDs**），所以请小心。

+   `quantity_increment`：这是订单大小的最小`quant`；1,000.000 欧元的增量意味着你可以发送一个价值 1,003,000 欧元的买卖订单，只需 2,000 EURUSD，但不能是 1,003,300 或 1,100,301 欧元。

+   `price_increment`：这是最小的价格波动。0.00001 意味着最小变化可以是在小数点右边的第五位，这种变化的数量是 1（所谓**分数点**）。

+   `ticker_enabled`：这意味着该符号可用于下单。

要检索特定符号的整个订单簿信息，我们可以使用以下方法：

```py
curl -i -X GET "https://public-data-api.london-demo.lmax.com/v1/orderbook/eur-usd"
```

响应将包含 LMAX 为演示账户允许的深度内的买卖报价列表，以纯 JSON 格式呈现。

如果你想要从 ECN 接收连续数据，你可能想使用 WebSockets 而不是 REST：

1.  首先，你需要安装 WebSockets，你可以使用 pip 来做这件事：

    ```py
    pip install websocket_client
    ```

如果你使用 Anaconda 分发的 Python，你可以使用以下代码：

```py
conda install -c conda-forge websocket-client
```

1.  首先，我们需要导入 WebSocket 模块：

    ```py
    import websocket
    ```

1.  然后，设置我们将要订阅的 URL：

    ```py
    url = "wss://public-data-api.london-demo.lmax.com/v1/web-socket"
    ```

1.  然后，创建 WebSocket 并连接它：

    ```py
    ws = websocket.WebSocket()
    ```

    ```py
    ws.connect(url)
    ```

1.  然后，将请求以常规 JSON 格式形成：

    ```py
    req = '{"type": "SUBSCRIBE","channels": [{"name": "ORDER_BOOK","instruments": ["eur-usd"]},{"name": "TICKER","instruments":["usd-jpy"]}]}'
    ```

1.  发送请求：

    ```py
    ws.send(req)
    ```

观察响应：

```py
print(ws.recv())
```

如果你正确地完成了所有步骤，你将看到类似这样的内容：

```py
{"type":"SUBSCRIPTIONS","channels":[{"name":"ORDER_BOOK","instruments":["eur-usd"]},{"name":"TICKER","instruments":["usd-jpy"]}]}
```

这个响应意味着订阅已经设置，并且订阅的工具是整个订单簿的欧元和最后价格数据的日元。

由于这本书不是关于 WebSockets 的教程，如果你不熟悉这种网络连接，我建议阅读非常全面的教程[`websockets.readthedocs.io/en/stable/intro/index.html`](https://websockets.readthedocs.io/en/stable/intro/index.html)。

你可以在 LMAX 官方文档中找到所有支持的 REST API 端点和 WebSocket 请求[`docs.lmax.com/public-data-api/`](https://docs.lmax.com/public-data-api/)。

注意

请不要忘记，前面的例子只是为了说明目的。我希望这本书尽可能不涉及任何经纪商，因此我无法真正推荐任何特定的经纪商或 ECN。这里提供 LMAX 的例子，仅仅是因为他们有一个最简单且易于使用的 API。

其他经纪商和交易场所可能有不同的 API，有时更复杂，但订阅数据的根本原则是相同的。

因此，既然我们已经知道了如何从交易场所获取数据，接下来就是最重要的部分：**数据处理**。你在交易应用中对数据进行的所有操作都必须确保数据一致性。

通过市场数据的一致性，我们假设以下情况：

+   如果接收到的 tick A 早于 tick B，那么 tick A 的时间戳应该早于 tick B 的时间戳。

+   如果两个相邻 tick 之间的时间间隔显著大于平均值，那么对此必须有明确的逻辑解释。

+   如果两个相邻 tick 之间的价格差距显著大于平均值，那么对此必须有明确的逻辑解释。

让我们在以下子节中详细考虑每个点。

## tick 序列

当你开始处理真实市场数据时，你会对具有错误时间戳的 tick 数量印象深刻。这种现象有几个解释；最容易被理解的可能是因为 tick 的数量（我们记得从*第一章*中，tick 是价格更新，无论是新的出价、新的要价还是新的交易）如此巨大，以至于交易所或 ECN 自己的服务器实际上无法正确地按顺序处理所有这些，并为一批 tick 分配相同的时间戳。还有其他一些原因，这些原因更多地与交易所服务器和交易服务器或客户端计算机之间的延迟有关。无论如何，无论原因如何，错误的时间戳都是一个真正的问题，在我们开始处理数据之前，我们总是必须进行检查，并在其中存在任何不一致时纠正时间戳。

有几种技术可以解决时间戳问题，我们将在下一章详细讨论这些技术，这一章完全致力于处理和存储市场数据。

## 时间间隔

基本上，时间间隔是指在一定时间内没有接收到市场数据的情况。当然，问题是如何定义这个“一定时间”。是多长时间？一秒？一分钟？一小时？如果 5 分钟内没有市场数据更新，这意味着连接丢失，还是市场根本没有任何活动？

如果你以实时报价的形式接收数据，可以通过在你的市场数据检索实现中添加心跳消息来相对容易地解决这个问题。

一个*心跳消息*与*ping*有些相似：发送一个内容为假的消息到服务器，服务器只是回复一些表示“好的，我还活着，并且可以很好地听到你。”的消息。这样的消息会自动以相等的间隔发送，这是一种简单而稳健的检查连接健康状况的方法。

如果你使用 FIX，这个协议原生支持心跳（消息类型 0，标签 35=0）。如果你使用其他 API——嗯……正如本章一贯的，你应该参考你的经纪商的文档，了解他们如何实现心跳（以及他们期望你使用什么）。如果经纪商没有保留特殊的心跳消息，你可能想不时地使用任何中性的请求，例如偶尔请求报价，并检查响应。

使用特殊心跳消息的关键优势是它在服务器运行时任何时候都有效。即使市场实际上关闭，并且尝试接收市场报价失败，心跳消息也会通过并得到响应。因此，使用心跳消息始终是首选的方法。

注意

如果你的经纪商或交易场所支持心跳消息，你可能想避免使用任何其他类型的请求，以确保连接是活跃的。在某些情况下，这种活动可能是某些 ECN 禁止的原因。

因此，对于实时报价，通过添加心跳消息可以相对容易地解决时间间隔的问题。但在我们处理*历史数据*的情况下，即不是代表现在市场状况的数据，而是表示过去某个时间市场状况的数据，我们该怎么办？在这种情况下，没有记录心跳消息（至少我不了解任何单一个例子表明情况相反），如果我们看到两个时间点之间有 1 小时的暂停，总会有一个问题是这些数据是否一致。

通常，这种一致性检查分为两个阶段：

+   首先，我们识别时间间隔。这里的主要问题是如何判断两个时间点之间的暂停是否足够长，以至于变得可疑。我们将在下一章详细探讨这个问题。现在，我们只需假设任何大于平均数加两个标准差（这里的 sigma 代表标准差，我们将在*第六章**，基本分析及其在 FX 交易中的可能用途*)的暂停都被认为是*可疑的*。

+   接下来，所有*可疑的*暂停都将与已知市场数据可以暂停的情况列表进行核对。我们排除所有周末、银行结算前后的暂停，以及某些货币银行日的开盘，并将剩余的与已知事件的时间表进行核对，例如重要经济新闻的发布，这也可能导致市场报价的中断。

如果剩余的时间间隔问题列表不显著（为了清晰起见，我们假设它至少是原始列表的 10 倍小），那么我们认为这些数据总体上是可用的。如果未识别的时间间隔数量仍然很大，最好避免使用这些数据。

## 价格间隔

价格缺口是指两个相邻的 tick 之间存在异常的价格差异。当然，就像时间间隔一样，问题是我们如何定义这种差异为**异常**。在这里，我们可以使用与时间间隔相似的技术。如果两个相邻 tick 的价格差异大于平均值加 2 个标准差，那么这可能是潜在的价格缺口。

在价格缺口的情况下，我们经常使用 3 个标准差以上，因为目标并不是真正捕捉到价格快速跳动的每一个情况（在真实市场中这种情况可能相当常见，至少每天发生几次），而是隔离和过滤掉**非市场价格**。

你可能还记得*第一章*中非市场价格示意图。所以，非市场价格是指完全、完全超出任何合理范围的东西，因此我们可以很容易地考虑 10、20，有时甚至 100 个标准差来过滤掉这些错误的报价。

你可能会想知道这些非市场价格的来源。非市场价格可能有多个原因：

+   最常见的原因是所谓的**大拇指效应**，简单地说就是发送到市场的要价或出价中的错误。通常，由于报价中的额外 0 或缺失的数字，它可能是前一个市场价格的大 10 倍或小 10 倍。在事后看来，以这些价格进行的交易通常会被撤销，但这些报价会被记录在数据流中并存储为历史数据。

+   一些数据提供商包括与交易无关的数据；例如，我见过一个案例，交易所将转移到保险基金的资金记录为市场价格数据。幸运的是，他们以零价格记录了这些*ticks*——幸运的是，因为这使得过滤变得非常容易。

+   在罕见的情况下，数据提供商的数据库、软件或硬件可能会出现故障——由这种原因造成的错误报价是最难找到和过滤的。

在你成功连接到数据源、接收数据并过滤它之后，是时候用它做一些有意义的事情了：即分析数据并做出一些交易决策。这就是我们将在下一节考虑的内容。

# 交易逻辑——这里一个小错误可能会损失一大笔财富

交易逻辑显然是整个交易应用的核心。它是分析市场数据以寻找任何预定义的价格-时间模式（有时还包括其他数据，如成交量和对冲头寸，但这些数据通常在现货市场不可用）并生成订单的组件。本书的大部分内容都将致力于交易逻辑以及开发交易算法的各种方法，但我们不能不考虑一个已经让许多交易者损失数百万甚至数十亿美元的错误——我指的是**前瞻性**问题。

提前查看的现象仅限于项目的开发阶段，当交易算法使用历史数据进行优化或训练时，这被称为历史数据。正如你从上一节中记得的那样，历史数据是由你自己或第三方（如交易所、经纪人、数据供应商等）预先记录的。这些数据可能包含 tick，也可能被压缩成 1 秒或 1 分钟的快照。无论数据压缩如何，清洗后的数据集中的所有数据都是按时间戳排序的，不存在任何*未来的数据会出现在过去数据之前*的情况，或者相反，任何过去的数据会在未来数据之后被记录。让我们看看以下例子来了解这意味着什么：

```py
1/27/2015,13:30:00,1.12947,1.12959,1.12941,1.12941,230,438,888,4,7,12
1/27/2015,13:31:00,1.12953,1.12970,1.12951,1.12965,400,240,650,9,4,14
1/27/2015,13:32:00,1.12944,1.12944,1.12883,1.12883,90,609,749,2,10,13
1/27/2015,13:33:00,1.12876,1.12907,1.12876,1.12894,589,170,909,5,4,12
1/27/2015,13:34:00,1.12902,1.12925,1.12902,1.12925,720,400,1120,9,4,13
```

在这个例子中，时间戳是正确的顺序。这块数据意味着该工具的收盘价（可以在每条记录的第六个位置找到）最初是`1.12941`，然后是`1.12965`，然后是`1.12883`，然后是`1.12894`，最后是`1.12925`。

当我们开发和测试一个交易算法时，我们通过处理历史数据并据此做出交易决策来*模拟*交易。通常，模拟引擎会逐个处理来自文件、列表或 pandas DataFrame 的数据块，以模拟如果我们的算法在那个时间进行交易会发生什么。因此，我们必须确保在任何时候我们的交易算法都不能接收*来自未来*的数据。

让我们再次看看前面的例子。想象一下，我们在 13:32 时模拟了我们的交易算法的行为。在这个步骤中，我们和算法可能知道的信息只是当时的收盘价是 1.12883。我们*不能*知道——算法*也不能*知道一分钟后的收盘价*将会是*1.12894*。然而，如果你将价格存储在列表（或 pandas DataFrame）中，很容易通过索引引用未来的价格。所以，我可能写出如下这样的代码（以下示例假设`current_position`是遍历数据集的指针，而`price_data`是数据集本身）：

```py
current_position = x
if price_data[x + 1] > price_data[current_position]:
      order.buy(market)
if price_data[x + 1] < price_data[current_position]:
      order.sell(market)
```

在此代码中，我们假设`buy`和`sell`方法分别生成买入和卖出订单。如果我们使用此代码运行模拟，我们将拥有*100%的盈利交易*。没有任何一笔会亏损，因为我们比较的是*未来的价格*（第 2 行和第 4 行）与模拟时刻存在的真实价格。在我们的例子中，这意味着在 13:32 时，我已经*知道 13:33 时的价格*并将其与当前价格进行比较。好吧，如果我真的能知道的话...无论如何，没有人能预知未来，你应该确保你的算法也不例外。

注意

总是要确保你逐个引用价格，不要提前查看。使用队列或引用时间戳，但始终避免通过索引引用数据。

好吧，我们现在至少从表面上看知道了如何与市场沟通，如何检索数据并确保其一致性，甚至如何避免系统交易策略开发者可能在交易逻辑中犯的最大错误。现在，我们应该能够发送交易订单并保护自己免受众多不利情况的影响。

# 风险管理——您的安全带

在您的算法生成交易信号后，它应该通过风险管理。当交易逻辑回答“是否交易”的问题时，风险管理回答另一个问题：应该投入多少？

简而言之，风险管理包括分析每笔交易可能的最大不利波动、账户规模、杠杆和保证金作为风险财务组成部分，以及宏观经济因素和政治事件作为外部和非市场风险。仅举一例，在 2015 年 1 月瑞士国家银行决策之前或 2016 年美国总统选举之前关闭交易是明智的。

风险管理的话题非常广泛，我们将在学习更多关于交易策略和订单类型之后，在*第十章**，Python 中的订单类型及其模拟*中详细讨论这个问题。

# 订单——确保您被正确理解

最后，但同样重要的是，您的交易应用将有一个订单模块。此模块执行以下功能：

+   它保持与执行服务器的连接，使其保持活跃。

+   它将风险管理模块传递的交易信号转换为实际订单——使用 FIX 或任何专有 API。

+   它处理来自经纪人或交易场所的所有类型响应。这些响应范围从仅仅是*OK*到部分成交和拒绝。

+   它决定在您的订单被拒绝或部分成交的情况下应采取什么措施。

+   如果交易逻辑青睐它，它会重新提交全部或部分订单。

您可能已经注意到，订单模块的一个职责是维护连接——就像数据处理模块一样。是的，这里没有错误，一个交易应用使用**不同**的连接来处理数据和订单是完全正常的。此外，当数据从数据供应商那里获取，而订单在交易所执行，或者从交易所获取并执行与市场做市商等时，这种情况非常常见——任何可能的组合。因此，订单模块也维护连接，因为这种连接是不同且独立的。

与风险管理一样，我们将在*第十章**，Python 中的订单类型及其模拟*中，与风险管理一起详细讨论订单问题。

# 摘要

在本章中，我们学习了如何连接到经纪商或数据供应商，检索实时市场数据，了解这些数据质量的要求，以及了解我们未来交易应用将包含的五个核心逻辑块。

在下一章中，我们将继续讨论如何高效地处理*历史*市场数据的细节，因为这正是研究和开发阶段所必需的。
