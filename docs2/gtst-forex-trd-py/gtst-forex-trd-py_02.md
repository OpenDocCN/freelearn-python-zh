# 2

# 使用 Python 进行交易策略

Python 已经成为金融行业中广泛应用的开发语言的首选，并成为交易策略开发研究阶段的事实上的行业标准。然而，就像任何其他语言或，更确切地说，编程生态系统一样，它有其优点和缺点。因此，就像任何工具一样，了解其优点和缺点对于正确使用工具至关重要（比如说，不要试图用显微镜敲钉子）。

在本章中，我们不仅将考虑使用 Python 进行算法交易策略开发，还将学习研究和开发过程中的基本步骤，讨论市场建模和基于事件交易之间的区别，并指出在研究和开发过程中最常犯的错误。最后，我们将看到使用 Python 进行算法交易的局限性，以确保我们的期望始终与现实相符。

我们将快速深入探讨，不仅仅是对 Python 的表面概述，看看 Python 最强大的优势，如原生语言结构和高效的**面向对象编程**（**OOP**），如何帮助使代码透明，并保持交易应用架构的模块化、灵活性和可扩展性。

到本章结束时，您将熟悉交易和算法交易的关键概念、Python 的应用以及用于交易策略研究和开发的多种**集成开发环境**（**IDE**），并且您将了解使用 Python 效率不高的限制。

在本章中，我们将涵盖以下主题：

+   使用 Python 进行交易策略开发的优点

+   建模——预测未来并不一定意味着实际效益

+   纸质交易和回测——系统交易员风险管理的一个基本部分

+   使用 Python 进行交易策略开发的缺点

+   真实交易——Python 面临的限制

# 技术要求

您需要 Python 3.10 或更高版本才能运行本章中的代码。

# 使用 Python 进行交易策略开发的优点

当我们今天说*Python*时，我们很可能不仅指的是最灵活的面向对象编程语言，还包括最强大和方便的交互式集成开发环境（IDE），如 Spyder 或 PyCharm，以及大量扩展此语言的库，使其几乎适合任何应用和基础研究的领域，从医学到天文学。在数字起决定性作用的金融行业中，Python 生态系统已经成为事实上的标准，这并不令人惊讶。

使用 Python 进行交易策略开发的优点是显而易见的，我们将在以下几节中详细探讨这些优点。

## 内存管理

Python 是少数具有强大内置内存管理服务（如垃圾回收和引用计数）的解释器之一。本质上，这意味着你不必关心你工作中遇到的任何复杂对象以及你的代码处理的数据量。当然，这大大提高了开发速度，尤其是当你处理大量数据集时——交易应用处理大量数据集。

## 交互式计算

Python 是一种解释型语言，这意味着两件重要的事情。

首先，你可以在任何时候停止代码的执行并检查运行时的环境，包括所有变量、函数和对象——这对于调试来说非常方便。

其次，你可以以交互式的方式使用 Python。这意味着在所有类 Unix 系统中，我们在控制台中运行 Python，可以逐个发送命令并立即从解释器那里获得响应。如果你开发交易应用，这允许你在将它们集成到最终代码之前，快速在小数据集上测试一些模块。这也允许你快速可视化数据集的任何部分，而无需重写和重新运行任何代码，这对于开发任何处理时间序列的应用程序来说是无价的。

在原生控制台中工作不如在 IPython 中方便——IPython 是一个支持内省、富媒体、语法高亮、自动补全和历史记录的命令行。作为 2001 年发布的一个开源项目，IPython 迅速将 Python 转变为 Matlab 的直接竞争对手，多亏了开源状态和庞大的贡献者社区，我们可以说，如今 Python 已经赢得了这场竞争。2014 年，一个基于 IPython 的衍生项目启动，其理念是开发一个通用的交互式计算环境，不仅适用于 Python，也适用于其他语言。这个项目被称为 Jupyter，如今这可能是最受欢迎的笔记本式交互计算环境。有时 Jupyter 甚至被认为是 IPython 的替代品；然而，这并不完全正确。DataCamp 发布了一篇优秀的文章，解释了两者之间的区别：[`www.datacamp.com/blog/ipython-or-jupyter.`](https://www.datacamp.com/blog/ipython-or-jupyter)

)

## 集成和路由的便捷性

如果前两个优势并非特定于交易应用的开发，那么使 Python 成为交易研究和开发首选语言的是，你可以轻松地在*研究模式*和*生产模式*之间切换。

如果你已经仔细规划了你的数据结构和代码（这正是我们将在整本书中学到的），那么交易应用（我们在上一章中制定的）的所有基本模块都将独立且可替换。这对作为开发者的你有什么优势？优势如下：

+   它允许你使用历史数据开发交易逻辑，然后使用来自经纪商的实时流替换数据源。

+   这允许你通过模拟订单执行来微调和调试你的应用程序，并让你使用与开发时相同的代码切换到生产环境。这降低了出错的风险。

+   这允许你通过添加更多的执行场所、协议、API 和交易账户来扩展你的交易业务，同时保持其余代码不变。

此外，得益于 Python 环境的交互性，你甚至可以手动干预交易过程。例如，在紧急情况下，你可以发送一个`FIX`消息来关闭所有未平仓的头寸。当然，这*不是*最佳实践，甚至不是可以推荐的做法，但知道即使在最糟糕的意外情况下，你也能直接从熟悉的开发环境中采取紧急行动，这有助于增加安心感。

## 原生语言结构 - 列表和字典

使用 Python 进行数据处理的一个关键优势是它原生实现了两个强大的结构：列表和字典。

交易应用处理时间序列数据，拥有方便的工具来读取、访问、压缩和处理这些数据至关重要。使用列表、字典以及对象变得相当高效。让我们考虑一个例子。

假设我们有一些 tick 数据，并希望将其转换为 OHLC 数据点（有关 OHLC 的解释，请参阅上一章）。在交易中，这种数据点通常被称为*条形图*，我们可以如下定义：

```py
class OHLC:
        def __init__(self, O, H, L, C):
                self.open = O
                self.high = H
                self.low = L
                self.close = C
```

然后，我们可以为我们的条形图创建存储：

```py
class time_series:
        def __init__(self):
                self.ts = []
                self.last = -1
        def add(self, bar):
                self.ts.append(bar)
        def read(self):
                self.last += 1
                return self.ts[self.last]
```

在这里，我们可以定义一个本地的 Python 列表，用于存储 OHLC 条形图和`self.last`指针，该指针指向列表中最后读取的元素。然后，我们将添加`read`方法，该方法返回`self.last`指针指向的元素。

然后，在生产代码中，我们不是通过索引检索 OHLC 条形图，如下所示：

```py
data = time_series()
i = some_index
price = data.ts[i].close
```

我们将检索收盘价，而不直接引用索引：

```py
data = time_series()
price = data.read().close
```

这极大地简化了处理时间序列（或任何数据序列）的工作，因为我们不再需要在主代码中存储索引，更重要的是——我们减少了*提前查看*的风险。提前查看是交易策略开发中常见的错误。在进行回测时，策略代码必须只使用每个模拟交易过去和当前的价格数据。例如，如果策略模拟了 4 月 1 日的市场，它就不应参考 4 月 2 日的价格数据。同样适用于任何时间分辨率，甚至到毫秒。在研究阶段使用未来数据的策略通常无法在实际生活中工作（参见*第五章**，使用 Python 检索和处理市场数据,* 对进行回测时正确处理数据的详细讨论）。Python 允许你避免此类关键错误的便利性无法过高估计，因为这些错误可能会造成真实和重大的经济损失。

字典为在 Python 中存储和处理序列数据提供了另一种方式。由于每个数据点，无论是 tick 还是 bar，都有一个时间戳，我们可以使用时间戳作为字典中的键：

```py
class OHLC:
        def __init__(self, dt, O, H, L, C):
                self.datetime = dt
                self.open = O
                self.high = H
                self.low = L
                self.close = C
class time_series:
        def __init__(self):
                self.ts = {}
        def add(self, bar):
                self.ts[bar.datetime] = bar
```

然后，使用以下代码通过其`timestamp`值检索特定的`close`价格将变得简单：

```py
price = data.ts[timestamp].close
```

因此，即使是本地的 Python 语言结构也提供了快速、简单且极其高效的方式来处理特定的交易数据。然而，是库使得 Python 成为定量交易的不二选择。

## 库

Python 作为定量金融和交易环境的最终成功取决于许多库，这些库今天实际上是行业标准，有时与语言本身紧密相关，以至于许多开发者甚至没有单独考虑它们。让我们来看看这些库。

### NumPy

最初于 1995 年作为 Numeric Python 发布，这个库今天几乎用于任何使用数学的应用。它正是将 Python 从一种编程语言转变为类似 Matlab 的、强大的、数值处理套件的库。

NumPy 为线性代数中的许多核心对象提供了实现，例如向量、数组和与之相关的操作。它提供了全面的数学函数、随机数生成器、傅里叶变换等。最好的是——它的核心是用 C 编写的，因此所有本地的`numpy`方法都运行得非常快。

### Matplotlib

Matplotlib 于 2003 年发布，作为 Python 和 NumPy 的通用绘图库。它识别本地的 NumPy 对象，并生成几乎任何类型图表的打印质量图像。

以下特性使得 Matplotlib 在交易应用开发中特别吸引人：

+   它会自动将数据系列缩放到适合图表，因此只需一个命令就可以轻松可视化任何市场或交易数据

+   这些图表可以嵌入，并且可以输出到 IPython 或 Jupyter 等控制台

+   图表是交互式的，因此你可以放大、缩小和拖动来探索细节，而不需要编写自己的图像处理工具。

### pandas

人们认为，**pandas**这个名字来源于计量经济学中使用的术语**面板数据**。它也可以理解为**Python 数据分析**。这是一个引入 DataFrame 概念的库。你可以将 DataFrame 视为 Python 字典、列表和数据库的混合体。它使用关键字来访问记录，但保留项目的顺序，以便可以通过索引检索数据。同时，它还具备数据库典型的程序，如制作子集或切片。

在 DataFrame 的基础上，pandas 提供了在内存结构和不同文件格式之间读取和写入数据的功能，包括 CSV、JSON、SQL 查询和表格，以及 MS Excel，几乎涵盖了数据供应商、经纪人和交易所今天使用的所有格式。

如果我们再考虑这样一个事实，即 pandas 提供了一系列强大的功能，可以重建缺失数据，生成日期时间范围，转换采样频率，支持滑动窗口统计，等等——你就会明白，你得到了开发任何类型交易应用的终极工具箱。

尽管全面介绍 pandas 的所有强大功能超出了本书的范围，但我们将考虑 pandas 在*第八章*中的一些有用应用，即*使用 Python 进行外汇交易数据可视化*。

NumPy 和 matplotlib 是 SciPy 的一部分——一个涵盖任何应用数学的综合性库，从优化和线性代数到信号处理和多维图像处理。

# 建模——预测未来并不一定意味着实际的好处。

为了保持讨论的一致性，我们需要在交易和建模之间划一条既薄又坚实的界限。有时，这两个术语会被严重混淆，不仅可能导致误解，还可能导致亏损。

建模是一种研究活动，旨在构建一个能够解释观测数据的模型。例如，托勒密提出了一个以地球为中心的太阳系模型，而尼古拉·哥白尼则提出了一个地球围绕其自身轴旋转并在椭圆轨道上绕太阳运行的模式——现在被称为日心模型。这两个模型都解释了观测到的数据：太阳看起来在地球周围移动，白天跟随黑夜，季节按顺序变化。然而，日心模型证明要精确得多，也更容易使用，因此另一个模型被废弃了。

在金融世界中，建模市场意味着找到一组能够解释观测价格行为的定量规则。乍一看，它看起来像建模任何其他物理过程，例如，同样的太阳运动。金融建模的主要问题，尤其是在交易中，是建模过程是非平稳的。

用非常简单的术语来说，一个**非平稳过程**没有恒定的均值或随时间变化的值的一致分布。这正是任何尝试使用经典统计学（从平均值到高斯分布）来计算公平价格或预测未来的任何尝试最终失败的原因。这也是为什么许多涉及机器学习元素的现代方法，尤其是基于线性回归的方法，在实际交易中也会失败的原因。

如果你想要了解更多关于非平稳过程的信息，包括它们是什么以及为什么基于统计学的成功交易如此困难，那么我建议从 Investopedia 的一个基本文章开始：[`www.investopedia.com/articles/trading/07/stationary.asp`](https://www.investopedia.com/articles/trading/07/stationary.asp)。或者，如果你在数学方面更为精通，M. B. Priestley 的《非线性与非平稳时间序列分析》是一本优秀的书籍。

回到正题——对非平稳数据进行建模不仅问题重重，而且往往提供实际上毫无用处的结果。在平稳过程的情况下，例如地球围绕太阳运行，我们可以使用我们的模型来预测未来——在绝大多数情况下都会是正确的。但是，对于非平稳过程，大多数模型将完美地解释过去的数据，即已经观察到的数据，但在预测未来的观察值时将遇到问题。因此，在我看来，市场建模领域属于学术研究，而将其用于实际主动交易是值得怀疑的。我知道存在相反的观点，但无论如何，在这本书中，我们将只关注事件驱动交易。

方法上的差异在于，在市场建模中，我们试图预测未来的价格变动，然后根据预测做出交易决策；而在事件驱动交易中，我们等待某个事件发生，然后立即通过下单来做出反应。例如，如果我们运行套利策略，那么我们会等待资产定价错误的（罕见）时刻。如果我们运行方向性交易策略，我们会等待某些经济新闻发布或价格开始快速变化的时刻，或者相反——当市场缓慢时，但无论如何——策略会对市场当前正在发生的事情做出反应，而不进行任何*预测*或*预测*。

### scikit-learn

尽管如此，一些在市场建模中传统上使用的库存，尤其是在机器学习中，作为数据处理的一部分，在事件驱动交易策略中可以相当有用。因此，我们应该至少提到一个 Python 库，它是数据科学事实上的行业标准。

**scikit-learn** 或 **sklearn** 是一个包含数据科学和机器学习中常用技术实现的库。它包括分类、回归、聚类和预处理等易于使用的实现，以及模型选择算法（交叉验证、网格搜索等）。拥有这样一个强大的库也增加了 Python 作为开发交易策略首选生态系统的选择。

现在我们已经熟悉了 Python 和众多库提供的强大功能，是时候深入挖掘任何类型的算法交易策略典型的研发过程了。

# 模拟交易和回测——系统交易者风险管理的重要组成部分

想象一下，我们已经使用了 Python 的所有功能并开发了一个交易应用。现在怎么办？是时候立即推出它并尝试赚钱了吗？不！在跳入泳池之前，确保里面有水是至关重要的，在我们的情况下，在将应用投入生产之前，确保它至少在理论上能够赚钱是至关重要的。

在本节中，我们将探讨模拟交易和回测——系统交易的两个基石，帮助我们了解新开发策略的潜在陷阱。我们将学习关于历史数据、交易模拟和订单处理，同时也会快速考虑一些现成的包，这些包可以简化这一部分的发展过程。

## 模拟交易和回测是什么？

在我们开发了一个交易算法，连接到数据源，并准备好发送订单后，是时候测试我们的设置了。这样的测试验证以下关键点：

+   交易逻辑的一致性

+   风险管理

+   订单界面和错误处理

如果使用过去的市场数据（通常称为**历史数据**）进行测试，并将订单发送到模拟引擎，那么这被称为**回测**。如果使用实时市场数据进行测试，并将订单发送到 UAT 环境（由经纪人、交易场所或再次本地模拟提供），那么这被称为**模拟交易**。

回测的目的是查看我们的策略在过去各种市场情况下的反应。这是绝对必要的，因为所有系统交易都是围绕这样一个想法建立的：如果过去发生了某种情况，那么它很可能会在未来重复。例如，如果非农就业人数远低于预期，股票价格会在一段时间内下跌。这一点得到了多年历史数据的证实。因此，我们可能会假设下次它太低时，股票价格会再次下跌。

纸化交易是必不可少的，因为这可能是唯一能够证明策略能够在实践中赚钱的测试，而不仅仅是理论上。还记得我们在前几节中关于建模和预测的讨论吗？构建一个在历史中完美交易但无法在生产中使用的模型是可能的（并且并不真的困难）。所以，任何交易应用都需要一定时间的纸化交易来检查它是否能在现实生活中赚钱。

## Python 中的回测和纸化交易

Python 本身非常适合回测和纸化交易，因为它具有交互式计算的能力以及现成的数据处理和可视化库。我们可以编写一个订单执行模拟器，并在数据集中收集关于我们交易回报的累积数据——这需要一些时间和努力，但分析起来却非常简单：从统计方法到可视化表示，这最广为人知的是**权益曲线**。所有这些都可以通过在控制台中发出单个命令进行交互式完成。

在这本书中，我们将重点关注交易应用架构，因此主要考虑基于原生 Python 结构的解决方案，因为我们的目标是理解开发交易应用的所有阶段，直至核心逻辑结构。然而，正如数据处理的情况一样，存在开源和免费的库和框架，它们简化了 Python 中的回测，使得开发交易策略更具吸引力。对任何这些产品的详细审查或教程都不在本书的范围之内，但一旦你理解了研究和开发过程，你将能够轻松地将它们中的任何一个整合到你的工作流程中。

### PyAlgoTrade

PyAlgoTrade 是一个框架，你可以用它来开发功能齐全的交易策略。它是一个非常成熟的产品，因为它是这一类中的第一个之一，它仍在积极维护和开发中。它遵循设计交易应用的模块化理念。因此，你可以首先开发一个策略，对其进行回测，然后切换数据源到实时数据，进行纸化交易，最后将输出从模拟订单执行切换到你选择的经纪商，进行实时交易。它支持免费的数据源，如 Yahoo! Finance 和 Google Finance，但如果你想要使用 PyAlgoTrade 进行外汇交易，你必须从第三方来源获取数据，将其保存为 CSV 格式，然后才能使用这个框架。

需要注意的是，PyAlgoTrade 支持实时 Twitter 事件处理，这意味着你可以为你的策略使用基于非价格数据的规则（例如，“当欧洲央行成员说些什么时，卖出*欧元”*）。

你可以在以下位置找到项目页面：[github.com/gbeced/pyalgotrade.](https://github.com/gbeced/pyalgotrade)

)

### bt – Python 的回测

bt 是另一个用于回测的框架，它更专注于投资组合交易（并行运行许多不同的策略和交易许多不同的市场）。

这种方法使 bt 接近了曾经流行的各种交易策略可视化构建器。当然，这大大加快了开发过程，因为你不需要在低级别上编写算法；你只需从库存中选择最合适的即可。然而，这种优势显然也是一个缺点，因为你被限制在只能使用框架开发者认为合适的工具。

然而，好消息是，与可视化构建器不同，你可以在 bt 中修改任何内容并编写自己的*构建块*，这给你带来了几乎与从头开始编写自己的策略相同的自由度。

bt 还提供了一套全面的统计工具，用于分析策略或投资组合的表现，并快速尝试各种交易算法的组合，以发现最适合特定市场的算法。

这个框架主要关注回测和纸面交易，所以如果你计划从同一应用程序中实时交易，你需要开发自己的订单生成和提交模块。

你可以在以下位置找到项目页面：[pmorissette.github.io/bt.](https://pmorissette.github.io/bt)

)

### Zipline

Zipline 可能是交易策略最知名的研究和开发工具。它由 Quantopian 开发，这是一个著名的项目，它为任何开发者提供了一个机会，通过提供开发交易策略的环境，使他们有机会成为量化交易员。它甚至为他们分配了一些资金，以防策略表现得到证明是可接受的。

Zipline 可以用作框架和独立应用程序，是一个具有纸面和实时交易能力的算法交易构建器和模拟器。你可以通过基于浏览器的 iPython Notebook 界面与之交互。

Zipline 附带了 10 年分辨率为 1 分钟的美国股票历史数据。这并不多，而且绝对与外汇交易无关，但它支持导入各种格式的数据，因此你可以使用第三方数据，例如来自你的经纪商。

由于 Zipline 是作为 Quantopian 生态系统的一部分设计的，其实时交易功能有限。

尽管 Quantopian 最初取得了成功，媒体上也有相当多的炒作，但在 2020 年，该公司破产并关闭了所有业务。Zipline 随后被卖给了 Robinhood。但新所有者对产品的开发兴趣不如其创造者，因此该项目现在主要以爱好者支持的分支形式存在，“官方”版本不再得到支持。

你可以在以下位置找到项目页面：[zipline.io.](https://zipline.io)

)

你可以在以下 GitHub 位置找到源代码：[github.com/quantopian/zipline.](https://github.com/quantopian/zipline)

)

### QSTrader

QSTrader 是由 QuantStart 开发的。它再次是一个具有实时交易功能的研发框架。

该框架严格遵循我们在上一章中看到的构建交易应用的模块化原则，这也是本书的主要焦点。这有助于简化一般开发过程——**研究** | **回测** | **纸面交易** | **实时交易**——因为负责策略逻辑的代码保持不变。

目前，QSTrader 支持基于 bar 的数据，但也可以使用 tick 数据。

您可以在以下页面找到该项目：[`www.quantstart.com/qstrader/.`](https://www.quantstart.com/qstrader/)

)

您可以在以下 GitHub 源代码中找到该项目：[github.com/mhallsmoore/qstrader.](https://github.com/mhallsmoore/qstrader)

)

# 在交易策略开发中使用 Python 的缺点

在赞扬了 Python 在算法交易中的优势之后，现在是时候提到它的重要缺点了。正如许多强大而通用的生态系统一样，这些缺点是其优势的另一面。

无论如何，Python 最令人烦恼的事情是速度，或者更确切地说，是它的缺乏。部分原因是 Python 是一种解释型语言；然而，对整体缓慢贡献更大的因素是弱类型和我们在开发代码时非常喜爱的相同高级内存管理。

对于不熟悉内存管理的读者，我建议从一篇简单的文章开始，例如[`www.geeksforgeeks.org/memory-management-in-python/`](https://www.geeksforgeeks.org/memory-management-in-python/)，该文章还提供了进一步阅读的参考。简而言之，如果语言减轻了程序员声明变量的负担，那么每次引用变量时，都会执行一系列程序来确保引用是正确的。当然，这会减慢整个代码的执行速度。

交易策略开发的主要部分，在代码执行速度不足的情况下变得明显，就是回测阶段。在回测过程中，我们应该以足够细粒度的分辨率处理所有历史数据，对于特定的策略来说，有时这可能低至原始的 tick 数据。如您所记得，这类数据的数量可能达到每秒数千 tick，所以想象一下我们会在循环中重复多少次整个策略逻辑来处理去年收到的每个 tick！

但在研发阶段，这种缓慢可能只是令人烦恼：确实，没有人愿意等待几分钟、有时是几个小时，甚至在最糟糕的情况下是几天，才能看到他们策略的理论性能。然而，等待时间过长是一回事，而在生产环境中无法进行交易则是完全不同的事情，而实时交易正是 Python 面临其极限的地方。

# 实时交易——Python 面临的极限

如此一来，纯 Python 编写的交易应用不适合任何假设从收到市场数据到发送订单的时间最小化的实时交易活动。因此，传统的套利和许多高频交易活动（有时建议每秒发送数千个订单）肯定不适合 Python。

此外，即使是来自自动化内存管理的*慢速*交易策略也存在另一种风险。我们已经知道，交易策略依赖于价格时间序列，处理的市场数据量可能相当大。尽管原生 Python 和第三方库如 pandas 提供了确保数据持久性的数据结构，但在高吞吐量的交易环境中，实时更新数据可能会变得有问题。

有多种方法可以在一定程度上加速 Python。例如，有静态编译器如 Cython ([`cython.org`](https://cython.org))，它可以帮助更快地执行 Python 代码，并为 Python 编写 C 扩展。还有运行时翻译器如 Numba ([`numba.pydata.org`](https://numba.pydata.org))，它也能以与 C 相当的速度执行 Python 代码。此外，使用`numpy`结构代替 pandas 也有帮助，因为尽管在某些方面会降低便利性，但我们可以获得速度上的提升。然而，在这本书中，我们不会真正关注这个问题，因为我们从更少延迟关键、更简单的策略开始，这些策略有助于我们理解交易应用的一般开发。

总结来说，我们可以这样说，Python 生态系统是研究和开发任何类型交易策略的绝佳工具。如果交易策略满足以下两个标准，它也可以用于实时自动化交易：

+   它不需要接收大量实时市场数据

+   它对内部延迟（数据接收和订单提交之间的延迟）不敏感

在这本书中，我们将主要关注使用 Python 进行研究和开发，以及模拟交易。

# 摘要

在本章中，我们考虑了使用 Python 进行算法交易策略研究和开发的优缺点。我们考虑了使用原生 Python 数据结构处理市场数据的各种选项。我们了解了各种生态系统、第三方库和环境，它们可以加快开发过程。我们还了解了开发过程中最重要的阶段和旨在确保策略在实时市场中具有盈利潜力的基本程序。

然而，与任何领域的任何项目一样，在我们开始实际编码之前，我们应该熟悉主题。在我们的情况下，那就是市场本身，它的基本要素、结构以及组织，这些都是我们将考虑的因素，以便了解它是如何运作的，以及我们在构建稳健的交易应用时应该考虑什么。这正是我们将在下一章中要做的。
