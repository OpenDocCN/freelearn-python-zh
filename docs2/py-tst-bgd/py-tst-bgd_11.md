# 附录 A. 突击测验答案

# 第二章

## 突击测验 – doctest 语法

1.  测试表达式总是以 `>>>` 开头。

1.  行的延续始终以...开始

1.  预期输出从表达式之后立即开始，直到下一个空白行。

1.  通过使用规范化空白指令。

1.  doctest 忽略`Traceback (most recent last call)`之间的所有内容。

1.  同一文本文件中的所有后续代码都可以看到这个变量。

1.  我们关心这一点，因为测试应该彼此独立，如果两个测试使用相同的变量，它们可能会相互影响结果。

1.  我们可以用省略号（`...`）在预期输出中表示该部分。

# 第三章

## 突击测验 – 理解单位

1.  3 个单元存在：`__init__`、`method1`和`method2`。

1.  `method1`和`method2`都假设`__init__`的正确操作，并且`method2`还假设`method1`的正确操作。

1.  对`method2`的测试需要使用假的`method1`。

## 突击测验 – 设计期间的单元测试

1.  我们现在构建的测试是整个开发过程的基础。我们在这里做出的选择将影响之后的一切；正确地完成这一点很重要。

1.  如果编写规范的人与编写代码的人不是同一个人，那么编码者尽早参与其中，以确保整个过程在可以有用地完成的范围之内是很重要的。如果规范制定者是编码者，那么这个问题就是学术性的。

1.  最大的优点是，测试允许在真正实现它们之前，以测试驱动的方式测试代码的接口。主要的缺点是，测试可能会锁定一个可能从进一步演变中受益的设计。

## 突击测验 – 单元测试

1.  测试应该在将要测试的代码之前编写，基于对该代码的期望。

1.  是的。

1.  应尽可能多地运行测试。在编码时定期运行测试，以及在将代码存储到版本控制系统之前运行测试非常有用。

1.  你将花费大部分时间使用测试的输出作为工具，帮助你找到和修复代码中的错误。

# 第四章

## 突击测验 – Mocker 使用

1.  `IN`。

1.  将`None`作为上限传递。

1.  它检查模拟对象是否确实以我们描述的方式被使用。

# 第五章

## 突击测验 – 基本 unittest 知识

1.  ```py
    class test_exceptions(TestCase):
     def test_ValueError(self):
      self.assertRaises(ValueError, int, '123')
    ```

1.  使用`assertAlmostEqual`方法。

1.  如果你没有更适合你需求的更专业化的断言，你会使用`assertTrue`。如果你需要表达测试失败的复杂条件，以至于它们不适合放入一个单一的布尔表达式中，你会使用`fail`。

## 突击测验 – 文本固定装置

1.  为每个测试提供一个相同、独立的运行环境。

1.  将`setUp`和/或`tearDown`方法添加到`TestCase`子类中。

1.  测试固定装置可以由一个或两个方法组成，所以答案是肯定的。

# 第六章

## 突击测验 – 使用 Nose 进行测试

1.  在你的 Nose 配置文件中设置`processes=4`。

1.  在 Nose 命令行中添加`--include="specs"`。

1.  `unit_tests`、`TestFiles`和`test_files`将被识别。

# 第七章

## 突击测验 - 测试驱动开发

1.  由于可测试的规范没有遵循单元测试规范，它没有满足我对单元测试的需求。我不得不编写额外的测试来满足这一需求。这样做是可以的，只要我不在真正的单元测试上节省。

1.  绝对不是。实际上，尽可能频繁地运行你的测试是可取的。

1.  你失去了在你将代码的计划接口固定之前对其进行测试的机会。你失去了在没有受到你第一次实现的实际行为污染的情况下写下你的期望的机会。你失去了让计算机告诉你需要做什么来创建一个有效实现的机会。

# 第八章

## 突击测验 - Twill 语言

1.  最后被`formvalue`命令触及的任何形式都会被提交。

1.  `notfind`命令。

1.  Twill 将报告整个脚本失败，并且不会执行任何后续命令。

## 突击测验 - 浏览器方法

1.  你传递给参数的值将与表单的名称、编号和 ID 进行匹配。

1.  `clicked`方法将模拟输入焦点移动到网页上的新控件。

1.  `code`命令检查响应代码，如果它与预期值不匹配，则抛出异常。`get_code`方法简单地返回响应代码。

# 第九章

## 突击测验 - 集成测试绘图

1.  如果这些单元之间没有关联，它们就不会存在于同一个类中。通过将它们视觉上分组到它们的类中，我们可以利用这种关系使我们的图表更容易理解。

1.  通常，这可以让我们在以后避免麻烦。在某一层面上相互关联的事物往往在更高层面上是同一事物的组成部分。

1.  在测试中，就像在化学中一样，一次只改变一件事很重要。如果我们一次性拉起两个以上的东西，我们就改变了不止一件事，因此我们可能会失去追踪我们找到的任何问题的来源。

## 突击测验 - 编写集成测试

1.  在最小圆圈中的那些，尤其是如果它们没有任何线条指向其他圆圈的话。

1.  从包含该代码的最小圆圈开始，逐步构建，直到你准备好将其与之前的代码集成。

1.  当我们进行单元测试时，即使是同一类的其他实例也被模拟了；我们关心的是这段代码是否按预期执行，而不涉及任何其他东西。现在我们正在进行集成测试，我们需要测试同一类的实例是否正确地相互交互，或者当它们被允许从一个操作保留状态到下一个操作时，它们是否与自己正确交互。这两种测试覆盖了不同的事情，所以我们需要两者都有是有道理的。

1.  系统测试是集成测试的最后阶段。这是一个涉及整个代码库的测试。

# 第十章

## 突击测验 - 代码覆盖率

1.  这意味着在运行测试时，大部分代码库都被执行了。

1.  那将是一个糟糕的想法，因为覆盖率并不能告诉你测试的质量。它是用来帮助你找到需要测试的东西，而不是用来告诉你测试是否好。

1.  覆盖率报告提供最有用的信息是未执行的代码行列表，因为那正是让你知道你可能需要添加哪些新测试的原因。

## 突击测验 - 版本控制钩子

1.  它可以确保你的测试经常被执行，并且可以在你检查有缺陷的代码时立即让你意识到。

1.  不要让检查有缺陷的代码变得不可能。不要让版本控制钩子成为公司政策的问题。

1.  在集中式版本控制系统中，钩子通常由系统管理员控制，并在服务器上执行。在分布式版本控制系统中，钩子通常由用户控制，并在用户的计算机上执行。
