# 第九章。异常

Python 处理意外情况的一般方法是通过引发**异常**。想法是操作要么正常完全工作，要么引发异常。在某些语言中，使用复杂的数值状态码来指示成功。在 Python 中，假设成功；如果有问题，会引发异常来指示操作未成功。

Python 程序的所有方面都可以引发异常。所有内置类都涉及各种意外情况的异常。许多库包定义了自己的独特异常，这些异常扩展了内置异常层次结构。

我们首先看看异常背后的基本概念。Python 有一些我们将使用的语句。`raise`语句创建一个异常对象。`try`语句允许我们处理异常。

`try`语句中的`except`子句用于匹配引发的异常类。在一些编程语言中，我们严格匹配特定的异常类。在其他情况下，我们使用更不具体的异常类或异常类列表，以统一的方式处理各种异常。

# 核心异常概念

异常背后的核心概念可以总结为：“当不确定时，引发异常”。在典型情况下，每个 Python 函数或方法都会返回一个值或有一些文档化的副作用。对于所有不在“成功路径”上的情况，Python 的方法是引发异常。

尽管大多数异常描述了错误情况，但异常并不一定是错误。它只是给定函数无法处理的异常情况。例如，当迭代器无法再产生结果项时，会引发`StopIteration`异常。这是迭代器对象生命周期中仅发生一次的异常情况。

当处理数字时，作为第二个例子，除以零是异常的。如果我们除以任何其他值，成功的路径将引导我们得到结果。虽然可以通过构造**非数字**（**NaN**）值作为除以零的结果，但让除法运算符引发`ZeroDivisionError`异常更简单——也更通用。除以零不是正常或预期的设计。几乎普遍来说，除以零表示以下情况之一：

+   **设计问题**：零是一个可能的情况，但设计没有处理这种情况。`ZeroDivisionError`异常是意外的。设计问题的根本原因可能是对需求理解不足：可能是匆忙整理的故事，也可能是对问题域理解的其他问题。

+   **实现问题**：零的出现是因为一个错误。`ZeroDivisionError`异常同样意外。根本原因可能包括单元测试不足。

+   **应用误用**：用户提供了导致除以零的输入。整体应用可以提供一个有用的错误消息并等待不同的输入。或者，整体应用可能可以使用更适合输入值的另一种计算方法。

异常在其含义上可以是深刻的或浅显的。

当处理字符串时，例如，有许多情况下会引发异常。也有一些情况下，返回状态码而不是抛出异常。我们可以比较`str.find()`和`str.index()`在方法上的两个不同之处：

```py
>>> "abc".index("x")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: substring not found

>>> "abc".find("x")
-1.
```

第一个例子显示了`index()`方法，当子串找不到时引发异常。第二个例子显示了`find()`方法，当子串找不到时返回一个特殊数字。

异常被广泛使用。在 Python 中，状态码很少被使用。

## 检查异常对象

当异常被抛出时，它涉及处理方式的改变以及一些关于条件的数据。异常是更通用类的一个实例。我们将一般地讨论`EOFError`异常，而不强调给定的异常是`EOFError`异常类的实例。

与异常关联的数据可以包括根本原因异常和一系列额外的参数。有时这些额外的参数仅仅是一个字符串消息。一些异常可能有更复杂的参数集合。

还有一个包含调用栈的 traceback 对象。这确定了引发异常的函数，调用该函数的函数，以及等等，直到最初启动一切的函数。这个 traceback 信息在一个特别命名的属性`__traceback__`中。

我们可以通过几种不同的方式创建异常：

+   我们可以创建异常对象，稍后抛出它们以表示问题：

    ```py
    obj = Exception("some message")
    raise obj
    ```

+   我们可以一次性创建并抛出异常：

    ```py
    raise Exception("Some Argument", "additional details")
    ```

+   我们可以创建一个封装根本原因异常的异常：

    ```py
    raise MyError("problem") from some_exception
    ```

在最后一种情况中，当一个异常封装了根本原因时，根本原因信息在一个名为`__cause__`的属性中。

# 使用 try 和 except 语句

当异常被抛出时，普通的顺序语句执行停止。下一个顺序语句不会执行。相反，会检查异常处理程序以找到与给定异常类匹配的`except`子句。这个搜索从当前函数开始，沿着调用栈向下到调用它的函数。如果找到一个与异常匹配的`except`子句，那么在`except`子句中继续普通的顺序执行。当`except`子句完成后，`try`语句也结束了。从那里开始，正常的顺序语句执行在`try`语句之后继续。

如果没有`except`子句与给定的异常匹配，则会打印异常和跟踪信息。处理停止，Python 退出。通常，退出状态是非零的，表示 Python 程序异常结束。

函数内部的`try`语句看起来像这样：

```py
def clean_number(text):
    try:
        value= float(text)
    except ValueError:
        value= None
    return value
```

我们定义了一个将文本转换为数字的函数。我们将静默`ValueError`异常，并返回`None`对象而不是引发异常。我们可能会在清理 CSV 文件时使用它，以便将没有正确数值的单元格替换为`None`对象。

当我们将它应用于数字时，我们可以看到它的运行情况，如下所示。

```py
    >>> row = ['heading', '23', '2.718']
    >>> list(map(clean_number, row))
    [None, 23.0, 2.718]
    >>> clean_number("1,956")
```

在这个例子中，我们将`clean_number()`函数应用于 CSV 读取器的数据行。示例数据行显示了快乐路径和异常路径。在快乐路径上，两个数字从字符串转换为正确的浮点值。在异常路径上，不正确的文本被转换为`None`。

我们还包含了一个处理不好的测试用例。这个类似数字的字符串"`1,956`"变成了`None`。我们可能希望即使有嵌入的逗号，也能将其转换为正确的数字。我们可以看到，简单的`except`子句并没有真正完成我们希望它完成的全部工作。

注意，一些以财务为导向的电子表格值应该转换为`Decimal`值而不是`float`值。我们可以创建一个高阶函数，该函数将使用`float()`函数或`Decimal()`函数（或任何其他转换函数）来创建所需类型的值。

这里有一个包含两个`try`语句的修订版本：

```py
from decimal import Decimal,  InvalidOperation
def clean_number3(text, num_type=Decimal):
    try:
        value= num_type(text)
    except (ValueError, InvalidOperation):
        text= text.replace(",","").replace("$","")
        try:
            value= num_type(text)
        except (ValueError, InvalidOperation):
            value= None
    return value
```

在我们这个数字清理函数的版本中，我们有一个额外的参数`num_type`，它有一个要应用的转换函数。我们提供了一个默认值`Decimal`，因此它是可选的。函数的主体与上一个版本相同。我们已经更新了第一个`except`子句，以进行更复杂的回退处理。这种更复杂的处理包括创建一个新的字符串，其中不包含常见的污染数值数据的`","`或`"$"`字符。

如果将这个第二个字符串转换为数字，我们将返回一个有用的数值结果。如果这个修订后的字符串不是数字，我们将陷入困境，被迫返回`None`对象。

### 注意

作为练习，读者可以创建一个算法将单词转换为数字作为回退。将"twenty one"转换为 21。英语等语言复杂度使得这是一个有趣的挑战。

## 使用嵌套`try`语句

`clean_number3()`函数展示了我们可以嵌套`try`语句的两种方式之一。在这种情况下，`try`语句嵌套在单个函数内部。如果在内部`try`语句中引发异常，则首先检查内部`try`语句的`except`子句以匹配异常。然后检查外部`try`语句的`except`子句。如果没有这些匹配，则检查调用此函数的函数。

考虑以下例子：

```py
>>> from fractions import Fraction
>>> clean_number3(',2/0,', Fraction)
```

这将生成一个跟踪输出，显示嵌套`try`块的行为：

```py
Traceback (most recent call last):
  ...
ValueError: Invalid literal for Fraction: ',2/0,'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  ...
ZeroDivisionError: Fraction(2, 0)
```

我们省略了一些行号细节，以关注消息的相关部分。第一个异常是在第一次尝试应用`Fraction(',2/0,')`时引发的。这引发了一个`ValueError`异常，使我们偏离了快乐路径。Python 在`except`子句中继续顺序执行。这创建了一个新的字符串，其中移除了`","`字符。第二次转换尝试不会引发`ValueError`异常，而是引发`ZeroDivisionError`异常。

内部`try`语句没有`except`子句来匹配此异常。然后 Python 必须搜索外部`try`语句的`except`子句以查找匹配的异常。由于外部`try`语句不匹配异常，整个脚本以未处理的异常结束。

更常见的情况是在单独的函数中包含`try`语句。嵌套是通过函数调用栈发生的，而不是单个语句块的结构。以下是一个调用我们的`clean_number3()`函数以创建一排`Fraction`对象的函数。

```py
def fraction_row(row):
    try:
        return [clean_number3(item,Fraction) for item in row]
    except (TypeError, ZeroDivisionError):
        return [None for item in row]
```

此函数包含另一个`try`语句。当此函数调用`clean_number3()`时，调用栈将包括`fraction_row()`和`clean_number3()`。如果`clean_number3()`函数引发未处理的异常，Python 将向下移动调用栈，并在此`try`语句中搜索匹配的`except`子句。

# 在`except`子句中匹配异常类

在前面的例子中，我们展示了两种`except`子句的类型：

+   `except SomeException:`

+   `except (OneException, AnotherException):`

第一个例子匹配单个特定异常。第二个例子匹配列表中的任何特定异常。

在许多情况下，异常的详细信息并不重要。另一方面，有些情况下我们想在异常对象的参数上执行一些处理。我们可以使用此语法将异常对象分配给变量：

```py
except SomeException as exc:
```

这将把异常实例分配给`exc`变量。然后我们可以将其写入日志，或检查参数，或修改要打印的跟踪信息。

## 匹配更一般的异常

Python 异常形成一个类层次结构。通常，我们会具体匹配异常。在少数情况下，我们会使用异常超类而不是具体类。一些最常见的超类是 `OSError` 和 `ArithmeticError` 异常。有一些 `OSError` 的子类提供了关于异常的更详细的信息；在许多情况下，我们对 `OSError` 超类的细微差别不太感兴趣。同样，`OverflowError` 和 `ZeroDivisionError` 之间的区别可能没有帮助。

我们可以这样使用超类异常：

```py
import os
def names(path="."):
    try:
        return [name
            for name in os.listdir(path)
            if not name.startswith('.')]
    except OSError as exc:
        print( exc.__class__.__name__, exc )
        raise

```

我们已经使用超类 `OSError` 来匹配所有各种 `OSError` 子类。虽然最可能的异常是 `FileNotFoundError` 和 `NotADirectoryError`，但我们也可能得到 `OSError` 的其他子类之一。在这种情况下，我们不在乎具体问题，所以我们可以使用超类错误。

此示例还使用了不带参数的 `raise` 语句。在 `except` 子句中，这将在进行一些初步处理后重新抛出异常。现在，异常将随着 Python 搜索处理程序而沿着调用堆栈传播。

## 空的 `except` 子句

Python 允许没有指定异常的 `except` 子句。这是最通用的异常匹配器：它匹配所有异常类。

由于它与 `SystemExit` 和 `KeyboardInterrupt` 异常匹配，随意使用可能会引起问题。当我们处理这个异常时，我们可能会发现我们不能再优雅地退出我们的程序，而必须求助于 SIGKILL 信号来停止程序。

未装饰的 `except` 子句应持怀疑态度。

# 创建我们自己的异常

异常的层次结构有一个名为 `Exception` 的错误相关异常的父类。所有反映基本错误条件的异常都是 `Exception` 类的子类。所有异常的基类是 `BaseException` 类；一些非错误相关异常是 `BaseException` 类的直接子类。

我们可以这样总结层次结构：

+   `BaseException`

    +   `SystemExit`

    +   `KeyboardInterrupt`

    +   `GeneratorExit`

    +   `Exception`

        +   所有其他异常

所有错误相关异常的父类 `Exception` 非常广泛。我们可以在像这样长期运行的服务器中使用它：

```py
def server():
        try:
        while True:
            try:
                one_request()
            except Exception as e:
                print(e.__class__.__name__, e)
    except Shutdown_Request:
        print("Shutting Down")
```

此示例依赖于一个函数，`one_request()`，它处理单个请求。`while` 循环永远运行，评估 `one_request()` 函数。如果抛出了任何与错误相关的 `Exception` 子类，错误将被记录，但请求处理将继续。

当抛出 `Shutdown_Request` 异常时，内部的 `try` 语句不会匹配这个异常。异常将传播出循环到外部的 `try` 语句。我们可以记录关闭请求，执行任何其他所需的清理，并退出 `server()` 函数。

类层次结构确保两个非错误异常——`KeyboardInterrupt`和`SystemExit`——不会在内部`try`语句中被错误处理。这些异常是`Exception`类的同等级别，这就是为什么它们不会匹配。这意味着一个`SIGINT`信号（在键盘上按*Ctrl* + *C*的效果）将干净地终止服务器。此外，如果请求处理的一部分评估`sys.exit()`，服务器将优雅地关闭。

# 使用`finally`子句

我们可以在`try`语句上包含一个`finally`子句。这包含一个在`try`语句结束时始终执行的语句集。这意味着无论是成功路径还是异常路径，都会始终执行`finally`子句。以下是它的总结：

```py
try:
    # Something that might fail.
except SomeException:
    # Fallback plan to handle failure.
finally:
    # Always executed.
```

当我们有清理或必须始终执行的结束语句集时，我们会使用这个。这种用法最常见的情况是关闭文件或网络连接，即使异常已被引发并正确处理。

在许多情况下，我们可以使用上下文管理器来正确关闭文件或网络连接。我们可以使用`contextlib.closing()`来包装具有`close()`方法但不是正确上下文管理器的对象。我们将在第十章*文件、数据库、网络和上下文*中查看上下文管理器。

# 异常的使用场景

异常的使用场景非常广泛。我们将确定几个在 Python 中使用异常的显著领域。

一些异常完全是良性的。`StopIteration`异常是由一个耗尽值的可迭代对象引发的。`for`语句从可迭代对象中消耗项目，直到这个异常被引发以表示没有更多数据。同样，当生成器在产生所有数据之前被关闭时，会使用`GeneratorExit`。这并不是错误；这是一个信号，表示不会请求更多数据。

完全在程序之外的条件下可能被视为异常。意外的操作系统条件或错误通过是`OSError`异常子类的异常来表示。一些操作系统条件可以忽略；其他可能表明环境或应用程序中存在严重问题。有十几个此类错误的子类，以提供对操作系统条件的更详细描述。此外，内部操作系统错误号也作为参数提供给这些异常，以帮助区分问题的细节。

一些异常是程序内部普通事物引起的。当我们使用`str.index()`方法时，可能会引发`ValueError`异常而不是返回一个数值。我们可以捕获并利用这个异常信息作为程序正常操作的一部分。

我们通常会通过异常检测程序的使用不当。可能涉及不良数据，或者尝试了不受支持的运算。在这些情况下，程序可能会使用异常来表示由用户输入问题引起的问题。一个常见的设计模式是在足够高的级别进行异常处理，以捕获、记录并以有意义的方式向用户显示这些问题。一个长期运行的服务器可能只是记录然后处理下一个请求。一个网页可能将输入表单验证包裹在异常处理中，以便用户的响应是带有错误信息的表单页面。

一些异常反映了设计或实现问题。`ValueError` 异常的意外发生可能表明设计问题或实现问题。它可能表明测试用例不足。在这种情况下，最好是整个程序崩溃，以便可以使用回溯信息来定位和纠正问题。

未预期的异常通常表明程序已损坏。程序将停止；异常的输出可以提供有价值的调试信息。我们可以通过编写不必要的广泛异常处理程序来干扰这种正常行为，但隐藏未预期的异常通常是一个坏主意，因为会丢失有价值的调试信息。

在蒂姆·彼得斯的《Python 之禅》中，有一些诗意的建议：

> *错误绝不应该默默无闻。*
> 
> *除非明确静默。*

这里的想法是，Python 中的未预期异常将以一个大的、嘈杂的错误回溯停止程序。如果我们需要静默异常，我们可以使用广泛的通用 `except` 语句来捕获和静默它们。

# 发出警告而不是异常

Python 的 `warnings` 模块处理异常的特殊子类。我们可以使用 `warnings` 模块来识别应用程序中的潜在问题。警告模块用于内部跟踪多个内部考虑因素。

警告概念介于完全正常的操作和错误条件之间。我们的程序可能表现不佳，但也不是完全损坏。

在运行单元测试时，我们可能会遇到三种显著的警告类别。由于单元测试框架显示`所有`警告，我们可能会在测试环境中看到一些在软件的正常操作使用中看不到的警告。

+   `DeprecationWarning`：此警告由已弃用的模块、函数或类引发。它提醒我们需要修复代码以停止使用此功能。

+   `PendingDeprecationWarning`：对于已宣布弃用的函数、模块或类，可能会引发此警告。这是一个提示，我们需要在它成为弃用功能之前停止使用此功能。

+   `ImportWarning`：由于一些模块是可选的或平台特定的，一些导入语句被包裹在 `try` 块中；这个警告会引发而不是异常。我们可以暴露这些警告以确保导入被正确处理。

我们可以利用 `warnings` 模块来暴露那些通常被静默的警告。我们可以使用 `warnings.simplefilter("always")` 来查看所有警告。

我们可以像这样引发通用的 `UserWarning`：

```py
>>> import warnings
>>> warnings.warn("oopsie")
__main__:1: UserWarning: oopsie
```

使用 `warnings.warn()` 允许我们在应用程序中包含警告信息，而几乎不需要任何开销。我们可以将其用作调试辅助工具，以跟踪可疑或可能令人困惑的罕见情况。

# 授权与宽恕——Pythonic 方法

一条常见的 Python 知识点是来自 RADM 格蕾丝·穆雷·霍珀的以下建议：

> *"求得宽恕比求得许可更容易"*

在 Python 社区中，这有时被总结为 EAFP（先做后检查）编程。这与 **LBYL（先检查后执行**）编程形成对比。

Python 异常处理速度快。更重要的是，所有潜在问题的必要先决条件检查已经包含在语言本身中。我们永远不需要用额外的 `if` 语句括起来处理过程，以查看输入是否可能引发异常。

通常认为编写如下形式的 LBYL（先检查后执行）代码是不良实践：

```py
if text.isdigit():
    num= int(text)
else:
    num= None
```

这里展示的糟糕想法是仔细检查以防止抛出异常。由于多种原因，这种方法是无效的。

+   `isdigit()` 测试无法正确处理负数。对于 `float()` 转换，这种测试会错过大量有效的语法变体。

+   检查字符和语法的有效性开销已经包含在 `int()` 函数中。提前检查会重复已经存在的检查。

更 Pythonic 的方法是对内置异常进行处理。例如：

```py
try:
    num= int(text)
except ValueError:
    num= None
```

这段代码的行数与之前相同。它正确地转换了所有可能的 Python 整数字符串。它不包括任何冗余的有效性检查。

# 摘要

在本章中，我们看到了如何使用 Python 异常编写能够正确处理意外情况的程序。各种类型的异常反映了外部条件以及可能改变程序行为的内部条件。我们可以使用异常子句来实现回退处理，以便程序能够优雅地处理这些异常情况。

我们还看到了一些被 discourage 的事情。空白的 `except` 子句——它匹配太多种异常类——是合法的，但不应该使用。

**“三思而后行”**（**LBYL**）编程的思想也通常不被鼓励。Python 的方法可以概括为**“求原谅比求许可更容易”**（**EAFP**）。一般的方法是将操作封装在`try`语句中，并为有意义的异常编写适当的异常处理器。

一些异常，如`RuntimeError`或`SyntaxError`，不应该由普通的应用程序编程来处理。这些异常通常表明问题非常严重，程序确实应该崩溃。

其他异常，如`IndexError`或`KeyError`，可能是设计的一部分。当这些异常是意外的，我们就发现了设计问题。这也可能表明我们缺乏足够的单元测试。

在第十章*文件、数据库、网络和上下文*中，我们将探讨 Python 在处理持久数据文件和网络数据传输方面的多种方法。这类处理通常需要异常处理。
