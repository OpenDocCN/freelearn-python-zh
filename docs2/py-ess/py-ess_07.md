# 第七章. 基本函数定义

从数学的角度来看，一个函数是将定义域中的值映射到值域中的映射。像正弦或余弦这样的函数将角度域的值映射到-1 和+1 之间的实数值域。映射的详细信息总结在函数名、定义域和值域中。我们将使用这个函数概念来将我们的 Python 编程打包成可以使用名称总结实现细节的东西。

我们将探讨如何定义和评估 Python 函数。在本章中，我们将关注仅返回 Python 对象作为值域的 Python 函数。在第八章，*更高级的函数*中，我们将探讨生成器函数；这些是迭代器，它们与`for`循环一起使用以产生值序列。

Python 函数还提供可选参数以及位置参数和关键字参数的混合。这使得我们可以定义一个具有多个变体签名的单个函数，从而在函数的使用上提供了相当大的灵活性。

# 查看五种可调用类型

Python 在函数主题上提供了五种变体。每一种都是一种可调用对象：我们可以用参数值调用对象，它返回一个结果。以下是我们将如何组织我们的探索：

+   使用`def`语句创建的基本函数是本章的主题。

+   Lambda 形式是将函数定义简化为参数和表达式；这也是本章的一个主题。

+   生成器函数和`yield`语句是我们将在第八章，*更高级的函数*中探讨的内容。这些函数是迭代器，可以提供多个结果。

+   函数包装器用于类方法，我们将在第十一章，*类定义*中探讨。这些是利用类特性的内置函数。像`len()`这样的函数是由集合的`__len__()`方法实现的。

+   可调用对象也是第十一章，*类定义*的一部分。这些类包括`__call__()`方法，使得类的实例表现得像使用`def`语句创建的基本函数。

所有这些都是基于一个共同主题的变体。它们是将某些功能打包成具有名称、输入参数和结果的方式。这使得我们可以将大型、复杂的程序分解成更小、更容易理解的函数。

# 使用位置参数定义函数

Python 函数定义的基本结构是用`def`语句构建的。我们提供一个名称、参数的名称，以及函数体的缩进语句序列。`return`语句提供值域。

语法看起来像这样：

```py
def prod(sequence):
    p= 1
    for item in sequence:p *= item
    return p
```

我们定义了一个名为`prod`的名称，并提供了一个只有一个参数`sequence`的列表。函数体包括三个语句：赋值、`for`和`return`。`return`语句中的表达式提供了结果值。

这合理地符合函数的数学概念。值域是任何数值序列，值域将是反映序列数据类型的类型值。

我们通过在表达式中使用函数名和特定参数值来评估函数：

```py
>>> prod([1,2,3,4])
24
>>> prod(range(1,6))
120
```

在第一个例子中，我们提供了一个简单的列表显示`[1, 2, 3, 4]`作为参数。这被分配给函数的参数`sequence`。函数的评估返回了这些序列项的乘积。

在第二个例子中，我们将一个`range()`对象作为`prod()`函数的参数。这个参数值被分配给函数的参数。当与`for`循环一起使用时，范围对象表现得像一个序列集合，计算并返回一个乘积。

## 定义多个参数

Python 为我们提供了多种方式来为参数赋值。在最简单的情况下，参数值根据位置分配给参数。这里有一个具有两个位置参数的函数：

```py
def main_sail_area(boom, mast):
    return (boom*mast)/1.8
```

我们定义了一个函数，该函数需要帆杆的长度，通常称为“E”维度，以及帆索的长度，通常称为“P”维度。给定这两个数字以及关于帆曲率的假设，我们返回帆的大致面积。

我们可以评估这个函数，提供两个位置参数，即帆杆长度和桅杆高度。

```py
>>> main_sail_area(15, 45)
375.0
```

我们可以定义具有任何数量的参数的函数。具有大量参数的函数可能会使可理解性达到极限。一个好的函数应该有一个整洁的摘要，使得在不详细研究太多细节的情况下也能理解函数的目的。

## 使用`return`语句

`return`语句有两个目的：它结束函数的执行，并且可以可选地提供函数的结果值。`return`语句是可选的。这导致三种用法：

+   没有使用`return`语句：函数在语句块结束时结束。返回值是`None`。

+   没有表达式的`return`语句：当执行`return`语句时，函数结束，结果是`None`。

+   带有表达式的`return`语句：当执行`return`语句时，函数结束，表达式的值是结果。带有表达式列表的`return`语句创建一个`tuple`，适合多重赋值。

这里是一个没有`return`语句的函数：

```py
def boat_summary(name, rig, sails):
    print( "Boat {0}, {1} rig, {2:.0f} sq. ft.".format(
        name, rig, sum(sails))
    )
```

这个函数由一个使用`print()`函数的单个表达式语句组成。没有显式的`return`，所以默认返回值将是`None`。

当满足异常条件时，通常使用 `return` 语句提前结束，否则执行函数定义中的语句序列的其余部分。它看起来像这样：

```py
def mean_diff(data_sequence):
    s0, s1 = 0, 0
    for item in data_sequence:
        s0 += 1
        s1 += item
    if s0 < 2:
        return
    m= s1/s0
    for item in data_sequence:
       print(item, abs(item-m))
```

此函数期望一个数据集合。它将从该集合中计算两个值：`s0` 和 `s1`。`s0` 值将是项目数量的计数，`s1` 值将是项目的总和。如果计数太小，函数将直接返回。如果计数足够大，则进行额外的处理：打印值及其与平均值的绝对差异。

在语句序列的末尾没有 `return` 语句，因为这不是必需的。在函数中间使用 `return` 语句允许我们避免深层嵌套的 `if` 语句。

注意，变量 `s0`、`s1` 和 `m` 是在局部命名空间中创建的，该命名空间仅在函数被评估时存在。一旦函数完成，局部命名空间将被移除，引用计数将减少，临时对象将被清理。我们将在本章后面的 *使用命名空间* 部分查看更多细节。

内置函数 `divmod()` 返回两个结果。我们经常使用这样的多重赋值：`q, r = divmod(n, 16)`；它将两个结果赋值给两个变量，`q` 和 `r`。我们可以在 `return` 语句中包含多个表达式来编写返回多个值的函数。

在 *可变和不可变参数值* 部分，我们将展示一个具有多个返回值的函数。

## 使用位置或关键字参数评估函数

Python 允许我们通过显式参数名称提供参数值。当我们提供名称时，它被称为关键字参数。例如，上一节中的 `boat_summary()` 函数可以用多种方式使用。

我们可以按位置提供参数值，如下所示：

```py
>>> sails =  [358.3, 192.5, 379.75, 200.0]
>>> boat_summary("Red Ranger", "ketch", sails)
```

参数根据其位置分配给 `name`、`rig` 和 `sails` 的参数变量。

我们可以，作为替代，这样做：

```py
>>> boat_summary(sails=sails, rig="ketch", name="Red Ranger" )
```

此示例提供了所有三个参数的关键字。请注意，当提供关键字参数时，位置并不重要。关键字参数必须在任何位置参数之后提供，但关键字参数之间的顺序并不重要，因为它们是根据名称分配给参数的。

我们可以使用位置和关键字参数的混合。为了使这起作用，Python 使用两条规则将参数值映射到函数的参数：

1.  从左到右匹配所有位置参数到参数。

1.  通过名称匹配所有关键字参数。

有一些额外的规则来处理重复项和默认值——包括可选参数——将在稍后的 *通过默认值定义可选参数* 部分描述。

为了使这些规则能够正确工作，我们必须首先提供所有位置参数，然后我们可以在位置参数之后提供任何关键字参数。我们不能通过位置和关键字为同一个参数提供两个值。同样，也不能为关键字提供两次。

这里有一个好的例子和一个不好的例子：

```py
>>> boat_summary("Red Ranger", sails=sails, rig="ketch")
>>> boat_summary("Red Ranger", sails=sails, rig="ketch", name="Red Ranger")
```

在第一个例子中，`name` 参数是按位置匹配的。`sails` 和 `rig` 参数是通过关键字匹配的。

在第二个例子中，`name` 变量既有位置值也有关键字值。这将引发一个 `TypeError` 异常。

由于这个原因，选择参数变量名非常重要。一个好的参数名可以使关键字参数函数评估非常清晰。

## 编写函数的文档字符串

为了节省空间，我们没有提供很多带有文档字符串的函数示例。我们将在第十四章第十四章。完善 – 单元测试、打包和文档中详细讨论文档字符串。现在，我们需要意识到每个函数至少应该有一个摘要。摘要包含在一个三引号字符串中，它必须是函数语句块中的第一个表达式。

带有文档字符串的函数看起来像这样：

```py
def jib(foot, height):
    """
    jib(foot,height) -> area of given jib sail.

    >>> jib(12,40)
    240.0
    """
    return (foot*height)/2
```

这个特定的三引号字符串有两个作用。首先，它总结了函数的功能。当我们查看源文件时可以阅读它。我们也可以在调用 `help(jib)` 时看到它。

这个文档字符串的第二个目的是提供一个具体的例子，说明如何使用该函数。这些例子看起来就像是从一个交互式解释器会话中复制并粘贴到文档字符串注释中一样。

这些交互式解释器格式的例子是通过使用 `doctest` 工具定位的。在定位示例后，这个工具可以运行代码以确认它按预期工作。本书中的所有示例都是使用 `doctest` 测试的。虽然测试的细节是第十四章第十四章。完善 – 单元测试、打包和文档的一部分，但考虑在每个函数中编写文档字符串是很重要的。

# 可变和不可变参数值

在某些编程语言中，存在多种函数评估策略，包括按值调用和按引用调用。在按值调用的语义中，将参数值的副本分配给函数中的参数变量。在按引用调用的语义中，在函数中使用变量的引用。这意味着函数内部的赋值语句可以替换函数外部的变量值。这两种语义类型都不适用于 Python。

Python 使用名为“按共享调用”或“按对象调用”的机制。函数被赋予原始对象的引用。如果该对象是可变的，函数可以修改该对象。然而，函数不能通过参数变量将变量赋值给函数外的变量。函数共享对象，而不是对象所分配的变量。

最重要的影响之一是，函数体可以给参数变量赋新值，而不会对传递给函数的原始参数有任何影响。参数变量严格局限于函数内部。

这是一个给参数变量赋新值的函数：

```py
def get_data(input_string):
    input_string= input_string.strip()
    input_string, _, _ = input_string.partition("#")
    input_string= input_string.rstrip()
    name, _, value = input_string.partition('=')
    return name, value
```

这个函数评估`input_string`变量的`strip()`方法，并将结果字符串赋给参数变量。它将`partition()`方法应用于新的`input_string`变量值，并将三个结果字符串之一赋给参数变量。然后它返回这个字符串对象，再次将其赋给参数变量。

对`input_string`参数变量的任何赋值语句都不会影响函数外的任何变量。当函数被评估时，会使用一个独立的命名空间来处理参数和其他局部变量。

Python 工作方式的一个后果是，当我们提供可变对象作为参数时，这些对象可以被函数内部评估的方法更新。函数的参数变量将是原始可变对象的引用，我们可以评估像`remove()`或`pop()`这样的方法，这些方法会改变引用的对象。

这是一个通过移除选定值来更新`list`参数的函数：

```py
def remove_mod(some_list, modulus):
    for item in some_list[:]:
        if item % modulus == 0:
            some_list.remove(item)
```

这个函数期望一个可变对象，如列表，命名为`some_list`，以及一个值，命名为`modulus`。函数使用`some_list[:]`创建参数值的临时副本。对于这个副本中是`modulus`值的倍数的每个值，我们将从原始的`some_list`对象中移除该副本。这将修改原始对象。

当我们评估这个函数时，它看起来是这样的：

```py
>>> data= list(range(10))
>>> remove_mod(data, 5)
>>> remove_mod(data, 7)
>>> data
[1, 2, 3, 4, 6, 8, 9]
```

我们创建了一个简单的列表并将其赋值给`data`变量。这个由`data`变量引用的对象被`remove_mod()`函数修改。序列中的所有五和七的倍数都被丢弃。

在这个函数中，在开始移除值之前，我们需要创建输入`list`对象的临时副本。如果我们试图在同时从该`list`中移除项目的同时迭代该`list`，我们会得到看起来不正确的结果。将原始值与正在修改的`list`分开是有帮助的。

函数可以通过`global`和`nonlocal`语句（在*使用命名空间*部分中展示）进行特殊安排，在全局命名空间和其他非局部命名空间中创建变量。

# 通过默认值定义可选参数

Python 允许我们为参数提供一个默认值。具有默认值的参数是可选的。标准库中充满了具有可选参数的函数。一个例子是`int()`函数。我们可以使用`int("48897")`将字符串转换为整数，假设该字符串表示的是十进制数。我们可以使用`int("48897", 16)`明确指出字符串应被视为十六进制值。`base`参数的默认值是 10。

记住我们可以为函数使用关键字参数。这意味着我们可能想要写一些像这样的事情：`int("48897", base=16)`，以便清楚地表明`int()`函数的第二个参数是用来做什么的。

之前，我们列出了两个将参数值与参数匹配的规则。当我们引入默认值时，我们增加了两个额外的规则。

1.  从左到右将所有位置参数与参数匹配。

1.  匹配所有关键字参数。如果已经分配了位置参数，将引发`TypeError`异常。

1.  为任何缺失的参数设置默认值。

1.  如果有参数没有值，将引发`TypeError`异常。

    ### 注意

    注意：这不是最终的规则集；还有一些其他特性需要介绍。

这些规则的一个重要后果是，必须首先定义所需的参数——即没有默认值的参数。具有默认值的参数必须最后定义。"先定义必需参数，后定义可选参数"的规则确保我们位置匹配过程能够正常工作。

我们在函数定义中提供默认值。以下是一个示例：

```py
import random
def dice(n=2, sides=6):
    return [random.randint(1,sides) for i in range(n)]
```

我们导入了`random`模块，以便可以使用`random.randint()`函数。我们的`dice()`函数有两个参数，它们都有默认值。如果未提供`n`参数，它的值将为 2。如果省略了`sides`参数，它的值将为 6。

这个函数的主体是一个列表推导式：它使用生成器表达式来构建一个包含单个值的列表。我们将在第八章中详细探讨生成器表达式，*更高级的函数*。现在，我们可以观察到它使用`random.randint(1,sides)`函数来生成介于 1 和`sides`参数值之间的数字。推导式包括一个`for`子句，它遍历`n`个值。

我们可以用多种方式使用这个函数。以下是一些示例：

```py
>>> dice()
[6, 6]
>>> dice(6)
[3, 6, 2, 2, 1, 5]
>>> dice(4, sides=4)
[3, 3, 4, 3]
```

第一个示例依赖于默认值来模拟在像 Craps 这样的赌场游戏中常用的两枚骰子。第二个示例使用六枚骰子，这在像 10,000（有时称为 Zilch 或 Crap Out）这样的游戏中很典型。第三个示例使用四枚四面骰子，这在使用各种多面骰子的游戏中很常见。

### 注意

关于测试的说明：为了为涉及`random`模块的函数提供可重复的单元测试，我们已使用`random.seed("test")`设置了一个特定的种子值。

## 关于可变默认值的警告

这里有一个病态的例子。这显示了非常糟糕的编程实践；这是许多 Python 程序员在开始使用默认值时犯的一个错误。

这是一个非常糟糕的想法：

```py
def more_dice(n, collection=[]):
    for i in range(n):
        collection.append(random.randint(1,6))
    return collection
```

我们定义了一个只有一个参数变量`n`和`collection`的简单函数。`collection`的默认值是一个空列表。（剧透：这将会是一个错误。）该函数将模拟六面骰子的数量添加到给定的集合中。

函数返回一个值以及修改一个参数。这意味着当我们使用这个函数在 REPL 中时，我们会看到`return`值被打印出来。

我们可以使用这个来玩像 Yacht（也称为 Generala 或 Poker Dice）这样的游戏。玩家有一副骰子，我们将从中移除骰子并附加新的骰子滚动。

一个用例是创建一个`list`对象，并将其用作`more_dice()`函数的参数。这个`list`对象将得到很好的更新。下面是如何工作的示例：

```py
>>> hand1= []
>>> more_dice(5, hand1)
[6, 6, 3, 6, 2]
>>> hand1
[6, 6, 3, 6, 2]
```

我们创建了一个空的`list`并将其分配给`hand`变量。我们向`more_dice()`函数提供了这个序列对象，以便将五个值附加到`hand`对象上。这给了我们一个初始的三个六、一个三和一个二的骰子。我们可以从`hand1`对象中移除两个和三个；我们可以使用`more_dice(2, hand1)`重新使用它，将两个骰子放入手中。

我们可以使用另一个空序列作为参数来发第二手牌。除了结果外，它与其他示例相同：

```py
>>> hand2= []
>>> more_dice(5, hand2)
[5, 4, 2, 2, 5]
>>> hand2
[5, 4, 2, 2, 5]
```

所有的东西似乎都工作得很好。这是因为我们为收集参数提供了一个明确的论证。每个手对象都是一个独特的、空的`list`。让我们尝试为`collection`参数使用默认值。

在这个第三个示例中，我们不会提供参数，而是依赖于`more_dice()`函数返回的默认序列：

```py
>>> hand1= more_dice(5)
>>> hand1
[6, 6, 3, 6, 2]
>>> hand2= more_dice(5)
>>> hand2
[6, 6, 6, 2, 1, 5, 4, 2, 2, 5]
```

等等。刚才发生了什么？这是怎么可能的？

作为提示，我们需要在代码中搜索一个具有隐藏的共享状态的对象。之前，我们提到默认的`list`对象会是一个问题。这个隐藏的`list`对象正在被重复使用。

发生的事情是这样的：

1.  当`def`语句执行时，定义参数默认值的表达式将被评估。这意味着创建了一个单个可变`list`对象作为`collection`参数的默认对象。

1.  当`more_dice()`函数在没有`collection`参数的论证下评估时，唯一可变的`list`对象被用作默认对象。重要的是，单个可变对象正在被重复使用。如果在任何时刻我们更新了这个对象，那么这种变更将应用于该对象的所有共享使用。由于它是由函数返回的，这个单一的`list`可以被分配给几个变量。

1.  当`more_dice()`函数在没有`collection`参数的论证下第二次评估时，变更后的`list`对象被重新用作默认对象。

从这个例子中，我们可以看出可变对象是一个糟糕的默认值选择。

通常，我们不得不做类似这样的事情：

```py
def more_dice_good(n, collection=None):
    if collection is None:
        collection = []
    for i in range(n):
        collection.append(random.randint(1,6))
    return collection
```

此函数使用一个不可变且易于识别的默认值 `None`。如果没有为 `collection` 变量提供参数值，它将被设置为 `None`。我们可以在函数评估时创建一个新的空可变对象来替换 `None` 值。然后我们可以更新这个新的列表对象，确信我们没有破坏任何正在被重复使用的可变默认对象。

### 小贴士

不要将可变对象用作参数的默认值。

避免使用 `list`、`dict`、`set` 以及任何其他可变类型作为默认参数值。使用 `None` 作为默认值；将 `None` 替换为一个新的空可变对象。

你已经被警告了。

这可能会导致错误。这是函数定义方式和按共享语义调用的一种后果。

有意利用这一点是可能的：我们可以使用可变默认值作为缓存来保留值，创建具有滞后效应的函数。可调用对象可能是实现具有内部缓存或缓冲区功能的函数的更好方式。有关更多信息，请参阅第十一章，*类定义*。

# 使用 * 和 ** 的 "其余所有内容" 表示法

Python 在如何定义函数的位置参数和关键字参数方面提供了更多的灵活性。我们看到的例子都限于固定和有限的参数值集合。Python 允许我们编写具有无限数量位置参数以及关键字参数值的函数。

Python 将创建一个包含所有未匹配位置参数的 `tuple`。它还将创建一个包含所有未匹配关键字参数的字典。这允许我们编写如下使用的函数：

```py
>>> prod2(1, 2, 3, 4)
24
```

此函数接受任意数量的位置参数。与前面展示的 `prod()` 函数进行比较。我们之前的例子需要一个单一的序列对象，我们必须按照以下方式使用该函数：

```py
>>> prod([1, 2, 3, 4])
24
```

`prod2()` 函数将创建所有参数值的乘积。由于 `prod2()` 函数可以与无限数量的位置参数一起工作，这导致该函数的语法稍微简单一些。

为了编写一个具有无限数量位置参数的函数，我们必须提供一个带有 `*` 前缀的参数。它看起来是这样的：

```py
def prod2(*args):
    p= 1
    for item in args:
        p *= item
    return p
```

`prod2()` 的定义将所有位置参数分配给带有 `*` 前缀的参数 `*args`。`args` 参数的值是一个包含参数值的元组。

这是一个使用位置和关键字参数混合的函数：

```py
def boat_summary2(name, rig, **sails):
    print("Boat {0}, {1} rig, {2:.0f} sq. ft.".format(
name, rig, sum(sails.values())))
```

此函数将接受两个参数，`name` 和 `rig`。这些可以通过位置或关键字提供。除了 `name` 和 `rig` 之外的所有额外关键字参数被收集到一个字典中，并分配给 `sails` 参数。`sails.values()` 表达式仅从 `sails` 字典中提取值；这些值被加在一起以写入最终的总结行。

这是我们可以使用此函数的许多方法之一：

```py
>>> boat_summary2("Red Ranger", rig="ketch",
...     main=358.3, mizzen=192.5, yankee=379.75, staysl=200 )
```

我们通过位置提供了第一个参数值；这将分配给第一个位置参数，`name`。我们使用关键字参数 `rig` 提供了一个定义好的参数。剩余的关键字参数被收集到一个字典中，并分配给名为 `sails` 的参数。

`sails` 字典将被分配一个类似这样的值：

```py
{'main': 358.3, 'mizzen': 192.5, 'yankee': 379.75, 'staysl': 200}
```

由于这是一个正确的 `dict` 对象，我们可以使用任何字典处理来处理这个映射。

之前，我们提供了匹配参数值与参数的四条规则。以下是匹配参数值与函数参数的更完整的规则集：

1.  从左到右匹配所有位置参数到参数。

1.  如果位置参数多于参数名：

    1.  如果有一个带有 `*` 前缀的参数名，将剩余值的 `tuple` 分配给带前缀的参数。

    1.  如果没有带有 `*` 前缀的参数，则引发 `TypeError` 异常。

1.  匹配所有关键字参数。如果已经分配了位置参数，则引发 `TypeError` 异常。

1.  如果关键字参数多于参数名：

    1.  如果有一个带有 `**` 前缀的参数名，将剩余的关键字和值 `dict` 分配给带前缀的参数。

    1.  如果没有带有 `**` 前缀的参数，则引发 `TypeError` 异常。

1.  将默认值应用于缺失的参数。

1.  如果参数仍然没有值，则引发 `TypeError` 异常。

这些规则的一个后果是，最多只有一个参数可以有 `*` 前缀；同样，最多只有一个参数可以有 `**` 前缀。这些特殊情况必须在其他所有参数之后给出。如果没有剩余的位置参数，`*` 前缀变量将被分配一个空元组。如果没有剩余的关键字参数，`**` 前缀变量将被分配一个空字典。

在调用函数时，我们必须首先提供位置参数值。我们可以按任何顺序提供关键字参数值。

## 使用序列和字典填充 *args 和 *kw

之前展示的 `prod2()` 函数期望收集到单个 `*args` 元组中的单个值。如果我们用 `prod2(1, 2, 3, 4, 5)` 调用该函数，则从五个位置参数构建的元组被分配给 `args` 参数。

如果我们想向 `prod2()` 函数提供一个列表，我们如何有效地写出 `prod2(some_list[0], some_list[1], some_list[2], … )`？

当我们使用`prod2(*some_sequence)`调用函数时，给定参数序列的值将与位置参数匹配。参数序列中的第一个项成为第一个位置参数。序列中的第二个项成为第二个参数，依此类推。每个项都会被分配，直到它们都被使用完。如果有额外的参数值，并且函数定义中使用了带有`*`前缀的参数，则额外的参数值将被分配给`*`前缀参数。

因此，我们可以轻松地使用`prod2(*range(1, 10))`。这实际上等同于`prod2(1, 2, 3, 4, 5, …, 9)`。由于所有的位置参数值都被分配给`*`前缀的`args`变量，我们可以使用这个函数与单个值一起使用，例如：`prod2(1, 2, 3, 4)`。我们也可以提供值序列，例如：`prod2(*sequence)`。

我们有一个类似的技术，可以将关键字参数的字典提供给函数。我们可以这样做：

```py
>>> rr_args = dict(
...    name="Red Ranger", rig="ketch",
...    main=358.3, mizzen=192.5, yankee=379.75, staysl=200
... )
>>> boat_summary2(**rr_args)
Boat Red Ranger, ketch rig, 1131 sq. ft.
```

我们创建了一个包含所有通过关键字定义的参数的字典。这是`dict()`函数的一个方便特性，其中所有关键字参数都用于构建字典对象。我们将该字典分配给`rr_args`变量。当我们调用`boat_summary2()`函数时，我们使用`**rr_args`参数来强制将`rr_args`字典中的每个键和值与函数的参数匹配。这意味着与字典中`name`和`rig`键关联的值将与`name`和`rig`参数匹配。字典中的所有其他键都将分配给`sails`参数。

这些技术使我们能够动态地构建函数参数。这为我们定义和使用 Python 函数提供了极大的灵活性。

# 嵌套函数定义

我们可以在函数定义中包含任何内容，甚至另一个函数定义。当我们查看第十三章中的装饰器时，*元编程与装饰器*，我们会看到包含嵌套函数定义的函数的例子。

我们可以在函数定义中包含`import`语句。一个`import`语句实际上只执行一次。但是，导入的模块有一个全局集合。然而，名称会被本地化到执行导入的函数。

一般建议在 Tim Peters 的《Python 之禅》诗中给出：

> *扁平优于嵌套*。

我们通常会努力使函数定义在一个相对简单、扁平的序列中。除非真正需要，否则我们会避免嵌套，例如在创建装饰器时。

# 与命名空间一起工作

当一个函数被评估时，Python 会创建一个局部命名空间。当参数值（或默认值）被分配时，参数变量在这个局部命名空间中创建。函数体中的语句块中创建的任何变量也会在这个局部命名空间中创建。

正如我们在第四章中提到的，*变量、赋值和作用域规则*，每个对象都有一个引用计数器。作为函数参数提供的对象，在函数的语句套件执行期间，其引用计数会增加。

当函数完成时——无论是由于显式的`return`语句还是套件末尾的隐式返回——命名空间被移除。这将减少对参数对象的引用数。

当我们评估像`more_dice_good(2, hand)`这样的表达式时，字面整数`2`将被分配给`n`参数变量。在函数执行期间，它的引用计数为`1`。分配给`hand`变量的对象将被分配给`collection`参数。在函数执行期间，这个对象将有一个引用计数为`2`。

当函数退出时，命名空间被移除，这将移除两个参数变量。分配给`n`变量的`2`对象将结束时的引用计数为零，这个`int`对象可以从内存中移除。分配给`collection`变量的对象将它的引用计数从两个减少到一；它不会被从内存中移除。这个对象仍然被分配给`hand`变量，并且可以在其他地方继续使用。

使用局部命名空间的好处是，我们可以自由地将对象分配给参数，而不用担心对象会被覆盖或从内存中移除。这还允许我们在函数体内自由创建中间变量，因为我们知道变量不会覆盖脚本中其他地方使用的某个变量。

当我们引用一个变量时，Python 会在两个地方查找该变量。它首先在局部命名空间中查找。如果找不到变量，Python 然后搜索全局命名空间。

当我们导入一个模块，比如`random`，我们通常在脚本的开头写`import`，这样模块就被导入到全局命名空间。这意味着使用`random.randint()`的函数首先会在局部命名空间中查找`random`；如果没有找到，它将检查全局命名空间并找到导入的模块。

这种回退到全局命名空间的做法允许我们在脚本文件中自由地重用导入的模块、函数定义和类定义。我们还可以在一定程度上共享全局变量。默认行为是我们可以读取全局变量的值，但不容易更新它们。

如果我们在函数中写入`global_variable = global_variable + 1`，我们可以获取名为`global_variable`的全局变量的值。然而，这个赋值操作将在局部命名空间中创建一个新的名为`global_variable`的变量。实际的全球变量将保持不变。

## 赋值全局变量

如果我们想要为一个没有作为参数提供的变量赋值怎么办？我们可以编写一个函数来更新全局变量。这可能导致程序令人困惑，因为几个函数可能通过全局变量共享公共状态。

要在全局命名空间而不是局部命名空间中创建名称，我们使用 `global` 语句。这标识了必须在全局命名空间而不是局部命名空间中找到的变量。以下是一个更新全局变量的函数示例：

```py
import random
def roll_dice_count_7():
    global sevens
    d= random.randint(1,6), random.randint(1,6)
    if d[0] + d[1] == 7:
        sevens += 1
    return d
```

我们定义了一个函数，并使用 `global` 语句来声明名为 `sevens` 的变量将在全局命名空间中找到。我们创建了两个随机数，并将这对数赋给一个局部变量 `d`。这个变量将在局部命名空间中创建，并且不会与其他命名空间中定义的其他变量冲突。

每当两个骰子的总和为七时，全局变量就会被更新。这是一个可能令人困惑的副作用。它必须明确记录，并且需要一些仔细的单元测试。

两个内置函数 `globals()` 和 `locals()` 可以帮助澄清在函数被评估时可以使用的变量。如果我们直接在 `return` 语句之前添加一个 `print()` 函数，我们会看到如下结果（一些细节被省略）：

```py
globals={'__cached__': None,
'__loader__': <_frozen_importlib.SourceFileLoader object at 0x100623750>,
'sevens': 20,
'__name__': '__main__',
'__file__': '…',
… etc.
    'roll_dice_count_7': <function roll_dice_count_7 at 0x10216e710>,
    'random': <module 'random' from '...'>}
locals={'d': (2, 1)}
```

`globals` 函数包括像 `sevens` 这样的变量，它包括随机模块和 `roll_dice_count_7` 函数。它还包括一些系统变量：`like __cached__`、`__loader__`、`__name__` 和 `__file__`。

`locals` 函数包括局部变量 `d` 以及没有其他内容。

## 赋值非局部变量

当一个函数在另一个函数内部定义时，外部函数可以包含既不是内部函数的局部变量也不是全局的变量。我们称这些为非局部变量。在某些情况下，我们可能想要设置一个属于封装函数的变量。

嵌套函数定义最常用于定义装饰器。我们将在第十三章《元编程和装饰器》中探讨这一点。

这里有一个关于嵌套函数和非局部共享变量的虚构示例：

```py
def roll_nl(n=2, d=6):
    def dice():
        nonlocal total
        points= tuple(random.randint(1,d) for _ in range(n))
        total = sum(points)
        return points
    total= 0
    dice()
    return total
```

我们定义了一个名为 `roll_nl()` 的函数，该函数将模拟掷骰子。函数的主体包括一个嵌套函数定义 `dice()`。其余的主体创建了变量 `total`，评估内部 `dice()` 函数，并返回 `total` 变量的值。

`total` 变量是如何被设置为非零值的？在 `roll_nl()` 函数的主体中并没有更新它。

在嵌套的`dice()`函数中，有一个对名为`total`的变量的非局部引用。这个变量必须存在于外部命名空间中，但不一定是全局命名空间。`dice()`函数创建一个包含`n`个骰子值的`tuple`对象。这个表达式从一个生成器函数的结果构建一个`tuple`。它更新非局部的`total`变量，即`points`元组的总和。`nonlocal`语句确保`total`变量是`dice()`函数容器的一部分。`dice()`函数的返回值是骰子元组，这个值实际上并没有被真正使用。

# 定义 lambda 表达式

lambda 形式是一种退化的函数。lambda 甚至没有名字：它只有参数和一个单一的表达式。我们通过提供参数名称和表达式来创建 lambda。它看起来像这样：

```py
lambda x: x[0]+x[1]
```

这种方法在 Python 的高阶函数上下文中很有帮助。我们经常与`max()`、`min()`、`sorted()`、`map()`、`filter()`或`list.sort()`一起使用 lambda。这里有一个简单的例子：

```py
>>> colors = [
... (255,160,137),
... (143, 80,157),
... (255,255,255),
... (162,173,208),
... (255, 67,164),
... ]
>>> sorted(colors)
[(143, 80, 157), (162, 173, 208), (255, 67, 164),
  (255, 160, 137), (255, 255, 255)]
>>> sorted(colors,
...     key= lambda rgb: (rgb[0]+rgb[1]+rgb[2])/3)
[(143, 80, 157), (255, 67, 164), (162, 173, 208),
  (255, 160, 137), (255, 255, 255)]
```

我们创建了一个简单的列表对象，其中包含四个 RGB 颜色值。如果我们对这个列表使用`sorted()`函数，颜色将按照红色分量值排序。如果红色分量相等，则使用绿色分量。在红色和绿色分量都相等的情况下，则使用蓝色分量。

如果我们想要按亮度排序颜色，我们不能简单地按红色、绿色和蓝色排序。对亮度的感知是微妙的，有多个公式可以近似这种现象。我们只选择了一个，那就是平均 RGB 值。这个公式没有考虑到我们的眼睛对绿色更敏感的事实。

`sorted()`函数接受第二个参数`key`，我们在第二个示例中提供了关键字参数。我们不是写一个完整的函数定义，这个定义只会包含一个表达式，而是将表达式`(rgb[0]+rgb[1]+rgb[2])/3`打包成一个 lambda。

语法 `lambda rgb: (rgb[0]+rgb[1]+rgb[2])/3` 等同于以下函数定义。

```py
def brightness(rgb):
    return (rgb[0]+rgb[1]+rgb[2])/3
```

lambda 表达式更紧凑。如果我们只需要在某个地方使用这个表达式，那么一个可重用的函数可能就不合适了。lambda 是一个提供简单表达式且开销最小的简单方法。如果我们认为我们需要编写复杂的 lambda 表达式——不仅仅是简单表达式，或者我们需要重用 lambda，那么我们应该考虑使用合适的函数。

# 编写附加函数注释

**Python 增强提案**（**PEP**）编号 3107 指定了可以应用于函数定义的附加注释。此外，PEP 482、483 和 484 涵盖了相关的一些想法。

这之所以重要，仅仅是因为 Python 有一些可选的语法，我们可能会看到。在 Python 3.5 中，可能会有提供此类信息类型的一些额外工具。注释的代码可以看起来像这样：

```py
def roller( n: int, d: int = 6 ) -> tuple:
    return tuple(random.randint(1,d) for _ in range(n))
```

此函数在每个参数之后包含额外的`: 表达式`注解。它还包括一个`-> 表达式`注解来显示函数的返回类型。本例中的所有注解表达式都是内置类型的名称。

为了描述更复杂的结构，一个额外的类型模块可以提供定义更精确的`Tuple[int, …]`作为此函数返回类型的工具。这是一个令人兴奋的发展，可能会避免某些类型的错误。

这些注解是合法的 Python3 语法。它们没有正式定义的语义，这意味着它们是可选的。有一些增强项目正在努力利用这些可选注解，并创建可以使用那里提供的信息的工具。虽然很少使用，但完全合法。

# 摘要

我们探讨了 Python 中用于函数定义的许多功能。我们探讨了如何定义函数的名称和参数，提供默认值以使参数可选。我们还探讨了如何向函数提供参数：我们可以按位置提供参数，或者使用参数变量名作为关键字。我们可以通过位置将值映射到参数上，通过评估`function(*args)`。我们也可以通过评估`function(**kw)`将字典中的值按名称映射到参数上。当然，我们也可以结合这两种技术。

我们已经探讨了函数如何通过`return`语句返回值。我们还探讨了不返回值的函数。技术上，它们返回一个`None`值，Python 编程的其他部分会忽略这个值。

我们探讨了尝试在函数定义中将可变对象作为默认值使用的重要问题。大多数情况下，将可变对象作为默认值将会引起问题。

除了函数定义的基本知识之外，我们还探讨了如何将局部变量分配给临时命名空间。我们还探讨了如何使用`global`语句在全局命名空间中创建变量。我们还探讨了如何使用嵌套函数定义来操作嵌套函数非局部但不是容器函数全局的变量。

在第八章中，我们将探讨生成器表达式和函数。这些是可迭代的函数，与`for`循环协同工作，以处理集合和数据序列。
