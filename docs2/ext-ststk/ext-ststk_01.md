# 第一章：从基础知识开始

大多数 Salt 用户将其视为配置管理平台。事实上，它在这方面处理得非常好。但它的设计目标并非一开始就是如此。在其早期，Salt 是一个通信框架，旨在对那些不编写代码的人来说也很有用。但对于那些愿意的人来说，它也被设计成对那些工具箱中有些 Python 知识的使用者高度可扩展。

在我们开始编写模块之前，了解 Salt 模块系统的工作原理会有所帮助。在本章中，你将学习以下内容：

+   加载系统的工作原理

+   Salt 如何使用 Python

# 使用插件

由于 Salt 最初被设计为一个其他软件可以用来通信的骨干，其最初目的是从大量物理和虚拟机器中收集信息，并将这些数据返回给用户或数据库。各种程序，如`ps`、`du`和`netstat`，被用来收集这些信息。因此，每个程序都被一个插件封装，其中包含调用这些程序和解析返回数据的各种功能。

这些插件最初被称为模块。后来，当 Salt 中添加了其他类型的模块时，原始模块开始被称为*执行模块*。这是因为执行模块会承担繁重的工作，而其他类型的模块通常围绕它们扩展其功能。

## 加载模块

就像许多数据中心一样，Salt 被创建的那个数据中心拥有各种服务器，它们使用不同的软件包来完成工作。一台服务器可能运行 Nginx，而另一台服务器可能运行 DNSMasq。在 DHCP 服务器上启用`nginx`模块或在 Web 服务器上启用`dnsmasq`模块是没有意义的。许多流行的程序通过允许用户在启动服务之前配置要加载的插件来解决这一问题。

Salt 处理插件的方式与其他不同。在一个大型基础设施中，单个服务器的配置可能非常耗时。随着配置管理被添加到 Salt 中，一个核心信念逐渐形成，即配置管理平台本身应该尽可能少地需要配置。如果一开始就需要花费大量时间来启动，那么使用这样的套件来节省时间又有什么意义呢？

这就是加载系统是如何产生的。Salt 总是附带一套完整的模块，并且 Salt 会自动检测可用的模块，并动态加载它们。

执行模块是一种插件，在 Salt 内部执行大部分繁重的工作。这些是第一个使用加载系统的，在一段时间内没有其他类型的模块。随着 Salt 功能的增加，很快就很明显需要其他类型的模块。例如，返回输出最初只是打印到控制台。然后输出被改为更容易从 shell 脚本中处理。然后添加了输出器系统，以便可以在 JSON、YAML、Python 的 `pprint` 以及任何可能有用的其他格式中显示输出。

## 标准模块

在开始时，有一些类型的模块总是会加载。其中第一个是 `test` 模块，它只需要 Salt 自身的依赖项；特别是，它只需要 Python。

其他模块也设计用于通用用途，不需要比 Salt 自身的依赖项更多。`file` 模块将执行各种基于文件的操作。`useradd` 模块将包装标准的 Unix `useradd` 程序。这很好，只要 Salt 只在 Unix-like 平台上使用。当用户开始在 Windows 上运行 Salt 时，这些实用工具并不容易获得，情况就改变了。这正是虚拟模块真正开始发光的地方。

## 虚拟模块

在各种平台上支持 Salt，例如 Unix-like 和 Windows，与是否使 `nginx` 模块可用的问题类似：如果该平台已安装且可用，则使模块可用。否则，不要。Salt 通过实现虚拟模块来处理可用性问题。

虚拟模块背后的想法是它将包含一段代码，用于检测其依赖项是否满足，如果满足，则该模块将被加载并使该系统上的 Salt 可用。我们将在第二章*编写执行模块*中详细介绍如何实际执行此操作。

## 惰性加载模块

在开始时，如果检测到某个模块可加载，那么在 Salt 服务启动时就会加载该模块。对于特定系统，可能加载多个模块，管理员可能永远不会使用它们。虽然拥有它们可能不错，但在某些情况下，仅在需要时加载它们会更好。

当 Salt 服务启动时，惰性加载器将检测特定系统上可能使用的模块，但它不会立即将它们加载到内存中。一旦调用特定模块，Salt 将按需加载它，并将其保留在内存中。在一个通常只使用少量模块的系统上，这可以比以前产生更小的内存占用。

# 扩展加载系统

如我们之前所说，加载系统最初是为一种类型的模块设计的：我们现在称之为执行模块。不久之后，添加了其他类型的模块，而且这个数量至今仍在增长。

本书并不包括所有类型的模块，但它确实涵盖了相当多。以下列表并不全面，但它将告诉您现在可用的许多内容，并在您完成本书后可能给您提供一个关于其他类型模块的参考：

+   **执行模块**在 Salt 内部执行大部分繁重的工作。当需要调用一个程序时，将为它编写一个执行模块。当其他模块需要使用该程序时，它们将调用该模块。

+   **Grain 模块**用于报告关于 minion 的信息。**虚拟模块**通常严重依赖这些模块。配置也可以在 grains 中定义。

+   **Runner 模块**被设计用来给 Salt 添加脚本元素。而执行模块在 minion 上运行，runner 模块则会在 Master 上运行，并调用 minion。

+   **Returner 模块**为 minion 提供了一种将数据返回给 Master 以外的途径，例如配置为存储日志数据的数据库。

+   **State 模块**将 Salt 从远程执行框架转变为配置管理引擎。

+   **Renderer 模块**允许使用不同的文件格式（根据需要）定义 Salt States。

+   **Pillar 模块**通过提供更集中的配置定义系统来扩展 grains。

+   **SDB 模块**提供了一种简单的数据库查找功能。它们通常从配置区域（包括 grains 和 pillars）引用，以防止敏感数据以明文形式出现。

+   **Outputter 模块**影响命令行数据输出显示给用户的方式。

+   **外部文件服务器模块**允许 Salt 服务的文件存储在 Master 本地之外的地方。

+   **云模块**用于管理不同计算云提供商的虚拟机。

+   **信标**允许来自其他 Salt 组件或第三方应用程序的各种软件向 Salt 报告数据。

+   **外部身份验证模块**允许用户无需在 Master 上拥有本地账户即可访问 Master。

+   **Wheel 模块**提供了一种管理 Master 端配置文件的 API。

+   **代理 minion 模块**允许无法运行 Salt 平台的设备能够被当作完整的 minion 来处理。

+   **引擎**允许 Salt 向长时间运行的外部进程提供内部信息和服务的功能。实际上，最好将引擎视为它们自己的程序，并且与 Salt 有特殊的连接。

+   **Master Tops 系统**允许在不使用 `top.sls` 文件的情况下针对 States。

+   **Roster 模块**允许 Salt SSH 在不使用 `/etc/salt/roster` 文件的情况下针对 minion。

+   **Queue 模块**提供了一种组织函数调用的方式。

+   **pkgdb** 和 **pkgfile 模块**允许 Salt 软件包管理器存储其本地数据库并将 Salt 公式安装到本地硬盘以外的位置。

这些模块通常是按照必要性创建的。它们全部是用 Python 编写的。虽然其中一些可能相当复杂，但大多数创建起来都很简单。事实上，现在与 Salt 一起提供的许多模块实际上是由没有 Python 经验的用户提供的。

# 使用 Python 加载模块

Python 非常适合构建加载系统。尽管它被归类为一种非常高级的语言（而不是像 C 那样的中级语言），Python 对其内部管理的控制能力很强。Python 内置的强大模块内省功能对 Salt 非常有用，因为它使得在运行时任意加载虚拟模块变得非常顺畅。

每个 Salt 模块都可以支持一个名为`__virtual__()`的函数。这是检测该模块是否将在该系统上提供给 Salt 的函数。

当`salt-minion`服务加载时，它将遍历每个模块，寻找`__virtual__()`函数。如果没有找到，则假定该模块的所有要求已经满足，并且它可以被提供。如果找到该函数，则将使用它来检测该模块的要求是否满足。

如果一个模块类型使用懒加载器，那么可以加载的模块将被放置一旁，在需要时加载。不符合要求的模块将被丢弃。

## 检测颗粒

在 Minion 上，最重要的可能是加载颗粒。尽管颗粒模块很重要（并在第三章中讨论，*扩展 Salt 配置*)，但实际上有许多核心颗粒是由 Salt 本身加载的。

许多这些颗粒描述了系统上的硬件。其他描述了 Salt 运行的操作系统。例如，`os`和`os_family`颗粒被设置，并在以后用于确定哪些核心模块将被加载。

例如，如果`os_family`颗粒被设置为`redhat`，则位于`salt/modules/yumpkg.py`的执行模块将作为`pkg`模块被加载。如果`os_family`颗粒被设置为`debian`，则`salt/modules/aptpkg.py`将作为`pkg`模块被加载。

## 使用其他检测方法

颗粒并不是用于确定是否加载模块的唯一机制。Salt 还提供了一些可以使用的实用工具。`salt.utils`库包含了一些函数，它们通常比颗粒更快，或者比简单的`name=value`（也称为键值对）配置提供更多的功能。

一个例子是`salt.utils.is_windows()`函数，正如其名称所暗示的，报告 Salt 是否在 Windows 内部运行。如果检测到 Windows，则`salt/modules/win_file.py`将作为`file`模块被加载。否则，`salt/modules/file.py`将作为`file`模块被加载。

另一个非常常见的例子是`salt.utils.which()`函数，该函数报告是否有一个必要的 shell 命令可用。例如，这被`salt/modules/nginx.py`用于检测`nginx`命令是否对 Salt 可用。如果是的话，那么`nginx`模块将被提供。

我们还可以探讨其他许多例子，但在这本书中，几乎无法为所有这些例子提供足够的空间。实际上，最常见的一些例子最好通过示例来展示。从第二章《编写执行模块》开始，我们将开始编写使用我们已讨论过的示例以及其他大量示例的 Salt 模块。

# 摘要

盐的生成依赖于加载器系统的存在，该系统能够检测哪些模块能够被加载，然后只加载可用的部分。仅当需要时，才会加载使用懒加载的模块类型。

Python 是 Salt 的一个组成部分，使得模块的编写和维护变得容易。Salt 附带了一个函数库，它帮助支持加载器系统以及与之一起加载的模块。这些文件位于 Salt 代码库下的`salt/`目录下的各个目录中。例如，执行模块位于`salt/modules/`。

本章仅仅触及了 Salt 所能实现的可能性，但已经介绍了一些必要概念。从现在开始，重点将全部放在使用 Python 编写和维持模块上。
