# 第六章 设计模式

本章将向你介绍一些常用的设计模式。以下是本章的组织结构：

+   我们将从设计模式的一个快速介绍开始，然后讨论一些有助于简化它们实现的 Python 语言特性。

+   接下来，借助幻想游戏主题，我们将讨论以下设计模式：

    +   策略模式

    +   简单和抽象工厂模式

    +   适配器模式

+   对于每个模式，一个简单的游戏场景将演示一个实际的问题。我们将看到设计模式如何帮助解决这个问题。

+   我们还将使用 Python 方法实现这些模式中的每一个。

已知有几种设计模式。如前所述，我们只讨论其中的一些。我们的目的是不提供一本关于模式的全新食谱，而是仅仅展示设计模式如何帮助解决一些常见的问题，以及如何在 Python 中实现它们。除了这本书之外，你还可以探索其他传统的设计模式，并尝试为它们添加 Python 风格。

顺便说一句，你即将被介绍到一些新的游戏角色。所以准备好和 Sir Foo 和他的朋友们一起学习设计模式吧！

# 设计模式简介

假设在进行应用程序开发过程中，你遇到了一个反复出现的问题。沮丧之余，你向你的共同开发者或社区寻求帮助。猜猜看，你并不孤单。很多人在他们的代码中遇到过类似的问题。幸运的是，你得到了一个找到解决方案的人的回应。这个解决方案似乎在类似的问题上工作得很可靠。你修改了有问题的代码，使其符合建议的设计，哇！你的问题解决了！

我们刚才讨论的是软件设计模式。软件设计模式是一种经过验证的解决方案或策略，帮助我们解决代码中常见的难题。让我们从设计模式的广泛类别开始，然后讨论一些重要的设计原则。

### 注意

**四人帮书籍**：

在开始任何关于 Python 中设计模式的讨论之前，值得注意的是，有一本非常好的书你可能想在你的书架上，那就是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著的《设计模式：可复用面向对象软件元素》（Design Patterns: Elements of Reusable Object-Oriented Software）。这四位作者通常被称为**四人帮**（**GoF**）。他们的书使用 C++和 Smalltalk 示例来说明设计模式。如果你有 C++或 Java 等编程语言背景，这本书可能对你更有兴趣。正如你将在本章中看到的，Python 的一些高级语言特性使得许多设计模式更容易实现。GoF 的书仍然是一本很好的参考书，将帮助你理解设计模式背后的核心概念。

## 模式的分类

软件设计模式可以大致分为四类，即行为模式、创建模式、结构模式和并发模式。在本书中，我们将仅讨论三种设计模式。我们将分别看到一个行为模式、一个创建模式和结构模式的例子。并发模式在此不涉及，因为它是一个高级主题，超出了本书的范围。为了深入了解其他设计模式，你可以阅读关于设计模式的书籍，例如前面提到的 GoF 书籍。考虑到这一点，接下来我们将简要讨论这些类别。

### 行为模式

行为设计模式试图简化不同对象之间如何相互通信。在这样做的同时，这些模式有助于保持这些对象松散耦合或减少彼此的依赖。以下是一些行为设计模式的列表：责任链模式、命令模式、策略模式、观察者模式、迭代器模式、访问者模式，等等。在本章中，我们将看到如何在 Python 中实现策略模式。

### 创建模式

这些模式都是关于实例创建机制的。这些设计模式展示了根据你所处理的情况创建对象的更好方式。

下面是主要创建设计模式列表：抽象工厂模式、工厂方法模式、建造者模式、原型模式和单例模式。我们将在本章中讨论抽象工厂模式。

### 结构模式

结构设计模式通常处理组件之间的关系，例如对象或类，以便更容易使这些实体在一个更大、更复杂的系统中协同工作。结构设计模式的例子包括适配器模式、组合模式、装饰器模式、外观模式、享元模式、代理模式等等。在本章中，我们将看到适配器模式的 Python 实现。

### 并发模式

简而言之，并发意味着同时执行多项任务。并发使你的应用程序能够在执行一项任务（例如，更新数据库）的同时，也在处理其他事情（例如，响应用户查询）。一般来说，并发设计模式处理多线程编程范式。以下是一些并发模式的列表：主动对象模式、拒绝模式、监控对象模式、双重检查锁定，等等。如前所述，本书将不讨论任何并发模式。尽管如此，第九章 *性能提升 – 第二部分，NumPy 和并行化* 将介绍 Python 中多线程编程的一些方面。有关更多信息，请访问[`en.wikipedia.org/wiki/Concurrency_pattern`](https://en.wikipedia.org/wiki/Concurrency_pattern)。

# Python 语言和设计模式

由于 Python 中内置的高级语言特性，许多正式的设计模式都很容易实现。在某些情况下，这些模式对语言来说如此自然，以至于很难将其视为正式的设计模式。例如，迭代器模式可以通过使用任何可迭代对象来实现，例如列表、字典等。让我们快速回顾本节中的这些语言特性或范式。这不是一个详尽的列表，但我们将涵盖一些重要方面。

### 提示

你即将阅读的习语（一等函数、闭包等）可能听起来有些复杂。但不要被这些术语所压倒！如果你是 Python 程序员，那么你很可能已经有意或无意地使用了这些特性。如果这些习语对你来说现在毫无意义，请跳到下一节，在那里我们将快速跳到一个假想的游戏场景。在接下来的讨论中，我们将使用这些语言特性。当你需要方便的参考时，可以随时回到这一节。

## 一等函数

存在一个名为**一等公民**的编程习语。在 Python 中，任何函数、类、类方法或对象，都符合一等公民的资格。在这些实体上，你可以自由执行通常在其他实体上支持的操作。

例如，你可以将一个函数赋值给一个变量，就像你将一个值赋给该变量一样。同样，你可以将这个函数作为参数传递，或者从另一个函数的返回值中获取它。任何支持在函数上执行此类操作的编程语言都被说成具有一等函数。以下是一段简单的代码，展示了我们如何在 Python 中使用一等函数所能实现的事情。在这个例子中，一个函数`test`被赋值给一个变量`x`。赋值之后，该函数可以以`x()`或`test()`的形式调用：

```py
>>> def test(): 
...     print("inside test function") 
... 
>>> x = test 
>>> x() 
inside test function 
>>> x 
<function test at 0x7fca460efbf8> 

```

这里还有一个例子，说明了第一等函数特性。它展示了我们如何将相同的函数`test`作为参数传递给另一个名为`some_function`的函数：

```py
>>> def some_function(y): 
...     y() 
... 
>>> some_function(test) 
inside test function 

```

让我们看看我们可以用其他一等实体，Python 类，做什么。

## 作为一等对象的类

就像函数一样，Python 类也是一等公民。它们可以作为参数传递，赋值给变量，或从函数中返回。以下是一个例子，其中类`Foo`被赋值给变量`bar`。在这个赋值之后，你可以使用`bar`来创建`Foo`的一个实例：

```py
>>> class Foo:
...     def say_hi(self):
...         print("hi!")
... 
>>> bar = Foo
>>> z = bar()
>>> z.say_hi()
hi!

```

### 提示

我们在本章中不会使用闭包。这是一个相对高级的话题，包含在这里是为了完整性。你可以选择性地跳过下一节。

## 闭包

考虑任何在 Python 中定义了一些局部变量的函数。你可以在函数内部使用这些变量，但它们不能被外部世界访问（除非你从函数中返回它）。从某种意义上说，函数可以被认为是封闭的。当函数执行时，它使用这些局部变量；当函数完成后，局部变量超出作用域。它们的任务完成了，这就是故事的结尾。现在，如果你想要一个在创建时保持其局部环境的函数呢？

我们希望有一种方法可以将这个函数及其局部环境一起封装起来。以下示例可以更好地解释这一点：

![闭包](img/B05034_06_46.jpg)

在前面的示例中：

+   `modified_number`是`initial_number`函数内的嵌套函数。

+   这个嵌套函数使用一个局部变量`x`，它在顶层函数的作用域内。

+   在主程序中，我们创建了`foo`，它是`initial_number`的返回值。但看看`initial_number`函数的返回值。它返回嵌套函数`modified_number`。

+   这意味着`foo`变量变成了嵌套函数`modified_number`。

我们在这里实现了什么？我们实现了两个目标——首先，它使得从主程序中访问嵌套函数成为可能，其次，嵌套函数仍然保留了我们在实例化`initial_number`时使用的原始工作环境。在这个例子中，工作环境指的是传递给这个函数的具有`100`值的`x`参数。以下是该程序的输出：

```py
1\. Initial number (orig environment during function creation): 100 
2\. Now calling this function with its original environment loaded: 
 x: 100, y: 1 , x+y: 101 
 x: 100, y: 5 , x+y: 105

```

注意到`x`的值保持不变。任何后续对`foo`的调用都保留了这个原始的局部环境，这是嵌套函数`modified_number`使用的。同样，你也可以使用不同的`x`值创建`initial_number`的另一个实例。这被称为 Python 中的闭包。闭包可以用来实现如观察者模式等设计模式。

## 其他特性

让我们回顾一些在实现某些设计模式时非常有用的内置函数和装饰器。再次强调，这并不是一个完整的列表，但足以帮助我们进行即将到来的设计模式讨论。

### 类方法

类方法（`@classmethod`）是一种可以在不创建该类实例的情况下调用的方法。与需要将类的实例（`self`）作为其第一个参数的常规实例方法不同，类方法将类作为其第一个参数。装饰器`@classmethod`只是创建类方法的一种方便方式。我们将在简单工厂的讨论中看到如何使用类方法。

### 抽象方法

使用 `@abstractmethod` 装饰器来指示给定方法是抽象的，必须在子类中重新实现。回想一下，我们已经使用此装饰器将 `AbstractGameUnit.info()` 实现为抽象方法。有关更多详细信息，请参阅第一章中的*Python 中的抽象基类*部分，*开发简单应用程序*。在本章中，我们不会使用此装饰器。

### `__getattr__` 方法

当你尝试访问在类中尚未定义的实例属性时，Python 会自动调用 `__getattr__` 方法。你可以在类中实现 `__getattr__`，并使用它为所有此类未定义属性添加特殊处理代码。此方法的使用将在适配器模式中稍后进行说明。

## 鸭子类型

“鸭子类型”这个术语通常被举例说明为：“如果它像鸭子游泳和嘎嘎叫，那么我们就把它当作鸭子对待。”让我们通过一个简单的例子来看看这意味着什么。我们有一个名为 `Knight` 的类，具有 `move` 和 `attack` 方法，如下所示：

```py
class Knight: 
    def move(self): 
        pass 
    def attack(self): 
        pass 
```

一个函数接受 `Knight` 实例作为参数，并按如下方式调用这些方法：

```py
def do_something(a_thing): 
    a_thing.move() 
    a_thing.attack() 
```

然而，该函数不会检查输入参数是否真的是 `Knight` 类的实例。只要对象具有 `move` 和 `attack` 方法，它就不会抱怨。因此，在鸭子类型中，语言不会对对象进行任何验证。它唯一关心的是是否可以使用该对象调用某些属性。鸭子类型的一个优点是代码可重用性。你可以通过传递不同类的对象来在其他代码中重用 `do_something` 函数。

例如，想象一个实现了 `move` 和 `attack` 方法的 `Lion` 类。你希望在某个其他项目中重用上述 `do_something` 函数，该项目已经使用了这个类：

```py
 class Lion: 
    def move(self): 
        pass 
    def jump(self): 
        pass 
    def roar(self): 
        pass
```

只要输入对象定义了 `move` 和 `attack` 方法，`do_something` 函数就会正常工作。这一切如何转化为设计模式讨论？其他编程语言，如 Java，在代码中定义正式接口以实现某些设计模式，例如抽象工厂模式。在 C++ 中，使用纯虚函数定义抽象基类。在 Python 中，我们有选择使用鸭子类型而不是实现接口或抽象基类的选项。为了对设计模式本身有更清晰的理解，你可能仍然需要记录这样的抽象基类或接口。

### 小贴士

在 Python 中，我们仍然可以使用 Java 风格的接口。**Zope** 网络框架（本书未涉及）是一个很好的例子。有关更多信息，请访问以下链接：[`docs.zope.org/zope.interface/README.html`](https://docs.zope.org/zope.interface/README.html)。另外，请参阅稍后关于抽象工厂讨论中的注释，说明如何在 Python 中强制执行接口。

Duck typing 为程序员提供了很多自由，但这种自由有可能引入仅通过查看代码就难以察觉的 bug。但通过广泛的单元测试可以检测到这样的错误。减少此类问题的另一种方法是强制执行严格的编码标准和文档。例如，你可以创建一些自定义编码标准，以避免由于 Duck typing 引起的混淆。

通过对一些关键语言特性的基本介绍，让我们继续讨论如何实现一些设计模式，以及它们解决什么问题。

# 本章剩余部分的结构

在深入讨论设计模式和它们的实现之前，让我们首先为剩余的讨论制定一个策略。如前所述，我们将回顾策略模式、简单工厂模式和抽象工厂模式，以及适配器模式。关于设计模式的讨论将大致按照以下结构进行：

+   从模式的正式定义开始

+   提出一个新的功能请求的假设场景

+   讨论引入这个新功能时遇到的问题

+   尝试快速解决这个问题，很快意识到我们需要重新思考设计

+   使用设计模式解决问题的方案

对于一些设计模式，我们将讨论两种解决问题的方法。一种类似于在 C++等语言中遵循的传统方法，另一种是 Pythonic 方法。

### 小贴士

如果你只对 Pythonic 方法感兴趣，可以跳过传统解决方案。

以下是从支持代码包中将要审查的文件列表：

![本章剩余部分的结构](img/B05034_06_47.jpg)

值得注意的是，我们不会开发一个完整的功能游戏应用。这个想法是利用这个游戏主题作为理解一些设计模式的辅助。本章使用的代码相当简单。虽然大部分代码将在接下来的讨论中展示，但你也可以从本章的补充代码包中下载并审查源代码。

# 快进 – 魔兽攻击 v6.0.0

让我们快速跳到游戏的未来假设版本！

| 这个假设版本是最受欢迎的开源 Python 应用程序之一。现在你有一支开发团队帮助你进行应用开发。游戏已经发展得相当多。它不再是一个简单的应用，通过击败敌人来控制小屋。现在它是一个回合制的幻想游戏，玩家和敌人轮流攻击对方，或者利用这个回合向对手靠近或远离。**你引入了几个新的游戏任务，并重新设计和重构了代码以适应新的要求。在最新版本中，你有以下游戏角色：骑士、兽人骑手和精灵骑手。** |
| --- |

### 小贴士

**精灵**是一种想象中的超自然神话生物。请参阅第一章中的*书籍主题*部分，*开发简单应用程序*，以获取有关精灵的一些参考资料。

在这个版本中，每个游戏角色都有攻击敌人、向敌人靠近或远离敌人，或在棚屋内恢复的能力。我们不必担心实现这些功能的应用程序的实际逻辑。我们更应关注应用程序的高级设计。以下伪 UML 图显示了各种类及其一些公共方法：

![快进 – 魔兽攻击 v6.0.0](img/B05034_06_01.jpg)

### 注意

如第一章中所述，*开发简单应用程序*，我们将松散地遵循 UML 表示。我们将其称为伪 UML 图。这里使用的惯例的解释是必要的。图中的每个类都由一个圆角矩形表示。它显示了类名后跟其属性。属性前的加号（`+`）表示它是公共的。受保护的或私有方法通常用负号（`-`）表示。为了便于说明，只列出了几个相关的公共属性。

如类图所示，所有游戏角色都继承自一个共同的超类`AbstractGameUnit`。每个子类都有自己的`info()`和`attack()`实现。换句话说，每个子类都有自己攻击敌人的方式。进一步假设在上述版本中，所有子类都使用在超类中定义的公共`move()`方法。如果你看到游戏说明的实际操作，这可能会更容易想象。

请参阅以下截图，展示了玩家将被提示进行移动的方式：

![快进 – 魔兽攻击 v6.0.0](img/B05034_06_02.jpg)

### 注意

**太棒了！我想玩这个新游戏场景。源代码在哪里？**

这里的意图不是开发完整的游戏逻辑。这是一个想象场景，仅用于突出应用程序开发中常见的一些问题。通过这个场景，我们将看到设计模式如何帮助解决这些问题。没有提供代码来实际“玩”这个新游戏。支持代码说明了如何实现这里讨论的各种设计模式。

如从命令行输出中可见，它为玩家提供了选择向四个方向之一移动的选项。它还指示了每个方向前方的情况。在这个特定的情况下，玩家决定向南移动，但这种移动受到栅栏的限制。

# 策略模式

策略设计模式是一种行为模式，用于表示一组算法。该家族中的一个算法表示为一个策略对象。该模式使得在特定家族的不同策略（算法）之间轻松切换。这通常在你想要在运行时切换到不同的策略时非常有用。我们将在讨论策略模式的末尾重新审视这个定义。

## 策略场景 – 跳跃功能

| *有一个高优先级的特性请求。更确切地说，这是一个投诉。用户们只是讨厌栅栏强加的运动限制。现在连 Foo 爵士也加入了抗议...* |
| --- |

![策略场景 – 跳跃功能](img/B05034_06_03.jpg)

| *与其从场景中移除栅栏，不如添加一个新功能，允许单位跳过栅栏或任何类似的障碍物？* |
| --- |

你在超类 `AbstractGameUnit` 中引入了一个新的方法，`jump()`。所有类都继承了这个方法，如下面的类图所示：

![策略场景 – 跳跃功能](img/B05034_06_04.jpg)

栅栏不再阻止玩家移动。新的跳跃选项使得跨越栅栏没有任何问题。这很简单，不是吗？每个人都感到高兴（尤其是 Foo 爵士）！

## 策略 – 问题

让我们快速前进到应用的一些更多主要版本。

| *你向游戏中引入了两个新的虚构角色，一个矮人和一个精灵，提供了独特的技能。例如，精灵拥有治愈你军队中附近受伤单位的能力，而矮人单位则提供对敌人攻击的坚固防线。因此，每周的应用程序下载量现在已经达到了新的高峰。然而，用户们报告了一个新的问题。让我们听听伟大的矮人的意见：* |
| --- |

![策略 – 问题](img/B05034_06_05.jpg)

你在这里看到了问题吗？跳跃功能有一个不希望出现的副作用。它甚至允许精灵或矮人跳过栅栏。骑士、精灵骑手和兽人骑手都是骑乘单位。想象这些单位跳过栅栏更容易。然而，对于一个像矮人这样的游戏角色来说，这样思考并不直观。我们遇到这个问题是因为所有类都使用了 `AbstractGameUnit.jump` 方法的默认实现。如下面的类图所示：

![策略 – 问题](img/B05034_06_06.jpg)

## 策略 – 尝试的解决方案

精灵和矮人游戏单位不应该有跳跃功能。那么我们在这里能做什么呢？精灵有话要说：

![策略 – 尝试的解决方案](img/B05034_06_07.jpg)

使用继承当然是一种方法。你可以在新类中覆盖`jump`方法，使其成为无操作。然而，在下一个版本中，你计划引入一些不应该跳跃或需要以不同方式跳跃的新角色。以下是一些在以下类图中表示的新类。所有这些都需要覆盖并实现它们自己的逻辑。

![策略 – 尝试的解决方案](img/B05034_06_08.jpg)

跳跃功能只是你将看到这个问题的地方之一。我们甚至不需要超出我们已有的内容。在上面的图中，看看`move`和`attack`方法。你是否看到了同样的问题在酝酿？

游戏角色在进化。它们有自己的移动规则。例如，骑马的`Knight`可能需要两回合就能穿越河流，而`DwarfFighter`则需要 10 回合才能完成同样的任务。

同样，每个单位都有其独特的攻击敌人的风格。你军队中的老`Wizard`可以对敌人施展魔法咒语。`ElfRider`角色在一回合内使用弓箭攻击两次。`DwarfFighter`角色则使用锤子攻击，等等。

如果我们继续在这里使用继承原则，很快就会变成一个维护噩梦。为什么？这是因为你写的每个类都负责实现和维护其移动、跳跃和攻击能力的逻辑。最初，你可能认为这是一个微不足道的问题，在子类中覆盖功能即可解决问题。但随着角色类型和它们不断增长的能力（移动、跳跃、游泳、防御、隐藏、再生等）的增加，这将会变成一项艰巨的任务。代码也可能在各个类之间重复。

逻辑的任何小改动都需要你更新所有类中的相应方法。如果在更新过程中遗漏了一些方法，也可能引入新的错误。我们需要重新思考设计，以便更容易地适应未来的需求。让我们接下来这么做。

## 策略 – 重新思考设计

在这种情况下我们能做什么？观察发现，定义这些能力的实现代码在子类之间是不同的。在这个例子中，`DwarfFighter`不能跳跃，而`Knight`则骑马跳跃。

首先要问的问题是为什么这些类要承担定义能力的负担？这能否外包给不同的类或函数？我们将重新设计`AbstractGameUnit`类（及其子类），使得各种能力现在由专门处理这些任务的对象来处理。换句话说，我们将使用对象组合来减轻`AbstractGameUnit`及其子类的工作负担。

### 注意

回想一下，在第一章《开发简单应用程序》中，我们使用了`Hut`类中的对象组合，其中其`occupant`由不同的对象表示。对象组合允许你通过组合简单对象来表示复杂对象。大声说出来，骑士有移动的能力，骑士有跳跃的能力，等等。每种能力都将由单独的对象表示。

我们如何实现这个新设计？我们将讨论两种解决问题的方法。第一种方法更像是经典方法，类似于在其他语言（如 C++）中通常遵循的方法。如果你有这样的开发背景，这种方法看起来会更熟悉。第二种方法更符合 Python 风格。它使用 Python 中的第一类函数，这是一种语言特性。第二种方法将使整个问题看起来微不足道。如果你对传统方法不感兴趣，可以跳到策略模式的 Python 解决方案。

## 策略解决方案 1 – 传统方法

在上一节中，我们决定创建专用对象来表示如跳跃等能力。让我们绘制一个类图来更好地解释这一点：

![策略解决方案 1 – 传统方法](img/B05034_06_09.jpg)

这里是对前面图表所表示内容的更详细描述：

+   现在有三个新类，`AttackStrategy`、`MoveStrategy`和`JumpStrategy`，分别处理`attack`、`move`和`jump`方法的逻辑。

+   现在的`AbstractGameUnit`类由这些类的实例组成，即`attack_strategy`、`move_strategy`和`jump_strategy`。

+   `AbstractGameUnit.jump`方法只是调用`jump_strategy.jump()`。对于`move`和`attack`方法，采用类似的实现方式。

由于游戏角色需要它们自己的跳跃实现，我们将创建`JumpStrategy`的子类。例如，一个子类`CanNotJump`可以用于无法跳跃的游戏单位。以下类图展示了这一点：

![策略解决方案 1 – 传统方法](img/B05034_06_10.jpg)

### 注意

**重新审视策略模式定义**：

我们从策略模式的定义开始讨论。这个设计模式代表了一组算法。仔细看看前面的类图。`JumpStrategy` 及其子类代表了一组算法。每个这些类中定义的功能相当于一个算法或策略。这些类属于同一个家族，因为任何算法的执行都与跳跃有关。例如，`PowerJump` 类定义了一个与 `HorseJump` 类不同的算法。同样，`MoveStrategy` 定义了一组移动算法，`AttackStrategy` 定义了攻击敌人的算法。为了完成策略模式，我们还需要一种动态在算法家族之间切换的方法。让我们看看如何实现这一点。

让我们回顾一下新的类 `JumpStrategy`。它现在定义了之前在 `AbstractGameUnit` 中定义的跳跃行为。整体逻辑由以下示意图和代码片段表示。为了便于理解，我们只讨论与跳跃能力相关的函数：

![策略解决方案 1 – 传统方法](img/B05034_06_11.jpg)

因此，我们有一个由 `JumpStrategy` 及其子类表示的算法系列。以下是相关的代码片段，展示了 `AbstractGameUnit` 和 `DwarfFighter` 类。支持文件 `strategypattern_traditional.py` 包含此代码：

![策略解决方案 1 – 传统方法](img/B05034_06_12.jpg)

实例变量 `self.jump_strategy` 用于表示跳跃行为的一种策略或算法。`AbstractGameUnit` 的子类可以选择由 `JumpStrategy` 类及其子类定义的算法系列中的任何跳跃策略。例如，`DwarfFighter` 子类可以使用 `CanNotJump` 类中定义的算法作为其跳跃策略，等等。`AbstractGameUnit.jump` 方法现在是调用代码的 API 方法。此方法依赖于策略对象来实现实际的跳跃。它只是调用该策略对象的相应方法，如前一个类图所示。

在这个简单的例子中，子类 `DwarfFighter` 只覆盖了抽象方法 info。你可以为这个类添加一些额外的定制。现在让我们看看跳跃功能的算法系列：

![策略解决方案 1 – 传统方法](img/B05034_06_13.jpg)

如前所述，目的不是开发一个完整的游戏应用程序，而是仅仅理解应用开发中的重要概念。在这个微不足道的例子中，我们只是打印一条信息性消息来阐述这个概念。在实际实现中，这些是定义你的算法的类。最后，让我们回顾一下实例化游戏角色并动态设置不同跳跃策略的调用代码：

![策略解决方案 1 – 传统方法](img/B05034_06_14.jpg)

我们首先创建 `jump_strategy`，这是一个定义单位如何跳跃的对象。在这种情况下，它被作为参数传递给 `DwarfFighter` 的 `__init__` 方法。或者，你也可以在这个类中定义一个默认策略对象，因为我们知道这个类的默认行为（单位不能跳跃）。然后你可以调用 `set_jump_strategy` 来切换到不同的跳跃算法，如代码片段所示。以下是这个程序的输出：

![策略解决方案 1 – 传统方法](img/B05034_06_15.jpg)

## 策略解决方案 2 – Pythonic 方法

我们在上一个章节中讨论的更多的是一种传统方法，通常在像 C++ 这样的编程语言中遵循。鉴于 Python 语言提供的灵活性，实际上没有必要像前一个解决方案中那样定义各种策略类。我们将利用前面讨论的一等函数语言特性。让我们看看修改后的代码。你还可以在代码包中的 `strategypattern_pythonic.py` 文件中找到这段代码：

![策略解决方案 2 – Pythonic 方法](img/B05034_06_16.jpg)

在前面的代码中，我们使用了 Python 语言支持将函数（`jump_strategy`）赋值给变量（`self.jump`）的功能。我们为什么要这样做？当我们回顾下一个代码片段时，答案就会变得清晰。在那之前，让我们快速讨论一下前面的代码片段。

### 注意

**以下断言语句我们到底实现了什么？**

```py
assert(isinstance(jump_strategy, Callable))
```

这段话来自前面代码片段中的 `AbstractGameUnit.__init__` 方法。在将函数赋值给变量之前，我们需要确保它确实是一个函数。这个断言语句会在条件不满足的情况下阻止代码的进一步执行。这个想法很简单。你想要确保 `jump_strategy` 是一个可调用的对象。任何可调用的对象都定义了一个内置的 `__call__()` 方法。`collections.abc.Callable` 类是所有提供内置 `__call__()` 方法的类的抽象基类。在 `assert` 语句中，我们检查 `jump_strategy` 是否是这个 `Callable` 类的实例。对于 Python 2.7.9，这个类应该直接导入为 `collections.Callable`。

如前所述，让我们回顾一下实例化游戏角色（`矮人`）并动态设置不同跳跃策略的代码片段：

![策略解决方案 2 – Pythonic 方法](img/B05034_06_17.jpg)

将此代码与之前讨论的第一个方法进行比较。这里有一个区别。在先前的解决方案中，在实例化`DwarfFighter`时，我们传递了一个处理跳跃行为的`CanNotJump`类的实例。在这里，我们传递了`can_not_jump`函数作为参数，就像任何简单变量一样。为了动态更改`jump`算法，我们只需将`dwarf.jump`赋值给`power_jump`，如图所示。现在当我们调用`dwarf.jump()`时，它实际上执行了`power_jump()`函数中的代码。

### 小贴士

**关于 Python 风格的方法**:

我们刚才看到的是一个酷炫的 Python 风格，让事情变得非常简单。如果你来自 C++或 Java 编程背景，一开始你可能不太适应 Python 提供的自由度。例如，可能会出现程序员错误地将函数参数视为简单变量的情况，从而导致潜在的 bug。但这不应该阻止你使用这个出色的语言特性。为了避免这样的问题，你应该很好地记录代码，以便每个输入参数的目的清晰。

# 简单工厂

简单工厂通常不被视为正式的设计模式，但你会在日常编程中发现它非常有用。在本节末尾获得的理解将有助于讨论一个更正式的模式，即抽象工厂设计模式。让我们从简单工厂的定义开始。

工厂封装了实例创建的部分。客户端代码不需要知道实例创建的逻辑。它只知道，每当它需要特定类型的对象时，工厂就是首选的地方。任何用于构建此类对象的类、函数或类方法通常被称为工厂。简单工厂是你经常会用到的东西。它通常被认为比正式的设计模式更优秀的面向对象技术。

## 简单工厂场景 – 招募功能

| *回想一下，我们已将游戏快进到一个名为“Orcs 的攻击 v6.0.0”的虚构未来版本。这个版本引入了另一个备受期待的功能，允许招募新单位与敌人作战。* |
| --- |

这里是新类`Kingdom`的`recruit`方法的初始版本，其他方法未展示。让我们假设它们存在。进一步假设玩家或敌人可以招募以下游戏角色中的任何一个：`ElfRider`、`Knight`、`DwarfFighter`、`OrcRider`和`OrcKnight`：

![简单工厂场景 – 招募功能](img/B05034_06_18.jpg)

`recruit`方法包含基于用户输入（`if..else`块）创建游戏单位的逻辑。一旦角色创建完成，`Kingdom`就会支付雇佣费用（`pay_gold`），并且中央数据库会更新以反映军队中新成员的加入（`update_records`）。

## 简单工厂 – 问题

| 如预期，用户喜欢这个*功能，现在希望有招募更多单位类型的能力。让我们看看 Sir Foo 有什么要说的：* |
| --- |

![简单工厂 – 问题](img/B05034_06_19.jpg)

让我们添加新的招募类型，为了避免 Sir Foo 的愤怒，移除`OrcKnight`：

![简单工厂 – 问题](img/B05034_06_20.jpg)

如前述代码片段所示，这已经变得难以维护。明天，你可能会决定支持更多的单位，或者移除一些现有的单位。我们如何处理这个问题？让我们看看下一个。

## 简单工厂 – 重新思考设计

我们能说些什么关于`recruit`方法中的那个大`if..else`块呢？它是可以改变的。方法中的其余代码只是记账（例如，更新记录）并且保持不变。如果我们把那块变量代码移除并给它一个新的家呢？这将减轻`recruit`方法的负担，这样你就不需要在需求有变化时每次都打开它进行编辑。接下来要问的问题是，我们将把这段代码放在哪里？

![简单工厂 – 重新思考设计](img/B05034_06_21.jpg)

是的，Fairy，这是一个选项。你可以在`Kingdom`类中创建一个新的方法，并将所有这些对象创建代码放在那里。

但想象一下一个游戏场景，其中有一个庞大的银河系军队，由`GalacticArmy`类表示。这个类需要一种招募或获取各种游戏角色的方法。它与`Kingdom`类毫不相干。因此，我们无法在`Kingdom.recruit`中重用对象创建代码。

让我们让`Kingdom`类摆脱创建新单位的责任。再一次，我们将使用对象组合原则。将有一个新的类（甚至是一个函数），它封装了实例创建的部分。我们将称之为简单工厂。客户端代码（在这个讨论中的`Kingdom`或`GalacticArmy`类）现在可以使用这个工厂来获取特定类型的对象。

## 简单工厂解决方案 1 – 传统方法

现在是时候实现简单工厂了。让我们首先回顾一下传统方法。

### 小贴士

这是最低限度的代码，没有任何异常处理。目的是仅仅为了说明使用类似于 C++实现风格的简单工厂。你可以作为一个练习使它更健壮。代码可以在`simplefactory_traditional.py`文件中找到。这个例子被写成单个模块以方便理解。理想情况下，你应该重构它，并将类放在它们自己的模块中。

看看下面的重构代码。我们从一个新的类开始，`UnitFactory`，它封装了对象创建的部分：

![简单工厂解决方案 1 – 传统方法](img/B05034_06_22.jpg)

在前面的代码中，我们将之前讨论的 `Kingdom.recruit` 方法中的大 `if..else` 子句重构出来，并将其放入 `UnitFactory` 类的 `create_unit` 方法中。`create_unit` 方法只有一个职责，即根据给定的输入参数（`unit_type`）创建并返回一个游戏角色的实例。以下是在此重构后的 `Kingdom` 类：

![简单工厂解决方案 1 – 传统方法](img/B05034_06_23.jpg)

`self.factory` 实例代表 `UnitFactory`。在 `recruit` 方法中，创建游戏角色的责任委托给了这个工厂对象。`pay_gold` 和 `update_records` 方法只是为了完整性而展示。让我们不要担心这两个方法内部的逻辑。它们保持不变。最后，以下是一种使用工厂的方法。代码是自解释的：

![简单工厂解决方案 1 – 传统方法](img/B05034_06_24.jpg)

在这个例子中，我们没有展示的是我们工厂实际使用的具体产品类（如 `ElfRider`、`Knight` 等）的实现。这些类将与我们之前讨论过的类相似。例如，所有这些具体类都可以是 `AbstractGameUnit` 的子类。这些细节在我们刚刚覆盖的例子中没有展示。然而，实现简单工厂的方法不止一种。在 Python 中，我们还可以用其他方式处理这个问题。接下来将讨论其中一种方法。

## 简单工厂解决方案 2 – Pythonic 方法

上一节中提出的解决方案有一个问题。你仍然需要在 `create_unit` 中维护 `if..else` 块。另一个问题是，我们真的需要实例化 `UnitFactory` 吗？根据你的应用程序，答案可能是是或否。在这个例子中，`create_unit` 代码对于你创建的每个工厂实例都是相同的。所以，我们实际上不需要 `UnitFactory` 的实例。让我们讨论如何在不实际实例化的情况下实现简单工厂。

### 小贴士

这里展示的并不是实现简单工厂的唯一方法。源代码在支持材料中作为 `simplefactory_pythonic.py` 提供。根据你处理的问题类型，你可以进一步调整这种方法，并提出不同的解决方案。例如，你可以选择一个工厂实例，并像访问普通实例方法一样访问其方法。这种方法在 `simplefactory_pythonic_alternatesolution.py` 文件中有展示。

这里是来自文件 `simplefactory_pythonic.py` 的重新工作的 `UnitFactory` 类：

![简单工厂解决方案 2 – Pythonic 方法](img/B05034_06_25.jpg)

在本章早期，我们回顾了一些对设计模式有帮助的 Python 语言特性。让我们看看如何使用一等类和类方法在简单工厂中应用：

+   `units_dict` 是一个作为类变量声明的 Python 字典对象（对于 `UnitFactory` 类）。

+   Python 类是一等对象。因此，我们可以简单地将其作为字典 `units_dict` 的值。字典键可以是您选择的唯一字符串。只需确保调用代码知道哪个键对应哪个类。

+   `create_unit` 方法被定义为使用装饰器 `@classmethod` 的类方法。这意味着传递给此方法的第一个参数是类本身（表示为 `cls`），而不是 `self`（类的实例）。

+   现在看看 `create_unit` 方法的 `return` 语句：

    ```py
    return cls.units_dict.get(key)()
    ```

    在这里，我们通过 `cls.units_dict` 访问类变量 `units_dict`，并根据输入参数提供的特定键获取其值。这可以通过一个例子更好地解释。假设给定的键是 `elfrider`。字典中对应的值是 `ElfRider` 类。因此，`create_unit` 方法将返回 `ElfRider()`，它是 `ElfRider` 类的一个实例。

将此代码与我们在上一标题中看到的代码进行比较，*简单的工厂解决方案 1 – 传统方法*。如可注意到，代码行数并没有显著减少。但这里的代码清晰度要好得多。您仍然需要维护字典对象（`units_dict`）以供所有未来的需求，这相对于维护 `if..else` 子句来说相对容易。

现在观察 `Kingdom` 类。它只有几个变化：

![简单的工厂解决方案 2 – Pythonic 方法](img/B05034_06_26.jpg)

让我们回顾一下前面的代码片段

+   首先，我们将 `UnitFactory` 类赋值给类变量 `factory`。我们之所以能够这样做，是因为 Python 类是一等对象。

+   `recruit` 方法是 `Kingdom` 的一个普通实例方法。类变量 `factory` 通过 `type(self).factory` 访问。

+   在这个例子中，`type(self).factory.create_unit` 等同于 `UnitFactory.create_unit`。我们本可以直接那样写，但如果 `Kingdom` 的子类将其 `factory` 定义为不同的类，例如 `DwarfUnitFactory`，那么它将需要您编写一些额外的代码，例如重写 `recruit` 方法。

最后，这里是调用代码。请注意，我们没有创建任何 `factory` 实例：

![简单的工厂解决方案 2 – Pythonic 方法](img/B05034_06_27.jpg)

对简单工厂的讨论为正式设计模式——抽象工厂模式奠定了基础。让我们接下来回顾一下。

# 抽象工厂模式

我们刚刚学习了如何在程序中创建和使用简单的工厂。让我们更进一步，研究一个称为抽象工厂模式的形式化模式。

想象一下，我们有一个主工厂和一些跟随工厂。进一步假设每个跟随工厂负责生产其自己的品牌产品（对象）。跟随工厂在某种程度上是相关的。它们创建具有共同主题的产品。例如，每个跟随工厂都生产其自己的番茄酱版本。这些工厂有自己的产品订购表格。

客户在保持这么多订购番茄酱的表格方面感到困难。例如，一个工厂说你应该称之为 MyRedTomatoKetchup，否则它不会理解。因此，主工厂说：

| *我们制造的产品就像一个大家庭的一部分。如果我们可以简化并标准化从我们工厂集团订购这些产品的程序，我们的客户将受益。从现在起，每个跟随工厂都必须实现一个共同的订购表格。* |
| --- |

客户受益，因为他们只需要知道高级名称番茄酱和可以提供这种产品的工厂。让我们用编程术语来表达这一点：

+   主工厂是一个抽象工厂，而跟随工厂是具体工厂。

+   番茄酱是一个抽象类。每个具体工厂都创建其定制的番茄酱版本；我们将称之为具体对象（具体类的实例）。

+   之前提到的标准化程序被称为接口。抽象工厂声明了这样一个接口（或者用 Python 术语来说，一组抽象方法），具体工厂必须实现它以创建具体对象系列。

+   客户是客户端代码。它不需要知道从具体工厂接收到的具体对象的详细信息。它只需要了解抽象类。

### 注意

Java 编程语言有一个创建抽象类型接口的条款。如果一个类实现了接口，它必须实现该接口描述的所有方法。有关 Java 语言中接口的更多信息，请访问维基页面：[`en.wikipedia.org/wiki/Interface_(Java)`](https://en.wikipedia.org/wiki/Interface_(Java))。在 Python 中，没有这样的正式条款来创建和实现接口。相反，我们可以使用继承，具体工厂从抽象工厂继承。或者，我们可以使用之前讨论过的一等特性。让我们看看这些。

太多了？让我们通过一个游戏场景更深入地了解抽象工厂模式。

## 抽象工厂场景 – 配件商店

| *想象一下，你已经实现了一个新功能，允许为你的军队购买配件。目前，你可以购买装甲夹克或金质护身符，如下面的代码片段所示：* |
| --- |

![抽象工厂场景 – 配件商店](img/B05034_06_28.jpg)

添加了更多关于装甲和护身符的选择如下：

![抽象工厂场景 – 配件商店](img/B05034_06_29.jpg)

| *你重构了前面的代码，并实现了一个简单工厂。这个工厂将生产游戏角色的所有配件。在这个例子中，它将返回盔甲和护身符对象。* |
| --- |

下一个展示的是实现简单工厂的重构代码：

![抽象工厂场景 – 配件商店](img/B05034_06_30.jpg)

下一个展示的是`Kingdom`类和主要执行代码。`Kingdom`类有一个实例变量`self.factory`，它代表我们的简单工厂：

![抽象工厂场景 – 配件商店](img/B05034_06_31.jpg)

`self.factory`变量用于创建`armor`和`locket`实例，如`buy_accessories`方法中所示。

### 小贴士

如简单工厂部分所示，工厂也可以指定为一个类属性，通过`Kingdom.factory`访问，而不是创建一个实例，`self.factory`。

![抽象工厂场景 – 配件商店](img/B05034_06_49.jpg)

| *你所做的更改简化了实现。看起来 Foo 爵士对他的新铁甲非常满意，然而，其他人似乎并不这么认为！有一个* *新问题...* |
| --- |

## 抽象工厂 – 问题

| *一种尺寸* *并不适合所有人！矮人王国现在使用这个 AccessoryFactory，并报告了产品的问题：* |
| --- |

![抽象工厂 – 问题](img/B05034_06_32.jpg)

| *伟大的矮人现在对工厂不支持其创建的产品进行定制感到烦恼。我们如何解决这个问题？* |
| --- |

这是我们可以使用抽象工厂模式的一个场景。

## 抽象工厂 – 重新思考设计

观察以下类图。它代表了一个典型的抽象工厂模式，我们解决问题的方法：

![抽象工厂 – 重新思考设计](img/B05034_06_33.jpg)

让我们回顾一下这里展示的类似 UML 的图的组成部分，并将它们与之前抽象工厂定义中使用的术语相对应：

+   `DwarfAccessoryFactory`，`ElfAccessoryFactory`：跟随者或具体工厂。回想一下，每个具体工厂都创建具有共同主题的产品。在这里，它们为游戏角色创建配件。如前所述，它们需要实现由主工厂设定的标准程序。

+   `AbstractAccessoryFactory`：这是抽象工厂类，或者我们之前所说的主工厂。它定义了一个接口（一组抽象方法），具体工厂必须实现。在这种情况下，每个具体工厂都需要实现创建盔甲和护身符的方法。

+   在这个例子中，每个具体工厂都实现了`create_armor`和`create_locket`方法。这些方法返回具体产品类的实例。因此，每个工厂都创建了自己风格的产品。例如，`DwarfAccessoryFactory`的`create_locket`方法返回`DwarfGoldLocket`的实例，而`ElfAccessoryFactory`中的相同方法返回`ElfGoldLocket`的实例。

+   `AbstractArmor`, `AbstractLocket`：这些是抽象产品类。可能存在几个具体产品类型从这些抽象类继承。例如，具体产品类`DwarfGoldLocket`和`SuperLocket`从`AbstractLocket`继承，等等。

+   **客户端代码**：这没有在类图中展示。客户端代码不需要知道哪个具体产品类能提供它所需的产品。它只知道产品的高层名称（例如，`create_locket`）。本质上，它选择工厂，并调用标准 API 方法，如`create_locket`，以获取所需的对象。请参见下一节中的示例。

### 进一步简化设计

上述类图展示了实现抽象工厂模式的一种经典方式。为了便于理解，让我们进一步简化问题。我们将假设所有具体工厂都定义了所需的方法，而无需抽象工厂强制执行（接口）规则。 

基于这个假设，我们甚至可以完全从设计中移除`AbstractAccessoryFactory`类，只保留具体工厂。回想一下，我们在本章开头讨论了鸭子类型。因此，只要具体工厂实现了所需的方法，客户端代码（参见下一例中的`Knight.buy_accessories`）就不会抱怨。

为了概念上的理解，我们将在接下来的讨论中保留继承层次结构。我们将把这个类简单地称为`AccessoryFactory`，并且不会将`create_armor`和`create_locket`定义为抽象方法。强制执行接口需要在代码中进行一些小的调整。我们将在下一节的末尾简要讨论这一点，作为一个可选或高级主题，在那里我们将查看实际的实现。

## 抽象工厂解决方案 – Pythonic 方法

在上一节中，我们看到了一个展示抽象工厂模式实现细节的代表类图。我们将只讨论实现此模式的 Pythonic 解决方案。由于我们已经深入探讨了简单工厂，抽象工厂模式只是几步之遥。我们将讨论一些重要的类。请查看支持代码中的`abstractfactory_pythonic.py`文件以获取完整的源代码。

下一个示例中展示了`Kingdom`和`DwarfKingdom`类。代码是自解释的，并且之前已经讨论过：

![抽象工厂解决方案 – Pythonic 方法](img/B05034_06_34.jpg)

让我们看看`AccessoryFactory`类（参见上一标题下关于设计简化的注释，*进一步简化设计*）：

![抽象工厂解决方案 – Pythonic 方法](img/B05034_06_35.jpg)

这与我们在简单工厂实现部分中审查的`UnitFactory`类非常相似。唯一的区别是工厂生产两个独立的产品，`armor`和`locket`。因此，我们为每个具体产品定义了两个不同的类方法（工厂方法）。`armor_dict`字典以与盔甲相关的具体类作为其值，而`locket_dict`用于与挂锁相关的类。这两个都是定义为类变量。

以下代码片段是为`DwarfAccessoryFactory`这个具体工厂之一。在这里，我们只重新定义了`armor_dict`和`locket_dict`字典。其他什么都没有改变。同样，你也可以定义其他具体工厂，如`ElfAccesoryFactory`。如果你想实现严格的抽象工厂模式，你也应该在具体工厂中强制执行一个接口。这一点在本节的末尾简要讨论：

![抽象工厂解决方案 – Pythonic 方法](img/B05034_06_36.jpg)

最后一个拼图碎片是主执行代码。它创建了两个王国，第一个是默认的`Kingdom`，第二个是*伟大的矮人*王国——`DwarfKingdom`。这是通过以下方式完成的：

![抽象工厂解决方案 – Pythonic 方法](img/B05034_06_37.jpg)

注意到`buy_accessories`在两个王国中用相同的参数`ironjacket`和`goldlocket`被调用。但是每个王国得到的具体产品取决于选择的工厂。例如，由于`DwarfKingdom`选择了`DwarfAccessoryFactory`作为其工厂，对于名为`ironjacket`的抽象产品，它会得到一个`DwarfIronJacket`的实例。以下是在`abstractfactory_pythonic.py`文件中的代码的示例输出：

![抽象工厂解决方案 – Pythonic 方法](img/B05034_06_38.jpg)

### 高级主题 – 强制执行接口

本节说明了在 Python 中强制执行接口的一种方法。如果你现在对此不感兴趣，请忽略它并继续下一个主题。

回想一下，为了简化 Pythonic 解决方案的说明，我们简化了问题。`AccessoryFactory`不强制要求子类实现`create_armor`和`create_locket`方法。实际上，这样做很简单。如果你使用 Python 3.3 或更高版本，你可以简单地定义这些方法作为类方法，并使用两个装饰器`@classmethod`和`@abstractmethod`，如下所示：

```py
@classmethod 
@abstractmethod 
def create_armor(cls, armor_type): 
    return cls.armor_dict.get(armor_type)()
```

在像 `DwarfAccessoryFactory` 这样的子类中，你只需要实现这些类方法。为了完整性，通过从 `ABCMeta` 继承来使 `AccessoryFactory` 成为抽象类。技术上，这将确认抽象工厂的正式设计。但如果你看看这个方法（`create_armor`）内部的代码，它一点都没变。因此，在这个例子中，声明一个抽象方法只会帮助强制执行子类必须实现某些方法的规则。

# 适配器模式

适配器设计模式允许两个不兼容的接口之间进行握手。在这里，一个类或库的不兼容接口被转换成客户端代码期望的接口。这种转换是通过适配器类完成的。通常，具有与客户端期望不同的接口的另一个类被称为适配者。

适配器模式有两种主要类别，即类适配器模式和对象适配器模式。在前者中，适配器从适配者继承。在 Python 中可以实现类适配器，因为该语言支持多重继承。然而，选择对象组合（具有关系）而不是继承会更好。在对象适配器模式中，适配器对象有一个适配者对象，而不是从适配者类继承。对象适配器模式有助于保持适配者和客户端代码之间的松散耦合，其中客户端不需要了解适配者接口。与类适配器模式相比，这提供了更多的灵活性。

在接下来的讨论中，我们只会讨论对象适配器模式。

## 适配器场景 - 侏儒的远亲

| *让我们再次快进到一个* *虚构的未来。一群开发者来找你。他们一直在开发一个类似的幻想游戏应用。鉴于你的游戏受欢迎程度，他们希望进行合作。这对双方都是双赢的局面。你欣然接受这个提议，因为它将让你能够访问他们收藏中的几个游戏角色。* |
| --- |

## 适配器 - 问题

你开始进行集成工作，并注意到一个问题。让我们听听我们的朋友，精灵的看法：

![适配器 - 问题](img/B05034_06_39.jpg)

下面的代码进一步突出了这个问题。这里展示的是新 `WoodElf` 类的简化版本，只显示了 `leap()` 方法。假设它的其他方法与我们的现有接口相匹配。

### 小贴士

在 *策略模式* 部分讨论的 `jump` 方法（而不是跳跃策略）与这里展示的不相关。为了更容易理解这个模式，只展示了最基本代码。例如，这里没有使用 `AbstractGameUnit` 类。作为一个练习，尝试使用策略模式中的代码，并实现一个适配器，以便我们可以与 `WoodElf` 通信（解决方案未提供）！

![适配器 - 问题](img/B05034_06_40.jpg)

## 适配器 – 尝试的解决方案

| *新类* *没有 leap() 方法。我们如何解决这个问题？有什么想法，仙女？* |
| --- |

![适配器 – 尝试的解决方案](img/B05034_06_41.jpg)

我们可能可以这样做，但这个代码属于第三方。如果他们分享了源代码，那么你可以更新它。但这将给你带来维护开销。如果你没有源代码，那么你必须依赖他们来支持这个方法。出于所有这些原因，仙女提出的解决方案可能不是最佳前进方式。话虽如此，仙女的方向是正确的！她有一个 `jump()` 方法，它将这个调用委托给 `leap()` 方法。让我们看看适配器模式如何在这里帮助。

我们是否可以添加一个新的类，它能够在这两个接口之间实现握手？看看以下代码片段：

![适配器 – 尝试的解决方案](img/B05034_06_42.jpg)

这个最后的代码片段似乎解决了一个问题。我们不需要对第三方类 `WoodElf` 进行任何修改。我们将 `WoodElf` 的一个实例传递给适配器 `WoodElfAdapter`。这个适配器类有一个 `jump` 方法，它调用 `WoodElf` 的 `leap` 方法。客户端代码只需要使用这个适配器实例而不是 `WoodElf` 实例。然而，这个解决方案有两个主要问题：

+   适配器类似乎与 `WoodElf` 类相关联。如果我们有一个新的类 `MountainElf`，它将 `spring` 方法作为 `jump` 方法的等效方法呢？

+   想象一下 `WoodElf` 类有其他方法，如 `attack`、`info`、`climb` 等。其中一些可能已经与现有接口兼容，而对于其他一些，则没有等效方法。所有这些方法都可以直接调用，而无需像 `leap()` 那样进行任何特殊处理。如果我们遵循前面代码片段中讨论的方法，你将不得不在适配器类 `WoodElfAdapter` 中定义这些方法中的每一个。如果不实现它们，你将无法在客户端代码中无缝使用适配器类。这是一项相当多的工作。

解决这两个问题非常简单。让我们接下来写一个通用的解决方案。

## 适配器解决方案 – Pythonic 方法

总结一下问题，第三方开发者提供的 `WoodElf` 新类有一个 `leap()` 方法而不是 `jump()`。换句话说，它有一个不兼容的接口。我们正在寻找一个不需要我们修改 `WoodElf` 类的解决方案。我们创建了一个适配器 `WoodElfAdapter`，但正如前一小节所讨论的，它有其自身的不足之处，*适配器 – 尝试的解决方案*。

让我们将适配器类进一步泛化以解决这些问题。参见补充的 `adapterpattern.py` 文件以获取源代码。这将在下面说明。首先看看以下代码片段，然后我们将讨论它：

![适配器解决方案 – Pythonic 方法](img/B05034_06_43.jpg)![适配器解决方案 – Pythonic 方法](img/B05034_06_44.jpg)

在前面的代码截图中有以下几点需要注意：

+   适配器类被重命名为`ForeignUnitAdapter`。

+   第一个输入参数`adaptee`代表我们需要适配的类的实例。第二个参数`adaptee_method`是需要适配的实例方法（例如，`wood_elf.leap`需要被解释为`jump`方法）。

+   接下来，我们利用 Python 的一等函数将`adaptee_method`分配给`self.jump`。例如，调用`self.jump()`现在等同于调用`wood_elf.leap()`。这消除了在适配器类内部创建单独的`jump`方法的需求。

+   在本章的早期部分，我们学习了`__getattr__`方法。在这里，我们在适配器类`ForeignUnitAdapter`中实现了它。客户端代码假设适配器对象（代表第三方游戏角色），已经定义了`info()`、`attack()`和`climb()`等方法。客户端通过适配器对象调用这些方法。实际上，适配器类并没有定义这些方法。它依赖于`self.foreign_unit`来提供这些方法。

+   这段处理代码是在`__getattr__`方法中编写的。在这里，`getattr(self.foreign_unit, item)`将简单地返回`self.foreign_unit.item`。

+   你可以通过传入不同的游戏单位实例和需要适配的方法来创建多个适配器对象。前述代码片段中展示了这样一个例子。

### 适配器 – 多个适配器方法

在早期的示例中，我们假设`self.jump`将是处理适配器的方法。如果我们有多个需要适配以符合现有 API 的方法，怎么办？你可以进一步泛化这个实现。这里有一种处理多个方法的方式。这个源代码可以在支持代码包中找到。查找`adapterpattern_multiple_methods.py`文件：

![适配器 – 多个适配器方法](img/B05034_06_45.jpg)

以下是最主要的执行代码：

![适配器 – 多个适配器方法](img/B05034_06_48.jpg)

再次，我们利用 Python 的一等函数。`set_adapter`方法使用内置方法`setattr()`为`ForeignUnitAdapter`类设置新的属性。这些属性充当适配器方法。或者，你也可以按以下方式设置属性：

```py
foo_elf_adapter.jump = foo_elf.leap 
foo_elf_adapter.attack = foo_elf.hit
```

# 摘要

本章介绍了 Python 中的设计模式，这是应用开发的一个重要方面。我们以一个介绍开始本章，并了解了设计模式的分类。接下来，我们回顾了 Python 语言提供的几个关键特性，这些特性有助于简化几个设计模式。通过实际示例，你学习了如何实现设计模式以解决应用开发中反复出现的问题。更具体地说，你学习了策略模式、抽象工厂模式和适配器模式。对于这些模式中的每一个，我们首先用一个有趣的游戏场景来描述问题。然后，我们讨论了设计模式如何解决这个问题，并进一步使用 Python 风格实现了设计模式。对于某些模式，我们还回顾了实现设计模式的传统方法。最后但同样重要的是，我们遇到了 Sir Foo 的一些新朋友。

到目前为止，我们已经讨论了应用开发中的几个重要方面。这次讨论帮助我们编写更好的代码，使应用更加健壮，并延长了应用的使用寿命。在接下来的三章中，我们将学习各种提高应用性能的方法。
