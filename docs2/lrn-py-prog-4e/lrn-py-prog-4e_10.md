

# 第十章：测试

> “正如智者经过加热、切割和摩擦来检验黄金后才会接受它一样，我的话也应该在经过检验后接受，而不是出于对我的尊重。”
> 
> – 佛陀

我们非常喜欢佛陀的这句话。在软件世界中，它完美地转化为一个健康的习惯：永远不要仅仅因为某人聪明就信任代码，或者因为它长时间运行良好就信任它。如果它没有被测试，代码就不应该被信任。

为什么测试如此重要？好吧，首先，它们为你提供了可预测性。或者至少，它们帮助你实现高可预测性。不幸的是，代码中总是会有一些漏洞悄悄溜进来。但我们希望我们的代码尽可能可预测。我们不希望有惊喜；换句话说，我们不希望代码以不可预测的方式运行。在检查飞机、火车或核电站传感器的软件中存在不可预测性可能导致灾难性的情况。

我们需要测试我们的代码；我们需要检查其行为是否正确，当它处理边缘情况时是否按预期工作，当它与之通信的组件损坏或无法访问时，它不会挂起，性能是否在可接受的范围内，等等。

本章全部关于这一点——确保你的代码准备好面对可怕的外部世界，它足够快，并且能够处理意外或异常条件。

在本章中，我们将探讨以下主题：

+   通用测试指南

+   单元测试

+   简要介绍**测试驱动开发**（**TDD**）

让我们先从理解什么是测试开始。

# 测试你的应用程序

测试有很多种类；实际上，公司通常有一个专门的部门，称为**质量保证**（**QA**），由那些负责测试公司开发软件的个人组成。

为了进行初步分类，我们可以将测试分为两大类：**白盒**和**黑盒**测试。

白盒测试是那些锻炼代码内部结构的测试；它们检查到非常详细的程度。另一方面，黑盒测试是那些将待测试的软件视为一个盒子，忽略其内部结构的测试。即使是盒子内部使用的科技或语言，对黑盒测试来说也不重要。它们所做的是将一些输入插入盒子的一个端点，并验证另一个端点的输出——仅此而已。

还有一个介于两者之间的类别，称为**灰盒**测试，它涉及以与黑盒方法相同的方式测试系统，但对我们使用的算法和数据结构有一些了解，并且只有部分访问源代码的权限。

这些类别中有许多种测试，每种都服务于不同的目的。为了给你一个概念，这里有一些例子：

+   **前端测试**：它们确保你的应用程序客户端暴露了应该暴露的信息，所有链接、按钮、广告以及需要展示给客户端的一切。它们还可能验证是否可以通过**用户界面**（**UI**）走一条特定的路径。

+   **场景测试**：它们利用故事（或场景）帮助测试人员解决复杂问题或测试系统的一部分。

+   **集成测试**：它们验证当应用程序的不同组件协同工作并通过接口发送消息时的行为。

+   **冒烟测试**：在你对应用程序部署新的更新时特别有用，它们检查应用程序最基本、最重要的部分是否仍然按预期工作，并且它们没有处于**燃烧**状态。这个术语来源于工程师通过确保没有冒烟来测试电路的时候。

+   **验收测试**，或**用户验收测试**（**UAT**）：开发者与产品负责人（例如，在敏捷开发环境中）一起进行的工作，以确定委托的工作是否正确完成。

+   **功能测试**：它们验证你的软件的功能或功能。

+   **破坏性测试**：它们破坏系统的某些部分，模拟故障，以确定系统剩余部分的表现如何。这种测试由需要提供高度可靠服务的公司广泛进行。

+   **性能测试**：它们旨在验证系统在特定数据负载或流量下的表现如何，以便工程师可以更好地了解可能导致系统在重负载情况下崩溃的瓶颈，或者那些阻止可扩展性的瓶颈。

+   **可用性测试**，以及与之密切相关的**用户体验**（**UX**）**测试**：它们旨在检查 UI 是否简单、易于理解和使用。它们还旨在为设计师提供反馈，以改善 UX。

+   **安全和渗透测试**：它们旨在验证系统抵御攻击和入侵的能力。

+   **单元测试**：它们帮助开发者以稳健和一致的方式编写代码，提供第一线的反馈和防御，以防止编码错误、重构错误等。

+   **回归测试**：它们为开发者提供有关更新后系统中的某个功能被破坏的有用信息。系统被认为有回归的一些原因是旧错误再次出现、现有功能被破坏，或者引入了新的问题。

关于测试的书籍和文章已经有很多了，如果你对了解所有不同类型的测试感兴趣，我们必须向你推荐那些资源。在本章中，我们将专注于单元测试，因为它们是软件构建的基石，构成了开发者编写的测试中的绝大多数。

测试是一种**艺术**，不幸的是，这种艺术你无法从书中学习。你可以学习所有的定义（你应该这样做），并尽可能多地收集有关测试的知识，但只有当你积累了足够多的经验时，你才可能正确地测试你的软件。

当你在重构一小段代码时遇到困难，因为每次你触摸到的东西都会使测试失败，你会学会编写不那么严格和限制性的测试，这些测试仍然可以验证代码的正确性，同时，也让你有自由和乐趣去玩弄它，按照你的意愿去塑造它。

当你频繁被要求修复代码中的意外错误时，你会学会如何更彻底地编写测试，如何提出一个更全面的边缘情况列表，以及应对这些情况的策略，以防它们变成错误。

当你花费太多时间阅读测试并尝试重构它们以更改代码中的一个小功能时，你会学会编写更简单、更短、更专注的测试。

我们可以继续用这种“当你……你学……”的方式来讨论，但我们猜测你已经明白了。你需要付出努力并积累经验。我们的建议？尽可能多地学习理论，然后尝试使用不同的方法进行实验。此外，尝试向经验丰富的程序员学习；这非常有效。

理想情况下，你越有经验，你就越应该感觉到源代码和单元测试不是两件独立的事情。测试不是可选的。它们与代码紧密相连。源代码和单元测试相互影响。

## 测试的结构

在我们专注于单元测试之前，让我们先看看什么是测试，以及它的目的是什么。

**测试**是一段代码，其目的是验证我们系统中的某个东西。这可能意味着我们正在调用一个函数，传递两个整数，或者一个对象有一个名为`donald_duck`的属性，或者当你在一个**应用程序编程接口**（**API**）上放置一个订单后，一分钟内你可以在数据库中看到它被分解成基本元素。

一个测试通常由三个部分组成：

1.  **准备**：这是我们设置场景的地方。我们在需要的地方准备所有需要的数据、对象和服务，以便它们可以随时使用。

1.  **执行**：这是我们在测试阶段执行逻辑的地方。我们使用在准备阶段设置的数据和接口执行一个动作。

1.  **验证**：这是验证结果并确保它们符合我们预期的地方。我们检查函数的返回值，或者某些数据是否在数据库中，某些不是，某些已更改，已发起 HTTP 请求，发生了某些事情，调用了某个方法，等等。

虽然测试通常遵循这种结构，但在测试套件中，你通常会找到一些参与测试过程的其它构造：

+   **设置**：这是在多个测试中相当常见的东西。这是一种可以定制以运行每个测试、类、模块或整个会话的逻辑。在这个阶段，开发者通常会设置与数据库的连接，用测试所需的数据填充它们，等等。

+   **拆卸**：这是设置的反面；拆卸阶段在测试运行之后发生。像设置一样，它可以定制以运行每个测试、类、模块或会话。通常，在这个阶段，我们会销毁为测试套件创建的任何工件，并清理我们的痕迹。这很重要，因为我们不希望有任何残留的对象，这也有助于确保每个测试都是从一张干净的纸开始。

+   **固定装置**：这些是在测试中使用的数据片段。通过使用特定的固定装置集，结果是可以预测的，因此测试可以针对它们进行验证。

在本章中，我们将使用`pytest` Python 库。这是一个强大的工具，它使得测试比仅使用标准库工具要容易得多。`pytest`提供了大量的辅助工具，以便测试逻辑可以更多地关注实际的测试，而不是围绕它的布线和模板。当你看到代码时，你会发现`pytest`的一个特点是，固定装置、设置和拆卸通常融合在一起。

## 测试指南

就像软件一样，测试可以是好的或坏的，中间还有一系列的灰色地带。要编写好的测试，以下是一些指导原则：

+   **尽可能简单**：违反一些良好的编码规则，如硬编码值或重复代码，是可以接受的。测试首先需要尽可能的可读和易于理解。当测试难以阅读或理解时，我们永远无法确信它们实际上是在确保我们的代码正确执行。

+   **测试应验证一件事，且仅一件事**：保持它们简短并包含在一个范围内非常重要。写多个测试来测试单个对象或函数是完全正常的。我们只需要确保每个测试只有一个且只有一个目的。

+   **测试不应做出任何不必要的假设**：起初这可能难以理解，但这是很重要的。验证函数调用的结果是`[1, 2, 3]`并不等同于说输出是一个包含数字 1、2 和 3 的列表。在前者中，我们还在假设顺序；在后者中，我们只假设列表中包含哪些项目。这些差异有时可能非常微妙，但它们仍然很重要。

+   **测试应关注“是什么”，而不是“如何”**：测试应专注于检查函数应该做什么，而不是它是如何做到的。例如，关注函数是计算一个数字的平方根（即“是什么”），而不是它调用`math.sqrt()`来做到这一点（即“如何”）。除非我们正在编写性能测试或我们有特定的需求来验证某些动作是如何执行的，否则我们应该尽量避免这种类型的测试，并专注于“是什么”。测试“如何”会导致测试过于严格，并使得重构变得困难。此外，当我们专注于“如何”时，我们必须编写的测试类型更有可能在频繁修改软件时降低我们的测试代码库的质量。

+   **测试应使用完成工作所需的最小固定数据集**：这是另一个关键点。固定数据集往往会随着时间的推移而增长。它们也往往会时不时地发生变化。如果我们使用许多固定数据集并且忽略测试中的冗余，重构将需要更长的时间。发现错误将更加困难。我们应该尽量使用一组足够大的固定数据集，以便测试能够正确执行，但不要过大。

+   **测试应尽可能少地使用资源**：这样做的原因是，任何检出我们代码的开发者都应该能够运行测试，无论他们的机器有多强大。这可能是一个瘦虚拟机或 CircleCI 设置；测试应在不消耗太多资源的情况下运行。

+   **测试应尽可能快地运行**：一个好的测试代码库最终可能会比被测试的代码本身更长。这取决于具体情况和开发者，但无论长度如何，我们最终都会拥有数百甚至数千个测试要运行，这意味着它们运行得越快，我们就能越快回到编写代码。例如，在使用**TDD**时，我们会非常频繁地运行测试，因此速度至关重要。

    **CircleCI**是今天可用的最大的**持续集成/持续交付**（**CI/CD**）平台之一。例如，它与 GitHub 等服务的集成非常容易。你只需要在源代码中添加一些配置（通常是文件的形式），当新代码准备合并到当前代码库时，CircleCI 就会运行测试。

## 单元测试

现在我们已经了解了测试是什么以及为什么我们需要它，让我们来介绍开发者的最佳拍档：**单元测试**。

在我们继续举例之前，让我们分享一些注意事项：我们将尝试向您介绍单元测试的基础知识，但我们并不严格遵循任何特定的思想或方法论。多年来，我们尝试了许多不同的测试方法，最终形成了我们自己的做事方式，这种方式一直在不断演变。用布鲁斯·李的话来说：

吸收有用的，摒弃无用的，增加你自己的独特之处。

### 编写单元测试

单元测试的名字来源于它们用于测试代码的小单元。为了解释如何编写单元测试，让我们看看一个简单的代码片段：

```py
# data.py
def get_clean_data(source):
    data = load_data(source)
    cleaned_data = clean_data(data)
    return cleaned_data 
```

`get_clean_data()` 函数负责从 `source` 获取数据，清理它，并将其返回给调用者。我们如何测试这个函数？

做这件事的一种方法是在调用它并确保 `load_data()` 仅以 `source` 作为其唯一参数被调用一次。然后，我们需要验证 `clean_data()` 仅被调用一次，并且其参数是 `load_data()` 的返回值。最后，我们需要确保 `clean_data()` 的返回值与 `get_clean_data()` 函数返回的值相同。

要做到这一点，我们需要设置源并运行此代码，这可能会成为一个问题。单元测试的黄金法则之一是*任何跨越你应用程序边界的东西都需要被模拟*。我们不想与真实的数据源交谈，我们也不想实际运行与我们的应用程序之外的任何东西通信的真实函数。一些例子包括数据库、搜索服务、外部 API 或文件系统。

我们需要这些限制来充当盾牌，这样我们就可以始终安全地运行测试，而不必担心在真实数据源中破坏某些东西。

另一个原因是，对于开发者来说，在他们的机器上重现整个架构可能相当困难。这可能需要设置数据库、API、服务、文件和文件夹等，这可能很困难，耗时，有时甚至不可能。

简单来说，**API** 是构建软件应用程序的工具集。API 以其操作、输入和输出以及底层类型来表示软件组件。例如，如果你创建的软件需要与数据提供者服务接口，那么你很可能需要通过他们的 API 来获取数据。

因此，在我们的单元测试中，我们需要以某种方式模拟所有这些事情。单元测试需要由任何开发者运行，而无需在他们的机器上设置整个系统。

另一种不同的方法，当可能这样做时，我们更喜欢使用它，是通过使用特殊用途的测试对象而不是使用模拟对象来模拟实体。例如，如果我们的代码与数据库进行通信，而不是模拟所有与数据库通信的函数和方法，并编程模拟对象使其返回真实对象的结果，我们宁愿创建一个测试数据库，设置我们需要的表和数据，然后修补连接设置，以便我们的测试在测试数据库上运行真实代码。这样做的好处是，如果底层库发生变化，引入了我们的代码中的问题，这种设置将捕获这个问题。一个测试将失败。另一方面，使用模拟的测试将无忧无虑地继续成功运行，因为模拟的接口将不会了解底层库的变化。内存数据库是这些情况下的绝佳选择。

允许您为测试创建数据库的应用之一是 Django。在`django.test`包中，您可以找到几个工具，这些工具可以帮助您编写测试，这样您就无需模拟与数据库的对话。通过这种方式编写测试，您还可以检查事务、编码以及编程的所有其他数据库相关方面。这种方法的另一个优点是能够检查可能从一个数据库到另一个数据库发生变化的细节。

有时，尽管如此，仍然无法实现。例如，当软件与 API 接口交互，而该 API 没有测试版本时，我们需要使用模拟来模拟该 API。实际上，大多数情况下，我们最终不得不采用混合方法，即使用允许这种方法的技术的测试版本，而对于其他所有内容则使用模拟。现在让我们来谈谈模拟。

### 模拟对象和修补

首先，在 Python 中，这些模拟对象被称为**模拟**。直到版本 3.3，`mock`库是一个第三方库，基本上每个项目都会通过 pip 安装，但从版本 3.3 开始，它已被包含在标准库的`unittest`模块中，这是合理的，考虑到其重要性和普及程度。

用`mock`替换真实对象或函数（或一般而言，任何数据结构）的行为被称为**修补**。`mock`库提供了`patch`工具，它可以作为函数或类装饰器，甚至可以作为上下文管理器，您可以使用它来模拟事物。

### 断言

验证阶段是通过使用断言来完成的。在大多数情况下，断言是一个可以用来验证对象之间相等性以及其他条件的函数或方法。当条件不满足时，断言将引发一个异常，这将导致测试失败。你可以在`unittest`模块的文档中找到一个断言列表；然而，当使用`pytest`时，你通常会使用通用的`assert`语句，这使得事情变得更加简单。

## 测试 CSV 生成器

让我们现在采取一种实际的方法。我们将向您展示如何测试一小段代码，并且我们将在这个示例的背景下涉及单元测试的其他重要概念。

我们想要编写一个`export()`函数，它执行以下操作：接收一个字典列表，每个字典代表一个用户。它创建一个**逗号分隔值**（**CSV**）文件，在其中放置一个标题，然后继续添加根据某些规则被认为是有效的所有用户。该函数将接受三个参数：用户字典列表、要创建的 CSV 文件名以及一个指示是否应该覆盖具有相同名称的现有文件的标志。

要被认为是有效的并添加到输出文件中，用户字典必须满足以下要求：每个用户必须至少有一个电子邮件、一个姓名和一个年龄。还可以有一个表示角色的第四个字段，但这不是必需的。用户的电子邮件地址必须是有效的，姓名不能为空，年龄必须在 18 到 65 岁之间。

这是我们的任务；因此，现在我们将向您展示代码，然后我们将分析为其编写的测试。但是，首先，在以下代码片段中，我们将使用两个第三方库：`marshmallow`和`pytest`。它们都包含在该章节源代码的要求中，所以请确保您已经使用 pip 安装了它们。

`marshmallow`（[`marshmallow.readthedocs.io/`](https://marshmallow.readthedocs.io/)）是一个库，它为我们提供了序列化（或`marshmallow`术语中的*dump*）和反序列化（或`marshmallow`术语中的*load*）对象的能力，最重要的是，它为我们提供了定义模式的能力，我们可以使用该模式来验证用户字典。我们将在*第十四章*，*API 开发简介*中看到另一个用于创建模式的库，`pydantic`。

`pytest`（[`docs.pytest.org/`](https://docs.pytest.org/)）是我们所见过的最好的软件之一。它几乎被用于所有地方，并取代了其他库，如*nose*。它为我们提供了编写测试的有用工具，效率很高。

让我们来看代码。我们将其命名为`api.py`仅仅是因为它暴露了一个我们可以用来导出 CSV 的函数。我们将分块向您展示：

```py
# api.py
from pathlib import Path
import csv
from copy import deepcopy
from marshmallow import Schema, fields, pre_load
from marshmallow.validate import Length, Range
class UserSchema(Schema):
    """Represent a *valid* user."""
    email = fields.Email(required=True)
    name = fields.Str(required=True, validate=Length(min=1))
    age = fields.Int(
        required=True, validate=Range(min=18, max=65)
    )
    role = fields.Str()
    @pre_load()
    def strip_name(self, data, **kwargs):
        data_copy = deepcopy(data)
        try:
            data_copy["name"] = data_copy["name"].strip()
        except (AttributeError, KeyError, TypeError):
            pass
        return data_copy
schema = UserSchema() 
```

这一部分是我们导入所有需要的模块（`Path`、`csv`、`deepcopy` 以及来自 `marshmallow` 的一些工具），然后我们定义用户的模式。正如你所见，我们继承自 `marshmallow.Schema`，然后设置四个字段。注意我们使用了两个字符串字段（`Str`），一个 `Email` 字段和一个整数（`Int`）。这些将已经为我们提供了一些来自 `marshmallow` 的验证。注意在 `role` 字段中没有 `required=True`。

尽管如此，我们还需要添加一些自定义的代码。我们需要在 `age` 上添加验证以确保值在我们想要的范围内。如果它不是，`marshmallow` 将抛出 `ValidationError`。它还会处理如果我们传递的不是整数时抛出错误。

我们还对 `name` 字段添加了验证，因为字典中存在 `name` 键并不保证该名称的值不为空。我们验证字段值的长度至少为一位。注意我们不需要为 `email` 字段添加任何内容。这是因为 `marshmallow` 会为我们验证它。

在字段声明之后，我们编写了另一个方法，`strip_name()`，该方法被 `pre_load()` `marshmallow` 辅助器装饰。这个方法将在 `marshmallow` 反序列化（加载）数据之前运行。正如你所见，我们首先复制 `data`，因为在当前上下文中直接在可变对象上工作不是一个好主意，然后确保从 `data['name']` 中移除前导和尾随空格。这个键代表我们刚才声明的名称字段。我们确保在 `try` / `except` 块中这样做，这样即使在出现错误的情况下，反序列化也可以顺利运行。该方法返回修改后的数据副本，而 `marshmallow` 执行剩余的操作。

我们随后实例化 `schema`，以便我们可以用它来验证数据。因此，让我们编写 `export` 函数：

```py
# api.py
def export(filename, users, overwrite=True):
    """Export a CSV file.
    Create a CSV file and fill with valid users.  If `overwrite`
    is False and file already exists, raise IOError.
    """
    if not overwrite and Path(filename).is_file():
        raise IOError(f"'{filename}' already exists.")
    valid_users = get_valid_users(users)
    write_csv(filename, valid_users) 
```

正如你所见，其逻辑非常直接。如果 `overwrite` 为 `False` 且文件已存在，我们将抛出带有文件已存在信息的 `IOError`。否则，如果我们可以继续进行，我们只需获取有效用户的列表并将其传递给 `write_csv()`，该函数负责实际执行工作。让我们看看所有这些函数是如何定义的：

```py
# api.py
def get_valid_users(users):
    """Yield one valid user at a time from users."""
    yield from filter(is_valid, users)
def is_valid(user):
    """Tell if the user is valid."""
    return not schema.validate(user) 
```

我们将 `get_valid_users()` 编码为一个生成器，因为在写入文件之前没有必要创建一个可能很大的列表。我们可以逐个验证和保存它们。`is_valid()` 函数简单地委托给 `marshmallow` 的 `schema.validate()` 来验证用户。此方法返回一个字典，如果数据根据模式有效则为空，否则将包含错误信息。我们不需要收集错误信息来完成这项任务，所以我们简单地忽略它，而 `is_valid()` 函数如果 `schema.validate()` 的返回值为空，则简单地返回 `True`，否则返回 `False`。

本模块中的最后一部分代码是：

```py
# api.py
def write_csv(filename, users):
    """Write a CSV given a filename and a list of users.
    The users are assumed to be valid for the given CSV structure.
    """
    fieldnames = ["email", "name", "age", "role"]
    with open(filename, "w", newline="") as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(users) 
```

再次强调，逻辑非常直接。我们在`fieldnames`中定义了表头，然后打开`filename`进行写入，并指定`newline=""`，这在 CSV 文件的文档中被推荐使用。当文件创建完成后，我们通过使用`csv.DictWriter`类来获取一个`writer`对象。这个工具将用户字典映射到字段名，因此我们不需要关心顺序。

我们首先写入表头，然后遍历用户并逐个添加。请注意，这个函数假设传入的是一个有效的用户列表，如果这个假设不成立（使用默认值时，如果任何用户字典有额外的字段，它可能会中断）。

这是你应该尝试记住的代码。我们建议你花点时间再次过一遍。没有必要去记忆它，而且我们使用了具有有意义名称的小辅助函数，这将使你更容易地跟踪测试。

现在我们来探讨有趣的部分：测试`export()`函数。我们再次将代码分块展示：

```py
# tests/test_api.py
import re
from unittest.mock import patch, mock_open, call
import pytest
from api import is_valid, export, write_csv 
```

让我们从导入开始：首先，我们从标准库中导入`re`模块，因为其中一个测试需要它。然后，我们引入`unittest.mock`中的某些工具，接着是`pytest`，最后，我们获取我们想要实际测试的三个函数：`is_valid()`、`export()`和`write_csv()`。

在我们可以编写测试之前，我们需要做一些固定装置。正如你将看到的，`pytest`中的**固定装置**是一个用`pytest.fixture`装饰器装饰的函数。固定装置在应用它们的每个测试之前运行。在大多数情况下，我们期望固定装置返回一些内容，这样我们就可以在测试中使用它。我们对用户字典有一些要求，所以让我们写几个用户：一个具有最小要求，另一个具有完整要求。两者都需要是有效的。以下是代码：

```py
# tests/test_api.py
@pytest.fixture
def min_user():
    """Represent a valid user with minimal data."""
    return {
        "email": "minimal@example.com",
        "name": "Primus Minimus",
        "age": 18,
    }
@pytest.fixture
def full_user():
    """Represent valid user with full data."""
    return {
        "email": "full@example.com",
        "name": "Maximus Plenus",
        "age": 65,
        "role": "emperor",
    } 
```

在这个例子中，用户之间的唯一区别是`role`键的存在，但这应该足以说明问题。

注意，我们并没有在模块级别简单地声明字典，而是实际上编写了两个返回字典的函数，并用`@pytest.fixture`装饰器进行了装饰。这是因为当你需要在模块级别声明用于测试的字典时，你需要确保在每个测试的开始处复制它。如果你不这样做，并且任何测试（或被测试的代码）修改了它，那么所有后续的测试可能会受到影响，因为字典将不会保持其原始形式。通过使用这些固定装置，`pytest`将为每个测试提供一个新字典，因此我们不需要进行复制过程。这有助于遵守独立性原则，即每个测试应该是自包含和独立的。

固定值也是*可组合的*，这意味着它们可以相互使用，这是 `pytest` 的一个有用特性。为了展示这一点，让我们为用户列表编写一个固定值，我们将放入我们已有的两个，再加上一个没有年龄将无法通过验证的用户。让我们看一下以下代码：

```py
# tests/test_api.py
@pytest.fixture
def users(min_user, full_user):
    """List of users, two valid and one invalid."""
    bad_user = {
        "email": "invalid@example.com",
        "name": "Horribilis",
    }
    return [min_user, bad_user, full_user] 
```

我们现在有两个用户可以使用，我们还有一个包含三个用户的列表。

前几个测试将测试我们如何验证用户。我们将为此任务将所有测试分组在一个类中。这有助于为相关测试提供一个命名空间，一个存放的地方。正如我们稍后将会看到的，这也允许我们声明类级别的固定值，这些固定值仅针对属于该类的测试定义。声明类级别固定值的一个好处是，你可以轻松地覆盖一个与类作用域外同名的内容。

尽管在这种情况下，我们发现按类组织测试很方便，但你也可以只在模块级别定义测试。`pytest` 允许在测试结构方面具有很大的灵活性。

此外，你将注意到，当我们引导你通过示例时，每个测试函数的名称都以 `test_` 开头，每个测试类的名称都以 `Test` 开头。这是为了让 `pytest` 发现这些函数和类，并将它们视为测试。请参阅 `pytest` 文档以了解完整的规范。

让我们回到我们的代码。看一下以下内容：

```py
# tests/test_api.py
class TestIsValid:
    """Test how code verifies whether a user is valid or not."""
    def test_minimal(self, min_user):
        assert is_valid(min_user)
    def test_full(self, full_user):
        assert is_valid(full_user) 
```

我们从确保我们的固定值确实通过验证开始，这有助于确保我们的代码能够正确验证已知有效的用户，无论是最小数据还是完整数据。请注意，我们给每个测试函数提供了一个与固定值名称匹配的参数。这会激活该测试的固定值。当 `pytest` 运行测试时，它将检查每个测试的参数，并将相应固定值函数的返回值作为参数传递给测试。

在我们继续之前，运行这两个测试以确保一切连接正确会是个好主意。要运行测试，我们在 `ch10` 文件夹的壳中调用 `pytest` 命令：

```py
$ pytest tests -vv
===================== test session starts =====================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0 --
  /Users/fab/.virtualenvs/lpp4ed-ch10/bin/python
cachedir: .pytest_cache
rootdir: /Users/fab/code/lpp4ed
configfile: pyproject.toml
collected 2 items
tests/test_api.py::TestIsValid::test_minimal PASSED      [ 50%]
tests/test_api.py::TestIsValid::test_full PASSED         [100%]
====================== 2 passed in 0.03s ====================== 
```

我们指示命令在 `tests` 文件夹中搜索测试。此外，为了展示详细信息，我们使用详细标志（ `-vv` ）调用了它。

在一些样板代码之后，我们发现了两行被高亮的代码。它们代表了运行的所有测试的完整路径。首先，是包含测试的模块名称，然后在这个例子中，是定义它们的类名称，最后是它们的名称。

在右侧，你可以看到进度，以百分比表示。在这种情况下，我们现在只有两个测试，所以在运行第一个测试后，我们已经完成了测试套件的 50%，在运行第二个测试后完成 100%。它们都通过了。

如果任何测试失败，`pytest` 会打印错误和一些调试信息，这样我们就可以检查哪里出了问题并修复它。让我们通过从 `min_user` 固定值中移除 `name` 键并再次运行测试来模拟一个失败：

```py
$ pytest tests -vv
===================== test session starts =====================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0 --
/Users/fab/.virtualenvs/lpp4ed-ch10/bin/python
cachedir: .pytest_cache
rootdir: /Users/fab/code/lpp4ed
configfile: pyproject.toml
collected 2 items
tests/test_api.py::TestIsValid::test_minimal FAILED     [ 50%]
tests/test_api.py::TestIsValid::test_full PASSED        [100%]
=========================== FAILURES ==========================
___________________ TestIsValid.test_minimal __________________
self = <ch10.tests.test_api.TestIsValid object at 0x103603920>,
       min_user = {'age': 18, 'email': 'minimal@example.com'}
    def test_minimal(self, min_user):
>       assert is_valid(min_user)
E       AssertionError: assert False
E        +  where False = is_valid(
                {'age': 18, 'email': 'minimal@example.com'}
            )
tests/test_api.py:45: AssertionError
=================== short test summary info ===================
FAILED tests/test_api.py::TestIsValid::test_minimal
       - AssertionError: assert False
================= 1 failed, 1 passed in 0.04s ================= 
```

如您在突出显示的部分所见，`pytest` 会报告哪些测试失败了，以及发生失败的地方的代码片段，这样我们就可以检查它并发现问题所在。在代码片段的左侧有一个 `>` 符号，它表示抛出错误的行，下面是两行代表错误本身，在这个例子中是 `{'age': 18, 'email': 'minimal@example.com'}` 不是一个有效的用户。

既然我们已经知道如何运行测试，请随时运行它们。当我们运行测试时，一个好的做法是确保如果有什么问题，它们会失败，所以请随意玩弄固定值和断言。

现在我们回到测试套件。下一个任务是测试年龄。为了做到这一点，我们将使用参数化。

**参数化**是一种技术，使我们能够多次运行相同的测试，但向它提供不同的数据。它非常有用，因为它允许我们只写一次测试，没有重复，并且结果将由 `pytest` 智能处理，它将像实际单独运行那样运行所有这些测试，当它们失败时，会提供清晰的错误信息。另一个解决方案是在一个包含 `for` 循环的测试中运行我们想要测试的所有数据，但后者质量要低得多，因为框架无法提供像单独运行测试那样的具体信息。此外，如果 `for` 循环的任何迭代失败，将没有关于之后会发生什么的信息，因为后续迭代将不会发生。最后，由于 `for` 循环的额外逻辑，测试的主体将更难以理解。因此，参数化对于这个用例来说是一个更好的选择。

它还使我们免于编写大量几乎相同的测试来穷尽所有可能的场景。让我们看看我们如何测试年龄（我们正在为您重复类签名，但省略了已经展示过的测试）：

```py
# tests/test_api.py
class TestIsValid:
    …
    **@pytest.mark.parametrize(****"age"****,** **range****(****18****)****)**
    def test_invalid_age_too_young(self, **age**, min_user):
        min_user["age"] = age
        assert not is_valid(min_user) 
```

我们首先编写一个测试来检查当用户年龄太小时验证失败。根据我们的规则，当用户年龄小于 18 岁时，他们年龄太小。我们通过使用 `range()` 来检查 0 到 17 岁之间的每个年龄。

如果你看看参数化是如何工作的，你会看到我们声明了一个对象的名字和 `age`，然后我们指定这个对象将取哪些值。测试将针对每个指定的值运行一次。在这个第一个测试中，值是 `range(18)` 返回的所有值，这意味着包括从 0 到 17 的所有整数。注意，我们还向测试添加了一个 `age` 参数。参数化中指定的值将通过这个参数传递给测试。

我们也在这个测试中使用了 `min_user()` 固定值。在这种情况下，我们在 `min_user()` 字典中更改 `age`，然后验证 `is_valid(min_user)` 的结果是 `False`。我们通过断言 `not False` 是 `True` 来做到这一点。在 `pytest` 中，这就是检查某个条件的方法。你只需断言某个条件是真实的。如果是这样，测试就成功了。如果相反，测试将失败。

注意，`pytest` 将为使用它的每个测试运行重新评估固定值函数，因此我们可以在测试中修改固定值数据，而不会影响其他任何测试。

让我们继续添加所有必要的测试，以便在年龄上使验证失败：

```py
# tests/test_api.py
class TestIsValid:
    ...
    @pytest.mark.parametrize("age", range(66, 100))
    def test_invalid_age_too_old(self, age, min_user):
        min_user["age"] = age
        assert not is_valid(min_user)
    @pytest.mark.parametrize("age", ["NaN", 3.1415, None])
    def test_invalid_age_wrong_type(self, age, min_user):
        min_user["age"] = age
        assert not is_valid(min_user) 
```

另外两个测试。一个处理从 66 岁到 99 岁的另一端，第二个确保当年龄不是整数时，年龄无效。因此，我们传递一些值，例如字符串、浮点数和 `None`，以确保这一点。注意，这些测试的结构都是相同的，但多亏了参数化，我们向它提供了不同的输入参数。

现在我们已经整理好了年龄失败的逻辑，让我们添加一个测试来检查年龄是否在有效范围内：

```py
# tests/test_api.py
class TestIsValid:
    ...
    @pytest.mark.parametrize("age", range(18, 66))
    def test_valid_age(self, age, min_user):
        min_user["age"] = age
        assert is_valid(min_user) 
```

就这么简单。我们传递正确的范围，从 18 到 65 岁，并在断言中移除 `not`。

我们可以将年龄视为已处理。让我们继续编写关于必填字段的测试：

```py
# tests/test_api.py
class TestIsValid:
    ...
    @pytest.mark.parametrize("field", ["email", "name", "age"])
    def test_mandatory_fields(self, field, min_user):
        del min_user[field]
        assert not is_valid(min_user)
    @pytest.mark.parametrize("field", ["email", "name", "age"])
    def test_mandatory_fields_empty(self, field, min_user):
        min_user[field] = ""
        assert not is_valid(min_user)
    def test_name_whitespace_only(self, min_user):
        min_user["name"] = " \n\t"
        assert not is_valid(min_user) 
```

这三个测试仍然属于同一个类。第一个测试检查当必填字段之一缺失时，用户是否无效。记住，在每次测试运行时，`min_user` 固定值都会被恢复，所以我们每次测试运行只有一个缺失的字段，这是检查必填字段的正确方式。我们只需从字典中移除那个键。这次，参数化对象取名为 `field`，通过查看第一个测试，你可以在参数化装饰器中看到所有必填字段：`email`、`name` 和 `age`。

在第二个测试中，事情略有不同。我们不是移除键，而是简单地（逐个）将它们设置为空字符串。最后，在第三个测试中，我们检查名称是否只由空白字符组成。

之前的测试确保了必填字段存在且非空，以及用户`name`键周围的格式。现在让我们为这个类编写最后两个测试。我们想要检查电子邮件是否有效，在第二个测试中，检查电子邮件、姓名和角色的类型：

```py
# tests/test_api.py
class TestIsValid:
    ...
    @pytest.mark.parametrize(
        ("email", "outcome"),
        [
            ("missing_at.com", False),
            ("@missing_start.com", False),
            ("missing_end@", False),
            ("missing_dot@example", False),
            ("good.one@example.com", True),
            ("δοκιμή@παράδειγμα.δοκιμή", True),
            ("аджай@экзампл.рус", True),
        ],
    )
    def test_email(self, email, outcome, min_user):
        min_user["email"] = email
        assert is_valid(min_user) == outcome 
```

这次，参数化稍微复杂一些。我们定义了两个对象（`email`和`outcome`），然后我们向装饰器传递一个元组列表，而不是一个简单的列表。每次运行测试时，这些元组中的一个将被解包以填充`email`和`outcome`的值。这允许我们为有效的和无效的电子邮件地址编写一个测试，而不是两个单独的测试。我们定义了一个电子邮件地址，并指定了验证预期的结果。前四个是无效的电子邮件地址，最后三个是有效的。我们使用了一些非 ASCII 字符的例子，只是为了确保我们没有忘记在验证中包括来自世界各地的朋友们。

注意验证是如何进行的，断言调用结果需要与我们设定的结果相匹配。

现在我们写一个简单的测试来确保当我们向字段提供错误类型时验证会失败（再次强调，年龄在之前已经单独处理过了）：

```py
# tests/test_api.py
class TestIsValid:
    ...
    @pytest.mark.parametrize(
        ("field", "value"),
        [
            ("email", None),
            ("email", 3.1415),
            ("email", {}),
            ("name", None),
            ("name", 3.1415),
            ("name", {}),
            ("role", None),
            ("role", 3.1415),
            ("role", {}),
        ],
    )
    def test_invalid_types(self, field, value, min_user):
        min_user[field] = value
        assert not is_valid(min_user) 
```

就像我们之前做的那样，我们传递了三个不同的值，其中没有一个实际上是字符串。这个测试可以扩展以包含更多的值，但老实说，我们不应该需要编写这样的测试。我们在这里包含它只是为了展示什么是可能的，但通常你只会关注确保代码考虑了有效的类型，那些必须被认为是有效的类型，这应该就足够了。

在我们移动到下一个测试类之前，让我们花点时间谈谈我们在测试年龄时简要提到的事情。

### 边界和粒度

在检查年龄时，我们编写了三个测试来覆盖三个范围：0-17（失败）、18-65（成功）和 66-99（失败）。我们为什么这样做？答案在于我们正在处理两个边界：18 和 65。因此，我们的测试需要集中在这两个边界定义的三个区域：18 之前、18 和 65 之间以及 65 之后。你如何做不重要，只要确保你正确地测试了边界。这意味着如果有人将模式中的验证从`18 <= value <= 65`更改为`18 <= value < 65`（注意第二个`<=`现在变成了`<`），那么在 65 上必须有一个失败的测试。

这个概念被称为**边界**，你必须在代码中识别它们，以便可以针对它们进行测试。

另一个重要的事情是要理解我们离边界有多近。换句话说，我应该使用哪个单位来接近它们？

在年龄的情况下，我们处理整数，因此单位为 1 将是完美的选择（这就是为什么我们使用了 16、17、18、19、20 等）。但是，如果你正在测试时间戳呢？在这种情况下，正确的粒度可能不同。如果代码必须根据你的时间戳以不同的方式执行，并且该时间戳代表秒，那么你的测试的粒度应该缩小到秒。如果时间戳代表年，那么你应该使用年作为单位。我们希望你能理解这一点。这个概念被称为 **粒度**，需要与边界概念相结合，这样通过以正确的粒度绕过边界，你可以确保你的测试没有留下任何偶然性。

让我们继续我们的例子，并测试 `export` 函数。

### 测试导出函数

在同一个测试模块中，我们定义了另一个类，它代表 `export()` 函数的测试套件。下面是它：

```py
# tests/test_api.py
class TestExport:
    """Test behavior of `export` function."""
    @pytest.fixture
    def csv_file(self, tmp_path):
        """Yield a filename in a temporary folder.
        Due to how pytest `tmp_path` fixture works, the file does
        not exist yet.
        """
        csv_path = tmp_path / "out.csv"
        yield csv_path
        csv_path.unlink(missing_ok=True)
    @pytest.fixture
    def existing_file(self, tmp_path):
        """Create a temporary file and put some content in it."""
        existing = tmp_path / "existing.csv"
        existing.write_text("Please leave me alone...")
        return existing 
```

让我们首先分析设置函数。这次我们在类级别定义了它们，这意味着它们将可用于同一类中的测试。我们不需要在这个类之外使用这些设置函数，所以没有必要像用户设置函数那样在模块级别声明它们。

我们需要两个文件。如果你还记得本章开头我们写的内容，当涉及到与数据库、磁盘、网络等交互时，我们应该模拟一切。然而，当可能时，我们更喜欢使用不同的技术。在这种情况下，我们将使用临时文件夹，这些文件夹将在设置函数中创建和删除。如果我们能够避免模拟，我们会更加高兴。为了创建临时文件夹，我们使用来自 `pytest` 的 `tmp_path` 设置函数，它是一个 `pathlib.Path` 对象。

第一个设置函数 `csv_file()` 提供了对一个临时文件夹的引用。我们可以将直到并包括 `yield` 的逻辑视为设置阶段。就数据而言，设置函数本身由临时文件名表示。该文件本身尚不存在。当测试运行时，设置函数被创建，并在测试结束时，执行设置函数的其余代码（如果有 `yield` 之后的部分）。

这部分可以被视为拆卸阶段。在 `csv_file()` 设置函数的情况下，它包括调用 `csv_path.unlink()` 来删除 `.csv` 文件（如果存在）。你可以在任何设置函数的每个阶段放入更多内容，并且随着经验的积累，你将掌握以这种方式进行设置和拆卸的艺术。这会很快变得自然而然。

在每次测试后严格来说没有必要删除 `.csv` 文件。`tmp_path` 设置函数将为每个测试创建一个新的临时目录，因此不存在在此目录中创建的文件干扰其他测试的风险。我们选择在这个设置函数中删除文件只是为了演示在设置函数中使用 `yield` 的用法。

第二个固定值`existing_file()`与第一个类似，但我们将使用它来测试当我们用`overwrite=False`调用`export()`时，我们能否防止覆盖。因此，我们在临时文件夹中创建了一个文件，并放入了一些内容，只是为了有验证它没有被修改的手段。

现在我们来看看测试（就像我们之前做的那样，我们包括类声明但省略了已经展示过的测试）：

```py
# tests/test_api.py
class TestExport:
    ...
    def test_export(self, users, csv_file):
        export(csv_file, users)
        text = csv_file.read_text()
        assert (
            "email,name,age,role\n"
            "minimal@example.com,Primus Minimus,18,\n"
            "full@example.com,Maximus Plenus,65,emperor\n"
        ) == text 
```

这个测试使用了`users()`和`csv_file()`固定值，并立即用它们调用`export()`。我们期望创建了一个文件，并填充了我们拥有的两个有效用户（记住列表中有三个用户，但有一个是无效的）。

为了验证这一点，我们打开临时文件，将其所有文本收集到一个字符串中。然后我们比较文件的内容与我们期望的内容。注意我们只放上了标题和两个有效的用户，并且顺序正确。

现在我们需要另一个测试来确保如果其中一个值中有逗号，我们的 CSV 仍然可以正确生成。作为一个**CSV**文件，我们需要确保数据中的逗号不会破坏结构：

```py
# tests/test_api.py
class TestExport:
    ...
    def test_export_quoting(self, min_user, csv_file):
        min_user["name"] = "A name, with a comma"
        export(csv_file, [min_user])
        text = csv_file.read_text()
        assert (
            "email,name,age,role\n"
            'minimal@example.com,"A name, with a comma",18,\n'
        ) == text 
```

这次，我们不需要整个用户列表；我们只需要一个，因为我们正在测试一个特定的事情，我们已经有之前的测试来确保我们能够正确地生成包含所有用户的文件。记住，总是尽量在测试中减少你的工作量。

因此，我们使用`min_user()`并在其名称中加逗号。然后我们重复之前的程序，这和之前的测试类似，最后，我们确保名称被放在 CSV 文件的双引号内。这对任何好的 CSV 解析器来说都足够理解，它们不应该在双引号内断开逗号。

现在，我们还想进行另一个测试，以确保当文件已经存在而我们不想覆盖它时，我们的代码不会这样做：

```py
# tests/test_api.py
class TestExport:
    ...
    def test_does_not_overwrite(self, users, existing_file):
        with pytest.raises(IOError) as err:
            export(existing_file, users, overwrite=False)
        err.match(
            r"'{}' already exists\.".format(
                re.escape(str(existing_file))
            )
        )
        # let us also verify the file is still intact
        assert existing_file.read_text() == (
            "Please leave me alone..."
        ) 
```

这是一个有趣的测试，因为它允许我们向您展示如何告诉`pytest`您期望一个函数调用抛出异常。我们在`pytest.raises()`提供的上下文中这样做，我们将我们期望从上下文管理器体内进行的调用中获得的异常提供给它。如果异常没有被引发，测试将失败。

我们喜欢在测试中做到彻底，所以不想就此停止。我们还通过使用方便的`err.match()`辅助函数对消息进行断言。注意，在调用`err.match()`时，我们不需要使用`assert`语句。如果参数不匹配，调用将引发`AssertionError`，导致测试失败。我们还需要转义`existing_file`的字符串版本，因为在 Windows 上，路径有反斜杠，这会混淆我们提供给`err.match()`的正则表达式。

最后，我们通过读取文件并比较其内容与最初写入文件中的字符串来确保文件仍然包含其原始内容（这就是为什么我们创建了`existing_file()`固定值）。

### 最终考虑

在我们继续下一个主题之前，让我们总结一些考虑因素。

首先，我们希望你已经注意到我们没有测试我们编写的所有函数。具体来说，我们没有测试`get_valid_users()`、`validate()`和`write_csv()`。原因是这些函数已经被我们的测试套件隐式测试了。我们已经测试了`is_valid()`和`export()`，这已经足够确保模式正确验证用户，并且`export()`函数在需要时过滤掉无效用户，尊重现有文件，并正确写入 CSV。我们没有测试的函数是内部函数；它们提供参与执行我们已经彻底测试过的某些操作的逻辑。

为那些函数添加额外的测试是好事还是坏事？答案实际上很难。

我们测试得越多，就越难重构那段代码。就目前而言，我们可以很容易地决定重命名`validate()`，而且我们不需要更改我们编写的任何测试。如果你这么想，这是有道理的，因为只要`validate()`为`get_valid_users()`函数提供正确的验证，我们就真的不需要了解它。

如果我们为`validate()`函数编写了测试，那么如果我们决定重命名它（或更改其签名，例如），我们就必须更改这些测试。

那么，正确的事情是什么？测试还是不测试？这取决于你。你必须找到正确的平衡。我们个人对这个问题的看法是，一切都需要彻底测试，无论是直接还是间接。我们试图编写尽可能小的测试套件，以确保这一点。这样，我们将拥有一个在覆盖率方面的完整测试套件，但不会比必要的更大。我们需要维护这些测试。

我们希望这个例子对你来说是有意义的；我们认为它使我们能够触及重要的主题。

如果你查看这本书的源代码，在`test_api.py`模块中，你会找到几个额外的测试类，它们会向你展示如果我们决定完全使用模拟进行测试，测试会有何不同。确保你阅读并充分理解那段代码。它相当直接，并且会为你提供一个与我们在这里展示的方法的良好比较。

现在我们来运行完整的测试套件：

```py
$ pytest tests
====================== test session starts ======================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0
rootdir: /Users/fab/code/lpp4ed
configfile: pyproject.toml
collected 132 items
tests/test_api.py ..............................................
................................................................
......................                                    [100%]
====================== 132 passed in 0.14s ====================== 
```

如前所述，请确保您在`ch10`文件夹内运行`$ pytest test`（添加`-vv`标志以获得详细输出，这将显示参数化如何修改测试名称）。`pytest`会扫描您的文件和文件夹，寻找以`test_`开头或结尾的模块，如`test_*.py`或`*_test.py`。在这些模块中，它会获取以`test`为前缀的函数或`Test`为前缀的类中的`test`为前缀的方法（您可以在`pytest`文档中阅读完整的规范）。如您所见，132 个测试在 140 毫秒内完成，并且全部成功。我们强烈建议您检查此代码并对其进行实验。在代码中更改一些内容，看看是否有测试失败。理解为什么它失败了（或没有）。

即使代码不再正确，测试是否仍然通过？测试是否过于严格，即使你做出不影响输出正确性的更改，测试也会失败？思考这些问题将帮助您更深入地了解测试的艺术。

我们还建议您学习`unittest`模块，以及`pytest`库。这些是您将经常使用的工具，因此您需要熟悉它们。

让我们现在讨论 TDD。

# 测试驱动开发

让我们简要地谈谈**TDD**。这是一种由 Kent Beck 重新发现的方法论，他写了《通过示例进行测试驱动开发，Addison Wesley，2002》，我们鼓励您阅读这本书，如果您想了解这个主题的基础知识。

TDD 是一种基于非常短的开发周期持续重复的软件开发方法。

首先，开发者编写一个测试并运行它。这个测试应该检查尚未成为代码一部分的功能。可能是一个要添加的新功能，或者是要删除或修改的内容。运行测试将使其失败，因此这个阶段被称为**红色**。

然后，开发者编写最少的代码以使测试通过。当测试运行成功时，我们就有了所谓的**绿色**阶段。在这个阶段，可以编写一些欺骗性的代码，只是为了使测试通过。这种技术被称为*fake it ‘til you make it*。在 TDD 周期的第二次迭代中，测试会添加不同的边缘情况，如果有任何欺骗性代码，它将无法同时满足所有测试，因此开发者必须编写满足测试的实际逻辑。添加其他测试案例有时被称为**三角测量**。

循环的最后一部分是开发者负责重构代码和测试，直到它们达到期望的状态。这个最后阶段被称为**重构**。

因此，TDD 的咒语是**红色-绿色-重构**。

起初，在编写代码之前编写测试可能会感觉有些奇怪，我们必须承认我们花了很长时间才习惯这种方式。但是，如果你坚持下去，并强迫自己学习这种稍微有些反直觉的方法，在某个时刻，几乎会发生某种神奇的事情，你将看到代码质量以其他方式不可能实现的方式提高。

当我们在测试之前编写代码时，我们必须同时关注代码需要做什么以及如何做。另一方面，当我们先编写测试再编写代码时，我们可以几乎完全专注于“是什么”的部分。

之后，当我们编写代码时，我们主要需要关注代码如何实现测试所要求的内容。这种关注点的转变使得我们的思维可以分别专注于“是什么”和“如何做”的部分，从而产生一种令人惊讶的脑力提升。

采用这种技术还有其他一些好处：

+   **提高代码质量**：首先编写测试确保代码库得到彻底测试，可以导致生产代码中更少的错误和错误。它鼓励开发者只编写通过测试所必需的代码，这可能导致更干净、更简单的代码。

+   **更好的设计决策**：TDD 鼓励开发者从一开始就考虑代码的设计和结构。这种早期的考虑可以导致更好的软件设计和架构。

+   **促进重构**：有了全面的测试套件，开发者可以自信地进行重构和改进代码，因为他们知道测试将捕捉到任何由更改引入的回归或问题。

+   **文档**：测试本身就是代码库的文档。它们描述了代码应该做什么，这有助于新团队成员或回顾旧代码时。

+   **减少调试时间**：通过在开发过程中早期捕捉错误，TDD 可以减少开发者调试代码所花费的时间。

+   **更好的业务需求理解**：有一套通过测试的测试套件可以让开发者有信心，他们的代码符合所需的规范，并且按预期行为。

另一方面，这种技术也有一些缺点：

+   **初始减速**：在编写功能代码之前编写测试可能会减缓初始的开发过程。这在快速发展的开发环境或紧迫的截止日期下尤其具有挑战性。

+   **学习曲线**：TDD（测试驱动开发）需要与许多开发者习惯的编程思维和方式有所不同。学习曲线可能会很陡峭，开发者最初可能会发现编写有效的测试比较困难。

+   **简单更改的额外开销**：对于非常简单的更改或修复，编写测试的第一步可能会显得不必要且耗时。

+   **复杂 UI 或外部系统困难**：当处理复杂的 UI 或与外部系统、数据库或 API 的交互时，测试可能会变得具有挑战性。模拟和存根可能会有所帮助，但它们也增加了复杂性和维护开销。

我们对 TDD 非常热情。然而，经过多年的应用，我们遇到了一些情况，TDD 证明不太可行。一个典型的例子是面对包含数百甚至数千个测试用例的测试套件。在这种情况下，预先确定要更改以实现源代码中所需更改的具体测试几乎是一项无法克服的任务。有时，直接修改代码并观察哪些测试失败可能更为实际。

尽管如此，我们仍然坚信掌握 TDD 的价值。虽然 TDD 的最大优势可能在于其教育意义而不是其实际应用，但它所传授的知识和心态是无价的。将 TDD 掌握到可以高效应用的程度，在我们的编码实践中留下了不可磨灭的印记，即使在那些不使用 TDD 的项目中，它也影响着我们的方法。

因此，牢记以下原则至关重要：始终严格测试您的代码。这种做法对于确保软件的可靠性和完整性至关重要，无论采用何种开发方法。

# 摘要

在本章中，我们探讨了测试的世界。

我们试图为您提供关于测试的相当全面的概述，特别是单元测试，这是开发者最常进行的测试类型。我们希望我们已经成功地传达了这样一个信息：测试并不是一个完美定义的东西，你可以从书中学习。在感到舒适之前，你需要花相当长的时间去实验。在所有关于学习和实验的努力中，我们认为测试是最重要的之一。

在下一章中，我们将探讨调试和性能分析，这些技术与测试密切相关。您应该确保您能很好地掌握它们。

# 加入我们的 Discord 社区

加入我们社区的 Discord 空间，与作者和其他读者进行讨论：

`discord.com/invite/uaKmaz7FEC`

![img](img/QR_Code119001106417026468.png)
