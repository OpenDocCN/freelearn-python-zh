# 第十八章。尼克·科根兰

![尼克·科根兰](img/B08180_11_01.jpg)

尼克·科根兰是一位澳大利亚软件开发者和系统架构师。他过去的工作经历包括在波音澳大利亚的软件工程师和红帽亚太地区的资深软件工程师，红帽是一家开源解决方案提供商。尼克是 CPython 核心开发者，Python 打包互操作性标准的 BDFL 代表。他是 Python 软件基金会（PSF）的 Python 打包工作组创始人，也是 PyCon 澳大利亚教育研讨会的创始人。在过去 20 年里，尼克为一系列开源系统和软件项目做出了贡献。

> **尼克·科根兰的照片版权**：©库沙尔·达斯
> 
> **讨论主题：核心开发者、PEP、学习 Python。**
> 
> **在这里了解尼克·科根兰：@ncoghlan_de**

**迈克·德里斯科尔**：是什么让你决定成为一名计算机程序员？

**尼克·科根兰**：起初，我只是把编程当作孩子时的玩具。我们有一本关于 Apple IIe 的老式 BASIC 编程书籍。

直到我在高中一年级学习信息技术时，我才意识到计算机实际上是一种可以用来工作的玩具。我去的学校是该州最早开设信息技术课程的学校之一。所以这就是我后来在大学选择计算机系统工程的原因。

我大学毕业后最初的全职工作是使用 C 语言为德州仪器的 DSP 进行嵌入式系统编程。从那里，我做了很多系统控制和自动化工作，这看起来更像编程，而不是嵌入式软件开发。所以，我只是喜欢编程，我擅长它，而且你可以从中赚钱。

**德里斯科尔**：那你为什么转向 Python？

**科根兰**：我转向 Python 的方式实际上很有趣，因为我最初是一名 C/C++开发者。

> **尼克·科根兰：“我就是那个回答说‘我们能用不同的语言吗？我已经知道 Java 了，我想用 Java’的人。’**

我在大学里对 Python 的唯一接触是从一位网络讲师那里，他说：“我将让你们所有人用 Python 完成作业，因为我相信你们中没有人会知道它”。我就是那个回答说：“我们能用不同的语言吗？我已经知道 Java 了，我想用 Java”的人。

我的讲师说：“好吧，如果你真的想用 Java，那就用吧，但先试试 Python”。所以我试了 Python 1.5.2，感觉很有趣。

在专业领域，我在澳大利亚的一家大型系统集成公司工作。对于我正在工作的 DSP 项目，我的测试套件是一个非常基础的 C 程序，如果它运行到结束而没有崩溃，那就算成功了。

当我们到达下一级集成测试时，我们遇到了很多 DSP 代码不正常工作的问题。所以我们有大量的行为错误通过。我们决定我们需要编写一个更好的测试套件来输入音频。检查我们是否从实际数据分析中获得预期的答案是重要的，而不仅仅是我们可以与 DSP 通信并远程请求它做事情。

> **尼克·科格兰：'检查我们是否从实际数据分析中获得预期的答案是很重要的。'**

我们想检查实际的信号处理。我们也不想用 C 和 C++来编写它。系统的另一部分已经批准 Python 作为系统控制组件的语言。所以 Python 并没有用于关键路径的东西，只是协调系统的不同部分，并在它们应该启动时启动它们。

我们在自动化测试方面有两个主要的选择。一个选项是使用 Python 的`unittest`模块和 SWIG 生成绑定到与 DSP 通信的 C++驱动程序的绑定。另一个选择是我们用于其他所有事情的内部 C/C++测试框架。我们选择了 Python。

**德里斯科尔**: 为什么选择 Python？

**科格兰**: 问题是 Python 有一个`unittest`模块来实际组织测试。Python 有 SWIG 来连接到 C++驱动程序。我们控制了那个驱动程序的 API，所以让它与 SWIG 很好地配合是直接的。

然后最后一个关键部分是 Python 在其标准库中有一个 wave 模块，可以从 PC 播放 WAV 文件。因此，这为整个项目确立了一个趋势，即澳大利亚高频现代化项目。Python 最终在这个项目中广泛传播，用于所有测试、模拟系统接口的测试目的。

**德里斯科尔**: 所以我知道另一个澳大利亚人帮助创建了 pywin32。你在那个项目中有什么参与吗？

**科格兰**: 不，我过去一直只是个 pywin32 用户。实际上，历史上有很多澳大利亚人为 Python 社区做出了贡献。但是因为他们并没有真正活跃在 PyCon Australia 或类似的活动上，所以我实际上从未见过他们！

**德里斯科尔**: 好吧，让我们继续。你是如何成为 Python 语言的核心开发者的？

**科格兰**: 所以我对这个问题的简短回答是，我是通过与 Guido van Rossum 争论而成为核心开发者的！

> **尼克·科格兰：'我是通过与 Guido van Rossum 争论而成为核心开发者的！'**

实际上发生的事情是，我从 20 世纪 90 年代末就开始使用 Usenet，所以我非常熟悉那个整个在线讨论格式。在我开始使用 Python 后，我最终加入了原始的 Python 邮件列表，并参与了那里的讨论。

我发现 Python-Dev 是一个东西，并开始在那里潜伏，最初只是想听听人们都在谈论什么。我实际上开始积极参与讨论并发表帖子。我记得我第一次真正做出的贡献是在 Python 列表上的讨论。

使用`timeit`模块来计时代码片段并说“哦，这个比那个快。”是很常见的。在那个阶段，如果你想比较两个不同版本之间的代码片段，你必须找到标准库中特定版本的`timeit`模块所在的位置。

我们说，“等等！Python 已经知道`timeit`模块在哪里了。我们为什么还要告诉 Python 在哪里找到它？”所以这最终成为了一个补丁，用于在 Python 2.4 中添加初始版本的-m 开关。我认为雷蒙德·赫廷格审查了那个。这个 Python 初始版本只能处理顶层模块，不能处理包或子模块。最终到了 Python 2.7，-m 开关实际上正常工作，并做了你期望的所有事情。

> **尼克·科根：'终于到了 Python 2.7 版本，-m 开关才真正正常工作。'**

在 2004 年底发生了一件有趣的事情。在工作中的一个大压力期之后，我请了三个月的假。我最终帮助雷蒙德和法昆多·巴蒂斯塔对 Python 十进制模块进行了初始的性能提升。我们正在研究我们能做什么来使该模块更快。

**德里斯科尔**：你找到加快速度的方法了吗？

**科根**：实际上，几年后找到了一个解决方案，但在那些早期日子里，有很多基准测试来说明，“我们能把这个东西做得有多快，仅仅作为一个纯 Python 的东西？”

> **尼克·科根：'有很多基准测试来说明，'我们能把这个东西做得有多快，仅仅作为一个纯 Python 的东西？'**

我记得那些日子里有一个辉煌的技巧。我们发现，在纯 Python 中，如果你有一个你想转换成十进制数的数字元组，那么 CPython 本身提供的最快转换机制是将所有数字转换为字符串，连接这些字符串，然后使用`int`将连接后的字符串转换回数字。

这是因为字符串到`int`的转换已经被优化到了一个程度，这样做比用 Python 代码进行所有乘法和加法运算要快。当然，在 C 语言中，你会进行算术运算。我们的发现真的让 PyPy 开发者感到烦恼。从他们的角度来看，进行算术运算要好得多，因为 JIT（即时编译）工作。这意味着他们的`decimal`模块比他们希望的运行得慢。

我认为我是在 Python 2.3 发布后不久开始参与讨论的。当时的一种流行消遣是嘲笑扩展切片语法。你有反向笑脸的开放括号，冒号，冒号，-1，和闭合括号，来反转一个序列。这还是在`reversed`或类似功能出现之前。

`reversed`之所以成为可能，是因为发现正确处理切片反转的算术实际上相当棘手。如果你手动做，很容易出现偏移量错误。所以添加`reversed`使得代码更容易阅读。

**德里斯科尔**: 你对 Python 2.7 的长期存在有何看法？人们应该迁移到最新版本吗？

**科格兰**: 我们故意将 Python 2.7 的支持期设定得足够长，以便现有用户可以自己决定何时认为 Python 3 生态系统足够成熟，可以切换过来。

> **尼克·科格兰：“我们故意将 Python 2.7 的支持期设定得足够长，以便现有用户可以自己做出决定。”**

感受过 Python 2.7 限制之苦的人们早早地迁移了，所以我们现在处于这样一个阶段，即大多数尚未迁移的人要么正在寻找更好的工具来帮助他们完成这个过程，要么只是简单地计划在 Python 2.7 停止支持的同时结束受影响的项目和产品。

在工具方面，Python 3 的类型提示机制的一个重要用例是允许人们静态检查 Python 3 的类型正确性错误，即使他们的自动化测试覆盖率很低。这大大扩大了可以可靠迁移的代码范围。

**德里斯科尔**: 你希望在未来的 Python 版本中看到哪些变化？

**科格兰**: 我希望看到更好的工具来处理部分结构化的分层数据，但方式要保留 Python 作为可执行伪代码的声誉。我还希望继续减少使用扩展模块可以做到的事情和具体需要 Python 源模块的事情之间的差异。

最后，我希望看到对受保护内存管理模型的支持得到改善，而不是旨在作为安全边界，而是提供内存分离作为辅助维护并发代码正确性的方式。CPython 的子解释器功能已经在某种程度上提供了这种支持，但该功能目前存在许多可用性挑战，埃里克·斯诺正在努力解决这些问题。

**德里斯科尔**: 好啊！那么让我们假设我想成为像你一样的核心开发者。我实际上需要做什么才能成为核心开发者？

**科格兰**: 其中最重要的一件事是要弄清楚你为什么想成为核心开发者。你需要回答这个问题，因为在不可避免的不满中，你会问自己：“我究竟为什么要做这件事？！”

如果你不知道自己的动机是什么，那么这将会成为一个问题！没有人能为你回答这个问题。过了这个阶段，成为核心开发者最主要的是，这实际上很多都是关于信任和赢得信任。

> **尼克·科根：**“成为核心开发者最主要的是，这实际上很多都是关于信任和赢得信任。”

这是一个贡献的问题，所以作为核心审查员，我们基本上在那里说，“我们是否想接受这个变化并将其维护到未来？如果我们后来被问及，我们能否给出一个关于我们为什么接受这个变化的良好答案？”

当我们提名新的核心开发者时，我们寻找的是我们信任其能够做出良好判断的人。我们希望他们能说，“是的，这是一个合适的变更，从整体上讲，将使未来的 Python 用户的生活变得更好。”

编程语言设计是一场权衡的游戏。如果你试图一次性优化所有事情，那么你最终什么都没有优化。所以随着时间的推移，出现了很多权衡，使某些事情变得像 Python 一样。这变成了一个问题，即你是否可以自己做出决定，或者你是否需要将问题带到 Python-Dev 进行讨论。

> **尼克·科根：**“编程语言设计是一场权衡的游戏。如果你试图一次性优化所有事情，那么你最终什么都没有优化。”

然后有一个最终的升级级别，当我们说，“这个提案很棘手，这里有很多微妙之处。这里有足够的潜在争议，我们应该将这个问题升级为一个完整的 Python 增强提案，并详细讨论细节，然后再做其他任何事情。”最终是核心开发者决定一个特定的变化位于那个光谱的哪个位置。

> **尼克·科根：**“最终是核心开发者决定一个特定的变化位于那个光谱的哪个位置。”

**德里斯科尔：**核心开发者是如何做出那个决定的？

**科根：**嗯，错误修复通常相当直接，因为我们知道有些东西是错误的。即使是在错误修复的情况下，有时也会让人困惑。

我们有三个真理来源，因为我们有参考解释器所做的工作，测试套件所说的，以及文档所说的。当这三个都达成一致时，你就知道你所做的是一致的。

当解释器做了某事，而测试套件和文档对此保持沉默时，事情开始更多地成为设计判断的问题。那种情况根本就没有被测试，也没有记录为做了任何特别的事情。然后另一种情况是，文档说了一件事，但测试和实现说的是另一件事。在这些情况下，你必须说，“嗯，是文档正确并且是一个错误，还是文档只是错了？”

那些是你作为一个核心开发者能够做的事情。而当你是一个贡献者时，你只是希望把自己的想法提出来。这仍然是一个信任管理的问题，但你试图做的是说服审阅者你的改动是值得进行的。所以，是的，这确实很有趣！

你需要理解成为核心开发者意味着什么，以及为什么这是你想要的。从角色的实际操作机制来看，有由布赖特·卡农最初用 BSF 资金编写的开发者指南。开发者指南随着时间的推移得到了维护和增强，它解释了成为核心开发者与成为 CPython 贡献者之间的区别。

> **尼克·科根：'作为一个核心开发者，你会有额外的责任。'**

作为一个核心开发者，你会有额外的责任。这个角色包括处理问题、与审阅者合作、理解审阅流程、在邮件列表上讨论事情以及做出设计决策。你最终会处理在这样一个大项目上工作的不可避免的不满。根据你是什么样的人，核心导师邮件列表也可能很有用。

**德里斯科尔：所以我一直对 Python 增强提案很感兴趣。你能描述一下它们是如何被创建和接受的流程吗？**

**科根：是的，所以 Python 增强提案（PEPs）可以通过两种不同的流程进行。**

> **尼克·科根：'有一种情况是一个核心开发者提出一个我们知道我们想要进行的改动，但我们也知道这个改动将会很大且复杂。我们知道不需要任何人告诉我们，这个改动需要成为一个 PEP。所以在这种情况下，我们通常会先写一个 PEP，并将 PEP 提交到 PEPs 仓库。'**

一种情况是一个核心开发者提出一个我们知道我们想要进行的改动，但我们也知道这个改动将会很大且复杂。我们知道不需要任何人告诉我们，这个改动需要成为一个 PEP。所以在这种情况下，我们通常会先写一个 PEP，并将 PEP 提交到 PEPs 仓库。

我们将在 Python-ideas 上开始讨论，说：“嘿，我写了一个新的 PEP，提出了这个，这是原因。”讨论基本上就是从那个层面开始的。核心开发者管理 PEP 流程，因为我们已经经历了几次，我们知道什么时候一个改动足够大，可以成为 PEP。

对于其他 PEP（Python 增强提案），通常的起点是有人带着一个建议来到 Python-ideas。这个建议已经作为一个 Python-ideas 线程讨论了一段时间。然后人们会说：“你知道什么，这实际上听起来可能是一个好主意！”然后决定将这个想法变成一个完整的 PEP，并通过这种方式提出这个想法，而不是仅仅在问题跟踪器上提交为一个问题。

这实际上让我想起了 PEP 发生的第三种方式。它们可以从问题跟踪器上的讨论中产生，当我们确实知道我们想要进行改动，但有很多小细节。我们写一个 PEP，讨论细节，然后使用它来推动我们如何实现这个想法。

> **尼克·科格兰**：“我们编写一个 PEP，讨论细节，然后使用它来推动我们的想法的实施。”

**德里斯科尔**：那么这些变化只是讨论，直到它们最终被解决，然后被接受或拒绝吗？

**科格兰**：这取决于提议。有些提议本身并不具有争议性，但细节需要进一步讨论。

这些提议通常会经过 Python-ideas 和 Python-Dev 的一些讨论。然后，将做出决定停止讨论这个想法，并开始实施它。这个提议成为了一个被接受的 PEP，并最终进入最终阶段。

有些提议更接近边缘，我们向 Python-Dev 提出了一个问题，即它们是否真的是一个好主意。我们目前确实有一个关于空合并运算符的提议。我们真的不知道我们是否想继续下去。这个 PEP 会使语言更加复杂，因为它是一种需要学习和理解的晦涩语法。所以这是反对这个想法的主要论据。但在支持这个论据时，你说：“嗯，这是一个在数据处理管道中相当常见的模式。”

因此，这个 PEP 仍在讨论中，直到它最终被提交给 Python-Dev 作为一个是或否的问题。然后，将做出决定，要么我们确实想继续下去，要么我们不，除非有变化。

> **尼克·科格兰**：“非常偶尔，你会得到一些专门写成被拒绝的 PEP。”

非常偶尔，你会得到一些专门写成被拒绝的 PEP。在这些情况下，一个想法会不断出现，但反对它的论据从未在任何地方被清楚地记录下来。所以有人只是花时间写下这个想法，并写下我们拒绝这个 PEP 的所有原因，然后说：“好吧！我正在发布这个被拒绝的 PEP，来说明我们为什么不做这件事。”这让我想到了我在 Python 3.5 和 3.6 中看到的一些新东西，这些只被部分接受，并被归类为临时。

**德里斯科尔**：那么这略有不同吗？这意味着人们已经足够同意，他们想添加一些内容，但他们可能不会保留它吗？

**科格兰**：是的，所以我们接受了一些变更，并立即将其纳入我们的标准向后兼容性保证中，结果我们遇到了几次麻烦。

我们最终陷入的困境是把自己逼入了一个角落。我们陷入了支持一个实际上对它试图解决的问题并不好的 API。我们收到了这些建议和潜在的模块添加，这些显然对用户是有益的，并且显然是有帮助的。问题是，我们不确定我们是否正确地设计了 API 的细节。

> **尼克·科格兰**：“我们陷入了支持一个实际上对它试图解决的问题并不好的 API。”

我们不想将任何内容置于我们完整的标准库向后兼容性保证之下，所以我们决定不包含这些新增内容。这种方法最终对每个人都不利，因为它将本应包含在标准库中的内容排除在外。

我们也无法使用这种类型的模块来帮助我们改进标准库的其他部分。坦白说，新构建块进入标准库的主要方式之一是我们想在标准库的其他部分使用它们。所以现在有一个标准库的`enum`类型，因为我们想在像 socket 模块这样的东西中使用`enum`类型。

我认为最终成为 PEP 411 的临时 PEP 经历了几次迭代。基本上，PEP 411 是为了让我们能够接受我们相当有信心会保留的模块，但我们还不确定 API 设计细节是否正确。

我们将 PEP 作为临时提案保留几轮发布，以便在出现错误时，我们有权利对 API 进行破坏性更改。我认为异步 I/O 仅在 Python 3.6 中刚刚变为非临时。

> **尼克·科根：**“我们将 PEP 作为临时提案保留几轮发布，以便在出现错误时，我们有权利对 API 进行破坏性更改。”

**德里斯科尔**：那么将 PEP 作为临时提案是否有效？

**科根**：是的，我们实际上对它的运作效果非常满意。它让我们能够清楚地警告人们 PEP 仍然有些变动。这使用户知道我们仍在确定细节，如果这让他们感到困扰，那么他们就不应该使用这个 PEP。

最近有一个有趣的例子是 Python 3.6 中的`pathlib`。`pathlib`被作为一个临时 API 包含在内，它与期望字符串的其他标准库 API 存在许多互操作性问题。

> **尼克·科根：**“对于 Python 3.6，`pathlib`遇到了十字路口。”**

对于 Python 3.6，`pathlib`遇到了十字路口，要么再次从标准库中移除并推回纯 PyPI 模块，要么必须修复互操作性问题。这是 Python 3.6 核心开发团队面前的一个非此即彼的决定。

这个决定成为了`os.path`协议，或`os.fspath`协议以及路径对象支持，这基本上是修复了`pathlib`的互操作性问题。这意味着现在有很多标准库 API 会自动接受路径对象。

**德里斯科尔**：好的，那么 Python 打包权威机构是什么？

**科根**：所以 Python 打包权威机构的名字实际上最初是 pip 和 virtualenv 开发者开的玩笑。他们想要一个涵盖这两个项目的开发团队的名称。所以他们说：“让我们称自己为 Python 打包权威机构，因为没有人会期待 Python 打包权威机构！”

然后，回到 2013 年，我们开始积极尝试将更多工具，如`setuptools`和`distutils`，引入这个领域。Python 打包用户指南开始将这些信息整合起来，以提供一种更连贯且官方推荐的做法。我们也需要一个名字来称呼这个范畴组。我们决定 Python 打包权威机构这个名字听起来挺酷的，所以我们可以开始将更多项目纳入这个范畴。

> **尼克·科根：**“我们决定 Python 打包权威机构这个名字听起来挺酷的，所以我们可以开始将更多项目纳入这个范畴。”**

基本上，Python 打包权威机构在打包工具和互操作性标准方面扮演着一种角色，这与核心开发者与 Python 整体的关系类似。虽然对编程语言设计和软件分发设计感兴趣的人之间有一些重叠，但很多人更倾向于其中的一边。这些人对于另一方面的内容并不感兴趣。

将这两种类型的人分开意味着任何关心这两种设计类型的人都可以参与这两个子社区。但我们并不是一直在试图向语言设计师解释软件分发的复杂性，反之亦然。我认为这种划分使人们普遍感到更快乐。能在一个你理解的群体中是很不错的。我喜欢打包，但也喜欢 Python。所以我有点犹豫自己可能属于哪一类。我可能还想在 Python 和 Python 打包权威机构上工作。

> **尼克·科根：**“我喜欢打包，但也喜欢 Python。所以我有点犹豫自己可能属于哪一类。”**

**德里科：**Python 是 AI 和机器学习中使用的几种主要语言之一。你认为为什么 Python 会是这样？

**科根：**AI 和机器学习是探索性交互数据分析与重型数值计算的有趣结合。CPython 丰富的 C API 导致 Python 成为连接用 C、C++和 Fortran 等语言编写的性能组件的“胶水”语言。

科学研究界已经这样使用 Python 超过 20 年了（Numeric 的第一个版本于 1995 年发布）。这意味着 Python 提供了一种独特的混合体，既灵活又易于学习，是一种通用计算语言，结合了一套为高性能计算环境开发使用的科学计算库。

**德里科：**“为了使 Python 成为更好的 AI 和机器学习语言，我们可以做些什么？”**

**科根：**在易用性方面，还有很多机会让组件更容易地提供给用户，无论是通过预配置的免费增值网络服务（如 Google Colabatory 或 Microsoft Azure Notebooks），还是通过本地的 Python 和 Conda 打包工具链。

在性能方面，还有许多未探索的机会来更好地优化 CPython 解释器和 Cython 静态编译器（例如，Cython 目前不提供共享动态运行时，因此生成的模块中可能存在大量的重复样板代码，这不仅使它们更大、编译速度更慢，而且在运行时导入也更快）。

**德里斯科尔**: 所以我注意到你也是一个博主。你写了多久关于 Python 的内容？是什么让你决定成为一名博主的？

**科格兰**: 大概是在 Python 3.3 的时候，我开始在我的博客上谈论编程相关的内容。大多数情况下，我发现写作是一种非常有用的思考辅助工具。你被迫使你的想法足够连贯以便于阅读。所以现在我还是主要用这种方式来使用博客。如果我对 Python 的某个特定方面想要稍后引用，那么我会写下我的当前想法。

**德里斯科尔**: 在你看来，Python 是一个适合实际开始学习编程的语言吗？

**科格兰**: 我确实推荐 Python 作为一种基于文本的第一语言。对于很多人来说，如果他们想要掌握基本概念，从一种即插即用的语言开始是一个不错的选择。

> **尼克·科格兰：“一旦你想进入完整的组合编程，那么 Python 就是一个非常优秀的语言。”**

一旦你想进入完整的组合编程，Python 就是一个非常优秀的语言。故意的语言设计限制并不十分明智。你不能让它们解析非常复杂的远程操作。如果你学习语言学，你就会意识到人类大脑也难以解析复杂的远程操作。

所以 Python 的优势在于，你只需要向前看一个标记就能理解你当前正在查看的内容的上下文。你不需要在脑海中保留太多信息来理解代码试图告诉你的内容。我们试图使不同名称的来源可见。我认为这会对人们将想法融入大脑的难易程度产生很大的影响。

几年前，我发表了一篇关于脚本语言和适宜复杂度的帖子。如果你查看一本菜谱或工作指导手册，你将找到程序性指令。菜谱的外层非常程序化和顺序化。然后子函数和对象都嵌入在这个框架中。我认为 Python 对人们来说效果很好，因为它反映了我们与世界互动的方式。

> **尼克·科格兰：“我认为 Python 对人们来说效果很好，因为它反映了我们与世界互动的方式。”**

**德里斯科尔**: 你能更详细地解释一下为什么 Python 工作得如此好吗？

**科格兰**: 当然，我们按顺序做事。从程序性开始作为你的基础，然后根据需要，将其他所有东西层层叠加，这样做是非常有意义的。

面向对象编程、函数式编程和基于事件的编程都是我们为了管理复杂性而提出的技术。无论你选择哪一种，作为你语言的基本组织原则，都将设定你所做事情的最小复杂度。

与那些使用机器人技术和具身计算类型环境进行教学的人交谈非常有趣。当你这样教学时，从对象开始是一个不错的选择。具身计算的人有那种自然的能力，可以说：“我桌子上坐着的机器人对应于我程序中的‘Robot’类。”他们可以进行这种视觉关联。

我认为默认情况下，过程式编程确实与烹饪书和说明书的编写方式相匹配。这有助于降低入门门槛，但与此同时，Python 是一种可以与你一起成长的编程语言。Python 拥有进行数学编程、面向对象编程和函数式编程的所有工具。

> **尼克·科格兰**：“Python 是一种可以与你一起成长的编程语言。”

你可以根据你遇到的问题使用 Python。当你开始更深入地了解 Python 的特定方面时，你可以利用这一点作为跳板，进入专注于特定领域的语言。因此，你可以使用 Python 来进入 Haskell（函数式编程）、Java 或 C#。

**德里斯科尔**：所以，让我们假设我已经了解了 Python 的所有基础知识，现在我想增强我对这种语言的理解。我应该怎么做？

**科格兰**：在这个阶段，你需要问自己的重要问题是你是如何学习的。例如，对我来说，我发现我非常注重基于需求的学习。

> **尼克·科格兰**：“我学习新的编程技术和新的库是为了解决问题。”

我并不擅长为了学习而学习。我学习新的编程技术和新的库是为了解决问题。在我的情况下，我会找到我感兴趣解决的问题，然后学习我需要做的任何事情来解决它。

在学习更多方面，艾莉森·卡普图已经写了一些相当不错的内容。我们已经开始在开发指南中添加一个关于深入了解内部结构的章节。一个有用的技巧是看看你每天都会用到的东西，尤其是开源库，然后开始深入研究代码。

> **尼克·科格兰**：“看看你每天都会用到的东西，尤其是开源库，然后开始深入研究代码。”

因此，在标准库中，实际上会有从标准库模块文档到源代码的链接。实际上，只是去阅读它，并试图弄清楚为什么某些事情被这样做，可能会有所帮助。

这让我想起了另一个有趣的项目，叫做 Python Tutor（pythontutor.com）。Python Tutor 是一个代码可视化器或行为可视化器。当你通过代码工作时，Python Tutor 有一个逐步更新的小系统模型，解释正在发生的事情。

一种策略，我知道有些人肯定觉得很有用，就是试图改变事物，不是因为它们实际上想要做出改变，而是为了学习涉及其中的机制。

**德里斯科尔**：你对今天的 Python 最兴奋的是什么？

**科格兰**：我会给出一个分裂的回答，因为我对这个问题的专业和个人观点略有不同。

在很多方面，Python 对 Linux 生态系统所做的一切，就像 Linux 生态系统对一般企业组织所做的那样：无处不在，却没有人真正费心去告诉管理层。这意味着我们迄今为止所取得的一切成就，主要是通过志愿者社区贡献者的努力实现的，只有大型商业和机构用户偶尔和间歇性的投资。

> **尼克·科格兰**：“我们迄今为止所取得的一切成就，主要是通过志愿者社区贡献者的努力实现的。”

所以，从职业角度来看，最让我兴奋的是，AI 和机器学习技术在商业软件开发中的使用增加，促使许多组织意识到，软件开发的世界远不止当前的 C、C++、Java 和 C# 的企业巨头。

这在近年来通过 IEEE Spectrum 的年度多数据源语言排名中表现得最为明显，Python 在 2014 年开始时位于前五名边缘（与 C# 一起），但稳步攀升，在 2017 年的调查中达到了第一名。

个人而言，最让我兴奋的是我们正在让教师和其他教育者直接参与到开源 Python 社区中来。受到 2014 年 PyCon 澳大利亚上詹姆斯·柯兰的精彩主题演讲以及 PyCon 英国教育轨道的启发，我在 2015 年成立了 PyCon 澳大利亚教育研讨会，并且从那以后每年都在举办。

许多 Python 用户组也专注于成人教育，并为那些希望提高他们在当前职业中的计算技能，或者考虑转向软件开发职业的人提供研讨会。

**德里斯科尔**：谢谢你，尼克·科格兰。
