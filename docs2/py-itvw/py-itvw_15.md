# 第十五章。Oliver Schoenborn

![Oliver Schoenborn](img/B08180_10_01.jpg)

Oliver Schoenborn 是一位加拿大软件开发商和独立软件开发商。他过去的工作经历包括在 CAE 公司担任模拟顾问以及在加拿大国家研究委员会担任可视化软件开发者。Oliver 热衷于与商业和政府社区建立联系。他是 Pypubsub（托管在[`github.com/schollii/pypubsub`](https://github.com/schollii/pypubsub)）的作者，这是一个 Python 包，为用户提供了一种简单的方法来解耦他们基于事件的程序的部分。Oliver 定期更新 Pypubsub，并为 wxPython 邮件列表做出贡献。

> **讨论主题：Pypubsub、Python 在人工智能中的应用、Python 的未来。**
> 
> **与 Oliver Schoenborn 保持联系：@schollii2**

**Mike Driscoll**：那么，让我们从你的背景开始。你为什么决定成为一名程序员？

**Oliver Schoenborn**：嗯，学校的一个朋友在卖他的 Apple IIe。在那之前，我从未编程过，但我决定买下他的二手电脑。我当时 14 岁。

我记得我对 BASIC 和汇编语言非常感兴趣。有一个命令提示符，你可以以某种方式进入汇编级别来编写汇编代码。我阅读了计算机的许多手册，它们描述了如何编程。我尝试编写了一些小程序，最终进入了 Pascal。我真的很喜欢它。

在我高中第五年时，一位老师要求我们用一种叫做 Logo 的语言做一些事情。它基本上是一组图形命令，用来移动笔、画线等。我在那里创建了一个模拟循环，这样我就可以模拟一个小飞机飞行并投下炸弹。这很简单，但很有趣，老师也很印象深刻！

所以我就这样进入了编程。在某种程度上，这更像是一个机会。那时，编程仍然只是个爱好，因为我的目标是进入物理学。

**Driscoll**：那么你是如何最终接触到 Python 本身的？

**Schoenborn**：在工作时，我们有一个需要在 Windows 上开发图形用户界面的项目。

在过去的 10 年里，我主要在 UNIX 上用 C++编程，开发命令行和 3D 图形应用程序，但不是基于菜单的应用程序（除了用 Java AWT 编写的 GUI）。我真的很讨厌 MFC，所以我开始寻找 Windows 上做这个的选项。我发现了 Python（因为它具有平台无关性），还有 Tk。

> **Oliver Schoenborn**：“Python 是完美的选择。一看到这种语言，我就真的喜欢上了它的简单和清晰的语法。”

Python 是完美的选择。一看到这种语言，我就真的喜欢上了它的简单和清晰的语法。我不知道它是否只是与我思维方式相匹配。我还发现了 wxPython，并看到它的 API 似乎相当稳固。我爱上了 Python 以及它提供的快速创建 wxPython 界面的能力。

我是如何接触到 Python 的呢？是通过一个工作项目，这个项目的要求在 Python 中比在 C++ 中更容易实现。

**Driscoll**：这是你如何参与 wxPython 社区的吗？

**Schoenborn**：没错。我之所以开发我的第一个 wxPython 应用程序，是因为那个项目。这是一个分析座椅加热和空调的应用程序。当时，汽车座椅的舒适性正在使用这种软件进行原型设计。

所以我使用了 wxPython，并认为它支持的发布-订阅模式是一个非常棒的想法。我通过接管那个库的 Pubsub 组件，更深入地参与了 wxPython 的开发。

> **Oliver Schoenborn**：“我通过接管 wxPython 库的 Pubsub 组件，更深入地参与了 wxPython 的开发。”

**Driscoll**：那么 Pubsub 是由其他人开始的吗？

**Schoenborn**：是的，Robb Shecter 创建了 Pubsub 的第一个版本。有一些限制需要我解决（主要是内存泄漏：订阅者在不再被应用程序需要后没有被释放），我提出了一些重要的补丁和单元测试。Robb 正在寻找接手 `wx.lib.pubsub` 的人。所以我做了这件事。

**Driscoll**：这是 Pubsub 被分割成自己的模块，脱离 wxPython 的时候吗？

**Schoenborn**：我认为是在那之后的几年。Pubsub 几乎是一个独立的子包，而其他大多数 wx.lib 子包需要其他 wxPython 组件。我想让 wx.lib.pubsub 对更广泛的开发者可用，并且 wxPython 开发者小组的其他人也同意了。

> **Oliver Schoenborn**：“Pubsub 几乎是一个独立的组件。”

**Driscoll**：当时你们是否知道 PyDispatcher 项目？

**Schoenborn**：嗯，我在那些年中的某个时候确实意识到了 PyDispatcher。它是一个相当不同的方法。

我记得当时它不是基于主题的。Pubsub 与它足够不同，以至于可以作为一个独立的包来证明其合理性。自从上次查看它以来已经有一段时间了，但实际看看 PyDispatcher 现在处于什么位置会很有趣。

现在有几个项目正在使用主题、消息和发布/订阅的基本思想（例如 MQTT 和 Google pub/sub），但在网络层面，即应用程序之间的层面，而 Pypubsub 是在应用程序的组件之间层面。它们的发展比 Pubsub 必须发展的要多得多；Pypubsub 已经成熟，是生产级别的。

**Driscoll**：所以我注意到，在你参加我在“PyDev of the Week”系列中的采访的时候，你已经切换到了 PyQt。这是怎么发生的？

**肖恩博恩：**那是在 2013 年左右。我们基本上有一个项目，涉及现代化我们的客户的一个旧原型。该应用程序涉及用户定义的脚本，这些脚本可以通过原型运行，并且都是用 Python 编写的。因此，我们不得不嵌入一个 Python 解释器，或者将大量的 Python 脚本翻译成另一种语言，同时保证相同的输出（这是一个无法在项目预算范围内完成的任务）。

> **奥利弗·肖恩博恩：'我们不得不嵌入一个 Python 解释器，或者翻译大量的 Python 脚本。'**

图形界面必须非常复杂。当时，原型有一个 3D 组件，用户可以在 3D 环境中旋转模型组件。我们需要将图形用户界面与菜单和列表视图集成，作为一个复杂的 2D 和 3D 画布，用户可以与之交互。

我们想要的是一个稳定、强大、文档完善的解决方案，背后有一个活跃的社区。当时，WPF、wxPython 和 PyQt（或 Qt，用于 C++基础设施）是我们主要的候选者。在 C#方面有 WPF。我们考虑了多种不同的方法，最后在 wxPython 和 PyQt 之间选择了。

PyQt 似乎比 wxPython 有更强大的 3D 环境集成。PyQt 似乎也在迅速增长，以支持 3D 场景图，而在 wxPython 中，我可能需要使用 OpenGL，这将更加复杂。

需要 Python 3，但我认为那是罗宾·邓恩决定创建 wxPython 3 的时候，因此支持 Python 3 的工作还非常早期。基本上，wxPython 只有 Python 2.7，Qt Designer 的可用性也是一个因素。PyQt 在创建设计时有一个非常复杂的界面。

> **奥利弗·肖恩博恩：'PyQt 显然有势头。'**

PyQt 和 WPF 都支持由 XML 驱动的用户界面描述。

PyQt 显然有势头，并且支持该包的商业使用，这对那个项目来说很重要。我之前与 WPF 有过一些负面体验，与它用来将属性绑定到小部件的黑魔法作斗争。此外，有迹象表明 IronPython 不再维护。综合考虑，我们选择了 PyQt。我们没有后悔这个选择。

**德里科：**回到 Pypubsub 部分，我忘记问你了，你在运行那个开源项目时遇到了什么挑战吗？

**肖恩博恩：**嗯，那并不是一个技术挑战，但我确实从开源开发的角度有一个有趣的经验。这让我想起，你实际上并不能控制你在开源世界中可以占据的空间。

> **奥利弗·肖恩博恩：'你实际上并不能控制你在开源世界中可以占据的空间。'**

发生的事情是 Pypubsub 在 SourceForge 上，那里的名字简单地是“pubsub”，因为这就是在 wxPython 中的命名。在 PyPI 上，我把它命名为 pypubsub。几年后，我发现 SourceForge 上还有一个名为 Pypubsub 的项目，但它并没有取得进展。基本上，这是一个已经停止的项目，有时它会导致 Stack Overflow 和两个 pypubsub 论坛上的一些混淆。

这需要一些努力才能弄清楚。我不得不联系作者并解释发生了什么。最终，他同意了，我得以在 SourceForge 上拥有“pypubsub”这个名称。

同时，GitHub 已经变得非常流行。有些人把我的 Pypubsub 源代码复制到 GitHub 上，只是为了方便使用。这没什么不妥，但既然这些分支并没有添加新功能，当我决定将 Pypubsub 迁移到 GitHub 时，我不得不通知一些开发者 Pypubsub 最终可以在那里找到。我解释说，可能已经没有理由保留单独的副本了。这是开源的一个有趣方面。

**德里科：**这个项目需要多大的承诺？

**肖恩博恩：**嗯，在过去 15 年的不同时期，我进行了重大的实现更改并扩展了 API：修复错误、更新文档，并确保在 Python 的新版本发布时所有测试都能通过。找到时间做这些事情通常是一个挑战。我想，这也是在志愿者基础上工作的另一个有趣方面。

在保持向后兼容的同时演进 API，主要是罗宾，wxPython 的作者所要求的，即使 Pypubsub 在技术上与 wxPython 分开，这对我也很重要。这是一个重大的技术挑战，使得这一切成为可能。这导致了 Pubsub 支持三个 API 或消息协议的概念。

> **奥利弗·肖恩博恩：**“这是一个重大的技术挑战。”

首先，与 Pubsub 的第一个版本保持向后兼容。这就是我所说的版本 1 消息协议。然后是“现代”Pubsub，它在 API 方面有显著的改进，并且有两个 API。

其中一个被称作`arg1`，因为所有消息数据都包含在一个大块中，作为`sendMessage()`函数的一个参数传递。另一个被称作`kwargs`，因为消息数据是通过`sendMessage()`函数中的关键字参数发送的。当你独立安装 Pypubsub 时，这是默认设置。

一个标准的 wxPython 安装会安装`arg1` API，因为这与版本 1 API 几乎 100%兼容。可以在导入 Pypubsub 之前在应用程序代码中设置一个设置标志，以选择`kwargs`协议。

因此，让所有这些工作起来是一个巨大的头疼问题。我不得不稍微篡改一下导入系统，基本上是为了允许用户说：“嗯，在这个应用程序中，我想使用`arg1`协议，而在这个 wxPython 应用程序中，我想使用`kwargs`协议。”

我还添加了一些代码，帮助 wxPython 应用程序从版本 1 过渡到`arg1`，再到`kwargs`协议。这也很困难。

我真的很希望我没有做所有那些事情，但当时我觉得这是必要的恶行。除了代码复杂性之外，它使 Pypubsub 使用的导入系统相当复杂，可能会干扰冻结。

**Driscoll**：你为什么专注于使这种过渡成为可能？

**Schoenborn**：因为我必须在我自己的一个项目应用中经历那个挑战。它使用`arg1`协议并将其迁移到新的`kwargs`协议。虽然不算复杂，但这有点繁琐且容易出错。由于`kwargs` API 的优势，添加这些错误检查器并经历过渡是值得的。

我有一个概念，可以在导入 Pypubsub 时设置参数。这将配置 Pypubsub 执行一些“中间”任务，这些任务在两种消息协议之间的过渡期间很有用。这个桥梁将允许你逐步过渡到完全使用 kwargs，沿途还有一些有用的设施。

> **Oliver Schoenborn**：'代码确实比我想要的要复杂。'**

实现一个稳定的 API 花费了相当多的努力。令人沮丧的是，代码确实比我想要的要复杂，因此维护起来更困难，通过 Pypubsub 追踪调用也更困难。此外，它也给那些想要冻结其应用程序的人带来了一些挑战。

一旦我有能力，我就建议我们废弃所有那些旧的东西，因为它们只对具有旧 API 的 wxPython 应用程序有用。罗宾同意了。2016 年，我放弃了所有对版本 1 和 arg1 协议的支持，从而实现了代码库的重大清理和简化。所以现在只有一个 API。这是 Pypubsub 的 v4 版本。

**Driscoll**：那么你能告诉我你最近参与的一些其他 Python 项目吗？

**Schoenborn**：当然，有一个非常酷的闭源项目，技术上具有挑战性，GUI 非常复杂。我实际上在讨论近年来与 PyQt 合作的原因时间接提到了它。

应用程序显示一个画布，用户可以在上面放置盒子并以不同的方式将它们连接起来。与 Visio 这样的工具相比，用户可以编程这些盒子随时间变化，就像动画一样，以表示一个过程。

用户通过定义 Python 脚本来实现这一点。应用程序为每个用户脚本添加了一个实时 Python 命名空间，因此用户可以动态查询底层模型（例如，在模型中动态更改的属性上的代码补全）。

> **Oliver Schoenborn**：'该应用程序为每个用户脚本添加了一个实时 Python 命名空间，因此用户可以动态查询底层模型。'**

因此，有一个非常复杂的界面用于创建模型组件、添加它们以及将它们链接起来。还有一个非常复杂的撤销功能，涵盖了模型编辑的所有不同方面。

> **Oliver Schoenborn: '就像往常一样，有 10% 的功能占据了 90% 的开发时间。’**

我们将视图与撤销/重做功能耦合，这样用户在导航文档时总能看到将要撤销或重做的内容。这是一个有趣的挑战，就像往常一样，有 10% 的功能占据了 90% 的开发时间。

这个应用程序是一个模拟系统，所以它不仅仅是创建线条或盒子。还有界面组件来管理模拟，即随时间改变模型，恢复到初始状态，查看更改队列等。

因此，应用程序中有很多功能。但在这个方面，PyQt 与之合作得非常出色。

**Driscoll**: 你能多解释一下在这个项目中使用 Qt 吗？

**Schoenborn**: 是的，Qt 的图形视图在允许我们做的事情方面给人留下了深刻的印象。

我记得一开始，在 Qt 中做某些事情并不总是那么明显。例如，在一个基于画布的应用程序中，你可以做很多不同的事情，有一个状态机来管理在任何给定时刻可以做什么是非常有用的。没有文档解释这一点，因为这是你多年来作为有用技术学到的东西。请注意，Qt 内置了对状态机的支持，但它并不足以满足我们的需求。

状态机允许你定义只有某些动作可能发生的状态。所以在“创建线条”状态下，你唯一能做的就是取消创建、拖动鼠标或选择线条目标。这就是状态机发光的地方。没有它，你的代码最终会变成难以维护的意大利面。调试和扩展新动作要简单得多。

虽然 Qt 文档很优秀，但有些东西是在使用过程中逐渐理解的。有时你会说，“哦，我终于明白了怎么这么做。我要回过头来修改一下。”最终你得到的是一个更健壮的实现，能够真正支持下一级别的功能。

> **Oliver Schoenborn: '你最终得到的是一个更健壮的实现，能够真正支持下一级别的功能。’**

我开始熟悉 Qt 所有的小部件了。当我们升级 PyQt 时，我们发现了一个讨厌的 bug，导致整个界面在拖动部件时显示各种线条。不用说，这确实是个问题，但我们确实需要更新 PyQt 以支持其他功能。

我们将问题追溯到 C++层，并且由于一些不可思议的幸运，有一个解决方案：有一行代码我们只需要在 Python 级别上放入我们的应用程序中。我们甚至不需要更改 PyQt 源代码。只要我们有了那一行代码，那么错误就会消失。我提交了：[`bugreports.qt.io/browse/QTBUG-55918`](https://bugreports.qt.io/browse/QTBUG-55918)。

使用 Qt 的另一个非常有趣的方面是单元测试。我们需要为应用程序的 GUI 部分编写单元测试。我们使用了优秀的 pytest，有一个用于核心业务逻辑的测试套件，还有一个用于 GUI 组件的测试套件。对 GUI 进行单元测试可能真的很有挑战性：你必须编写用户操作的脚本。

幸运的是，Qt 使得这相对容易，因为你可以通过调用一个方法轻松触发任何小部件事件。但因为是基于事件的，我们需要一种方法来定义一系列用户操作及其预期结果。因此，我创建了一个库来支持这样做。不幸的是，源代码是封闭的，所以我无法分享代码，但我已经在 PyQt 论坛上提到了这个想法，有些人实现了他们自己的概念。

**Driscoll**: Python 是 AI 和机器学习热潮中被广泛使用的几种主要语言之一。你认为这背后是什么原因？

**Schoenborn**: 我认为正是 Python 的“奥林匹克”特性使其非常适合人工智能和机器学习。Python 恰好在很多必要的元素上都非常强大，而不仅仅是某一个或两个。

> **Oliver Schoenborn: 'Python 的“奥林匹克”特性使其非常适合人工智能和机器学习。”**

例如，Python 可以用于函数式、过程式或面向对象的编码，可以任意组合，代码仍然易于理解和简洁。此外，不需要编译使得算法和数据探索变得非常容易：你只需修改代码并重新运行脚本。

最后，Python 通过简单的语法提供了强大的抽象。也许我有偏见，但我觉得在这方面 Python 处于领先地位。我非常重视代码的明确性和简洁性，以及重构和测试。在这些方面都表现出色使得 Python 成为人工智能的完美语言。

**Mike Driscoll: 为了使 Python 成为更好的 AI 和机器学习语言，我们可以做些什么？**

**Schoenborn**: 在某个问题域中，当提供的抽象与问题域的抽象相匹配时，一种语言最有用。

因此，如果深度学习使用神经网络，那么拥有一个通用的神经网络概念可能非常有用。这目前由像 TensorFlow 这样的库提供。但随着机器学习算法的改进，可能会出现一个通用的神经网络抽象，它可以成为一个像列表和映射这样的基本数据结构。

此外，我认为我们需要能够询问 AI/机器学习功能，“你是如何得到这个结果的？”这是人类验证结论的方式。他们了解自己使用的逻辑，可以将其口头表达出来，其他人可以跟随，并验证其正确性。

**Driscoll**：我和很多人交谈过，甚至 PyCon 上的人，都非常强调 Python 在数据科学领域的增长。你在你所做的工作中看到这一点了吗，或者你能给我任何一方面的意见吗？

**Schoenborn**：是的，Python 在那个领域确实在增长。我认为像 Jupyter、Anaconda 和 scikit-learn 这样的工具是这一增长的主要原因。

可能还因为有了强大的计算能力，语言的运行速度不再那么重要。Python 可以用于嵌入式系统，所以原则上，基于训练的机器模型的预测分析可以在设备本身发生。

> ****Oliver Schoenborn：'有了强大的计算能力，语言的运行速度不再那么重要。'****

在 2017 年的 PyCon 大会上，有一个非常有趣的演讲。演讲者正在调查绘图库的格局。调查从 matplotlib 及其相关内容开始。然后调查转向了一些 JavaScript 库，有些情况下与 Python 库相关。这真的很吸引人，因为即使对我的客户来说，对使用 pandas、NumPy 和 matplotlib 也很有兴趣。这表明你可以添加很多不同的扩展或层。

从客户的角度来看，你希望有一定程度的可用性，而且你不希望仅限于 matplotlib，因为还有更多可用。你也知道，你不想重新发明轮子，所以你必须确保你构建的东西足够通用。如果你想进行统计分析，那么你可能想用 Jupyter 或 R 来做。你总是试图了解提供这些功能的应用程序。

你不希望强迫用户使用 matplotlib，因为它如此多样化，API 也如此先进。你无法提供一个支持 matplotlib 所能做的一切的 GUI 组件。

Python 是一种如此表达性强的语言，而且如此容易学习。我认为这就是 Python 现在在研究和应用研究中如此受欢迎的原因。它易于应用，复杂且能解决技术问题。

> ****Oliver Schoenborn：'Python 是一种如此表达性强的语言，而且如此容易学习。我认为这就是 Python 现在在研究和应用研究中如此受欢迎的原因。'****

Python 为你提供了所有工具来制作和提供既稳健又确定性的东西。我们可以衡量性能，找到瓶颈或找到内存泄漏。有很多事情真正使 Python 成为一个伟大的工具。

**Driscoll**：有没有其他特别值得记忆的 PyCon 演讲？

**Schoenborn**: 在 2017 年的 PyCon 上，还有一个关于全局解释器锁（GIL）的有趣演讲。从理论上讲，去掉 GIL 会非常好：我们可以让 Python 线程在不同的核心上运行。

> **Oliver Schoenborn: '从理论上讲，去掉 GIL 会非常好。'**

但 GIL 解决了一个非常实际的问题：同步访问 Python 数据结构。您开始分析什么是必要的，以及与成本相比的收益，从而深入了解 GIL。您会意识到 GIL 确实简化了很多事情，并且可能是 Python 做复杂事情如此容易的一个原因。

您基本上可以获取并发编程，而不需要多线程编程的所有陷阱。在大多数问题的大类中，这正是您想要的。在另一类问题中，您想要解决那些可以轻易并行化的简单问题。这基本上是将解决方案细分为任务。任务之间几乎没有耦合，您可以非常容易地完成它们。

蒙特卡洛是一个例子，因为它在模拟和业务流程中非常重要。您基本上想要多次运行大量的事情，它们之间几乎没有变化。Python 也使这一点变得容易。

对于可以轻易并行化的问题，您需要运行它们。您可以在单独的核心上运行它们，只需使用多进程模块。是的，甚至有这种能力！所以，在 Python 中，许多在原则上复杂的事情实际上很简单，这使得它非常适合数值计算任务。

> **Oliver Schoenborn: '所以，在 Python 中，许多在原则上复杂的事情实际上很简单。'**

但我认为应该有一个更简单的方法来在多个核心上运行 Python 代码，而无需使用该模块。应该有与 GIL 协同工作的语言结构。那里没有技术上的不可行性；只是需要有足够的共同努力来实现它。

**Driscoll**: 您今天对 Python 中最兴奋的是什么？

**Schoenborn**: 可选类型注解系统、异步调用和多进程模块。

**Driscoll**: 您认为哪种语言是 Python 最大的竞争对手？

**Schoenborn**: JavaScript。真是太不幸了，JavaScript 在网页方面占主导地位。有两个主要竞争者：网页上的 JavaScript 和科技计算中的 Python。如果您真的需要原始的计算速度，那么您可以做 C++。

通过编写一些 C++代码并通过 SWIG 和 SIP 将其摄入 Python，您可以在 Python 中获得重大的速度提升。还有 Cython。使用 Python 在高级抽象层次上工作非常容易，当您需要从 C++获取计算能力时。

我不知道这会走向何方。我认为在 JavaScript 方面需要发生很多事情才能使其像 Python 一样强大且易于使用，但另一方面，我看不到 Python 成为网络浏览器的支持语言，因为 JavaScript 已经太根深蒂固了。也许如果谷歌决定让 Python 代码在 Chrome 中可运行。

> **奥利弗·肖恩博恩：'要使 JavaScript 像 Python 一样强大且易于使用，需要在 JavaScript 方面发生很多事情。'**

**Driscoll**: 那么 Python 会一直存在吗？

**Schoenborn**: 我认为 Python 会一直存在。Python 是一门太好的语言，其社区已经开发出了高质量和稳固的库，以及通过 PEPs 的语言进化过程。Python 有一个非常严格的过程，并且有很多聪明的人在工作。所以它肯定会一直存在。

**Driscoll**: 你对 Python 2.7 的长期存在有何看法？人们应该迁移到最新版本吗？

**Schoenborn**: Python 2.7 的长期存在最令人烦恼！像 Ubuntu 和谷歌云平台这样的大影响力者必须开始将 Python 3.6 作为默认版本。

> **奥利弗·肖恩博恩：'Python 2.7 的长期存在最令人烦恼！'**

**Driscoll**: 你希望在未来的 Python 版本中看到哪些变化？

**Schoenborn**: 我希望看到一种可选的静态类型系统，具有类型推断（因此不需要声明类型），真正的并行性，以及可选的编译模式。

可选的静态类型、编译和类型推断的结合将允许语言在开始时保持简单，在需要时变得更加严格。

它还可以在速度和生产率上带来巨大的提升：能够指向任何对象并确切知道对其可用的操作或对其的要求（在函数签名内），这总是节省时间。现实地讲，我不知道一个冻结类型的编译模式（即使是即时编译）是否可行，但外面有一些极其聪明的人，所以我不会排除它。

关于并行性，我指的是在保持全局解释器锁（GIL）的同时，能够在多个核心上同时运行 Python 代码的能力。当然，有进程模块，但我谈论的是语言本身内置的一等构造。

**Driscoll**: 感谢，奥利弗·肖恩博恩。
