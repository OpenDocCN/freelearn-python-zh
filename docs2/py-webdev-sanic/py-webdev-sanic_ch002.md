# 1 介绍 Sanic 和异步框架

应该只有一个——最好是只有一个——明显的解决方案。

- *Tim Peters，《Python 的禅意》*

太常了，这个 Python 格言被理解为“必须只有一个方法来做某事”。任何 Python 网络开发者都可以简单地看看存在的网络框架数量，并告诉你选择并不简单。在 PyPI 上有数十个网络框架，在任何单个框架的生态系统中，你将找到更多解决单个问题的选项。在[`pypi.org`](https://pypi.org)的搜索栏中输入`authentication`。看看结果的数量，只有一个“[一个]明显的解决方案”似乎并不明显。也许这句话需要改变。或许它可以读作，“应该有一个……对你来说明显的解决方案。”为什么？因为添加我们正在讨论你的特定应用程序的上下文，使我们达到了下一个层次。

这就是 **Sanic**，这也是本书的目标。

对于构建股票组合跟踪器的人来说可能显而易见的事情，对于构建流媒体播放器的人来说可能并不明显。因此，为了弄清楚什么是最明显的解决方案，我们首先必须理解问题。而且，为了理解问题，我们必须对我们的特定用例保持高度警觉。

当试图找到一个问题的解决方案时，许多其他工具和框架会回答说：这是你应该这样做。你想从你的网络请求中读取数据？这是如何验证它的方法。你需要 **跨站请求伪造**（**CSRF**）保护？这是你需要添加的代码片段。这种方法无法让你成为一个更好的开发者，也无法为你找到最佳的使用案例解决方案。

为什么我应该以这种方式验证我的数据？为什么我需要这个代码片段来保护自己？因为有人为你做出了决定。你无法回答这些问题。你所知道的就是框架文档——或者某个互联网上的博客——告诉你这样做，所以你就这样做了。

这也是为什么 Sanic——以及本书——采取不同的方法。到本书结束时，我们希望你知道如何发现特殊的使用案例，以及如何调整工具以满足你的需求。你应该能够思考不同类型的实现，并选择对你最有意义的解决方案。这将是最明显的解决方案。

Sanic 以其无偏见而自豪。这并不是说项目的维护者没有强烈的观点。我欢迎你与我或社区中的任何人就代理转发、部署策略、身份验证方案等进行讨论。你肯定会找到充满激情的观点。通过“无偏见”，我们是指 Sanic 的工作是处理基础设施，而你只需要构建逻辑。如何处理问题的决策不是框架的领域。

你会发现，Sanic 开发者最热衷于寻找针对他们面临的特定挑战的超专注解决方案。开发者使用 Sanic 是因为它既快又简单。但，你也会发现，使用 Sanic 意味着问题的明显解决方案不是基于 Sanic，而是基于你独特的应用需求。

另一方面，有时你的用例并不需要超专注的解决方案。这也是可以的。因此，你会发现许多插件（其中许多由 Sanic 核心开发者团队活跃成员支持）或现成的解决方案。我们完全支持你采用它们及其模式。在这本书中，我们的例子将避免需要插件的实现。然而，当有包括插件在内的流行解决方案时，我们也会为你指出以供参考。

我们在这本书中的目标是学习识别你独特的应用需求，并将它们与我们可用的工具相匹配，以：（1）使我们的应用更好；（2）使我们成为更好的开发者。

在本章中，我们将通过以下主题来构建阅读这本书所需的基础理解：

+   什么是 Sanic？

+   提升水平

+   框架与服务器

+   为什么使用 Sanic – 构建快，运行快

## 技术要求

本章将包括一些基本的 Python 和终端使用。为了跟随示例，请确保你的计算机已设置 Python 3.7 或更高版本。你还需要安装 curl 或类似程序，这样我们就可以轻松地制作和检查 HTTP 请求。如果你不熟悉 curl，它是一个从终端会话执行的程序，允许你进行 HTTP 请求。它应该默认在大多数 macOS 和 Linux 安装中可用，也可以在 Windows 机器上安装。 

## 什么是 Sanic？

由于你在阅读这本书，你很可能熟悉 Python，甚至可能了解一些用于使用 Python 构建 Web 应用的流行工具。至于 Sanic，你可能听说过它，或者已经使用过它，并希望提高你的技能和对它的理解。你可能知道 Sanic 与传统工具不同。它是从头开始构建的，完全基于异步 Python 的理念。从一开始，Sanic 就旨在追求速度。这是推动其大部分发展的关键决策之一。

要真正理解 Sanic 项目，我们可能需要从历史课开始。Sanic 是第一个将异步 Python 引入 Web 框架的合法尝试。它最初是一个概念验证，作为一个爱好项目。让我们设定场景。

Sanic 最基础的构建块是来自 Python 标准库的**asyncio 模块**。Sanic 项目在模块早期发布阶段诞生，并随着模块的成熟而成熟。

Python 3.4——2014 年初发布——是将 **协程** 的概念引入标准库中新增的 **asyncio** 模块的第一步。使用标准的 Python 生成器，可以在其他事情发生时暂停函数的执行，然后可以将数据注入该函数以允许其恢复执行。如果有一个“循环”对象可以遍历需要工作的任务列表，我们就可以同时进入和退出多个函数的执行。这可以在单个线程中实现“并发”，这是 asyncio 概念的基础。

在早期，这主要是一个玩具，协程并没有得到广泛的应用。当然，有一些合法的应用需求得到了解决，但这个概念在其发展初期仍然非常初级，并未完全成熟。在接下来的几个 Python 版本中，这个概念得到了细化，最终形成了我们今天所知道的 asyncio 模块。

下面快速看一下 Python 3.4 中异步编程的样子：

```py
import asyncio
@asyncio.coroutine
def get_value():
    yield from asyncio.sleep(1)
    return 123
@asyncio.coroutine
def slow_operation():
    value = yield from get_value()
    print(">>", value)
loop = asyncio.get_event_loop()
loop.run_until_complete(slow_operation())
loop.close()
```

虽然我们不会深入探讨其工作原理，但值得一提的是，异步 Python 是建立在生成器的基础上的。其理念是生成器函数可以返回到某个“循环”以允许其进入和退出执行。

> **重要提示**
> 
> 我们将在稍后讨论如何使用替代循环（例如 trio），但本书将假设我们正在使用 asyncio。

新的 asyncio 模块的语言和语法都非常强大，但有点笨拙。生成器通常对不太熟练的 Python 开发者来说有点神秘和难以理解。`yield` `from` 究竟是什么？这些东西对许多人来说看起来很陌生；Python 需要更好的语法。

在继续之前，如果你不熟悉生成器，这里做一个简要的说明。Python 有一种特殊类型的函数，它返回一个生成器。这个生成器可以通过 *yield* 一个值来部分执行并暂停其操作，直到需要进一步处理。生成器还具有双向操作的能力，即在执行过程中可以将数据发送回它们。再次强调，这些细节超出了本书的范围，因为它们并非完全相关，但了解这一点有助于知道这就是 `yield from` 帮助我们实现的目标。利用生成器的双向功能，Python 能够构建异步协程的能力。

由于这个实现复杂，对于 Python 3.5 的初学者来说稍微有点困难，因此它包含了一个更简单、更干净的版本：

```py
async def get_value():
    await asyncio.sleep(1)
    return 123
async def slow_operation():
    value = await get_value()
    print(">>", value)
```

这种编程风格的主要好处是它减轻了由于输入和输出导致的代码阻塞。这被称为 **io-bound**。一个经典的 io-bound 应用示例是网络服务器。因此，构建一个旨在创建与网络流量交互的协议的新 asyncio 模块是顺理成章的。

然而，当时没有框架或 Web 服务器采用这种方法。Python Web 生态系统建立在与异步 Python 基本对立的前提之上。

> **重要提示**
> 
> 经典的 Python 集成应用程序与 Python Web 服务器的方式被称为 **Web 服务器网关接口**（**WSGI**）。这不在本书的范围内。虽然可以将 Sanic 强行塞入 WSGI，但通常是不受欢迎的。WSGI 的问题在于其整个前提是阻塞的。Web 服务器接收一个请求，处理它，并在单个执行中发送响应。这意味着服务器一次只能处理一个请求。使用 Sanic 与 WSGI 服务器完全破坏了高效并发处理多个请求的异步能力。

经典的 **Django** 和 **Flask** 无法采用这种模式。回顾 6 年以上，这些项目最终找到了引入 *async*/*await* 的方法。但是，这并不是这些框架的自然使用模式，并且付出了多年非凡的努力。

当 asyncio 模块发布时，缺乏能够满足这一新用例的 Web 框架。甚至后来被称为 **异步服务器网关接口**（**ASGI**）的概念也尚未存在。

> **重要提示**
> 
> ASGI 是 WSGI 的对应物，但针对异步 Python。虽然不是必需的，但可以将其用于 Sanic，我们将在 *第八章*，*运行服务器* 中进一步讨论。

在 2016 年夏季，Sanic 被构建出来以探索这个差距。想法很简单：我们能否将一个看起来简单的 Flask API 应用程序转换为 *async*/*await*？

某种程度上，这个想法起飞并获得了势头。这并不是一个最初旨在重新设计 Python 应用程序处理 Web 请求的项目。这非常典型地是一个意外曝光的案例。项目迅速爆炸并迅速创造了兴奋。很多人认为 Flask 采用这种新模式有很大的吸引力；但由于 Flask 本身无法做到这一点，许多人认为 Sanic 可以是 Flask 的异步版本。

开发者对使用最新的 Python 带来应用程序全新性能水平的新机会感到兴奋。早期的基准测试显示 Sanic 在 Flask 和 Django 之上运行得如风驰电掣。

然而，像许多项目一样，最初的热情逐渐消退。原始项目旨在回答一个问题：是否存在一个类似 Flask 的框架？答案是响亮的肯定。然而，作为一个没有打算处理所获得的级别支持和关注的单人项目，该项目开始积满灰尘。拉取请求开始堆积。问题无人回答。

在 2017 年和 2018 年间，异步 Python 的生态系统仍然非常不成熟。它缺乏值得信赖的平台，这些平台将得到支持、维护，并且适用于个人和专业的网络应用程序。此外，关于 Sanic 仍有一些身份上的疑问。有些人认为它应该是一个非常小众的软件，而另一些人则认为它可能有广泛的应用。

几个月来对项目维护者缺乏响应和挫败感的后果导致了 Sanic 任务小组的成立。这个 Sanic 社区组织的先驱是一群对找到即将失败的项目未来感兴趣的开发者松散集体。他们希望稳定 API 并回答所有悬而未决的身份问题。在 2018 年中旬的几个月里，关于如何推进项目以及如何确保项目不会再次遭受同样命运的争论一直在酝酿。 

最基本的问题之一是项目是否应该被分叉。由于 Sanic 任务小组中没有人在仓库或其他资产上拥有管理员权限——而唯一有权限的人没有响应——唯一的选择就是分叉并重新命名项目。然而，Sanic 在那时已经存在两年，在 Python 社区中作为构建异步网络应用程序的一个可行（且快速）的选项而闻名。放弃现有的项目名称将对新项目重新崛起造成巨大的打击。尽管如此，这是唯一剩下的解决方案。在将项目分叉到新的 GitHub 仓库的前夕，原始维护者提供了对仓库的访问权限，SCO 因此诞生。团队努力重组社区运作，以下是一些目标：

+   定期和可预测的发布，以及弃用；

+   对响应问题和支持的问责制和责任感；以及

+   代码审查和决策的结构。

在 2018 年 12 月，SCO 发布了 Sanic 的第一个社区版本：18.12 LTS。

在建立起新的结构之后，SCO 转向了下一个问题：Sanic 是什么？最终的决定是打破任何与 Flask 兼容的尝试。虽然可以说原始项目是一个“Flask 克隆”，但这已经不再真实。你仍然会听到它被称为“类似 Flask”，但这种比较只因为它们在表面上看起来相似。功能和行为在本质上都是不同的，相似之处到此为止。我个人尽量避开这种比较，因为它贬低了数百名贡献者为让 Sanic 独立而付出的努力和改进。

## 升级

Sanic 鼓励实验、定制，最重要的是，好奇心。

由于它假设对 Python 和 Web 开发都有一定的了解，因此可能不是 Python 初学者的最佳工具。这并不是说项目会阻止新手，或者刚开始接触 Web 开发的人。实际上，对于那些真正想了解实践的人来说，Sanic 是一个学习 Web 开发的绝佳起点。Web 开发很大程度上是学习平衡相互竞争的决策。Sanic 开发通常包括了解这些决策点。

这触及了本书的目标：回答“构建我的 Sanic 应用的最佳路径是什么？”本书旨在探讨在 Sanic 中可能使用的不同模式。虽然我们将学习与 Sanic 相关的概念，但原则可以抽象化并应用于构建任何其他框架或语言的应用程序。记住，没有“正确”或“错误”的方法是至关重要的。在线论坛充满了“正确方法”的问题，这些假设存在标准实践。这些问题的答案指向了这样的含义，即如果他们没有遵循特定的模式，那么他们的应用程序就是错误的。

例如，有人可能会问以下问题：

+   “提供国际化内容的正确方法是什么？”

+   “我应该如何部署我的 Web 应用？”

+   “处理长时间运行操作的正确方法是什么？”

这些“正确方法”的问题存在一个关键缺陷：认为只有一个“明显”的解决方案。以这种方式构建问题属于有偏见的框架领域，这些框架不教会开发者独立思考。在 Sanic 论坛上提出相同的问题，你可能会得到一个“视情况而定”的回答。有偏见的框架阻碍了创造力和设计。它们最终迫使开发者根据框架提供的限制而不是应用程序的需求来做出选择。

相反，Sanic 提供了一套工具，帮助开发者根据他们的用例定制解决方案，而不强制执行某些实践。这就是为什么 Sanic 的内置功能专注于功能性和请求/响应周期，而不是像验证、**跨源资源共享**（**CORS**）、CSRF 和数据库管理这样的实现细节。当然，所有那些“其他东西”都很重要，我们将在后面的章节中探讨它们。但本书的意图是查看问题，并看看你“可能”如何解决问题。Web 应用程序和 Web API 有不同的需求，因此作为开发者，你应该被允许做出最适合（且明显）解决问题的选择。

回顾上述问题，更好的表述方式可能是：

+   “我该如何提供国际化内容？”

+   “考虑到我的限制，哪种部署策略对我适用？”

+   “在处理长时间运行的操作时，需要考虑哪些权衡？”

到这本书的结尾，你将能够识别问题，并运用你的创造力来提出合适的解决方案。你将学习 Sanic 提供的一些强大策略。但绝不要认为任何给定的解决方案是唯一的。仅仅因为它在这里被概述，并不意味着它是正确的。或者，所使用的工具只适用于特定的情况。

正确的方法是使用 Sanic 和 Python 提供的工具来解决你的问题。如果你被要求做汤，你会发现没有唯一的方法可以做到。你可以查找一些食谱，并尝试学习一些基本模式：烧开水，加配料等。最终，要掌握做汤的艺术，你需要在你自己的厨房、设备、配料以及你要服务的人的约束条件下烹饪。这就是我想让你了解的关于 Web 开发的知识：掌握你的工具、环境和需求，为你的特定用户构建你需要的东西。

在阅读这本书的过程中，你应该既在学习也在分析模式和代码。尝试概括概念，并思考如何在未来的代码中运用类似的想法。我们鼓励你通读全书，或者根据需要跳读章节，这两种方法都是有效的。

让我们更深入地探讨国际化的问题，看看不同的问题框架如何影响我们的应用程序和知识。

+   **错误**：如何正确地提供国际化内容？

+   **正确**：我如何提供国际化内容？

第一个问题的答案可能包括一些曾经遇到过这个问题的开发者的代码片段。开发者会复制粘贴并继续前进，在这个过程中没有学到任何东西（因此将无法将知识应用于未来类似的问题）。最好的解决方案是勉强可以接受的。最坏的情况是，解决方案对应用程序的整体设计有害，而开发者甚至不知道这一点。

将问题框架为“我如何...”留出了可能有多种途径达到同一目的的想法。错误的问题风格是狭窄的，将我们的注意力引向单一的方法。好的风格则打开了探索不同解决方案的可能性，并权衡它们的优点。在提出问题后，我们现在的工作是找出可能的解决方案，确定潜在的权衡，然后得出结论。在这个过程中，我们可以借鉴我们自己的过去经验，其他开发者的例子，以及像这本书这样的资源材料。

我们可以思考以下可能的解决方案：

+   **中间件**（捕获头信息或路径，并将请求重定向到不同的处理程序）

+   **路由**（在 URL 路径中嵌入语言代码，并从路由中提取语言）

+   **函数式编程**（使用不同的函数处理程序来生成单独的响应）

+   **装饰器**（在实际处理程序运行之前或之后执行一些逻辑）。

但应该使用哪种解决方案？我们需要了解我们应用程序的具体情况。以下是一些需要记住的重要问题：

+   谁在开发它？他们的经验水平如何？团队中有多少开发者？他们将使用哪些工具？谁将维护它？

+   谁将使用这个应用程序？它将被一个前端 JS 框架消费吗？一个移动应用？第三方集成？

+   它将扩展到多大？需要传递什么样的内容？

这些问题是这本书的领域。我们打算提出问题，并确定做出特定设计模式决策的原因。当然，我们不可能详尽无遗。相反，我们希望激发你使用尽可能多的工具和创造性解决方案的旅程。

很少有项目能和关于 Django 所写的文献数量相匹配。但正是因为 Sanic 不需要特定的模式，所以不需要如此大量的文档。唯一的前提是知道 Python。成功使用 Sanic 所需的 API 特定知识的深度并不大。你知道如何实例化对象、传递值和访问属性吗？当然，你知道，这只是 Python！

两个显然有价值的 Sanic 特定资源是用户指南([`sanicframework.org`](https://sanicframework.org))和 API 文档([`sanic.readthedocs.io`](https://sanic.readthedocs.io))。在这本书中，我们将大量参考这两个资源。但是，同样重要的是任何其他你到目前为止用来学习 Python 的在线或印刷资源。

回到 Sanic 内部处理某些任务的最明显方式的问题：使用现有的资源和工具。StackOverflow 和 Sanic 社区论坛上有很多信息。Discord 服务器是一个活跃的实时讨论频道。让自己被认识，让自己的声音被听到。

不要问“正确的方式”问题。相反，问“我该如何”问题。

## 框架 v 服务器

Sanic 将自己称为既是 Web 框架又是 Web 服务器。这意味着什么？更重要的是，这为什么很重要？

在我们探索这个问题之前，我们首先必须理解这些术语的含义以及它们为什么存在。

### Web 服务器

Web 服务器是一种设计用来通过**HTTP**协议传递文档和数据的软件。它的功能是接受传入的 HTTP 请求，解码消息以理解请求试图完成什么，并返回适当的响应。Web 服务器的语言是 HTTP 协议。

我们将在稍后深入了解具体细节，但现在，我们将设置一个简单的 Sanic 服务器，从`curl`发出请求，并查看消息。

1.  创建一个名为 server.py 的文件，然后在您的终端中运行它。

    ```py
    from sanic import Sanic, text, Request
    app = Sanic(__name__)
    @app.post("/")
    async def handler(request: Request):
        message = (
            request.head + b"\n\n" + request.body
        ).decode("utf-8")
        print(message)
        return text("Done")
    app.run(port=9999, debug=True)
    ```

1.  现在，我们向我们的 API 发送一个请求：

    ```py
    $ curl localhost:9999 -d '{"foo": "bar"}'
    ```

在我们的控制台中，我们现在应该能看到 HTTP 请求消息：

```py
POST / HTTP/1.1
Host: localhost:9999
User-Agent: curl/7.76.1
Accept: */*
Content-Length: 14
Content-Type: application/x-www-form-urlencoded
{"foo": "bar"}
```

我们看到的是三个组件：

+   第一行包含 HTTP 方法、路径以及使用的 HTTP 协议

+   接下来是 HTTP 头部列表，每行一个，格式为 `key: value`

+   最后是 HTTP 主体，前面有一个空行。HTTP 响应非常相似：

    ```py
    HTTP/1.1 200 OK
    content-length: 4
    connection: keep-alive
    content-type: text/plain; charset=utf-8
    Done
    ```

现在的三个组件是：

+   第一行包含 HTTP 协议，后面是 HTTP 状态和状态描述

+   接下来是 HTTP 头部列表，每行一个，格式为 `key: value`

+   最后是 HTTP 主体（如果有的话），前面有一个空行。

虽然这是 Web 服务器的语言，但编写所有这些内容非常繁琐。因此，创建了像 Web 浏览器和 HTTP 客户端库这样的工具来为我们构建和解析这些消息。

### Web 框架

当然，我们可以用 Python 编写一个程序来接收这些原始的 HTTP 消息，解码它们，并返回适当的 HTTP 响应消息。然而，这需要大量的模板代码，难以扩展，并且容易出错。

有一些工具会为我们做这件事：Web 框架。Web 框架的工作是简化构建 HTTP 消息和处理请求的过程。许多框架更进一步，提供便利和实用工具以简化流程。

Python 生态系统中有许多 Web 框架，它们在提供这项工作方面各有不同。有些提供了大量的功能，有些提供得非常有限。有些非常严格，有些则更加开放。Sanic 尝试在功能丰富和不妨碍开发者之间找到一个平衡点。

Sanic 提供的一个特性是它既是 Web 框架又是 Web 服务器。

如果你对 PyPI 上的 Web 框架进行一次调查，你会发现大多数都需要安装一个单独的 Web 服务器。在部署 *大多数* Python 应用程序时，机器上运行的持久操作和用于开发响应处理器的工具之间存在一条明确的界限。我们不会深入探讨 WSGI，因为它不适用于 Sanic。然而，有一个重要的范式需要理解：有一个服务器调用一个输入函数，传递有关请求的信息并期望得到响应。所有介于其间的都是框架。

如果我们的焦点缩小到支持 *async*/*await* 风格协程处理器的项目，那么绝大多数都需要你运行一个 ASGI 服务器。它遵循类似的模式：一个 ASGI 准备好的服务器调用一个 ASGI 准备好的框架。这两个组件通过一个特定的协议相互操作。目前有三个流行的 ASGI 服务器：uvicorn、hypercorn 和 daphne。

正因为 Sanic 诞生在 ASGI 之前的时代，它需要自己的服务器。随着时间的推移，这已成为其最大的资产之一，也是它优于大多数其他 Python 框架的部分原因。Sanic 服务器的开发高度专注于性能和最小化请求/响应周期。然而，近年来 Sanic 也采用了 ASGI 接口，以便它可以通过 ASGI 网络服务器运行。

然而，在这本书的大部分内容中，你可以假设当我们谈论运行 Sanic 时，我们指的是使用内部网络服务器。它是生产就绪的，并且仍然是部署 Sanic 的最佳方法之一。在 *第八章*，*运行服务器* 中，我们将讨论所有潜在的选择，并帮助你提出在决定哪种解决方案对你的需求来说是*明显*的问题。

## 为什么我们使用 Sanic——构建快速，运行快速。

让我们从了解 Sanic 的目标开始：

提供一种简单的方法来快速搭建、扩展并最终扩展高性能的 HTTP 服务器。

*来源*: [`sanicframework.org/en/guide/#goal`](https://sanicframework.org/en/guide/#goal)

大多数熟悉 Sanic 项目的人都会告诉你，其定义特征是性能。虽然这当然很重要，但它只是 Sanic 项目核心哲学的一个方面。

Sanic 的口号是：“构建快速。运行快速。”这当然突出了项目的性能导向。它还表明，在 Sanic 中构建应用程序的目标是直观的。让应用程序快速运行不应该意味着学习复杂的一套 API 和几乎持续打开的文档的第二浏览器窗口。虽然其他工具大量使用“黑盒”类型的功能，如全局变量、“魔法”导入和猴子补丁，但 Sanic 通常更倾向于走向编写良好、干净且符合 Python 习惯（即 **pythonic 代码**）的方向。如果你了解 Python，你可以使用 Sanic 构建网络 API。

如果性能不是定义特征，那么是什么？Sanic 项目网站首页给出了六个原因，让我们来探索：

+   简单且轻量级

+   无偏见且灵活

+   性能卓越且可扩展

+   生产就绪

+   受数百万用户信赖

+   社区驱动

### 简单且轻量级

API 故意保持轻量级。这意味着最常见的属性和方法易于访问，你不需要花费大量时间来记忆特定的调用堆栈。在项目早期，曾有过关于添加某些功能的讨论。但通常添加功能会导致臃肿。SCO 决定，专注于提供优质的开发者体验比提供“铃铛和口哨”功能更为重要。

例如，如果我的应用程序旨在被第三方应用程序使用，那么为什么它需要 CORS？对于 Web 应用程序来说，需求差异很大，因此决定将这些功能留给插件和开发者。这导致了下一个原因。

### 无偏见且灵活

无偏见是一个巨大的优势。这意味着开发者决定他们是否需要会话或令牌认证，以及他们是否需要 ORM、原始 SQL 查询、NoSQL 数据库、组合，甚至根本不需要数据存储。这并不是说这些事情在其他框架中无法实现。但是，需要考虑某些设计决策。与其关注所有这些特性，Sanic 更愿意提供工具来实现你需要的功能，而无需更多。工具胜过特性。借用一句流行的谚语：*Sanic 不给你鱼，而是教你如何捕鱼*。

### 性能优异且可扩展

这就是 Sanic 最出名的特点。Sanic 以性能优先的开发方法，以及包括**uvloop**和**ujson**在内的工具在内的实现，往往能超越其他异步 Python 框架。我们不会在基准测试上花费太多时间，因为我倾向于认为在比较框架时它们的使用有限。对性能来说，更重要的是能够快速构建和快速扩展。Sanic 使得从单个部署运行多个服务器实例变得简单。*第八章*，*运行服务器*，将更详细地讨论扩展。同样重要的是要注意，由于 API 的故意灵活性，Sanic 非常适合构建单体应用程序、微服务以及介于两者之间的所有内容。

### 生产就绪

框架通常附带开发服务器。这些开发服务器通过包括你在工作时自动重新加载等特性，使构建过程变得更简单。然而，这些服务器往往不适合生产环境。Sanic 服务器是故意构建的，旨在成为生产系统中部署的主要策略。这导致了下一个原因。

### 受数百万信任

Sanic 已安装并支持众多大小不一的应用程序。它被用于企业构建的 Web 应用程序和个人 Web 项目中。它往往是 PyPI 上下载量最大的框架之一。在 2019 年 4 月到 2020 年 4 月之间，Django 的下载量达到了 4800 万次。在同一时期，Sanic 的下载量约为 4400 万次。这是一个具有高度可见性和广泛采用的项目，适用于各种使用场景。

### 由社区驱动

自从 2018 年从个人仓库迁移到社区组织以来，决策权已经通过社区成员所称为的“懒惰共识”共享。以下是 SCO 网站([`sanicframework.org/en/guide/project/scope.html#lazy-consensus`](https://sanicframework.org/en/guide/project/scope.html#lazy-consensus))上的说法：

通常情况下，只要没有人明确反对一个提案或补丁，它就被认为是得到了社区的认可。这被称为懒惰共识；也就是说，那些没有明确表达意见的人已经隐含地同意了提案的实施。

社区的一个重要因素是所有成员（无论是常规贡献者还是首次用户）都有能力参与到对话中，并将有价值的信息输入到对话中。尽可能多的，Sanic 试图成为“由社区，为社区”的，以确保其稳定性、功能集和未来。

强调以社区为先的组织本身是为了创造一种稳定性。项目上的所有工作都是由志愿者完成的。这是一项充满爱的工作。话虽如此，仅靠激情驱动的项目如果依赖于单一个人的肩膀，就有可能变得无人维护。这正是 Sanic 在创建 SCO 时试图避免的场景。作为一个“由社区”的项目意味着有多个愿意并且能够帮助继续前进的人。Sanic 通过一组轮换的开发者来实现这一点，并在长期稳定性和交错任期之间取得平衡。

> **更多关于 SCO**
> 
> 如果你想了解更多关于 SCO 的结构以及如何参与其中，请查看 Sanic 社区组织政策 E 手册（也称为 SCOPE）：[`sanicframework.org/en/guide/project/scope.html`](https://sanicframework.org/en/guide/project/scope.html)。

### 驱动代码决策的是什么？

虽然并没有被正式化，但 Sanic 的架构师和工程师在做出编码决策时，遵循一套潜在的原则。考虑到这个项目是由来自不同背景和经验水平的多个人共同打造的，因此了解到维护一套一致的编码实践本身就是一项挑战，也就不足为奇了。

我并不是在具体谈论诸如格式化等问题——像**black**、**isort**、**flake8**和**mypy**这样的工具已经将这些问题抽象化了。相反，代码应该是什么样子，应该如何组织，以及应该遵循哪些模式？

构建 Sanic 代码库背后的原则包括：

+   性能，

+   可用性（无偏见），以及

+   简单性

在请求/响应周期执行过程中将要运行的任何代码行都将对其性能影响进行高度审查。当面对一个将两个或更多核心原则置于对立的问题时，性能考虑几乎总是占上风。然而，有时必须使用较慢的替代方案，要么是为了：（1）不让开发者陷入尴尬的开发模式，或者（2）为开发者增加不必要的复杂性。Sanic 的“速度”不仅仅是指应用性能，还包括开发性能。

当使用 Sanic 时，我们可以确信有一支开发团队在审查每一行代码及其对性能、可用性和简洁性的影响。

让我们假设你被项目经理要求构建一个 API，他有一个明确的截止日期。为了达到这个目标，你希望尽可能快地开始运行。但是，你也不想失去对面临的问题进行迭代改进的自由，而不必担心做出糟糕的决定。本书的一个目标就是帮助你识别有用的模式，以适应并帮助你达到那里。

## 摘要

理解 Sanic 的历史和背后的决策有助于了解其功能集和实现。通常，Sanic 被视为将 *async/await* 风格编程引入 Flask 应用的尝试。虽然这可能是一个原始概念的一个公平观点，但 Sanic 已经发展出了一条非常不同的路径，其目标和影响是成为一个专为性能应用设计的强大工具。

因此，Sanic 通常被那些寻求构建一个满足其应用需求独特且*明显*的设计模式的丰富环境的开发者和团队所使用。项目的目的是去除构建网络服务器和提供创建高性能和可扩展网络应用工具的困难或繁琐部分。

现在我们已经了解了 Sanic 的背景，我们可以理解和欣赏使用 Sanic 作为网络框架的灵活性。了解 Sanic 的开发背景对我们学习如何在项目中使用它非常有帮助。下一步——从*第二章*，*组织项目*开始——是开始学习我们在开始任何新的网络开发项目时应该做出的基础决策。
