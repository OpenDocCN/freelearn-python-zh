# 1

# 引言、代码格式化和工具

在本章中，我们将探讨与清洁代码相关的第一个概念，从它是什么以及它的意义开始。本章的主要目标是理解清洁代码不仅仅是一件好事或软件项目中的奢侈品。它是一种必需品。没有高质量的代码，项目将面临因技术债务积累而失败的风险（技术债务是我们将在本章后面详细讨论的内容，所以如果你之前没有听说过这个术语，请不要担心）。

同样，但更详细地，是格式化和文档化的概念。这些也可能听起来像是多余的或任务，但再次强调，我们将发现它们在保持代码库可维护和可操作方面起着基本作用。

我们将分析采用良好的编码指南对这个项目的重要性。意识到维护与参考代码对齐是一个持续的任务，我们将看到如何从自动化工具中获得帮助，这些工具将简化我们的工作。因此，我们将讨论如何配置将在项目构建过程中自动运行的工具。

本章的目标是了解清洁代码是什么，为什么它很重要，为什么格式化和文档化代码是关键任务，以及如何自动化这个过程。从这一点出发，你应该获得一种快速组织新项目结构的心态，目标是良好的代码质量。

在阅读本章之后，你将学习以下内容：

+   清洁代码真正意味着比格式化更重要的东西

+   拥有标准格式是软件项目维护性的关键组成部分

+   如何通过使用 Python 提供的功能使代码自我文档化

+   如何配置工具来自动化代码的静态验证

# 引言

我们首先将理解什么是清洁代码，以及为什么这对于软件工程项目的成功至关重要。在前两节中，我们将学习保持良好的代码质量对于高效工作的重要性。

然后我们将讨论这些规则的例外情况：即在某些情况下，甚至可能是有成本效益的，不重构我们的代码以偿还所有技术债务。毕竟，我们不能简单地期望一般规则适用于所有地方，因为我们知道总有例外。这里的关键是要正确理解我们为什么愿意做出例外，并正确识别这些情况。我们不想误导自己认为某些东西不应该改进，而实际上它应该改进。

## 清洁代码的意义

清洁代码并没有一个唯一或严格的定义。此外，可能没有一种正式的方法来衡量清洁代码，因此你无法在存储库上运行一个工具来告诉你代码是好是坏，或者是否易于维护。当然，你可以运行像`checkers`、`linters`、`static analyzers`等工具，这些工具非常有帮助。它们是必要的，但并不充分。清洁代码不是机器或脚本可以识别的（到目前为止）的东西，而是一种我们作为专业人士可以决定的东西。

几十年来，我们使用编程语言这个术语，认为它们是用来将我们的想法传达给机器，以便它们可以运行我们的程序的。我们错了。这不是真相，但这是真相的一部分。编程语言中“语言”部分的真正含义是将我们的想法传达给其他开发者。

正是这里揭示了清洁代码的真正本质。它取决于其他工程师能否阅读和维护代码。因此，我们作为专业人士，是唯一能够判断这一点的人。想想看；作为开发者，我们花在阅读代码上的时间比实际编写代码的时间要多得多。每次我们想要进行更改或添加新功能时，我们首先必须阅读我们必须修改或扩展的代码的所有周围环境。语言（Python）是我们用来相互沟通的工具。

因此，而不是给你一个清洁代码的定义（或我的定义），我邀请你阅读这本书，了解所有关于惯用 Python 的知识，看到好代码和坏代码之间的区别，识别好代码和好架构的特征，然后提出你自己的定义。阅读这本书后，你将能够自己判断和分析代码，并且对清洁代码将有更清晰的理解。你将知道它是什么，它意味着什么，无论别人给你什么样的定义。

## 清洁代码的重要性

清洁代码之所以重要，有很多原因。其中大多数都与可维护性、减少技术债务、有效地与敏捷开发合作以及管理成功项目有关。

我想要探讨的第一个想法是关于敏捷开发和持续交付。如果我们希望我们的项目能够以稳定和可预测的速度持续不断地交付功能，那么拥有一个良好且易于维护的代码库是必不可少的。

想象一下，你正在驾驶一辆汽车，沿着一条通往你希望在某个时间点到达的目的地的道路行驶。你必须估算你的到达时间，以便你可以告诉等待你的人。如果汽车运行良好，道路平坦完美，那么我看不到你为什么会大大超出你的估计。然而，如果道路状况糟糕，你必须下车移走石头，或者避开裂缝，每隔几公里就停下来检查引擎，那么你很可能无法确切知道你何时会到达（或者你是否能到达）。我认为这个类比很清楚；道路就是代码。如果你想以稳定、恒定和可预测的速度前进，代码就需要是可维护和可读的。如果不是这样，每当产品管理要求添加新功能时，你将不得不停下来重构和修复技术债务。

技术债务指的是软件中由于妥协或不良决策而产生的问题的概念。我们可以从现在到过去和从现在到未来两种方式来思考技术债务。从现在到过去：如果我们目前面临的问题是由于之前编写的糟糕代码造成的呢？从现在到未来：如果我们现在决定走捷径，而不是投入时间在合适的解决方案上，我们将会为自己在未来的某个时刻创造什么问题？

“债务”这个词是一个很好的选择。它之所以被称为债务，是因为代码在未来将比现在更难更改。这种产生的成本就是债务的利息。积累技术债务意味着，明天，代码将比今天更难更改，而且成本更高（甚至可以测量这一点），后天成本更高，以此类推。

每当团队无法按时交付某个项目，不得不停下来修复和重构代码时，它就是在支付技术债务的代价。

甚至可以争论说，拥有带有技术债务的代码库的团队并没有在进行敏捷软件开发。因为，敏捷的对立面是什么？僵化。如果代码充满了代码异味，那么它就不容易更改，因此团队无法快速响应需求的变化并持续交付。

技术债务最糟糕的地方在于，它代表了一个长期和根本的问题。它不是那种会拉响警报的问题。相反，它是一个静默的问题，散布在项目的各个部分，有一天，在某个特定的时间点，会突然爆发，成为拦路虎。

在一些更令人担忧的情况下，“技术债务”甚至是一种轻描淡写，因为问题实际上要严重得多。在前面的段落中，我提到了一些场景，在这些场景中，技术债务使得团队在未来面临的问题更加困难，但现实情况是否更加危险呢？想象一下采取捷径，使得代码处于脆弱状态（一个简单的例子可能是在函数中有一个可变的默认参数，这会导致内存泄漏，我们将在后面的章节中看到）。你可以部署你的代码，并且它会在相当长的一段时间内运行良好（只要那个缺陷没有显现出来）。但实际上，这是一个等待发生的崩溃：有一天，在人们最不期待的时候，代码中某个条件将会满足，这将导致应用程序在运行时出现问题，就像代码中的一个定时炸弹，在随机的时间爆炸。

我们显然希望避免上述情况。并非所有问题都能被自动化工具捕获，但只要可能，这都是一项良好的投资。其余的则依赖于良好的、彻底的代码审查和良好的自动化测试。

软件只有在能够轻松更改的程度上是有效的。想想看。我们创建软件是为了满足某些需求（无论是购买机票、在线购物还是听音乐，仅举几个例子）。这些需求很少冻结，这意味着软件将不得不在导致该软件最初被编写的环境中的任何变化发生时立即更新。如果代码不能更改（我们知道现实是会变化的），那么它就是无用的。拥有一个干净的代码库是修改它的绝对要求，因此干净代码的重要性。

## 一些例外情况

在前面的章节中，我们探讨了干净的代码库在软件项目成功中的关键作用。话虽如此，请记住，这是一本面向实践者的书，因此一个务实的读者可能会合理地指出，这提出了一个问题：“是否存在合法的例外情况？”

当然，如果这本书不允许读者对其假设提出挑战，那么它就不是一个真正实用的书籍。

事实上，有些情况下，你可能想要考虑放宽一些保持代码库纯净的约束。以下是一个列表（绝非详尽无遗），列出了可能证明跳过一些质量检查的情况：

+   黑客马拉松

+   如果你正在编写一个用于一次性任务的简单脚本

+   编程竞赛

+   在开发概念验证时

+   在开发原型时（只要确保它确实是一个将被丢弃的原型）

+   当你与一个将被弃用且仅处于固定、短暂维护模式的遗留项目一起工作时（再次强调，只要这是确定的）

在这些情况下，常识适用。例如，如果你刚刚加入一个项目，该项目将在未来几个月内上线，然后被退役，那么修复其继承的技术债务并等待其存档可能不是值得所有麻烦的选择。

注意这些例子都有一个共同点，即它们都假设代码可以不按照良好的质量标准编写，而且我们永远不会再次查看这些代码。这与之前所讨论的内容是一致的，可以被视为我们原始前提的逆命题：我们编写干净的代码是因为我们想要实现高可维护性。如果不需要维护那段代码，那么我们可以跳过在它上面保持高质量标准的努力。

记住，我们编写干净的代码是为了能够维护项目。这意味着能够将来自己修改代码，或者，如果我们正在将代码的所有权转移到公司中的另一个团队，这将使这种过渡（以及未来维护者的生活）变得更加容易。这意味着，如果一个项目只处于维护模式，但不会过时，那么支付其技术债务可能仍然是一个好的投资。这是因为某个时候（通常是在最意想不到的时候），将会有一个需要修复的错误，并且使代码尽可能易于阅读将是有益的。

# 代码格式化

干净的代码仅仅是关于格式化和结构化代码吗？简短的回答是否定的。

有些编码标准，如 PEP-8([`www.python.org/dev/peps/pep-0008/`](https://www.python.org/dev/peps/pep-0008/))，规定了代码应该如何编写和格式化。在 Python 中，PEP-8 是最为人所知的标准，该文档提供了关于我们应该如何编写程序的指导，包括间距、命名约定、行长度等方面。

然而，干净的代码是另外一回事，它远远超出了编码标准、格式化、linting 工具和其他关于代码布局的检查。干净的代码是关于实现高质量的软件和构建一个既健壮又易于维护的系统。一段代码或整个软件组件可以 100%符合 PEP-8（或任何其他指南），但仍不满足这些要求。

尽管格式化不是我们的主要目标，但忽视代码结构有一些风险。因此，我们将首先分析糟糕的代码结构的问题以及如何解决这些问题。之后，我们将看到如何配置和使用工具来自动检查 Python 项目的最常见问题。

总结来说，我们可以这样说，干净的代码与 PEP-8 或编码风格等事物无关。它远远超出了这些，对代码的可维护性和软件的质量有更深远的意义。然而，正如我们将看到的，正确格式化代码对于高效工作是非常重要的。

## 在你的项目中遵循编码风格指南

编码规范是一个项目在被视为符合质量标准开发时应该拥有的最低要求。在本节中，我们将探讨其背后的原因。在接下来的章节中，我们可以开始探讨如何通过使用工具自动执行这些规范。

当我试图在代码布局中寻找好的特质时，首先想到的是一致性。我期望代码的结构是一致的，这样便于阅读和跟踪。如果代码既不正确也不结构一致，而且团队中的每个人都以自己的方式做事，那么我们最终会得到需要额外努力和集中精力才能理解的代码。这将导致错误，误导，并且错误或细微之处可能会轻易地被忽略。

我们希望避免这种情况。我们想要的正好相反——代码能够让我们一眼就能快速阅读和理解。

如果开发团队的所有成员都同意一种标准化的代码结构方式，那么生成的代码看起来会更为熟悉。因此，你将很快识别出模式（关于这一点将在下一节中详细介绍），并且有了这些模式在心中，理解事物和检测错误将会容易得多。例如，当某处出现问题时，你会注意到，某种方式下，你习惯看到的模式中有些奇怪，这会吸引你的注意。你会仔细查看，并且很可能发现错误！

正如经典书籍《代码大全》中所述，在 1973 年发表的论文《棋局感知》中，对这一点进行了有趣的分析。该实验旨在确定不同的人如何理解或记忆不同的棋局位置。实验针对所有级别的玩家（新手、中级和棋艺大师）以及棋盘上的不同棋局位置进行。他们发现，当位置是随机的，新手的表现和棋艺大师一样好；这仅仅是一个任何人都能在相当相同的水平上完成的记忆练习。当位置遵循可能在真实游戏中出现的逻辑顺序（再次强调，一致性，遵循模式）时，棋艺大师的表现远远优于其他人。

现在想象一下，将同样的情况应用到软件上。我们作为 Python 软件工程师专家，就像之前例子中的棋艺大师。当代码结构随机，没有遵循任何逻辑，或者不遵循任何标准时，对于我们来说，找出错误就像新手开发者一样困难。另一方面，如果我们习惯于以结构化的方式阅读代码，并且我们已经学会了通过遵循模式快速从代码中获取想法，那么我们就处于相当的优势地位。

尤其是对于 Python，你应该遵循的编码风格是 PEP-8。你可以根据你正在工作的项目的特定需求扩展它或采用其部分内容（例如，行的长度，关于字符串的注释等）。

如果你意识到你正在工作的项目没有遵循任何编码标准，那么推动在该代码库中采用 PEP-8。理想情况下，你应该有一个书面文件，解释你所在的公司或团队期望遵循的编码标准。这些编码规范可以是 PEP-8 的改编。

如果你注意到你的团队在代码风格上没有一致性，并且在代码审查期间对此进行了多次讨论，那么重新审视编码规范并投资于自动验证工具可能是个不错的想法。

尤其是 PEP-8 涉及了一些对于项目质量特性非常重要的要点，你不想在你的项目中错过；其中一些包括：

+   **可搜索性**：这指的是一眼就能识别代码中标记的能力；也就是说，在特定的文件（以及这些文件的哪个部分）中搜索我们正在寻找的特定字符串。PEP-8 的一个关键点是它区分了变量赋值和传递给函数的关键字参数的写法。为了更好地说明这一点，让我们用一个例子来说明。假设我们正在调试，需要找到名为`location`的参数值被传递的地方。我们可以运行以下`grep`命令，结果会告诉我们我们正在寻找的文件和行：

    ```py
    $ grep -nr "location=" . 
    ./core.py:13: location=current_location, 
    ```

    现在，我们想知道这个变量在哪里被赋予这个值，以下命令也会给我们提供我们想要的信息：

    ```py
    $ grep -nr "location =" .
    ./core.py:10: current_location = get_location() 
    ```

    PEP-8 确立了这样的惯例，即在向函数传递关键字参数时，我们不使用空格，但在给变量赋值时使用空格。因此，我们可以调整我们的搜索标准（第一个例子中`=`周围没有空格，第二个例子中有一个空格），并在搜索中更加高效。这是遵循惯例的一个优点。

+   **一致性**：如果代码格式统一，阅读起来会容易得多。这对于入职尤其重要，如果你希望欢迎新开发者加入你的项目，或者甚至雇佣新的（可能经验较少的）程序员到你的团队，并且他们需要熟悉代码（可能包括多个仓库）。如果所有文件中的代码布局、文档、命名约定等都是相同的，这将使他们的生活变得更加容易。

+   **更好的错误处理**：PEP-8 中提出的建议之一是限制`try/except`块内的代码量到尽可能少。这减少了错误面，从某种意义上说，它减少了意外吞下异常并掩盖错误的可能性。这可能是难以通过自动检查执行的，但无论如何，在代码审查时值得注意。

+   **代码质量**：通过以结构化的方式查看代码，你将更擅长一眼看懂它（再次，就像在《棋艺感知》中一样），并且更容易发现错误和错误。此外，检查代码质量的工具也会提示潜在的错误。代码的静态分析可能有助于降低每行代码的错误率。

如我在引言中提到的，格式化是干净代码的一个必要部分，但这并不结束。还有更多需要考虑的因素，例如在代码中记录设计决策，并尽可能使用工具来利用自动质量检查。在下一节中，我们将从第一个因素开始。

# 文档

本节是关于在 Python 代码内部记录代码。好的代码是自我解释的，但也是良好记录的。解释它应该做什么（而不是如何做）是一个好主意。

一个重要的区别：记录代码与向其添加注释不同。本节旨在探讨 docstrings 和注释，因为它们是 Python 中用于记录代码的工具。顺便说一句，我将简要地触及代码注释的主题，只是为了确立一些将使区分更清晰的要点。

在 Python 中，代码文档化很重要，因为它是动态类型的，可能会在函数和方法之间的变量或对象值中迷失方向。因此，声明这些信息将使未来的代码读者更容易理解。

另一个与注释特别相关的理由是，它们还可以通过像`mypy`([`mypy-lang.org/`](http://mypy-lang.org/))或`pytype`([`google.github.io/pytype/`](https://google.github.io/pytype/))这样的工具运行一些自动检查，例如类型提示。我们会发现，最终，添加注释是值得的。

## 代码注释

作为一条一般规则，我们应该**尽量减少代码注释的数量**。这是因为我们的代码应该是自我文档化的。这意味着如果我们努力使用正确的抽象（比如通过有意义的函数或对象来划分代码中的责任），并且清晰地命名事物，那么注释就不需要了。

在写注释之前，试着看看你是否可以用只有代码（即添加一个新函数或使用更好的变量名）来表达相同的意思。

这本书中关于注释的观点与软件工程文献中的其他观点基本一致：代码中的注释是我们无法正确表达代码的迹象。

然而，在某些情况下，避免在代码中添加注释是不可能的，而且不这样做是危险的。这种情况通常发生在代码中必须完成某些特定技术细节，而这些细节乍一看并不简单（例如，如果底层外部函数中有一个错误，我们需要传递一个特殊参数来规避问题）。在这种情况下，我们的任务是尽可能简洁，以最佳方式解释问题是什么，以及为什么我们要采取这种特定的代码路径，以便读者能够理解情况。

最后，代码中还有一种评论是绝对不好的，而且根本无法为其辩护：被注释掉的代码。这种代码必须无情地删除。记住，代码是开发者之间的交流语言，是设计的最终表达。代码是知识。被注释掉的代码会带来混乱（以及很可能是矛盾），这将污染这种知识。

现在根本没有任何合理的理由，尤其是在现代版本控制系统的背景下，留下可以简单地删除（或存放在其他地方的）被注释掉的代码。

总结一下：代码注释是邪恶的。有时是必要的邪恶，但无论如何，我们都应该尽可能地避免。另一方面，代码的文档是另一回事。这指的是在代码本身中记录设计或架构，使其清晰，这是一种积极的动力（也是下一节的主题，我们将讨论文档字符串）。

## 文档字符串

简而言之，我们可以这样说，文档字符串是嵌入在源代码中的**文档**。**文档字符串**基本上是一个字面字符串，放置在代码的某个位置，以记录该部分逻辑。

注意到对单词**文档**的强调。这很重要，因为它旨在代表解释，而不是辩解。文档字符串不是注释；它们是文档。

文档字符串旨在为代码中的特定组件（一个`模块`、`类`、`方法`或`函数`）提供文档，这对其他开发者将是有用的。想法是，当其他工程师想要使用你正在编写的组件时，他们很可能会查看文档字符串，以了解它应该如何工作，预期的输入和输出是什么，等等。因此，在可能的情况下添加文档字符串是一个好习惯。

文档字符串也有助于记录设计和架构决策。给最重要的 Python 模块、函数和类添加文档字符串可能是个好主意，以便向读者暗示该组件如何在整体架构中发挥作用。

它们在代码中（或者甚至可能根据你项目的标准是必需的）是一个好东西，是因为 Python 是动态类型的。这意味着，例如，一个函数可以接受任何值作为其任何参数的值。Python 不会强制执行，也不会检查这类事情。所以，想象一下，你发现了一个你将不得不修改的函数。你甚至很幸运，这个函数有一个描述性的名称，它的参数也是如此。但它仍然可能不太清楚你应该传递什么类型给它。即使在这种情况下，它们应该如何使用？

这里就是一个好的文档字符串可能有所帮助的地方。记录一个函数的预期输入和输出是一个良好的实践，这将帮助阅读该函数的人理解它应该如何工作。

要运行以下代码，你需要一个`IPython`([`ipython.org/`](https://ipython.org/))交互式外壳，其 Python 版本应满足本书的要求。如果你没有`IPython`外壳，你仍然可以在正常的`Python`外壳中运行相同的命令，只需将`<function>??`替换为`help(<function>)`。

考虑这个来自标准库的好例子：

```py
Type: method_descriptor 
```

在这里，字典上的`update`方法的文档字符串为我们提供了有用的信息，并且它告诉我们我们可以以不同的方式使用它：

1.  我们可以传递一个具有`.keys()`方法的对象（例如，另一个字典），并且它将使用通过参数传递的对象的键来更新原始字典：

    ```py
    >>> d = {}
    >>> d.update({1: "one", 2: "two"})
    >>> d
    {1: "one", 2: 'two'} 
    ```

1.  我们可以传递一个键值对的序列，并将它们解包以更新：

    ```py
    >>> d.update([(3, "three"), (4, "four")])
    >>> d
    {1: 'one', 2: 'two', 3: 'three', 4: 'four'} 
    ```

1.  它还告诉我们我们可以使用关键字参数从字典中更新值：

    ```py
    >>> d.update(five=5)
    >>> d
    {1: 'one', 2: 'two', 3: 'three', 4: 'four', 'five': 5} 
    ```

（注意，在这种情况下，关键字参数是字符串，所以我们不能设置形如`5="five"`的东西，因为这将是错误的。）

对于想要学习和理解新函数的工作方式以及如何利用它的人来说，这些信息至关重要。

注意，在第一个例子中，我们通过在函数上使用双问号(`dict.update??`)来获取函数的文档字符串。这是`IPython`交互式解释器的一个特性。当调用它时，它将打印出你期望的对象的文档字符串。现在，想象一下，以同样的方式，我们从标准库的这个函数中获取帮助；如果你在你的函数上放置文档字符串，以便其他人可以以相同的方式理解它们的工作方式，你将使你的读者（你的代码的用户）的生活变得多么容易？

文档字符串不是与代码分离或孤立的东西。它成为代码的一部分，你可以访问它。当一个对象定义了文档字符串时，它通过其`__doc__`属性成为它的一部分：

```py
>>> def my_function():
        """Run some computation"""
        return None
     ...
>>> my_function.__doc__  # or help(my_function)
 'Run some computation' 
```

这意味着甚至可以在运行时访问它，甚至可以从源代码生成或编译文档。实际上，有专门的工具来做这件事。如果你运行`Sphinx`，它将为你的项目文档创建基本框架。特别是使用`autodoc`扩展（`sphinx.ext.autodoc`），该工具将从代码中提取文档字符串并将它们放置在记录函数的页面上。

一旦你有了构建文档的工具，就让它公开，这样它就成为项目本身的一部分。对于开源项目，你可以使用`read the docs` ([`readthedocs.org/`](https://readthedocs.org/))，它将根据分支或版本（可配置）自动生成文档。对于公司或项目，你可以使用相同的工具或在本地配置这些服务，但无论这个决定如何，重要的是文档应该准备好并可供团队所有成员使用。

很不幸，文档字符串有一个缺点，那就是和所有文档一样，它需要手动和持续的维护。随着代码的变化，它将不得不进行更新。另一个问题是，为了使文档字符串真正有用，它们必须详细，这通常需要多行。考虑到这两个因素，如果你正在编写的函数非常简单，并且是自我解释的，那么最好避免添加冗余的文档字符串，因为这将需要在以后进行维护。

维护适当的文档是软件工程的一个挑战，我们无法逃避。这也很有道理。如果你这么想，文档需要手动编写的原因是因为它是为了被其他人类阅读。如果它是自动化的，可能就不会有多大用处。为了使文档具有任何价值，团队中的每个人都必须同意这是一项需要手动干预的工作，因此需要付出努力。关键是理解软件不仅仅是代码。与之相关的文档也是交付成果的一部分。因此，当有人对函数进行更改时，同样重要的是也要更新与刚刚更改的代码相对应的文档部分，无论它是维基、用户手册、`README`文件还是几个文档字符串。

## 注释

PEP-3107 引入了注释的概念。它们的基本思想是向代码的读者暗示函数中参数的预期值。使用“暗示”这个词并非偶然；注释使类型提示成为可能，我们将在本章稍后讨论这一点，在介绍注释之后。

注释允许你指定已定义的一些变量的预期类型。实际上，它不仅关于类型，还包括任何可以帮助你更好地理解该变量实际代表的元数据。

考虑以下示例：

```py
@dataclass
class Point
    lat: float
    long: float

def locate(latitude: float, longitude: float) -> Point:
    """Find an object in the map by its coordinates""" 
```

在这里，我们使用`float`来表示`latitude`和`longitude`的预期类型。这仅仅是对函数读者的信息，使他们能够了解这些预期类型。Python 不会检查这些类型也不会强制执行它们。

我们还可以指定函数返回值的预期类型。在这种情况下，`Point`是一个用户定义的类，这意味着返回的任何内容都将是一个`Point`的实例。

然而，类型或内置类型并不是我们可以用作注释的唯一类型。基本上，在当前 Python 解释器的范围内有效的一切都可以放在那里。例如，一个解释变量意图的字符串，一个用作回调或验证函数的可调用对象，等等。

我们可以利用注释使我们的代码更具表达性。考虑以下示例，这是一个应该启动任务但同时也接受一个参数以延迟执行的函数：

```py
def launch_task(delay_in_seconds):
    ... 
```

在这里，参数`delay_in_seconds`的名称似乎相当冗长，但尽管如此，它仍然没有提供太多信息。对于秒来说，哪些值是可接受的优良值？它是否考虑了分数？

我们是否应该在代码中回答这些问题？

```py
Seconds = float
def launch_task(delay: Seconds):
    ... 
```

现在代码自己说话了。此外，我们可以争论，随着`Seconds`注释的引入，我们已经在如何解释代码中的时间方面创建了一个小的抽象，我们可以在代码库的更多部分重用这个抽象。如果我们后来决定改变秒的底层抽象（比如说，从现在开始，只允许整数），我们可以在一个地方进行这个更改。

随着注释的引入，还包含了一个新的特殊属性，即`__annotations__`。这将使我们能够访问一个字典，该字典将注释的名称（作为字典中的键）映射到它们对应的值，即我们为它们定义的值。在我们的例子中，它看起来如下所示：

```py
>>> locate.__annotations__
{'latitude': <class 'float'>, 'longitude': <class 'float'>, 'return': <class 'Point'>} 
```

如果我们认为有必要，我们可以使用这个来生成文档、运行验证或在我们的代码中执行检查。

说到通过注释检查代码，这就是 PEP-484 发挥作用的时候。这个 PEP 指定了类型提示的基础；通过注释检查我们函数类型的思想。再次明确一下，并引用 PEP-484 本身：

> “Python 将保持动态类型语言，作者们没有意愿将类型提示强制为必须的，即使是按照惯例。”

类型提示的想法是拥有额外的工具（独立于解释器）来检查代码中类型的正确使用，并在检测到任何不兼容性时向用户提示。有一些有用的工具会在数据类型及其在我们代码中的使用方面进行检查，以找到潜在的问题。例如，`mypy`和`pytype`等工具在*工具部分*中有更详细的解释，我们将讨论如何使用和配置项目中的工具。现在，你可以将其视为一种检查代码中使用的类型语义的 linter。因此，在项目中配置`mypy`或`pytype`并将其用于与静态分析工具相同的级别是一个好主意。

然而，类型提示不仅仅是一个检查我们代码中类型的工具。从我们之前的例子中继续，我们可以为我们的代码中的类型创建有意义的名称和抽象。考虑以下一个处理客户列表的函数的例子。在其最简单的形式中，它可以使用一个通用的列表进行注解：

```py
def process_clients(clients: list):
    ... 
```

如果我们知道在我们的当前数据建模中，客户被表示为整数和文本的元组，我们可以添加更多细节：

```py
def process_clients(clients: list[tuple[int, str]]):
    ... 
```

但这仍然没有给我们提供足够的信息，所以最好明确地给这个别名起一个名字，这样我们就不必推断这个类型意味着什么：

```py
from typing import Tuple
Client = Tuple[int, str]
def process_clients(clients: list[Client]):
    ... 
```

在这种情况下，含义更清晰，并且它支持数据类型的演变。也许元组是适合正确表示客户的最低数据结构，但后来我们可能希望将其更改为另一个对象或创建一个特定的类。在这种情况下，注释将保持正确，所有其他类型验证也将保持正确。

这背后的基本思想是，现在语义扩展到更有意义的概念，这使得我们（人类）更容易理解代码的含义，或者在一个特定点期望什么。

注释还带来了一些额外的优势。随着 PEP-526 和 PEP-557 的引入，有一种方便的方式来紧凑地编写类并定义小的容器对象。想法就是只在一个类中声明属性，并使用注释来设置它们的类型，借助`@dataclass`装饰器，它们将被处理为实例属性，而无需在`__init__`方法中显式声明并设置它们的值：

```py
from dataclasses import dataclass
@dataclass
class Point:
    lat: float
    long: float 
```

```py
>>> Point.__annotations__
{'lat': <class 'float'>, 'long': <class 'float'>}
>>> Point(1, 2)
Point(lat=1, long=2) 
```

在本书的后面部分，我们将探讨注释的其他重要用途，这些用途更多地与代码的设计相关。当我们探讨面向对象设计的良好实践时，我们可能希望使用诸如依赖注入等概念，其中我们设计代码以依赖于声明契约的接口。而声明代码依赖于特定接口的最好方法可能是使用注释。更具体地说，有一些工具专门使用 Python 注释来自动提供对依赖注入的支持。

在设计模式中，我们通常还希望将代码的某些部分与特定的实现解耦，并依赖于抽象接口或契约，以使我们的代码更加灵活和可扩展。此外，设计模式通常通过创建所需的适当抽象来解决这些问题（这通常意味着有新的类来封装部分逻辑）。在这两种情况下，注解我们的代码将提供额外的帮助。

## 注解是否取代了文档字符串？

这是一个合理的问题，因为在 Python 的早期版本中，在引入注解之前，记录函数或属性的参数类型的方式是在它们上面放置文档字符串。甚至还有一些关于如何结构化文档字符串的约定，以包括函数的基本信息，包括类型、每个参数的含义、返回值以及函数可能引发的异常。

大部分内容已经通过注解以更紧凑的方式得到了解决，所以有人可能会想知道是否真的有必要同时拥有文档字符串。答案是肯定的，这是因为它们是互补的。

的确，文档字符串中先前包含的部分信息现在可以移动到注解中（因为我们不再需要在文档字符串中指示参数的类型，因为我们可以使用注解）。但这应该为更好的文档字符串留下更多空间。特别是，对于动态和嵌套数据类型，提供预期数据的示例总是一个好主意，这样我们可以更好地了解我们正在处理的内容。

考虑以下示例。假设我们有一个期望接收字典以验证某些数据的函数：

```py
def data_from_response(response: dict) -> dict:
    if response["status"] != 200:
        raise ValueError
    return {"data": response["payload"]} 
```

在这里，我们可以看到一个接收字典并返回另一个字典的函数。如果键`"status"`下的值不是预期的值，则可能引发异常。然而，我们对此了解不多。例如，一个正确的`response`对象实例看起来是什么样子？`result`对象实例会是什么样子？为了回答这两个问题，记录预期通过参数传递并由该函数返回的数据的示例将是一个好主意。

让我们看看是否可以通过文档字符串更好地解释这一点：

```py
def data_from_response(response: dict) -> dict:
    """If the response is OK, return its payload.

    - response: A dict like::

    {
        "status": 200, # <int>
        "timestamp": "....", # ISO format string of the current
        date time
        "payload": { ... } # dict with the returned data
    }

    - Returns a dictionary like::

    {"data": { .. } }

    - Raises:
    - ValueError if the HTTP status is != 200
    """
    if response["status"] != 200:
        raise ValueError
    return {"data": response["payload"]} 
```

现在，我们对这个函数预期接收和返回的内容有了更好的了解。文档不仅有助于理解和获取正在传递的内容的概要，而且也是单元测试的有价值来源。我们可以从这样的数据中推导出输入，并知道在测试中应该使用正确的和错误的值。实际上，测试也充当了我们代码的可操作文档，但这将在本书的后面部分进行更详细的解释。

优点在于，现在我们知道了键的可能值以及它们的类型，并且我们对数据的外观有了更具体的解释。缺点是，正如我们之前提到的，它需要占用很多行，并且需要详细且冗长才能有效。

# 工具

在本节中，我们将探讨如何配置一些基本工具，并自动对代码进行检查，目标是利用部分重复的验证检查。

这是一个重要的观点：记住，代码是为了我们，即人类，去理解的，所以只有我们才能判断什么是好代码或坏代码。我们应该在代码审查上投入时间，思考什么是好代码，以及它的可读性和可理解性如何。当查看同事编写的代码时，你应该提出如下问题：

+   这段代码是否容易让其他程序员理解并遵循？

+   它是否使用问题域的术语？

+   新加入团队的人能否理解它，并有效地与之合作？

正如我们之前看到的，代码格式、一致的布局和适当的缩进是必要的，但不足以在代码库中拥有这些特性。此外，这些是我们作为有高度质量意识的工程师会认为理所当然的事情，因此我们会远远超出其布局的基本概念来阅读和编写代码。因此，我们不愿意浪费时间审查这类项目，我们可以通过查看代码中的实际模式来更有效地投入时间，以理解其真正的含义并提供有价值的成果。

所有这些检查都应该自动化。它们应该是测试或清单的一部分，反过来，这也应该是持续集成构建的一部分。如果这些检查未通过，则构建失败。这是确保代码结构始终连续的唯一方法。它还作为团队参考的客观参数。而不是让一些工程师或团队领导在代码审查中总是指出关于 PEP-8 的相同评论，构建将自动失败，使其变得客观。

本节中介绍的工具将给你一个关于可以对代码自动执行检查的想法。这些工具应该强制执行某些标准。通常，它们是可配置的，并且每个仓库都有自己的配置是完全可以接受的。

使用工具的想法是有一个可重复和自动运行某些检查的方式。这意味着每个工程师都应该能够在他们的本地开发环境中运行这些工具，并得到与团队其他成员相同的结果。此外，这些工具应该作为**持续集成**（**CI**）构建的一部分进行配置。

## 检查类型一致性

类型一致性是我们希望自动检查的主要事项之一。Python 是动态类型的，但我们仍然可以添加类型注解来向读者（和工具）暗示代码不同部分期望的内容。尽管注解是可选的，如我们所见，添加注解是一个好主意，这不仅因为它使代码更易读，而且因为我们可以使用注解和一些工具自动检查一些常见的错误，这些错误很可能是 bug。

自从 Python 引入类型提示以来，已经开发了众多用于检查类型一致性的工具。在本节中，我们将探讨其中的两个：`mypy` ([`github.com/python/mypy`](https://github.com/python/mypy)) 和 `pytype` ([`github.com/google/pytype`](https://github.com/google/pytype))。虽然有多种工具可供选择，甚至你可能选择使用不同的工具，但通常，无论具体使用哪种工具，原则都是相同的：重要的是要有一个自动验证更改的方法，并将这些验证作为 CI 构建的一部分。`mypy`是 Python 中进行可选静态类型检查的主要工具。其理念是，一旦安装，它将分析项目中的所有文件，检查类型使用中的不一致性。这很有用，因为大多数时候，它会在早期发现实际的错误，但有时它可能会给出误报。

你可以使用`pip`来安装它，并建议在设置文件中将它包括为项目的依赖项：

```py
$ pip install mypy 
```

一旦在虚拟环境中安装，你只需运行前面的命令，它就会报告类型检查的所有发现。尽可能遵循其报告，因为大多数时候，它提供的见解有助于避免可能否则会进入生产的错误。然而，这个工具并不完美，所以如果你认为它报告了误报，你可以用以下标记作为注释来忽略该行：

```py
type_to_ignore = "something" # type: ignore 
```

重要的是要注意，为了使这个或任何工具变得有用，我们必须在代码中声明的类型注解上小心谨慎。如果我们对类型设置过于泛化，我们可能会错过工具可能报告的合法问题。

在下面的示例中，有一个旨在接收要迭代的参数的函数。最初，任何可迭代的对象都可以工作，因此我们想利用 Python 的动态类型能力，允许函数使用传递列表、元组、字典键、集合或几乎任何支持`for`循环的对象：

```py
def broadcast_notification(
    message: str, 
    relevant_user_emails: Iterable[str]
):
    for email in relevant_user_emails:
        logger.info("Sending %r to %r", message, email) 
```

问题在于，如果代码的某些部分错误地传递了这些参数，`mypy`不会报告错误：

```py
broadcast_notification("welcome", "user1@domain.com") 
```

当然，这不是一个有效的实例，因为它会迭代字符串中的每个字符，并尝试将其用作电子邮件。

如果我们对该参数设置的类型更加严格（比如说只接受字符串的列表或元组），那么运行 `mypy` 就会识别出这种错误场景：

```py
$ mypy <file-name>
error: Argument 2 to "broadcast_notification" has incompatible type "str"; expected "Union[List[str], Tuple[str]]" 
```

类似地，`pytype` 也是可配置的，并且以类似的方式工作，因此你可以根据项目的具体上下文调整这两个工具。我们可以看到这个工具报告的错误与之前的情况非常相似：

```py
File "...", line 22, in <module>: Function broadcast_notification was called with the wrong arguments [wrong-arg-types]
         Expected: (message, relevant_user_emails: Union[List[str], Tuple[str]])
  Actually passed: (message, relevant_user_emails: str) 
```

然而，`pytype` 有一个关键的区别，那就是它不仅会检查定义与参数之间的匹配，还会尝试解释代码在运行时是否正确，并报告可能出现的运行时错误。例如，如果一个类型定义暂时被违反，只要最终结果符合声明的类型，这就不会被视为问题。虽然这是一个很好的特性，但一般来说，我建议你尽量不要破坏代码中设置的不可变特性，并尽可能避免中间无效状态，因为这会使你的代码更容易推理和依赖，并且副作用更少。

## 代码中的通用验证

除了使用上一节中介绍的工具来检查程序中类型管理上的错误外，我们还可以使用其他工具，这些工具将对更广泛的参数提供验证。

在 Python 中有许多用于检查代码结构的工具（基本上，这是符合 PEP-8 规范），例如 `pycodestyle`（在 `PyPi` 中曾被称为 `pep8`），`flake8` 以及更多。它们都是可配置的，并且使用起来与运行它们提供的命令一样简单。

这些工具是运行在一系列 Python 文件上的程序，检查代码是否符合 PEP-8 标准，并报告每行违反规则的情况以及相应的错误提示。

还有其他工具提供更全面的检查，这样它们不仅验证代码是否符合 PEP-8，还包括对超出 PEP-8 的更复杂情况的额外检查（记住，代码仍然可以完全符合 PEP-8，但质量并不好）。

例如，PEP-8 主要关于代码的样式和结构，但它并不强制我们为每个 `public method`、`class` 或 `module` 添加文档字符串。它也没有提到函数参数过多的问题（我们将在本书后面的章节中将这个问题识别为不良特性）。

这些工具的一个例子是 `pylint`。这是目前最完整和最严格的用于验证 Python 项目的工具之一，它也是可配置的。和之前一样，要使用它，你只需在虚拟环境中使用 `pip` 安装即可：

```py
$ pip install pylint 
```

然后，只需运行 `pylint` 命令就足以在代码中检查它。

可以通过名为`pylintrc`的配置文件来配置`pylint`。在这个文件中，你可以决定你想启用或禁用的规则，并参数化其他规则（例如，更改列的最大长度）。例如，正如我们刚才讨论的，我们可能不希望每个函数都有文档字符串，因为强制这样做可能适得其反。然而，默认情况下，`pylint`将强制执行此限制，但我们可以通过在配置文件中声明来覆盖它：

```py
 [DESIGN]
    disable=missing-function-docstring 
```

一旦这个配置文件达到了稳定状态（意味着它与编码指南保持一致，不需要进行太多进一步的调整），然后它可以复制到其他存储库，那里也应该受到版本控制。

记录开发团队同意的编码标准，并在配置文件中强制执行，这些配置文件将用于在存储库中自动运行的工具。

最后，我想提到另一个工具，那就是`Coala` ([`github.com/coala/coala`](https://github.com/coala/coala))。`Coala`更通用一些（这意味着它支持多种语言，而不仅仅是 Python），但想法与之前类似：它接受一个配置文件，然后提供一个命令行工具，该工具将对代码执行一些检查。在运行时，如果工具在扫描文件时检测到一些错误，它可能会提示用户，如果适用，它还会建议自动应用修复补丁。

但如果我的用例没有被工具的默认规则覆盖怎么办？`pylint`和`Coala`都附带了许多预定义的规则，涵盖了最常见的场景，但你可能还在你的组织中检测到一些导致错误的模式。

如果你检测到代码中反复出现的、容易出错的模式，我建议花些时间来定义你自己的规则。这两个工具都是可扩展的：在`pylint`的情况下，有多个插件可用，你可以编写自己的。在`Coala`的情况下，你可以编写自己的验证模块，以便与常规检查并行运行。

## 自动格式化

如本章开头所述，团队就代码的编写约定达成一致是明智的，以避免在拉取请求中讨论个人偏好，并专注于代码的本质。但协议只能带你走这么远，如果这些规则不得到执行，它们会随着时间的推移而丢失。

除了通过工具检查代码是否符合标准之外，自动直接格式化代码也会很有用。

有多个工具可以自动格式化 Python 代码（例如，大多数验证 PEP-8 的工具，如 `flake8`，也具有重写代码使其符合 PEP-8 标准的模式），并且它们也是可配置和适应每个特定项目的。在这些工具中，也许正因为与完全灵活和配置相反，我想强调的是：`black`。

`black` ([`github.com/psf/black`](https://github.com/psf/black)) 有一个特性，以独特和确定的方式格式化代码，不允许任何参数（除了可能行长的设置）。

这其中的一个例子是 `black` 总是使用双引号来格式化字符串，参数的顺序也总是遵循相同的结构。这听起来可能有些死板，但这是确保代码差异最小化的唯一方法。如果代码始终遵循相同的结构，代码的更改只会出现在包含实际更改的 pull request 中，而不会有额外的外观修改。它比 PEP-8 更为严格，但同时也方便，因为通过工具直接格式化代码，我们实际上不必担心这一点，可以专注于手头问题的核心。

这也是 `black` 存在的原因。PEP-8 定义了一些代码结构的指南，但有多种方式可以使代码符合 PEP-8 标准，因此仍然存在寻找风格差异的问题。`black` 格式化代码的方式是将它移动到一个始终确定的 PEP-8 严格子集。

例如，以下代码符合 PEP-8 标准，但它并不遵循 `black` 的约定：

```py
def my_function(name):
    """
    >>> my_function('black')
    'received Black'
    """
    return 'received {0}'.format(name.title()) 
```

现在，我们可以运行以下命令来格式化文件：

```py
black -l 79 *.py 
```

我们可以查看工具生成的结果：

```py
def my_function(name):
    """
    >>> my_function('black')
    'received Black'
    """
    return "received {0}".format(name.title()) 
```

在更复杂的代码中，会有更多的变化（尾随逗号等），但基本思想可以清楚地看到。再次强调，它具有主观性，但也是一个好主意，有一个工具可以为我们处理细节。

这也是 Go 社区很久以前就学到的东西，以至于有一个标准的工具库，`go fmt`，它可以自动根据语言的约定格式化代码。现在 Python 也有类似的东西是件好事。

安装后，默认情况下，`'black'` 命令会尝试格式化代码，但它还有一个 `'--check'` 选项，该选项将验证文件是否符合标准，如果验证未通过，则终止进程。这个命令是作为自动检查和 CI 流程的一部分的好候选。

值得注意的是，`black` 会彻底格式化文件，并且不支持部分格式化（与其他工具相反）。这可能是一个问题，因为遗留项目可能已经存在不同风格的代码，如果你想在项目中采用 `black` 作为格式化标准，你很可能会接受以下两种情况之一：

1.  创建一个里程碑`pull`请求，将`black`格式应用于仓库中的所有 Python 文件。这有一个缺点，就是会添加很多噪声并污染仓库的版本控制历史。在某些情况下，你的团队可能会决定接受这个风险（取决于你对`git`历史的依赖程度）。

1.  或者，你可以使用`black`格式重写代码中的历史变更。在`git`中，通过在每个提交上应用一些命令，可以重写提交（从最一开始）。在这种情况下，我们可以在`'black'`格式化应用后重写每个提交。最终，项目看起来就像从一开始就是新的形式，但也有一些注意事项。首先，项目的历史被重写了，所以每个人都需要刷新他们的本地仓库副本。其次，根据你的仓库历史，如果有大量的提交，这个过程可能需要一段时间。

在格式化采用“全有或全无”方式不可接受的情况下，我们可以使用`yapf` ([`github.com/google/yapf`](https://github.com/google/yapf))，这是另一个与`black`有许多不同之处的工具：它高度可定制，并且也接受部分格式化（仅对文件的特定区域应用格式化）。

`yapf`接受一个参数来指定要应用格式的行范围。利用这个参数，你可以配置你的编辑器或 IDE（或者更好的是，设置一个`git` pre-commit 钩子），以自动仅对刚刚更改的代码区域进行格式化。这样，项目可以在变更过程中以分阶段的时间间隔对齐到编码标准。

要总结本节关于自动格式化代码的工具，我们可以说`black`是一个很好的工具，它将推动代码向一个规范标准靠拢，因此，你应该尝试在你的仓库中使用它。在创建新仓库时使用`black`没有任何摩擦，但对于遗留仓库，这可能会成为一个障碍。如果团队决定在遗留仓库中采用`black`过于繁琐，那么像`yapf`这样的工具可能更适合。

## 自动检查的设置

在 Unix 开发环境中，最常见的工作方式是通过 Makefiles。Makefiles 是强大的工具，它让我们能够配置在项目中运行的命令，主要用于编译、运行等。除此之外，我们可以在项目的根目录中使用 Makefile，配置一些命令来自动运行对代码格式和约定的检查。

对于此，一个好的方法是为测试设置目标，并为每个特定的测试设置一个目标，然后还有一个运行所有测试的目标；例如：

```py
.PHONY: typehint
typehint:
	mypy --ignore-missing-imports src/
.PHONY: test
test:
	pytest tests/
.PHONY: lint
lint:
	pylint src/
.PHONY: checklist
checklist: lint typehint test
.PHONY: black
black:
	black -l 79 *.py
.PHONY: clean
clean:
	find . -type f -name "*.pyc" | xargs rm -fr
	find . -type d -name __pycache__ | xargs rm -fr 
```

在这里，我们运行的命令（在我们的开发机器上以及 CI 环境构建中）如下：

```py
make checklist 
```

这将在以下步骤中运行所有内容：

1.  它将首先检查是否符合编码指南（PEP-8，或者例如使用`'--check'`参数的`black`）。

1.  然后它将检查代码中对类型的用法。

1.  最后，它将运行测试。

如果这些步骤中的任何一个失败，请考虑整个过程为失败。

这些工具（`black`、`pylint`、`mypy`等）可以与您选择的编辑器或 IDE 集成，使事情更加简单。配置您的编辑器，在保存文件或通过快捷键进行此类修改，这是一个很好的投资。

值得注意的是，使用`Makefile`有几个原因很方便：首先，有一个简单且统一的方法来自动执行最重复的任务。新加入团队的成员可以通过学习像`'make format'`这样的命令来自动格式化代码，而不管使用的是哪种底层工具（及其参数）。此外，如果后来决定更改工具（比如说从`yapf`切换到`black`），那么相同的命令`('make format'`)仍然有效。

其次，尽可能利用`Makefile`，这意味着配置你的 CI 工具以调用`Makefile`中的命令。这样，就有了一个标准化的方式来运行项目中的主要任务，我们将尽可能少地在 CI 工具中放置配置（这同样可能在将来发生变化，而且不必成为一项重大负担）。

# 摘要

我们现在对什么是干净的代码有一个初步的了解，以及对其的一个可行的解释，这将作为本书其余部分的一个参考点。

更重要的是，我们现在明白，干净的代码比代码的结构和布局更重要。我们必须关注代码中想法的表达方式，以判断它们是否正确。干净的代码关乎代码的可读性、可维护性，将技术债务降至最低，以及有效地在代码中传达我们的想法，以便他人能够理解我们最初想要写的内容。

然而，我们讨论了遵守编码风格或指南的重要性，原因有很多。我们一致认为，这是一个必要条件，但不是充分条件，并且由于它是每个稳健项目都必须遵守的最小要求，因此很明显，这是我们应该留给工具的事情。因此，自动化所有这些检查变得至关重要，在这方面，我们必须记住如何配置`mypy`、`pylint`、`black`和其他工具。

下一章将更加专注于 Python 特定的代码，以及如何用惯用的 Python 方式表达我们的想法。我们将探讨 Python 中那些使代码更加紧凑和高效的惯用用法。在这个分析中，我们将看到，总的来说，Python 与其他语言相比，有不同的想法或不同的方式来完成事情。

# 参考文献

+   *PEP-8*: [`www.python.org/dev/peps/pep-0008/`](https://www.python.org/dev/peps/pep-0008/)

+   `mypy`: [`mypy-lang.org/`](http://mypy-lang.org/)

+   `pytype`: [`google.github.io/pytype/`](https://google.github.io/pytype/)

+   *PEP-3107*: [`www.python.org/dev/peps/pep-3107/`](https://www.python.org/dev/peps/pep-3107/)

+   *PEP-484*: [`www.python.org/dev/peps/pep-0484/`](https://www.python.org/dev/peps/pep-0484/)

+   *PEP-526*: [`www.python.org/dev/peps/pep-0526/`](https://www.python.org/dev/peps/pep-0526/)

+   *PEP-557*: [`www.python.org/dev/peps/pep-0557/`](https://www.python.org/dev/peps/pep-0557/)

+   *PEP-585*: [`www.python.org/dev/peps/pep-0585/`](https://www.python.org/dev/peps/pep-0585/)
