# 9

# 常见设计模式

设计模式自从在著名的**四人帮**（**GoF**）书籍《设计模式：可复用面向对象软件元素》中首次提出以来，一直是软件工程中的一个广泛讨论的话题。设计模式通过为特定场景提供抽象来帮助解决常见问题。当它们被正确实现时，解决方案的一般设计可以从它们中受益。

在本章中，我们查看了一些最常见的设计模式，但不是从在特定条件下应用工具的视角（一旦模式被设计出来），而是分析设计模式如何有助于编写干净的代码。在展示实现设计模式的解决方案之后，我们将分析最终实现相对于选择不同路径的比较优势。

作为这次分析的一部分，我们将看到如何在 Python 中具体实现设计模式。结果，我们将看到 Python 的动态特性意味着与其他静态类型语言相比，在实现上存在一些差异，而这些设计模式最初是为它们而设计的。这意味着在设计模式方面，有一些特定的特性，当涉及到 Python 时你应该牢记在心，在某些情况下，试图在不适合的地方应用设计模式是不符合 Python 风格的。

在本章中，我们将涵盖以下主题：

+   常见的设计模式

+   在 Python 中不适用且应遵循的惯用替代设计模式

+   实现最常见设计模式的 Python 风格

+   理解良好的抽象如何自然地演变成模式

借助前几章的知识，我们现在可以分析更高层次的设计代码，同时考虑其详细的实现（我们如何以最有效地使用 Python 特性的方式来编写它？）。

在本章中，我们将分析如何使用设计模式来实现更干净的代码，从以下部分的分析初始考虑开始。

# Python 中的设计模式考虑因素

面向对象的设计模式是软件构建的思路，当我们在处理我们正在解决的问题的模型时，它们会在不同的场景中出现。因为它们是高级思想，所以很难将它们视为与特定编程语言相关联。它们是关于对象如何在应用程序中交互的更一般的概念。当然，它们将有自己的实现细节，这些细节会因语言而异，但这并不构成设计模式的核心。

这就是设计模式的理论方面，即它是一个抽象的概念，表达了关于解决方案中对象布局的概念。关于面向对象设计和特别是设计模式，有大量的其他书籍和资源，所以在这本书中，我们将专注于 Python 的实现细节。

考虑到 Python 的特性，一些经典的设计模式实际上并不需要。这意味着 Python 已经支持了那些使这些模式变得不可见的功能。有些人认为它们在 Python 中不存在，但请记住，不可见并不意味着不存在。它们确实存在，只是嵌入在 Python 本身中，所以我们可能甚至都不会注意到它们。

其他模式有更简单的实现，这同样要归功于语言的动态特性，而其余的模式在其他平台上实际上与它们相同，只有一些小的差异。

在任何情况下，实现 Python 中干净代码的重要目标就是知道要实现哪些模式以及如何实现。这意味着要识别 Python 已经抽象的一些模式以及我们如何利用它们。例如，尝试实现迭代器模式的常规定义（就像我们在其他语言中做的那样）是完全不符合 Python 风格的，因为（正如我们已经讨论过的）迭代在 Python 中已经深深嵌入，而且我们可以创建将在`for`循环中直接工作的对象，这使得这是正确的处理方式。

类似的情况也发生在一些创建型模式上。在 Python 中，类是常规对象，函数也是如此。正如我们在之前的几个例子中看到的，它们可以被传递、装饰、重新分配等等。这意味着无论我们想要对我们的对象进行何种定制，我们很可能不需要任何特定的工厂类设置就能做到。此外，Python 中没有创建对象的特殊语法（例如没有`new`关键字）。这也是为什么在大多数情况下，简单的函数调用就能像工厂一样工作的另一个原因。

其他模式仍然是必需的，我们将看到如何通过一些小的调整，使它们更加符合 Python 风格，充分利用语言提供的特性（魔法方法或标准库）。

在所有可用的模式中，并不是所有模式都同样频繁或有用，所以我们将关注主要的模式，那些我们预计会在我们的应用程序中最常看到的模式，我们将通过一种实用主义的方法来实现这一点。

# 设计模式在实际应用中

在这个主题中，由 GoF（四人帮）撰写的规范参考书介绍了 23 种设计模式，每种模式都属于创建型、结构型和行为型类别之一。甚至还有更多模式或现有模式的变体，但与其死记硬背所有这些模式，我们更应该关注两点。一些模式在 Python 中是看不见的，我们可能在使用它们时甚至没有意识到。其次，并非所有模式都同样常见；其中一些非常有用，因此它们非常频繁地被找到，而另一些则适用于更具体的案例。

在本节中，我们将回顾最常见的模式，那些最有可能从我们的设计中出现的模式。注意这里使用“出现”这个词。我们不应该强迫将设计模式应用到我们正在构建的解决方案中，而应该通过进化、重构和改进我们的解决方案，直到出现一个模式。

设计模式并非是发明出来的，而是被发现出来的。当我们在代码中反复遇到某种情况时，类、对象和相关组件的通用和更抽象的布局就会以一个我们用来识别模式的名称出现。

设计模式的名称概括了众多概念。这可能是设计模式最好的地方；它们提供了一种语言。通过设计模式，更有效地传达设计思想变得容易。当两个或更多的软件工程师共享相同的词汇，并且其中一人提到策略时，房间里其余的软件工程师可以立即想到所有相关的类，以及它们如何相互关联，它们的机制是什么，等等，而不必重复这个解释。

读者会注意到，本章中展示的代码与所讨论的设计模式的规范或原始设想不同。这有多个原因。第一个原因是示例采取了一种更务实的方法，旨在解决特定场景的解决方案，而不是探索一般的设计理论。第二个原因是模式是用 Python 的特定性实现的，在某些情况下非常微妙，但在其他情况下，差异是明显的，通常简化了代码。

## 创建型模式

在软件工程中，创建型模式是那些处理对象实例化的模式，试图抽象掉很多复杂性（比如确定初始化对象所需的参数，所有可能需要的相关对象，等等），以便为用户提供一个更简单、更安全的接口。基本的对象创建形式可能会导致设计问题或增加设计的复杂性。创建型设计模式通过某种方式控制对象创建来解决这个问题。

在创建对象的五种模式中，我们将主要讨论用于避免单例模式并替换为博格模式（在 Python 应用中最常用）的变体，讨论它们之间的差异和优势。

### 工厂

如介绍中所述，Python 的一个核心特性是万物皆对象，因此它们都可以被同等对待。这意味着我们没有特殊区分的事物，无论是使用类、函数还是自定义对象，我们都可以对它们进行操作。它们都可以通过参数传递、赋值等操作。

正是因为这个原因，许多工厂模式通常并不需要。我们只需简单地定义一个函数来构建一组对象，我们甚至可以用参数传递我们想要创建的类。

当我们使用`pyinject`作为库来帮助我们进行依赖注入和复杂对象的初始化时，我们看到了工厂模式的一个例子。在需要处理复杂设置，并确保我们使用依赖注入初始化对象而不重复代码的情况下，我们可以使用`pyinject`这样的库，或者在我们的代码中创建类似的结构。

### 单例和共享状态（单态）

相反，单例模式并不是 Python 完全抽象化的。事实是，大多数情况下，这个模式要么根本不是必需的，要么是一个糟糕的选择。单例有很多问题（毕竟，它们实际上是面向对象软件的全局变量的形式，因此是不良实践）。它们难以进行单元测试，它们可能随时被任何对象修改，这使得它们难以预测，并且它们的副作用可能非常成问题。

作为一般原则，我们应该尽可能避免使用单例。如果在某些极端情况下需要使用单例，那么在 Python 中实现这一点的最简单方法就是使用模块。我们可以在模块中创建一个对象，一旦创建，它将可以从导入模块的任何部分访问。Python 本身确保模块已经是单例的，也就是说，无论导入多少次，以及从多少个地方导入，总是同一个模块将被加载到`sys.modules`中。因此，在这个 Python 模块内部初始化的对象将是唯一的。

注意，这并不完全等同于单例。单例的想法是创建一个类，无论你调用多少次，它都会给你相同的对象。前一段中提出的思想是关于拥有一个唯一对象。无论其类如何定义，我们只创建一个对象，然后多次使用同一个对象。这些有时被称为知名对象；不需要超过一个的对象。

我们已经熟悉这些对象了。考虑`None`。对于整个 Python 解释器，我们不需要多个。一些开发者声称“`None`在 Python 中是一个单例”。我对此略有不同意见。它是一个众所周知的对象：我们所有人都知道的东西，我们不需要另一个。对于`True`和`False`也是如此。尝试创建不同类型的布尔值是没有意义的。

#### 共享状态

而不是强迫我们的设计有一个单例，无论对象是如何被调用、构造或初始化的，都只创建一个实例，更好的做法是在多个实例之间复制数据。

单例模式（SNGMONO）的想法是，我们可以有许多只是普通对象而没有必要关心它们是否是单例（因为它们只是对象）。这个模式的好处是，这些对象将同步它们的信息，以一种完全透明的方式，我们不必担心它是如何内部工作的。

这使得这种模式成为一个更好的选择，不仅因为它方便，而且因为它更不容易出错，并且受单例模式（关于它们的可测试性、创建派生类等）的缺点更少。

我们可以根据需要同步多少信息来在多个层面上使用这个模式。

在最简单的情况下，我们可以假设我们只需要一个属性被反射到所有实例上。如果是这样，实现就像使用类变量一样简单，我们只需要确保提供一个正确的接口来更新和检索属性的值。

假设我们有一个对象，它必须通过最新的`tag`从`Git`仓库中`pull`某个代码版本。可能会有多个此类对象实例，并且当每个客户端调用获取代码的方法时，此对象将使用其属性中的`tag`版本。在任何时候，这个`tag`都可以更新为更新版本，我们希望其他任何实例（无论是新创建的还是已经创建的）在调用`fetch`操作时使用这个新分支，如下面的代码所示：

```py
class GitFetcher:
    _current_tag = None
    def __init__(self, tag):
        self.current_tag = tag
    @property
    def current_tag(self):
        if self._current_tag is None:
            raise AttributeError("tag was never set")
        return self._current_tag
    @current_tag.setter
    def current_tag(self, new_tag):
        self.__class__._current_tag = new_tag
    def pull(self):
        logger.info("pulling from %s", self.current_tag)
        return self.current_tag 
```

读者可以简单地验证创建多个不同版本的`GitFetcher`类型的对象会导致所有对象在任何时候都设置为最新版本，如下面的代码所示：

```py
>>> f1 = GitFetcher(0.1)
>>> f2 = GitFetcher(0.2)
>>> f1.current_tag = 0.3
>>> f2.pull()
0.3
>>> f1.pull()
0.3 
```

如果我们需要更多的属性，或者我们希望更紧密地封装共享属性，以使设计更简洁，我们可以使用描述符。

如下代码所示，描述符解决了这个问题，虽然它确实需要更多的代码，但它封装了更具体的责任，并且部分代码实际上被移出了我们的原始类，这使得它更具有凝聚力和符合单一责任原则：

```py
class SharedAttribute:
    def __init__(self, initial_value=None):
        self.value = initial_value
        self._name = None
    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.value is None:
            raise AttributeError(f"{self._name} was never set")
        return self.value
    def __set__(self, instance, new_value):
        self.value = new_value
    def __set_name__(self, owner, name):
        self._name = name 
```

除了这些考虑因素之外，现在这个模式也更加可重用。如果我们想要重复这个逻辑，我们只需要创建一个新的描述符对象，它将能够工作（符合 DRY 原则）。

如果我们现在想要对当前分支做同样的操作，我们创建这个新的类属性，而类的其余部分保持不变，同时仍然保留所需的逻辑，如下面的代码所示：

```py
class GitFetcher:
    current_tag = SharedAttribute()
    current_branch = SharedAttribute()
    def __init__(self, tag, branch=None):
        self.current_tag = tag
        self.current_branch = branch
    def pull(self):
        logger.info("pulling from %s", self.current_tag)
        return self.current_tag 
```

这种新方法的平衡和权衡现在应该已经很清晰了。这种新的实现方式使用了更多的代码，但它可以重用，因此从长远来看可以节省代码行数（以及重复的逻辑）。再次提醒，参考三个或更多实例规则来决定你是否应该创建这样的抽象。

这个解决方案的另一个重要好处是，它还减少了单元测试的重复（因为我们只需要测试`SharedAttribute`类，而不是它的所有使用）。

在这里重用代码将使我们更有信心于解决方案的整体质量，因为现在我们只需要为描述符对象编写单元测试，而不是为所有使用它的类编写单元测试（我们可以安全地假设它们是正确的，只要单元测试证明了描述符是正确的）。

#### 博尔模式

以前的方法应该适用于大多数情况，但如果我们真的需要使用单例（这必须是一个非常好的例外），那么还有最后一个更好的替代方案，但这是一个风险更高的方案。

这实际上是单态模式，在 Python 中被称为博尔模式。想法是创建一个对象，能够在其相同类的所有实例之间复制其所有属性。绝对每个属性都在被复制的事实必须是一个警告，要记住可能的不希望出现的副作用。尽管如此，这个模式与单例相比有很多优点。

在这种情况下，我们将把之前的对象分成两个——一个用于处理`Git`标签，另一个用于处理分支。我们使用使博尔模式工作的代码：

```py
class BaseFetcher:
    def __init__(self, source):
        self.source = source
class TagFetcher(BaseFetcher):
    _attributes = {}
    def __init__(self, source):
        self.__dict__ = self.__class__._attributes
        super().__init__(source)
    def pull(self):
        logger.info("pulling from tag %s", self.source)
        return f"Tag = {self.source}"
class BranchFetcher(BaseFetcher):
    _attributes = {}
    def __init__(self, source):
        self.__dict__ = self.__class__._attributes
        super().__init__(source)
    def pull(self):
        logger.info("pulling from branch %s", self.source)
        return f"Branch = {self.source}" 
```

两个对象都有一个基类，它们共享初始化方法。但随后它们必须再次实现它，以便使*博尔逻辑*工作。想法是使用一个字典作为类属性来存储属性，然后我们让每个对象的字典（在初始化时）使用这个相同的字典。这意味着任何对对象字典的更新都会反映在类上，对于其他对象来说也将是相同的，因为它们的类是相同的，而字典是可变的对象，作为引用传递。换句话说，当我们创建这种类型的新对象时，它们都将使用同一个字典，而这个字典会不断更新。

注意，我们不能将字典的逻辑放在基类上，因为这会将不同类对象之间的值混合在一起，这不是我们想要的。这个样板解决方案会让很多人认为它实际上是一个惯用语，而不是一个模式。

一种以实现 DRY 原则的方式抽象化这一过程的方法是创建一个`mixin`类，如下面的代码所示：

```py
class SharedAllMixin:
    def __init__(self, *args, **kwargs):
        try:
            self.__class__._attributes
        except AttributeError:
            self.__class__._attributes = {}
        self.__dict__ = self.__class__._attributes
        super().__init__(*args, **kwargs)
class BaseFetcher:
    def __init__(self, source):
        self.source = source
class TagFetcher(SharedAllMixin, BaseFetcher):
    def pull(self):
        logger.info("pulling from tag %s", self.source)
        return f"Tag = {self.source}"
class BranchFetcher(SharedAllMixin, BaseFetcher):
    def pull(self):
        logger.info("pulling from branch %s", self.source)
        return f"Branch = {self.source}" 
```

这次，我们使用`mixin`类来创建具有每个类中属性的字典，以防它已经存在，然后继续使用相同的逻辑。

这个实现应该不会与继承有任何重大问题，因此它是一个更可行的替代方案。

### 构建者

构建者模式是一种有趣的模式，它抽象化了对象的复杂初始化。这个模式不依赖于任何特定的语言特性，因此在 Python 中的应用与任何其他语言一样广泛。

虽然它解决了有效的情况，但它通常也是一个复杂的情况，更可能出现在框架、库或 API 的设计中。类似于对描述符给出的建议，我们应该将这种实现保留在预期将暴露给多个用户使用的 API 的情况下。

这个模式的高级思想是我们需要创建一个复杂对象，即一个还需要许多其他对象来协同工作的对象。我们不想让用户创建所有这些辅助对象，然后将它们分配给主要对象，我们希望创建一个抽象，允许所有这些操作在一步内完成。为了实现这一点，我们将有一个`builder`对象，它知道如何创建所有部分并将它们连接起来，为用户提供一个接口（可能是类方法），以参数化关于结果对象应如何看起来的一切信息。

## 结构型模式

结构型模式适用于需要创建更简单接口或通过扩展其功能而不增加接口复杂性的更强大对象的情况。

这些模式最好的地方在于，我们可以创建更多有趣的对象，具有增强的功能，并且我们可以以干净的方式实现这一点；也就是说，通过组合多个单一对象（最明显的例子是组合模式），或者通过收集许多简单且一致的接口。

### 适配器

适配器模式可能是最简单的设计模式之一，同时也是最有用的一种。

也称为*包装器*，这个模式解决了两个或多个不兼容对象接口适配的问题。

我们通常遇到的情况是，我们的一部分代码与一个或一组类一起工作，这些类在某个方法上是多态的。例如，如果有多个对象使用`fetch()`方法检索数据，那么我们希望保持这个接口，这样我们就不必对我们的代码进行重大更改。

但然后我们来到了一个需要添加新的数据源的地方，不幸的是，这个数据源没有`fetch()`方法。更糟糕的是，这种类型的对象不仅不兼容，而且我们也不控制它（可能是一个不同的团队决定了 API，我们无法修改代码，或者它是一个来自外部库的对象）。

而不是直接使用这个对象，我们调整其接口以适应我们需要的接口。有两种方法可以做到这一点。

第一种方法可能是创建一个从我们需要继承的类，并为方法创建一个别名（如果需要，它还必须调整参数和签名），这样内部将调整调用以使其与所需的方法兼容。

通过继承，我们导入外部类并创建一个新的类，该类将定义新的方法，调用具有不同名称的方法。在这个例子中，假设外部依赖有一个名为`search()`的方法，它只接受一个参数进行搜索，因为它以不同的方式查询，所以我们的`adapter`方法不仅调用外部方法，而且还相应地转换参数，如下面的代码所示：

```py
from _adapter_base import UsernameLookup
class UserSource(UsernameLookup):
    def fetch(self, user_id, username):
        user_namespace = self._adapt_arguments(user_id, username)
        return self.search(user_namespace)
    @staticmethod
    def _adapt_arguments(user_id, username):
        return f"{user_id}:{username}" 
```

利用 Python 支持多重继承的事实，我们可以用它来创建我们的适配器（甚至可以创建一个作为适配器的`mixin`类，就像我们在前面的章节中看到的那样）。

然而，正如我们之前多次看到的，继承伴随着更多的耦合（谁知道有多少其他方法是从外部库中携带过来的？），并且它不够灵活。从概念上讲，这也不是正确的选择，因为我们保留继承用于规范的情况（继承是一种 IS-A 类型的关系），在这种情况下，我们的对象是否必须是第三方库提供的类型之一并不清楚（尤其是我们并不完全理解那个对象）。

因此，更好的方法可能是使用组合。假设我们可以为我们提供的对象提供一个`UsernameLookup`的实例，代码将像以下代码所示，只需在采用参数之前重定向请求那么简单：

```py
class UserSource:
    ...
    def fetch(self, user_id, username):
        user_namespace = self._adapt_arguments(user_id, username)
        return self.username_lookup.search(user_namespace) 
```

如果我们需要调整多个方法，并且我们可以设计一种通用的方法来调整它们的签名，那么使用`__getattr__()`魔法方法将请求重定向到包装对象可能是有价值的，但就像所有通用实现一样，我们应该小心不要给解决方案增加更多的复杂性。

使用`__getattr__()`可能使我们能够拥有一种“通用适配器”；一种可以包装另一个对象并通用地适配其所有方法的东西。但我们确实应该非常小心，因为这个方法将创建一个非常通用的东西，这可能甚至更危险，并产生不可预见的副作用。如果我们想在保持原始接口的同时对对象执行转换或额外功能，那么装饰器模式是一个更好的选择，正如我们将在本章后面看到的。

### 组合

我们程序的部分部分需要我们与由其他对象组成的对象一起工作。我们有具有良好定义逻辑的基本对象，然后我们将有其他容器对象，它们将分组一些基本对象，挑战在于我们希望在不察觉任何差异的情况下同时处理这两种对象（基本和容器对象）。

这些对象以树形层次结构组织，其中基本对象将是树的叶子，而组合对象将是中间节点。客户可能想要调用任何一个来获取被调用的方法的返回结果。然而，组合对象将充当客户端；它将把这个请求以及它包含的所有对象（无论是叶子还是其他中间节点）传递下去，直到所有对象都被处理。

想象一个简化版的在线商店，其中包含产品。比如说，我们提供将产品分组的功能，并为每组产品提供折扣。产品有一个价格，当顾客付款时，这个值会被询问。但是，一组分组产品的价格也需要计算。我们将有一个代表这个包含产品的组的对象，并将询问每个特定产品的价格的责任委托给每个产品（这可能是另一个产品组），依此类推，直到没有其他需要计算的内容。

以下代码展示了这种实现的示例：

```py
class Product:
    def __init__(self, name: str, price: float) -> None:
        self._name = name
        self._price = price
    @property
    def price(self):
        return self._price
class ProductBundle:
    def __init__(
        self,
        name: str,
        perc_discount: float,
        *products: Iterable[Union[Product, "ProductBundle"]]
    ) -> None:
        self._name = name
        self._perc_discount = perc_discount
        self._products = products
    @property
    def price(self) -> float:
        total = sum(p.price for p in self._products)
        return total * (1 - self._perc_discount) 
```

我们通过一个属性公开接口，并将`price`保留为私有属性。`ProductBundle`类使用这个属性来计算折扣后的值，首先添加它包含的所有产品的价格。

这些对象之间唯一的差异是它们使用不同的参数创建。为了完全兼容，我们应该尝试模仿相同的接口，然后添加额外的添加产品到捆绑的方法，但使用允许创建完整对象的接口。不需要这些额外步骤是一个优势，这也证明了这种小差异的合理性。

### 装饰器

不要将装饰器模式与 Python 装饰器的概念混淆，我们在*第五章*中已经讨论过，即*使用装饰器改进我们的代码*。它们有一些相似之处，但设计模式的思想相当不同。

此模式允许我们动态扩展某些对象的功能，而无需使用继承。它是创建更灵活对象时多重继承的良好替代方案。

我们将创建一个结构，允许用户定义要应用到对象上的一系列操作（装饰），我们将看到每个步骤是如何按指定顺序进行的。

以下代码示例是一个简化版本的对象，它从传递给它的参数（例如，我们可能会使用它来运行对 `Elasticsearch` 的查询，但代码省略了分散注意力的实现细节，以专注于模式的理念）构建一个查询字典。

在其最基本的形式中，查询只是返回在创建时提供的数据的字典。客户端期望使用此对象的 `render()` 方法：

```py
class DictQuery:
    def __init__(self, **kwargs):
        self._raw_query = kwargs
    def render(self) -> dict:
        return self._raw_query 
```

现在我们希望通过应用转换到数据（过滤值、归一化等）来以不同的方式呈现查询。我们可以创建装饰器并将它们应用到 `render` 方法上，但这不会足够灵活——如果我们想在运行时更改它们怎么办？或者如果我们只想选择其中的一些，而不是全部呢？

设计是创建另一个具有相同接口和通过多个步骤增强（装饰）原始结果的能力，但可以组合的对象。这些对象是链式的，每个对象都执行它原本应该执行的操作，以及一些其他操作。这个其他操作就是特定的装饰步骤。

由于 Python 有鸭子类型，我们不需要创建一个新的基类并将这些新对象作为该层次结构的一部分，包括 `DictQuery`。只需创建一个新的具有 `render()` 方法的类就足够了（再次强调，多态不应需要继承）。这个过程在下面的代码中显示：

```py
class QueryEnhancer:
    def __init__(self, query: DictQuery):
        self.decorated = query
    def render(self):
        return self.decorated.render()
class RemoveEmpty(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v for k, v in original.items() if v}
class CaseInsensitive(QueryEnhancer):
    def render(self):
        original = super().render()
        return {k: v.lower() for k, v in original.items()} 
```

`QueryEnhancer` 语句有一个与 `DictQuery` 客户端期望的接口兼容的接口，因此它们可以互换。此对象旨在接收一个装饰过的对象。它将从这些值中获取值并转换它们，返回修改后的代码版本。

如果我们想删除所有评估为 `False` 的值并将它们归一化以形成我们的原始查询，我们必须使用以下模式：

```py
>>> original = DictQuery(key="value", empty="", none=None, upper="UPPERCASE", title="Title")
>>> new_query = CaseInsensitive(RemoveEmpty(original))
>>> original.render()
{'key': 'value', 'empty': '', 'none': None, 'upper': 'UPPERCASE', 'title': 'Title'}
>>> new_query.render()
{'key': 'value', 'upper': 'uppercase', 'title': 'title'} 
```

这是一个我们可以以不同方式实现的模式，利用 Python 的动态特性和函数是对象的事实。我们可以通过将函数提供给基装饰器对象（`QueryEnhancer`），并将每个装饰步骤定义为函数来实现此模式，如下面的代码所示：

```py
class QueryEnhancer:
    def __init__(
        self,
        query: DictQuery,
        *decorators: Iterable[Callable[[Dict[str, str]], Dict[str, str]]]
    ) -> None:
        self._decorated = query
        self._decorators = decorators
    def render(self):
        current_result = self._decorated.render()
        for deco in self._decorators:
            current_result = deco(current_result)
        return current_result 
```

对于客户端来说，没有任何变化，因为这个类通过其 `render()` 方法保持了兼容性。然而，在内部，这个对象的使用方式略有不同，如下面的代码所示：

```py
>>> query = DictQuery(foo="bar", empty="", none=None, upper="UPPERCASE", title="Title")
>>> QueryEnhancer(query, remove_empty, case_insensitive).render()
{'foo': 'bar', 'upper': 'uppercase', 'title': 'title'} 
```

在前面的代码中，`remove_empty` 和 `case_insensitive` 只是转换字典的常规函数。

在这个例子中，基于函数的方法似乎更容易理解。可能会有一些更复杂的规则，这些规则依赖于被装饰对象的数据（不仅仅是它的结果），在这些情况下，采用面向对象的方法可能更有价值，尤其是如果我们真的想在设计中创建一个对象层次结构，其中每个类实际上代表了一些我们想要在设计中明确表达的知识。

### 外观

外观模式是一个优秀的模式。它在许多情况下都很有用，当我们想要简化对象之间的交互时。模式应用于存在多个对象之间多对多关系的场景，我们希望它们进行交互。而不是创建所有这些连接，我们在许多对象前面放置一个中间对象，充当外观。

在这个布局中，外观充当中心或单一参考点。每次新对象想要连接到另一个对象时，它不需要为所有可能的 **N** 个对象创建 **N** 个接口（需要 **O(N²**) 的总连接），它只需与外观进行通信，然后外观会相应地重定向请求。外观后面的所有内容对外部对象来说都是完全透明的。

除了主要和明显的益处（对象的解耦）之外，这种模式还鼓励设计更简单，接口更少，封装性更好的设计。

这是一个我们可以用来改进领域问题的代码，也可以用来创建更好的 API 的模式。如果我们使用这个模式并提供一个单一接口，作为我们代码的单一点真实或入口点，那么用户与暴露的功能交互将会容易得多。不仅如此，通过暴露功能并隐藏在接口背后的所有内容，我们可以自由地更改或重构底层代码，因为我们可以在外观后面进行更改，而不会破坏向后兼容性，用户也不会受到影响。

注意，使用外观模式的想法不仅限于对象和类，也适用于包（技术上，包在 Python 中是对象，但仍然如此）。我们可以使用外观模式来决定包的布局；也就是说，用户可以看到什么，可以导入什么，以及内部的内容不应该直接导入。

当我们创建一个目录来构建一个包时，我们将`__init__.py`文件与其他文件一起放置。这是模块的根，一种门面。其余的文件定义了要导出的对象，但它们不应该被客户端直接导入。`__init__.py`文件应该导入它们，然后客户端应该从那里获取它们。这创建了一个更好的接口，因为用户只需要知道一个单一的入口点来获取对象，更重要的是，包（其余的文件）可以根据需要多次重构或重新排列，只要`init`文件上的主要 API 保持不变。牢记这样的原则对于构建可维护的软件至关重要。

在 Python 本身中就有这样一个例子，即`os`模块。该模块将操作系统的功能分组，但在其下面，它使用`posix`模块为**可移植操作系统接口**（**POSIX**）操作系统（在 Windows 平台上称为**nt**）。想法是，出于可移植性的原因，我们永远不应该直接导入`posix`模块，而应该总是导入`os`模块。这个模块负责确定它被哪个平台调用，并公开相应的功能。

## 行为模式

行为模式旨在解决对象应该如何协作、如何通信以及它们在运行时应该有什么接口的问题。

我们主要讨论以下行为模式：

+   责任链模式

+   模板方法

+   命令

+   状态

这可以通过继承或使用组合动态地完成。无论该模式使用什么，在接下来的示例中，我们将看到这些模式共有的特点是，结果代码在某些重要方面有所改进，无论是避免重复还是创建良好的抽象来相应地封装行为并解耦我们的模型。

### 责任链模式

现在，我们将再次审视我们的事件系统。我们希望从日志行（例如，从我们的 HTTP 应用程序服务器导出的文本文件）中解析系统上发生的事件的信息，并且我们希望以方便的方式提取这些信息。

在我们之前的实现中，我们实现了一个符合开闭原则的有趣解决方案，它依赖于使用`__subclasses__()`魔法方法来发现所有可能的事件类型，并使用正确的事件处理数据，通过每个类封装的方法来解决问题。

这个解决方案符合我们的需求，并且相当灵活，但正如我们将看到的，这种设计模式将带来额外的优势。

这里的想法是我们将以稍微不同的方式创建事件。每个事件仍然具有确定是否可以处理特定日志行的逻辑，但它还将有一个`successor`。这个`successor`是一个新的事件，是队列中的下一个事件，如果第一个事件无法处理文本行，它将继续处理文本行。逻辑很简单——我们链式地连接事件，每个事件都尝试处理数据。如果它可以，它就返回结果。如果它不能，它将传递给它的`successor`并重复，如下面的代码所示：

```py
import re
from typing import Optional, Pattern
class Event:
    pattern: Optional[Pattern[str]] = None
    def __init__(self, next_event=None):
        self.successor = next_event
    def process(self, logline: str):
        if self.can_process(logline):
            return self._process(logline)
        if self.successor is not None:
            return self.successor.process(logline)
    def _process(self, logline: str) -> dict:
        parsed_data = self._parse_data(logline)
        return {
            "type": self.__class__.__name__,
            "id": parsed_data["id"],
            "value": parsed_data["value"],
        }
    @classmethod
    def can_process(cls, logline: str) -> bool:
        return (
            cls.pattern is not None and cls.pattern.match(logline) is not None
        )
    @classmethod
    def _parse_data(cls, logline: str) -> dict:
        if not cls.pattern:
            return {}
        if (parsed := cls.pattern.match(logline)) is not None:
            return parsed.groupdict()
        return {}
class LoginEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+login\s+(?P<value>\S+)")
class LogoutEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+logout\s+(?P<value>\S+)") 
```

在这个实现中，我们创建`event`对象，并按照它们将要被处理的特定顺序排列。由于它们都具有`process()`方法，它们对于这个消息是多态的，因此它们对齐的顺序对客户端来说是完全透明的，任何一个都是透明的。不仅如此，`process()`方法具有相同的逻辑；它试图提取提供的数据是否适合处理该对象类型的正确信息，如果不是，它将移动到队列中的下一个。

这样，我们可以按照以下方式处理登录事件：

```py
>>> chain = LogoutEvent(LoginEvent())
>>> chain.process("567: login User")
{'type': 'LoginEvent', 'id': '567', 'value': 'User'} 
```

注意`LogoutEvent`如何接收`LoginEvent`作为其后续事件，当它被要求处理它无法处理的事情时，它将重定向到正确的事件。正如我们从字典上的`type`键中可以看到的，`LoginEvent`实际上是创建那个字典的事件。

这个解决方案足够灵活，并且与我们的上一个解决方案有一个有趣的共同点——所有条件都是互斥的。只要没有冲突，并且没有数据块有多个处理程序，以任何顺序处理事件将不会成问题。

但如果我们不能做出这样的假设怎么办？在之前的实现中，我们仍然可以改变根据我们的标准制作的列表中的`__subclasses__()`调用，而且效果会很好。如果我们想运行时（例如，由用户或客户端）确定这种优先级顺序，这将是一个缺点。

新的解决方案允许我们实现这样的要求，因为我们可以在运行时组装这个链，这样我们就可以根据需要动态地操作它。

例如，现在我们添加一个通用类型，将登录和登出会话事件分组，如下面的代码所示：

```py
class SessionEvent(Event):
    pattern = re.compile(r"(?P<id>\d+):\s+log(in|out)\s+(?P<value>\S+)") 
```

如果由于某种原因，在应用程序的某个部分，我们想在登录事件之前捕获它，可以通过以下链来完成：

```py
chain = SessionEvent(LoginEvent(LogoutEvent())) 
```

通过改变顺序，例如，我们可以指定通用会话事件比登录有更高的优先级，但不是登出，等等。

事实上，这个模式与对象一起工作使其比我们之前的实现更加灵活，我们之前的实现依赖于类（虽然在 Python 中它们仍然是对象，但它们并没有完全排除一定程度上的刚性）。

### 模板方法

模板方法模式是一种在正确实现时能带来重要益处的模式。主要的好处是它允许我们重用代码，并且它还使我们的对象更加灵活，更容易更改，同时保持多态性。

理念是存在一个定义某些行为的类层次结构，比如说其公共接口中的一个重要方法。层次结构中的所有类共享一个公共模板，可能只需要更改其某些元素。因此，理念是将这种通用逻辑放在父类的公共方法中，该方法将内部调用所有其他（私有）方法，而这些方法正是派生类将要修改的；因此，模板中的所有逻辑都得到了重用。

聪明的读者可能已经注意到，我们在前面的章节中已经实现了这个模式（作为责任链模式示例的一部分）。请注意，从`Event`派生出的类在其特定模式中只实现了一件事。对于其余的逻辑，模板位于`Event`类中。`process`事件是通用的，依赖于两个辅助方法：`can_process()`和`process()`（它反过来调用`_parse_data()`）。

这些额外的方法依赖于类属性模式。因此，为了扩展这个模式以支持新的对象类型，我们只需创建一个新的派生类并将正则表达式放置其中。之后，其余的逻辑将通过这个新的属性继承过来。这重用了大量的代码，因为处理日志行的逻辑在父类中只定义了一次。

这使得设计更加灵活，因为保持多态性也容易实现。如果我们需要一种新的事件类型，由于某种原因需要以不同的方式解析数据，我们只需在那个子类中重写这个私有方法，并且兼容性将得到保持，只要它返回与原始类型相同的东西（符合 Liskov 替换原则和开闭原则）。这是因为父类正在调用派生类的方法。

如果我们在设计自己的库或框架，这种模式同样很有用。通过这种方式安排逻辑，我们使用户能够非常容易地改变其中一个类的行为。他们需要创建一个子类并重写特定的私有方法，结果将是一个具有新行为的新对象，这个新行为将保证与原始对象的先前调用者兼容。

### 命令

命令模式为我们提供了将需要执行的操作与其请求时刻的实际执行时刻分离的能力。不仅如此，它还可以将客户端发出的原始请求与其接收者分离，接收者可能是一个不同的对象。在本节中，我们将主要关注模式的第一个方面：我们可以将命令的执行方式与其实际执行时刻分离的事实。

我们知道可以通过实现`__call__()`魔法方法来创建可调用的对象，所以我们只需初始化对象，然后稍后调用它。实际上，如果这是唯一的要求，我们甚至可以通过一个嵌套函数来实现这一点，该函数通过闭包创建另一个函数，以达到延迟执行的效果。但这个模式可以被扩展到更难以实现的目的。

这个想法是命令也可能在其定义之后被修改。这意味着客户端指定要运行的命令，然后其中的一些参数可能会被更改，添加更多选项，等等，直到有人最终决定执行动作。

这种例子可以在与数据库交互的库中找到。例如，在`psycopg2`（一个`PostgreSQL`客户端库）中，我们建立了一个连接。从这一点，我们得到一个游标，并且可以向这个游标传递一个`SQL`语句来执行。当我们调用`execute`方法时，对象的内部表示会发生变化，但实际上在数据库中并没有执行任何操作。只有在调用`fetchall()`（或类似的方法）时，数据才会被查询并可在游标中获取。

在流行的**对象关系映射器 SQLAlchemy**（**ORM SQLAlchemy**）中，同样会发生这种情况。查询是通过几个步骤定义的，一旦我们有了`query`对象，我们仍然可以与之交互（添加或删除过滤器、更改条件、申请排序等），直到我们决定需要查询的结果。在调用每个方法后，`query`对象会改变其内部属性并返回`self`（自身）。

这些是我们想要实现的行为的类似例子。创建这种结构的一个非常简单的方法是拥有一个对象，该对象存储要运行的命令的参数。之后，它还必须提供与这些参数交互的方法（添加或删除过滤器等）。可选地，我们可以向该对象添加跟踪或日志功能以审计正在进行的操作。最后，我们需要提供一个实际执行动作的方法。这个方法可以是`__call__()`或自定义的。让我们称它为`do()`。

当我们处理异步编程时，这个模式可能很有用。正如我们所看到的，异步编程有语法上的细微差别。通过将命令的准备与执行分离，我们可以使前者仍然具有同步形式，而后者具有异步语法（假设这部分需要异步运行，例如，如果我们正在使用库连接到数据库）。

### 状态

状态模式是软件设计中具体化的一个明显例子，它将我们的领域问题的概念明确化为一个对象，而不是仅仅是一个辅助值（例如，使用字符串或整数标志来表示值或管理状态）。

在*第八章*，*单元测试和重构*中，我们有一个表示`merge`请求的对象，并且它有一个与之关联的状态（例如`open`、`closed`等）。我们使用枚举来表示这些状态，因为那时它们只是持有值的（特定状态的字符串表示）数据。如果它们需要具有某些行为，或者整个`merge`请求必须根据其状态和转换执行某些操作，这就不够了。

我们向代码的一部分添加行为、运行时结构的事实，迫使我们从对象的角度思考，因为毕竟这就是对象应该做的事情。现在，状态不能仅仅是一个带有字符串的枚举；它需要是一个对象。

假设我们必须向`merge`请求添加一些规则，比如当它从`open`转换为`closed`时，所有批准都会被移除（他们将不得不再次审查代码）——并且当`merge`请求刚刚打开时，批准的数量设置为零（无论它是重新打开的还是全新的`merge`请求）。另一个规则可能是，当`merge`请求合并时，我们希望删除源分支，当然，我们希望禁止用户执行无效的转换（例如，已关闭的`merge`请求不能合并，等等）。

如果我们将所有这些逻辑放入一个地方，即在`MergeRequest`类中，我们最终会得到一个具有许多职责（这是设计不良的迹象）的类，可能有很多方法，以及大量的`if`语句。这将很难跟踪代码并理解哪一部分应该代表哪个业务规则。

将其分布到更小的对象中会更好，每个对象都有更少的职责，状态对象是这种分布的好地方。我们为每种我们想要表示的状态创建一个对象，并在它们的方法中放置上述规则的转换逻辑。然后`MergeRequest`对象将有一个状态协作者，这反过来也将了解`MergeRequest`（需要双重分发机制来在`MergeRequest`上运行适当的操作并处理转换）。

我们定义一个包含要实现的方法的基抽象类，然后为每个我们想要表示的特定`state`创建一个子类。然后`MergeRequest`对象将所有操作委托给`state`，如下面的代码所示：

```py
class InvalidTransitionError(Exception):
    """Raised when trying to move to a target state from an unreachable 
    Source
    state.
    """
class MergeRequestState(abc.ABC):
    def __init__(self, merge_request):
        self._merge_request = merge_request
    @abc.abstractmethod
    def open(self):
        ...
    @abc.abstractmethod
    def close(self):
        ...
    @abc.abstractmethod
    def merge(self):
        ...
    def __str__(self):
        return self.__class__.__name__
class Open(MergeRequestState):
    def open(self):
        self._merge_request.approvals = 0
    def close(self):
        self._merge_request.approvals = 0
        self._merge_request.state = Closed
    def merge(self):
        logger.info("merging %s", self._merge_request)
        logger.info(
            "deleting branch %s", 
            self._merge_request.source_branch
        )
        self._merge_request.state = Merged
class Closed(MergeRequestState):
    def open(self):
        logger.info(
            "reopening closed merge request %s", 
            self._merge_request
        )
        self._merge_request.state = Open
    def close(self):
        """Current state."""
    def merge(self):
        raise InvalidTransitionError("can't merge a closed request")
class Merged(MergeRequestState):
    def open(self):
        raise InvalidTransitionError("already merged request")
    def close(self):
        raise InvalidTransitionError("already merged request")
    def merge(self):
        """Current state."""
class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self.source_branch = source_branch
        self.target_branch = target_branch
        self._state = None
        self.approvals = 0
        self.state = Open
    @property
    def state(self):
        return self._state
    @state.setter
    def state(self, new_state_cls):
        self._state = new_state_cls(self)
    def open(self):
        return self.state.open()
    def close(self):
        return self.state.close()
    def merge(self):
        return self.state.merge()
    def __str__(self):
        return f"{self.target_branch}:{self.source_branch}" 
```

以下列表概述了一些关于实现细节和应做出的设计决策的澄清：

+   `state`是一个属性，因此它不仅是`public`的，而且还有一个单独的地方定义了如何为`merge`请求创建状态，传递`self`作为参数。

+   抽象基类不是必需的，但拥有它有一些好处。首先，它使我们所处理的对象类型更加明确。其次，它强制每个子状态实现接口的所有方法。有另外两种选择：

    +   我们本可以不编写这些方法，当尝试执行无效操作时让`AttributeError`抛出，但这并不正确，并且它没有表达出实际发生的情况。

    +   与这一点相关的是，我们本可以使用一个简单的基类并留那些方法为空，但这样默认的不执行任何操作的行为并没有使它更清楚应该发生什么。如果子类中的某个方法应该不执行任何操作（例如合并的情况），那么最好让空方法就那样放着，并明确指出对于那个特定的情况，不应该执行任何操作，而不是强迫所有对象执行那个逻辑。

+   `MergeRequest`和`MergeRequestState`之间存在关联。一旦发生转换，前一个对象将不会有额外的引用并且应该被垃圾回收，因此这种关系应该是始终为 1:1。经过一些小的和更详细的考虑，可以使用弱引用。

以下代码展示了如何使用对象的示例：

```py
>>> mr = MergeRequest("develop", "mainline") 
>>> mr.open()
>>> mr.approvals
0
>>> mr.approvals = 3
>>> mr.close()
>>> mr.approvals
0
>>> mr.open()
INFO:log:reopening closed merge request mainline:develop
>>> mr.merge()
INFO:log:merging mainline:develop
INFO:log:deleting branch develop
>>> mr.close()
Traceback (most recent call last):
...
InvalidTransitionError: already merged request 
```

转换状态的操作委托给`state`对象，这是`MergeRequest`始终持有的（这可以是`ABC`的任何子类）。它们都知道如何以不同的方式响应相同的消息，因此这些对象将采取与每个转换相对应的适当行动（删除分支、引发异常等），然后移动`MergeRequest`到下一个状态。

由于`MergeRequest`将所有操作委托给其`state`对象，我们会发现这通常发生在它需要执行的操作形式为`self.state.open()`等情况下。我们能移除一些那些样板代码吗？

我们可以通过`__getattr__()`来实现，如下面的代码所示：

```py
class MergeRequest:
    def __init__(self, source_branch: str, target_branch: str) -> None:
        self.source_branch = source_branch
        self.target_branch = target_branch
        self._state: MergeRequestState
        self.approvals = 0
        self.state = Open
    @property
    def state(self) -> MergeRequestState:
        return self._state
    @state.setter
    def state(self, new_state_cls: Type[MergeRequestState]):
        self._state = new_state_cls(self)
    @property
    def status(self):
        return str(self.state)
    def __getattr__(self, method):
        return getattr(self.state, method)
    def __str__(self):
        return f"{self.target_branch}:{self.source_branch}" 
```

在代码中实现这些类型的通用重定向时要小心，因为这可能会损害可读性。有时，有一些小的样板代码，但明确说明我们的代码做什么会更好。

一方面，我们重用了一些代码并去除了重复的行，这是好事。这使抽象基类更有意义。在某个地方，我们希望记录所有可能的行为，并列在单一位置。那个地方曾经是`MergeRequest`类，但现在那些方法已经消失了，所以唯一剩下的真理来源是`MergeRequestState`。幸运的是，`state`属性的类型注解对用户来说非常有帮助，知道在哪里查找接口定义。

用户可以简单地看一下，就会看到`MergeRequest`没有的任何东西都会询问其`state`属性。从`init`定义中，注解会告诉我们这是一个`MergeRequestState`类型的对象，通过查看这个接口，我们会看到我们可以安全地调用其上的`open()`、`close()`和`merge()`方法。

# 空对象模式

空对象模式是一个与本书前几章提到的良好实践相关联的想法。在这里，我们对其进行了正式化，并为此想法提供了更多的背景分析和解释。

原则相当简单——函数或方法必须返回一致类型的对象。如果这一点得到保证，那么我们代码的客户就可以使用返回的对象，并以多态的方式使用它们，而无需对它们进行额外的检查。

在前面的例子中，我们探讨了 Python 的动态特性如何使大多数设计模式变得更加容易。在某些情况下，它们完全消失，在其他情况下，它们更容易实现。设计模式的主要目标，正如最初所设想的那样，是方法或函数不应明确命名它们需要以工作的对象类。因此，它们提出了创建接口和重新排列对象的方法，以便使它们符合这些接口，从而修改设计。但在 Python 中，大多数时候这并不是必需的，我们只需传递不同的对象，只要它们尊重必须有的方法，解决方案就会有效。

另一方面，对象不一定必须遵守接口的事实要求我们更加小心地对待从这些方法和函数返回的事物。就像我们的函数没有对其接收的内容做出任何假设一样，我们有理由假设我们的代码的客户也不会做出任何假设（这是我们的责任，提供兼容的对象）。这可以通过契约设计来强制或验证。在这里，我们将探讨一个简单的模式，这将帮助我们避免这类问题。

考虑到在前一节中探讨的责任链设计模式。我们看到了它的灵活性及其许多优点，例如将责任分解为更小的对象。它存在的问题之一是我们实际上永远不知道哪个对象最终会处理消息，如果有的话。特别是，在我们的例子中，如果没有合适的对象来处理日志行，那么该方法将简单地返回`None`。

我们不知道用户会如何使用我们传递的数据，但我们确实知道他们期望的是一个字典。因此，可能会发生以下错误：

```py
AttributeError: 'NoneType' object has no attribute 'keys' 
```

在这种情况下，修复方法相当简单——`process()`方法的默认值应该是一个空字典而不是`None`。

确保你返回的是一致类型的对象。

但如果该方法没有返回字典，而是返回了我们领域中的自定义对象呢？

为了解决这个问题，我们应该有一个表示该对象空状态的类，并返回它。如果我们有一个表示系统中用户的类，以及一个通过`ID`查询用户的函数，那么在找不到用户的情况下，它应该做以下两件事之一：

+   抛出异常

+   返回`UserUnknown`类型的对象

但在任何情况下都不应该返回`None`。`None`这个短语并不代表刚刚发生的事情，调用者可能会合法地尝试调用它的方法，这将导致`AttributeError`。

我们之前已经讨论过异常及其优缺点，因此我们应该提到，这个`null`对象应该只拥有与原始用户相同的方法，并且对每一个方法都不做任何事情。

使用这种结构的优点是，我们不仅避免了运行时错误，而且这个对象可能是有用的。它可以使代码更容易测试，甚至可以，例如，帮助调试（我们可能需要在方法中添加日志记录，以了解为什么达到那种状态，提供了哪些数据，等等）。

通过利用 Python 几乎所有的魔法方法，我们可以创建一个通用的`null`对象，它绝对什么也不做，无论怎样调用它，但可以从几乎任何客户端调用。这样的对象会稍微类似于一个`Mock`对象。由于以下原因，不建议走这条路：

+   它与领域问题失去了意义。回到我们的例子中，有一个`UnknownUser`类型的对象是有意义的，并且给调用者一个清晰的印象，即查询出了问题。

+   它不尊重原始接口。这是问题所在。记住，目标是`UnknownUser`是一个用户，因此它必须具有相同的方法。如果调用者意外地请求一个不存在的方法，那么在这种情况下，它应该抛出一个`AttributeError`异常，这将很好。如果我们选择创建一个具有`spec=User`的`Mock`对象，那么这种异常就会被捕获，但再次强调，使用`Mock`对象来表示实际上是一个空状态，这与我们提供清晰、易懂代码的意图不符。

这种模式是一种良好的实践，它允许我们在对象中保持多态性。

# 关于设计模式的最后思考

我们已经看到了 Python 中的设计模式世界，在这个过程中，我们找到了解决常见问题的方法，以及更多有助于我们实现清晰设计的技巧。

所有这些都听起来很好，但它提出了一个问题：设计模式有多好？有些人认为它们弊大于利，认为它们是为那些有限类型系统（以及缺乏一等函数）的语言而创建的，这使得我们无法完成在 Python 中通常能做的事情。另一些人声称，设计模式强迫采用一种设计方案，从而产生一些偏见，限制了本应出现的、更好的设计方案。让我们逐一审视这些观点。

## 模式对设计的影响

一个设计模式本身不能说是好是坏，而是取决于它的实现方式或使用方式。在某些情况下，当有更简单的解决方案时，并不需要设计模式。试图将模式强加在不适合的地方，就是过度设计，这显然是错误的，但这并不意味着设计模式本身有问题，而且在这些场景中，问题甚至可能根本与模式无关。有些人试图过度设计一切，因为他们不理解灵活和适应性软件的真正含义。

正如我们在本书前面提到的，编写好软件不是关于预测未来需求（进行未来学是没有意义的），而是仅仅解决我们现在手头的问题，以一种不会阻止我们在未来对其进行更改的方式。它现在不需要处理这些变化；它只需要足够灵活，以便将来可以进行修改。当未来来临时，我们仍然需要记住在提出通用解决方案或适当的抽象之前，必须记住三个或更多相同问题的规则。

这通常是设计模式应该出现的地方，一旦我们正确地识别了问题，能够识别模式并相应地进行抽象。

让我们回到模式对语言的适用性这个话题。正如我们在本章引言中所说，设计模式是高级思想。它们通常指的是对象及其交互的关系。很难想象这些事情可能会从一个语言消失到另一个语言。

诚然，有些模式在 Python 中可能需要更少的工作，比如迭代器模式（正如在本书前面详细讨论的那样，它是 Python 内置的），或者策略模式（因为，相反，我们只需像传递任何其他常规对象一样传递函数；我们不需要将策略方法封装到对象中，因为函数本身就是这个对象）。

但其他模式实际上是需要的，并且它们确实解决了问题，就像装饰器和组合模式的情况一样。在其他情况下，Python 本身实现了某些设计模式，我们只是没有总是看到它们，就像我们在本章前面讨论的外观模式一样。

至于我们的设计模式可能将我们的解决方案引向错误的方向，我们必须在这里小心。再一次，如果我们从考虑领域问题并创建正确的抽象开始设计我们的解决方案，然后看看是否有一个设计模式从那个设计中浮现出来，那就更好了。假设它确实如此。这是坏事吗？我们试图解决的问题已经有了现成的解决方案，这并不是坏事。在我们这个领域，重新发明轮子的情况很多，这是坏事。此外，我们正在应用一个模式，一个已经被证明和验证过的模式，这应该让我们对我们所构建的质量更有信心。

## 设计模式作为理论

我认为设计模式是一种软件工程理论。虽然我同意代码越自然地演变越好这个观点，但这并不意味着我们应该完全忽视设计模式。

设计模式之所以存在，是因为没有必要重新发明轮子。如果已经有一个针对特定类型问题的解决方案，那么在我们规划设计时思考这个想法可以节省我们一些时间。从这个意义上讲（以及为了重新引用第一章中的类比），我喜欢将设计模式类比为棋局的开局：职业棋手在游戏的早期阶段不会考虑每一个组合。这是理论。它已经被研究了。这与数学或物理公式是一样的。你应该第一次就深入理解它，知道如何推断它，并吸收其含义，但之后就没有必要反复发展这个理论了。

作为软件工程的从业者，我们应该利用设计模式的理论来节省脑力并更快地提出解决方案。不仅如此，设计模式应该成为不仅是语言，也是构建模块。

## 模型中的名称

我们是否应该在代码中提及我们正在使用设计模式？

如果设计良好且代码整洁，它应该能够自我表达。出于以下几个原因，不建议你根据你正在使用的设计模式来命名：

+   我们代码的使用者和其他开发者不需要了解代码背后的设计模式，只要它能按预期工作即可。

+   陈述设计模式破坏了意图揭示原则。将设计模式的名称添加到类中会使它失去部分原始含义。如果一个类代表一个查询，它应该被命名为`Query`或`EnhancedQuery`，这应该揭示该对象预期要做什么。`EnhancedQueryDecorator`没有任何意义，而`Decorator`后缀比清晰度更造成混淆。

在文档字符串中提及设计模式可能是可以接受的，因为它们充当文档，在我们的设计中表达设计思想（再次，沟通）是好事。然而，这并不是必需的。尽管如此，大多数时候，我们并不需要知道设计模式的存在。

最好的设计是那些设计模式对用户完全透明的。一个例子是外观模式在标准库中的出现，它使得用户对如何访问`os`模块的方式完全透明。一个更加优雅的例子是迭代器设计模式被语言完全抽象化，以至于我们甚至不需要考虑它。

# 摘要

设计模式一直被视为解决常见问题的有效方案。这是一个正确的评估，但在这章中，我们从良好的设计技术角度探讨了它们，这些模式利用了整洁的代码。在大多数情况下，我们研究了它们如何提供良好的解决方案来保持多态性、减少耦合，并创建所需的正确抽象来封装细节——所有这些都与第八章中探讨的概念相关，即单元测试和重构。

尽管如此，设计模式最吸引人的地方并不是应用它们所能获得的整洁设计，而是扩展的词汇量。作为沟通工具，我们可以用它们的名称来表达我们设计的意图。有时，我们并不需要应用整个模式，而可能只需要从我们的解决方案中提取模式的一个特定想法（例如，一个子结构），在这里，它们也证明是更有效地沟通的一种方式。

当我们以模式为思考方式来创建解决方案时，我们是在更高层次上解决问题。以设计模式为思考方式使我们更接近高级设计。我们可以逐渐“缩小”视野，更多地从架构的角度思考。既然我们现在正在解决更普遍的问题，那么是时候开始思考系统将如何长期演变和维护了（如何扩展、变化、适应等等）。

为了实现这些目标，一个软件项目需要在核心上拥有整洁的代码，同时架构也必须是整洁的，这就是我们将在下一章中探讨的内容。

# 参考文献

这里有一份您可以参考的信息列表：

+   *GoF*：由*艾里希·伽玛*、*理查德·赫尔姆*、*拉尔夫·约翰逊*和*约翰·弗利西斯*合著的《设计模式：可复用面向对象软件元素》一书

+   *SNGMONO*：由*罗伯特·C·马丁*于 2002 年撰写的一篇文章，名为*单例和单态*：[`staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf`](http://staff.cs.utu.fi/~jounsmed/doos_06/material/SingletonAndMonostate.pdf)

+   *空对象模式*，由*博比·伍尔夫*撰写
