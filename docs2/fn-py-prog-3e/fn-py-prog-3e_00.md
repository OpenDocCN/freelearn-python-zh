## 前言

函数式编程提供了一系列创建简洁和表达性软件的技术。虽然 Python 不是一个纯粹的函数式编程语言，但我们可以在 Python 中进行大量的函数式编程。

Python 拥有一组核心的函数式编程特性。这使得我们可以从其他函数式语言中借用许多设计模式和技巧。这些借用的概念可以引导我们创建优雅的程序。特别是 Python 的生成器表达式，它否定了创建大型内存数据结构的需要，导致程序可能执行得更快，因为它们使用的资源更少。

在 Python 中，我们无法轻松地创建纯函数式程序。Python 缺乏实现这一目标所需的一些特性。例如，我们没有无限的递归，我们没有对所有表达式的惰性求值，我们也没有优化编译器。

Python 中提供了函数式编程语言的一些关键特性。其中之一是函数作为一等对象的理念。Python 还提供了一些高阶函数。内置的 `map()`、`filter()` 和 `functools.reduce()` 函数在此角色中广泛使用，而像 `sorted()`、`min()` 和 `max()` 这样的函数则不那么明显。

在某些情况下，对问题的函数式方法也会导致极高的性能算法。Python 使得创建大型中间数据结构变得过于容易，这会占用内存（和处理时间）。使用函数式编程设计模式，我们通常可以用占用内存更少且运行速度更快的生成器表达式来替换大型列表。

我们将从 Python 视角来探讨函数式编程的核心特性。我们的目标是借鉴函数式编程语言中的好思想，并使用这些思想在 Python 中创建表达性和简洁的应用程序。

### 本书面向对象

本书面向那些希望通过从函数式编程语言中借用技术和设计模式来创建简洁、表达性强的 Python 程序的更有经验的程序员。某些算法可以用函数式风格优雅地表达；我们可以——并且应该——将这些思想应用到使 Python 程序更易于阅读和维护。

这本书并不是作为 Python 教程编写的。本书假设读者对语言和标准库有一定的了解。对于 Python 的基础介绍，可以考虑学习《Python 编程学习指南》第三版：[`www.packtpub.com/product/learn-python-programming-third-edition/9781801815093`](https://www.packtpub.com/product/learn-python-programming-third-edition/9781801815093)。

虽然我们涵盖了函数式编程的基础，但这并不是对各种函数式编程技术的全面回顾。在另一种语言中接触过函数式编程可能会有所帮助。

### 本书涵盖内容

我们可以将这本书分解为两大类主题：

+   Python 中函数式编程的精华。这是第一章到第七章的内容。

+   帮助创建函数式程序的库模块。这是本书剩余章节的主题。第十二章包括基本语言和库主题。

第一章，理解函数式编程，介绍了表征函数式编程的一些技术。我们将确定一些将这些特性映射到 Python 的方法。我们还将讨论使用这些设计模式构建 Python 应用程序时，函数式编程的好处是如何积累的。

第二章，介绍核心函数式编程概念，深入探讨了函数式编程范式的核心特性。我们将逐一详细探讨它们在 Python 中的实现方式。我们还将指出一些不适用于 Python 的函数式语言特性。特别是，许多函数式语言都有复杂的类型匹配规则，这些规则是支持编译和优化的必要条件。

第三章，函数、迭代器和生成器，将展示如何利用不可变 Python 对象，以及如何将生成器表达式适应 Python 语言中的函数式编程概念。我们将探讨一些内置的 Python 集合，以及我们如何在不偏离函数式编程概念太远的情况下利用它们。

第四章，使用集合，展示了如何使用多个内置 Python 函数来操作数据集合。本章将重点介绍一些相对简单的函数，如`any()`和`all()`，这些函数可以将值集合缩减为单个结果。

第五章，高阶函数，探讨了常用的诸如`map()`和`filter()`等高阶函数。它还展示了一些其他的高阶函数，以及我们如何创建与函数一起工作或返回函数的自定义函数。

第六章，递归和归约，教授如何设计使用递归的算法，并将其优化为高性能的`for`语句。我们还将探讨一些其他广泛使用的归约方法，包括`collections.Counter()`。

第七章, 复杂无状态对象, 展示了我们可以使用不可变元组、`typing.NamedTuple` 和冻结的 `@dataclass` 来替代有状态对象的一些方法。我们还将探讨 `pyrsistent` 模块作为创建不可变对象的一种方式。不可变对象比有状态对象具有更简单的接口：我们永远不必担心滥用属性并将对象设置到某种不一致或无效的状态。

第八章, 迭代工具模块，检查了 `itertools` 标准库模块中的多个函数。这个函数集合简化了处理集合或生成器函数的程序编写。

第九章, 组合学中的迭代工具 – 排列和组合, 讲述了 `itertools` 模块中的组合学函数。这些函数比上一章中的函数更专业。本章包括一些示例，说明了这些函数使用不当以及组合爆炸的后果。

第十章, Functools 模块，专注于如何使用 `functools` 模块中的某些函数进行函数式编程。该模块中的一些函数更适合构建装饰器，它们被留到 第十二章, 装饰器设计技巧 中讨论。

第十一章, Toolz 包，涵盖了 `toolz` 包，这是一系列紧密相关的模块，帮助我们用 Python 编写函数式程序。`toolz` 模块与内置的 `itertools` 和 `functools` 模块并行，提供了一些更复杂且更好地利用柯里化函数的替代方案。

第十二章, 装饰器设计技巧，介绍了我们可以将装饰器视为构建复合函数的一种方式。虽然这里有很大的灵活性，但也存在一些概念上的限制：我们将探讨过于复杂的装饰器可能会变得令人困惑而不是有帮助的方法。

第十三章, PyMonad 库，探讨了 PyMonad 库的一些特性。这提供了一些额外的函数式编程特性。它还提供了一种学习更多关于单子的方法。在某些函数式语言中，单子是强制操作以特定顺序执行的重要方式，这些操作可能会被优化成不希望执行的顺序。由于 Python 已经具有严格的表达式和语句顺序，因此单子特性更具有教育意义而不是实用性。

第十四章，Multiprocessing、Threading 和 Concurrent.Futures 模块，指出良好函数式设计的一个重要后果：我们可以分配处理工作负载。使用不可变对象意味着我们不会因为同步写入操作不当而损坏对象。

第十五章，面向 Web 服务的函数式方法，展示了我们可以如何将 Web 服务视为一个嵌套的函数集合，这些函数将请求转换为响应。我们将看到如何利用函数式编程的概念来构建响应式、动态的 Web 内容。

第十六章，卡方案例研究，是一个额外的、仅在网络上提供的案例研究，它将多种函数式编程技术应用于特定的探索性数据分析问题。我们将对一些复杂数据进行χ²统计测试，以查看结果是否显示普通变异性，或者是否表明需要更深入分析的情况。你可以在这里找到案例研究：[`github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition/blob/main/Bonus_Content/Chapter_16.pdf`](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition/blob/main/Bonus_Content/Chapter_16.pdf)。

### 为了充分利用这本书

本书假设读者对 Python 3 和应用程序开发的一般概念有所了解。我们不会深入研究 Python 的微妙或复杂特性；我们将避免过多地考虑语言的内部结构。

一些示例使用探索性数据分析（EDA）作为问题领域来展示函数式编程的价值。对基本概率和统计学的了解将有助于理解这一点。只有少数示例涉及到更深入的数据科学。

需要 Python 3.10。示例也已在 Python 3.11 上进行了测试，并且运行正确。出于数据科学的目的，通常建议从 conda 工具开始创建和管理虚拟环境。然而，这并非必需，读者应该能够使用任何可用的 Python。

通常使用 pip 安装额外的包。命令看起来像这样：

```py

 % python -m pip install toolz pymonad pyrsistent beautifulsoup4
```

#### 完成练习

每章都包含一些练习，帮助读者将章节中的概念应用到实际代码中。大多数练习基于 GitHub 上本书的存储库中的代码：[`github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition`](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。

在某些情况下，读者会注意到 GitHub 上提供的代码包含一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。

在许多情况下，练习需要单元测试用例来确认它们确实解决了问题。这些通常与 GitHub 存储库中已提供的单元测试用例相同。读者应将书籍的示例函数名替换为自己的解决方案，以确认其工作正常。

在某些情况下，练习建议编写一个响应文档来比较和对比多个解决方案。找到一位导师或专家，通过审查这些小文档的清晰度和完整性来帮助读者。一个好的设计方法比较将包括使用`timeit`模块进行性能测量，以展示一个设计相对于另一个设计的性能优势。

#### 下载示例代码文件

书籍的代码包托管在 GitHub 上，网址为[`github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition`](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。我们还有其他来自我们丰富图书和视频目录的代码包，可在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。查看它们吧！

#### 下载彩色图像

我们还提供了一份包含本书中使用的截图/图表的彩色图像的 PDF 文件。您可以从这里下载：[`packt.link/OV1CB`](https://packt.link/OV1CB)。

### 使用的约定

本书使用了多种文本约定。

`CodeInText`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。例如：“Python 有其他语句，如`global`或`nonlocal`，它们会修改特定命名空间中变量的规则。”

粗体：表示新术语、重要单词或您在屏幕上看到的单词，例如在菜单或对话框中。例如：“基本案例说明零长度序列的和是 0。递归案例说明序列的和是第一个值加上序列其余部分的和。”

代码块设置如下：

```py
print("Hello, World!")
```

任何命令行输入或输出都写作如下：

```py

 % conda create -n functional3 python=3.10
```

警告或重要提示看起来像这样。

小贴士和技巧看起来像这样。

### 联系我们

我们始终欢迎读者的反馈。

一般反馈：请通过电子邮件 feedback@packtpub.com 发送反馈，并在邮件主题中提及书籍标题。如果您对本书的任何方面有疑问，请通过电子邮件 questions@packtpub.com 联系我们。

错误更正：尽管我们已经尽最大努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们非常感谢您能向我们报告。请访问[`subscription.packtpub.com/help`](https://subscription.packtpub.com/help)，点击提交错误按钮，搜索您的书籍，并输入详细信息。

侵权：如果您在互联网上以任何形式发现我们作品的非法副本，如果您能提供位置地址或网站名称，我们将不胜感激。请通过版权@packtpub.com 与我们联系，并提供材料的链接。

如果您有兴趣成为作者：如果您在某个领域有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[`authors.packtpub.com`](http://authors.packtpub.com)。

### 分享您的想法

一旦您阅读了《Python 函数式编程》第三版，我们非常乐意听到您的想法！扫描下面的二维码直接进入此书的亚马逊评论页面并分享您的反馈。

![PIC](img/file2.png)

[`packt.link/r/1803232579`](https://packt.link/r/1803232579)

您的评论对我们和科技社区非常重要，并将帮助我们确保我们提供高质量的内容。

### 下载本书的免费 PDF 副本

感谢您购买此书！

您喜欢在路上阅读，但无法随身携带您的印刷书籍吗？您的电子书购买是否与您选择的设备不兼容？

不用担心，现在每购买一本 Packt 书籍，您都可以免费获得该书的 DRM 免费 PDF 版本。

在任何地方、任何设备上阅读。直接从您喜欢的技术书籍中搜索、复制和粘贴代码到您的应用程序中。

优惠不会就此停止，您还可以获得独家折扣、时事通讯和每日免费内容的每日电子邮件。

按照以下简单步骤获取优惠：

1.  扫描下面的二维码或访问下面的链接

    ![PIC](img/file3.png)

    [`packt.link/free-ebook/9781803232577`](https://packt.link/free-ebook/9781803232577)

1.  提交您的购买证明

1.  就这样！我们将直接将您的免费 PDF 和其他优惠发送到您的电子邮件。
