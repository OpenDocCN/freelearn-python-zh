# 第一章. 我们的间谍工具包

间谍的工作是收集和分析数据。这要求我们使用计算机和软件工具。

普通的桌面工具（文字处理器、电子表格等）无法满足我们需要应对的工作类型。对于严肃的数据收集、分析和传播，我们需要更强大的工具。当我们考虑自动化数据收集时，我们无法轻易使用需要手动点击的桌面工具。我们希望有一个可以自主运行为我们工作的工具，而不需要有人在桌前操作。

我们可以使用的最强大的数据分析工具之一是 Python。我们将通过一系列使用 Python 进行实际数据收集和分析的示例来逐步介绍。本章将涵盖以下主题：

+   首先，我们将下载并安装最新的 Python 版本。

+   我们将在后续章节中用`easy_install`（或`pip`）工具来补充 Python，帮助我们收集额外的软件工具。

+   我们将简要地查看 Python 的内部帮助系统。

+   我们将探讨 Python 如何处理数字。毕竟，特工收集数据的工作将涉及数字。

+   我们将花一些时间来学习编写 Python 应用程序的第一步。我们将把我们的应用程序称为脚本以及模块。

+   我们将把文件输入和输出分成几个部分。我们将有一个快速概述，以及深入查看 ZIP 存档文件。在后续章节中，我们将查看更多类型的文件。

+   我们的大任务是应用我们的技能来恢复 ZIP 文件的丢失密码。这不会很容易，但我们应该已经掌握了足够的基础知识来成功完成。

这将使我们具备足够的 Python 技能，以便我们可以在下一章中进入更复杂的任务。

# 获取行业工具 - Python 3.3

使用 Python 的第一步是将 Python 语言安装到我们的计算机上。如果你的计算机使用 Mac OS X 或 Linux，你可能已经安装了 Python。在撰写本文时，它是 Python 2.7，而不是 3.3。在这种情况下，我们除了已经安装的 Python 2.7 之外，还需要安装 Python 3.3。

Windows 特工通常没有 Python 的任何版本，需要安装 Python 3.3。

### 小贴士

Python 3 不是“Python 2.7 加上一些特性”。Python 3 是一种独立的语言。本书不涵盖 Python 2.7。示例在 Python 2 中真的无法工作。

Python 下载可在[`www.python.org/download/`](http://www.python.org/download/)找到。

找到适合你计算机的正确版本。Windows、Linux 和 Mac OS X 有许多预构建的二进制文件。Linux 特工应关注适合其发行版的二进制文件。每个下载和安装都会略有不同；我们无法涵盖所有细节。

Python 有几种实现方式。我们将关注 CPython。对于某些任务，你可能想看看 Jython，它是使用 Java 虚拟机实现的 Python。如果你在使用其他 .NET 产品，你可能需要 Iron Python。在某些情况下，你可能对 PyPy 感兴趣，它是用 Python 实现的 Python。（是的，这似乎是循环和矛盾的。它真的很有趣，但超出了我们的关注范围。）

Python 不仅仅是一个工具。它是起点。在后面的章节中，我们将下载额外的工具。似乎我们作为秘密特工的工作有一半是寻找解决特定复杂问题所需的工具。另一半则是获取信息。

## Windows 的秘密

为你的 Windows 版本下载 Python 3.3（或更高版本）的安装程序。当你运行安装程序时，你将需要回答一系列关于安装位置和安装内容的问题。

确保将 Python 安装在具有简单名称的目录中。在 Windows 中，常见的选项是 `C:\Python33`。使用名称中包含空格的 Windows 目录（如 `Program Files`、`My Documents` 或 `Documents and Settings`）可能会导致混淆。

一定要安装 Tcl/Tk 组件。这将确保你拥有支持 IDLE 所需的所有元素。**IDLE** 是 Python 附带的方便的文本编辑器。对于 Windows 用户，这通常包含在安装包中。你只需要确保在安装向导中勾选了它。

在 Windows 系统中，`python.exe` 程序的名称中不包含版本号，这是不寻常的。

## Mac OS X 的秘密

在 Mac OS X 中，已经有一个 Python 安装，通常是 Python 2.7。这必须保持完整。

下载适用于 Mac OS X 的 Python 3.3（或更高版本）安装程序。当你运行这个程序时，你将添加 Python 的第二个版本。这意味着许多附加模块和工具必须与 Python 的正确版本相关联。这需要一点小心。使用模糊命名的工具如 `easy_install` 并不好。重要的是使用更具体的 `easy_install-3.3`，它可以识别你正在使用的 Python 版本。

命名为 `python` 的程序通常是一个指向 `python2.7` 的别名。这也必须保持完整。在这本书中，我们始终会明确使用 `python3`（也称为 `python3.3`）。你可以通过使用 shell 命令来确认这一点。

注意，Mac OS X 有几个版本的 Tcl/Tk 可用。Python 网站会指导你到特定的版本。在撰写本文时，这个版本是 ActiveTCL 8.5.14，来自 ActiveState 软件。你也需要安装这个版本。这款软件允许我们使用 IDLE。

访问 [`www.activestate.com/activetcl/downloads`](http://www.activestate.com/activetcl/downloads) 获取正确的版本。

# 获取更多工具 – 文本编辑器

要创建 Python 应用程序，我们需要一个合适的程序员文本编辑器。文字处理器是不够的，因为文字处理器创建的文件太复杂了。我们需要简单的文本。我们强调的是简单性。Python3 在 Unicode 下工作，不需要加粗或斜体内容。（Python 2 与 Unicode 的兼容性不是很好。这也是我们放弃它的原因之一。）

如果你已经使用过文本编辑器或**集成开发环境**（**IDEs**），你可能已经有一个喜欢的。请随意使用它。一些流行的 IDE 支持 Python。

Python 被称为动态语言。在特定上下文中确定哪些名称或关键字是合法的并不总是简单。Python 编译器不执行很多静态检查。IDE 不能轻易地提供一个所有合法替代品的简短列表。一些 IDE 尝试提供逻辑建议，但它们并不一定是完整的。

如果你还没有使用过程序员编辑器（或 IDE），你的第一个任务是找到一个你可以使用的文本编辑器。Python 包含一个名为 IDLE 的编辑器，它易于使用。这是一个很好的开始地方。

Active State Komodo Edit 可能很合适([`komodoide.com/komodo-edit/`](http://komodoide.com/komodo-edit/))。它是商业产品的轻量级版本。它有一些非常巧妙的方式来处理 Python 动态语言方面。

有许多其他的代码编辑器。你的第一个训练任务是找到一个你可以使用的。你将独立完成。我们对你有信心。

## 获取其他开发者工具

大多数 GNU/Linux 代理都有各种 C 编译器和其他开发者工具可用。许多 Linux 发行版已经配置为支持开发者，因此工具已经准备好了。

Mac OS X 代理通常需要 Xcode。从[`developer.apple.com/xcode/downloads/`](https://developer.apple.com/xcode/downloads/)获取它。每个 Mac OS X 代理都应该有这个。

在安装此软件时，请确保还安装了命令行开发者工具。这又是一个比基本 Xcode 下载更大的下载。

Windows 代理通常会发现大多数感兴趣的软件包都有预构建的二进制文件。如果，在极少数情况下，预构建的代码不可用，可能需要使用 Cygwin 等工具。请参阅[`www.cygwin.com`](http://www.cygwin.com)。

## 获取更多 Python 组件的工具

为了有效地简单地下载额外的 Python 模块，我们经常使用一个获取工具的工具。有两种流行的方法可以添加 Python 模块：PIP 和`easy_install`脚本。

要安装`easy_install`，请访问[`pypi.python.org/pypi/setuptools/3.6`](https://pypi.python.org/pypi/setuptools/3.6)。

`setuptools`软件包将包括`easy_install`脚本，我们将使用它来添加 Python 模块。

如果您安装了多个版本的 Python，请确保下载并安装正确的 Python 3.3 版本的 easy install。这意味着您通常将使用 `easy_install-3.3` 脚本来添加新的软件工具。

要安装 PIP，请访问 [`pypi.python.org/pypi/pip/1.5.6`](https://pypi.python.org/pypi/pip/1.5.6)。

我们将在 第三章 *使用隐写术编码秘密信息* 中添加 `Pillow` 包。我们还将添加 `Beautiful Soup` 包在 第四章 *投递点、藏身之处、聚会和巢穴* 中。

Python 3.4 分发应包括 PIP 工具。您不需要单独下载它。

# 确认我们的工具

为了确保我们有一个工作的 Python 工具，最好从命令提示符进行检查。我们将使用命令提示符来完成大部分工作。这涉及最少的开销，并且是与 Python 最直接的联系。

Python 3.3 程序显示一个启动信息，如下所示：

```py
MacBookPro-SLott:Secret Agent's Python slott$ python3
Python 3.3.4 (v3.3.4:7ff62415e426, Feb  9 2014, 00:29:34)
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type help, copyright, credits or license for more information.
>>>
```

我们已经展示了操作系统的提示（`MacBookPro-SLott:Secret Agent's Python slott$`），我们输入的命令（`python3`），以及 Python 的响应。

Python 提供了三条介绍信息，随后是其自己的 `>>>` 提示符。第一行显示它是 Python 3.3.4。第二行显示构建 Python 所使用的工具（GCC 4.2.1）。第三行提供了关于我们可能接下来要做什么的一些提示。

我们已经与 Python 交互。一切正常。

### 小贴士

**下载示例代码**

您可以从您在 [`www.packtpub.com`](http://www.packtpub.com) 的账户下载您购买的所有 Packt 书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [`www.packtpub.com/support`](http://www.packtpub.com/support) 并注册以将文件直接通过电子邮件发送给您。

随意输入 `版权`, `致谢`, 和 `许可` 到 `>>>` 提示符。它们可能很无聊，但它们作为确认事情正在工作的依据。

重要的是要注意，这些对象（`版权`, `致谢`, 和 `许可`）在 Python 语言中不是命令或动词。它们是作为方便首次使用 Python 的代理而创建的全局变量。当评估时，它们会显示文本块。

我们还会使用另外两个启动对象：`exit` 和 `help`。这些提供了一些提示信息，提醒我们使用 `help()` 和 `exit()` 函数。

## 我们该如何停止？

我们可以始终输入 `exit` 来获取如何从交互式 Python 中退出的提示，如下所示：

```py
>>> exit
```

使用 `exit()` 或 *Ctrl* + *D*（即 **EOF** （文件结束标志））来退出。

Windows 代理将看到他们必须使用 *Ctrl* + *Z* 和 `Return` 来退出。

Python 是一种编程语言，它也有一个 `>>>` 的交互式提示符。为了确认 Python 是否工作，我们正在响应那个提示符，使用一个称为 **读取-执行-打印循环** （**REPL**）的功能。

从长远来看，我们将编写脚本来处理我们的数据。我们的数据可能是一张图片或一条秘密信息。脚本文件的结尾将退出 Python。这与按下 *Ctrl* + *D*（或在 Windows 上为 *Ctrl* + *Z* 和 `Return`）发送 EOF 序列相同。

## 使用 help() 系统帮助

Python 有一个帮助模式，它通过 `help()` 函数启动。`help()` 函数提供特定主题的帮助。在 Python 中看到的大部分内容都可以作为帮助的主题。

对于 Python 语法片段，如 `+` 运算符，你需要使用一个字符串表示，你应该在引号中包含语法。例如，`help("+")` 将提供关于运算符优先级的详细帮助。

对于其他对象（如数字、字符串、函数、类和模块），你只需直接在对象本身上请求帮助；不需要使用引号。Python 将定位对象的类并提供关于该类的帮助。

例如，`help(3)` 将提供关于整数的许多详细的技术帮助，如下面的片段所示：

```py
>>> help(3)
Help on int object:
class int(object)
|  int(x=0) -> integer
|  int(x, base=10) -> integer
|
etc.
```

当从命令行使用 `help()` 模块时，输出将以分页形式呈现。在输出第一页的末尾，我们看到一种新的非 Python 提示符。这通常是 `:`, 但在 Windows 上可能是 `-- More --`。

Python 通常以 `>>>` 或 `...` 提示我们。非 Python 提示符必须来自帮助查看器之一。

### Mac OS 和 GNU/Linux 秘籍

在 POSIX 兼容的操作系统上，我们将与一个名为 `less` 的程序交互；对于文档的最后一页之外的所有页面，它将以 `:` 提示。对于最后一页，它将以 `(END)` 提示。

这个程序非常复杂；你可以在维基百科上了解更多信息：[`en.wikipedia.org/wiki/Less_(Unix)`](http://en.wikipedia.org/wiki/Less_(Unix))。

以下是最重要的四个命令：

+   `q`：此命令用于退出 `less` 帮助查看器

+   `h`：此命令用于获取所有可用命令的帮助

+   `˽`：此命令用于进入空格以查看下一页

+   `b`：此命令用于返回上一页

### Windows 秘籍

在 Windows 上，我们通常会与一个名为 `more` 的程序交互；它将以 `-- More --` 提示你。你可以在维基百科上了解更多关于它的信息：[`en.wikipedia.org/wiki/More_(command)`](http://en.wikipedia.org/wiki/More_(command))。

这里三个重要的命令是：`q`、`h` 和 ˽。

## 使用帮助模式

当我们不带对象或字符串值输入 `help()` 时，我们将进入帮助模式。这使用 Python 的 `help>` 提示符来清楚地表明我们正在获取帮助，而不是输入 Python 语句。要返回普通 Python 编程模式，并输入 `quit`。

提示符随后将变回 `>>>` 以确认我们可以返回输入代码。

在我们继续前进之前，你的下一个训练任务是在使用 `help()` 函数和帮助模式之前进行实验。

# 背景简报 – 数学与数字

在我们开始任何更严肃的任务之前，我们将回顾 Python 编程的基础知识。如果你已经对 Python 有所了解，这将是一个复习。如果你对 Python 一无所知，这只是一个概述，许多细节将被省略。

如果你之前从未进行过任何编程，这份简介可能有点过于简略。你可能需要获取更深入的教程。如果你对编程一无所知，你可能想查看此页以获取额外的教程：[`wiki.python.org/moin/BeginnersGuide/NonProgrammers`](https://wiki.python.org/moin/BeginnersGuide/NonProgrammers)。若要开始学习专家级 Python 编程，请访问 [`www.packtpub.com/expert-python-programming/book`](http://www.packtpub.com/expert-python-programming/book)。

## 常见的错误

Python 提供了常规的算术和比较运算符。然而，有一些重要的细节和特性。我们不会假设你已经了解它们，我们将回顾这些细节。

传统的算术运算符有：`+`、`-`、`*`、`/`、`//`、`%` 和 `**`。在除法上有两种变体：精确除法（`/`）和整数除法（`//`）。你必须选择你想要精确的浮点结果还是整数结果：

```py
>>> 355/113
3.1415929203539825
>>> 355//113
3
>>> 355.0/113.0
3.1415929203539825
>>> 355.0//113.0
3.0
```

精确除法（`/`）从两个整数产生一个 `float` 结果。整数除法产生一个整数结果。当我们使用 `float` 值时，我们期望精确除法产生 `float`。即使对于两个浮点值，整数除法也会产生一个向下取整的浮点结果。

我们有这个额外的除法运算符，以避免使用诸如 `int(a/b)` 或 `math.floor(a/b)` 这样的冗长构造。

除了常规的算术运算外，还有一些额外的**位操作**运算符可用：`&`、`|`、`^`、`>>`、`<<` 和 `~`。这些运算符作用于整数（和集合）。这些运算符绝对不是布尔运算符；它们不作用于 `True` 和 `False` 的狭窄领域。它们作用于整数的各个位。

我们将使用带有 `0b` 前缀的二进制值来展示运算符的作用，如下面的代码所示。我们将在稍后详细讨论这个 `0b` 前缀。

```py
>>> bin(0b0101 & 0b0110)
'0b100'
>>> bin(0b0101 ^ 0b0110)
'0b11'
>>> bin(0b0101 | 0b0110)
'0b111'
>>> bin(~0b0101)
'-0b110'
```

`&` 运算符执行位运算 `AND`。`^` 运算符执行位运算的排他 `OR`（`XOR`）。`|` 运算符执行包含 `OR`。`~` 运算符是位的补码。结果有多个 `1` 位，并以负数的形式显示。

`<<` 和 `>>` 运算符用于执行位的左移和右移，如下面的代码所示：

```py
>>> bin( 0b110 << 4 )
'0b1100000'
>>> bin( 0b1100000 >> 3 )
'0b1100'
```

这可能并不明显，但将 `x` 位左移相当于将其乘以 `2**x`，不过它可能运行得更快。同样，右移 `b` 位相当于除以 `2**b`。

我们还有所有常规的比较运算符：`<`、`<=`、`>`、`>=`、`==` 和 `!=`。

在 Python 中，我们可以组合比较运算符而不包括 `AND` 运算符：

```py
>>> 7 <= 11 < 17
True
>>> 7 <= ll and 11 < 17
True
```

这种简化实际上实现了我们传统的数学理解，即比较可以如何书写。我们不需要说 `7 <= 11 and 11 < 17`。

在某些特定情况下，还有一个比较运算符被使用：`is`。目前，`is` 运算符看起来与 `==` 相同。试试看。`3 is 3` 和 `3 == 3` 好像做了同样的事情。稍后，当我们开始使用 `None` 对象时，我们会看到 `is` 运算符最常见的使用。对于更高级的 Python 编程，需要区分对同一对象的两个引用（`is`）和两个声称具有相同值的对象（`==`）。

## 数字的象牙塔

Python 给我们提供了各种数字，以及轻松添加新类型数字的能力。在这里，我们将关注内置数字。添加新类型的数字是更高级书籍中占据整个章节的内容。

Python 将数字排列成一种塔状结构。在顶部是具有最少特征的数字。每个子类都通过添加更多特征来扩展该数字。我们将从底部向上查看这座塔，从具有最多特征的整数开始，然后转向具有最少特征的复数。以下各节将介绍我们将需要使用的各种数字。

### 整数数字

我们可以用十进制、十六进制、八进制或二进制来表示整数值。十进制数字不需要前缀，其他基数将使用一个简单的双字符前缀，如下面的代码片段所示：

```py
48813
0xbead 
0b1011111010101101
0o137255
```

我们还有将数字转换为不同基数的方便字符串的函数。我们可以使用 `hex()`、`oct()` 和 `bin()` 函数来查看基于 16、8 或 2 的值。

整数大小的问题很常见。Python 的整数没有最大值。它们不是人为地限制在 32 或 64 位。试试这个：

```py
>>> 2**256
115792089237316195423570985008687907853269984665640564039457584007913129639936
```

大数字是有效的。它们可能有点慢，但它们工作得非常好。

### 有理数

有理数并不常用。它们必须从标准库中导入。我们必须导入 `fractions`.`Fraction` 类定义。它看起来是这样的：

```py
>>> from fractions import Fraction
```

一旦我们定义了 `Fraction` 类，我们就可以使用它来创建数字。假设我们被派去追踪一个丢失的设备。设备的详细信息是严格需要知道的。由于我们是新特工，总部只向我们发布了设备的总面积（平方英寸）。

这里是我们找到的设备的面积的确切计算。它测量为 4⅞" 乘以 2¼"：

```py
>>> length=4+Fraction("7/8")
>>> width=2+Fraction("1/4")
>>> length*width
Fraction(351, 32)
```

好吧，面积是 351/32，这在实际英寸和分数中是——什么？

我们可以使用 Python 的 `divmod()` 函数来解决这个问题。`divmod()` 函数会给我们一个商和一个余数，如下面的代码所示：

```py
>>> divmod(351,32)
(10, 31)
```

大约是 5 × 2，所以这个值似乎符合我们的粗略估计。我们可以将其作为正确的结果传输。如果我们找到了正确的设备，我们会被告知如何处理它。否则，我们可能已经破坏了任务。

### 浮点数

我们可以用常规或科学记数法写出浮点值，如下所示：

```py
3.1415926
6.22E12
```

小数点的存在区分了整数和浮点数。

这些是普通的双精度浮点数。重要的是要记住，浮点值只是近似值。它们通常有 64 位的实现。

如果你使用 CPython，它们明确基于在`sys.version`启动消息中显示的 C 编译器。我们还可以从`platform`包中获取信息，如下面的代码片段所示：

```py
>>> import platform
>>> platform.python_build()
('v3.3.4:7ff62415e426', 'Feb  9 2014 00:29:34')
>>> platform.python_compiler()
'GCC 4.2.1 (Apple Inc. build 5666) (dot 3)'
```

这告诉我们使用了哪个编译器。反过来，这可以告诉我们使用了哪些浮点库。这可能有助于确定正在使用的底层数学库。

### 十进制数

我们需要小心对待金钱。*生活箴言：监管间谍的会计师是一群吝啬鬼*。

重要的是，浮点数是一个近似值。我们在处理金钱时不能依赖于近似值。对于货币，我们需要精确的十进制值，其他任何东西都不行。可以使用扩展模块来使用十进制数。我们将导入`decimal.Decimal`类定义来处理货币。它看起来是这样的：

```py
>>> from decimal import Decimal
```

我们收买的线人为了找到设备而索要 50000 希腊德拉克马作为丢失设备的情报费。当我们提交费用时，我们需要包括一切，包括出租车费（23.50 美元）和我们必须为她购买的昂贵午餐（12,900 GRD）。

*为什么线人不愿意接受美元或欧元？我们不想知道，我们只想得到他们的信息*。最近，希腊德拉克马对美元的汇率为 247.616。

信息的确切预算是多少？以德拉克马和美元计算？

首先，我们将货币精确转换为美分的千分之一（美元的 1000 分之一）：

```py
>>> conversion=Decimal("247.616")
>>> conversion
Decimal('247.616')
```

我们午餐的账单，从德拉克马转换成美元，计算如下：

```py
>>> lunch=Decimal("12900")
>>> lunch/conversion
Decimal('52.09679503747738433703799431')
```

什么？这个混乱如何能让会计师满意？

所有这些数字都是精确除法的结果：我们得到了很多小数位数的精度；并不是所有的它们都真正相关。我们需要正式化“四舍五入”值的概念，这样政府会计师才会满意。最接近的美分即可。在`Decimal`方法中，我们将使用`quantize`方法。术语**quantize**指的是对给定值进行舍入、截断。`decimal`模块提供了一系列量化规则。默认规则是`ROUND_HALF_EVEN`：四舍五入到最近的值；在出现平局的情况下，优先选择偶数值。代码如下：

```py
>>> penny=Decimal('.00')
>>> (lunch/conversion).quantize(penny)
Decimal('52.10')
That's much better. How much was the bribe we needed to pay?
>>> bribe=50000
>>> (bribe/conversion).quantize(penny)
Decimal('201.93')
```

注意，涉及的除法是一个整数和一个小数。Python 对十进制的定义会默默地从一个整数创建一个新的十进制数，这样数学运算就会使用十进制对象进行。

出租车司机收了我们美元。我们不需要做太多的转换。因此，我们将把这个金额加到最终金额中，如下面的代码所示：

```py
>>> cab=Decimal('23.50')
That gets us to the whole calculation: lunch plus bribe, converted, plus cab.
>>> ((lunch+bribe)/conversion).quantize(penny)+cab
Decimal('277.52')
```

等等。我们似乎差了一分钱。为什么我们没有得到 277.53 美元作为答案？

四舍五入。基本规则称为*四舍六入五成双*。每个单独的金额（`52.10`和`201.93`）都有一分钱的零头四舍五入。（更详细的价值是`52.097`和`201.926`。）在我们将德拉克马相加并在转换之前计算时，总数不包括两个分别四舍五入的五分钱值。

我们对此有非常精细的控制。有许多舍入方案，有许多定义何时以及如何舍入的方法。此外，可能需要一些代数运算来了解它们是如何结合在一起的。

### 复数

我们在 Python 中也有复数。它们由两部分组成：实部和虚部，如下面的代码所示：

```py
>>> 2+3j
(2+3j)
```

如果我们将复数与其他大多数类型的数字混合，结果将是复数。例外的是十进制数字。但我们为什么要将工程数据和货币混合呢？如果任何任务涉及科学和工程数据，我们有一种处理复数的方法。

## 在数字之外

Python 包含各种数据类型，它们不是数字。在*处理文本和字符串*部分，我们将查看 Python 字符串。我们将在第二章，*获取智能数据*中查看集合。

布尔值`True`和`False`形成自己的小域。我们可以使用`bool()`函数从大多数对象中提取布尔值。以下是一些例子：

```py
>>> bool(5)
True
>>> bool(0)
False
>>> bool('')
False
>>> bool(None)
False
>>> bool('word')
True
```

一般模式是大多数对象具有`True`的值，而少数异常对象具有`False`的值。空集合、`0`和`None`具有`False`的值。布尔值有自己的特殊运算符：`and`、`or`和`not`。这些运算符有一个附加功能。以下是一个例子：

```py
>>> True and 0
0
>>> False and 0
False
```

当我们评估`True and 0`时，`and`运算符的两边都会被评估；右侧的值是结果。但当评估`False and 0`时，只有`and`的左侧被评估。由于它已经是`False`，就没有必要评估右侧了。

`and`和`or`运算符是*短路*运算符。如果`and`的左侧是`False`，那就足够了，右侧将被忽略。如果`or`的左侧是`True`，那就足够了，右侧将被忽略。

Python 的评估规则与数学实践紧密相关。算术运算具有最高优先级。比较运算符的优先级低于算术运算。逻辑运算符的优先级非常低。这意味着`a+2 > b/3 or c==15`将分阶段完成：首先算术运算，然后比较运算，最后逻辑运算。

数学规则遵循算术规则。`**`的优先级高于`*`、`/`、`//`或`%`。`+`和`–`运算符接下来。当我们写`2*3+4`时，必须首先执行`2*3`操作。位操作甚至更低。当你有一系列相同优先级的操作（`a+b+c`）时，计算是从左到右进行的。当然，如果有任何疑问，使用括号是明智的。

## 将值赋给变量

我们一直在使用 Python 工具集的 REPL 功能。从长远来看，这并不理想。我们将更乐意编写脚本。使用计算机进行情报收集的目的是自动化数据收集。我们的脚本将需要将变量赋值。它还需要显式输出和输入。

我们已经在几个例子中展示了简单的、明显的赋值语句。请注意，在 Python 中我们不需要声明变量。我们只是将值赋给变量。如果变量不存在，它就会被创建。如果变量已存在，其先前值将被替换。

让我们看看一些更复杂的技术来创建和更改变量。我们有多个赋值语句。以下代码将一次性为几个变量赋值：

```py
>>> length, width = 2+Fraction(1,4), 4+Fraction(7,8)
>>> length
Fraction(9, 4)
>>> width
Fraction(39, 8)
>>> length >= width
False
```

我们设置了两个变量，`length`和`width`。然而，我们也犯了一个小错误。长度并不是较大的值；我们交换了`length`和`width`的值。我们可以非常简单地使用多重赋值语句来交换它们，如下所示：

```py
>>> length, width = width, length
>>> length
Fraction(39, 8)
>>> width
Fraction(9, 4)
```

这是因为右侧是整体计算的。在这种情况下，这真的很简单。然后所有值都被分解并分配给命名变量。显然，右侧的值的数量必须与左侧变量的数量相匹配，否则这不会起作用。

我们还有*增强型*赋值语句。这些将算术运算符与赋值语句结合在一起。以下代码是`+=`的一个例子：使用带有加法的赋值增强。这里有一个从各个部分计算总和的例子：

```py
>>> total= 0
>>> total += (lunch/conversion).quantize(penny)
>>> total += (bribe/conversion).quantize(penny)
>>> total += cab
>>> total
Decimal('277.53')
```

我们不必写`total = total +...`。相反，我们可以简单地写`total += ...`。这很好地阐明了我们的意图。

所有的算术运算符都可作为增强型赋值语句使用。我们可能很难找到`%=`或`**=`的用途，但语句是语言的一部分。

优雅的澄清的想法应该导致一些额外的思考。例如，名为`conversion`的变量是一个完全晦涩难懂的名字。对数据的保密是一回事：我们将探讨加密数据的方法。通过糟糕的数据处理来隐藏数据通常会导致噩梦般的混乱。也许我们应该给它起一个更清楚地定义其含义的名字。我们将在后面的例子中重新审视这个晦涩的问题。

## 编写脚本并查看输出

我们的大多数任务将涉及收集和分析数据。我们不会创建一个非常复杂的**用户界面**（**UI**）。Python 有用于构建网站和复杂**图形用户界面**（**GUIs**）的工具。这些主题的复杂性导致有整本书来涵盖 GUI 和 Web 开发。

我们不想在`>>>`提示符中逐个输入 Python 语句。这使学习 Python 变得容易，但我们的目标是创建程序。在 GNU/Linux 术语中，我们的 Python 应用程序程序可以被称为**脚本**。这是因为 Python 程序符合**脚本语言**的定义。

对于我们的目的，我们将专注于使用**命令行界面**（**CLI**）的脚本。我们将写的一切都将在一个简单的终端窗口中运行。这种方法的优势是速度和简单性。我们可以在以后添加图形用户界面。或者，一旦脚本工作，我们可以将其基本核心扩展为网络服务。

应用程序或脚本是什么？脚本只是一个纯文本文件。我们可以使用任何文本编辑器来创建这个文件。很少建议使用文字处理器，因为文字处理器不擅长生成纯文本文件。

如果我们不是从`>>>` REPL 提示符工作，我们需要显式地显示输出。我们将使用`print()`函数从脚本中显示输出。

这里有一个简单的脚本，我们可以用它来为贿赂（*鼓励*）我们的线人生成收据。

从`decimal`导入`Decimal`：

```py
PENNY= Decimal('.00')

grd_usd= Decimal('247.616')
lunch_grd= Decimal('12900')
bribe_grd= 50000
cab_usd= Decimal('23.50')

lunch_usd= (lunch_grd/grd_usd).quantize(PENNY)
bribe_usd= (bribe_grd/grd_usd).quantize(PENNY)

print( "Lunch", lunch_grd, "GRD", lunch_usd, "USD" )
print( "Bribe", bribe_grd, "GRD", bribe_usd, "USD" )
print( "Cab", cab_usd, "USD" )
print( "Total", lunch_usd+bribe_usd+cab_usd, "USD" )
```

让我们分解这个脚本，以便我们可以跟随它。阅读脚本就像给线人加上尾巴一样。我们想看看脚本会去哪里，它会做什么。

首先，我们导入了`Decimal`定义。这对于处理货币是必不可少的。我们定义了一个值，`PENNY`，我们将用它来将货币计算四舍五入到最近的分。我们使用全大写字母的名称来使这个变量与众不同。它不是一个普通变量；在脚本中我们不应该再看到它在赋值语句的左侧。

我们创建了货币转换系数，并将其命名为`grd_usd`。这个名字在这个上下文中似乎比`conversion`更有意义。请注意，我们还为我们的金额名称添加了一个小的后缀。我们使用了诸如`lunch_grd`、`bribe_grd`和`cab_usd`这样的名称来强调正在使用哪种货币。这可以帮助防止混淆问题。

给定`grd_usd`转换系数，我们创建了两个额外的变量，`lunch_usd`和`bribe_usd`，金额已转换为美元并四舍五入到最近的分。如果会计师想要调整转换系数——也许他们可以使用不同于我们的间谍的银行——他们可以调整数字并准备不同的收据。

最后一步是使用`print()`函数来编写收据。我们打印了我们在上面花费金钱的三个项目，显示了 GRD 和 USD 的金额。我们还计算了总额。这将帮助会计师正确报销我们的任务。

我们将描述输出为 *原始但可接受*。毕竟，他们只是会计。我们将单独探讨格式化。

## 收集用户输入

收集输入的最简单方法是将其复制并粘贴到脚本中。这就是我们之前所做的那样。我们将希腊德拉克马转换粘贴到脚本中：`grd_usd= Decimal('247.616')`。我们可以用注释来帮助会计进行任何更改。

行尾的附加注释以 `#` 符号开始。它们看起来像这样：

```py
grd_usd= Decimal('247.616') # Conversion from Mihalis Bank 5/15/14
```

这段额外的文本是应用程序的一部分，但它实际上并没有做什么。这是给我们自己、我们的会计、我们的处理者或在我们消失时接管我们任务的那些人的备注。

这种数据行很容易编辑。但有时我们合作的人希望有更多的灵活性。在这种情况下，我们可以从一个人那里收集这个值作为输入。为此，我们将使用 `input()` 函数。

我们通常将用户输入分解为两个步骤，如下所示：

```py
        entry= input("GRD conversion: ")
        grd_usd= Decimal(entry)
```

第一行将写入一个提示并等待用户输入金额。金额将是一个字符字符串，分配给变量 `entry`。Python 不能直接在算术语句中使用这些字符，因此我们需要明确地将它们转换为有用的数值类型。

第二行将尝试将用户的输入转换为有用的 `Decimal` 对象。我们必须强调这个 `try` 部分。如果用户没有输入表示有效 `Decimal` 数字的字符串，将发生重大危机。试试看。

危机看起来会是这样：

```py
>>> entry= input("GRD conversion: ")
GRD conversion: 123.%$6
>>> grd_usd= Decimal(entry)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
decimal.InvalidOperation: [<class 'decimal.ConversionSyntax'>]
```

而不是这样做，输入一个良好的数字。我们输入了 `123.%$6`。

以 `Traceback` 开头的错误信息表明 Python 抛出了一个异常。Python 中的危机总是导致抛出异常。Python 定义了各种异常，以便我们能够编写处理这些危机的脚本。

一旦我们了解了如何处理危机，我们就可以看看字符串数据以及一些简单的清理步骤，这些步骤可以使用户的生活变得轻松一些。我们无法修复他们的错误，但我们可以处理一些源于在键盘上尝试输入数字的常见问题。

### 处理异常

当 `Decimal` 类无法解析给定的字符串以创建有效的 `Decimal` 对象时，会引发 `decimal.InvalidOperation` 异常。对于这个异常我们能做什么？

我们可以忽略它。在这种情况下，我们的应用程序程序会崩溃。它停止运行，使用它的代理会感到不高兴。这并不是最好的方法。

捕获异常的基本技术如下：

```py
    entry= input("GRD conversion: ")
    try:
        grd_usd= Decimal(entry)
    except decimal.InvalidOperation:
        print("Invalid: ", entry)
```

我们将 `Decimal()` 转换和赋值包裹在 `try:` 语句中。如果 `try:` 块中的每个语句都正常工作，则 `grd_usd` 变量将被设置。另一方面，如果在 `try:` 块内部抛出 `decimal.InvalidOperation` 异常，则将处理 `except` 子句。这将写入一条消息，并且不会设置 `grd_usd` 变量。

我们可以用各种方式处理异常。最常见的异常处理类型是在某些失败的情况下进行清理。例如，尝试创建文件的脚本可能会在抛出异常时删除无用的文件。问题还没有解决：程序仍然必须停止。但它可以以一种干净、愉快的方式停止，而不是以一种混乱的方式。

我们也可以通过计算一个替代答案来处理异常。我们可能从各种网络服务中收集信息。如果其中一个没有及时响应，我们将得到超时异常。在这种情况下，我们可能会尝试另一个网络服务。

在另一个常见的异常处理情况中，我们可能会重置计算的状态，以便可以再次尝试某个操作。在这种情况下，我们将异常处理程序包裹在一个循环中，该循环可以反复要求用户输入，直到他们提供一个有效的数字。

这些选择不是互斥的，一些处理程序可以执行之前异常处理程序的组合。我们将详细查看第三个选择，即再次尝试。

### 循环尝试

这里有一个从用户获取输入的常见方法：

```py
grd_usd= None
while grd_usd is None:
    entry= input("GRD conversion: ")
    try:
        grd_usd= Decimal(entry)
    except decimal.InvalidOperation:
        print("Invalid: ", entry)
print( grd_usd, "GRD = 1 USD" )
```

我们将添加一个尾巴并跟随它一段时间。目标是获取我们货币转换的有效十进制值`grd_usd`。我们将该变量初始化为 Python 的特殊`None`对象。

`while`语句正式声明了我们的意图。我们将执行`while`语句的主体，直到`grd_usd`变量保持为`None`。注意，我们使用`is`运算符将`grd_usd`与`None`进行比较。我们在这里强调一个细节：Python 中只有一个`None`对象，我们正在使用那个单一实例。技术上可以调整`==`的定义；我们不能调整`is`的定义。

在`while`语句的末尾，`grd_usd is None`必须为`False`；我们可以说`grd_usd is not None`。当我们查看语句的主体时，我们可以看到只有一个语句设置了`grd_usd`，因此我们可以确信它必须是一个有效的`Decimal`对象。

在`while`语句的主体中，我们使用了我们的异常处理方法。首先，我们提示并获取一些输入，设置`entry`变量。然后，在`try`语句中，我们尝试将字符串转换为`Decimal`值。如果转换成功，则`grd_usd`将分配那个`Decimal`对象。该对象不会是`None`，循环将终止。胜利！

如果将输入转换为`Decimal`值失败，将会抛出异常。我们会打印一条消息，并保持`grd_usd`不变。它仍然将保持`None`的值。循环将继续，直到输入一个有效的值。

Python 还有其他类型的循环，我们将在本章的后面讨论。

# 处理文本和字符串

我们已经简要介绍了 Python 对字符串对象的使用。例如 `Decimal('247.616')` 和 `input(GRD conversion: )` 的表达式涉及字符串字面值。Python 给我们几种方法将字符串放入程序中；有很多灵活性可用。

这里有一些字符串的例子：

```py
>>> "short"
'short'
>>> 'short'
'short'
>>> """A multiple line,
... very long string."""
'A multiple line,\nvery long string.'
>>> '''another multiple line
... very long string.'''
'another multiple line\nvery long string.'
```

我们使用单引号和撇号来创建短字符串。这些必须在程序的单行内完整。我们使用三引号和三撇号来创建长字符串。这些字符串可以跨越程序的多行。

注意，Python 使用 `\n` 字符回显字符串以显示换行。这被称为**字符转义**。`\` 字符转义了 `n` 的正常意义。序列 `\n` 并不意味着 `n`；`\n` 意味着通常不可见的换行符。Python 有许多转义字符。换行符可能是最常用的转义字符。

有时候我们需要使用不在我们电脑键盘上的字符。例如，我们可能想要打印各种 Unicode 特殊字符之一。

以下示例在我们知道特定符号的 Unicode 数字时效果很好：

```py
>>> "\u2328"
'⌨'
```

以下示例更好，因为我们不需要知道符号的晦涩代码：

```py
>>> "\N{KEYBOARD}"
'⌨'
```

## 介于数字和字符串之间的转换

我们有两种有趣的字符串转换：字符串转数字和数字转字符串。

我们已经看到了像 `Decimal()` 这样的函数，可以将字符串转换为数字。我们还有其他函数：`int()`, `float()`, `fractions.Fraction()` 和 `complex()`。当我们有不是十进制基数的数字时，我们也可以使用 `int()` 来转换，如下面的代码所示：

```py
>>> int( 'dead', 16 )
57005
>>> int( '0b1101111010101101', 2 )
57005
```

我们也可以从数字创建字符串。我们可以使用 `hex()`, `oct()`, 和 `bin()` 函数来创建基数为 16、8 和 2 的字符串。我们还有 `str()` 函数，这是将任何 Python 对象转换为某种字符串的最通用函数。

比这些更有价值的是字符串的 `format()` 方法。它执行各种值到字符串的转换。它使用转换格式指定或模板字符串来定义结果字符串的形状。

这里有一个使用 `format()` 将几个值转换成单个字符串的例子。它使用了一个相当复杂的格式指定字符串：

```py
 >>> "{0:12s} {1:6.2f} USD {2:8.0f} GRD".format( "lunch", lunch_usd, lunch_grd )
'lunch         52.10 USD    12900 GRD'
```

格式字符串有三个转换指定：`{0:12s}`, `{1:6.2f}`, 和 `{2:8.0f}`。它还有一些文本，主要是空格，但 `USD` 和 `GRD` 是背景文本的一部分，数据将被合并到其中。

每个转换指定有两个部分：要转换的项目和该项目的格式。这两个部分用 `{}` 内的 `:` 分隔。我们将逐一查看每个转换：

+   项目 `0` 使用 `12s` 格式进行转换。这个格式产生一个 12 位的字符串。字符串 `lunch` 被填充到 12 位。

+   项目 `1` 使用 `6.2f` 格式进行转换。这种格式生成一个六位字符串。小数点右侧将有两位。`lunch_usd` 的值就是使用这种方式进行格式化的。

+   项目 `2` 使用 `8.0f` 格式进行转换。这种格式生成一个没有小数点右侧位置的八位字符串。`lunch_grd` 的值就是按照这个规范进行格式化的。

我们可以做一些类似以下的事情来改进我们的收据：

```py
receipt_1 = "{0:12s}              {1:6.2f} USD"
receipt_2 = "{0:12s} {1:8.0f} GRD {2:6.2f} USD"
print( receipt_2.format("Lunch", lunch_grd, lunch_usd) )
print( receipt_2.format("Bribe", bribe_grd, bribe_usd) )
print( receipt_1.format("Cab", cab_usd) )
print( receipt_1.format("Total", lunch_usd+bribe_usd+cab_usd) )
```

我们使用了两个并行的格式规范。`receipt_1` 字符串可以用来格式化标签和单个美元值。`receipt_2` 字符串可以用来格式化标签和两个数值：一个以美元为单位，另一个以希腊德拉克马为单位。

这使收据看起来更好。这应该能让会计们远离我们，让我们专注于真正的工作：处理数据文件和文件夹。

## 解析字符串

字符串对象也可以被分解或解析成子字符串。我们可以轻松地写一整章关于字符串对象提供的所有各种解析方法。一个常见的转换是从字符串的开始和结束处去除多余的空白字符。想法是去除空格和制表符（以及一些其他不明显字符）。它看起来像这样：

```py
entry= input("GRD conversion: ").strip()
```

我们已经应用了 `input()` 函数从用户那里获取一个字符串。然后我们应用了该字符串对象的 `strip()` 方法来创建一个新的字符串，去除了所有空白字符。我们可以像这样从 `>>>` 提示符尝试它：

```py
>>> "   123.45     ".strip()
'123.45'
```

这显示了如何将包含杂项的字符串简化为基本要素。这可以简化用户的生活；一些额外的空格不会成问题。

另一种转换可能是将字符串分割成片段。这里只是众多可用技术中的一种：

```py
>>> amount, space, currency = "123.45 USD".partition(" ")
>>> amount
'123.45'
>>> space
' '
>>> currency
'USD'
```

让我们详细看看。首先，这是一个多赋值语句，其中三个变量将被设置：`amount`、`space` 和 `currency`。

表达式 `"123.45 USD".partition(" ")` 通过应用 `partition()` 方法到字面字符串值来实现。我们将字符串分割在空格字符上。`partition()` 方法返回三样东西：分割前的子字符串、分割字符和分割后的子字符串。

实际的分割变量也可以被分配一个空字符串，`''`。试试这个：

```py
amount, space, currency = "word".partition(" ") 
```

`amount`、`space` 和 `currency` 的值是多少？

如果你使用 `help(str)`，你会看到字符串可以执行的所有各种类型的事情。周围有 `__` 的名字映射到 Python 操作符。例如，`__add__()` 是 `+` 操作符的实现方式。

# 组织我们的软件

Python 给我们提供了多种方式来将软件组织成概念单元。长而杂乱的脚本难以阅读、修复或扩展。Python 提供了包、模块、类和函数。我们将在整个代理训练过程中看到不同的组织技术。我们将从函数定义开始。

在前面的章节中，我们使用了许多 Python 的内置函数。定义我们自己的函数是通过`def`语句完成的。函数定义使我们能够总结（在某些情况下是一般化）一些处理。以下是一个我们可以用来从用户获取十进制值的简单函数：

```py
def get_decimal(prompt):
    value= None
    while value is None:
        entry= input(prompt)
        try:
            value= Decimal(entry)
        except decimal.InvalidOperation:
            print("Invalid: ", entry)
    return value
```

这遵循了我们之前展示的设计，作为一个单独的函数打包。此函数将返回一个合适的`Decimal`对象：`value`变量的值。我们可以像这样使用我们的`get_decimal()`函数：

```py
grd_usd= get_decimal("GRD conversion: ")
```

Python 允许在向函数提供参数值时有很大的灵活性。一种常见的技术是提供一个可选参数，可以使用关键字参数提供。`print()`函数具有此功能，我们可以通过提供关键字参数值来命名一个文件。

```py
import sys
print("Error", file=sys.stderr)
```

如果我们不提供`file`参数，默认情况下将使用`sys.stdout`文件。

我们可以使用以下语法在我们的函数中这样做：

```py
def report( grd_usd, target=sys.stdout ):
    lunch_grd= Decimal('12900')
    bribe_grd= 50000
    cab_usd= Decimal('23.50')

    lunch_usd= (lunch_grd/grd_usd).quantize(PENNY)
    bribe_usd= (bribe_grd/grd_usd).quantize(PENNY)

    receipt_1 = "{0:12s}              {1:6.2f} USD"
    receipt_2 = "{0:12s} {1:8.0f} GRD {2:6.2f} USD"
    print( receipt_2.format("Lunch", lunch_grd, lunch_usd), file=target )
    print( receipt_2.format("Bribe", bribe_grd, bribe_usd), file=target )
    print( receipt_1.format("Cab", cab_usd), file=target )
    print( receipt_1.format("Total", lunch_usd+bribe_usd+cab_usd), file=target )
```

我们定义了我们的`report`函数，它有两个参数。`grd_usd`参数是必需的。`target`参数有一个默认值，因此它是可选的。

我们还使用了一个全局变量，`PENNY`。这是我们在函数外部设置的。该值在函数内部可用。

四个`print()`函数使用关键字语法提供文件参数：`file=target`。如果我们为`target`参数提供了值，则将使用该值；如果没有提供`target`参数的值，则将使用`sys.stdout`文件的默认值。我们可以以多种方式使用此函数。以下是一个版本：

```py
rate= get_decimal("GRD conversion: ")
print(rate, "GRD = 1 USD")
report(rate)
```

我们按位置提供了`grd_usd`参数值：它是第一个。我们没有为`target`参数提供值；将使用默认值。

这里是另一个版本：

```py
rate= get_decimal("GRD conversion: ")
print(rate, "GRD = 1 USD", file=sys.stdout)
report(grd_usd=rate, target=sys.stdout)
```

在这个例子中，我们为`grd_usd`和`target`参数都使用了关键字参数语法。是的，`target`参数的值重复了默认值。我们将在下一节中查看如何创建我们自己的文件。

# 与文件和文件夹一起工作

我们的计算机充满了文件。我们操作系统最重要的特性之一是它处理文件和设备的方式。Python 为我们提供了对各种类型文件的高水平访问。

然而，我们必须画几条线。所有文件都由字节组成。这是一种还原论的观点，并不总是有帮助的。有时这些字节代表 Unicode 字符，这使得读取文件相对容易。有时这些字节代表更复杂的对象，这使得读取文件可能相当困难。

实际上，文件有各种各样的物理格式。我们的各种桌面应用程序（文字处理器、电子表格等）都有独特的数据格式。其中一些物理格式是专有产品，这使得它们特别难以处理。内容是神秘的（不安全的），而挖掘信息可能需要高昂的成本。我们总是可以求助于检查低级字节并以此方式恢复信息。

许多应用程序都使用广泛标准化的文件格式。这使得我们的生活变得更加简单。格式可能很复杂，但符合标准的事实意味着我们可以恢复所有数据。我们将探讨后续任务中的一些标准化格式。目前，我们需要掌握基础知识。

## 创建文件

我们将首先创建一个我们可以工作的文本文件。与文件一起工作有几个有趣的方面。我们将关注以下两个方面：

+   创建`文件`对象。`文件`对象是 Python 对操作系统资源的视图。实际上它相当复杂，但我们可以非常容易地访问它。

+   使用文件上下文。文件有特定的生命周期：打开、读取或写入，然后关闭。为了确保我们关闭文件并正确地将操作系统资源从 Python 对象中分离出来，我们通常更喜欢将文件用作上下文管理器。使用`with`语句可以保证文件被正确关闭。

我们创建文件的通用模板，以`open("message1.txt", "w")`为目标，看起来像这样：

```py
    print( "Message to HQ", file=target )
    print( "Device Size 10 31/32", file=target )
```

我们将使用`open()`函数打开文件。在这种情况下，文件以写入模式打开。我们使用了`print()`函数将一些数据写入文件。

一旦程序完成`with`语句的缩进上下文，文件将被正确关闭，操作系统资源将被释放。我们不需要显式关闭`文件`对象。

我们还可以使用类似的方法来创建我们的文件：

```py
text="""Message to HQ\n Device Size 10 31/32\n"""
with open("message1.txt", "w") as target:
    target.write(text)
```

注意这里的重要区别。`print()`函数自动在每个行尾添加一个`\n`字符。文件对象的`write()`方法不添加任何内容。

在许多情况下，文件可能具有更复杂的物理格式。我们将在后面的章节中查看 JSON 或 CSV 文件。我们还将查看在第三章中读取和写入图像文件，*使用隐写术编码秘密信息*。

## 读取文件

我们读取文件的通用模板看起来像这样：

```py
with open("message1.txt", "r") as source:
    text= source.read()
print( text )
```

这将创建一个`文件`对象，但它将以读取模式打开。如果文件不存在，我们将得到一个异常。`read()`函数将整个文件吸入一个单独的文本块。一旦我们完成读取文件内容，我们也完成了`with`上下文。文件可以被关闭，资源可以被释放。我们创建的文本变量将包含文件内容，以便进行进一步处理。

在许多情况下，我们想要单独处理文本的行。为此，Python 为我们提供了`for`循环。这个语句与文件交互，遍历文件的每一行，如下面的代码所示：

```py
with open("message1.txt", "r") as source:
    for line in source:
        print(line)
```

输出看起来有点奇怪，不是吗？

它是双倍间距的，因为从文件中读取的每一行末尾都包含一个`\n`字符。`print()`函数自动包含一个`\n`字符。这导致输出是双倍间距的。

我们有两个候选的修复方案。我们可以告诉`print()`函数不要包含`\n`字符。例如，`print(line, end="")`就是这样做的。

一个稍微好一点的修复方案是使用`rstrip()`方法从行的右侧移除尾随空格。这稍微好一些，因为我们在多个上下文中经常会这样做。试图抑制`print()`函数中额外的`\n`字符的输出过于特定于这种情况。

在某些情况下，我们可能需要过滤文件中的行，寻找特定的模式。我们可能有一个包含通过`if`语句进行条件处理的循环，如下面的代码所示：

```py
with open("message1.txt", "r") as source:
    for line in source:
        junk1, keyword, size= line.rstrip().partition("Size")
        if keyword != '':
            print( size )
```

这显示了文本处理程序的典型结构。首先，我们通过`with`语句上下文打开文件；这确保无论发生什么情况，文件都将被正确关闭。

我们使用`for`语句遍历文件的所有行。每一行都有一个两步的过程：`rstrip()`方法移除尾随空格，`partition()`方法在关键字`Size`周围分割行。

`if`语句定义了一个条件（`keyword != ''`）以及仅在条件为`True`时执行的一些处理。如果条件为`False`（`keyword`的值为`''`），则`if`语句的缩进主体将被静默跳过。

赋值和`if`语句构成了`for`语句的主体。这两个语句在文件的每一行上执行一次。当我们到达`for`语句的末尾时，我们可以确信所有行都已处理。

我们必须注意，我们可以使用`break`语句提前退出循环，打破常规的假设。我们更愿意避免使用`break`语句，这样就可以很容易地看到`for`语句适用于文件的每一行。

在`for`语句的末尾，我们完成了对文件的加工。我们也完成了`with`上下文。文件将被关闭。

## 定义更复杂的逻辑条件

如果我们寻找的图案比我们预期的多呢？如果我们正在处理更复杂的数据呢？

假设我们在文件中有类似以下的内容：

```py
Message to Field Agent 006 1/2 
Proceed to Rendezvous FM16uu62
Authorization to Pay $250 USD
```

我们正在寻找两个关键字：`Rendezvous`和`Pay`。Python 将`elif`子句作为`if`语句的一部分提供。这个子句提供了一种优雅地处理多个条件的方法。以下是一个解析总部发来的信息的脚本：

```py
amount= None
location= None
with open("message2.txt", "r") as source:
    for line in source:
        clean= line.lower().rstrip()
        junk, pay, pay_data= clean.partition("pay")
        junk, meet, meet_data= clean.partition("rendezvous")
        if pay != '':
            amount= pay_data
        elif meet != '':
            location= meet_data
        else:
            pass # ignore this line 
print("Budget", amount, "Meet", location)
```

我们正在搜索文件内容中的两块信息：会合地点和我们可以用以贿赂联系人的金额。实际上，我们将总结这个文件为两个简短的事实，丢弃我们不关心的部分。

与前面的示例一样，我们使用`with`语句创建一个处理上下文。我们还使用`for`语句遍历文件的所有行。

我们使用两步过程来清理每一行。首先，我们使用`lower()`方法创建一个字符串的小写版本。然后我们使用`rstrip()`方法从行中删除任何尾随空格。

我们对清理后的行应用了`partition()`方法两次。一个分区查找`pay`，另一个分区查找`rendezvous`。如果行可以在`pay`上分区，则`pay`变量（和`pay_data`）的值不会等于空字符串。如果行可以在`rendezvous`上分区，则`meet`变量（和`meet_data`）的值不会等于空字符串。Python 中的`else, if`被缩写为`elif`。

如果前面的所有条件都不成立，我们就不需要做任何事情。我们不需要`else:`子句。但我们决定包含`else:`子句，以防我们以后需要添加一些处理。目前，没有更多的事情要做。在 Python 中，`pass`语句什么都不做。它是一个语法占位符；当我们必须写点东西时可以写的东西。

# 解决问题——恢复丢失的密码

我们将应用许多技术来编写一个程序，帮助我们探索锁定 ZIP 文件内部。重要的是要注意，任何合格的加密方案都不会加密密码。密码在最坏的情况下，被简化为散列值。当有人输入密码时，会比较散列值。原始密码基本上是无法恢复的，除非通过猜测。

我们将探讨一种暴力破解密码的方案。它将简单地尝试字典中的所有单词。更复杂的猜测方案将使用字典单词和标点符号来形成越来越长的候选密码。更复杂的猜测甚至包括字符的*leet speak*替换。例如，使用`1337 sp3@k`代替`leet speak`。

在我们研究 ZIP 文件的工作原理之前，我们必须找到一个可用的词库。一个常见的词库替代品是拼写检查字典。对于 GNU/Linux 或 Mac OS X 计算机，可以在几个地方找到字典。三个常见的地方是：`/usr/dict/words`、`/usr/share/dict/words`，或者可能是`/usr/share/myspell/dicts`。

Windows 代理可能需要搜索类似字典资源。查看`%AppData%\Microsoft\Spelling\EN`作为可能的存储位置。字典通常是`.dic`文件。也可能有一个相关的`.aff`（词缀规则）文件，其中包含从`.dic`文件中的词根（或词元）构建单词的额外规则。

如果我们找不到可用的词汇语料库，最好安装一个独立的拼写检查程序及其词典。例如，aspell、ispell、Hunspell、Open Office 和 LibreOffice 包含各种语言的广泛拼写词典集合。

有其他方法可以获得各种词汇语料库。一种方法是在所有这些文件中搜索所有单词。我们用来创建密码的单词可能反映在我们实际使用的其他文件中的单词。

另一个好方法是使用 Python 的**自然语言工具包**（**NLTK**），它提供了处理自然语言处理的多种资源。当这本手册即将出版时，已经发布了一个与 Python3 兼容的版本。请参阅[`pypi.python.org/pypi/nltk`](https://pypi.python.org/pypi/nltk)。这个库提供了词典、几个单词列表语料库和比简单的拼写检查词典更好的单词词干工具。

你的任务是找到你电脑上的词典。如果你找不到，那么下载一个好的拼写检查程序并使用它的词典。通过搜索`web2（韦伯斯特第二国际）`可能找到可用的语料库。

## 阅读词汇语料库

我们需要做的第一件事是阅读我们的拼写检查语料库。我们将称之为语料库——一组词汇，而不是词典。示例将基于**web2（韦伯斯特第二国际）中的全部 234,936 个单词**。这通常在 BSD Unix 和 Mac OS X 中可用。

这是一个典型的脚本，它将检查语料库：

```py
count= 0
corpus_file = "/usr/share/dict/words" 
with open( corpus_file ) as corpus:
    for line in corpus:
        word= line.strip()
        if len(word) == 10:
            print(word)
            count += 1
print( count )
```

我们已经打开了语料库文件并读取了所有行。通过从行中去除空白字符找到了单词；这移除了尾随的`\n`字符。使用`if`语句过滤了 10 个字母的单词。共有 30,878 个这样的单词，从 abalienate 到 Zyzzogeton。

这个小程序实际上并不是任何大型应用程序的一部分。它是一种技术尖峰——我们用它来锁定细节。在编写这样的小程序时，我们通常会跳过类或函数的仔细设计，只是将一些 Python 语句放入文件中。

在 POSIX 兼容的操作系统上，我们可以做两件事来使脚本更容易使用。首先，我们可以在文件的非常第一行添加一个特殊注释，以帮助操作系统确定如何处理它。该行看起来像这样：

```py
#!/usr/bin/env python3
```

这告诉操作系统如何处理脚本。具体来说，它告诉操作系统使用`env`程序。然后`env`程序将定位我们的 Python 3 安装。责任将转交给`python3`程序。

第二步是将脚本标记为可执行。我们使用操作系统命令`chmod +x some_file.py`将 Python 文件标记为可执行脚本。

如果我们已经完成了这两个步骤，我们只需在命令提示符下键入其名称即可执行脚本。

在 Windows 中，文件扩展名（`.py`）与 Python 程序相关联。有一个**高级设置**面板定义了这些文件关联。当您安装 Python 时，这个关联是由安装程序建立的。这意味着您可以直接输入 Python 脚本的名称，Windows 会搜索您的`PATH`值中命名的目录，并正确执行该脚本。

## 读取 ZIP 归档

我们将使用 Python 的`zipfile`模块来处理 ZIP 归档。这意味着在我们可以做其他任何事情之前，我们需要使用`import zipfile`。由于 ZIP 归档包含多个文件，我们通常会想要获取归档中可用的文件列表。以下是调查归档的方法：

```py
import zipfile
with zipfile.ZipFile( "demo.zip", "r" ) as archive:
    archive.printdir()
```

我们打开了归档，创建了一个文件处理上下文。然后我们使用了归档的`printdir()`方法来输出归档的成员。

然而，我们无法提取任何文件，因为 ZIP 归档被加密了，我们丢失了密码。以下是一个尝试读取第一个成员的脚本：

```py
import zipfile
with zipfile.ZipFile( "demo.zip", "r" ) as archive:
    archive.printdir()
    first = archive.infolist()[0]
    with archive.open(first) as member:
        text= member.read()
        print( text )
```

我们使用打开的归档创建了一个文件处理上下文。我们使用归档的`infolist()`方法获取每个成员的信息。`archive.infolist()[0]`语句将从列表中选取第一个项目，即第一个项目。

我们尝试为这个特定成员创建一个文件处理上下文。而不是看到成员的内容，我们得到了一个异常。细节会有所不同，但您的异常信息将类似于以下内容：

```py
RuntimeError: File <zipfile.ZipInfo object at 0x1007e78e8> is encrypted, password required for extraction
```

十六进制数（`0x1007e78e8`）可能不匹配您的输出，但您尝试读取加密的 ZIP 文件时仍会出错。

## 使用暴力搜索

为了恢复文件，我们需要求助于暴力搜索以找到一个可行的密码。这意味着将我们的语料库读取循环插入到我们的归档处理上下文中。这是一些闪亮的复制粘贴操作，导致以下脚本：

```py
import zipfile
import zlib
corpus_file = "/usr/share/dict/words"

with zipfile.ZipFile( "demo.zip", "r" ) as archive:
    first = archive.infolist()[0]
    print( "Reading", first.filename )
    with open( corpus_file ) as corpus:
        for line in corpus:
            word= line.strip().encode("ASCII")
            try:
                with archive.open(first, 'r', pwd=word) as member:
                    text= member.read()
                print( "Password", word )
                print( text )
                break
            except (RuntimeError, zlib.error, zipfile.BadZipFile):
                pass
```

我们导入了两个库：`zipfile`以及`zlib`。我们添加`zlib`是因为我们发现，在猜测密码时，有时会看到`zlib.error`异常。我们为打开的归档文件创建了一个上下文。我们使用`infolist()`方法获取成员的名称，并从该列表中获取第一个文件。如果我们能读取一个文件，我们就能读取所有文件。

然后，我们打开了我们的语料库文件，并为该文件创建了一个文件处理上下文。对于语料库中的每一行，我们使用了两种方法：`strip()`方法将删除尾随的`"\n"`，而`encode("ASCII")`方法将把行从 Unicode 字符转换为 ASCII 字节。我们需要这样做，因为 ZIP 库密码是 ASCII 字节，而不是正确的 Unicode 字符字符串。

`try:` 块尝试打开并读取第一个成员。我们在归档中为这个成员创建了一个文件处理上下文。我们尝试读取成员。如果在尝试读取加密成员的过程中发生任何错误，将会引发异常。当然，通常的罪魁祸首是尝试用错误的密码读取成员。

如果一切顺利，那么我们就猜对了正确的密码。我们可以打印出恢复的密码，以及成员的文本作为确认。

注意，我们已经使用 `break` 语句来结束语料库处理的 `for` 循环。这改变了 `for` 循环的语义，从 `for all words` 变为 `there exists a word`。`break` 语句意味着一旦找到有效的密码，循环就会结束。不需要进一步处理语料库中的其他单词。

我们列出了三种可能因尝试使用不良密码而引发的异常。为什么不同类型的异常可能由错误的密码引发并不明显。但进行一些实验来确认确实存在一个共同的根本问题引发了各种不同的异常是很容易的。

# 摘要

在本章中，我们了解了我们间谍工具包的基础：Python 和我们选择的文本编辑器。我们已经使用 Python 来操作数字、字符串和文件。我们看到了许多 Python 语句：赋值、`while`、`for`、`if`、`elif`、`break` 和 `def`。我们看到了一个表达式（例如 `print("hello world")`）如何被用作 Python 语句。

我们还研究了处理 ZIP 文件的 Python API。我们看到了 Python 如何与流行的文件归档格式协同工作。我们甚至看到了如何使用简单的单词语料库来恢复简单的密码。

现在我们有了基础知识，我们准备进行更高级的任务。接下来，我们必须开始使用万维网（WWW）来收集信息并将其带回我们的电脑。
