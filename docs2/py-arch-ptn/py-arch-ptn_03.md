

# 第二章：API 设计

在本章中，我们将讨论基本的**应用程序编程接口**（**API**）设计原则。我们将了解如何通过定义有用的抽象来开始我们的设计，这些抽象将为设计奠定基础。

我们将接着介绍 RESTful 接口的原则，涵盖严格的、学术性的定义以及更实用的定义，以帮助进行设计。我们将探讨设计方法和技巧，以帮助基于标准实践创建有用的 API。我们还将花一些时间讨论认证，因为这是大多数 API 的关键元素。

我们将在这本书中专注于 RESTful 接口，因为它们现在是最常见的。在此之前，还有其他替代方案，包括 20 世纪 80 年代的**远程过程调用**（**RPC**），一种进行远程函数调用的方法，或者 21 世纪初的**单一对象访问协议**（**SOAP**），它标准化了远程调用的格式。当前的 RESTful 接口更容易阅读，并且更强烈地利用了已经建立的 HTTP 使用，尽管本质上，它们可以通过这些较旧的规范进行集成。

尽管现在主要存在于较老的系统上，但它们仍然可用。

我们将介绍如何为 API 创建版本控制系统，考虑到可能受到影响的不同用例。

我们将探讨前端和后端之间的区别，以及它们的交互。尽管本章的主要目标是讨论 API 接口，但我们也会讨论 HTML 接口，以了解它们之间的差异以及它们如何与其他 API 交互。

最后，我们将描述我们将在书中使用的示例的设计。

在本章中，我们将涵盖以下主题：

+   抽象

+   RESTful 接口

+   认证

+   API 版本控制

+   前端和后端

+   HTML 界面

+   为示例设计 API

让我们先看看抽象。

# 抽象

一个 API 允许我们使用一段软件，而无需完全理解其中涉及的所有不同步骤。它提供了一个清晰的动作菜单，允许外部用户（可能并不理解操作的复杂性）高效地执行这些操作。它简化了过程。

这些动作可以是纯粹的功能性的，其中输出仅与输入相关；例如，一个计算行星和恒星质心的数学函数，给定它们的轨道和质量。

或者，它们可以处理状态，因为相同的动作重复两次可能产生不同的效果；例如，检索系统中的时间。也许甚至一个调用允许设置计算机的时区，随后两次检索时间的调用可能返回非常不同的结果。

在这两种情况下，API 都在定义**抽象**。通过单个操作检索系统时间很简单，但也许执行此操作的细节并不那么容易。这可能涉及到以某种方式读取跟踪时间的某些硬件。

不同的硬件可能以不同的方式报告时间，但结果应该始终以标准格式转换。需要应用时区和夏令时。所有这些复杂性都由公开 API 并为用户提供清晰、易懂契约的模块开发者处理。“调用这个函数，将以 ISO 格式返回时间。”

虽然我们主要在讨论 API，并且在整本书中我们将主要描述与在线服务相关的 API，但抽象的概念实际上可以应用于任何事物。一个用于管理用户的网页是一个抽象，因为它定义了“用户账户”及其相关参数的概念。另一个无处不在的例子是电子商务中的“购物车”。创建一个清晰的思维图像是很有好处的，因为它有助于为用户提供更清晰、更一致的界面。

这当然是一个简单的例子，但 API 可以在其界面下隐藏大量的复杂性。一个值得思考的好例子是像 `curl` 这样的程序。即使只是向 URL 发送 HTTP 请求并打印返回的头部，这也与大量的复杂性相关：

```py
$ curl -IL http://google.com

HTTP/1.1 301 Moved Permanently

Location: http://www.google.com/

Content-Type: text/html; charset=UTF-8

Date: Tue, 09 Mar 2021 20:39:09 GMT

Expires: Thu, 08 Apr 2021 20:39:09 GMT

Cache-Control: public, max-age=2592000

Server: gws

Content-Length: 219

X-XSS-Protection: 0

X-Frame-Options: SAMEORIGIN

HTTP/1.1 200 OK

Content-Type: text/html; charset=ISO-8859-1

P3P: CP="This is not a P3P policy! See g.co/p3phelp for more info."

Date: Tue, 09 Mar 2021 20:39:09 GMT

Server: gws

X-XSS-Protection: 0

X-Frame-Options: SAMEORIGIN

Transfer-Encoding: chunked

Expires: Tue, 09 Mar 2021 20:39:09 GMT

Cache-Control: private

Set-Cookie: NID=211=V-jsXV6z9PIpszplstSzABT9mOSk7wyucnPzeCz-TUSfOH9_F-07V6-fJ5t9L2eeS1WI-p2G_1_zKa2Tl6nztNH-ur0xF4yIk7iT5CxCTSDsjAaasn4c6mfp3fyYXMp7q1wA2qgmT_hlYScdeAMFkgXt1KaMFKIYmp0RGvpJ-jc; expires=Wed, 08-Sep-2021 20:39:09 GMT; path=/; domain=.google.com; HttpOnly 
```

这将调用 `www.google.com` 并使用 `-I` 标志显示响应的头部。添加 `-L` 标志是为了自动重定向任何请求，这正是这里发生的情况。

与服务器建立远程连接需要很多不同的部件：

+   DNS 访问将服务器地址 `www.google.com` 转换为实际的 IP 地址。

+   两个服务器之间的通信，这涉及到使用 TCP 协议来生成持久连接并保证数据的接收。

+   根据第一次请求的结果进行重定向，因为服务器返回了一个指向另一个 URL 的代码。这是由于使用了 `-L` 标志。

+   重定向指向一个 HTTPS URL，这需要在上面添加一个验证和加密层。

每个这些步骤也使用了其他 API 来执行更小的操作，这可能涉及到操作系统的功能，甚至调用远程服务器（如 DNS 服务器）以从那里获取数据。

在这里，使用命令行从 `curl` 界面进行操作。虽然 API 严格的定义规定最终用户是人类，但实际上并没有太大的变化。好的 API 应该很容易被人类用户测试。命令行界面也可以通过 bash 脚本或其他语言轻松自动化。

但是，从`curl`用户的观点来看，这并不太相关。它被简化到只需一个带有几个标志的单行命令行就可以执行一个定义良好的操作，无需担心从 DNS 获取数据的格式或如何使用 SSL 加密请求。

## 使用正确的抽象

对于一个成功的接口，其根本在于创建一系列抽象并将它们呈现给用户，以便他们可以执行操作。因此，在设计新的 API 时，最重要的一个问题就是决定哪些是最合适的抽象。

当这个过程自然发生时，抽象主要是在过程中决定的。有一个最初的想法，被认可为对问题的理解，然后得到调整。

例如，以添加不同的标志到用户开始启动用户管理系统是非常常见的。因此，用户有权限执行操作 A，然后有一个参数执行操作 B，依此类推。通过一次添加一个标志，到第十个标志时，这个过程变得非常混乱。

然后，可以使用一个新的抽象；角色和权限。某些类型的用户可以执行不同的操作，例如管理员角色。用户可以有一个角色，该角色描述了相关的权限。

注意，这简化了问题，因为它易于理解和管理。然而，从“单个标志集合”到“多个角色”的转变可能是一个复杂的过程。可能减少了可能的选项数量。也许一些现有用户有一些独特的标志组合。所有这些都需要谨慎处理。

在设计新的 API 时，最好尝试明确描述 API 使用的固有抽象，至少在高级别上，以澄清它们。这也具有这样的优势，即作为 API 的用户思考这些问题，看看是否合理。

在软件开发者的工作中，最有用的观点之一是脱离你的“内部视角”，站在软件实际用户的立场上。这比听起来要难，但确实是一项值得培养的技能。这将使你成为一个更好的设计师。不要害怕请朋友或同事检测你设计中的盲点。

然而，每个抽象都有其局限性。

## 抽象泄露

当一个抽象从实现中泄露细节，而不是呈现一个完美的不透明图像时，它被称为泄露的抽象。

虽然一个好的 API 应该尽量避免这种情况，但有时它还是会发生。这可能是由服务于 API 的代码中的底层错误引起的，或者有时直接由代码在特定操作中的运行方式引起的。

这种情况的常见例子是关系型数据库。SQL 抽象了从数据库中实际存储方式搜索数据的过程。你可以使用复杂的查询进行搜索并获取结果，而不需要知道数据的结构。但有时，你会发现某个特定的查询速度很慢，重新组织查询参数会对这个过程产生重大影响。这是一个泄漏的抽象。

这非常常见，这也是为什么有大量的工具可以帮助确定在运行 SQL 查询时发生了什么，而 SQL 查询与实现非常分离。其中最主要的是 `EXPLAIN` 命令。

操作系统是生成良好抽象且大多数情况下不会泄漏的系统的好例子。有很多例子。由于空间不足而无法读取或写入文件（现在比三十年前少见的难题）；由于网络问题而与远程服务器断开连接；或者由于达到打开文件描述符的数量限制而无法创建新的连接。

泄漏的抽象在某种程度上是不可避免的。这是不生活在完美世界的结果。软件是会出错的。理解和准备这一点至关重要。

> "所有非平凡的抽象，在某种程度上，都是泄漏的。"
> 
> – 乔尔·斯波尔斯基的泄漏抽象定律

在设计 API 时，考虑到以下几个原因，重要的是要考虑这个事实：

+   **为了在外部清晰地展示错误和提示**。一个好的设计将始终包括出错的情况，并尝试用适当的错误代码或错误处理方式清晰地展示它们。

+   **为了内部处理可能来自依赖服务的错误**。依赖服务可能会失败或出现其他类型的问题。API 应该在一定程度上抽象这个问题，如果可能的话从问题中恢复，如果不能优雅地失败，并返回适当的结果。

最好的设计不仅要在预期工作的情况下设计事物，还要为意外问题做好准备，并确信它们可以被分析和纠正。

## 资源和操作抽象

在设计 API 时考虑的一个非常有用的模式是生成一组可以执行操作的资源。这个模式使用两种类型的元素：**资源**和**操作**。

资源是被引用的被动元素，而操作是在资源上执行的。

例如，让我们定义一个非常简单的接口来玩一个简单的猜硬币游戏。这是一个由三次硬币投掷组成的游戏，如果用户至少猜对其中两次，则获胜。

资源和操作可能如下所示：

| 资源 | 操作 | 详情 |
| --- | --- | --- |
| HEADS | None | 硬币投掷结果。 |
| TAILS | None | 硬币投掷结果。 |
| GAME | START | 开始一个新的游戏。 |
|  | READ | 返回当前轮次（1 到 3）和当前正确猜测。 |
| COIN_TOSS | 投掷 | 投掷硬币。如果 GUESS 尚未生成，则返回错误。 |
|  | 猜测 | 接受 HEADS 或 TAILS 作为猜测。 |
|  | 结果 | 返回 HEADS 或 TAILS 以及猜测是否正确。 |

单个游戏的可能顺序可以是：

```py
GAME START

> (GAME 1)

GAME 1 COIN_TOSS GUESS HEAD

GAME 1 COIN_TOSS TOSS

GAME 1 COIN_TOSS RESULT

> (TAILS, INCORRECT)

GAME 1 COIN_TOSS GUESS HEAD

GAME 1 COIN_TOSS TOSS

GAME 1 COIN_TOSS RESULT

> (HEAD, CORRECT)

GAME 1 READ

> (ROUND 2, 1 CORRECT, IN PROCESS)

GAME 1 COIN_TOSS GUESS HEAD

GAME 1 COIN_TOSS TOSS

GAME 1 COIN_TOSS RESULT

> (HEAD, CORRECT)

GAME 1 READ

> (ROUND 3, 2 CORRECT, YOU WIN) 
```

注意每个资源都有其自己的动作集，可以执行。如果方便，动作可以重复，但这不是必需的。资源可以组合成层次表示（如这里，`COIN_TOSS`依赖于更高的`GAME`资源）。动作可能需要参数，这些参数可以是其他资源。

然而，抽象是围绕具有一致的资源集和动作集组织的。这种明确组织 API 的方式很有用，因为它阐明了系统中什么是被动的，什么是主动的。

**面向对象编程**（**OOP**）使用这些抽象，因为一切都是可以接收消息以执行某些动作的对象。另一方面，函数式编程并不适合这种结构，因为“动作”可以像资源一样工作。

这是一个常见的模式，它被用于 RESTful 接口，正如我们接下来将要看到的。

# RESTful 接口

RESTful 接口在当今非常普遍，这是有充分理由的。它们已经成为服务其他应用程序的 Web 服务的既定标准。

**表征状态转移**（**REST**）由 Roy Fielding 在 2000 年的一篇博士论文中定义，它使用 HTTP 标准作为基础来创建一种软件架构风格的定义。

要使一个系统被认为是 RESTful 的，它应该遵循某些规则：

+   **客户端-服务器架构**。它通过远程调用工作。

+   **无状态**。与特定请求相关的所有信息都应该包含在请求本身中，使其独立于特定服务器。

+   **缓存性**。响应的缓存性应该是明确的，要么说明它们是可缓存的，要么不是。

+   **分层系统**。客户端无法判断它们是否连接到最终服务器或是否存在中间服务器。

+   **统一接口**，有四个先决条件：

    +   **请求中的资源标识**，意味着资源被明确表示，其表示是独立的

    +   **通过表示进行资源操作**，允许客户端在拥有表示时拥有所有所需信息以进行更改

    +   **自描述消息**，意味着消息本身是完整的

    +   **超媒体作为应用状态引擎**，意味着客户端可以通过引用的超链接遍历系统

+   **按需代码**。这是一个可选要求，通常不使用。服务器可以提交代码以帮助执行操作或改进客户端；例如，提交要在浏览器中执行的 JavaScript。

这是最正式的定义。如您所见，它不一定基于 HTTP 请求。为了更方便的使用，我们需要限制一些可能性并设定一个共同框架。

## 更实用的定义

当人们非正式地谈论 RESTful 接口时，通常它们被理解为基于 HTTP 资源使用 JSON 格式请求的接口。这与我们之前看到的定义完全兼容，但考虑了一些关键元素。

这些关键元素有时会被忽略，导致伪 RESTful 接口，它们不具有相同的属性。

主要的一点是**URI（统一资源标识符）**应该描述清晰的资源，以及对其执行的操作的 HTTP 方法和动作，使用**CRUD（创建、检索、更新、删除）**方法。

CRUD 接口简化了这些动作的执行：创建（保存新条目）、检索（读取）、更新（覆盖）和删除条目。这些是任何持久存储系统的基本操作。

有两种 URI，无论是描述单个资源还是资源集合，如下表所示：

| 资源 | 示例 | 方法 | 描述 |
| --- | --- | --- | --- |
| 集合 | `/books` | `GET` | 列表操作。返回集合中所有可用的元素，例如，所有书籍。 |
|  |  | `POST` | 创建操作。创建集合的新元素。返回新创建的资源。 |
| 单个 | `/books/1` | `GET` | 检索操作。返回资源的数据，例如，ID 为 1 的书籍。 |
|  |  | `PUT` | 设置（更新）操作。发送资源的新数据。如果不存在，则创建。如果存在，则覆盖。 |
|  |  | `PATCH` | 部分更新操作。仅覆盖资源的部分值，例如，仅发送和写入用户对象的电子邮件。 |
|  |  | `DELETE` | 删除操作。删除资源。 |

这个设计的关键要素是将一切定义为资源，正如我们之前所看到的。资源通过其 URI 定义，其中包含资源的分层视图，例如：

`/books/1/cover` 定义了 ID 为 1 的书的封面图片资源。

为了简化，我们将在本章中使用整数 ID 来标识资源。在实际操作中，这并不推荐。它们没有任何意义，更糟糕的是，它们有时会泄露系统元素数量或其内部顺序的信息。例如，竞争对手可能会估计每周新增了多少条记录。为了摆脱任何内部表示，如果可能的话，尽量始终使用外部自然键，例如书的 ISBN 号码，或者创建一个随机的**通用唯一标识符**（**UUID**）。

顺序整数的一个问题是，在高速率下，系统可能难以正确创建它们，因为它不可能同时创建两个。这可能会限制系统的发展。

资源的大部分输入和输出将以 JSON 格式表示。例如，这可能是一个请求和响应示例，用于检索用户：

```py
GET /books/1

HTTP/1.1 200 OK

Content-Type: application/json

{"name": "Frankenstein", "author": "Mary Shelley", "cover": "http://library.lbr/books/1/cover"} 
```

响应格式为 JSON，如`Content-Type`中指定。这使得自动解析和分析变得容易。请注意，`avatar`字段返回指向另一个资源的超链接。这使得接口易于导航，并减少了客户端事先需要的信息量。

这是设计 RESTful 接口时最容易被遗忘的特性之一。最好返回资源的完整 URI，而不是间接引用，例如无上下文 ID。

例如，在创建新资源时，在`Location`头中包含新的 URI。

要发送新值以覆盖，应使用相同的格式。请注意，某些元素可能是只读的，例如`cover`，并且不是必需的：

```py
PUT /books/1

Content-Type: application/json

{"name": "Frankenstein or The Modern Prometheus", "author": "Mary Shelley"}

HTTP/1.1 200 OK

Content-Type: application/json

{"name": "Frankenstein or The Modern Prometheus", "author": "Mary Shelley", "cover": "http://library.com/books/1/cover"} 
```

**相同的表示应用于输入和输出**，这使得客户端能够轻松检索资源、修改它，然后重新提交。

这非常方便，并在实现客户端时创建了一个非常受欢迎的一致性水平。在测试时，请确保检索值并重新提交是有效的，并且不会造成问题。

当资源将由二进制内容直接表示时，它可以返回在`Content-Type`头中指定的正确格式。例如，检索头像资源可能返回一个图像文件：

```py
GET /books/1/cover

HTTP/1.1 200 OK

Content-Type: image/png

... 
```

同样地，在创建或更新新头像时，应使用适当的格式发送。

虽然 RESTful 接口的原始意图是利用多种格式，例如接受 XML 和 JSON，但在实践中这并不常见。总的来说，JSON 是目前最标准的格式。尽管如此，一些系统可能从使用多种格式中受益。

另一个重要的属性是确保某些操作是**幂等的**，而其他操作则不是。幂等操作可以多次重复，产生相同的结果，而重复非幂等操作将产生不同的结果。显然，操作应该是相同的。

这的一个明显例子是创建新元素。如果我们提交两个相同的`POST`创建资源列表中新元素的请求，它将创建两个新元素。例如，提交两个同名和同作者的书籍将创建两本相同的书籍。

这是在假设资源内容没有限制的情况下。如果有，第二次请求将失败，在任何情况下都会产生与第一次不同的结果。

另一方面，两个`GET`请求将产生相同的结果。对于`PUT`或`DELETE`也是如此，因为它们将覆盖或“再次删除”资源。

事实表明，唯一非幂等请求是`POST`操作，这显著简化了处理问题时是否应该重试的设计措施。幂等请求可以在任何时候安全地重试，从而简化了处理如网络问题等错误。

## 头部和状态

HTTP 协议的一个重要细节有时可能会被忽视的是不同的头部和状态码。

头部包括关于请求或响应的元数据信息。其中一些是自动添加的，例如请求或响应体的尺寸。以下是一些值得考虑的有趣头部：

| 头部 | 类型 | 详情 |
| --- | --- | --- |
| `Authorization` | 标准 | 用于验证请求的凭证。 |
| `Content-Type` | 标准 | 请求体的类型，如`application/json`或`text/html`。 |
| `Date` | 标准 | 消息创建的时间。 |
| `If-Modified-Since` | 标准 | 发送者此时拥有资源的副本。如果自那时起没有变化，可以返回一个`304 未修改`响应（带有空体）。这允许缓存数据，并通过不返回重复信息来节省时间和带宽。这可以在`GET`请求中使用。 |
| `X-Forwarded-From` | 实际标准 | 存储消息起源的 IP 地址以及它经过的不同代理。 |
| `Forwarded` | 标准 | 与`X-Forwarded-From`相同。这是一个较新的头部，比`X-Forwarded-From`更不常见。 |

一个设计良好的 API 将利用头部来传达适当的信息，例如正确设置`Content-Type`或如果可能接受缓存参数。

可以在[`developer.mozilla.org/en-US/docs/Web/HTTP/Headers`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)找到完整的头部列表。

另一个重要细节是充分利用可用的状态码。状态码提供了关于发生情况的重要信息，并且尽可能为每种情况使用最详细的信息将提供更好的接口。

**以下是一些常见的状态码：**

| 状态码 | 描述 |
| --- | --- |
| `200 OK` | 成功的资源访问或修改。它应该返回一个体；如果不返回，则使用`204 无内容`。 |
| `201 已创建` | 成功的`POST`请求，用于创建新资源。 |
| `204 无内容` | 一个成功但不返回体的请求，例如成功的`DELETE`请求。 |
| `301 永久移动` | 访问的资源现在永久位于不同的 URI。它应该返回一个包含新 URI 的`Location`头。大多数库将自动跟进`GET`访问。例如，API 仅可通过`HTTPS`访问，但被访问的是`HTTP`。 |
| `302 找到` | 访问的资源临时位于不同的 URI。一个典型例子是在经过身份验证后重定向到登录页面。 |
| `304 未修改` | 缓存的资源仍然有效。正文应为空。只有在客户端请求缓存信息时，例如使用`If-Modified-Since`头，才会返回此状态码。 |
| `400 错误请求` | 请求中存在一个通用错误。这是服务器在说：“你的端发生了错误。”应该在正文中添加一个更详细的错误信息。如果可能的话，应该使用更详细的错误状态码。 |
| `401 未授权` | 请求不允许，因为请求没有正确认证。请求可能缺少用于认证的有效头。 |
| `403 禁止` | 请求已认证，但不能访问此资源。这与`401 未授权`状态不同，因为请求已经正确认证，但没有访问权限。 |
| `404 未找到` | 这可能是最著名的状态码！由 URI 描述的资源无法找到。 |
| `405 方法不允许` | 请求的方法不能使用；例如，资源不能被删除。 |
| `429 请求过多` | 如果客户端可以进行的请求数量有限制，服务器应返回此状态码。应在正文中返回描述或更多信息，并且理想情况下，返回一个`Retry-After`头，指示下一次重试的时间（以秒为单位）。 |
| `500 服务器错误` | 服务器中存在一个通用错误。只有在服务器发生意外错误时才应使用此状态。 |
| `502 网关错误` | 服务器正在将请求重定向到不同的服务器，并且通信不正确。此错误通常出现在某些后端服务不可用或配置不正确的情况下。 |
| `503 服务不可用` | 服务器目前无法处理请求。这通常是一个临时情况，例如负载问题。它可以用来标记维护停机时间，但这通常很少见。 |
| `504 网关超时` | 与`502 网关错误`类似，但在此情况下，后端服务没有响应，导致超时。 |

通常，非描述性错误代码，如`400 错误请求`和`500 服务器错误`，应保留用于通用情况。然而，如果有更好的、更详细的错误状态码，则应使用该状态码。

例如，如果要对参数进行覆盖的`PATCH`请求，如果参数由于任何原因不正确，则应返回`400 错误请求`，但如果资源 URI 未找到，则返回`404 未找到`。

有其他的状态码。您可以在以下位置查看一个包含每个状态码详细信息的综合列表：[`httpstatuses.com/`](https://httpstatuses.com/).

在任何错误中，请向用户提供一些额外的反馈，包括原因。一个通用的描述符可以帮助处理意外情况并简化问题调试。

这对于`4XX`错误特别有用，因为它们将帮助 API 的用户修复自己的错误，并迭代地改进他们的集成。

例如，提到的`PATCH`可能会返回以下正文：

```py
{

    "message": "Field 'address' is unknown"

} 
```

这将给出关于问题的具体细节。其他选项包括返回错误代码、在存在多个可能错误的情况下返回多条消息，以及在正文中重复状态代码。

## 设计资源

RESTful API 中可用的操作仅限于 CRUD 操作。因此，资源是 API 的基本构建块。

将一切变成资源有助于创建非常明确的 API，并有助于满足 RESTful 接口的无状态要求。

无状态服务意味着满足请求所需的所有信息要么由调用者提供，要么从外部检索，通常是从数据库中检索。这排除了其他保持信息的方式，例如在相同服务器的硬盘上本地存储信息。这使得任何服务器都能处理每个单独的请求，这对于实现可扩展性至关重要。

可以通过创建不同的动作激活的元素可以分离到不同的资源中。例如，模拟笔的接口可能需要以下元素：

+   开启和关闭笔。

+   写东西。只有开启的笔才能书写。

在某些 API 中，如面向对象的 API，这可能涉及创建笔对象并更改其状态：

```py
pen = Pen()

pen.open()

pen.write("Something")

pen.close() 
```

在 RESTful API 中，我们需要为笔及其状态创建不同的资源：

```py
# Create a new pen with id 1

POST /pens

# Create a new open pen for pen 1

POST /pens/1/open

# Update the new open text for the open pen 1

PUT /pens/1/open/1/text

# Delete the open pen, closing the pen

DELETE /pens/1/open/1 
```

这可能看起来有点繁琐，但 RESTful API 应该旨在比典型的面向对象 API 更高层次。可以直接创建文本，或者创建笔然后创建文本，而不必执行开启/关闭操作。

请记住，RESTful API 是在远程调用上下文中使用的。这意味着它们不能是低级的，因为与本地 API 相比，每个调用都是一个大的投资，因为调用时间将是操作中一个合理的部分。

注意，每个方面和步骤都会被注册，并有自己的标识符集，是可寻址的。这比面向对象中可以找到的内部状态更明确。正如我们所看到的，我们希望它是无状态的，而对象则非常具有状态性。

请记住，资源不一定需要直接翻译成数据库对象。这是从存储到 API 的逆向思维。记住，你并不局限于这一点，可以组合从多个来源获取信息或不适合直接翻译的资源。我们将在下一章中看到示例。

如果来自更传统的面向对象环境，仅处理资源可能需要某些适应，但它们是非常灵活的工具，可以分配多种执行动作的方式。

## 资源和参数

虽然一切都是资源，但某些元素作为与资源交互的参数更有意义。这在修改资源时非常自然。任何更改都需要提交以更新资源。但是，在其他情况下，某些资源可能因其他原因而修改。最常见的情况是搜索。

典型的搜索端点将定义一个 `search` 资源并检索其结果。然而，没有过滤参数的搜索实际上并不实用，因此需要额外的参数来定义搜索，例如：

```py
# Return every pen in the system

GET /pens/search

# Return only red pens

GET /pens/search?color=red

# Return only red pens, sorted by creation date

GET /pens/search?color=red&sort=creation_date 
```

这些参数存储在查询参数中，这是检索它们的自然扩展。

作为一般规则，只有 `GET` 请求应该有查询参数。其他类型的请求方法应将任何参数作为正文的一部分提供。

如果包含查询参数，`GET` 请求也容易进行缓存。如果搜索返回每个请求相同的值，鉴于这是一个幂等请求，包括查询参数在内的完整 URI 可以在外部进行缓存。

按照惯例，存储 `GET` 请求的所有日志也将存储查询参数，而作为请求头或正文发送的任何参数都不会被记录。这具有安全影响，因为任何合理的参数，如密码，都不应该作为查询参数发送。

有时，这是创建通常会是 `GET` 请求的 `POST` 操作的原因，但更倾向于在请求的正文而不是查询参数中设置参数。虽然在 HTTP 协议中可以在 `GET` 请求中设置正文，但这绝对是非常不寻常的。

这种情况的例子可能是通过电话号码、电子邮件或其他个人信息进行搜索，因此中间人代理可以拦截并了解它们。

使用 `POST` 请求的另一个原因是允许更大的参数空间，因为包括查询参数在内的完整 URL 通常限制在 2K 大小，而正文的大小限制则小得多。

## 分页

在 RESTful 接口中，任何返回合理数量元素的 `LIST` 请求都应该进行分页。

这意味着可以从请求中调整元素和页面的数量，只返回特定页面的元素。这限制了请求的范围，避免了非常慢的响应时间和传输字节的浪费。

一个例子可能涉及使用 `page` 和 `size` 参数，例如：

```py
# Return only first 10 elements

GET /pens/search?page=1&size=10 
```

一个构建良好的响应将具有与此类似的格式：

```py
{

    "next": "http://pens.pns/pens/search?page=2&size=10",

    "previous": null,

    "result": [

        # elements

    ]

} 
```

它包含一个 `result` 字段，其中包含结果列表，以及 `next` 和 `previous` 字段，它们是到下一页和上一页的超链接，如果不可用，则值为 `null`。这使得遍历所有结果变得容易。

一个 `sort` 参数也可以用来确保页面的一致性。

这种技术还允许并行检索多页，这可以加快信息的下载速度，通过进行几个小请求而不是一个大请求来实现。然而，目标是为通常返回不太多的信息提供足够的过滤参数，以便只检索相关信息。

分页有一个问题，即集合中的数据可能在多个请求之间发生变化，尤其是在检索多页时。问题如下：

```py
# Obtain first page

GET /pens/search?page=1&size=10&sort=name

# Create a new resource that is added to the first page

POST /pens

# Obtain second page

GET /pens/search?page=2&size=10&sort=name 
```

第二页现在有一个重复的元素，它曾经在一页上，但现在已移动到第二页，然后还有一个未返回的元素。通常，新资源的未返回并不是一个大问题，因为毕竟信息检索是在其创建之前开始的。然而，相同资源的重复返回可能会是。

为了避免这类问题，默认按创建日期或类似方式排序值是有可能的。这样，任何新的资源都将添加到分页的末尾，并且可以一致地检索。

对于返回固有“新”元素的资源，如通知或类似资源，添加一个`updated_since`参数以检索自最近访问以来仅有的新资源。这以实际方式加快了访问速度，并检索了相关信息。

创建一个灵活的分页系统可以增加任何 API 的有用性。确保您的分页定义在所有不同资源中是一致的。

## 设计 RESTful API 的过程

设计 RESTful API 的最佳方式是明确声明资源，然后描述它们，包括以下细节：

+   *描述*：操作的描述

+   *资源 URI*：请注意，这可以用于多个操作，通过方法区分（例如，GET 用于检索和 DELETE 用于删除）

+   *适用的方法*：在此端点定义的操作中使用的 HTTP 方法

+   *(只有相关时) 输入体*：请求的输入体

+   *预期结果在体中*：结果

+   *可能预期的错误*：根据特定错误返回状态码

+   *描述*：操作的描述

+   *(只有相关时) 输入查询参数*：要添加到 URI 的查询参数以提供额外功能

+   (*只有相关时) 相关头信息*：任何支持的头部

+   *(只有相关时) 返回非普通状态码（200 和 201）*：与错误不同，如果存在被认为是成功但不是常规情况的状态码；例如，成功返回重定向

这将足够创建一个其他工程师可以理解的设计文档，并允许他们在此接口上工作。

然而，先快速草拟不同的 URI 和方法，并快速查看系统中的所有不同资源，而不深入细节，如正文描述或错误，是一种良好的实践。这有助于检测 API 中缺失的资源差距或其他不一致性。

例如，本章中描述的 API 有以下操作：

```py
GET    /pens

POST   /pens

POST   /pens/<pen_id>/open

PUT    /pens/<pen_id>/open/<open_pen_id>/text

DELETE /pens/<pen_id>/open/<open_pen_id>

GET    /pens/search 
```

这里有一些细节可以调整和改进：

+   看起来我们忘记添加删除笔的动作了，一旦创建

+   应该添加几个`GET`操作来检索有关已创建资源的详细信息

+   在`PUT`操作中，添加`/text`感觉有点冗余

在这个反馈的基础上，我们再次如下描述 API（修改处有箭头）：

```py
GET    /pens

POST   /pens

GET    /pens/<pen_id> 

DELETE /pens/<pen_id> ←

POST   /pens/<pen_id>/open

GET    /pens/<pen_id>/open/<open_pen_id> ←

PUT    /pens/<pen_id>/open/<open_pen_id> ←

DELETE /pens/<pen_id>/open/<open_pen_id>

GET    /pens/search 
```

注意在分层结构中的组织如何有助于仔细查看所有元素，并找到可能一开始并不明显的空白或关系。

之后，我们可以深入了解。我们可以使用本节开头描述的模板，或者任何适合你的其他模板。例如，我们可以定义创建一个新笔和读取系统中笔的端点：

**创建一个新的笔：**

+   *描述*：创建一个新的笔，指定颜色。

+   *资源 URI*： `/pens`

+   *方法*： `POST`

+   *输入体*：

    ```py
    {

        "name": <pen name>,

        "color": (black|blue|red)

    } 
    ```

+   *错误*：

    ```py
    400 Bad Request 
    ```

主体中的错误，例如一个未识别的颜色、重复的名称或格式错误。

**检索现有的笔：**

+   *描述*：检索现有的笔。

+   *资源 URI*： `/pens/<pen id>`

+   *方法*： `GET`

+   *返回体*：

    ```py
    {

        "name": <pen name>,

        "color": (black|blue|red)

        } 
    ```

+   *错误*：

    ```py
    404 Not Found 

    The pen ID is not found. 
    ```

主要目标是这些小模板既实用又简洁。请随意按预期调整它们，不必担心对错误或细节过于详尽。最重要的是它们是**实用**的；例如，添加一个`405 Method Not Allowed`消息可能是多余的。

API 也可以使用 Postman ([www.postman.com](https://www.postman.com))等工具设计，这是一个 API 平台，可以用来设计或测试/调试现有的 API。虽然很有用，但能够在不使用外部工具的情况下设计 API 是很好的，以防万一需要，并且因为它迫使你思考设计而不是工具本身。我们还将看到如何使用基于定义的 Open API，而不是提供测试环境。

设计和定义一个 API 也可以使其在之后以标准方式结构化，以便利用工具。

## 使用 Open API 规范

一个更结构化的替代方案是使用像 Open API ([`www.openapis.org/`](https://www.openapis.org/))这样的工具。Open API 是通过 YAML 或 JSON 文档定义 RESTful API 的规范。这允许这个定义与其他工具交互，为 API 生成自动文档。

它允许定义可以重复的不同组件，无论是作为输入还是输出。这使得构建一致的可重复使用的对象变得容易。还有从彼此继承或组合的方法，从而创建一个丰富的接口。

详细描述整个 Open API 规范超出了本书的范围。大多数常见的 Web 框架都允许与之集成，自动生成 YAML 文件或我们稍后看到的 Web 文档。它之前被称为 Swagger，其网页([`swagger.io/`](https://swagger.io/))有一个非常有用的编辑器和其他资源。

例如，这是一个描述上述两个端点的 YAML 文件。该文件可在 GitHub 上找到：[`github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml`](https://github.com/PacktPublishing/Python-Architecture-Patterns/blob/main/pen_example.yaml)

```py
openapi: 3.0.0

info:

  version: "1.0.0"

  title: "Swagger Pens"

paths:

  /pens:

    post:

      tags:

      - "pens"

      summary: "Add a new pen"

      requestBody:

        description: "Pen object that needs to be added to the store"

        required: true

        content:

          application/json:

            schema:

              $ref: "#/components/schemas/Pen"

      responses:

        "201":

          description: "Created"

        "400":

          description: "Invalid input"

  /pens/{pen_id}:

    get:

      tags:

      - "pens"

      summary: "Retrieve an existing pen"

      parameters:

      - name: "pen_id"

        in: path

        description: "Pen ID"

        required: true

        schema:

          type: integer

          format: int64

      responses:

        "200":

          description: "OK"

          content:

            application/json:

              schema:

                $ref: "#/components/schemas/Pen"

        "404":

          description: "Not Found"

components:

  schemas:

    Pen:

      type: "object"

      properties:

        name:

          type: "string"

        color:

          type: "string"

          enum:

            - black

            - blue

            - red 
```

在`components`部分，定义了`Pen`对象，然后在其两个端点中使用。您可以看到如何定义两个端点，`POST /pens`和`GET /pens/{pen_id}`，并描述预期的输入和输出，考虑到可能产生的不同错误。

Open API 最有趣的特点之一是能够自动生成包含所有信息的文档页面，以帮助任何可能的实现。生成的文档看起来像这样：

![图形用户界面，文本，应用程序，电子邮件]

自动生成的描述](img/B17580_02_01.png)

图 2.1：Swagger Pens 文档

如果 YAML 文件正确且完整地描述了您的界面，这将非常有用。在某些情况下，从 YAML 到 API 的工作可能更有优势。这首先生成 YAML 文件，并允许从那里双向工作，无论是前端方向还是后端方向。对于以 API 为先的方法，这可能是有意义的。甚至可以自动在多种语言中创建客户端和服务器的基本框架，例如，Python Flask 或 Spring 中的服务器，以及 Java 或 Angular 中的客户端。

请记住，确保实现与定义紧密匹配的责任在于您。这些基本框架仍然需要足够的工作才能正确运行。Open API 将简化这个过程，但不会神奇地解决所有集成问题。

每个端点都包含更多信息，甚至可以在同一文档中进行测试，从而极大地帮助希望使用 API 的外部开发者，正如我们可以在下一张图中看到：

![图形用户界面，应用程序]

自动生成的描述](img/B17580_02_02.png)

图 2.2：Swagger Pens 扩展文档

考虑到即使设计不是从 Open API YAML 文件开始的，也很容易确保服务器可以生成这种自动文档，因此生成它是件好事，以便创建自生成文档。

# 认证

几乎任何 API 的关键部分都是能够区分授权和不授权的访问。能够正确记录用户至关重要，从安全角度来看，这是一个头疼的问题。

安全性很难，因此最好依赖于标准来简化操作。

正如我们之前所说，这些只是一些一般性的建议，但绝不是一套全面的网络安全实践。本书并不专注于安全。请关注安全问题及其解决方案，因为这是一个始终在发展的领域。

与认证相关的最重要的安全问题是在生产环境中始终使用 HTTPS 端点。这允许保护通道免受窃听，并使通信私密。请注意，一个 HTTP 网站仅仅意味着通信是私密的；你可能在和恶魔交谈。但它是最基本的要求，允许您的 API 用户发送密码和其他敏感信息，而不用担心外部用户会接收到这些信息。

通常，大多数架构在请求达到数据中心或安全网络之前使用 HTTPS，然后内部使用 HTTP。这允许检查内部流动的数据，同时也保护了跨互联网传输的数据。虽然现在这不太重要，但它也提高了效率，因为将请求编码为 HTTPS 需要额外的处理能力。

HTTPS 端点对所有访问都有效，但其他细节取决于它们是 HTML 界面还是 RESTful 界面。

## 验证 HTML 界面

在 HTML 网页中，通常验证流程如下：

1.  用户界面会显示登录界面。

1.  用户输入他们的登录名和密码，并将它们发送到服务器。

1.  服务器验证密码。如果正确，它将返回一个包含会话 ID 的 cookie。

1.  浏览器接收到响应并存储 cookie。

1.  所有新的请求都会发送 cookie。服务器将验证 cookie 并正确识别用户。

1.  用户可以注销，删除 cookie。如果这样做是明确的，则会向服务器发送请求以删除会话 ID。通常，会话 ID 将有一个过期时间来自动清理。这个过期时间可以在每次访问时更新，或者强制用户时不时地重新登录。

将 cookie 设置为`Secure`、`HttpOnly`和`SameSite`非常重要。`Secure`确保 cookie 只发送到 HTTPS 端点，而不是 HTTP 端点。`HttpOnly`使 cookie 无法通过 JavaScript 访问，这使得通过恶意代码获取 cookie 更加困难。cookie 将自动发送到设置它的主机。`SameSite`确保只有在源页面来自同一主机时才会发送 cookie。它可以设置为`Strict`、`Lax`和`None`。`Lax`允许您从不同站点导航到页面，从而发送 cookie，而`Strict`则不允许。

您可以在 Mozilla SameSite Cookie 页面获取更多信息：[`developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite)。

cookie 的潜在不良使用是通过 XSS（跨站脚本）攻击。受损害的脚本读取该 cookie，然后伪造出作为用户认证的恶意请求。

另一种重要的安全问题是**跨站请求伪造**（**CSRF**）。在这种情况下，利用用户在外部服务上登录的事实，通过展示一个将在不同的、受损害的网站上自动执行的 URL。

例如，在访问论坛时，会调用一个来自普通银行的 URL，以图片的形式展示。如果用户已经登录到这个银行，操作将会执行。

`SameSite`属性大大降低了 CSRF 的风险，但如果老版本的浏览器不理解这个属性，银行向用户展示的操作应该提供一个随机令牌，使用户发送带有 cookie 的认证请求和一个有效的令牌。外部页面不会知道一个有效的随机令牌，这使得这种攻击变得更加困难。

存储在 cookie 中的会话 ID 可以是存储在数据库中，仅仅是一个随机唯一的标识符，或者是一个丰富的令牌。

随机标识符正是如此，只是一个随机数字，用于在数据库中存储相关信息，主要是谁在访问以及会话何时过期。每次访问时，这个会话 ID 都会查询到服务器，并检索相关信息。在非常大的部署中，由于访问量很大，这可能会造成问题，因为它不够可扩展。存储会话 ID 的数据库需要所有工作者访问，这可能会造成瓶颈。

一种可能的解决方案是创建一个丰富的数据令牌。这是通过直接将所有必要的信息添加到 cookie 中实现的；例如，直接存储用户 ID、过期时间等。这避免了数据库访问，但使得 cookie 可能被伪造，因为所有信息都是公开的。为了解决这个问题，cookie 被签名。

签名证明数据是由受信任的登录服务器生成的，并且可以被任何其他服务器独立验证。这更可扩展，避免了瓶颈。可选地，内容也可以被加密，以避免被读取。

这个系统的另一个优点是令牌的生成可以独立于通用系统。如果令牌可以独立验证，就没有必要让登录服务器与通用服务器相同。

更重要的是，单个令牌签发者可以为多个服务发行令牌。这是**单点登录**（**SSO**）的基础：登录到认证提供者，然后使用相同的账户在多个相关服务中使用。这在像 Google、Facebook 或 GitHub 这样的常见服务中非常普遍，以避免为某些网页创建特定的登录。

那种拥有令牌授权的操作模式是 OAuth 授权框架的基础。

## 验证 RESTful 接口

OAuth 已成为 API 认证的通用标准，尤其是 RESTful API。

认证和授权之间存在差异，本质上，OAuth 是一个授权系统。认证是确定用户身份，而授权是用户能够做什么。OAuth 使用`作用域`的概念来返回用户的能力。

大多数 OAuth 实现，如 OpenID Connect，也将用户信息包含在返回的令牌中，以验证用户，并返回用户身份。

它基于这样一个想法：存在一个授权者可以检查用户的身份并向他们提供包含允许用户登录信息的令牌。该服务将接收此令牌并记录用户：

![图解自动生成的描述](img/B17580_02_03.png)

图 2.3：认证流程

目前最常用的版本是 OAuth 2.0，它允许在登录和流程方面具有灵活性。请记住，OAuth 并不完全是一个协议，但它提供了一些可以针对特定用例进行调整的想法。

这意味着你可以以不同的方式实现 OAuth，并且，关键的是，不同的授权者将会有不同的实现方式。在实施集成时，请仔细验证他们的文档。

通常，授权者使用基于 OAuth 的 OpenID Connect 协议。

当 API 访问系统是最终用户直接访问，还是代表用户访问时，在这一点上有重要差异。后者的一个例子可能是用于访问 Twitter 等服务智能手机应用，或者需要访问 GitHub 中存储的用户数据的工具，如代码分析工具。该应用本身并不执行操作，而是转移用户的操作。

这种流程被称为授权代码授予。其主要特点是授权提供商会向用户展示登录页面，并使用认证令牌将他们重定向。

例如，这是授权代码授予的调用序列：

```py
GET https://myservice.com/login

    Return a page with a form to initiate the login with authorizer.com

Follow the flow in the external authorize until login, with something like.

POST https://authorizer.com/authorize

  grant_type=authorization_code

  redirect_uri=https://myservice.com/redirect

  user=myuser

  password=mypassword

    Return 302 Found to https://myservice.com/redirect?code=XXXXX

GET https://myservice.com/redirect?code=XXXXX

-> Login into the system and set proper cookie, 

   return 302 to https://myservice.com 
```

如果访问 API 的系统直接来自最终用户，则可以使用客户端凭据授予类型流程。在这种情况下，第一个调用将发送`client_id`（用户 ID）和`client_secret`（密码）以直接检索认证令牌。此令牌将在新的调用中作为头信息设置，以验证请求。

注意，这跳过了一步，并且更容易自动化：

```py
POST /token HTTP/1.1

  grant_type=authorization_code

  &client_id=XXXX

  &client_secret=YYYY

    Returns a JSON body with

    {

  "access_token":"ZZZZ",

  "token_type":"bearer",

  "expires_in":86400,

}

Make new requests setting the header

Authorization: "Bearer ZZZZ" 
```

虽然 OAuth 允许你使用外部服务器来检索访问令牌，但这并不是严格必需的。它可以与其它服务器相同。这对于最后一个流程很有用，在这个流程中，使用外部提供者（如 Facebook 或 Google）进行登录的能力并不那么有用。我们的示例系统将使用客户端凭据流程。

### 自编码令牌

来自授权服务器的返回令牌可以包含足够的信息，以至于不需要与授权者进行外部检查。

正如我们所见，将用户信息包含在令牌中对于确定用户身份很重要。如果不这样做，我们将得到一个能够执行工作但缺乏代表谁的信息的请求。

要这样做，通常将令牌编码为**JSON Web Token**（**JWT**）。JWT 是一种标准，它将 JSON 对象编码为一系列 URL 安全的字符。

JWT 具有以下元素：

+   一个头信息。这包含有关令牌如何编码的信息。

+   一个有效载荷。令牌的主体。此对象中的一些字段，称为声明，是标准的，但也可以分配自定义声明。标准声明不是必需的，可以描述元素，例如发行者（`iss`）或令牌的过期时间作为 Unix 纪元（`exp`）。

+   一个签名。这验证令牌是由正确来源生成的。这使用不同的算法，基于头信息中的信息。

通常，JWT 是编码的，但不是加密的。标准的 JWT 库将解码其部分并验证签名是否正确。

您可以在交互式工具中测试不同的字段和系统：[`jwt.io/`](https://jwt.io/).

例如，要使用`pyjwt`（[`pypi.org/project/PyJWT/`](https://pypi.org/project/PyJWT/)）生成令牌，如果尚未安装，您需要使用 pip 安装 PyJWT：

```py
$ pip install PyJWT 
```

然后，在打开 Python 解释器时，要创建一个包含用户 ID 并使用 HS256 算法签名的令牌，使用以下代码：

```py
>>> import jwt

>>> token = jwt.encode({"user_id": "1234"}, "secret", algorithm="HS256")

>>> token

'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoiMTIzNCJ9.vFn0prsLvRu00Kgy6M8s6S2Ddnuvz-FgtQ7nWz6NoC0' 
```

JWT 令牌然后可以被解码，并提取有效载荷。如果密钥不正确，它将产生错误：

```py
>>> jwt.decode(token,"secret", algorithms=['HS256'])

{'user_id': '1234'}

>>> jwt.decode(token,"badsecret", algorithms=['HS256'])

Traceback (most recent call last):

 …

  jwt.exceptions.InvalidSignatureError: Signature verification failed 
```

要使用的算法存储在头信息中，但出于安全考虑，只使用预期的算法验证令牌是个好主意，不要依赖于头信息。在过去，某些 JWT 实现和令牌伪造存在一些安全问题，您可以在此处阅读：[`www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html`](https://www.chosenplaintext.ca/2015/03/31/jwt-algorithm-confusion.html).

然而，最有趣的算法并不是像`HS256`这样的对称算法，其中编码和解码时添加相同的值，而是像 RSA-256（`RS256`）这样的公私钥。这允许使用私钥对令牌进行编码，并使用公钥进行验证。

此架构非常常见，因为公钥可以广泛分发，但只有拥有私钥的正确授权者才能成为令牌的来源。

包含可用于识别用户的有效载荷信息，允许使用有效载荷中的信息进行请求的认证，一旦验证，正如我们之前讨论的那样。

# API 版本控制

接口很少是从零开始完全创建的。它们不断地被调整，添加新功能，修复错误或不一致。为了更好地传达这些变化，创建某种形式的版本控制来传递这些信息是有用的。

## 为什么需要版本控制？

版本控制的主要优势是塑造关于何时包含哪些内容的对话。这可以是错误修复、新功能，甚至是新引入的错误。

如果我们知道当前发布的接口版本是`v1.2.3`，而我们即将发布版本`v1.2.4`，该版本修复了错误 X，我们可以更容易地讨论这个问题，以及创建发布说明通知用户这一事实。

## 内部版本与外部版本

有两种版本可能会有些混淆。一种是内部版本，这是项目开发者有意义的东西。这通常与软件版本相关，通常需要版本控制（如 Git）的帮助。

这个版本非常详细，可以涵盖非常小的变化，包括小的错误修复。它的目的是能够检测到软件之间的最小变化，以便检测错误或引入代码。

另一种是外部版本。外部版本是使用外部服务的用户将能够感知到的版本。虽然它可以像内部版本一样详细，但这通常对用户没有太大帮助，并且可能会提供令人困惑的信息。

这在很大程度上取决于系统的类型以及预期的用户是谁。技术用户会欣赏额外的细节，但更随意的用户则不会。

例如，内部版本可能区分两种不同的错误修复，因为这有助于复制。外部沟通的版本可以将它们两者结合为“多个错误修复和改进。”

另一个有用的例子是在接口发生重大变化时区分版本。例如，一个网站外观和感觉的全新改版可以使用“版本 2 接口”，但这可以在多个内部新版本中发生，以供内部测试或选定的小组（例如，测试人员）测试。最后，当“版本 2 接口”准备就绪时，它可以对所有用户激活。

描述外部版本的一种方法可能是将其称为“营销版本。”

注意，我们在这里避免使用“发布版本”这个术语，因为它可能会引起误导。这个版本仅用于对外部信息进行沟通。

这个版本将更多地依赖于营销努力，而不是技术实现。

## 语义版本控制

定义版本的一个常见模式是使用语义版本控制。语义版本控制描述了一种使用三个递增整数的方法，这些整数具有不同的含义，按不兼容性降序排列：

`vX.Y.Z`

X 被称为**主版本**。主版本的任何变化都意味着向后不兼容的变化。

Y 是**次要**版本。次要更改可能会添加新功能，但任何更改都将保持向后兼容。

Z 是**修补**版本。它只会进行小的更改，例如错误修复和安全补丁，但它不会改变接口本身。

开头的`v`是可选的，但有助于表明它是一个版本号。

这意味着设计用于与`v1.2.15`一起工作的软件将能够与版本`v1.2.35`和`v1.3.5`一起工作，但它不能与版本`v2.1.3`或版本`v1.1.4`一起工作。它可能与版本`v1.2.14`一起工作，但可能存在后来被纠正的错误。

有时，可以添加额外的细节来描述尚未准备好的接口，例如，`v1.2.3-rc1`（发布候选）或`v1.2.3-dev0`（开发版本）。

通常，在软件准备发布之前，主版本号被设置为零（例如，`v0.1.3`），使得版本`v1.0.0`成为第一个公开可用的版本。

这种语义版本号非常容易理解，并提供了关于更改的良好信息。它被广泛使用，但在某些情况下存在一些问题：

+   对于没有明确向后兼容性的系统，严格采用主版本号可能很困难。这就是为什么 Linux 内核停止使用正确的语义版本号的原因，因为他们永远不会更新主版本号，因为每个发布都需要向后兼容。在这种情况下，主版本号可能被冻结多年，并停止作为一个有用的参考。在 Linux 内核中，这种情况发生在版本 2.6.X 上，它持续了 8 年，直到 2011 年发布了没有向后不兼容变化的版本 3.0。

+   语义版本号要求对接口有一个相当严格的定义。如果接口经常随着新功能的变化而变化，就像在线服务通常发生的那样，次要版本会迅速增加，而修补版本几乎没有任何用处。

对于在线服务，两者的组合只会使一个数字有用，这不是很好的利用。语义版本号在需要同时运行多个 API 版本的情况下效果更好，例如：

+   该 API 非常稳定，变化很少，尽管有定期的安全更新。每隔几年，就会有一个主要更新。一个好的例子是数据库，如 MySQL。操作系统是另一个例子。

+   该 API 属于一个软件库，可以被多个支持的环境使用；例如，一个与 Python 2 版本 v4 和 Python 3 版本 v5 兼容的 Python 库。这可以在需要时保持多个版本存活。

如果系统实际上同时运行一个版本，那么最好不要额外努力保持适当的语义版本号，因为这种努力与所需的回报相比不值得。

## 简单版本号

相比于严格的语义版本控制，可以采用简化的版本控制。这不会传达相同的意义，但将是一个不断增长的计数器。这将有助于协调团队，尽管它不会要求相同的承诺。

这与编译器可以自动创建的构建号相同，是一个递增的数字，用于区分不同版本并作为参考。然而，纯构建号可能有点枯燥。

使用与语义版本控制类似的架构会更好，因为这样每个人都能理解；但与使用特定规则相比，它更为宽松：

+   通常，对于新版本，增加补丁版本号。

+   如果补丁版本号过高（换句话说，100、10 或另一个任意数字），则增加小版本号并将补丁版本号设为零。

+   或者，如果项目有任何特殊里程碑，如项目组成员所定义的，则应提前增加小版本号。

+   同样对主版本号进行相同的处理。

这样做可以让数字以一致的方式增加，而不必过于担心其意义。

这种结构非常适合像在线云服务这样的东西，本质上需要递增的计数器，因为它们同时部署了单个版本。在这种情况下，版本的最重要用途是内部使用，并且不需要严格的语义版本控制所要求的维护。

# 前端和后端

常见的区分不同服务的方式是通过谈论“前端”和“后端”。它们描述了软件的层级，其中靠近最终用户的层级是前端，而位于其后的则是后端。

传统上，前端是负责用户界面的层级，紧邻用户，而后端是数据访问层，它服务于业务逻辑。在客户端-服务器架构中，客户端是前端，服务器是后端：

![图解自动生成的描述](img/B17580_02_04.png)

图 2.4：客户端-服务器架构

随着架构的日益复杂，这些术语变得有些多义，它们通常根据上下文来理解。虽然*前端*几乎总是被理解为直接的用户界面，*后端*可以应用于多个层级，意味着为正在讨论的任何系统提供支持的下一层。例如，在云应用中，Web 应用可能使用 MySQL 数据库作为存储后端，或者使用 Redis 作为缓存后端。

前端和后端的一般方法相当不同。

前端专注于用户体验，因此最重要的元素是可用性、令人愉悦的设计、响应性等。其中很多都需要对“最终外观”和如何使事物易于使用有敏锐的洞察力。前端代码在最终用户处执行，因此不同类型硬件之间的兼容性可能很重要。同时，它分散了负载，因此从用户界面的角度来看，性能最为重要。

后端更注重稳定性。在这里，硬件处于严格控制之下，但负载并未分配，因此在控制总资源使用方面，性能变得尤为重要。修改后端也更为容易，因为一旦更改，所有用户都会同时受到影响。但这也更具风险，因为这里的问题可能会影响每一个用户。这种环境更倾向于关注稳健的工程实践和可复制性。

“全栈工程师”这个术语通常用来描述那些对这两种工作都感到舒适的人。虽然在某些方面这可能可行，但实际上很难找到在长期内对这两个元素都同样舒适或倾向于同时从事这两个元素的人。

大多数工程师自然会倾向于某一端，而大多数公司都会有不同的团队分别负责这两个方面。在某种程度上，每个工作所需的个性特征是不同的，前端工作需要更多对设计的关注，而后端用户则更适应稳定性和可靠性实践。

通常，用于前端的一些常见技术如下：

+   HTML 及其相关技术，如 CSS

+   JavaScript 以及用于增加交互性的库或框架，如 jQuery 或 React

+   设计工具

后端技术，由于它们处于更直接的控制之下，因此可以更加多样化，例如：

+   多种编程语言，无论是脚本语言如 Python、PHP、Ruby，还是使用 Node.js 的 JavaScript，甚至是编译语言如 Java 或 C#。它们甚至可以混合使用，使不同元素使用不同的语言。

+   数据库，无论是关系型数据库如 MySQL 或 PostgreSQL，还是非关系型数据库如 MongoDB、Riak 或 Cassandra。

+   网络服务器，如 Nginx 或 Apache。

+   可扩展性和高可用性工具，如负载均衡器。

+   基础设施和云技术，如 AWS 服务。

+   与容器相关的技术，如 Docker 或 Kubernetes。

前端将利用后端定义的接口以用户友好的方式展示操作。同一个后端可以有多个前端，一个典型的例子是针对不同平台的多个智能手机界面，但它们使用相同的 API 与后端通信。

请记住，前端和后端是概念上的划分，但它们不一定需要划分为不同的进程或存储库。一个常见的前端和后端共存的情况是像 Ruby on Rails 或 Django 这样的 Web 框架，您可以在定义后端处理数据访问和业务逻辑的控制器的同时定义前端 HTML 界面。在这种情况下，HTML 代码直接从执行数据访问的同一进程提供。这个过程使用模型视图控制器结构来分离关注点。

## 模型视图控制器结构

模型视图控制器，或 MVC，是一种将程序逻辑分为三个不同组件的设计。

模型视图控制器模式在图形用户界面的设计初期就已经出现，并且自 80 年代第一个完整的图形交互界面以来，该模式一直被应用于该领域。在 90 年代，它开始作为一种处理 Web 应用程序的方式被引入。

+   这种结构非常成功，因为它创造了概念之间的清晰分离：

+   模型管理数据

+   控制器接受用户的输入并将其转换为对模型的操作

+   视图代表用户理解的信息

从本质上讲，模型是系统的核心，因为它处理数据的操作。控制器代表输入，视图代表操作的输出。

![形状自动生成的描述](img/B17580_02_05.png)

图 2.5：模型视图控制器模式

MVC 结构可以在不同的层面上进行考虑，它可以被视为分形。如果几个元素相互作用，它们可以有自己的 MVC 结构，并且系统的模型部分可以与提供信息的后端进行通信。

MVC 模式可以以不同的方式实现。例如，Django 声称它是一个模型视图**模板**，因为控制器更像是框架本身。然而，这些是微不足道的细节，并不与总体设计相矛盾。

模型可以说是三个元素中最重要的，因为它是其核心部分。它包含数据访问，同时也包含业务逻辑。一个丰富的模型组件充当一种从输入和输出中抽象应用程序逻辑的方式。

通常，控制器之间的某些障碍会变得有些模糊。不同的输入可能在控制器中处理，产生对模型的不同的调用。同时，输出可以在传递到视图之前在控制器中进行调整。虽然始终很难强制执行清晰、严格的边界，但记住每个组件的主要目标以提供清晰度是很好的。

# HTML 界面

虽然 API 的严格定义适用于设计为被其他程序访问的界面，但花点时间讨论如何创建成功的人机界面基础是很好的。为此，我们将主要讨论 HTML 界面，旨在由最终用户在浏览器中使用。

我们将要处理的大部分概念也适用于其他类型的人机界面，如 GUI 或移动应用。

HTML 技术与 RESTful 技术高度相关，因为它们在互联网早期并行开发。通常，它们在现代网络应用中被交织在一起展示。

## 传统 HTML 界面

传统网络界面通过 HTTP 请求工作，仅使用`GET`和`POST`方法。`GET`从服务器检索页面，而`POST`与一些表单配对，将数据提交到服务器。

这是一个先决条件，因为浏览器只实现了这些方法。虽然如今，大多数现代浏览器都可以在请求中使用所有 HTTP 方法，但允许与旧浏览器兼容仍然是一个常见的要求。

虽然这确实比所有可用选项都更加限制性，但它对于简单的网站界面来说可以很好地工作。

例如，博客的阅读次数远多于写作次数，因此读者会使用大量的`GET`请求来获取信息，也许还会使用一些`POST`请求来发送评论。删除或更改评论的传统需求很小，尽管它可以通过使用`POST`的其他 URL 来分配。

注意，在重试`POST`请求之前，浏览器会询问您，因为它们不是幂等的。

由于这些限制，HTML 界面与 RESTful 界面工作方式不同，但也可以通过考虑抽象和资源方法的设计来得到改进。

例如，以下是一些博客的常见抽象：

+   每个帖子及其相关评论

+   一个包含最新帖子的主页

+   一个可以返回包含特定单词或标签的帖子的搜索页面

这与资源界面中的界面非常相似，其中只有“评论”和“帖子”这两个资源，在 RESTful 方式中将它们分开，将它们结合在同一个概念中。

传统 HTML 界面的主要限制是每次更改都需要刷新整个页面。对于像博客这样的简单应用，这可以很好地工作，但更复杂的应用可能需要更动态的方法。

## 动态页面

为了给浏览器添加交互性，我们可以添加一些 JavaScript 代码，这些代码将在浏览器表示中直接执行操作以改变页面；例如，从下拉选择器中选择界面的颜色。

这被称为操作**文档对象模型**（**DOM**），它包含由 HTML 定义的文档表示，以及可能包含的 CSS。JavaScript 可以访问这种表示，并通过编辑任何参数或添加或删除元素来更改它。

从 JavaScript 中，也可以进行独立的 HTTP 请求，因此我们可以使用它来发出特定调用以检索可以添加以改善用户体验的详细信息。

例如，对于一个输入地址的表单，下拉菜单可以选择国家。一旦选择，服务器调用将检索适当的区域以包含输入。如果用户选择**美国**，将检索所有州并可在下一个下拉菜单中可用。如果用户选择**加拿大**，将使用地区和省的列表代替：

![图形用户界面自动生成描述](img/B17580_02_06.png)

图 2.5：使用适当的下拉菜单改进用户体验

另一个例子，可以稍微反转界面，可能是使用 ZIP 代码自动确定州。

实际上有一个名为[`zippopotam.us/`](https://zippopotam.us/)的服务可以检索此类信息。它可以被调用，并不仅返回州，还以 JSON 格式返回更多信息。

这类调用被称为**异步 JavaScript 和 XML**（**AJAX**）。尽管名称中提到了 XML，但并非必需，任何格式都可以检索。目前，使用 JSON 或甚至纯文本非常普遍。一种可能性是使用 HTML，这样可以将来自服务器的代码片段替换页面上的某个区域：

![形状，矩形自动生成描述](img/B17580_02_07.png)

图 2.6：使用 HTML 替换页面区域

纯 HTML，虽然有些不优雅，但可能有效，因此非常常见使用返回 JSON 的 RESTful API 来检索这些小元素所需的数据，然后通过 JavaScript 代码使用它来修改 DOM。鉴于此 API 的目标不是完全替换 HTML 界面，而是补充它，因此这个 RESTful API 可能是不完整的。仅使用这些 RESTful 调用无法创建完整体验。

其他应用直接从创建 API 优先的方法开始，并从那里创建浏览器体验。

## 单页应用

单页应用背后的理念很简单。让我们打开一个 HTML 页面，并动态更改其内容。如果有任何新数据需要，将通过特定的（通常是 RESTful）API 访问。

这完全将人类界面，即负责将信息显示给人类的元素，从服务中分离出来。该服务仅提供 RESTful API，无需担心数据的表示形式。

这种方法有时被称为 API 优先，因为它从 API 到表示设计系统，而不是相反，这是在有机服务中自然创建的方式。

尽管有专门为此目的设计的特定框架和工具，例如 React 或 AngularJS，但采用这种方法的两个主要挑战是：

+   在单页上创建成功的人机界面的技术技能要求相当高，即使有工具的帮助也是如此。任何非平凡的界面表示都需要保持大量的状态和应对多次调用。这容易出错，可能会损害页面的稳定性。传统的浏览器页面方法使用独立的页面，限制了每一步的范围，这更容易处理。

请记住，浏览器携带的界面期望可能难以避免或替换，例如点击后退按钮。

+   需要在项目开始前设计和准备 API 可能会导致项目启动缓慢。即使双方都并行开发，这也需要更多的规划和前期承诺，这也存在其挑战。

这些问题确保了这种方法通常不会用于从头开始的新应用。然而，如果应用是从另一种类型的用户界面开始的，比如智能手机应用，它可以利用现有的 REST API 来生成一个复制的 HTML 界面，以实现其功能。

这种方法的主要优势是将应用与用户界面分离。如果一个应用以一个小项目开始，其开发是从常规 HTML 界面开始的，那么任何其他用户界面都倾向于符合 HTML 界面。这可能会迅速积累大量的技术债务，并损害 API 的设计，因为所使用的抽象可能来自现有界面，而不是最合适的界面。

完全采用 API 优先的方法可以极大地分离界面，因此创建新界面与现有 API 一样容易使用。对于需要多个界面，如 HTML 界面，以及 iOS 和 Android 的不同智能手机应用的应用，这可能是一个好的解决方案。

单页应用在呈现完整界面方面也可以非常创新。这可以创建丰富和复杂的界面，与通常所说的“网页”不同，例如在游戏或交互式应用中。

## 混合方法

如我们所见，全面采用单页应用可能会相当具有挑战性。在某种程度上，这是在用浏览器覆盖其使用。

正因如此，通常设计不会走得太远，而是创建一个更传统的 Web 界面。这个界面仍然可以被识别为 Web 应用程序，但严重依赖于 JavaScript 来使用 RESTful 接口获取信息。这可能是从传统的 HTML 界面迁移到单页应用程序的自然步骤，但也可能是一个有意识的决策。

这种方法结合了前两种方法。一方面，它仍然需要一个 HTML 界面来处理界面的通用方法，有清晰的页面进行导航。另一方面，它创建了一个 RESTful API，填充了大部分信息，并使用 JavaScript 来利用这个 API。

这种方法类似于动态页面方法，但有一个重要的区别，即创建一个可以不针对 HTML 界面而使用的连贯 API 的意图。这显著改变了方法。

实际上，这往往会导致一个不太完整的 RESTful API，因为一些元素可能直接添加到它的 HTML 部分。但与此同时，它允许元素迭代迁移到 API 中，从某些元素开始，但随着时间的推移添加更多。这个阶段非常灵活。

# 为示例设计 API

正如我们在第一章中描述的，*示例概述*，我们需要为示例中将要工作的不同界面设置定义。请记住，示例是一个微博客应用程序，将允许用户编写自己的文本微帖子，以便其他人可以阅读。

示例中有两个主要界面：

+   一个 HTML 界面，允许用户使用浏览器与服务交互

+   一个 RESTful 接口，允许创建其他客户端，如智能手机应用程序

在本章中，我们将描述第二个界面的设计。我们将从描述我们将使用的基本定义和资源开始：

+   **用户**：应用程序用户的表示。它将通过用户名和密码来定义，以便能够登录。

+   **微帖子**：由**用户**发布的最多 255 个字符的小文本。**微帖子**可以可选地指向一个**用户**。它还包括创建时间。

+   **集合**：显示来自**用户**的**微帖子**。

+   **关注者**：一个**用户**可以关注另一个**用户**。

+   **时间线**：按顺序排列的由关注的**用户**发布的**微帖子**。

+   **搜索**：允许通过**用户**或**微帖子**中包含的文本进行搜索。

我们可以以 RESTful 的方式定义这些元素作为资源，正如本章之前介绍的那样，首先是对 URI 的快速描述：

```py
POST   /api/token

DELETE /api/token

GET    /api/user/<username>

GET    /api/user/<username>/collection

POST   /api/user/<username>/collection

GET    /api/user/<username>/collection/<micropost_id>

PUT    /api/user/<username>/collection/<micropost_id>

PATCH  /api/user/<username>/collection/<micropost_id>

DELETE /api/user/<username>/collection/<micropost_id>

GET    /api/user/<username>/timeline

GET    /api/user/<username>/following

POST   /api/user/<username>/following

DELETE /api/user/<username>/following/<username>

GET    /api/user/<username>/followers

GET    /api/search 
```

注意，我们在`/token`中添加了`POST`和`DELETE`资源来处理登录和注销。

一旦这个简短的设计完成，我们就可以详细阐述每个端点的定义。

## 端点

我们将更详细地描述所有 API 端点，遵循本章之前引入的模板。

**登录**：

+   *描述*：使用适当的认证凭据，返回有效的访问令牌。令牌需要包含在请求的`Authorization`头信息中。

+   *资源 URI*：`/api/token`

+   *方法*：`POST`

+   *请求体*：

    ```py
    {  

     "grant_type": "authorization_code"

        "client_id": <client id>,

        "client_secret": <client secret>

    } 
    ```

+   *返回体*：

    ```py
    {

      "access_token": <access token>,

      "token_type":"bearer",

      "expires_in":86400,

    } 
    ```

+   *错误*：

    ```py
    400 Bad Request Incorrect body.

    400 Bad Request Bad credentials. 
    ```

**登出：**

+   *描述*：使令牌失效。如果成功，将返回`204 No Content`错误。

+   *资源 URI*：`/api/token`

+   *方法*：`DELETE`

+   *头信息*：`Authentication: Bearer: <token>`

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being properly authenticated. 
    ```

**检索用户：**

+   *描述*：返回用户名资源。

+   *资源 URI*：`/api/users/<username>`

+   *方法*：`GET`

+   *头信息*：`Authentication: Bearer: <token>`

+   *查询参数*：

    ```py
    size Page size.

    page Page number. 
    ```

+   *返回体*：

    ```py
    {

        "username": <username>,

        "collection": /users/<username>/collection,

    } 
    ```

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist. 
    ```

**检索用户的收藏夹：**

+   *描述*：以分页形式返回用户的所有微帖子集合。

+   *资源 URI*：`/api/users/<username>/collection`

+   *方法*：`GET`

+   *头信息*：`Authentication: Bearer: <token>`

+   *返回体*：

    ```py
    {

        "next": <next page or null>,

        "previous": <previous page or null>,

        "result": [

            {

                "id": <micropost id>,

                "href": <micropost url>,

                "user": <user url>,

                "text": <Micropost text>,

                "timestamp": <timestamp for micropost in ISO 8601>

            },

            ...

        ]

    } 
    ```

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist. 
    ```

**创建新的微帖子：**

+   *描述*：创建一个新的微帖子。

+   *资源 URI*：`/api/users/<username>/collection`

+   *方法*：`POST`

+   *头信息*：`Authentication: Bearer: <token>`

+   *请求体*：

    ```py
    {

        "text": <Micropost text>,

        "referenced": <optional username of referenced user>

    } 
    ```

+   *错误*：

    ```py
    400 Bad Request Incorrect body.

    400 Bad Request Invalid text (for example, more than 255 characters).

    400 Bad Request Referenced user not found.

    401 Unauthorized Trying to access this URI without being authenticated.

    403 Forbidden Trying to create a micropost of a different user to the one logged in. 
    ```

**检索微帖子：**

+   *描述*：返回单个微帖子。

+   *资源 URI*：`/api/users/<username>/collection/<micropost_id>`

+   *方法*：`GET`

+   *头信息*：`Authentication: Bearer: <token>`

+   *返回体*：

    ```py
     {

                "id": <micropost id>,

                "href": <micropost url>,

                "user": <user url>,

                "text": <Micropost text>,

                "timestamp": <timestamp for micropost in ISO 8601>,

          "referenced": <optional username of referenced user>

            } 
    ```

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist.

    404 Not Found Micropost ID does not exist. 
    ```

**更新微帖子：**

+   *描述*：更新微帖子的文本。

+   *资源 URI*：`/api/users/<username>/collection/<micropost_id>`

+   *方法*：`PUT, PATCH`

+   *头信息*：`Authentication: Bearer: <token>`

+   *请求体*：

    ```py
     {

                "text": <Micropost text>,

          "referenced": <optional username of referenced user>

            } 
    ```

+   *错误*：

    ```py
    400 Bad Request Incorrect body.

    400 Bad Request Invalid text (for example, more than 255 characters).

    400 Bad Request Referenced user not found.

    401 Unauthorized Trying to access this URI without being authenticated.

    403 Forbidden Trying to update a micropost of a different user to the one logged in.

    404 Not Found Username does not exist.

    404 Not Found Micropost ID does not exist. 
    ```

**删除微帖子：**

+   *描述*：删除微帖子。如果成功，将返回`204 No Content`错误。

+   *资源 URI*：`/api/users/<username>/collection/<micropost_id>`

+   *方法*：`DELETE`

+   *头信息*：`Authentication: Bearer: <token>`

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    403 Forbidden Trying to delete a micropost of a different user to the one logged in.

    404 Not Found Username does not exist.

    404 Not Found Micropost ID does not exist. 
    ```

**检索用户的动态：**

+   *描述*：以分页形式返回用户时间线上的所有微帖子集合。微帖子将按时间戳顺序返回，最早的先返回。

+   *资源 URI*：`/api/users/<username>/timeline`

+   *方法*：`GET`

+   *头信息*：`Authentication: Bearer: <token>`

+   *返回体*：

    ```py
    {

        "next": <next page or null>,

        "previous": <previous page or null>,

        "result": [

            {

                "id": <micropost id>,

                "href": <micropost url>,

                "user": <user url>,

                "text": <Micropost text>,

                "timestamp": <timestamp for micropost in ISO 8601>,

                "referenced": <optional username of referenced user>

            },

            ...

        ]

    } 
    ```

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist. 
    ```

**检索用户关注的用户：**

+   *描述*：返回所选用户关注的用户集合。

+   *资源 URI*：`/api/users/<username>/following`

+   *方法*：`GET`

+   *头信息*：`Authentication: Bearer: <token>`

+   *返回体*：

    ```py
    {

        "next": <next page or null>,

        "previous": <previous page or null>,

        "result": [

            {

                "username": <username>,

                "collection": /users/<username>/collection,

            },

            ...

        ]

    } 
    ```

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist. 
    ```

**关注一个用户：**

+   *描述*：使所选用户关注不同的用户。

+   *资源 URI*：`/api/users/<username>/following`

+   *方法*：`POST`

+   *头信息*：`Authentication: Bearer: <token>`

+   *请求体*：

    ```py
    {    

        "username": <username>

    } 
    ```

+   *错误*：

    ```py
    400 Bad Request The username to follow is incorrect or does not exist.

    400 Bad Request Bad body.

    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist. 
    ```

**停止关注一个用户：**

+   *描述*：停止关注一个用户。如果成功，将返回`204 No Content`错误。

+   *资源 URI*：`/api/users/<username>/following/<username>`

+   *方法*：`DELETE`

+   *头信息*：`Authentication: Bearer: <token>`

+   *错误*：

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    403 Forbidden Trying to stop following a user who is not the authenticated one.

    404 Not Found Username to stop following does not exist. 
    ```

**检索用户的关注者：**

+   *描述*: 以分页形式返回此用户的全部关注者。

+   *资源 URI*: `/api/users/<username>/followers`

+   *方法*: `GET`

+   *头部*: `Authentication: Bearer: <token>`

+   *返回体*:

    ```py
    {

        "next": <next page or null>,

        "previous": <previous page or null>,

        "result": [

            {

                "username": <username>,

                "collection": /users/<username>/collection,

            },

            ...

        ]

    } 
    ```

+   *错误*:

    ```py
    401 Unauthorized Trying to access this URI without being authenticated.

    404 Not Found Username does not exist. 
    ```

**搜索微帖子**:

+   *描述*: 以分页形式返回满足搜索查询的微帖子。

+   *资源 URI*: `/api/search`

+   *方法*: `GET`

+   *头部*: `Authentication: Bearer: <token>`

+   *查询参数*:

    ```py
    username: Optional username to search. Partial matches will be returned.

    text: Mandatory text to search, with a minimum of three characters. Partial matches will be returned. 
    ```

+   *返回体*:

    ```py
    {

        "next": <next page or null>,

        "previous": <previous page or null>,

        "result": [

            {

                "id": <micropost id>,

                "href": <micropost url>,

                "user": <user url>,

                "text": <Micropost text>,

                "timestamp": <timestamp for micropost in ISO 8601>,

                "referenced": <optional username of referenced user>

            },

        ]

    } 
    ```

+   *错误*:

    ```py
    400 Bad Request No mandatory query parameters.

    400 Bad Request Incorrect value in query parameters.

    401 Unauthorized Trying to access this URI without being authenticated. 
    ```

## 设计和实现的审查

这种两步法，即展示和设计新的 API，使您能够快速查看设计是否有不合适的地方。然后，可以迭代修复。下一步是开始实施，正如我们将在后续章节中看到的。

# 概述

在本章中，我们描述了 API 设计的基本原则，即创建一组有用的抽象，使用户能够在不关心内部细节的情况下执行操作。这导致了如何使用资源和动作定义 API 的描述。

这个 API 的定义已经发展到了涵盖遵循某些特性的 RESTful 接口，这些特性使得它们对于网络服务器设计非常有趣。我们在设计 RESTful 接口以创建一致和完整的接口时，描述了一系列有用的标准和技巧，包括 OpenAPI 工具。我们还讨论了认证细节，因为它是 API 的一个重要元素。

记住，在保护具有外部使用的 API 时，应特别注意。我们讨论了一些一般想法和常见策略，但请注意，本书并不专注于安全性。这是任何 API 设计的一个关键方面，应该谨慎处理。

我们涵盖了版本化的理念以及如何创建适合 API 特定用例的适当版本化模式。我们还讨论了前端和后端的差异以及如何进行一般化。我们还讨论了 MVC 模式，这是一种非常常见的软件结构方式。

我们描述了 HTML 界面的不同选项，以提供一个关于网络服务中不同接口的完整概述。我们讨论了 HTML 服务如何构建以及如何与其他 API 交互的不同选项。

最后，我们在审查总体设计和端点的同时，展示了示例的 RESTful 接口设计。

设计的另一个关键元素是数据结构。我们将在下一章中介绍这一点。
