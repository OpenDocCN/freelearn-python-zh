# 第一章。Python 和测试

你可能是一名程序员、编码者、开发者，或者可能是一名黑客。作为这样的角色，你几乎不可能没有坐下来与一个你确信已经准备好使用的程序——或者可能是一个你知道还没有准备好的程序——一起编写一系列测试来证明它的正确性。这通常感觉像是一项徒劳的练习，或者在其最好的情况下，是浪费时间。我们将学习如何避免这种情况，使测试变得简单且愉快。

这本书将向你展示一种新的测试方法，这种方法将测试的大部分负担放在了它应该放的地方——计算机上。更好的是，你的测试将帮助你早期发现问题，并告诉你它们的确切位置，这样你就可以轻松地修复它们。你会喜欢自动化测试的简单、有帮助的方法，以及测试驱动开发。

当涉及到测试时，Python 语言拥有一些最好的工具，因此我们将通过利用这些工具来学习如何使测试变得简单、快捷、有趣且富有成效。

本章提供了本书的概述，因此我们将简要讨论以下主题：

+   测试的级别：单元测试、集成测试和系统测试

+   接受测试和回归测试

+   测试驱动开发

# 测试以娱乐和盈利

这一章开始时有很多宏伟的声明——你会喜欢测试的。你会依赖它来帮助你早期且轻松地消灭 bug。测试将不再成为你的负担，而会成为你愿意去做的事情。*如何做到？*

回想一下你最近遇到的那个真正令人烦恼的 bug。它可能是任何东西：数据库模式不匹配、糟糕的数据结构，等等。

记得是什么原因导致了 bug 吗？那是一行带有微妙逻辑错误的代码。那个没有按照文档说明执行的功能。无论是什么，都要记住这一点。

想象一下，如果它在正确的时间运行，并且你被告知了它，那么一小块代码就能捕捉到那个 bug。

现在想象一下，所有的代码都伴随着那些小块的测试代码，并且它们执行起来既快又简单。

你的 bug 能存活多久？根本不会很久。

这为你提供了一个相当基本的理解，我们将在这本书中讨论什么。有许多改进和工具可以使这个过程更快、更简单，但基本思想是使用简单且易于编写的代码片段告诉计算机你期望什么，然后在编码过程中让计算机双重检查你的期望。因为期望很容易描述，你可以先写下它们，让计算机承担调试代码的大部分负担。因为期望很容易描述，你可以快速写下它们，这样你就可以继续做有趣的事情，而计算机则跟踪其余的事情。

当你完成时，你将拥有一个高度测试的代码库，你可以非常有信心。你早早地捕捉到 bug 并迅速修复它们。最好的是，你的测试是基于你告诉计算机的以及你希望程序做什么来进行的。毕竟，为什么你应该做，当计算机可以为你做的时候？

我已经有过简单的自动化测试捕捉到从轻微的打字错误到在模式更改后数据库访问代码被危险地遗弃的实例，以及几乎任何可以想象的 bug。测试迅速捕捉到错误并确定了它们的位置。由于它们的存在，避免了大量的努力和麻烦。

花更少的时间进行调试并确保结果，使得编程更有趣。在更短的时间内生产出更高质量的代码，使其更具盈利性。测试套件提供即时反馈，允许你立即运行代码的每一块，而不是等待整个程序处于可以执行的状态。这种快速周转使得编程既令人满意又富有成效。

# 测试级别

根据被测试组件的复杂程度，测试通常被分为几个类别。我们的大部分时间将集中在最低级别——单元测试——因为单元测试为其他类别的测试提供了基础。其他类别的测试遵循相同的原理。

## 单元测试

单元测试是对程序中最小可能的片段进行测试。通常，这意味着单个函数或方法。这里的重点是单独的：如果无法以有意义的方式进一步分割它，那么它就是一个“单元”。

例如，考虑这个函数作为一个单元是有意义的：

```py
def quadratic(a, b, c, x):
   return a * (x ** 2) + b * x + c
```

前面的函数作为一个单元工作，因为将其拆分成更小的部分既不实际也不实用。

单元测试单独测试一个单元，验证它是否按预期工作，而不考虑程序其他部分可能的行为。这保护每个单元免受其他地方错误带来的 bug 的影响，并使得缩小真正问题所在变得容易。

单独的单元测试不足以确认完整程序的正确性，但它是一切其他基于的基础。你不能没有坚固的材料建造房子，你也不能没有按预期工作的单元来建造程序。

## 集成测试

在集成测试中，隔离的边界被进一步推后，因此测试涵盖了相关单元之间的交互。每个测试仍然应该单独运行，以避免从外部继承问题，但现在测试检查测试的单元是否作为一个群体正确地表现。

集成测试可以使用与单元测试相同的工具进行。因此，对于自动化测试的新手来说，有时会被诱使忽略单元测试和集成测试之间的区别。忽略这个区别是危险的，因为这种多用途测试通常会对它们所涉及的某些单元的正确性做出假设；这意味着测试者失去了自动化测试本应带来的许多好处。我们直到它们“咬我们”才意识到我们做出的假设，因此我们需要有意识地选择以最小化假设的方式工作。这就是为什么我把测试驱动开发称为“纪律”的一个原因。

## 系统测试

系统测试将隔离的边界扩展到甚至不存在的地方。系统测试在整体连接在一起之后检查程序的部分。从某种意义上说，系统测试是集成测试的一种极端形式。

系统测试非常重要，但没有集成测试和单元测试的支持，它们并不很有用。在你能确定整体之前，你必须确定各个部分。如果某个地方有细微的错误，系统测试会告诉你它存在，但不会告诉你它在哪或如何修复它。你很可能以前经历过这种情况；这可能是你讨厌测试的原因。一个组织良好的测试套件，系统测试几乎成了一种形式。大多数问题都是由单元测试或集成测试发现的，而系统测试只是提供了一种保证，即一切正常。

# 接受测试

当一个程序最初被指定时，我们决定期望它有什么行为。编写以确认程序实际上确实做了所期望的事情的测试被称为接受测试。接受测试可以在之前讨论的任何级别上编写，但最常见的是在集成或系统级别。

接受测试往往是不按常规从单元测试到集成测试再到系统测试的例外。许多程序规范在相当高的层面上描述程序，接受测试需要与规范在同一级别上操作。系统测试的大部分是接受测试的情况并不少见。

接受测试是很有用的，因为它们为你提供了持续的保证，即你正在创建的程序确实是所指定的程序。

# 回归测试

回归是指你的代码中曾经正确工作的部分停止工作。这通常是由于代码其他部分的更改破坏了现在有缺陷部分的假设。当这种情况发生时，向你的测试套件中添加可以识别该错误的测试是个好主意。这确保了，如果你再次犯类似的错误，测试套件会立即捕捉到它。

确保工作代码不会出现错误的测试被称为回归测试。它们可以在发现错误之前或之后编写，并且它们为你提供了保证，即你的程序复杂性不会导致错误成倍增加。一旦你的代码通过了单元测试、集成测试或系统测试，你不需要从测试套件中删除这些测试。你可以保留它们，它们将作为额外的回归测试发挥作用，让你知道测试是否停止工作。

# 测试驱动开发

当你结合本章中我们介绍的所有元素时，你将进入测试驱动开发的领域。在测试驱动开发中，你总是先编写测试。一旦你为即将编写的代码编写了测试，然后才会编写使测试通过的代码。

这意味着你首先要做的事情是编写验收测试。然后你确定你要从程序的哪些单元开始，并编写测试——名义上，这些是回归测试，尽管它们最初捕获的错误是“代码不存在”；这确认了这些单元尚未正确运行。然后你可以编写一些代码，使单元级别的回归测试通过。

这个过程会一直持续到整个程序完成：编写测试，然后编写使测试通过的代码。如果你发现了一个现有测试没有捕获到的错误，首先添加一个测试，然后添加或修改代码以使测试通过。由于早期、轻松且快速地捕获了所有错误，最终结果是程序非常稳固。

# 你需要 Python

本书假设你具备 Python 编程语言的实用知识，特别是该语言的 3.4 或更高版本。如果你还没有 Python，你可以从[`www.python.org/`](http://www.python.org/)下载完整的语言工具包和库，作为一个易于安装的单个包。

### 小贴士

大多数 Linux 和 Mac OS X 版本已经包含了 Python，但并不一定包含与本书兼容的新版本。通过命令行运行 Python 来检查。

你还需要你的最喜欢的文本编辑器，最好是支持 Python 语言的。流行的编辑器选择包括 emacs、Vim、Geany、gedit 和 Notepad++。对于那些愿意付费的人来说，TextMate 和 Sublime 很受欢迎。

### 注意

一些这些流行的编辑器有些……异国情调。它们有自己的操作习惯语，并且不像你可能使用过的任何其他程序。它们之所以受欢迎，是因为它们功能强大；尽管如此，它们可能有些奇怪。如果你发现某个编辑器不适合你，只需选择另一个即可。

# 摘要

在本章中，我们了解了你可以从这本书中学到什么，以及简要地讨论了自动化测试和测试驱动开发的哲学。

我们讨论了测试的不同层次和角色，它们组合起来形成了一个程序完整的测试套件：单元测试、集成测试、系统测试、验收测试和回归测试。我们了解到单元测试是对程序基本组件（如函数）的测试；集成测试是覆盖程序更大范围的测试（如模块）；系统测试是覆盖整个程序的测试；验收测试确保程序符合预期；回归测试确保它在开发过程中保持正常工作。

我们讨论了如何通过将测试的大部分负担转移到计算机上来帮助您。您可以告诉计算机如何检查您的代码，而不是自己进行这些检查。这使得在早期和更频繁地检查代码变得方便，让您免于错过您本可能会错过的东西，并帮助您快速定位和修复错误。

我们讨论了测试驱动开发，这是一种先编写测试的纪律，并让它们告诉您为了编写所需的代码需要做什么。我们还简要讨论了为了完成这本书的工作您将需要的开发环境。

现在，我们准备继续使用`doctest`测试工具进行工作，这是下一章的主题。
