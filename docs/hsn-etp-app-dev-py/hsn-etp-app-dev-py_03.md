# 第三章：构建大规模数据库操作

在企业软件开发领域，开发人员一直在构建处理大量数据的应用程序。在计算机的早期，系统通常跨越比我们目前居住的房间还要大的空间，数据存储在平面文件格式中，而今天，系统已经缩小到以前存放单个系统的相同大小的房间中，我们现在可以运行成千上万个系统，每个系统都与其他系统协调，为我们提供可以以光速处理数据的机器。随着时间的推移，数据存储的方式也从使用平面文件发展到了复杂的数据库管理系统。

随着企业规模的增长和由新兴领域带来的不断扩大的业务，企业应用程序需要处理的数据量也在增长，这使得了解如何构建我们的应用程序以处理大规模数据库相关操作变得重要。虽然构建大规模数据库操作永远不可能是一种适合所有情况的解决方案，但我们将涵盖一些常见的构建应用程序的要点，这些应用程序可以轻松扩展以处理数据增加、模式修改的要求、应用程序复杂性的增加等。

尽管有多种类型的数据库，如 SQL、NoSQL 和图形数据库，可以用来存储应用程序数据，取决于企业所需的应用程序类型，本章重点关注使用 SQL 的关系数据库管理系统，因为它们非常流行，并且能够处理大量的用例。

通过本章结束时，您将学到以下内容：

+   使用**对象关系映射器**（**ORMs**）及其提供的好处

+   为了提高效率和便于修改，构建数据库模型

+   专注于维护数据库一致性

+   急切加载和延迟加载之间的区别

+   利用缓存加速查询

# 技术要求

本书中的代码清单可以在[`github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python`](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter03`目录下找到

可以通过运行以下命令克隆代码示例：

```py
git clone https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python
```

本章提供的代码示例需要您在系统上安装和配置以下系统包：

+   `python-devel`

+   PostgreSQL

+   Python - `virtualenv`

除了这三个包，您还需要`sqlalchemy`包，它提供了我们在整个章节中将使用的 ORM，以及`psycopg2`，它提供了`postgres`数据库绑定，以允许`sqlalchemy ...`

# 数据库和对象关系映射器

正如我们在前几章中讨论的，Python 为我们提供了许多面向对象的能力，并允许我们以类和对象的术语来映射我们的用例。现在，当我们可以将我们的问题集映射到一个类及其对象时，为什么我们不应该将我们的数据库表也映射为对象，其中一个特定的类代表一个表，它的对象代表表中的行。沿着这条路走，不仅有助于我们维护我们编写代码的一致性，还有助于我们建模我们的问题。

提供了通过它们可以将我们的数据库映射到对象的功能的框架被称为 ORMs，它们帮助我们将我们的数据库可视化为一组类和对象。

在 Python 领域中，看到 ORMs 是非常常见的。例如，流行的 Python Web 框架 Django 提供了自己的 ORM 解决方案。然后，还有 SQLAlchemy，它提供了一个完整的 ORM 解决方案和支持各种关系数据库的数据库工具包。

但是，要说服开发人员使用 ORM 框架，应该有比仅仅说它们能够将数据库映射到类和对象，并为您提供面向对象的接口来访问数据库更好的优势。让我们看看 ORM 的使用带来了哪些优势：

+   **抽象出特定供应商的 SQL**：关系数据库领域充满了选择，有几家公司在推广他们的产品。这些产品中的每一个都可以在如何通过使用 SQL 实现某个功能上有所不同。有时，一些数据库可能实现了一些尚未在其他数据库中支持的 SQL 关键字。对于开发人员来说，如果他们需要支持具有不连贯功能集的多个数据库，这可能会成为一个问题。由于 ORM 已经知道如何处理这些数据库的差异，它们帮助开发人员减轻了支持多个数据库的问题。大多数情况下，使用 ORM 时，开发人员所需要做的就是修改数据库连接的统一资源标识符（URI），然后他们就可以准备在应用程序中使用新的数据库了。

+   **减少重复 SQL 的需求**：在编写应用程序时，有很多地方需要使用类似的查询从相同的表中检索数据。这将导致很多重复的 SQL 代码被写入很多地方，不仅导致很多格式不佳的代码，还会因为 SQL 查询构造不当而导致错误的出现（人类在做重复工作时很容易失去注意力，开发人员也会这样吗？）。ORM 解决方案通过提供对 SQL 命令的抽象和根据我们调用不同方法动态生成 SQL 来减少编写 SQL 以实现相同结果的需求。

+   **增加应用程序的可维护性**：由于 ORM 允许您一次定义数据库模型并通过实例化类在整个应用程序中重用它，它允许您在一个地方进行更改，然后在整个应用程序中反映出来。这使得维护应用程序的任务变得稍微不那么繁琐（至少与处理数据库相关的部分）。

+   **提高生产力**：这本身不是一个特性，而是前面提到的点的副作用。使用 ORM 解决方案，开发人员现在不再那么担心始终考虑 SQL 查询，或者试图遵循特定的设计模式。他们现在可以专注于如何最好地设计他们的应用程序。这显著提高了开发人员的生产力，并允许他们完成更多工作并提高时间的利用率。

在这一章中，我们将专注于如何利用 ORM 来最好地开发我们的企业应用程序，以便它们可以轻松地与数据库交互并高效地处理大规模的数据库操作。为了保持本章简单，我们将坚持使用 SQLAlchemy，它将自己作为一个 SQL 工具包，并为 Python 提供了一个 ORM 解决方案，并为 Python 领域中的不同框架提供了许多绑定。它被一些相当大规模的项目使用，如 OpenStack，Fedora 项目和 Reddit。

# 设置 SQLAlchemy

在我们深入研究如何为应用程序创建最佳的数据库模型以促进高效的大规模数据库操作之前，我们首先需要设置我们的 ORM 解决方案。由于我们将在这里使用 SQLAlchemy，让我们看看如何在开发环境中设置它。

为了使 SQLAlchemy 工作，你应该有一个数据库管理系统设置，可以是在你的系统上或远程机器上，你可以连接到它。一个暴露端口的容器也可以为我们完成工作。为了保持示例简单，我们假设读者在这里使用 PostgreSQL 作为他们的数据库解决方案，并且了解 PostgreSQL 设置的工作原理。现在，让我们看看如何设置 SQLAlchemy：

```py
mkdir ch3 && cd ch3 ...
```

# 构建最佳数据库模型

实现对数据库的任何有效访问的第一步是为数据库构建一个最佳模型。如果一个模型不是最佳的，那么加速对数据库的访问的其他技术将几乎没有什么区别。

但在我们深入研究如何为数据库构建最佳模型之前，让我们首先看看如何实际使用 SQLAlchemy 为我们的数据库构建任何模型。

举个例子，假设我们想要构建一个模型来代表我们的 BugZot 应用程序中的用户。在我们的 BugZot 应用程序中，用户将需要提供以下字段：

+   名字和姓氏

+   用户名

+   电子邮件地址

+   密码

此外，我们的 BugZot 应用程序还需要维护有关用户的一些其他信息，例如他们在系统中的会员级别，用户有权利的特权，用户帐户是否处于活动状态，以及发送给用户激活他们帐户的激活密钥。

现在，让我们看看如果我们尝试使用 SQLAlchemy 来满足这些要求建立用户表会发生什么。以下代码描述了我们如何在 SQLAlchemy 中构建用户模型：

```py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Boolean, Date, Integer, String, Column
from datetime import datetime

# Initialize the declarative base model
Base = declarative_base()

# Construct our User model
class User(Base):
 __tablename__ = 'users'

 id = Column(Integer, primary_key=True, autoincrement=True)
 first_name = Column(String, nullable=False)
 last_name = Column(String, nullable=False)
 username = Column(String(length=25), unique=True, nullable=False)
 email = Column(String(length=255), unique=True, nullable=False)
 password = Column(String(length=255), nullable=False)
 date_joined = Column(Date, default=datetime.now())
 user_role = Column(String, nullable=False)
 user_role_permissions = Column(Integer, nullable=False)
 account_active = Column(Boolean, default=False)
 activation_key = Column(String(length=32))

 def __repr__(self):
 return "<User {}>".format(self.username)
```

这个例子展示了我们如何使用 SQLAlchemy 构建模型。现在，让我们看看我们在代码示例中做了什么。

在代码示例的开始部分，我们首先导入了`declarative_base`方法，该方法负责为我们的模型提供基类。

`Base = declarative_base()`行将基本模型分配给我们的基本变量。

接下来我们做的事情是包括来自 SQLAlchemy 的不同数据类型，这些数据类型将在我们的模型定义中使用。

最后的导入导入了我们将在数据库模型中使用的 Python `datetime`库。

现在，不考虑我们的代码将如何填充数据库模型的不同字段，让我们看看我们是如何设计我们的用户模型的。

设计模型的第一步是定义一个作为我们模型类的用户类。这个类派生自我们在代码中之前初始化的基本模型。

`__tablename__ = 'users'`行定义了当这个数据库模型在数据库中实现时应该给表的名称。

接着，我们开始定义表将包含的列。为了定义列，我们使用`key=value`的方式，其中 key 定义了列的名称，value 定义了列的属性。

例如，要定义 id 列，它应该是整数类型，并且应该作为用户表的主键，我们这样定义：

```py
id = Column(Integer, primary_key=True, autoincrement=True)
```

我们现在可以看到它是多么简单。我们不需要编写任何 SQL 来定义我们的列。同样，通过只传递`unique=True`和`nullable=False`参数给列构造函数，就可以很容易地强制一个特定字段应该具有唯一值，并且不能有 null 值，可以从以下行作为例子：

```py
username = Column(String(length=25), unique=True, nullable=False)
```

在我们定义了所有的列之后，我们提供了`__repr__`方法的定义。`__repr__`方法是一个魔术方法，它由内部的`repr()`Python 方法调用，以提供对象的表示，比如当用户发出`print(userobj)`时。

这样就完成了我们使用 SQLAlchemy 定义用户模型的定义。很简单，不是吗？我们不需要编写任何 SQL；我们只需快速地将列添加到一个类中，然后让 SQLAlchemy 处理其他所有事情。现在，虽然所有这些都很有趣且容易实现，但我们犯了一些错误，现在似乎没有造成任何伤害，但随着我们的应用规模扩大，这些错误将会变得代价高昂。让我们来看看这些错误。

# 我们模型定义的问题

虽然 SQLAlchemy 为我们提供了很多抽象来轻松定义用户模型，但它也让我们很容易犯一些错误，一旦应用规模扩大并且企业增长，这些错误就会变得代价高昂。让我们来看看我们在定义这个模型时犯了一些错误：

+   **易受变化影响**：我们当前的用户模型定义使得一旦应用规模扩大，对模型进行更改变得非常困难。让我们举个例子，假设组织决定在错误报告上为用户提供更多权限。在 SQL 方面，为了实现这个效果，我们需要编写一个查询，遍历所有记录并具有`user_role`作为用户...

# 优化我们的模型

在讨论如何构建最佳模型之前，我们首先需要了解最佳模型应具备的特征。让我们来看看以下内容：

+   **易于调整**：一个优化的模型应该根据应用程序不断增长的需求变化而容易调整。这意味着更改特定模型不应该需要在整个应用程序中进行更改，并且应该具有高内聚性。

+   **最大化主机吞吐量**：每个主机都有不同的架构，数据模型应该能够利用底层主机资源，以最大化吞吐量。这可以通过使用特定架构和用例的正确数据存储引擎，或者在一组机器上运行数据库以增加并行执行能力来实现。

+   **高效存储**：数据库模型还应考虑到随着存储在其中的数据增长，可能使用的存储空间。这可以通过仔细选择数据类型来实现。例如，仅表示一个只能有两个值（true 或 false）的列，使用整数类型会浪费大量磁盘空间，随着数据库中记录的数量增加。对于这样的列，名义数据类型可以是布尔型，它在内部不占用太多空间。

+   **易于调整**：一个高效的模型将谨慎地为可以加速对特定表的查询处理的列建立索引。这将导致数据库的响应时间得到改善，并且用户不会因为应用程序从数据库返回 10,000 条记录需要长达 20 分钟而感到沮丧。

为了实现这些目标，我们现在需要简化我们的模型，并使用关系数据库提供的关系概念。现在让我们开始重构我们的用户模型，使其更加优化。

为了实现这一点，首先我们需要将一个大模型分解为多个小模型，在我们的代码库中独立存在，并且不要将所有东西耦合得太紧。让我们开始吧。

我们要移出模型的第一件事是如何处理角色和权限。由于角色及其权限不会在用户之间有太大的差异（肯定不是每个用户都会有一个唯一的角色，也不是每个角色都可以有不同的权限集），我们可以将这些字段移动到另一个模型，称为权限。以下代码说明了这一点：

```py
class Role(Base):
 __tablename__ = 'roles'

 id = Column(Integer, primary_key=True, autoincrement=True)
 role_name = Column(String(length=25), nullable=False, unique=True)
 role_permissions = Column(Integer, nullable=False)

 def __repr__(self):
 return "<Role {}>".format(role_name)
```

现在，我们已经将角色与用户模型解耦。这使我们可以轻松地对提供的角色进行修改，而不会引起太多问题。这些修改可能包括重命名角色或更改现有角色的权限。我们只需要在一个地方进行修改，就可以反映到所有具有相同角色的用户身上。让我们看看如何在我们的用户模型中利用**关系数据库管理系统**（**RDBMS**）中的关系来做到这一点。

以下代码示例显示了如何实现角色模型和用户模型之间的关系：

```py
class User(Base):
  __tablename__ = 'users'

  id = Column(Integer, primary_key=True, autoincrement=True)
  first_name = Column(String, nullable=False)
  last_name = Column(String, nullable=False)
  username = Column(String(length=25), unique=True, nullable=False)
  email = Column(String(length=255), unique=True, nullable=False)
  password = Column(String(length=255), nullable=False)
  date_joined = Column(Date, default=datetime.now())
  user_role = Column(Integer, ForeignKey("roles.id"))
  account_active = Column(Boolean, default=False)
  activation_key = Column(String(length=32))

  def __repr__(self):
    return "<User {}>".format(self.username) 
```

在这个代码示例中，我们将`user_role`修改为整数，并存储在`roles`模型中存在的值。任何尝试向这个字段插入不在 roles 模型中的值的操作都会引发 SQL 异常，表示不允许该操作。

现在，继续使用同一个例子，让我们考虑用户模型的`activation_key`列。一旦用户激活了他们的账户，我们可能就不再需要激活密钥。这为我们提供了在用户模型中进行一次优化的机会。我们可以将这个激活密钥从用户模型中移出，并存储在一个单独的模型中。一旦用户成功激活了他们的账户，记录就可以被安全地删除，而不会有用户模型被修改的风险。因此，让我们开发激活密钥的模型。以下代码示例说明了我们想要做的事情：

```py
class ActivationKey(Base):
  __tablename__ = 'activation_keys'

  id = Column(Integer, primary_key=True, autoincrement=True)
  user_id = Column(Integer, ForeignKey("users.id"))
  activation_key = Column(String(length=32), nullable=False)

  def __repr__(self):
    return "<ActivationKey {}>".format(self.id)
```

在这个例子中，我们实现了`ActivationKey`模型。由于每个激活密钥都属于唯一的用户，我们需要存储哪个用户拥有哪个激活密钥。我们通过向用户模型的`id`字段引入外键来实现这一点。

现在，我们可以安全地从用户模型中移除`activation_key`列，而不会引起任何麻烦。

# 利用索引

索引是一种可以在适合建立索引的字段上提供大量性能优势的东西。但是，如果被索引的列没有经过慎重选择，索引也可能毫无用处，甚至会损害数据库的性能。例如，在表中索引每一列可能不会带来任何优势，而且会不必要地占用磁盘空间，同时使数据库操作变慢。

因此，在我们以一个例子来介绍的 ORM 中如何对特定字段建立索引之前，让我们首先澄清在数据库上下文中索引到底是什么（不深入探讨它们的工作原理），这个数据结构...

# 保持数据库一致性

数据库通常在应用程序部署后的整个生命周期中并行进行大量操作。这些操作可以是从数据库中检索信息，也可以是修改数据库状态的操作，比如插入新记录、更新现有记录或删除其他记录。目前大型组织生产中使用的大多数数据库都具有相当多的弹性，可以处理环境中可能发生的错误和崩溃，以防止数据损坏和停机。

但这并不能完全解除应用程序开发人员对数据库内数据一致性的关注。让我们试着理解这种情况。

在企业级应用程序中，任何给定时间点都会有许多数据库查询并行运行。这些查询来自于许多用户使用的应用程序或内部应用程序维护作业。其中一个主要的事实是，并非所有的查询都能成功执行。这可能是由于多种原因，比如查询中的数据不符合模式，为列值提供了不正确的数据类型，以及违反约束。当这种情况发生时，数据库引擎会阻止查询执行并返回查询错误。这是完全可以接受的，因为我们不正确的查询没有对数据库进行任何不正确的更改。但是当这个查询是一系列操作的一部分，用于在数据库中创建一个新资源时，情况就变得棘手了。现在我们需要确保在失败的查询之前由其他查询所做的更改被恢复。

这种行为仍然可以通过应用程序的开发人员通过跟踪 SQL 查询并在事情变得混乱时手动恢复它们的更改来解决。

但是，如果数据库引擎由于执行查询时发生错误而崩溃。现在我们处于一个无法预测数据库状态的情况下，处理这种情况可能会变得非常繁琐，并且可能会成为一个长时间阻碍整个组织运营的任务，直到数据库一致性得到验证。那么，我们能做些什么？有没有办法可以防止这些问题的出现？答案是肯定的。让我们来看看。

# 利用事务来维护一致性

关系数据库中的事务为我们提供了解决刚才讨论的问题的能力。在关系数据库方面，事务可以被认为是由多个数据库查询组成的信封，这些查询要么作为一个任务执行，要么在任何一个失败时完全恢复。我们还可以将事务视为数据库操作的原子单位，在这里，即使一个失败也会恢复整个事务。但是，这难道不正是我们需要解决数据库一致性问题的吗？

现在，让我们看看我们的 ORM 解决方案如何帮助我们实现事务支持。

为了理解这一点，让我们举个例子。我们的 BugZot...

# 理解延迟加载与急切加载

当我们查询从数据库加载数据时，这个操作可能会定义我们构建的应用程序的响应时间。这主要发生在需要加载大量数据并且应用程序等待数据库将所有这些行和列返回给它时。

这样的操作可能需要一些时间，从几毫秒到超过 10 秒，这取决于从数据库查询多少数据。这里的问题是，我们能否优化这一点以改善我们应用程序的响应时间？

这个问题的答案在于使用 SQL 关系和 ORM 层加载技术。虽然关系可以帮助我们定义两个模型之间的关系，加载技术定义了 ORM 如何检索关系。当需要加载大量数据时，这可以证明是非常有帮助的，不仅提供了一个机制，通过这个机制我们可以推迟加载关系数据直到需要它们，而且还可以在应用程序的内存占用方面节省相当多的空间。所以，让我们来看看这些技术。

# 使用关系

有了关系数据库管理系统的支持，我们现在可以定义两个模型之间的关系。数据库支持对两个模型之间不同类型的关系进行建模，例如：

+   **一对一关系**：这是一种关系，其中一个模型的记录只与另一个模型的一个记录相关联。例如，我们的用户模型中的用户只有一个激活密钥与我们的 ActivationKey 模型相关联。这是一种一对一关系。

+   **一对多关系**：这是一种关系，其中一个模型的记录映射到另一个模型的多个记录。例如，如果我们有一个描述 bug 条目的 Bug 模型，那么我们可以说，一个用户…

# 延迟加载

许多 ORM 层以及 SQLAlchemy 都试图尽可能地延迟数据加载。通常情况下，只有在应用程序实际访问对象时才会加载数据。这种延迟加载数据直到尝试访问数据的技术被称为延迟加载。

这种技术对于减少应用程序的响应时间非常有帮助，因为整个数据不是一次性加载的，而是按需加载的。这种优化是以运行更多的 SQL 查询为代价的，这些查询将在请求时检索实际数据。但是有没有一种方法可以明确控制这种技术呢？

对于每个 ORM 解决方案，答案都会有所不同，但其中很多实际上允许您启用或禁用延迟加载行为。那么，在 SQLAlchemy 中如何控制这一点呢？

看一下我们在上一节中对用户模型的修改，我们可以通过在我们的角色字段中添加一个额外的属性来明确告诉 SQLAlchemy 从我们的角色模型中延迟加载数据，如下面的片段所示：

```py
role = relationship("Role", lazy_load='select')
```

这个额外的`lazy_load`属性定义了 SQLAlchemy 用来从我们的角色模型加载数据的技术。下面的例子展示了在延迟加载期间请求的流程：

```py
>>> Session = sessionmaker(bind=engine)
>>> db_session = Session()
>>> user_record = db_session.query(User).first()
INFO sqlalchemy.engine.base.Engine SELECT users.username AS users_username, users.id AS users_id, users.role_id AS users_role_id 
FROM users 
 LIMIT %(param_1)s
INFO sqlalchemy.engine.base.Engine {'param_1': 1}
>>> role = user_record.role
INFO sqlalchemy.engine.base.Engine SELECT roles.id AS roles_id, roles.role_name AS roles_role_name, roles.role_permissions AS roles_role_permissions 
FROM roles 
WHERE roles.id = %(param_1)s
INFO sqlalchemy.engine.base.Engine {'param_1': 1}
```

从这个例子中可以看出，SQLAlchemy 在我们尝试访问角色模型的数据之前并不尝试加载角色模型的数据。一旦我们尝试访问角色模型的数据，SQLAlchemy 就会向数据库发出`SELECT`查询，获取结果并返回填充的对象，然后我们现在可以使用它。

与按需加载数据的技术相反，我们也可以要求 SQLAlchemy 在第一次请求时加载所有数据。这可以节省我们等待应用程序等待 ORM 层按需从数据库获取数据的几毫秒时间。

这种技术被称为**急切加载**，我们将在接下来的部分中解释。

# 急切加载

有时我们希望加载我们想要的对象的数据以及我们的对象映射到的关系的数据。这是一个有效的用例，比如当开发人员确信他们将访问关系的数据时，无论情况如何。

在这些用例中，没有必要浪费时间，而 ORM 层会按需加载关系。这种加载对象数据以及与我们的主对象相关的关联对象的数据的技术被称为急切加载。

SQLAlchemy 提供了一种简单的方法来实现这种行为。还记得我们在上一节中指定的`lazy_load`属性吗？是的，这就是你需要从延迟加载行为切换到急切加载的全部内容…

# 优化数据加载

我们可以为应用程序的性能提供的一种提升是优化它从数据库加载数据的方式。这并不是一件复杂的事情，ORM 解决方案使得这一切变得更加简单。

优化数据加载只有几条规则。因此，让我们看看这些规则是什么，以及它们如何能够证明有利：

+   **推迟加载可以跳过的数据**：当我们知道我们不需要从数据库中获取的所有数据时，我们可以安全地推迟加载该数据，利用延迟加载技术。例如，如果我们想要向我们的 BugZot 应用程序的所有用户发送邮件，这些用户有超过 10 个未解决的 bug，并且不是管理员，我们可以推迟加载角色的关系。考虑到一个有很多用户的大型数据库，这可以帮助显著减少应用程序的响应时间，以及整体内存占用，而只需付出一些额外的查询，这可能是一个可取的权衡。

+   **如果数据将被使用，则尽早加载**：与第一点完全相反，如果我们知道应用程序将使用数据，无论情况如何，那么一次性加载它而不是发出额外的查询来按需加载数据是完全有道理的。例如，如果我们想要将所有管理员提升为超级管理员，我们知道我们将访问所有用户的角色字段。那么，让应用程序懒加载角色字段就没有意义。我们可以简单地要求应用程序急切地加载所需的数据，以便应用程序不必等待数据按需加载。这种优化会增加内存使用量和初始响应时间，但一旦所有数据加载完毕，就会提供快速执行的优势。

+   **不加载不需要的数据**：有时对象映射的一些关系在处理过程中根本不需要。在这种情况下，我们可以通过简单地设置`lazy_load='noload'`来节省大量内存和时间，从而根本不加载这些关系对象。在 SQLAlchemy 中可以很容易地实现这一点。一个这样的用例是当我们只想要更新数据库中用户的`last_active`时间时，不需要加载关系。在这种情况下，我们知道我们不需要验证与用户角色相关的任何内容，因此我们可以完全跳过加载角色。

如果加载技术完全嵌入在模型定义中，显然无法实现这些效果。因此，SQLAlchemy 确实提供了另一种通过使用不同方法来实现这些效果的方式，这些方法根据它们从数据库加载数据的技术命名，例如，`lazyload()`用于延迟加载，`joinedload()`用于连接急切加载，`subqueryload()`用于子查询急切加载，`noload()`用于不加载，我们将在后面的章节中解释它们，包括它们如何在实际应用程序中使用。

现在我们熟悉了加载技术以及如何利用它们的优势，现在让我们来看看本章的最后一个主题之一，我们将看到如何利用缓存来加快应用程序的响应时间，以及节省一遍又一遍地查询数据库的工作，这在应用程序执行大量数据密集型操作时确实会帮助我们。

# 利用缓存

在大多数企业应用程序中，一旦访问过的数据就会被再次使用。这可能是在不同的请求中，也可能是因为请求正在操作相同的数据集。

在这些情况下，如果我们试图一遍又一遍地从数据库中再次访问相同的数据，这将是一种巨大的资源浪费，导致应用程序向数据库发出大量查询，导致数据库负载高，响应时间差。

我们使用的 ORM 层提供了一定程度的缓存以访问过的数据，但是，大部分控制权仍然掌握在应用程序开发人员手中，他可以通过分析哪些数据将一遍又一遍地使用来使应用程序性能良好。

# 在数据库级别进行缓存

数据库是相当复杂的软件。它们不仅能够高效地存储我们的数据，还能够以同样的效率提供检索数据的机制。这背后涉及了许多复杂的逻辑。

使用 ORM 的优势之一是数据库可以在查询级别执行缓存。由于数据库应该以最快的方式返回数据，数据库系统通常会缓存反复执行的查询。这种缓存发生在查询解析级别，因此当在数据库上执行相同的查询时，可以通过不再解析相同的查询来节省一些时间。

这种缓存可以提高响应时间，因为保存了大量解析查询的工作。

# 块级缓存

现在，让我们来看一下我们可以在应用程序级别使用的缓存类型，这可能会提供重要帮助。

要理解应用程序块级缓存的概念，让我们看一下以下简单的代码片段：

```py
for name in ['super_admin', 'admin', 'user']:  if db_session.query(User).first().role.role_name == name:    print("True")
```

从我们可以假设的情况来看，这可能已经查询了一次，然后从数据库中检索了数据，然后将一遍又一遍地使用它来与名称变量进行比较。但让我们来看一下前面代码的输出：

```py
INFO sqlalchemy.engine.base.Engine SELECT users.username AS users_username, users.id AS users_id, users.role_id AS ...
```

# 使用用户级缓存

用户级缓存是另一种可以证明非常有用的缓存级别。想象一下，每次用户从一个页面移动到另一个页面时都从数据库查询用户的个人详细信息。这不仅效率低下，而且在高负载情况下会受到惩罚，当数据库的响应时间非常高时，请求可能会超时，用户将无法登录到应用程序，直到整体负载减少。

那么，有什么可以在这里帮助的吗？

答案是用户级缓存。当我们知道某些数据是特定于用户且对安全性不重要时，我们可以简单地从数据库中加载一次并将其保存在用户端。这可以通过实现 cookie 或在客户端创建临时文件来实现。这些 cookie 或临时文件存储有关用户的非机密数据，例如用户 ID 或用户名，或其他不重要的数据，例如用户的姓名。

每当应用程序想要加载这些数据时，它首先检查用户是否在其端有这些数据可用。如果找到数据，则从那里加载数据。如果在用户端找不到数据，则向数据库发出请求，然后从那里加载数据，最后在客户端缓存。

这种技术在试图减少特定于用户的数据加载的影响时非常有帮助，并且不需要经常从数据库刷新。

通过使用键值缓存机制，还有更复杂的缓存数据的技术，我们将在后面的章节中看到，比如使用诸如 memcached 之类的工具来实现内存缓存，这在处理大量数据时可能会非常有帮助。然而，由于涉及的主题复杂性可能涵盖数百页，这超出了本书的范围。

# 总结

在本章中，我们学习了如何构建数据库模型，以帮助我们在处理大规模数据时使应用程序性能更高。我们看到优化模型可以是优化的第一阶段，它可以帮助我们使应用程序更易于维护，通过减少数据库模型之间的耦合。然后，我们继续讨论索引如何有助于通过对更频繁访问的列进行索引来加快访问数据库内部数据。

后来，我们讨论了通过使用事务来维护数据库一致性的重要方面之一。

本章的最后部分涵盖了数据加载技术，如延迟加载、急切加载和无加载，…

# 问题

1.  数据库表规范化的好处是什么？

1.  通过`select`和通过`joined`进行延迟加载有什么区别？

1.  在运行数据库更新查询时，我们如何保持数据的完整性？

1.  从数据库缓存数据的不同级别是什么？
