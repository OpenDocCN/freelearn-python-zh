# 第十七章：评估

# 第一章

# 答案 1

在 Python 3 标准中，不允许将不可变类型的`byte`类型和`str`类型进行连接；任何尝试连接这两种类型的操作都会引发`TypeError`错误。

# 答案 2

Python 3 中引入的类型提示支持只旨在提供对方法和参数进行更清晰的文档记录，并不强制执行任何操作标准。

# 答案 3

除了功能性和非功能性需求外，软件需求规格说明文档还指定了其他要求，如 UI、性能、业务和市场需求。

# 答案 4

各种类型的需求被分类如下：

+   **必须要求：**这些是必须存在于系统中的要求。如果缺少任何一个，其缺失将影响系统中的关键功能。

+   **应该要求：**这些要求如果存在，将增强应用程序的功能。

+   **可选要求：**这些要求在性质上是非关键的。如果缺少它们，不会对应用程序的功能产生任何影响。

+   **需求愿望清单：**这些是利益相关者可能希望在应用程序的未来更新中看到的要求。

# 答案 5

一旦生成了软件需求规格说明文档，流程的下一步包括软件的设计阶段。在设计阶段，决定软件应用程序的结构，并就可能使用的技术栈做出决策。

# 第二章

# 答案 1

Python 中的责任链模式允许我们构建一个考虑松散耦合的应用程序。这是通过将接收到的请求通过软件内的一系列对象链传递实现的。

以下代码片段显示了在 Python 中实现责任链模式的方法：

```py
import abcclass Handler(metaclass=abc.ABCMeta):    """Handler provides an interface to build handlers."""    def __init__(self, handler=None):        """Initialize the handler.        Keyword arguments:        handler -- The next handler object to be called        """        self._next_handler = handler    @abc.abstractmethod    def handler(self, data):        """The handler abstract method.        Keyword arguments:        data -- The data to be processed by the handler        """        passclass StringHandler(Handler): ...
```

# 答案 2

`__new__`方法是在需要创建对象的新实例时调用的第一个方法，而`__init__`方法仅在需要初始化对象的新创建实例时运行。在类实例创建的正常流程中，`__new__`方法将始终首先执行，并且只有在开发人员希望控制新实例的创建时才应该被重写。然后应调用`__init__`方法，该方法将在实例创建后调用，并且需要进行初始化。

# 答案 3

使用 ABC 元类很容易定义一个新的抽象类。以下代码片段展示了实现这种行为的示例：

```py
import abcclass Handler(metaclass=abc.ABCMeta):    """Handler provides an interface to build handlers."""    def __init__(self, handler=None):        """Initialize the handler.        Keyword arguments:        handler -- The next handler object to be called        """        self._next_handler = handler    @abc.abstractmethod    def handler(self, data):        """The handler abstract method.        Keyword arguments:        data -- The data to be processed by the handler        """        pass
```

# 第三章

# 答案 1

DBMS 中模式的规范化提供了许多好处，例如：

+   改进关系的整体组织

+   减少冗余数据的存储

+   改进数据库中数据的一致性

+   更好地索引数据，提高对数据的访问

# 答案 2

SQLAlchemy 中的延迟加载为开发人员提供了使用*select*或*joined*模式进行延迟加载的选项。当开发人员选择*select*模式加载数据时，数据集的加载通过发出 SQL `SELECT`语句进行，这样可以根据需求加载数据。

在使用*joined*时，相关数据集通过发出 SQL `JOIN`语句一次性加载。这种技术也被称为连接式急加载。

# 答案 3

在进行数据更新时，我们可以通过多种方式来保持数据的完整性。其中一种最简单的方法是通过使用事务来实现，这允许我们在原子事务中进行多个更新，其中要么应用所有更新，要么不应用任何更新。

在事务中的更新失败时，之前应用的事务中的更新也会被回滚，从而保持数据库中关系的一致状态。

# 答案 4

可以在数据库中实现的不同级别的缓存如下：

+   **数据库级缓存：** 当我们在数据库级缓存时，通常利用数据库的内置功能，通过维护查询缓存来缓存频繁使用的数据集。

+   **块级缓存：** 块级缓存发生在应用程序级别，我们将 ORM 层获取的数据缓存到基于内存的数据存储中，以避免每次请求特定结果时运行数据库查询。

+   **用户级缓存：** 在用户级缓存时，非安全关键数据通过会话 cookie 或本地存储在客户端缓存。

# 第四章

# 答案 1

Python 有两种不同的方式允许我们构建能够并发处理请求的应用程序。具体如下：

+   **多进程：** Python 的多进程模块允许开发人员启动多个进程以并行处理工作负载

+   **多线程：** Python 多线程模块允许开发人员执行多个线程，可用于处理并发工作负载

# 答案 2

当获得锁的线程突然终止时，根据获得锁的方式，可能会出现多种情况。

如果锁是通过 Python 中的`with`语句获得的，那么一旦线程终止，锁就会被释放。

如果锁是在`try-except-final`方法中获取的，那么当异常传播到最终语句时，锁将被释放。

如果锁是在没有任何安全程序的情况下获得的，线程的突然终止将导致死锁，因为锁没有被释放。

# 答案 3

通常，当主程序接收到终止信号时，信号也会传播到其线程；否则，线程可以被标记为守护线程，以便其执行随主程序终止而终止。

另一种实现方式是通过标志，线程可以定期检查。如果标志被设置，线程就会开始终止。

# 答案 4

不同进程之间的状态共享可以通过使用管道来实现，这可以帮助进程彼此通信。

# 答案 5

在 Python 中，我们有多种方法来创建进程池以分发任务。我们可以手动创建这些池——就像本章*进程同步*部分中的示例所示——或者我们可以利用`concurrent.futures`库中提供的`ProcessPoolExecutor`。

# 第五章

# 答案 1

为了通过多个应用程序实例处理请求，我们使用水平扩展的概念，其中我们在负载均衡器后启动多个相同应用程序的实例。负载均衡器负责在这些应用程序实例池中分发传入的请求。

# 答案 2

可以通过 Python 中的`concurrent.futures`库中的`ProcessPoolExecutor`来实现进程池。如何使用`ProcessPoolExecutor`在本章的*使用线程池处理传入连接*部分中有示例。

# 答案 3

完全可以编写一个同时使用多进程和多线程的程序。以下代码片段显示了这种实现方式：

```py
import threading
import multiprocessing

def say_hello():
    print("Hello")

def start_threads():
    thread_pool = []
    for _ in range(5):
        thread = threading.Thread(target=say_hello)
        thread_pool.append(thread)
    for thread in thread_pool:
        thread.start()
    for thread in thread_pool:
        thread.join()

def start_process():
    process_pool = []
    for _ in range(3):
        process = multiprocessing.Process(target=start_threads)
        process_pool.append(process)
    for process in process_pool:
        process.start()
    for process in process_pool:
        process.join()

if __name__ == '__main__':
    start_process()
```

上述实现方式是有效的，并且可以轻松实现而不会出现任何问题，尽管您可能会发现它的使用案例有限，并且其使用将受到 GIL 实现的限制。

# 答案 4

本章的*使用 AsyncIO 实现简单的套接字服务器*部分展示了实现套接字服务器的简单示例。另一种通过使用`aiohttp`框架实现完全功能的 Web 服务器的方法是使用基于 AIO 的 HTTP 服务器。

# 第六章

# 答案 1

除了我们在本章中看到的通用`View`类之外，Flask 还提供了另一个预构建的可插拔视图类，称为`MethodView`。

# 答案 2

是的，我们可以删除用户表中对角色表的外键约束，并保持关系。但是每当我们需要存储数据时，我们将需要在用户表中手动插入角色对象所需的对象。

# 答案 3

有许多替代方案可用于为基于 Flask 的 Python 应用程序提供服务，例如以下内容：

+   uWSGI

+   扭曲的网络

+   `mod_wsgi`

+   Gevent

# 答案 4

增加 Gunicorn 工作进程的数量非常简单。我们只需要在命令中添加`-w <worker count>`参数来设置 Gunicorn 工作进程的数量，如下例所示：

```py
gunicorn -w 8 --bind 0.0.0.0:8000 wsgi:app
```

# 第七章

# 答案 1

使用 CDN 确实可以提高网页的加载性能。这是因为浏览器缓存来自给定 URL 的内容的方式。有时，当我们使用现有的 CDN 来提供一些内容时，我们可以获得以下好处：

+   对于一些常见的前端库，有可能用户的浏览器已经缓存了这些库，因为他们访问了其他网站，其中包括来自 CDN 的内容。这有助于我们避免重新下载这些库，减少带宽使用，并提高页面的加载速度。

+   CDN 还可以根据用户地理位置将请求路由到服务器，以便以最小的延迟下载内容，从而提高页面的加载速度。

# 答案 2

为了让浏览器使用现有的连接，我们可以利用一个叫做`KeepAlive`的概念。当请求中设置了`KeepAlive`头时，服务器会保持用于发出请求的连接打开一段固定的时间，希望可以在另一个请求中继续使用相同的连接，避免为每个请求进行初始连接设置的成本。

# 答案 3

JavaScript API 提供了一个非常方便的方法，称为`removeKey(key)`，可以用来从浏览器的本地/会话存储中删除特定的键。

# 第八章

# 答案 1

单元测试和功能测试之间的主要区别是测试的范围，如下所述：

+   **单元测试：**单元测试通常侧重于测试软件中的单个组件，这些组件可以被分解为单个函数或类的方法。

+   **功能测试：**功能测试也称为集成测试，通常测试系统的特定功能，可能涉及多个组件之间的交互，以及它们与外部环境（如数据库系统）的交互。

# 答案 2

测试套件是需要在特定程序上运行的一系列测试用例。使用 Python 的`unittest`库编写测试套件非常容易实现。例如，如果您编写了一些测试用例，比如`TestTextInput`、`TestTextUppercase`和`TestTextEncode`，我们可以使用以下代码片段将它们组合成一个测试套件：

```py
import texttest # Module containing our text related test casesimport unittest# Create a test loaderloader = unittest.TestLoader()# Create a test suitesuite = unittest.TestSuite()# Add tests to a suitesuite.addTests(loader.loadTestsFromModule(texttests)
```

# 答案 3

Pytest 中 fixture 的目的是提供一个固定和稳定的环境，以便测试用例可以执行。这些 fixture 负责通过设置所需的变量或接口来初始化环境，以便测试执行。

使用 fixture 的另一个优点是它的可重用性，允许同一个 fixture 在多个测试中使用而没有任何问题。

# 答案 4

Pytest 中的 fixture 作用域描述了 fixture 将被调用的频率。fixture 有许多不同的作用域可以应用于它们，如下所示：

+   **函数作用域：**Fixture 在每个测试中运行一次

+   **类作用域：**Fixture 在每个类中运行一次

+   **模块作用域：**Fixture 在每个模块中运行一次

+   **会话作用域：**Fixture 在每个测试会话中运行一次

# 第九章

# 答案 1

应用程序内部可能导致性能瓶颈的多个因素，包括以下内容：

+   不足的硬件资源规划，以运行应用程序

+   在应用程序中实施功能的算法选择不当

+   数据库关系实施不当，存在大量冗余

+   未对频繁访问的数据实施适当的缓存

# 答案 2

Python 中方法的时间分析有助于我们了解方法执行所需的时间。根据要求，我们可以通过几种不同的方式对方法进行时间分析，如下所示：

+   **使用**`timeit`**模块：**`timeit`模块提供了一个功能，可以用来找出脚本或方法执行所需的时间。

+   **使用**`time`**模块：**我们还可以使用`time`模块来帮助我们测量 Python 中方法的运行时间。我们可以通过创建装饰器来实现这一点，这可以帮助我们对方法的运行时间进行分析。

+   **使用**`cProfile`**模块：**`cProfile`模块允许我们对 Python 程序内部的不同步骤进行性能分析。

# 答案 3

尽管 Python 是一种具有垃圾回收功能且没有直接访问内存指针的语言，但通过非法指针操作可能导致的典型内存泄漏几乎不会发生。但还有另一种方式，即 Python 程序可以继续消耗更多内存而不释放它。当程序忘记在对象不再使用时取消引用这些对象时，可能会导致分配新对象而不进行不再使用对象的垃圾回收。

# 答案 4

应用程序的 API 响应可以通过测量 API 返回响应所需的平均时间来进行性能分析，这可以通过多种方式进行测量，可能涉及使用 Python 标准库中的`timeit`或`time`模块。

# 答案 5

设计模式在应用程序性能中起着重要作用，不正确的设计模式可能会对应用程序性能造成影响。例如，考虑分配一个对象来实现应用程序中的日志记录。如果这个日志记录对象分配需要在每个单独的模块或类中进行，那么我们可能会浪费大量资源来分配一个对象，而这个对象本可以在不同模块之间共享。

# 第十章

# 答案 1

目前有许多问题使得应用程序的安全性变得困难。这些问题包括以下内容：

+   难以应对的复杂攻击

+   未被修补的 0-day 漏洞的增加

+   越来越多的国家支持的攻击针对系统的多个漏洞，通常很难追踪

+   越来越多的设备上线而没有适当的安全措施，使它们容易受到 DDoS 攻击的利用

# 答案 2

XSS（或跨站脚本）攻击是指攻击者在受信任的网站中注入恶意脚本。当加载带有恶意脚本的页面时，它会导致客户端系统受到攻击者的威胁。

# 答案 3

DoS（或拒绝服务）攻击是攻击者用来通过向系统发送多余的请求来使服务或资源对其用户不可用的一种方式，这会导致系统排队这些请求并造成服务中断。

可以通过在不同级别实施不同的技术来减轻攻击，例如：

+   添加防火墙规则以拒绝来自给定不受信任来源的流量

+   使用云安全提供商的服务，可以分析传入流量并在到达应用程序基础设施之前阻止它，有助于减轻 DoS 攻击

+   配置基础设施以将流量引导到没有运行应用程序的节点，或者重新路由...

# 答案 4

有很多可能的错误可能会危及应用程序的安全性，例如：

+   在应用程序内部使用不安全的第三方库，可能包含安全漏洞

+   不过滤用户提供的应用程序输入

+   在应用程序内部以未加密的方式存储安全敏感数据

+   不实施适当的限制以控制对内部基础设施的访问

# 第十一章

# 答案 1

面向服务的架构和微服务架构之间的主要区别在于，在面向服务的架构中，应用程序由不同的服务组成，每个服务提供组织业务领域之一的功能。这些服务通过企业服务总线进行通信，该总线将消息从一个服务路由到另一个服务，同时提供消息交换的通用格式。

在微服务的情况下，应用程序将由许多小型微服务组成，每个微服务负责提供仅限于单一功能的功能，可能无法映射到组织的完整领域，可能只是更大问题领域的子集。这些微服务通过各自微服务公开的 API 或通过无状态消息路由器进行通信，允许消息从一个服务传递到另一个服务。

# 答案 2

为了确保基于微服务的应用程序具有高的正常运行时间，我们可以使用以下技术：

+   不使用单一存储来存储所有微服务

+   在负载均衡器后运行同一微服务的多个实例

+   使用 API 网关在关键服务失败时提供优雅降级的服务，使客户端仍然在服务失败时收到响应

# 答案 3

使用服务级别协议（SLA）提供了许多保证，例如：

+   对服务的 API 稳定性的保证

+   对服务正常运行时间的保证

+   对服务的预期响应时间的保证

+   对服务实施的请求速率限制的保证

# 答案 4

API 网关可以通过服务注册表提供的 SDK 或通过服务注册表公开的 API 与服务注册表直接通信。这允许 API 网关自动从服务注册表中获取给定服务的正确位置。

# 答案 5

微服务内部的异步通信可以通过使用无状态消息代理来实现。要实现异步通信，一些微服务充当生产者，并将消息发送到消息代理队列。然后，其他微服务可能会消费该消息，处理它，并将响应发送回发送消息的微服务。然后，由请求微服务设置的回调函数来处理响应。这就是微服务之间的异步通信建立的方式。

# 第十二章

# 答案 1

微服务的集成测试基本上与单片应用程序的测试方式相同，只有以下几点不同：

+   如果微服务需要与另一个外部微服务通信，则集成测试可能需要设置外部服务，以便正确执行测试用例

+   组成单个服务的各个组件应该为基础设施中的所有微服务设置好，例如，伴随特定微服务的数据库需要用于测试目的

# 答案 2

单体应用程序的跟踪与基于微服务的应用程序的跟踪不同，单体应用程序的跟踪涉及理解请求从应用程序内的一个组件到另一个组件的流程。相反，跟踪基于微服务的应用程序涉及理解请求不仅在特定微服务内的流动，还涉及请求从一个微服务到另一个微服务的流动。

# 答案 3

有多个可用于微服务架构内跟踪的工具，如下列表所示：

+   Jaeger

+   Zipkin

+   Appdash

# 答案 4

为了跟踪微服务内的各个组件，我们可以利用 Jaeger 提供的功能之一，称为 spans。如何使用 spans 的示例可以在[`github.com/jaegertracing/jaeger-client-python`](https://github.com/jaegertracing/jaeger-client-python)中看到。

# 第十三章

# 答案 1

迁移到无服务器架构提供了许多优势，例如：

+   通过集成第三方服务减少开发工作量

+   操作复杂性减少，因为现在组织不需要关心基础设施

+   改进的安全性，因为各个功能在它们自己独立的容器中执行，这有助于我们保持不同功能之间不会相互干扰

+   应用程序的可扩展性得到改善

# 答案 2

使用**后端即服务**（**BaaS**）有助于通过集成 API 提供的常见功能来创建应用程序。这些服务由第三方提供商托管，从而减少了应用程序开发人员在从头开始重建它们的应用程序中所需的工作量。

# 答案 3

无服务器架构中的 API 网关将 API 端点映射到后端的一个功能。当特定事件发生时，客户端可以调用这些 API 端点，从而调用后端功能。

# 答案 4

有一些原因导致应用无法成功迁移到无服务器架构。这些原因如下：

+   使用无服务器基础设施提供商不支持的技术堆栈

+   需要存储请求处理状态以生成正确结果的应用程序

+   代码基础紧密耦合，很难定义个别方法

+   应用程序的某些组件执行时间非常长

# 第十四章

# 答案 1

使用蓝绿部署为我们提供了以下一系列好处：

+   能够立即将应用程序从一个版本切换到另一个版本

+   在新版本遇到一些关键功能错误时，能够轻松将应用程序从新版本回滚到旧版本

+   与应用程序升级相关的停机时间减少

# 答案 2

使用 Canary 部署可以帮助测试应用程序的以下方式：

+   应用程序经过一小部分真实请求的测试，这可能有助于暴露应用程序中的任何未识别的错误

+   Canary 部署使我们能够同时运行应用程序的新版本和旧版本，以便比较 API 提供的响应

# 答案 3

使用虚拟机运行基于微服务的应用程序可能会导致微服务实例的开销增加，因为虚拟机的要求更高。此外，使用虚拟机会限制可以共存在同一基础设施上的服务数量，因为虚拟机比容器更重，容器利用操作系统功能来保持程序隔离。

# 答案 4

混合云模型中的部署可以以与公共或私有云中处理的方式进行处理。区别在于应用程序需要进行扩展时。在这种情况下，使用混合云方法时，组织可以根据扩展的需求从公共云中汇集资源，然后在公共云中运行其应用程序的某些部分，而在私有云中运行其他部分。

# 第十五章

# 答案 1

企业应用程序的点对点集成需要为需要集成的每对应用程序构建连接器。这将创建一个复杂的基础设施，如果引入新应用程序，可能难以管理和扩展。

# 答案 2

企业服务总线负责通过消息传递机制帮助基础设施内的不同服务相互连接。ESB 为应用程序提供连接器，应用程序可以通过这些连接器连接到 ESB 并向 ESB 发送消息。

然后，ESB 负责将这些消息路由到它们预期的正确服务，从而促进基础设施内两个服务之间的通信。

# 答案 3

EAI 的不同类型的模式如下：

+   调解模式

+   联邦模式

# 第十六章

# 答案 1

由于基础设施中可能使用特定微服务的不同技术堆栈，因此很难实现不同微服务的点对点集成。这可能导致为每对微服务构建单独的连接器，以将一个微服务的数据格式转换为另一个微服务的数据格式。

另一个瓶颈是由于这些服务的可伸缩性，现在连接器必须连接部署的每个单个微服务实例。

# 答案 2

随着微服务架构的出现，企业服务总线已被无状态消息路由器所取代，这些路由器可以单独扩展，并为可能在基础设施内运行的大量微服务实现消息路由。

# 答案 3

微服务架构中的消息代理通过在多个消息代理实例之间复制消息队列来提供高可用性。这允许路由器取代失败的路由器，并保持基础设施内的通信完整。
