# 第九章：为性能分析应用程序

在本书的过程中，我们已经看到了应用程序的性能和可扩展性在企业环境中有多么重要；考虑到这一点，我们在本书的相当大部分内容中致力于理解如何构建一个不仅性能良好而且可扩展的应用程序。

到目前为止，我们只是看到了一些构建高性能和可扩展应用程序的最佳实践，但并不知道如何找出我们应用程序中特定代码的执行速度慢以及可能导致它的原因。

对于任何企业级应用程序，提高其性能和可扩展性是一个持续的过程，因为应用程序的用户群不断增长，应用程序的…

# 技术要求

本书中的代码清单可以在[`github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python`](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter09`目录下找到。

与 bugzot 示例应用程序的性能分析和基准测试相关的代码示例可以在代码库的测试模块下的`chapter06`目录中找到。

可以通过运行以下命令克隆代码示例：

```py
git clone https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python
```

这一章还依赖于第三方 Python 库，可以通过在开发系统上运行以下命令轻松安装：

```py
pip install memory_profiler
```

# 性能瓶颈的幕后

在应用程序进入开发阶段之前，会对应用程序应该做什么、如何做以及应用程序需要与之交互的第三方组件的类型进行彻底讨论。一旦所有这些都确定下来，应用程序就进入了开发阶段，在这个阶段，开发人员负责以尽可能高效的方式构建应用程序，以便应用程序执行的任务可以以最有效的方式完成。这种效率通常是以应用程序完成提供的任务所需的时间和应用程序在执行该任务时使用的资源数量来衡量的。

当应用程序部署到生产环境时，…

# 查看性能瓶颈的原因

通常，性能瓶颈可能是由许多因素引起的，这些因素可能包括部署应用程序的环境中物理资源的短缺，或者在处理特定工作负载时选择了不好的算法，而实际上有更好的算法可用。让我们看看可能导致部署应用程序性能瓶颈的一些可能问题：

+   **没有足够的硬件资源：** 最初，性能和可扩展性的大部分瓶颈是由于对运行应用程序所需的硬件资源的规划不足。这可能是由于估计不正确或应用程序用户群突然不经意地激增。当这种情况发生时，现有的硬件资源会受到压力，系统会变慢。

+   **不正确的设计选择：** 在第二章中，*设计模式-做出选择*，我们看到了对于任何企业级应用程序来说，设计选择是多么重要。不断为某些事情分配新对象，而本可以通过分配一个共享对象来完成，这将影响应用程序的性能，不仅会给可用资源带来压力，还会因为重复分配对象而导致不必要的延迟。

+   **低效的算法：** 在处理大量数据或进行大量计算以生成结果的系统中，由于选择了低效的算法，性能可能会下降。仔细研究可用的替代算法或现场算法优化的可用性可能有助于提高应用程序的性能。

+   **内存泄漏：** 在大型应用程序中，可能会出现内存泄漏的地方。尽管在 Python 等垃圾收集语言中这很困难，但仍然有可能发生。有时候，尽管对象不再使用，但由于它们在应用程序中的映射方式，它们仍然没有被垃圾收集。随着运行时间的延长，这将导致可用内存减少，并最终使应用程序停止运行。

这些是系统中性能瓶颈发生的几个原因。对于我们作为软件开发人员来说，幸运的是，我们有许多工具可以帮助我们找出瓶颈，以及发现诸如内存泄漏之类的问题，甚至只是对个别部分的内存使用进行分析。

有了关于为什么会出现性能瓶颈的知识，现在是时候学习如何在应用程序中寻找这些性能瓶颈，然后尝试理解我们可以减少它们影响的一些方法了。

# 探测应用程序的性能问题

性能是任何企业级应用程序的关键组成部分，您不能容忍应用程序经常变慢并影响整个组织的业务流程。不幸的是，性能问题也是最难理解和调试的问题之一。这种复杂性是因为没有标准的方法来访问应用程序中特定代码片段的性能，而且一旦应用程序开发完成，就需要理解代码的完整流程，以便找出可能导致特定性能问题的可能区域。

作为开发人员，我们可以通过以这种方式构建应用程序来减少这些困难...

# 编写性能基准测试

让我们从讨论开始，讨论我们作为软件开发人员如何构建应用程序，以帮助我们在开发周期的早期阶段标记性能瓶颈，以及如何在调试这些瓶颈方面使我们的生活变得更加轻松。

在应用程序开发周期中，我们可以做的第一件最重要的事情是为应用程序的各个组件编写基准测试。

基准测试是简单的测试，旨在通过多次迭代执行代码并计算这些迭代中执行代码所需的时间的平均值来评估特定代码片段的性能。您还记得听说过一个名为 Pytest 的库吗？我们在第八章中用它来编写单元测试，*编写可测试的代码*吗？

我们将利用相同的库来帮助我们编写性能基准测试。但是，在我们可以让 Pytest 用于编写基准测试之前，我们需要让它理解基准测试的概念，这在 Python 中非常容易，特别是因为有一个庞大的 Python 生态系统可用。为了让 Pytest 理解基准测试的概念，我们将导入一个名为`pytest-benchmark`的新库，它为 Pytest 添加了基准测试固定装置，并允许我们为我们的应用程序编写基准测试。为此，我们需要运行以下命令：

```py
pip install pytest-benchmark
```

一旦我们安装了库，我们就可以为我们的应用程序编写性能基准测试了。

# 编写我们的第一个基准测试

安装所需的库后，现在是时候为我们的第一个性能基准测试编写了。为此，我们将使用一个简单的示例，然后继续了解如何为我们的应用程序编写基准测试：

```py
'''File: sample_benchmark_test.pyDescription: A simple benchmark test'''import pytestimport timedef sample_method():  time.sleep(0.0001)  return 0def test_sample_benchmark(benchmark):  result = benchmark(sample_method)  assert result == 0if __name__ == '__main__':  pytest.main()
```

我们已经编写了我们的第一个基准测试。确实是一个非常简单的测试，但有很多事情我们需要了解，以便看清我们在这里做什么：

首先，当我们开始编写基准测试时，我们导入...

# 编写 API 基准测试

有了这个，我们知道如何编写一个简单的基准测试。那么，我们如何为我们的 API 编写类似的东西呢？让我们看看如何修改我们用于验证索引 API 端点功能的 API 测试之一，并看看如何在其中运行基准测试。

以下代码修改了我们现有的索引 API 测试用例，包括 API 的基准测试：

```py
'''
File: test_index_benchmark.py
Description: Benchmark the index API endpoint
'''
import os
import pytest
import sys
import tempfile

sys.path.append('.')
import bugzot

@pytest.fixture(scope='module')
def test_client():
  db, bugzot.app.config['DATABASE'] = tempfile.mkstemp()
  bugzot.app.config['TESTING'] = True
  test_client = bugzot.app.test_client()

  with bugzot.app.app_context():
    bugzot.db.create_all()

  yield test_client

  os.close(db)
  os.unlink(bugzot.app.config['DATABASE'])

def test_index_benchmark(test_client, benchmark):
  resp = benchmark(test_client.get, "/")
  assert resp.status_code == 200
```

在上述代码中，我们只需添加一个名为`test_index_benchmark()`的新方法，它接受两个 fixture 作为参数。其中一个 fixture 负责设置我们的应用程序实例，第二个 fixture——基准 fixture——用于在客户端 API 端点上运行基准测试并生成结果。

另一个重要的事情要注意的是，我们如何能够将单元测试代码与基准测试代码混合在一起，这样我们就不需要为每个测试类编写两种不同的方法；所有这些都是由 Pytest 实现的，它允许我们在方法上运行基准测试，并允许我们通过单个测试方法验证被测试的方法是否提供了正确的结果。

现在我们知道如何在应用程序中编写基准测试。但是，如果我们需要调试某些慢的东西，但基准操作并没有引发任何关注，我们该怎么办呢？幸运的是，Python 提供了许多选项，允许我们测试代码内部可能发生的任何性能异常。因此，让我们花一些时间来了解它们。

# 进行组件级性能分析

使用 Python，许多设施都是内置的，其他设施可以很容易地使用第三方库实现。因此，让我们看看 Python 为我们提供了哪些用于运行组件级性能分析的功能。

# 使用 timeit 测量慢操作

Python 提供了一个非常好的模块，称为`timeit`，我们可以使用它来对代码的小片段运行一些简单的时间分析任务，或者了解特定方法调用所花费的时间。

让我们来看一个简单的脚本，向我们展示了如何使用`timeit`来了解特定方法所花费的时间，然后我们将更多地了解如何使用`timeit`提供的功能来运行我们打算构建的应用程序的时间分析。

以下代码片段展示了在方法调用上运行`timeit`进行时间分析的简单用法：

```py
import timeit

def calc_sum():
    sum = 0
    for i in range(0, 100):
        sum = sum + i
    return sum

if __name__ == '__main__':
    setup = "from __main__ import calc_sum"
    print(timeit.timeit("calc_sum()", setup=setup))
```

运行此文件后，我们得到的输出如下：

```py
7.255408144999819
```

正如我们从上面的示例中看到的，我们可以使用`timeit`来对给定方法的执行进行简单的时间分析。

现在，这很方便，但是当我们需要对多个方法进行计时时，我们不能一直编写多个设置语句。在这里我们该怎么办呢？应该有一种简单的方法来实现这一点。

那么，我们可以创建一个简单的装饰器，用于对可能需要时间分析的方法进行计时。

让我们创建这个简单的装饰器方法。以下示例向我们展示了如何编写一个装饰器方法，以便以后在我们的方法上进行时间比较：

```py
import time
def time_profile(func):
  """Decorator for timing the execution of a method."""
  def timer_func(*args, **kwargs):
    start = time.time()
    value = func(*args, **kwargs)
    end = time.time()
    total_time = end – start
    output_msg = "The method {func} took {total_time} to execute"
    print(output_msg.format(func=func, total_time=total_time))
    return value
  return timer_func
```

这是一个我们创建的装饰器。在装饰器内部，我们将要分析的函数作为参数传入，以及传递给它的任何参数。现在，我们初始化函数的开始时间，然后调用函数，然后在函数返回执行后存储调用的结束时间。基于此，我们计算函数执行所花费的总时间。

但是我们如何使用这个装饰器来分析我们的方法呢？以下示例展示了一个示例：

```py
@time_profile
def calc_sum():
    sum = 0
    for i in range(100):
        sum = sum+i
    return sum
```

这非常简单，比一遍又一遍地导入单个方法进行时间分析要容易得多。

因此，我们的`timeit`方法是一个非常简单的方法，可以为我们提供有关特定方法执行所花费的时间的一些基本信息。我们甚至可以使用这些方法对单个语句进行分析。但是，如果我们想要更详细地了解特定方法内部单个语句花费了多少时间，或者了解是什么导致了给定方法变慢，我们的简单计时解决方案就不是一个理想的选择。我们需要更复杂的东西。

事实上，Python 为我们提供了一些内置的分析器，我们可以使用它们来对应用程序进行深入的性能分析。让我们看看如何做到这一点。

# 使用 cProfile 进行分析

Python 库为我们提供了一个应用程序分析器，可以通过它轻松地对整个应用程序以及应用程序的各个组件进行分析，从而简化开发人员的工作。

Profile 是一个内置的代码分析器，作为一些 Python 发行版的模块捆绑在一起。该模块能够收集有关已进行的单个方法调用的信息，以及对第三方函数的任何调用进行分析。

一旦收集了这些细节，该模块将为我们提供大量统计信息，可以帮助我们更好地了解组件内部发生了什么。在我们深入了解收集和表示的细节之前，...

# 使用 memory_profiler 进行内存使用分析

内存分析是应用程序性能分析的一个非常重要的方面。在构建应用程序时，有些地方我们可能会实现处理动态分配对象的不正确机制，因此可能会陷入这样一种情况：这些不再使用的对象仍然有一个指向它们的引用，从而阻止了垃圾收集器对它们的回收。

这导致应用程序内存使用随时间增长，导致应用程序在系统耗尽可分配给应用程序执行其常规活动所需的内存时停止运行。

现在，为了解决这些问题，我们不需要一个能帮助我们分析应用程序调用堆栈并提供有关单个调用花费了多少时间的分析器。相反，我们需要的是一个能告诉我们应用程序的内存趋势的分析器，比如单个方法可能消耗多少内存，以及随着应用程序继续运行，内存如何增长。

这就是`memory_profiler`发挥作用的地方，它是一个第三方模块，我们可以轻松地将其包含在我们的应用程序中以进行内存分析。但是，在深入了解如何使用`memory_profiler`之前，我们需要先将该模块引入我们的开发环境。以下代码行将所需的模块引入我们的开发环境：

```py
pip install memory_profiler
```

一旦内存分析器被获取到开发环境中，我们现在可以开始使用它了。让我们看一个示例程序，并了解如何使用`memory_profiler`来了解我们应用程序的内存使用模式。

以下代码片段向我们展示了如何使用`memory_profiler`的示例：

```py
from memory_profiler import profile

@profile
def calc_sum():
    sum = 0
    for i in range(100):
        sum = sum + i
    print(str(sum))

if __name__ == '__main__':
    calc_sum()
```

现在，代码已经就位，让我们试着理解我们在这里做了什么。

首先，我们导入了一个名为 profile 的装饰器，它是由`memory_profiler`库提供的。这个装饰器用于通知`memory_profiler`需要对内存使用情况进行分析的方法。

要为方法启用内存分析，我们只需要使用装饰器装饰该方法。例如，在我们的示例应用程序代码中，我们使用装饰器装饰了`calc_sum()`方法。

现在，让我们运行我们的示例代码，并通过运行以下命令查看输出结果：

```py
python3 memory_profile_example.py
```

一旦执行了命令，我们会得到以下输出：

```py
4950
Filename: memory_profile.py

Line # Mem usage Increment Line Contents
================================================
     3 11.6 MiB 11.6 MiB @profile
     4 def calc_sum():
     5 11.6 MiB 0.0 MiB sum = 0
     6 11.6 MiB 0.0 MiB for i in range(100):
     7 11.6 MiB 0.0 MiB sum = sum + i
     8 11.6 MiB 0.0 MiB print(str(sum))
```

从上述输出中可以看出，我们得到了有关该方法的内存分配的详细统计信息。输出为我们提供了有关应用程序使用了多少内存以及每个步骤导致应用程序增加了多少内存的信息。

现在，让我们举一个例子，看看当一个方法调用另一个方法时内存分配如何改变。以下代码展示了这一点：

```py
from memory_profiler import profile

@profile
def calc_sum():
    sum = 0
    for i in range(100):
        sum = sum + i
    say_hello()
    print(str(sum))

def say_hello():
    lst = []
    for i in range(10000):
        lst.append(i)

if __name__ == '__main__':
    calc_sum()
```

执行上述代码后，我们得到以下输出：

```py
Line # Mem usage Increment Line Contents
================================================
     3 11.6 MiB 11.6 MiB @profile
     4 def calc_sum():
     5 11.6 MiB 0.0 MiB sum = 0
     6 11.6 MiB 0.0 MiB for i in range(100):
     7 11.6 MiB 0.0 MiB sum = sum + i
     8 11.7 MiB 0.1 MiB say_hello()
     9 11.7 MiB 0.0 MiB print(str(sum))
```

正如我们所看到的，当调用`say_hello()`方法时，调用导致内存使用量增加了 0.1 MB。如果我们怀疑代码中可能存在内存泄漏，这个库就非常方便。

# 收集实时性能数据

到目前为止，我们已经看到了在需要时如何使用不同的性能分析工具来分析应用程序的性能，以帮助我们找出代码的哪一部分导致了性能瓶颈。但是，我们如何知道一个操作是否花费的时间比应该花费的时间长？

其中一个答案可能是用户报告的响应时间慢，但这可能有很多因素，可能只涉及用户端的减速。

我们可以使用一些其他机制来实时监控应用程序的性能问题。因此，让我们看看其中一种方法，它允许我们收集有关单个操作所需时间的信息...

# 记录性能指标

在应用程序中，可能有几个步骤。可以通过使用不同的工具来分析每个步骤的性能。其中最基本的工具之一是日志记录。在这种情况下，我们收集不同方法的执行时间，并将其记录在日志文件中。

以下代码片段展示了如何在我们在第六章中构建的演示应用程序中实现这一点，*示例-构建 BugZot*：

```py
@app.before_request
def before_request_handler():
    g.start_time = time.time()

@app.teardown_request
def teardown_request_handler(exception=None):
    execution_time = time.time() - g.start_time
    app.logger.info("Request URL: {} took {} seconds".format(request.url, str(execution_time)))
```

这是一个简单的代码，记录了请求中调用的每个 API 端点的执行时间。我们在这里做的非常简单。我们首先创建一个`before_request`处理程序，在 flask 全局命名空间中初始化一个属性`start_time`。一旦完成这一步，请求就被发送到处理程序。一旦请求被处理，它就会进入我们定义的`teardown`处理程序。

一旦请求到达这个`teardown`处理程序，我们计算处理请求所需的总时间，并将其记录在应用程序日志中。

这种方法允许我们查询或处理我们的日志文件，了解每个请求所需的时间以及哪些 API 端点花费了最长的时间。

# 避免性能瓶颈

在过去的几个部分中，我们看了一下我们可以对应用程序进行性能分析的不同方式，以便解决可能导致性能下降或内存泄漏的性能瓶颈。但是一旦我们意识到这些问题以及它们发生的原因，我们还有哪些其他选项可以防止它们再次发生呢？

幸运的是，我们有一些有用的准则可以帮助防止性能瓶颈，或者可以限制这些瓶颈可能产生的影响。因此，让我们看看其中一些准则：

+   **选择正确的设计模式：**设计模式在应用程序中是一个重要的选择。例如，日志对象不需要在应用程序的每个子模块中重新初始化...

# 总结

在本章中，我们看到应用程序的性能是软件开发中的重要方面，通常会导致应用程序出现性能瓶颈的问题。接下来，我们看了一下我们可以对应用程序进行性能分析的不同方式。首先，这涉及编写单个组件以及单个 API 的基准测试，然后转向更具体的组件级分析，我们看了不同的组件分析方法。这些分析技术包括使用 Python 的`timeit`模块对方法进行简单的时间分析，然后我们转向使用更复杂的技术，使用 Python cProfile 并进行内存分析。在我们的旅程中，我们还看了一下使用日志技术来帮助我们评估慢请求的一些主题。最后，我们看了一些通用原则，可以帮助我们预防应用程序内的性能瓶颈。

在下一章中，我们将看一下保护应用程序的重要性。如果不这样做，不仅会为严重的数据窃取铺平道路，还会产生许多责任，并可能侵蚀用户的信任。

# 问题

1.  应用部署时可能导致性能瓶颈的因素有哪些？

1.  我们可以通过哪些不同的方式来对方法进行时间分析？

1.  什么可能导致 Python 中的内存泄漏，Python 是一种垃圾收集语言？

1.  我们如何对 API 响应进行分析，找出其减慢的原因？

1.  选择错误的设计模式会导致性能瓶颈吗？
