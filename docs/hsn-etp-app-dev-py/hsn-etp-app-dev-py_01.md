# 第一章：使用 Python 进行企业开发

Python 在编程世界中已经存在了二十多年，多年来，这种语言已经经历了许多改进，一个不断增长的社区，以及许多生产就绪和得到良好支持的库。但 Python 是否准备好在长期由 C++、Java 和.NET 等所谓的**企业级语言**主导的企业应用程序开发领域取得突破？

在本章中，我们将看到 Python 如何在多年来发展，并且准备成为企业应用程序开发领域的严肃竞争者。

本章将涵盖以下主题：

+   Python 的最新发展，以促进其在企业应用程序开发中的增长

+   Python 发光的特殊用例

+   企业和通用软件之间的区别

+   开发企业应用程序的要求

# 技术要求

本书中的代码清单可以在[`github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python`](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python)的`chapter01`目录下找到

可以通过运行以下命令克隆代码示例：

```py
git clone https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python
```

运行代码的说明可以在各个章节目录下的`README`文件中找到。

代码已经测试在运行 Fedora 28 和 Python 版本 3.6.5 的系统上运行，但它应该能够在运行 Python 3.6.5 的任何系统上运行。

# Python 的最新发展

Python 是一种动态类型的解释型语言，最初非常适合于无聊和重复的日常脚本任务。但随着年龄的增长，语言获得了许多新功能和庞大的社区支持，推动了其发展，使其成为一种非常适合执行从简单的应用程序（如网络抓取）到分析大量数据以训练机器学习模型的任务的语言。这些模型本身是用 Python 编写的。让我们看看多年来发生了哪些重大变化，并了解 Python 的最新版本 Python 3 带来了什么。

# 放弃向后兼容性

Python 作为一种语言在多年来发生了很大变化，但尽管这一事实，用 Python 1.0 编写的程序仍然能够在 Python 2.7 中运行，这是在 Python 1.0 发布 19 年后发布的版本。

尽管对 Python 应用程序的开发人员来说是一个巨大的好处，但语言的这种向后兼容性也是语言规范的重大改进的增长和发展的主要障碍，因为如果对语言规范进行重大更改，大量旧代码库将会中断。

随着 Python 3 的发布，这种向后兼容性链被打破了。版本 3 的语言放弃了对早期版本编写的程序的支持...

# 这都是 Unicode

在 Python 2 时代，文本数据类型`str`用于支持 ASCII 数据，对于 Unicode 数据，语言提供了`unicode`数据类型。当有人想要处理特定编码时，他们会取一个字符串并将其编码为所需的编码方案。

此外，该语言天生支持将字符串类型隐式转换为`unicode`类型。如下代码片段所示：

```py
str1 = 'Hello'
type(str1)        # type(str1) => 'str'
str2 = u'World'
type(str2)        # type(str2) => 'unicode'
str3 = str1 + str2
type(str3)        # type(str3) => 'unicode'
```

这曾经有效，因为在这里，Python 会隐式地使用默认编码将字节字符串`str1`解码为 Unicode，然后执行连接。这里需要注意的一点是，如果`str1`字符串包含任何非 ASCII 字符，那么这种连接在 Python 中将失败，引发`UnicodeDecodeError`。

随着 Python 3 的到来，处理文本的数据类型发生了变化。现在，默认数据类型`str`用于存储文本并支持 Unicode。此外，Python 3 还引入了一个名为`bytes`的二进制数据类型，用于存储二进制数据。这两种类型`str`和`bytes`是不兼容的，它们之间不会发生隐式转换，任何尝试这样做的行为都会引发`TypeError`，如下面的代码所示：

```py
str1 = 'I am a unicode string'
type(str1) # type(str1) => 'str'
str2 = b"And I can't be concatenated to a byte string"
type(str2) # type(str2) => 'bytes'
str3 = str1 + str2
-----------------------------------------------------------
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can't concat str to bytes
```

正如我们所看到的，尝试将`unicode`类型字符串与`byte`类型字符串连接失败，出现了`TypeError`。虽然无法将`string`隐式转换为`byte`，或者将`byte`隐式转换为`string`，但我们有一些方法可以将`string`编码为`bytes`类型，将`bytes`类型解码为`string`。看看以下代码：

```py
str1 = '₹100'
str1.encode('utf-8')
#b'\xe2\x82\xb9100'
b'\xe2\x82\xb9100'.decode('utf-8')
# '₹100'
```

字符串类型和二进制类型之间的明显区别以及对隐式转换的限制可以实现更健壮的代码和更少的错误。但这些变化也意味着，任何在 Python 2 中处理 Unicode 的代码都需要在 Python 3 中进行重写，因为存在向后不兼容性。

在这里，你应该关注用于将`string`转换为`bytes`和反之的编码和解码格式。选择不同的格式进行编码和解码可能会导致重要信息的丢失，并可能导致数据损坏。

# 类型提示的支持

Python 是一种动态类型语言，因此变量的类型在赋值后由解释器在运行时评估，如下面的代码所示：

```py
a = 10type(a)        # type(a) => 'int'a = "Joe"      type(a)        # type(a) => 'str'
```

尽管动态解释变量类型的功能在编写小型程序时可能很方便，因为代码库可以很容易地被跟踪，但当处理非常庞大的代码库时，这种语言特性也可能成为一个大问题，因为会产生大量模块，跟踪特定变量类型可能会成为一个挑战，与不兼容类型相关的愚蠢错误也很容易发生。看看以下代码：...

# Python 的亮点

每种语言都是为了解决开发人员在构建特定领域软件时遇到的某种类型的问题而开发的。Python 作为一种动态类型、解释型语言，也有一系列擅长的用例。

这些用例涉及自动化重复和乏味的任务，快速原型设计应用程序，以及专注于实现特定目标的小型应用程序，比如安装软件、设置开发环境、执行清理等。

但这就是全部吗？Python 只适用于执行小任务吗？答案是否定的。作为一种语言，Python 更加强大，可以轻松完成大量越来越复杂的任务，比如运行一个网站，能够在很短的时间内扩展以满足数百万用户的需求，处理大量的传入文件，或者为图像识别系统训练机器学习模型。

我们正在讨论使用 Python 执行越来越复杂的任务，但与我们传统的编译时语言（如 C++、Java 和.NET）相比，Python 是否慢？嗯，这完全取决于一个人想要使用 Python 的上下文。如果你的目标是在处理能力有限的嵌入式设备上运行 Python 程序，那么是的，Python 可能不够，因为其解释器对处理环境的额外负载。但如果你计划在配置良好的现代硬件上运行 Web 应用程序，你可能永远不会在使用 Python 时遇到任何减速。相反，你可能会觉得在使用 Python 时更加高效，因为其语法非常简单，执行操作时无需编写数百行代码。

因此，让我们看看 Python 在企业环境中的表现。

# 企业 IT 的需求

企业 IT 是复杂的，为企业构建的应用程序与为普通消费者构建的应用程序有很大的不同。在为企业用户开发应用程序之前，需要考虑几个因素。让我们看看企业 IT 应用程序与普通消费者产品有何不同，如下列表所示：

+   **面向业务**：与为解决个人用户问题而构建的应用程序不同，企业应用程序是为满足组织的特定需求而构建的。这要求应用程序符合组织的业务实践、规则和工作流程。

+   **健壮性...**

# Python 在企业生态系统中

Python 以多种形式存在于企业生态系统中；无论是自动化乏味和重复的任务，作为产品两层之间的粘合剂，还是用于构建快速易用的大型服务器后端客户端，该语言在各种用例中都看到了越来越多的采用。但是是什么让 Python 准备好开发大型企业应用程序呢？让我们来看一下：

+   **能够快速构建原型**：Python 的语法非常简单，很多事情可以用很少的代码实现。这使开发人员能够快速开发和迭代应用程序的原型。除此之外，这些原型并不总是需要被丢弃，如果开发得当，它们可以作为构建最终应用程序的良好基础。

通过快速原型化应用程序的能力，企业软件开发人员可以准确地看到需求如何在应用程序中对齐以及应用程序的性能如何。有了这些信息，应用程序的利益相关者可以更准确地定义应用程序开发的路径，从而避免因为某些事情没有按预期的方式进行而导致中期架构更改。

+   **成熟的生态系统**：成熟的生态系统是 Python 值得关注的特性之一。Python 的外部库数量正在迅速增长。对于大多数需要在应用程序中实现的任务，例如双因素身份验证、测试代码、运行生产 Web 服务器、与消息总线集成等，您可以轻松地寻找到一个具有相当不错支持的库。

这证明了它非常有帮助，因为它减少了代码重复量，并增加了组件的可重用性。借助诸如`pip`之类的工具，很容易将所需的库添加到项目中，并借助诸如`virtualenv`之类的工具，您可以轻松地在同一系统上对许多不同的项目进行分隔，而不会创建依赖混乱。

例如，如果有人想要构建一个简单的 Web 应用程序，他们可能只需使用 Flask，这是一个用于开发 Web 应用程序的微框架，并且可以继续开发 Web 应用程序，而无需担心处理套接字、操纵数据等底层复杂性。他们只需要几行代码就可以让一个简单的应用程序运行起来，如下面的代码所示：

```py
from flask import Flask
app = Flask(__name__)

@app.route('/', methods=["GET"])
def hello():
    return "Hello, this is a simple Flask application"

if name == '__main__':
    app.run(host='127.0.0.1', port=5000)
```

现在，一旦有人调用前面的脚本，他们将拥有一个`flask` HTTP 应用程序正在运行。这里剩下要做的就是启动浏览器并导航到`http://localhost:5000`。然后我们将看到 Flask 在不费吹灰之力地提供 Web 应用程序。所有这些都可以在不到 10 行代码的情况下实现。

有许多外部库为许多任务提供支持，企业开发人员可以轻松地在应用程序中启用对新功能的支持，而无需从头开始编写所有内容，从而减少可能出现的错误和非标准化接口进入应用程序的机会。

+   **社区支持**：Python 语言不归任何特定的公司实体所有，完全由庞大的社区支持，决定标准的未来。这确保了语言将继续得到长时间的支持，并且不会很快过时。这对组织来说非常重要，因为他们希望他们运行的应用程序能够得到长期的支持。

考虑到 Python 的所有优势，如果能够以经过精心规划的方式做出决策，那么使用该语言时开发人员的生产力将得到提升，同时还能够降低软件的总拥有成本。这些决策涉及应用程序架构的布局以及使用外部库或自行开发的决定。因此，是的，Python 现在确实已经准备好在企业应用程序开发的主流世界中使用。

# 介绍 BugZot - 一个 RESTful 错误跟踪器

随着我们在本书的章节中的进展，我们需要一种方法来实现我们所学到的知识。

想象一下，你在一家名为**Omega Corporation**的组织工作，这是一家向公司和个人销售软件产品的市场领导者。Omega Corporation 需要一个系统，通过该系统可以跟踪其产品中的错误。经过大量的头脑风暴，他们启动了一个名为 BugZot 的项目，这将是他们跟踪产品中错误的工具。

让我们看看 Omega Corporation 希望通过 BugZot 项目实现什么：

+   **用户能够报告产品中的错误**：用户，无论是内部还是外部用户，都应该能够针对特定产品报告错误...

# 在开发之前收集需求

在开始开发企业应用程序之前收集软件需求可能是一项繁琐的任务，如果未能充分做到这一点，可能会导致严重后果，例如由于在应用程序开发周期后期识别需求而导致的延迟增加的成本。缺乏重要功能以改进业务流程工作流的应用程序将导致用户在最坏的情况下停止使用应用程序。

需求收集过程复杂而繁琐，在组织中可能需要数月才能完成。本书的范围超出了涉及该过程的所有步骤。本节试图简要描述需求收集软件需求过程中的一些重要步骤。

# 询问用户需求

对于组织内部的应用程序，可能会有各种利益相关者和用户，可以定义应用程序的需求。这些用户可以大致分为两类：

+   **劳动力**：这些是通常使用应用程序来完成一定任务的用户。他们不关心应用程序提供的所有功能，而是关注应用程序如何适应他们的个人工作流程。这些用户可以提供特定于他们工作的需求，但可能无法提供关于他们将来可能需要什么或其他团队可能需要什么的想法。

+   **管理层**：管理层由人员组成...

# 需求分类

一旦用户被调查了他们希望在应用程序中拥有什么，下一步就是对这些需求进行分类。广义上说，需求可以分为两部分：

+   **功能需求**：这些是定义应用程序功能和功能的需求。例如，BugZot 具有以下功能需求：

+   为内部和外部用户提供提交错误的功能

+   提供角色和权限支持

+   提供处理文件上传的功能

+   与电子邮件系统集成，以便在错误更改状态时发送电子邮件，等等

+   **非功能需求**：这些是不影响软件功能的一组要求，而是基于功能需求的隐式或显式特征。例如，在 BugZot 中，以下可能被定义为一些非功能需求：

+   应用程序应提供针对常见 Web 攻击向量（如 XSS 和 CSRF）的安全性

+   应用程序的运营成本不应超过总预算的*N*%

+   应用程序应能够在崩溃后需要恢复时生成备份

# 优先考虑需求

一旦确定并将需求分类为功能和非功能需求，就需要根据其在应用程序中的重要性对其进行优先考虑。如果不进行这种优先考虑，将导致开发成本增加、截止日期延迟，并降低组织的生产力。广义上，我们可以将需求分类为以下类别：

+   **必须有**：这些是对应用程序成功至关重要的要求，在应用程序发货时必须存在。

+   **应该有**：这些是那些将增强应用程序功能的要求，但需要进一步讨论是否...

# 生成软件需求规格说明文档

一旦确定、分组和优先考虑了需求，就会生成一份名为软件需求规格说明的文档。该文档描述了需要开发的软件的预期目的、需求和性质。

**软件需求规格说明**（**SRS**）将描述以下信息：

+   应用程序的预期目的

+   文档中使用的约定是特定于组织业务流程的

+   应用程序的特性

+   将使用应用程序的用户类

+   应用程序将运行的环境

+   应用程序的功能和非功能需求

一旦 SRS 生成，就会进行审查和进一步的谈判。一旦成功完成，应用程序就会进入设计阶段，其中会设计应用程序的模拟。

# 摘要

在本章中，我们简要介绍了不断变化的编程环境，并探讨了多年来 Python 生态系统的变化。我们看到 Python 允许快速原型设计，并且拥有大量得到良好支持的库和一个开放的社区，因此迅速成为需要长期支持和与现有系统轻松集成的企业大型应用程序开发的主要选择。

然后，我们介绍了演示应用程序 BugZot，这是我们将在本书的过程中构建的，并定义了应用程序所需的功能。

本章的最后一节涵盖了...

# 问题

1.  在 Python 3 中是否可以对`str`类型和`byte`类型执行连接等操作？

1.  Python 3 中引入的类型提示支持是否是强制性的？

1.  除了功能和非功能需求之外，还有其他类型的需求可能需要记录到软件需求规格说明中吗？

1.  需求优先级可以在哪些主要类别中进行？

1.  一旦生成了软件需求规格说明文档，接下来应该采取哪些步骤？

# 进一步阅读

如果您想在进入企业应用程序开发世界之前再次学习 Python 编程的基础知识，Packt 有一本非常好的书可以供您参考。您可以在以下链接获取：

+   [`www.packtpub.com/application-development/learn-python-programming-second-edition`](https://www.packtpub.com/application-development/learn-python-programming-second-edition)
