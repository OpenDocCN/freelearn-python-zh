# 第三章：使用 Matplotlib 进行数学绘图

绘图是数学中的基本工具。一个好的图可以揭示隐藏的细节，建议未来的方向，验证结果或加强论点。因此，科学 Python 堆栈中拥有一个名为 Matplotlib 的强大而灵活的绘图库并不奇怪。

在本章中，我们将以各种样式绘制函数和数据，并创建完全标记和注释的图。我们将创建三维图，自定义图的外观，使用子图创建包含多个图的图，并直接将图保存到文件中，以供在非交互式环境中运行的应用程序使用。

在本章中，我们将涵盖以下示例：

+   使用 Matplotlib 进行基本绘图

+   更改绘图样式

+   为绘图添加标签和图例

+   添加子图

+   保存 Matplotlib 图

+   表面和等高线图

+   自定义三维图

# 技术要求

Python 的主要绘图包是 Matplotlib，可以使用您喜欢的软件包管理器（如`pip`）进行安装：

```py
          python3.8 -m pip install matplotlib

```

这将安装最新版本的 Matplotlib，在撰写本书时，最新版本是 3.2.1。

Matplotlib 包含许多子包，但主要用户界面是`matplotlib.pyplot`包，按照惯例，它被导入为`plt`别名。可以使用以下导入语句来实现这一点：

```py
import matplotlib.pyplot as plt
```

本章中的许多示例还需要 NumPy，通常情况下，它被导入为`np`别名。

本章的代码可以在 GitHub 存储库的`Chapter 02`文件夹中找到，网址为[`github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002`](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002)。

查看以下视频以查看代码实际操作：[`bit.ly/2ZOSuhs`](https://bit.ly/2ZOSuhs)。

# 使用 Matplotlib 进行基本绘图

绘图是理解行为的重要部分。通过简单地绘制函数或数据，可以学到很多原本隐藏的东西。在这个示例中，我们将介绍如何使用 Matplotlib 绘制简单的函数或数据。

Matplotlib 是一个非常强大的绘图库，这意味着用它执行简单任务可能会令人畏惧。对于习惯于使用 MATLAB 和其他数学软件包的用户，有一个称为`pyplot`的基于状态的接口。还有一个面向对象的接口，对于更复杂的绘图可能更合适。`pyplot`接口是创建基本对象的便捷方式。

## 准备工作

通常情况下，要绘制的数据将存储在两个单独的 NumPy 数组中，我们将为了清晰起见将它们标记为`x`和`y`（尽管在实践中这个命名并不重要）。我们将演示绘制函数的图形，因此我们将生成一组`x`值的数组，并使用函数生成相应的`y`值。我们定义将要绘制的函数如下：

```py
def f(x):
    return x*(x - 2)*np.exp(3 - x)
```

## 操作步骤

在我们绘制函数之前，我们必须生成要绘制的`x`和`y`数据。如果要绘制现有数据，可以跳过这些命令。我们需要创建一组覆盖所需范围的`x`值，然后使用函数创建`y`值：

1.  NumPy 中的`linspace`例程非常适合创建用于绘图的数字数组。默认情况下，它将在指定参数之间创建 50 个等间距点。可以通过提供额外的参数来自定义点的数量，但对于大多数情况来说，50 就足够了。

```py
x = np.linspace(-0.5, 3.0)  # 100 values between -0.5 and 3.0
```

1.  一旦我们创建了`x`值，就可以生成`y`值：

```py
y = f(x)  # evaluate f on the x points
```

1.  要绘制数据，我们只需要从`pyplot`接口调用`plot`函数，该接口被导入为`plt`别名。第一个参数是`x`数据，第二个是`y`数据。该函数返回一个用于绘制数据的轴对象的句柄：

*```py
plt.plot(x, y)
```

1.  这将在新的图形上绘制`y`值与`x`值。如果你在 IPython 中工作或者使用 Jupyter 笔记本，那么图形应该会自动出现；否则，你可能需要调用`plt.show`函数来使图形出现：

```py
plt.show()
```

如果使用`plt.show`，图形应该会出现在一个新窗口中。生成的图形应该看起来像*图 2.1*中的图形。你的默认绘图颜色可能与你的绘图不同。这是为了增加可见性而更改的默认绘图颜色：

![](img/c3c939df-e3cf-44f2-b35b-897b2b5ba75a.png)

图 2.1：使用 Matplotlib 绘制的函数的图形，没有任何额外的样式参数

我们不会在本章的其他配方中添加这个命令，但是你应该知道，如果你不是在自动渲染图形的环境中工作，比如在 IPython 控制台或 Jupyter Notebook 中，你将需要使用它。

## 工作原理...

如果当前没有`Figure`或`Axes`对象，`plt.plot`例程会创建一个新的`Figure`对象，向图形添加一个新的`Axes`对象，并用绘制的数据填充这个`Axes`对象。返回一个指向绘制线的句柄列表。每个句柄都是一个`Lines2D`对象。在这种情况下，这个列表将包含一个单独的`Lines2D`对象。我们可以使用这个`Lines2D`对象稍后自定义线的外观（参见*更改绘图样式*配方）。

Matplotlib 的对象层与较低级别的*后端*进行交互，后端负责生成图形绘图的繁重工作。`plt.show`函数发出指令给后端来渲染当前的图形。Matplotlib 可以使用多个后端，可以通过设置`MPLBACKEND`环境变量、修改`matplotlibrc`文件，或者在 Python 中调用`matplotlib.use`并指定替代后端的名称来自定义。

`plt.show`函数不仅仅是在图形上调用`show`方法。它还连接到一个事件循环，以正确显示图形。应该使用`plt.show`例程来显示图形，而不是在`Figure`对象上调用`show`方法。

## 还有更多...

有时候在调用`plot`例程之前手动实例化一个`Figure`对象是有用的，例如，强制创建一个新的图形。这个配方中的代码也可以写成如下形式：

```py
fig = plt.figure()  # manually create a figure
lines = plt.plot(x, y)  # plot data
```

`plt.plot`例程接受可变数量的位置输入。在前面的代码中，我们提供了两个位置参数，它们被解释为`x`值和`y`值（按顺序）。如果我们只提供了一个单一的数组，`plot`例程会根据数组中的位置绘制数值；也就是说，`x`值被视为`0`、`1`、`2`等等。我们还可以提供多对数组来在同一坐标轴上绘制多组数据：

```py
x = np.linspace(-0.5, 3.0)
lines = plt.plot(x, f(x), x, x**2, x, 1 - x)
```

前面代码的输出如下：

![](img/c6e0b680-a648-4082-bbf0-b7d40a1635c6.png)

图 2.2：在 Matplotlib 中使用一次调用 plot 例程产生单个图形上的多个图形

有时候需要创建一个新的图形，并在该图形中显式地创建一组新的坐标轴。实现这一目标的最佳方法是使用`pyplot`接口中的`subplots`例程（参见*添加子图*配方）。这个例程返回一对对象，第一个对象是`Figure`，第二个对象是`Axes`：

```py
fig, ax = plt.subplots()
l1 = ax.plot(x, f(x))
l2 = ax.plot(x, x**2)
l3 = ax.plot(x, 1 - x)
```

这一系列命令产生了与前面显示的*图 2.2*中相同的图形。

Matplotlib 除了这里描述的`plot`例程之外，还有许多其他绘图例程。例如，有一些绘图方法使用不同的比例尺来绘制坐标轴，包括分别使用对数*x*轴或对数*y*轴（`semilogx`或`semilogy`）或同时使用（`loglog`）。这些在 Matplotlib 文档中有解释。

# 更改绘图样式

Matplotlib 绘图的基本样式适用于绘制有序的函数或数据，但对于不按任何顺序呈现的离散数据来说，这种样式就不太合适了。为了防止 Matplotlib 在每个数据点之间绘制线条，我们可以将绘图样式更改为“关闭”线条绘制。在这个示例中，我们将通过向`plot`方法添加格式字符串参数来为坐标轴上的每条线自定义绘图样式。

## 准备工作

您需要将数据存储在数组对中。为了演示目的，我们将定义以下数据：

```py
y1 = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
y2 = np.array([1.2, 1.6, 3.1, 4.2, 4.8])
y3 = np.array([3.2, 1.1, 2.0, 4.9, 2.5])
```

我们将根据数组中的位置（即*x*坐标将分别为`0`、`1`、`2`、`3`或`4`）绘制这些点。

## 如何做到...

控制绘图样式的最简单方法是使用**格式字符串**，它作为`plot`命令中*x-y*对或`plot`命令中的`y`*data 后的可选参数提供。在绘制多组数据时，可以为每组参数提供不同的格式字符串。以下步骤提供了创建新图并在该图上绘制数据的一般过程：*

*1. 我们首先使用`pyplot`中的`subplots`例程显式创建`Figure`和`Axes`对象：

```py
fig, ax = plt.subplots()
```

1.  现在我们已经创建了`Figure`和`Axes`对象，可以使用`Axes`对象上的`plot`方法绘制数据。这个方法接受与`pyplot`中的`plot`例程相同的参数：

```py
lines = ax.plot(y1, 'o', y2, 'x', y3, '*')
```

这将使用圆圈标记绘制第一个数据集（`y1`），使用`x`标记绘制第二个数据集（`y2`），使用星号（`*`）标记绘制第三个数据集（`y3`）。这个命令的输出显示在*图 2.3*中。格式字符串可以指定多种不同的标记线和颜色样式。如果我们改为使用`pyplot`接口中的`plot`例程，其调用签名与`plot`方法相同，也是一样的。

![](img/a98c28e3-2c76-4e50-87ac-079979b9bd71.png)

图 2.3：绘制三组数据，每组数据使用不同的标记样式绘制

## 它是如何工作的...

格式字符串有三个可选部分，每个部分由一个或多个字符组成。第一部分控制标记样式，即打印在每个数据点处的符号；第二部分控制连接数据点的线条样式；第三部分控制绘图的颜色。在这个示例中，我们只指定了标记样式，这意味着在相邻数据点之间不会绘制连接线。这对于绘制不需要在点之间进行插值的离散数据非常有用。有四种线条样式参数可用：实线（`-`）；虚线（`--`）；点划线（`-.`）；或点线（`:`）。格式字符串中只能指定有限数量的颜色；它们是红色、绿色、蓝色、青色、黄色、品红色、黑色和白色。格式字符串中使用的字符是每种颜色的第一个字母（黑色除外），因此相应的字符分别是`r`、`g`、`b`、`c`、`y`、`m`、`k`和`w`。

例如，如果我们只想更改标记样式，就像在这个示例中所做的那样，改为加号字符，我们将使用`"+"`格式字符串。如果我们还想将线条样式更改为点划线，我们将使用`"+-."`格式字符串。最后，如果我们还希望将标记的颜色更改为红色，我们将使用`"+-.r"`格式字符串。这些指定符也可以以其他配置提供，例如在标记样式之前指定颜色，但这可能会导致 Matplotlib 解析格式字符串的方式存在歧义。

如果您正在使用 Jupyter 笔记本和`subplots`命令，则必须在与绘图命令相同的单元格中包含对`subplots`的调用，否则图形将不会被生成。

## 还有更多...

`plot`方法还接受许多关键字参数，这些参数也可以用于控制图的样式。如果同时存在关键字参数和格式字符串参数，则关键字参数优先，并且它们适用于调用绘制的所有数据集。控制标记样式的关键字是`marker`，线型的关键字是`linestyle`，颜色的关键字是`color`。`color`关键字参数接受许多不同的格式来指定颜色，其中包括 RGB 值作为`(r, g, b)`元组，其中每个字符都是`0`到`1`之间的浮点数，或者是十六进制字符串。可以使用`linewidth`关键字控制绘制的线的宽度，应该提供一个`float`值。`plot`还可以传递许多其他关键字参数；在 Matplotlib 文档中列出了一个列表。这些关键字参数中的许多都有较短的版本，例如`c`代表`color`，`lw`代表`linewidth`。

例如，我们可以使用以下命令通过在调用`plot`时使用`color`关键字参数来设置配方中所有标记的颜色：

```py
ax.plot(y1, 'o', y2, 'x', y3, '*', color="k")
```

从对`plot`方法（或`plt.plot`例程）的调用返回的`Line2D`对象也可以用于自定义每组数据的外观。例如，可以使用`Line2D`对象中的`set_linestyle`方法，使用适当的线型格式字符串设置线型。

可以使用`Axes`对象上的方法自定义图的其他方面。可以使用`Axes`对象上的`set_xticks`和`set_yticks`方法修改坐标轴刻度，可以使用`grid`方法配置网格外观。`pyplot`接口中还有方便的方法，可以将这些修改应用于当前坐标轴（如果存在）。

例如，我们修改轴限制，在*x*和*y*方向上的每个`0.5`的倍数设置刻度，并通过以下命令向图添加网格：

```py
ax.axis([-0.5, 5.5, 0, 5.5]) # set axes
ax.set_xticks([0.5*i for i in range(9)])  # set xticks
ax.set_yticks([0.5*i for i in range(11)] # set yticks
ax.grid()  # add a grid
```

注意我们将限制设置为略大于图的范围。这是为了避免标记放在图窗口的边界上。

如果希望在轴上绘制离散数据而不连接点与线，则`scatter`绘图例程可能更好。这允许更多地控制标记的样式。例如，可以根据一些额外信息调整标记的大小。

# 向绘图添加标签和图例

每个图应该有一个标题，并且轴应该被正确标记。对于显示多组数据的图，图例是帮助读者快速识别不同数据集的标记、线条和颜色的好方法。在本示例中，我们将向图添加轴标签和标题，然后添加一个图例来帮助区分不同的数据集。为了保持代码简单，我们将绘制上一个示例中的数据。

## 如何做...

按照以下步骤向您的图添加标签和图例，以帮助区分它们代表的数据集：

1.  我们首先使用以下`plot`命令从上一个示例中重新创建图：

```py
fig, ax = plt.subplots()
ax = ax.plot(y1, "o-", y2, "x--", y3, "*-.")
```

1.  现在，我们有了一个`Axes`对象的引用，我们可以开始通过添加标签和标题来自定义这些轴。可以使用`subplots`例程创建的`ax`对象上的`set_title`、`set_xlabel`和`set_ylabel`方法向图中添加标题和轴标签。在每种情况下，参数都是包含要显示的文本的字符串：

```py
ax.set_title("Plot of the data y1, y2, and y3")
ax.set_xlabel("x axis label")
ax.set_ylabel("y axis label")
```

在这里，我们使用不同的样式绘制了三个数据集。标记样式与上一个示例中相同，但我们为第一个数据集添加了实线，为第二个数据集添加了虚线，为第三个数据集添加了点划线。

1.  要添加图例，我们在`ax`对象上调用`legend`方法。参数应该是一个包含每组数据在图例中的描述的元组或列表：

```py
ax.legend(("data y1", "data y2", "data y3"))
```

上述一系列命令的结果如下：

![](img/0ab005b7-27f6-4a24-8ec9-acdb04abd3d8.png)

图 2.4：使用 Matplotlib 生成的带有轴标签、标题和图例的图

## 工作原理...

`set_title`、`set_xlabel`和`set_ylabel`方法只是将文本参数添加到`Axes`对象的相应位置。如前面的代码中调用的`legend`方法，按照它们添加到图中的顺序添加标签，本例中为`y1`、`y2`，然后是`y3`。

可以提供一些关键字参数给`set_title`、`set_xlabel`和`set_ylabel`方法来控制文本的样式。例如，`fontsize`关键字可以用来指定标签字体的大小，通常使用`pt`点度量。还可以通过向例程提供`usetex=True`来使用 TeX 格式化标签。标签的 TeX 格式化在*图 2.5*中演示。如果标题或轴标签包含数学公式，这是非常有用的。不幸的是，如果系统上没有安装 TeX，就不能使用`usetex`关键字参数，否则会导致错误。但是，仍然可以使用 TeX 语法来格式化标签中的数学文本，但这将由 Matplotlib 而不是 TeX 来排版。

我们可以使用`fontfamily`关键字来使用不同的字体，其值可以是字体的名称或`serif`、`sans-serif`或`monospace`，它将选择适当的内置字体。可以在 Matplotlib 文档中找到`matplotlib.text.Text`类的完整修饰符列表。

要向图添加单独的文本注释，可以在`Axes`对象上使用`annotate`方法。这个例程接受两个参数——要显示的文本作为字符串和注释应放置的点的坐标。这个例程还接受前面提到的样式关键字参数。

# 添加子图

有时，将多个相关的图放在同一图中并排显示，但不在同一坐标轴上是很有用的。子图允许我们在单个图中生成一个网格的单独图。在这个示例中，我们将看到如何使用子图在单个图上并排创建两个图。

## 准备工作

您需要将要绘制在每个子图上的数据。例如，我们将在第一个子图上绘制应用于*f*(*x*) = *x²-1*函数的牛顿法的前五个迭代，初始值为*x[0] = 2*，对于第二个子图，我们将绘制迭代的误差。我们首先定义一个生成器函数来获取迭代：

*```py
def generate_newton_iters(x0, number):
    iterates = [x0]
    errors = [abs(x0 - 1.)]
    for _ in range(number):
        x0 = x0 - (x0*x0 - 1.)/(2*x0)
        iterates.append(x0)
        errors.append(abs(x0 - 1.))
    return iterates, errors
```

这个例程生成两个列表。第一个列表包含应用于函数的牛顿法的迭代，第二个包含近似值的误差：

```py
iterates, errors = generate_newton_iters(2.0, 5)
```

## 如何做...

以下步骤显示了如何创建包含多个子图的图：

1.  我们使用`subplots`例程创建一个新的图和每个子图中的所有`Axes`对象的引用，这些子图在一个行和两个列的网格中排列。我们还将`tight_layout`关键字参数设置为`True`，以修复生成图的布局。这并不是严格必要的，但在这种情况下是必要的，因为它产生的结果比默认的更好：

```py
fig, (ax1, ax2) = plt.subplots(1, 2, tight_layout=True) # 1 row, 2 columns
```

1.  一旦创建了`Figure`和`Axes`对象，我们可以通过在每个`Axes`对象上调用相关的绘图方法来填充图。对于第一个图（显示在左侧），我们在`ax1`对象上使用`plot`方法，它与标准的`plt.plot`例程具有相同的签名。然后我们可以在`ax1`上调用`set_title`、`set_xlabel`和`set_ylabel`方法来设置标题和`x`和`y`标签。我们还通过提供`usetex`关键字参数来使用 TeX 格式化轴标签；如果您的系统上没有安装 TeX，可以忽略这一点：

*```py
ax1.plot(iterates, "x")
ax1.set_title("Iterates")
ax1.set_xlabel("$i$", usetex=True)
ax1.set_ylabel("$x_i$", usetex=True)
```

1.  现在，我们可以使用`ax2`对象在第二个图上（显示在右侧）绘制错误值。我们使用了一种使用对数刻度的替代绘图方法，称为`semilogy`。该方法的签名与标准的`plot`方法相同。同样，我们设置了轴标签和标题。如果没有安装 TeX，可以不使用`usetex`。

```py
ax2.semilogy(errors, "x") # plot y on logarithmic scale
ax2.set_title("Error")
ax2.set_xlabel("$i$", usetex=True)
ax2.set_ylabel("Error")
```

这些命令序列的结果如下图所示：

![](img/f335dbe8-fa72-4b78-8a52-20f3159250f8.png)

图 2.5：Matplotlib 子图

左侧绘制了牛顿法的前五次迭代，右侧是以对数刻度绘制的近似误差。

## 工作原理...

Matplotlib 中的`Figure`对象只是一个特定大小的绘图元素（如`Axes`）的容器。`Figure`对象通常只包含一个`Axes`对象，该对象占据整个图形区域，但它可以在相同的区域中包含任意数量的`Axes`对象。`subplots`例程执行几项任务。首先创建一个新的图形，然后在图形区域内创建一个指定形状的网格。然后，在网格的每个位置添加一个新的`Axes`对象。然后将新的`Figure`对象和一个或多个`Axes`对象返回给用户。如果请求单个子图（一行一列，没有参数），则返回一个普通的`Axes`对象。如果请求单行或单列（分别具有多于一个列或行），则返回`Axes`对象的列表。如果请求多行和多列，则将返回一个列表的列表，其中行由填充有`Axes`对象的内部列表表示。然后我们可以使用每个`Axes`对象上的绘图方法来填充图形以显示所需的绘图。

在本示例中，我们在左侧使用了标准的`plot`方法，就像我们在以前的示例中看到的那样。但是，在右侧绘图中，我们使用了一个将*y*轴更改为对数刻度的绘图。这意味着*y*轴上的每个单位代表 10 的幂的变化，而不是一个单位的变化，因此`0`代表 10⁰=1，`1`代表 10，`2`代表 100，依此类推。轴标签会自动更改以反映这种比例变化。当值按数量级变化时，例如近似误差随着迭代次数的增加而变化时，这种缩放是有用的。我们还可以使用`semilogx`方法仅对*x*使用对数刻度进行绘制，或者使用`loglog`方法对两个轴都使用对数刻度进行绘制。

## 还有更多...

在 Matplotlib 中有几种创建子图的方法。如果已经创建了一个`Figure`对象，则可以使用`Figure`对象的`add_subplot`方法添加子图。或者，您可以使用`matplotlib.pyplot`中的`subplot`例程将子图添加到当前图。如果尚不存在，则在调用此例程时将创建一个新的图。`subplot`例程是`Figure`对象上`add_subplot`方法的便利包装。

要创建一个具有一个或多个子图的新图形，还可以使用`pyplot`接口中的`subplots`例程（如*更改绘图样式*中所示），它返回一个新的图形对象和一个`Axes`对象的数组，每个位置一个。这三种方法都需要子图矩阵的行数和列数。`add_subplot`方法和`subplot`例程还需要第三个参数，即要修改的子图的索引。返回当前子图的`Axes`对象。

在前面的例子中，我们创建了两个具有不同比例的*y*轴的图。这展示了子图的许多可能用途之一。另一个常见用途是在矩阵中绘制数据，其中列具有共同的`x`标签，行具有共同的`y`标签，这在多元统计中特别常见，用于研究各组数据之间的相关性。用于创建子图的`plt.subplots`例程接受`sharex`和`sharey`关键字参数，允许轴在所有子图或行或列之间共享。此设置会影响轴的比例和刻度。

## 另请参阅

Matplotlib 通过为`subplots`例程提供`gridspec_kw`关键字参数来支持更高级的布局。有关更多信息，请参阅`matplotlib.gridspec`的文档。

# 保存 Matplotlib 图

当您在交互式环境中工作，例如 IPython 控制台或 Jupyter 笔记本时，运行时显示图是完全正常的。但是，有很多情况下，直接将图存储到文件中而不是在屏幕上呈现会更合适。在本示例中，我们将看到如何将图直接保存到文件中，而不是在屏幕上显示。

## 准备工作

您需要要绘制的数据以及要存储输出的路径或文件对象。我们将结果存储在当前目录中的`savingfigs.png`中。在此示例中，我们将绘制以下数据：

```py
x = np.arange(1, 5, 0.1)
y = x*x
```

## 如何做...

以下步骤显示了如何将 Matplotlib 图直接保存到文件：

1.  第一步是像往常一样创建图，并添加任何必要的标签、标题和注释。图将以其当前状态写入文件，因此应在保存之前进行对图的任何更改：

```py
fig, ax = plt.subplots()
ax.plot(x, y)
ax.set_title("Graph of $y = x²$", usetex=True)
ax.set_xlabel("$x$", usetex=True)
ax.set_ylabel("$y$", usetex=True)
```

1.  然后，我们使用`fig`上的`savefig`方法将此图保存到文件。唯一必需的参数是要输出的路径或可以写入图形的文件对象。我们可以通过提供适当的关键字参数来调整输出格式的各种设置，例如分辨率。我们将输出图的**每英寸点数**（**DPI**）设置为`300`，这对于大多数应用程序来说是合理的分辨率：

```py
fig.savefig("savingfigs.png", dpi=300)
```

Matplotlib 将根据给定文件的扩展名推断我们希望以**便携式网络图形**（**PNG**）格式保存图像。或者，可以通过提供关键字参数（使用`format`关键字）显式地提供格式，或者可以从配置文件中回退到默认格式。

## 它是如何工作的...

`savefig`方法选择适合输出格式的后端，然后以该格式呈现当前图。生成的图像数据将写入指定的路径或文件对象。如果您手动创建了`Figure`实例，则可以通过在该实例上调用`savefig`方法来实现相同的效果。

## 还有更多...

`savefig`例程接受许多额外的可选关键字参数来自定义输出图像。例如，可以使用`dpi`关键字指定图像的分辨率。本章中的图是通过将 Matplotlib 图保存到文件中生成的。

可用的输出格式包括 PNG、**可缩放矢量图形**（**SVG**）、**PostScript**（**PS**）、**Encapsulated PostScript**（**EPS**）和**便携式文档格式**（**PDF**）。如果安装了 Pillow 软件包，还可以保存为 JPEG 格式，但自 Matplotlib 3.1 版本以来就不再原生支持此功能。JPEG 图像还有其他自定义关键字参数，如`quality`和`optimize`。可以将图像元数据的字典传递给`metadata`关键字，在保存时将其写入图像元数据。

## 另请参阅

Matplotlib 网站上的示例库包括使用几种常见的 Python GUI 框架将 Matplotlib 图嵌入到**图形用户界面**（**GUI**）应用程序中的示例。

# 曲面和等高线图

Matplotlib 还可以以各种方式绘制三维数据。显示这种数据的两种常见选择是使用**表面图**或**等高线图**（类似于地图上的等高线）。在本示例中，我们将看到一种从三维数据绘制表面和绘制三维数据等高线的方法。

## 准备就绪

要绘制三维数据，需要将其排列成*x*、*y*和*z*分量的二维数组，其中*x*和*y*分量必须与*z*分量的形状相同。为了演示，我们将绘制对应于*f*(*x*, *y*) = *x*²*y*³函数的表面。

## 如何做...

我们想要在-2≤*x*≤2 和-1≤*y*≤1 范围内绘制*f*(*x*, *y*) = *x*²*y*³函数。第一项任务是创建一个适当的(*x*, *y*)对的网格，以便对该函数进行评估：

1.  首先使用`np.linspace`在这些范围内生成合理数量的点：

```py
X = np.linspace(-2, 2)
Y = np.linspace(-1, 1)
```

1.  现在，我们需要创建一个网格来创建我们的*z*值。为此，我们使用`np.meshgrid`例程：

```py
x, y = np.meshgrid(X, Y)
```

1.  现在，我们可以创建要绘制的*z*值，这些值保存了每个网格点上函数的值：

```py
z = x**2 * y**3
```

1.  要绘制三维表面，我们需要加载一个 Matplotlib 工具箱`mplot3d`，它随 Matplotlib 包一起提供。这不会在代码中明确使用，但在幕后，它使三维绘图实用程序可用于 Matplotlib：

```py
from mpl_toolkits import mplot3d
```

1.  接下来，我们创建一个新的图和一组三维坐标轴用于该图：

```py
fig = plt.figure()
ax = fig.add_subplot(projection="3d")  # declare 3d plot
```

1.  现在，我们可以在这些坐标轴上调用`plot_surface`方法来绘制数据：

```py
ax.plot_surface(x, y, z)
```

1.  为三维图添加轴标签非常重要，因为在显示的图上可能不清楚哪个轴是哪个：

```py
ax.set_xlabel("$x$")
ax.set_ylabel("$y$")
ax.set_zlabel("$z$")
```

1.  此时我们还应该设置一个标题：

```py
ax.set_title("Graph of the function $f(x) = x²y³$)
```

您可以使用`plt.show`例程在新窗口中显示图（如果您在 Python 中交互使用，而不是在 Jupyter 笔记本或 IPython 控制台上使用），或者使用`plt.savefig`将图保存到文件中。上述序列的结果如下所示：

![](img/b844fb9d-e453-46f2-a233-9ec2e4eeb71e.png)

图 2.6：使用默认设置使用 Matplotlib 生成的三维表面图

1.  等高线图不需要`mplot3d`工具包，在`pyplot`接口中有一个`contour`例程可以生成等高线图。但是，与通常的（二维）绘图例程不同，`contour`例程需要与`plot_surface`方法相同的参数。我们使用以下顺序生成绘图：

```py
fig = plt.figure()  # Force a new figure
plt.contour(x, y, z)
plt.title("Contours of $f(x) = x²y³$")
plt.xlabel("$x$")
plt.ylabel("$y$")
```

结果显示在以下图中：

![](img/18cd3684-5b44-4b67-9ce2-d48ecd675303.png)

图 2.7：使用默认设置使用 Matplotlib 生成的等高线图

## 它是如何工作的...

`mplot3d`工具包提供了一个`Axes3D`对象，这是核心 Matplotlib 包中`Axes`对象的三维版本。当给定`projection="3d"`关键字参数时，这将被提供给`Figure`对象上的`axes`方法。通过在三维投影中在相邻点之间绘制四边形，可以获得表面图。这与用直线连接相邻点来近似二维曲线的方式相同。

`plot_surface`方法需要提供*z*值，这些值作为二维数组编码在(*x*, *y*)对的网格上的*z*值。我们创建了我们感兴趣的*x*和*y*值的范围，但是如果我们简单地在这些数组的对应值上评估我们的函数，我们将得到一条线上的*z*值，而不是整个网格上的值。相反，我们使用`meshgrid`例程，它接受两个`X`和`Y`数组，并从中创建一个网格，其中包含`X`和`Y`中所有可能的值的组合。输出是一对二维数组，我们可以在其上评估我们的函数。然后我们可以将这三个二维数组全部提供给`plot_surface`方法。

## 还有更多...

在前面的部分中描述的例程`contour`和`plot_contour`只适用于高度结构化的数据，其中*x*、*y*和*z*分量被排列成网格。不幸的是，现实生活中的数据很少有这么结构化的。在这种情况下，您需要在已知点之间执行某种插值，以近似均匀网格上的值，然后可以绘制出来。执行这种插值的常见方法是通过对(*x*, *y*)对的集合进行三角剖分，然后使用每个三角形顶点上的函数值来估计网格点上的值。幸运的是，Matplotlib 有一个方法可以执行所有这些步骤，然后绘制结果，这就是`plot_trisurf`例程。我们在这里简要解释一下如何使用它：

1.  为了说明`plot_trisurf`的用法，我们将从以下数据绘制表面和等高线：

```py
x = np.array([ 0.19, -0.82, 0.8 , 0.95, 0.46, 0.71, 
     -0.86, -0.55,   0.75,-0.98, 0.55, -0.17, -0.89,
         -0.4 , 0.48, -0.09, 1., -0.03, -0.87, -0.43])
y = np.array([-0.25, -0.71, -0.88, 0.55, -0.88, 0.23, 
      0.18,-0.06, 0.95, 0.04, -0.59, -0.21, 0.14, 0.94, 
          0.51, 0.47, 0.79, 0.33, -0.85, 0.19])
z = np.array([-0.04, 0.44, -0.53, 0.4, -0.31, 0.13, 
      -0.12, 0.03, 0.53, -0.03, -0.25, 0.03, -0.1 , 
          -0.29, 0.19, -0.03, 0.58, -0.01, 0.55, -0.06])
```

1.  这次，我们将在同一图中绘制表面和等高线（近似），作为两个单独的子图。为此，我们向包含表面的子图提供`projection="3d"`关键字参数。我们在三维坐标轴上使用`plot_trisurf`方法绘制近似表面，并在二维坐标轴上使用`tricontour`方法绘制近似等高线：

```py
fig = plt.figure(tight_layout=True)  # force new figure
ax1 = fig.add_subplot(1, 2, 1, projection="3d")  # 3d axes
ax1.plot_trisurf(x, y, z)
ax1.set_xlabel("$x$")
ax1.set_ylabel("$y$")
ax1.set_zlabel("$z$")
ax1.set_title("Approximate surface")
```

1.  现在，我们可以使用以下命令绘制三角剖分表面的等高线：

```py
ax2 = fig.add_subplot(1, 2, 2)  # 2d axes
ax2.tricontour(x, y, z)
ax2.set_xlabel("$x$")
ax2.set_ylabel("$y$")
ax2.set_title("Approximate contours")
```

我们在图中包含`tight_layout=True`关键字参数，以避免稍后调用`plt.tight_layout`例程。结果如下所示：

![](img/c347d304-3e13-4341-a1e8-20ce0854d5a8.png)

图 2.8：使用三角剖分生成的近似表面和等高线图

除了表面绘图例程外，`Axes3D`对象还有一个用于简单三维绘图的`plot`（或`plot3D`）例程，其工作方式与通常的`plot`例程完全相同，但在三维坐标轴上。该方法还可用于在其中一个轴上绘制二维数据。

# 自定义三维图

等高线图可能会隐藏表示的表面的一些细节，因为它们只显示“高度”相似的地方，而不显示值是多少，甚至与周围的值相比如何。在地图上，这可以通过在特定等高线上打印高度来解决。表面图更具启发性，但是将三维对象投影到二维以在屏幕上显示可能会模糊一些细节。为了解决这些问题，我们可以自定义三维图（或等高线图）的外观，以增强图表并确保我们希望突出显示的细节清晰可见。最简单的方法是通过更改图表的颜色映射来实现这一点。

在这个示例中，我们将使用`binary`颜色映射的反转。

## 准备工作

我们将为以下函数生成表面图：

![](img/de81842d-a1b9-4ec4-b7a8-5e3fe30bb458.png)

我们生成应该绘制的点，就像在前一个示例中一样：

```py
X = np.linspace(-2, 2)
Y = np.linspace(-2, 2)
x, y = np.meshgrid(X, Y)
t = x**2 + y**2  # small efficiency
z = np.cos(2*np.pi*t)*np.exp(-t)
```

## 如何做...

Matplotlib 有许多内置的颜色映射，可以应用于图表。默认情况下，表面图是用根据光源进行着色的单一颜色绘制的（请参阅本示例的*更多信息*部分）。颜色映射可以显著改善图表的效果。以下步骤显示了如何向表面和等高线图添加颜色映射：

1.  首先，我们只需应用内置的颜色映射之一`binary_r`，通过向`plot_surface`例程提供`cmap="binary_r"`关键字参数来实现：

```py
fig = plt.figure()
ax = fig.add_subplot(projection="3d")
ax.plot_surface(x, y, z, cmap="binary_r")
ax.set_title("Surface with colormap")
ax.set_xlabel("$x$")
ax.set_ylabel("$y$")
ax.set_zlabel("$z$")
```

结果是一个图（*图* 2.9），其中表面的颜色根据其值而变化，颜色映射的两端具有最极端的值——在本例中，*z*值越大，灰度越浅。请注意，下图中的不规则性是由网格中相对较少的点造成的：

![](img/cf0e7c34-b176-49b8-b54f-0a4150f9b746.png)

图 2.9：应用灰度颜色映射的表面图

颜色映射适用于表面绘图以外的其他绘图类型。特别是，颜色映射可以应用于等高线图，这有助于区分代表较高值和代表较低值的等高线。

1.  对于等高线图，更改颜色映射的方法是相同的；我们只需为`cmap`关键字参数指定一个值：

```py
fig = plt.figure()
plt.contour(x, y, z, cmap="binary_r")
plt.xlabel("$x$")
plt.ylabel("$y$")
plt.title("Contour plot with colormap set")
```

上述代码的结果如下所示：

![](img/34011236-d782-49c1-910d-b4283dbe9951.png)图 2.10：具有替代颜色映射设置的等高线图

图中较深的灰色阴影对应于 z 的较低值。

## 工作原理...

颜色映射通过根据比例尺分配 RGB 值来工作——**颜色映射**。首先，对值进行归一化，使其介于`0`和`1`之间，通常通过线性变换来实现，将最小值取为`0`，最大值取为`1`。然后将适当的颜色应用于表面绘图的每个面（或者在另一种类型的绘图中是线）。

Matplotlib 带有许多内置的颜色映射，可以通过简单地将名称传递给`cmap`关键字参数来应用。这些颜色映射的列表在文档中给出（[`matplotlib.org/tutorials/colors/colormaps.html`](https://matplotlib.org/tutorials/colors/colormaps.html)），还有一个反转的变体，通过在所选颜色映射的名称后添加`_r`后缀来获得。

## 还有更多...

应用颜色映射中的归一化步骤是由`Normalize`类派生的对象执行的。Matplotlib 提供了许多标准的归一化例程，包括`LogNorm`和`PowerNorm`。当然，您也可以创建自己的`Normalize`子类来执行归一化。可以使用`plot_surface`或其他绘图函数的`norm`关键字添加替代`Normalize`子类。

对于更高级的用途，Matplotlib 提供了一个接口，用于使用光源创建自定义阴影。这是通过从`matplotlib.colors`包中导入`LightSource`类，然后使用该类的实例根据*z*值对表面元素进行着色来完成的。这是使用`LightSource`对象的`shade`方法完成的：

```py
from matplotlib.colors import LightSource
light_source = LightSource(0, 45)  # angles of lightsource
cmap = plt.get_cmap("binary_r")
vals = light_source.shade(z, cmap)
surf = ax.plot_surface(x, y, z, facecolors=vals)
```

如果您希望了解更多关于这个工作原理的内容，可以在 Matplotlib 库中查看完整的示例。

# 进一步阅读

Matplotlib 包非常庞大，我们在这么短的篇幅内几乎无法充分展现它。文档中包含的细节远远超过了这里提供的内容。此外，还有一个大型的示例库（[`matplotlib.org/gallery/index.html#`](https://matplotlib.org/gallery/index.html#)），其中包含了比本书中更多的包功能。

还有其他构建在 Matplotlib 之上的包，为特定应用程序提供了高级绘图方法。例如，Seaborn 库提供了用于可视化数据的例程（[`seaborn.pydata.org/`](https://seaborn.pydata.org/)）。
