# 前言

编程语言有时可以很好地适应整洁的范畴，比如命令式和函数式。命令式语言可能进一步分为过程式和包含面向对象编程特性的语言。然而，Python 语言包含了所有这三种语言范畴的特点。虽然 Python 不是纯粹的函数式编程语言，但我们可以在 Python 中进行大量的函数式编程。

最重要的是，我们可以利用许多来自其他函数式语言的设计模式和技术，并将它们应用于 Python 编程。这些借鉴的概念可以帮助我们创建简洁而优雅的程序。特别是 Python 的生成器表达式，避免了创建大型内存数据结构的需要，从而导致程序可能更快地执行，因为它们使用更少的资源。

我们无法在 Python 中轻松创建纯函数式程序。Python 缺少许多必要的功能。例如，我们没有无限递归，所有表达式的惰性求值和优化编译器。

一般来说，Python 强调严格的求值规则。这意味着语句按顺序执行，表达式从左到右求值。虽然这偏离了函数式纯度，但它允许我们在编写 Python 时执行手动优化。我们将采用混合方法来使用 Python 的函数式特性，当它们可以增加清晰度或简化代码时使用，以及使用普通的命令式特性进行优化。

函数式编程语言中有几个关键特性在 Python 中也可以使用。其中最重要的一个是函数作为一等对象的概念。在一些语言中，函数只存在于源代码结构中：它们在运行时并不作为合适的数据结构存在。在 Python 中，函数可以将函数作为参数使用，并将函数作为结果返回。

Python 提供了许多高阶函数。像`map()`、`filter()`和`functools.reduce()`这样的函数在这方面被广泛使用。像`sorted()`、`min()`和`max()`这样不太明显的函数也是高阶函数；它们有一个默认函数，因此与更常见的例子有不同的语法。

函数式程序经常利用不可变数据结构。对无状态对象的强调允许灵活的优化。Python 提供了元组和命名元组作为复杂但不可变的对象。我们可以利用这些结构来借鉴其他函数式编程语言的一些设计实践。

许多函数式语言强调递归，但利用尾调用优化（TCO）。Python 倾向于将递归限制在相对较小的堆栈帧中。在许多情况下，我们可以将递归视为生成器函数。然后我们可以简单地重写它以使用`yield from`语句，自己进行尾调用优化。

我们将从 Python 的角度来看函数式编程的核心特性。我们的目标是借鉴函数式编程语言的好思想，并将这些思想用于在 Python 中创建富有表现力和简洁的应用程序。

# 本书涵盖的内容

第一章 *介绍函数式编程*，介绍了一些特征函数式编程的技术。我们将确定一些将这些特性映射到 Python 的方法，最后，我们还将讨论一些使用这些设计模式构建 Python 应用程序时函数式编程的好处。

第二章，“引入一些函数式特性”，将深入探讨函数式编程范式的六个核心特性。我们将详细研究每个特性在 Python 中的实现。我们还将指出一些不适用于 Python 的函数式语言特性。特别是，许多函数式语言具有复杂的类型匹配规则，需要支持编译和优化。

第三章，“函数，迭代器和生成器”，将展示如何利用不可变的 Python 对象和生成器表达式，并将函数式编程概念应用到 Python 语言中。我们将研究一些内置的 Python 集合以及如何在不远离函数式编程概念的情况下利用它们。

第四章，“使用集合”，展示了如何使用许多内置的 Python 函数来操作数据集合。本节将重点介绍一些相对简单的函数，如`any()`和`all()`，它们将一组值减少为单个结果。

第五章，“高阶函数”，探讨了常用的高阶函数，如`map()`和`filter()`。本章还包括许多其他高阶函数，以及如何创建我们自己的高阶函数。

第六章，“递归和归约”，展示了如何使用递归设计算法，然后将其优化为高性能的`for`循环。我们还将研究一些其他广泛使用的归约，包括`collections.Counter()`函数。

第七章，“附加元组技术”，展示了我们可以使用不可变元组和命名元组而不是有状态对象的许多方法。不可变对象有一个更简单的接口：我们永远不必担心滥用属性并将对象设置为一些不一致或无效的状态。

第八章，“Itertools 模块”，研究了标准库模块中的一些函数。这些函数集简化了处理集合或生成器函数的程序编写。

第九章，“更多 Itertools 技术”，涵盖了 itertools 模块中的组合函数。这些函数的用处相对较少。本章包括一些例子，说明了对这些函数的不慎使用以及组合爆炸的后果。

第十章，“Functools 模块”，将展示如何使用该模块中的一些函数进行函数式编程。该模块中的一些函数更适合构建装饰器，并留待下一章。然而，其他函数提供了设计和实现函数程序的几种更多方式。

第十一章，“装饰器设计技巧”，展示了如何将装饰器视为构建复合函数的一种方式。虽然这里有相当大的灵活性，但也有一些概念上的限制：我们将探讨过于复杂的装饰器可能变得令人困惑而不是有帮助的方式。

第十二章，“多进程和线程模块”，指出了良好的函数式设计的一个重要结果：我们可以分配处理工作负载。使用不可变对象意味着我们不能因为同步不良的写操作而破坏对象。

第十三章，“条件表达式和操作员模块”，将展示一些我们可以打破 Python 严格的求值顺序的方法。在这里我们所能实现的有限制。我们还将看看操作员模块以及操作员模块如何对一些简单的处理进行轻微澄清。

第十四章，“PyMonad 库”，审查了 PyMonad 库的一些特性。这提供了一些额外的函数式编程特性。这也提供了学习更多关于单子的方法。在一些函数式语言中，单子是强制执行特定顺序的重要方式，以防止被优化为不希望的顺序。由于 Python 已经对表达式和语句有严格的顺序，单子特性更多是具有教学意义而非实际意义。

第十五章，“Web 服务的功能方法”，展示了我们如何将 Web 服务视为一个嵌套的函数集合，将请求转换为回复。我们将看到如何利用函数式编程概念来构建响应迅速、动态的网络内容。

第十六章，“优化和改进”，包括一些有关性能和优化的额外提示。我们将强调诸如记忆化之类的技术，因为它们易于实现，并且在正确的情况下可以产生显著的性能改进。

# 您需要为这本书做些什么

这本书假设您对 Python 3 和应用程序开发的一般概念有一定了解。我们不会深入研究 Python 的微妙或复杂特性；我们将避免对语言内部的考虑。

我们将假设您对函数式编程有一定了解。由于 Python 不是一种函数式编程语言，我们无法深入探讨函数式概念。我们将挑选适合 Python 的函数式编程方面，并仅利用那些看似有用的方面。

一些示例使用探索性数据分析（EDA）作为问题领域，以展示函数式编程的价值。对基本概率和统计学的一些了解将有助于理解。只有少数示例会涉及更严肃的数据科学。

您需要安装并运行 Python 3.3 或 3.4。有关 Python 的更多信息，请访问[`www.python.org/`](http://www.python.org/)。

在第十四章，“PyMonad 库”，我们将看看如何安装这个额外的库。如果您有 Python 3.4，其中包括 pip 和 Easy Install，这将非常容易。如果您有 Python 3.3，您可能已经安装了 pip 或 Easy Install，或者两者都有。一旦您有了安装程序，您就可以添加 PyMonad。访问[`pypi.python.org/pypi/PyMonad/`](https://pypi.python.org/pypi/PyMonad/)了解更多详情。

# 这本书是为谁准备的

这本书适用于希望通过借鉴函数式编程语言的技术和设计模式来创建简洁、表达力强的 Python 程序的程序员。一些算法可以用函数式风格优雅地表达；我们可以—而且应该—调整这一点，使 Python 程序更易读和易维护。

在某些情况下，对问题的功能方法也会导致极高性能的算法。Python 使得创建大型中间数据结构变得太容易，占用内存和处理器时间。通过函数式编程设计模式，我们经常可以用生成器表达式替换大型列表，这些表达式同样具有表现力，但占用的内存更少，运行速度更快。

# 约定

在这本书中，您将找到一些区分不同信息类型的文本样式。以下是一些这些样式的示例，以及它们的含义解释。

文本中的代码单词显示如下：“我们可以创建一个`Pool`对象，将任务分配给并发工作进程，并期望任务并发执行。”

代码块设置如下：

```py
GIMP Palette
Name: Crayola
Columns: 16
#
```

任何命令行输入或输出都是这样写的：

```py
def max(a, b):
 **f = {a >= b: lambda: a, b >= a: lambda: b}[True]
 **return f()

```

### 注意

警告或重要说明会出现在这样的框中。

### 提示

提示和技巧会出现在这样。
