

# 第十一章：调试和性能分析

> “如果调试是移除软件错误的过程，那么编程就必须是引入错误的过程。”
> 
> ——埃德加·W·迪杰斯特拉

在专业程序员的生涯中，调试和故障排除占据了大量的时间。除了最简单的软件，所有软件都几乎肯定会存在错误。人类并不完美；我们会犯错误。因此，我们编写的代码也不完美。作为开发者，我们花费大量时间阅读其他开发者编写的代码。在我们看来，一个好的软件开发者是在阅读代码时也会留心潜在错误的开发者，即使这些代码并未报告为错误或有缺陷。

能够高效快速地调试代码是每个程序员需要不断改进的技能。就像测试一样，调试是一项最好通过经验来学习的技能。你可以遵循一些指南，但没有一本书能教你成为调试高手所需知道的一切。

我们觉得在这个问题上，我们从同事那里学到了最多的东西。我们惊讶地观察到有人非常擅长解决问题。我们喜欢看到他们采取的步骤，他们验证以排除潜在原因的事情，以及他们如何选择最终引导他们找到解决方案的路径。

我们与之共事的每一位同事都能教会我们一些东西，或者用他们出色的猜测来让我们感到惊讶，而这些猜测最终被证明是正确的。当这种情况发生时，不要只是停留在惊奇（或者更糟，嫉妒）之中，而要抓住这个机会，询问他们是如何得出这个猜测的，为什么会有这样的想法。这个答案将帮助你判断是否有什么东西你可以深入研究，以便下次你能找到错误。

有些错误很容易被发现。它们来自错误，一旦你看到这些错误的效果，就很容易找到解决问题的方法。但还有一些错误更为微妙，需要真正的专业知识以及大量的创造性和跳出思维来处理。最糟糕的错误是非确定性的错误。这些错误有时会发生，有时不会。有些错误只会在特定的环境中发生，而在看似相同的环境中则不会发生。

在专业环境中，我们经常需要在高度紧张的情况下调试代码。如果一个网站宕机，或者客户感到不满，业务就会损失金钱。因此，通常会对开发者施加很大的压力，要求他们立即找到并修复问题。在这种情况下，能够保持冷静至关重要。如果你想要有效地与错误作斗争，这是最重要的技能。压力会负面影响我们寻找和修复错误所需的创造性思维和解决问题的能力。所以，深呼吸，坐好，集中注意力。

在本章中，我们将尝试展示一些有用的技术，您可以根据错误的严重程度来使用这些技术，以及一些希望有助于增强您对抗错误和问题的武器的建议。

具体来说，我们将关注以下内容：

+   调试技术

+   故障排除指南

+   性能分析

# 调试技术

在这部分，我们将向您介绍我们最常用的几种技术。这不是一个详尽的列表，但它应该能给您一些有用的想法，告诉您在调试自己的 Python 代码时从哪里开始。

## 使用打印进行调试

理解任何错误的关键是理解错误发生时您的代码正在做什么。因此，我们将探讨一些不同的技术，用于在程序运行时检查程序的状态。

所有技术中最简单的一种是在代码的各个位置添加`print()`调用。这允许您轻松地看到哪些部分的代码被执行，以及在执行过程中的关键变量的值。例如，如果您正在开发一个 Django 网站，页面上的行为不是您预期的，您可以在视图中添加打印语句，并在重新加载页面时关注控制台。

使用`print()`进行调试有几个缺点和局限性。要使用这种技术，您需要能够修改源代码并在终端中运行它，以便您可以看到`print()`函数调用的输出。在您自己的机器上的开发环境中，这不成问题，但它确实限制了这种技术在其他环境中的有用性。

当您在代码中分散`print()`调用时，您可能会无意中重复大量的调试代码。例如，您可能想打印时间戳（就像我们在测量列表推导和生成器速度时做的那样），或者以某种方式构建一个包含您想要显示的信息的字符串。这种技术的另一个缺点是，很容易忘记代码中的`print()`调用。

由于这些原因，我们有时更喜欢使用自定义调试函数，而不是仅仅使用裸露的`print()`调用。让我们看看如何做。

## 使用自定义函数进行调试

在某个地方保存一个自定义调试函数，以便您可以快速抓取并粘贴到代码中，这特别有用。如果您动作快，您也可以现场编写一个。重要的是要编写它，以便在最终删除调用及其定义时不会留下任何东西。因此，*重要的是要以完全自包含的方式编写它*。这个要求的好另一个原因是，它将避免与代码中其他部分的潜在名称冲突。

让我们来看一个这样的函数的例子：

```py
# custom.py
def debug(*msg, print_separator=True):
    print(*msg)
    if print_separator:
        print("-" * 40)
debug("Data is ...")
debug("Different", "Strings", "Are not a problem")
debug("After while loop", print_separator=False) 
```

在这种情况下，我们使用关键字参数来能够打印一个分隔符，即一条由 40 个破折号组成的线。

该函数只是将`msg`中的内容传递给`print()`的调用，如果`print_separator`为`True`，它将打印一个行分隔符。运行代码将显示以下内容：

```py
$ python custom.py
Data is ...
----------------------------------------
Different Strings Are not a problem
----------------------------------------
After while loop 
```

如你所见，最后一行后面没有分隔符。

这只是增强简单`print()`函数调用的一种简单方法。让我们看看我们如何利用 Python 的一个巧妙特性来计算调用之间的时间差：

```py
# custom_timestamp.py
from time import sleep
def debug(*msg, timestamp=[None]):
    from time import time  # local import
    print(*msg)
    if timestamp[0] is None:
        timestamp[0] = time()  # 1
    else:
        now = time()
        print(f" Time elapsed: {now - timestamp[0]:.3f}s")
        timestamp[0] = now  # 2
debug("Entering buggy piece of code...")
sleep(0.3)
debug("First step done.")
sleep(0.5)
debug("Second step done.") 
```

这有点复杂。首先，注意我们在`debug()`函数内部使用了`import`语句来从`time`模块导入`time()`函数。这样做可以避免在函数外部添加`import`语句，从而降低忘记移除它的风险。

看看我们是如何定义`timestamp`的。它是一个带有列表作为默认值的函数参数。在*第四章*，*函数，代码的构建块*中，我们警告过不要为参数使用可变默认值，因为默认值是在 Python 解析函数时初始化的，并且相同的对象会在函数的不同调用中持续存在。大多数情况下，这不是你想要的行为。然而，在这种情况下，我们正是利用这一特性来存储函数上一次调用的时间戳，而不必使用外部全局变量。我们是从对**闭包**的研究中借用这个技巧的，这是一个我们鼓励你阅读的技巧。

在打印消息后，我们检查`timestamp`中的唯一项的内容。如果它是`None`，那么我们没有先前的时戳，因此我们将值设置为当前时间（`#1`）。另一方面，如果我们有一个先前的时戳，我们可以计算一个差值（我们将其格式化为三位小数），最后，我们将当前时间放入`timestamp`（`#2`）。

运行此代码会输出以下内容：

```py
$ python custom_timestamp.py
Entering buggy piece of code...
First step done.
 Time elapsed: 0.300s
Second step done.
 Time elapsed: 0.500s 
```

使用自定义的调试函数解决了仅使用`print()`时的一些问题。它减少了调试代码的重复，并在你不再需要时更容易移除所有调试代码。然而，它仍然需要修改代码并在可以检查输出的控制台中运行它。在本章的后面部分，我们将看到如何通过向代码中添加日志记录来克服这些困难。

## 使用 Python 调试器

另一种有效的调试 Python 的方法是使用交互式调试器。Python 标准库模块`pdb`提供了一个这样的调试器；然而，我们通常更喜欢使用第三方`pdbpp`包。`pdbpp`是`pdb`的替代品，拥有一个相对友好的用户界面和一些实用的额外工具，我们最喜欢的是*粘性模式*，它允许你在单步执行指令时看到整个函数。

激活调试器（如果你已经安装了`pdbpp`包，它将代替标准的`pdb`调试器）有几种不同的方法。最常见的方法是在你的代码中添加一个调用调试器的调用。这被称为在代码中添加**断点**。

当代码运行并且解释器达到断点时，执行会暂停，你将获得对交互式调试会话的控制台访问权限。然后你可以检查当前作用域中的所有名称，并逐行执行程序。你还可以实时更改数据以改变程序的流程。

作为玩具示例，假设我们有一个程序，该程序接收一个字典和一个键的元组作为输入。然后它使用给定的键处理字典项。程序正在引发`KeyError`，因为其中一个键在字典中缺失。假设我们无法控制输入（可能来自第三方 API），但我们想绕过错误，以便我们可以验证我们的程序在有效输入上是否表现正确。让我们看看我们如何可以使用调试器中断程序，检查并修复数据，然后允许执行继续：

```py
# pdebugger.py
# d comes from an input that we do not control
d = {"first": "v1", "second": "v2", "fourth": "v4"}
# keys also comes from an input we do not control
keys = ("first", "second", "third", "fourth")
def do_something_with_value(value):
    print(value)
for key in keys:
    do_something_with_value(d[key])
print("Validation done.") 
```

如你所见，当`key`获得值为`"third"`时，这个值在字典中缺失，代码会中断。记住，我们假装`d`和`keys`都来自我们无法控制的输入源。如果我们按原样运行代码，我们会得到以下结果：

```py
$ python pdebugger.py
v1
v2
Traceback (most recent call last):
  File ".../ch11/pdebugger.py", line 13, in <module>
    do_something_with_value(d[key])
                            ~^^^^^
KeyError: 'third' 
```

我们发现字典中缺少了`key`，但由于每次运行此代码时，我们可能会得到不同的字典或`keys`元组，这个信息实际上并没有真正帮助我们。我们希望在程序运行时检查和修改数据，因此让我们在`for`循环之前插入一个断点。在 Python 的现代版本中，这样做最简单的方法是调用内置的`breakpoint()`函数：

```py
breakpoint() 
```

在 Python 3.7 之前，你需要导入`pdb`模块并调用`pdb.set_trace()`函数：

```py
import pdb; pdb.set_trace() 
```

注意，我们使用分号来分隔同一行上的多个语句。PEP 8 不鼓励这样做，但在设置此类断点时相当常见，因为当你不再需要断点时，要删除的行更少。

`breakpoint()`函数调用`sys.breakpointhook()`，它反过来调用`pdb.set_trace()`。你可以通过将`PYTHONBREAKPOINT`环境变量设置为指向一个替代函数来覆盖`sys.breakpointhook()`的默认行为，而不是调用`pdb.set_trace()`。

此示例的代码位于`pdebugger_pdb.py`模块中。如果我们现在运行此代码，事情会变得有趣（注意你的输出可能略有不同，并且此输出中的所有注释都是我们添加的）：

```py
$ python pdebugger_pdb.py
[0] > .../ch11/pdebugger_pdb.py(17)<module>()
-> for key in keys:
(Pdb++) l
 16
 17 -> for key in keys:  # breakpoint comes in
 18 do_something_with_value(d[key])
 19
(Pdb++) keys  # inspect the keys tuple
('first', 'second', 'third', 'fourth')
(Pdb++) d.keys()  # inspect keys of d
dict_keys(['first', 'second', 'fourth'])
(Pdb++) d['third'] = 'placeholder'  # add missing item
(Pdb++) c  # continue
v1
v2
placeholder
v4
Validation done. 
```

首先，请注意，当你达到断点时，你会看到一个控制台，它会告诉你你在哪里（Python 模块）以及下一行将要执行的代码。在这个时候，你可以执行一些探索性操作，例如检查下一行之前和之后的代码，打印堆栈跟踪，以及与对象交互。在我们的例子中，我们首先检查 `keys` 元组。我们还检查了 `d` 的键。我们发现 `'third'` 缺失，所以我们自己添加了它（这会危险吗？想想看）。最后，现在所有的键都已经添加完毕，我们输入 `c` 来继续正常执行。

调试器还允许你使用 `n` 命令（对于下一个）逐行执行你的代码。你可以使用 `s` 命令进入函数以进行更深入的分析，或者使用 `b` 命令设置额外的断点。有关命令的完整列表，请参阅文档（您可以在 [`docs.python.org/3.12/library/pdb.html`](https://docs.python.org/3.12/library/pdb.html) 找到）或在使用调试器控制台时输入 `h`（对于帮助）。

从前面的运行输出中，你可以看到我们最终到达了验证的末尾。

`pdb`（或 `pdbpp`）是我们每天都会使用的无价工具。所以，请尝试使用它。在某个地方设置一个断点并尝试检查它，遵循官方文档，并在你的代码中尝试命令以查看它们的效果并熟练掌握它们。

注意，在这个例子中，我们假设你已经安装了 `pdbpp`。如果情况不是这样，你可能会发现一些命令在普通的 `pdb` 中表现略有不同。一个例子是字母 *d*，`pdb` 将其解释为 *down* 命令。为了解决这个问题，你需要在 `d` 前面加上一个 `!` 来告诉 `pdb` 它应该被字面地解释，而不是作为一个命令。

## 检查日志

另一种调试表现不佳的应用程序的方法是检查其日志。**日志**是按顺序排列的事件列表，这些事件是在应用程序运行期间发生或采取的动作。如果日志被写入磁盘上的文件，它就被称为**日志文件**。

使用日志进行调试在某些方面与添加 `print()` 调用或使用自定义调试函数相似。关键区别在于，我们通常从一开始就在代码中添加日志以帮助未来的调试，而不是在调试期间添加它然后再移除。另一个区别是，日志可以轻松地配置为输出到文件或网络位置。这两个方面使得日志非常适合调试可能无法直接访问的远程机器上运行的代码。

事实是，日志记录通常是在发生错误之前添加到代码中的，这确实提出了决定记录什么内容的挑战。我们通常会期望在日志中找到与应用程序内发生的任何重要过程的开始、完成（以及可能的中途步骤）相对应的条目。重要变量的值应包含在这些日志条目中。错误也需要被记录，这样如果出现问题，我们可以检查日志以找出出了什么问题。

Python 中的日志记录几乎各个方面都可以以各种方式配置。这赋予我们很大的权力，因为我们可以通过更改日志配置来改变日志输出的位置、输出的日志消息以及日志消息的格式，而无需更改任何其他代码。在 Python 中涉及日志记录的四个主要类型的对象是：

+   **日志记录器**：暴露应用程序代码直接使用的接口

+   **处理器**：将日志记录（由日志记录器创建）发送到适当的目的地

+   **过滤器**：提供了一种更细粒度的设施来决定要输出哪些日志记录

+   **格式化器**：指定最终输出中日志记录的布局

日志记录是通过调用`Logger`类实例的方法来执行的。你记录的每一行都与一个严重级别相关联。最常用的级别是`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。日志记录器使用这些级别来确定要输出哪些日志消息。低于日志记录器级别的任何内容都将被忽略。这意味着你必须小心地以适当的级别进行日志记录。如果你以`DEBUG`级别记录一切，你需要将你的日志记录器配置在`DEBUG`级别或以下，才能看到任何消息。这可能会迅速导致你的日志文件变得非常大。如果你以`CRITICAL`级别记录一切，也会出现类似的问题。

Python 为你提供了多个选择来记录日志。你可以将日志记录到文件、网络位置、队列、控制台、操作系统的日志设施等。你发送日志的位置通常非常依赖于上下文。例如，当你在你开发环境中运行你的代码时，你通常会记录到你的终端。如果你的应用程序在单个机器上运行，你可能将日志记录到文件或将日志发送到操作系统的日志设施。

另一方面，如果你的应用程序使用跨越多个机器的分布式架构（例如在面向服务的或微服务架构的情况下），那么实现一个集中式的日志记录解决方案会更好，这样每个服务的所有日志消息都可以存储和调查在一个地方。这使得调试变得容易得多，因为试图将来自多个来源的巨大文件关联起来以找出出了什么问题，可能会变得真正具有挑战性。

**面向服务的架构**（**SOA**）是软件设计中的一个架构模式，其中应用程序组件通过通信协议（通常是网络）向其他组件提供服务。这个系统的美妙之处在于，当代码编写得当，每个服务都可以用最合适的语言来编写，以实现其目的。唯一重要的是与其他服务的通信，这需要通过一个公共格式来实现，以便进行数据交换。

**微服务架构**是 SOA 的演变，但遵循不同的架构模式。

Python 的日志记录的可配置性的缺点是日志机制相对复杂。幸运的是，默认设置通常足够，你只有在有特定定制需求时才需要覆盖设置。让我们看看将几条消息记录到文件中的简单示例：

```py
# log.py
import logging
logging.basicConfig(
    filename="ch11.log",
    level=logging.DEBUG, 
    format="[%(asctime)s] %(levelname)s: %(message)s",
    datefmt="%m/%d/%Y %I:%M:%S %p")
mylist = [1, 2, 3]
logging.info("Starting to process 'mylist'...")
for position in range(4):
    try:
        logging.debug(
            "Value at position %s is %s",
            position,
            mylist[position]
        )
    except IndexError:
        logging.exception("Faulty position: %s", position)
logging.info("Done processing 'mylist'.") 
```

首先，我们导入`logging`模块，然后设置基本配置。我们指定一个文件名，配置记录器以输出任何级别为`DEBUG`或更高的日志消息，并设置消息格式。我们希望记录日期和时间信息、级别和消息。

在配置到位后，我们可以开始记录日志。我们首先记录一条`info`消息，告诉我们我们即将处理我们的列表。在循环内部，我们将记录每个位置上的值（我们使用`debug()`函数在`DEBUG`级别记录）。我们在这里使用`debug()`是为了将来能够过滤掉这些日志（通过配置记录器的`level`为`logging.INFO`或更高），因为我们可能需要处理大型列表，我们不希望总是记录所有值。

如果我们遇到`IndexError`（我们确实遇到了，因为我们正在遍历`range(4)`），我们调用`logging.exception()`，它在`ERROR`级别记录，但也会输出异常回溯。

在代码的末尾，我们记录了一条另一个`info`消息，表示我们已经完成。运行此代码后，我们将有一个新的`ch11.log`文件，其中包含以下内容：

```py
# ch11.log
[10/06/2024 10:08:04 PM] INFO: Starting to process 'mylist'...
[10/06/2024 10:08:04 PM] DEBUG: Value at position 0 is 1
[10/06/2024 10:08:04 PM] DEBUG: Value at position 1 is 2
[10/06/2024 10:08:04 PM] DEBUG: Value at position 2 is 3
[10/06/2024 10:08:04 PM] ERROR: Faulty position: 3
Traceback (most recent call last):
  File ".../ch11/log.py", line 20, in <module>
    mylist[position],
    ~~~~~~^^^^^^^^^^
IndexError: list index out of range
[10/06/2024 10:08:04 PM] INFO: Done processing 'mylist'. 
```

这正是我们能够调试运行在远程机器上的应用程序而不是我们自己的开发环境所需要的东西。我们可以看到我们的代码做了什么，任何抛出的异常的回溯，等等。

随意修改前一个示例中的日志级别，包括代码和配置。这样，你将能够看到输出如何根据你的设置而变化。

这里提供的示例只是对日志记录的表面了解。对于更深入的解释，你可以在官方 Python 文档的*Python HOWTOs*部分找到信息：*Logging HOWTO*和*Logging Cookbook*。

记录日志是一种艺术。你需要找到一个在记录一切和记录什么都不记录之间的良好平衡。理想情况下，你应该记录任何你需要确保应用程序正确运行的事情，以及可能的所有错误或异常。

## 其他技术

我们将简要提及一些其他可能对您有用的调试技术来结束本节的调试部分。

### 阅读跟踪信息

错误通常表现为未处理的异常。因此，解释异常跟踪信息是成功调试的关键技能。请确保您已经阅读并理解了*第七章*，*异常和上下文管理器*中关于跟踪信息的部分。如果您试图了解异常发生的原因，检查程序在跟踪信息中提到的行所表示的状态（使用我们上面讨论的技术）通常很有用。

### 断言

错误通常是我们代码中不正确假设的结果。断言可以帮助验证这些假设。如果我们的假设是有效的，断言通过并正常执行。如果它们不是，我们会得到一个异常，告诉我们哪些假设是不正确的。有时，与其使用调试器或 `print()` 语句进行检查，不如在代码中添加几个断言来排除可能性更快。让我们看一个例子：

```py
# assertions.py
mylist = [1, 2, 3]  #  pretend this comes from an external source
assert 4 == len(mylist)  # this will break
for position in range(4):
    print(mylist[position]) 
```

在这个例子中，我们假设 `mylist` 来自一些外部来源，我们无法控制（可能是用户输入）。`for` 循环假设 `mylist` 有四个元素，我们添加了一个断言来验证这个假设。当我们运行代码时，结果是这个：

```py
$ python assertions.py
Traceback (most recent call last):
  File ".../ch11/assertions.py", line 4, in <module>
    assert 4 == len(mylist)  # this will break
           ^^^^^^^^^^^^^^^^
AssertionError 
```

这告诉我们问题确实在哪里。

当激活 `-O` 标志运行程序时，Python 将忽略所有断言。如果我们的代码依赖于断言来工作，这一点需要记住。

断言还允许更长的格式，包括第二个表达式，例如：

```py
assert expression1, expression2 
```

第二个表达式传递给由语句引发的 `AssertionError` 异常。它通常是一个包含错误信息的字符串。例如，如果我们将上一个例子中的断言更改为以下内容：

```py
assert 4 == len(mylist), f"Mylist has {len(mylist)} elements" 
```

结果将是：

```py
$ python assertions.py
Traceback (most recent call last):
  File ".../ch11/assertions.py", line 19, in <module>
    assert 4 == len(mylist), f"Mylist has {len(mylist)} elements"
           ^^^^^^^^^^^^^^^^
AssertionError: Mylist has 3 elements 
```

## 信息查找位置

官方 Python 文档包含一个专门用于调试和性能分析的章节。在那里，您可以阅读关于 `bdb` 调试框架以及 `faulthandler`、`timeit`、`trace`、`tracemalloc` 和 `pdb` 等模块的信息。

让我们现在探索一些故障排除指南。

# 故障排除指南

在本节简短的部分，我们想向您提供一些来自我们故障排除经验的技巧。

## 检查位置

我们的第一些建议是关于在哪里放置您的调试断点。无论您是使用 `print()`、自定义函数、`pdb` 还是日志记录，您仍然必须选择放置提供信息的调用位置。有些地方肯定比其他地方好，而且有一些处理调试进度的方法比其他方法更好。

我们通常避免在`if`子句内放置断点。如果包含断点的分支没有被执行，我们就失去了获取我们想要的信息的机会。有时，重现一个错误可能很困难，或者你的代码可能需要一段时间才能到达断点，所以在放置它们之前要仔细思考。

另一个重要的事情是确定从哪里开始。想象一下，你有 100 行代码来处理你的数据。数据从第 1 行开始输入，不知何故，在第 100 行出现了错误。你不知道错误在哪里，那么你该怎么办？你可以在第 1 行设置一个断点，并耐心地逐行检查所有 100 行，检查每一步的数据。在最坏的情况下，经过 99 行（以及许多杯咖啡）后，你发现了错误。所以，考虑使用不同的方法。

从第 50 行开始检查。如果数据是好的，这意味着错误发生在后面，在这种情况下，你将下一个断点设置在第 75 行。如果第 50 行的数据已经不好，你继续通过在第 25 行设置断点。然后，你重复这个过程。每次，你要么向后移动，要么向前移动，移动的距离是上一次跳跃距离的一半。

在我们最坏的情况下，你的调试将从 1, 2, 3, ..., 99，以线性方式，转变为一系列跳跃，如 50, 75, 87, 93, 96, ..., 99，这要快得多。实际上，这是一种对数搜索技术。这种搜索技术被称为**二分搜索**；它基于分而治之的方法，并且非常有效，所以尽量掌握它。

## 使用测试进行调试

在第十章的*测试*部分，我们简要地向你介绍了**测试驱动开发**（**TDD**）。即使你并不完全接受 TDD，你也应该采纳的一个 TDD 实践是在开始修改代码以修复错误之前，编写重现错误的测试。这样做有几个原因。如果你有一个错误，并且所有测试都通过了，这意味着你的测试代码库中可能存在错误或遗漏。

添加这些测试将帮助你确保你真正修复了错误：只有当错误消失时，测试才能通过。最后，拥有这些测试将保护你免得意外地再次引入相同的错误。

## 监控

监控同样重要。软件应用程序有时在边缘情况下可能会表现出意外的行为，例如网络中断、队列满或外部组件无响应。在这些情况下，了解问题发生时的大致情况，并将其与相关联的微妙、甚至神秘的事物联系起来，这一点很重要。

你可以监控 API 端点、进程、网页的可用性和加载时间，以及你可以编码的一切。一般来说，当你从头开始启动一个应用程序时，从最早的设计阶段开始考虑你想要如何监控它可能会有所帮助。

现在，让我们继续看看我们如何对 Python 代码进行性能分析。

# Python 性能分析

分析意味着在运行应用程序的同时跟踪几个不同的参数，例如函数被调用的次数以及在其中花费的时间量。

分析与调试密切相关。尽管使用的工具和过程相当不同，但这两项活动都涉及探测和分析您的代码，以了解问题的根源，然后进行更改以修复它。区别在于，我们试图解决的问题不是错误的输出或崩溃，而是性能不佳。

有时，分析会指向性能瓶颈所在的位置，此时您需要使用本章前面讨论的调试技术来了解为什么某个特定的代码片段没有像预期的那样表现良好。例如，数据库查询中的错误逻辑可能会导致从表中加载数千行而不是数百行。分析可能会显示某个特定函数被调用的次数比预期多得多，此时您需要使用您的调试技能来找出原因并解决问题。

有几种方法可以分析 Python 应用程序。如果您查看标准库官方文档中的分析部分，您将看到有两种不同的分析接口实现，`profile`和`cProfile`：

+   `cProfile`是用 C 语言编写的，并且相对较少地增加了开销，这使得它适合分析长时间运行的程序。

+   `profile`是用纯 Python 实现的，因此为被分析的程序增加了显著的开销。

此接口执行**确定性分析**，这意味着所有函数调用、函数返回和异常事件都被监控，并在这些事件之间的间隔中进行精确计时。另一种方法称为**统计分析**，在固定的时间间隔内随机采样程序的调用堆栈，并推断时间花费在哪里。

后者通常涉及较少的开销，但只提供近似的结果。此外，由于 Python 解释器运行代码的方式，确定性分析并不像人们想象的那样增加很多开销，因此我们将向您展示一个使用命令行中的`cProfile`的简单示例。

有时，即使是相对较低的开销的`cProfile`也不可接受，例如，如果您需要在实时生产 Web 服务器上分析代码，因为您无法在开发环境中重现性能问题。在这种情况下，您确实需要一个统计分析器。如果您对 Python 的统计分析感兴趣，我们建议您查看`py-spy`（[`github.com/benfred/py-spy`](https://github.com/benfred/py-spy)）。

我们将再次使用以下代码计算毕达哥拉斯三元组：

```py
# profiling/triples.py
def calc_triples(mx):
    triples = []
    for a in range(1, mx + 1):
        for b in range(a, mx + 1):
            hypotenuse = calc_hypotenuse(a, b)
            if is_int(hypotenuse):
                triples.append((a, b, int(hypotenuse)))
    return triples
def calc_hypotenuse(a, b):
    return (a**2 + b**2) ** 0.5
def is_int(n):
    return n.is_integer()
triples = calc_triples(1000) 
```

脚本很简单；我们用`a`和`b`遍历区间`[1, mx]`（通过设置`b >= a`避免重复的配对）并检查它们是否属于直角三角形。我们使用`calc_hypotenuse()`来获取`a`和`b`的斜边，然后，使用`is_int()`检查它是否为整数，这意味着`(a, b, 斜边)`是一个毕达哥拉斯三元组。

当我们对这个脚本进行性能分析时，我们以表格形式获得信息。列包括`ncalls`（函数调用的次数）、`tottime`（每个函数花费的总时间）、`percall`（每次调用每个函数的平均时间）、`cumtime`（函数及其调用的所有函数的累积时间）、`percall`（每次调用的平均累积时间）和`filename:lineno(function)`。以下是我们的结果（为了节省空间，我们省略了两个`percall`列）：

```py
$ python -m cProfile profiling/triples.py
1502538 function calls in 0.393 seconds
Ordered by: cumulative time
ncalls tottime cumtime filename:lineno(function)
     1   0.000   0.393 {built-in method builtins.exec}
     1   0.000   0.393 triples.py:1(<module>)
     1   0.143   0.393 triples.py:1(calc_triples)
500500   0.087   0.147 triples.py:15(is_int)
500500   0.102   0.102 triples.py:11(calc_hypotenuse)
500500   0.060   0.060 {method 'is_integer' of 'float' objects}
  1034   0.000   0.000 {method 'append' of 'list' objects}
     1   0.000   0.000 {method 'disable' of '_lsprof.Profiler' objects} 
```

即使只有这么有限的数据，我们仍然可以从中推断出一些关于这段代码的有用信息。首先，我们可以看到我们选择的算法的时间复杂度随着输入大小的平方增长。`calc_hypotenuse()`函数的调用次数正好是*m*x (m*x + 1) / 2*。我们用`mx = 1000`运行脚本，得到了正好 500,500 次调用。循环内部发生的三件事是：我们调用`calc_hypotenuse()`，调用`is_int()`，如果条件满足，就将它添加到`triples`列表中。

在分析性能报告中的累积时间时，我们注意到程序在`is_int()`函数内部花费了 0.147 秒，而`calc_hypotenuse()`函数内部则花费了 0.102 秒。这两个函数被调用的次数相同，因此我们优化的首要目标应该是成本更高的`is_int()`函数。

如果我们查看`tottime`列，我们会看到程序在`is_int()`中花费了 0.087 秒。这排除了在`is_int()`调用`float`对象的`is_integer()`方法中花费的 0.060 秒。然而，`is_int()`除了调用其参数`n`的`is_integer()`方法外，没有做任何事情。这意味着仅仅额外的函数调用就增加了 87 毫秒的开销。在这个程序中，`is_int()`函数并没有带来太多好处，因此我们可以通过直接调用`hypotenuse.is_integer()`来节省 87 毫秒。

如果我们重新运行性能分析，我们会看到现在我们在`calc_hypotenuse()`中花费的时间比在`is_integer()`方法中更多。正如我们在*第五章* *理解与生成器*中提到的，使用`**`幂运算符来计算一个数的平方比将其自身相乘要昂贵。考虑到这一点，我们可以尝试通过将`calc_hypotenuse()`更改为以下内容来提高性能：

```py
def calc_hypotenuse(a, b): 
    return (a * a + b * b) ** 0.5 
```

再次运行性能分析后，我们发现程序现在在`calc_hypotenuse()`函数中花费了 0.084 秒。我们只获得了 18 毫秒的改进。我们可以通过消除对`calc_hypotenuse()`函数调用的开销并直接计算斜边来获得更多的改进：

```py
 hypotenuse = (a * a + b * b) ** 0.5 
```

对这个版本进行性能分析显示，我们可以通过这种方式获得高达 100 毫秒的改进。然而，我们认为，在这种情况下，函数提供的可读性、可维护性和可测试性的好处超过了移除它所带来的性能提升。

你将在本书的源代码中找到这个程序的四个版本。我们鼓励你自己运行性能分析，并尝试对代码进行其他更改以查看它们对性能的影响（例如，你可以尝试将`calc_triples()`转换为生成器函数）。

当然，这个例子很简单，但足以展示你如何对应用程序进行性能分析。了解对函数调用的次数可以帮助我们更好地理解算法的时间复杂度。例如，许多程序员未能意识到那两个`for`循环是与输入大小的平方成比例运行的。

我们已经看到了函数的性能分析，但如果需要，也可以达到更高的粒度级别，对代码的每一行进行性能分析。平均而言，Python 程序员在其职业生涯中可能不需要进行太多的性能分析，但这种情况可能会发生，因此了解我们拥有的选项是很好的。

有一个需要提到的事情：性能分析的结果很可能因你所运行的系统而异。因此，如果可能的话，在尽可能接近软件部署的系统上进行软件的性能分析是很重要的，如果不是在它上面的话。

在本节中，我们专注于性能分析和优化程序的运行时间。性能分析也可以用来分析和优化内存使用。Python 中用于内存分析的最受欢迎的工具之一是 memray。你可以在[`bloomberg.github.io/memray/`](https://bloomberg.github.io/memray/)了解更多信息。

## 何时进行性能分析

了解何时进行性能分析以及如何处理我们得到的结果是很重要的。唐纳德·克努特曾经说过，“*过早的优化是所有邪恶的根源*”，虽然我们不会说得这么绝对，但我们确实同意他的观点。例如，为了获得几毫秒的速度提升而牺牲可读性或可维护性通常是不值得的。

你的首要关注点始终应该是*正确性*。你希望你的代码能够输出正确的结果，因此编写测试，寻找边缘情况，并以你认为合理的方式对代码进行压力测试。不要过于保护；不要将事情放在大脑的后面，因为你认为它们不太可能发生。要全面考虑。

其次，注意编码*最佳实践*。记住以下几点：可读性、可扩展性、松散耦合、模块化、设计。应用面向对象编程（OOP）原则：封装、抽象、单一职责、开闭原则等。了解这些概念。它们将为你的视野打开新的天地，并扩展你对代码的思考方式。

第三，*重构*。童子军规则说：

> 总是保持露营地的清洁，比找到它时更干净。

将此规则应用到你的代码中。

最后，当所有这些都已经处理完毕后，然后，并且只有然后，才开始优化和性能分析。

运行你的分析器并识别瓶颈。在分析分析结果时，关注被调用次数最多的函数。正如我们在*第五章*，*列表推导式和生成器*中提到的，你甚至可以从对被调用一百万次的函数的微小改进中获得比尝试改进只被调用几次的函数更多的收益。当你对需要解决的瓶颈有了概念后，从最严重的一个开始。有时，修复一个瓶颈会引起连锁反应，从而改变其余代码的工作方式。有时，这种影响可能只是微小的，有时，可能更多一些，这取决于你的代码是如何设计和实现的。因此，从最大的问题开始。

Python 之所以如此受欢迎，其中一个原因是它可以使用用更快、编译语言（如 C 或 C++）编写的模块来扩展。所以，如果你有一些关键的代码，你无法在纯 Python 中达到所需的性能，你总是可以选择将其部分重写为 C。

## 测量执行时间

在我们完成本章之前，我们想简要地讨论一下测量代码执行时间的话题。有时，测量小块代码的性能以比较它们之间的性能是有帮助的。例如，如果你有几种实现某些操作的方法，并且你真的需要最快的版本，你可能想在不分析整个应用程序的情况下比较它们的性能。

我们在本章前面已经看到了一些测量和比较执行时间的例子，例如，在*第五章*，*列表推导式和生成器*中，当我们比较`for`循环、列表推导式和`map()`函数的性能时。在此阶段，我们想向您介绍一种更好的方法，即使用`timeit`模块。此模块使用诸如多次重复执行代码以改进测量精度等技术。

`timeit`模块可能有点难以使用。我们建议你在官方 Python 文档中阅读有关内容，并在那里尝试示例，直到你理解如何使用它。在这里，我们只简要演示如何使用命令行界面来测量上一个例子中`calc_hypotenuse()`的两个不同版本的执行时间：

```py
$ python -m timeit -s 'a=2; b=3' '(a**2 + b**2) ** .5'
5000000 loops, best of 5: 91 nsec per loop 
```

在这里，我们正在运行`timeit`模块，初始化变量`a = 2`和`b = 3`，然后在执行`(a**2 + b**2) ** .5`之前计时。在输出中，我们可以看到`timeit`运行了 5 次重复，每次重复计时 5,000,000 次循环迭代执行我们的计算。在这 5 次重复中，5,000,000 次迭代中的最佳平均执行时间为 91 纳秒。让我们看看替代计算`(a*a + b*b) ** .5`的表现：

```py
$ python -m timeit -s 'a=2; b=3' '(a*a + b*b) ** .5'
5000000 loops, best of 5: 72.8 nsec per loop 
```

这次，我们每循环的平均时间为 72.8 纳秒。这再次证实了第二个版本稍微快一点。

`timeit`模块会自动选择迭代次数，以确保总运行时间至少为 0.2 秒。这有助于通过减少测量开销的相对影响来提高准确性。

关于测量 Python 性能的更多信息，请确保查看`pyperf` ([`github.com/psf/pyperf`](https://github.com/psf/pyperf)) 和 `pyperformance` ([`github.com/python/pyperformance`](https://github.com/python/pyperformance))。

# 摘要

在这个简短的章节中，我们探讨了调试、故障排除和代码性能分析的不同技术和建议。调试是软件开发者工作的一部分，因此掌握它很重要。

如果以正确的心态去面对，这可以是一件有趣且有益的事情。

我们探讨了使用自定义函数、日志记录、调试器、跟踪信息、性能分析和断言来检查我们的代码的技术。我们看到了其中大多数的简单示例。我们还讨论了一些有助于应对挑战的指导方针。

总是记得要*保持冷静和专注*，这样调试将会容易得多。这也是一种需要学习并且最重要的技能。一个焦躁和紧张的大脑无法正常、逻辑和创造性地工作。因此，如果你不加强它，你将很难充分利用你的知识。所以，当你面对一个棘手的 bug 时，如果你有机会，确保你进行短暂的散步或小憩——放松。通常，在良好的休息之后，解决方案就会显现出来。

在下一章中，我们将探讨类型提示和静态类型检查器的使用，这有助于减少某些类型错误的可能性。

# 加入我们的社区 Discord

加入我们的社区 Discord 空间，与作者和其他读者进行讨论：

[加入我们的 Discord 社区](https://discord.com/invite/uaKmaz7FEC)

![img](img/QR_Code119001106417026468.png)
