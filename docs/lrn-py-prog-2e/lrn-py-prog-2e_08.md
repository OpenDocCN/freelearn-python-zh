# 第八章：测试、性能分析和处理异常

“就像智者在加热、切割和摩擦后接受黄金一样，我的话语在经过检验后才应该被接受，而不是因为尊重我。” - 佛陀

我喜欢佛陀的这句话。在软件世界中，它完美地诠释了一个健康的习惯，即永远不要因为某个聪明人编写了代码或者它长期以来一直运行良好就信任代码。如果没有经过测试，代码就不值得信任。

为什么测试如此重要？首先，它们给您可预测性。或者至少，它们帮助您实现高度可预测性。不幸的是，总会有一些错误潜入代码中。但我们绝对希望我们的代码尽可能可预测。我们不希望出现意外，换句话说，我们的代码表现出不可预测的方式。您会乐意知道负责检查飞机传感器的软件有时会出现故障吗？可能不会。

因此，我们需要测试我们的代码；我们需要检查其行为是否正确，当处理边缘情况时是否按预期工作，当其所连接的组件出现故障或不可访问时是否不会挂起，性能是否在可接受范围内等等。

本章就是关于这个的 - 确保您的代码准备好面对可怕的外部世界，它足够快，并且可以处理意外或异常情况。

在本章中，我们将探讨以下主题：

+   测试（包括对测试驱动开发的简要介绍）。

+   异常处理

+   性能分析和表现

让我们首先了解测试是什么。

# 测试您的应用程序

有许多不同类型的测试，实际上有很多，以至于公司通常会有一个专门的部门，称为**质量保证**（**QA**），由一些人组成，他们整天都在测试公司开发人员生产的软件。

为了开始进行初步分类，我们可以将测试分为两大类：白盒测试和黑盒测试。

**白盒测试**是对代码内部进行测试的测试；它们详细检查代码的内部。另一方面，**黑盒测试**是将被测试的软件视为一个盒子，其中的内部被忽略。甚至盒子内部使用的技术或语言对于黑盒测试也不重要。它们所做的就是将输入插入盒子的一端，并验证另一端的输出，就是这样。

还有一个中间类别，称为**灰盒**测试，它涉及以与黑盒方法相同的方式测试系统，但对编写软件所使用的算法和数据结构有一定了解，并且只能部分访问其源代码。

在这些类别中有许多不同类型的测试，每种测试都有不同的目的。举个例子，以下是其中一些：

+   **前端测试**：确保应用程序的客户端展示应该展示的信息，所有链接、按钮、广告，所有需要展示给客户端的内容。它还可以验证通过用户界面走特定路径是否可能。

+   **场景测试**：利用故事（或场景）来帮助测试人员解决复杂问题或测试系统的一部分。

+   **集成测试**：验证应用程序各个组件在一起工作并通过接口发送消息时的行为。

+   **冒烟测试**：在应用程序部署新更新时特别有用。它们检查应用程序最基本、最重要的部分是否仍然按照预期工作，并且它们没有着火。这个术语来源于工程师通过确保没有任何东西冒烟来测试电路的情况。

+   验收测试，或用户验收测试（UAT）：开发人员与产品所有者（例如，在 SCRUM 环境中）一起确定委托的工作是否正确完成。

+   功能测试：验证软件的特性或功能。

+   破坏性测试：摧毁系统的部分，模拟故障，以确定系统的其余部分的表现。这些类型的测试被需要提供极其可靠服务的公司广泛进行，例如亚马逊和 Netflix。

+   性能测试：旨在验证系统在特定数据或流量负载下的性能，以便工程师可以更好地了解系统中可能导致其在高负载情况下崩溃的瓶颈，或者阻止可扩展性的瓶颈。

+   可用性测试，以及与之密切相关的用户体验（UX）测试：旨在检查用户界面是否简单易懂、易于理解和使用。它们旨在为设计师提供输入，以改善用户体验。

+   安全和渗透测试：旨在验证系统对攻击和入侵的保护程度。

+   单元测试：帮助开发人员以健壮和一致的方式编写代码，提供第一条反馈线并防范编码错误、重构错误等。

+   回归测试：在更新后，为开发人员提供有关系统中功能受损的有用信息。系统被认为有回归的原因包括旧错误重新出现、现有功能受损或引入新问题。

关于测试已经有许多书籍和文章，如果你对了解所有不同类型的测试感兴趣，我不得不指向这些资源。在本章中，我们将集中讨论单元测试，因为它们是软件开发的支柱，并且是开发人员编写的绝大多数测试。

测试是一门艺术，一门你恐怕无法从书本中学到的艺术。你可以学习所有的定义（你应该这样做），并尝试收集尽可能多的关于测试的知识，但只有当你在领域中做了足够长时间的测试时，你才可能能够正确地测试你的软件。

当你试图重构一小段代码时遇到困难，因为你触及的每一个小细节都会导致测试失败，你会学会如何编写不那么严格和限制性的测试，这些测试仍然验证代码的正确性，但同时允许你自由地玩耍，按照自己的意愿塑造它。

当你被频繁调用来修复代码中的意外错误时，你会学会如何更彻底地编写测试，如何列出更全面的边界情况列表，并学会在它们变成错误之前应对它们的策略。

当你花费太多时间阅读测试并尝试重构它们以更改代码中的小功能时，你会学会编写更简单、更短、更专注的测试。

我可以继续这个“当你...你会学会...”，但我想你已经明白了。你需要动手并积累经验。我的建议？尽可能多地学习理论，然后尝试使用不同的方法进行实验。此外，尝试向经验丰富的编程人员学习；这是非常有效的。

# 测试的解剖

在我们集中讨论单元测试之前，让我们看看测试是什么，它的目的是什么。

测试是一个代码片段，其目的是验证系统中的某些内容。可能是我们调用一个函数传递两个整数，一个对象有一个名为`donald_duck`的属性，或者当你在某个 API 上下订单后，一分钟后你可以看到它被分解成其基本元素，存储在数据库中。

测试通常由三个部分组成：

+   **准备**：这是您设置场景的地方。您准备所有数据、对象和服务，以便它们准备好在需要它们的地方使用。

+   **执行**：这是您执行要检查的逻辑的地方。您使用准备阶段设置的数据和接口执行一个操作。

+   **验证**：这是您验证结果并确保它们符合您的期望的地方。您检查函数的返回值，或者数据库中是否有一些数据，有一些没有，有一些已经改变，是否已经发出请求，是否发生了某些事情，是否已经调用了某个方法，等等。

虽然测试通常遵循这种结构，在测试套件中，您通常会发现一些其他参与测试的构造：

+   **设置**：这是在几种不同的测试中经常发现的东西。这是可以定制为每个测试、类、模块，甚至整个会话运行的逻辑。在这个阶段，通常开发人员建立与数据库的连接，也许用测试需要的数据填充数据库，等等。

+   **拆卸**：这与设置相反；拆卸阶段发生在测试运行后。与设置一样，它可以定制为每个测试、类或模块，或会话。通常在这个阶段，我们销毁为测试套件创建的任何工件，并在测试后进行清理。

+   **固定装置**：它们是测试中使用的数据片段。通过使用特定的固定装置集，结果是可预测的，因此测试可以对其进行验证。

在本章中，我们将使用 Python 库`pytest`。这是一个非常强大的工具，使测试变得更容易，并提供了大量的辅助功能，使测试逻辑可以更多地专注于实际测试而不是围绕它的连接。当我们开始编写代码时，您会看到`pytest`的一个特点是固定装置、设置和拆卸通常融为一体。

# 测试指南

像软件一样，测试可以是好的或坏的，在中间有各种不同的情况。要编写好的测试，以下是一些指南：

+   **尽可能保持简单**。违反一些良好的编码规则，如硬编码值或重复代码是可以的。测试首先需要尽可能**可读**和易于理解。当测试难以阅读或理解时，您永远无法确信它们实际上是否确保您的代码执行正确。

+   **测试应该验证一件事情，而且只有一件事情**。非常重要的是，您要保持测试简短和集中。编写多个测试来测试单个对象或函数是完全可以的。只需确保每个测试只有一个目的。

+   **测试在验证数据时不应做出任何不必要的假设**。这一点起初很难理解，但很重要。验证函数调用的结果是`[1, 2, 3]`并不等同于说输出是包含数字`1`、`2`和`3`的列表。在前者中，我们还假设了顺序；在后者中，我们只假设了列表中有哪些项。这些差异有时相当微妙，但仍然非常重要。

+   测试应该关注的是“什么”，而不是“如何”。测试应该专注于检查函数应该做什么，而不是它是如何做的。例如，专注于它计算一个数字的平方根（“什么”），而不是它调用`math.sqrt`来做到这一点（“如何”）。除非你正在编写性能测试或者有特定需要验证某个操作是如何执行的，尽量避免这种类型的测试，专注于“什么”。测试“如何”会导致限制性测试，并使重构变得困难。此外，当您经常修改软件时，专注于“如何”时必须编写的测试类型更有可能降低测试代码库的质量。

+   测试应该使用最少量的固定装置来完成工作。这是另一个关键点。固定装置往往会随着时间的推移而增长。它们也往往会不时地发生变化。如果您使用大量的固定装置并忽略测试中的冗余，重构将需要更长的时间。发现错误将更加困难。尽量使用足够大的固定装置集来正确执行测试，但不要使用过多。

+   测试应该尽可能快地运行。一个良好的测试代码库最终可能比被测试的代码本身要长得多。根据情况和开发人员的不同，长度可能会有所不同，但无论长度如何，您最终会有数百甚至数千个测试需要运行，这意味着它们运行得越快，您就能越快地回到编写代码。例如，在使用 TDD 时，您经常运行测试，因此速度至关重要。

+   测试应该尽量使用最少的资源。原因是每个检出您代码的开发人员都应该能够运行您的测试，无论他们的计算机有多强大。它可能是一个瘦小的虚拟机或一个被忽视的 Jenkins 盒子，您的测试应该在不消耗太多资源的情况下运行。

**Jenkins**盒子是运行 Jenkins 软件的机器，该软件能够自动运行您的测试，除此之外还有许多其他功能。Jenkins 经常用于那些开发人员使用持续集成和极限编程等实践的公司。

# 单元测试

现在您已经了解了测试是什么以及为什么我们需要它，让我们介绍开发人员最好的朋友：**单元测试**。

在我们继续示例之前，让我分享一些警告：我会尝试向您介绍有关单元测试的基础知识，但我并没有完全遵循任何特定的思想或方法。多年来，我尝试了许多不同的测试方法，最终形成了自己的做事方式，这种方式不断发展。用李小龙的话来说：

“吸收有用的东西，抛弃无用的东西，添加特别属于你自己的东西。”

# 编写单元测试

单元测试得名于它们用于测试代码的小单元。为了解释如何编写单元测试，让我们看一个简单的代码片段：

```py
# data.py
def get_clean_data(source): 
    data = load_data(source) 
    cleaned_data = clean_data(data) 
    return cleaned_data 
```

`get_clean_data`函数负责从`source`获取数据，清理数据，并将其返回给调用者。我们如何测试这个函数呢？

一种做法是调用它，然后确保`load_data`只调用了一次，参数是`source`。然后我们需要验证`clean_data`被调用了一次，参数是`load_data`的返回值。最后，我们需要确保`clean_data`的返回值也是`get_clean_data`函数返回的值。

为了做到这一点，我们需要设置源并运行此代码，这可能是一个问题。单元测试的黄金法则之一是*任何跨越应用程序边界的东西都需要被模拟*。我们不想与真实的数据源交谈，也不想实际运行真实的函数，如果它们与我们应用程序中不包含的任何东西进行通信。一些例子包括数据库、搜索服务、外部 API 和文件系统中的文件。

我们需要这些限制来充当屏障，以便我们始终可以安全地运行我们的测试，而不必担心在真实数据源中破坏任何东西。

另一个原因是，对于单个开发人员来说，复制整个架构可能会非常困难。它可能需要设置数据库、API、服务、文件和文件夹等等，这可能很困难、耗时，有时甚至不可能。

非常简单地说，**应用程序编程接口**（**API**）是一组用于构建软件应用程序的工具。API 以其操作、输入和输出以及底层类型来表达软件组件。例如，如果您创建一个需要与数据提供者服务进行接口的软件，很可能您将不得不通过他们的 API 来访问数据。

因此，在我们的单元测试中，我们需要以某种方式模拟所有这些事物。单元测试需要由任何开发人员运行，而无需在他们的计算机上设置整个系统。

另一种方法，我总是在可能的情况下更喜欢的方法是，模拟实体而不使用伪造对象，而是使用专门的测试对象。例如，如果您的代码与数据库交互，我宁愿生成一个测试数据库，设置我需要的表和数据，然后修补连接设置，以便我的测试运行真正的代码，针对测试数据库，从而不会造成任何伤害。内存数据库是这些情况的绝佳选择。

允许您为测试生成数据库的应用程序之一是 Django。在`django.test`包中，您可以找到几个工具，这些工具可以帮助您编写测试，以便您无需模拟与数据库的对话。通过这种方式编写测试，您还可以检查事务、编码和编程的所有其他与数据库相关的方面。这种方法的另一个优势在于能够检查可能会从一个数据库更改到另一个数据库的事物。

有时候，这仍然是不可能的，我们需要使用伪造的东西，所以让我们来谈谈它们。

# 模拟对象和修补

首先，在 Python 中，这些伪造的对象被称为**mocks**。直到 3.3 版本，`mock`库是一个第三方库，基本上每个项目都会通过`pip`安装，但是从 3.3 版本开始，它已经包含在标准库中的`unittest`模块下，这是理所当然的，考虑到它的重要性和普及程度。

用伪造对象替换真实对象或函数（或者一般来说，任何数据结构的一部分）的行为被称为**修补**。`mock`库提供了`patch`工具，它可以作为函数或类装饰器，甚至可以作为上下文管理器，您可以使用它来模拟事物。一旦您用合适的伪造对象替换了您不需要运行的一切，您可以进入测试的第二阶段并运行您正在测试的代码。执行后，您将能够检查这些伪造对象，以验证您的代码是否正确运行。

# 断言

验证阶段是通过断言来完成的。**断言**是一个函数（或方法），你可以用它来验证对象之间的相等性，以及其他条件。当条件不满足时，断言将引发一个异常，使你的测试失败。你可以在`unittest`模块文档中找到一系列的断言；然而，当使用`pytest`时，你通常会使用通用的`assert`语句，这样事情会更简单。

# 测试 CSV 生成器

现在让我们采取一个实际的方法。我将向你展示如何测试一段代码，我们将涉及到关于单元测试的其他重要概念，以这个例子为背景。

我们想要编写一个`export`函数，它执行以下操作：接受一个字典列表，每个字典代表一个用户。它创建一个 CSV 文件，在其中放入一个标题，然后继续添加所有根据某些规则被视为有效的用户。`export`函数还接受一个文件名，这将是输出的 CSV 的名称。最后，它接受一个指示，是否允许覆盖同名的现有文件。

至于用户，他们必须遵守以下规定：每个用户至少有一个电子邮件、一个名称和一个年龄。可以有第四个字段代表角色，但是它是可选的。用户的电子邮件地址需要是有效的，名称需要是非空的，年龄必须是 18 到 65 之间的整数。

这是我们的任务，所以现在我要向你展示代码，然后我们将分析我为它编写的测试。但首先，在以下代码片段中，我将使用两个第三方库：`marshmallow`和`pytest`。它们都在本书源代码的要求中，所以确保你已经用`pip`安装了它们。

`marshmallow` 是一个很棒的库，它为我们提供了序列化和反序列化对象的能力，最重要的是，它让我们能够定义一个模式，我们可以用它来验证用户字典。`pytest` 是我见过的最好的软件之一。现在它随处可见，并且已经取代了其他工具，比如`nose`。它为我们提供了很好的工具来编写简洁的测试。

但让我们来看看代码。我将它称为`api.py`，只是因为它公开了一个我们可以用来做事情的函数。我会把它分块展示给你：

```py
# api.py
import os
import csv
from copy import deepcopy

from marshmallow import Schema, fields, pre_load
from marshmallow.validate import Length, Range

class UserSchema(Schema):
    """Represent a *valid* user. """

    email = fields.Email(required=True)
    name = fields.String(required=True, validate=Length(min=1))
    age = fields.Integer(
        required=True, validate=Range(min=18, max=65)
    )
    role = fields.String()

    @pre_load(pass_many=False)
    def strip_name(self, data):
        data_copy = deepcopy(data)

        try:
            data_copy['name'] = data_copy['name'].strip()
        except (AttributeError, KeyError, TypeError):
            pass

        return data_copy

schema = UserSchema()
```

这第一部分是我们导入所需的所有模块（`os`和`csv`），以及从`marshmallow`中导入一些工具，然后我们为用户定义模式。正如你所看到的，我们继承自`marshmallow.Schema`，然后设置了四个字段。请注意，我们使用了两个`String`字段，`Email`和`Integer`。这些将已经为我们提供了一些来自`marshmallow`的验证。请注意，在`role`字段中没有`required=True`。

不过，我们需要添加一些自定义的代码。我们需要添加`validate_age`来确保值在我们想要的范围内。如果不是，我们会引发`ValidationError`。而且`marshmallow`会很好地处理除了整数之外的任何值。

接下来，我们添加`validate_name`，因为字典中存在`name`键并不保证名称实际上是非空的。所以我们取它的值，去除所有前导和尾随的空白字符，如果结果为空，我们再次引发`ValidationError`。请注意，我们不需要为`email`字段添加自定义验证器。这是因为`marshmallow`会验证它，而有效的电子邮件不能为空。

然后我们实例化`schema`，这样我们就可以用它来验证数据。所以让我们编写`export`函数：

```py
# api.py
def export(filename, users, overwrite=True):
    """Export a CSV file.

    Create a CSV file and fill with valid users. If `overwrite`
    is False and file already exists, raise IOError.
    """
    if not overwrite and os.path.isfile(filename):
        raise IOError(f"'{filename}' already exists.")

    valid_users = get_valid_users(users)
    write_csv(filename, valid_users)
```

如你所见，它的内部非常简单。如果`overwrite`为`False`并且文件已经存在，我们会引发一个带有文件已经存在的消息的`IOError`。否则，如果我们可以继续，我们只需获取有效用户列表并将其提供给`write_csv`，后者负责实际完成工作。让我们看看这些函数是如何定义的：

```py
# api.py
def get_valid_users(users):
    """Yield one valid user at a time from users. """
    yield from filter(is_valid, users)

def is_valid(user):
    """Return whether or not the user is valid. """
    return not schema.validate(user)
```

事实证明，我将`get_valid_users`编码为生成器，因为没有必要为了将其放入文件而制作一个潜在的大列表。我们可以逐个验证和保存它们。验证的核心是简单地委托给`schema.validate`，它使用`marshmallow`的验证引擎。这样的工作方式是返回一个字典，如果验证成功则为空，否则将包含错误信息。对于这个任务，我们并不真正关心收集错误信息，所以我们简单地忽略它，在`is_valid`中，如果`schema.validate`的返回值为空，我们基本上返回`True`，否则返回`False`。

还缺少最后一部分；在这里：

```py
# api.py
def write_csv(filename, users):
    """Write a CSV given a filename and a list of users.

    The users are assumed to be valid for the given CSV structure.
    """
    fieldnames = ['email', 'name', 'age', 'role']

    with open(filename, 'x', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for user in users:
            writer.writerow(user)
```

同样，逻辑很简单。我们在`fieldnames`中定义标题，然后打开`filename`进行写入，并指定`newline=''`，这在处理 CSV 文件时在文档中是推荐的。文件创建后，我们通过使用`csv.DictWriter`类来获取一个`writer`对象。这个工具的美妙之处在于它能够将用户字典映射到字段名，因此我们不需要关心排序。

我们首先写入标题，然后循环遍历用户并逐个添加它们。请注意，此函数假定它被提供一个有效用户列表，如果这个假设是错误的（使用默认值，如果任何用户字典有额外字段，它将会出错）。

这就是你需要记住的全部代码。我建议你花一点时间再次阅读它。没有必要记住它，而且我使用有意义的名称编写了小的辅助函数，这将使你更容易跟随测试。

现在让我们来到有趣的部分：测试我们的`export`函数。再次，我将把代码分成几部分给你看：

```py
# tests/test_api.py
import os
from unittest.mock import patch, mock_open, call
import pytest
from ..api import is_valid, export, write_csv
```

让我们从导入开始：我们需要`os`、临时目录（我们在第七章中已经看到了，“文件和数据持久性”），然后是`pytest`，最后，我们使用相对导入来获取我们想要实际测试的三个函数：`is_valid`、`export`和`write_csv`。

然而，在我们可以编写测试之前，我们需要制作一些固定装置。正如你将看到的，一个`fixture`是一个被`pytest.fixture`装饰的函数。在大多数情况下，我们期望`fixture`返回一些东西，这样我们就可以在测试中使用它。我们对用户字典有一些要求，所以让我们写一些用户：一个具有最低要求的用户，一个具有完整要求的用户。两者都需要有效。以下是代码：

```py
# tests/test_api.py
@pytest.fixture
def min_user():
    """Represent a valid user with minimal data. """
    return {
        'email': 'minimal@example.com',
        'name': 'Primus Minimus',
        'age': 18,
    }

@pytest.fixture
def full_user():
    """Represent valid user with full data. """
    return {
        'email': 'full@example.com',
        'name': 'Maximus Plenus',
        'age': 65,
        'role': 'emperor',
    }
```

在这个例子中，唯一的区别是存在`role`键，但这足以向你展示我希望的观点。请注意，我们实际上编写了两个返回字典的函数，并且用`pytest.fixture`装饰了它们，而不是简单地在模块级别声明字典。这是因为当你在模块级别声明一个字典，它应该在你的测试中使用，你需要确保在每个测试的开始时复制它。如果不这样做，你可能会有一个修改它的测试，这将影响所有随后的测试，从而损害它们的完整性。

通过使用这些固定装置，`pytest`将在每次测试运行时为我们提供一个新的字典，因此我们不需要自己费心去做。请注意，如果一个固定装置返回另一种类型，而不是字典，那么你将在测试中得到这种类型。固定装置也是*可组合*的，这意味着它们可以相互使用，这是`pytest`的一个非常强大的特性。为了向你展示这一点，让我们为一个用户列表编写一个固定装置，其中我们放入了我们已经有的两个用户，再加上一个因为没有年龄而无法通过验证的用户。让我们看一下下面的代码：

```py
# tests/test_api.py
@pytest.fixture
def users(min_user, full_user):
    """List of users, two valid and one invalid. """
    bad_user = {
        'email': 'invalid@example.com',
        'name': 'Horribilis',
    }
    return [min_user, bad_user, full_user]
```

不错。现在我们有两个可以单独使用的用户，但是我们也有一个包含三个用户的列表。第一轮测试将测试我们如何验证用户。我们将把这个任务的所有测试分组到一个类中。这不仅有助于给相关的测试提供一个命名空间，一个位置，而且，正如我们后面将看到的，它允许我们声明类级别的固定装置，这些装置仅为属于该类的测试定义。看一下这段代码：

```py
# tests/test_api.py
class TestIsValid:
    """Test how code verifies whether a user is valid or not. """
    def test_minimal(self, min_user):
        assert is_valid(min_user)

    def test_full(self, full_user):
        assert is_valid(full_user)
```

我们从非常简单的开始，确保我们的固定装置实际上通过了验证。这非常重要，因为这些固定装置将被用在各个地方，所以我们希望它们是完美的。接下来，我们测试年龄。这里有两件事需要注意：我不会重复类签名，所以接下来的代码缩进了四个空格，因为这些都是同一个类中的方法，好吗？其次，我们将大量使用参数化。

参数化是一种技术，它使我们能够多次运行相同的测试，但提供不同的数据。这是非常有用的，因为它允许我们只编写一次测试而没有重复，而`pytest`会非常智能地处理结果，当测试失败时会运行所有这些测试，从而为我们提供清晰的错误消息。如果你手动进行参数化，你将失去这个特性，相信我你不会高兴。让我们看看如何测试年龄：

```py
# tests/test_api.py
    @pytest.mark.parametrize('age', range(18))
    def test_invalid_age_too_young(self, age, min_user):
        min_user['age'] = age
        assert not is_valid(min_user)
```

好的，所以我们首先编写一个测试，检查当用户年龄太小时验证失败。根据我们的规定，当用户年龄小于 18 岁时，用户年龄太小。我们通过使用`range`检查 0 到 17 岁之间的每个年龄。

如果你看一下参数化是如何工作的，你会看到我们声明了一个对象的名称，然后将其传递给方法的签名，然后指定这个对象将采用哪些值。对于每个值，测试将运行一次。在这个第一个测试的情况下，对象的名称是`age`，值是由`range(18)`返回的所有整数，这意味着从`0`到`17`的所有整数都包括在内。请注意，我们在`self`之后将`age`传递给测试方法，然后我们还做了另一件有趣的事情。我们传递了一个固定装置给这个方法：`min_user`。这将激活该固定装置进行测试运行，以便我们可以使用它，并且可以在测试中引用它。在这种情况下，我们只是改变了`min_user`字典中的年龄，然后我们验证`is_valid(min_user)`的结果是否为`False`。

我们通过断言`not False`是`True`来完成最后一部分。在`pytest`中，这是你检查某事的方式。你只需断言某事是真实的。如果是这样，测试就成功了。如果相反，测试将失败。

让我们继续添加所有需要使年龄验证失败的测试：

```py
# tests/test_api.py
    @pytest.mark.parametrize('age', range(66, 100))
    def test_invalid_age_too_old(self, age, min_user):
        min_user['age'] = age
        assert not is_valid(min_user)

    @pytest.mark.parametrize('age', ['NaN', 3.1415, None])
    def test_invalid_age_wrong_type(self, age, min_user):
        min_user['age'] = age
        assert not is_valid(min_user)
```

接下来是另外两个测试。一个负责处理年龄范围的另一端，从 66 岁到 99 岁。另一个则确保当年龄不是整数时是无效的，因此我们传递一些值，比如字符串、浮点数和`None`，只是为了确保。请注意测试的结构基本上总是相同的，但是由于参数化的原因，我们向其提供了非常不同的输入参数。

现在我们已经解决了年龄验证失败的问题，让我们添加一个实际检查年龄是否在有效范围内的测试：

```py
# tests/test_api.py
    @pytest.mark.parametrize('age', range(18, 66))
    def test_valid_age(self, age, min_user):
        min_user['age'] = age
        assert is_valid(min_user)
```

就是这么简单。我们传递了正确的范围，从`18`到`65`，并在断言中去掉了`not`。请注意，所有测试都以`test_`前缀开头，并且具有不同的名称。

我们可以考虑年龄已经被照顾到了。让我们继续编写关于必填字段的测试：

```py
# tests/test_api.py
    @pytest.mark.parametrize('field', ['email', 'name', 'age'])
    def test_mandatory_fields(self, field, min_user):
        min_user.pop(field)
        assert not is_valid(min_user)

    @pytest.mark.parametrize('field', ['email', 'name', 'age'])
    def test_mandatory_fields_empty(self, field, min_user):
        min_user[field] = ''
        assert not is_valid(min_user)

```

```py
    def test_name_whitespace_only(self, min_user):
        min_user['name'] = ' \n\t'
        assert not is_valid(min_user)
```

前面的三个测试仍然属于同一个类。第一个测试检查当必填字段中有一个缺失时用户是否无效。请注意，在每次测试运行时，`min_user` fixture 都会被恢复，因此每次测试运行只有一个缺失字段，这是检查必填字段的适当方式。我们只需从字典中弹出键。这次参数化对象采用了`field`名称，并且通过查看第一个测试，您可以看到参数化装饰器中的所有必填字段：`email`，`name`和`age`。

在第二个测试中，情况有些不同。我们不是弹出键，而是简单地将它们（一个接一个）设置为空字符串。最后，在第三个测试中，我们检查姓名是否只由空格组成。

前面的测试处理了必填字段的存在和非空，以及用户的`name`键周围的格式。很好。现在让我们为这个类编写最后两个测试。我们想要检查电子邮件的有效性，以及电子邮件，姓名和角色的类型：

```py
# tests/test_api.py
    @pytest.mark.parametrize(
        'email, outcome',
        [
            ('missing_at.com', False),
            ('@missing_start.com', False),
            ('missing_end@', False),
            ('missing_dot@example', False),

            ('good.one@example.com', True),
            ('δοκιμή@παράδειγμα.δοκιμή', True),
            ('аджай@экзампл.рус', True),
        ]
    )
    def test_email(self, email, outcome, min_user):
        min_user['email'] = email
        assert is_valid(min_user) == outcome
```

这次，参数化略微复杂。我们定义了两个对象（`email`和`outcome`），然后我们将一个元组的列表，而不是一个简单的列表，传递给装饰器。发生的情况是每次运行测试时，其中一个元组将被解包以填充`email`和`outcome`的值。这使我们能够为有效和无效的电子邮件地址编写一个测试，而不是两个单独的测试。我们定义了一个电子邮件地址，并指定了我们期望的验证结果。前四个是无效的电子邮件地址，但最后三个实际上是有效的。我使用了一些包含 Unicode 的例子，只是为了确保我们没有忘记在验证中包括来自世界各地的朋友。

注意验证是如何进行的，断言调用的结果需要与我们设置的结果匹配。

现在让我们编写一个简单的测试，以确保当我们向字段提供错误类型时验证失败（再次强调，年龄已经单独处理）：

```py
# tests/test_api.py
    @pytest.mark.parametrize(
        'field, value',
        [
            ('email', None),
            ('email', 3.1415),
            ('email', {}),

            ('name', None),
            ('name', 3.1415),
            ('name', {}),

            ('role', None),
            ('role', 3.1415),
            ('role', {}),
        ]
    )
    def test_invalid_types(self, field, value, min_user):
        min_user[field] = value
        assert not is_valid(min_user)
```

就像以前一样，只是为了好玩，我们传递了三个不同的值，其中没有一个实际上是字符串。这个测试可以扩展到包括更多的值，但是，老实说，我们不应该需要编写这样的测试。我在这里包括它只是为了向您展示可能的情况。

在我们转到下一个测试类之前，让我谈谈我们在检查年龄时看到的一些东西。

# 边界和粒度

在检查年龄时，我们编写了三个测试来覆盖三个范围：0-17（失败），18-65（成功），66-99（失败）。为什么我们要这样做呢？答案在于我们正在处理两个边界：18 和 65。因此，我们的测试需要集中在这两个边界定义的三个区域上：18 之前，18 和 65 之间，以及 65 之后。你如何做并不重要，只要确保正确测试边界。这意味着如果有人将模式中的验证从`18 <= value <= 65`更改为`18 <= value < 65`（注意缺少`=`），必须有一个测试在`65`处失败。

这个概念被称为**边界**，非常重要的是你能够在代码中识别它们，以便你可以针对它们进行测试。

另一个重要的事情是要理解我们想要接近边界的缩放级别。换句话说，我应该使用哪个单位来在其周围移动？在年龄的情况下，我们处理整数，因此单位`1`将是完美的选择（这就是为什么我们使用`16`、`17`、`18`、`19`、`20`等）。但如果你要测试时间戳呢？嗯，在这种情况下，正确的粒度可能会有所不同。如果代码必须根据您的时间戳以不同方式运行，并且该时间戳代表秒，则您的测试的粒度应该缩小到秒。如果时间戳代表年份，则年份应该是您使用的单位。希望你明白了。这个概念被称为**粒度**，需要与边界的概念结合起来，这样通过以正确的粒度绕过边界，您可以确保您的测试不会留下任何机会。

现在让我们继续我们的例子，并测试`export`函数。

# 测试导出函数

在同一个测试模块中，我定义了另一个类，代表了`export`函数的测试套件。在这里：

```py
# tests/test_api.py
class TestExport:

    @pytest.fixture
    def csv_file(self, tmpdir):
        yield tmpdir.join("out.csv")

    @pytest.fixture
    def existing_file(self, tmpdir):
        existing = tmpdir.join('existing.csv')
        existing.write('Please leave me alone...')
        yield existing
```

让我们开始理解装置。这次我们在类级别定义了它们，这意味着它们只在类中的测试运行时存在。我们在这个类之外不需要这些装置，所以在模块级别声明它们就没有意义，就像我们在用户装置中所做的那样。

因此，我们需要两个文件。如果您回忆一下我在本章开头写的内容，当涉及与数据库、磁盘、网络等的交互时，我们应该将所有东西都模拟出来。但是，如果可能的话，我更喜欢使用一种不同的技术。在这种情况下，我将使用临时文件夹，它们将在装置内诞生，并在其中死去，不留下任何痕迹。如果可以避免模拟，我会更加开心。模拟是很棒的，但除非做得正确，否则它可能会很棘手，并且是错误的源泉。

现在，第一个装置`csv_file`定义了一个受控上下文，在其中我们获得了对临时文件夹的引用。我们可以认为逻辑直到`yield`为止的部分是设置阶段。就数据而言，装置本身由临时文件名表示。文件本身尚不存在。当测试运行时，装置被创建，并且在测试结束时，装置代码的其余部分（如果有的话）被执行。这部分可以被认为是拆卸阶段。在这种情况下，它包括退出上下文管理器，这意味着临时文件夹被删除（以及其所有内容）。您可以在任何装置的每个阶段中放入更多内容，并且通过经验，我相信您很快就能掌握以这种方式进行设置和拆卸的艺术。这实际上非常自然地很快就会掌握。

第二个装置与第一个非常相似，但我们将用它来测试当我们使用`overwrite=False`调用`export`时是否可以防止覆盖。因此，我们在临时文件夹中创建一个文件，并将一些内容放入其中，以便验证它没有被修改。

请注意，两个装置都返回了带有完整路径信息的文件名，以确保我们实际上在我们的代码中使用了临时文件夹。现在让我们看看测试：

```py
# tests/test_api.py
    def test_export(self, users, csv_file):
        export(csv_file, users)

        lines = csv_file.readlines()

        assert [
            'email,name,age,role\n',
            'minimal@example.com,Primus Minimus,18,\n',
            'full@example.com,Maximus Plenus,65,emperor\n',
        ] == lines
```

这个测试使用了`users`和`csv_file`装置，并立即调用了`export`。我们期望已经创建了一个文件，并用我们拥有的两个有效用户填充了它（记住列表包含三个用户，但一个是无效的）。

为了验证这一点，我们打开临时文件，并将其所有行收集到一个列表中。然后，我们将文件的内容与我们期望在其中的行的列表进行比较。请注意，我们只按正确顺序放置了标题和两个有效用户。

现在我们需要另一个测试，以确保如果一个值中有逗号，我们的 CSV 仍然可以正确生成。作为**逗号分隔值**（**CSV**）文件，我们需要确保数据中的逗号不会导致问题：

```py
# tests/test_api.py
    def test_export_quoting(self, min_user, csv_file):
        min_user['name'] = 'A name, with a comma'

        export(csv_file, [min_user])

        lines = csv_file.readlines()
        assert [
            'email,name,age,role\n',
            'minimal@example.com,"A name, with a comma",18,\n',
        ] == lines
```

这一次，我们不需要整个用户列表，我们只需要一个，因为我们正在测试一个特定的事情，并且我们有之前的测试来确保我们正确生成了包含所有用户的文件。记住，尽量在测试中最小化你的工作。

因此，我们使用`min_user`，并在其名称中放一个漂亮的逗号。然后我们重复之前测试的过程，这与前一个测试非常相似，最后我们确保名称被放入由双引号括起来的 CSV 文件中。这对于任何良好的 CSV 解析器来说已经足够了，它们不会因为双引号内的逗号而出错。

现在我想再做一个测试，需要检查文件是否存在，如果我们不想覆盖它，我们的代码就不会触及它：

```py
# tests/test_api.py
    def test_does_not_overwrite(self, users, existing_file):
        with pytest.raises(IOError) as err:
            export(existing_file, users, overwrite=False)

        assert err.match(
            r"'{}' already exists\.".format(existing_file)
        )

        # let's also verify the file is still intact
        assert existing_file.read() == 'Please leave me alone...'
```

这是一个很好的测试，因为它让我可以向你展示如何告诉`pytest`你期望一个函数调用引发一个异常。我们在`pytest.raises`给我们的上下文管理器中这样做，我们在这个上下文管理器的主体内部调用中提供我们期望的异常。如果异常没有被引发，测试将失败。

我喜欢在我的测试中做到彻底，所以我不想止步于此。我还通过使用方便的`err.match`助手来断言消息（注意，它接受正则表达式，而不是简单的字符串-我们将在第十四章中看到正则表达式，*Web Development*）。

最后，让我们确保文件仍然包含其原始内容（这就是我创建`existing_file` fixture 的原因），方法是打开它，并将其所有内容与应该是的字符串进行比较。

# 最后的考虑

在我们继续下一个话题之前，让我用一些考虑来总结。

首先，我希望您已经注意到我没有测试我编写的所有函数。具体来说，我没有测试`get_valid_users`，`validate`和`write_csv`。原因是因为这些函数已经被我们的测试套件隐式测试过了。我们已经测试了`is_valid`和`export`，这已经足够确保我们的模式正确验证用户，并且`export`函数在需要时正确处理过滤无效用户，并正确地写入 CSV。我们没有测试的函数是内部函数，它们提供的逻辑已经在我们彻底测试过的操作中发挥了作用。为这些函数添加额外的测试是好还是坏？请思考一下。

答案实际上很难。你测试得越多，你就越不能重构那段代码。就目前而言，我可以轻松地决定以另一个名称调用`is_valid`，而不必更改任何测试。如果你仔细想想，这是有道理的，因为只要`is_valid`正确验证`get_valid_users`函数，我就不需要知道它的具体情况。这对你有意义吗？

如果我要测试`validate`函数，那么如果我决定以不同的方式调用它（或者以某种方式更改其签名），我将不得不更改它们。

那么，应该做什么？测试还是不测试？这取决于你。你必须找到合适的平衡。我个人对这个问题的看法是，一切都需要经过彻底的测试，无论是直接还是间接地。我希望测试套件尽可能小，但能够保证我有很好的覆盖率。这样，我将拥有一个很好的测试套件，但不会比必要的更大。你需要维护这些测试！

我希望这个例子对您有意义，我认为它让我触及了重要的话题。

如果你查看本书的源代码，在`test_api.py`模块中，我添加了几个额外的测试类，这将展示如果我决定完全使用模拟测试，不同的测试方式会是什么样子。确保你阅读并充分理解这段代码。它非常直接，将为你提供一个与我个人方法的良好比较。

现在，我们来运行这些测试吧？（输出已重新排列以适应本书的格式）：

```py
$ pytest tests
====================== test session starts ======================
platform darwin -- Python 3.7.0b2, pytest-3.5.0, py-1.5.3, ...
rootdir: /Users/fab/srv/lpp/ch8, inifile:
collected 132 items

tests/test_api.py ...............................................
.................................................................
.................... [100%]

================== 132 passed in 0.41 seconds ===================
```

确保你在`ch8`文件夹中运行`$ pytest test`（添加`-vv`标志以获得详细输出，显示参数化如何修改测试名称）。正如你所看到的，少于半秒内运行了`132`个测试，它们全部都成功了。我强烈建议你查看这段代码并进行调试。更改代码中的某些内容，看看是否有任何测试失败。理解为什么会失败。这是因为测试不够好的重要原因吗？还是因为一些愚蠢的原因导致测试失败？所有这些看似无害的问题都将帮助你深入了解测试的艺术。

我还建议你学习`unittest`模块和`pytest`。这些是你将经常使用的工具，所以你需要非常熟悉它们。

现在让我们来看看测试驱动开发！

# 测试驱动开发

让我们简要谈谈**测试驱动开发**（**TDD**）。这是一种方法论，由肯特·贝克重新发现，他写了《通过示例驱动开发》，*Addison Wesley, 2002*，我鼓励你查看一下，如果你想学习这个主题的基础知识。

TDD 是一种基于非常短的开发周期的持续重复的软件开发方法论。

首先，开发人员编写一个测试，并使其运行。测试应该检查代码中尚未存在的功能。也许是要添加的新功能，或者要删除或修改的内容。运行测试会使其失败，因此这个阶段被称为**红色**。

当测试失败时，开发人员编写最少量的代码使其通过。当运行测试成功时，我们进入了所谓的**绿色**阶段。在这个阶段，编写欺骗性代码只是为了让测试通过是可以接受的。这种技术被称为*假装直到你成功为止*。在第二个阶段，测试用例会丰富起来，包括不同的边界情况，然后欺骗性代码必须用适当的逻辑进行重写。添加其他测试用例被称为**三角测量**。

循环的最后一部分是开发人员在不同的时间处理代码和测试，并对它们进行重构，直到它们达到期望的状态。这最后阶段被称为**重构**。

因此，**TDD**的口头禅是**红-绿-重构**。

一开始，先编写代码然后再编写测试会感觉非常奇怪，我必须承认我花了一段时间才习惯。然而，如果你坚持下去，并强迫自己学习这种略微违反直觉的工作方式，某个时刻几乎会发生一些近乎神奇的事情，你会看到你的代码质量以一种其他方式不可能的方式提高。

当你在编写代码之前编写测试时，你必须同时关注代码的*作用*和*如何*实现它。另一方面，当你在编写代码之前编写测试时，你可以在编写测试时只专注于*作用*部分。当你之后编写代码时，你将主要关注代码如何实现测试所需的*作用*。这种关注焦点的转变允许你的大脑在不同的时刻专注于*作用*和*如何*部分，从而提供了一种令人惊讶的大脑能量提升。

采用这种技术还有其他几个好处：

+   您将更有信心地进行重构：如果引入错误，测试将会失败。此外，架构重构也将受益于具有充当守护者的测试。

+   代码将更易读：在我们这个时代，编码是一种社交活动，每个专业开发人员花在阅读代码上的时间远远超过编写代码的时间。

+   代码将更松散耦合且更易于测试和维护：首先编写测试会迫使您更深入地思考代码结构。

+   首先编写测试要求您对业务需求有更好的理解：如果您对需求的理解缺乏信息，您会发现编写测试非常具有挑战性，这种情况对您来说是一个警示。

+   拥有完整的单元测试意味着代码将更容易调试：此外，小测试非常适合提供替代文档。英语可能会误导，但在简单测试中的五行 Python 很难误解。

+   更高的速度：编写测试和代码比先编写代码然后花时间调试要快。如果您不编写测试，您可能会更快地交付代码，但然后您将不得不追踪错误并解决它们（可以肯定会有错误）。编写代码然后调试所花费的时间通常比使用 TDD 开发代码的时间长，因为在编写代码之前运行测试，确保其中的错误数量要比另一种情况下少得多。

另一方面，这种技术的主要缺点如下：

+   整个公司都需要相信它：否则，您将不得不不断地与老板争论，他不会理解为什么您花费这么长时间交付。事实是，短期内您可能需要更长时间才能交付，但从长远来看，您会因 TDD 获得很多。然而，很难看到长期效果，因为它不像短期效果那样显而易见。在我的职业生涯中，我与固执的老板进行了激烈的斗争，以便能够使用 TDD 进行编码。有时这是痛苦的，但总是值得的，我从未后悔，因为最终结果的质量总是受到赞赏。

+   如果您未能理解业务需求，这将反映在您编写的测试中，因此也将反映在代码中：这种问题很难发现，直到进行用户验收测试，但您可以做的一件事是与另一位开发人员合作。合作将不可避免地需要讨论业务需求，讨论将带来澄清，这将有助于编写正确的测试。

+   糟糕编写的测试很难维护：这是事实。测试中有太多的模拟或额外的假设或结构不良的数据很快就会成为负担。不要让这使您灰心；继续尝试并改变编写测试的方式，直到找到一种不需要您每次触及代码时都需要大量工作的方式。

我对 TDD 非常热衷。当我面试工作时，我总是问公司是否采用它。我鼓励你去了解并使用它。使用它直到你觉得有所领悟。我保证你不会后悔。

# 例外情况

尽管我还没有正式向您介绍它们，但我现在希望您至少对异常有一个模糊的概念。在前几章中，我们已经看到当迭代器耗尽时，调用`next`会引发`StopIteration`异常。当我们尝试访问列表中超出有效范围的位置时，我们遇到了`IndexError`。当我们尝试访问对象上没有的属性时，我们也遇到了`AttributeError`，当我们尝试使用键和字典时，我们遇到了`KeyError`。

现在是时候谈论异常了。

有时，即使操作或代码是正确的，也有可能出现某些条件会出错。例如，如果我们将用户输入从`string`转换为`int`，用户可能会意外地在数字的位置上输入字母，这样我们就无法将该值转换为数字。在进行数字除法时，我们可能事先不知道是否会尝试进行除以零的除法。在打开文件时，文件可能丢失或损坏。

在执行过程中检测到错误时，称为**异常**。异常并不一定是致命的；事实上，我们已经看到`StopIteration`深度集成在 Python 生成器和迭代器机制中。不过，通常情况下，如果您不采取必要的预防措施，异常将导致应用程序中断。有时，这是期望的行为，但在其他情况下，我们希望预防和控制这样的问题。例如，我们可能会警告用户，他们试图打开的文件损坏或丢失，以便他们可以修复它或提供另一个文件，而无需因此问题而使应用程序中断。让我们看一些异常的例子：

```py
# exceptions/first.example.py
>>> gen = (n for n in range(2))
>>> next(gen)
0
>>> next(gen)
1
>>> next(gen)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
StopIteration
>>> print(undefined_name)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
NameError: name 'undefined_name' is not defined
>>> mylist = [1, 2, 3]
>>> mylist[5]
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> mydict = {'a': 'A', 'b': 'B'}
>>> mydict['c']
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
KeyError: 'c'
>>> 1 / 0
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
```

正如您所看到的，Python shell 非常宽容。我们可以看到`Traceback`，这样我们就可以获得有关错误的信息，但程序不会中断。这是一种特殊的行为，通常情况下，如果没有处理异常，常规程序或脚本通常会中断。

要处理异常，Python 为您提供了`try`语句。当进入`try`子句时，Python 将监视一个或多个不同类型的异常（根据您的指示），如果它们被引发，它将允许您做出反应。`try`语句由`try`子句组成，它打开语句，一个或多个`except`子句（全部可选），定义了在捕获异常时要执行的操作，一个`else`子句（可选），当`try`子句在没有引发任何异常的情况下退出时执行，以及一个`finally`子句（可选），其代码无论其他子句中发生了什么都会执行。`finally`子句通常用于清理资源（我们在第七章中看到过，*文件和数据持久性*，当我们在没有使用上下文管理器的情况下打开文件时）。

注意顺序——这很重要。此外，`try`后面必须至少跟一个`except`子句或一个`finally`子句。让我们看一个例子：

```py
# exceptions/try.syntax.py
def try_syntax(numerator, denominator):
    try:
        print(f'In the try block: {numerator}/{denominator}')
        result = numerator / denominator
    except ZeroDivisionError as zde:
        print(zde)
    else:
        print('The result is:', result)
        return result
    finally:
        print('Exiting')

print(try_syntax(12, 4))
print(try_syntax(11, 0))
```

前面的例子定义了一个简单的`try_syntax`函数。我们执行两个数字的除法。如果我们用`denominator = 0`调用函数，我们准备捕获`ZeroDivisionError`异常。最初，代码进入`try`块。如果`denominator`不是`0`，则计算`result`并在离开`try`块后在`else`块中恢复执行。我们打印`result`并返回它。看一下输出，你会注意到在返回`result`之前，也就是函数的退出点，Python 执行`finally`子句。

当`denominator`为`0`时，情况就会改变。我们进入`except`块并打印`zde`。`else`块不会被执行，因为在`try`块中引发了异常。在（隐式）返回`None`之前，我们仍然执行`finally`块。看一下输出，看看它对您是否有意义：

```py
$ python try.syntax.py
In the try block: 12/4     # try
The result is: 3.0         # else
Exiting                    # finally
3.0                        # return within else

In the try block: 11/0     # try
division by zero           # except
Exiting                    # finally
None                       # implicit return end of function
```

当执行`try`块时，您可能希望捕获多个异常。例如，当尝试解码 JSON 对象时，可能会遇到`ValueError`（JSON 格式不正确）或`TypeError`（传递给`json.loads()`的数据类型不是字符串）。在这种情况下，您可以像这样构造代码：

```py
# exceptions/json.example.py
import json
json_data = '{}'

try:
    data = json.loads(json_data)
except (ValueError, TypeError) as e:
    print(type(e), e)
```

这段代码将捕获`ValueError`和`TypeError`。尝试将`json_data = '{}'`更改为`json_data = 2`或`json_data = '{{'`，您将看到不同的输出。

如果要以不同方式处理多个异常，只需添加更多的`except`子句，就像这样：

```py
# exceptions/multiple.except.py
try:
    # some code
except Exception1:
    # react to Exception1
except (Exception2, Exception3):
    # react to Exception2 or Exception3
except Exception4:
    # react to Exception4
...
```

请记住，异常在首次定义该异常类或其任何基类的块中处理。因此，当您像我们刚刚做的那样堆叠多个`except`子句时，请确保将特定的异常放在顶部，将通用的异常放在底部。在面向对象编程术语中，子类在顶部，祖先类在底部。此外，请记住，当引发异常时，只有一个`except`处理程序被执行。

您还可以编写**自定义异常**。要做到这一点，您只需从任何其他异常类继承。Python 内置的异常太多，无法在此列出，因此我必须指向官方文档。要知道的一件重要的事情是，每个 Python 异常都派生自`BaseException`，但您的自定义异常不应直接从它继承。原因是处理这样的异常也会捕获**系统退出异常**，例如`SystemExit`和`KeyboardInterrupt`，它们派生自`BaseException`，这可能会导致严重问题。在灾难发生时，您希望能够通过*Ctrl* + *C*退出应用程序。

您可以通过从`Exception`继承来轻松解决这个问题，它从`BaseException`继承，但在其子类中不包括任何系统退出异常，因为它们在内置异常层次结构中是同级的（参见[`docs.python.org/3/library/exceptions.html#exception-hierarchy`](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)）。

使用异常进行编程可能非常棘手。您可能会无意中消除错误，或者捕获不应该处理的异常。通过牢记一些准则来确保安全：只在`try`子句中放入可能引发您想要处理的异常的代码。当编写`except`子句时，尽可能具体，不要只是使用`except Exception`，因为这样很容易。使用测试来确保您的代码以需要尽可能少的异常处理来处理边缘情况。编写`except`语句而不指定任何异常将捕获任何异常，因此使您的代码面临与将自定义异常从`BaseException`派生时一样的风险。

您几乎可以在网上的任何地方找到有关异常的信息。一些程序员大量使用它们，而其他人则节俭使用。通过从其他人的源代码中获取示例，找到自己处理异常的方法。在 GitHub（[`github.com`](https://github.com)）和 Bitbucket（[`bitbucket.org/`](https://bitbucket.org/)）等网站上有许多有趣的开源项目。

在谈论性能分析之前，让我向您展示异常的非常规用法，以便为您提供一些帮助，帮助您扩展对它们的看法。它们不仅仅是简单的错误：

```py
# exceptions/for.loop.py
n = 100
found = False
for a in range(n):
    if found: break
    for b in range(n):
        if found: break
        for c in range(n):
            if 42 * a + 17 * b + c == 5096:
                found = True
                print(a, b, c)  # 79 99 95
```

前面的代码是处理数字时的常见习语。您必须迭代几个嵌套范围，并寻找满足条件的特定`a`、`b`和`c`的组合。在示例中，条件是一个微不足道的线性方程，但想象一些比这更酷的东西。让我困扰的是每次循环开始时都要检查解决方案是否已找到，以便在找到解决方案时尽快跳出循环。跳出逻辑会干扰其他代码，我不喜欢这样，所以我想出了另一种解决方案。看看它，并看看你是否也可以将其适应到其他情况：

```py
# exceptions/for.loop.py
class ExitLoopException(Exception):
    pass

try:
    n = 100
    for a in range(n):
        for b in range(n):
            for c in range(n):
                if 42 * a + 17 * b + c == 5096:
                    raise ExitLoopException(a, b, c)
except ExitLoopException as ele:
    print(ele)  # (79, 99, 95)
```

您能看到它有多么优雅吗？现在，跳出逻辑完全由一个简单的异常处理，甚至其名称都暗示了其目的。一旦找到结果，我们就会引发它，立即将控制权交给处理它的`except`子句。这是一个值得思考的问题。这个例子间接地向您展示了如何引发自己的异常。阅读官方文档，深入了解这个主题的美丽细节。

此外，如果你想挑战一下，你可能想尝试将最后一个例子转换为嵌套`for`循环的上下文管理器。祝你好运！

# Python 分析

有几种不同的方法来分析 Python 应用程序。分析意味着在应用程序运行时跟踪几个不同的参数，例如函数被调用的次数和在其中花费的时间。分析可以帮助我们找到应用程序中的瓶颈，以便我们只改进真正拖慢我们的部分。

如果你查看标准库官方文档中的分析部分，你会看到同一分析接口的几种不同实现——`profile`和`cProfile`：

+   `cProfile`建议大多数用户使用，它是一个 C 扩展，具有合理的开销，适用于对长时间运行的程序进行分析

+   `profile`是一个纯 Python 模块，其接口被`cProfile`模仿，但对被分析的程序增加了显著的开销

这个接口进行**确定性分析**，这意味着所有函数调用、函数返回和异常事件都受到监视，并且对这些事件之间的时间间隔进行了精确的计时。另一种方法，称为**统计分析**，随机抽样有效指令指针，并推断时间花费在哪里。

后者通常的开销较小，但提供的结果只是近似的。此外，由于 Python 解释器运行代码的方式，确定性分析并没有增加太多开销，所以我会向你展示一个简单的例子，使用命令行中的`cProfile`。

我们将使用以下代码计算勾股数（我知道，你们已经错过了它们...）：

```py
# profiling/triples.py
def calc_triples(mx):
    triples = []
    for a in range(1, mx + 1):
        for b in range(a, mx + 1):
            hypotenuse = calc_hypotenuse(a, b)
            if is_int(hypotenuse):
                triples.append((a, b, int(hypotenuse)))
    return triples

def calc_hypotenuse(a, b):
    return (a**2 + b**2) ** .5

def is_int(n):  # n is expected to be a float
    return n.is_integer()

triples = calc_triples(1000)
```

这个脚本非常简单；我们用`a`和`b`（通过设置`b >= a`来避免对成对的重复）迭代区间[`1`, `mx`]，并检查它们是否属于直角三角形。我们使用`calc_hypotenuse`来获取`a`和`b`的`hypotenuse`，然后，用`is_int`，我们检查它是否是一个整数，这意味着(*a*, *b*, *c*)是一个勾股数。当我们对这个脚本进行分析时，我们得到了表格形式的信息。列是`ncalls`、`tottime`、`percall`、`cumtime`、`percall`和`filename:lineno(function)`。它们代表我们对一个函数的调用次数，我们在其中花费的时间等等。我会删除一些列以节省空间，所以如果你自己运行分析——不要担心如果你得到不同的结果。这是代码：

```py
$ python -m cProfile triples.py
1502538 function calls in 0.704 seconds
Ordered by: standard name

ncalls tottime percall filename:lineno(function)
500500   0.393   0.000 triples.py:17(calc_hypotenuse)
500500   0.096   0.000 triples.py:21(is_int)
 1   0.000   0.000 triples.py:4(<module>)
 1   0.176   0.176 triples.py:4(calc_triples)
 1   0.000   0.000 {built-in method builtins.exec}
 1034   0.000   0.000 {method 'append' of 'list' objects}
 1   0.000   0.000 {method 'disable' of '_lsprof.Profil...
500500   0.038   0.000 {method 'is_integer' of 'float' objects}
```

即使有限的数据，我们仍然可以推断出关于这段代码的一些有用信息。首先，我们可以看到我们选择的算法的时间复杂度随着输入规模的平方增长。我们进入内部循环体的次数恰好是*mx (mx + 1) / 2*。我们使用`mx = 1000`运行脚本，这意味着我们在内部的`for`循环中进入了`500500`次。在循环内发生了三件主要的事情：我们调用`calc_hypotenuse`，我们调用`is_int`，并且如果条件满足，我们将其附加到`triples`列表中。

查看分析报告，我们注意到算法在`calc_hypotenuse`内花费了`0.393`秒，这比在`is_int`内花费的`0.096`秒要多得多，考虑到它们被调用了相同的次数，所以让我们看看是否可以稍微提高`calc_hypotenuse`。

事实证明，我们可以。正如我在本书前面提到的，`**`幂运算符是非常昂贵的，在`calc_hypotenuse`中，我们使用了三次。幸运的是，我们可以很容易地将其中两个转换为简单的乘法，就像这样：

```py
def calc_hypotenuse(a, b): 
    return (a*a + b*b) ** .5 
```

这个简单的改变应该会改善事情。如果我们再次运行分析，我们会看到`0.393`现在降到了`0.137`。不错！这意味着现在我们只花费了大约 37%的时间在`calc_hypotenuse`内，这比以前少了。

让我们看看是否我们也可以改进`is_int`，通过像这样改变它：

```py
def is_int(n): 
    return n == int(n) 
```

这个实现是不同的，它的优势在于当`n`是整数时也能工作。然而，当我们对其进行性能分析时，我们发现`is_int`函数内部所花费的时间增加到了`0.135`秒，因此在这种情况下，我们需要恢复到先前的实现。你可以在本书的源代码中找到这三个版本。

当然，这个例子很琐碎，但足以向你展示如何对应用程序进行性能分析。了解针对函数执行的调用数量有助于我们更好地理解算法的时间复杂度。例如，你不会相信有多少程序员没有意识到这两个`for`循环与输入大小的平方成比例地运行。

需要提到的一点是：根据你使用的系统不同，结果可能会有所不同。因此，能够在尽可能接近软件部署的系统上进行软件性能分析非常重要，如果可能的话，甚至直接在部署的系统上进行。

# 何时进行性能分析？

性能分析非常酷，但我们需要知道何时适当进行性能分析，以及我们需要如何处理从中得到的结果。

唐纳德·克努斯曾说过，<q class="calibre30">*"过早优化是万恶之源"*</q>，尽管我不会用这么激烈的措辞来表达，但我同意他的观点。毕竟，我有什么资格不同意那个给我们带来*计算机编程艺术*、*TeX*以及我在大学时期学习过的一些最酷的算法的人呢？

因此，首要的是*正确性*。你希望你的代码能够提供正确的结果，因此编写测试，找到边缘情况，并以你认为有意义的每种方式来测试你的代码。不要保守，不要把事情放在脑后，因为你认为它们不太可能发生。要彻底。

第二，要注意编码*最佳实践*。记住以下内容——可读性、可扩展性、松散耦合、模块化和设计。应用面向对象的原则：封装、抽象、单一责任、开闭原则等等。深入了解这些概念。它们将为你打开新的视野，扩展你对代码的思考方式。

第三，*像野兽一样重构！*童子军规则说：

*"永远把营地留得比你找到时更干净*。"

将这条规则应用到你的代码中。

最后，当所有这些都已经处理好了，那么并且只有那时，才开始优化和性能分析。

运行你的性能分析器并识别瓶颈。当你有了需要解决的瓶颈的想法时，首先从最严重的问题开始。有时，修复一个瓶颈会引起连锁反应，会扩展和改变代码的工作方式。有时这只是一点点，有时更多一些，这取决于你的代码是如何设计和实现的。因此，首先解决最大的问题。

Python 如此受欢迎的一个原因是可以用许多不同的方式来实现它。因此，如果你发现自己在纯粹使用 Python 时遇到了困难，没有什么能阻止你卷起袖子，买上 200 升咖啡，然后用 C 语言重写代码中的慢部分——保证会很有趣！

# 总结

在本章中，我们探讨了测试、异常和性能分析的世界。

我试图为你提供一个相当全面的测试概述，特别是单元测试，这是开发人员主要进行的测试类型。我希望我已经成功地传达了测试不是一件可以从书本上完美定义并学习的事情。在你感到舒适之前，你需要大量地进行实验。在所有程序员必须进行的学习和实验中，我认为测试是最重要的。

我们简要地看到了如何防止我们的程序因为运行时发生的错误（称为异常）而死掉。为了远离通常的领域，我给了你一个有点不寻常的异常使用的例子，用来跳出嵌套的`for`循环。这并不是唯一的情况，我相信随着你作为编程人员的成长，你会发现其他情况。

最后，我们简要地触及了性能分析，给出了一个简单的例子和一些指导方针。我想谈谈性能分析是为了完整起见，这样至少你可以尝试一下。

在下一章中，我们将探索神奇的秘密世界，哈希和创建令牌。

我知道在本章中我给了你很多指针，但没有链接或方向。我害怕这是有意为之的。作为一个编程人员，在工作中不会有一天你不需要在文档页面、手册、网站等上查找信息。我认为对于一个编程人员来说，能够有效地搜索他们需要的信息是至关重要的，所以希望你能原谅我这额外的训练。毕竟，这都是为了你的利益。
