# 第十五章：评估

# 第一章

1.  将项目特定的 Python 软件包和依赖项与其他项目和系统级 Python 软件包隔离开来。

1.  不。您可以随时重新生成虚拟环境并重新安装软件包。

1.  保持 Python 项目依赖的所有 Python 软件包（和版本）的列表。拥有一个维护良好的`requirements.txt`文件可以让您通过`pip install -r requirements.txt`命令轻松重新安装所有软件包。

1.  确保您使用的是虚拟环境的`bin`文件夹中的 Python 解释器的绝对路径。

1.  它激活了一个虚拟环境，以便 Python 和 pip 的所有用户都被隔离到虚拟环境中。

1.  `deactivate`。如果您输入`exit`（我们有时都会这样做！），它会退出终端窗口或关闭远程 SSH 会话！Grrrrr。

1.  是的，只需切换到`projects`文件夹并激活虚拟环境。

1.  Python IDLE，但请记住，您需要在虚拟环境中使用`python -m idlelib.idle [filename] &`。

1.  检查在 Raspbian 中是否已启用了 I2C 接口。

# 第二章

1.  按照答案编号排序，这样您就不会损坏其他组件或电阻器...除非您了解不同值将如何影响电子电路并且这样做是安全的。

1.  错误。GPIO Zero 是其他 GPIO 库的封装。它旨在通过隐藏较低级别的 GPIO 接口细节，使初学者易于使用。

1.  错误。在许多情况下，最好使用成熟的高级软件包，因为它们将有助于加快开发速度。Python API 文档也推荐这种方法。

1.  不。LED 具有正（阳极）和负（阴极）端子（腿），必须正确连接。

1.  有可能设备的时区处理存在不匹配。

1.  `signal.pause()`

# 第三章

1.  我们可以创建和配置一个`RequestParser`的实例。我们在我们的控制器处理程序方法中使用这个实例，比如`.get()`或`.post()`来验证客户端的请求。

1.  WebSockets - 使用 Web Sockets 构建的客户端和服务器可以在任何方向上相互发起请求。这与 RESTful API 服务形成对比，后者只有客户端可以向服务器发起请求。

1.  Flask-SocketIO 不包括像 Flask-RESTful 那样的内置验证类。您必须手动执行输入验证。或者，您也可以从 PyPi.org 找到一个合适的第三方 Python 模块来使用。

1.  `templates`文件夹是 Flask 框架查找模板文件的默认位置。在这个位置，我们存储我们的 HTML 页面和模板。

1.  我们应该在文档准备好的函数中初始化事件侦听器和网页内容，这个函数在网页完全加载后调用。

1.  命令是`curl`。它默认安装在大多数基于 Unix 的操作系统上。

1.  更改`value`属性会改变 LED 的 PWM 占空比。我们将这视为改变 LED 的亮度。

# 第四章

1.  **MQTT**，或**消息队列遥测协议**，是在分布式物联网网络中经常使用的轻量级消息协议。

1.  检查 QoS 级别，确保它们是 1 级或 2 级。

1.  如果客户端突然断开与代理的连接而没有干净地关闭连接，将代表客户端发布`Will`消息。

1.  发布的消息和订阅的客户端都必须至少使用 QoS 级别 1，这可以确保消息被传递一次或多次。

1.  理想情况下，除了可能需要更改代理主机和端口之外，您的 Python 代码不应该需要任何更改，因为 MQTT 是一个开放标准。前提是新代理配置与被替换的代理类似 - 例如，两个代理都配置类似以为客户端提供消息保留或持久连接功能。

1.  你应该在成功连接类型的处理程序中订阅主题。这样，如果客户端失去了与代理的连接，它可以在重新连接时自动重新建立主题订阅。

# 第五章

1.  **SPI**（串行外围接口电路）。LED 灯带和矩阵是常见的例子。

1.  你可以参考设备的官方数据表，或使用列出所有连接的 I2C 设备地址的命令行工具 i2cdetect。

1.  确保你使用的是库期望的正确引脚编号方案，并/或者确保你已经配置了库以使用你喜欢的方案，如果库提供了这个选项。

1.  驱动程序库不是建立在 PiGPIO 之上的，因此不支持远程 GPIO。

1.  错误。所有的 GPIO 引脚额定电压为 3.3 伏特。连接任何高于这个电压的电压都可能损坏你的树莓派。

1.  你使用来驱动舵机的库很可能是使用软件 PWM 来生成舵机的 PWM 信号。当树莓派的 CPU 变得繁忙时，软件 PWM 信号可能会失真。

1.  如果你从树莓派的 5 伏特引脚为舵机供电，这将表明你正在吸取过多的电力，实际上是从树莓派中夺取电力。理想情况下，舵机应该由外部电源供电。

# 第六章

1.  一般来说，是的。尝试是安全的，因为电阻越高，电路中的电流就越低（欧姆定律），而 330Ω相对接近期望的 200Ω电阻。

1.  更高的电阻导致了更少的电流，以至于电路没有足够的电流来可靠地工作。

1.  电阻要耗散的功率超过了电阻的功率额定值。除了使用欧姆定律来确定电阻值之外，你还需要计算电阻的预期功率耗散，并确保电阻的功率额定值（以瓦特为单位）超过你计算出的值。

1.  1（一）。连接到+3.3 伏特的输入 GPIO 引脚是逻辑高。

1.  GPIO 21 是浮动的。它没有通过物理电阻或者通过代码使用函数调用（例如`pi.set_pull_up_down(21, pigpio.PUD_UP)）`拉高到+3.3 伏特。

1.  你必须使用逻辑电平转换器。这可以是一个简单的基于电阻的电压分压器，一个专用的逻辑电平转换器 IC 或模块，或者任何其他可以适当将 5 伏特转换为 3.3 伏特的形式。

1.  错误。电阻分压器只能降低电压。但是，请记住，只要 5 伏特设备将 3.3 伏特注册为逻辑高，可能可以使用 3.3 伏特来驱动 5 伏特逻辑设备。

# 第七章

1.  MOSFET 是电压控制元件，而 BJT 是电流控制元件。

1.  你在 MOSFET 的栅极上没有下拉电阻，所以它是悬空的。MOSFET 放电缓慢，这反映在电机减速。使用下拉电阻可以确保 MOSFET 迅速放电并关闭。

1.  （a）确保 G、S 和 D 腿正确连接，因为不同的封装样式（例如 T092 与 TP220）它们的腿的顺序是不同的。

（b）你还要确保 MOSFET 是逻辑电平兼容的，这样它就可以使用 3.3 伏特的电压源进行控制。

（c）确保在下拉电阻和限流电阻之间创建的电压分压器允许>〜3 伏特进入 MOSFET 的栅极腿。

1.  光耦和继电器在电路的输入和输出端之间进行电气隔离。晶体管是在电路中的，虽然它们允许低电流设备控制更大的电流设备，但两个设备仍然都是电气连接的（例如，你会看到一个公共地连接）。

1.  主动低是指使 GPIO 低电平以打开或激活连接的电路。主动高则相反，我们使 GPIO 引脚高电平以激活连接的电路。

1.  代码激活的下拉仅在运行代码时变为下拉，因此 MOSFET 门基本上是悬浮的，直到运行代码。

1.  堵转电流是电机在其轴被强行停止旋转时使用的电流。这是电机将吸取的最大电流。

1.  没有区别-它们是两个可互换使用的术语，用来描述电机在轴上没有负载的情况下自由旋转时所使用的电流。

# 第八章

1.  检查您的电源是否能够提供足够的电流（和电压）给 LED 灯带。电流需求随您想要点亮的 LED 数量以及它们设置的颜色和亮度而成比例增加。电流不足可能意味着内部的红/绿/蓝 LED 没有正确点亮，因此颜色不如您期望的那样。

1.  缺少从选择或客户端启用引脚意味着 APA102 完全控制 SPI 接口。这意味着您不能将多个 SPI 从设备连接到一个 SPI 引脚（除非您使用额外的电子设备）。

1.  首先，检查您的逻辑电平转换器是否连接正确。其次，可能逻辑电平转换器无法快速转换逻辑电平以跟上 SPI 接口。尝试降低 SPI 总线速度。

1.  我们使用**PIL**（**Python Imaging Library**）创建一个内存中的图像，代表我们想要显示的内容。然后将此图像发送到 OLED 显示器进行渲染。

1.  **RTTTL**意味着**Ring Tone Text Transfer Language**，这是由诺基亚创建的一个铃声音乐格式。

# 第九章

1.  DHT22 是一种更精确的传感器，它能够感知更广泛的温度和湿度范围。

1.  外部上拉电阻是可选的，因为我们的树莓派可以使用其内部嵌入的上拉电阻。

1.  LDR 是一种光敏电阻。当作为电压分压电路的一部分使用时，我们将变化的电阻转换为变化的电压。然后，这个电压可以被模拟到数字转换器（如连接到您的树莓派的 ADS1115）检测到。

1.  尝试改变电压分压电路中固定电阻的电阻值。尝试更高阻值的电阻以使 LDR 在较暗的条件下更敏感。尝试更低的电阻值以使 LDR 对更明亮的条件更敏感。

1.  当涉及到它们测量的电阻时，没有两个 LDR 是相同的。如果在电路中更换 LDR，请重新校准代码以确保。

1.  水传导电。它在两个探针线之间充当电阻。这种电阻通过电压分压器转换为电压，ADS1115 ADC 可以检测到这种电压。

# 第十章

1.  我们通常发现默认的参考脉冲宽度为 1 毫秒用于左，2 毫秒用于右的舵机。实际上，舵机可能需要略微调整的脉冲宽度才能达到其极限旋转位置。

1.  您正在应用尝试将舵机旋转到其物理极限之外的脉冲宽度。

1.  H 桥还允许我们改变电机的旋转并快速制动以停止电机旋转。

1.  许多因素影响制动的可靠性，包括 IC 和您的电机。您可以采用 PWM 式制动作为替代制动技术。

1.  振动但不转动通常是线圈通电顺序和线圈步进序列不匹配的症状。您需要确定并确保步进电机的线圈连接正确并匹配步进序列。查阅您的步进电机的数据表是开始的最佳地点。

1.  L293D 的电压降约为 2 伏，因此您的电机只能获得约 3 伏。为了补偿这种电压降，您需要一个 7 伏的电源。

1.  不。GPIO 引脚只提供 3.3 伏。虽然这可能刚好足够旋转 5 伏的步进电机，但是步进电机的电流要求将超出树莓派 GPIO 引脚的安全限制。

# 第十一章

1.  不。**被动红外**（PIR）传感器只能检测抽象的运动。您将需要一种主动型红外传感器或类似热成像相机的设备（以及更复杂的代码）来提取更丰富的运动信息。

1.  超声波传感器测量超声脉冲的往返时间，然后用于计算距离。影响超声脉冲时间或所用的声速常数的因素因此会影响计算出的距离。一些例子包括温度，因为这会影响声速，被检测物体的材料（例如，它是否吸收声音？），物体的大小以及其相对于传感器的角度。

1.  锁定和非锁定霍尔效应传感器都输出数字信号-它们的输出引脚要么是高电平要么是低电平。相比之下，比例霍尔效应传感器输出与它们离磁场有多近的模拟信号（变化的电压）。

1.  `callback_handler`函数将在 GPIO 转换为高电平或低电平时调用。

1.  因此，位于 5 伏特源和电压分压器输出（两个电阻之间）之间的电阻器上的相对电压降为 3.3 伏特，即 5 伏特*2kΩ/(1kΩ+2kΩ) = ~3.3 伏特。如果您在电路中颠倒了电阻值，电压分压器输出将为~1.7 伏特，即 5 伏特*1kΩ/(1kΩ+2kΩ) = ~1.7 伏特。

1.  在查阅 HC-SR501 PIR 传感器的数据表后，我们了解到它的输出引脚始终在 3.3 伏特工作，即使它是由 5 伏特供电的，因此我们不需要电压分压器。（请注意，在实践中，我们最好也通过我们的测量来确认这一点。）

# 第十二章

1.  发布-订阅方法促进了高度解耦的编程方法。当您有许多组件（例如传感器）发布数据，只需要在程序的其他地方消耗数据时，这可能是有益的。

1.  GIL 代表全局解释器锁。这是 Python 编程语言的一个设计方面，意味着一次只有一个线程可以访问 Python 解释器。

1.  纯事件循环（例如，一个长的 while 循环）在程序增长时可能会变得复杂。对许多状态变量和非平凡的和干预的条件测试（例如，if 语句）的需求可能会使程序逻辑难以理解和调试。

1.  不。每种方法都有其目的。事件循环在小而专注时是可以的。只有当它们变得庞大并执行多个操作时，它们才会变得复杂。

1.  当您使用线程进行编程时，调用`join()`另一个线程会将该线程加入到当前线程。然后，您的当前线程将阻塞，直到所有加入的线程运行方法完成。这是同步多个线程完成的简单方法。

1.  也许您正在使用`sleep`语句（来自`time`库），例如`sleep(duration)`，它会阻塞整个持续时间。尝试使用以下示例中的方法，这将使您的程序保持对`duration`值的更改的响应性：

```py
duration = 1   # 1 second
timer = 0
while timer < duration:
    timer += 0.01
    sleep(0.01)
```

1.  没有一种方法是优越的。在 Python 中，达到编程目标的方法总是不止一种。最佳方法或方法的组合完全取决于您的项目以及您想要实现的目标。最佳方法也可能是根据您的个人偏好和首选编程风格而为您最佳的方法。

# 第十三章

1.  我们使用不同的温度创建一个缓冲区，这样我们就不会在温度围绕单个温度值徘徊时生成多个触发器（和多个电子邮件）。

1.  使用中介者意味着我们不需要担心防火墙、端口转发和其他必要的配置，以将您的树莓派暴露给公共互联网。

1.  IFTTT 更加面向消费者，而 Zapper 在提供集成方面更加面向企业。Zapper 还允许您创建更复杂的工作流程、触发器和操作场景。

1.  不，ThingSpeak 只消耗数据以在仪表板上显示。一些平台，如 ThingBoard，将允许您将数据发送回设备，以控制该设备。

1.  最多可以使用三个 JSON 属性`– Value1`、`Value2`和`Value3`。

1.  从开发的便捷性和速度的角度来看，IFTTT 或 Zapper 都是不错的选择，但您当然也可以使用 AWS 或其他主要的物联网平台，甚至是 Home Assistant。

# 第十四章

1.  使用 PyPubSub 是一个设计决策，旨在将与 MQTT 相关的代码和逻辑与硬件控制代码和逻辑分离，以使代码更清晰、更易于维护。

1.  使用 Google 助手应用程序时说的命令会显示在您的设备上，因此很容易看到 Google 助手是如何听到您说的命令，以及发送给您的 IFTTT Applet 的文本命令。

1.  您需要构建一个集成服务，用于在 MQTT 和 RESTful API 之间传输数据（或者，也可以找到一个第三方服务来做到这一点，例如，可以查看[`io.adafruit.com`](https://io.adafruit.com)和他们的 IFTTT 服务）。IFTTT 提供 RESTful webhooks 作为构建自定义集成的选项，但它不提供 MQTT 选项。

1.  一种选择是使用 MQTT，就像我们在本章中介绍的示例一样。如果您使用 MQTT 将多个 IoTree 连接到中央 MQTT 代理，它们将一起接收指令。第二个选择可能是构建基于 WebSockets 的服务和应用程序（我们在第三章中介绍了这种方法，*使用 Flask 进行 RESTful API 和 Web Sockets 的网络连接*）。

1.  我们使用免费的[dweet.io](http://dweet.io)服务，因为这样做非常方便，这样我们就不必担心防火墙、端口转发和路由器配置（以防您没有相关经验）。免费的[dweet.io](http://dweet.io)服务不提供安全性或隐私性，因此对许多项目来说并不理想。如果您喜欢[dweet.io](http://dweet.io)的想法，还有[dweetpro.io](https://dweetpro.io)，这是一个付费的替代方案，提供了免费版本中不可用的安全性和许多其他功能。

1.  `CURL`是一种常用的命令行工具，可用于测试 RESTful API。Postman ([getpostman.com](https://getpostman.com))是一种常用的 GUI 工具，也可以用于相同的目的。

1.  如果您使用 MQTT 代理的保留消息功能，每个 IoTree 在连接时都会收到最后一条消息（例如，要显示什么颜色模式），因此可以初始化自己。我们在《使用 MQTT、Python 和 Mosquitto MQTT 代理进行网络连接》第四章中介绍了保留消息。

1.  如果您的 MQTT 代理运行在与 IoTree 相同的树莓派上，并且重新启动了这个树莓派，除非 Mosquitto MQTT 代理在其配置中启用了持久性，否则所有保留的消息都将丢失。（我们在第四章中的配置，*使用 MQTT、Python 和 Mosquitto MQTT 代理进行网络连接*，确保了持久性已启用）。
