## 第八章：推导式、可迭代对象和生成器

*对象序列*的抽象概念在编程中是无处不在的。它可以用来模拟简单的字符串、复杂对象的列表和无限长的传感器输出流等各种概念。也许你不会感到惊讶的是，Python 包含了一些非常强大和优雅的工具来处理序列。事实上，Python 对于创建和操作序列的支持是许多人认为这门语言的亮点之一。

在这一章中，我们将看到 Python 提供的三个用于处理序列的关键工具：推导式、可迭代对象和生成器。*推导式*包括了一个专门的语法，用于声明性地创建各种类型的序列。*可迭代对象*和*迭代协议*构成了 Python 中序列和迭代的核心抽象和 API；它们允许你定义新的序列类型，并对迭代进行精细控制。最后，*生成器*允许我们以命令式的方式定义惰性序列，在许多情况下是一种令人惊讶的强大技术。

让我们直接进入推导式。

### 推导式

在 Python 中，推导式是一种简洁的语法，用于以声明性或函数式风格描述列表、集合或字典。这种简写是可读的和表达性强的，这意味着推导式非常有效地传达了人类读者的意图。一些推导式几乎读起来像自然语言，使它们成为很好的自我文档化。

#### 列表推导式

如上所示，*列表推导式*是创建列表的一种简写方式。它是使用简洁的语法来描述*如何定义列表元素*的表达式。推导式比解释更容易演示，所以让我们打开一个 Python REPL。首先，我们将通过拆分一个字符串来创建一个单词列表：

```py
>>> words = "If there is hope it lies in the proles".split()
>>> words
['If', 'there', 'is', 'hope', 'it', 'lies', 'in', 'the', 'proles']

```

现在是列表推导式的时候了。推导式被包含在方括号中，就像一个字面上的列表一样，但它包含的不是字面上的元素，而是一段描述如何构造列表元素的声明性代码片段。

```py
>>> [len(word) for word in words]
[2, 5, 2, 4, 2, 4, 2, 3, 6]

```

这里，新列表是通过将名称`word`依次绑定到`words`中的每个值，然后评估`len(word)`来创建新列表中的相应值而形成的。换句话说，这构建了一个包含`words`中字符串长度的新列表；很难想象有更有效地表达这个新列表的方式了！

##### 列表推导式语法

列表推导式的一般形式是：

```py
[ expr(item) for item in iterable ]

```

也就是说，对于右侧的`iterable`中的每个`item`，我们在左侧评估`expr(item)`表达式（几乎总是，但不一定是关于该项的）。我们使用该表达式的结果作为我们正在构建的列表的下一个元素。

上面的推导式是以下命令式代码的声明性等价物：

```py
>>> lengths = []
>>> for word in words:
...     lengths.append(len(word))
...
>>> lengths
[2, 5, 2, 4, 2, 4, 2, 3, 6]

```

##### 列表推导式的元素

请注意，在列表推导式中我们迭代的源对象不需要是列表本身。它可以是任何实现了可迭代协议的对象，比如元组。

推导式的表达式部分可以是任何 Python 表达式。在这里，我们使用 `range()` 来找出前 20 个阶乘中每个数的十进制位数 —— `range()` 是一个可迭代对象 —— 以生成源序列。

```py
>>> from math import factorial
>>> f = [len(str(factorial(x))) for x in range(20)]
>>> f
[1, 1, 1, 1, 2, 3, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18]

```

还要注意，列表推导式产生的对象类型只不过是一个普通的 `list`：

```py
>>> type(f)
<class 'list'>

```

在我们看其他类型的推导式并考虑如何对无限序列进行迭代时，牢记这一点是很重要的。

#### 集合推导式

集合支持类似的推导式语法，使用的是花括号，正如你所期望的那样。我们之前的“阶乘中的数字位数”结果包含了重复项，但通过构建一个集合而不是一个列表，我们可以消除它们：

```py
>>> s = {len(str(factorial(x))) for x in range(20)}
>>> s
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 18}

```

与列表推导式类似，集合推导式产生标准的 `set` 对象：

```py
>>> type(s)
<class 'set'>

```

请注意，由于集合是无序容器，所以结果集不一定以有意义的顺序存储。

#### 字典理解

第三种理解类型是字典理解。与集合理解语法类似，字典理解也使用大括号。它与集合理解的区别在于，我们现在提供了两个以冒号分隔的表达式 - 第一个用于键，第二个用于值 - 这将同时为结果字典中的每个新项目进行评估。这是一个我们可以玩的字典：

```py
>>> country_to_capital = { 'United Kingdom': 'London',
...                        'Brazil': 'Brasília',
...                        'Morocco': 'Rabat',
...                        'Sweden': 'Stockholm' }

```

字典理解的一个很好的用途是反转字典，这样我们就可以在相反的方向上执行高效的查找：

```py
>>> capital_to_country = {capital: country for country, capital in country_to_capital\
.items()}
>>> from pprint import pprint as pp
>>> pp(capital_to_country)
{'Brasília': 'Brazil',
 'London': 'United Kingdom',
 'Rabat': 'Morocco',
 'Stockholm': 'Sweden'}

```

请注意，字典理解不直接作用于字典源！^(16) 如果我们想要从源字典中获取键和值，那么我们应该使用`items()`方法结合元组解包来分别访问键和值。

你的理解应该产生一些相同的键，后面的键将覆盖先前的键。在这个例子中，我们将单词的首字母映射到单词本身，但只保留最后一个 h 开头的单词：

```py
>>> words = ["hi", "hello", "foxtrot", "hotel"]
>>> { x[0]: x for x in words }
{'h': 'hotel', 'f': 'foxtrot'}

```

##### 理解的复杂性

记住，你可以在任何理解中使用的表达式的复杂性没有限制。但是为了你的同行程序员着想，你应该避免过度。相反，将复杂的表达式提取到单独的函数中以保持可读性。以下是接近于字典理解的合理限制：

```py
>>> import os
>>> import glob
>>> file_sizes = {os.path.realpath(p): os.stat(p).st_size for p in glob.glob('*.py')}
>>> pp(file_sizes)
{'/Users/pyfund/examples/exceptional.py': 400,
 '/Users/pyfund/examples/keypress.py': 778,
 '/Users/pyfund/examples/scopes.py': 133,
 '/Users/pyfund/examples/words.py': 1185}

```

这使用`glob`模块在目录中查找所有的 Python 源文件。然后它创建了一个从这些文件中的路径到文件大小的字典。

#### 过滤理解

所有三种集合理解类型都支持一个可选的过滤子句，它允许我们选择由左侧表达式评估的源的哪些项目。过滤子句是通过在理解的序列定义之后添加`if <boolean expression>`来指定的；如果布尔表达式对输入序列中的项目返回 false，则在结果中不会对该项目进行评估。

为了使这个有趣，我们首先定义一个确定其输入是否为质数的函数：

```py
>>> from math import sqrt
>>> def is_prime(x):
...     if x < 2:
...         return False
...     for i in range(2, int(sqrt(x)) + 1):
...         if x % i == 0:
...             return False
...     return True
...

```

现在我们可以在列表理解的过滤子句中使用这个来产生小于 100 的所有质数：

```py
>>> [x for x in range(101) if is_prime(x)]
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, \
83, 89, 97]

```

##### 结合过滤和转换

我们在这里有一个看起来有点奇怪的`x for x`构造，因为我们没有对过滤值应用任何转换；关于`x`的表达式只是`x`本身。然而，没有什么能阻止我们将过滤谓词与转换表达式结合起来。这是一个将具有三个约数的数字映射到这些约数的元组的字典理解：

```py
>>> prime_square_divisors = {x*x:(1, x, x*x) for x in range(101) if is_prime(x)}
>>> pp(prime_square_divisors)
{4: (1, 2, 4),
 9: (1, 3, 9),
 25: (1, 5, 25),
 49: (1, 7, 49),
 121: (1, 11, 121),
 169: (1, 13, 169),
 289: (1, 17, 289),
 361: (1, 19, 361),
 529: (1, 23, 529),
 841: (1, 29, 841),
 961: (1, 31, 961),
 1369: (1, 37, 1369),
 1681: (1, 41, 1681),
 1849: (1, 43, 1849),
 2209: (1, 47, 2209),
 2809: (1, 53, 2809),
 3481: (1, 59, 3481),
 3721: (1, 61, 3721),
 4489: (1, 67, 4489),
 5041: (1, 71, 5041),
 5329: (1, 73, 5329),
 6241: (1, 79, 6241),
 6889: (1, 83, 6889),
 7921: (1, 89, 7921),
 9409: (1, 97, 9409)}

```

* * *

### 禅的时刻

![](img/zen-simple-is-better-than-complex.png)

理解通常比替代方法更易读。然而，过度使用理解是可能的。有时，一个长或复杂的理解可能比等价的 for 循环*更*难读。关于何时应该优先选择哪种形式没有硬性规定，但在编写代码时要谨慎，并尽量选择适合你情况的最佳形式。

首先，你的理解理想上应该是纯函数的 - 也就是说，它们不应该有任何副作用。如果你需要创建副作用，比如在迭代过程中打印到控制台，那么使用另一种构造，比如 for 循环。

* * *

### 迭代协议

理解迭代的最常用语言特性是推导和 for 循环。它们都从源中逐个获取项目并依次处理。然而，推导和 for 循环默认情况下都会遍历整个序列，有时需要更精细的控制。在本节中，我们将看到如何通过研究两个重要概念来实现这种精细控制，这两个概念构成了大量 Python 语言行为的基础：*可迭代*对象和*迭代器*对象，这两个对象都反映在标准 Python 协议中。

*可迭代协议*定义了可迭代对象必须实现的 API。也就是说，如果要使用 for 循环或推导来迭代对象，该对象必须实现可迭代协议。内置类如`list`实现了可迭代协议。您可以将实现可迭代协议的对象传递给内置的`iter()`函数，以获取可迭代对象的*迭代器*。

*迭代器*则支持*迭代器协议*。该协议要求我们可以将迭代器对象传递给内置的`next()`函数，以从底层集合中获取下一个值。

#### 迭代协议的示例

通常情况下，在 Python REPL 上进行演示将有助于将所有这些概念凝结成可以操作的东西。我们从一个包含季节名称的列表作为我们的可迭代对象开始：

```py
>>> iterable = ['Spring', 'Summer', 'Autumn', 'Winter']

```

然后我们要求可迭代对象使用内置的`iter()`给我们一个迭代器：

```py
>>> iterator = iter(iterable)

```

接下来我们使用内置的`next()`从迭代器中请求一个值：

```py
>>> next(iterator)
'Spring'

```

每次调用`next()`都会通过序列移动迭代器：

```py
>>> next(iterator)
'Summer'
>>> next(iterator)
'Autumn'
>>> next(iterator)
'Winter'

```

但是当我们到达末尾时会发生什么？

```py
>>> next(iterator)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
StopIteration

```

在 Python 中，异常会引发`StopIteration`异常，这显示了 Python 的自由主义精神。那些来自对异常处理更为严格的其他编程语言的人可能会觉得这有点令人不安，但实际上，还有什么比到达集合的末尾更特殊的呢？毕竟它只有一个结束！

考虑到可迭代系列可能是潜在的无限数据流，这种尝试对 Python 语言设计决策进行合理化的做法更有意义。在这种情况下到达末尾确实是一件值得写信或引发异常的事情。

#### 迭代协议的更实际的示例

使用 for 循环和推导时，这些较低级别的迭代协议的实用性可能不太明显。为了演示更具体的用途，这里有一个小型实用函数，当传递一个可迭代对象时，它会返回该系列的第一个项目，或者如果该系列为空，则引发`ValueError`：

```py
>>> def first(iterable):
...     iterator = iter(iterable)
...     try:
...         return next(iterator)
...     except StopIteration:
...         raise ValueError("iterable is empty")
...

```

这在任何可迭代对象上都能按预期工作，本例中包括`list`和`set`：

```py
>>> first(["1st", "2nd", "3rd"])
'1st'
>>> first({"1st", "2nd", "3rd"})
'1st'
>>> first(set())
Traceback (most recent call last):
  File "./iterable.py", line 17, in first
    return next(iterator)
StopIteration

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "./iterable.py", line 19, in first
    raise ValueError("iterable is empty")
ValueError: iterable is empty

```

值得注意的是，高级迭代构造，如 for 循环和推导，直接建立在这种低级别的迭代协议之上。

### 生成器函数

现在我们来介绍*生成器函数*^(17)，这是 Python 编程语言中最强大和优雅的特性之一。Python 生成器提供了使用函数中的代码描述可迭代系列的方法。这些序列是惰性求值的，这意味着它们只在需要时计算下一个值。这一重要特性使它们能够模拟没有明确定义结束的无限值序列，例如来自传感器的数据流或活动日志文件。通过精心设计生成器函数，我们可以制作通用的流处理元素，这些元素可以组合成复杂的管道。

#### `yield`关键字

生成器由任何在其定义中至少使用一次`yield`关键字的 Python 函数定义。它们也可以包含没有参数的`return`关键字，就像任何其他函数一样，在定义的末尾有一个隐式的`return`。

为了理解生成器的作用，让我们从 Python REPL 中的一个简单示例开始。让我们定义生成器，然后我们将研究生成器的工作原理。

生成器函数由`def`引入，就像普通的 Python 函数一样：

```py
>>> def gen123():
...     yield 1
...     yield 2
...     yield 3
...

```

现在让我们调用`gen123()`并将其返回值赋给`g`：

```py
>>> g = gen123()

```

正如你所看到的，`gen123()`就像任何其他 Python 函数一样被调用。但它返回了什么？

```py
>>> g
<generator object gen123 at 0x1006eb230>

```

#### 生成器是迭代器

`g`是一个生成器对象。生成器实际上是 Python 的*迭代器*，因此我们可以使用迭代器协议从系列中检索或产生连续的值：

```py
>>> next(g)
1
>>> next(g)
2
>>> next(g)
3

```

请注意，现在我们已经从生成器中产生了最后一个值后会发生什么。对`next()`的后续调用会引发`StopIteration`异常，就像任何其他 Python 迭代器一样：

```py
>>> next(g)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
StopIteration

```

因为生成器是迭代器，而迭代器也必须是可迭代的，它们可以在所有期望可迭代对象的常规 Python 结构中使用，例如 for 循环：

```py
>>> for v in gen123():
...     print(v)
...
1
2
3

```

请注意，对生成器函数的每次调用都会返回一个新的生成器对象：

```py
>>> h = gen123()
>>> i = gen123()
>>> h
<generator object gen123 at 0x1006eb2d0>
>>> i
<generator object gen123 at 0x1006eb280>
>>> h is i
False

```

还要注意每个生成器对象可以独立推进：

```py
>>> next(h)
1
>>> next(h)
2
>>> next(i)
1

```

#### 生成器代码何时执行？

让我们更仔细地看一下我们的生成器函数体中的代码是如何执行的，以及关键的*何时*执行。为了做到这一点，我们将创建一个稍微复杂一点的生成器，它将用老式的打印语句跟踪它的执行：

```py
>>> def gen246():
...     print("About to yield 2")
...     yield 2
...     print("About to yield 4")
...     yield 4
...     print("About to yield 6")
...     yield 6
...     print("About to return")
...
>>> g = gen246()

```

此时生成器对象已经被创建并返回，但是生成器函数体内的代码尚未执行。让我们对`next()`进行初始调用：

```py
>>> next(g)
About to yield 2
2

```

看看当我们请求第一个值时，生成器体运行到第一个`yield`语句为止。代码执行到足够的地方，以便字面上`yield`下一个值。

```py
>>> next(g)
About to yield 4
4

```

当我们从生成器请求下一个值时，生成器函数的执行会在离开的地方*恢复*，并继续运行直到下一个`yield`：

```py
>>> next(g)
About to yield 6
6

```

在最后一个值返回后，下一个请求会导致生成器函数执行，直到它在函数体的末尾返回，这将引发预期的`StopIteration`异常。

```py
>>> next(g)
About to return
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
StopIteration

```

现在我们已经看到生成器执行是通过对`next()`的调用来启动，并通过`yield`语句来中断，我们可以继续将更复杂的代码放在生成器函数体中。

#### 在生成器函数中保持显式状态

现在我们将看看我们的生成器函数如何在每次请求下一个值时恢复执行，并在本地变量中保持状态。在这个过程中，我们的生成器将变得更有趣和更有用。我们将展示两个演示惰性评估的生成器，稍后我们将把它们合并成一个生成器管道。

##### 第一个有状态的生成器：`take()`

我们将要查看的第一个生成器是`take()`，它从序列的前面检索指定数量的元素：

```py
def take(count, iterable):
    """Take items from the front of an iterable.

    Args:
        count: The maximum number of items to retrieve.
        iterable: The source of the items.

    Yields:
        At most 'count' items from 'iterable'.
    """
    counter = 0
    for item in iterable:
        if counter == count:
            return
        counter += 1
        yield item

```

请注意，该函数定义了一个生成器，因为它包含至少一个`yield`语句。这个特定的生成器还包含一个`return`语句来终止产生的值流。生成器使用一个计数器来跟踪到目前为止已经产生了多少元素，当请求超出请求的计数时返回。

由于生成器是惰性的，并且只在请求时产生值，我们将在`run_take()`函数中使用 for 循环来驱动执行：

```py
def run_take():
    items = [2, 4, 6, 8, 10]
    for item in take(3, items):
        print(item)

```

在这里，我们创建了一个名为`items`的源`list`，并将其与`3`一起传递给我们的生成器函数。在内部，for 循环将使用迭代器协议从`take()`生成器中检索值，直到它终止。

##### 第二个有状态的生成器：`distinct()`

现在让我们把第二个生成器带入图片。这个名为`distinct()`的生成器函数通过跟踪它已经在`set`中看到的元素来消除重复项：

```py
def distinct(iterable):
    """Return unique items by eliminating duplicates.

    Args:
        iterable: The source of the items.

    Yields:
        Unique elements in order from 'iterable'.
    """
    seen = set()
    for item in iterable:
        if item in seen:
            continue
        yield item
        seen.add(item)

```

在这个生成器中，我们还使用了一个之前没有见过的控制流构造：`continue`关键字。`continue`语句结束当前循环的迭代，并立即开始下一个迭代。在这种情况下执行时，执行将被转移到`for`语句，但与`break`一样，它也可以与 while 循环一起使用。

在这种情况下，`continue`用于跳过已经产生的任何值。我们还可以添加一个`run_distinct()`函数来使用`distinct()`：

```py
def run_distinct():
    items = [5, 7, 7, 6, 5, 5]
    for item in distinct(items):
        print(item)

```

##### 理解这些生成器！

在这一点上，您应该花一些时间探索这两个生成器，然后再继续。确保您了解它们的工作方式以及它们如何在维护状态时控制流进出。如果您正在使用 IDE 运行这些示例，您可以使用调试器通过在生成器和使用它们的代码中设置断点来跟踪控制流。您也可以使用 Python 的内置`pdb`调试器（我们稍后会介绍）或者甚至只是使用老式的打印语句来实现相同的效果。

无论如何，确保在继续下一节之前，您真正了解这些生成器的工作方式。

#### 惰性生成器管道

现在您已经了解了单独的生成器，我们将把它们两个安排成一个惰性管道。我们将使用`take()`和`distinct()`一起从集合中获取前三个唯一的项目：

```py
def run_pipeline():
    items = [3, 6, 6, 2, 1, 1]
    for item in take(3, distinct(items)):
        print(item)

```

请注意，`distinct()`生成器只做足够的工作来满足`take()`生成器的需求，后者正在迭代它 - 它永远不会到达源列表的最后两个项目，因为它们不需要产生前三个唯一的项目。这种对计算的懒惰方法非常强大，但它产生的复杂控制流可能很难调试。在开发过程中，强制评估所有生成的值通常很有用，最简单的方法是插入一个对`list()`构造函数的调用：

```py
take(3, list(distinct(items)))

```

这个交错调用`list()`导致`distinct()`生成器在`take()`执行其工作之前彻底处理其源项目。有时，当您调试惰性计算的序列时，这可以让您了解正在发生什么。

#### 懒惰和无限

生成器是惰性的，这意味着计算只会在下一个结果被请求时才会发生。生成器的这种有趣和有用的特性意味着它们可以用来模拟无限序列。由于值只在调用者请求时产生，并且不需要构建数据结构来包含序列的元素，因此生成器可以安全地用于生成永无止境（或者只是非常大）的序列，比如：

+   传感器读数

+   数学序列（例如素数、阶乘等）^(18)

+   多太字节文件的内容

##### 生成 Lucas 系列

让我们介绍一个 Lucas 系列的生成器函数^(19)：

```py
def lucas():
    yield 2
    a = 2
    b = 1
    while True:
        yield b
        a, b = b, a + b

```

Lucas 系列以`2, 1`开始，之后每个值都是前两个值的和。因此，序列的前几个值是：

```py
2, 1, 3, 4, 7, 11

```

第一个`yield`产生值`2`。然后函数初始化`a`和`b`，它们保存着函数进行时所需的“前两个值”。然后函数进入一个无限的 while 循环，其中：

1.  它产生`b`的值

1.  `a`和`b`被更新以保存新的“前两个”值，使用元组解包的巧妙应用

现在我们有了一个生成器，它可以像任何其他可迭代对象一样使用。例如，要打印 Lucas 数，您可以使用以下循环：

```py
>>> for x in lucas():
...     print(x)
...
2
1
3
4
7
11
18
29
47
76
123
199

```

当然，由于 Lucas 序列是无限的，这将永远运行，打印出值，直到您的计算机耗尽内存。使用 Control-C 来终止循环。

### 生成器表达式

生成器表达式是推导和生成器函数之间的交叉。它们使用与推导类似的语法，但它们会产生一个*生成器对象*，该对象会懒惰地产生指定的序列。生成器表达式的语法与列表推导非常相似：

```py
( expr(item) for item in iterable )

```

它由括号界定，而不是用于列表推导的方括号。

生成器表达式在您希望使用推导的声明性简洁性进行懒惰评估的情况下非常有用。例如，这个生成器表达式产生了前一百万个平方数的列表：

```py
>>> million_squares = (x*x for x in range(1, 1000001))

```

此时，还没有创建任何一个平方数；我们只是将序列的规范捕捉到了一个生成器对象中：

```py
>>> million_squares
<generator object <genexpr> at 0x1007a12d0>

```

我们可以通过使用它来创建一个（长！）`list`来强制评估生成器：

```py
>>> list(million_squares)
. . .
999982000081, 999984000064, 999986000049, 999988000036, 999990000025,
999992000016, 999994000009, 999996000004, 999998000001, 1000000000000]

```

这个列表显然消耗了大量的内存 - 在这种情况下，列表对象和其中包含的整数对象大约为 40MB。

##### 生成器对象只运行一次

注意，生成器对象只是一个迭代器，一旦以这种方式耗尽，就不会再产生任何项目。重复前面的语句会返回一个空列表：

```py
>>> list(million_squares)
[]

```

生成器是一次性对象。每次调用生成器*函数*时，我们都会创建一个新的生成器对象。要从生成器表达式中重新创建生成器，我们必须再次执行表达式本身。

##### 无内存迭代

让我们通过使用内置的`sum()`函数来计算前*一千万*个平方数的和来提高赌注，该函数接受一个可迭代的数字序列。如果我们使用列表推导，我们可以期望它消耗大约 400MB 的内存。使用生成器表达式，内存使用将是微不足道的：

```py
>>> sum(x*x for x in range(1, 10000001))
333333383333335000000

```

这将在一秒钟左右产生一个结果，并且几乎不使用内存。

##### 可选的括号

仔细观察，您会发现在这种情况下，我们没有为生成器表达式提供单独的括号，除了`sum()`函数调用所需的括号。这种优雅的能力使得用于函数调用的括号也可以用于生成器表达式，有助于可读性。如果您愿意，您可以包含第二组括号。

##### 在生成器表达式中使用 if 子句

与推导一样，您可以在生成器表达式的末尾包含一个 if 子句。重复使用我们承认效率低下的`is_prime()`谓词，我们可以这样确定前一千个整数中是质数的整数的总和：

```py
>>> sum(x for x in range(1001) if is_prime(x))
76127

```

请注意，这与计算前 1000 个质数的总和不同，这是一个更棘手的问题，因为我们事先不知道在我们累积了一千个质数之前需要测试多少个整数。

### “电池包含”迭代工具

到目前为止，我们已经介绍了 Python 提供的创建可迭代对象的许多方法。推导、生成器和遵循可迭代或迭代器协议的任何对象都可以用于迭代，因此应该清楚迭代是 Python 的一个核心特性。

Python 提供了许多用于执行常见迭代器操作的内置函数。这些函数构成了一种用于处理迭代器的*词汇*，它们可以组合在一起，以产生非常简洁、可读的代码中的强大语句。我们已经遇到了其中一些函数，包括用于生成整数索引的`enumerate()`和用于计算数字总和的`sum()`。

#### 介绍`itertools`

除了内置函数之外，`itertools`模块还包含了大量用于处理可迭代数据流的有用函数和生成器。

我们将通过使用内置的`sum()`和`itertools`中的两个生成器函数：`islice()`和`count()`来解决前一千个质数问题来开始演示这些函数。

早些时候，我们为了懒惰地检索序列的开头而制作了自己的`take()`生成器函数。然而，我们不需要费心，因为`islice()`允许我们执行类似于内置列表切片功能的懒惰切片。要获取前 1000 个质数，我们需要做类似这样的事情：

```py
from itertools import islice, count

islice(all_primes, 1000)

```

但是如何生成`all_primes`呢？以前，我们一直使用`range()`来创建原始的整数序列，以供我们的质数测试使用，但范围必须始终是有限的，即在两端都有界。我们想要的是`range()`的开放版本，这正是`itertools.count()`提供的。使用`count()`和`islice()`，我们的前 1000 个质数表达式可以写成：

```py
>>> thousand_primes = islice((x for x in count() if is_prime(x)), 1000)

```

这返回一个特殊的`islice`对象，它是可迭代的。我们可以使用列表构造函数将其转换为列表。

```py
>>> thousand_primes
<itertools.islice object at 0x1006bae10>
>>> list(thousand_primes)
[2, 3, 5, 7, 11, 13 ... ,7877, 7879, 7883, 7901, 7907, 7919]

```

现在回答我们关于前 1000 个质数之和的问题很容易，记得重新创建生成器：

```py
>>> sum(islice((x for x in count() if is_prime(x)), 1000))
3682913

```

#### 布尔序列

另外两个非常有用的内置函数是`any()`和`all()`。它们相当于逻辑运算符`and`和`or`，但适用于`bool`值的可迭代序列，

```py
>>> any([False, False, True])
True
>>> all([False, False, True])
False

```

在这里，我们将使用`any()`与生成器表达式一起来回答一个问题，即 1328 到 1360 范围内是否有任何质数：

```py
>>> any(is_prime(x) for x in range(1328, 1361))
False

```

对于完全不同类型的问题，我们可以检查所有这些城市名称是否都是以大写字母开头的专有名词：

```py
>>> all(name == name.title() for name in ['London', 'Paris', 'Tokyo', 'New York', 'Sy\
dney', 'Kuala Lumpur'])
True

```

#### 使用`zip`合并序列

我们将要看的最后一个内置函数是`zip()`，顾名思义，它给我们提供了一种同步迭代两个可迭代序列的方法。例如，让我们一起`zip`两列温度数据，一个来自星期日，一个来自星期一：

```py
>>> sunday = [12, 14, 15, 15, 17, 21, 22, 22, 23, 22, 20, 18]
>>> monday = [13, 14, 14, 14, 16, 20, 21, 22, 22, 21, 19, 17]
>>> for item in zip(sunday, monday):
...     print(item)
...
(12, 13)
(14, 14)
(15, 14)
(15, 14)
(17, 16)
(21, 20)
(22, 21)
(22, 22)
(23, 22)
(22, 21)
(20, 19)
(18, 17)

```

我们可以看到，当迭代时，`zip()`会产生元组。这反过来意味着我们可以在 for 循环中使用元组解包来计算这些天每小时的平均温度：

```py
>>> for sun, mon in zip(sunday, monday):
...     print("average =", (sun + mon) / 2)
...
average = 12.5
average = 14.0
average = 14.5
average = 14.5
average = 16.5
average = 20.5
average = 21.5
average = 22.0
average = 22.5
average = 21.5
average = 19.5
average = 17.5

```

##### 使用`zip()`处理两个以上的序列

事实上，`zip()`可以接受任意数量的可迭代参数。让我们添加第三个时间序列，并使用其他内置函数来计算相应时间的统计数据：

```py
>>> tuesday = [2, 2, 3, 7, 9, 10, 11, 12, 10, 9, 8, 8]
>>> for temps in zip(sunday, monday, tuesday):
...     print("min = {:4.1f}, max={:4.1f}, average={:4.1f}".format(
...            min(temps), max(temps), sum(temps) / len(temps)))
...
min =  2.0, max=13.0, average= 9.0
min =  2.0, max=14.0, average=10.0
min =  3.0, max=15.0, average=10.7
min =  7.0, max=15.0, average=12.0
min =  9.0, max=17.0, average=14.0
min = 10.0, max=21.0, average=17.0
min = 11.0, max=22.0, average=18.0
min = 12.0, max=22.0, average=18.7
min = 10.0, max=23.0, average=18.3
min =  9.0, max=22.0, average=17.3
min =  8.0, max=20.0, average=15.7
min =  8.0, max=18.0, average=14.3

```

注意我们如何使用字符串格式化功能来控制数字列的宽度为四个字符。

#### 使用`chain()`懒惰地连接序列

也许，我们想要一个长的星期日、星期一和星期二的温度序列。我们可以使用`itertools.chain()`来*懒惰地*连接可迭代对象，而不是通过急切地组合三个温度列表来创建一个新列表：

```py
>>> from itertools import chain
>>> temperatures = chain(sunday, monday, tuesday)

```

`temperatures`是一个可迭代对象，首先产生来自`星期日`的值，然后是来自`星期一`的值，最后是来自`星期二`的值。虽然它是懒惰的，但它从来不会创建一个包含所有元素的单个列表；事实上，它从来不会创建任何中间列表！

现在我们可以检查所有这些温度是否都高于冰点，而不会造成数据重复的内存影响：

```py
>>> all(t > 0 for t in temperatures)
True

```

### 将所有内容汇总在一起

在总结之前，让我们把我们做的一些事情整合起来，让你的计算机计算卢卡斯质数：

```py
>>> for x in (p for p in lucas() if is_prime(p)):
...     print(x)
...
2
3
7
11
29
47
199
521
2207
3571
9349
3010349
54018521
370248451
6643838879
119218851371
5600748293801
688846502588399
32361122672259149

```

当你看够了这些内容后，我们建议你花一些时间探索`itertools`模块。你越熟悉 Python 对可迭代对象的现有支持，你自己的代码就会变得更加优雅和简洁。

### 总结

+   理解是描述列表、集合和字典的简洁语法。

+   理解操作可迭代源对象，并应用可选的谓词过滤器和强制表达式，这两者通常都是关于当前项目的。

+   可迭代对象是我们可以逐个迭代的对象。

+   我们使用内置的`iter()`函数从可迭代对象中检索迭代器。

+   迭代器每次传递给内置的`next()`函数时，都会从底层可迭代序列中逐个产生项目。

+   当集合耗尽时，迭代器会引发`StopIteration`异常。

#### 生成器

+   生成器函数允许我们使用命令式代码描述序列。

+   生成器函数至少包含一次使用`yield`关键字。

+   生成器是迭代器。当迭代器使用`next()`进行推进时，生成器会开始或恢复执行，直到包括下一个`yield`为止。

+   对生成器函数的每次调用都会创建一个新的生成器对象。

+   生成器可以在迭代之间的局部变量中维护显式状态。

+   生成器是懒惰的，因此可以模拟无限的数据系列。

+   生成器表达式具有类似的语法形式，可以更声明式和简洁地创建生成器对象。

#### 迭代工具

+   Python 包括一套丰富的工具，用于处理可迭代系列，包括内置函数如`sum()`、`any()`和`zip()`，以及`itertools`模块中的工具。
