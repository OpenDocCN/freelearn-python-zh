# 第十三章：评估

# 第一章

1.  **什么是单体？**

单体应用是指以单个块创建的软件应用程序。该应用程序作为单个进程运行。它只能一起部署，尽管可以创建多个相同的副本。

1.  **单体可能会遇到什么问题？**

随着发展，单体可能会遇到以下问题：

+   代码变得太大且难以阅读。

+   可扩展性问题。

+   需要协调部署。

+   资源的不良使用。

+   不可能在不同情况下使用冲突的技术（例如，相同库的不同版本，或两种编程语言）。

+   一个错误和部署可能会影响整个系统。

1.  **你能描述微服务架构吗？**

微服务架构是一组松散耦合的专业化服务的集合，它们协同工作以提供全面的服务。

1.  **微服务最重要的特性是什么？**

微服务最重要的特性是它们可以独立部署，以便可以独立开发。

1.  **从单体架构迁移到微服务时，我们需要克服的主要挑战是什么？**

可能的挑战包括以下内容：

+   +   需要进行大的变更，需要我们改变服务的运行方式，包括团队的文化。这可能导致成本高昂的培训。

+   调试分布式系统更加复杂。

+   我们需要计划变更，以便不中断服务。

+   每个开发的微服务都会产生大量开销。

+   我们需要在允许每个团队决定如何工作和标准化以避免重复造轮之间找到平衡。

+   我们需要记录服务，以便与另一个团队进行交互。

1.  **我们如何进行这样的迁移？**

我们需要分析系统，测量，相应地计划并执行计划。

1.  **描述我们如何使用负载均衡器从旧服务器迁移到新服务器，而不中断系统。**

首先，我们必须配置负载均衡器，使其指向旧的 Web 服务器，这将使流量通过 Web 服务器。然后，我们必须更改 DNS 记录，使其指向负载均衡器。流量经过负载均衡器后，我们需要为新服务创建一个新条目，以便负载均衡器在两者之间分配流量。确认一切按预期工作后，我们需要从旧服务中删除条目。现在，所有流量将路由到新服务。

# 第二章

1.  **RESTful 应用程序的特征是什么？**

虽然 RESTful 应用程序被理解为将 URI 转换为对象表示并通过 HTTP 方法操纵它们的 Web 界面（通常使用 JSON 格式化请求），但 REST 架构的典型特征如下：

+   统一接口

+   客户端-服务器

+   无状态

+   可缓存

+   分层系统

+   按需代码（可选）

您可以在[`restfulapi.net/`](https://restfulapi.net/)了解有关 REST 架构的更多信息。

1.  **使用 Flask-RESTPlus 的优势是什么？**

使用 Flask-RESTPlus 的一些优势包括：

+   自动生成 Swagger。

+   可以定义和解析输入并整理输出的框架。

+   它允许我们在命名空间中组织代码。

1.  **Flask-RESTPlus 的一些替代方案是什么？**

其他选择包括 Flask-RESTful（这类似于 Flask-RESTPlus，但它不支持 Swagger）和 Django REST 框架，它拥有丰富的生态系统，充满了第三方扩展。

1.  命名用于测试以修复时间的 Python 软件包。

`freezegun`。

1.  **描述认证流程。**

认证系统（用户后端）生成编码的令牌。此令牌使用只有用户后端拥有的私钥进行编码。此令牌以 JWT 编码，并包含用户 ID 以及其他参数，例如告诉我们令牌有效的时间。此令牌包含在`Authentication`标头中。

令牌从标头中获取，并使用相应的公钥进行解码，该公钥存储在 Thoughts 后端中。这使我们能够独立获取用户 ID，并确信它已被用户后端验证。

1.  **为什么我们选择 SQLAlchemy 作为数据库接口？**

SQLAlchemy 在 Flask 中得到很好的支持，并允许我们定义已经存在的数据库。它高度可配置，并允许我们在低级别（即接近底层 SQL）和高级别上工作，从而消除了任何样板代码的需求。在我们的用例中，我们从遗留系统继承了一个数据库，因此需要与现有模式无缝工作。

# 第三章

1.  **Dockerfile 中的 FROM 关键字是做什么的？**

它从现有的镜像开始，向其添加更多的层。

1.  **如何使用预定义命令启动容器？**

您将运行以下命令：

```py
docker run image
```

1.  **为什么在 Dockerfile 中创建一个删除文件的步骤不会创建一个更小的镜像？**

由于 Docker 使用的文件系统具有分层结构，Docker 文件中的每个步骤都会创建一个新的层。文件系统是所有操作协同工作的结果。最终镜像包括所有现有的层；添加一个层永远不会减小镜像的大小。删除的新步骤将不会出现在最终镜像中，但它将始终作为前一个层的一部分可用。

1.  **多阶段 Dockerfile 是如何工作的？**

多阶段 Dockerfile 包含多个阶段，每个阶段都将以`FROM`命令开始，该命令指定作为起点的镜像。数据可以在一个阶段生成，然后复制到另一个阶段。

多阶段构建在我们希望减小最终镜像大小时非常有用；只有生成的数据将被复制到最终阶段。

1.  **运行和执行命令之间有什么区别？**

`run`命令从镜像启动一个新的容器，而`exec`命令连接到已经存在的运行中的容器。请注意，如果在执行时容器停止，会话将被关闭。

在`exec`会话中停止容器可能会发生。保持容器运行的主要进程是`run`命令。如果您终止命令或以其他方式停止它，容器将停止，会话将被关闭。

1.  **何时应该使用-it 标志？**

当您需要保持终端打开时，例如交互式运行`bash`命令。请记住这个助记符*交互式终端*。

1.  **除了使用 uWSGI 来提供 Web Python 应用程序之外，还有哪些替代方案？**

任何支持 WSGI 网络协议的 Web 服务器都可以作为替代方案。最受欢迎的替代方案是 Gunicorn，旨在易于使用和配置，`mod_wsgi`是流行的 Apache Web 服务器的扩展，支持 WSGI Python 模块，以及 CherryPy，它包括自己的 Web 框架。

1.  **docker-compose 用于什么？**

`docker-compose`允许轻松编排，也就是说，我们可以协调多个相互连接的 Docker 容器，使它们协同工作。它还帮助我们配置 Docker 命令，因为我们可以使用`docker-compose.yaml`文件来存储所有受影响容器的配置参数。

1.  **你能描述一下 Docker 标签是什么吗？**

Docker 标签是一种在保持其根名称的同时标记图像的方法。它通常标记相同应用程序或软件的不同版本。默认情况下，`latest`标签将应用于图像构建。

1.  **为什么我们需要将镜像推送到远程注册表？**

我们将镜像推送到远程注册表，以便与其他系统和开发人员共享镜像。除非需要将镜像推送到另一个存储库，否则 Docker 会在本地构建镜像，以便其他 Docker 服务可以使用它们。

# 第四章

1.  **增加部署数量是否会降低部署的质量？**

不会；已经证明增加部署数量与其质量增加有很强的相关性。一个能够快速部署的系统必须依赖于强大的自动化测试，这会增加系统的稳定性和整体质量。

1.  **什么是管道？**

管道是用于执行构建的有序步骤或阶段的连续顺序。如果其中一个步骤失败，构建将停止。步骤的顺序应该旨在最大程度地早期检测问题。

1.  **我们如何知道我们的主分支是否可以部署？**

如果我们自动运行我们的管道以在每次提交时生成构建，我们应该在提交时尽快检测主分支上的问题。构建应该让我们确信主分支的顶部提交可以部署。主分支的中断应该尽快修复。

1.  **Travis CI 的主要配置来源是什么？**

`.travis.yml`文件，可以在存储库的根目录中找到。

1.  **Travis CI 默认在何时发送通知邮件？**

Travis CI 在构建中断时发送通知邮件，以及先前中断的分支成功通过时发送通知邮件。成功的构建发生在先前的提交成功但未报告的情况下。

1.  **我们如何避免将中断的分支合并到主分支？**

我们可以通过在 GitHub 中进行配置来避免这种情况，这可以确保分支在合并到受保护的分支之前通过构建。为了确保功能分支没有偏离主分支，我们需要强制它与构建合并。为了实现这一点，它需要与主分支保持最新。

1.  **为什么我们应该避免将机密存储在 Git 存储库中？**

由于 Git 的工作方式，任何引入的机密都可以通过查看提交历史来检索，即使它已被删除。由于提交历史可以在任何克隆的存储库中复制，这使得我们无法验证它是否正确 - 我们无法将提交历史重写到克隆的存储库中。除非正确加密，机密不应存储在 Git 存储库中。任何错误存储的机密都应该被删除。

# 第五章

1.  **什么是容器编排器？**

容器编排器是一个系统，我们可以在其中部署多个容器，这些容器可以协同工作，并以有序的方式管理供应和部署。

1.  **在 Kubernetes 中，什么是节点？**

节点是集群中的物理服务器或虚拟机。节点可以被添加或从集群中移除，Kubernetes 会相应地迁移或重新启动正在运行的容器。

1.  **Pod 和容器之间有什么区别？**

一个 Pod 可以包含多个共享相同 IP 的容器。要在 Kubernetes 中部署容器，我们需要将其与一个 Pod 关联起来。

1.  **作业和 Pod 之间有什么区别？**

一个 Pod 预期会持续运行。一个作业或定时作业执行单个操作，然后所有 Pod 容器完成它们的执行。

1.  **我们何时应该添加 Ingress？**

当我们需要能够从集群外部访问服务时，我们应该添加 Ingress。

1.  **命名空间是什么？**

命名空间是一个虚拟集群。集群中的所有定义都需要具有唯一的名称。

1.  **我们如何在文件中定义 Kubernetes 元素？**

我们需要以 YAML 格式指定它，并提供关于其 API 版本、元素类型、具有名称和命名空间的元数据部分，以及`spec`部分中的元素定义。

1.  **kubectl get 和 describe 命令有什么区别？**

`kubectl get`获取多个元素，如服务或 pod，并显示它们的基本信息。另一方面，`describe`访问单个元素并呈现更多关于它的信息。

1.  CrashLoopBackOff 错误表示什么？

这个错误表明一个容器已经执行了定义的启动命令。这个错误只与 pod 有关，因为它们永远不应该停止执行。

# 第六章

1.  我们正在部署的三个微服务是什么？

以下是我们正在部署的三个微服务：

+   用户后端用于控制身份验证和用户处理方式。

+   Thoughts Backend 用于存储思想并允许我们创建和搜索它们。

+   前端为我们提供了一个用户界面，以便我们可以与系统进行交互。它通过 RESTful 调用调用其他两个微服务。

1.  这三个微服务中哪一个需要其他两个微服务可用？

前端调用其他两个微服务，因此它们需要对前端可用。

1.  为什么我们需要在运行 docker-compose 时使用外部 IP 连接到微服务？

`docker-compose`为每个微服务创建一个内部网络，因此它们需要使用外部 IP 进行通信，以便正确路由。虽然我们在主机计算机上暴露端口，但可以使用外部主机 IP。

1.  每个应用程序所需的主要 Kubernetes 对象是什么？

对于每个微服务，我们提供一个部署（自动生成一个 pod）、一个服务和一个 Ingress。

1.  有没有任何不需要的对象？

用户后端和 Thoughts 后端的 Ingress 并不是绝对必需的，因为它们可以通过节点端口访问，但这样做可以更轻松地访问它们。

1.  如果我们扩展到多个 pod 或任何其他微服务，我们能检测到问题吗？

用户后端和 Thoughts 后端创建了一个包含两个容器的 pod，其中包括数据库。如果我们创建多个 pod，将创建多个数据库，并在它们之间交替可能会导致问题。

例如，如果我们在一个 pod 中创建一个新的想法，如果请求是在另一个 pod 中进行的，我们将无法搜索到它。

另一方面，前端可以轻松扩展。

1.  我们为什么要使用`/etc/hosts`文件？

我们正在使用这个文件来定义一个`host`，将其路由到我们的本地 Kubernetes 集群。这样我们就不必定义 FQDN 并配置 DNS 服务器。

# 第七章

1.  为什么我们不应该管理自己的 Kubernetes 集群？

由于 Kubernetes 是一个抽象层，让云提供商负责维护、管理和安全最佳实践更加方便。将集群委托给现有的商业云提供商也非常便宜。

1.  你能说出一些具有托管 Kubernetes 解决方案的商业云提供商吗？

亚马逊网络服务、谷歌云服务、微软 Azure、Digital Ocean 和 IBM Cloud 都是商业云提供商，提供了托管的 Kubernetes 解决方案。

1.  你需要执行什么操作才能推送到 AWS Docker 注册表？

您需要登录到 Docker 守护程序。您可以使用以下代码获取登录命令：

```py
$ aws ecr get-login --no-include-email
```

1.  我们用什么工具来设置 EKS 集群？

`eksctl`允许我们从命令行创建整个集群，并根据需要进行扩展或缩减。

1.  我们在本章中做了哪些主要更改，以便我们可以使用之前章节中的 YAML 文件？

我们必须更改图像定义才能使用 AWS 注册表。我们包括了活跃性和就绪性探针，以及部署策略。

这些只添加到`frontend`部署中。将其余部署添加留给你作为练习。

1.  在这个集群中有没有不需要的 Kubernetes 元素？

Ingress 元素并不是严格要求的，因为 Thoughts Backend 和 Users Backend 无法从外部访问。前端服务能够创建一个面向外部的 ELB。

不要觉得我们的配置限制了你。你可以手动配置 ELB，这样你就可以以不同的方式访问集群，如果你愿意，你可以使用 Ingress 配置。

1.  **我们为什么需要控制与 SSL 证书关联的 DNS？**

我们需要证明我们拥有 DNS，以便 SSL 证书可以验证只有 DNS 地址的合法所有者才能访问该 DNS 的证书。这是 HTTPS 的根本要素，并且表明您正在与特定 DNS 的所有者进行私人通信。

1.  **存活探针和就绪探针之间有什么区别？**

如果就绪探针失败，Pod 将不接受请求，直到再次通过。如果存活探针失败，容器将被重新启动。

1.  **滚动更新在生产环境中为什么重要？**

它们很重要，因为它们避免了服务中断。它们一次添加一个工作进程，同时删除旧的工作进程，确保任何时候可用的工作进程数量保持不变。

1.  **自动缩放 Pod 和节点之间有什么区别？**

由于节点反映在物理实例中，对它们进行扩展会影响系统中的资源。与此同时，扩展 Pod 使用它们可用的资源，但不会修改它们。

换句话说，增加节点数量会增加需要在系统上运行的硬件。这是有成本的，因为我们需要从云提供商那里租用更多的硬件。增加 Pod 数量在硬件方面没有成本，这就是为什么应该有一些额外的开销来允许增加。

两种策略应该协调，以便我们可以迅速对负载增加做出反应，并同时减少正在使用的硬件数量，以便降低成本。

1.  **在本章中，我们部署了自己的数据库容器。在生产中，这是不需要的。但是，如果您连接到已经存在的数据库，您将如何做到这一点？**

第一步是更改`thoughts_backend/deployment.yaml`和`users_backend/deployment.yaml`文件中的环境变量。主要连接的是`POSTGRES_HOST`，但用户和密码可能也需要更改。

我们可以创建一个名为`postgres-db`的内部 Kubernetes 服务，它指向外部地址，而不是直接连接到`POSTGRES_HOST`作为 IP 或 DNS 地址。这可以帮助我们抽象外部数据库的地址。

这将一次性部署，以确保我们可以连接到外部数据库。

然后，我们可以删除部署中描述的数据库容器，即`thoughts-backend-db`和`users-backend-db`。这些容器的映像仅用于测试和开发。

# 第八章

1.  **使用脚本将新代码推送到服务器和使用 Puppet 等配置管理工具之间有什么区别？**

当使用脚本将新代码推送到服务器时，每台服务器都需要单独推送代码。*Puppet*和其他配置管理工具有一个集中的服务器，接收新数据并适当分发。它们还监视服务器是否按预期运行，并可以执行补救任务。

配置管理工具用于大型集群，因为它们减少了需要在自定义脚本中处理的工作量。

1.  **DevOps 的核心理念是什么？**

DevOps 的核心理念是赋予团队控制权，使他们能够自行部署和管理基础设施。这需要一套自动化程序作为安全网络，以确保这些操作易于进行、安全且快速。

1.  **使用 GitOps 的优势是什么？**

使用 GitOps 的主要优势如下：

+   Git 是大多数团队已经知道如何使用的常见工具。

+   它保留了基础设施定义的副本，这意味着我们可以将其用作备份，并从灾难性故障中恢复，或者轻松地基于先前的定义创建新的集群。

+   基础设施更改是有版本的，这意味着我们可以逐个进行小的离散更改，并在出现问题时撤消其中任何一个。

1.  **Kubernetes 集群只能使用 GitOps 吗？**

尽管 GitOps 与 Kubernetes 具有协同作用，因为 Kubernetes 可以通过 YAML 文件进行控制，但没有什么能阻止我们使用 Git 存储库来控制集群。

1.  **Flux 部署位于哪里？**

它位于自己的 Kubernetes 集群中，以便可以从 Git 中提取数据。

1.  **您需要在 GitHub 中配置什么，以便 Flux 可以访问它？**

您需要将 SSH 密钥添加到 GitHub 存储库的部署密钥中。您可以通过调用`fluxctl identity`来获取 SSH 密钥。

1.  **在生产环境中工作时，GitHub 提供的哪些功能确保我们对部署有控制？**

在我们可以合并到主分支之前，需要进行审查和批准，这会触发部署。强制从特定用户那里获得批准的代码所有者的包含可以帮助我们控制敏感区域。

# 第九章

1.  **在微服务架构下运行的系统中，当收到新的业务功能时，需要进行哪些分析？**

我们需要确定新业务功能影响哪个微服务或多个微服务。影响多个微服务的功能使其实施更加困难。

1.  **如果一个功能需要更改两个或更多微服务，我们如何决定首先更改哪个？**

这应该以向后兼容的方式进行，以保持向后兼容性。在考虑向后兼容性的情况下添加新功能，因此可能性有限。一旦后端准备就绪，前端可以相应地进行更改，以便我们可以利用新功能。

1.  **Kubernetes 如何帮助我们设置多个环境？**

在 Kubernetes 中创建新的命名空间非常容易。由于系统的定义封装在 YAML 文件中，它们可以被复制和修改以创建一个重复的环境。这可以用作基线，然后进行演变。

1.  **代码审查是如何工作的？**

在一个分支中的代码与主分支进行比较。另一个开发人员可以查看它们之间的差异并进行评论，要求澄清或更改。然后可以讨论这些评论，如果审阅者认为代码足够好，那么代码就可以被批准。合并可以被阻止，直到它获得一个或多个批准。

1.  **代码审查的主要瓶颈是什么？**

主要瓶颈是没有审阅者提供反馈并批准代码。这就是为什么有足够的人可以担任审阅者角色非常重要。

1.  **根据 GitOps 原则，部署的审查与代码审查不同吗？**

不；在 GitOps 下，部署被视为代码，因此它们可以像任何其他代码审查一样进行审查。

1.  **一旦功能准备合并到主分支中，为什么有一个清晰的部署路径是重要的？**

重要的是要有一个清晰的部署路径，以便每个人都在同一页面上。它还提供了部署速度的明确期望。通过这样做，我们可以指定何时需要审查。

1.  **为什么数据库迁移与常规代码部署不同？**

它们不同，因为无法轻松回滚。虽然代码部署可以回滚以便重新部署以前的镜像，但数据库迁移会对数据库或数据的模式进行更改，如果它们被回滚可能会导致数据丢失。通常，数据库迁移只能向前进行，任何出现的问题都需要通过新的部署进行更正。

这就是为什么我们必须特别小心数据库迁移，并确保它们不向后兼容的主要原因。

# 第十章

1.  **系统的可观察性是什么？**

这是系统的容量。它让您知道其内部状态是什么。

1.  **默认情况下日志中有哪些不同的严重级别？**

按严重性递增的不同严重级别是`DEBUG`、`INFO`、`WARNING`、`ERROR`和`CRITICAL`。

1.  **指标用于什么？**

指标允许您了解系统上发生的事件的聚合状态，并了解系统的一般状态。

1.  **为什么需要在日志中添加请求 ID？**

您需要向日志中添加请求 ID，以便您可以将与同一请求对应的所有日志分组在一起。

1.  **Prometheus 中有哪些类型的指标？**

计数器，用于计算特定事件；仪表，用于跟踪可以上升或下降的值；以及直方图（或摘要），用于跟踪与值相关联的事件，例如事件发生的时间或请求返回的状态代码。

1.  **度量中的 75th 百分位数是什么，它与平均值有何不同？**

对于直方图，*75^(th)*百分位数是平均值高于*25%*的事件的位置，而低于它的事件占*75%*。平均值是通过将所有值相加并将该值除以最初相加在一起的值的数量来找到的。通常，平均值将接近 50th 百分位数，尽管这取决于值的分布方式。

*90^(th)*-*95^(th)*百分位数对于确定延迟很有用，因为它提供了请求的上限时间，不包括异常值。平均值可能会被异常值所偏离，因此不能为绝大多数请求提供真实的数字。

1.  **四个黄金信号是什么？**

四个黄金信号是收集系统健康描述的四个测量值。它们是请求的延迟、流量量、返回错误的百分比和资源的饱和度。

# 第十一章

1.  **在微服务架构系统和单体架构中发布更改有哪些不同？**

在单体架构中发布更改只涉及一个存储库，因为单体只是一个代码库。在微服务架构中进行的一些更改将需要我们更改两个或更多微服务，以便我们可以分配它们。这需要更多的规划和关注，因为我们需要确保这是正确协调的。在正确架构的微服务系统中，这种多存储库更改应该相对罕见，因为它们会产生额外的开销。

1.  **为什么在微服务架构中发布更改应该小？**

微服务的优势在于我们可以并行发布微服务，这比单体发布更快。然而，鉴于微服务中的发布可能会影响其他微服务，它们应该以迭代方式工作，减少更改的规模并增加部署速度。

小的更改风险较小，如果需要，可以更容易地回滚。

1.  **语义版本如何工作？**

在语义版本中，版本有三个数字：*Major*版本号，*Minor*版本号和*Patch*版本号。它们之间都用点分隔：

+   补丁版本的增加只修复错误和安全问题。

+   次要版本的增加会增加更多功能，但不会引入向后不兼容的更改。

+   主要版本的增加会产生不向后兼容的更改。

1.  **微服务架构系统中内部接口的语义版本控制存在哪些问题？**

由于微服务中的部署非常常见，向后兼容性非常重要，因此*主要*发布的含义变得淡化。此外，大多数微服务的消费者是内部的，因此版本之间的隐式通信变得不那么重要。

当发布变得常见时，语义版本控制失去了意义，因为目标是不断完善和改进产品，而不是标记大的发布。

1.  **添加版本端点的优势是什么？**

任何使用微服务的消费者都可以以与进行任何其他请求相同的方式请求其版本：通过使用 RESTful 调用。

1.  **我们如何解决本章代码中的依赖问题？**

本章的代码存在依赖问题。

1.  **我们应该在共享 ConfigMap 中存储哪些配置变量？**

我们应该存储被多个微服务访问的配置变量。我们应该预先存储大部分配置变量，以便它们可以被重复使用。

1.  **描述将所有配置变量放入单个共享 ConfigMap 的优缺点。**

一个共享的 ConfigMap 使配置变量非常明确。它鼓励每个人重复使用它们，并告诉其他人配置用于其他微服务的用途。

更改微服务的依赖将触发重新启动，因此更改作为一切依赖的 ConfigMap 将导致集群中的所有微服务重新启动，这是耗时的。

此外，单个 ConfigMap 文件可能会变得相当大，将其拆分为几个较小的文件可以帮助我们更有效地组织数据。

1.  **Kubernetes ConfigMap 和 Kubernetes Secret 有什么区别？**

Kubernetes Secrets 更好地防止意外访问。直接访问工具不会以明文显示 Secret。对 Secret 的访问也需要以更明确的方式进行配置。另一方面，ConfigMaps 可以进行批量配置，因此 pod 将能够访问 ConfigMap 中存储的所有值。

1.  **我们如何更改 Kubernetes Secret？**

我们可以使用`kubectl edit`更改 Secret，但它需要以 Base64 格式进行编码。

例如，要用以下代码替换`postgres-password`秘密为`someotherpassword`值：

```py
$ echo someotherpassword | base64
c29tZW90aGVycGFzc3dvcmQK
$ kubectl edit secrets -n example thoughts-secrets
# Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: v1
data:
 postgres-password: c29tZW90aGVycGFzc3dvcmQK
...
secret/thoughts-secrets edited
```

一旦重新启动，我们的 pod 将能够使用新的 Secret。

1.  **假设基于我们的配置，我们决定将 public_key.pub 从 Secret 更改为 ConfigMap。我们需要做哪些更改？**

我们需要更改 ConfigMap，以便它包含`configuration.yaml`中的文件：

```py
THOUGHTS_BACKEND_URL: http://thoughts-service
public_key.pub: |
  -----BEGIN PUBLIC KEY-----
  <public key>
  -----END PUBLIC KEY-----
USER_BACKEND_URL: http://users-service
```

注意缩进以界定文件。 `|`字符标记多行字符串。

然后，在`deployment.yaml`文件中，我们需要将挂载的来源从 Secret 更改为 ConfigMap：

```py
volumes:
    - name: public-key
      configMap:
          name: shared-config
          items:
              - key: public_key.pub
                path: public_key.pub
```

记得先将这些更改应用到 ConfigMap 中，以便在应用部署文件时它们是可用的。

请注意，此方法创建了一个名为`public_key.pub`的环境变量，以及文件的内容，因为它作为`shared-config` ConfigMap 的一部分应用。另一种方法是创建一个独立的 ConfigMap。

在所有 pod 重新启动后，可以删除 Secret。

# 第十二章

1.  **为什么对于微服务架构系统来说，有一个领先的架构师很方便？**

在微服务架构中构建系统允许我们创建可以并行处理的独立服务。这些服务仍然需要相互通信和合作。

独立团队通常无法把握全局，倾向于专注于自己的项目。为了协调和整体系统的发展，独立团队需要一个高层次概览系统的首席架构师。

1.  **康威定律是什么？**

康威定律是一句谚语，它说软件结构复制了编写它的组织的沟通结构。

这意味着，要改变软件的结构，组织需要改变，这是一项更加困难的任务。

为了成功设计和发展大型系统，组织需要考虑并相应地进行规划。

1.  **技术债务是如何引入的？**

技术债务可以以许多方式产生。

通常，技术债务可以分为以下四类或它们的混合：

+   通过过快地发展而没有花时间分析其他选项

+   通过妥协缩短开发时间，同时知道这种妥协以后需要修复

+   通过对当前系统或工具的了解不够充分，或者缺乏培训或专业知识

+   通过对外部问题做出错误假设，从而为不一定需要修复的东西设计

1.  **为什么重要建立一种文化，以便我们可以持续减少技术债务？**

重要的是建立一种文化，以避免*软件腐烂*，即由于向现有软件添加复杂性而导致性能和可靠性持续下降。除非解决技术债务成为一个持续的过程，否则日常发布的压力意味着我们将无法进行维护。

1.  **为什么重要记录发布中的问题并与团队其他成员分享？**

这很重要，因为每个团队都可以从其他人的经验和解决方案中学习，并改进他们的流程。这也可以创造一种开放的文化，人们不会害怕对自己的错误负责。

1.  **事后总结会议的主要目标是什么？**

事后总结会议的主要目标是创建解决事故原因的后续任务。为此，我们需要尽可能确信已成功检测到根本原因（这也是次要目标）。
