# 第一章：一些准备工作

为了使本书其余部分的设计问题更加清晰，我们需要看一些我们的动机问题。其中之一是二十一点游戏。具体来说，我们对模拟玩二十一点的策略感兴趣。我们不想支持赌博。事实上，稍微研究一下就会发现这个游戏对玩家的不利程度非常高。这应该揭示出大多数赌场赌博只不过是对不识数的人的一种税收。

然而，模拟是面向对象编程的早期问题领域之一。这是一个面向对象编程特别优雅的领域。有关更多信息，请参见[`en.wikipedia.org/wiki/Simula`](http://en.wikipedia.org/wiki/Simula)。还请参见*Rob Pooley*的《Simula 编程简介》。

本章将介绍一些编写完整 Python 程序和包所必需的工具。我们将在后面的章节中使用这些工具。

我们将利用`timeit`模块来比较各种面向对象设计，以查看哪种性能更好。重要的是要权衡客观证据和代码如何反映问题领域的主观考虑。

我们将研究`unittest`和`doctest`模块的面向对象使用。这些是编写已知实际有效的软件的基本要素。

一个良好的面向对象设计应该清晰易懂。为了确保它被正确理解和使用以及维护，编写 Pythonic 文档是必不可少的。模块、类和方法中的文档字符串非常重要。我们将在这里简要介绍 RST 标记，并在第十八章*质量和文档*中深入讨论。

除此之外，我们将讨论**集成开发环境**（**IDE**）的问题。一个常见的问题是关于 Python 开发的*最佳*IDE。

最后，我们将介绍 Python 特殊方法名称背后的概念。特殊方法的主题填满了前七章。在这里，我们将提供一些背景知识，可能有助于理解第一部分*通过特殊方法创建 Python 类*。

我们将尽量避免陷入 Python 面向对象编程的基础知识。我们假设您已经阅读了*Packt Publishing*的《Python 3 面向对象编程》。我们不想重复已经在其他地方详细说明的事情。在本书中，我们将专注于 Python 3。

我们将涉及一些常见的面向对象设计模式。我们将尽量避免重复 Packt 的《学习 Python 设计模式》中的内容。

# 关于赌场二十一点

如果您对赌场二十一点游戏不熟悉，这里有一个概述。

目标是接受来自庄家的牌，以创建一个点数总和介于庄家总和和 21 之间的手。

数字牌（2 到 10）的点数等于数字本身。花牌（J、Q 和 K）值为 10 点。A 可以是 11 点或 1 点。当 A 作为 11 点时，手的值是*soft*。当 A 作为 1 点时，值是*hard*。

因此，一手有一张 A 和一张 7 的牌，硬总数为 8，软总数为 18。

有四种两张牌的组合总数为 21。尽管其中只有一种组合涉及到 J，但它们都被称为*blackjack*。

## 玩游戏

赌场二十一点游戏可能因赌场而异，但大纲是相似的。玩法的机制如下：

+   首先，玩家和庄家各发两张牌。玩家当然知道他们两张牌的价值。在赌场里，它们是正面朝上发的。

+   庄家的一张牌是正面朝上的，另一张是正面朝下的。因此，玩家对庄家的手有一些了解，但并非全部。

+   如果庄家展示了一张 A 牌，那么隐藏的牌价值为 10 且庄家有 21 点的概率是 4:13。玩家可以选择额外投保。

+   接下来，玩家可以选择要么接收牌要么停止接收牌。这两个最常见的选择被称为**拿牌**或**停牌**。

+   还有一些额外的选择。如果玩家的牌匹配，手可以分开。这是一个额外的赌注，两手分开玩。

+   最后，玩家可以在拿最后一张牌之前加倍下注。这被称为**加倍**。如果玩家的牌总数为 10 或 11，这是一个常见的赌注。

手的最终评估如下：

+   如果玩家超过 21 点，手就爆了，玩家输了，庄家的脸朝下的牌就不重要了。

+   如果玩家的总数是 21 或以下，那么庄家根据一个简单的固定规则拿牌。庄家必须打一个小于 18 的手。庄家必须站在一个总数为 18 或更多的手上。这里有一些小的变化，我们暂时可以忽略。

+   如果庄家爆了，玩家赢了。

+   如果庄家和玩家都是 21 或以下，那么比较手来看玩家是赢了还是输了。

最终赔偿的金额现在并不太重要。为了更准确地模拟各种玩法和投注策略，赔偿将非常重要。

## 21 点玩家策略

在 21 点的情况下（这与轮盘等游戏不同），玩家实际上必须使用两种策略，如下：

+   决定游戏玩法的策略：投保、拿牌、停牌、分牌或加倍。

+   决定下注金额的策略。一个常见的统计谬误导致玩家提高和降低他们的赌注，试图保留他们的赢利并最小化他们的损失。任何模拟赌场游戏的软件也必须模拟这些更复杂的投注策略。这些是有趣的算法，通常是有状态的，并导致学习一些高级的 Python 编程技术。

这两套策略是**策略**设计模式的主要示例。

## 用于模拟 21 点的对象设计

我们将使用玩家手和卡作为对象建模的示例。但我们不会设计整个模拟。我们将专注于这个游戏的元素，因为它们有一些微妙之处，但并不是非常复杂。

我们有一个简单的容器：一个手对象将包含零个或多个卡对象。

我们将查看`Card`的子类`NumberCard`、`FaceCard`和`Ace`。我们将查看定义这个简单类层次结构的各种方法。因为层次结构如此之小（和简单），我们可以很容易地尝试多种实现替代方案。

我们将看一些实现玩家手的方法。这是一个简单的卡片集合，带有一些额外的功能。

我们还需要把玩家作为一个整体来看。玩家将有一系列手，以及一个投注策略和一个 21 点游戏策略。这是一个相当复杂的复合对象。

我们还将快速查看洗牌和发牌的牌组。

# 性能- timeit 模块

我们将利用`timeit`模块来比较不同面向对象设计和 Python 构造的实际性能。`timeit`模块包含许多函数。我们将专注的是名为`timeit`的函数。这个函数为某个语句创建一个`Timer`对象。它还可以包括一些设置代码，准备环境。然后调用`Timer`的`timeit()`方法来执行设置一次，目标语句重复执行。返回值是运行语句所需的时间。

默认计数为 100,000。这提供了一个有意义的时间，可以平均出计算机上执行测量的其他操作系统级活动。对于复杂或长时间运行的语句，较低的计数可能更为谨慎。

以下是与`timeit`的简单交互：

```py
>>> timeit.timeit( "obj.method()", """
... class SomeClass:
...     def method(self):
...        pass
... obj= SomeClass()
""")
0.1980541350058047
```

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://www.packtpub.com)的帐户中购买的所有 Packt Publishing 图书下载示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便直接将文件发送到您的电子邮件。

语句`obj.method()`被提供给`timeit()`作为一个字符串。设置是类定义，也被提供为一个字符串。重要的是要注意语句所需的一切都必须在设置中。这包括所有的导入以及所有的变量定义和对象创建。一切。

完成设置可能需要几次尝试。在使用交互式 Python 时，我们经常会忘记全局变量和已经滚动到终端窗口顶部的导入。这个例子表明，执行 100,000 次什么都不做的方法调用需要 0.198 秒。

以下是另一个使用`timeit`的例子：

```py
>>> timeit.timeit( "f()","""
... def f():
...     pass
... """ )
0.13721893899491988
```

这告诉我们，一个无用的函数调用比一个无用的方法调用稍微便宜一些。在这种情况下的开销几乎是 44%。

在某些情况下，操作系统开销可能是性能的一个可测量的组成部分。这些往往会根据难以控制的因素而变化。在这种情况下，我们可以使用这个模块中的`repeat()`函数来代替`timeit()`函数。它将收集基本时间的多个样本，以便进一步分析操作系统对性能的影响。

对于我们的目的，`timeit()`函数将提供我们需要客观衡量各种面向对象设计考虑的反馈。

# 测试-单元测试和 doctest

单元测试绝对是必不可少的。如果没有自动化测试来展示特定元素的功能，那么这个功能实际上并不存在。换句话说，直到有一个测试表明它已经完成，它才算完成。

我们将间接地涉及测试。如果我们要深入研究每个面向对象设计特性的测试，这本书将比现在的两倍还要大。省略测试的细节的缺点是，它使得良好的单元测试看起来是可选的。它们绝对不是可选的。

### 提示

**单元测试是必不可少的**

如果有疑问，首先设计测试。将代码适应测试用例。

Python 提供了两个内置的测试框架。大多数应用程序和库都会同时使用这两个框架。所有测试的通用包装器是`unittest`模块。此外，许多公共 API 文档字符串都会有可以通过`doctest`模块找到并使用的示例。此外，`unittest`可以包含`doctest`模块。

一个崇高的理想是每个类和函数至少有一个单元测试。更重要的是，可见的类、函数和模块也将有`doctest`。还有其他崇高的理想：100%的代码覆盖率，100%的逻辑路径覆盖率等等。

从实际角度来看，有些类不需要测试。例如，由`namedtuple()`创建的类实际上不需要单元测试，除非您不信任`namedtuple()`的实现。如果您不信任您的 Python 实现，那么您实际上不能用它来编写应用程序。

通常，我们希望首先开发测试用例，然后编写符合这些测试用例的代码。测试用例为代码规范化了 API。这本书将揭示许多编写具有相同接口的代码的方法。这很重要。一旦我们定义了一个接口，仍然有许多候选实现适合这个接口。一组测试应该适用于几种不同的面向对象设计。

使用`unittest`工具的一般方法是为项目创建至少三个并行目录，如下所示：

+   `myproject`：这个目录是最终将安装在`lib/site-packages`中的包或应用程序。它有一个`__init__.py`包，我们将把我们的文件放在这里的每个模块中。

+   `测试`：此目录包含测试脚本。在某些情况下，脚本将与模块并行。在某些情况下，脚本可能比模块本身更大更复杂。

+   `doc`：这个目录有其他文档。我们将在下一节以及第十八章中涉及到这个。*质量和文档*。

在某些情况下，我们希望在多个候选类上运行相同的测试套件，以确保每个候选类都有效。对于实际上不起作用的代码进行`timeit`比较是没有意义的。

## 单元测试和技术尖峰

作为面向对象设计的一部分，我们经常会创建类似于本节中所示代码的技术尖峰模块。我们将其分为三个部分。首先，我们有以下总体抽象测试：

```py
import types
import unittest

class TestAccess( unittest.TestCase ):
    def test_should_add_and_get_attribute( self ):
        self.object.new_attribute= True
        self.assertTrue( self.object.new_attribute )
    def test_should_fail_on_missing( self ):
        self.assertRaises( AttributeError, lambda: self.object.undefined )
```

这个抽象的`TestCase`子类定义了一些我们期望一个类通过的测试。被测试的实际对象被省略了。它被引用为`self.object`，但没有提供定义，使得这个`TestCase`子类是抽象的。每个具体子类都需要一个`setUp()`方法。

以下是三个具体的`TestAccess`子类，它们将测试三种不同类型的对象：

```py
class SomeClass:
    pass
class Test_EmptyClass( TestAccess ):
    def setUp( self ):
       self.object= SomeClass()
class Test_Namespace( TestAccess ):
    def setUp( self ):
       self.object= types.SimpleNamespace()
class Test_Object( TestAccess ):
    def setUp( self ):
       self.object= object()
```

`TestAccess`类的子类分别提供了所需的`setUp()`方法。每个方法构建了不同类型的对象进行测试。一个是一个否则为空的类的实例。第二个是`types.SimpleNamespace`的实例。第三个是`object`的实例。

为了运行这些测试，我们需要构建一个套件，该套件不允许我们运行`TestAccess`抽象测试。

以下是剩下的尖峰：

```py
def suite():
    s= unittest.TestSuite()
    s.addTests( unittest.defaultTestLoader.loadTestsFromTestCase(Test_EmptyClass) )
    s.addTests( unittest.defaultTestLoader.loadTestsFromTestCase(Test_Namespace) )
    s.addTests( unittest.defaultTestLoader.loadTestsFromTestCase(Test_Object) )
    return s

if __name__ == "__main__":
    t= unittest.TextTestRunner()
    t.run( suite() )
```

我们现在有了具体证据，即`object`类不能像`types.SimpleNamespace`类一样使用。此外，我们有一个简单的测试类，我们可以用它来演示其他有效（或无效）的设计。例如，测试表明`types.SimpleNamespace`的行为类似于一个否则为空的类。

我们省略了许多潜在的单元测试案例的细节。我们将在第十五章中深入研究测试，*可测试性设计*。

# 文档字符串 - RST 标记和文档工具

所有 Python 代码都应该在模块、类和方法级别有文档字符串。并不是每个方法都需要有文档字符串。有些方法名选择得非常好，对它们几乎不需要多说。然而，大多数情况下，文档对于清晰度是必不可少的。

Python 文档通常使用**ReStructured Text**（**RST**）标记编写。

然而，在本书的代码示例中，我们将省略文档字符串。这样可以使书的大小保持在合理范围内。这种做法的缺点是，它使得文档字符串看起来是可选的。它们绝对不是可选的。

我们将再次强调。*文档字符串是必不可少的*。

Python 使用文档字符串的材料有以下三种方式：

+   内部的`help()`函数显示文档字符串

+   `doctest`工具可以在文档字符串中找到示例并将其作为测试用例运行

+   外部工具如**Sphinx**和**epydoc**可以生成优雅的文档摘录

由于 RST 的相对简单，编写良好的文档字符串非常容易。然而，我们将在第十八章中详细介绍文档和预期的标记，*质量和文档*。但是，现在，我们将提供一个文档字符串可能看起来像的快速示例：

```py
def factorial( n ):
    """Compute n! recursively.

    :param n: an integer >= 0
    :returns: n!

    Because of Python's stack limitation, this won't
    compute a value larger than about 1000!.

    >>> factorial(5)
    120
    """
    if n == 0: return 1
    return n*factorial(n-1)
```

这显示了参数和返回值的 RST 标记。它包括了一个关于深刻限制的额外说明。它还包括了可以用来验证实现的`doctest`工具的`doctest`输出。有许多标记特性可以用来提供额外的结构和语义信息。

# IDE 问题

一个常见的问题是关于 Python 开发的*最佳*IDE。简短的答案是，IDE 的选择一点都不重要。支持 Python 的开发环境数量是庞大的。

本书中的所有示例都显示了 Python `>>>`提示符下的交互式示例。交互式运行示例发出了一个深刻的声明。写得好的 Python 应该足够简单，可以从命令行运行。

### 注意

我们应该能够在`>>>`提示符下展示一个设计。

从`>>>`提示符下运行代码是 Python 设计复杂性的一个重要质量测试。如果类或函数太复杂，那么就没有简单的方法可以从`>>>`提示符下运行它。对于一些复杂的类，我们可能需要提供适当的模拟对象，以便轻松地进行交互使用。

# 关于特殊方法名

Python 有多个实现层。我们只对其中的两个感兴趣。

在表面上，我们有 Python 的源文本。这个源文本是传统面向对象的符号和过程式函数调用符号的混合。后缀面向对象的符号包括`object.method()`或`object.attribute`构造。前缀符号涉及`function(object)`构造，这更典型于过程式编程语言。我们还有中缀符号，比如`object+other`。当然，还有一些语句，比如`for`和`with`，调用对象方法。

`function(object)`前缀构造的存在导致一些程序员质疑 Python 的对象导向的“纯度”。不清楚是否严格遵守`object.method()`符号是必要的，甚至有帮助。Python 使用了前缀和后缀符号的混合。前缀符号是特殊方法后缀符号的替身。前缀、中缀和后缀符号的存在是基于表达和美学的选择。写得好的 Python 的一个目标是它应该读起来更像英语。在底层，语法变化是由 Python 的特殊方法一致地实现的。

Python 中的一切都是对象。这与 Java 或 C++不同，那里有避免对象范式的“原始”类型。每个 Python 对象都提供了一系列特殊方法，用于提供语言表面特性的实现细节。例如，我们可能在应用程序中写`str(x)`。这个前缀表面符号是作为`x.__str__()`在底层实现的。

诸如`a+b`这样的构造可能被实现为`a.__add__(b)`或`b.__radd__(a)`，这取决于内置到对象`a`和`b`的类定义中的兼容性规则。

表面语法和特殊方法的实现之间的映射绝对不是从`function(x)`到`x.__function__()`的简单重写。有许多语言特性具有有趣的特殊方法来支持该特性。一些特殊方法具有从基类`object`继承的默认实现，而其他特殊方法没有默认实现，并将引发异常。

在第一部分中，*通过特殊方法实现 Pythonic 类*，我们将介绍特殊方法，并展示如何实现这些特殊方法，以提供 Python 和我们的类定义之间的无缝集成。

# 总结

我们已经看过我们的一个示例问题领域：21 点赌场游戏。我们喜欢它是因为它具有一定的算法复杂性，但并不太复杂或玄妙。我们还介绍了三个重要的模块，这些模块将贯穿整本书的使用。

+   `timeit`模块是我们将用来比较替代实现性能的工具。

+   `unittest`和`doctest`模块将被用来确认我们的软件是否正确工作。

我们还看了一些我们将如何为我们的 Python 程序添加文档的方式。我们将在模块、类和函数中使用文档字符串。为了节省空间，不是每个示例都会显示文档字符串。尽管如此，它们应该被视为必不可少的。

**集成开发环境**（**IDE**）并非必需。任何适合您的 IDE 或文本编辑器都可以用于高级 Python 开发。

接下来的八章将涉及特殊方法名称的不同子集。这些方法是关于我们如何创建与内置库模块无缝集成的 Python 编程。

在下一章中，我们将专注于`__init__()`方法以及我们可以使用它的各种方式。`__init__()`方法很重要，因为初始化是对象生命周期中的第一步；每个对象必须被正确初始化才能正常工作。比这更重要的是，`__init__()`的参数值可以采用多种形式。我们将探讨多种设计`__init__()`的方式。
