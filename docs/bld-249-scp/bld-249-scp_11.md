# 附录 B. 常见陷阱

# 阅读 API 文档

虽然听起来有些繁琐，但说许多在 Blender 论坛上提出的与 Python 相关的问题可以通过仔细阅读 API 文档来简单地回答，这并不夸张。

当然，这些文档不是最容易阅读的，因为它们涵盖了众多主题，而且往往不清楚从哪里开始阅读，所以至少从头到尾完整阅读一次可能是个好主意。这不仅会给你一些关于 Blender API 广阔范围的想法，而且还会帮助你以后找到特定的主题。

# 导入的问题

经常出现的问题之一是为什么 `import` 语句没有按预期工作。这里的问题是，你必须知道预期的结果。Blender 扩展了 Python 的标准导入行为，使其能够从 `.blend` 文件中驻留的文本文件中导入。这是一个巨大的便利，因为它允许你模块化你的代码，而无需分发单独的文件。然而，导入这些内部文件的部分的行为应该非常清晰，以避免让你遇到令人不快的惊喜，但目前这部分并不是非常详细地记录在文档中。

当执行如 `import foo` 这样的 `import` 语句时，会发生以下情况：

1.  检查 `foo.pyc` 或 `foo.py` 是否存在于 `sys.path` 中的任何目录中

1.  如果其中之一存在：

    +   如果 `foo.py` 更新了

        +   编译 `foo.pyfoo.pyc`

    +   使用 `foo.pyc`

1.  否则，如果 `foo.py` 作为内部文本文件存在：

    +   如果它尚未编译：

        +   编译内部文本文件

    +   使用编译版本

1.  否则

    +   抛出异常

第一部分是 Python 的常规行为（这里简化了一些，因为我们没有在这里提及包或 `.pyo` 文件），第二部分是如果所需的模块不是外部文件时，Blender 添加到其中的内容。这里有两个重要的事项需要注意：如果存在与内部文件同名的外部文件，外部文件（或其编译版本）将具有优先权。这可能会让人烦恼，因为许多人保存了与内部文件同名的外部副本。如果这两个文件不同步，可能会发生意外的事情。幸运的是，Blender 的内部编辑器通过在内部文件名称旁边显示一个 **Out of Sync**（不同步）按钮来提醒你这种情况。尽管如此，如果你没有打开该特定文件的文本编辑器，你可能不会注意到它。

此外，如果你仔细查看之前的概述，你会注意到如果 Blender 正在寻找一个内部文件，它会检查这个内部文件是否已经编译，但不会检查源文件是否可能更新。这意味着任何要导入的内部源代码更改都不会被主程序看到。为了解决这个问题，你可以通过使用内置的 `reload()` 函数强制 Python 编译模块。这在运行程序时效率较低，但在开发过程中可以节省很多麻烦。一旦你的脚本准备就绪，你可能会放弃使用 `reload()`。

假设你有两个内部文件，`main.py` 和 `mymodule.py`，并且你想要确保在 `main.py` 执行后，`module.py` 的更改始终可见，那么每个文件可能看起来像这样：

```py
# main.py

import mymodule
reload(mymodule)

mymodule.myfunction()

# mymodule.py

def myfunction():
   print "myfunction called"
```

突出的行显示了至关重要的 `reload()` 函数。

# 安装完整的 Python 发行版

两个具体问题经常出现：要么是一个标准的 Python 模块似乎丢失了（一个 `import` 语句会引发异常，告诉你它找不到请求的模块），要么 Blender 警告说它找不到与编译版本相等的 Python 发行版。

这两个问题都在 第一章 *使用 Python 扩展 Blender* 中得到了解决，并且对于更多信息请参考：[`wiki.blender.org/index.php/Doc:Manual/Introduction/Installing_Blender/Python`](http://wiki.blender.org/index.php/Doc:Manual/Introduction/Installing_Blender/Python)。
