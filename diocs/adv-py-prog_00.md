# 前言

*高级 Python 编程*作为指南，帮助你将 Python 技能提升到下一个层次。对于初学者来说，由于其简单的语法，Python 是快速原型设计和软件开发的一个很好的选择，但当人们想要加速和扩展他们的代码时，有些人倾向于转向其他语言。然而，这种心态并不一定正确。正如本书将向我们展示的那样，Python 提供了广泛的支持，用于优化、扩展和整体高性能计算。

第二版包含了第一版中的更新内容和新增内容。许多包含重叠材料的章节已被合并，以使整本书的逻辑流程更加简洁。此外，还增加了一章关于 JAX 的内容，JAX 是机器学习中最高性能计算工具。这些调整有望使本书成为所有寻求从其程序中获得最大价值的 Python 用户的优质文本。

在本书结束时，你将接触到各种技术和库，它们旨在简化、保护和优化你的软件。你将获得实际技能，了解如何使你的 Python 应用程序健壮、高效和可扩展。

# 本书面向对象

本书面向中级到高级的 Python 程序员，他们希望以系统化和稳健的方式扩展其应用程序。来自不同背景的程序员会发现这本书很有用，包括软件工程师、科学程序员和软件架构师。

# 本书涵盖内容

*第一章*，*基准测试和性能分析*，教你如何评估 Python 程序的性能，以及如何识别和隔离代码中的慢速部分的实际策略。

*第二章*，*纯 Python 优化*，讨论了如何通过使用 Python 标准库和纯 Python 第三方模块中的高效数据结构和算法来提高你的运行时间。

*第三章*，使用 NumPy、Pandas 和 Xarray 进行快速数组操作，提供了对 NumPy 和 pandas 包的指南。掌握这些包将允许你使用表达性强、简洁的接口实现快速数值算法。

*第四章*，*使用 Cython 进行 C 性能提升*，是关于 Cython 的教程，Cython 是一种使用与 Python 兼容的语法来生成高效 C 代码的语言。

*第五章*，*探索编译器*，介绍了可用于将 Python 编译成高效机器代码的工具。本章将教会你如何使用 Numba，一个针对 Python 函数的优化编译器，以及 PyPy，一个可以在运行时执行和优化 Python 程序的替代解释器。

*第六章*, *自动微分和加速线性代数在机器学习中的应用*，涵盖了高性能 Python 编程，这在科学计算和机器学习中至关重要。JAX 在底层实现了许多编译器相关的优化，这显著加快了 NumPy 操作的速度。此外，该工具可以自动微分原生 Python 函数，使得基于梯度的优化算法得以广泛应用。

*第七章*, *实现并发*，提供了异步和响应式编程的指南。我们将学习关键术语和概念，并演示如何使用 asyncio 和 RxPy 框架编写干净、并发的代码。

*第八章*, *并行处理*，介绍了在多核处理器和 GPU 上的并行编程。在本章中，你将学习如何使用 multiprocessing 模块以及通过使用 Theano 和 TensorFlow 表达你的代码来实现并行性。

*第九章*, *并发 Web 请求*，涵盖了并发编程的主要应用之一：网络爬虫。在讨论如何将线程应用于并行化此过程之前，本章还涵盖了网络爬取的其他相关元素。

*第十章*, *并发图像处理*，深入探讨了并发的具体应用：图像处理。本章讨论了图像处理的基本思想以及一些最常用的处理技术。当然，我们还将看到如何通过并发，特别是多进程，来加速图像处理任务。

*第十一章*, *使用 asyncio 构建通信通道*，结合了前几章中关于异步编程的知识以及网络通信的主题。具体来说，我们将探讨如何使用 aiohttp 模块作为工具向 Web 服务器发送异步 HTTP 请求，以及实现异步文件读写操作的 aiofile 模块。

*第十二章*, *死锁*，介绍了在并发编程中常见的问题之一。我们将通过经典的食物哲学家问题作为例子，了解死锁如何导致并发程序停止运行。本章还涵盖了处理死锁的多种潜在方法以及相关概念，如活锁和分布式死锁。

*第十三章*，*饥饿问题*，考虑了并发应用程序中的另一个常见问题。本章通过经典读者-写者问题的叙述来解释饥饿的概念及其原因。当然，我们还将通过 Python 的实际示例讨论这些问题的潜在解决方案。

*第十四章*，*竞态条件*，讨论了可能是最著名的并发问题：竞态条件。我们还将讨论临界区概念，这在竞态条件的特定背景下，以及在并发编程中都是基本元素。本章随后介绍了互斥作为解决此问题的潜在方法。

*第十五章*，*全局解释器锁*，介绍了臭名昭著的全局解释器锁（GIL），被认为是 Python 并发编程中最大的挑战。我们将了解 GIL 实现背后的原因以及它引起的问题。本章最后将讨论 Python 程序员和开发者应该如何思考和与 GIL 交互的一些想法。

*第十六章*，*工厂模式*，教你如何使用工厂设计模式（工厂方法和抽象工厂）初始化对象，并涵盖使用工厂设计模式而不是直接对象实例化的好处。

*第十七章*，*建造者模式*，教你如何简化由多个相关对象组成的案例的对象创建过程。我们将回顾现实世界的例子和用例，然后在一个比萨订购应用程序的开发中实现建造者模式。

*第十八章*，*其他创建型模式*，教你如何使用诸如创建一个现有对象的全拷贝（一个命名克隆）等技巧来处理其他对象创建情况，这是原型模式提供的技术。你还将了解单例模式。

*第十九章*，*适配器模式*，教你如何通过最小更改使现有代码与外部接口（例如，外部库）兼容。具体来说，你将看到如何使用适配器模式实现接口一致性，而不修改不兼容模型源代码。

*第二十章*，*装饰者模式*，教你如何在不用继承的情况下增强对象的功能。我们将提及几个横切关注点类别，并具体演示在这个视角中的记忆化。我们还将描述装饰者如何帮助我们保持函数的整洁，同时不牺牲性能。

*第二十一章*，*桥接模式*，教您如何将对象的实现细节从其类层次结构外部化到另一个对象类层次结构。本章鼓励优先考虑组合而非继承。

*第二十二章*，*外观模式*，教您如何创建一个单一入口点来隐藏系统的复杂性。我们将介绍外观模式的基本用例和多服务器操作系统使用的接口实现。

*第二十三章*，*其他结构型模式*，介绍了享元模式、**模型-视图-控制器**（**MVC**）和代理模式。使用享元模式，您将学习如何从对象池中重用对象以改善内存使用并可能提高应用程序的性能。MVC 模式在应用程序开发（桌面和网页）中用于通过避免将业务逻辑与用户界面混合来提高可维护性。而使用代理模式，您提供一个特殊对象，作为其他对象的代理或占位符，以控制对其的访问并减少复杂度或提高性能。

*第二十四章*，*责任链模式*，教您另一种技术，通过避免将业务逻辑与用户界面混合来提高应用程序的可维护性。

*第二十五章*，*命令模式*，教您如何将操作（如撤销、复制和粘贴）封装为对象，以改进您的应用程序。这种技术的优点之一是调用命令的对象与执行它的对象解耦。

*第二十六章*，*观察者模式*，教您如何向多个接收者发送请求。

# 要充分利用本书

本书使用的代码已在 macOS Big Sur、Windows、Ubuntu 和 Monterey 上的 Python 3.8 版本上进行了测试。

您首先应安装 Python，最好是在虚拟环境中。推荐的安装方法是使用 Anaconda，可以从[`www.anaconda.com/products/individual`](https://www.anaconda.com/products/individual)下载。个别章节可能会讨论必须通过包管理器安装的各种外部库和工具，以及如何进行安装的具体说明，这些说明包含在相应的文本中。

注意

如果您使用的是本书的数字版，我们建议您亲自输入代码或从本书的 GitHub 仓库（下一节中提供链接）获取代码。这样做将帮助您避免与代码复制粘贴相关的任何潜在错误。

# 下载示例代码文件

您可以从 GitHub 上下载本书的示例代码文件[`github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition`](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition)。如果代码有更新，它将在 GitHub 仓库中更新。

我们还有其他来自我们丰富的书籍和视频目录的代码包可供在[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)找到。去看看吧！

# 下载彩色图像

我们还提供了一份包含本书中使用的截图和图表彩色图像的 PDF 文件。您可以从这里下载：[`static.packt-cdn.com/downloads/9781801814010_ColorImages.pdf`](https://static.packt-cdn.com/downloads/9781801814010_ColorImages.pdf)。

# 使用的约定

本书中使用了多种文本约定。

`文本中的代码`：表示文本中的代码单词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 昵称。以下是一个示例：“在我们的主程序中，我们首先创建一个作为锁对象的分支；然后，我们创建两个`Spouse`线程对象，它们是彼此的`partner`属性。”

代码块设置如下：

```py
fork = threading.Lock()
partner1 = Spouse('Wife', None)
partner2 = Spouse('Husband', partner1)
partner1.partner = partner2
partner1.start()
partner2.start()
partner1.join()
partner2.join()
print('Finished.')
```

当我们希望您注意代码块中的特定部分时，相关的行或项目将以粗体显示：

```py
fork = threading.Lock()
partner1 = Spouse('Wife', None)
partner2 = Spouse('Husband', partner1)
partner1.partner = partner2
partner1.start()
partner2.start()
partner1.join()
partner2.join()
print('Finished.')
```

任何命令行输入或输出都如下所示：

```py
pip install numpy
```

**粗体**：表示新术语、重要单词或您在屏幕上看到的单词。例如，菜单或对话框中的单词以粗体显示。以下是一个示例：“**坐标**部分显示了这些维度可以取的值。”

小贴士或重要提示

看起来像这样。

# 联系我们

我们始终欢迎读者的反馈。

**一般反馈**：如果您对本书的任何方面有疑问，请通过电子邮件发送至 customercare@packtpub.com，并在邮件主题中提及书名。

**勘误**：尽管我们已经尽一切努力确保内容的准确性，但错误仍然可能发生。如果您在这本书中发现了错误，我们将非常感激您能向我们报告。请访问[www.packtpub.com/support/errata](http://www.packtpub.com/support/errata)并填写表格。

**盗版**：如果您在互联网上以任何形式发现我们作品的非法副本，我们将非常感激您能提供位置地址或网站名称。请通过电子邮件发送至 copyright@packt.com 并提供材料的链接。

**如果您有兴趣成为作者**：如果您在某个主题上具有专业知识，并且您有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com)。

# 分享您的想法

一旦您阅读了《高级 Python 编程》，我们非常期待听到您的想法！请[点击此处直接访问此书的亚马逊评论页面](https://packt.link/r/1801814015)并分享您的反馈。

您的评论对我们和科技社区都非常重要，它将帮助我们确保我们提供高质量的内容。
