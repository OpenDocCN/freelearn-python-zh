- en: Chapter 2. Layout Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 布局管理
- en: 'In this chapter we will lay out our GUI using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 3 来搭建我们的图形用户界面：
- en: Arranging several labels within a label frame widget
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签框架小部件中排列多个标签
- en: Using padding to add space around widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用填充来为小部件周围添加空间
- en: How widgets dynamically expand the GUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件如何动态扩展GUI
- en: Aligning the GUI widgets by embedding frames within frames
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在框架内嵌套框架来对齐GUI小部件
- en: Creating menu bars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: Creating tabbed widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标签式小部件
- en: Using the grid layout manager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will explore how to arrange widgets within widgets to create
    our Python GUI. Learning the fundamentals of GUI layout design will enable us
    to create great looking GUIs. There are certain techniques that will help us to
    achieve this layout design.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在窗口小部件内部排列小部件以创建我们的Python图形用户界面。掌握GUI布局设计的根本原理将使我们能够创建外观出色的GUI。有一些技术将帮助我们实现这种布局设计。
- en: The grid layout manager is one of the most important layout tools built into
    tkinter that we will be using.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是tkinter内置的最重要的布局工具之一，我们将要使用它。
- en: We can very easily create menu bars, tabbed controls (aka Notebooks), and many
    more widgets using tk.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地使用 tk 创建菜单栏、标签控制（即笔记本）以及许多其他小部件。
- en: One widget that is missing out of the box from tk is a status bar.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: tk中缺少一个开箱即用的状态栏组件。
- en: In this chapter, we will not bother to hand-craft this widget, but it can be
    done.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不必费心手工制作这个小部件，但它是可以完成的。
- en: Arranging several labels within a label frame widget
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在标签框架小部件中排列多个标签
- en: The `LabelFrame` widget allows us to design our GUI in an organized fashion.
    We are still using the grid layout manager as our main layout design tool, yet
    by using `LabelFrame` widgets we get much more control over our GUI design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`小部件允许我们以有组织的方式设计我们的GUI。我们仍然使用网格布局管理器作为我们的主要布局设计工具，但通过使用`LabelFrame`小部件，我们对GUI设计有了更多的控制。'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We are starting to add more and more widgets to our GUI, and we will make the
    GUI fully functional in the coming recipes. Here, we are starting to use the `LabelFrame`
    widget. We will reuse the GUI from the last recipe of the previous chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始在我们的GUI中添加越来越多的控件，并在接下来的菜谱中使GUI完全功能化。在这里，我们开始使用`LabelFrame`控件。我们将重用上一章最后一个菜谱中的GUI。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add the following code just above the main event loop towards the bottom of
    the Python module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python模块的底部主事件循环上方添加以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![How to do it...](img/B04829_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_01.jpg)'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can easily align the labels vertically by changing our code, as shown next.
    Note that the only change we had to make was in the column and row numberings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改代码轻松地垂直对齐标签，如下所示。请注意，我们唯一需要做的更改是在列和行编号上。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![How to do it...](img/B04829_02_01_1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_01_1.jpg)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Comment # 1: Here, we will create our first ttk LabelFrame widget and give
    the frame a name. The parent container is `win`, our main window.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 # 1：在这里，我们将创建我们的第一个 ttk LabelFrame 小部件，并为框架命名。父容器是 `win`，即我们的主窗口。'
- en: 'The three lines following comment # 2 create label names and place them in
    the LabelFrame. We are using the important grid layout tool to arrange the labels
    within the LabelFrame. The column and row properties of this layout manager give
    us the power to control our GUI layout.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释# 2之后的三个行创建标签名称并将它们放置在LabelFrame中。我们正在使用重要的网格布局工具来排列LabelFrame内的标签。这个布局管理器的列和行属性赋予我们控制GUI布局的能力。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The parent of our labels is the LabelFrame, not the `win` instance variable
    of the main window. We can see the beginning of a layout hierarchy here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标签的父容器是LabelFrame，而不是主窗口的`win`实例变量。在这里我们可以看到布局层次结构的开始。
- en: 'The highlighted comment # 3 shows how easy it is to change our layout via the
    column and row properties. Note how we change the column to 0, and how we layer
    our labels vertically by numbering the row values sequentially.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '突出的注释 # 3 展示了如何通过列和行属性轻松更改我们的布局。注意我们如何将列更改为 0，以及我们如何通过按顺序编号行值来垂直堆叠我们的标签。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The name ttk stands for "themed tk". The tk-themed widget set was introduced
    in Tk 8.5.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ttk 的名字代表 "主题化的 tk"。Tk 8.5 中引入了 tk 主题化的控件集。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In a recipe later in this chapter, we will embed LabelFrame(s) within LabelFrame(s),
    nesting them to control our GUI layout.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的食谱中，我们将嵌入LabelFrame(s)到LabelFrame(s)中，通过嵌套它们来控制我们的GUI布局。
- en: Using padding to add space around widgets
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用填充来为小部件周围添加空间
- en: Our GUI is being created nicely. Next, we will improve the visual aspects of
    our widgets by adding a little space around them, so they can breathe...
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形用户界面正在顺利创建。接下来，我们将通过在它们周围添加一些空间来改善我们小部件的视觉外观，这样它们就可以呼吸了...
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: While tkinter might have had a reputation for creating ugly GUIs, this has dramatically
    changed since version 8.5, which ships with Python 3.4.x. You just have to know
    how to use the tools and techniques that are available. That's what we will do
    next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 tkinter 可能曾因创建丑陋的 GUI 而声名狼藉，但自从 8.5 版本（随 Python 3.4.x 一起发布）以来，这一情况已经发生了显著变化。你只需知道如何使用可用的工具和技术。这正是我们接下来要做的。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The procedural way of adding spacing around widgets is shown first, and then
    we will use a loop to achieve the same thing in a much better way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先展示的是围绕小部件添加间距的流程方式，然后我们将使用循环以更优的方式实现相同的效果。
- en: Our LabelFrame looks a bit tight as it blends into the main window towards the
    bottom. Let's fix this now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LabelFrame在底部与主窗口融合时看起来有点紧凑。现在我们来修复这个问题。
- en: 'Modify the following line of code by adding `padx` and `pady`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 修改以下代码行，通过添加`padx`和`pady`：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And now our LabelFrame got some breathing space:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 我们的 LabelFrame 获得了一些呼吸空间：
- en: '![How to do it...](img/B04829_02_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_02.jpg)'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In tkinter, adding space horizontally and vertically is done by using the built-in
    properties named `padx` and `pady`. These can be used to add space around many
    widgets, improving horizontal and vertical alignments, respectively. We hard-coded
    20 pixels of space to the left and right of the LabelFrame, and we added 40 pixels
    to the top and bottom of the frame. Now our LabelFrame stands out more than it
    did before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在tkinter中，通过使用名为`padx`和`pady`的内置属性来添加水平和垂直空间。这些属性可以用来在许多小部件周围添加空间，分别改善水平和垂直对齐。我们硬编码了20像素的空间到LabelFrame的左右两侧，并在框架的顶部和底部添加了40像素的空间。现在我们的LabelFrame比之前更加突出。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshot above only shows the relevant change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图仅显示了相关更改。
- en: 'We can use a loop to add space around the labels contained within the LabelFrame:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用循环来在包含在LabelFrame中的标签周围添加空格：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the labels within the LabelFrame widget have some space around them too:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在LabelFrame小部件内的标签周围也有一些空间：
- en: '![How it works...](img/B04829_02_02_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_02_02_1.jpg)'
- en: The `grid_configure()` function enables us to modify the UI elements before
    the main loop displays them. So, instead of hard-coding values when we first create
    a widget, we can work on our layout and then arrange spacing towards the end of
    our file, just before the GUI is being created. This is a neat technique to know.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid_configure()` 函数使我们能够在主循环显示之前修改 UI 元素。因此，当我们首次创建小部件时，我们不必硬编码值，而是可以先工作在布局上，然后在文件末尾创建
    GUI 之前调整间距。这是一个值得了解的技巧。'
- en: The `winfo_children()` function returns a list of all the children belonging
    to the `labelsFrame` variable. This enables us to loop through them and assign
    the padding to each label.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()` 函数返回属于 `labelsFrame` 变量的所有子元素的列表。这使得我们可以遍历它们，并为每个标签分配填充。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: One thing to notice is that the spacing to the right of the labels is not really
    visible. This is because the title of the LabelFrame is longer than the names
    of the labels. We can experiment with this by making the names of the labels longer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项之一是标签右侧的间距实际上并不明显。这是因为LabelFrame的标题长度超过了标签的名称。我们可以通过使标签的名称更长来实验这个问题。
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now our GUI looks like the following. Note how there is now some space added
    to the right of the long label next to the dots. The last dot does not touch the
    LabelFrame, which it would without the added space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI看起来如下。注意现在在点旁边的长标签右侧增加了一些空间。最后一个点没有接触到LabelFrame，如果没有增加空间，它本会触碰到。
- en: '![How it works...](img/B04829_02_02_2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_02_02_2.jpg)'
- en: We can also remove the name of the LabelFrame to see the effect `padx` has on
    positioning our labels.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以移除LabelFrame的名称来观察`padx`对定位我们的标签有何影响。
- en: '![How it works...](img/B04829_02_02_3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_02_02_3.jpg)'
- en: How widgets dynamically expand the GUI
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件如何动态扩展GUI
- en: You probably noticed in previous screenshots and by running the code that widgets
    have a capability to extend themselves to the space they need to visually display
    their text.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了在之前的截图和运行代码的过程中，小部件具有扩展自身以适应所需空间来视觉显示文本的能力。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Java introduced the concept of dynamic GUI layout management. In comparison,
    visual development IDEs like VS.NET lay out the GUI in a visual manner, and are
    basically hard-coding the x and y coordinates of UI elements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java引入了动态GUI布局管理的概念。相比之下，像VS.NET这样的可视化开发IDE以可视化的方式布局GUI，基本上是硬编码UI元素的x和y坐标。
- en: Using `tkinter`, this dynamic capability creates both an advantage and a little
    bit of a challenge, because sometimes our GUI dynamically expands when we would
    prefer it rather not to be so dynamic! Well, we are dynamic Python programmers,
    so we can figure out how to make the best use of this fantastic behavior!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tkinter`，这种动态能力既带来优势也带来一点挑战，因为有时候我们更希望我们的GUI不要那么动态地扩展！嗯，我们是动态的Python程序员，所以我们可以找出如何充分利用这种出色的行为！
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: At the beginning of the previous recipe we added a label frame widget. This
    moved some of our controls to the center of column 0\. We might not wish this
    modification to our GUI layout. Next, we will explore some ways to fix this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一道菜谱的开始部分，我们添加了一个标签框架小部件。这使我们的部分控件移动到了第0列的中心。我们可能不希望对GUI布局进行这种修改。接下来，我们将探讨一些修复此问题的方法。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let us first become aware of the subtle details that are going on in our GUI
    layout, in order to understand it better.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先意识到在我们GUI布局中正在发生的微妙细节，以便更好地理解它。
- en: We are using the grid layout manager widget and it lays out our widgets in a
    zero-based grid.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用网格布局管理器小部件，并且它以零为基础的网格排列我们的小部件。
- en: '| Row 0; Col 0 | Row 0; Col 1 | Row 0; Col 2 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 行 0; 列 0 | 行 0; 列 1 | 行 0; 列 2 |'
- en: '| Row 1; Col 0 | Row 1; Col 1 | Row 1; Col 2 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 第1行；第0列 | 第1行；第1列 | 第1行；第2列 |'
- en: Using the grid layout manager, what is happening is that the width of any given
    column is determined by the longest name or widget in that column. This affects
    all rows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格布局管理器时，所发生的情况是任何给定列的宽度由该列中最长名称或小部件决定。这会影响所有行。
- en: By adding our LabelFrame widget and giving it a title that is longer than some
    hard-coded size widget like the top-left label and the text entry below it, we
    dynamically move those widgets to the center of column 0, adding space to the
    left and right sides of those widgets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加我们的LabelFrame小部件，并给它一个比像左上角的标签和其下方的文本输入框这样的硬编码尺寸小部件更长的标题，我们动态地将这些小部件移动到第0列的中心，为这些小部件的左右两侧添加空间。
- en: Incidentally, because we used the sticky property for the Checkbutton and ScrolledText
    widgets, those remain attached to the left side of the frame.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是，因为我们使用了粘性属性来设置 Checkbutton 和 ScrolledText 小部件，所以它们仍然附着在框架的左侧。
- en: 'Let''s look in more detail at the screenshot from the first recipe of this
    chapter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看本章第一道菜谱的截图：
- en: '![How to do it...](img/B04829_02_02_4.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_02_4.jpg)'
- en: 'We added the following code to create the LabelFrame and then placed labels
    into this frame:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了以下代码来创建LabelFrame，然后在这个框架中放置了标签：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the text property of the LabelFrame, which is displayed as the title of
    the LabelFrame, is longer than both our **Enter a name:** label and the textbox
    entry below it, those two widgets are dynamically centered with the new width
    of column 0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于LabelFrame的文本属性，即显示为LabelFrame标题的文本，比我们的**输入一个名称：**标签和其下方的文本框输入都要长，因此这两个小部件会根据列0的新宽度动态居中。
- en: The Checkbutton and Radiobutton widgets in column 0 did not get centered because
    we used the `sticky=tk.W` property when we created those widgets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列0中的Checkbutton和Radiobutton小部件没有居中，因为我们创建这些小部件时使用了`sticky=tk.W`属性。
- en: For the ScrolledText widget we used `sticky=tk.WE,` which binds the widget to
    both the west (aka left) and east (aka right) side of the frame.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ScrolledText小部件，我们使用了`sticky=tk.WE,`，这会将小部件绑定到框架的西边（即左边）和东边（即右边）。
- en: Let's remove the sticky property from the ScrolledText widget and observe the
    effect this change has.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 ScrolledText 小部件中移除粘性属性，并观察这种变化带来的效果。
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now our GUI has new space around the ScrolledText widget both on the left and
    right sides. Because we used the `columnspan=3` property, our ScrolledText widget
    still spans all three columns.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI在ScrolledText小部件的左右两侧都增加了新的空间。因为我们使用了`columnspan=3`属性，所以我们的ScrolledText小部件仍然跨越了所有三个列。
- en: '![How to do it...](img/B04829_02_02_5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_02_5.jpg)'
- en: If we remove `columnspan=3`, we get the following GUI, which is not what we
    want. Now our ScrolledText only occupies column 0, and, because of its size, it
    stretches the layout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除 `columnspan=3`，我们会得到以下GUI，这并不是我们想要的。现在我们的ScrolledText只占据了列0，并且，由于其大小，它拉伸了布局。
- en: '![How to do it...](img/B04829_02_02_6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_02_6.jpg)'
- en: One way to get our layout back to where we were before adding the LabelFrame
    is to adjust the grid column position. Change the column value from 0 to 1.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要将布局恢复到添加LabelFrame之前的状态，一种方法是通过调整网格列位置。将列值从0更改为1。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now our GUI looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图形用户界面看起来是这样的：
- en: '![How to do it...](img/B04829_02_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_03.jpg)'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we are still using individual widgets, our layout can get messed up.
    By moving the column value of the LabelFrame from 0 to 1, we were able to get
    the controls back to where they used to be and where we prefer them to be. At
    least the left-most label, text, checkbox, scrolledtext, and radio button widgets
    are now located where we intended them to be. The second label and text `Entry`
    located in column 1 have aligned themselves to the center of the length of the
    **Labels in a Frame** widget, so we basically moved our alignment challenge one
    column to the right. It is not so visible because the size of the **Choose a number:**
    label is almost the same as the size of the **Labels in a Frame** title, and so
    the column width was already close to the new width generated by the LabelFrame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在使用单个小部件，我们的布局可能会变得混乱。通过将LabelFrame的列值从0更改为1，我们能够将控件恢复到它们原本的位置，以及我们希望它们所在的位置。至少最左边的标签、文本、复选框、滚动文本和单选按钮小部件现在都位于我们期望它们所在的位置。位于第1列的第二标签和文本`Entry`已经自动对齐到**框架中的标签**小部件长度的中心，因此我们基本上将我们的对齐挑战向右移动了一列。这并不那么明显，因为**选择一个数字：**标签的大小几乎与**框架中的标签**标题的大小相同，因此列宽已经接近由LabelFrame生成的新宽度。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next recipe, we will embed frames within frames to avoid the accidental
    misalignment of widgets we just experienced in this recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将嵌套框架以避免在本菜谱中刚刚经历的部件意外错位问题。
- en: Aligning the GUI widgets by embedding frames within frames
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过在框架内嵌套框架来对齐GUI小部件
- en: We have much better control of our GUI layout if we embed frames within frames.
    This is what we will do in this recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在框架中嵌套框架，我们将对我们的GUI布局有更好的控制。这正是本食谱中我们将要做的。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The dynamic behavior of Python and its GUI modules can create a little bit of
    a challenge to really get our GUI looking the way we want. Here we will embed
    frames within frames to get more control of our layout. This will establish a
    stronger hierarchy among the different UI elements, making the visual appearance
    easier to achieve.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python及其GUI模块的动态行为可能会给真正实现我们想要的GUI外观带来一定的挑战。在这里，我们将嵌套框架以获得更多对布局的控制。这将增强不同UI元素之间的层次结构，使得视觉外观更容易实现。
- en: We will continue to use the GUI we created in the previous recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用在前一个菜谱中创建的图形用户界面。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Here, we will create a top-level frame that will contain other frames and widgets.
    This will help us to get our GUI layout just the way we want.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个顶层框架，它将包含其他框架和小部件。这将帮助我们获得我们想要的GUI布局。
- en: In order to do so, we will have to embed our current controls within a central
    ttk.LabelFrame. This ttk.LabelFrame is a child of the main parent window and all
    controls will be children of this ttk.LabelFrame.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们不得不将当前的控件嵌入到一个中央的 ttk.LabelFrame 中。这个 ttk.LabelFrame 是主父窗口的一个子窗口，所有的控件都将成为这个
    ttk.LabelFrame 的子控件。
- en: Up to this point in our recipes, we have assigned all widgets to our main GUI
    frame directly. Now we will only assign our LabelFrame to our main window, and
    after that, we will make this LabelFrame the parent container for all the widgets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的配方中，我们已经直接将所有小部件分配给了我们的主GUI框架。现在，我们只将我们的LabelFrame分配给主窗口，之后，我们将这个LabelFrame作为所有小部件的父容器。
- en: 'This creates the following hierarchy in our GUI layout:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们GUI布局中创建以下层次结构：
- en: '![How to do it...](img/B04829_02_30.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_30.jpg)'
- en: In this diagram, **win** is the variable that references our main GUI tkinter
    window frame; **monty** is the variable that references our LabelFrame and is
    a child of the main window frame (**win**); and **aLabel** and all other widgets
    are now placed into the LabelFrame container (**monty**).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，**win** 是一个变量，它引用我们的主 GUI tkinter 窗口框架；**monty** 是一个变量，它引用我们的 LabelFrame，并且是主窗口框架（**win**）的子框架；而
    **aLabel** 和所有其他小部件现在都被放置到 LabelFrame 容器（**monty**）中。
- en: 'Add the following code towards the top of our Python module (see comment #
    1):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的 Python 模块顶部添加以下代码（参见注释 #1）：'
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will modify all the following controls to use `monty` as the parent,
    replacing `win`. Here is an example of how to do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改所有以下控件以使用`monty`作为父控件，替换`win`。以下是一个如何操作的示例：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![How to do it...](img/B04829_02_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_04.jpg)'
- en: 'Note how all the widgets are now contained in the **Monty Python** LabelFrame,
    which surrounds all of them with a barely visible thin line. Next, we can reset
    the **Labels in a Frame** widget to the left without messing up our GUI layout:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有的小部件现在都被包含在**蒙提·派森**标签框架中，它用几乎看不见的细线包围了它们。接下来，我们可以将左边的**框架中的标签**小部件重置，而不会弄乱我们的GUI布局：
- en: '![How to do it...](img/B04829_02_04_1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_04_1.jpg)'
- en: Oops - maybe not. While our frame within another frame aligned nicely to the
    left, it again pushed our top widgets into the center (a default).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——也许不是这样。虽然我们嵌套的框架在左侧对齐得很好，但它又把我们的顶部小部件推到了中间（默认行为）。
- en: In order to align them to the left, we have to force our GUI layout by using
    the `sticky` property. By assigning it "W" (West), we can control the widget to
    be left-aligned.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将它们左对齐，我们必须通过使用`sticky`属性强制我们的GUI布局。通过将其赋值为"W"（西），我们可以控制小部件实现左对齐。
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](img/B04829_02_04_2.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_04_2.jpg)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Note how we aligned the label, but not the text box below it. We have to use
    the `sticky` property for all the controls we want to left-align. We can do that
    in a loop, using the `winfo_children()` and `grid_configure(sticky='W')` properties,
    as we did before in recipe 2 of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何对齐标签，但下面的文本框并没有对齐。我们必须为所有想要左对齐的控件使用`sticky`属性。我们可以通过循环使用`winfo_children()`和`grid_configure(sticky='W')`属性来实现，就像我们在本章第2个菜谱中做的那样。
- en: The `winfo_children()` function returns a list of all the children belonging
    to the parent. This enables us to loop through all of the widgets and change their
    properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()` 函数返回属于父元素的所有子元素的列表。这使得我们能够遍历所有小部件并更改它们的属性。'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using tkinter to force left, right, top, bottom the naming is very similar
    to Java: west, east, north and south, abbreviated to: "W" and so on. We can also
    use the following syntax: tk.W instead of "W".'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter强制左、右、上、下命名与Java非常相似：west（西）、east（东）、north（北）和south（南），缩写为："W"等等。我们还可以使用以下语法：tk.W代替"W"。
- en: 'In a previous recipe, we combined both "W" and "E" to make our ScrolledText
    widget attach itself both to the left and right sides of its container using "WE".
    We can add more combinations: "NSE" will stretch our widget to the top, bottom
    and right side. If we have only one widget in our form, for example a button,
    we can make it fill in the entire frame by using all options: "NSWE". We can also
    use tuple syntax: `sticky=(tk.N, tk.S, tk.W, tk.E)`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们结合了“W”和“E”来使我们的ScrolledText小部件通过“WE”同时附着到其容器的左右两侧。我们可以添加更多的组合：“NSE”将我们的小部件拉伸到顶部、底部和右侧。如果我们表单中只有一个小部件，例如一个按钮，我们可以通过使用所有选项来使其填充整个框架：“NSWE”。我们还可以使用元组语法：`sticky=(tk.N,
    tk.S, tk.W, tk.E)`。
- en: Let's change the very long label back and align the entry in column 0 to the
    left.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将非常长的标签改回来，并将列0中的条目左对齐。
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How it works...](img/B04829_02_04_3.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_02_04_3.jpg)'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to separate the influence that the length of our **Labels in a Frame**
    LabelFrame has on the rest of our GUI layout, we must not place this LabelFrame
    into the same LabelFrame as the other widgets. Instead we assign it directly to
    the main GUI form (`win`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离我们**Frame中的标签**LabelFrame的长度对我们GUI布局其余部分的影响，我们不应将此LabelFrame放置在与其他小部件相同的LabelFrame中。相反，我们直接将其分配给主GUI表单（`win`）。
- en: We will do this in later chapters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中这样做。
- en: Creating menu bars
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: In this recipe, we will add a menu bar to our main window, add menus to the
    menu bar, and then add menu items to the menus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为主窗口添加一个菜单栏，然后将菜单添加到菜单栏中，最后将菜单项添加到菜单里。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will start by learning the techniques of how to add a menu bar, several menus
    and a few menu items to show the principle of how to do it. Clicking on a menu
    item will have no effect. Next, we will add functionality to the menu items, for
    example, closing the main window when clicking the **Exit** menu item and displaying
    a **Help** | **About** dialog.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何添加菜单栏、几个菜单和几个菜单项的技术，以展示如何实现这一原理。点击菜单项将没有任何效果。接下来，我们将为菜单项添加功能，例如，当点击**退出**菜单项时关闭主窗口，并显示**帮助**
    | **关于**对话框。
- en: We are continuing to extend the GUI we created in the current and previous chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在继续扩展当前和上一章中创建的图形用户界面。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we have to import the `Menu` class from `tkinter`. Add the following
    line of code to the top of the Python module, where the import statements live:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从 `tkinter` 模块中导入 `Menu` 类。将以下代码行添加到 Python 模块的顶部，即导入语句所在的位置：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will create the menu bar. Add the following code towards the bottom
    of the module, just above where we create the main event loop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建菜单栏。将以下代码添加到模块的底部，正好在我们创建主事件循环的上方：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we add a menu to the bar and also assign a menu item to the menu.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们给这个栏添加一个菜单，并将一个菜单项分配给该菜单。
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running this code adds a menu bar, with a menu, which has a menu item.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将添加一个菜单栏，其中包含一个菜单，该菜单有一个菜单项。
- en: '![How to do it...](img/B04829_02_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_05.jpg)'
- en: Next, we add a second menu item to the first menu we added to the menu bar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在之前添加到菜单栏的第一个菜单中添加第二个菜单项。
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How to do it...](img/B04829_02_05_1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_05_1.jpg)'
- en: We can add a separator line between the MenuItems by adding the following line
    of code (# 4) in between the existing MenuItems.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在现有菜单项之间添加以下代码行（# 4）来在菜单项之间添加分隔线。
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it...](img/B04829_02_05_2.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_05_2.jpg)'
- en: By passing in the property `tearoff` to the constructor of the menu, we can
    remove the first dashed line that, by default, appears above the first MenuItem
    in a menu.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将属性 `tearoff` 传递给菜单的构造函数，我们可以移除默认情况下出现在第一个 `MenuItem` 上方的第一条虚线。
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How to do it...](img/B04829_02_05_3.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_05_3.jpg)'
- en: We will add a second menu, which will be horizontally placed to the right of
    the first menu. We will give it one MenuItem, which we name `About`, and, in order
    for this to work, we have to add this second menu to the MenuBar.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加第二个菜单，它将水平放置在第一个菜单的右侧。我们将给它一个MenuItem，我们将其命名为`关于`，为了使这个功能正常工作，我们必须将这个第二个菜单添加到MenuBar中。
- en: '**File** and **Help** | **About** are very common Windows GUI layouts that
    we are all familiar with, and we can create those same menus using Python and
    tkinter.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**和**帮助**|**关于**是我们都非常熟悉的常见Windows GUI布局，我们可以使用Python和tkinter创建相同的菜单。'
- en: The order of creation and the naming of menu, menu item, and menu bar might
    at first be a little bit confusing, but, once we get used to how tkinter requires
    us to code it, this actually becomes fun.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单、菜单项和菜单栏的创建顺序和命名可能一开始会有些令人困惑，但一旦我们习惯了tkinter要求我们这样编写代码的方式，这实际上变得很有趣。
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it...](img/B04829_02_05_4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_05_4.jpg)'
- en: 'At this point, our GUI has a MenuBar and two menus that contain some MenuItems.
    Clicking on them does not do much, until we add some commands. That''s what we
    will do next. Add the following code above the creation of the MenuBar:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的GUI有一个菜单栏和两个包含一些菜单项的菜单。点击它们并不会做太多，直到我们添加一些命令。这正是我们接下来要做的。在创建菜单栏的上方添加以下代码：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we bind the **File** | **Exit** MenuItem to this function by adding the
    following command to the MenuItem:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将**文件** | **退出**菜单项绑定到该函数，通过在MenuItem中添加以下命令：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, when we click the `Exit` MenuItem, our application will indeed exit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们点击`退出`菜单项时，我们的应用程序确实会退出。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In comment # 1, we are calling the `tkinter` constructor of the menu and assigning
    the menu to our main GUI window. We save a reference in the instance variable
    named `menuBar` and, in the following line of code, we use this instance to configure
    our GUI to use `menuBar` as our menu.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '在评论 # 1 中，我们调用菜单的 `tkinter` 构造函数并将菜单分配给我们的主 GUI 窗口。我们在实例变量 `menuBar` 中保存了一个引用，在下一行代码中，我们使用这个实例来配置我们的
    GUI 以使用 `menuBar` 作为我们的菜单。'
- en: 'Comment # 2 shows how we first add a MenuItem and then create a menu. This
    seems to be unintuitive, but this is how tkinter works. The `add_cascade()` method
    aligns the MenuItems one below the other, in a vertical layout.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 #2 展示了我们首先添加一个 MenuItem，然后创建菜单的过程。这似乎不太直观，但这就是 tkinter 的工作方式。`add_cascade()`
    方法将 MenuItems 从上到下垂直排列。'
- en: 'Comment # 3 shows how to add a second MenuItem to the menu.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 # 3 展示了如何向菜单中添加第二个 MenuItem。'
- en: 'In comment # 4, we are adding a separator line between the two MenuItems. This
    is usually used to group related MenuItems and separate them from less related
    items (hence the name).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '在评论 # 4 中，我们在两个菜单项之间添加了一条分隔线。这通常用于将相关的菜单项分组，并将它们与不太相关的项分开（因此得名）。'
- en: 'Comment # 5 disables the tearoff dashed line to make our menu look much better.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 # 5 禁用了撕裂虚线，使我们的菜单看起来好得多。'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Without disabling this default feature, the user can "tear off" the menu from
    the main window. I find this capability to be of little value. Feel free to play
    around with it by double-clicking the dashed line (before disabling this feature).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在不禁用此默认功能的情况下，用户可以从主窗口“撕下”菜单。我发现这个功能价值不大。您可以通过双击虚线（在禁用此功能之前）随意尝试操作。
- en: If you are using a Mac, this feature might not be enabled, so you do not have
    to worry about it at all.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Mac，这个功能可能没有被启用，所以你根本不必担心它。
- en: '![How it works...](img/B04829_02_05_5.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04829_02_05_5.jpg)'
- en: 'Comment # 6 shows you how to add a second menu to the MenuBar. We can keep
    on adding menus by using this technique.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 #6 展示了如何向菜单栏添加第二个菜单。我们可以通过使用这种技术继续添加菜单。'
- en: 'Comment # 7 creates a function to quit our GUI application cleanly. This is
    the recommended Pythonic way to end the main event loop.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '评论 #7 创建了一个函数来干净地退出我们的GUI应用程序。这是结束主事件循环的推荐Python方式。'
- en: 'In # 8 we bind the function we created in # 7 to the MenuItem, using the `tkinter`
    command property. Whenever we want our MenuItems to actually do something, we
    have to bind each of them to a function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8节中，我们使用`tkinter`命令属性将第7节中创建的函数绑定到MenuItem上。每当我们要让我们的菜单项真正执行某些操作时，我们必须将每个菜单项绑定到一个函数上。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: We are using a recommended Python naming convention by preceding our quit function
    with one single underscore, to indicate that this is a private function not to
    be called by clients of our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循推荐的 Python 命名规范，在退出函数前加上一个单下划线，以表明这是一个私有函数，不应被我们的代码客户端调用。
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: We will add the **Help** | **About** functionality in the next chapter, which
    introduces message boxes and much more.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中添加**帮助** | **关于**功能，该功能介绍了消息框以及更多内容。
- en: Creating tabbed widgets
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标签式小部件
- en: In this recipe, we will create tabbed widgets to further organize our expanding
    GUI written in tkinter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建标签式小部件来进一步组织我们用tkinter编写的不断扩展的GUI。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In order to improve our Python GUI using tabs, we will start at the beginning,
    using the minimum amount of code necessary. In the following recipes, we will
    add widgets from previous recipes and place them into this new tabbed layout.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提升我们的Python GUI使用标签页的功能，我们将从最基础开始，使用最少的代码来实现。在接下来的菜谱中，我们将从之前的菜谱中添加小部件，并将它们放置到这个新的标签页布局中。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new Python module and place the following code into this module:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块，并将以下代码放入此模块中：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This creates the following GUI:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下图形用户界面：
- en: '![How to do it...](img/B04829_02_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06.jpg)'
- en: While not amazingly impressive as of yet, this widget adds another very powerful
    tool to our GUI design toolkit. It comes with its own limitations in the minimalist
    example above (for example, we cannot reposition the GUI nor does it show the
    entire GUI title).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前并不令人特别印象深刻，这个小部件还是为我们GUI设计工具箱增添了一个非常强大的工具。在上面的简约示例中，它有其自身的局限性（例如，我们无法重新定位GUI，并且它也没有显示整个GUI标题）。
- en: While in previous recipes, we used the grid layout manager for simpler GUIs,
    we can use a simpler layout manager and "pack" is one of them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们使用了网格布局管理器来处理更简单的GUI，而现在我们可以使用更简单的布局管理器，“pack”就是其中之一。
- en: In the preceding code, we "pack" tabControl ttk.Notebook into the main GUI form
    expanding the notebook tabbed control to fill in all sides.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将tabControl ttk.Notebook“打包”到主GUI表单中，扩展笔记本标签控制以填充所有侧面。
- en: '![How to do it...](img/B04829_02_06_0.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_0.jpg)'
- en: We can add a second tab to our control and click between them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的控制面板中添加第二个标签页，并在它们之间进行点击。
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have two tabs. Click on **Tab 2** to give it the focus.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个标签页。点击**标签页 2**以使其获得焦点。
- en: '![How to do it...](img/B04829_02_06_1.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_1.jpg)'
- en: We would really like to see our windows title. So, to do this, we have to add
    a widget to one of our tabs. The widget has to be wide enough to expand our GUI
    dynamically to display our window title. We are adding Ole Monty back, together
    with his children.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的很想看到我们的窗口标题。所以，为了做到这一点，我们必须在我们的标签页之一中添加一个小部件。这个小部件必须足够宽，以便动态扩展我们的GUI来显示我们的窗口标题。我们将重新添加Ole
    Monty，以及他的孩子们。
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we got our **Monty Python** inside **Tab1**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们把我们的**蒙提·派森**放进了**Tab1**。
- en: '![How to do it...](img/B04829_02_06_2.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_2.jpg)'
- en: We can keep placing all the widgets we have created so far into our newly created
    tab controls.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将迄今为止创建的所有小部件放入我们新创建的标签控制中。
- en: '![How to do it...](img/B04829_02_06_3.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_3.jpg)'
- en: 'Now all the widgets reside inside **Tab1**. Let''s move some to **Tab2**. First,
    we create a second LabelFrame to be the container of our widgets relocating to
    **Tab2**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的小部件都位于**Tab1**内。让我们将一些移动到**Tab2**。首先，我们创建第二个LabelFrame作为将要移动到**Tab2**的小部件的容器：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we move the check and radio buttons to **Tab2**, by specifying the new
    parent container, which is a new variable we name `monty2`. Here is an example
    which we apply to all controls that relocate to **Tab2**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将复选框和单选按钮移动到**Tab2**，通过指定新的父容器，这是一个我们命名为`monty2`的新变量。以下是一个示例，我们将它应用于所有移动到**Tab2**的控件：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we run the code, our GUI now looks different. **Tab1** has less widgets
    than it had before when it contained all of our previously created widgets.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们的GUI现在看起来不同了。**Tab1**中的小部件比之前少，因为它包含了我们之前创建的所有小部件。
- en: '![How to do it...](img/B04829_02_06_4.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_4.jpg)'
- en: We can now click **Tab 2** and see our relocated widgets.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以点击**Tab 2**并查看我们重新定位的控件。
- en: '![How to do it...](img/B04829_02_06_5.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_5.jpg)'
- en: Clicking the relocated Radiobutton(s) no longer has any effect, so we will change
    their actions to rename the text property, which is the title of the LabelFrame
    widget, to the name the Radiobuttons display. When we click the **Gold** Radiobutton,
    we no longer set the background of the frame to the color gold but here replace
    the LabelFrame text title instead. Python "The Snake" now becomes "Gold".
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 点击重新定位的单选按钮（复选）不再有任何效果，因此我们将更改它们的操作，将文本属性重命名为单选按钮显示的名称，即LabelFrame小部件的标题。当我们点击**黄金**单选按钮时，我们不再将框架的背景设置为金色，而是在这里替换LabelFrame文本标题。Python
    "蛇"现在变为"黄金"。
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, selecting any of the RadioButton widgets results in changing the name of
    the LabelFrame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择任何一个RadioButton小部件都会导致LabelFrame的名称发生变化。
- en: '![How to do it...](img/B04829_02_06_6.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_06_6.jpg)'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After creating a second tab, we moved some of the widgets that originally resided
    in **Tab1** to **Tab2**. Adding tabs is another excellent way to organize our
    ever-increasing GUI. This is one very nice way to handle complexity in our GUI
    design. We can arrange widgets in groups where they naturally belong, and free
    our users from clutter by using tabs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建第二个标签页之后，我们将原本位于**Tab1**的一些小部件移动到了**Tab2**。添加标签页是组织我们不断增长的GUI的另一种极好方式。这是处理我们GUI设计中复杂性的一个非常不错的方法。我们可以将小部件按照它们自然归属的组进行排列，并通过使用标签页来让用户摆脱杂乱。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'In `tkinter`, creating tabs is done via the `Notebook` widget, which is the
    tool that allows us to add tabbed controls. The tkinter notebook widget, like
    so many other widgets, comes with additional properties that we can use and configure.
    An excellent place to start exploring additional capabilities of the tkinter widgets
    at our disposal is the official website: [https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tkinter` 中，创建标签页是通过 `Notebook` 小部件来完成的，这是允许我们添加标签控制的工具。与许多其他小部件一样，tkinter
    的笔记本小部件也附带了一些我们可以使用和配置的额外属性。探索我们可用的 tkinter 小部件的额外功能的一个绝佳起点是官方网站：[https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)
- en: Using the grid layout manager
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: The grid layout manager is one of the most useful layout tools at our disposal.
    We have already used it in many recipes because it is just so powerful.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是我们可用的最有用的布局工具之一。我们已经在许多菜谱中使用了它，因为它实在是非常强大。
- en: Getting ready…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: In this recipe, we will review some of the techniques of the grid layout manager.
    We have used them already and here we will explore them further.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将回顾网格布局管理器的一些技术。我们已经使用过它们了，在这里我们将进一步探索它们。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this chapter, we have created rows and columns, which truly is a database
    approach to GUI design (MS Excel does the same). We hard-coded the first four
    rows but then we forgot to give the next row a specification of where we wish
    it to reside.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了行和列，这实际上是一种数据库方法来设计GUI（MS Excel也是这样做）。我们硬编码了前四行，但后来我们忘记为下一行指定它希望驻留的位置。
- en: Tkinter did fill this in for us without us even noticing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 在我们甚至没有注意到的情况下就已经帮我们填充了这个内容。
- en: 'Here is what we did in our code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们代码中执行的操作：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Tkinter automatically adds the missing row (emphasized in comment # 1) where
    we did not specify any particular row. We might not realize this.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter会自动添加我们未指定任何特定行的缺失行（在注释# 1中已强调）。我们可能没有意识到这一点。
- en: We laid out the checkbuttons on row 4 then we "forgot" to specify the row for
    our ScrolledText widget, which we reference via the scr variable and then we added
    the Radiobutton widgets to be laid out in row 6.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第四行布局了复选框，然后我们“忘记”指定我们的ScrolledText小部件所在的行，我们通过scr变量引用这个小部件，接着我们添加了单选按钮小部件，以便在第六行布局。
- en: This works nicely because tkinter automatically incremented the row position
    for our ScrolledText widget to use the next highest row number, which was row
    5.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，因为tkinter自动增加了我们的ScrolledText小部件的行位置，以便使用下一个最高的行号，即第5行。
- en: Looking at our code and not realizing that we "forgot" to explicitly position
    our ScrolledText widget to row 5, we might think nothing resides there.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 看着我们的代码，没有意识到我们“忘记”将 ScrolledText 小部件显式地定位到第 5 行，我们可能会认为那里没有任何内容。
- en: So, we might try the following.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能会尝试以下方法。
- en: 'If we set the variable `curRad` to use row 5, we might get an unpleasant surprise:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将变量 `curRad` 设置为使用第 5 行，我们可能会得到一个不愉快的惊喜：
- en: '![How to do it...](img/B04829_02_07.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_02_07.jpg)'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Note how our row of RadioButton(s) suddenly ended up in the middle of our ScrolledText
    widget! This is definitely not what we intended our GUI to look like!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的RadioButton（s）行突然出现在ScrolledText小部件的中间！这绝对不是我们想要我们的GUI看起来像的样子！
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: If we forget to explicitly specify the row number, by default, `tkinter` will
    use the next available row.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记明确指定行号，默认情况下，`tkinter`将使用下一个可用的行。
- en: 'We also used the `columnspan` property to make sure our widgets did not get
    limited to just one column. Here is how we made sure that our ScrolledText widget
    spans all the columns of our GUI:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`columnspan`属性来确保我们的小部件不会仅限于一个列。以下是确保我们的ScrolledText小部件跨越我们GUI所有列的方法：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
