- en: Chapter 10. Deploying Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。部署您的应用程序
- en: In this chapter, we will learn how to deploy our Flask applications securely
    and in an automated, repeatable manner. We will see how to configure commonly
    used **WSGI** (**Web Server Gateway Interface**) capable servers such as Apache,
    Nginx, as well as the Python Webserver Gunicorn. Then we will see how to secure
    a part or the entire site using SSL, before finally wrapping up our application
    in a configuration management tool to automate our deployment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何以安全和自动化的可重复方式部署我们的Flask应用程序。我们将看到如何配置常用的**WSGI**（**Web服务器网关接口**）能力服务器，如Apache、Nginx，以及Python
    Web服务器Gunicorn。然后，我们将看到如何使用SSL保护部分或整个站点，最后将我们的应用程序包装在配置管理工具中，以自动化我们的部署。
- en: 'In this chapter we shall learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Configuring commonly-used WSGI servers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置常用的WSGI服务器
- en: Serving static files efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地提供静态文件
- en: Using SSL to secure your site
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSL保护您的网站
- en: Automating deployment using Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible自动化部署
- en: Running Flask with a WSGI server
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WSGI服务器运行Flask
- en: It is important to note that Flask, by itself, is not a web server. Web servers
    are tools that are Internet-facing, have had many years of development and patching
    applied to them, and can run many services at once.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，Flask本身并不是一个Web服务器。Web服务器是面向互联网的工具，经过多年的开发和修补，并且可以同时运行多个服务。
- en: Running Flask by itself as a Web server on the Internet will most likely be
    fine, thanks to the Werkzeug WSGI layer However, the real focus of development
    on Flask is page-routing and rendering the system. Running Flask as a web server
    may have unintended effects. Ideally, Flask will sit behind a web server and be
    called upon when the server recognizes a request for your app. To do this, the
    web server and Flask need to be able to speak the same language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上仅运行Flask作为Web服务器可能会很好，这要归功于Werkzeug WSGI层。然而，Flask在页面路由和渲染系统上的真正重点是开发。作为Web服务器运行Flask可能会产生意想不到的影响。理想情况下，Flask将位于Web服务器后面，并在服务器识别到对您的应用程序的请求时被调用。为此，Web服务器和Flask需要能够使用相同的语言进行通信。
- en: Fortunately the Werkzeug stack, upon which Flask is built, is designed to speak
    WSGI. WSGI is a common protocol used by web servers such as Apache's httpd and
    Nginx. It can be used to manage the load on your Flask app and communicate the
    important bits of information about where the requests came from and what kind
    of headers the request has, all in a way that Python can understand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Flask构建在Werkzeug堆栈之上，该堆栈旨在使用WSGI协议。WSGI是一个常见的协议，被诸如Apache的httpd和Nginx之类的Web服务器使用。它可以用来管理Flask应用程序的负载，并以Python可以理解的方式传达关于请求来源和请求头的重要信息。
- en: However, to get Werkzeug to talk to your web server using the WSGI protocol,
    we must use a gateway. This will take the requests from your web server and the
    Python application and translate the actions between them. Most web servers will
    speak WSGI although some need a module, and some a separate gateway such as uWSGI.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要让Werkzeug使用WSGI协议与您的Web服务器通信，我们必须使用一个网关。这将接收来自您的Web服务器和Python应用程序的请求，并在它们之间进行转换。大多数Web服务器都会使用WSGI，尽管有些需要一个模块，有些需要一个单独的网关，如uWSGI。
- en: 'One of the first things to do is to create a WSGI file for the WSGI gateway
    to communicate through. This is simply a Python file with a known structure so
    that the WSGI gateway can access it. We need to create a file called `wsgi.py`
    in the same directory as the rest of your blog app and it will contain:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的一件事是为WSGI网关创建一个WSGI文件以进行通信。这只是一个具有已知结构的Python文件，以便WSGI网关可以访问它。我们需要在与您的博客应用程序的其余部分相同的目录中创建一个名为`wsgi.py`的文件，它将包含：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Flask, by default, is WSGI-compatible so we just need to declare the object
    in the right way for the WSGI gateway to understand. Now the web server needs
    to be configured to find this file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Flask默认是与WSGI兼容的，因此我们只需要以正确的方式声明对象，以便WSGI网关理解。现在，Web服务器需要配置以找到此文件。
- en: Apache's httpd
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache的httpd
- en: Apache's httpd is probably the most widely used web server on the internet right
    now. The program's name is actually httpd, and it is maintained by the Apache
    Software Foundation. However, most people refer to it as *Apache* so that is what
    we shall call it as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Apache的httpd目前可能是互联网上使用最广泛的Web服务器。该程序的名称实际上是httpd，并由Apache软件基金会维护。然而，大多数人都将其称为*Apache*，因此我们也将称其为*Apache*。
- en: 'To make sure that Apache and the WSGI module are installed on Debian- and Ubuntu-based
    systems, run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保在基于Debian和Ubuntu的系统上安装了Apache和WSGI模块，请运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, on Red Hat- and Fedora-based systems run the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在基于Red Hat和Fedora的系统上运行以下命令：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To set up the Apache configuration, we must create a configuration file that
    will specify a new VirtualHost. You must locate the directory on your system where
    these files are kept. In Debian-based systems, such as Ubuntu, this will be in
    `/etc/apache2/sites-available`; create your `blog` file in there. On Red Hat/Fedora-based
    systems, we need to create a file called `blog.conf` in the `/etc/apache2/conf.d`
    directory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Apache配置，我们必须创建一个指定新VirtualHost的配置文件。您必须找到系统上存放这些文件的目录。在基于Debian的系统（如Ubuntu）中，这将在`/etc/apache2/sites-available`中；在基于Red
    Hat/Fedora的系统中，我们需要在`/etc/apache2/conf.d`目录中创建一个名为`blog.conf`的文件。
- en: 'In that configuration file, update the content with the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在该配置文件中，使用以下代码更新内容：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration instructs Apache that, for every request to the host on port
    `80`, there is to attempt to load from the `wsgi.py` script. The directory section
    tells Apache how to handle requests to that directory and, by default, it is best
    to deny access to the files within your source directory to anyone accessing the
    web server. Be aware that, in this instance, `<path to app>` is the full absolute
    path to the directory where the `wsgi.py` file is stored.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置指示Apache，对于对端口`80`上主机的每个请求，都要尝试从`wsgi.py`脚本加载。目录部分告诉Apache如何处理对该目录的请求，并且默认情况下，最好拒绝任何访问Web服务器的人对源目录中的文件的访问。请注意，在这种情况下，`<path
    to app>`是存储`wsgi.py`文件的目录的完整绝对路径。
- en: 'We will now need to enable the WSGI module for Apache''s httpd server. This
    is so that Apache knows to use it when specifying the WSGI configuration. On Debian-
    and Ubuntu-based systems, we just run this command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为Apache的httpd服务器启用WSGI模块。这样Apache就知道在指定WSGI配置时要使用它。在基于Debian和Ubuntu的系统中，我们只需运行此命令：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However on Red Hat and CentOS systems, it is a little more tricky. We will
    need to create or modify the file `/etc/httpd/conf.d/wsgi.conf` to contain the
    following line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Red Hat和CentOS系统上，情况会复杂一些。我们需要创建或修改文件`/etc/httpd/conf.d/wsgi.conf`，并包含以下行：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we need to enable our new site on the web server on Debian- and Ubuntu-based
    systems by running this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过运行以下命令在基于Debian和Ubuntu的系统上启用我们的新站点：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This instructs Apache to create a symbolic link from `/etc/apache2/sites-available`
    to `/etc/apache2/sites-enabled,` where Apache actually gets its configuration
    from. Now we need to restart Apache. This can be performed in many ways in your
    particular environment or distribution. The simplest may be just to run the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示Apache在`/etc/apache2/sites-available`和`/etc/apache2/sites-enabled`之间创建符号链接，Apache实际上从中获取其配置。现在我们需要重新启动Apache。在您的特定环境或分发中，可以以许多方式执行此操作。最简单的方法可能只是运行以下命令：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So all we need to do is connect to the web server through your browser by going
    to `http://localhost/`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要做的就是通过浏览器连接到Web服务器，访问`http://localhost/`。
- en: Check for any issues in your `/var/log/apache2/error.log` in Debian and Ubuntu
    systems and `/var/log/httpd/error_log` in Red Hat- and CentOS-based systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian和Ubuntu系统的`/var/log/apache2/error.log`和基于Red Hat和CentOS的系统的`/var/log/httpd/error_log`中检查是否有任何问题。
- en: 'Be aware that some Linux distros ship with a default configuration that must
    be disabled. This can likely be disabled in Debian- and Ubuntu-based systems by
    typing the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些Linux发行版默认配置必须禁用。这可能可以通过在Debian和Ubuntu系统中输入以下命令来禁用：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, in Red Hat- and CentOS-based systems we need to remove the `/etc/httpd/conf.d/welcome.conf`
    file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在基于Red Hat和CentOS的系统中，我们需要删除`/etc/httpd/conf.d/welcome.conf`文件：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will, of course, have to restart the server again for Debian- and Ubuntu-based
    systems:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要再次重启Debian和Ubuntu系统的服务器：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And in Red Hat- and CentOS-based systems:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Red Hat和CentOS的系统中：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Apache also has a reload option rather than restart. This tells the server to
    have a look at the configuration files again and work with them. This is typically
    faster than restart and can keep the existing connections open. Where as, restart
    exits the server and starts again, taking open connections with it. The benefit
    of restart is that it is more definitive and, for setup purposes, more consistent.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Apache还有一个重新加载选项，而不是重新启动。这告诉服务器再次查看配置文件并与其一起工作。这通常比重新启动更快，并且可以保持现有连接打开。而重新启动会退出服务器并重新启动，带走打开的连接。重新启动的好处是更明确，对于设置目的更一致。
- en: Serving static files
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: One very important step to go through when using Flask, through a web server,
    is to decrease the load on your app by creating a shortcut for your web server
    to the static content on your site. This offloads to the web server the relatively
    trivial task of serving basic files to the end browser, making the process faster
    and more responsive. It is also a straightforward thing to do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Flask时，通过Web服务器，非常重要的一步是通过为站点的静态内容创建一个快捷方式来减少应用程序的负载。这将把相对琐碎的任务交给Web服务器，使得处理过程更快速、更响应。这也是一件简单的事情。
- en: 'Edit your `blog.conf` file to add the following line within the `<VirtualHost
    *:80>` tags:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您的`blog.conf`文件，在`<VirtualHost *:80>`标签内添加以下行：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, `<path to app>` is the full absolute path to the directory where your
    static directory exists. Then reload the Apache configuration for Debian- and
    Ubuntu-based systems as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<path to app>`是静态目录存在的完整绝对路径。然后按照以下步骤重新加载Debian和Ubuntu系统的Apache配置：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And for Red Hat- and CentOS-based systems as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Red Hat和CentOS的系统如下：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will now inform Apache where to look for files when `/static` is requested
    by the browser. You will be able to see this happening by looking at your Apache
    log file, `/var/log/apache2/access.log` for Debian- and Ubuntu-based systems and
    `/var/log/httpd/access.log` for Red Hat- and CentOS-based systems.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Apache在浏览器请求`/static`时在何处查找文件。您可以通过查看Apache日志文件来看到这一点，在Debian和Ubuntu系统中为`/var/log/apache2/access.log`，在基于Red
    Hat和CentOS的系统中为`/var/log/httpd/access.log`。
- en: Nginx
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nginx
- en: Nginx is rapidly becoming the de facto web server to replace Apache's httpd.
    It is proven to be faster and more lightweight and its configuration, although
    quite different, can be simpler to understand.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx正迅速成为取代Apache的httpd的事实标准Web服务器。它被证明更快，更轻量级，尽管配置有所不同，但更容易理解。
- en: 'While Nginx has supported WSGI for some time, even newer Linux distros may
    not have updated to it and therefore we must use an interface layer called **uWSGI**
    to access the Python web apps. uWSGI is a WSGI gateway written in Python that
    can translate between WSGI and your web server via sockets. We need to install
    both Nginx and uWSGI. In Debian and Ubuntu based systems run the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Nginx 已经支持 WSGI 有一段时间了，但即使是更新的 Linux 发行版也可能没有更新到它，因此我们必须使用一个称为 **uWSGI**
    的接口层来访问 Python web 应用程序。uWSGI 是一个用 Python 编写的 WSGI 网关，可以通过套接字在 WSGI 和您的 Web 服务器之间进行翻译。我们需要安装
    Nginx 和 uWSGI。在基于 Debian 和 Ubuntu 的系统中运行以下命令：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And in Red Hat- or Fedora-based systems, the following
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Red Hat 或 Fedora 的系统中，以下
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now since uWSGI is a Python module, we can install it using `pip`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于 uWSGI 是一个 Python 模块，我们可以使用 `pip` 安装它：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To configure Nginx in Debian- and Ubuntu-based systems, create a file called
    `blog.conf` in `/etc/nginx/sites-available` or, in Red Hat- or Fedora-based systems,
    create the file in `/etc/nginx/conf.d` and add the content with:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在基于 Debian 和 Ubuntu 的系统中配置 Nginx，需要在 `/etc/nginx/sites-available` 中创建一个名为 `blog.conf`
    的文件，或者在基于 Red Hat 或 Fedora 的系统中，在 `/etc/nginx/conf.d` 中创建文件，并添加以下内容：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This configuration is very much the same as the Apache configuration, although
    expressed in Nginx form. It accepts connections on port `80` and for any server
    name, it tries to access the `blog.wsgi.sock`, which is a unix socket file used
    to communicate with uWSGI. You will notice that `@blogapp` is used as a shortcut
    reference to the location.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置与 Apache 配置非常相似，尽管是以 Nginx 形式表达的。它在端口 `80` 上接受连接，并且对于任何服务器名称，它都会尝试访问 `blog.wsgi.sock`，这是一个用于与
    uWSGI 通信的 Unix 套接字文件。您会注意到 `@blogapp` 被用作指向位置的快捷方式引用。
- en: 'Only in Debian- and Ubuntu-based systems do we now need to enable the new site,
    by creating a symlink from the available site to the enabled one:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在基于 Debian 和 Ubuntu 的系统中，我们现在需要通过从可用站点创建符号链接到已启用站点来启用新站点：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we need to tell uWSGI where to find the socket file so it can communicate
    with Nginx. To do this, we need to create a uWSGI configuration file in the `blog
    app` directory called `uwsgi.ini` that contains the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要告诉 uWSGI 在哪里找到套接字文件，以便它可以与 Nginx 通信。为此，我们需要在 `blog app` 目录中创建一个名为 `uwsgi.ini`
    的 uWSGI 配置文件，其中包含以下内容：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will have to change `<path to app>` to the path where your `app.py` file
    exists. Also note how the socket is set up in the same path as specified in the
    Nginx site configuration file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要将 `<path to app>` 更改为您的 `app.py` 文件存在的路径。还要注意套接字是如何设置在与 Nginx 站点配置文件中指定的相同路径中的。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may note that the formatting and structure of the INI file are very much
    like a Windows INI file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到 INI 文件的格式和结构非常类似于 Windows 的 INI 文件。
- en: 'We can verify if this configuration works by running the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来验证此配置是否有效：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now Nginx knows how to talk to the gateway but isn''t yet using the site configuration
    file; we need to restart it. This can be performed in many ways in your particular
    environment. The simplest may be just to run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Nginx 知道如何与网关通信，但还没有使用站点配置文件；我们需要重新启动它。在您特定的环境中可以通过多种方式执行此操作。最简单的方法可能就是运行以下命令：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So all we need to do is connect to the web server through your browser by going
    to `http://localhost/`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们需要做的就是通过浏览器连接到 Web 服务器，访问 `http://localhost/`。
- en: Be aware that some Linux distros ship with a default configuration that must
    be disabled. This can normally be done in both Debian- and Ubuntu-based systems,
    and Red Hat- and CentOS-based systems, by deleting the `/etc/nginx/conf.d/default.conf`
    file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些 Linux 发行版附带了必须禁用的默认配置。在基于 Debian 和 Ubuntu 的系统以及基于 Red Hat 和 CentOS 的系统中，通常可以通过删除
    `/etc/nginx/conf.d/default.conf` 文件来完成此操作。
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And restarting the `nginx` service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 并重新启动 `nginx` 服务：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Nginx also has a reload option rather than restart. This tells the server to
    have a look at the configuration files again and work with them. This is typically
    faster than restart and can keep existing connections open. Where as, restart
    exits the server and starts again, taking open connections with it. The benefit
    of restart is that it is more definitive and, for setup purposes, more consistent.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 还有一个重新加载选项，而不是重新启动。这告诉服务器再次查看配置文件并与其一起工作。这通常比重新启动更快，并且可以保持现有的连接打开。而重新启动会退出服务器并重新启动，带走打开的连接。重新启动的好处在于它更加明确，并且对于设置目的更加一致。
- en: Serving static files
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: One very important step to go through when using Flask, through a web server,
    is to decrease the load on your app by creating a shortcut for your web server
    to the static content on your site. This offloads, to the web server, the relatively
    trivial task of serving basic files to the end browser, making the process faster
    and more responsive. It is also a straightforward task to do.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Flask 通过 Web 服务器时，非常重要的一步是通过为站点上的静态内容创建一个快捷方式，以减轻应用程序的负载。这将使 Web 服务器从相对琐碎的任务中解脱出来，使得向最终浏览器提供基本文件的过程更快速、更响应。这也是一个简单的任务。
- en: 'Edit your `blog.conf` file to add this line within the server `{` tag:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您的 `blog.conf` 文件，在 server `{` 标签内添加以下行：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'where `<path to app>` is the full absolute path to the directory where your
    static directory exists. Reload the Nginx configuration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `<path to app>` 是静态目录存在的完整绝对路径。重新加载 Nginx 配置：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will now inform Nginx where to look for files when `/static` is requested
    by the browser. You will be able to see this happening by looking at your Nginx
    log file, `/var/log/nginx/access.log`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉 Nginx 在浏览器请求 `/static` 时在哪里查找文件。您可以通过查看 Nginx 日志文件 `/var/log/nginx/access.log`
    来看到这一点。
- en: Gunicorn
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gunicorn
- en: 'Gunicorn is a web server written in Python. It already understands WSGI and
    so does Flask, so getting Gunicorn running it is as easy as entering the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Gunicorn 是一个用 Python 编写的 Web 服务器。它已经理解了 WSGI，Flask 也是如此，因此让 Gunicorn 运行起来就像输入以下代码一样简单：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'where `app:app` is your app and the module name the one we used within that
    (much the same as the uWSGI configuration). There are way more options than that,
    but it is useful, for example, to work from and set a port and binding:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`app:app`是您的应用程序，模块名称是我们在其中使用的（与uWSGI配置基本相同）。除此之外还有更多选项，但例如，从中工作并设置端口和绑定是有用的：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `--bind` flag tells Gunicorn what interface to connect to and on what port.
    This is useful if we need to only use the web app internally.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`--bind`标志告诉Gunicorn要连接到哪个接口以及在哪个端口。如果我们只需要在内部使用Web应用程序，这是有用的。'
- en: Another useful flag is the `--daemon` flag that tells Gunicorn to run in the
    background and detach from your shell. This means we no longer have direct control
    of the process but it is running and can be accessed via the bind interface and
    the port that was setup.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的标志是`--daemon`标志，它告诉Gunicorn在后台运行并与您的shell分离。这意味着我们不再直接控制该进程，但它正在运行，并且可以通过设置的绑定接口和端口进行访问。
- en: Securing your site with SSL
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SSL保护您的网站
- en: In an increasingly ruthless Internet, it is important to improve the security
    of your site by proving its authenticity. A common tool for improving this for
    your site is to use SSL, or even better TLS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个日益残酷的互联网上，通过证明其真实性来提高网站的安全性是很重要的。改善网站安全性的常用工具是使用SSL，甚至更好的是TLS。
- en: SSL and TLS certificates allow your server to be verified by a trusted third-party
    based upon the domain name that your browser is connecting to. This means that,
    as a web user, we can be sure that the web site we are talking to hasn't been
    changed in transit, is the correct server we are talking to, and that the data
    being sent between the server and our browser cannot be sniffed. This obviously
    becomes important when we want to verify that the information our users are sending
    us is valid, and protected, and our users want to know that our data is protected
    in transit.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SSL和TLS证书允许您的服务器通过受信任的第三方基于您的浏览器连接的域名进行验证。这意味着，作为网站用户，我们可以确保我们正在交谈的网站在传输过程中没有被更改，是我们正在交谈的正确服务器，并且在服务器和我们的浏览器之间发送的数据不能被嗅探。当我们想要验证用户发送给我们的信息是否有效和受保护时，这显然变得重要，而我们的用户希望知道我们的数据在传输过程中受到保护。
- en: Getting your certificate
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取您的证书
- en: 'The first thing to do is generate your SSL certificate request. This is used
    in conjunction with a third party who signs the request to verify your server
    with any browser. There are a few ways of doing this, depending on your system,
    but the easiest is to run the command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是生成您的SSL证书请求。这与第三方一起使用，该第三方签署请求以验证您的服务器与任何浏览器。有几种方法可以做到这一点，取决于您的系统，但最简单的方法是运行以下命令：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You will now be asked a few questions about the organization you''re affiliated
    to, but the important line is the Common Name. This is the domain name (without
    `https://`) that your server will be accessed at:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将询问您有关您所属组织的一些问题，但重要的是通用名称。这是您的服务器将被访问的域名（不带`https://`）：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can see here we used `blog.example.com` as our example domain name that
    our blog app will be accessed at. You must use your own here. E-mail addresses
    and passwords are not hugely important and can be left blank, but you should fill
    in the `Organization Name` field as this will be the name your SSL certificate
    will be recognized as. If you are not a company, just use your own name.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们使用`blog.example.com`作为我们示例域名，我们的博客应用将在该域名下访问。您必须在这里使用您自己的域名。电子邮件地址和密码并不是非常重要的，可以留空，但您应该填写“组织名称”字段，因为这将是您的SSL证书被识别为的名称。如果您不是一家公司，只需使用您自己的名字。
- en: That command generates two files for us; one is a `private.key` file, the file
    our server will use to sign our communication with the browser, and the other
    is `public.csr`, which is the certificate request file sent to the third-party
    service that handles the verification between the server and your browser.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令为我们生成了两个文件；一个是`private.key`文件，这是我们的服务器用来与浏览器签署通信的文件，另一个是`public.csr`，这是发送给处理服务器和浏览器之间验证的第三方服务的证书请求文件。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Public/Private key cryptography is a vast but well explored subject. In the
    light of the Heartbleed attack, it is worth having a reasonable understanding
    of this, if you are looking to secure a server.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥/私钥加密是一个广泛但深入研究的主题。鉴于Heartbleed攻击，如果您希望保护服务器，了解这个是值得的。
- en: The next step is to sign your `public.csr` request with a third party. There
    are many services that will do this for you, some free and some at a slight cost;
    some such as **Let's Encrypt** automate the entire process with a script completely
    free of cost. All of them offer essentially the same service, but they may not
    all be built-in to all browsers, and offer various levels of support for varying
    degrees of cost.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用第三方签署您的`public.csr`请求。有许多服务可以为您执行此操作，有些免费，有些略有成本；例如**Let's Encrypt**等一些服务可以完全免费地自动化整个过程。它们都提供基本相同的服务，但它们可能不会全部内置到所有浏览器中，并且为不同成本的不同程度的支持提供不同程度的支持。
- en: These services will go through a verification process with you, ask for your
    `public.csr` certificate request, and return you a signed `.crt` certificate file
    for your host name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务将与您进行验证过程，要求您的`public.csr`证书请求，并为您的主机名返回一个已签名的`.crt`证书文件。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it will most likely help you to name your `.crt` and `.key` file with
    your site's host name in it, with which you applied for the certificate. In our
    case, this would be `blog.example.com.crt`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将您的`.crt`和`.key`文件命名为其中申请证书的站点主机名可能会对您有所帮助。在我们的情况下，这将是`blog.example.com.crt`。
- en: Your new `.crt` file and your existing `.key` file can be placed anywhere on
    your server. However, typically the `.crt` files go into `/etc/ssl/certs` and
    the `.key` files in `/etc/ssl/private`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新`.crt`文件和现有的`.key`文件可以放在服务器的任何位置。但是，通常`.crt`文件放在`/etc/ssl/certs`中，而`.key`文件放在`/etc/ssl/private`中。
- en: With all the correct files in the right place, we need to reopen the existing
    Apache configuration that we used for our blog service. It would be preferable
    to run a normal HTTP and HTTPS service. However, since we have gone to the effort
    of setting up the HTTPS service, it makes sense to enforce it by redirecting our
    users. This can be done using a new specification called HSTS however not all
    builds of web servers support this yet, so we will use rewrites.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有正确的文件都放在正确的位置后，我们需要重新打开用于我们的博客服务的现有Apache配置。最好运行一个正常的HTTP和HTTPS服务。但是，由于我们已经努力设置了HTTPS服务，强制执行它以重定向我们的用户是有意义的。这可以通过一个称为HSTS的新规范来实现，但并非所有的Web服务器构建都支持这一点，所以我们将使用重定向。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can run tests on your local machine with SSL certs by adding an entry to
    your operating system's host file for your domain. Just don't forget to remove
    it when you are done.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向操作系统的主机文件添加一个条目来在本地机器上运行带有SSL证书的测试域。只是不要忘记在完成后将其删除。
- en: Apache httpd
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache httpd
- en: 'The first thing to change is the port on the `VirtualHost` line from the default
    HTTP port of `80` to the default HTTPS port of `443`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要更改的是`VirtualHost`行上的端口，从默认的HTTP端口`80`更改为默认的HTTPS端口`443`：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We should also specify the server's hostname the SSL cert is being used on;
    so within the VirtualHost section add a `ServerName` parameter. This will ensure
    the certificate will not be used in the wrong domain.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该指定服务器的主机名正在使用的SSL证书；因此，在VirtualHost部分添加一个`ServerName`参数。这将确保证书不会在错误的域中使用。
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You must replace `blog.example.com` with the host name that you will be using.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须用您将要使用的主机名替换`blog.example.com`。
- en: 'We also need to set up the SSL configuration so as to tell Apache how to respond:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置SSL配置，以告诉Apache如何响应：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What is going on here is that the SSL module in Apache is being enabled, the
    public certificate and private key file are being specified for this site, and
    there is no client certificate required. It is important to disable the default
    SSL protocols and enable TLS, which is considered more secure than SSL. However,
    SSLv2 is still enabled to support older browsers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的情况是，Apache中的SSL模块被启用，为该站点指定了公共证书和私钥文件，并且不需要客户端证书。禁用默认的SSL协议并启用TLS非常重要，因为TLS被认为比SSL更安全。但是，仍然启用SSLv2以支持旧版浏览器。
- en: 'Now we need to test it. Let''s restart Apache:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要测试它。让我们重新启动Apache：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Try connecting to the web server with your browser, not forgetting that you
    are now using `https://`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用浏览器连接到Web服务器，不要忘记您现在正在使用`https://`。
- en: 'Now that is working, the final step is to redirect plain old HTTP to HTTPS.
    In the configuration file, again add the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它正在工作，最后一步是将普通的HTTP重定向到HTTPS。在配置文件中，再次添加以下内容：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We create a new `VirtualHost` for port `80` and specify that it is for the `ServerName
    blog.example.com` hostname. But then we use the `Rewrite` module in Apache to
    simply redirect the browser to the same URL it requested, however, using HTTPS
    at the beginning.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为端口`80`创建一个新的`VirtualHost`，并指定它是为`ServerName blog.example.com`主机名而设的。然后我们使用Apache中的`Rewrite`模块简单地将浏览器重定向到相同的URL，但是在开头使用HTTPS。
- en: 'Again, restart Apache:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次重启Apache：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now test this configuration in your browser on the site; verify that you get
    redirected to HTTPS for whichever page you access.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在网站上用浏览器测试这个配置；验证您被重定向到HTTPS，无论您访问哪个页面。
- en: Nginx
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nginx
- en: 'The configuration of Nginx is pretty simple. In much the same way as the Apache
    configuration, we need to change the port that Nginx will be listening to for
    our site. Since HTTPS works on port `443`, the difference here is to tell Nginx
    to expect SSL connections. In the configuration, we must update the line as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx的配置非常简单。与Apache配置非常相似，我们需要更改Nginx将监听我们站点的端口。由于HTTPS在端口`443`上运行，这里的区别在于告诉Nginx期望SSL连接。在配置中，我们必须更新以下行：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now to add the SSL configuration to the server element of the configuration,
    enter the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要将SSL配置添加到配置的服务器元素中，输入以下内容：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This tells Nginx to apply this configuration to requests for the `blog.example.com`
    hostname (don't forget to replace it with your own), as we wouldn't like to send
    the SSL cert for a domain that it doesn't apply to. We also specify the public
    certificate file location and the private SSL key file location on the file system.
    Finally, we specify the SSL protocols we want to use, which means enabling TLS
    (considered more secure than SSL). However SSLv2 is still enabled to support older
    browsers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Nginx将此配置应用于对`blog.example.com`主机名的请求（不要忘记用您自己的替换它），因为我们不希望为不适用的域发送SSL证书。我们还指定了公共证书文件位置和文件系统上的私有SSL密钥文件位置。最后，我们指定了要使用的SSL协议，这意味着启用TLS（被认为比SSL更安全）。但是SSLv2仍然启用以支持旧版浏览器。
- en: 'Now to test it. Let''s restart the Nginx service:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来测试它。让我们重新启动Nginx服务：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Try connecting to the web server with your browser, not forgetting you are now
    using `https://`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用浏览器连接到Web服务器，不要忘记您现在正在使用`https://`。
- en: 'Once we have proved that it is working, the final step is to redirect plain
    old HTTP to HTTPS. In the configuration file again add the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们证明它正在工作，最后一步是将普通的HTTP重定向到HTTPS。再次在配置文件中添加以下内容：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This works much the same as the previous, plain old HTTP configuration; except
    that we use the `rewrite` command to tell Nginx to pick up all URLs and send a
    redirect command to the browser accessing port HTTP to go to HTTPS instead, with
    the exact path they attempted to use on HTTP.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以前的普通HTTP配置基本相同；只是我们使用`rewrite`命令告诉Nginx捕获所有URL，并向访问HTTP端口的浏览器发送重定向命令，以转到HTTPS，使用他们在HTTP上尝试使用的确切路径。
- en: 'For the last time, restart Nginx:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次，重新启动Nginx：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, test your browser on the site on which you get redirected to HTTPS
    whichever page you access.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您被重定向到HTTPS的网站上测试您的浏览器，无论您访问哪个页面。
- en: Gunicorn
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gunicorn
- en: 'Gunicorn has also had SSL support added to it as of 0.17\. To enable SSL from
    the command line, we need a few flags:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从0.17版本开始，Gunicorn也添加了SSL支持。要从命令行启用SSL，我们需要一些标志：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This works much the same as the Nginx and Apache SSL configurations. It specifies
    the port to bind to, as well as all the interfaces in this case. It then directs
    Gunicorn to the public certificate and private key files, and opts to use SSLv2
    for older browsers and the (commonly considered more secure) TLS cipher protocols.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Nginx和Apache SSL配置的工作方式非常相似。它指定要绑定的端口，以及在这种情况下的所有接口。然后，它将Gunicorn指向公共证书和私钥文件，并选择在旧版浏览器中使用SSLv2和（通常被认为更安全的）TLS密码协议。
- en: Test this in your browser by going to the host name and the HTTPS in your browser.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在浏览器中输入主机名和HTTPS来测试这个。
- en: 'Now that is ready, let''s set up a redirection from port `80` to port `443`.
    This is quite complicated in Gunicorn as it does not have a built-in redirection
    facility. One solution is to create a really simple Flask app that is started
    on port `80` in Gunicorn and redirects to port `443`. It would be a new app with
    a new `app.py` file, and with its contents looking as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在准备好了，让我们将端口`80`重定向到端口`443`。这在Gunicorn中相当复杂，因为它没有内置的重定向功能。一个解决方案是创建一个非常简单的Flask应用程序，在Gunicorn上的端口`80`启动，并重定向到端口`443`。这将是一个新的应用程序，带有一个新的`app.py`文件，其内容如下：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is a really simple Flask app that can be used anywhere to redirect a browser
    to the equivalent URL that was requested of it, but with HTTPS on the front. It
    builds a URL by making use of the standard Python `urlparse` library, the requested
    hostname using the header that is sent by the browser to the server, and the generic
    path variable in the route to pick up all document requests. It then uses the
    Flask `redirect` method to tell the browser where it really needs to go.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的Flask应用程序，可以在任何地方使用，将浏览器重定向到等效的URL，但在前面加上HTTPS。它通过使用标准的Python `urlparse`库，使用浏览器发送到服务器的标头中的请求主机名，以及路由中的通用路径变量来构建URL。然后，它使用Flask的`redirect`方法告诉浏览器它真正需要去哪里。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the empty strings are important to the urlunparse function as it is
    expecting a complete URL tuple, much like that generated by urlparse.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，空字符串对于urlunparse函数很重要，因为它期望一个完整的URL元组，就像由urlparse生成的那样。
- en: 'It is likely you will know how to run this in Gunicorn by now, nevertheless
    the command to use is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能已经知道如何在Gunicorn中运行这个，尽管如此，要使用的命令如下：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now connect using your browser to your old HTTP host and you should be redirected
    to the HTTPS version.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用浏览器连接到旧的HTTP主机，您应该被重定向到HTTPS版本。
- en: Automating deployment using Ansible
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible自动化部署
- en: Ansible is a configuration management tool. It allows us to automate the deployment
    of our applications in a repeatable and manageable manner, without having to consider
    how our application is deployed each time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个配置管理工具。它允许我们以可重复和可管理的方式自动化部署我们的应用程序，而无需每次考虑如何部署我们的应用程序。
- en: Ansible works both locally and over SSH. One of the clever things you can do
    with Ansible is to get Ansible to configure itself. Based on your own configuration,
    it can then be told to deploy the other machines that it needs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可以在本地和通过SSH工作。您可以使用Ansible的一个聪明之处是让Ansible配置自身。根据您自己的配置，然后可以告诉它部署它需要的其他机器。
- en: We, however, are just going to concentrate on building our own local Flask instance
    using Apache, WSGI, and Flask.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只需要专注于使用Apache、WSGI和Flask构建我们自己的本地Flask实例。
- en: 'The first thing to do is install Ansible on the machine that we are going to
    deploy our Flask app on to. Since Ansible is written in Python, we can achieve
    this quite simply by making use of `pip`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在我们要部署Flask应用的机器上安装Ansible。由于Ansible是用Python编写的，我们可以通过使用`pip`来实现这一点：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We now have a configuration manager and, since a configuration manager is designed
    to set up servers, let's build up a playbook that Ansible can use to build the
    entire machine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个配置管理器，既然配置管理器是用来设置服务器的，让我们建立一个playbook，Ansible可以用来构建整个机器。
- en: 'In a new project or directory, create a file called `blog.yml`. We are creating
    a file that Ansible calls a Playbook; it is a list of commands that will run in
    sequence and build our blog running under Apache. For simplicity, in this file
    it is assumed that you are using an Ubuntu-derivative operating system:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新项目或目录中，创建一个名为`blog.yml`的文件。我们正在创建一个Ansible称为Playbook的文件；它是一个按顺序运行的命令列表，并构建我们在Apache下运行的博客。为简单起见，在这个文件中假定您使用的是一个Ubuntu衍生操作系统：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: An Ansible Playbook is a YAML file that consists of a few sections; the main
    section describes the "play". The `hosts` value describes what group of machines
    the subsequent settings should apply to. `user` describes what user the play should
    run as; for you, this should be a user that Ansible can run as to install your
    application. The `sudo` setting tells Ansible to run this play with `sudo` permissions
    and not to run it as root.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Playbook是一个YAML文件，包含几个部分；主要部分描述了“play”。`hosts`值描述了后续设置应该应用于哪组机器。`user`描述了play应该以什么用户身份运行；对于您来说，这应该是Ansible可以运行以安装您的应用程序的用户。`sudo`设置告诉Ansible以`sudo`权限运行此play，而不是以root身份运行。
- en: The `vars` section describes variables common to the playbook. These settings
    can be found easily as they are at the top but can also be used later in the playbook
    configuration in the format `${example_variable}`, if `example_variable` was defined
    in the `vars` section here. The most important variable here is the `app_src`
    variable which tells Ansible where to find our app when it is copying it to the
    correct location. In this example, we are assuming it is in a directory called
    `blog`, but for you it may be located elsewhere on your file system and you may
    need to update this variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars`部分描述了playbook中常见的变量。这些设置很容易找到，因为它们位于顶部，但也可以在playbook配置中以`${example_variable}`的格式稍后使用，如果`example_variable`在这里的`vars`部分中定义。这里最重要的变量是`app_src`变量，它告诉Ansible在将应用程序复制到正确位置时在哪里找到我们的应用程序。在这个例子中，我们假设它在一个名为`blog`的目录中，但对于您来说，它可能位于文件系统的其他位置，您可能需要更新此变量。'
- en: 'The final and most important section is the `tasks` section. This tells Ansible
    what to run when it is updating the machine it is controlling. If you are familiar
    with Ubuntu, these tasks should be somewhat familiar. `action: apt`, for example,
    tells apt to make sure that all the packages specified in the `with_items` list
    are installed. You will notice the `$item` variable with the `pkg` argument. The
    `$item` variable is automatically populated by Ansible as it iterates over the
    `with_items` command and the `apt` command uses the `pkg` argument to verify that
    the package is installed.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一个最重要的部分是`tasks`部分。这告诉Ansible在更新它控制的机器时要运行什么。如果您熟悉Ubuntu，这些任务应该有些熟悉。例如，`action:
    apt`告诉apt确保`with_items`列表中指定的所有软件包都已安装。您将注意到`$item`变量与`pkg`参数。`$item`变量由Ansible自动填充，因为它在`with_items`命令和`apt`命令上进行迭代，`apt`命令使用`pkg`参数来验证软件包是否已安装。'
- en: 'The subsequent tasks enable the WSGI module using the command-line command
    `a2enmod wsgi`, which is shorthand in Debian systems for enabling a module, setting
    up the Apache configuration for our blog site by populating a template. Fortunately
    for us, the language Ansible uses for its templates is Jinja, which you are most
    likely already familiar with. The contents of our template file should be relative
    to this `blog.yml`, in a directory called `templates`, and a file called `blog`.
    The contents should look like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的任务使用命令行命令`a2enmod wsgi`启用WSGI模块，这是Debian系统中启用模块的简写，通过填充模板设置我们博客站点的Apache配置。幸运的是，Ansible用于模板的语言是Jinja，您很可能已经熟悉。我们的模板文件的内容应该与此`blog.yml`相关，在一个名为`templates`的目录中，一个名为`blog`的文件。内容应该如下所示：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This should be pretty familiar, it is a direct rip-off of the example in the
    Apache section; however, we have made use of the Ansible variables to populate
    the locations of the blog app. This means that, if we want to install the app
    to another location, it will just be a matter of updating the `app_dest` variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很熟悉，这是Apache部分示例的直接剽窃；但是，我们已经利用了Ansible变量来填充博客应用程序的位置。这意味着，如果我们想将应用程序安装到另一个位置，只需更新`app_dest`变量即可。
- en: Finally, among the Playbook tasks, it copies our all-important blog app onto
    the machine, enables the site in Apache by using the Debian shorthand, and reloads
    Apache so it can make use of the site.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Playbook任务中，它将我们非常重要的博客应用程序复制到机器上，使用Debian简写在Apache中启用站点，并重新加载Apache，以便可以使用该站点。
- en: So all that is left is to run Ansible on that machine and get it to build your
    system for you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以剩下的就是在那台机器上运行Ansible，并让它为您构建系统。
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This tells Ansible to run the Playbook file `blog.yml` that we created earlier
    and to use it on the `local` connection type, which means applying to the local
    machine.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Ansible运行我们之前创建的Playbook文件`blog.yml`，并在`local`连接类型上使用它，这意味着应用于本地机器。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Ansible Tips**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible提示**'
- en: It is worth noting this may not be the best way to use Ansible in a large distributed
    environment. For one, you may want to apply it to remote machines or to separate
    out the Apache configuration, Apache WSGI configuration, Flask app configuration,
    and blog configuration into separate files that Ansible calls a role; this will
    make them reusable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这可能不是在大型分布式环境中使用Ansible的最佳方式。首先，您可能希望将其应用于远程机器，或者将Apache配置、Apache WSGI配置、Flask应用程序配置和博客配置分开成Ansible称为角色的单独文件；这将使它们可重用。
- en: 'Another useful tip would be to to specify the configuration file used and set
    up the static directory in Apache. Read the Ansible documentation for more ideas
    about ways to improve your deployment:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的提示是指定使用的配置文件并在Apache中设置静态目录。阅读Ansible文档，了解更多有关改进部署的方法的想法：
- en: '[http://docs.ansible.com/](http://docs.ansible.com/)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://docs.ansible.com/](http://docs.ansible.com/)'
- en: Read more
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读更多
- en: For more information on how to secure your Flask deployment more effectively
    in Apache and WSGI by creating shell-less users that can only run the Flask app,
    see [http://www.subdimension.co.uk/2012/04/24/Deploying_Flask_to_Apache.html](http://www.subdimension.co.uk/2012/04/24/Deploying_Flask_to_Apache.html).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在Apache和WSGI中更有效地保护您的Flask部署，通过创建只能运行Flask应用程序的无shell用户，详细信息请参见[http://www.subdimension.co.uk/2012/04/24/Deploying_Flask_to_Apache.html](http://www.subdimension.co.uk/2012/04/24/Deploying_Flask_to_Apache.html)。
- en: This guide has more examples for CentOS systems along with Lighttpd and Gunicorn
    all through Ansible [https://www.zufallsheld.de/2014/11/19/deploying-lighttpd-your-flask-apps-gunicorn-and-supervisor-with-ansible-on-centos/](https://www.zufallsheld.de/2014/11/19/deploying-lighttpd-your-flask-apps-gunicorn-and-supervisor-with-ansible-on-centos/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此指南还提供了更多针对CentOS系统的示例，以及通过Ansible在Lighttpd和Gunicorn上部署的所有示例[https://www.zufallsheld.de/2014/11/19/deploying-lighttpd-your-flask-apps-gunicorn-and-supervisor-with-ansible-on-centos/](https://www.zufallsheld.de/2014/11/19/deploying-lighttpd-your-flask-apps-gunicorn-and-supervisor-with-ansible-on-centos/)。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen many ways in which you can run your Flask app,
    including securing it for privacy and security in multiple web servers and serving
    static files to reduce load on your Flask app. We have also made a configuration
    file for Ansible that will enable repeatable application deployment so that if
    the machine ever needs to be built again, it will be a simple task.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了许多运行Flask应用程序的方法，包括在多个Web服务器中保护隐私和安全，并提供静态文件以减少Flask应用程序的负载。我们还为Ansible制作了一个配置文件，以实现可重复的应用程序部署，因此，如果需要重新构建机器，这将是一个简单的任务。
