- en: Creating a Pipeline and Workflow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流水线和工作流程
- en: A pipeline that runs automatically in a workflow, through different stages,
    will detect problems early and help your team collaborate in the most efficient
    way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自动运行的流水线工作流程，通过不同阶段，将及早发现问题，并帮助您的团队以最有效的方式进行协作。
- en: In this chapter, we will follow continuous integration practices, running the
    pipeline automatically and on every change, to be sure that all our code follows
    high quality standards, and that it runs and passes all tests. We'll also get
    a container ready to go to production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将遵循持续集成实践，自动运行流水线并在每次更改时确保我们所有的代码都符合高质量标准，并且运行并通过所有测试。我们还将准备一个容器以便投入生产。
- en: We will see how to leverage tools such as GitHub and Travis CI to create images
    with minimal intervention.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何利用GitHub和Travis CI等工具来创建最小干预的镜像。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding continuous integration practices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解持续集成实践
- en: Configuring Travis CI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Travis CI
- en: Configuring GitHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置GitHub
- en: Pushing Docker images from Travis CI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Travis CI推送Docker镜像
- en: By the end of the chapter, you'll know how to automatically run tests on every
    code change and how to create a safety net that will allow you to develop faster
    and more efficiently.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何在每次代码更改时自动运行测试，以及如何创建一个安全网，使您能够更快，更高效地开发。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You require a GitHub account and need to be the owner of the project you'll
    set up for continuous integration. We will create a Travis CI account as part
    of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个GitHub帐户，并且需要是您为持续集成设置的项目的所有者。我们将在本章中创建一个Travis CI帐户。
- en: You can checkout the full code referred to in this chapter in the `Chapter04`
    subdirectory from GitHub ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter04)).
    The file ending with `.travis.yml` is in the root directory ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/.travis.yml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/.travis.yml)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub的`Chapter04`子目录中查看本章中提到的完整代码（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter04)）。以`.travis.yml`结尾的文件位于根目录中（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/.travis.yml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/.travis.yml)）。
- en: Understanding continuous integration practices
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解持续集成实践
- en: '**Continuous integration** (usually abbreviated as **CI**) is a series of software
    engineering practices that ensure that code is always in a working state.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（通常缩写为**CI**）是一系列软件工程实践，确保代码始终处于工作状态。'
- en: The term continuous integration comes from historically having to integrate
    software frequently, often multiple times a day. This arose from the fact that
    developers worked with local code that was not necessarily joined with other people's
    code automatically. Nowadays, using a source-control versioning software such
    as Git makes some of the elements automatically available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成这个术语的由来是历史上经常需要频繁集成软件，通常一天多次。这是因为开发人员使用的是本地代码，不一定会自动与其他人的代码结合。如今，使用Git等源代码控制版本软件使一些元素自动可用。
- en: Continuous integration emphasizes on having potentially releasable code at all
    times. This makes releases possible very often, with small increments of code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成强调始终具有潜在可发布的代码。这使得以非常小的代码增量非常频繁地进行发布成为可能。
- en: Making more releases more often actually generates an increase in the quality
    of each release. More deployments also mean that each deployment is smaller, reducing
    the possibility of a big problem. Even if it sounds counterintuitive, faster deployment
    is highly correlated with higher quality in deployments and fewer production problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更频繁地发布更多的版本实际上会增加每个版本的质量。更多的部署也意味着每个部署都更小，减少了出现大问题的可能性。即使听起来违反直觉，更快的部署与部署质量更高以及更少的生产问题之间存在高度相关性。
- en: The objective here is to be able to increase the deployment speed. But for that,
    we need to be sure to build a good safety net that checks (automatically) that
    what we're doing is safe to release. That's where all the CI practices come into
    play.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是能够提高部署速度。但为此，我们需要确保建立一个良好的安全网，自动检查我们正在做的是否安全发布。这就是所有CI实践发挥作用的地方。
- en: It is quite possible, after setting all the processes and infrastructure in
    place, to implement releases multiple times a day (assuming that the code is generated
    fast enough). It can take a while to get there, but be sure to take your time
    to understand the process and produce all the necessary tools to be certain that
    you gain speed without sacrificing stability. And, trust me, it is totally achievable!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置所有流程和基础设施之后，完全有可能一天多次实施发布（假设代码生成速度足够快）。可能需要一段时间才能达到这一点，但一定要花时间了解流程，并生成所有必要的工具，以确保您在不牺牲稳定性的情况下获得速度。相信我，这是完全可以实现的！
- en: Producing automated builds
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成自动化构建
- en: The core element in CI is generating automated builds integrated with a source
    control system. A software build is a process that (starting from the source code)
    performs a series of actions and produces an output. If the project is written
    in a compiled language, the output will typically be the compiled program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CI的核心要素是生成与源代码控制系统集成的自动化构建。软件构建是一个过程（从源代码开始），执行一系列操作并产生输出。如果项目是用编译语言编写的，输出通常将是编译后的程序。
- en: If we want to have quality software, then part of the build involves checking
    that the produced code follows code standards. If the code doesn't follow those
    standards, then the build will return an error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要高质量的软件，那么构建的一部分就是检查生成的代码是否符合代码标准。如果代码不符合这些标准，那么构建将返回一个错误。
- en: A common way of describing errors on a build is to say that the *build is broken*.
    A build can break in different ways, and some kinds of error may stop it early
    (such as a compilation error before running tests) or we can continue to detect
    further issues (such as running all tests to return all possible errors).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 描述构建错误的一种常见方式是说*构建已损坏*。构建可以以不同的方式中断，某些类型的错误可能会在早期停止它（例如在运行测试之前的编译错误），或者我们可以继续检测更多问题（例如运行所有测试以返回所有可能的错误）。
- en: 'Some examples of steps that can be a part of the build are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建中可能包括的一些步骤示例如下：
- en: Compiling the code.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译代码。
- en: Python usually doesn't need to be compiled, but it might be required if you
    use C extensions (modules written in C and imported from Python: [https://docs.python.org/3/extending/](https://docs.python.org/3/extending/))
    or tools such as Cython ([https://cython.org/](https://cython.org/)[).](https://cython.org/)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常不需要编译，但如果使用C扩展（用C编写并从Python导入的模块：[https://docs.python.org/3/extending/](https://docs.python.org/3/extending/)）或诸如Cython
    ([https://cython.org/](https://cython.org/)) 这样的工具可能需要编译。
- en: Running unit tests
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: Running static code analysis tools
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行静态代码分析工具
- en: Building one or more containers
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个或多个容器
- en: Checking dependencies for known vulnerabilities with a tool such as Safety ([https://pyup.io/safety/](https://pyup.io/safety/))
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用诸如Safety ([https://pyup.io/safety/](https://pyup.io/safety/))这样的工具检查已知漏洞的依赖项。
- en: Generating a binary or source package for distribution. For example, RPM ([https://rpm.org/](https://rpm.org/)),
    Debian packages ([https://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics](https://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics)),
    and so on
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成用于分发的二进制或源代码包。例如，RPM ([https://rpm.org/](https://rpm.org/))，Debian软件包 ([https://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics](https://www.debian.org/doc/manuals/debian-faq/ch-pkg_basics))，等等
- en: Running other kinds of tests
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行其他类型的测试
- en: Generating reports, diagrams, or other assets from the code
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从代码生成报告、图表或其他资产
- en: Anything that can run automatically can be a part of a build. A local build
    can be generated at any time, even with code that's still in progress. This is
    important for debugging and solving issues. But automated builds will run against
    each individual commit, and not at any intermediate stage. This makes it very
    explicit to check what code is expected to run in production and what code is
    still work in progress.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以自动运行的东西都可以成为构建的一部分。可以随时生成本地构建，即使代码仍在进行中。这对于调试和解决问题非常重要。但自动构建将针对每个单独的提交运行，并不会在任何中间阶段运行。这使得明确检查预期在生产中运行的代码以及仍在进行中的代码非常重要。
- en: Note that a single commit may still be work in progress, but it will be worth
    committing anyway. Maybe it's a single step toward a feature, more than one person
    is working on the same part of the code, or it's work spread over several days
    and the code gets pushed at the end of the day. No matter, each commit is a reproducible
    step that can be built and checked whether the build is successful or not.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单个提交可能仍然是正在进行的工作，但无论如何都值得提交。也许这是朝着一个功能迈出的一小步，有多人在同一部分代码上工作，或者工作分布在几天之间，代码在一天结束时被推送。无论如何，每个提交都是一个可重现的步骤，可以构建并检查构建是否成功。
- en: Running the build for each commit detects problems very quickly. If commits
    are small, a breaking change is easy to pinpoint. It also makes it easy to revert
    changes that break the build and go back to known working code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个提交运行构建可以非常快速地检测问题。如果提交很小，那么很容易找出破坏性的更改。它还可以轻松地撤销破坏构建的更改并返回到已知的工作代码。
- en: Knowing the advantages of using Docker for builds
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解使用Docker进行构建的优势
- en: One of the main traditional problems with builds was having an adequate build
    environment with all the dependencies needed to run the full build. This could
    include things such as the compiler, the test framework to run the tests, any
    static analysis tools, and the package manager. A discrepancy in versions could
    also produce errors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的一个主要传统问题是拥有一个适当的构建环境，其中包含运行完整构建所需的所有依赖项。这可能包括编译器、运行测试的测试框架、任何静态分析工具和软件包管理器。版本不一致也可能导致错误。
- en: As we've seen before, Docker is a fantastic way of encapsulating our software.
    It allows us to create an image that contains both our code and all tools that
    are able to proceed through all the steps.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，Docker是封装软件的绝佳方式。它允许我们创建一个包含我们的代码和所有能够执行所有步骤的工具的镜像。
- en: In the previous chapter, we saw how to run unit tests in a single command, based
    on a build image. The image itself can run its own unit tests. This abstracts
    the test environment and explicitly defines it. The only dependency necessary
    here is to have Docker installed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何在一个构建镜像上运行单元测试的单个命令。镜像本身可以运行自己的单元测试。这样可以抽象测试环境并明确定义它。这里唯一必要的依赖是安装了Docker。
- en: Keep in mind that a single build could generate multiple images and make them
    work in coordination. We saw how to run unit tests in the previous chapter—by
    generating service image and a database image—but there are more possible usages.
    For example, you could check the test running on two different operating systems,
    creating two images from each of the operating systems or different Python interpreter
    versions, and checking whether the tests pass in all of them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，单个构建可能会生成多个镜像并使它们协调工作。我们在上一章中看到了如何运行单元测试——通过生成服务镜像和数据库镜像——但还有更多可能的用途。例如，您可以在两个不同的操作系统上运行测试，从每个操作系统创建两个镜像或不同的Python解释器版本，并检查测试是否在所有这些版本中都通过。
- en: The usage of Docker images allows for standardization in all environments. We
    can locally run images in a development environment, using the same commands that
    we did in our automated environment. This streamlines finding bugs and problems,
    as it creates the same environment, including an encapsulated operating system,
    everywhere the build is run.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker镜像可以在所有环境中实现标准化。我们可以在开发环境中本地运行镜像，使用与自动化环境中相同的命令。这样可以简化查找错误和问题，因为它在每次运行构建的地方都创建了相同的环境，包括封装的操作系统。
- en: Do not underestimate this element. Before that, a developer working on a laptop
    running Ubuntu and keen to run code to be deployed in CentOS needed to install
    a **Virtual Machine** (**VM**) and follow steps to have an environment similar
    to the one in production. But invariably, the local VM would deviate as it was
    difficult to keep every developer's local VM in sync with the one in production;
    also, any automated-build tool might also have requirements, such as not supporting
    an old version of CentOS running in production.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估这一点。在此之前，一个在运行Ubuntu的笔记本电脑上工作的开发人员，想要运行在CentOS中部署的代码，需要安装一个虚拟机并按照步骤来创建一个与生产环境类似的环境。但是，本地虚拟机往往会偏离，因为很难保持每个开发人员的本地虚拟机与生产环境中的虚拟机同步；此外，任何自动构建工具也可能有要求，比如不支持在生产中运行的旧版本CentOS。
- en: To make things worse, sometimes different projects were installed on the same
    VM, to avoid having one VM per project, and that may cause compatibility problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，有时不同的项目安装在同一个虚拟机上，以避免每个项目都有一个虚拟机，这可能会导致兼容性问题。
- en: Docker massively simplifies this problem, in part forcing you to explicitly
    declare what the dependencies are, and reducing the surface actually required
    to run our code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker大大简化了这个问题，部分原因是它迫使你明确声明依赖关系，并减少了实际运行我们的代码所需的表面。
- en: Note that we don't necessarily need to create a single step that runs the whole
    build; it could be several Docker commands, even making use of different images.
    But the requirement is that they are all contained in Docker, the only software
    required to run it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不一定需要创建一个运行整个构建的单个步骤；它可以是几个Docker命令，甚至可以使用不同的镜像。但要求是它们都包含在Docker中，这是运行它所需的唯一软件。
- en: The main product of a build using Docker is Docker image or images. We will
    need to properly tag them, but only if the build is successful.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker构建的主要产品是Docker镜像。我们需要正确地给它们打标签，但只有在构建成功的情况下才需要。
- en: Leveraging the pipeline concept
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用流水线的概念
- en: CI tools help to clarify how a build should proceed and work around the concept
    of a pipeline. A pipeline is a collection of stages. If any of them are not successful,
    the pipeline stops.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CI工具有助于澄清构建应该如何进行，并围绕流水线的概念进行工作。流水线是一系列阶段。如果其中任何一个不成功，流水线就会停止。
- en: Each stage in the pipeline can produce elements that could be used at later
    stages or are available as the final product of the full build. These final elements
    are known as artifacts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线中的每个阶段都可以产生可以在后续阶段使用的元素，或者作为完整构建的最终产品可用。这些最终元素被称为构件。
- en: 'Let''s look at an example of a pipeline:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个流水线的例子：
- en: '![](img/11e95cdf-0c76-4701-9c4a-69964b4b49dd.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11e95cdf-0c76-4701-9c4a-69964b4b49dd.png)'
- en: The first stage pulls the latest commit from the source control system. Then,
    we build all the containers and run both tests and the static analysis. If all
    has been successful, we tag the resulting `server` container and push it to the
    registry.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段从源代码控制系统中拉取最新的提交。然后，我们构建所有的容器并运行测试和静态分析。如果一切顺利，我们就会给生成的`server`容器打标签，并将其推送到注册表中。
- en: The order in which these stages run should be oriented at detecting problems
    as quickly as possible to give quick feedback. For example, if the `static-analysis`
    stage is much faster than the `test` stage, putting the analysis stage first will
    make a failing build finish earlier. Be aware of which parts can be executed earlier
    to reduce the feedback time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些阶段运行的顺序应该是为了尽快检测问题，以便快速反馈。例如，如果`static-analysis`阶段比`test`阶段快得多，将分析阶段放在第一位将使失败的构建更快完成。要注意哪些部分可以更早执行以减少反馈时间。
- en: CI tools normally allow great configuration in pipelines, including the possibility
    of running different stages in parallel. To be able to run stages in parallel,
    they need to be able to be parallelizable, meaning that they should not change
    the same elements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CI工具通常允许在流水线中进行大量配置，包括并行运行不同阶段的可能性。为了能够并行运行阶段，它们需要能够并行化，这意味着它们不应该改变相同的元素。
- en: 'If the chosen CI tool allows running stages in parallel, the pipeline could
    be defined as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所选的CI工具允许并行运行阶段，可以将流水线定义如下：
- en: '![](img/c7754936-9bc7-4507-a412-2ad09198cb3c.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7754936-9bc7-4507-a412-2ad09198cb3c.png)'
- en: Note that we build the database and the test images in parallel. The next stage
    builds the rest of the elements, which are already available in the cache, so
    it will be very quick. Both the tests and the static analysis can run in parallel,
    in two different containers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们同时构建数据库和测试图像。下一个阶段构建其余的元素，这些元素已经在缓存中可用，因此速度会非常快。测试和静态分析都可以在两个不同的容器中并行运行。
- en: This may speed up complex builds.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能加快复杂的构建速度。
- en: Be sure to validate that the amount of time taken reduces. There are cases where
    the time taken will be very similar. For example, static analysis could be very
    fast or the hardware you run it on may be not powerful enough to build things
    in parallel, making the time taken to build in parallel and sequentially very
    similar. So, always validate your assumptions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要验证所花费的时间是否减少。有些情况下，所花费的时间会非常相似。例如，静态分析可能非常快，或者你运行它的硬件可能不够强大，无法并行构建，使得并行构建和顺序构建所花费的时间非常相似。因此，一定要验证你的假设。
- en: The pipeline is described in a script specific to the Travis CI tool. We'll
    look at an example with Travis CI later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线是特定于Travis CI工具的脚本描述的。我们稍后会看一个Travis CI的例子。
- en: Branching, merging, and ensuring a clear main build
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支、合并和确保清晰的主要构建
- en: 'When do we run a build? Every time a commit is pushed. But every result is
    not the same. When dealing with a source control system such as Git, we typically
    have two kinds of branches:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 何时运行构建？每次推送提交时。但每个结果并不相同。在处理Git等源代码控制系统时，我们通常有两种类型的分支：
- en: One main branch
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主分支
- en: Feature branches
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能分支
- en: 'They implement a particular feature or bugfix, which will be merged into the
    main branch when ready, as is shown in the following figure:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它们实现了特定的功能或错误修复，当准备好时将合并到主分支中，如下图所示：
- en: '![](img/a6510d21-1c6b-4fa8-9d99-fc0e7b0b6a57.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6510d21-1c6b-4fa8-9d99-fc0e7b0b6a57.png)'
- en: 'In this example, we see how the main branch (**master**) is branched to develop
    **feature** **A**. **Feature** **A** is introduced briefly after that. There is
    a **feature B** that hasn''t been merged yet since it''s not ready. With the extra
    information on what builds have been successful or not, we can know when it is
    safe to merge a feature branch into the main branch:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到主分支（**master**）分支到开发**feature** **A**。**Feature** **A**随后被简要介绍。还有一个**feature
    B**，因为它还没有准备好，所以尚未合并。有了额外的信息，我们可以知道何时安全地将一个功能分支合并到主分支中：
- en: '![](img/f477c83f-b377-42f2-b128-2d526c862899.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f477c83f-b377-42f2-b128-2d526c862899.png)'
- en: Breakage in a feature branch that is not yet merged is not great, but while
    it is work in progress, it is expected to happen. Meanwhile, a breakage in the
    main branch is an event that should be fixed as soon as possible. If the main
    branch is in good shape, that means that it is potentially releasable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未合并的功能分支出现故障并不是很好，但在进行中的工作中，这是可以预料的。与此同时，主分支的破坏是一个应该尽快修复的事件。如果主分支状态良好，那意味着它有可能发布。
- en: 'GitHub has a model for this: pull requests. We will configure pull requests
    to automatically check whether the build has passed and avoided merging or not.
    If we force any feature branch to also be up-to-date with the main branch before
    merging back, the main branch ends up being very stable.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub有一个模型：拉取请求。我们将配置拉取请求自动检查构建是否通过并避免合并。如果我们强制任何功能分支在合并回来之前也与主分支保持最新，那么主分支最终会非常稳定。
- en: For dealing with branches in Git to define releases, the most popular model
    is Git-flow, defined in this influential blog post ([https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)).
    The following CI practices allow simplify things a bit and don't deal with elements
    such as release branches. This blog post is a highly recommended read.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Git中处理分支以定义发布，最流行的模型是Git-flow，在这篇有影响力的博文中定义（[https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)）。以下的CI实践可以简化一些事情，不涉及诸如发布分支之类的元素。这篇博文是强烈推荐阅读的。
- en: Having an uninterrupted line of successful builds in the main branch is also
    very helpful to develop a sense of stability and quality in the project. If main
    branch breakages are very rare, confidence in creating a new release with the
    latest main branch is very high.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在主分支上有一系列连续成功的构建也对项目的稳定性和质量有很大帮助。如果主分支的破坏非常罕见，那么使用最新的主分支创建新版本的信心就会非常高。
- en: Configuring Travis CI
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Travis CI
- en: Travis CI ([https://travis-ci.com/](https://travis-ci.com/)) is a popular continuous
    integration service that's freely available for public GitHub projects. Integration
    with GitHub is very simple and it allows you to configure the platform it runs
    on, such as macOS, Linux, or even iOS.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI ([https://travis-ci.com/](https://travis-ci.com/)) 是一个流行的持续集成服务，可免费用于公共GitHub项目。与GitHub的集成非常简单，它允许您配置它运行的平台，如macOS、Linux，甚至iOS。
- en: Travis CI integrates tightly with GitHub, so you only need to log in to GitHub
    to be able to access it. We'll see how to connect our project to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI与GitHub紧密集成，因此您只需要登录GitHub即可访问它。我们将看看如何将我们的项目连接到它。
- en: For clarity, only the code in this chapter will be hooked up to Travis.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，本章中的代码将只与Travis连接起来。
- en: Travis works a bit differently from other CI tools in that it creates independent
    jobs by starting a new VM. This means that any artifact created for a previous
    stage needs to be copied somewhere else to be downloaded at the start of the next
    stage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Travis的工作方式与其他CI工具有些不同，它通过启动一个新的虚拟机创建独立的任务。这意味着任何为上一个阶段创建的构件都需要复制到其他地方，以便在下一个阶段开始时下载。
- en: This makes things a bit unpractical sometimes, and an easy solution is to build
    multiple times for each individual job.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这会让事情变得有点不切实际，一个简单的解决方案是为每个单独的任务构建多次。
- en: Configuring a remote system such as Travis CI can be a little frustrating sometimes,
    as it requires you to push a commit to be built to see if the configuration is
    correct. Also, it gets configured with a YAML file, which can be a bit temperamental
    in terms of syntax. It will take you a few attempts to get something stable, but
    don't worry. Once it is set up, you can change it only via a specific pull request
    as the configuration file is also under source control.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 配置远程系统，如Travis CI，有时可能会有点令人沮丧，因为它要求您推送一个提交以进行构建，以查看配置是否正确。此外，它使用一个YAML文件进行配置，在语法方面可能有点暴躁。您可能需要尝试几次才能得到稳定的东西，但不要担心。一旦设置好，您只能通过特定的拉取请求来更改它，因为配置文件也受源代码控制。
- en: You can also check the requests in the Travis CI configuration to see if a `.yml`
    file creates a parse error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查Travis CI配置中的请求，看看`.yml`文件是否创建了解析错误。
- en: 'You can check full Travis CI documentation here: [https://docs.travis-ci.com/](https://docs.travis-ci.com/).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看完整的Travis CI文档：[https://docs.travis-ci.com/](https://docs.travis-ci.com/)。
- en: To configure Travis CI, let's start off by adding a repository from GitHub.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Travis CI，让我们首先从GitHub添加一个存储库。
- en: Adding a repo to Travis CI
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将存储库添加到Travis CI
- en: 'To add a repo to Travis CI, we need to take the following steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要将存储库添加到Travis CI，我们需要采取以下步骤：
- en: The first stage is to go to the Travis CI web page and log in with your GitHub
    credentials.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一阶段是转到Travis CI网页并使用您的GitHub凭据登录。
- en: Then, you'll need to grant Travis access to GitHub, by activating it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要授权Travis访问GitHub，通过激活它。
- en: Then, select which repo you want to build.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择要构建的存储库。
- en: The easiest starting point is to fork the repo with the examples from this book
    in [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python).
    Feel free to do so!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的起点是在[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python)中fork此书中的示例的存储库。随意操作！
- en: But remember to change the usernames, credentials, and registry information
    to match your own.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住更改用户名、凭据和注册信息以匹配您自己的信息。
- en: You'll need to have owner permissions for the GitHub repos and then you're ready
    to go!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要对GitHub存储库拥有者权限，然后您就可以开始了！
- en: Creating the .travis.yml file
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建.travis.yml文件
- en: The main element in Travis CI is the creation of the `.travis.yml` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI中的主要元素是创建`.travis.yml`文件。
- en: Be sure to name it exactly like this (including the initial dot and the `.yml`
    extension) and include it in the root directory of your GitHub repo. If not, Travis
    CI builds won't start. Please note that, in the example repo, the file is in the
    **root directory** and **not** under the `Chapter04` subdirectory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将其命名为这样（包括初始点和`.yml`扩展名），并将其包含在GitHub存储库的根目录中。如果不这样做，Travis CI构建将不会启动。请注意，在示例存储库中，该文件位于**根目录**中，而**不是**在`Chapter04`子目录下。
- en: '`.travis.yml` describes the build and its different steps. A build gets executed
    in one or more VMs. Those VMs can be configured by specifying the general operating
    system and the specific version. By default, they run in Ubuntu Linux 14.04 Trusty.
    You can find more information about available operating systems here: [https://docs.travis-ci.com/user/reference/overview/](https://docs.travis-ci.com/user/reference/overview/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`.travis.yml`描述了构建及其不同的步骤。构建在一个或多个虚拟机中执行。可以通过指定一般操作系统和具体版本来配置这些虚拟机。默认情况下，它们在Ubuntu
    Linux 14.04 Trusty中运行。您可以在此处找到有关可用操作系统的更多信息：[https://docs.travis-ci.com/user/reference/overview/](https://docs.travis-ci.com/user/reference/overview/)。'
- en: Using Docker allows us to abstract most of the operating system differences,
    but we need to ensure the specific `docker` and `docker-compose` version that
    we use is correct.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker允许我们抽象出大部分操作系统的差异，但我们需要确保我们使用的特定`docker`和`docker-compose`版本是正确的。
- en: 'We will start `.travis.yml`, ensuring that a valid `docker-compose` version
    (1.23.2) is present, by using the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始`.travis.yml`，确保存在有效的`docker-compose`版本（1.23.2），使用以下代码：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `before_install` block will be executed in all our VMs. Now, to run the
    tests, we add a `script` block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`before_install`块将在所有虚拟机中执行。现在，为了运行测试，我们添加一个`script`块：'
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We build all the images to use and then run the tests. Note that running the
    tests using the PostgreSQL database requires you to build the `db` container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建所有要使用的镜像，然后运行测试。请注意，使用PostgreSQL数据库运行测试需要构建`db`容器。
- en: 'There''s a small detail about the `db` container: the Travis VM doesn''t allow
    us to open port `5432`. We removed `ports` in `docker-compose` for that. Note
    that this only makes PostgreSQL available externally for debugging purposes; internally,
    the containers can talk to each other through their internal network.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`db`容器有一个小细节：Travis虚拟机不允许我们打开端口`5432`。因此我们在`docker-compose`中删除了`ports`。请注意，这仅仅是为了调试目的而使得PostgreSQL在外部可用；在内部，容器可以通过其内部网络相互通信。
- en: We created a `db-debug` service that's a copy of `db` but it exposes the port
    for local development. You can check it in the `docker-compose.yaml` file at [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter04/docker-compose.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter04/docker-compose.yaml).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`db-debug`的服务，它是`db`的副本，但它公开了本地开发的端口。您可以在`docker-compose.yaml`文件中查看它，网址为[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter04/docker-compose.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter04/docker-compose.yaml)。
- en: 'This runs all the tests. After pushing into the repo, we can see that the build
    starts in Travis CI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行所有测试。将代码推送到存储库后，我们可以看到构建在Travis CI中开始：
- en: '![](img/cbc98740-909b-426f-a13c-87ee5e1bb86a.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbc98740-909b-426f-a13c-87ee5e1bb86a.png)'
- en: 'Once it finishes, we can tell that the build was successful by the fact that
    it''s flagged in green. The logs can then be checked for more information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们可以通过标记为绿色来确认构建成功。然后可以检查日志以获取更多信息：
- en: '![](img/7eb1ed98-42f7-4c6c-bc9c-a9490165daf5.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb1ed98-42f7-4c6c-bc9c-a9490165daf5.png)'
- en: 'And now you can see the tests at the end of the logs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在日志的末尾看到测试：
- en: '![](img/299c2d36-633a-4dc6-acce-bd4a49d3c8fb.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/299c2d36-633a-4dc6-acce-bd4a49d3c8fb.png)'
- en: This is useful for detecting problems and build breaks. Now, let's look at how
    jobs work in Travis.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于检测问题和构建中断非常有用。现在，让我们看看Travis中作业的工作方式。
- en: Working with Travis jobs
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Travis作业
- en: Travis divides the whole build into a collection of stages that will run one
    after another. At each stage, there can be several jobs. All of the jobs in the
    same build will run in parallel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Travis将整个构建划分为一系列将依次运行的阶段。在每个阶段，可以有多个作业。同一构建中的所有作业将并行运行。
- en: 'As we''ve seen before, we can configure tests and static analysis to run in
    parallel, by replacing the `script` section with a `jobs` section:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，可以通过用`jobs`部分替换`script`部分来配置测试和静态分析并行运行：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates two jobs implicitly in one stage. The stage is named `tests` and
    the jobs are called `"Unit Tests"` and `"Static Analysis"`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一个阶段隐式地创建了两个作业。该阶段命名为`tests`，作业分别称为“单元测试”和“静态分析”。
- en: 'The results appear on the Travis page:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在Travis页面上：
- en: '![](img/4644a76d-718c-4224-ae01-55a00fcfed62.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4644a76d-718c-4224-ae01-55a00fcfed62.png)'
- en: Note that, in both cases, as the jobs are independent, they need to build the
    required images. As the unit test job needs to build the `db` image, which takes
    a couple of minutes, it is slower than the static analysis one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两种情况下，由于作业是独立的，它们需要构建所需的映像。由于单元测试作业需要构建`db`映像，这需要几分钟的时间，所以比静态分析慢。
- en: You can check the detailed logs on each job. Note how the environment setting
    and `before_install` actions get executed in all jobs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查每个作业的详细日志。请注意，环境设置和`before_install`操作在所有作业中都会执行。
- en: This division can not only speed up the build quite dramatically, but it can
    also clarify what the problems are. At a brief glance, you can see that the breaking
    factor was either the unit tests or the static analysis. This removes clutter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分工不仅可以极大地加快构建速度，还可以澄清问题所在。一眼就可以看出破坏因素是单元测试还是静态分析。这样可以减少混乱。
- en: Sending notifications
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送通知
- en: By default, Travis CI will send an email to notify the result of a build, but
    only when the build is broken or when a broken build is fixed. This avoids constantly
    sending *success* emails and acts only when action is required. The email is only
    sent to the committer (and the commit author, if different) by default.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Travis CI会发送电子邮件通知构建的结果，但只有在构建失败或修复了破损的构建时才会发送。这样可以避免不断发送“成功”电子邮件，并且只在需要采取行动时才会发送。默认情况下，电子邮件只发送给提交者（如果不同，则发送给提交作者）。
- en: Note that there's a difference between *failed* builds and *errored* builds.
    The latter are failures in the job setup, which means that there's a problem in
    the `before_install`, `install`, or `before_script` sections, while failed builds
    arise because the script part returned a non-zero result. *Errored* builds are
    common while changing Travis configuration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“失败”构建和“错误”构建之间存在差异。后者是作业设置中的失败，这意味着`before_install`、`install`或`before_script`部分存在问题，而失败的构建是因为脚本部分返回了非零结果。在更改Travis配置时，*错误*构建很常见。
- en: 'Travis allows us to configure notification emails and hook up more notification
    systems, including Slack, IRC, or even OpsGenie, which is capable of sending SMS
    messages based on on-call schedules. Check the full documentation here for more
    information: [https://docs.travis-ci.com/user/notifications/](https://docs.travis-ci.com/user/notifications/).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Travis允许我们配置通知电子邮件并连接更多通知系统，包括Slack、IRC，甚至OpsGenie，它可以根据值班计划发送短信。在此处查看更多信息的完整文档：[https://docs.travis-ci.com/user/notifications/](https://docs.travis-ci.com/user/notifications/)。
- en: Configuring GitHub
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置GitHub
- en: 'To take full advantage of our configured CI system, we need to ensure that
    we check the build before merging it into the main branch. To do so, we can configure `master`
    in GitHub as the main branch and add requirements before merging into it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用我们配置的CI系统，我们需要确保在将其合并到主分支之前检查构建。为此，我们可以在GitHub中将`master`配置为主分支，并在合并到它之前添加要求：
- en: Be sure that the `.travis.yaml` file contains the proper credentials if you
    fork the repo. You'll need to update them with your own.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`.travis.yaml`文件包含适当的凭据，如果您fork了存储库。您需要使用自己的更新它们。
- en: Go to Settings and Branches in our GitHub repo and click Add rule.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到我们的GitHub存储库中的设置和分支，然后单击添加规则。
- en: 'Then, we enable the Require status checks to pass before merging option with
    the status checks from `travis-ci`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们启用了要求状态检查通过才能合并选项，并使用来自`travis-ci`的状态检查：
- en: '![](img/2516fab5-583a-48a2-be37-387f168305a1.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2516fab5-583a-48a2-be37-387f168305a1.png)'
- en: We also select the Require branches to be up to date before merging option.
    This ensures that there are no merges into `master` that haven't been run before.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还选择了在合并之前要求分支是最新的选项。这确保了没有合并到`master`的分支在之前没有运行过。
- en: Take a look at the other possibilities that GitHub offers. In particular, enforcing
    code reviews is advisable to make code to be reviewed before being merged and
    disseminating knowledge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 看看GitHub提供的其他可能性。特别是，强制执行代码审查是明智的，可以在合并之前对代码进行审查并传播知识。
- en: 'After creating a new branch and a new pull request designed to fail static
    tests, we can see how tests are added to GitHub:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新分支和新的拉取请求，旨在失败静态测试，我们可以看到测试是如何添加到GitHub的：
- en: '![](img/e488d600-6062-4a6b-8d20-7c7e5a45be61.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e488d600-6062-4a6b-8d20-7c7e5a45be61.png)'
- en: 'The Details links take you to Travis CI and the specific builds. You can also
    see a history of the builds:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 详细链接将带您到Travis CI和特定的构建。您还可以查看构建的历史记录：
- en: '![](img/1d635138-eae4-4a5d-9387-7c4c490e4a8d.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d635138-eae4-4a5d-9387-7c4c490e4a8d.png)'
- en: 'When the build is finished, GitHub won''t let you merge the pull request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建完成时，GitHub不会让您合并拉取请求：
- en: '![](img/fec96e7a-1b64-408a-8df3-aea645993129.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fec96e7a-1b64-408a-8df3-aea645993129.png)'
- en: 'The details can be found on the build page in Travis CI:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Travis CI中构建页面的详细信息可以在此处找到：
- en: '![](img/4f036c07-0a5a-4372-87a7-8c15e38b626f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f036c07-0a5a-4372-87a7-8c15e38b626f.png)'
- en: 'Fixing the problem and pushing the code will trigger another build. This time,
    it will be successful, and the pull request will be merged successfully. You can
    see how each commit has its own build information, whether it is correct or incorrect:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 修复问题并推送代码将触发另一个构建。这一次，它将成功，并且拉取请求将成功合并。您可以看到每个提交都有自己的构建信息，无论是正确还是错误：
- en: '![](img/6325f284-fdb6-4df2-b7c4-d0dda7ffe9c5.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6325f284-fdb6-4df2-b7c4-d0dda7ffe9c5.png)'
- en: We can now merge into the master branch with confidence that the `master` branch
    won't break when it runs its tests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以放心地合并到主分支，确保`master`分支在运行测试时不会中断。
- en: 'Note that there are two builds in the pull request: one for the branch and
    another for the pull request. By default, Travis CI has that configuration. If
    you force it to always create a pull request before merging, the request will
    be redundant, though it can help in some cases when the branch gets pushed before
    creating a pull request. You can enable or disable it in the Travis project configuration.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，拉取请求中有两个构建：一个用于分支，另一个用于拉取请求。默认情况下，Travis CI有这种配置。如果您强制它在合并之前始终创建拉取请求，那么请求将是多余的，尽管在某些情况下，当分支在创建拉取请求之前被推送时，它可能有所帮助。您可以在Travis项目配置中启用或禁用它。
- en: Another interesting feature that can be configured is automatically canceling
    builds if a newer commit is pushed. This helps to reduce the total number of builds
    in the system.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置的另一个有趣的特性是，如果推送了更新的提交，可以自动取消构建。这有助于减少系统中的总构建数量。
- en: Build result can also be checked in the Commits view in GitHub.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub的Commits视图中也可以检查构建结果。
- en: Pushing Docker images from Travis CI
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Travis CI推送Docker图像
- en: After our build creates a Docker image, we need to be able to share it with
    the rest of the team or deploy it. We will use the Docker registry in Docker Hub,
    as explained in the previous chapter, to push the images.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构建创建了一个Docker镜像之后，我们需要能够与团队的其他成员共享或部署它。我们将使用Docker Hub中的Docker注册表，如前一章所述，来推送镜像。
- en: Let's start by setting the secret variables.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置安全变量开始。
- en: Setting the secret variables
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置安全变量
- en: 'To be able to push to the Docker repo, we first need to configure a password
    to log in to the Docker registry. This needs to be done through the secrets configuration
    in Travis CI, to avoid committing sensible information in the GitHub repo:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够推送到Docker存储库，我们首先需要在Travis CI的秘密配置中配置密码，以避免在GitHub存储库中提交敏感信息：
- en: It's worth repeating: **do not commit secrets in your GitHub repo**. These techniques
    can be used for any other required secret.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重申：**不要在GitHub存储库中提交机密信息**。这些技术可以用于任何其他所需的机密。
- en: 'Install the `travis` command line using `gem`. This assumes that you have `gem`
    installed on your system (Ruby 1.93 or later). If you don''t, check the installation
    instructions ([https://github.com/travis-ci/travis.rb#installation](https://github.com/travis-ci/travis.rb#installation)):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gem`安装`travis`命令行。这假设你的系统上已经安装了`gem`（Ruby 1.93或更高版本）。如果没有，请查看安装说明（[https://github.com/travis-ci/travis.rb#installation](https://github.com/travis-ci/travis.rb#installation)）：
- en: '[PRE3]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Log in to Travis:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Travis：
- en: '[PRE4]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a secure variable with the Docker Hub username:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker Hub用户名创建一个安全变量：
- en: '[PRE5]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You''ll see output similar to the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you need to add the encrypted data to the environment variables, as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要将加密数据添加到环境变量中，如下所示：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, note the new `global` section and repeat step 3 with the Docker Hub password:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请注意新的`global`部分，并重复第3步，使用Docker Hub密码：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add another secure variable, after the first one:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个之后添加另一个安全变量：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This operation creates two environment variables, available during the builds.
    Do not worry—they will be not shown in the logs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作创建了两个环境变量，在构建期间可用。不用担心——它们不会显示在日志中：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now add the proper login command in the `before_install` section so
    that Docker service can connect and push images:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`before_install`部分添加适当的登录命令，以便Docker服务可以连接并推送图像：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next stage is to build and tag the resulting image.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一阶段是构建和标记结果图像。
- en: Tagging and pushing builds
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记和推送构建
- en: 'The following code will add a new stage that will build, tag, and finally push
    the result to the Docker registry:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将添加一个新的阶段，用于构建、标记和最终将结果推送到Docker注册表：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This first part builds the final image for the server and tags it with the
    name of the branch. To deploy it, we will add a `deploy` section:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一部分构建了服务器的最终镜像，并使用分支的名称进行标记。为了部署它，我们将添加一个`deploy`部分：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `deploy` section will execute a `script` command when the branch is `master`.
    Now, our build will also generate a final image and push it. This will ensure
    our registry gets the latest version in our main branch.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当分支是`master`时，`deploy`部分将执行一个`script`命令。现在，我们的构建还将生成一个最终镜像并推送它。这将确保我们的注册表中有主分支的最新版本。
- en: We can add more `deploy` conditions to push the tag; for example, if we create
    a new Git tag, we can push the resulting image with the proper tag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加更多的`deploy`条件来推送标签；例如，如果我们创建了一个新的Git标签，我们可以推送带有适当标签的结果图像。
- en: Remember that tags, as discussed in the previous chapter, are a way to mark
    an image as significant. Normally, this will mean it's ready for some to be used
    outside automatic tests, for example, in deployment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如前一章所述，标签是标记图像为重要的一种方式。通常，这意味着它已准备好在自动测试之外的某些地方使用，例如在部署中。
- en: 'We can add the tags to the `deploy` section:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`deploy`部分添加标签：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that here we push whether the branch is the master or there's a defined
    tag, as both conditions won't be matched.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们推送的是主分支或有定义标签的情况，因为这两种情况都不会匹配。
- en: 'You can check the full deployment documentation here: [https://docs.travis-ci.com/user/deployment](https://docs.travis-ci.com/user/deployment).
    We''ve covered the `script` provider, which is a way of creating our own commands,
    but offers support for providers such as Heroku, PyPI (in the case of creating
    a Python package), and AWS S3.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处查看完整的部署文档：[https://docs.travis-ci.com/user/deployment](https://docs.travis-ci.com/user/deployment)。我们已经介绍了`script`提供程序，这是一种创建自己的命令的方式，但也支持提供程序，如Heroku、PyPI（用于创建Python包的情况）和AWS
    S3。
- en: Tagging and pushing every commit
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对每次提交进行标记和推送
- en: It is possible to push every single built image to the registry, identified
    by its Git SHA. This can be useful when work in progress can be shared for demo
    purposes, tests, and so on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将每个构建的图像推送到注册表，由其Git SHA标识。当工作正在进行中可以共享用于演示目的、测试等时，这可能很有用。
- en: 'To do so, we need to create an environment variable with the Git SHA in the
    `before_install` section:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要在`before_install`部分创建一个包含Git SHA的环境变量：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `push` section then adds the tag and push of the image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`push`部分添加了图像的标记和推送：
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As this action happens before the `deploy` part, it will be produced on every
    build that reaches this section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此操作发生在`deploy`部分之前，因此它将在达到此部分的每次构建中产生。
- en: This method will produce a lot of tags. Depending on how your registry manages
    them, that may be costly. Be sure that it is a sensible thing to do.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将产生大量的标签。根据您的注册表如何管理它们，这可能是昂贵的。请确保这是一个明智的做法。
- en: Keep in mind that this same approach can be used for other conditional pushes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种方法也可以用于其他条件推送。
- en: Please note that the registry needs to be adapted to your own registry details.
    If you clone the example repo, the later will need to be changed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，注册表需要根据您自己的注册表详细信息进行调整。如果您克隆示例存储库，则后者需要更改。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we presented continuous integration practices and explored
    how Docker helps to implement them. We also looked at how to design a pipeline
    that ensures that our code always follows high standards and detects deviations
    as soon as possible. Using Git branches and pull requests in GitHub plays along
    with this, as we can determine when the code is ready to be merged into the main
    branch and deployed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了持续集成的实践，并探讨了Docker如何帮助实现这些实践。我们还研究了如何设计一个管道，确保我们的代码始终符合高标准，并尽快检测到偏差。在GitHub中使用Git分支和拉取请求与此相一致，因为我们可以确定代码何时准备合并到主分支并部署。
- en: We then introduced Travis CI as a great tool to work with alongside GitHub to
    achieve continuous integration, and discussed its features. We learned how to
    create a pipeline in Travis CI, from the creation of the `.travis.yml` file, how
    to configure jobs, how to make the build push a validated Docker image to our
    Docker registry, and how to be notified.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了Travis CI作为一个与GitHub一起使用的优秀工具，以实现持续集成，并讨论了它的特点。我们学习了如何在Travis CI中创建一个管道，从创建`.travis.yml`文件，配置作业，使构建推送经过验证的Docker镜像到我们的Docker注册表，以及如何收到通知。
- en: We described how to speed up running sections in parallel, as well as how to
    set values as secrets. We also configured GitHub to ensure that the Travis CI
    pipeline has run successfully before merging new code into our main branch.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了如何加快并行运行部分的速度，以及如何将值设置为秘密。我们还配置了GitHub，以确保Travis CI管道在将新代码合并到我们的主分支之前已成功运行。
- en: In the next chapter, we will learn about basic Kubernetes operations and concepts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习基本的Kubernetes操作和概念。
- en: Questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Does increasing the number of deployments reduce their quality?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加部署数量是否会降低它们的质量？
- en: Describe what a pipeline is.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述管道是什么。
- en: How do we know if our main branch can be deployed?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何知道我们的主分支是否可以部署？
- en: What is the main configuration source for Travis CI?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Travis CI的主要配置来源是什么？
- en: When will Travis CI send a notification email by default?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Travis CI何时会默认发送通知电子邮件？
- en: How can we avoid merging a broken branch into our main branch?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何避免将一个损坏的分支合并到我们的主分支中？
- en: Why should we avoid storing secrets in a Git repo?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该避免在Git存储库中存储秘密？
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about continuous integration and other tools, you can check out
    the book *Hands-On Continuous Integration and Delivery* ([https://www.packtpub.com/eu/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/eu/virtualization-and-cloud/hands-continuous-integration-and-delivery)),
    which covers not only Travis CI but other tools such as Jenkins and CircleCI.
    If you want to dig deeper into GitHub and all its possibilities, including how
    to effectively collaborate and the different workflows it enables, find out more
    in *GitHub Essentials* ([https://www.packtpub.com/eu/web-development/github-essentials-second-edition](https://www.packtpub.com/eu/web-development/github-essentials-second-edition)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于持续集成和其他工具的信息，您可以查看《实践持续集成和交付》一书（[https://www.packtpub.com/eu/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/eu/virtualization-and-cloud/hands-continuous-integration-and-delivery)），该书不仅涵盖了Travis
    CI，还包括Jenkins和CircleCI等其他工具。如果您想深入了解GitHub及其所有可能性，包括如何有效地协作以及它所支持的不同工作流程，请在《GitHub
    Essentials》中了解更多信息（[https://www.packtpub.com/eu/web-development/github-essentials-second-edition](https://www.packtpub.com/eu/web-development/github-essentials-second-edition)）。
