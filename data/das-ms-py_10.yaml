- en: Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: In the previous chapter, you learned about unit testing and the `unittest.mock`
    package. In this chapter, you will get a handle on the concepts of reactive programming
    and then take a look at the RxPY reactive programming framework. We'll work on
    solidifying your conceptual understanding of reactive programming and put together
    a very bare-bones reactive programming system from scratch.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了单元测试和`unittest.mock`包。在本章中，你将掌握响应式编程的概念，然后了解RxPY响应式编程框架。我们将巩固你对响应式编程的概念理解，并从头开始构建一个非常基础的响应式编程系统。
- en: 'In this chapter, we will coverÂ the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What does reactive programming mean?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程是什么意思？
- en: Building a simple reactive programming framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建简单的响应式编程框架
- en: Using the **Reactive Extensions for Python** (**RxPY**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Python的响应式扩展**（**RxPY**）
- en: The concept of reactive programming
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程的概念
- en: There are a lot of different and valid ways that I could define reactive programming.
    It's a matter of perspective and focus. Which of them is the best definition?
    We're going to cover several in this section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以以很多不同的和有效的方式来定义响应式编程。这取决于视角和焦点。哪一种定义最好？在本节中，我们将介绍几种定义。
- en: 'Perhaps, the most fundamental definition of reactive programming, at least
    in terms of what we need to think about to implement a reactive programming system,
    is that it''s a publish/subscribe model of event handling. The following diagram
    illustrates the basic reactive event handling:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，响应式编程最基本、至少在实现响应式编程系统时需要考虑的定义是它是一种事件处理发布/订阅模型。以下图表说明了基本的响应式事件处理：
- en: '![](img/992c7bdd-b087-4da6-848f-4f01fc3cd7be.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/992c7bdd-b087-4da6-848f-4f01fc3cd7be.jpg)'
- en: In the traditional nomenclature of reactive programming, there are **observables**
    and **observers**, which encapsulate the behavior of event publishers and event
    subscribers, respectively. In a reactive programming system, everything, or at
    least as much as possible, is an observable or an observer. So far, so good, but
    the publish/subscribe model by itself isn't really that exciting.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的响应式编程命名法中，有**可观察对象**和**观察者**，它们分别封装了事件发布者和事件订阅者的行为。在一个响应式编程系统中，一切，或者至少尽可能多的事物，都是一个可观察对象或观察者。到目前为止，一切都很顺利，但仅仅依靠发布/订阅模型本身并不那么令人兴奋。
- en: Reactive programming comes into its own when we recognize that an observable
    is conceptually very similar to a list, which means functional programming tools,
    such as map and reduce, have powerful analogues that apply to observables. So,
    the second definition of reactive programming is that it's **event-driven functional**
    programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们认识到可观察对象在概念上与列表非常相似时，响应式编程才真正发挥其优势，这意味着函数式编程工具，如map和reduce，有强大的类似功能可以应用于可观察对象。因此，响应式编程的第二种定义是它是一种**事件驱动的函数式**编程。
- en: The idea that we could, for example, take two observables, map a function over
    one of them, merge the result with the other, and reduce that merge sequence to
    a new value is a powerful one. We could describe all of the operations we want
    to perform ahead of time and whenever a new value comes out of one of the root
    observables, it will cascade through our whole processing chain, without further
    effort on our part.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我们可以取两个可观察对象，对一个中的对象应用一个函数，将结果与另一个合并，然后将合并序列减少到一个新值，这是一个强大的想法。我们可以提前描述我们想要执行的所有操作，每当根可观察对象之一产生新值时，它将通过我们的整个处理链级联，而无需我们进一步的努力。
- en: Functional programming operations are mostly stateless and when they're not,
    the state is at least easy to define and keep contained. This means that our event-driven,
    mostly-stateless reactive programming systems are very well-suited to asynchronous
    or parallel execution. Thus, our third definition of reactive programming is that
    it's a systematic way of writing high-performance asynchronous or parallel code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程操作大多是状态无关的，当它们不是状态无关时，状态至少是容易定义和保持的。这意味着我们的以事件驱动为主、状态无关的响应式编程系统非常适合异步或并行执行。因此，我们对响应式编程的第三种定义是它是一种编写高性能异步或并行代码的系统化方法。
- en: So, what is reactive programming? Let's bundle those definitions together. Reactive
    programming is an event-driven paradigm in which event sources can have functional
    operators applied to them to create new event sources. This is desirable because
    it results in programs that work well in asynchronous or parallel execution environments.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是响应式编程呢？让我们把这些定义放在一起。响应式编程是一种事件驱动的范式，其中事件源可以对其应用功能操作符以创建新的事件源。这是可取的，因为它导致程序在异步或并行执行环境中表现良好。
- en: Building a simple reactive programming framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个简单的响应式编程框架
- en: You have gained an understanding of what reactive programming means in a theoretical
    way. Now, we're going to get very concrete and build a simple reactive programming
    system, then build a demo so we can watch it in action. The roots of formalized
    reactive programming are in statically typed languages, particularly C#. That's
    of little concern to us as users of a language based around dynamic typing, but
    it does mean that the standard presentation of these ideas is heavily intertwined
    with types, templates, interfaces, and anonymous functions. We'll be a little
    less Pythonic here and perhaps a little more C#-ish. That said, let's move on
    to the coding.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经从理论上理解了响应式编程的含义。现在，我们将非常具体地构建一个简单的响应式编程系统，然后构建一个演示，以便我们可以观察其运行情况。形式化响应式编程的根源在于静态类型语言，尤其是C#。对于我们这种基于动态类型语言的用户来说，这并不重要，但它确实意味着这些想法的标准表述与类型、模板、接口和匿名函数紧密交织。在这里，我们将稍微不那么Pythonic，也许会稍微多一些C#风格。话虽如此，让我们继续编码。
- en: Observers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: 'Arguably, the single most fundamental element of a reactive programming system
    is the observer interface. The definition of how we can notify an object that
    the next item in a sequence is watching it is available. What we''re starting
    with in the following code example is an abstract base class, the closest Python
    equivalent to a C# interface:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，响应式编程系统中最基本的元素是观察者接口。如何通知一个对象序列中的下一个项目正在观察它的定义是可用的。在下面的代码示例中，我们从一个抽象基类开始，这是Python中与C#接口最接近的等价物：
- en: '![](img/4dea38a2-5d5b-40da-b390-3b93ddadf9ea.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dea38a2-5d5b-40da-b390-3b93ddadf9ea.jpg)'
- en: Our `Observer` class doesn't define any functionality at all, just method names
    and signatures, and guarantees that classes which inherit from it will have to
    implement at least the `on_event` method. For a complete functionality, they'd
    have to implement `on_exception` and `on_complete` as well, but that's not required.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Observer`类根本不定义任何功能，只定义方法名称和签名，并保证从它继承的类必须实现至少`on_event`方法。为了实现完整的功能，它们还必须实现`on_exception`和`on_complete`，但这不是必需的。
- en: So, the intent is that an `Observer` class will have its `on_event` method called
    once for each element of the sequence, followed by its `on_complete` method if
    the sequence terminates while the observer is watching it. If something goes sideways,
    the `on_exception` method would be called instead.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，意图是`Observer`类将为序列中的每个元素调用一次其`on_event`方法，如果观察者在观察它时序列终止，则随后调用其`on_complete`方法。如果出现意外情况，将调用`on_exception`方法代替。
- en: For an `Observer` class to be useful, there must also be an `Observable` class.
    So, let's see the beginning of that class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Observer`类有用，还必须有一个`Observable`类。那么，让我们看看这个类的开头。
- en: Observables
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察对象
- en: Like `Observer`, `Observable` is an abstract base class, although in this case,
    we provide meaningful default implementations of all of its functionality.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Observer`类似，`Observable`也是一个抽象基类，尽管在这种情况下，我们提供了所有功能的有意义默认实现。
- en: 'The `subscribe` method, shown in the following code example, is how an `Observer`
    class connects to the `Observable` class, registering itself as a consumer of
    the events that the `Observable` class emits:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中展示的`subscribe`方法，是`Observer`类连接到`Observable`类的方式，将自己注册为`Observable`类发出的事件的消费者：
- en: '![](img/7b07d43e-abc6-4005-8c60-0ceb39272862.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b07d43e-abc6-4005-8c60-0ceb39272862.jpg)'
- en: Emitting events
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射事件
- en: 'There are three methods which take care of emitting events. These are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法负责处理事件的发射。具体如下：
- en: One for sending normal events
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发送正常事件的一个
- en: One for sending exceptions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发送异常的一个
- en: One for sending a "this sequence has ended" event
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发送“此序列已结束”事件的一个
- en: 'These are shown in the following code example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在下面的代码示例中展示：
- en: '![](img/963c86ca-7b46-428f-a17e-2f2e3c118e6e.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/963c86ca-7b46-428f-a17e-2f2e3c118e6e.jpg)'
- en: In each case, they do a bit of error checking, then loop through the registered
    observers and invoke the appropriate method. These methods have names prefixed
    with a single underscore (`_`), marking them as not part of the public interface
    of the `Observable` class. They are helpers to make subclasses easier to write.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，它们都会进行一些错误检查，然后循环遍历已注册的观察者并调用适当的方法。这些方法以单个下划线（`_`）为前缀命名，表明它们不是`Observable`类的公共接口的一部分。它们是帮助子类更容易编写的辅助工具。
- en: That can't possibly be a complete reactive programming system, can it? Yes and
    no. It is fundamentally complete, but it's lacking a great many refinements and
    in no way is it ready for a production environment. It will serve nicely as the
    spine for our demo program though, so let's move on to that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这不可能是一个完整的响应式编程系统，对吧？是的，也不是。它从根本上说是完整的，但它缺乏许多改进，并且绝对还没有准备好进入生产环境。不过，它将很好地作为我们的演示程序的脊梁，所以让我们继续吧。
- en: Building the observable sequence
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可观察序列
- en: For our demo, we'll make a program that prints messages loosely representing
    the sounds we might hear in a zoo. The animals will be represented as observables
    emitting events, representing sounds at random intervals. We'll use merging and
    mapping to combine and modify the event sequences, before finally printing out
    the resulting sequence.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的演示，我们将创建一个程序，打印出大致代表我们可能在动物园中听到的声音的消息。动物将被表示为可观察的，它们在随机的时间间隔内发出事件，代表声音。我们将使用合并和映射来组合和修改事件序列，最后打印出结果序列。
- en: 'So, first of all, we have our `Animal` class, which is an observable, and the
    `AnimalEvent` helper class. The `Animal` class contains some basic information
    and a coroutine, which will run asynchronously and occasionally send events to
    the observers of the `Animal` class as shown in the following code example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们有我们的`Animal`类，它是一个可观察者，以及`AnimalEvent`辅助类。`Animal`类包含一些基本信息和一个协程，该协程将异步运行，并偶尔向`Animal`类的观察者发送事件，如下面的代码示例所示：
- en: '![](img/d76f72c0-3a3a-4ab6-8516-003fcbe54a45.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d76f72c0-3a3a-4ab6-8516-003fcbe54a45.jpg)'
- en: Looking at the preceding code, we can see that an animal is effectively a sequence
    of noise events, then a die event, immediately followed by the completion of the
    sequence.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的代码，我们可以看到动物实际上是一系列噪音事件，然后是一个掷骰子的事件，紧接着是序列的完成。
- en: We want some of our animals to be capable of creating loud noises. Instead of
    adding that capability to the `Animal` class, we'll create a mapping over the
    sequence of events, which replaces randomly selected noise events with loud noise
    events.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望某些动物能够发出响亮的声音。我们不会将这种能力添加到`Animal`类中，而是将在事件序列上创建一个映射，用响亮的声音事件替换随机选择的噪音事件。
- en: This mapping is both an observer, so that it can subscribe to the sequence of
    events, and an observable because the sequence of modified events is still a sequence
    of events and not much use if another observable can't subscribe to it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射既是观察者，因此它可以订阅事件序列，同时也是一个可观察者，因为修改后的事件序列仍然是一个事件序列，如果另一个可观察者无法订阅它，那么它就没有什么用处。
- en: This is fundamentally what happens in any reactive programming system when we
    apply an operator to an observable sequence to create a new observable sequence.
    However, in almost every case, a real reactive system provides us with a quicker,
    easier, and usually more efficient way of doing it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在对可观察序列应用操作符以创建新的可观察序列时，任何响应式编程系统所发生的根本性事件。然而，在几乎所有情况下，一个真实的响应式系统都为我们提供了一个更快、更简单、通常也更有效的方法来做这件事。
- en: Actually creating a class that's both observer and observable is rare indeed!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确实创建一个既是观察者又是可观察者的类是非常罕见的！
- en: Illustrating a stream of animal events
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示一系列动物事件
- en: 'There''s one more piece we need before we start putting things together and
    that''s a way to display a stream of animal events. Another observer is the obvious
    choice for that and it turns out to be quite easy, as you can see in the following
    code example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始组合事物之前，我们还需要一个显示动物事件流的方法。对于这个任务，另一个观察者是一个明显的选择，并且正如你将在下面的代码示例中看到的那样，这实际上非常简单：
- en: '![](img/0f250761-dcdf-4a76-a28d-199333e5d487.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f250761-dcdf-4a76-a28d-199333e5d487.jpg)'
- en: The code for a new observer is similar to what we've already seen; all we need
    is a constructor and an appropriate `on_event` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 新观察者的代码与我们之前看到的类似；我们需要的只是一个构造函数和一个适当的`on_event`方法。
- en: Composing an observable sequence
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合可观察序列
- en: 'Now that we''ve got all the pieces, how do we put them together to achieve
    our goal? Well, first we make our animal objects and then use the `SometimesLoud`
    and `Output` classes to create our modified composite sequence and display it
    as shown in the following code example from `animals.py`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有部件，我们该如何将它们组合起来以实现我们的目标呢？嗯，首先我们创建我们的动物对象，然后使用`SometimesLoud`和`Output`类来创建我们的修改后的复合序列，并像以下`animals.py`代码示例中所示那样显示它：
- en: '![](img/862005ac-4c88-48a4-9552-1343a5265725.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/862005ac-4c88-48a4-9552-1343a5265725.jpg)'
- en: 'Then, we need to schedule the run methods of each animal for asynchronous execution
    via `asyncio`, which happens implicitly in this example when we pass them as parameters
    together in our `__main__.py` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要通过`asyncio`调度每个动物的运行方法以进行异步执行，这在以下示例中是隐式发生的，当我们把它们作为参数一起传递到`__main__.py`文件中时：
- en: '![](img/1bf0ba87-74af-488a-8af6-d23a04f4bc72.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bf0ba87-74af-488a-8af6-d23a04f4bc72.jpg)'
- en: 'Our `__main__.py` file actually runs the `asyncio` event loop. So, now we can
    just sit back and watch the pseudo cacophony of our imaginary zoo, as shown in
    the following output window:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`__main__.py`文件实际上运行了`asyncio`事件循环。所以，现在我们只需坐下来，观察我们想象中的动物园的伪混乱，如下面的输出窗口所示：
- en: '![](img/8c9dc959-ee3b-4480-815c-9c799a4798f4.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c9dc959-ee3b-4480-815c-9c799a4798f4.png)'
- en: Did you notice how the meat of our program is boiled down to a single line of
    code?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我们的程序的核心被简化为一行代码了吗？
- en: Sure, we have a whole file devoted to the framework, but that's reusable. We
    also have the `SometimesLoud` and `Output` classes, but the only reason they're
    here is so we can see exactly what happens at each step of this program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一个整个文件是关于这个框架的，但这可以重用。我们还有`SometimesLoud`和`Output`类，但它们存在的唯一原因是我们可以看到这个程序每个步骤中确切发生了什么。
- en: In a real system, `Output` and `SometimesLoud` would have used built-in functionality
    that mapped the function on the sequence, as we'll see in the next section. All
    of this leaves us with a single line of code that composites several observable
    sequences and transformations, and defines most of the behavior of the program.
    This one line demonstrates the power of reactive programming.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实系统中，`Output`和`SometimesLoud`将使用内置功能将函数映射到序列上，正如我们将在下一节中看到的。所有这些都让我们只剩下一行代码，这行代码组合了多个可观察序列和转换，并定义了程序的大部分行为。这一行代码展示了响应式编程的力量。
- en: Using the reactive extensions for Python (RxPY)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的响应式扩展（RxPY）
- en: Now that we have a basic understanding of reactive programming under our belts,
    let's look at one of the more widely used reactive programming frameworks called
    **Reactive Extensions**, which is often shortened to **ReactiveX**, or simply
    **Rx**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对响应式编程有了基本的了解，让我们看看更广泛使用的响应式编程框架之一，称为**响应式扩展**，通常简称为**ReactiveX**，或者简单地称为**Rx**。
- en: 'Rx is not part of a standard Python installation, so we''ll need to use `pip`
    to install it. No problem; it''s only a single command, if you prefer to install
    to your Python system library instead of user library, or you are working in a
    virtual created by the `--user` from this command, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Rx不是Python标准安装的一部分，因此我们需要使用`pip`来安装它。没问题；这只是一个命令，如果你更喜欢将安装到Python系统库而不是用户库，或者你正在使用由`--user`命令创建的虚拟环境中，如下所示：
- en: '![](img/6a4d4269-fc26-4db2-b5f0-e7ab7f44b08b.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a4d4269-fc26-4db2-b5f0-e7ab7f44b08b.png)'
- en: Once we have Rx installed, we can move on to the fun stuff.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了Rx，我们就可以继续进行有趣的部分。
- en: Translating our zoo demo into Rx
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的动物园演示转换为Rx
- en: Like our example in the previous section, Rx provides `Observer` and `Observable`
    classes, and they encompass the same basic functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们上一节中的示例一样，Rx提供了`Observer`和`Observable`类，并且它们包含相同的基本功能。
- en: The largest visible difference is that the `Observable` class of Rx has a large
    number of factory methods that could be used to construct special-purpose observables,
    especially, observables that produce a sequence based on one or more other observable
    sequences. In other words, most of the operators and operations that we'll use
    to construct a reactive dataflow are methods of the `Observable` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的区别是Rx的`Observable`类有许多工厂方法，可以用来构建特殊用途的可观察对象，特别是基于一个或多个其他可观察序列生成序列的可观察对象。换句话说，我们将使用的大多数操作符和操作都是`Observable`类的方法。
- en: Let's take a moment to rewrite our demo from the previous section in Rx and
    we'll see what that means in practice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间重写上一节中的演示，并在Rx中看看这意味着什么。
- en: 'The `AnimalEvent` class can stay the same, since it''s just a data structure
    and doesn''t know anything about who''s using it for what. Our `Animal` class
    changes quite a bit. The run coroutine method goes away and in its place we have
    a somewhat simpler `generate_event` method (refer to the following code example):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimalEvent`类可以保持不变，因为它只是一个数据结构，并不知道谁在使用它以及用于什么。我们的`Animal`类变化很大。运行协程方法消失了，取而代之的是稍微简单一点的`generate_event`方法（参考下面的代码示例）：'
- en: '![](img/79366e77-2498-4d0e-9a3c-5418f9d1ab9c.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79366e77-2498-4d0e-9a3c-5418f9d1ab9c.jpg)'
- en: That name isn't significant by the way; it's just a reasonable name I picked
    because it describes what the method does.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，那个名字并不重要；它只是我选择的一个合理的名字，因为它描述了该方法的功能。
- en: As shown in the preceding code, the `generate_event` method by itself doesn't
    encompass the entire functionality of the old run coroutine method, though. It
    knows how to emit an event, but it doesn't know how to wait a short while and
    do it again. That's where the `as_observable` method comes into play.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`generate_event`方法本身并不包含旧运行协程方法的所有功能。它知道如何发出事件，但不知道如何等待一段时间后再做。这就是`as_observable`方法发挥作用的地方。
- en: Observable factory methods
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察的工厂方法
- en: The `as_observable` method uses one of the factory methods of the `Observable`
    class to create an observable sequence. This sequence is backed up by what is
    functionally a generator, although it's not implemented as one because that concept
    doesn't exist in every language that Rx is portable to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`as_observable`方法使用`Observable`类的工厂方法之一来创建一个可观察的序列。这个序列在功能上是一个生成器，尽管它并没有作为生成器实现，因为Rx可移植到的不是每种语言都存在这个概念。'
- en: So, instead of a real generator, we're providing it with a state variable, which
    in this case is just the animal instance, along with functions it could call to
    check whether the sequences continue, update the state, get the next value in
    the sequence, or determine how long to wait before producing the next value. The
    factory method also accepts a scheduler object, which we'll discuss later in this
    section. So, what we're asking for in this code is an observable that produces
    animal events at random intervals from 0 to 10 seconds. Now, the `Animal` class
    may be a little simpler than it used to be; there's not a big difference.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是提供一个真正的生成器，而是提供一个状态变量，在这个例子中是动物实例，以及它可以调用的函数来检查序列是否继续，更新状态，获取序列中的下一个值，或者确定在产生下一个值之前要等待多长时间。工厂方法还接受一个调度器对象，我们将在本节稍后讨论。所以，在这段代码中，我们要求的是一个产生动物事件的可观察序列，这些事件在0到10秒的随机间隔内。现在，`Animal`类可能比以前简单一些；没有太大的区别。
- en: 'However, let''s take a look at what happens with the `SometimesLoud` and `Output`
    classes (refer to the following code example); they''re not classes anymore, just
    functions, and are significantly simpler:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看`SometimesLoud`和`Output`类发生了什么（参考下面的代码示例）；它们不再是类，只是函数，并且要简单得多：
- en: '![](img/a658e30b-d361-449d-9d5d-033be099cb95.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a658e30b-d361-449d-9d5d-033be099cb95.jpg)'
- en: The `sometimes_loud` function takes an event and returns an event, and we'll
    use it to map from one observable sequence of events into a new one, just as you'd
    expect in a functional programming environment. The `output` function takes an
    event and returns none, which is again what we'd expect for a `side_effect` in
    a functional system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`sometimes_loud`函数接收一个事件并返回一个事件，我们将用它将一个事件的可观察序列映射到一个新的序列中，就像在函数式编程环境中预期的那样。`output`函数接收一个事件并返回none，这在函数式系统中对`side_effect`的预期也是一样的。'
- en: Explaining the observable sequence of events
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释事件的可观察序列
- en: So, now that we have our observable factory method and function to take and
    return an event; what do we need to do to put it all together? First, we will
    create an `asyncio` scheduler. Next comes the interesting part, where we will
    tell the computer how to combine and process those observable sequences.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了我们的可观察工厂方法和一个用于接收和返回事件的函数；我们需要做什么来把它们全部组合起来？首先，我们将创建一个`asyncio`调度器。接下来是更有趣的部分，我们将告诉计算机如何组合和处理这些可观察序列。
- en: Creating an asyncio scheduler
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个asyncio调度器
- en: 'We can create an `asyncio` scheduler using a simple command, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的命令创建一个`asyncio`调度器，如下所示：
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an Rx scheduler that specifically integrates with an `asyncio` event
    loop. Rx contains quite a few different scheduler implementations that integrate
    with various event loops available in Python, as well as one that uses Python
    threads to implement scheduling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个专门与`asyncio`事件循环集成的Rx调度器。Rx包含许多不同的调度器实现，它们与Python中可用的各种事件循环集成，以及一个使用Python线程来实现调度的实现。
- en: Regardless of which scheduler we use, the scheduler's job will be to decide
    when time-based elements of our event pipeline occur. This means that in this
    example, the scheduler is going to be deciding when our animal observables produce
    new values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们使用哪个调度器，调度器的任务将是决定我们事件管道中基于时间的元素何时发生。这意味着在这个例子中，调度器将决定我们的动物可观察对象何时产生新值。
- en: 'After creating the scheduler, we create the animal objects and their observable
    sequence of events. The animal objects are the easy part, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建调度器之后，我们创建动物对象及其事件的可观察序列。动物对象是容易的部分，如下所示：
- en: '![](img/2cff40d7-a19a-4a9b-acb2-898c8c3bf090.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cff40d7-a19a-4a9b-acb2-898c8c3bf090.jpg)'
- en: Combining and processing observable sequences
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合和处理可观察序列
- en: 'For combining and processing the observable sequences, we have three steps
    to follow. These are explained here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组合和处理可观察序列，我们有三个步骤要遵循。这些解释如下：
- en: 'First, we merge the elephant and lion sequences into a single combined sequence,
    and process that sequence through our `sometimes_loud` function to create a new
    sequence we call `louder`, as shown in the following code example:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将大象和狮子序列合并成一个单一的组合序列，并通过我们的`sometimes_loud`函数处理该序列以创建一个新的序列，我们称之为`louder`，如下面的代码示例所示：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `select` method used in that line is the direct equivalent of the map function
    in a functional programming environment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在该行中使用的`select`方法在函数式编程环境中是map函数的直接等价物。
- en: 'Next, we merge the `louder` sequence with the remaining animal sequences and
    tell the system that whenever a new value arrives at the front of that merge sequence,
    it should call the output function on that value:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将`louder`序列与剩余的动物序列合并，并告诉系统，每当新值到达合并序列的前端时，它应该调用该值上的输出函数：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `do_action` method used in this example is not equivalent to map because
    it doesn't transform the sequence; it just performs an action on each element
    of it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的`do_action`方法与map不等价，因为它不转换序列；它只是在序列的每个元素上执行一个操作。
- en: The `do_action` method is for side_effects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_action`方法用于副作用。'
- en: 'Finally, as shown as follows, we subscribe to the `on_completed` event on the
    out observable sequence, which is the same as the sequence merging all event streams
    into one, since the `do_action` operation returns its input sequence unchanged:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如以下所示，我们订阅了输出可观察序列上的`on_completed`事件，这与将所有事件流合并为一个序列的序列相同，因为`do_action`操作返回其输入序列不变：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the sequence is complete, we set a result value on the `done` future. Since
    we used that feature as the perimeter to run until complete in our `main.py` file,
    setting its result value terminates the `asyncio` event loop and our program ends.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当序列完成时，我们在`done`未来上设置一个结果值。由于我们在`main.py`文件中使用了该特性作为运行直到完成的边界，设置其结果值将终止`asyncio`事件循环，我们的程序结束。
- en: 'The complete code listing for the `animals.py` file in this section is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中`animals.py`文件的完整代码列表如下：
- en: '![](img/550bfeb1-8b85-483c-92a2-5fc8e416179b.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/550bfeb1-8b85-483c-92a2-5fc8e416179b.jpg)'
- en: Miscellaneous observable factory methods
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项可观察工厂方法
- en: The demo that we just worked through has shown us the `merge`, `merge.select`,
    and `generate_with_relative_time` factory methods of `Observable`, but that's
    just the tip of the iceberg.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成的工作演示了`Observable`的`merge`、`merge.select`和`generate_with_relative_time`工厂方法，但这只是冰山一角。
- en: 'There are so many observable factories (a sample of which is shown in the following
    image) that it would take more time than we have, just to get a short description
    of each one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有如此多的可观察工厂（以下图像是其中的一部分）的样本，仅简要描述每个就需要比我们拥有的时间还要多：
- en: '![](img/66acf3f8-e9b7-4e01-830f-026ea275a0ae.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66acf3f8-e9b7-4e01-830f-026ea275a0ae.jpg)'
- en: Each of them gives us a useful way of constructing an observable, usually, but
    not always, based on one or more other observables.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都为我们提供了一种构建可观察对象的有用方式，通常是基于一个或多个其他可观察对象，但并不总是如此。
- en: Python's interactive shell and `help` function are our friends here. There's
    a lot to be learned by poking around in the `Observable` class. In the meantime,
    we're going to talk about a few of the very best observable factory methods that
    we haven't seen yet.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的交互式外壳和 `help` 函数是我们的朋友。通过在 `Observable` 类中探索，我们可以学到很多东西。同时，我们将讨论一些我们尚未看到的非常好的
    observable 工厂方法。
- en: The Observable.create method
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.create 方法
- en: 'First on that list is `Observable.create` shown in the following code example.
    This is the recommended way of creating a completely customized observable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表的第一位是以下代码示例中显示的 `Observable.create`。这是创建完全自定义 observable 的推荐方法：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `create` method has callable as its parameter and calls that callable each
    time an observer subscribes to the observable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法以可调用为参数，并在观察者订阅 observable 时调用该可调用。'
- en: In the preceding code example, we created an observable that says `Hi!` when
    an observer subscribes and then never produces another value; not the most useful
    of sequences, but it serves to illustrate the idea.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们创建了一个当观察者订阅时说 `Hi!` 的 observable，然后不再产生其他值；这不是最有用的序列，但它有助于说明这个想法。
- en: We can take the basic framework and construct an observable with any behavior
    we like from it, without subclassing the observable class and without re-implementing,
    probably incorrectly, the internal machinery that keeps observables synchronized
    and functioning properly in an asynchronous or parallel environment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从基本框架中构建一个具有任何所需行为的 observable，而无需对 observable 类进行子类化，也无需重新实现，可能不正确地实现保持
    observables 在异步或并行环境中同步和正常工作的内部机制。
- en: The Observable.select_many method
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.select_many 方法
- en: 'Next is `Observable.select_many`. This time, let''s take a look at what Python''s
    `help` function can show us, using following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `Observable.select_many`。这次，让我们看看 Python 的 `help` 函数可以显示什么，使用以下命令：
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should give you the following description:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给出以下描述：
- en: '![](img/bd704f31-53a9-42d1-b55f-073a51f56c66.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd704f31-53a9-42d1-b55f-073a51f56c66.jpg)'
- en: This observable factory method is a more generalized version of select. Here,
    select applies a function to each member of the sequence to create a new sequence
    from the function return values, and `select_many` expects a function that returns
    an observable sequence and concatenates those sequences.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 observable 工厂方法是 select 的一个更通用版本。在这里，select 对序列的每个成员应用一个函数，从函数的返回值创建一个新的序列，而
    `select_many` 期望一个返回 observable 序列的函数并将这些序列连接起来。
- en: This means that the function applied by `select_many` can remove elements from
    the sequence by returning an empty sequence and it can insert values by returning
    a sequence containing more than one element.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `select_many` 应用函数可以通过返回一个空序列来从序列中删除元素，也可以通过返回包含多个元素的序列来插入值。
- en: As with select, the values added to the result aren't necessarily the same values
    that were passed to the function either, so `select_many` can produce a sequence
    containing more or fewer values than the input sequence and the values can be
    determined however we choose.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与 select 类似，添加到结果中的值也不一定是传递给函数的相同值，因此 `select_many` 可以产生比输入序列包含更多或更少的值的序列，并且值可以按我们的选择确定。
- en: Empty, return_value, and from_iterable factory methods
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Empty, return_value, 和 from_iterable 工厂方法
- en: Empty sequences and sequences of one value are easy to create using the `empty`
    and `return_value` factory methods, respectively. These can be shown using two
    commands, which are illustrated with their help pages respectively.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `empty` 和 `return_value` 工厂方法分别可以轻松创建空序列和只有一个值的序列。这些可以通过两个命令来展示，分别用它们的帮助页面进行说明。
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command will lead us to the following help page:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将带我们到以下帮助页面：
- en: '![](img/4014c686-12e0-4d38-9a51-f7abe4806bf4.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4014c686-12e0-4d38-9a51-f7abe4806bf4.jpg)'
- en: 'Similarly, in the case of `return_value`, we can use this command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `return_value` 的情况下，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll get this help page explaining how to use the method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下帮助页面，解释如何使用该方法：
- en: '![](img/62a8165d-d02c-4e54-89c4-e88ba580ff94.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/62a8165d-d02c-4e54-89c4-e88ba580ff94.png)'
- en: Similarly, it's easy to construct an observable sequence of any already known
    series of objects using the `of` or `from_iterable` factory methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用 `of` 或 `from_iterable` 工厂方法可以轻松构建任何已知对象序列的 observable 序列。
- en: The where factory method
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Where 工厂方法
- en: 'While we could use `select_many` to remove unwanted events from an observable
    sequence, it''s easier to use the `where` method. Let''s look at the help information
    for the `where` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用 `select_many` 从可观察序列中移除不需要的事件，但使用 `where` 方法会更简单。让我们看看 `where` 方法的帮助信息：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This method applies a callable to each element of the input observable sequence
    and returns an observable sequence containing only those elements for which the
    callable returned true. The following image shows the help description:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将一个可调用对象应用于输入可观察序列的每个元素，并返回一个只包含那些可调用对象返回 true 的元素的观察序列。以下图像显示了帮助描述：
- en: '![](img/f537127e-1e7b-4672-8d55-4f57575244d7.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f537127e-1e7b-4672-8d55-4f57575244d7.jpg)'
- en: Now we saw that there are fundamental ways to add and remove observable sequences,
    so what about processing them? We could just use `select` and `select_many` to
    do all of our processing, but Rx provides us with many more methods, such as `min`,
    `max`, `average`, `distinct`, `slice`, and `zip`, just to name a few of the tools
    available to us. I highly recommend that you investigate the Rx framework in more
    detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到，有基本的方法来添加和删除可观察序列，那么关于处理它们呢？我们本可以使用 `select` 和 `select_many` 来完成所有的处理，但
    Rx 为我们提供了许多更多的方法，例如 `min`、`max`、`average`、`distinct`、`slice` 和 `zip`，仅举几个我们可用的工具。我强烈建议您更详细地研究
    Rx 框架。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed what reactive programming is and implemented a
    bare-bones reactive framework, and used it to implement a demo program to help
    us get a handle on the concepts. We looked at the Reactive Extensions for Python,
    and used them to re-implement our zoo demo. We finished by looking at some of
    the broader possibilities of the Rx framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了响应式编程是什么，并实现了一个基本的响应式框架，并使用它来实现一个演示程序，以帮助我们掌握这些概念。我们研究了 Python 的响应式扩展，并使用它们重新实现了我们的动物园演示。最后，我们探讨了
    Rx 框架的一些更广泛的可能性。
- en: In the next chapter, we'll look at microservices, which are very small server
    processes that are meant to work together to create the desired results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨微服务，它们是非常小的服务器进程，旨在协同工作以产生所需的结果。
