- en: Implementing a Decentralized Application Using IPFS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IPFS实现去中心化应用
- en: In this chapter, we are going to combine a smart contract with the **InterPlanetary
    File System** (**IPFS**) to build a decentralized video-sharing application (similar
    to YouTube but decentralized). We will use a web application as the frontend for
    the blockchain and IPFS. As stated previously, IPFS is not a blockchain technology.
    IPFS is a decentralized technology. However, in a blockchain forum, meetup, or
    tutorial, you may hear IPFS being mentioned quite often. One of the main reasons
    for this is that IPFS overcomes the weakness of blockchain, which is that its
    storage is very expensive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将结合智能合约和**星际文件系统**（**IPFS**）来构建一个去中心化的视频分享应用（类似于YouTube但是去中心化）。我们将使用一个Web应用作为区块链和IPFS的前端。正如之前所述，IPFS并不是一种区块链技术。IPFS是一种去中心化技术。然而，在区块链论坛、聚会或教程中，你可能会经常听到IPFS被提到。其中一个主要原因是IPFS克服了区块链的弱点，即其存储非常昂贵。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Architecture of the decentralized video-sharing application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化视频分享应用的架构
- en: Writing the video-sharing smart contract
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写视频分享智能合约
- en: Building the video-sharing web application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建视频分享Web应用
- en: Architecture of the decentralized video-sharing application
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去中心化视频分享应用的架构
- en: This is how our application will look after it is finished—first, you go to
    a website, where you will see a list of videos (just like YouTube). Here, you
    can play videos in your browser, upload videos to your browser so that people
    can watch your cute cat video, and like other people's videos.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的应用在完成后的样子——首先，你去一个网站，在那里你会看到一个视频列表（就像YouTube一样）。在这里，你可以在浏览器中播放视频，上传视频到你的浏览器，这样人们就可以观看你的可爱的猫视频，并喜欢其他人的视频。
- en: On the surface, this is like a normal application. You build it with your favorite
    Python web framework, such as Django, Flask, or Pyramid. Then you use MySQL or
    PostgreSQL as the database. You could choose NGINX or Apache as the web server
    in front of the Gunicorn web server. For caching, you can use Varnish for full
    page caching and Redis for template caching. You will also host the web application
    and videos on the cloud, such as **Amazon Web Service** (**AWS**) or **Google
    Cloud Platform** (**GCP**), Azure. Then you will use a content delivery network
    to make it scalable worldwide. For the frontend side, you could use the JavaScript
    framework, with React.js, Angular.js, Vue.js, or Ember. If you are an advanced
    user, you could use machine learning for video recommendations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，这就像一个普通的应用。你可以用你喜欢的Python Web框架构建它，比如Django、Flask或Pyramid。然后你可以使用MySQL或PostgreSQL作为数据库。你可以选择NGINX或Apache作为Gunicorn
    Web服务器前面的Web服务器。对于缓存，你可以使用Varnish进行整页缓存，使用Redis进行模板缓存。你还将在云上托管Web应用和视频，比如**亚马逊网络服务**（**AWS**）或**谷歌云平台**（**GCP**），Azure。然后你将使用内容传送网络使其在全球范围内可扩展。对于前端，你可以使用JavaScript框架，如React.js、Angular.js、Vue.js或Ember。如果你是一个高级用户，你可以使用机器学习进行视频推荐。
- en: However, the key point here is that what we want to build is a decentralized
    video sharing application with blockchain technology, not a centralized application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键点在于，我们想要构建的是一个利用区块链技术的去中心化视频分享应用，而不是一个集中式应用。
- en: Let's discuss what we mean by building a decentralized video-sharing application
    with blockchain technology.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们所说的利用区块链技术构建去中心化视频分享应用的含义。
- en: 'We cannot store video files on the Ethereum blockchain as it is very expensive;
    even storing a picture file costs an arm and a leg on the Ethereum blockchain.
    Someone has done the math on this for us at the following link: [https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block](https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在以太坊区块链上存储视频文件，因为这非常昂贵；即使在以太坊区块链上存储图片文件也要花费很多钱。有人已经为我们在以下链接上进行了计算：[https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block](https://ethereum.stackexchange.com/questions/872/what-is-the-cost-to-store-1kb-10kb-100kb-worth-of-data-into-the-ethereum-block)。
- en: The cost of storing 1 KB is roughly 0.032 ETH. A decent image file is about
    2 MB. 1 MB is 1,000 KB if you ask hard drive manufacturers, or 1,024 KB if you
    ask an operating system. We simply round this to 1,000 because it does not make
    any difference to our calculation. Consequently, the cost of storing a 2 MB file
    on Ethereum is around 2,000 multiplied by 0.032 ETH, which is equal to 64 ETH.
    The price of ETH is always changing. At the time of writing, the cost of 1 ETH
    is around 120 US dollars. This means that to store a 2 MB picture file (a normal
    size stock picture file on the Unsplash website) you need to spend 7,680 US dollars.
    A one-and-a-half-minute video file in MP4 format is roughly 46 MB. Consequently,
    you need to spend 176,640 US dollars to store this video file on Ethereum.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 存储1 KB的成本大约为0.032 ETH。一个体面的图像文件大约为2 MB。如果你问硬盘制造商，1 MB就是1,000 KB，如果你问操作系统，就是1,024
    KB。我们简单地将其四舍五入为1,000，因为这对我们的计算没有任何影响。因此，在以太坊上存储2 MB文件的成本大约是2,000乘以0.032 ETH，等于64
    ETH。ETH的价格一直在变化。在撰写本文时，1 ETH的成本大约是120美元。这意味着要存储一个2 MB的图片文件（Unsplash网站上的普通大小库存图片文件），你需要花费7,680美元。一个一分半钟的MP4格式视频文件大约为46
    MB。因此，你需要花费176,640美元来在以太坊上存储这个视频文件。
- en: 'Instead of paying this, blockchain developers will usually store the reference
    of a video file on the blockchain and store the video file itself on normal storage,
    such as on AWS. In a Vyper smart contract, you can use the `bytes` data type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与其支付这个费用，区块链开发者通常会在区块链上存储视频文件的引用，并将视频文件本身存储在正常的存储介质上，比如AWS。在Vyper智能合约中，你可以使用`bytes`数据类型：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you could store the link of the video that you store in AWS S3 ([https://aws.amazon.com/s3/](https://aws.amazon.com/s3/))
    in the smart contract:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在智能合约中存储你在AWS S3（[https://aws.amazon.com/s3/](https://aws.amazon.com/s3/)）中存储的视频链接：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This approach is all fine and dandy, but the problem is that you are dependent
    on AWS. If the company does not like your cute panda video, they could delete
    it, and the URL that is present in the smart contract becomes invalid. You could
    of course change the value of the `cute_panda_video` variable on the smart contract
    (unless you forbid it from doing so). However, this situation causes inconveniences
    in our application. If you use the service from a centralized company, your faith
    is dependent on the whim of that company.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法都很好，但问题在于你依赖于AWS。如果公司不喜欢你的可爱熊猫视频，他们可以删除它，而存在于智能合约中的URL也会变得无效。当然，你可以改变智能合约中`cute_panda_video`变量的值（除非你禁止这样做）。然而，这种情况会给我们的应用程序带来不便。如果你使用来自集中化公司的服务，你的命运取决于该公司的心情。
- en: 'We can mitigate this problem by using decentralized storage, such as IPFS.
    Instead of an URL, we could store the IPFS path (or IPFS hash) as the value of
    the `cute_panda_video` variable, similar to the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用IPFS等去中心化存储来缓解这个问题。我们可以将IPFS路径（或IPFS哈希）存储为`cute_panda_video`变量的值，类似于以下示例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, we can launch our IPFS daemon on AWS and other places, such as GCP. Consequently,
    if AWS censors our cute panda video, the IPFS path of our cute panda video is
    still valid. We could serve the video from other places, such as GCP. You could
    even host the video on the computer at your grandma's house. People who are addicted
    to cute panda videos could even pin the video, and help us serve the cute panda
    video.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在AWS和其他地方（比如GCP）上启动我们的IPFS守护程序。因此，如果AWS审查我们的可爱熊猫视频，我们的可爱熊猫视频的IPFS路径仍然有效。我们可以从其他地方（比如GCP）提供视频。你甚至可以将视频托管在你奶奶家的电脑上。痴迷于可爱熊猫视频的人甚至可以固定该视频，帮助我们提供可爱熊猫视频。
- en: 'Other than hosting a cute panda video in a decentralized fashion, there are
    other values of the decentralized video sharing application. This value relates
    to blockchain technology. Suppose we want to build a **like** (thumbs up) video
    feature. We could store the like value on the blockchain. This prevents corruption.
    Imagine we want to build a voting contest for the cutest panda video with a prize
    of 10 BTC. If our contest application is done in a centralized fashion (using
    a table to keep the like value on a SQL database such as MySQL or PostgreSQL),
    we, as a centralized admin, could hijack the winner using the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以去中心化的方式托管可爱的熊猫视频之外，去中心化视频分享应用程序还有其他价值。这个价值与区块链技术有关。假设我们想要构建一个视频点赞功能。我们可以将点赞值存储在区块链上。这可以防止腐败。想象一下，我们想要为最可爱的熊猫视频举办一个投票比赛，奖金是10个比特币。如果我们的比赛应用程序是以集中化的方式完成的（使用表将点赞值存储在SQL数据库中，比如MySQL或PostgreSQL），我们作为集中化的管理员可以使用以下代码操纵获胜者：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, it is not this easy to cheat. You need to cover your tracks with
    database logs by ensuring that the aggregate counts match individual counts. This
    needs to be done subtly. Instead of adding a whopping number of votes, such as
    1 million at once, you could add the aggregate count to a random number between
    100 and 1,000 in an hour. This is not to suggest that you cheat the users, I am
    merely getting my point across.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作弊并不是这么容易的。你需要通过确保聚合计数与个体计数匹配来掩盖你的行踪，这需要做得很微妙。你可以在一个小时内将聚合计数添加到100到1,000之间的随机数字，而不是一次性添加一百万张选票，这并不是在建议你欺骗用户，我只是在阐明我的观点。
- en: With blockchain, we can prevent the corruption of the integrity of data via
    the centralized admin. The like value is kept in the smart contract, and you let
    people audit the smart contract's source code. Our like feature on the decentralized
    video sharing application increases the number of likes on a video through an
    honest process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过区块链，我们可以防止集中化管理员对数据完整性的腐败。点赞值保存在智能合约中，并且你可以让人们审计智能合约的源代码。我们在去中心化视频分享应用程序上的点赞功能通过一个诚实的过程增加了视频的点赞数。
- en: Other than the integrity of data, we could build a crypto economy. What I mean
    is, we could have economic activities (such as selling, buying, bidding, and so
    on) in our smart contract. We could build tokens in the same smart contract. The
    coin of this token could be spent on liking the video, so that liking videos is
    no longer free. The owner of the video could cash this out like money into their
    pocket. This dynamic could incentivize people to upload better videos.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据的完整性，我们还可以构建一个加密经济。我的意思是，我们可以在我们的智能合约中进行经济活动（比如出售、购买、竞标等）。我们可以在同一个智能合约中构建代币。这个代币的硬币可以用来点赞视频，这样点赞视频就不再是免费的。视频的所有者可以像把钱放进口袋一样把它兑现出来。这种动态可以激励人们上传更好的视频。
- en: On top of that, a decentralized application guarantees the independence of APIs.
    The nature of the decentralization of the application prevents APIs from being
    disturbed or harassed in a similar way to the Twitter API fiasco. A long time
    ago, developers could develop an interesting application on top of the Twitter
    API with a lot of freedom, but then Twitter imposed heavy restrictions on how
    developers could use their API. One such example is that Twitter once shut down
    API access to Politwoops, which preserved politicians' deleted tweets. Access
    has been reactivated, though. By making our application decentralized, we could
    increase the democratic nature of the API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，去中心化的应用程序保证了API的独立性。应用程序的去中心化性质防止了API受到类似Twitter API丑闻的干扰或骚扰。很久以前，开发者可以在Twitter
    API的基础上自由开发有趣的应用程序，但后来Twitter对开发者如何使用他们的API施加了严格的限制。其中一个例子是Twitter曾经关闭了Politwoops对API的访问权限，该应用程序保存了政客删除的推文。不过现在访问权限已经重新激活。通过使我们的应用程序去中心化，我们可以增加API的民主性质。
- en: For educational purposes, our application has two main features. Firstly, you
    can see a list of videos, play videos, and upload videos. These are normal things
    that you do on YouTube. Secondly, you can like a video, but only with a coin or
    token.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 出于教育目的，我们的应用程序有两个主要功能。首先，你可以看到视频列表，播放视频和上传视频。这些都是你在YouTube上做的正常事情。其次，你可以点赞视频，但只能用硬币或代币。
- en: Before we jump into building the application, let's design the architecture
    of the smart contract and the architecture of the web application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手构建应用程序之前，让我们设计智能合约的架构和Web应用程序的架构。
- en: Architecture of a video-sharing smart contract
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频分享智能合约的架构
- en: 'Our application starts with the smart contract. There are a few things that
    our smart contract needs to do here, and these are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序始于智能合约。我们的智能合约需要做一些事情，具体如下：
- en: Keep track of videos that have been uploaded by a user
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪用户上传的视频
- en: Utilize a token and its standard operation (ERC20)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用代币及其标准操作（ERC20）
- en: Provide a way for a user to like a video using a coin or token
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种用户可以使用硬币或代币点赞视频的方式
- en: The coin used for liking a video will be transferred to the video owner
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于点赞视频的硬币将转移到视频所有者
- en: That's it. We always strive to keep the smart contract as short as possible.
    The more the lines of code, the bigger the chances of a bug showing up. And a
    bug in the smart contract can't be fixed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们始终努力使智能合约尽可能简短。代码行数越多，出现错误的机会就越大。而智能合约中的错误是无法修复的。
- en: Before writing this smart contract, let's think about how we want to structure
    our smart contract. The structure of the smart contract includes the data structure.
    Let's look at an example of what data structure we want to use to track a user's
    videos.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这个智能合约之前，让我们考虑一下我们想要如何构建智能合约。智能合约的结构包括数据结构。让我们看一个例子，我们想要使用什么数据结构来跟踪用户的视频。
- en: We definitely want to use a mapping variable with an address data type as the
    key. The difficult part here is choosing what data type we want to use as the
    value for this mapping data type. As we learned in [Chapter 3](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml), *Implementing
    Smart Contracts Using Vyper*, there is no infinite size array in Vyper. If we
    use a `bytes32` array, we are limited to a certain size of array as the value
    for this mapping. This means a user can have a maximum size of videos. We can
    use a `bytes32` array to hold a list of videos that is very large in size, such
    as 1 million videos. What is the chance someone will upload more than 1 million
    videos? If you upload one video per day, you will only upload 3,650 videos in
    ten years. However, the problem with the `bytes32` array is, that it cannot accept data
    more than 32 bytes in size. The IPFS path, such as `QmWgMcTdPY9Rv7SCBusK1gWBRJcBi2MxNkC1yC6uvLYPwK`,
    has a length of 44 characters. Consequently, you must use at least a `bytes[44]`
    data type, but we round this up to `bytes[50]`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定想要使用一个映射变量，其中地址数据类型作为键。这里的困难部分是选择我们想要用作这个映射数据类型值的数据类型。正如我们在[第3章](9505075a-72c4-4fbe-ad17-564e599c3193.xhtml)中学到的，Vyper中没有无限大小的数组。如果我们使用`bytes32`数组，我们将受限于作为这个映射值的数组的特定大小。这意味着用户最多可以拥有一定大小的视频。我们可以使用`bytes32`数组来保存非常大的视频列表，比如100万个视频。有人会上传超过100万个视频的机会有多大呢？如果你每天上传一个视频，十年内你只会上传3650个视频。然而，`bytes32`数组的问题是，它不能接受超过32字节大小的数据。IPFS路径，比如`QmWgMcTdPY9Rv7SCBusK1gWBRJcBi2MxNkC1yC6uvLYPwK`，长度为44个字符。因此，你必须至少使用`bytes[44]`数据类型，但我们将其四舍五入为`bytes[50]`。
- en: Instead, we want to have another mapping data type variable (let's call this
    mapping z) as the value of this mapping data type variable, which has been described
    in the previous paragraph. Mapping z has an integer as the key and a struct that
    contains a `bytes[50]` data type variable to keep the IPFS path and the `bytes[20]`
    data type variable to keep the video title as the value. There is an integer tracker
    to initiate the value of the key in mapping z. This integer tracker is initialized
    with the value 0\. Every time we add a video (IPFS path and video title) to mapping
    z, we increase this integer tracker by one. So the next time we add another video,
    the key of mapping z is not 0 anymore, but 1\. This integer tracker is unique
    for each account. We could create another mapping of the account to this integer
    tracker.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们希望有另一个映射数据类型变量（让我们称之为映射z）作为前一段描述的这个映射数据类型变量的值。映射z的键是整数，值是包含`bytes[50]`数据类型变量以保存IPFS路径和`bytes[20]`数据类型变量以保存视频标题的结构。有一个整数跟踪器来初始化映射z中键的值。这个整数跟踪器的初始值为0。每次我们向映射z添加一个视频（IPFS路径和视频标题），我们就将这个整数跟踪器加一。因此，下次我们添加另一个视频时，映射z的键不再是0，而是1。这个整数跟踪器对每个账户都是唯一的。我们可以创建另一个映射将账户映射到这个整数跟踪器。
- en: After taking care of videos, we focus on likes. How do we store the fact that
    user A likes video Z? We need to make sure that a user cannot like the same video
    more than once. The easiest way to do this is to create a mapping with a `bytes[100]`
    data type as the key and a `boolean` data type as the value. The `bytes[100]`
    data type variable is a combination of using the video liker's address, the video
    uploader's address, and the index of videos. The `boolean` data type variable
    is used to indicate whether the user has already liked the video or not.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理视频之后，我们关注点赞。我们如何存储用户A点赞视频Z的事实？我们需要确保用户不能多次点赞同一视频。最简单的方法是创建一个映射，其中`bytes[100]`数据类型作为键，`boolean`数据类型作为值。`bytes[100]`数据类型变量是使用视频点赞者的地址、视频上传者的地址和视频索引的组合。`boolean`数据类型变量用于指示用户是否已经点赞了视频。
- en: On top of that, we need an integer data type to keep the aggregate count of
    the number of likes a video has. The aggregate likes is a mapping with a `bytes[100]`
    data type as the key and an `integer` data type as the value. The `bytes[100]`
    data type variable is a combination of the video uploader's address and the index
    of the videos.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要一个整数数据类型来保持视频点赞数量的总计。总点赞数是一个映射，其中`bytes[100]`数据类型作为键，`integer`数据类型作为值。`bytes[100]`数据类型变量是视频上传者的地址和视频索引的组合。
- en: The downside of this approach is that it is very hard to keep track of which
    users have liked particular videos in the smart contract. We could create another
    mapping to keep track of which users have liked a certain video. However, that
    would complicate our smart contract. Previously, we went the extra mile to create
    a mapping dedicated to keeping track of all videos that a user has uploaded. That
    is necessary because we want to get a list of a user's videos. This is what we
    call a core feature. However, keeping track of which users have liked a video
    is not what I call a core feature.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是很难跟踪哪些用户喜欢了智能合约中的特定视频。我们可以创建另一个映射来跟踪哪些用户喜欢了某个视频。然而，这会使我们的智能合约变得更加复杂。之前，我们不惜一切代价创建了一个专门用于跟踪用户上传的所有视频的映射。这是必要的，因为我们想要获取用户视频的列表。这就是我们所说的核心功能。然而，跟踪哪些用户喜欢了一个视频并不是我所说的核心功能。
- en: As long as we can make the video-liking process honest, we don't need to keep
    track of which users have liked a video. If we are really itching to keep track
    of these users, we can use events in a smart contract. Every time a user likes
    a video, it triggers an event. Then, on the client side with the `web3.py` library,
    we could filter these events to get all users who like a particular video. This
    will be an expensive process and should be done separately to the main application.
    We can use background jobs using Celery, at which point the result can be stored
    on a database such as SQlite, PostgreSQL, or MySQL. Building a decentralized application
    does not mean completely negating a centralized approach.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们能够让视频点赞的过程变得诚实，我们就不需要跟踪哪些用户喜欢了一个视频。如果我们真的渴望跟踪这些用户，我们可以在智能合约中使用事件。每当用户喜欢一个视频，它就会触发一个事件。然后，在客户端使用`web3.py`库，我们可以过滤这些事件以获取所有喜欢特定视频的用户。这将是一个昂贵的过程，应该单独完成主要应用程序。我们可以使用Celery进行后台作业，此时结果可以存储在数据库中，如SQlite、PostgreSQL或MySQL。构建去中心化应用并不意味着完全否定集中化的方法。
- en: The topic of tokens has been discussed thoroughly in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有关代币的主题已在[第8章](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml)中进行了彻底讨论，*在以太坊中创建代币*。
- en: Architecture of a video-sharing web application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频共享Web应用程序的架构
- en: We will develop a Python web application to use as the frontend for our smart
    contract. This means we need a proper server to become the host for the Python
    web application. For this, we at least need a Gunicorn web server. In other words,
    we need to host our Python web application in a centralized server, such as in
    AWS, GCP, or Azure. This is actually fine for viewing videos, but the problem
    arises when a user wants to upload a video because that requires accessing a private
    key. Users may become concerned that our Python web application on a centralized
    server would steal their private keys.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个Python Web应用程序，用作我们智能合约的前端。这意味着我们需要一个适当的服务器来成为Python Web应用程序的主机。为此，我们至少需要一个Gunicorn
    Web服务器。换句话说，我们需要在集中服务器上托管我们的Python Web应用程序，例如在AWS、GCP或Azure中。这对于观看视频来说是可以的，但当用户想要上传视频时就会出现问题，因为这需要访问私钥。用户可能会担心我们在集中服务器上的Python
    Web应用程序会窃取他们的私钥。
- en: So, the solution is to post the source code of our Python web application on
    GitHub or GitLab, then tell a user to download it, install it, and run it on their
    computer. They can audit our Python web application's source code to make sure
    there is no pesky code trying to steal their private keys. However, if they need
    to audit the source code every time, then we add another commit on our Git repository.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决方案是将我们的Python Web应用程序的源代码发布在GitHub或GitLab上，然后告诉用户下载、安装并在他们的计算机上运行它。他们可以审计我们的Python
    Web应用程序的源代码，以确保没有恶意代码试图窃取他们的私钥。然而，如果他们需要每次审计源代码，那么我们就在Git存储库上添加另一个提交。
- en: Or better still, we could store our Python web application's source code on
    IPFS. They can download this from IPFS and be sure that our application's source
    code could not be tampered with. They only need to audit the source code once
    before using it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的是，我们可以将我们的Python Web应用程序的源代码存储在IPFS上。他们可以从IPFS下载这个源代码，并确保我们应用程序的源代码不会被篡改。他们只需要在使用之前审计一次源代码。
- en: However, while we could host a static website on IPFS, we could not do the same
    with dynamic web pages such as Python, PHP, Ruby, or Perl web applications. Such
    dynamic websites need a proper web server. Consequently, anyone who downloads
    our Python web application's source code needs to install the right software before
    executing our application. They need to install the Python interpreter, the web
    server (Gunicorn, Apache, or NGINX), and all of the necessary libraries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然我们可以在IPFS上托管静态网站，但我们无法对Python、PHP、Ruby或Perl Web应用程序等动态网页执行相同的操作。这些动态网站需要一个适当的Web服务器。因此，任何下载我们的Python
    Web应用程序源代码的人都需要在执行我们的应用程序之前安装正确的软件。他们需要安装Python解释器、Web服务器（Gunicorn、Apache或NGINX）以及所有必要的库。
- en: However, only desktop users can do that. Mobile users cannot execute our application
    because there are no proper Python interpreters or web servers on the Android
    or iOS platforms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有桌面用户才能这样做。移动用户无法执行我们的应用程序，因为Android或iOS平台上没有适当的Python解释器或Web服务器。
- en: This is where JavaScript shines. You could create a static website that is dynamic
    so that you can have interactivity in the web pages. You could also create a complex
    JavaScript web application using React.js, Angular.js, Ember.js, or Vue.js and
    deploy it on IPFS. A desktop user and a mobile user could execute the JavaScript
    web application. Because this is a book about Python, we will still look at creating
    a Python web application. However, you should keep the advantages of JavaScript
    compared to Python in mind.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JavaScript的亮点所在。您可以创建一个静态网站，使其具有动态性，以便在网页中实现交互。您还可以使用React.js、Angular.js、Ember.js或Vue.js创建一个复杂的JavaScript
    Web应用程序，并将其部署在IPFS上。桌面用户和移动用户都可以执行JavaScript Web应用程序。因为这是一本关于Python的书，我们仍然会考虑创建一个Python
    Web应用程序。但是，您应该记住JavaScript相对于Python的优势。
- en: No matter how good JavaScript is, it still cannot save the plight of mobile
    users. Computing power on the mobile platform is still less powerful than computing
    power on the desktop platform. You still cannot run a full Ethereum node on a
    mobile platform in the same way that you cannot run IPFS software on a mobile
    platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论JavaScript有多好，它仍然不能解决移动用户的困境。移动平台上的计算能力仍然不如桌面平台上的计算能力强大。你仍然不能在移动平台上运行完整的以太坊节点，就像你不能在移动平台上运行IPFS软件一样。
- en: 'Let''s design our web application. This has a few utilities:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计我们的Web应用程序。这有一些实用工具：
- en: Playing a video
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放视频
- en: Uploading a video
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传视频
- en: Liking a video
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点赞视频
- en: Listing recent videos from many users
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从许多用户中列出最近的视频
- en: Listing videos from one specific user
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出一个特定用户的所有视频
- en: Listing all videos from a user is moderately easy because we have an unlimited
    size array (which is basically a mapping with integer as key and another integer
    tracker) of videos that we can get based on a user in the smart contract. The
    controller of the page accepts a user (or basically an address in the smart contract)
    as parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列出一个特定用户的所有视频相对容易，因为在智能合约中，我们有一个无限大小的数组（基本上是一个以整数为键和另一个整数跟踪器的映射），我们可以根据用户获取视频。页面的控制器接受一个用户（或者基本上是智能合约中的地址）作为参数。
- en: Playing a video accepts the video uploader's address and the index of the videos
    as parameters. If the video does not yet exist on our storage, we download it
    from IPFS. Then we serve the video to the user.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 播放视频接受视频上传者的地址和视频索引作为参数。如果视频还没有存在于我们的存储中，我们会从IPFS上下载它。然后我们将视频提供给用户。
- en: Uploading a video requires interacting with an Ethereum node. This method or
    functionality to upload a video accepts an argument of the account's address to
    be used, an argument of a password for the encrypted private key, an argument
    of the video file, and an argument of the video title. We store the video file
    first on IPFS. Then if it succeeds, we can store the information about this video
    on the blockchain.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上传视频需要与以太坊节点进行交互。上传视频的方法或功能接受一个要使用的账户地址的参数，一个加密私钥的密码参数，一个视频文件的参数，以及一个视频标题的参数。我们首先将视频文件存储在IPFS上。然后如果成功，我们可以在区块链上存储关于这个视频的信息。
- en: Liking a video also requires interacting with an Ethereum node. This method
    or functionality to like a video accepts an argument of the video liker's address
    to be used, an argument of a password for the encrypted private key, an argument
    of the video uploader's address, and an argument of the videos index. After making
    sure that the user has not liked the video previously, we store the information
    on the blockchain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点赞视频也需要与以太坊节点进行交互。点赞视频的方法或功能接受一个视频点赞者的地址参数，一个加密私钥的密码参数，一个视频上传者的地址参数，以及一个视频索引的参数。在确保用户之前没有点赞视频的情况下，我们将信息存储在区块链上。
- en: Listing recent videos from many users is a bit tricky. The effort involved is
    quite tremendous. In a smart contract, we don't have a variable to track all participating
    users. We also don't have a variable to track all videos from different users.
    However, we can create an event through the method of storing video information
    on the blockchain. After doing so, we can find all recent videos from this event.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从许多用户中列出最近的视频有点棘手。所涉及的工作量相当大。在智能合约中，我们没有一个变量来跟踪所有参与用户。我们也没有一个变量来跟踪不同用户的所有视频。然而，我们可以通过在区块链上存储视频信息的方法创建一个事件。这样做之后，我们可以从这个事件中找到所有最近的视频。
- en: Now it's time to build the decentralized video-sharing application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建去中心化的视频分享应用程序了。
- en: Writing the video-sharing smart contract
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写视频分享智能合约
- en: 'Without further ado, let''s set up our smart contract development platform:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们设置我们的智能合约开发平台：
- en: 'First things first, we set up our virtual environment as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们按照以下方式设置我们的虚拟环境：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we install Web3, Populus, and Vyper:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们安装Web3、Populus和Vyper：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The latest version of Vyper is 0.1.0b6, which breaks Populus. The developer
    needs some time to fix this. If the bug has not been fixed by the time you are
    reading this book, you could patch Populus yourself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vyper的最新版本是0.1.0b6，这破坏了Populus。开发者需要一些时间来修复这个问题。如果在你阅读本书时bug还没有被修复，你可以自己修补Populus。
- en: 'Check whether this library has fixed the bug or not using the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查这个库是否已经修复了bug：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In our case, the bug has not been fixed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，bug还没有被修复。
- en: 'So, let''s patch Populus to fix the bug. Make sure you are still in the same
    directory (`videos-venv/src/populus`):'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，让我们修补Populus以修复bug。确保你仍然在同一个目录中（`videos-venv/src/populus`）：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After patching Populus, we will create our smart contract project directory:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在修补Populus之后，我们将创建我们的智能合约项目目录：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we will initialize the directory as a Populus project directory:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将目录初始化为Populus项目目录：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we will download the Populus configuration file inside the Populus project
    directory:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在Populus项目目录中下载Populus配置文件：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will now open the `project.json` configuration file for Populus and override
    the value of the `compilation` key, as shown in the following code block:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将打开Populus的`project.json`配置文件，并覆盖`compilation`键的值，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we write our smart contract code in `videos-sharing-smart-contract/contracts/VideosSharing.vy` as
    shown in the following code block (refer to the code file at the following GitLab
    link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/contracts/VideosSharing.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/contracts/VideosSharing.vy)):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们在`videos-sharing-smart-contract/contracts/VideosSharing.vy`中编写我们的智能合约代码，如下面的代码块所示（请参考以下GitLab链接的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/contracts/VideosSharing.vy](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/contracts/VideosSharing.vy)）：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s discuss our smart contract bit by bit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步讨论我们的智能合约：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a struct of video information that we want to keep on the blockchain.
    The `path` of the `Video` struct stores the IPFS path, which has a length of 44\.
    The IPFS path will be a different length if we use another hashing function. Remember
    that IPFS uses multihash when hashing objects. If you use the more expensive hashing
    function, such as SHA512, in your IPFS configuration, then you need to double
    the size of the  `bytes[]` array data type. For example, `bytes[100]` should be
    sufficient. The `title` of the `Video` struct stores the video title. Here, I
    use `bytes[20]` because I want to keep the title short. You could use lengthier
    bytes such as `bytes[100]` if you want to store a lengthier title. However, remember
    that the more bytes you store on the blockchain, the more gas (money!) you have
    to spend. Of course, you could add more information in this struct, such as a
    video description or video tags, as long as you know the consequences, which is
    more gas needed to execute the method to store the video information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要在区块链上保留的视频信息的结构体。`Video`结构体的`path`存储了IPFS路径，长度为44。如果我们使用另一个哈希函数，IPFS路径将有不同的长度。请记住，IPFS在对对象进行哈希时使用多哈希。如果在IPFS配置中使用更昂贵的哈希函数，比如SHA512，那么需要将`bytes[]`数组数据类型的大小加倍。例如，`bytes[100]`应该足够了。`Video`结构体的`title`存储了视频标题。在这里，我使用了`bytes[20]`，因为我想要标题简短。如果你想要存储更长的标题，可以使用更长的字节，比如`bytes[100]`。然而，请记住，在区块链上存储的字节数越多，需要花费的gas（费用）就越多。当然，你可以在这个结构体中添加更多信息，比如视频描述或视频标签，只要你知道后果，即执行存储视频信息的方法需要更多的gas。
- en: 'We are now moving to the list of events:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转移到事件列表：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Transfer` and `Approval` are part of ERC20 standard events. You can read more
    about ERC20 in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum*. The `UploadVideo` event is triggered when we upload video
    information in our smart contract. We save the video uploader''s address and the
    index of videos. The `LikeVideo` event is triggered when we like a video in our
    smart contract.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transfer`和`Approval`是ERC20标准事件的一部分。你可以在[第8章](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml)中了解更多关于ERC20的信息，*在以太坊中创建代币*。`UploadVideo`事件在我们的智能合约中上传视频信息时触发。我们保存视频上传者的地址和视频的索引。`LikeVideo`事件在我们的智能合约中喜欢视频时触发。'
- en: 'We save the video liker''s address, the video uploader''s address, and the
    index of videos:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存视频喜欢者的地址，视频上传者的地址和视频的索引：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the integer tracker for our unlimited array. So if `user_videos_index[address
    of user A] = 5`, it means user A has uploaded four videos already.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们无限数组的整数跟踪器。所以如果`user_videos_index[用户A的地址] = 5`，这意味着用户A已经上传了四个视频。
- en: 'The following is part of the ERC20 standard:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ERC20标准的一部分：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Refer to [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum* for more information about ERC20.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ERC20的更多信息，请参阅[第8章](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml)，*在以太坊中创建代币*。
- en: 'We move on to the next line:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续下一行：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the core variable to keep all videos from all users. The `address` data
    type key is used to hold a user's address. The `map(uint256, Video)` data type
    value is our infinite array. The `uint256` key in `map(uint256, Video)` starts
    from 0 and then is tracked by the `user_videos_index` variable. `Video` struct
    is our video information.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保留所有用户所有视频的核心变量。`address`数据类型键用于保存用户的地址。`map(uint256, Video)`数据类型值是我们的无限数组。`map(uint256,
    Video)`中的`uint256`键从0开始，然后由`user_videos_index`变量跟踪。`Video`结构体是我们的视频信息。
- en: 'The next two lines of code are used for the likes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行代码用于喜欢：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `likes_videos` variable is a variable that's used to check whether a certain
    user has liked a particular video or not. The `aggregate_likes` variable is a
    variable used to show how many likes this particular video has got already.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`likes_videos`变量是用来检查某个用户是否喜欢特定视频的变量。`aggregate_likes`变量是用来显示这个特定视频已经获得了多少赞。'
- en: 'We are now done with defining variables and will move on to the code shown
    in the following code block:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了变量，将继续下面代码块中的代码：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is standard ERC20 code that you can learn about in [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating
    Token in Ethereum*. However, I made a small adjustment to the code, as shown in
    the following code block:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准的ERC20代码，你可以在[第8章](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml)中了解更多，*在以太坊中创建代币*。然而，我对代码进行了小幅调整，如下面的代码块所示：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this smart contract, I extracted the inner code of the `transfer` method
    to the dedicated private method. The reason for this is that the transferring
    coins functionality would be used in the method to like a video. Remember, when
    we like a video, we must pay coins to the video uploader. We cannot call public
    function inside another public function. The rest of the code is the same (other
    than the name of the token):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个智能合约中，我将`transfer`方法的内部代码提取到了专用的私有方法中。这样做的原因是，转移代币的功能将在喜欢视频的方法中使用。记住，当我们喜欢一个视频时，我们必须向视频上传者支付代币。我们不能在另一个公共函数中调用公共函数。其余的代码是一样的（除了代币的名称）：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the method used to store video information on the blockchain. We call
    this method after we upload the video to IPFS. `_video_path` is the IPFS path,
    and `_video_title` is the video title. We get the latest index from the video
    uploader (`msg.sender`). Then we set the value of the `Video` struct to `all_videos`
    based on video uploader's address and the latest index.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于在区块链上存储视频信息的方法。我们在将视频上传到IPFS后调用这个方法。`_video_path`是IPFS路径，`_video_title`是视频标题。我们从视频上传者（`msg.sender`）那里获取最新的索引。然后我们根据视频上传者的地址和最新的索引将`Video`结构体的值设置为`all_videos`。
- en: We then increase the integer tracker (`user_videos_index`). Don't forget to
    log this event.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们增加整数跟踪器(`user_videos_index`)。不要忘记记录这个事件。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The methods in the preceding code block are convenient ways to get the latest
    video index, the video IPFS path, and the video title for clients using web3\.
    Without these methods, you could still get the information about the video, but
    accessing a struct variable inside a nested mapping data type variable with web3
    is not straightforward.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中的方法是用于客户端使用web3获取最新视频索引、视频IPFS路径和视频标题的便利方法。没有这些方法，你仍然可以获取视频的信息，但是使用web3访问嵌套映射数据类型变量中的结构变量并不直接。
- en: 'The following code shows the method used to like a video. It accepts the video
    uploader''s address and the videos index. Here, you create two keys—one for `likes_videos` and
    the other for `aggregate_likes`. The key for `likes_videos` is a combination of
    the video liker''s address, the video uploader''s address, and the videos index.
    The key for `aggregate_likes` is a combination of the video uploader''s address
    and the video''s index. After creating keys, then we make sure the video liker
    cannot like the same video in the future and the video liker has not liked this
    particular video before. Liking a video merely sets a `True` value to `likes_videos` variable
    with the key that we have created. Then we increase the value of `aggregate_likes` with
    the key that we have created by one. Finally, we transfer one coin of the token
    from the video liker to the video uploader. Don''t forget to log this event:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了用于点赞视频的方法。它接受视频上传者的地址和视频索引。在这里，你创建了两个键——一个用于`likes_videos`，另一个用于`aggregate_likes`。`likes_videos`的键是视频点赞者的地址、视频上传者的地址和视频索引的组合。`aggregate_likes`的键是视频上传者的地址和视频索引的组合。创建键之后，我们确保视频点赞者将来不能再次点赞同一个视频，并且视频点赞者之前没有点赞过这个特定视频。点赞视频只是将`likes_videos`变量与我们创建的键设置为`True`。然后我们将`aggregate_likes`的值增加1。最后，我们将代币中的一枚硬币从视频点赞者转移到视频上传者。不要忘记记录这个事件：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following lines of code are convenience methods used to check whether a
    video has been liked by a particular user and how many likes this particular video
    has already:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行是用于检查特定用户是否已经点赞视频以及这个特定视频已经获得多少赞的便利方法：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s write a test in `videos_sharing_smart_contract/tests/test_video_sharing.py`.
    Refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/tests/test_videos_sharing.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/tests/test_videos_sharing.py).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`videos_sharing_smart_contract/tests/test_video_sharing.py`中编写一个测试。请参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/tests/test_videos_sharing.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/videos_sharing_smart_contract/tests/test_videos_sharing.py)。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s discuss the test script in detail, bit by bit. In the following code
    block, after importing necessary libraries, we created three convenient functions—a
    function to upload video, a function to transfer coins, and a function to like
    a video:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步详细讨论测试脚本。在下面的代码块中，导入必要的库之后，我们创建了三个便利函数——一个用于上传视频的函数，一个用于转移代币的函数，以及一个用于点赞视频的函数：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As the following code block shows, before uploading a video, we make sure that
    the latest videos index is 0\. Then, after we upload one video, we should check
    the latest video''s index, which should have increased by one. Of course, we check
    the video path and the video title as well. Then we upload one video again and
    check the latest video''s index, which should be 2 by now. We also check the video
    path and the video title. Finally, we check the events and make sure they have
    been created correctly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码块所示，在上传视频之前，我们确保最新视频的索引为0。然后，在上传一个视频之后，我们应该检查最新视频的索引，这个索引应该增加1。当然，我们也要检查视频路径和视频标题。然后我们再次上传一个视频并检查最新视频的索引，这时应该是2。我们还要检查视频路径和视频标题。最后，我们检查事件，并确保它们已经被正确创建：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s look at the next part of the test script:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下测试脚本的下一部分：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we transfer some coins from the manager account (the one that launched
    the smart contract) to different accounts, then we upload a video. Before liking
    a video, we should ensure that accounts' token balances are what they should be,
    the testing accounts have not liked this video, and the aggregate likes number
    is still 0.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从管理员账户（启动智能合约的账户）向不同的账户转移一些代币，然后我们上传一个视频。在点赞视频之前，我们应该确保账户的代币余额是正确的，测试账户还没有点赞这个视频，并且累计点赞数仍然是0。
- en: After doing this, we like a video from a particular account. The balance of
    a token for the video liker should be decreased by one and the balance of a token
    for the video uploader should be increased by one. This means that the smart contract
    has recorded that this account has liked the video and the aggregate likes of
    this video should be increased by 1.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些之后，我们从特定账户点赞一个视频。视频点赞者的代币余额应该减少1，视频上传者的代币余额应该增加1。这意味着智能合约已记录下这个账户点赞了视频，并且这个视频的累计点赞数应该增加1。
- en: Then, we like a video from another account. The balance of the token for the
    video liker should be decreased by one and the balance of token for the video
    uploader should be increased by one again. The smart contract has recorded that
    this other account has liked this video, at which point the aggregate likes of
    this video should be increased by 1 again, making it 2.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从另一个账户点赞一个视频。视频点赞者的代币余额应该减少1，视频上传者的代币余额应该再次增加1。智能合约已记录下另一个账户点赞了这个视频，此时这个视频的累计点赞数应该再次增加1，变为2。
- en: Then, we make sure the events of liking a video are triggered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们确保视频点赞事件被触发。
- en: Lastly, we make sure the video liker cannot like the same video more than once.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们确保视频点赞者不能多次点赞同一视频。
- en: We will not discuss the testing of ERC20 part of this smart contract. Refer
    to [Chapter 8](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml), *Creating Token in
    Ethereum,* to learn how to test the ERC20 token smart contract.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讨论智能合约的ERC20部分的测试。请参考[第8章](a4f3e7c5-3229-44cf-83d1-62c660fb04f2.xhtml)，*在以太坊中创建代币*，了解如何测试ERC20代币智能合约。
- en: 'To execute the test, run the following statement:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行测试，请运行以下语句：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Launching a private Ethereum blockchain
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动私有以太坊区块链
- en: 'Let''s launch our private Ethereum blockchain using geth. We will not use Ganache
    here, because events are not supported in the stable version of Ganache yet (however,
    the beta version of Ganache (v 2.0.0 beta 2) already supports events):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用geth启动我们的私有以太坊区块链。我们在这里不使用Ganache，因为稳定版本的Ganache尚不支持事件（然而，Ganache的beta版本（v
    2.0.0 beta 2）已经支持事件）：
- en: 'We will use the following code block to launch the block:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用以下代码块来启动区块：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now edit `chains/localblock/run_chain.sh`. Find `--ipcpath`, then change the
    value (the word after `--ipcpath`) to `/tmp/geth.ipc`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑`chains/localblock/run_chain.sh`。找到`--ipcpath`，然后更改值（`--ipcpath`后面的单词）为`/tmp/geth.ipc`。
- en: 'Then edit the `project.json` file. The `chains` object points to four keys:
    `tester`, `temp`, `ropsten`, and `mainnet`. Add another key, `localblock`, in
    the `chains` object:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后编辑`project.json`文件。`chains`对象指向四个键：`tester`、`temp`、`ropsten`和`mainnet`。在`chains`对象中添加另一个键`localblock`：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the blockchain using the following command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行区块链：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Compile our smart contract using the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译我们的智能合约：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, deploy our smart contract to our private blockchain using the following
    command:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令将我们的智能合约部署到我们的私有区块链：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Write down the address in which our smart contract is deployed in `address.txt`.
    This file must be adjacent to `videos_sharing_smart_contract` directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的智能合约部署的地址写入`address.txt`。该文件必须与`videos_sharing_smart_contract`目录相邻。
- en: Creating a bootstrap script
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建引导脚本
- en: This script is used to load data to make the development of our application
    easier. We can download free videos from [https://videos.pexels.com/](https://videos.pexels.com/).
    Create a `stock_videos` directory adjacent to the `videos_sharing_smart_contract`
    directory and download some MP4 files to that `stock_videos` directory. In my
    case, I downloaded more than 20 videos.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本用于加载数据，以便更轻松地开发我们的应用程序。我们可以从[https://videos.pexels.com/](https://videos.pexels.com/)下载免费视频。在`videos_sharing_smart_contract`目录旁边创建一个`stock_videos`目录，并将一些MP4文件下载到该`stock_videos`目录中。在我的情况下，我下载了超过20个视频。
- en: 'After downloading some data, we will create a script called `bootstrap_videos.py`.
    Refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/bootstrap_videos.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/bootstrap_videos.py):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下载一些数据后，我们将创建一个名为`bootstrap_videos.py`的脚本。有关完整代码，请参考以下GitLab链接的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/bootstrap_videos.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/bootstrap_videos.py)。
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s discuss the script in detail, bit by bit. In the following code block,
    after importing the necessary libraries, we create an object named `w3`, which
    is a connection object to our private blockchain:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步详细讨论脚本。在导入必要的库之后，在以下代码块中，我们创建了一个名为`w3`的对象，它是连接到我们私有区块链的连接对象：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the following lines of code, we create new accounts with the `w3.personal.newAccount()` method.
    Then we put the new account''s address in the `accounts.txt` file and the `accounts` variable.
    All accounts use `''bitcoin123''` as their password:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们使用`w3.personal.newAccount()`方法创建新账户。然后我们将新账户的地址放入`accounts.txt`文件和`accounts`变量中。所有账户都使用`'bitcoin123'`作为密码：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Remember: we save our smart contract''s address in the `address.txt` file after
    deploying it on our private blockchain. Now it''s time to load the content of
    the file to the `address` variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：在我们的私有区块链上部署智能合约后，我们将智能合约的地址保存在`address.txt`文件中。现在是时候将文件的内容加载到`address`变量中了：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then we load the `abi` or the interface of our smart contract that we can get
    from `contracts.json` in the `build` directory of our Populus project directory: `videos_sharing_smart_contract`.
    We load the JSON to the `contract` variable with the `json.load()` method. The
    `abi` is from the `'abi'` key of the `'VideosSharing'` key from the `json` object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们加载我们的智能合约的`abi`或接口，可以从Populus项目目录的`build`目录中的`contracts.json`中获取。我们使用`json.load()`方法将JSON加载到`contract`变量中。`abi`来自`json`对象的`'VideosSharing'`键中的`'abi'`键。
- en: 'Then we initialize the smart contract object with the address and the interface
    with `w3.eth.contract()` method. Then we get the IPFS connection object with the `ipfsapi.connect()` method:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`w3.eth.contract()`方法初始化智能合约对象的地址和接口。然后我们使用`ipfsapi.connect()`方法获取IPFS连接对象：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we want to transfer ether to our new accounts. By default, the first
    account (`w3.eth.accounts[0]`) gets all the rewards from the mining, so it has
    plenty of ether to share. The default password is `''this-is-not-a-secure-password''`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要向我们的新账户转移以太币。默认情况下，第一个账户（`w3.eth.accounts[0]`）获得所有来自挖矿的奖励，因此它有足够的以太币可以分享。默认密码是`'this-is-not-a-secure-password'`：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Sending ether is done via the `w3.personal.sendTransaction()` method, which
    accepts a dictionary containing the sender (`'from'`), destination (`'to'`), amount
    of ether (`'value'`), gas, price of gas (`'gasPrice'`), `nonce` as the first argument,
    and a password as the second argument. Then we wait for the transaction to be
    confirmed with the `wait_for_transaction_receipt()` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`w3.personal.sendTransaction()`方法发送以太币，该方法接受包含发送者（`'from'`）、目的地（`'to'`）、以太币数量（`'value'`）、gas、燃气价格（`'gasPrice'`）、`nonce`作为第一个参数，密码作为第二个参数的字典。然后我们使用`wait_for_transaction_receipt()`方法等待交易确认。
- en: 'After transferring ether, we transfer some ERC20 coins of our token to new
    accounts. This is necessary because, to like a video, we need coins of our ERC20
    token:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在转移以太币之后，我们将我们的代币的一些ERC20硬币转移到新账户。这是必要的，因为要喜欢一个视频，我们需要我们的ERC20代币的硬币：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We build a transaction object, `txn`, for transferring token methods (`VideosSharing.functions.transfer`),
    which accepts the destination account and the amount of coins with the `buildTransaction`
    method. This accepts a dictionary of the sender (`'from'`), gas, the price of
    gas (`'gasPrice'`), and nonce. We create a transaction using the `w3.personal.sendTransaction()`
    method then wait for the transaction to be confirmed with the `wait_for_transaction_receipt()`
    method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为转移代币方法（`VideosSharing.functions.transfer`）构建了一个交易对象`txn`，该方法接受目标帐户和硬币数量的`buildTransaction`方法。这个方法接受发送者（`'from'`）、燃气、燃气价格（`'gasPrice'`）和nonce的字典。我们使用`w3.personal.sendTransaction()`方法创建一个交易，然后使用`wait_for_transaction_receipt()`方法等待交易被确认。
- en: 'We list all files from the `stock_videos` directory with the `os.listdir()` method.
    You have downloaded some MP4 files to this directory. After doing this, we iterate
    over these files:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`os.listdir()`方法列出`stock_videos`目录中的所有文件。您已经将一些MP4文件下载到此目录中。在这样做之后，我们遍历这些文件：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We want every account to upload seven videos (`account = accounts [index//7]`).
    Consequently, the first seven videos will be uploaded by the first account, while
    the second batch of seven videos will be uploaded by the second account. Then
    we add the MP4 file to IPFS (`ipfs_add = c.add(directory + '/' + movie)`). We
    get the IPFS path and convert it to a bytes object (`ipfs_path = ipfs_add['Hash'].encode('utf-8')`),
    strip the MP4 filename to 20 characters and convert it to a bytes object because
    the title in the smart contract has a data type of `bytes[20]`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个帐户上传七个视频（`account = accounts [index//7]`）。因此，前七个视频将由第一个帐户上传，而第二批七个视频将由第二个帐户上传。然后我们将MP4文件添加到IPFS（`ipfs_add
    = c.add(directory + '/' + movie)`）。我们获取IPFS路径并将其转换为字节对象（`ipfs_path = ipfs_add['Hash'].encode('utf-8')`），将MP4文件名削减为20个字符并将其转换为字节对象，因为智能合约中的标题具有`bytes[20]`数据类型。
- en: Then we call the `upload_video` method of our smart contract (`VideosSharing.functions.upload_video`).
    We have to build the transaction object before sending it as argument to the `w3.personal.sendTransaction()`
    method. We wait for the transaction to be confirmed as usual with the `wait_for_transaction_receipt()`
    method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用我们智能合约的`upload_video`方法（`VideosSharing.functions.upload_video`）。在将其作为参数发送到`w3.personal.sendTransaction()`方法之前，我们必须构建交易对象。我们等待交易像往常一样被确认，使用`wait_for_transaction_receipt()`方法。
- en: However, you must be careful with the `upload_video` method because it saves
    the video path, which has a `bytes[50]` data type, and video title, which has
    a `bytes[20]` data type on the blockchain. It also increases the video's index
    and logs the event. The gas and gas price needed is much more than the transferring
    coins or token method. To transfer token coins, you can get away with a gas price
    of 1 gwei and 70,000 gas. However, this would fail for our `upload_video` method.
    For this method, I use gas price of 30 gwei and 200,000 gas. Remember, storage
    is expensive in blockchains. Even some strings could raise the gas and gas price
    needed for the operation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您必须小心`upload_video`方法，因为它会保存视频路径，该路径具有`bytes[50]`数据类型，并且视频标题，该标题具有`bytes[20]`数据类型在区块链上。它还会增加视频的索引并记录事件。所需的燃气和燃气价格比转移硬币或代币方法要多得多。要转移代币硬币，您可以使用1
    gwei和70,000 gas的燃气价格。但是，对于我们的`upload_video`方法，这将失败。对于此方法，我使用30 gwei和200,000 gas的燃气价格。请记住，在区块链中存储是昂贵的。即使一些字符串也可能会提高操作所需的燃气和燃气价格。
- en: 'Make sure you have launched your private blockchain, then launch the IPFS `daemon`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已经启动了您的私有区块链，然后启动IPFS `daemon`：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Refer to [Chapter 11](e90593ae-aa5a-4c74-b6b9-5793cb32afdd.xhtml), *Using ipfsapi
    to Interact with IPFS*, if you don't know how to install and launch IPFS.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道如何安装和启动IPFS，请参考[第11章](e90593ae-aa5a-4c74-b6b9-5793cb32afdd.xhtml)，*使用ipfsapi与IPFS交互*。
- en: 'Now, we need to install the IPFS Python library in our virtual environment:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的虚拟环境中安装IPFS Python库：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we run our bootstrap script using the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令运行我们的引导脚本：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It will take some time. You could test whether your bootstrap script succeeds
    or not by accessing the smart contract and checking whether the videos have been
    uploaded or not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间。您可以通过访问智能合约并检查视频是否已上传来测试您的引导脚本是否成功。
- en: 'Create a script named `check_bootstrap.py`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`check_bootstrap.py`的脚本：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the script. If you get `0` as the output, your bootstrap script failed.
    If you get some output other than `0`, then your video information has been uploaded
    into the blockchain successfully.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本。如果输出为`0`，则您的引导脚本失败。如果您得到除`0`之外的一些输出，则您的视频信息已成功上传到区块链中。
- en: Building the video-sharing web application
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建视频分享网络应用程序
- en: 'It''s time to build the frontend of our smart contract. Previously, in [Chapter
    7](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml), *Frontend Decentralized Application*,
    and [Chapter 9](e0b7a349-cbc8-4733-8fbe-6bd97b303a7d.xhtml), *Cryptocurrency Wallet*,
    we have created a desktop application using Qt for Python or the `Pyside2` library.
    This time we are going to build a web application using the Django library:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建我们智能合约的前端了。在[第7章](0a33cede-7868-4a41-97ce-50a6c741486e.xhtml)和[第9章](e0b7a349-cbc8-4733-8fbe-6bd97b303a7d.xhtml)中，我们使用Qt
    for Python或`Pyside2`库创建了一个桌面应用程序。这次我们将使用Django库构建一个Web应用程序：
- en: 'Without further ado, let''s install Django:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 话不多说，让我们安装Django：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also need the OpenCV Python library to get the thumbnail of our videos:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要OpenCV Python库来获取我们视频的缩略图：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s create our Django project directory. This will create a skeleton
    Django project with its settings files:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的Django项目目录。这将创建一个带有其设置文件的骨架Django项目：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inside this new directory, create a `static media` directory:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新目录中，创建一个`static media`目录：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Still in the same directory, create a Django application named `videos`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个目录中，创建一个名为`videos`的Django应用程序：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then update our Django project settings file. The file is located in `decentralized_videos/settings.py`.
    Add our new application, `videos`, to `INSTALLED_APPS` variable. Make sure there
    is a comma between the `''videos''` and `''django.contrib.staticfiles''` strings.
    We need to add every Django application to this variable in order for the Django
    project to recognize it. A Django project can be composed of many Django applications:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后更新我们的Django项目设置文件。该文件位于`decentralized_videos/settings.py`。将我们的新应用程序`videos`添加到`INSTALLED_APPS`变量中。确保`'videos'`和`'django.contrib.staticfiles'`字符串之间有逗号。我们需要将每个Django应用程序添加到这个变量中，以便Django项目能够识别它。一个Django项目可以由许多Django应用程序组成：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, in the same file, add the following lines of code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在同一个文件中，添加以下代码行：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `STATIC_URL` variable defines how we access a static URL. With this value,
    we can access static files with this URL: `http://localhost:8000/static/our_static_file`. The `STATICFILES_DIRS`
    variable refers to where we keep our static files in the filesystem. We simply
    store the videos in the `static` directory inside our Django project directory.
    `MEDIA_URL` has the same purpose as `STATIC_URL`, but for media files. Media files
    are what users upload into the Django project, while static files are what we
    as developers put into the Django project.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`STATIC_URL`变量定义了我们如何访问静态URL。有了这个值，我们可以使用这个URL访问静态文件：`http://localhost:8000/static/our_static_file`。`STATICFILES_DIRS`变量指的是我们在文件系统中保存静态文件的位置。我们简单地将视频存储在Django项目目录内的`static`目录中。`MEDIA_URL`和`STATIC_URL`的作用是一样的，但是用于媒体文件。媒体文件是用户上传到Django项目中的文件，而静态文件是我们作为开发者放入Django项目中的文件。'
- en: Views
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'Now let''s create the view file of the `videos` application. A view is a controller
    that is like an API endpoint. The file is located in `decentralized_videos/videos/views.py`.
    Refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/views.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/views.py):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`videos`应用程序的视图文件。视图是一个类似API端点的控制器。该文件位于`decentralized_videos/videos/views.py`。请参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/views.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/views.py)：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s discuss the code bit by bit. First, we import all the required libraries
    using the following lines of code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步讨论代码。首先，我们使用以下代码行导入所有所需的库：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `render` and `redirect` methods are convenience functions from Django library
    that render templates (such as HTML files) and redirect them from a view to another
    view. `videos_sharing` is a custom instance that we will create soon in our `models`
    file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`和`redirect`方法是Django库中的便利函数，用于渲染模板（如HTML文件）并将其从一个视图重定向到另一个视图。`videos_sharing`是我们将在`models`文件中很快创建的自定义实例。'
- en: 'Next, we will create the method that will be the view for our homepage:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个方法，这个方法将成为我们主页的视图：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We retrieve recent videos from our model instance. We will build this class
    and its methods. We render the `'videos/index.html'` template, which we will create
    later with a context containing a `videos` object. The `request` parameter is
    the representation of POST parameters and GET parameters, among other things.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的模型实例中检索最近的视频。我们将构建这个类及其方法。我们使用包含`videos`对象的上下文渲染`'videos/index.html'`模板，稍后我们将创建这个模板。`request`参数是POST参数和GET参数的表示，还有其他内容。
- en: 'Then, we have the following lines of code for the page, which lists all the
    videos from a specific video uploader:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有以下代码行用于列出特定视频上传者的所有视频的页面：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This method accepts a `video_user` parameter, which represents the address of
    the video uploader. We get the videos from the `videos_sharing.get_videos` method,
    which accepts the address of the video uploader. Then we render the `'videos/channel.html'`
    template file with a context containing the videos and the address of the video
    uploader.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受一个`video_user`参数，代表视频上传者的地址。我们从`videos_sharing.get_videos`方法中获取视频，该方法接受视频上传者的地址。然后我们使用包含视频和视频上传者地址的上下文渲染`'videos/channel.html'`模板文件。
- en: 'In the following method, we have the view for the page on which a video will
    be played:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的方法中，我们有一个用于播放视频的页面的视图：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This method accepts the `video_user` parameter, which represents the address
    of the video uploader, and the `index` parameter, which represents the video's
    index. We get a specific video from the `videos_sharing.get_video` method, which
    accepts the `video_user` and `index` parameters. Following this, we render `'videos/video.html'`
    with a contract containing this video.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受`video_user`参数，代表视频上传者的地址，以及`index`参数，代表视频的索引。我们从`videos_sharing.get_video`方法中获取特定视频，该方法接受`video_user`和`index`参数。接下来，我们使用包含这个视频的上下文渲染`'videos/video.html'`。
- en: 'Then, we have the view that we call when we upload a video file, its title,
    the address of the video uploader, and the password:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个视图，当我们上传视频文件、标题、视频上传者的地址和密码时调用：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: To retrieve the POST parameter, we can use `request.POST` property. However,
    to access the file we are uploading, we use the `request.FILES` property. This
    view is used for the page to upload the file and to process the file itself. We
    store video information to the blockchain with the `videos_sharing.upload_video`
    method. At the end of this method, we render `'videos/upload.html'` with `context`
    containing a success notification if we have uploaded a video successfully.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索POST参数，我们可以使用`request.POST`属性。然而，要访问我们正在上传的文件，我们使用`request.FILES`属性。这个视图用于上传文件的页面和处理文件本身。我们使用`videos_sharing.upload_video`方法将视频信息存储到区块链中。在这个方法的结尾，我们使用`context`渲染`'videos/upload.html'`，如果我们成功上传了视频，就会包含一个成功的通知。
- en: For educational purposes, I made the uploading code simpler without validating
    it. On top of that, this web application is used by one person. However, if you
    intend to build a web application that serves many strangers, you need to validate
    uploaded files. You should also use the Django form to handle POST parameters
    instead of doing it manually.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 出于教育目的，我简化了上传代码，没有进行验证。此外，这个网络应用只被一个人使用。然而，如果你打算构建一个为许多陌生人提供服务的网络应用，你需要验证上传的文件。你还应该使用Django表单来处理POST参数，而不是手动处理。
- en: 'Then, in the following method, we have the view to like the video:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在以下方法中，我们有喜欢视频的视图：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When we want to like a video, we retrieve all the necessary information, such
    as the address of the video liker, the address of the video uploader, the video's
    index, and the password, so we can get the specific video. Then we use the `videos_sharing.like_video`
    method to do the job. After liking a video, we redirect to the `video` view.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要喜欢一个视频时，我们会检索所有必要的信息，比如视频点赞者的地址、视频上传者的地址、视频的索引和密码，这样我们就可以获取特定的视频。然后我们使用`videos_sharing.like_video`方法来完成这项工作。点赞视频后，我们重定向到`video`视图。
- en: Models
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'Let''s create our models file in `decentralized_videos/videos/models.py`. Most
    logic and heavy operations happen here. Calling a smart contract''s methods and
    storing files into IPFS also happen here. Refer to the code file at the following
    GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/models.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/models.py):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`decentralized_videos/videos/models.py`中创建我们的模型文件。大部分逻辑和繁重的操作都发生在这里。调用智能合约的方法和将文件存储到IPFS也发生在这里。请参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/models.py](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/models.py)：
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s discuss the core functionalities of our Django project bit by bit. First,
    we import convenience methods from the Python standard library, the IPFS Python
    library, OpenCV Python library, the web3 library, the Populus library, and some
    variables from the Django settings file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步讨论我们Django项目的核心功能。首先，我们从Python标准库、IPFS Python库、OpenCV Python库、web3库、Populus库中导入方便的方法，以及从Django设置文件中导入一些变量：
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we start with the initialization code of the `VideosSharing` model:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`VideosSharing`模型的初始化代码开始：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We initialize this instance by creating a web3 connection object, which is `w3`,
    create a smart contract object by providing the address of the smart contract
    and the interface, which is `SmartContract`, and lastly create an IPFS connection
    object, which is `ipfs_con`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个web3连接对象`w3`来初始化这个实例，创建一个智能合约对象，提供智能合约的地址和接口`SmartContract`，最后创建一个IPFS连接对象`ipfs_con`。
- en: 'Then, we have the method that is used in the `index` view:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有在`index`视图中使用的方法：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Recent videos can be retrieved from events. If you recall when we uploaded a
    video in our smart contract, you will remember that we logged an event here. Our
    event is `UploadVideo`. Because this Django project is a toy application, we get
    all the events from the starting block. In the real world, you will want to limit
    it (maybe the last 100 blocks). Furthermore, you probably want to store events
    to a database in background jobs (such as cron) for easy retrieval. This event
    object contains the video uploader and the video's index. Based on this information
    we can get the video path, the video title, and the video thumbnail. We accumulate
    videos in the `videos` object, reverse it (because we want to get recent videos),
    and return this object to the caller of the method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的视频可以从事件中检索。如果你还记得我们在智能合约中上传视频时，会记得我们在这里记录了一个事件。我们的事件是`UploadVideo`。因为这个Django项目只是一个玩具应用，我们从起始块获取所有事件。在现实世界中，你可能希望限制它（也许是最后100个块）。此外，你可能希望在后台作业（比如cron）中将事件存储到数据库中，以便轻松检索。这个事件对象包含了视频上传者和视频的索引。根据这些信息，我们可以获取视频路径、视频标题和视频缩略图。我们在`videos`对象中累积视频，然后将其反转（因为我们想获取最近的视频），并将这个对象返回给方法的调用者。
- en: 'Then, we have the method to get the videos from a specific video uploader:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个从特定视频上传者那里获取视频的方法：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is used in the `channel` view. First, we get the latest videos index of
    this video uploader. Based on this information, we can find out how many videos
    the video uploader has uploaded. Then, we retrieve the videos one by one from
    the highest index to the lowest index until the number of videos reaches the number
    we need.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`channel`视图中使用。首先，我们获取这个视频上传者的最新视频索引。根据这些信息，我们可以找出视频上传者上传了多少个视频。然后，我们从最高索引到最低索引逐个检索视频，直到视频数量达到我们需要的数量。
- en: 'These are the methods for getting the video path and the video title based
    on the address of the video uploader:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是根据视频上传者的地址获取视频路径和视频标题的方法：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And the videos index is defined as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 视频索引定义如下：
- en: '[PRE67]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We use the `videos_path` and `videos_title` methods from our smart contract.
    Don't forget to decode the result because the `bytes` object forms our smart contract.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了我们智能合约的`videos_path`和`videos_title`方法。不要忘记解码结果，因为`bytes`对象形成了我们的智能合约。
- en: 'The following code block is the method that gets the video thumbnail:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是获取视频缩略图的方法：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When we view a video in the video-playing page, we check whether there is a
    certain filename with a `.png` file extension. We find this filename pattern inside
    the `static files` directory. If we can't find the file, we just use a placeholder
    picture file from the internet.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在播放视频页面查看视频时，我们会检查是否有一个特定的带有`.png`文件扩展名的文件名。我们在`static files`目录中找到这个文件名模式。如果找不到文件，我们就从互联网上使用一个占位图片文件。
- en: 'The following code block is the method to retrieve a specific video:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块是检索特定视频的方法：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is used in the `video` view. We need the video path, the video title, the
    video file, the video thumbnail, and the aggregate likes of this video (which
    we can get with `video_aggregate_likes` method from our smart contract). We check
    whether this MP4 file exists or not in our static files directory. If not, we
    retrieve it from IPFS with the `ipfs_con.get` method. Then we move the file to
    the static files directory and create a thumbnail image if one does not exist
    yet.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`video`视图中使用。我们需要视频路径、视频标题、视频文件、视频缩略图和这个视频的总点赞数（我们可以使用智能合约的`video_aggregate_likes`方法获取）。我们检查静态文件目录中是否存在这个MP4文件。如果不存在，我们使用`ipfs_con.get`方法从IPFS中检索它。然后我们将文件移动到静态文件目录，并在尚未存在时创建缩略图图像。
- en: In the real world, you will want to retrieve the file from IPFS in a background
    job using Celery and RabbitMQ, for example. For this toy application, we just
    download a video in a blocking fashion. However, installing and configuring Celery
    and RabbitMQ is not for the faint of heart, and I think it will be a distraction
    from our educational purpose here.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，您可能希望使用Celery和RabbitMQ等后台作业来从IPFS中检索文件。对于这个玩具应用程序，我们只是以阻塞的方式下载视频。但是，安装和配置Celery和RabbitMQ并不是一件轻松的事情，我认为这会分散我们在这里的教育目的。
- en: 'The following method demonstrates what happens when we upload a video:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法演示了当我们上传视频时会发生什么：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We save the file in the media directory from our file in memory, and then add
    the file to IPFS with the `ipfs_con.add` method. We get the IPFS path and prepare
    the title of the video. Then, we call `upload_video` method from our smart contract.
    Remember to set enough gas and gas price for this. This is quite an expensive
    smart contract method. We wait for the transaction to be confirmed. In the real
    world, you'll want to do all of these steps using a background job.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件保存在内存中的媒体目录中，然后使用`ipfs_con.add`方法将文件添加到IPFS。我们获取IPFS路径并准备视频的标题。然后，我们从智能合约中调用`upload_video`方法。记得为此设置足够的gas和gas价格。这是一个非常昂贵的智能合约方法。我们等待交易确认。在现实世界中，您可能希望使用后台作业来执行所有这些步骤。
- en: 'The following code block shows how to generate a thumbnail from a video:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了如何从视频生成缩略图：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After ensuring no such file exists, we get the video object. We read the first
    frame of the object and save this to an image file. This video functionality is
    from the OpenCV Python library.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不存在这样的文件后，我们获取视频对象。我们读取对象的第一帧并将其保存到图像文件中。这个视频功能来自OpenCV Python库。
- en: 'Then, we have the method for liking a video:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有点赞视频的方法：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We make sure this video has not been liked by calling the `video_has_been_liked`
    method from our smart contract. Then we call the `like_video` method with the
    required parameters from our smart contract.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用智能合约的`video_has_been_liked`方法来确保这个视频还没有被点赞。然后我们使用智能合约的`like_video`方法来点赞视频。
- en: 'And, finally, we create an instance of the `VideosSharing` class so we can
    import this instance:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了`VideosSharing`类的一个实例，以便可以导入这个实例：
- en: '[PRE73]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Instead of importing a class, I prefer to import an instance of a class. Consequently,
    we initialize a class instance here.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢导入一个类的实例，而不是导入一个类。因此，我们在这里初始化一个类的实例。
- en: Templates
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'It''s time to write our templates. First, let''s create a template directory
    using the following command lines:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候写我们的模板了。首先，让我们使用以下命令行创建一个模板目录：
- en: '[PRE74]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, we create our base layout first using the following lines of HTML. This
    is the layout that will be used by all our templates. The file is located in `videos/templates/videos/base.html`.
    You can refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/base.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/base.html):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们首先使用以下HTML代码创建我们的基本布局。这是所有我们模板将使用的布局。文件位于`videos/templates/videos/base.html`。您可以参考以下GitLab链接中的代码文件：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/base.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/base.html)：
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the header, we import the Bulma CSS framework and the Font Awesome JavaScript
    file. In this base layout, we set up our navigation, which holds the home page
    link and the video upload link. The section between `{% block content %}` and
    `{% endblock %}` will be filled by our template's content.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在页眉中，我们导入Bulma CSS框架和Font Awesome JavaScript文件。在这个基本布局中，我们设置了我们的导航，其中包含首页链接和视频上传链接。在`{%
    block content %}`和`{% endblock %}`之间的部分将由我们模板的内容填充。
- en: While this book focuses on teaching Python only, avoiding other technologies
    such as CSS and JavaScript as much as possible, some CSS is necessary to make
    our web application look decent. You can go to [https://bulma.io](https://bulma.io)
    to learn about this CSS framework.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书专注于教授Python，尽量避免其他技术，如CSS和JavaScript，但一些CSS是必要的，以使我们的Web应用程序看起来体面。您可以访问[https://bulma.io](https://bulma.io)了解这个CSS框架。
- en: 'Then, let''s create our first template file in `videos/templates/videos/index.html`.
    Use the following code block to create the template file:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们在`videos/templates/videos/index.html`中创建我们的第一个模板文件。使用以下代码块创建模板文件：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: First things first; we make sure this template extends our base layout. Then
    we display our video in this template. We use the `card` class div to display
    the video. The `cycle` method is used to generate the `columns` class div to contain
    four `column` class divs. The second `cycle` method is used to close this div.
    In the footer of this `card`, we create a link to the page to play this video.
    The `url` method accepts the URL name (which we will discuss soon) and its parameters.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保这个模板扩展了我们的基本布局。然后我们在模板中显示我们的视频。我们使用`card`类div来显示视频。`cycle`方法用于生成`columns`类div来包含四个`column`类div。第二个`cycle`方法用于关闭这个div。在这个`card`的页脚，我们创建了一个链接到播放此视频的页面。`url`方法接受URL名称（我们将很快讨论）及其参数。
- en: 'Then, we will create our template file to play the video in `videos/templates/videos/video.html`.
    You can refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/video.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/video.html):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个模板文件，在`videos/templates/videos/video.html`中播放视频。您可以参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/video.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/video.html)：
- en: '[PRE77]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: After extending base layout, we create a `breadcrumb` so a user can go to the
    video uploader's channel page. Then we display the video with a `video` HTML tag.
    Below the video, we display the aggregate likes number. At the bottom of the page,
    we create a form to like the video. This accepts the video liker's address and
    the password input by the user. There are hidden inputs to send the video uploader's
    address and the videos index. Note that there is a CSRF token named `{% csrf_token
    %}` inside this form. This is necessary for avoiding CSRF vulnerabilities.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展基本布局之后，我们创建一个`breadcrumb`，以便用户可以转到视频上传者的频道页面。然后我们使用`video` HTML标签显示视频。在视频下方，我们显示聚合点赞数。在页面底部，我们创建一个表单来点赞视频。这个表单接受视频点赞者的地址和用户输入的密码。有隐藏的输入来发送视频上传者的地址和视频索引。请注意，这个表单内有一个名为`{%
    csrf_token %}`的CSRF令牌。这是为了避免CSRF漏洞。
- en: 'Then let''s create our template file to list all videos from a specific video
    uploader in `videos/templates/videos/channel.html`. You can refer to the code
    file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/channel.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/channel.html):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们创建一个模板文件，用于在`videos/templates/videos/channel.html`中列出特定视频上传者的所有视频。您可以参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/channel.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/channel.html)：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This template file is the same as the index template, except we have a `breadcrumb`
    at the top of the list of videos.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板文件与索引模板相同，只是在视频列表的顶部有一个`breadcrumb`。
- en: 'Let''s create the last template file for uploading videos in `videos/templates/videos/upload.html`.
    You can refer to the code file at the following GitLab link for the full code: [https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/upload.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/upload.html):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建最后一个模板文件，用于在`videos/templates/videos/upload.html`中上传视频。您可以参考以下GitLab链接中的代码文件获取完整的代码：[https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/upload.html](https://gitlab.com/arjunaskykok/hands-on-blockchain-for-python-developers/blob/master/chapter_12/decentralized_videos/videos/templates/videos/upload.html)：
- en: '[PRE79]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this template, after extending the base layout, we create the `breadcrumb`.
    Then, we create a form to upload the video.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，扩展基本布局后，我们创建了`breadcrumb`。然后，我们创建一个上传视频的表单。
- en: This has four inputs—the video title, the video file, the video uploader's address,
    and the password. The JavaScript code at the bottom of the template is used to
    set the filename on the label of the file upload field after we have selected
    a file. Because we are uploading a file, we need to have the `enctype` attribute
    of the form set to `"multipart/form-data"`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有四个输入——视频标题、视频文件、视频上传者的地址和密码。模板底部的JavaScript代码用于在选择文件后将文件名设置为文件上传字段的标签。因为我们正在上传文件，所以需要将表单的`enctype`属性设置为`"multipart/form-data"`。
- en: Urls
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Urls
- en: 'The `urls` file is a routing mechanism in Django. Open `decentralized_videos/videos/urls.py`,
    delete the content, and replace it with the following script:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`urls`文件是Django中的路由机制。打开`decentralized_videos/videos/urls.py`，删除内容，并用以下脚本替换：'
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Remember the views file we created previously? Here, we map the views into routing.
    We access the video-playing page by using `http://localhost:8000/video/0x0000000000000000000000000000000000000000/1`.
    The parameters will be mapped into the `video_user` variable and the `index` variable.
    The first parameter of the `path` method is the way we call it in the browser.
    The second method is the view we use, and the third parameter is the name of the
    routing that is used in templates.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们之前创建的视图文件吗？在这里，我们将视图映射到路由。我们通过`http://localhost:8000/video/0x0000000000000000000000000000000000000000/1`访问视频播放页面。参数将映射到`video_user`变量和`index`变量。`path`方法的第一个参数是我们在浏览器中调用它的方式。第二个方法是我们使用的视图，第三个参数是在模板中使用的路由名称。
- en: 'Then we need to register these `urls` to the project `urls` file. Edit `decentralized_videos/decentralized_videos/urls.py` and
    add our `videos.urls` path so our web application knows how to route our URL to
    our `videos` views:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将这些`urls`注册到项目`urls`文件中。编辑`decentralized_videos/decentralized_videos/urls.py`并添加我们的`videos.urls`路径，以便我们的Web应用知道如何将我们的URL路由到我们的`videos`视图：
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Demo
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示
- en: 'It''s time to enjoy the fruits of your labor. Make sure you are inside the `decentralized_videos`
    directory before running the server. Don''t forget to run the private blockchain
    and IPFS daemon first:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是享受劳动成果的时候了。在运行服务器之前，请确保您在`decentralized_videos`目录中。不要忘记先运行私有区块链和IPFS守护程序：
- en: '[PRE82]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then open `http://localhost:8000`. Here, you will be greeted with recent videos,
    as shown in the following screenshot. If you are confused about why I have a thumbnail
    for some videos, you need to go to the video-playing page to generate the thumbnail:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开`http://localhost:8000`。在这里，您将看到最近的视频，如下图所示。如果您对为什么有一些视频的缩略图感到困惑，您需要转到播放视频的页面生成缩略图：
- en: '![](assets/8c447427-ed43-4be1-b6a3-524884e054c8.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c447427-ed43-4be1-b6a3-524884e054c8.png)'
- en: 'Let''s click on one of the videos:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们点击其中一个视频：
- en: '![](assets/9a27e163-7202-4317-9acc-857a99952a2b.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9a27e163-7202-4317-9acc-857a99952a2b.png)'
- en: You can play the video here.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里播放视频。
- en: 'To play HTML5 video on the web, we can use Chrome browser. You can also use
    Firefox browser, but you need to do additional steps to enable playing video on
    browser, by following the steps on this following website: [https://stackoverflow.com/questions/40760864/how-to-play-mp4-video-in-firefox](https://stackoverflow.com/questions/40760864/how-to-play-mp4-video-in-firefox).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Web上播放HTML5视频，我们可以使用Chrome浏览器。您也可以使用Firefox浏览器，但是您需要采取额外的步骤来启用浏览器上的视频播放，方法是按照以下网站上的步骤进行操作：[https://stackoverflow.com/questions/40760864/how-to-play-mp4-video-in-firefox](https://stackoverflow.com/questions/40760864/how-to-play-mp4-video-in-firefox)。
- en: 'You can also like the video with the form. Let''s click on the Channel link
    in the breadcrumb:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用表单喜欢视频。让我们点击面包屑中的“频道”链接：
- en: '![](assets/7bd25a63-5dbb-4734-9ce1-7e0527bfe0bb.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7bd25a63-5dbb-4734-9ce1-7e0527bfe0bb.png)'
- en: 'This is the list of videos from a specific video uploader. Finally, let''s
    go to the uploading video page. Click the Upload link in the navigation menu:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是特定视频上传者的视频列表。最后，让我们转到上传视频页面。点击导航菜单中的“上传”链接：
- en: '![](assets/7cbb792f-3b18-4a53-99b1-1128f9a93019.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7cbb792f-3b18-4a53-99b1-1128f9a93019.png)'
- en: You can upload a video here, as shown in the preceding screenshot.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里上传视频，如上图所示。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意
- en: To make this application perform better in the real world, there are a lot of
    things that need to be done. You need to add testing, you need to test the model,
    the views, the templates, and, finally, you need to carry out solid integration
    tests. You also need to put heavy and long operations (such as calling operations
    on the smart contract, adding and getting files with IPFS) in the background jobs
    using Celery and RabbitMQ or Redis. In addition to this, you need to add some
    JavaScript files in order to notice whether the background jobs have finished
    or not using a pooling mechanism. You could also use the Django channel to do
    the job.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个应用在现实世界中表现更好，有很多事情需要做。您需要添加测试，测试模型、视图、模板，最后，您需要进行完整的集成测试。您还需要使用Celery和RabbitMQ或Redis将繁重和长时间的操作（如在智能合约上调用操作，使用IPFS添加和获取文件）放在后台作业中。除此之外，您还需要添加一些JavaScript文件，以便使用轮询机制通知后台作业是否已经完成。您还可以使用Django通道来完成这项工作。
- en: Instead of accessing methods of the smart contract in the model, perhaps it
    is better to put all information from the blockchain in the database in the background
    task using cron. Then the model can access the database to get necessary information.
    To upload and like a video, we need to send our address and its password every
    time. Perhaps, for convenience, we could offer a way to save the address and the
    password temporarily for the user. We can save this in the session, in cookies,
    or even in a web3 object.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在模型中访问智能合约的方法，也许最好是使用cron在后台任务中将区块链中的所有信息存储在数据库中。然后模型可以访问数据库以获取必要的信息。要上传和喜欢视频，我们需要每次发送我们的地址和密码。也许，为了方便起见，我们可以为用户提供一种临时保存地址和密码的方法。我们可以将这些保存在会话中、cookie中，甚至是web3对象中。
- en: In our toy application, we assume everyone uploads a valid video file. If someone
    uploads an invalid video file, we need to handle that situation. Furthermore,
    if someone uploads an invalid IPFS path of a video, this should also be dealt
    with accordingly. Should we validate on the smart contract (using more gas)? Should
    we validate it in the frontend? There are many corner cases we need to take care
    of. We also need to add pagination. What about searching? We need to crawl the
    events on the blockchain. Should we only care about the video title, or should
    we extract the information from the video file itself? These are the questions
    you need to contemplate if you want to build a decentralized video-sharing application
    in the real world.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的玩具应用中，我们假设每个人都上传了有效的视频文件。如果有人上传了无效的视频文件，我们需要处理这种情况。此外，如果有人上传了无效的视频的IPFS路径，也需要相应处理。我们应该在智能合约中验证（使用更多的gas）吗？还是应该在前端验证？我们需要处理许多边缘情况。我们还需要添加分页。搜索呢？我们需要爬取区块链上的事件。我们只关心视频标题，还是应该从视频文件本身提取信息？这些都是您需要考虑的问题，如果您想在现实世界中构建一个去中心化的视频分享应用。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we combined IPFS technology and smart contract technology.
    We built a decentralized video-sharing application. First, we wrote a smart contract
    to store video information and the video titles. We also built in the crypto economics
    by making the act of liking videos require coins from the ERC20 token. In addition
    to this, we learned that even storing video information such as a bytes string
    of the IPFS path and the title requires more gas than usual. After writing a smart
    contract, we built a web application using the Django library. We created a project,
    followed by building an application inside this project. Moving forward, we built
    views, models, templates, and URLs. In the models, we stored the video file in
    IPFS and then stored the IPFS path on the blockchain. We made the templates more
    beautiful using the Bulma CSS framework, and then launched the application by
    executing the functionalities of this web application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们结合了IPFS技术和智能合约技术。我们构建了一个去中心化的视频分享应用程序。首先，我们编写了一个智能合约来存储视频信息和视频标题。我们还通过让点赞视频需要使用ERC20代币来内置加密经济学。除此之外，我们还了解到，即使存储视频信息，比如IPFS路径和标题的字节字符串，也需要比平常更多的gas。在编写智能合约之后，我们使用Django库构建了一个Web应用程序。我们创建了一个项目，然后在这个项目内构建了一个应用程序。接着，我们构建了视图、模型、模板和URL。在模型中，我们将视频文件存储在IPFS上，然后将IPFS路径存储在区块链上。我们使用Bulma
    CSS框架使模板更加美观，然后通过执行这个Web应用程序的功能来启动应用程序。
- en: In this book, we have learned what blockchain is and what a smart contract is.
    We used the Vyper programming language to build many interesting smart contracts,
    such as a voting smart contract, a Twitter-like application smart contract, an
    ERC20 token smart contract, and a video-sharing smart contract. We also utilized
    the web3 library to interact with these smart contracts and built decentralized
    applications. On top of that, we built our GUI frontend for our decentralized
    applications using the PySide2 library and the web frontend for our decentralized
    applications using the Django library. One of the GUI frontend applications is
    a cryptocurrency wallet that can handle ether and ERC20 tokens. Finally, we also
    learned about a complementary decentralized technology, IPFS, that can be the
    storage solution for blockchain applications.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们学习了区块链是什么，以及智能合约是什么。我们使用Vyper编程语言构建了许多有趣的智能合约，比如投票智能合约、类似Twitter的应用程序智能合约、ERC20代币智能合约和视频分享智能合约。我们还利用web3库与这些智能合约进行交互，并构建了去中心化应用程序。除此之外，我们使用PySide2库构建了我们的GUI前端，用于处理以太和ERC20代币的加密货币钱包应用程序。最后，我们还学习了一种补充的去中心化技术IPFS，它可以成为区块链应用程序的存储解决方案。
- en: After mastering all of these skills, you are equipped to build many interesting
    applications on top of the Ethereum platform. But Ethereum is still a nascent
    technology. Technologies such as sharding, Proof of Stake, and privacy are still
    being researched and developed in Ethereum. These new technologies may affect
    the technologies that you have learned, such as Vyper and web3\. So you need to
    be aware of new updates on the Ethereum platform.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了所有这些技能之后，您就有能力在以太坊平台上构建许多有趣的应用程序。但以太坊仍然是一项新兴技术。诸如分片、权益证明和隐私等技术仍在以太坊中进行研究和开发。这些新技术可能会影响您所学到的技术，比如Vyper和web3。因此，您需要关注以太坊平台的新更新。
- en: Further reading
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We can learn more about upcoming changes on Ethereum on the following website: 
    [https://github.com/ethereum/eth2.0-specs](https://github.com/ethereum/eth2.0-specs).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在以下网站了解有关以太坊的最新变化：[https://github.com/ethereum/eth2.0-specs](https://github.com/ethereum/eth2.0-specs)。
