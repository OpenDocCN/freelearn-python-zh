- en: Building an API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API
- en: Now that Mail Ape can send emails to our subscribers, let's make it easier for
    our users to integrate with Mail Ape using an API. In this chapter, we will build
    a RESTful JSON API that will let users create mailing lists and add subscribers
    to a mailing list. To simplify creating our API, we will use the **Django REST
    framework** (**DRF**). Finally, we'll access our API on the command line using
    curl.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Mail Ape可以向我们的订阅者发送电子邮件了，让我们让用户更容易地使用API与Mail Ape集成。在本章中，我们将构建一个RESTful JSON
    API，让用户可以创建邮件列表并将订阅者添加到邮件列表中。为了简化创建我们的API，我们将使用Django REST框架（DRF）。最后，我们将使用curl在命令行上访问我们的API。
- en: 'In this chapter, we will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Summarize the core concepts of DRF
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结DRF的核心概念
- en: Create `Serializer`s that define how to parse and serialize `MailingList` and
    `Subscriber` models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Serializer`，定义如何解析和序列化`MailingList`和`Subscriber`模型
- en: Create a permission class to restrict API to users who are`MailingList` owners
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建权限类以限制API对`MailingList`所有者的用户
- en: Use the Django REST framework's class-based views to create the views for our
    API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django REST框架的基于类的视图来创建我们API的视图
- en: Access our API over HTTP using curl
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curl通过HTTP访问我们的API
- en: Test our API in a unit test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中测试我们的API
- en: Let's start this chapter with DRF.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从DRF开始这一章。
- en: Starting with the Django REST framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Django REST框架开始
- en: We'll start by installing DRF and then reviewing its configuration. As we review
    the DRF configuration, we'll learn about the features and concepts that make it
    useful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装DRF，然后审查其配置。在审查DRF配置时，我们将了解使其有用的功能和概念。
- en: Installing the Django REST framework
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Django REST框架
- en: 'Let''s start by adding DRF to our `requirements.txt` file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将DRF添加到我们的`requirements.txt`文件中：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we can install it using `pip`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`pip`进行安装：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the library installed, let''s add DRF to our `INSTALLED_APPS`
    list in the `django/mailinglist/settings.py` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了库，让我们在`django/mailinglist/settings.py`文件中的`INSTALLED_APPS`列表中添加DRF：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Configuring the Django REST Framework
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Django REST框架
- en: DRF is highly configurable through its view classes. However, we can avoid repeating
    the same common settings across all our DRF views using DRF's settings in our
    `settings.py` file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: DRF通过其视图类高度可配置。但是，我们可以使用`settings.py`文件中的DRF设置来避免在所有DRF视图中重复相同的常见设置。
- en: All of DRF's features project out from how DRF handles views. DRF provides a
    rich collection of views that extend `APIView` (which in turn extends Django's
    `View` class). Let's look at the APIView's life cycle and the related settings.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DRF的所有功能都源自DRF处理视图的方式。DRF提供了丰富的视图集合，扩展了`APIView`（它又扩展了Django的`View`类）。让我们看看APIView的生命周期和相关设置。
- en: 'A DRF view''s life cycle perform the following actions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: DRF视图的生命周期执行以下操作：
- en: '**Wrap Django''s request object in the DRF request object**: DRF has a specialized
    `Request` class that wraps Django''s `Request` class, as will be discussed in
    the following sections.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在DRF请求对象中包装Django的请求对象**：DRF有一个专门的`Request`类，它包装了Django的`Request`类，将在下面的部分中讨论。'
- en: '**Perform content negotiation**: Find the request parser and response renderer.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行内容协商**：查找请求解析器和响应渲染器。'
- en: '**Perform authentication**: Check the credentials associated with the request.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行身份验证**：检查与请求相关联的凭据。'
- en: '**Check permissions**: Checks whether the user associated with the request
    can access this view.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查权限**：检查与请求相关联的用户是否可以访问此视图。'
- en: '**Check throttles**: Checks whether there haven''t been too many requests recently
    by this user.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查节流**：检查最近是否有太多请求由此用户发出。'
- en: '**Execute the view handler**: Performs the action associated with the view
    (for example, creating the resource, querying the database, and so on).'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行视图处理程序**：执行与视图相关的操作（例如创建资源、查询数据库等）。'
- en: '**Render the response**: Renders the response to the correct content type.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**渲染响应**：将响应呈现为正确的内容类型。'
- en: DRF's custom `Request` class is much like Django's `Request` class, except that
    it can be configured with a parser. A DRF view finds the correct parser for the
    request based on the view's settings and the content type of the request during
    content negotiation. The parsed contents are available as `request.data` just
    like a Django request with a `POST` form submission.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: DRF的自定义`Request`类与Django的`Request`类非常相似，只是它可以配置为解析器。DRF视图根据视图的设置和请求的内容类型在内容协商期间找到正确的解析器。解析后的内容可以像Django请求与`POST`表单提交一样作为`request.data`可用。
- en: DRF views also use a specialized `Response` class that uses a render instead
    of a Django template. The renderer is selected during the content negotiation
    step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: DRF视图还使用一个专门的`Response`类，它使用渲染而不是Django模板。渲染器是在内容协商步骤中选择的。
- en: 'Most of the preceding steps are performed using configurable classes. DRF is
    configurable by creating a dictionary in our project''s `settings.py` under the
    name `REST_FRAMEWORK`. Let''s review some of the most important settings:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分前面的步骤都是使用可配置的类来执行的。通过在项目的`settings.py`中创建一个名为`REST_FRAMEWORK`的字典，可以配置DRF。让我们回顾一些最重要的设置：
- en: '`DEFAULT_PARSER_CLASSES`: This supports JSON, forms and multipart forms by
    default. Other parsers (for example, YAML and MessageBuffer) are available as
    third-party community packages.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_PARSER_CLASSES`：默认支持JSON、表单和多部分表单。其他解析器（例如YAML和MessageBuffer）可作为第三方社区包提供。'
- en: '`DEFAULT_AUTHENTICATION_CLASSES`: This supports session-based authentication
    and HTTP basic authentication by default. Session authentication can make using
    your API in your app''s frontend easier. DRF ships with a token authentication
    class. OAuth (1 and 2) support is available through third-party community packages.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_AUTHENTICATION_CLASSES`：默认支持基于会话的身份验证和HTTP基本身份验证。会话身份验证可以使在应用的前端使用API更容易。DRF附带了一个令牌身份验证类。OAuth（1和2）支持可通过第三方社区包获得。'
- en: '`DEFAULT_PERMISSION_CLASSES`: This defaults to allowing any user to any action
    (including update and delete operations). DRF ships with a collection of stricter
    permissions listed in the documentation ([https://www.django-rest-framework.org/api-guide/permissions/#api-reference](https://www.django-rest-framework.org/api-guide/permissions/#api-reference)).
    We''ll also take a look at how to create a custom permission class later in this
    chapter.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_PERMISSION_CLASSES`: 默认情况下允许任何用户执行任何操作（包括更新和删除操作）。DRF附带了一组更严格的权限，列在文档中（[https://www.django-rest-framework.org/api-guide/permissions/#api-reference](https://www.django-rest-framework.org/api-guide/permissions/#api-reference)）。我们稍后还将看一下如何在本章后面创建自定义权限类。'
- en: '`DEFAULT_THROTTLE_CLASSES`/`DEFAULT_THROTTLE_RATES`: This is empty (unthrottled)
    by default. DRF offers a simple throttling scheme, letting us set different rates
    for anonymous requests and user requests out of the box.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_THROTTLE_CLASSES`/`DEFAULT_THROTTLE_RATES`: 默认情况下为空（未限制）。DRF提供了一个简单的节流方案，让我们可以在匿名请求和用户请求之间设置不同的速率。'
- en: '`DEFAULT_RENDERER_CLASSES`: This defaults to JSON and a *browsable* template
    renderer. The browsable template renderer makes a simple UI for view and testing
    your views, suitable to development.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFAULT_RENDERER_CLASSES`: 这默认为JSON和*browsable*模板渲染器。可浏览的模板渲染器为视图和测试视图提供了一个简单的用户界面，适合开发。'
- en: 'We will configure our DRF to be a bit stricter, even in development. Let''s
    update `django/config/settings.py` with the following new setting `dict`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置我们的DRF更加严格，即使在开发中也是如此。让我们在`django/config/settings.py`中更新以下新设置`dict`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This configuration restricts the API to authenticated users by default and sets
    a throttle on their requests. Authenticated users can make 60 requests per minute
    before being throttled. Unauthenticated users can make 30 requests per minute.
    DRF accepts throttle periods of `second`, `minute`, `hour`, or `day`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置默认将API限制为经过身份验证的用户，并对他们的请求设置了节流。经过身份验证的用户在被节流之前可以每分钟发出60个请求。未经身份验证的用户可以每分钟发出30个请求。DRF接受`second`、`minute`、`hour`或`day`的节流周期。
- en: Next, let's take a look at DRF `Serializer`s.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下DRF的`Serializer`。
- en: Creating the Django REST Framework Serializers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Django REST Framework序列化器
- en: When a DRF parser parses a request's body, the parser basically returns a Python
    dictionary. However, before we can perform any operation on that data, we will
    need to confirm that the data is valid. In our previous Django views, we'd use
    a Django form. In DRF, we use a `Serializer` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当DRF解析器解析请求的主体时，解析器基本上会返回一个Python字典。但是，在我们可以对数据执行任何操作之前，我们需要确认数据是否有效。在以前的Django视图中，我们会使用Django表单。在DRF中，我们使用`Serializer`类。
- en: DRF `Serializer` classes are very similar to Django form classes. Both are involved
    in receiving validation data and preparing models for output. However, a `Serializer` class
    doesn't know how to render its data, unlike a Django form that does. Remember
    that in a DRF view, the renderers are responsible for rendering the result into
    JSON or whatever format was negotiated by the request.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DRF的`Serializer`类与Django表单类非常相似。两者都涉及接收验证数据和准备模型输出。但是，`Serializer`类不知道如何呈现其数据，而Django表单知道。请记住，在DRF视图中，渲染器负责将结果呈现为JSON或请求协商的任何其他格式。
- en: Much like a Django form, a `Serializer` can be created to work on an arbitrary
    data or be based on a Django Model. Also, `Serializer` is composed of a collection
    of fields that we can use to control serialization. When a `Serializer` is related
    to a model, the Django REST framework knows which serializer `Field` to use for
    which model `Field`, similar to how `ModelForm`s work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Django表单一样，`Serializer`可以被创建来处理任意数据或基于Django模型。此外，`Serializer`由一组字段组成，我们可以用来控制序列化。当`Serializer`与模型相关联时，Django
    REST框架知道为哪个模型`Field`使用哪个序列化器`Field`，类似于`ModelForm`的工作方式。
- en: 'Let''s create a `Serializer` for our `MailingList` model in `django/mailinglist/serializers.py`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/serializers.py`中为我们的`MailingList`模型创建一个`Serializer`：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This seems very similar to how we wrote `ModelForm`s; let''s take a closer
    look:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎与我们编写`ModelForm`的方式非常相似；让我们仔细看一下：
- en: '`HyperlinkedModelSerializer`: This is the `Serializer` class that shows a hyperlink
    to any related model, so when it shows the related `Subscriber` model instances of
    a `MailingList`, it will show a link (URL) to that instance''s detail view.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HyperlinkedModelSerializer`: 这是显示到任何相关模型的超链接的`Serializer`类，因此当它显示`MailingList`的相关`Subscriber`模型实例时，它将显示一个链接（URL）到该实例的详细视图。'
- en: '`owner = serializers.PrimaryKeyRelatedField(...)`: This changes the field for
    serializing the model''s `owner` field. The `PrimaryKeyRelatedField` returns the
    related object''s primary key. This is useful when the related model doesn''t
    have a serializer or a related API view (like the user model in Mail Ape).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner = serializers.PrimaryKeyRelatedField(...)`: 这改变了序列化模型的`owner`字段。`PrimaryKeyRelatedField`返回相关对象的主键。当相关模型没有序列化器或相关API视图时（比如Mail
    Ape中的用户模型），这是有用的。'
- en: '`model = MailingList`: Tells our `Serializer` which mode it''s serializing'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model = MailingList`: 告诉我们的`Serializer`它正在序列化哪个模型'
- en: '`fields = (''url'', ''id'', ...)`: This lists the model''s fields to serialize.
    The `HyperlinkedModelSerializer` includes an extra field `url`, which is the URL
    to the serialized model''s detail view. Much like with a Django `ModelForm`, a
    `ModelSerializer` class (such as `HyperlinkedModelSerializer`) has a set of default
    serializer fields for each model field. In our case, we''ve decided to override
    how `owner` is represented (refer to the preceding point about the `owner` attribute).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields = (''url'', ''id'', ...)`: 这列出了要序列化的模型字段。`HyperlinkedModelSerializer`包括一个额外的字段`url`，它是序列化模型详细视图的URL。就像Django的`ModelForm`一样，`ModelSerializer`类（例如`HyperlinkedModelSerializer`）为每个模型字段有一组默认的序列化器字段。在我们的情况下，我们决定覆盖`owner`的表示方式（参考关于`owner`属性的前一点）。'
- en: '`read_only_fields = (''subscriber_set'', )`: This concisely lists which fields
    may not be modified. In our case, this prevents users from tampering with the
    mailing list a `Subscriber` is in.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_only_fields = (''subscriber_set'', )`: 这简明地列出了哪些字段不可修改。在我们的情况下，这可以防止用户篡改`Subscriber`所在的邮件列表。'
- en: '`extra_kwargs`: This dictionary lets us provide extra arguments to each field''s
    constructor without overriding the entire field. This is usually done to provide
    a `view_name` argument which is needed to look up the URL to a view.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extra_kwargs`: 这个字典让我们为每个字段的构造函数提供额外的参数，而不覆盖整个字段。通常是为了提供`view_name`参数，这是查找视图的URL所需的。'
- en: '`''url'': {''view_name'': ''...''},`: This provides the name of the `MailingList`
    API detail view.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''url'': {''view_name'': ''...''},: 这提供了`MailingList` API详细视图的名称。'
- en: '`''subscriber_set'': {''view_name'': ''...''},`: This provides the name of
    the `Subscriber` API detail view.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''subscriber_set'': {''view_name'': ''...''},: 这提供了`Subscriber` API详细视图的名称。'
- en: There are actually two ways of marking a `Serializer`'s field read only. One
    way is using the `read_only_fields` attribute as in the preceding code sample.
    Another is to pass `read_only=True` as an argument to a `Field` class's constructor
    (for example, `email = serializers.EmailField(max_length=240, read_only=True)`).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种标记`Serializer`字段为只读的方法。一种是使用`read_only_fields`属性，就像前面的代码示例中那样。另一种是将`read_only=True`作为`Field`类构造函数的参数传递（例如，`email
    = serializers.EmailField(max_length=240, read_only=True)`）。
- en: 'Next, we''ll create two serializers for our `Subscriber` model. Our two subscribers
    are going to have one difference: whether `Subscriber.email` is editable. We will
    need to let users write to `Subscriber.email` when they''re creating `Subscriber`.
    However, we don''t want them to be able to change the email after they''ve created
    the user.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的`Subscriber`模型创建两个`Serializer`。我们的两个订阅者将有一个区别：`Subscriber.email`是否可编辑。当他们创建`Subscriber`时，我们需要让用户写入`Subscriber.email`。但是，我们不希望他们在创建用户后能够更改电子邮件。
- en: 'First, let''s create a `Serializer` for the `Subscription` model in `django/mailinglist/serialiers.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`django/mailinglist/serialiers.py`中为`Subscription`模型创建一个`Serializer`：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `SubscriberSerializer` is just like our `MailingListSerializer`. We use
    many of the same elements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubscriberSerializer`与我们的`MailingListSerializer`类似。我们使用了许多相同的元素：'
- en: Subclassing `serializers.HyperlinkedModelSerializer`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化`serializers.HyperlinkedModelSerializer`
- en: Declaring the related model using an inner `Meta` class's `model` attribute
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部`Meta`类的`model`属性声明相关模型
- en: Declaring the related model's fields using an inner `Meta` class's `fields`
    attribute
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部`Meta`类的`fields`属性声明相关模型的字段
- en: Giving the related model's detail view's name using the `extra_kwargs` dictionary
    and the `view_name` key.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`extra_kwargs`字典和`view_name`键提供相关模型的详细视图名称。
- en: 'For our next `Serializer` class, we''ll create one just like `SubscriberSerializer`
    but make the `email` field read only; let''s add it to `django/mailinglist/serialiers.py`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个`Serializer`类，我们将创建一个与`SubscriberSerializer`类似的类，但将`email`字段设置为只读；让我们将其添加到`django/mailinglist/serialiers.py`中：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `Serializer` lets us update whether a `Subscriber` is `confirmed` or not,
    but it won't let the `Subscriber`'s `email` field change.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Serializer`让我们更新`Subscriber`是否`confirmed`，但不会让`Subscriber`的`email`字段发生变化。
- en: Now that we've create a few `Serializers`, we can see how similar they are to
    Django's built-in `ModelForm`s. Next, let's create a `Permission` class to prevent
    a user from accessing each other's `MailingList` and `Subscriber` model instances.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一些`Serializer`，我们可以看到它们与Django内置的`ModelForm`有多么相似。接下来，让我们创建一个`Permission`类，以防止用户访问彼此的`MailingList`和`Subscriber`模型实例。
- en: API permissions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API权限
- en: In this section, we'll create a permission class that the Django REST framework
    will use to check whether a user may perform an operation on a `MailingList` or
    `Subscriber`. This will perform a very similar role to the `UserCanUseMailingList`
    mixin we created in [Chapter 10](4c521041-4786-4a7f-bcaf-f44e3c5abedc.xhtml),
    Starting Mail Ape.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个权限类，Django REST框架将使用它来检查用户是否可以对`MailingList`或`Subscriber`执行操作。这将执行与我们在[第10章](4c521041-4786-4a7f-bcaf-f44e3c5abedc.xhtml)中创建的`UserCanUseMailingList`混合类非常相似的角色，开始Mail
    Ape。
- en: 'Let''s create our `CanUseMailingList` class in `django/mailinglist/permissions.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/mailinglist/permissions.py`中创建我们的`CanUseMailingList`类：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s take a closer look at some of the new elements introduced in our `CanUseMailingList` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下我们的`CanUseMailingList`类中引入的一些新元素：
- en: '`BasePermission`: Provides the basic contract of a permission class, implementing
    the `has_permission()` and `has_object_permission()` methods to always return
    `True`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BasePermission`: 提供权限类的基本约定，实现`has_permission()`和`has_object_permission()`方法，始终返回`True`'
- en: '`message`: This is the message that the `403` response body'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`: 这是`403`响应体的消息'
- en: '`def has_object_permission(...)`: Checks whether the request''s user is the
    owner of the related `MailingList`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def has_object_permission(...)`: 检查请求的用户是否是相关`MailingList`的所有者'
- en: The `CanUseMailingList` class doesn't override `BasePermission.has_permission(self,
    request, view)` because the permissions in our system are both at the object level
    rather than the view or model level.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanUseMailingList`类不覆盖`BasePermission.has_permission(self, request, view)`，因为我们系统中的权限都是在对象级别而不是视图或模型级别。'
- en: If you need a more dynamic permission system, you may want to use Django's built-in
    permission system ([https://docs.djangoproject.com/en/2.0/topics/auth/default/#permissions-and-authorization](https://docs.djangoproject.com/en/2.0/topics/auth/default/#permissions-and-authorization))
    or Django Guardian ([https://github.com/django-guardian/django-guardian](https://github.com/django-guardian/django-guardian)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更动态的权限系统，您可能希望使用Django的内置权限系统（[https://docs.djangoproject.com/en/2.0/topics/auth/default/#permissions-and-authorization](https://docs.djangoproject.com/en/2.0/topics/auth/default/#permissions-and-authorization)）或Django
    Guardian（[https://github.com/django-guardian/django-guardian](https://github.com/django-guardian/django-guardian)）。
- en: Now that we have our `Serializer`s and permission class, we will write our API
    views.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Serializer`和权限类，我们将编写我们的API视图。
- en: Creating our API views
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的API视图
- en: In this section, we'll create the actual views that define Mail Ape's RESTful
    API. The Django REST framework offers a collection of class-based views that are
    similar to Django's suite of class-based views. One of the main differences between
    the DRF generic views and the Django generic views is how they combine multiple
    operations in a single view class. For example, DRF offers the `ListCreateAPIView`
    class but Django only offers a `ListView` class and a `CreateView` class. DRF
    offers a `ListCreateAPIView` class because a resource at `/api/v1/mailinglists`
    would be expected to provide both a list of `MailingList` model instances and
    a creation endpoint.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建定义Mail Ape的RESTful API的实际视图。Django REST框架提供了一系列基于类的视图，这些视图类似于Django的一系列基于类的视图。DRF通用视图与Django通用视图的主要区别之一是它们如何将多个操作组合在一个单一的视图类中。例如，DRF提供了`ListCreateAPIView`类，但Django只提供了`ListView`类和`CreateView`类。DRF提供了`ListCreateAPIView`类，因为在`/api/v1/mailinglists`上的资源预期将提供`MailingList`模型实例的列表和创建端点。
- en: Django REST Framework also offers a suite of function decorators ([http://www.django-rest-framework.org/api-guide/views/#function-based-views](http://www.django-rest-framework.org/api-guide/views/#function-based-views))
    so that you use function-based views too.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架还提供了一套函数装饰器（[http://www.django-rest-framework.org/api-guide/views/#function-based-views](http://www.django-rest-framework.org/api-guide/views/#function-based-views)），这样你也可以使用基于函数的视图。
- en: Let's learn more about DRF views by creating our API, starting with the `MailingList`
    API views.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建我们的API来学习更多关于DRF视图的知识，首先从`MailingList` API视图开始。
- en: Creating MailingList API views
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MailingList API视图
- en: 'Mail Ape will provide an API to create, read, update, and delete `MailingList`s.
    To support these operations, we will create the following two views:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Mail Ape将提供一个API来创建、读取、更新和删除`MailingList`。为了支持这些操作，我们将创建以下两个视图：
- en: A `MailingListCreateListView` that extends `ListCreateAPIView`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展了`ListCreateAPIView`的`MailingListCreateListView`
- en: A `MailingListRetrieveUpdateDestroyView` that extends `RetrieveUpdateDestroyAPIView`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展了`RetrieveUpdateDestroyAPIView`的`MailingListRetrieveUpdateDestroyView`
- en: Listing MailingLists by API
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过API列出邮件列表
- en: 'To support getting a list of a user''s `MailingList` model instances and creating
    new `MailingList` model instances, we will create the `MailingListCreateListView` class
    in `django/mailinglist/views.py`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持获取用户的`MailingList`模型实例列表和创建新的`MailingList`模型实例，我们将在`django/mailinglist/views.py`中创建`MailingListCreateListView`类：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s review our `MailingListCreateListView` class in detail:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看我们的`MailingListCreateListView`类：
- en: '`ListCreateAPIView`: This is the DRF generic view we extend. It responds to
    `GET` requests with the serialized contents returned by the `get_queryset()` method.
    When it receives a `POST` request, it will create and return a `MailingList` model
    instance.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListCreateAPIView`：这是我们扩展的DRF通用视图。它通过`get_queryset()`方法返回的序列化内容响应`GET`请求。当它收到`POST`请求时，它将创建并返回一个`MailingList`模型实例。'
- en: '`permission_classes`: This is a collection of permission classes that will
    be called in an order. If `IsAuthenticated` fails, then `IsOwnerPermission` won''t
    be called.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permission_classes`：这是一组权限类，按顺序调用。如果`IsAuthenticated`失败，那么`IsOwnerPermission`将不会被调用。'
- en: '`serializer_class = MailingListSerializer`: This is the serializer this view
    uses.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serializer_class = MailingListSerializer`：这是该视图使用的序列化器。'
- en: '`def get_queryset(self)`: This is used to get a `QuerySet` of models to serialize
    and return.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_queryset(self)`: 用于获取要序列化和返回的模型的`QuerySet`。'
- en: '`def get_serializer(...)`: This is used to get the serializer instance. In
    our case, we''re overriding the owner (if any) that we received as input from
    the request with the currently logged in user. By doing so, we ensure that a user
    can''t create a mailing list owned by another. This is very similar to how we
    might override `get_initial()` in a Django form view (for example, refer to the `CreateMessageView` class
    from [Chapter 10](4c521041-4786-4a7f-bcaf-f44e3c5abedc.xhtml), *Starting Mail
    Ape*).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def get_serializer(...)`: 用于获取序列化器实例。在我们的情况下，我们正在用当前登录的用户覆盖（如果有的话）从请求中收到的owner。通过这样做，我们确保用户不能创建属于其他用户的邮件列表。这与我们可能如何在Django表单视图中覆盖`get_initial()`非常相似（例如，参考[第10章](4c521041-4786-4a7f-bcaf-f44e3c5abedc.xhtml)中的`CreateMessageView`类，*开始Mail
    Ape*）。'
- en: 'Now that we have our view, let''s add it to our URLConf in `django/mailinglist/urls.py`
    with the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了我们的视图，让我们在`django/mailinglist/urls.py`中添加以下代码：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can create and list `MailingList` model instances by sending a request
    to `/mailinglist/api/v1/mailing-list`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过向`/mailinglist/api/v1/mailing-list`发送请求来创建和列出`MailingList`模型实例。
- en: Editing a mailing list via an API
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过API编辑邮件列表
- en: 'Next, let''s add a view to view, update, and delete a single `MailingList` model
    instance by adding a new view to `django/mailinglist/views.py`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过在`django/mailinglist/views.py`中添加一个新视图来查看、更新和删除单个`MailingList`模型实例。
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MailingListRetrieveUpdateDestroyView` looks very similar to our previous view
    but extends the `RetrieveUpdateDestroyAPIView` class. Like Django''s built-in
    `DetailView`, `RetrieveUpdateDestroyAPIView` expects that it will receive the
    `pk` of the `MailingList` model instance it is to operate on in the request''s
    path. `RetrieveUpdateDestroyAPIView` knows how to handle a variety of HTTP methods:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailingListRetrieveUpdateDestroyView`看起来与我们之前的视图非常相似，但是扩展了`RetrieveUpdateDestroyAPIView`类。像Django内置的`DetailView`一样，`RetrieveUpdateDestroyAPIView`期望它将在请求路径中接收到`MailingList`模型实例的`pk`。`RetrieveUpdateDestroyAPIView`知道如何处理各种HTTP方法：'
- en: On a `GET` request, it retrieves the model identified by the `pk` argument
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GET`请求中，它检索由`pk`参数标识的模型
- en: On a `PUT` request, it overwrites all the fields of the model identified by
    the `pk` with the fields received in the argument
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PUT`请求中，它用收到的参数覆盖`pk`标识的模型的所有字段
- en: On a `PATCH` request, it overwrites only the fields received in the request
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PATCH`请求中，仅覆盖请求中收到的字段
- en: On a `DELETE` request, it deletes the model identified by the `pk`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`DELETE`请求中，它删除由`pk`标识的模型
- en: Any updates (whether by `PUT` or by `PATCH`) are validated by the `MailingListSerializer`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 任何更新（无论是通过`PUT`还是`PATCH`）都由`MailingListSerializer`进行验证。
- en: Another difference is that we define a `queryset` attribute for the view (`MailingList.objects.all()`)
    instead of a `get_queryset()` method. We don't need to restrict our `QuerySet`
    dynamically because the `CanUseMailingList` class will protect us from users editing/viewing
    `MailingLists` they don't have permission to access.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，我们为视图定义了一个`queryset`属性（`MailingList.objects.all()`），而不是一个`get_queryset()`方法。我们不需要动态限制我们的`QuerySet`，因为`CanUseMailingList`类将保护我们免受用户编辑/查看他们没有权限访问的`MailingLists`。
- en: 'Just like before, we now need to connect our view to our app''s URLConf in
    `django/mailinglist/urls.py` with the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，现在我们需要将我们的视图连接到我们应用的URLConf中的`django/mailinglist/urls.py`，使用以下代码：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we parse the `<uuid:pk>` argument out of the request's path just like
    we do with some of Django's regular views that operate on a single model instance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从请求的路径中解析出`<uuid:pk>`参数，就像我们在一些Django的常规视图中对单个模型实例进行操作一样。
- en: Now that we have our `MailingList` API, let's allow our users to manage `Subscriber`s
    by API as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`MailingList` API，让我们也允许我们的用户通过API管理`Subscriber`。
- en: Creating a Subscriber API
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建订阅者API
- en: 'In this section, we''ll create an API to manage `Subscriber` model instances.
    This API will be powered by two views:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个API来管理`Subscriber`模型实例。这个API将由两个视图支持：
- en: '`SubscriberListCreateView` to list and create `Subscriber` model instances'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberListCreateView`用于列出和创建`Subscriber`模型实例'
- en: '`SubscriberRetrieveUpdateDestroyView` to retrieve, update, and delete a `Subscriber`
    model instance'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberRetrieveUpdateDestroyView`用于检索、更新和删除`Subscriber`模型实例'
- en: Listing and Creating Subscribers API
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出和创建订阅者API
- en: '`Subscriber` model instances have an interesting difference from `MailingList` model
    instances in that `Subscriber` model instances are not directly related to a user.
    To get a list of `Subscriber` model instances, we need to know which `MailingList` model
    instance we should query. `Subscriber` model instance creation faces the same
    question, so both these operations will have to receive a related `MailingList`''s
    `pk` to execute.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscriber`模型实例与`MailingList`模型实例有一个有趣的区别，即`Subscriber`模型实例与用户没有直接关联。要获取`Subscriber`模型实例的列表，我们需要知道应该查询哪个`MailingList`模型实例。`Subscriber`模型实例的创建面临同样的问题，因此这两个操作都必须接收相关的`MailingList`的`pk`来执行。'
- en: 'Let''s start with our by creating our `SubscriberListCreateView` in `django/mailinglist/views.py`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`django/mailinglist/views.py`中创建我们的`SubscriberListCreateView`开始。
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our `SubscriberListCreateView` class has much in common with our `MailingListCreateListView` class,
    including the same base class and `permission_classes` attribute. Let''s take
    a closer look at some of the differences:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SubscriberListCreateView`类与我们的`MailingListCreateListView`类有很多共同之处，包括相同的基类和`permission_classes`属性。让我们更仔细地看看一些区别：
- en: '`serializer_class`: Uses a `SubscriberSerializer`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serializer_class`: 使用`SubscriberSerializer`。'
- en: '`get_queryset()`: Checks whether the related `MailingList` model instance identified
    in the URL exists before returning a `QuerySet` of all the related `Subscriber` model
    instances.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_queryset()`: 在返回所有相关的`Subscriber`模型实例的`QuerySet`之前，检查URL中标识的相关`MailingList`模型实例是否存在。'
- en: '`get_serializer()`: Ensures the new `Subscriber` is associated with the `MailingList`
    in the URL. We use the `reverse()` function to identify the associated `MailingList` model
    instance because the `SubscriberSerializer` class is inherits from the `HyperlinkedModelSerializer` class. `HyperlinkedModelSerializer`
    wants related models to be identified by a hyperlink or path (not a `pk`).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_serializer()`: 确保新的`Subscriber`与URL中的`MailingList`相关联。我们使用`reverse()`函数来识别相关的`MailingList`模型实例，因为`SubscriberSerializer`类继承自`HyperlinkedModelSerializer`类。`HyperlinkedModelSerializer`希望相关模型通过超链接或路径（而不是`pk`）来识别。'
- en: 'Next, we will add a `path()` object for our `SubscriberListCreateView` class
    to the URLConf in `django/mailinglist/urls.py`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`django/mailinglist/urls.py`的URLConf中为我们的`SubscriberListCreateView`类添加一个`path()`对象：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When adding a `path()` object for our `SubscriberListCreateView` class, we will
    need to ensure that we have a `mailing_list_pk` parameter. This lets `SubscriberListCreateView`
    know which `Subscriber` model instances to operate on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的`SubscriberListCreateView`类添加一个`path()`对象时，我们需要确保有一个`mailing_list_pk`参数。这让`SubscriberListCreateView`知道要操作哪些`Subscriber`模型实例。
- en: Our users are now able to add `Subscriber` s to their `MailingList` via our
    RESTful API. Adding a user to our API will then trigger a confirmation email because
    `Subscriber.save()` will be called by our `SubscriberSerializer`. Our API doesn't
    need to know how to send emails because our *fat model* is the expert on the behavior
    of `Subscriber`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户现在可以通过我们的RESTful API向他们的`MailingList`添加`Subscriber`。向我们的API添加用户将触发确认电子邮件，因为`Subscriber.save()`将由我们的`SubscriberSerializer`调用。我们的API不需要知道如何发送电子邮件，因为我们的*fat
    model*是`Subscriber`行为的专家。
- en: 'However, this API does present a potential bug in Mail Ape. Our current API
    lets us add a `Subscriber` who has been already confirmed. However, our `Subscriber.save()` method
    will send a confirmation email to the email address of all new `Subscriber` model
    instances. This can lead to us spamming the already confirmed `Subscriber`s. To
    fix this bug, let''s update `Subscriber.save` in `django/mailinglist/models.py`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个API在Mail Ape中存在潜在的错误。我们当前的API允许我们添加一个已经确认的`Subscriber`。然而，我们的`Subscriber.save()`方法将向所有新的`Subscriber`模型实例的电子邮件地址发送确认电子邮件。这可能导致我们向已经确认的`Subscriber`发送垃圾邮件。为了解决这个bug，让我们在`django/mailinglist/models.py`中更新`Subscriber.save`：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we're only calling `self.send_confirmation_email()` if we're saving a new
    *and* unconfirmed `Subscriber` model instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有在保存新的*且*未确认的`Subscriber`模型实例时才调用`self.send_confirmation_email()`。
- en: Great! Now, let's create a view to retrieve, update, and delete a `Subscriber` model
    instance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，让我们创建一个视图来检索、更新和删除`Subscriber`模型实例。
- en: Updating subscribers via an API
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过API更新订阅者
- en: Now, that we have created and list API operations for Subscriber model instances,
    we can create an API view for retrieving, updating, and deleting a single `Subscriber` model
    instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为Subscriber模型实例创建了列表API操作，我们可以创建一个API视图来检索、更新和删除单个`Subscriber`模型实例。
- en: 'Let''s add our view to `django/mailinglist/views.py`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的视图添加到`django/mailinglist/views.py`中：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `SubscriberRetrieveUpdateDestroyView` is very similar to our `MailingListRetrieveUpdateDestroyView`
    view. Both inherit from the same `RetrieveUpdateDestroyAPIView` class to provide
    the core behavior in response to HTTP requests and use the same `permission_classes`
    list. `SubscriberRetrieveUpdateDestroyView` however has two differences:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SubscriberRetrieveUpdateDestroyView`与我们的`MailingListRetrieveUpdateDestroyView`视图非常相似。两者都继承自相同的`RetrieveUpdateDestroyAPIView`类，以响应HTTP请求并使用相同的`permission_classes`列表提供核心行为。但是，`SubscriberRetrieveUpdateDestroyView`有两个不同之处：
- en: '`serializer_class = ReadOnlyEmailSubscriberSerializer`: This is a different
    `Serializer`. In the case of updates, we don''t want the user to be able to change
    email addresses.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serializer_class = ReadOnlyEmailSubscriberSerializer`：这是一个不同的`Serializer`。在更新的情况下，我们不希望用户能够更改电子邮件地址。'
- en: '`queryset = Subscriber.objects.all()`: This is a `QuerySet` of all `Subscribers`.
    We don''t need to restrict the `QuerySet` because the `CanUseMailingList` will
    prevent unauthorized access.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryset = Subscriber.objects.all()`：这是所有`Subscribers`的`QuerySet`。我们不需要限制`QuerySet`，因为`CanUseMailingList`将防止未经授权的访问。'
- en: 'Next, let''s make sure that we can route to it by adding it to the `urlpatterns`
    list in `django/mailinglist/urls.py`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们确保我们可以通过将其添加到`django/mailinglist/urls.py`中的`urlpatterns`列表来路由到它：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have our views, let's try interacting with it on the command line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的观点，让我们尝试在命令行上与它进行交互。
- en: Running our API
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的API
- en: 'In this section, we''ll run Mail Ape on the command line and interact with
    our API on the command line using `curl`, a popular command-line tool used for
    interacting with servers. In this section, we will perform the following functions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在命令行上运行Mail Ape，并使用`curl`在命令行上与我们的API进行交互，`curl`是一个用于与服务器交互的流行命令行工具。在本节中，我们将执行以下功能：
- en: Creating a user on the command line
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上创建用户
- en: Creating a mailing list on the command line
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上创建邮件列表
- en: Getting a list of `MailingList` s on the command line
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上获取`MailingList`列表
- en: Creating a `Subscriber` on the command line
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上创建`Subscriber`
- en: Getting a list of `Subscriber` s on the command line
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上获取`Subscriber`列表
- en: 'Let''s start by creating our user using the Django `manage.py shell` command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用Django `manage.py shell`命令创建我们的用户：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you've already registered a user using the web interface, you can use that
    user. Also, never use `secret` as your password in production.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用Web界面注册了用户，可以使用该用户。此外，在生产中永远不要使用`secret`作为您的密码。
- en: 'Now that we have a user who we can use on the command line, let''s start our
    local Django server:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以在命令行上使用的用户，让我们启动本地Django服务器：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that our server is running, we can open a different shell and get a list
    of `MailingList` s for our user:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务器正在运行，我们可以打开另一个shell并获取我们用户的`MailingList`列表：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s take a closer look at our command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看我们的命令：
- en: '`curl`: This is the tool we''re using.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl`：这是我们正在使用的工具。'
- en: '`"http://... api/v1/mailing-list"`: This is the URL we''re sending our request
    to.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"http://... api/v1/mailing-list"`：这是我们发送请求的URL。'
- en: '`-u ''user:secret''`: This is the basic authentication credentials. `curl`
    takes care of encoding these correctly for us.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u ''user:secret''`：这是基本的身份验证凭据。`curl`会正确地对这些进行编码。'
- en: '`[]`: This is an empty JSON list returned by the server. In our case, `user`
    doesn''t have any `MailingList`s yet.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]`：这是服务器返回的空JSON列表。在我们的情况下，`user`还没有任何`MailingList`。'
- en: We get a JSON response because the Django REST framework is configured to use
    JSON rendering by default.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个JSON响应，因为Django REST框架默认配置为使用JSON渲染。
- en: 'To create a `MailingList` for our user, we will need to send a `POST` request
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的用户创建一个`MailingList`，我们需要发送这样的`POST`请求：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is a much longer command with a proportionately longer result. Let''s
    take a look at each new argument:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更长的命令，结果也更长。让我们来看看每个新参数：
- en: '`-H ''Content-Type: application/json; charset=utf-8'' \`: This adds a new HTTP
    `Content-Type` header to tell the server to parse the body as JSON.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H ''Content-Type: application/json; charset=utf-8'' \`：这添加了一个新的HTTP `Content-Type`头，告诉服务器将正文解析为JSON。'
- en: '`-d $''{ ... }''`: This specifies the body of the request. In our case, we''re
    sending a JSON object with the name of the new mailing list.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d $''{ ... }''`：这指定了请求的正文。在我们的情况下，我们正在发送一个JSON对象，其中包含新邮件列表的名称。'
- en: '`"url":"http://...cd983e25-c6c8-48fa-9afa-1fd5627de9f1"`: This is the URL for
    the full details of the new `MailingLIst`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"url":"http://...cd983e25-c6c8-48fa-9afa-1fd5627de9f1"`：这是新`MailingLIst`的完整详细信息的URL。'
- en: '`"name":"New List"`: This shows the name of the new list that we requested.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"name":"New List"`：这显示了我们请求的新列表的名称。'
- en: '`"owner":2`: This shows the ID of the owner of the list. This matches the ID
    of the user we created earlier and included in this request (using `-u`).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"owner":2`：这显示了列表所有者的ID。这与我们之前创建的用户的ID匹配，并包含在此请求中（使用`-u`）。'
- en: '`"subscriber_set":[]`: This shows that there are no subscribers in this mailing
    list.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"subscriber_set":[]`：这显示了此邮件列表中没有订阅者。'
- en: 'We can now repeat our initial request to list `MailingList`s and check whether
    our new `MailingList` is included:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重复我们最初的请求来列出`MailingList`，并检查我们的新`MailingList`是否包含在内：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Seeing that we can run our server and API in development is great, but we don't
    want to always rely on manual testing. Let's take a look at how to automate testing
    our API next.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们可以在开发中运行我们的服务器和API是很好的，但我们不想总是依赖手动测试。让我们看看如何自动化测试我们的API。
- en: If you want to test creating subscribers, make sure that your Celery broker
    (for example, Redis) is running and that you've got a worker consuming tasks to
    get the full experience.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试创建订阅者，请确保您的Celery代理（例如Redis）正在运行，并且您有一个工作程序来消耗任务以获得完整的体验。
- en: Testing your API
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的API
- en: APIs provide value to our users by letting them automate their interactions
    with our service. Naturally, DRF helps us automate testing our code as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: API通过让用户自动化他们与我们服务的交互来为我们的用户提供价值。当然，DRF也帮助我们自动化测试我们的代码。
- en: 'DRF provides replacements for all the common Django tools we discussed in [Chapter
    8](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml), *Testing Answerly*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: DRF为我们讨论的所有常见Django工具提供了替代品[第8章](20763fd1-7b33-43c7-bb4b-a5b919e84048.xhtml)，*测试Answerly*：
- en: '`APIRequestFactory` for Django''s `RequestFactory` class'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django的`RequestFactory`类的`APIRequestFactory`
- en: '`APIClient` for Django''s `Client` class'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django的`Client`类的`APIClient`
- en: '`APITestCase` for Django''s `TestCase` class'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django的`TestCase`类的`APITestCase`
- en: '`APIRequestFactory` and `APIClient` make it easier to send requests formatted
    for our API. For example, they provide an easy way to set credentials for a request
    that isn''t relying on session-based authentication. Otherwise, the two classes
    serve the same purpose as their default Django equivalents.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIRequestFactory`和`APIClient`使得更容易发送格式化为我们的API的请求。例如，它们提供了一种简单的方法来为不依赖于基于会话的认证的请求设置凭据。否则，这两个类的作用与它们的默认Django等效类相同。'
- en: The `APITestCase` class simply extends Django's `TestCase` class and replaces
    Django's `Client` with `APIClient`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`APITestCase`类简单地扩展了Django的`TestCase`类，并用`APIClient`替换了Django的`Client`。'
- en: 'Let''s take a look at an example that we can add to `django/mailinglist/tests.py`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们可以添加到`django/mailinglist/tests.py`中：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s take a closer look at the new code introduced in our `ListMailingListsWithAPITestCase` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下在我们的`ListMailingListsWithAPITestCase`类中引入的新代码：
- en: '`class ListMailingListsWithAPITestCase(APITestCase)`: This makes `APITestCase`
    our parent class. The `APITestCase` class is basically a `TestCase` class with
    an `APIClient` object instead of the regular Django `Client` object assigned to
    the `client` attribute. We will use this class to test our view.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class ListMailingListsWithAPITestCase(APITestCase)`: 这使得`APITestCase`成为我们的父类。`APITestCase`类基本上是一个`TestCase`类，只是用`APIClient`对象代替了常规的Django
    `Client`对象分配给`client`属性。我们将使用这个类来测试我们的视图。'
- en: '`base64.b64encode(...)`: This does a base64 encoding of our username and password.
    We''ll use this to provide an HTTP basic authentication header. We must use `base64.b64encode()`
    instead of `base64.base64()` because the latter introduces white space to visually
    break up long strings. Also, we will need to `encode`/`decode` our strings because
    `b64encode()` operates on `byte` objects.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base64.b64encode(...)`: 这对我们的用户名和密码进行了base64编码。我们将使用这个来提供一个HTTP基本认证头。我们必须使用`base64.b64encode()`而不是`base64.base64()`，因为后者会引入空格来视觉上分隔长字符串。此外，我们需要对我们的字符串进行`encode`/`decode`，因为`b64encode()`操作`byte`对象。'
- en: '`client.credentials()`: This lets us set an authentication header to be sent
    all future requests by this `client` object. In our case, we''re sending an HTTP
    basic authentication header.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client.credentials()`: 这让我们设置一个认证头，以便将来由这个`client`对象发送所有的请求。在我们的情况下，我们发送了一个HTTP基本认证头。'
- en: '`json.loads(response.content)`: This parses the content body of the response
    return a Python list.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json.loads(response.content)`: 这解析了响应内容体并返回一个Python列表。'
- en: '`self.assertEqual(3, len(parsed))`: This confirms that the number of items
    in the parsed list is correct.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertEqual(3, len(parsed))`: 这确认了解析列表中的项目数量是正确的。'
- en: If we were to send a second request using `self.client`, we would not need to
    re-authenticate because `client.credentials()` remembers what it received and
    continues passing it to all requests. We can clear the credentials by calling
    `client.credentials()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`self.client`发送第二个请求，我们不需要重新认证，因为`client.credentials()`会记住它接收到的内容，并继续将其传递给所有请求。我们可以通过调用`client.credentials()`来清除凭据。
- en: Now, we know how to test our API code!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何测试我们的API代码了！
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered how to use the Django REST framework to create an
    RESTful API for our Django project. We saw how the Django REST framework uses
    similar principles to Django forms and Django generic views. We also used some
    of the core classes in the Django REST framework, we used a `ModelSerializer` to
    build a `Serializer` based on a Django models, and we used a `ListCreateAPIView`
    to create a view that can list and create Django models We used `RetrieveUpdateDestroyAPIView`
    to manage a Django model instance based on its primary key.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用Django REST框架为我们的Django项目创建RESTful API。我们看到Django REST框架使用了与Django表单和Django通用视图类似的原则。我们还使用了Django
    REST框架中的一些核心类，我们使用了`ModelSerializer`来构建基于Django模型的`Serializer`，并使用了`ListCreateAPIView`来创建一个可以列出和创建Django模型的视图。我们使用了`RetrieveUpdateDestroyAPIView`来管理基于其主键的Django模型实例。
- en: Next, we'll deploy our code to the internet using Amazon Web Services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用亚马逊网络服务将我们的代码部署到互联网上。
