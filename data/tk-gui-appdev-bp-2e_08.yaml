- en: Fun with Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上尽情玩耍
- en: Canvas is undoubtedly one of the most versatile widgets of Tkinter. Given that
    it provides direct control over the drawing of each individual pixel, combine
    it with some maths and it can be used to create all sorts of neat visualizations.
    While the possibilities are endless, we will explore how to implement some of
    the important mathematical ideas in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas无疑是Tkinter中最灵活的控件之一。鉴于它提供了对每个单独像素绘制的直接控制，结合一些数学知识，它可以用来创建各种巧妙的可视化效果。虽然可能性是无限的，但我们将在本章中探讨如何实现一些重要的数学思想。
- en: 'The key objectives for this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键目标是：
- en: Learning to animate with the Tkinter canvas
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 Tkinter 画布进行动画制作
- en: Understanding the usage of polar and Cartesian coordinates on the canvas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解在画布上使用极坐标和笛卡尔坐标的用法
- en: Implementing ordinary differential equations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现常微分方程
- en: Modeling simulations given a list of formulas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定公式列表进行建模模拟
- en: Modeling 3D graphics and studying some common transformation matrices used in
    3D animation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模3D图形和研究在3D动画中常用的某些常见变换矩阵
- en: Note that many of the code samples in this chapter requires heavy computations.
    However, code optimization for speed is not our first preference. The primary
    goal here is comprehension of the underlying concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的许多代码示例需要进行大量计算。然而，为了速度而进行的代码优化并不是我们的首要选择。这里的主要目标是理解底层概念。
- en: Building a screen saver
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建屏幕保护程序
- en: 'We will start by building a screen saver. The program will consist of several random-colored
    and random-sized balls bouncing all over the screen at random velocity, as shown
    in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个屏幕保护程序开始。该程序将包含几个随机颜色和随机大小的球，以随机速度在屏幕上四处弹跳，如下面的截图所示：
- en: '![](img/d4b6f8f8-1f84-457e-9a31-2139efebfe4a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4b6f8f8-1f84-457e-9a31-2139efebfe4a.png)'
- en: 'Let''s create a class to generate balls with random attributes. Accordingly,
    we define a new class named `RandomBall`. Refer the code file `8.01_screensaver`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个类来生成具有随机属性的球。相应地，我们定义一个新的类名为`RandomBall`。请参考代码文件`8.01_screensaver`：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the description for the preceding code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码的描述：
- en: Two key methods here are `create_ball` and `move_ball`. All other methods are
    helpers to these two methods. The `__init__` method takes a `canvas` as a parameter
    and then calls the `create_ball` method to draw the ball on the given canvas.
    To move the ball around, we will explicitly need to call the `move_ball` method.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有两个关键方法：`create_ball` 和 `move_ball`。所有其他方法都是这两个方法的辅助。`__init__` 方法接受一个 `canvas`
    作为参数，然后调用 `create_ball` 方法在给定的画布上绘制球。要移动球，我们需要显式地调用 `move_ball` 方法。
- en: The `create_ball` method uses the `canvas.create_oval()` method and `move_ball`
    uses the `canvas.move(item, dx, dy)` method, where `dx` and `dy` are `x` and `y`
    offsets for the canvas item.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_ball` 方法使用了 `canvas.create_oval()` 方法，而 `move_ball` 方法使用了 `canvas.move(item,
    dx, dy)` 方法，其中 `dx` 和 `dy` 是画布项的 `x` 和 `y` 偏移量。'
- en: Also, note how we create a random color for the ball. Because the hexadecimal
    color coding system uses up to four hexadecimal digits for each of red, green,
    and blue, there are up to `0xffff` possibilities for each color. We, therefore,
    create a lambda function that generates a random number from `0-0xffff`, and use
    this function to generate three random numbers. We convert this decimal number
    to its two-digit equivalent hexadecimal notation using the format specifier `#{:04x}{:04x}{:04x} `to
    get a random color code for the ball.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，请注意我们是如何为球体创建一个随机颜色的。因为十六进制颜色编码系统为红色、绿色和蓝色中的每一个都使用最多四个十六进制数字，所以每种颜色都有多达 `0xffff`
    种可能性。因此，我们创建了一个生成从 `0-0xffff` 的随机数的 lambda 函数，并使用这个函数生成三个随机数。我们使用格式说明符 `#{:04x}{:04x}{:04x}`
    将这个十进制数字转换为它的两位等效十六进制表示，以获取球体的随机颜色代码。
- en: That is all there is to the `RandomBall` class. We can use this class to create
    as many ball objects as we want to display in our screensaver.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`RandomBall`类的全部内容。我们可以使用这个类来创建我们想要在屏幕保护程序中显示的任意数量的球对象。
- en: 'Next, let''s create the `ScreenSaver` class that will show the actual screensaver:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个将显示实际屏保的`ScreenSaver`类：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The description of the code is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The `__init__` method of the ScreenSaver class takes the number of balls (`number_of_balls`)
    as its argument
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScreenSaver 类的 `__init__` 方法接受球的数量 (`number_of_balls`) 作为其参数
- en: We use `root.attributes ( -fullscreen, True )` to remove the enclosing frame
    from the parent window and make it a full-screen window.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `root.attributes ( -fullscreen, True )` 来从父窗口移除包围框架，使其成为一个全屏窗口。
- en: The `quit_on_interaction` method binds the root to call our `quit_screensaver`
    method in case of any interactions from the user's end.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quit_on_interaction` 方法将根绑定到在用户端发生任何交互时调用我们的 `quit_screensaver` 方法。'
- en: We then create a canvas to cover the entire screen with `Canvas(self.root)` with
    `pack ( expand=1, fill=BOTH )` options to fill the entire screen.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后使用 `Canvas(self.root)` 创建一个画布来覆盖整个屏幕，并使用 `pack ( expand=1, fill=BOTH )`
    选项来填充整个屏幕。
- en: We create several random ball objects using the `RandomBall` class, passing
    along the Canvas widget instance as its arguments.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`RandomBall`类创建了几个随机的球体对象，并将画布小部件实例作为其参数传递。
- en: We finally make a call to the `animate_balls` method, which uses the standard
    `widget.after()` method to keep running the animation in a loop at a regular interval
    of 30 milliseconds.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终调用了`animate_balls`方法，该方法使用标准的`widget.after()`方法以每30毫秒的固定间隔循环运行动画。
- en: To run the screen saver, we instantiate an object from our `ScreenSaver` class,
    passing the number of balls as its argument as follows: `ScreenSaver(number_of_balls=18)`
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行屏幕保护程序，我们需要从我们的`ScreenSaver`类实例化一个对象，并将球的数量作为其参数传递，如下所示：`ScreenSaver(number_of_balls=18)`
- en: Our screensaver is now ready! In fact, if you are working on the Windows platform, and
    when you learn to create an executable program from Python programs (discussed
    in [Chapter 10](cabe3587-e359-4987-9dde-52d04270aba3.xhtml), *Miscellaneous Tips*),
    you can create an executable file with a `.exe` extension for this screensaver.
    You can then change its extension from `.exe` to `.scr`, right-click, and select
    Install to add it to your list of screensavers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的保护屏现在已经准备好了！实际上，如果你正在使用Windows平台，并且当你学习如何从Python程序创建可执行程序（在第10章[Chapter 10](cabe3587-e359-4987-9dde-52d04270aba3.xhtml)，*杂项提示*）中讨论过），你可以为这个保护屏创建一个带有`.exe`扩展名的可执行文件。然后你可以将其扩展名从`.exe`更改为`.scr`，右键点击，并选择安装来将其添加到你的屏幕保护程序列表中。
- en: Graphing with Tkinter
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tkinter 绘图
- en: Tkinter is not a graphing tool. However, should you need to draw graphs with Tkinter,
    you can use the Canvas widget to draw graphs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 不是一个绘图工具。然而，如果您需要使用 Tkinter 绘制图表，您可以使用 Canvas 小部件来绘制图表。
- en: 'In this iteration, we will draw the following graphs:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们将绘制以下图表：
- en: Pie chart (`8.02_pie_chart.py`)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼图 (`8.02_pie_chart.py`)
- en: Bar graph (`8.03_bar_graph.py`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柱状图 (`8.03_bar_graph.py`)
- en: Scatter plot (`8.04_scatter_plot.py`)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散点图 (`8.04_scatter_plot.py`)
- en: 'The three graphs show up as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 三张图如下所示：
- en: '![](img/07e15b42-6540-4937-87a7-dc635ed13f19.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07e15b42-6540-4937-87a7-dc635ed13f19.png)'
- en: Let's look at the pie chart first. You can easily create a pie chart in Tkinter
    using the Canvas widget's `create_arc` method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看饼图。您可以使用Tkinter中的Canvas小部件的`create_arc`方法轻松创建饼图。
- en: 'The `create_arc` method has the following signature:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_arc` 方法具有以下签名：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Point (`x1`, `y1`) is the top-left corner and point (`x2`, `y2`) is the bottom-right
    corner of the rectangle into which the arc fits. If the bounding rectangle is
    a square, it makes a circle. The method also takes two arguments, named `start`
    and `extent`, which we will use to create the pie chart.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 点(`x1`, `y1`)是矩形左上角的顶点，而点(`x2`, `y2`)是矩形右下角的顶点，弧线就拟合在这个矩形内。如果边界矩形是正方形，它就形成了一个圆。该方法还接受两个参数，分别命名为`start`和`extent`，我们将使用这两个参数来创建饼图。
- en: The `start` option specifies the start angle for the arc, measured in degrees
    from the `+x` direction. When omitted, you get the complete ellipse. The `extent`
    option specifies the width of the arc in degrees.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`选项指定了弧线的起始角度，以度为单位，从`+x`方向测量。当省略时，得到完整的椭圆。`extent`选项指定了弧线的宽度，以度为单位。'
- en: The arc begins at the angle given by the `start` option and draws counterclockwise up
    to the degrees specified by the `extent` option.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 弧线从由`start`选项给出的角度开始，逆时针绘制，直到达到`extent`选项指定的度数。
- en: 'To create the pie chart, let''s define a method that, given a number *n*, divides
    the circle into, say, 1,000 equal parts and then, given a number less than 1,000,
    returns the equivalent angle in the arc. Since there are 360 degrees in a circle,
    the method is defined as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建饼图，我们定义一个方法，该方法在给定一个数字 *n* 的情况下，将圆分成，比如说，1,000个相等的部分，然后给定一个小于1,000的数字，返回弧线上的等效角度。由于圆有360度，该方法定义如下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we plot the various sections of the pie chart using code like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用如下代码来绘制饼图的各个部分：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can check out an example of a pie chart in `8.02_pie_chart.py`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `8.02_pie_chart.py` 中查看饼图的示例。
- en: 'Next, the bar graph. This is very simple. We use `create_rectangle` to draw a
    bar graph:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是条形图。这非常简单。我们使用`create_rectangle`来绘制条形图：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One important thing to note here. Since the Canvas widget represents the `y` coordinate
    starting from the top-left corner, we need to subtract the `y` position from the
    canvas height to get the `y` coordinate for the graphs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的事项需要注意。由于 Canvas 小部件表示从左上角开始的 `y` 坐标，我们需要从画布高度中减去 `y` 位置，以获得图表的 `y`
    坐标。
- en: You can check out the complete code of the bar graph in `8.03_bar_graph.py`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看条形图的完整代码，位于`8.03_bar_graph.py`文件中。
- en: Similarly, we use the `create_oval` method to draw the scatter plot. Check out
    the code for the scatter plot in `8.04_scatter_plot.py`*.*
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用 `create_oval` 方法来绘制散点图。请查看 `8.04_scatter_plot.py`*.* 中的散点图代码。
- en: Next, let us see how to embed `matplotlib` graphs in Tkinter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将 `matplotlib` 图形嵌入到 Tkinter 中。
- en: Using the Tkinter canvas to draw graphs may work fine for trivial cases. However, Tkinter
    is not the best choice when it comes to drawing more sophisticated and interactive
    graphs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tkinter画布绘制图表在简单情况下可能效果不错。然而，当涉及到绘制更复杂和交互式的图表时，Tkinter并不是最佳选择。
- en: Several Python modules have been developed for making graphs. However, `matplotlib`
    stands out as a clear winner for producing professional-quality interactive graphs
    with Python.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几个Python模块已被开发用于制作图表。然而，`matplotlib`在用Python生成专业质量的交互式图表方面脱颖而出，成为当之无愧的佼佼者。
- en: Although a detailed discussion on `matplotlib` is beyond the scope of this book,
    we will take a brief look at embedding matplotlib-generated graphs on a Tkinter
    canvas.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对`matplotlib`的详细讨论超出了本书的范围，但我们仍将简要地看看如何在Tkinter画布上嵌入由matplotlib生成的图形。
- en: 'You can install `matplotlib` and NumPy (a dependency for `matplotlib`) using
    the following commands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装`matplotlib`和NumPy（`matplotlib`的依赖项）：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `matplotlib` targets many types of use cases and output formats. Some of
    the different use cases for `matplotlib` are to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`matplotlib` 针对许多类型的用例和输出格式。`matplotlib` 的不同用例包括：'
- en: Make interactive graphs from the Python shell
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Python 命令行创建交互式图表
- en: Embed `matplotlib` in GUI modules such as Tkinter, wxPython, or PyGTK
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `matplotlib` 集成到 Tkinter、wxPython 或 PyGTK 等GUI模块中
- en: Generate postscript images from simulations
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模拟中生成 PostScript 图像
- en: Serve on web pages from backend web servers
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后端Web服务器上提供网页服务
- en: In order to target all these use cases, `matplotlib` uses the concept of a backend.
    In order to display a `matplotlib` graph on Tkinter, we use a backend called `TkAgg`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了针对所有这些用例，`matplotlib` 使用了后端的概念。为了在 Tkinter 上显示 `matplotlib` 图形，我们使用了一个名为 `TkAgg`
    的后端。
- en: 'We import the backend into `matplotlib` as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下将后端导入`matplotlib`：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then create the `matplotlib` graph as we would normally do in the `matplotlib`
    API:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后创建`matplotlib`图表，就像在`matplotlib` API中通常所做的那样：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we embed the generated graph in the `tkinter` main loop using the
    `TkAgg` backend as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`TkAgg`后端将生成的图嵌入到`tkinter`主循环中，如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also embed the navigation toolbar of `matplotlib` using the command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下命令嵌入`matplotlib`的导航工具栏：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code (`8.05_matplotlib_embedding_graphs.py`) generates a graph as
    shown in the following diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码（`8.05_matplotlib_embedding_graphs.py`）生成了一个如图所示的图表：
- en: '![](img/5cde33cc-6f63-4a28-9a94-fb9ce7b86b51.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cde33cc-6f63-4a28-9a94-fb9ce7b86b51.png)'
- en: Polar plots with Tkinter
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter绘制的极坐标图
- en: 'A point in space can be represented using the Cartesian coordinate using two
    numbers **x** and **y**.  The same point can also be represented in the polar
    coordinate by using the distance from the origin (**r**) and the angle from the
    *x* axis (theta), as shown in the following diagram:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 空间中的一个点可以用笛卡尔坐标系中的两个数字 **x** 和 **y** 来表示。同样的点也可以通过使用从原点（**r**）的距离和从 *x* 轴的角度（theta）来表示极坐标，如下面的图所示：
- en: '![](img/eefd2e49-44e1-4572-b7de-e4df3234d708.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eefd2e49-44e1-4572-b7de-e4df3234d708.png)'
- en: 'To convert between polar and Cartesian coordinates, we use the following equalities:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要在极坐标和笛卡尔坐标之间进行转换，我们使用以下等式：
- en: '*x= r cos(θ) and y = rsin(θ)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*x = r cos(θ) 和 y = r sin(θ)*'
- en: 'It is easier to plot equations expressed in terms of **r** and **θ** on a special
    kind of graph called the **polar plot**, which is divided into small concentric
    circles and radial lines emanating from the center. The radial lines are normally
    spaced at intervals of 15◦, while the radius of concentric circles depends on
    the scale on which the distance is to be measured from the center.  Here''s an
    example of a polar plot that we will draw:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在极坐标图上绘制以**r**和**θ**表示的方程更容易，这种特殊的图称为**极坐标图**，它被分成许多同心圆和从中心辐射出的径线。径线通常以15◦的间隔排列，而同心圆的半径取决于从中心测量的距离所使用的比例尺。以下是我们将要绘制的极坐标图的示例：
- en: '![](img/39b67f13-33c1-42c4-b2ad-46c1b2ddfd13.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39b67f13-33c1-42c4-b2ad-46c1b2ddfd13.png)'
- en: 'The Tkinter canvas understands Cartesian coordinates. It is, however, easy
    to convert from polar to Cartesian coordinates. We  accordingly define a method
    named `polar_to_cartesian`; see `8.06_polar_plot.py`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter画布理解笛卡尔坐标系。然而，从极坐标转换为笛卡尔坐标很容易。因此，我们相应地定义了一个名为`polar_to_cartesian`的方法；请参阅`8.06_polar_plot.py`：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s a brief description of the preceding code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对前面代码的简要描述：
- en: The method converts an input of  (`r`, `theta`) value to (`x`, `y`) coordinates
    using the equalities *x= r cos(**θ) and y = rsin(θ)*.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法将输入的 (`r`, `theta`) 值转换为 (`x`, `y`) 坐标，使用等式 *x= r cos(θ) 和 y = rsin(θ)*。
- en: The `scaling_factor` in the preceding equation decides how many pixels will
    equal to one unit in our polar plot and is set to a constant value. Changing it
    changes the size of the plot.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前一个方程中的`scaling_factor`决定了在我们极坐标图中多少像素等于一个单位，并且被设置为常数。改变它将改变图表的大小。
- en: We add the `x_center` and `y_center` values to the final results. `x_center`
    is defined as half the `window_width` while `y_center` is half the window size.
    We add these as offsets because Canvas considers (*0*,*0*) as the top left of
    the canvas, while we want to consider the center of the canvas as (*0*,*0*).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `x_center` 和 `y_center` 的值加到最终结果中。`x_center` 被定义为 `window_width` 的一半，而 `y_center`
    是窗口大小的一半。我们添加这些值作为偏移量，因为 Canvas 将 (*0*,*0*) 视为画布的左上角，而我们的目标是把画布的中心视为 (*0*,*0*)。
- en: 'We begin by creating a canvas in a Tkinter root window, and add radial lines
    and concentric circles to the canvas using the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Tkinter根窗口中创建一个画布，并使用以下代码在画布上添加径向线和同心圆：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that our graph paper is ready, it''s time to plot the actual polar plot.
    The following code plots `3000` points of the polar equation `r = 2*math.sin(2*theta)` on
    the graph:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了坐标纸，是时候绘制实际的极坐标图了。以下代码在图上绘制了极坐标方程 `r = 2*math.sin(2*theta)` 的 `3000`
    个点：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This creates the curve of the `form. r = a sin nθ`, where `n` is even. It is
    a  **2n-leaved rose**. If `n` is odd, it will form an **n-leaved rose**. There
    are many other good looking plots that you can plot by changing the `r` equation
    in the previous method. A few other equations that you can try are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就形成了 `form. r = a sin nθ` 的曲线，其中 `n` 是偶数。它是一个 **2n瓣的蔷薇花**。如果 `n` 是奇数，它将形成一个
    **n瓣的蔷薇花**。通过改变前一种方法中的 `r` 方程，你可以绘制出许多其他好看的图形。以下是一些你可以尝试的其他方程：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also play with the parameters of the individual equation to see the
    difference they make to the plot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以调整单个方程的参数，看看它们对图表造成的影响。
- en: This concludes the iteration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迭代。
- en: Gravity simulation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重力模拟
- en: Let's now simulate gravity. We will simulate the movement of four planets (Mercury,
    Venus, Earth, and Mars), and our very own Moon, using Newton's law of universal
    gravitation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在模拟重力。我们将使用牛顿的万有引力定律来模拟四个行星（水星、金星、地球和火星）以及我们自己的月球的运动。
- en: 'Our simulation assumes the Sun at the center, but it does not draw an oval
    for the Sun as that would make our planets invisible at that scale. Our simulation
    programs shows the four planets and moon revolving in circular orbits (`8.07_gravity_simulation.py`):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟假设太阳位于中心，但不会为太阳画一个椭圆形，因为这会使我们的行星在那个尺度上变得不可见。我们的模拟程序显示了四颗行星和月球在圆形轨道上旋转（`8.07_gravity_simulation.py`）：
- en: '![](img/2abbba07-1d86-4467-93b2-7e166b78f881.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2abbba07-1d86-4467-93b2-7e166b78f881.png)'
- en: While the system could be extended to include other planets from the solar system
    - putting them all on the rectangular window of our screen would not be possible
    as the differences in planet sizes and distances are so disproportionate that
    making one planet, such as Jupiter, show up would make sizes and distances of
    planets such as Earth  smaller than a pixel, making them invisible. So our visualization
    sticks to just the four relatively nearby planets and our Moon. A very insightful
    interactive visualization of the entire solar system, titled *If the moon were
    only 1 pixel*, can be found here: [http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html](http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该系统可以扩展以包括太阳系中的其他行星——但由于行星大小和距离的差异如此不成比例，将它们全部放在我们屏幕的矩形窗口中是不可能的。例如，要让木星这样的行星显示出来，会使地球等行星的大小和距离变得小于一个像素，从而使其变得不可见。因此，我们的可视化仅限于四个相对较近的行星和我们的月球。您可以在以下链接找到整个太阳系的一个非常富有洞察力的交互式可视化，标题为*如果月亮只有1像素*：[http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html](http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html).
- en: 'Newton''s law of gravitation established the fact that gravitation is universal
    and that all objects attract each other with a force of gravity that is related
    to the mass of the two bodies and the distance between them, using this formula:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿万有引力定律确立了万有引力是普遍存在的，并且所有物体都通过一个与两物体质量和它们之间的距离有关的引力相互吸引的事实，使用以下公式表示：
- en: '![](img/9677f10d-b22c-4e26-adf1-a08659666779.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9677f10d-b22c-4e26-adf1-a08659666779.png)'
- en: 'Where:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：
- en: '**F** = Force of attraction between two objects'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F** = 两个物体之间的引力'
- en: '**m1** = Mass of object 1'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**m1** = 物体1的质量'
- en: '**m2** = Mass of object 2'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**m2** = 物体2的质量'
- en: '**d** = Distance between the two objects'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d** = 两个物体之间的距离'
- en: '**G** = 6.673 x 10^(-11) N m²/kg^²'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**G** = 6.673 x 10^(-11) N m²/kg²'
- en: 'Once the preceding equation yields us the gravitational force, we can then
    find the angular velocity of the object using this formula:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前述方程给出了引力，我们就可以使用这个公式来找到物体的角速度：
- en: '![](img/9fc254f4-bbb3-48e2-a944-e1dd6f513c77.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fc254f4-bbb3-48e2-a944-e1dd6f513c77.png)'
- en: 'The preceding formula holds true for motion in circular paths, which is somewhat
    an approximation of the actual motion of planets in an elliptical orbit. With
    angular velocity in hand, we can get the angular position (θ):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述公式适用于圆周运动，这在某种程度上是对椭圆轨道上行星实际运动的近似。掌握了角速度后，我们可以得到角位置（θ）：
- en: '![](img/d7681fc0-bc81-4a5e-b733-fe16083c3cbb.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d7681fc0-bc81-4a5e-b733-fe16083c3cbb.png)'
- en: With the distance from the Sun (center) and θ in hand, we can convert it from
    a polar coordinate to a Cartesian coordinate as we have done in previous examples.
    Next, it's just a matter of drawing spheres on the Tkinter canvas at various locations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有从太阳（中心）的距离和θ值，我们可以将其从极坐标转换为笛卡尔坐标，就像我们在之前的例子中所做的那样。接下来，只需在Tkinter画布上不同位置绘制球体即可。
- en: 'With the formulas in hand, we define a `Planet` class (`8.07_gravity_simulation.py`):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到公式后，我们定义一个`Planet`类（`8.07_gravity_simulation.py`）：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While most of the preceding code is a simple instantiation of variables, note
    that it takes in a canvas as an input on which it will draw the planet.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码大部分是变量的简单实例化，请注意它接受一个画布作为输入，并在其上绘制行星。
- en: 'We also need to scale down the planet distances and radii to fit into our window
    screen, so we have defined two methods in the class to scale distance and radius
    (`8.07_gravity_simulation.py`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将行星的距离和半径缩小以适应我们的窗口屏幕，因此我们在类中定义了两种方法来缩放距离和半径 (`8.07_gravity_simulation.py`)：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For scaling the distance, we take the maximum distance and scale it to fit in
    half of the canvas width. For scaling radius, we take the maximum and minimum
    radii from the first four planets and multiply them with the arbitrary number
    16, so that the planets' scales look acceptable on the screen. Most of the preceding
    code was obtained by experimenting with what looks best on the screen, and the
    numbers were chosen purely arbitrarily.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缩放距离，我们取最大距离并将其缩放到画布宽度的一半。对于半径的缩放，我们从前四个行星中取最大和最小半径，并将它们与任意数16相乘，这样行星的缩放在屏幕上看起来是可接受的。大部分前面的代码是通过实验确定屏幕上看起来最好的效果，数字完全是任意选择的。
- en: The constructor then calls a method, `draw_initial_planet`, which creates an
    oval of a scaled radius and at a scaled distance on the canvas. It also returns
    the unique ID of the created oval so that the oval's position can be updated using
    the id as a handle.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数随后调用一个方法，`draw_initial_planet`，该方法在画布上创建一个按比例缩放的椭圆，并位于按比例缩放的距离处。同时，它还返回创建的椭圆的唯一ID，以便可以使用ID作为句柄来更新椭圆的位置。
- en: 'We then define two helper methods using the formulas we discussed earlier:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了两个辅助方法，使用我们之前讨论过的公式：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we calculate the angular position (`theta`), convert it from polar to Cartesian
    coordinates, and update the *x*, *y* position for the oval pertaining to the planet.
    We also leave a 1-pixel trail for the planet''s position using `create_rectangle`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们计算角位置（`theta`），将其从极坐标转换为笛卡尔坐标，并更新与该行星相关的椭圆的 *x*、*y* 位置。我们使用 `create_rectangle`
    函数为行星位置留下一个 1 像素的轨迹：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code to convert from polar to Cartesian coordinates is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将极坐标转换为笛卡尔坐标的代码如下：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we define a `Moon` class, which is similar in all aspects to the `Planet`
    class, so it inherits from the `Planet` class. However, the most important difference
    is that instead of taking distance from the Sun and the mass of the Sun as a reference,
    it takes distance from Earth and the mass of Earth as a reference. As scaling
    on actual values would have made the Moon's size smaller than 1 pixel, we have
    also hardcoded the scaled distance and scaled radius values for Moon to make it
    visible on the screen. Since Moon needs to go round Earth, we also need to pass
    Earth as an extra argument to the `__init__` method of the `Moon` class (`8.07_gravity_simulation.py`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Moon`类，它在所有方面都与`Planet`类相似，因此它继承自`Planet`类。然而，最重要的区别是它不是以距离太阳和太阳的质量作为参考，而是以距离地球和地球的质量作为参考。由于按实际值缩放会使月球的大小小于1像素，因此我们为月球硬编码了缩放距离和缩放半径值，以便在屏幕上显示。由于月球需要绕地球运行，我们还需要将地球作为额外参数传递给`Moon`类的`__init__`方法（`8.07_gravity_simulation.py`）。
- en: 'Finally, we create the four planets and the Moon, passing in their actual values
    taken from Wikipedia:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了四颗行星和月球，传入它们从维基百科获取的实际值：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then we create a Tkinter canvas and define an `update_bodies_positions` method
    that runs every 100 ms, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个Tkinter画布并定义一个每100毫秒运行一次的`update_bodies_positions`方法，如下所示：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That concludes the gravity simulation project. If you now go and run `8.07_gravity_simulation.py`,
    you can see the planets and our Moon responding to gravitational force.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着重力模拟项目的结束。如果你现在去运行`8.07_gravity_simulation.py`，你可以看到行星和我们的月球对重力作用的响应。
- en: Drawing fractals
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制分形
- en: A fractal is a never-ending pattern that repeats itself at all scales. Fractals
    are found everywhere in nature. We find them in our blood vessels, branches of
    trees, and in the structure of our galaxies, and the beauty of them lies in the
    fact that they are made out of simple formulas.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 分形是一种永无止境的图案，它在所有尺度上都会重复出现。分形在自然界中无处不在。我们在我们的血管、树木的枝条以及我们星系的结构中都能找到它们，它们的美丽之处在于它们是由简单的公式构成的。
- en: 'We will demonstrate the simplicity of these seemingly complex-looking phenomena
    by drawing a fractal named a Mandelbrot set. We assume a basic knowledge of set
    theory and complex numbers in this section.  Our code produces a Mandelbrot set
    that looks like the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过绘制一个名为曼德布罗特集的分数形来展示这些看似复杂现象的简单性。在本节中，我们假设读者具备集合理论和复数的基本知识。我们的代码生成的曼德布罗特集看起来如下所示：
- en: '![](img/bf88fd1a-298b-4302-b1b2-7cf48f33b8a4.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf88fd1a-298b-4302-b1b2-7cf48f33b8a4.png)'
- en: 'The Mandelbrot set  is defined as a set of complex numbers, *c*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗特集定义为复数集，*c*：
- en: '![](img/aa4f32fe-a773-4ebd-92a8-52c2036389f3.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa4f32fe-a773-4ebd-92a8-52c2036389f3.png)'
- en: 'So that the complex number *c* obeys the following recurrence relation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以便复数 *c* 遵循以下递归关系：
- en: '![](img/dc255dd5-3718-4b28-a33e-0ab66f2d6417.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc255dd5-3718-4b28-a33e-0ab66f2d6417.png)'
- en: Think of recurrence relations as functions where the last output is fed as input
    into the same function in the next iteration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将递归关系视为函数，其中最后一个输出作为输入传递到下一个迭代中相同的函数。
- en: So the Mandelbrot set is a set that only includes those complex numbers for
    which the previous equation does not, after any number of iterations, blow up
    the value of *z*[n] to infinity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，曼德布罗特集只包括那些在经过任意次迭代后，前述方程不会将复数*z*[n]的值爆炸到无穷大的复数。
- en: 'For a clearer understanding, if we take the number 1 as *c* and apply it to
    the preceding equation (note that 1 is also a complex number with no imaginary
    component—so real numbers are a subset of complex numbers and hence they too lie
    on the complex plane):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地理解，如果我们把数字1视为*c*并应用于前面的方程（注意，1也是一个没有虚部的复数——因此实数是复数的一个子集，所以它们也位于复平面上）：
- en: '| **Value of z after n iterations(z[n])** | **Value of z[n+1 =] z² [n] + c
    for c = 1** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **n次迭代后z的值(z[n])** | **z[n+1] = z²[n] + c，其中c = 1** |'
- en: '| z[0] | 0² + 1 = 1 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| z[0] | 0² + 1 = 1 |'
- en: '| z[1] | 1² + 1 = 2 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| z[1] | 1² + 1 = 2 |'
- en: '| z[2] | 2² +1 = 5 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| z[2] | 2² +1 = 5 |'
- en: '| z[3] | 5² +1 = 26 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| z[3] | 5² +1 = 26 |'
- en: It is clear that the previous series will blow up to infinity as the number
    of iterations tends to infinity. Since this complex number 1 blows up the equation,
    it is not a part of the Mandelbrot set.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，随着迭代次数趋向于无穷大，之前的序列将会爆炸到无穷大。由于这个复数1会使方程爆炸，它不是曼德布罗集的一部分。
- en: 'Contrast this with another number, c = -1  the values for which are plotted
    in the next table:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与另一个数字 c = -1 进行对比，其值在下一表中给出：
- en: '| **Value of z after n  iterations(z[n])** | **Value of  z[n+1] = z² [n] +
    c for c = -1** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **n次迭代后z的值(z[n])** | **z[n+1] = z²[n] + c 对于 c = -1 的值** |'
- en: '| z[0] | 0² + -1 = -1 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| z[0] | 0² + -1 = -1 |'
- en: '| z[1] | -1² + -1  = 0 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| z[1] | -1² + -1  = 0 |'
- en: '| z[2] | 0² + -1 = -1 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| z[2] | 0² + -1 = -1 |'
- en: '| z[3] | -1² + -1 = 0 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| z[3] | -1² + -1 = 0 |'
- en: Note that you may continue the preceding series up to infinity but the value
    will keep alternating between *-1* and *0*, thus never exploding. This makes the
    complex number *-1* eligible for inclusion in the Mandelbrot set.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以将前面的序列一直延续到无穷大，但数值将在 *-1* 和 *0* 之间交替，因此永远不会爆炸。这使得复数 *-1* 有资格被包含在曼德布罗特集中。
- en: Now, let us try to model the preceding equation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试对前面的方程进行建模。
- en: One immediate problem to overcome is that we cannot model infinity in the previous
    equation. Fortunately, it can be seen from the equation that if the absolute value
    of *z* ever exceeds *2*, the equation will eventually blow up.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 需要克服的一个直接问题是，我们无法在之前的方程中建模无穷大。幸运的是，从方程中可以看出，如果复数 *z* 的绝对值一旦超过 *2*，方程最终会爆炸。
- en: 'So a definitive way to check whether the equation blows up is to check whether
    the magnitude of *Z > 2*. The magnitude of a complex number *a + ib* is defined
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查方程是否爆炸的确定方法就是检查复数 *Z > 2* 的模。复数 *a + ib* 的模定义为如下：
- en: '![](img/d870b266-0079-44cd-9d8b-41b99dcae571.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d870b266-0079-44cd-9d8b-41b99dcae571.png)'
- en: 'So in order to check whether a complex number *a+ib* blows up the preceding
    equation, we need to check the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了检查复数 *a+ib* 是否会使前面的方程爆炸，我们需要检查以下内容：
- en: '![](img/2ad774df-1d79-44fb-a18f-9db0c23a0821.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ad774df-1d79-44fb-a18f-9db0c23a0821.png)'
- en: 'Or:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '![](img/d8b37d55-6d6d-4991-9c3a-4dc9db53b699.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8b37d55-6d6d-4991-9c3a-4dc9db53b699.png)'
- en: The next question to consider is how many times should we iterate *Zn* to see
    if its magnitude exceeds *2* or not?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来需要考虑的问题是，我们应该迭代*Zn*多少次才能看到其幅度是否超过*2*？
- en: 'The answer to this depends on the kind of image resolution you seek to obtain
    in the final image. In general, the higher the maximum number of iterations, the
    greater the image resolution, subject to the limitation of individual pixel size,
    beyond which you can never go in terms of details. In practice, an iteration of
    a few hundred times is sufficient. We use a maximum iteration of `200` as that
    is enough to determine whether or not the equation blows up for a small-scale
    image that we will draw. Accordingly, we define a variable in `8.08_Mandelbrot.py` as
    follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个答案取决于你希望在最终图像中获得的图像分辨率类型。一般来说，最大迭代次数越高，图像分辨率就越高，但受限于单个像素的大小，超过这个限制你将无法在细节上更进一步。在实践中，几百次的迭代就足够了。我们使用最大迭代次数为`200`，因为这对于我们将要绘制的较小规模的图像来说，足够确定方程是否爆炸。因此，我们在`8.08_Mandelbrot.py`中定义了一个变量，如下所示：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we define a method that takes in the real and imaginary components of
    a complex number, and tells whether the equation blows up for the complex number input.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法，该方法接受复数的实部和虚部，并判断该复数输入是否会导致方程爆炸。
- en: 'For example, the method should return `2` for an input of `1`, as the path
    to blow up is sensed right in the second iteration for the input value `1`. However,
    if we give it an input of `-1`, the equation never blows up so it runs for the
    maximum number of iterations and returns the `maximum_iteration_count`, which
    we have defined as `200` and is akin to saying that the said number belongs to
    the Mandelbrot set (`8.08_Mandelbrot.py`):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，该方法对于输入值`1`应该返回`2`，因为对于输入值`1`，爆炸路径在第二次迭代时就被检测到了。然而，如果我们给它一个输入值`-1`，方程永远不会爆炸，因此它会运行最大迭代次数并返回`maximum_iteration_count`，我们将其定义为`200`，这相当于说该数值属于曼德布罗特集（`8.08_Mandelbrot.py`）：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Accordingly, we define the `mandelbrot_set_check` method as follows (`8.08_Mandelbrot.py`):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义`mandelbrot_set_check`方法如下（`8.08_Mandelbrot.py`）：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code simply implements the recurrence relation for the Mandelbrot set.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 代码简单地实现了曼德布罗集的递归关系。
- en: While it's sufficient to know whether a complex number lies in the Mandelbrot
    set, we also keep a track of the iteration count, also called the escape time,
    which is the number of iterations it took a complex number to blow up, if it does
    blow up.  If the iteration count returns as `maximum_number_of_iterations`, it
    means the complex number does not blow up the equation and the escape time is
    infinite, that is, the number is a part of the Mandelbrot set. We keep track of
    the iteration count as we will use this data to paint areas with different escape
    times in different colors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然知道一个复数是否位于曼德布罗特集中已经足够，但我们还记录了迭代次数，也称为逃逸时间，这是复数爆炸所需的迭代次数，如果它确实爆炸了。如果迭代次数返回为`maximum_number_of_iterations`，这意味着复数没有使方程爆炸，逃逸时间是无限的，也就是说，这个数是曼德布罗特集的一部分。我们记录迭代次数，因为我们将会使用这些数据以不同的颜色绘制具有不同逃逸时间的区域。
- en: Now that we have a way to tell whether or not a complex number belongs to the
    Mandelbrot set, we need a set of complex numbers to run through this method. In
    order to do that, we first define a maximum and a minimum complex number, between
    which we will check for inclusion in the Mandelbrot set. Note that in the following
    example, we have set the range of complex numbers between *-1.5-1i and 0.7+1i. *
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了判断一个复数是否属于曼德布罗集的方法，我们需要一组复数来运行这个方法。为了做到这一点，我们首先定义一个最大和最小的复数，然后我们将检查这个范围内的复数是否包含在曼德布罗集中。注意，在下面的例子中，我们已将复数的范围设置为
    *-1.5-1i 和 0.7+1i*。
- en: 'You can try different ranges of these complex numbers, as long as the area
    falls inside a circle of radius 2,  and it will print different regions of the
    Mandelbrot set:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试这些复数的不同范围，只要面积落在半径为2的圆内，它将打印出曼德布罗特集的不同区域：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s next proceed by defining the `image_width` and `image_height` variables
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来定义`image_width`和`image_height`变量，如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To draw the Mandelbrot set in an image, we need to map each pixel coordinate
    of the image to our complex numbers. Having defined the maximum and minimum range
    for the real and imaginary parts of our complex numbers, it's simply a matter
    of interpolating the complex numbers to map them to the pixel coordinates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要在图像中绘制曼德布罗特集，我们需要将图像的每个像素坐标映射到我们的复数上。定义了复数的实部和虚部的最大和最小范围后，只需将复数插值映射到像素坐标即可。
- en: 'The following two methods do that for us (`8.08_Mandelbrot.py`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '以下两种方法为我们做到了这一点 (`8.08_Mandelbrot.py`):'
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we are ready to draw the actual image. We create a Tkinter root window,
    draw a canvas atop it, and then run the following loops:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备绘制实际图像。我们创建一个Tkinter根窗口，在其上方绘制一个画布，然后运行以下循环：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code takes each pixel in the image, maps its `x`, `y` coordinates
    to a real and imaginary number respectively, and then send this number out to
    the `mandelbrot_set_check` method, which in turn returns the number of iterations
    it took for the number to blow up. If the number did not blow up, it returns the
    value of `maximum_number_of_iterations. `With this number in hand, we call another
    method that gives an RGB color code, which is just based on some arbitrary numbers.
    It just adds the cosmetic value, and you can play with different arbitrarily designed
    color mapping schemes to generate Mandelbrot images of different colors. Finally,
    we use this color to fill the (*x*, *y*)^(th) pixel on the canvas.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对图像中的每个像素进行处理，将其`x`、`y`坐标分别映射到实数和虚数，然后将这个数字发送到`mandelbrot_set_check`方法，该方法反过来返回数字爆炸所需的迭代次数。如果数字没有爆炸，它返回`maximum_number_of_iterations`的值。有了这个数字，我们调用另一个方法，该方法提供一个RGB颜色代码，这仅仅基于一些任意数字。它只是增加了美观价值，你可以玩转不同任意设计的颜色映射方案来生成不同颜色的Mandelbrot图像。最后，我们使用这个颜色填充画布上的(*x*，*y*)^(th)像素。
- en: This concludes the iteration. Our code can now generate the Mandelbrot set.
    However, note that this code takes some time to generate the Mandelbrot set.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。我们的代码现在可以生成曼德布罗特集了。然而，请注意，这段代码生成曼德布罗特集需要一些时间。
- en: Voronoi diagrams
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Voronoi 图
- en: We will now draw a Voronoi diagram. Voronoi diagrams are a simple yet very powerful
    tool used in modeling lots of physical systems. Wikipedia ([https://en.wikipedia.org/wiki/Voronoi_diagram#Applications](https://en.wikipedia.org/wiki/Voronoi_diagram#Applications))  lists
    more than 20 disciplines of science and technology where Voronoi diagrams are
    used to model and solve real-world problems.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将绘制一个 Voronoi 图。Voronoi 图是一种简单但非常强大的工具，用于模拟许多物理系统。维基百科（[https://en.wikipedia.org/wiki/Voronoi_diagram#Applications](https://en.wikipedia.org/wiki/Voronoi_diagram#Applications)）列出了超过
    20 个科学和技术领域，其中 Voronoi 图被用于模拟和解决现实世界的问题。
- en: 'There are many little variations to the rules for drawing Voronoi diagrams,
     but the most common type of Voronoi diagram is made by choosing a finite number
    of points on a 2D plane. We call these points the seeds or the attractors. The
    tiny blue dots shown in the following image are attractor points.  We then map
    or attach all the points on the plane to their nearest attractor point. All points
    closer to a particular attractor point is drawn in one color, which partitions
    the plane into what are called **Voronoi cells**, as shown in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制 Voronoi 图的规则有很多小的变化，但最常见的 Voronoi 图是通过在二维平面上选择有限数量的点来制作的。我们称这些点为种子或吸引点。以下图像中显示的蓝色小点即为吸引点。然后我们将平面上所有的点映射或附着到它们最近的吸引点上。所有靠近特定吸引点的点都绘制成一种颜色，这把平面分割成所谓的**Voronoi
    单元**，如下面的图所示：
- en: '![](img/d8f62e37-5420-43f4-bdf0-2f43884694ce.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8f62e37-5420-43f4-bdf0-2f43884694ce.png)'
- en: Voronoi diagrams can be drawn in spaces of arbitrary dimensions, but we stick
    to studying them in a two-dimensional plane.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: There are many efficient but complicated algorithms for drawing Voronoi diagrams.
    However, we will use the simplest algorithm to understand. However, being simple
    comes at a cost. The algorithm requires more time to compute when compared to
    other faster but more complex algorithms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制 Voronoi 图有许多高效但复杂的算法。然而，我们将使用最简单的算法来理解。然而，简单是有代价的。与其他更快但更复杂的算法相比，该算法在计算时需要更多的时间。
- en: 'We will begin by creating a fixed number of random attractor points on a canvas
    of given width and height. Accordingly, we define three variables in the program
    (`8.09_vornoi_diagram.py`):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将首先在给定宽度和高度的画布上创建一定数量的随机吸引点。相应地，我们在程序中定义了三个变量（`8.09_vornoi_diagram.py`）:'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we create a canvas on a Tkinter root window with the preceding width
    and height and pass the canvas to a method named `generate_vornoi_diagram`, which
    does all the processing and drawing for us. Its code is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在Tkinter根窗口上创建一个具有先前宽度和高度的画布，并将画布传递给名为`generate_vornoi_diagram`的方法，该方法为我们完成所有处理和绘图工作。其代码如下：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s a brief description of the preceding code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对前面代码的简要描述：
- en: We begin by creating two lists. The first `for` loop is used to populate the
    `attractor_points` list with tuples (*x*, *y*) for each of the attractor points.
    We also create another list, `colors`, which holds the random color hexadecimal
    string for the cell of each attractor point.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建两个列表。第一个`for`循环用于将每个吸引点(`attractor_points`)的元组(*x*, *y*)填充到`attractor_points`列表中。我们还创建另一个列表，`colors`，它包含每个吸引点单元格的随机颜色十六进制字符串。
- en: The second triple nested `for` loops goes through each pixel on the canvas and
    finds the index of the nearest attractor. Once that has been established, it colors
    the individual pixel using the color assigned to that attractor point.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二层嵌套的`for`循环遍历画布上的每个像素，并找到最近的吸引子的索引。一旦确定了这个索引，它就会使用分配给那个吸引子点的颜色来着色单个像素。
- en: The last `for` loop then draws an overlapping blue colored square for each of
    the attractor points. This loop is deliberately run last to ensure that the attractor
    point draws over the colored cell region.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的 `for` 循环将为每个吸引点绘制一个重叠的蓝色方块。这个循环故意放在最后运行，以确保吸引点能够覆盖彩色单元格区域。
- en: Since the preceding code has to go through three nested loops for checking each
    *x*,*y* location on the plane against each attractor point, it has a computational
    complexity of O(n³) as per Big-O notation. This means that the algorithm is not
    at all scalable to drawing images of larger sizes and explains why this code takes
    some time to generate the Voronoi diagram, even for this modest-sized image. More
    efficient algorithms are available and if you do not want to reinvent the wheel,
    you can even use the `Voronoi` class from the `scipy.spatial` module to implement
    this much faster. That is left as an exercise for you to explore.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码需要通过三个嵌套循环来检查平面上每个 *x*, *y* 位置与每个吸引点之间的对应关系，根据大O记号，它的计算复杂度为 O(n³)。这意味着该算法根本无法扩展到绘制更大尺寸的图像，这也解释了为什么即使是这个尺寸适中的图像，这段代码生成
    Voronoi 图也需要一些时间。更高效的算法是可用的，如果你不想重新发明轮子，甚至可以使用来自 `scipy.spatial` 模块的 `Voronoi`
    类来实现这一点，这将快得多。这留给你作为探索的练习。
- en: This concludes the section. If you now run the `8.09_vornoi_diagram.py` program,
    it should generate a Voronoi diagram.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容到此结束。如果你现在运行`8.09_vornoi_diagram.py`程序，它应该会生成一个沃罗诺伊图。
- en: Spring pendulum simulation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹簧摆模拟
- en: 'A lot of real-world phenomena can be called **dynamical systems**.  The state
    of such systems varies with time. Modeling such systems requires the use of **differential
    equations**. We will take here an example of modeling a pendulum attached to a
    spring, as shown in the following image. The pendulum swings to and fro. Furthermore,
    since the bob is attached to a spring, the bob also oscillates up and down:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界现象都可以被称为**动态系统**。这类系统的状态随时间变化。建模这类系统需要使用**微分方程**。以下我们将以一个例子来说明如何建模一个连接到弹簧的摆，如图所示。摆来回摆动。此外，由于摆锤连接到弹簧，摆锤也会上下振荡：
- en: '![](img/1f6149ef-e83f-4274-b07c-ebe23df86a7d.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f6149ef-e83f-4274-b07c-ebe23df86a7d.png)'
- en: 'We study the evolution of two variables over time:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究两个变量随时间的变化：
- en: Length l of the spring
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹簧的长度 l
- en: Angle (θ) between the spring and the center line, as shown in the preceding
    diagram.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹簧与中心线之间的角度（θ），如图所示的前一图。
- en: 'Since there are two variables changing over time, the state of our system at
    any time can be represented by using four state variables:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有两个变量随时间变化，我们系统在任何时刻的状态都可以通过使用四个状态变量来表示：
- en: Spring length (l)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹簧长度（l）
- en: Change in spring length (dl/dt), which is  velocity
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 春季长度变化（dl/dt），即速度
- en: Angle (θ)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度 (θ)
- en: Change in angle (dθ/dt), which is the angular velocity
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角度变化（dθ/dt），即角速度
- en: 'They are modeled by the following four differential equations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它们由以下四个微分方程建模：
- en: '![](img/bb296051-9f19-419a-8f0a-ee8f0e9749bc.png)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](img/bb296051-9f19-419a-8f0a-ee8f0e9749bc.png)'
- en: '![](img/6cad5a03-616a-42d2-9116-a2b0da1c47a2.png)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](img/6cad5a03-616a-42d2-9116-a2b0da1c47a2.png)'
- en: '![](img/5d321d29-5b86-4872-ad58-deafa87db22d.png)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](img/5d321d29-5b86-4872-ad58-deafa87db22d.png)'
- en: '![](img/a4b83c6d-bccd-4279-a615-f102a1dc2a8f.png)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![图片](img/a4b83c6d-bccd-4279-a615-f102a1dc2a8f.png)'
- en: The first equation measures linear velocity, which is the rate of change of
    *L* over time. The second equation is a second derivative and gives us the acceleration.
    The third equation measures change in theta over time and hence represents the
    angular velocity. The last equation is the second derivative of theta over time
    and hence it represents the angular acceleration.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程衡量线性速度，即 *L* 随时间变化的速率。第二个方程是二阶导数，它给出了加速度。第三个方程衡量 theta 随时间的变化，因此代表角速度。最后一个方程是
    theta 随时间的二阶导数，因此它代表角加速度。
- en: 'Let us begin by defining the following constants:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义以下常数：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Accordingly, let us begin by defining the initial value for all these four
    state variables:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先定义这四个状态变量的初始值：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we define the `differentials_functions`  method which returns an array
    of the four differential functions defined previously:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了`differentials_functions`方法，该方法返回先前定义的四个微分函数的数组：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will use `scipy.integrate.odeint`  to solve the differential equations.
    This method can be used to solve a system of ordinary differential equations of
    the following form:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `scipy.integrate.odeint` 来求解微分方程。此方法可以用来求解以下形式的常微分方程组：
- en: '![](img/492ae2f7-b43c-4395-ac54-3ee8545e1644.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/492ae2f7-b43c-4395-ac54-3ee8545e1644.png)'
- en: 'Here''s the signature of `scipy.integrate.odeint`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`scipy.integrate.odeint`函数的签名：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Where:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 位置：
- en: '`func`: Callable(y, t0, ...), which computes the derivative of y at t0'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`: 可调用函数(y, t0, ...), 用于计算y在t0处的导数'
- en: '`y0`: Array of initial condition (can be a vector)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y0`: 初始条件数组（可以是一个向量）'
- en: '`t`: Array of time points for which to solve for y'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`: 用于求解 y 的时间点数组'
- en: The initial value point should be the first element of this sequence.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 初始值点应该是这个序列的第一个元素。
- en: This method takes as input the derivative function (`func`), an array of initial
    state values (`yθ`), and an array of times (`t`). It returns an array of state
    values corresponding to those times.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法以导数函数（`func`）、初始状态值数组（`yθ`）和时间数组（`t`）作为输入。它返回与这些时间相对应的状态值数组。
- en: 'Since we are differentiating against time, we need a variable to track time
    (`8.10_spring_pendulum.py`):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是针对时间进行微分，我们需要一个变量来跟踪时间（`8.10_spring_pendulum.py`）：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The number `37` here is the step size for sampling time. Changing this value
    will change the speed of simulation.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里数字`37`是采样时间的步长。改变这个值将会改变模拟的速度。
- en: 'Now we finally solve the sets of differential equations using `scipy.integrate.odeint`
    as follows (`8.10_spring_pendulum.py`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们终于使用 `scipy.integrate.odeint` 解决了微分方程组，如下所示 (`8.10_spring_pendulum.py`):'
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since we have set the number of simulation steps to 500 and there are four state
    variables, the `odeint` method returns a numpy array of the shape (*500*, *4*),
    where each row represents the value of the four state variables at a given point
    of time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将模拟步数设置为500，并且有四个状态变量，`odeint`方法返回一个形状为(*500*, *4*)的numpy数组，其中每一行代表在特定时间点上四个状态变量的值。
- en: 'Now recall that our state vector is a list of four values, `[''l'', ''dl/dt'',
    ''θ'', ''dθ/dt'']`. So the 0^(th) column returns the value `''l''` and the 2^(nd)
    column represents the value `''θ''`.  This is the polar format representation.
    Our canvas understands the Cartesian coordinate system. So we obtain the Cartesian
    coordinates (*x*, *y*) for the values of each value of (*l*, *θ*) as follows (`8.10_spring_pendulum.py`):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '现在回想一下，我们的状态向量是一个包含四个值的列表，`[''l'', ''dl/dt'', ''θ'', ''dθ/dt'']`。因此，第0列返回值
    `''l''`，而第2列代表值 `''θ''`。这是极坐标格式的表示。我们的画布理解笛卡尔坐标系。因此，我们按照以下方式获得每个(*l*, *θ*)值的笛卡尔坐标(*x*,
    *y*)（`8.10_spring_pendulum.py`）:'
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With that data in hand, it''s now just a matter of plotting it on the canvas.
    So we create a Canvas widget in a `mainloop` and call an `update_graph `method that
    runs every 15 milliseconds, deleting everything on the canvas and redrawing the
    line and an oval (pendulum bob).  We also add an increment variable, `plot_step`,
    which is reset to zero every time the simulation ends. This keeps the pendulum
    swinging forever (`8.10_spring_pendulum.py`):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到这些数据后，现在只需将其绘制在画布上。因此，我们在`mainloop`中创建一个Canvas小部件，并调用一个每15毫秒运行一次的`update_graph`方法，该方法会删除画布上的所有内容并重新绘制线条和一个椭圆（摆球）。我们还添加了一个增量变量，`plot_step`，每次模拟结束时都会重置为零。这使摆锤能够永远摆动（`8.10_spring_pendulum.py`）：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will create a spring pendulum, as shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个弹簧摆，如下面的截图所示：
- en: '![](img/3eb3d837-7cf3-44c5-8fa4-17e10c581d98.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3eb3d837-7cf3-44c5-8fa4-17e10c581d98.png)'
- en: That concludes the iteration. You can explore this simulation by changing the
    values of the constants (mass, spring constant, and gravity). Also, change the
    initial state vector elements, such as the angle and velocity, and the program
    should respond as it would in a real-world situation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。你可以通过改变常数的值（质量、弹簧常数和重力）来探索这个模拟。此外，改变初始状态向量的元素，例如角度和速度，程序应该会像在现实世界中那样做出响应。
- en: We saw how to obtain ODE, which is a derivative with respect to only one variable. An
    extension of this concept is **partial differential equations** (**PDEs**), which
    are derivatives with respect to several variables. More complex phenomena, such
    as electromagnetism, fluid mechanics, heat transfer, electromagnetic theory and
    various biological models, are all modeled by partial differential equations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何获得常微分方程（ODE），它是对仅一个变量的导数。这个概念的扩展是**偏微分方程**（**PDEs**），它是对多个变量的导数。更复杂的现象，如电磁学、流体力学、热传递、电磁理论和各种生物模型，都是由偏微分方程建模的。
- en: The FEniCS computing platform ([https://fenicsproject.org/](https://fenicsproject.org/))
    is a popular open-source software tool for solving PDEs with a Python binding.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: FEniCS计算平台([https://fenicsproject.org/](https://fenicsproject.org/))是一个流行的开源软件工具，用于通过Python绑定解决偏微分方程（PDEs）。
- en: Chaos game – building triangles out of randomness
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混沌游戏 – 从随机性中构建三角形
- en: 'The Chaos game refers to the emergence of fractal patterns with random numbers
    when the selection of random numbers are subject to some constraints. Let''s look
    at the rules of one of the simplest chaos games:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌游戏指的是当随机数的选取受到某些约束时，随机数产生的分形图案。让我们来看一下最简单的混沌游戏之一的规则：
- en: We start by creating three points on a plane to form a triangle.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在平面上创建三个点以形成一个三角形。
- en: To begin the game, we draw a random point inside the triangle.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始游戏，我们在三角形内随机画一个点。
- en: 'We then roll a dice. Given the outcome, we move halfway between the last point
    and any one of the vertices of the triangle. For example, if the outcome is 1
    or 2, we move halfway between the last point and vertex A. If the outcome is 3
    or 4, we move halfway from the current point towards vertex B, or if the outcome
    is 5 or 6, we draw the next point halfway between the current point and vertex
    C, as shown in the following image. This is repeated over and over again:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后掷骰子。根据结果，我们在上一点和三角形的任意一个顶点之间移动一半的距离。例如，如果结果是1或2，我们就从上一点移动到顶点A的一半距离。如果结果是3或4，我们就从当前点向顶点B移动一半的距离，或者如果结果是5或6，我们就画出下一个点，这个点位于当前点和顶点C之间的一半距离，如下面的图像所示。这个过程会反复进行：
- en: '![](img/4ef6d36e-c739-4336-a64d-c14c1878d497.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ef6d36e-c739-4336-a64d-c14c1878d497.png)'
- en: 'Here is the surprise part of it. While all the points except for the three
    vertexes were selected at random, the end result is not a haphazard set of points
    but rather a fractal—a set of repeating patterns of triangles called the Sierpinski
    triangle, shown in the following screenshot. This, according to some mathematicians,
    is a glimpse into the orderliness of the universe hidden inside what appears to
    be otherwise chaotic:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其中的惊喜部分。虽然除了三个顶点之外的所有点都是随机选择的，但最终结果并不是一组随机的点集，而是一个分形——一组重复的三角形模式，被称为谢尔宾斯基三角形，如下面的截图所示。据一些数学家所说，这是对宇宙秩序的窥视，这种秩序隐藏在看似混乱的事物之中：
- en: '![](img/00afbbfe-41d0-4207-8f13-1f0cde1c4f8d.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00afbbfe-41d0-4207-8f13-1f0cde1c4f8d.png)'
- en: Note that repeating this same rule inside a set of four points does not create
    a fractal. However, placing some specific kinds of restrictions on the choice
    of vertices produces a variety of interesting fractal shapes. You can read more
    about different varieties of fractals generated out of chaos games at [https://en.wikipedia.org/wiki/Chaos_game](https://en.wikipedia.org/wiki/Chaos_game).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在四个点的集合内重复这条规则并不会产生分形。然而，对顶点选择施加一些特定的限制会产生各种有趣的分形形状。您可以在[https://en.wikipedia.org/wiki/Chaos_game](https://en.wikipedia.org/wiki/Chaos_game)上了解更多关于从混沌游戏中产生的不同分形品种的信息。
- en: 'Let us now code this program.  We first define the three vertices of the triangle,
    as shown in the preceding screenshot:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在编写这个程序。我们首先定义三角形的三个顶点，如图中所示的前一个截图：
- en: '[PRE39]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `WIDTH` and `HEIGHT` are the window dimensions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`WIDTH` 和 `HEIGHT` 代表窗口的尺寸。
- en: Our next task is to choose a random point inside our triangle as the starting
    point. This can be done using what are called **barycentric coordinates**.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是选择三角形内部的一个随机点作为起点。这可以通过所谓的**重心坐标**来实现。
- en: Let *V1*, *V2*, *V3* be the three vertices of a triangle. A point *P* inside
    the triangle can be expressed as *P = aV[1] + bV[2] + cV[3]*, where *a+b+c=1*
    and *a,b,c* are each *≥ 0*. If we know and *b*, we can calculate *c* as *1-a-b*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *V1*, *V2*, *V3* 为三角形的三个顶点。三角形内部的点 *P* 可以表示为 *P = aV[1] + bV[2] + cV[3]*，其中
    *a+b+c=1* 且 *a, b, c* 均满足 *≥ 0*。如果我们已知 *a* 和 *b*，则可以通过 *1-a-b* 计算出 *c*。
- en: So we generate two random numbers, `a` and `b`, each in the range [*0*,*1*]
    so that their sum ≤ 1\. If the sum of two random points exceeds 1, we replace
    a with 1-a and b with 1-b, so that their sum falls back below 1\.  Then,  aV[1]
    + bV[2] + cV[3] is uniformly distributed inside the triangle.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们生成两个随机数，`a` 和 `b`，每个都在范围 [*0*,*1*] 内，使得它们的和 ≤ 1。如果两个随机点的和超过 1，我们将 `a` 替换为
    1-a，将 `b` 替换为 1-b，这样它们的和就会回到 1 以下。然后，aV[1] + bV[2] + cV[3] 在三角形内部是均匀分布的。
- en: 'Now that we have the barycentric coordinates a, b, and c,  we can compute point
    P inside the triangle as  aV1 + bV2 + cV3\. Here is the idea expressed in code
    (`8.11_chaos_game.py`):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了重心坐标 a、b 和 c，我们可以计算出三角形内部的点 P，即 aV1 + bV2 + cV3。以下是这个想法在代码（`8.11_chaos_game.py`）中的表达：
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We next define a method to calculate the halfway distance between two points:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来定义一种计算两点之间中点距离的方法：
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is a simple linear interpolation between two points based on the Pythagorean
    theorem. Note that in Python, the `/` operator does floating point division while
    `//` does integer division (dropping the remainder).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在两点之间基于勾股定理的简单线性插值。注意，在Python中，`/`运算符执行浮点除法，而`//`运算符执行整数除法（丢弃余数）。
- en: 'Next, we put the laws of the game in a method called `get_next_point`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将游戏的规则放入一个名为 `get_next_point` 的方法中：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we create a Tkinter canvas and define a method, `update`, to draw
    the individual pixels every 1 millisecond as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个Tkinter画布并定义一个名为`update`的方法，以便每1毫秒绘制单个像素，如下所示：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Calling this `update` method creates the fractal pattern in our chaos game.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个`update`方法会在我们的混沌游戏中创建分形图案。
- en: Phyllotaxy
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 叶序
- en: Phyllotaxy is derived from the Greek words phýllon (meaning leaf) and táxis
    (meaning arrangement). Accordingly, phyllotaxy is the study of the spiral arrangements
    found in leaves and flowers.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 叶序一词源自希腊语单词phýllon（意为叶子）和táxis（意为排列）。因此，叶序是研究叶子与花朵中发现的螺旋排列方式的研究。
- en: 'In this section, we will code the following floral pattern:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写以下花卉图案的代码：
- en: '![](img/7ddf3794-1d86-4007-895a-699e8f729751.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ddf3794-1d86-4007-895a-699e8f729751.png)'
- en: The mathematical details for this program have been taken from *Chapter 4* of
    the book  *Algorithmic Botany of Plants*—a PDF of which can be obtained from here: [http://algorithmicbotany.org/papers/abop/abop-ch4.pdf.](http://algorithmicbotany.org/papers/abop/abop-ch4.pdf)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的数学细节来自书籍《植物算法学》的**第4章**——您可以从这里获取其PDF版本：[http://algorithmicbotany.org/papers/abop/abop-ch4.pdf.](http://algorithmicbotany.org/papers/abop/abop-ch4.pdf)
- en: 'Here are the two formulas from the chapter that we will be using:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将在本章中使用的两个公式：
- en: '![](img/5a5db8a9-72ab-4c74-bc8e-4f56e981f834.png)   and   ![](img/a77cada8-49e1-452c-ba4d-5580ccd5e115.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/5a5db8a9-72ab-4c74-bc8e-4f56e981f834.png)  和 ![图片2](img/a77cada8-49e1-452c-ba4d-5580ccd5e115.png)'
- en: '![](img/052e08bf-e3b2-4780-8928-33a38ee15dd1.png) represents the polar coordinate
    of each point on the canvas. As you shall see, our phyllotaxy will be made up
    of dots arranged in a spiral pattern. So the variable *n* in the preceding example
    represents the count or the index of the *n*^(th) dot starting at zero at the
    center of the spiral. The variable c is used as a scale factor that in turn decides
    how near or far the dots will appear in the final image. The angle `137.5` is
    related to the golden ratio and the Fibonacci angle and looks the most natural.
    You can read more about it in the linked PDF.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![代表画布上每个点的极坐标](img/052e08bf-e3b2-4780-8928-33a38ee15dd1.png)。正如您将看到的，我们的叶序将由螺旋图案排列的点组成。所以，前一个例子中的变量
    *n* 代表从螺旋中心开始计数的第 *n* 个点的数量或索引。变量 c 被用作一个比例因子，它决定了点在最终图像中看起来是近还是远。角度 `137.5` 与黄金比例和斐波那契角度相关，看起来最自然。您可以在链接的
    PDF 中了解更多相关信息。'
- en: 'To begin with, we define all the values that we discussed so far:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义到目前为止所讨论的所有值：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we create a Tkinter canvas and add colors to the `colors` list. We also
    create the dots using `create_oval` and save the reference to all ovals in the
    `dots` list:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个Tkinter画布，并将颜色添加到`colors`列表中。我们还使用`create_oval`创建点，并将所有椭圆的引用保存到`dots`列表中：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The color defined in the preceding code is based on the value of `r` and is
    purely arbitrary. We could have used any other variable or rule for defining the
    color.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码中定义的颜色是基于`r`的值，并且完全是任意的。我们本可以使用任何其他变量或规则来定义颜色。
- en: 'Lastly, we define the update function, which calculates the value of the `r`
    and `∅` values every 15 milliseconds and updates the coordinates of all the ovals
    on the canvas:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了更新函数，该函数每15毫秒计算`r`和`∅`的值，并更新画布上所有椭圆的坐标：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should now see the phyllotaxy pattern. Try changing all the parameters to
    see how the image changes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到叶序模式。尝试更改所有参数，看看图像如何变化。
- en: 3D graphics with Tkinter
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter的3D图形
- en: Tkinter's Canvas widget provides for drawing with exact coordinate specifications. Therefore,
    it can be used to create all sorts of 3D graphics. Furthermore, we have already
    seen the animation abilities of Tkinter. We can apply these abilities to also
    animate in 3D.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的Canvas小部件允许使用精确的坐标进行绘图。因此，它可以用来创建各种3D图形。此外，我们之前已经看到了Tkinter的动画功能。我们还可以将这些功能应用到3D动画中。
- en: Let's create a simple application where we create a cube in the center. We add
    event listeners to rotate the cube on mouse events. We also make a small animation
    in which the cube keeps rotating by itself when no mouse intervention occurs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的应用程序，在其中我们创建一个位于中心的立方体。我们添加事件监听器以在鼠标事件上旋转立方体。我们还制作了一个小动画，当没有鼠标干预时，立方体会自行旋转。
- en: 'In its final form, the application would look as follows (`8.13_3D_graphics.py`):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '在其最终形态下，应用程序将如下所示 (`8.13_3D_graphics.py`):'
- en: '![](img/dab367b8-d190-4fd3-bc90-e4d34f94ded1.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dab367b8-d190-4fd3-bc90-e4d34f94ded1.png)'
- en: 'Transposing or unzipping can be done in Python by using the special * operator,
    any point in a 3D space can be represented by *x*, *y*, and *z* coordinates. This
    is usually represented by a vector of the form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，通过使用特殊的 * 操作符可以进行转置或解压，任何三维空间中的点都可以用 *x*、*y* 和 *z* 坐标来表示。这通常表示为以下形式的向量：
- en: '![](img/245c7267-8d78-4f8c-b3f8-e95f79a1b053.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/245c7267-8d78-4f8c-b3f8-e95f79a1b053.png)'
- en: This is an example of a row vector as all three points are written in a single
    row.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行向量的例子，因为所有三个点都写在一行中。
- en: 'This is convenient for humans to read. However, as per convention and for some mathematical
    advantage that we will see later, positions are taken as a column vector. So it
    is written in a column as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这对人类阅读来说很方便。然而，按照惯例，并且为了某些我们稍后会看到的数学优势，位置被视为一个列向量。因此，它被写成如下列的形式：
- en: '![](img/dfda0a51-6d8d-4018-bee1-e7dd4a2ccda9.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfda0a51-6d8d-4018-bee1-e7dd4a2ccda9.png)'
- en: 'Since a shape is a collection of points, it is, therefore, a collection of
    column vectors. A collection of column vectors is a matrix, where each individual
    column of the matrix represents a single point in 3D space:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于形状是一系列点的集合，因此它本质上是一系列列向量的集合。一系列列向量构成了一个矩阵，其中矩阵的每一列代表3D空间中的一个单独的点：
- en: '![](img/39fe396f-ca68-4f28-8535-9c7100c7a2d1.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39fe396f-ca68-4f28-8535-9c7100c7a2d1.png)'
- en: 'Let''s take the example of a cube. A cube has eight defining vertices. A representative cube
    could have the following eight points with its center located at [*0*,*0*,*0*]:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个立方体为例。一个立方体有八个定义的顶点。一个代表性的立方体可以有以下八个点，其中心位于[*0*，*0*，*0*]：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'However, here the vertices are represented as row vectors. To represent the
    vectors as column vectors, we need to transpose the preceding matrix. Since transposition will
    be a common operation, let''s start by building a class called `MatrixHelpers`
    and defining a method named `transpose_matrix`( `8.13_3D_graphics.py`):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在这里顶点被表示为行向量。为了将向量表示为列向量，我们需要转置前面的矩阵。由于转置将是一个常见的操作，让我们首先创建一个名为 `MatrixHelpers`
    的类，并定义一个名为 `transpose_matrix`( `8.13_3D_graphics.py`): 的方法。'
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Transposing or unzipping can be done in Python by using the special `*` operator,
    which makes zip its own inverse.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以通过使用特殊的`*`运算符来实现转置或解压，这使得`zip`函数成为其自身的逆函数。
- en: 'Another issue with the preceding coordinates is that it centers at (*0*,*0*,*0*).
    This means that if we try to plot the preceding points on a canvas, it will show
    up only partly, centered at the top-left corner of the canvas, something like
    this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 前述坐标的另一个问题是它以 (*0*,*0*,*0*) 为中心。这意味着如果我们尝试在画布上绘制前述点，它只会部分显示，位于画布的左上角，类似于这样：
- en: '![](img/3691b678-dcc7-4559-8ddf-71bf07a5223d.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3691b678-dcc7-4559-8ddf-71bf07a5223d.png)'
- en: We need to move all the points to the center of the screen. We can achieve this
    by adding *x* and *y* offset values to the original matrix.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将所有点移动到屏幕中心。我们可以通过向原始矩阵添加*x*和*y*偏移值来实现这一点。
- en: 'We accordingly define a new method named `translate_matrix` as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义一个新的方法，命名为 `translate_matrix`，如下所示：
- en: '[PRE49]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now let''s draw the actual cube. We define a new class named `Cube` that inherits from
    the `MatrixHelper` class because we want to use the `transpose_matrix` and `translate_vector`
    methods defined in the `MatrixHelper` class (see `code 8.13_3D_graphics.py`):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来绘制实际的立方体。我们定义了一个名为 `Cube` 的新类，它继承自 `MatrixHelper` 类，因为我们想使用在 `MatrixHelper`
    类中定义的 `transpose_matrix` 和 `translate_vector` 方法（参见 `code 8.13_3D_graphics.py`）：
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `__init__` method simply calls four new methods. The `init_data` method
    sets the coordinate values for all the eight vertices of the cube (`8.13_3D_graphics.py`):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法简单地调用了四个新方法。`init_data` 方法设置了立方体所有八个顶点的坐标值（`8.13_3D_graphics.py`）：'
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `create_canvas` method creates a `400` x `400` sized canvas on top of the
    root window and assigns a background and fill color to the canvas:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_canvas` 方法在根窗口上创建一个 `400` x `400` 尺寸的画布，并为画布指定背景和填充颜色：'
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lastly, we define the `draw_cube `method, which uses `canvas.create_line` to
    draw lines between selected points. We do not want lines between all the points,
    but rather lines between some selected vertices to create a cube. We accordingly
    define the method as follows (`8.13_3D_graphics.py`):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`draw_cube`方法，该方法使用`canvas.create_line`在选定的点之间绘制线条。我们不想在所有点之间绘制线条，而是希望在选定的某些顶点之间绘制线条以形成一个立方体。因此，我们相应地定义了该方法，如下所示（`8.13_3D_graphics.py`）：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code draws a cube on the canvas. However, since the cube draws upfront,
    all we see is a square from the front. In order to see the cube, we need to rotate
    the cube to a different angle. That brings us to the topic of 3D transformations.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在画布上绘制了一个立方体。然而，由于立方体是优先绘制的，所以我们看到的是正面的一个正方形。为了看到立方体，我们需要将立方体旋转到不同的角度。这引出了3D变换的话题。
- en: A wide variety of 3D transformations, such as scaling, rotation, shearing, reflection,
    and orthogonal projections, can be accomplished by multiplying the shape matrix
    with another matrix known as a transformation matrix.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将形状矩阵与另一个称为变换矩阵的矩阵相乘，可以实现多种3D变换，例如缩放、旋转、剪切、反射和正交投影。
- en: 'For example, the transformation matrix for scaling a shape is:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，缩放形状的变换矩阵是：
- en: '![](img/063945c9-1566-4227-9861-69c36eb9efaa.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/063945c9-1566-4227-9861-69c36eb9efaa.png)'
- en: Where *S*[x], *S*[y], and *S*[z] are scaling factors in *x*, *y*, and *z* directions.
    Multiply any shape matrix with this matrix and you get the matrices for the scaled
    shape.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *S*[x]、*S*[y] 和 *S*[z] 分别是沿 *x*、*y* 和 *z* 方向的缩放因子。将任何形状矩阵与这个矩阵相乘，你就能得到缩放形状的矩阵。
- en: 'Let''s, therefore, add a new method named `matrix_multiply` to our `MatrixHelper` class
    (`8.13_3D_graphics.py`):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们向我们的`MatrixHelper`类（`8.13_3D_graphics.py`）中添加一个名为`matrix_multiply`的新方法：
- en: '[PRE54]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, let''s add the ability to rotate the cube. We will be using the rotation
    transformation matrix. Furthermore, since rotation can happen along any of the
    *x*, *y*, or *z* axes, there are actually three different transformation matrices.
    The three rotation matrices are as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加旋转立方体的功能。我们将使用旋转变换矩阵。此外，由于旋转可以沿着任何 *x*、*y* 或 *z* 轴进行，实际上存在三个不同的变换矩阵。以下为三个旋转矩阵：
- en: '![](img/4dcd5250-3d43-4975-9566-ea5afea1faa1.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dcd5250-3d43-4975-9566-ea5afea1faa1.png)'
- en: Multiply the shape coordinates by the first matrix for a given value of *a*
    and you get the shape rotated by an angle *a* about the *x *axis in a counterclockwise direction.
    Similarly, the other two matrices rotate along the *y *axis and *z *axis respectively.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将形状坐标乘以给定值 *a* 的第一个矩阵，你得到形状绕 *x* 轴逆时针旋转了角度 *a*。同样，其他两个矩阵分别绕 *y* 轴和 *z* 轴旋转。
- en: To rotate in a clockwise direction, we simply need to flip the sign of all sin
    values in the preceding matrix.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要按顺时针方向旋转，我们只需将前一个矩阵中所有正弦值的符号翻转即可。
- en: Note, however, that the order of rotation matters. So if you first rotate along
    the *x *axis and then rotate along the *y *axis, it is not the same as first rotating
    along *y* and then along the *x *axis.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，旋转的顺序很重要。所以如果你首先沿着*x*轴旋转，然后沿着*y*轴旋转，这和首先沿着*y*轴旋转，然后沿着*x*轴旋转是不一样的。
- en: More details on rotation matrices can be found at [https://en.wikipedia.org/wiki/Rotation_matrix](https://en.wikipedia.org/wiki/Rotation_matrix).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于旋转矩阵的详细信息可以在[https://en.wikipedia.org/wiki/Rotation_matrix](https://en.wikipedia.org/wiki/Rotation_matrix)找到。
- en: 'So now that we know the three rotation matrices, let''s define the following
    three methods in our `MatrixHelper` class (`8.13_3D_graphics.py`):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经知道了三个旋转矩阵，那么让我们在我们的`MatrixHelper`类（`8.13_3D_graphics.py`）中定义以下三个方法：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, we define a method named `continually_rotate` and call this method from the
    `__init__` method of our `Cube` class:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为 `continually_rotate` 的方法，并在我们的 `Cube` 类的 `__init__` 方法中调用此方法：
- en: '[PRE56]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The method uses `root.after` to call itself back every 15 milliseconds. At each
    loop, the coordinates of the cube are rotated by `0.01` degrees along all three
    axes. This is followed by a call to draw the cube with a fresh set of coordinates.
    Now, if you run this code, the cube rotates continuously.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用 `root.after` 每 15 毫秒调用自身。在每次循环中，立方体的坐标沿所有三个轴旋转 `0.01` 度。随后调用绘制立方体，使用一组新的坐标。现在，如果你运行此代码，立方体会持续旋转。
- en: Next, let's bind the rotation of the cube to a mouse button click and mouse
    motion. This will let the user rotate the cube by clicking and dragging the mouse
    over the cube.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将立方体的旋转绑定到鼠标按钮点击和鼠标移动。这样用户就可以通过点击并拖动鼠标在立方体上旋转立方体。
- en: 'Accordingly, we define the following method and call it from the `__init__`
    method of the `Cube` class:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义以下方法并将其命名为`Cube`类的`__init__`方法：
- en: '[PRE57]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The methods linked from the preceding event binding are defined as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个事件绑定中链接的方法定义如下：
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the preceding method maps mouse displacements along the *y *axis to rotations
    along the *x *axis and vice versa.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面提到的方法是将鼠标沿 *y* 轴的位移映射到沿 *x* 轴的旋转，反之亦然。
- en: Also, note that the last line of the code calls `on_mouse_clicked()` to update
    the value of `last_x` and `last_y`. If you skip that line, the rotation becomes
    exceedingly fast as you increase the displacement from the last clicked position.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意代码的最后一行调用了`on_mouse_clicked()`函数来更新`last_x`和`last_y`的值。如果你跳过那一行，当你从最后点击的位置增加位移时，旋转会变得极其快速。
- en: 'The method also refers to another method, named epsilon, which translates the distance
    into an equivalent angle for rotation. The epsilon method is defined as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还指代另一种名为epsilon的方法，该方法将距离转换为等效角度以进行旋转。epsilon方法定义如下：
- en: '[PRE59]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The epsilon here is obtained by multiplying the displacement, d, with an arbitrary value
    of 0.01\. You can increase or decrease the sensitivity of rotation to mouse displacement
    by changing this value.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所说的ε是通过将位移d与任意值0.01相乘得到的。您可以通过改变这个值来增加或减少旋转对鼠标位移的灵敏度。
- en: Now the cube becomes responsive to mouse click and drag over the canvas. This
    concludes the last project of this chapter.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，立方体对鼠标点击和拖动操作在画布上的响应。这标志着本章最后一个项目的结束。
- en: Here, we have just scratched the surface of 3D graphics. A much more detailed discussion
    on 3D programming with Tkinter can be found at [https://sites.google.com/site/3dprogramminginpython/](https://sites.google.com/site/3dprogramminginpython/).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是刚刚触及了3D图形的表面。有关使用Tkinter进行3D编程的更详细讨论，可以在[https://sites.google.com/site/3dprogramminginpython/](https://sites.google.com/site/3dprogramminginpython/)找到。
- en: There have also been attempts to further abstract and build 3D programming frameworks
    for Tkinter. You can find an example of a 3D framework for Tkinter at [https://github.com/calroc/Tkinter3D](https://github.com/calroc/Tkinter3D).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 也有尝试进一步抽象化并构建 Tkinter 的 3D 编程框架。你可以在 [https://github.com/calroc/Tkinter3D](https://github.com/calroc/Tkinter3D)
    找到一个 Tkinter 的 3D 框架示例。
- en: That concludes the chapter, and also our experiments with the Canvas widget.
    In the next chapter, we will look at some of the most commonly recurring themes
    of writing GUI applications, such as using a queue data structure, database programming,
    network programming, interprocess communication, use of the `asyncio` module,
    and a few other important concepts in programming.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容到此结束，同时也结束了我们对Canvas小部件的实验。在下一章中，我们将探讨编写GUI应用程序中最常见的一些主题，例如使用队列数据结构、数据库编程、网络编程、进程间通信、使用`asyncio`模块，以及编程中的一些其他重要概念。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's summarize the concepts we discussed in this chapter.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章讨论的概念。
- en: We built a screen saver and in the process saw how to implement animations on
    the Tkinter canvas. Next, we saw how to create Cartesian and polar plots on the
    canvas. We also saw how to embed `matplotlib` plots on a Tkinter window.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了一个屏幕保护程序，在这个过程中学习了如何在 Tkinter 画布上实现动画。接下来，我们看到了如何在画布上创建笛卡尔和极坐标图。我们还学习了如何将
    `matplotlib` 图表嵌入到 Tkinter 窗口中。
- en: We then implemented a basic gravity simulation that showed how we could take
    a physical model and implement it using a Tkinter canvas. We got a glimpse into
    the implementation of Voronoi diagrams, which are being used to model and solve
    so many practical real-world problems.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后实现了一个基本的引力模拟，展示了我们如何将一个物理模型通过Tkinter画布进行实现。我们窥见了沃罗诺伊图（Voronoi diagrams）的实现过程，这些图被用于模拟和解决许多实际世界的实际问题。
- en: We also build some nice visualizations such as the Mandelbrot set and Phyllotaxies.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还构建了一些漂亮的可视化效果，例如曼德布罗特集和叶形星系。
- en: Finally, we learned how to use a Tkinter canvas to draw and animate 3D graphics
    using transformation matrices.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用Tkinter画布通过变换矩阵来绘制和动画化3D图形。
- en: QA section
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: 'Here are a few questions to reflect upon:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题供您思考：
- en: How do you convert between polar and Cartesian coordinates? When should we prefer
    one coordinate system over the other?
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何将极坐标转换为笛卡尔坐标？在什么情况下我们应该优先选择一个坐标系而不是另一个？
- en: How do you animate on a Tkinter canvas? What determines the speed of the animation?
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何在Tkinter画布上动画化？什么决定了动画的速度？
- en: How do we model real-world phenomena on a Tkinter canvas using differential
    equations?
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用微分方程在Tkinter画布上模拟现实世界的现象？
- en: What are some real-world applications of fractals?
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分形在现实世界中有哪些应用？
- en: Fractals are still under active research. Can you find out more about some cutting-edge
    technology that relies on the use of fractals?
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分形仍在积极研究中。你能找出一些依赖分形使用的尖端技术吗？
- en: What are some of the real-world applications of Voronoi diagrams?
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Voronoi 图在现实世界中有哪些应用？
- en: How can we extend our 3D cube program to show meshes of other objects—say the
    model of a car, or a human body, or a real-world object?
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何将我们的3D立方体程序扩展以显示其他物体的网格——比如说汽车模型、人体或现实世界中的物体？
- en: Further reading
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A close cousin of the Mandelbrot set is the Julia set. Read about the Julia
    set and then modify `8.07_Mandelbrot.py` to produce a Julia set. Fractals are
    a very interesting topic to study and a lot of the maths behind them is still
    unexplored.  Besides the fact that they are beautiful to look at, they are also
    used in a lot of practical applications. See [https://en.wikipedia.org/wiki/Fractal#Applications_in_technology](https://en.wikipedia.org/wiki/Fractal#Applications_in_technology).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 曼德布罗集的近亲是朱利亚集。阅读有关朱利亚集的内容，然后修改`8.07_Mandelbrot.py`以生成朱利亚集。分形是一个非常有趣的研究主题，而且它们背后的许多数学问题仍然未被探索。除了它们看起来很美之外，它们还被广泛应用于许多实际应用中。参见[https://en.wikipedia.org/wiki/Fractal#Applications_in_technology](https://en.wikipedia.org/wiki/Fractal#Applications_in_technology)。
- en: If fractals pique your interest, you can also take a look at other variants
    of the Mandelbrot set such as the Magnet 1 fractal and Buddhabrot.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分形引起了你的兴趣，你还可以看看曼德布罗集的其他变体，例如磁铁1分形和佛陀分形。
- en: If you are interested in learning more about chaotic behavior, try to plot Hénon’s
    Function on a Tkinter canvas.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对学习混沌行为感兴趣，尝试在Tkinter画布上绘制Hénon函数。
- en: We modeled a spring pendulum and it worked in a deterministic manner. However,
    adding two pendulums together to form a double pendulum creates a dynamic system
    that is chaotic. Even though such systems follow the ordinary differential equation,
    the net outcome may vary immensely, even for a very small change in the initial
    condition. It may be worth trying to model a double pendulum by modifying our
    spring pendulum.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟了一个弹簧摆，它以确定性的方式工作。然而，将两个摆组合成一个双摆会形成一个混沌的动态系统。尽管这样的系统遵循常微分方程，但最终结果可能会因初始条件的微小变化而大幅变化。尝试通过修改我们的弹簧摆来模拟双摆可能值得尝试。
- en: 'We used the built-in odeint method from `scipy`. However, we could have written
    our own variation using either the Euler''s method or Runge-Kutta method. You
    can read more about these numerical methods for approximating ordinary differential
    equations over here:  [https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations.](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `scipy` 中的内置 `odeint` 方法。然而，我们也可以使用欧拉法或龙格-库塔法编写自己的变体。你可以在这里了解更多关于这些用于近似常微分方程的数值方法：[常微分方程的数值方法](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations)。
- en: 'If neat or intriguing visualizations looks like a fun thing to do,  here are
    a few more interesting canvas projects that you can undertake: Barnsley fern,
    the cellular automata, the Lorenz attractor, and simulating tearable cloth with
    verlet integration.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整洁或引人入胜的视觉呈现看起来像是一件有趣的事情去做，这里还有一些你可能会感兴趣的项目：巴恩斯利蕨叶、细胞自动机、洛伦兹吸引子，以及使用Verlet积分模拟可撕裂布料。
- en: Ray tracing is another powerful but very simple to implement 3D rendering technique
    that can be easily implemented in about 100 lines of code.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 光线追踪是一种强大但非常简单的3D渲染技术，可以轻松地在大约100行代码中实现。
