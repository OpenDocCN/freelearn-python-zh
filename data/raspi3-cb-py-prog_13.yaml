- en: Interfacing with Technology
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与技术接口
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Automating your home with remotely controlled electrical sockets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程控制插座自动化您的家庭
- en: Using SPI to control an LED matrix
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SPI控制LED矩阵
- en: Communicating using a serial interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用串行接口进行通信
- en: Controlling Raspberry Pi using Bluetooth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝牙控制树莓派
- en: Controlling USB devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制USB设备
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the key aspects of Raspberry Pi that differentiates it from an average
    computer is its ability to interface with and control hardware. In this chapter,
    we use Raspberry Pi to control remotely activated mains sockets, send commands
    over serial connections from another computer, and control the GPIO remotely.
    We make use of SPI (another useful protocol) to drive an 8 x 8 LED matrix display.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派区别于普通计算机的关键特性之一是它能够与硬件进行交互和控制。在本章中，我们使用树莓派远程控制带电插座，从另一台计算机通过串行连接发送命令，并远程控制GPIO。我们利用SPI（另一个有用的协议）来驱动8
    x 8 LED矩阵显示屏。
- en: We also use a Bluetooth module to connect with a smartphone, allowing information
    to be transferred wirelessly between devices. Finally, we take control of USB
    devices by tapping into the commands sent over USB.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用蓝牙模块与智能手机连接，允许设备之间无线传输信息。最后，我们通过访问通过USB发送的命令来控制USB设备。
- en: Be sure to check out the *Hardware list* section in the Appendix, *Hardware
    and Software List*; it lists all the items used in this chapter and the places
    you can obtain them from.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看附录中的“*硬件清单*”部分，即“*硬件和软件清单*”；它列出了本章中使用的所有物品及其获取地点。
- en: Automating your home with remotely controlled electrical sockets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程控制插座自动化您的家庭
- en: Raspberry Pi can make an excellent tool for home automation by providing accurate
    timing, control, and the ability to respond to commands, button inputs, environmental
    sensors, or messages from the internet.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派可以通过提供精确的时间控制、响应命令、按钮输入、环境传感器或来自互联网的消息的能力，成为家庭自动化的优秀工具。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Great care must be taken when controlling devices that use electricity from
    the mains, because high voltage and currents are often involved.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制使用市电的设备时必须格外小心，因为通常涉及高压和电流。
- en: Never attempt to modify or alter devices that are connected to mains electricity
    without proper training. You must never directly connect any homemade devices
    to the mains supply. All electronics must undergo rigorous safety testing to ensure
    that there will be no risk or harm to people or property in the event of a failure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在没有适当培训的情况下尝试修改或改变连接到主电源的设备。你绝对不能直接将任何自制设备连接到主电源。所有电子产品都必须经过严格的安全测试，以确保在发生故障的情况下不会对人员或财产造成风险或伤害。
- en: 'In this example, we will use remote-controlled **radio frequency** (**RF**)
    plug-in sockets; these use a separate remote unit to send a specific RF signal
    to switch any electrical device that is plugged into it on or off. This allows
    us to modify the remote control and use Raspberry Pi to activate the switches
    safely, without interfering with dangerous voltage:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用遥控**射频**（**RF**）插头插座；这些插座使用一个独立的遥控单元发送特定的射频信号来控制任何连接到它的电器设备的开关。这使我们能够修改遥控器并使用树莓派安全地激活开关，而不会干扰危险的电压：
- en: '![](img/f157e836-9b25-4b59-b943-4385f5d8472b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f157e836-9b25-4b59-b943-4385f5d8472b.png)'
- en: Remote control and remote mains socket
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控和远程主电源插座
- en: 'The particular remote control used in this example has six buttons on it to
    directly switch three different sockets on or off and is powered by a 12V battery.
    It can be switched into four different channels, which allows you to control a
    total of 12 sockets (each socket has a similar selector that will be used to set
    the signal it will respond to):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中使用的特定遥控器上有六个按钮，可以直接切换三个不同的插座的开或关，并由12V电池供电。它可以切换到四个不同的频道，这使得您能够控制总共12个插座（每个插座都有一个类似的选择器，将用于设置它将响应的信号）：
- en: '![](img/4172e58f-4bf5-4714-938a-c643c00c6e48.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4172e58f-4bf5-4714-938a-c643c00c6e48.png)'
- en: Inside the remote control
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在遥控器内部
- en: The remote buttons, when pressed, will broadcast a specific RF signal (this
    one uses a transmission frequency of 433.92 MHz). This will trigger any socket(s)
    that are set to the corresponding channel (A, B, C, or D) and number (1, 2, or
    3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下遥控按钮时，将广播一个特定的射频信号（本设备使用传输频率为433.92 MHz）。这将触发设置为相应通道（A、B、C或D）和编号（1、2或3）的任何插座。
- en: Internally, each of the buttons connects two separate signals to ground, the
    number (1, 2,
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，每个按钮将两个独立的信号连接到地，编号（1，2，
- en: 'or 3), and state (on or off). This triggers the correct broadcast that is to
    be made by the remote control:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者3)，并说明（开启或关闭）。这会触发遥控器要发出的正确广播：
- en: '![](img/38875392-df46-4627-bd70-098b26c51b77.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38875392-df46-4627-bd70-098b26c51b77.png)'
- en: Connect the wires to ON and OFF, 1, 2, and 3, and GND at suitable points on
    the remote's PCB (only ON, OFF, 1, and GND are connected in the image)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将电线连接到遥控器PCB板上的ON和OFF，1，2和3，以及GND合适的位置（图中只连接了ON，OFF，1和GND）
- en: It is recommended that you do not connect anything to your sockets that could
    cause a hazard if switched on or off. The signals sent by the remote are not unique
    (there are only four different channels available). This therefore makes it possible
    for someone else nearby who has a similar set of sockets to unknowingly activate/deactivate
    one of your sockets. It is recommended that you select a channel other than the
    default, A, which will slightly reduce the chance of someone else accidentally
    using the same channel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您不要将任何可能因开关而造成危险的物品连接到您的插座上。遥控器发送的信号不是唯一的（只有四个不同的频道可用）。因此，这使附近有类似插座组合的人在不经意间激活/关闭您的其中一个插座成为可能。建议您选择除默认频道A以外的频道，这将略微降低他人意外使用相同频道的机会。
- en: To allow Raspberry Pi to simulate the button presses of the remote, we will
    need five
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让树莓派模拟遥控器的按钮按下，我们需要五个
- en: 'relays to allow us to select the number (1, 2, or 3) and state (on or off):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 中继器使我们能够选择数字（1、2或3）和状态（开启或关闭）：
- en: '![](img/033eb712-9704-4532-927d-64cdac423a59.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/033eb712-9704-4532-927d-64cdac423a59.png)'
- en: A prebuilt relay module can be used to switch the signals
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 预制继电器模块可用于切换信号
- en: Alternatively, the transistor and relay circuit from [Chapter 12](df3bebe6-c2d8-492c-92bb-298cc2bf49d9.xhtml),
    *Building Robots*, can be used to simulate the button presses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用[第12章](df3bebe6-c2d8-492c-92bb-298cc2bf49d9.xhtml)“构建机器人”中的晶体管和继电器电路来模拟按钮的按下。
- en: 'Wire the relay control pins to the Raspberry Pi GPIO and connect the socket
    remote control to each relay output as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将继电器控制引脚连接到树莓派的GPIO，并将插座遥控器连接到每个继电器输出端，具体连接方式如下：
- en: '![](img/a9183efb-b4a0-4d7e-b8a9-36dcf7e75f8a.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9183efb-b4a0-4d7e-b8a9-36dcf7e75f8a.png)'
- en: The socket remote control circuit
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 插座遥控电路
- en: Although the remote socket requires both the number (1, 2, or 3) and the state
    (on or off) to activate a socket, it is the state signal that activates the RF
    transmission. To avoid draining the remote's battery, we must ensure that we have
    turned off the state signal.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管远程套接字需要同时指定数字（1、2或3）和状态（开启或关闭）来激活套接字，但真正激活射频传输的是状态信号。为了避免耗尽远程设备的电池，我们必须确保我们已经关闭了状态信号。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following `socketControl.py` script:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `socketControl.py` 脚本：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The socket control script performs a quick test by switching the first socket
    on for 5 seconds and then turning it off again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 端口控制脚本通过将第一个端口开启5秒钟然后再次关闭来进行快速测试。
- en: 'To control the rest of the sockets, create a GUI menu as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要控制其余的插槽，创建如下GUI菜单：
- en: '![](img/5273a07c-480a-432f-9047-e5f063374e78.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5273a07c-480a-432f-9047-e5f063374e78.png)'
- en: Remote Switches GUI
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 远程开关GUI
- en: 'Create the following `socketMenu.py` script:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `socketMenu.py` 脚本：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first script defines a class called `Switch`; it sets up the GPIO pins required
    to control the five relays (within the `setup` function). It also defines the
    `__enter__` and `__exit__` functions, which are special functions used by the
    `with..as` statement. When a class is created using `with..as`, it uses `__enter__`
    to perform any extra initialization or setup (if required), and then it performs
    any cleanup by calling `__exit__`. When the `Switch` class has been executed,
    all the relays are switched off to preserve the remote's battery and `GPIO.cleanup()`
    is called to release the GPIO pins. The parameters of the `__exit__` function
    (`type`, `value`, and `traceback`) allow the handling of any specific exceptions
    that may have occurred when the class was being executed within the `with..as`
    statement (if required).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本定义了一个名为 `Switch` 的类；它设置了控制五个继电器所需的 GPIO 引脚（在 `setup` 函数中）。它还定义了 `__enter__`
    和 `__exit__` 函数，这些是 `with..as` 语句使用的特殊函数。当使用 `with..as` 创建一个类时，它使用 `__enter__`
    来执行任何额外的初始化或设置（如果需要），然后通过调用 `__exit__` 来执行任何清理工作。当 `Switch` 类执行完毕后，所有继电器都会关闭以保护遥控器的电池，并调用
    `GPIO.cleanup()` 来释放 GPIO 引脚。`__exit__` 函数的参数（`type`、`value` 和 `traceback`）允许处理在
    `with..as` 语句中执行类时可能发生的任何特定异常（如果需要）。
- en: To control the sockets, create two functions that will switch the relevant relays
    on or off to activate the remote control to send the required signal to the sockets.
    Then, shortly after, turn the relays off again using `clear()`. To make controlling
    the switches even easier, create a `message` function that will allow a switch
    number and state to be specified.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制插座，创建两个函数，这些函数将切换相关的继电器以开或关，从而激活远程控制发送所需的信号到插座。然后，稍后使用 `clear()` 再次关闭继电器。为了使控制开关更加简便，创建一个
    `message` 函数，该函数将允许指定开关编号和状态。
- en: We make use of the `socketControl.py` script by creating a Tkinter GUI menu.
    The menu is made up of three sets of controls (one for each of the switches) that
    are defined by the `swButtons` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个Tkinter GUI菜单来使用`socketControl.py`脚本。该菜单由三组控制（每个开关一组）组成，这些控制由`swButtons`类定义。
- en: The `swButtons` class creates a `Tkinter` button and two `Radiobutton` controls.
    Each `swButtons` object is given an index and a reference to the `mySwitches`
    object. This allows us to set a name for the button and control a particular switch
    when it is pressed. The socket is activated/deactivated by calling `message()`,
    with the required switch number and state set by the `Radiobutton` controls.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`swButtons` 类创建了一个 `Tkinter` 按钮 和两个 `Radiobutton` 控件。每个 `swButtons` 对象都会分配一个索引和一个对
    `mySwitches` 对象的引用。这使得我们可以为按钮设置一个名称，并在按下时控制特定的开关。通过调用 `message()` 函数来激活/停用套接字，所需的开关号和状态由
    `Radiobutton` 控件设置。'
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The previous example allows you to rewire the remotes of most remote-controlled
    sockets, but another option is to emulate the signals to control it directly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子允许您重新布线大多数遥控插座的遥控器，但另一个选择是模拟信号以直接控制它。
- en: Sending RF control signals directly
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接发送射频控制信号
- en: 'Instead of rewiring the remote control, you can replicate the remote''s RF
    signals using a transmitter that uses the same frequency as your sockets (these
    particular units use 433.94 MHz). This will depend on the particular sockets and
    sometimes your location – some countries prohibit the use of certain frequencies
    – as you may require certification before making your own transmissions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需重新布线遥控器，可以使用与你的插座相同频率的发射器来复制遥控器的射频信号（这些特定的设备使用433.94 MHz）。这取决于特定的插座，有时也取决于你的位置——一些国家禁止使用某些频率——在你自行发射之前，你可能需要获得认证：
- en: '![](img/3029bc19-2d83-4b74-a964-ca2c2e6e078d.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3029bc19-2d83-4b74-a964-ca2c2e6e078d.png)'
- en: The 433.94 MHz RF transmitter (left) and receiver (right)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 433.94 MHz 射频发射器（左侧）和接收器（右侧）
- en: The signals sent by the RF remote control can be recreated using 433Utils created
    by
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由433Utils创建的射频遥控器发送的信号可以被重新创建，其中433Utils是由
- en: '[http://ninjablocks.com](http://ninjablocks.com). The 433Utils uses WiringPi
    and is written in C++, allowing high speed capture and replication of the RF signals.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://ninjablocks.com](http://ninjablocks.com). 433Utils 使用 WiringPi，并以 C++
    编写，允许高速捕获和复制射频信号。'
- en: 'Obtain the code using the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取代码：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we need to wire up our RF transmitter (so we can control the switches)
    and RF receiver (so we can determine the control codes) to the Raspberry Pi.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的射频发射器（以便我们可以控制开关）和射频接收器（以便我们可以确定控制代码）连接到树莓派上。
- en: The transmitter (the smaller square module) has three pins, which are power
    (VCC), ground (GND), and data out (DATA). The voltage supplied on the power pin
    will govern the transmission range (we will use a 5V supply from Raspberry Pi,
    but you could replace this with 12V, as long as you ensure you connect the ground
    pin to both your 12V supply and Raspberry Pi).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器（较小的方形模块）有三个引脚，分别是电源（VCC）、地（GND）和数据输出（DATA）。电源引脚上提供的电压将决定传输范围（我们将使用来自树莓派的5V电源，但你也可以将其替换为12V，只要确保将地引脚连接到你的12V电源和树莓派）。
- en: 'Although the receiver has four pins, there is a power pin (VCC), ground pin
    (GND), and two data out pins (DATA), which are wired together, so we only need
    to connect three wires to Raspberry Pi:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管接收器有四个引脚，但其中有一个电源引脚（VCC）、一个地线引脚（GND）和两个数据输出引脚（DATA），这些引脚是连接在一起的，因此我们只需要连接三根线到树莓派：
- en: '| **RF Tx** | **RPi GPIO pin** | **RF Rx** | **RPi GPIO pin** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **射频发送** | **RPi GPIO 引脚** | **射频接收** | **RPi GPIO 引脚** |'
- en: '| VCC (5V) | 2 | VCC (3V3) | 1 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| VCC (5V) | 2 | VCC (3V3) | 1 |'
- en: '| Data out | 11 | Data in | 13 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 数据输出 | 11 | 数据输入 | 13 |'
- en: '| GND | 6 | GND | 9 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| GND | 6 | GND | 9 |'
- en: Before we use the programs within the `RPi_Utils`, we will make a few adjustments
    to ensure our RX and TX pins are set correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`RPi_Utils`中的程序之前，我们将进行一些调整以确保我们的RX和TX引脚设置正确。
- en: 'Locate `codesend.cpp` in `433Utils-master/RPi_utils/` to make the required
    changes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `433Utils-master/RPi_utils/` 目录下定位 `codesend.cpp` 文件以进行必要的修改：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Change `int PIN = 0;` (located at around line 24) to `int PIN = 11;` (RPi physical
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将`int PIN = 0;`（位于大约第24行）更改为`int PIN = 11;`（RPi物理
- en: pin number).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 验证码（pin number）。
- en: 'Change `wiringPi` to use physical pin numbering (located around line 27) by
    replacing `wiringPiSetup()` with `wiringPiSetupPhy()`. Otherwise, the default
    is `wiringPi` GPIO numbers; for more details, see [http://wiringpi.com/reference/setup/](http://wiringpi.com/reference/setup/).
    Find the following line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `wiringPi` 改为使用物理引脚编号（位于第27行）通过将 `wiringPiSetup()` 替换为 `wiringPiSetupPhy()`。否则，默认为
    `wiringPi` GPIO编号；更多详情，请参阅[http://wiringpi.com/reference/setup/](http://wiringpi.com/reference/setup/)。找到以下行：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Change it to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这个：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save and exit `nano` using *Ctrl* + *X*, *Y*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *X*, *Y* 保存并退出 `nano`。
- en: 'Make similar adjustments to `RFSniffer.cpp`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `RFSniffer.cpp` 进行类似的调整：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Find the following line (located at around line 25):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以下行（位于大约第25行）：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change it to this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这个：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Find the following line (located at around line 27):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 找到以下行（位于大约第27行）：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change it to this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 改成这个：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save and exit `nano` using *Ctrl* + *X*, *Y*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *X*, *Y* 保存并退出 `nano`。
- en: 'Build the code using the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建代码：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This should build without errors, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该可以无错误地构建，如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have our RF modules connected to Raspberry Pi and our code ready,
    we can capture the control signals from our remote. Run the following command
    and take note of the reported output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将RF模块连接到树莓派，并且代码已经准备就绪，我们可以从我们的遥控器捕获控制信号。运行以下命令并注意报告的输出：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Get the output by switching button 1 OFF with the remote set to channel A (note
    that we may pick up some random noise):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将按钮1关闭，并将遥控器设置为频道A来获取输出（注意我们可能会接收到一些随机噪音）：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now send out the signals using the `sendcode` command to switch the
    sockets OFF (`1381716`) and ON (`1381719`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`sendcode`命令发送信号来切换套接字关闭（`1381716`）和开启（`1381719`）：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You could even set up Raspberry Pi to use the receiver module to detect signals
    from the remote (on an unused channel) and to act upon them to start processes,
    control other hardware, or perhaps trigger a software shutdown/reboot.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以设置树莓派，使用接收模块来检测来自遥控器（在未使用的频道上）的信号，并根据这些信号启动进程、控制其他硬件，或者可能触发软件的关机/重启。
- en: Extending the range of the RF transmitter
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展射频发射机的范围
- en: The range of the transmitter is very limited when it is powered by 5V and without
    an additional antenna. However, it is worth testing everything before you make
    any modifications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当发射器由5V供电且没有附加天线时，其传输范围非常有限。然而，在做出任何修改之前，测试一切是值得的。
- en: 'Simple wire antenna can be made from 25 cm of single core wire, 17 mm side
    connected to the antenna solder point, then 16 turns (made using a thin screwdriver
    shaft or similar) and the remaining wire on top (approximately 53 mm):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的线状天线可以用25厘米的单芯线制成，17毫米的一端连接到天线焊接点，然后绕16圈（使用细螺丝刀柄或类似物品制作），剩余的线在上面（大约53毫米）：
- en: '![](img/23e8cd0a-11fe-46ab-b349-65ec56983419.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23e8cd0a-11fe-46ab-b349-65ec56983419.png)'
- en: The transmitter range is vastly improved with a simple antenna
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的天线，发射器的范围得到了极大的提升
- en: Determining the structure of the remote control codes
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定遥控码的结构
- en: 'Recording the codes for each of the buttons, we can determine the codes for
    each (and break down the structure):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记录每个按钮的代码，我们可以确定每个按钮的代码（并分解其结构）：
- en: '|  | **1** | **2** | **3** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '|  | **ON** | **OFF** | **ON** | **OFF** | **ON** | **OFF** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  | **开启** | **关闭** | **开启** | **关闭** | **开启** | **关闭** |'
- en: '| **A** | `0x15 15 57``(1381719)` | `0x15 15 54``(1381716)` | `0x15 45 57``(1394007)`
    | `0x15 45 54``(1394004)` | `0x15 51 57``(1397079)` | `0x15 51 54``(1397076)`
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **A** | `0x15 15 57`(1381719) | `0x15 15 54`(1381716) | `0x15 45 57`(1394007)
    | `0x15 45 54`(1394004) | `0x15 51 57`(1397079) | `0x15 51 54`(1397076) |'
- en: '| **B** | `0x45 15 57``(4527447)` | `0x45 15 54``(4527444)` | `0x45 45 57``(4539735)`
    | `0x45 45 54``(4539732)` | `0x45 51 57``(4542807)` | `0x45 51 54``(4542804)`
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **B** | `0x45 15 57`(4527447) | `0x45 15 54`(4527444) | `0x45 45 57`(4539735)
    | `0x45 45 54`(4539732) | `0x45 51 57`(4542807) | `0x45 51 54`(4542804) |'
- en: '| **C** | `0x51 15 57``(5313879)` | `0x51 15 54``(5313876)` | `0x51 45 57``(5326167)`
    | `0x51 45 54``(5326164)` | `0x51 51 57``(5329239)` | `0x51 51 54``(5329236)`
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **C** | `0x51 15 57`(5313879) | `0x51 15 54`(5313876) | `0x51 45 57`(5326167)
    | `0x51 45 54`(5326164) | `0x51 51 57`(5329239) | `0x51 51 54`(5329236) |'
- en: '| **D** | `0x54 15 57``(5510487)` | `0x54 15 57``(5510487)` | `0x54 45 57``(5522775)`
    | `0x54 45 54``(5522772)` | `0x54 51 57``(5525847)` | `0x54 51 54``(5526612)`
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **D** | `0x54 15 57`(5510487) | `0x54 15 57`(5510487) | `0x54 45 57`(5522775)
    | `0x54 45 54`(5522772) | `0x54 51 57`(5525847) | `0x54 51 54`(5526612) |'
- en: '| **A** | **B** | **C** | **D** | **1** | **2** | **3** | **na** | **na** |
    **na** | **na** | **ON/OFF** |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 11/00 |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 01 | 11/00 |  |'
- en: The different codes are shown in hex format to help you see the structure; the
    sendcode command uses the decimal format (shown within the parentheses)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的代码以十六进制格式显示，以便您查看其结构；`sendcode`命令使用十进制格式（括号内显示）
- en: To select channel A, B, C, or D, set the two bits to 00\. Similarly, for button
    1, 2, or 3, set the two bits to 00 to select that button. Finally, set the last
    two bits to 11 for ON or 00 for OFF.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择通道 A、B、C 或 D，将两个位设置为 00。同样，对于按钮 1、2 或 3，将两个位设置为 00 以选择该按钮。最后，将最后两个位设置为 11
    以表示开启或 00 以表示关闭。
- en: See [https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/](https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/),
    which analyses these and other similar RF remote controls.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/](https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-for-your-arduino/)，该页面分析了这些以及其他类似的射频遥控器。
- en: Using SPI to control an LED matrix
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPI控制LED矩阵
- en: In [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml), *Sensing and Displaying
    Real-World Data*, we connected to devices using a bus protocol called I²C. Raspberry
    Pi also supports another chip-to-chip protocol called **Serial Peripheral Interface** (**SPI**).
    The SPI bus differs from I²C because it uses two single direction data lines (where
    I²C uses one bidirectional data line).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)《感知与显示现实世界数据》中，我们使用了一种名为I²C的总线协议连接到设备。树莓派还支持另一种称为**串行外设接口**（**SPI**）的芯片间协议。SPI总线与I²C的不同之处在于它使用两条单向数据线（而I²C使用一条双向数据线）。
- en: 'Although SPI requires more wires (I²C uses two bus signals, SDA and SCL), it
    supports the simultaneous sending and receiving of data and much higher clock
    speeds than I²C:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SPI需要更多的线（I²C使用两条总线信号，SDA和SCL），但它支持数据的同步发送和接收，并且比I²C具有更高的时钟速度：
- en: '![](img/afdd071d-ff0c-4244-b67d-c6e54625ebb5.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afdd071d-ff0c-4244-b67d-c6e54625ebb5.png)'
- en: General connections of SPI devices with Raspberry Pi
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: SPI设备与树莓派的通用连接
- en: 'The SPI bus consists of the following four signals:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线由以下四个信号组成：
- en: '**SCLK**: This allows the clock edges to read/write data on the input/output
    lines; it is driven by the master device. As the clock signal changes from one
    state to another, the SPI device will check the state of the MOSI signal to read
    a single bit. Similarly, if the SPI device is sending data, it will use the clock
    signal edges to synchronize when it sets the state of the MISO signal.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SCLK**: 这允许时钟边缘在输入/输出线上读写数据；它由主设备驱动。当时钟信号从一个状态变化到另一个状态时，SPI设备将检查MOSI信号的状态以读取一个比特。同样地，如果SPI设备正在发送数据，它将使用时钟信号边缘来同步设置MISO信号状态的时刻。'
- en: '**CE**: This refers to Chip Enable (typically, a separate Chip Enable is used
    for each slave device on the bus). The master device will set the Chip Enable
    signal to low for the device that it wants to communicate with. When the Chip
    Enable signal is set to high, it ignores any other signals on the bus. This signal
    is sometimes called **Chip Select** (**CS**) or **Slave Select** (**SS**).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CE**：这指的是芯片使能（通常，在总线上为每个从设备使用一个单独的芯片使能）。主设备会将芯片使能信号设置为低电平，以便与它想要通信的设备通信。当芯片使能信号设置为高电平时，它会忽略总线上的任何其他信号。这个信号有时被称为**芯片选择**（**CS**）或**从设备选择**（**SS**）。'
- en: '**Master Output, Slave Input (MOSI)**: It connects to Data Out of the master
    device and Data In of the slave device.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主输出，从输入（MOSI）**：它连接到主设备的数据输出和从设备的数据输入。'
- en: '**Master Input, Slave Output (MISO)**: It provides a response from the slave.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主输入从输出（MISO）**：它提供从从设备（slave）的响应。'
- en: 'The following diagram shows each of the signals:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了每个信号：
- en: '![](img/f412c562-9822-401e-b6b9-3d9246592b93.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f412c562-9822-401e-b6b9-3d9246592b93.png)'
- en: 'The SPI signals: SCLK (1), CE(2), MOSI(3), and MISO(4)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SPI信号：SCLK（1）、CE（2）、MOSI（3）和MISO（4）
- en: 'The previous scope trace shows two bytes being sent over SPI. Each byte is
    clocked into the SPI device using the **SCLK (1)** signal. A byte is signified
    by a burst of eight clock cycles (a low and then high period on the **SCLK (1)**
    signal), where the value of a specific bit is read when the clock state changes.
    The exact sample point is determined by the clock mode; in the following diagram,
    it is when the clock goes from low to high:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的范围跟踪显示了通过SPI发送的两个字节。每个字节都通过**SCLK (1)**信号被时钟到SPI设备中。一个字节由八个时钟周期的一阵（**SCLK
    (1)**信号上的低电平和随后的高电平）表示，当时钟状态改变时读取特定位的值。确切的采样点由时钟模式决定；在下面的图中，它是在时钟从低电平变为高电平时：
- en: '![](img/0b4b046d-1e37-4fea-aa27-22c79ee2b224.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b4b046d-1e37-4fea-aa27-22c79ee2b224.png)'
- en: The first data byte sent by Raspberry Pi to the SPI device using the MOSI(3)
    signal
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 通过 MOSI(3) 信号发送的第一个数据字节
- en: The first byte sent is 0x01 (all the bits are low, except **Bit 0**) and the
    second sent is 0x03 (only **Bit 1** and **Bit 0** are high). At the same time,
    the **MOSI (4)** signal returns data from the SPI device-in this case, 0x08 (**Bit
    3** is high) and 0x00 (all the bits are low). The **SCLK (1)** signal is used
    to sync everything, even the data being sent from the SPI device.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的第一个字节是 0x01（所有位都是低电平，除了**位 0**）和第二个发送的是 0x03（只有**位 1**和**位 0**是高电平）。同时，**MOSI
    (4**) 信号从 SPI 设备返回数据——在这种情况下，0x08（**位 3**是高电平）和 0x00（所有位都是低电平）。**SCLK (1**) 信号用于同步一切，甚至包括从
    SPI 设备发送的数据。
- en: The **CE (2)** signal is held low while the data is being sent to instruct that
    particular SPI device to listen to the **MOSI (4)** signal. When the **CE (2)**
    signal is set to high again, it indicates to the SPI device that the transfer
    has been completed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据正在发送到特定SPI设备以指示其监听**MOSI (4)**信号时，**CE (2)**信号被保持低电平。当**CE (2)**信号再次设置为高电平时，它向SPI设备指示传输已完成。
- en: 'The following is an image of an 8 x 8 LED matrix that is controlled via the
    **SPI Bus**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个由**SPI总线**控制的8 x 8 LED矩阵的图像：
- en: '![](img/7f668052-ccd1-451a-9e01-811859262828.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f668052-ccd1-451a-9e01-811859262828.png)'
- en: An 8 x 8 LED module displaying the letter K
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示字母K的8 x 8 LED模块
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `wiringPi` library that we used previously for I²C also supports SPI. Ensure
    that `wiringPi` is installed (see [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml),
    *Sensing and Displaying Real-World Data*, for details) so that we can use it here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前用于 I²C 的 `wiringPi` 库也支持 SPI。请确保已安装 `wiringPi`（详情请见[第 10 章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)，*感知和显示现实世界数据*），以便我们在此处使用。
- en: 'Next, we need to enable SPI if we didn''t do so when we enabled I²C previously:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们之前在启用 I²C 时没有这样做，我们需要启用 SPI：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Remove the `#` before `#dtparam=spi=on` to enable it, so it reads, and save
    (*Ctrl* + *X*, *Y*, *Enter*):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 移除`#`前的`#dtparam=spi=on`以启用它，使其读取，并保存（*Ctrl* + *X*，*Y*，*Enter*）：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can confirm that the SPI is active by listing all the running modules using
    the following command and locating `spi_bcm2835`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下命令列出所有正在运行的模块，并定位到 `spi_bcm2835` 来确认 SPI 是否处于活动状态：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can test the SPI with the following `spiTest.py` script:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下 `spiTest.py` 脚本测试 SPI：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Connect inputs **19** and **21** to create an SPI loopback for testing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入**19**和**21**连接起来以创建用于测试的SPI环回：
- en: '![](img/1fc6523a-7814-4fbd-8c0c-09e4dbc2af52.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fc6523a-7814-4fbd-8c0c-09e4dbc2af52.png)'
- en: The SPI loopback test
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: SPI环回测试
- en: 'You should get the following result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下结果：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The example that follows uses an LED 8 x 8 matrix display that is being driven
    by an
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子使用了一个由LED 8 x 8矩阵显示器，该显示器正在被驱动
- en: 'SPI-controlled **MAX7219 LED driver**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SPI控制的**MAX7219 LED驱动器**：
- en: '![](img/a18157d2-1ba5-449a-a279-3f5d5dfce1b5.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a18157d2-1ba5-449a-a279-3f5d5dfce1b5.png)'
- en: An LED Controller MAX7219 pin-out, LED matrix pin-out, and LED matrix internal
    wiring (left to right)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: MAX7219 LED控制器引脚图、LED矩阵引脚图以及LED矩阵内部连接（从左到右）
- en: 'Although the device has been designed to control eight separate seven-segment
    LED digits, we can use it for our LED matrix display. When used for digits, each
    of the seven segments (plus a decimal place) is wired to one of the SEG pins and
    the COM connection of each of the digits is wired to the DIG pins. The controller
    then switches each of the segments on as required, while setting the relevant
    digit COM to low to enable it. The controller can quickly cycle through each of
    the digits using the DIG pin quickly enough that all eight appear to be lit at
    the same time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该设备被设计用来控制八个独立的七段LED数码管，但我们仍可以用它来制作我们的LED矩阵显示屏。当用于数码管时，每个七段（加上小数点）都连接到一个SEG引脚上，每个数码管的COM连接则连接到DIG引脚上。控制器随后根据需要打开每个段，同时将相关数码管的COM设置为低电平以启用它。控制器可以通过快速切换DIG引脚来快速循环每个数码管，以至于所有八个数码管看起来同时点亮：
- en: '![](img/046af381-a802-4f12-a6a4-8187b2941489.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/046af381-a802-4f12-a6a4-8187b2941489.png)'
- en: A seven-segment LED digit uses segments A to G, plus DP (decimal place)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个七段LED数码管使用段A到G，加上小数点DP（decimal place）
- en: We use the controller in a similar way, except each SEG pin will connect to
    a column in the matrix and the DIG pins will enable/disable a row.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似的方式使用控制器，除了每个 SEG 引脚将连接到矩阵中的一列，而 DIG 引脚将启用/禁用一行。
- en: 'We use an 8 x 8 module connected to the MAX7219 chip as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个8 x 8模块，如下连接到MAX7219芯片：
- en: '![](img/67c17366-1d28-48d8-a6a5-a64c97fe129a.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67c17366-1d28-48d8-a6a5-a64c97fe129a.png)'
- en: The MAX7219 LED controller driving an 8 x 8 LED matrix display
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动8 x 8 LED矩阵显示屏的MAX7219 LED控制器
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To control an LED matrix connected to an SPI MAX7219 chip, create the following
    `matrixControl.py` script:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要控制连接到SPI MAX7219芯片的LED矩阵，创建以下`matrixControl.py`脚本：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Running the script (`python3 matrixControl.py`) displays the letter `K`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本(`python3 matrixControl.py`)会显示字母`K`。
- en: 'We can use a GUI to control the output of the LED matrix using `matrixMenu.py`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用图形用户界面（GUI）通过`matrixMenu.py`来控制LED矩阵的输出：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Matrix GUI allows us to switch each of the LEDs on/off by clicking on each
    of the squares (or by directly entering the hexadecimal value) to create the required
    pattern:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵GUI允许我们通过点击每个方块（或直接输入十六进制值）来切换每个LED的开关状态，以创建所需的图案：
- en: '![](img/24ec196a-5ac9-4b64-8920-4f0855eaeb4c.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24ec196a-5ac9-4b64-8920-4f0855eaeb4c.png)'
- en: Using the Matrix GUI to control the 8 x 8 LED matrix
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Matrix GUI控制8 x 8 LED矩阵
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Initially, we defined addresses for each of the control registers used by the
    MAX7219 device. View the datasheet at for more information:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们为MAX7219设备使用的每个控制寄存器定义了地址。查看数据表以获取更多信息：
- en: '[https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf](https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf](https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf).'
- en: We created a class called `matrix` that will allow us to control the module.
    The `__init__()` function sets up the SPI of Raspberry Pi (using `SPI_CS` as pin
    26 CS1 and `SPI_SPEED` as 100 kHz).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `matrix` 的类，这将使我们能够控制该模块。`__init__()` 函数设置了树莓派的 SPI（使用 `SPI_CS` 作为引脚
    26 的 CS1，并将 `SPI_SPEED` 设置为 100 kHz）。
- en: 'The key function in our `matrix` class is the `sendCmd()` function; it uses
    `wiringpi.wiringPiSPIDataRW(SPI_CS,buff)` to send `buffer` (which is the raw byte
    data that we want to send) over the SPI bus (while also setting the `SPI_CS` pin
    to low when the transfer occurs). Each command consists of two bytes: the first
    specifies the address of the register, and the second sets the data that needs
    to be put into it. To display a row of lights, we send the address of one of the
    `ROW` registers (`MC.MAX7219_DIGIT`) and the bit-pattern we want to display (as
    a byte).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`matrix`类中的关键功能是`sendCmd()`函数；它使用`wiringpi.wiringPiSPIDataRW(SPI_CS,buff)`来通过SPI总线发送`buffer`（这是我们想要发送的原始字节数据），在传输发生时也将`SPI_CS`引脚设置为低电平。每个命令由两个字节组成：第一个字节指定寄存器的地址，第二个字节设置需要放入的数据。为了显示一排灯光，我们发送一个`ROW`寄存器（`MC.MAX7219_DIGIT`）的地址以及我们想要显示的位模式（作为一个字节）。
- en: After the `wiringpi.wiringPiSPIDataRW()` function is called, `buffer` contains
    the result of whatever is received on the MISO pin (which is read simultaneously
    as the data is sent via the MOSI pin). If connected, this will be the output of
    the LED module (a delayed copy of the data that was sent). Refer to the following
    *There's more...* section regarding daisy-chained SPI configurations to learn
    how the chip output can be used.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`wiringpi.wiringPiSPIDataRW()`函数之后，`buffer`变量包含了从MISO引脚（在数据通过MOSI引脚发送的同时读取）接收到的任何结果。如果连接了，这将是对LED模块的输出（发送数据的延迟副本）。有关如何使用芯片输出的信息，请参阅以下*更多内容...*部分，了解有关串行外设接口（SPI）配置的菊花链设置。
- en: To initialize the MAX7219, we need to ensure that it is configured in the correct
    mode. First, we set the Scan Limit field to `7` (which enables all the DIG0 -
    DIG7 outputs). Next, we disable the built-in digit decoding since we are using
    the raw output for the display (and don't want it to try to display digits). We
    also want to ensure that the `MAX7219_DISPLAYTEST` register is disabled (if enabled,
    it would turn on all the LEDs).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 MAX7219，我们需要确保它配置在正确的模式。首先，我们将扫描限制字段设置为 `7`（这将启用所有 DIG0 - DIG7 输出）。接下来，我们禁用内置的数字解码，因为我们正在使用原始输出进行显示（并且不希望它尝试显示数字）。我们还想确保
    `MAX7219_DISPLAYTEST` 寄存器被禁用（如果启用，它将点亮所有 LED）。
- en: We ensure the display is cleared by calling our own `clear()` function, which
    sends `0`
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用自己的`clear()`函数来确保显示被清除，该函数发送`0`
- en: to each of the `MAX7219_DIGIT` registers to clear each of the rows. Finally,
    we use the `MAX7219_INTENSITY` register to set the brightness of the LEDs. The
    brightness is controlled using a PWM output to make the LEDs appear brighter or
    darker according to the brightness that is required.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 向每个`MAX7219_DIGIT`寄存器发送指令以清除每一行。最后，我们使用`MAX7219_INTENSITY`寄存器来设置LED的亮度。亮度通过PWM输出进行控制，以使LED根据所需的亮度显得更亮或更暗。
- en: 'Within the `main()` function, we perform a quick test to display the letter
    K on the grid by sending a set of 8 bytes (`0x0066763e1e366646`):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们通过发送一组8个字节（`0x0066763e1e366646`）来执行快速测试，以在网格上显示字母K：
- en: '![](img/7a631f4d-d84f-4dd3-a1d4-f49476f7735c.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a631f4d-d84f-4dd3-a1d4-f49476f7735c.png)'
- en: Each 8 x 8 pattern consists of 8 bits in 8 bytes (one bit for each column, making
    each byte a row in the display)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个8 x 8图案由8个字节的8位组成（每个列对应一个位，使得每个字节成为显示屏中的一行）
- en: The `matrixGUI` class creates a canvas object that is populated with a grid
    of rectangle objects to represent the 8 x 8 grid of LEDs we want to control (these
    are kept in `self.light`). We also add a text entry box to display the resulting
    bytes that we will send to the LED matrix module. We then bind the `<Button-1>`
    mouse event to the canvas so that `mouseClick` is called whenever a mouse click
    occurs within the area of the canvas.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrixGUI` 类创建了一个画布对象，该对象填充了一个矩形对象的网格，以表示我们想要控制的 8 x 8 LED 网格（这些保存在 `self.light`
    中）。我们还添加了一个文本输入框来显示我们将发送到 LED 矩阵模块的结果字节。然后我们将 `<Button-1>` 鼠标事件绑定到画布上，以便在画布区域内发生鼠标点击时调用
    `mouseClick`。'
- en: We attach a function called `changedCode()` to the `codeText` variable using
    `trace`, a special Python function, which allows us to monitor specific variables
    or functions. If we use the `'w'` value with the `trace` function, the Python
    system will call the `callback` function whenever the value is written to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用特殊的 Python 函数 `trace` 将一个名为 `changedCode()` 的函数附加到 `codeText` 变量上，这允许我们监控特定的变量或函数。如果我们使用
    `trace` 函数的 `'w'` 值，Python 系统将在值被写入时调用 `callback` 函数。
- en: When the `mouseClick()` function is called, we use the `event.x` and `event.y`
    coordinates to identify the object that is located there. If an item is detected,
    then the ID of the item is used (via `toggleLight()`) to toggle the corresponding
    bit in the `self.lightStatus` value, and the color of the light in the display
    changes accordingly (via `setLight()`). The `codeText` variable is also updated
    with the new hexadecimal representation of the `lightStatus` value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `mouseClick()` 函数时，我们使用 `event.x` 和 `event.y` 坐标来识别位于那里的对象。如果检测到项目，则使用项目的
    ID（通过 `toggleLight()`）来切换 `self.lightStatus` 值中的相应位，并且显示中的灯光颜色相应地改变（通过 `setLight()`）。同时，`codeText`
    变量也会更新为 `lightStatus` 值的新十六进制表示。
- en: The `changeCode()` function allows us to use the `codeText` variable and translate
    it into an integer. This allows us to check whether it is a valid value. Since
    it is possible to enter text here freely, we must validate it. If we are unable
    to convert it to an integer, the `codeValue` text is refreshed using the `lightStatus`
    value. Otherwise, we check if it is too large, in which case we perform a bit-shift
    by 4 to divide it by 16 until it is within a valid range. We update the `lightStatus`
    value, the GUI lights, the `codeText` variable, and also the hardware (by calling
    `updateHardware()`).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeCode()` 函数允许我们使用 `codeText` 变量并将其转换为整数。这使我们能够检查它是否是一个有效的值。由于在这里可以自由输入文本，我们必须对其进行验证。如果我们无法将其转换为整数，则使用
    `lightStatus` 值刷新 `codeValue` 文本。否则，我们检查它是否过大，在这种情况下，我们通过4位位移操作将其除以16，直到它在有效范围内。我们更新
    `lightStatus` 值、GUI 灯光、`codeText` 变量，以及硬件（通过调用 `updateHardware()`）。'
- en: The `updateHardware()` function makes use of the `myMatrixHW` object that was
    created using the `MC.matrix` class. We send the bytes that we want to display
    to the matrix hardware one byte at a time (along with the corresponding `MAX7219_DIGIT`
    value to specify the row).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateHardware()` 函数利用了使用 `MC.matrix` 类创建的 `myMatrixHW` 对象。我们逐字节将想要显示的字节发送到矩阵硬件（同时附带相应的
    `MAX7219_DIGIT` 值以指定行）。'
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The SPI bus allows us to control multiple devices on the same bus by using the
    Chip
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线允许我们通过使用芯片来控制同一总线上的多个设备。
- en: Enable signal. Some devices, such as the MAX7219, also allow what is known as
    a
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 启用信号。一些设备，例如 MAX7219，还允许使用所谓的
- en: daisy-chain SPI configuration.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 菊链SPI配置。
- en: Daisy-chain SPI configuration
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Daisy-chain SPI配置
- en: You may have noticed that the `matrix` class also returns a byte when we send
    the data on the MOSI line. This is the data output from the MAX7219 controller
    on the DOUT connection. The MAX7219 controller actually passes all the DIN data
    through to DOUT, which is one set of instructions behind the DIN data. In this
    way, the MAX7219 can be daisy-chained (with each DOUT feeding into the next DIN).
    By keeping the CE signal low, multiple controllers can be loaded with data by
    being passed though one another.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们通过MOSI线发送数据时，`matrix`类也会返回一个字节。这是从DOUT连接上的MAX7219控制器输出的数据。实际上，MAX7219控制器会将所有的DIN数据传递到DOUT，这比DIN数据晚一组指令。通过这种方式，MAX7219可以通过DOUT连接到下一个DIN，从而实现菊花链（每个DOUT连接到下一个DIN）。通过保持CE信号低，可以通过相互传递数据来加载多个控制器。
- en: 'The data is ignored while CE is set to low; the output will only be changed
    when we set it to high again. In this way, you can clock in all the data for each
    of the modules in the chain and then set the CE to high to update them:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当CE设置为低时，数据将被忽略；只有当我们再次将其设置为高时，输出才会改变。这样，你可以为链中的每个模块记录所有数据，然后设置CE为高以更新它们：
- en: '![](img/11bafa78-73ba-47e9-8c55-dc53b6880c4e.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11bafa78-73ba-47e9-8c55-dc53b6880c4e.png)'
- en: The daisy-chain SPI configuration
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 菊链SPI配置
- en: We need to do this for each row that we wish to update (or use `MAX7219_NOOP`
    if we want to keep the current row the same). This is known as a daisy-chain SPI
    configuration, supported by some SPI devices, where data is passed through each
    device on the SPI bus to the next one, which allows the use of three bus control
    signals for multiple devices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每一行我们希望更新的行（或者如果我们想保持当前行不变，可以使用`MAX7219_NOOP`）执行此操作。这被称为菊花链SPI配置，一些SPI设备支持该配置，其中数据通过SPI总线上的每个设备传递到下一个设备，这允许使用三个总线控制信号来控制多个设备。
- en: Communicating using a serial interface
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用串行接口进行通信
- en: Traditionally, serial protocols such as RS232 are a common way to connect devices
    such as printers and scanners as well as joysticks and mouse devices to computers.
    Now, despite being superseded by USB, many peripherals still make use of this
    protocol for internal communication between components, to transfer data, and
    to update firmware. For electronics hobbyists, RS232 is a very useful protocol
    for debugging and controlling other devices while avoiding the complexities of
    USB.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，串行协议如RS232是连接打印机、扫描仪以及游戏手柄和鼠标等设备到计算机的常见方式。现在，尽管被USB所取代，许多外围设备仍然使用此协议进行组件间的内部通信、数据传输和固件更新。对于电子爱好者来说，RS232是一种非常实用的协议，用于调试和控制其他设备，同时避免了USB的复杂性。
- en: The two scripts in this example allow for the control of the GPIO pins to illustrate
    how we can remotely control Raspberry Pi using the serial port. The serial port
    can be connected to a PC, another Raspberry Pi device, or even an embedded microcontroller
    (such as Arduino, PIC, or similar).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的两个脚本允许控制GPIO引脚，以展示我们如何通过串行端口远程控制Raspberry Pi。串行端口可以连接到PC、另一个Raspberry Pi设备，甚至嵌入式微控制器（例如Arduino、PIC或类似设备）。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The easiest way to connect to Raspberry Pi via a serial protocol will depend
    on whether your computer has a built-in serial port or not. The serial connection,
    software, and test setup are described in the following three steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过串行协议连接到树莓派的 easiest way 将取决于您的计算机是否内置了串行端口。串行连接、软件以及测试设置将在以下三个步骤中描述：
- en: 'Create an RS232 serial connection between your computer and Raspberry Pi. For
    this, you need one of the following setups:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算机和树莓派之间创建一个RS232串行连接。为此，您需要以下配置之一：
- en: If your computer has a built-in serial port available, you can use
  id: totrans-208
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的计算机有可用的内置串行端口，您可以使用
- en: 'a Null-Modem cable with an RS232-to-USB adaptor to connect to Raspberry Pi:'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一条带有RS232到USB适配器的Null-Modem线，用于连接到树莓派：
- en: '![](img/1e43a32d-07cc-4c10-b29a-3b5d38c666dc.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e43a32d-07cc-4c10-b29a-3b5d38c666dc.png)'
- en: RS232-to-USB adapter
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: RS232-to-USB适配器
- en: 'A Null-Modem is a serial cable/adapter that has the TX and RX wires crossed
    over so that one side is connected to the TX pin of the serial port and the other
    side is connected to the RX pin:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Null-Modem是一种串行电缆/适配器，其TX和RX线已交叉连接，使得一边连接到串行端口的TX引脚，另一边连接到RX引脚：
- en: '![](img/acf971b4-d912-4d17-b8e5-dc8a97b101ed.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acf971b4-d912-4d17-b8e5-dc8a97b101ed.png)'
- en: A PC serial port connected to Raspberry Pi via a Null-Modem cable and an RS232-to-USB
    adapter USB for an RS232 adapter
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Null-Modem电缆和RS232-to-USB适配器连接到Raspberry Pi的PC串行端口，用于RS232适配器
- en: 'A list of supported USB-to-RS232 devices is available at the following link:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的USB-to-RS232设备列表可在以下链接中找到：
- en: '[http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters](http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters](http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters).'
- en: Refer to the *There's more...* section for details on how to set them up.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *更多内容...* 部分以获取如何设置它们的详细信息。
- en: If you do not have a serial port built in to your computer, you can use another
    USB-to-RS232 adapter to connect to the PC/laptop, converting the RS232 to the
    more common USB connection.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的电脑没有内置串行端口，您可以使用另一个USB-to-RS232适配器连接到PC/笔记本电脑，将RS232转换为更常见的USB连接。
- en: If you do not have any available USB ports on Raspberry Pi, you can use the
    GPIO serial pins directly with either a serial console cable or a Bluetooth serial
    module (refer to the *There's more...* section for details). Both of these will
    require some additional setup.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在树莓派上没有可用的USB端口，你可以直接使用GPIO串行引脚，通过串行控制线或蓝牙串行模块（有关详细信息，请参阅*更多内容...*部分）。这两种方法都需要进行一些额外的设置。
- en: In all cases, you can use an RS232 loopback to confirm that everything is working
    and set up correctly (again, refer to the *There's more...* section).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，您可以使用RS232环回测试来确认一切工作正常并且设置正确（再次，参考*更多内容...*部分）。
- en: Next, prepare the software you need for this example.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，准备您为此示例所需的软件。
- en: You will need to install `pyserial` so we can use the serial port with Python.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装 `pyserial`，这样我们才能使用 Python 的串行端口。
- en: 'Install `pyserial` with the following command (you will also need `pip` installed;
    refer to [Chapter 3](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml), *Using Python
    for Automation and Productivity*, for details):'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 `pyserial`（你还需要安装 `pip`；有关详细信息，请参阅[第3章](eb11b6c6-b334-42e0-941c-5d32db18cc9d.xhtml)，*使用Python进行自动化和生产效率*)：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Refer to the `pySerial` site for further documentation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`pySerial`网站以获取更多文档信息：
- en: '[https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/).'
- en: In order to demonstrate the RS232 serial control, you will require some example
    hardware attached to Raspberry Pi's GPIO pins.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示RS232串行控制，你需要一些连接到树莓派GPIO引脚的示例硬件。
- en: 'The `serialMenu.py` script allows the GPIO pins to be controlled using commands
    sent through the serial port. To fully test this, you can connect suitable output
    devices (such as LEDs) to each of the GPIO pins. You can ensure that the total
    current is kept low using 470-ohm resistors for each of the LEDs so that the maximum
    GPIO current that the Raspberry Pi can supply is not exceeded:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialMenu.py` 脚本允许通过串行端口发送的命令来控制 GPIO 引脚。为了全面测试这一点，你可以将合适的输出设备（例如 LED）连接到每个
    GPIO 引脚。你可以通过为每个 LED 使用 470 欧姆的电阻来确保总电流保持较低，这样就不会超过 Raspberry Pi 可以提供的最大 GPIO
    电流：'
- en: '![](img/a019b67d-3b3c-4793-bec9-74a1e7dac4af.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a019b67d-3b3c-4793-bec9-74a1e7dac4af.png)'
- en: A test circuit to test the GPIO output via serial control
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用于通过串行控制测试GPIO输出的测试电路
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following `serialControl.py` script:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `serialControl.py` 脚本：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ensure that the `serName` element is correct for the serial port you want to
    use (such as `/dev/ttyAMA0` for the GPIO pins or `/dev/ttyUSB0` for a USB RS232
    adapter).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您要使用的串行端口中的`serName`元素是正确的（例如，对于GPIO引脚使用`/dev/ttyAMA0`，对于USB RS232适配器使用`/dev/ttyUSB0`）。
- en: Connect the other end to a serial port on your laptop or computer (the serial
    port can be another USB-to-RS232 adapter).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将另一端连接到您的笔记本电脑或计算机的串行端口（串行端口可以是另一个USB-to-RS232适配器）。
- en: Monitor the serial port on your computer using a serial program such as HyperTerminal
    or RealTerm for Windows or Serial Tools for OS X. You will need to ensure that
    you have the correct COM port set and a baud rate of 9,600 bps (`Parity=None`,
    `Data Bits=8`, `Stop Bits=1`, and `Hardware Flow Control=None`).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用串行程序如Windows的HyperTerminal或RealTerm或OS X的Serial Tools来监控您计算机上的串行端口。您需要确保已正确设置COM端口，并设置波特率为9,600
    bps（`奇偶校验=None`，`数据位=8`，`停止位=1`，以及`硬件流控制=None`）。
- en: The script will send a request for data to the user and wait for a response.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将向用户发送数据请求并等待响应。
- en: To send data to Raspberry Pi, write some text on the other computer and press
    *Enter* to send it over to Raspberry Pi.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据发送到树莓派，在另一台计算机上输入一些文本，然后按*Enter*键将其发送到树莓派。
- en: 'You will see output similar to the following in the Raspberry Pi terminal:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在树莓派终端中看到类似以下输出的内容：
- en: '![](img/7020a150-d190-44bc-8c5b-53c79957578f.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7020a150-d190-44bc-8c5b-53c79957578f.png)'
- en: The text Switch on LED 1 has been sent via a USB-to-RS232 cable from a connected
    computer
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过USB-to-RS232线缆从连接的电脑发送了“开启LED 1”的文本
- en: 'You will also see output similar to the following in the serial monitoring
    program:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也将在串行监控程序中看到类似以下输出：
- en: '![](img/f490dd93-6784-471c-92a7-efa990579863.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f490dd93-6784-471c-92a7-efa990579863.png)'
- en: RealTerm displaying typical output from the connected serial port
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: RealTerm显示连接的串行端口典型的输出
- en: Press *Ctrl* + *C* on Raspberry Pi to stop the script.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树莓派上按 *Ctrl* + *C* 停止脚本。
- en: 'Now, create a GPIO control menu. Create `serialMenu.py`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个GPIO控制菜单。创建`serialMenu.py`：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you run the script (`sudo python3 serialMenu.py`), type the control messages
    within the serial monitoring program:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行脚本（`sudo python3 serialMenu.py`），在串行监控程序中输入控制信息：
- en: '![](img/cd8061b0-5146-474b-9586-719162945205.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd8061b0-5146-474b-9586-719162945205.png)'
- en: The GPIO Serial Control menu
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO串行控制菜单
- en: 'The Terminal output on Raspberry Pi will be similar to the following screenshot,
    and the LEDs should respond accordingly:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树莓派上的终端输出将类似于以下截图，LED灯应该相应地做出反应：
- en: '![](img/3637fda1-fe71-4192-99c9-db6f793215c4.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3637fda1-fe71-4192-99c9-db6f793215c4.png)'
- en: The GPIO Serial Control menu
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO串行控制菜单
- en: Raspberry Pi validates the commands received from the serial connection and
    switches the LEDs connected to the GPIO pins 7 and 11 on and then off.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派验证从串行连接接收到的命令，并切换连接到GPIO引脚7和11的LED灯，然后打开再关闭。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first script, `serialControl.py`, provides us with a `serPort` class. We
    define the class with the following functions:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段脚本，`serialControl.py`，为我们提供了一个`serPort`类。我们使用以下函数定义该类：
- en: '`__init__(self,serName="/dev/ttyAMA0")`: This function will create a new serial
    device using `serName` – the default of `/dev/ttyAMA0` is the ID for the GPIO
    serial pins (see the *There''s more...* section). After it is initialized, information
    about the device is displayed.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__(self,serName="/dev/ttyAMA0")`: 此函数将使用 `serName` 创建一个新的串行设备 – 默认的
    `/dev/ttyAMA0` 是 GPIO 串行引脚的 ID（参见 *更多内容...* 部分）。初始化后，将显示设备信息。'
- en: '`__enter__(self)`: This is a dummy function that allows us to use the `with...as`
    method.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__enter__(self)`: 这是一个虚拟函数，允许我们使用 `with...as` 方法。'
- en: '`send(self,message)`: This is used to check that the serial port is open and
    not in use; if this is the case, it will then send a message (after converting
    it to raw bytes using the `s2b()` function).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send(self,message)`: 这用于检查串行端口是否已打开且未被占用；如果是这种情况，它将发送一条消息（在将其转换为原始字节后使用 `s2b()`
    函数）。'
- en: '`receive(self, chars=1, echo=True, terminate="r")`: After checking whether
    the serial port is open and not in use, this function then waits for data through
    the serial port. The function will collect data until the terminated characters
    are detected and then the full message is returned.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receive(self, chars=1, echo=True, terminate="r")`: 在检查串口是否打开且未被占用后，此函数随后通过串口等待数据。函数将收集数据，直到检测到终止字符，然后返回完整消息。'
- en: '`__exit__(self,type,value,traceback)`: This function is called when the `serPort`
    object is no longer required by the `with...as` method, so we can close the port
    at this point.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__exit__(self,type,value,traceback)`: 这个函数在`serPort`对象不再需要通过`with...as`方法时被调用，因此我们可以在这一点关闭端口。'
- en: The `main()` function in the script performs a quick test of the class by sending
    a prompt for data through the serial port to a connected computer and then waits
    for input that will be followed by the terminated character(s).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的`main()`函数通过串行端口向连接的计算机发送数据提示，然后等待输入，输入之后将跟随终止字符（们）。
- en: The next script, `serialMenu.py`, allows us to make use of the `serPort` class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本 `serialMenu.py` 允许我们使用 `serPort` 类。
- en: The `main()` function sets up the GPIO pins as output (via `gpioSetup()`), creates
    a new `serPort` object, and finally waits for commands coming from the serial
    port. Whenever a new command is received, the `handleCmd()` function is used to
    parse the message to ensure that it is correct before acting on it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数设置 GPIO 引脚为输出（通过 `gpioSetup()`），创建一个新的 `serPort` 对象，并最终等待来自串行端口的命令。每当接收到新的命令时，使用
    `handleCmd()` 函数来解析消息，以确保在执行之前它是正确的。'
- en: The script will switch a particular GPIO pin on or off as commanded via the
    serial port using the `GPIO` command keyword. We could add any number of command
    keywords and control (or read) whatever device (or devices) we attached to Raspberry
    Pi. We now have a very effective way to control Raspberry Pi using any devices
    connected via a serial link.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将根据通过串行端口使用`GPIO`命令关键字发出的指令来切换特定的GPIO引脚的开关状态。我们可以添加任意数量的命令关键字，并控制（或读取）我们连接到树莓派上的任何设备（或多个设备）。现在，我们有了使用通过串行链路连接的任何设备来控制树莓派的一种非常有效的方法。
- en: There's more...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to the serial transmit and receive, the RS232 serial standard includes
    several other control signals. To test it, you can use a serial loopback to confirm
    if the serial ports
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了串行发送和接收之外，RS232串行标准还包括几个其他控制信号。为了测试它，你可以使用串行环回来确认串行端口
- en: are set up correctly.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 已正确设置。
- en: Configuring a USB-to-RS232 device for Raspberry Pi
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为树莓派配置USB-to-RS232设备
- en: Once you have connected the USB-to-RS232 device to Raspberry Pi, check to see
    whether
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将USB-to-RS232设备连接到树莓派，请检查是否
- en: 'a new serial device is listed by typing the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令列出新的串行设备：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `dmesg` command lists events that occur on the system; using `grep`, we
    can filter any messages that mention `tty`, as shown in the following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`dmesg` 命令列出了系统上发生的事件；使用 `grep`，我们可以过滤出提及 `tty` 的任何消息，如下面的代码所示：'
- en: '[PRE28]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This shows that a PL2303-based USB-RS232 device was attached (2,409 seconds
    after startup) and allocated the `ttyUSB0` identity. You will see that a new serial
    device has been added within the `/dev/` directory (usually `/dev/ttyUSB0` or
    something similar).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明基于PL2303的USB-RS232设备已连接（启动后2,409秒）并分配了`ttyUSB0`标识。您将看到在`/dev/`目录下（通常是`/dev/ttyUSB0`或类似名称）已添加了一个新的串行设备。
- en: If the device has not been detected, you can try steps similar to the ones used
    in [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml), *Getting Started with
    a Raspberry Pi 3 Computer*, to locate and install suitable drivers (if they are
    available).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备未被检测到，您可以尝试与[第1章](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml)中使用的步骤类似的步骤，即*使用Raspberry
    Pi 3计算机入门*，以定位和安装合适的驱动程序（如果可用）。
- en: RS232 signals and connections
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RS232信号和连接
- en: The RS232 serial standard has lots of variants and includes six additional control
    signals.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: RS232串行标准有很多变体，并包括六个额外的控制信号。
- en: 'The Raspberry Pi GPIO serial drivers (and the Bluetooth TTL module used in
    the following example) only support RX and TX signals. If you require support
    for other signals, such as DTR, which is often used for a reset prior to the programming
    of AVR/Arduino devices, then alternative GPIO serial drivers may be needed to
    set these signals via other GPIO pins. Most RS232-to-USB adapters support the
    standard signals; however, ensure that anything you connect is able to handle
    standard RS232 voltages:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派 GPIO 串行驱动程序（以及以下示例中使用的蓝牙 TTL 模块）仅支持 RX 和 TX 信号。如果您需要支持其他信号，例如常用于在编程 AVR/Arduino
    设备之前重置的 DTR 信号，那么可能需要其他 GPIO 串行驱动程序来通过其他 GPIO 引脚设置这些信号。大多数 RS232 到 USB 转换器支持标准信号；然而，请确保您连接的任何设备都能处理标准
    RS232 电压：
- en: '![](img/51528259-42e7-4569-8158-ae7f567feca0.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51528259-42e7-4569-8158-ae7f567feca0.png)'
- en: The RS232 9-Way D connector pin-out and signals
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: RS232 9针D型连接器引脚排列和信号
- en: 'For more details on the RS232 serial protocol and to learn how these signals
    are used, visit the following link:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于RS232串行协议的细节以及了解这些信号的使用方法，请访问以下链接：
- en: '[http://en.wikipedia.org/wiki/Serial_port](http://en.wikipedia.org/wiki/Serial_port).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[串行端口](http://en.wikipedia.org/wiki/Serial_port).'
- en: Using the GPIO built-in serial pins
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPIO内置的串行引脚
- en: 'Standard RS232 signals can range from -15V to +15V, so you must never directly
    connect any RS232 device to the GPIO serial pins. You must use an RS232 to TTL
    voltage-level converter (such as a MAX232 chip) or a device that uses TTL-level
    signals (such as another microcontroller or a TTL serial console cable):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的RS232信号可以从-15V到+15V，因此你绝对不能直接将任何RS232设备连接到GPIO串行引脚。你必须使用RS232到TTL电压级别转换器（例如MAX232芯片）或使用TTL级别信号的设备（例如另一个微控制器或TTL串行控制台电缆）：
- en: '![](img/a732198e-8bcb-49ff-97e9-54aa9e31528e.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a732198e-8bcb-49ff-97e9-54aa9e31528e.png)'
- en: A USB-to-TTL serial console cable (voltage level is 3V)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: USB-to-TTL串行控制台电缆（电压等级为3V）
- en: 'Raspberry Pi has TTL-level serial pins on the GPIO header that allow the connection
    of a TTL serial USB cable. The wires will connect to the Raspberry Pi GPIO pins
    and the USB will plug in to your computer and be detected like a standard RS232-to-USB
    cable:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派在GPIO引脚上具有TTL级别的串行引脚，这允许连接TTL串行USB线缆。线缆将连接到树莓派的GPIO引脚，而USB将插入到您的计算机上，并像标准RS232-to-USB线缆一样被检测到：
- en: '![](img/d45db928-bd0e-448d-bf93-443c59267a0d.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d45db928-bd0e-448d-bf93-443c59267a0d.png)'
- en: Connection of a USB-to-TTL serial console cable to the Raspberry Pi GPIO
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将USB-to-TTL串行控制台线缆连接到树莓派GPIO
- en: It is possible to provide power from the USB port to the 5V pin; however, this
    will bypass the built-in polyfuse, so it is not recommended for general use (just
    leave the 5V wire disconnected and power it up as normal using the micro USB).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从USB端口为5V引脚供电；然而，这将绕过内置的熔断器，因此不建议一般使用（只需将5V线断开，并像正常使用一样通过micro USB供电）。
- en: By default, these pins are set up to allow remote terminal access, allowing
    you to connect
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些引脚被设置为允许远程终端访问，使您能够连接
- en: to the COM port via PuTTY and to create a serial SSH session.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 PuTTY 连接到 COM 端口并创建一个串行 SSH 会话。
- en: A serial SSH session can be helpful if you want to use Raspberry Pi without
    a display attached to it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在未连接显示器的Raspberry Pi上使用它，串行SSH会话可能会有所帮助。
- en: However, a serial SSH session is limited to text-only Terminal access since
    it does not support X10 forwarding, as used in the *Connecting remotely to Raspberry
    Pi over the network using SSH (and X11 forwarding)* section of [Chapter 1](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml),
    *Getting Started with a Raspberry Pi 3 Computer*.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，串行SSH会话仅限于纯文本终端访问，因为它不支持X10转发，正如[第1章](b2230c60-fd75-45fd-82c8-e477459db3e0.xhtml)中“使用SSH（以及X11转发）远程连接到Raspberry
    Pi”部分所述，在《Raspberry Pi 3计算机入门》一书中。
- en: In order to use it as a standard serial connection, we have to disable the serial
    console so it is available for us to use.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其用作标准串行连接，我们必须禁用串行控制台，以便我们可以使用它。
- en: 'First, we need to edit `/boot/cmdline.txt` to remove the first `console` and
    `kgboc` options (do not remove the other `console=tty1` option, which is the default
    Terminal when you switch on):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编辑 `/boot/cmdline.txt` 文件以移除第一个 `console` 和 `kgboc` 选项（不要移除其他的 `console=tty1`
    选项，这是您开启时默认的终端）：
- en: '[PRE29]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous command line becomes the following (ensure that this is still a
    single
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令行变为以下内容（确保这仍然是一个单独的
- en: 'command line):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行（）：
- en: '[PRE30]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also have to remove the task that runs the `getty` command (the program
    that handles the text Terminal for the serial connection) by commenting it out
    with `#`. This is set in `/etc/inittab` as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须通过使用`#`注释掉运行`getty`命令的任务（处理串行连接文本终端的程序），将其移除。这已在`/etc/inittab`中设置如下：
- en: '[PRE31]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The previous command line becomes the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令行变为以下：
- en: '[PRE32]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To reference the GPIO serial port in our script, we use its name, `/dev/ttyAMA0`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中引用GPIO串行端口，我们使用其名称，`/dev/ttyAMA0`。
- en: The RS232 loopback
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RS232环回测试
- en: You can check whether the serial port connections are working correctly using
    a
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方法检查串行端口连接是否正常工作：
- en: serial loopback.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 串行环回。
- en: 'A simple loopback consists of connecting RXD and TXD together. These are pins
    8 and 10 on the Raspberry Pi GPIO header, or pins 2 and 3 on the standard RS232
    D9 connector on the USB-RS232 adapter:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的环回连接由将 RXD 和 TXD 连接在一起组成。这些是 Raspberry Pi GPIO 接头上的第 8 和第 10 脚，或者在 USB-RS232
    适配器上标准 RS232 D9 连接器上的第 2 和第 3 脚：
- en: '![](img/12505654-6822-4caa-8598-b5c4ddd62d07.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12505654-6822-4caa-8598-b5c4ddd62d07.png)'
- en: Serial loopback connections to test the Raspberry Pi GPIO (left) and RS232 9-Way
    D connector (right)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到测试树莓派GPIO（左侧）和RS232 9针D型连接器（右侧）的串行环回连接
- en: 'An RS232 full loopback cable also connects pin 4 (DTR) and pin 6 (DSR) as well
    as pin 7 (RTS) and pin 8 (CTS) on the RS232 adapter. However, this is not required
    for most situations, unless these signals are used. By default, no pins are allocated
    on Raspberry Pi specifically for these additional signals:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一条RS232全环回电缆也连接了RS232适配器上的4号引脚（DTR）和6号引脚（DSR），以及7号引脚（RTS）和8号引脚（CTS）。然而，在大多数情况下，这并不是必需的，除非使用这些信号。默认情况下，树莓派上没有专门为这些额外信号分配引脚：
- en: '![](img/4cb2a5a1-40c9-4c0b-8682-a549c491034a.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cb2a5a1-40c9-4c0b-8682-a549c491034a.png)'
- en: RS232 full loopback
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: RS232 全环回
- en: 'Create the following `serialTest.py` script:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `serialTest.py` 脚本：
- en: '[PRE33]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a loopback is connected, you will observe that the message is echoed back
    to the screen (when removed, `No data Received` will be displayed):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当环回连接时，你会观察到信息被回显到屏幕上（当移除时，将显示`无数据接收`）：
- en: '![](img/d5ba2a9f-3e18-4a10-bc04-0d9ba7282a18.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5ba2a9f-3e18-4a10-bc04-0d9ba7282a18.png)'
- en: An RS232 loopback test on GPIO serial pins
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPIO串行引脚上进行的RS232环回测试
- en: 'If we require non-default settings, they can be defined when the serial port
    is initialized (the pySerial documentation at [https://pyserial.readthedocs.io/en/latest/](https://pyserial.readthedocs.io/en/latest/)
    provides full details of all the options), as shown in the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要非默认设置，它们可以在初始化串行端口时定义（[pySerial 文档](https://pyserial.readthedocs.io/en/latest/)提供了所有选项的完整详情），如下面的代码所示：
- en: '[PRE34]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Controlling Raspberry Pi using Bluetooth
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蓝牙控制树莓派
- en: 'Serial data can also be sent through Bluetooth by connecting a HC-05 Bluetooth
    module that supports the **Serial Port Profile** (**SPP**) to the GPIO serial
    RX/TX pins. This allows the serial connection to become wireless, which allows
    Android tablets or smartphones to be used to control things and to read data from
    Raspberry Pi:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接支持**串行端口配置文件**（**SPP**）的HC-05蓝牙模块到GPIO串行RX/TX引脚，串行数据也可以通过蓝牙发送。这使得串行连接变为无线，从而可以使用Android平板电脑或智能手机来控制事物并从树莓派读取数据：
- en: '![](img/85c1c7b6-68c2-48df-ba23-d81bd93ec6cd.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85c1c7b6-68c2-48df-ba23-d81bd93ec6cd.png)'
- en: The HC-05 Bluetooth module for the TLL serial
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: TLL串行用的HC-05蓝牙模块
- en: While it is possible to achieve a similar result using a USB Bluetooth dongle,
    additional configuration would be required depending on the particular dongle
    used. The TTL Bluetooth module provides a drop-in replacement for a physical cable,
    requiring very little additional configuration.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用USB蓝牙适配器也能实现类似的效果，但根据所使用的适配器类型，可能需要进行额外的配置。TTL蓝牙模块可以作为一个物理电缆的直接替代品，只需要非常少的额外配置。
- en: Getting ready
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Ensure that the serial console has been disabled (see the previous *There's
    more...* section).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 确保串行控制台已被禁用（参见前面的 *还有更多...* 部分）。
- en: 'The module should be connected using the following pins:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块应使用以下引脚进行连接：
- en: '![](img/c2cf2f1f-224d-401f-833f-67be4a33e960.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2cf2f1f-224d-401f-833f-67be4a33e960.png)'
- en: Connection to a Bluetooth module for the TLL serial
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到TLL串行接口的蓝牙模块
- en: How to do it...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: With the Bluetooth module configured and connected, we can pair the module with
    a laptop or smartphone to send and receive commands wirelessly. Bluetooth spp
    pro provides an easy way to use a serial connection over Bluetooth to control
    or monitor Raspberry Pi for Android devices.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 配置并连接蓝牙模块后，我们可以将模块与笔记本电脑或智能手机配对，以无线方式发送和接收命令。蓝牙 spp pro 提供了一种简单的方法，通过蓝牙使用串行连接来控制或监控
    Android 设备的 Raspberry Pi。
- en: 'Alternatively, you may be able to set up a Bluetooth COM port on your PC/laptop
    and use it in the same way as the previous wired example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能能够在您的PC/笔记本电脑上设置一个蓝牙COM端口，并像之前的有线示例一样使用它：
- en: 'When the device is connected initially, the LED flashes quickly to indicate
    that it is waiting to be paired. Enable Bluetooth on your device and select the
    HC-05 device:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当设备首次连接时，LED灯快速闪烁以表示它正在等待配对。请启用您设备上的蓝牙并选择HC-05设备：
- en: '![](img/eb5aa69e-f913-4bf7-94b6-6804a93f8993.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb5aa69e-f913-4bf7-94b6-6804a93f8993.png)'
- en: The HC-05 Bluetooth module viewable in Bluetooth spp pro
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 可在蓝牙 spp pro 中查看的 HC-05 蓝牙模块
- en: 'Click on the Pair button to begin the pairing process and enter the device''s
    PIN (the default is `1234`):'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击配对按钮开始配对过程并输入设备的PIN码（默认为`1234`）：
- en: '![](img/eaacb1c8-65f6-408e-8ac4-7347cfcd283c.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eaacb1c8-65f6-408e-8ac4-7347cfcd283c.png)'
- en: Pair the Bluetooth device with the PIN code (1234)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将蓝牙设备与PIN码（1234）配对
- en: 'If the pairing was successful, you will be able to connect with the device
    and send and receive messages to and from Raspberry Pi:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果配对成功，您将能够连接到设备，并向 Raspberry Pi 发送和接收消息：
- en: '![](img/ea1f4551-307b-49b5-9cb3-ae5850c51155.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea1f4551-307b-49b5-9cb3-ae5850c51155.png)'
- en: Connect to the device and select the control method
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到设备并选择控制方法
- en: In Keyboard mode, you can define actions for each of the buttons to send suitable
    commands when pressed.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在键盘模式下，您可以定义每个按钮的动作，以便在按下时发送合适的命令。
- en: For example, Pin12 ON can be set to send `gpio 12 on` and Pin12 OFF can be set
    to send `gpio 12 off`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以将Pin12 ON设置为发送`gpio 12 on`，而将Pin12 OFF设置为发送`gpio 12 off`。
- en: Ensure that you set the end flag to `rn` via the menu options.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您通过菜单选项将结束标志设置为`rn`。
- en: 'Ensure that `menuSerial.py` is set to use the GPIO serial connection:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将 `menuSerial.py` 设置为使用 GPIO 串行连接：
- en: '[PRE35]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the `menuSerial.py` script (with the LEDs attached):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`menuSerial.py`脚本（连接上LED灯）：
- en: '[PRE36]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check that the Bluetooth serial app displays the `GPIO Serial Control` menu
    as shown in the following screenshot:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查蓝牙串行应用是否显示与以下截图所示的`GPIO串行控制`菜单：
- en: '![](img/95a5b345-114c-48f2-a5ab-f7540890c12c.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95a5b345-114c-48f2-a5ab-f7540890c12c.png)'
- en: GPIO control over Bluetooth
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过蓝牙进行GPIO控制
- en: 'We can see from the output in the following screenshot that the commands have
    been received and the LED connected to pin 12 has been switched on and off as
    required:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从下面的截图输出中看到，命令已被接收，连接到引脚12的LED灯已按需开启和关闭：
- en: '![](img/c473b6fa-7f5d-4b90-b756-80754fb516bf.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c473b6fa-7f5d-4b90-b756-80754fb516bf.png)'
- en: Raspberry Pi receiving GPIO control over Bluetooth
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派通过蓝牙接收GPIO控制
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By default, the Bluetooth module is set up to act like a TTL serial slave device,
    so we can simply plug it in to the GPIO RX and TX pins. Once the module is paired
    with a device, it will transfer the serial communication over the Bluetooth connection.
    This allows us to send commands and receive data via Bluetooth and to control
    Raspberry Pi using a smartphone or PC.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，蓝牙模块被设置为类似于TTL串行从设备，因此我们可以直接将其插入GPIO RX和TX引脚。一旦模块与设备配对，它将通过蓝牙连接传输串行通信。这使得我们可以通过蓝牙发送命令和接收数据，并使用智能手机或PC来控制Raspberry
    Pi。
- en: This means you can attach a second module to another device (such as an Arduino)
    that
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以将第二个模块连接到另一个设备（例如Arduino）上
- en: has TTL serial pins and control it using Raspberry Pi (either by pairing it
    with another
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有TTL串行引脚，并使用树莓派（通过与其配对或通过其他方式）来控制它
- en: TTL Bluetooth module or suitably configuring a USB Bluetooth dongle). If the
    module is
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: TTL 蓝牙模块或适当配置一个 USB 蓝牙适配器）。如果该模块是
- en: set up as a master device, then you will need to reconfigure it to act as a
    slave (see the *There's more...* section).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 将其设置为从设备后，您需要重新配置它以作为主设备（请参阅*更多内容...*部分）。
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now, let's understand how to configure the Bluetooth settings.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何配置蓝牙设置。
- en: Configuring Bluetooth module settings
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置蓝牙模块设置
- en: The Bluetooth module can be set to one of two different modes using the KEY
    pin.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过KEY引脚，可以将蓝牙模块设置为两种不同的模式之一。
- en: In a normal operation, serial messages are sent over Bluetooth; however, if
    we need to change the settings of the Bluetooth module itself, we can do so by
    connecting the KEY pin to 3V3 and putting it into AT mode.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常操作中，串行消息通过蓝牙发送；然而，如果我们需要更改蓝牙模块本身的设置，我们可以通过将KEY引脚连接到3V3并将它置于AT模式来实现。
- en: AT mode allows us to directly configure the module, allowing us to change the
    baud rate, the pairing code, the device name, or even set it up as a master/slave
    device.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: AT模式允许我们直接配置模块，使我们能够更改波特率、配对码、设备名称，甚至将其设置为主/从设备。
- en: 'You can use `miniterm`, which is part of pySerial, to send the required messages,
    as shown in the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用pySerial的一部分`miniterm`来发送所需的消息，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `miniterm` program, when started, will prompt you for the port to use:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 `miniterm` 程序时，它会提示您输入要使用的端口号：
- en: '[PRE38]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can send the following commands (you will need to do this quickly, or paste
    them in, as the module will time out if there is a gap and respond with an error):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以发送以下命令（您需要快速完成此操作，或者粘贴它们，因为如果出现间隔，模块将超时并返回错误信息）：
- en: '`AT`: This command should respond with OK.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AT`: 此命令应响应“OK”。'
- en: '`AT+UART?`: This command will report the current settings as `UART=<Param1>,<Param2>,<Param3>`.
    The output of this command will be OK.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AT+UART?`: 此命令将报告当前设置，格式为 `UART=<Param1>,<Param2>,<Param3>`。此命令的输出将是 OK。'
- en: To change the current settings, use `AT+UART=<Param1>,<Param2>,<Param3>`, that
    is, `AT+UART=19200,0,0`.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改当前设置，请使用 `AT+UART=<Param1>,<Param2>,<Param3>`，即 `AT+UART=19200,0,0`。
- en: '![](img/d0a9ec96-7589-4751-928e-ac2fbdd6294c.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0a9ec96-7589-4751-928e-ac2fbdd6294c.png)'
- en: HC-05 AT mode AT+UART command parameters
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: HC-05 AT模式 AT+UART命令参数
- en: 'Zak Kemble has written an excellent guide on how to configure modules as paired
    master and slave devices (for example, between two Raspberry Pi devices). It is
    available at the following link:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Zak Kemble 撰写了一篇优秀的指南，介绍了如何配置模块作为成对的从主设备（例如，在两个 Raspberry Pi 设备之间）。该指南可在以下链接找到：
- en: '[http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/](http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[如何让蓝牙模块相互通信](http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/)'
- en: 'For additional documentation on the HC-05 module, visit the following link:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 关于HC-05模块的附加文档，请访问以下链接：
- en: '[http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf](http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf](http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf).'
- en: Controlling USB devices
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制USB设备
- en: The **Universal Serial Bus** (**USB**) is used extensively by computers to provide
    additional peripherals and expansion through a common standard connection. We
    will use the
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用串行总线**（**USB**）被计算机广泛用于通过一个通用的标准连接提供额外的外围设备和扩展。我们将使用'
- en: '`pyusb` Python library to send custom commands to connected devices over USB.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyusb` Python 库用于通过 USB 向连接的设备发送自定义命令。'
- en: 'The following example controls a USB toy missile launcher, which in turn allows
    it to be controlled by our Python control panel. We can see that the same principle
    can be applied to other USB devices, such as a robotic arm, using similar techniques,
    and the controls can be activated using a sensor connected to the Raspberry Pi
    GPIO:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例控制一个USB玩具导弹发射器，反过来它可以通过我们的Python控制面板进行控制。我们可以看到，同样的原理可以应用于其他USB设备，例如使用类似技术的机械臂，并且可以通过连接到树莓派GPIO的传感器来激活控制：
- en: '![](img/58c8a524-baa9-4bf4-b085-2b4e7672e8d8.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58c8a524-baa9-4bf4-b085-2b4e7672e8d8.png)'
- en: The USB Tenx Technology SAM missile launcher
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: USB Tenx 技术SAM导弹发射器
- en: Getting ready
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will need to install `pyusb` for Python 3 using `pip-3.2` as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`pip-3.2`来为Python 3安装`pyusb`，具体操作如下：
- en: '[PRE39]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can test whether `pyusb` has installed correctly by running the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来测试`pyusb`是否已正确安装：
- en: '[PRE40]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This should allow you to view the package information, if it was installed correctly.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该允许您查看包信息，如果它被正确安装的话。
- en: How to do it...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create the following `missileControl.py` script, which will include
    two classes and a default `main()` function to test it:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下`missileControl.py`脚本，其中将包含两个类和一个默认的`main()`函数以进行测试：
- en: 'Import the required modules as follows:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式导入所需的模块：
- en: '[PRE41]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the `SamMissile()` class, which provides the specific commands for the
    USB device, as follows:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`SamMissile()`类，该类提供了USB设备的特定命令，如下所示：
- en: '[PRE42]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define the `Missile()` class, which allows you to detect the USB device and
    provide command functions, as follows:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Missile()`类，该类允许你检测USB设备并提供命令功能，具体如下：
- en: '[PRE43]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, create a `main()` function, which provides a quick test of our `missileControl.py`
    module if the file is run directly, as follows:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个 `main()` 函数，如果文件直接运行，它将为我们提供对 `missileControl.py` 模块的快速测试，如下所示：
- en: '[PRE44]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the script is run using the following command, you should see the missile
    launcher move downwards and then up again:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用以下命令运行脚本时，你应该看到导弹发射器向下移动然后再向上移动：
- en: '[PRE45]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To have easy control of the device, create the following GUI:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了轻松控制设备，创建以下图形用户界面：
- en: '![](img/0e2a7913-c477-481e-930e-c0128ef286bc.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e2a7913-c477-481e-930e-c0128ef286bc.png)'
- en: The Missile Command GUI
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 导弹指挥GUI
- en: Although simple commands have been used here, you could use a series of preset
    commands if desired.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里使用了简单的命令，但如果需要，你也可以使用一系列预设的命令。
- en: 'Create the GUI for the `missileMenu.py` missile command:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`missileMenu.py`导弹命令创建GUI：
- en: '[PRE46]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The control script consists of two classes: one called `Missile`, which provides
    a common interface for the control, and another called `SamMissile`, which provides
    all the specific details of the particular USB device being used.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 控制脚本由两个类组成：一个名为`Missile`的类，它为控制提供了一个通用接口，另一个名为`SamMissile`的类，它提供了正在使用的特定USB设备的所有详细信息。
- en: In order to drive a USB device, we need a lot of information about the device,
    such as its USB identification, its protocol, and the control messages it requires
    to be controlled.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 为了驱动USB设备，我们需要大量关于该设备的信息，例如其USB标识、其协议以及它需要用于控制的控制消息。
- en: The USB ID for the Tenx Technology SAM missile device is determined by the vendor
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Tenx Technology SAM导弹设备的USB ID由厂商确定
- en: ID (`0x1130`) and the product ID (`0x0202`). This is the same identification
    information
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ID (`0x1130`) 和产品 ID (`0x0202`)。这是相同的识别信息
- en: you would see within Device Manager in Windows. These IDs are usually registered
    with [www.usb.org](http://www.usb.org); therefore, each device should be unique.
    Again, you can use the `dmesg | grep usb` command to discover these.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 Windows 的设备管理器中看到这些 ID。这些 ID 通常在 [www.usb.org](http://www.usb.org) 进行注册；因此，每个设备应该是唯一的。再次提醒，你可以使用
    `dmesg | grep usb` 命令来发现这些 ID。
- en: We use the device IDs to find the USB device using `usb.core.find`; then, we
    can send messages using `ctrl_transfer()`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用设备ID通过`usb.core.find`找到USB设备；然后，我们可以使用`ctrl_transfer()`发送消息。
- en: 'The USB message has five parts:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: USB信息包含五个部分：
- en: '**Request type (0x21)**: This defines the type of the message request, such
    as the message direction (host to device), its type (vendor), and the recipient
    (interface).'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求类型（0x21）**：这定义了消息请求的类型，例如消息方向（主机到设备）、其类型（供应商）以及接收者（接口）。'
- en: '**Request** **(0x09)**: This is the set configuration.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求** **(0x09)**: 这是设置配置。'
- en: '**Value** **(0x02)**: This is the configuration value.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值** **(0x02)**: 这是配置值。'
- en: '**Index** **(0x01)**: This is the command we want to send.'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引** **(0x01)**: 这是我们要发送的命令。'
- en: '**Data**: This is the command we want to send (as described next).'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据**：这是我们想要发送的命令（如后续所述）。'
- en: 'The `SamMissile` device requires the following commands to move:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`SamMissile` 设备需要以下命令来移动：'
- en: It requires two initialization messages (`INITA` and `INITB`).
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要两个初始化消息（`INITA` 和 `INITB`）。
- en: It also requires the control message. This consists of the `CMD`, which includes
    one of the control bytes that has been set to `1` for the required component.
    The `CMD` is then added to `CMDFILL` to complete the message.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还要求控制信息。这包括`CMD`，其中包含一个被设置为`1`的控制字节，用于所需的组件。然后，`CMD`被添加到`CMDFILL`中以完成信息。
- en: You will see that the other missile devices and the robot arm (see the following
    *There's more...* section) have similar message structures.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现其他导弹装置和机械臂（见下文 *还有更多...* 部分）具有类似的消息结构。
- en: For each device, we created the `__init__()` and `move()` functions and defined
    values for each of the valid commands, which the `missile` class will use whenever
    the `left()`, `right()`, `up()`, `down()`, `fire()`, and `stop()` functions are
    called.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个设备，我们创建了`__init__()`和`move()`函数，并为每个有效的命令定义了值，当调用`missile`类的`left()`、`right()`、`up()`、`down()`、`fire()`和`stop()`函数时，`missile`类将使用这些值。
- en: For the control GUI for our missile launcher, we create a small Tkinter window
    with five buttons, each of which will send a command to the missile device.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们导弹发射器的控制GUI，我们创建了一个带有五个按钮的小Tkinter窗口，每个按钮都会向导弹设备发送一个命令。
- en: We import `missileControl` and create a `missile` object called `myMissile`
    that will be controlled by each of the buttons.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`missileControl`并创建一个名为`myMissile`的`missile`对象，该对象将由每个按钮控制。
- en: There's more...
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The example only shows how to control one particular USB device; however, it
    is possible to extend this to support several types of missile devices and even
    other USB devices in general.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例仅展示了如何控制一个特定的USB设备；然而，有可能将其扩展以支持多种类型的导弹设备，甚至是一般意义上的其他USB设备。
- en: Controlling similar missile-type devices
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制类似的导弹型装置
- en: There are several variants of USB missile-type devices, each with their own
    USB IDs and USB commands. We can add support for these other devices by defining
    their own classes to handle them.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: USB导弹型设备的变体有好几种，每种都有自己的USB ID和USB命令。我们可以通过定义它们自己的类别来处理这些其他设备，从而为这些设备添加支持。
- en: Use `lsusb -vv` to determine the vendor and product ID that matches your device.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lsusb -vv` 命令来确定与您的设备匹配的供应商和产品ID。
- en: 'For `Chesen Electronics/Dream Link`, we have to add the following code:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Chesen Electronics/Dream Link`，我们必须添加以下代码：
- en: '[PRE47]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For `Dream Cheeky Thunder`, we need the following code:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Dream Cheeky Thunder`，我们需要以下代码：
- en: '[PRE48]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, adjust the script to use the required class as follows:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将脚本调整为使用所需的类，如下所示：
- en: '[PRE49]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Robot arm
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人手臂
- en: 'Another device that can be controlled in a similar manner is the OWI Robotic
    Arm with a USB interface:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以用类似方式控制的设备是带有USB接口的OWI机器人手臂：
- en: '![](img/1af76f13-d717-4b72-909a-41d8a6c59244.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1af76f13-d717-4b72-909a-41d8a6c59244.png)'
- en: The OWI Robotic Arm with a USB interface (image courtesy of Chris Stagg)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 带有USB接口的OWI机器人手臂（图片由Chris Stagg提供）
- en: This has featured in *The MagPi* magazine several times, thanks to *Stephen
    Richards's*
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 *《The MagPi》杂志* 中多次被提及，多亏了 *Stephen Richards* 的贡献。
- en: articles on Skutter; the USB control has been explained in detail in issue 3
    (page 14)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Skutter的文章；USB控制已在第3期（第14页）中详细解释
- en: at [https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14](https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14).
    It can also be found at [https://www.raspberrypi.org/magpi/issues/3/](https://www.raspberrypi.org/magpi/issues/3/).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14](https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14)。也可以在[https://www.raspberrypi.org/magpi/issues/3/](https://www.raspberrypi.org/magpi/issues/3/)找到。
- en: 'The robotic arm can be controlled using the following class. Remember that
    you will also need to adjust the commands, `UP`, `DOWN`, and so on, when calling
    the `move()` function, as shown in the following code:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人臂可以通过以下类进行控制。记住，在调用`move()`函数时，你还需要调整命令，例如`UP`、`DOWN`等，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Taking USB control further
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将USB控制进一步深化
- en: The theory and method of control used for the USB missile device can be applied
    to very complex devices such as the Xbox 360's Kinect (a special 3D camera add-on
    for the Xbox game console) as well.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 用于USB导弹装置的控制理论和方法的适用范围很广，甚至可以应用于像Xbox 360的Kinect（Xbox游戏控制台的一个特殊3D摄像头附加装置）这样的非常复杂的设备。
- en: Adafruit's website has a very interesting tutorial written by *Limor Fried*
    (also known as *Ladyada*) on how to analyze and investigate USB commands; access
    it at [http://learn.adafruit.com/hacking-the-kinect](http://learn.adafruit.com/hacking-the-kinect).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Adafruit的网站上有一篇由*Limor Fried*（也称为*Ladyada*）撰写的非常有趣的教程，介绍了如何分析和调查USB命令；您可以通过[http://learn.adafruit.com/hacking-the-kinect](http://learn.adafruit.com/hacking-the-kinect)访问它。
- en: This is well worth a look if you intend to reverse engineer other USB items.
    In this chapter, we have used Raspberry Pi to control remotely activated mains
    sockets, to send commands over serial connections from another computer, and to
    control the GPIO remotely. We have also used SPI to drive an 8 x 8 LED matrix
    display.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算逆向工程其他USB设备，这绝对值得一看。在本章中，我们使用了树莓派来远程控制主电源插座，从另一台计算机通过串行连接发送命令，以及远程控制GPIO。我们还使用了SPI来驱动一个8
    x 8的LED矩阵显示屏。
