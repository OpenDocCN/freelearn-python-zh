- en: '*Chapter 12*: Applying GOF Design Patterns – Part 1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：应用GOF设计模式——第1部分'
- en: In this chapter, we will look at the concept of design patterns in Python 3
    and its various categories, along with examples of how they can be applied while
    developing software using Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Python 3中设计模式的概念及其各种类别，以及它们在用Python开发软件时如何应用的示例。
- en: The concept of design patterns originated from the book Design Patterns Elements
    of Reusable Object-Oriented Software by Erich Gamma, Richard Helm, Ralph Johnson,
    and John Vlissides, Addison-Wesley, which was written in C++. This concept was
    later extended to other o**bject-oriented programming** (**OOP**) languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的概念起源于Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides所著的《设计模式：可复用面向对象软件元素》一书，该书由Addison-Wesley出版，用C++编写。这个概念后来扩展到了其他面向对象编程（**OOP**）语言。
- en: In this chapter, we are going to look at how these design patterns can be applied
    in Python using our core example of *ABC Megamart*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用我们的核心示例*ABC Megamart*将这些设计模式应用于Python。
- en: 'We will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: An overview of design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式概述
- en: Exploring behavioral design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索行为设计模式
- en: By the end of this chapter, you should understand some important behavioral
    design patterns and how they can be implemented in various applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该理解一些重要的行为设计模式以及它们如何在各种应用程序中实现。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter are available in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter12)。
- en: An overview of design patterns
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式概述
- en: Every programming language has its elements uniquely designed and communicated
    to others. Design patterns give a structured and well-designed approach to developing
    software or applications in Python. In Python, every element is an object. Design
    patterns express how we are going to sequence or structure these objects to perform
    various operations. This allows them to become reusable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有其独特设计和传达给他人的元素。设计模式为在Python中开发软件或应用程序提供了一种结构化和精心设计的方法。在Python中，每个元素都是一个对象。设计模式表达了我们将如何对这些对象进行排序或结构化以执行各种操作。这使得它们变得可重用。
- en: 'The design patterns are divided into three categories – behavioral, structural,
    and creational. In this chapter, we will cover behavioral design patterns and
    look at three in particular, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式分为三个类别——行为、结构和创建。在本章中，我们将介绍行为设计模式，并特别关注以下三个：
- en: The chain of responsibility
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Command
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Strategy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: More than 20 different design patterns are available in Python and covering
    all of them would require a book of its own. Therefore, we will only focus on
    some of the most interesting design patterns in this chapter and the next. With
    that, let’s explore some behavioral design patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有超过20种不同的设计模式，涵盖所有这些需要一本自己的书。因此，我们将只关注本章和下一章中一些最有趣的设计模式。有了这个，让我们来探索一些行为设计模式。
- en: Exploring behavioral design patterns
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索行为设计模式
- en: As the name suggests, behavioral design patterns deal with the behavior of objects
    and how they talk to each other. In this section, we will learn about the elements
    of the chain of responsibility, command, and strategy design patterns, which belong
    to the behavioral design pattern category, and understand them by applying them
    to *ABC Megamart*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，行为设计模式处理对象的行为以及它们如何相互交流。在本节中，我们将学习责任链、命令和策略设计模式的元素，这些模式属于行为设计模式类别，并通过将它们应用于*ABC
    Megamart*来理解它们。
- en: Understanding the chain of responsibility
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解责任链
- en: 'The chain of responsibility is a design pattern where the responsibility of
    the actions that can be performed by objects are transferred from one object to
    another, similar to a chain of events or actions. To explain this further and
    to implement this design pattern, we need the following elements to be developed
    in our code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链是一种设计模式，其中可以由对象执行的动作的责任从一个对象传递到另一个对象，类似于一系列事件或动作。为了进一步解释这一点并实现这种设计模式，我们需要在我们的代码中开发以下元素：
- en: '**Parent handler**: A base class that defines a base function that specifies
    how a sequence of actions should be handled.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父处理器**：一个基类，它定义了一个基础函数，指定如何处理一系列动作。'
- en: '**Child handlers**: One or more subclasses that overwrite the base function
    from the base class to perform the respective action.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子处理器**：一个或多个子类，它们覆盖基类中的基础函数以执行相应的动作。'
- en: '**Exception handler**: A default handler that performs a specific action in
    case of exceptions. It also overwrites the base function from the base class.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异常处理器**：一个默认处理器，在发生异常时执行特定操作。它还会覆盖基类中的基础函数。'
- en: '**Requestor**: A function or method that calls the child handlers to initiate
    a chain of responsibility.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求者**：一个函数或方法，它调用子处理器来启动责任链。'
- en: Let’s look at the chain of responsibility with an example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看责任链。
- en: 'In this example, we will be calculating tax by state and generating an invoice
    for the New York and California branches of *ABC Megamart*. Follow these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将根据州计算税费并为*ABC Megamart*的纽约和加利福尼亚分支机构生成发票。请按照以下步骤操作：
- en: 'To illustrate the design pattern further, let’s create a parent handler class
    named `InvoiceHandler`. In this class, we will initiate a `next_action` variable
    to handle the next action in the chain and define a `handle` method to handle
    the requested action:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步说明设计模式，让我们创建一个名为`InvoiceHandler`的父处理器类。在这个类中，我们将初始化一个`next_action`变量来处理链中的下一个动作，并定义一个`handle`方法来处理请求的动作：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will create a supporting class to support the actions that we are
    going to perform in this example. Here, we want to calculate tax for a state based
    on the request and generate an invoice:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个支持类来支持我们在本例中将要执行的操作。在这里，我们希望根据请求计算州的税费并生成发票：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `InputState` class has two attributes for the list of acceptable values
    for the states of New York and California.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputState`类有两个属性，用于列出纽约州和加利福尼亚州的接受值。'
- en: 'Now, let’s create another class that adds a header to the invoice, as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个类，为发票添加一个标题，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will create a class for the child handler that has a method for generating
    an invoice, calculating New York’s state-specific tax for a product, and overwriting
    the `handle` method from the `InvoiceHandler` class:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个子处理器类，该类具有生成发票、计算产品在纽约州的具体税费以及覆盖来自`InvoiceHandler`类的`handle`方法的方法：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we will create a class for the child handler that has a method for generating
    an invoice, calculating California’s state-specific tax for a product, and overwriting
    the `handle` method from the `InvoiceHandler` class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个子处理器类，该类具有生成发票、计算产品在加利福尼亚州的具体税费以及覆盖来自`InvoiceHandler`类的`handle`方法的方法：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s define a class that will handle exceptions such as scenarios where
    the request does not invoke one of the child handler’s methods:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个类来处理异常，例如请求未调用子处理器方法之一的场景：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s create a requestor function that instantiates one of the child handler
    subclasses and initiates a chain of responsibility that transfers from one action
    to another:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个请求函数，该函数实例化一个子处理器子类，并启动一个责任链，将一个动作传递到另一个动作：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we defined the requestor to set the next action for
    `NYCHandler` to `CAHandler` and the next action for `CAHandler` to be the exception
    handler. Let’s test this design pattern by calling the `invoice_requestor` function
    with the input state’s name; that is, `CA`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了请求者来设置`NYCHandler`的下一个动作是`CAHandler`，以及`CAHandler`的下一个动作是异常处理器。让我们通过调用`invoice_requestor`函数并传入输入州名来测试这个设计模式；即`CA`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code returns the invoice for the state of California since we
    provided the input as `CC` instead of `NY`. If `NY` was provided as input, the
    design pattern would have invoked `NYHandler`. However, since CA was provided,
    the next-in-the-chain and relevant `CAHandler` is invoked as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码返回了加利福尼亚州的发票，因为我们提供的输入是`CC`而不是`NY`。如果提供的是`NY`作为输入，设计模式将调用`NYHandler`。然而，由于提供了CA，因此调用链中的下一个相关`CAHandler`如下：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If `invoice_requestor` is provided with `NY` as the input state name instead,
    it should call `NYHandler`, not `CAHandler`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`invoice_requestor`提供的输入州名是`NY`，它应该调用`NYHandler`，而不是`CAHandler`：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code returns the `NYHandler` class’s invoice and not the `CAHandler`
    class’s invoice, as expected:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码返回了`NYHandler`类的发票，而不是预期的`CAHandler`类的发票：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As the final part of the request, let’s call `ExceptionHandler` by providing
    an input state that is neither `NY` nor `CA`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为请求的最后部分，让我们通过提供一个既不是`NY`也不是`CA`的输入状态来调用`ExceptionHandler`：
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code returns the following output by invoking the action from
    `ExceptionHandler`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过从`ExceptionHandler`调用动作返回以下输出：
- en: '[PRE24]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s connect the elements of this design pattern with its corresponding objects:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个设计模式的元素与其对应的对象连接起来：
- en: '![Figure 12.1 – Chain of responsibility classes ](img/Figure_12.1_B13426.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 责任链类](img/Figure_12.1_B13426.jpg)'
- en: Figure 12.1 – Chain of responsibility classes
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 责任链类
- en: In this section, we looked at the chain of responsibility design pattern. Now,
    let’s look at the command design pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了责任链设计模式。现在，让我们看看命令设计模式。
- en: Learning about the command design pattern
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解命令设计模式
- en: 'In this section, we will look at the next design pattern of interest: the command
    design pattern. The command design pattern can be used to create a sequence for
    executing commands and reverting to a previous state if a command is executed
    by mistake. Similar to the chain of responsibility pattern, the command design
    pattern is also created by defining multiple elements that can execute an action
    and revert the action that’s performed by an object.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨下一个感兴趣的设计模式：命令设计模式。命令设计模式可以用来创建执行命令的序列，并在执行命令出错时回滚到之前的状态。类似于责任链模式，命令设计模式也是通过定义多个可以执行动作并撤销对象执行的动作的元素来创建的。
- en: 'To explain this further and to implement this design pattern, we need to develop
    the following elements in our code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释并实现这个设计模式，我们需要在我们的代码中开发以下元素：
- en: '**Parent command**: This is a base class that defines the base functions for
    one or more commands that need to be executed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父命令**：这是一个基类，定义了需要执行的一个或多个命令的基本功能。'
- en: '**Child commands**: Child commands specify one or more actions that are inherited
    from the parent command class and overwritten at the individual child command
    level.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子命令**：子命令指定从父命令类继承的一个或多个动作，并在单个子命令级别上覆盖。'
- en: '**Executor**: This is a base class for executing the child commands. It provides
    a method to execute the action and a method to revoke the action.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行者**：这是一个执行子命令的基类。它提供了一个执行动作的方法和一个撤销动作的方法。'
- en: '**Sub-executors**: These inherit executors and overwrite the methods to execute
    while also revoking the actions that are performed by the child commands.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子执行者**：这些继承自执行者并覆盖了执行方法，同时撤销子命令执行的动作。'
- en: '**Requestor**: The requestor is a class that requests the executors to execute
    commands and revert to a previous state.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求者**：请求者是请求执行者执行命令并回滚到之前状态的类。'
- en: '**Tester**: This class tests if the design pattern is working as expected.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试者**：这个类测试设计模式是否按预期工作。'
- en: 'Now, let’s look at this design pattern in action. To understand this design
    pattern, we’ll go back to *ABC Megamart* and calculate the selling price for a
    product, as well as apply a discount to the selling price. The command pattern
    can help us design billing in such a way that we can either sell at the actual
    selling price or apply a discount. Whenever a discount is applied by mistake,
    we can revert it. Similarly, whenever a discount is not applied, we can reapply
    it. Follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个设计模式在实际中的应用。为了理解这个设计模式，我们将回到*ABC Megamart*并计算产品的销售价格，以及应用折扣。命令模式可以帮助我们设计账单，以便我们可以以实际销售价格出售或应用折扣。每当错误地应用折扣时，我们可以撤销它。同样，每当没有应用折扣时，我们可以重新应用它。按照以下步骤进行：
- en: 'Let’s start by creating the `Billing` class. This is going to be the parent
    command and it will have an attribute named `sales`. This is a dictionary object.
    There will be two abstract methods – one to apply a discount and another to remove
    the discount:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建`Billing`类。这将是一个父命令，它将有一个名为`sales`的属性。这是一个字典对象。将有两个抽象方法——一个用于应用折扣，另一个用于移除折扣：
- en: '[PRE25]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s create the first child command class, `DiscountedBilling`, which
    will overwrite the `apply_discount` method from its parent class, `Billing`. Applying
    the `Discount` method will take in the sales dictionary object from the `Billing`
    class and calculate the discounted price, as shown here:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个子命令类`DiscountedBilling`，它将覆盖其父类`Billing`中的`apply_discount`方法。应用`Discount`方法将接受来自`Billing`类的销售字典对象并计算折扣后的价格，如下所示：
- en: '[PRE26]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will create the next child command class, `ActualBilling`, which will
    remove the discount. – That is, it will calculate the selling price without a
    discount:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建下一个子命令类，`ActualBilling`，它将移除折扣。也就是说，它将计算不带折扣的销售价格：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s create the base class for the executor. This will have two methods:
    `exec_discount` and `revoke_discount`. The first is an abstract method for executing
    the command that applies the discount. And the second is an abstract method for
    executing the command that revokes the discount:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建执行器的基类。这将有两个方法：`exec_discount` 和 `revoke_discount`。第一个是一个抽象方法，用于执行应用折扣的命令。第二个是一个抽象方法，用于执行撤销折扣的命令：
- en: '[PRE28]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let’s define a child class named `ExecuteDiscountedBilling` that inherits
    from the `ExecuteBilling` class. This will overwrite the `exec_discount` and `revoke_discount`
    methods from its superclass. We will call the `apply_discount` method from the
    `DiscountedBilling` class within the `exec_discount` method of this child class.
    We will also set the `ActualBilling` command class from the `ExecuteActualBilling`
    class within the `revoke_discount` method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个名为 `ExecuteDiscountedBilling` 的子类，它继承自 `ExecuteBilling` 类。这将覆盖其超类中的
    `exec_discount` 和 `revoke_discount` 方法。我们将在子类的 `exec_discount` 方法中调用 `DiscountedBilling`
    类的 `apply_discount` 方法。我们还将设置 `ActualBilling` 命令类，从 `ExecuteActualBilling` 类中在
    `revoke_discount` 方法内：
- en: '[PRE29]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s define a child class named `ExecuteActualBilling` that inherits
    from the `ExecuteBilling` class. This will overwrite the `exec_discount` and `revoke_discount`
    methods from its superclass. We will call the `remove_discount` method from the
    `ActualBilling` class within the `exec_discount` method of this child class. We
    will also set the `DiscountedBilling` command class from the `ExecuteDiscountedBilling`
    class within the `revoke_discount` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个名为 `ExecuteActualBilling` 的子类，它继承自 `ExecuteBilling` 类。这将覆盖其超类中的 `exec_discount`
    和 `revoke_discount` 方法。我们将在子类的 `exec_discount` 方法中调用 `ActualBilling` 类的 `remove_discount`
    方法。我们还将设置 `DiscountedBilling` 命令类，从 `ExecuteDiscountedBilling` 类中在 `revoke_discount`
    方法内：
- en: '[PRE30]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we will define the requestor class, `RequestAction`, which will request
    the commands to be executed and reverted as required. We will also define three
    methods:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义请求者类，`RequestAction`，它将请求执行和撤销所需的命令。我们还将定义三个方法：
- en: The `reset` method, which will set or reset the command
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset` 方法，它将设置或重置命令'
- en: The `runcalc` method, which will execute the discount calculation
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runcalc` 方法，它将执行折扣计算'
- en: 'The `revert` method, which will revert to the previous action by revoking the
    discount calculation:'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`revert` 方法，它将通过撤销折扣计算来恢复到之前的操作：'
- en: 'In the code block:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块中：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we must create the final class in this design pattern to test that
    the command design pattern works as expected:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须创建这个设计模式中的最后一个类来测试命令设计模式是否按预期工作：
- en: '[PRE32]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we defined an object instance of the `Billing` class,
    followed by the instances that can be discounted and the actual `ExecuteBilling`
    subclasses. We also created an instance of the `RequestAction` requestor class.
    After that, we sequenced a set of operations to run the discount calculation,
    then the `reset` command, followed by rerunning the calculation to remove the
    discount. This will revert the previous command and thus reapply the discount
    before reverting the previous command, which will, in turn, remove the discount.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了 `Billing` 类的对象实例，然后是可折扣的实例和实际的 `ExecuteBilling` 子类。我们还创建了一个 `RequestAction`
    请求者类的实例。之后，我们按顺序执行了一系列操作以运行折扣计算，然后是 `reset` 命令，接着重新运行计算以移除折扣。这将撤销之前的命令，从而在撤销之前的命令之前重新应用折扣，这将反过来移除折扣。
- en: 'Let’s call the `Tester` class, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称 `Tester` 类如下：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s connect the elements of this design pattern with its corresponding
    objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个设计模式的元素与其对应对象连接起来：
- en: '![Figure 12.2 – Command design pattern classes ](img/Figure_12.2_B13426.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 命令设计模式类](img/Figure_12.2_B13426.jpg)'
- en: Figure 12.2 – Command design pattern classes
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 命令设计模式类
- en: In this section, we looked at the concept of the command design pattern. Now,
    let’s look at the strategy design pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了命令设计模式的概念。现在，让我们看看策略设计模式。
- en: The strategy design pattern
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: 'In this section, we’ll look at the final design pattern under the category
    of behavioral design patterns that we will be covering in this chapter. Let’s
    look at the elements of the strategy pattern, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看本章将要介绍的行为设计模式类别下的最后一个设计模式。让我们查看策略模式的元素，如下所示：
- en: '**Domain**: A domain or base class defines all the base methods and attributes
    required for Python objects to perform a sequence of operations. This class also
    makes decisions concerning the operation that’s performed within the class according
    to the strategy method defined in the strategy classes.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域**：领域或基类定义了Python对象执行一系列操作所需的所有基方法和属性。此类还根据策略类中定义的策略方法在类内做出操作决策。'
- en: '**Strategies**: These are one or more independent classes that define one specific
    strategy within its strategy method. The same strategy method name will be used
    in each of the strategy classes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**：这些是一个或多个独立的类，它们在其策略方法中定义了一个特定的策略。每个策略类都将使用相同的策略方法名称。'
- en: '**Tester**: A tester function calls the domain class and executes the strategy.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试者**：测试函数调用领域类并执行策略。'
- en: To understand how the strategy design pattern is implemented, we’ll look at
    various billing counters that we covered in [*Chapter 8*](B13426_08_Final_PG_epub.xhtml#_idTextAnchor107).
    There are various billing counters in *ABC Megamart*, including a vegetable counter,
    a less than 10 item counter, an electronics counter, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解策略设计模式的实现，我们将查看我们在[*第8章*](B13426_08_Final_PG_epub.xhtml#_idTextAnchor107)中提到的各种计费计数器。在*ABC
    Megamart*中，有各种计费计数器，包括蔬菜计数器、少于10件物品的计数器、电子计数器等。
- en: 'In this example, we will define a vegetable counter and an electronics counter
    as strategy classes. Follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义一个蔬菜计数器和电子计数器作为策略类。按照以下步骤进行：
- en: 'To begin with, we will define a domain class named `SuperMarket` with methods
    that do the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个名为`SuperMarket`的领域类，其中包含以下方法：
- en: Initialize attributes
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化属性
- en: Display details about the items in the cart
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示购物车中物品的详细信息
- en: Go to a specific counter
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往特定的计数器
- en: 'Here is what the code for this looks like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个代码的样子：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we will define methods that do the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义以下方法：
- en: Scan the bar codes
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描条形码
- en: Add the bill details
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加账单详情
- en: Add the tax details
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加税费详情
- en: 'Here is the code for this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个代码：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The operations for calculating the bill and printing the invoice are also defined
    in the `SuperMarket` class. Refer to the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算账单和打印发票的操作也定义在`SuperMarket`类中。请参考以下代码：
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The final method within the `SuperMarket` class is the `pipeline_template`
    method, which creates a pipeline for running the sequence of methods:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SuperMarket`类中的最后一个方法是`pipeline_template`方法，它创建一个用于运行方法序列的管道：'
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this method, we have called the strategy method to change the strategy that’s
    performed by the `SuperMarket` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将改变`SuperMarket`类执行的策略称为策略方法。
- en: 'Now, let’s define a simple strategy class for the vegetable counter, as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个简单的蔬菜计数器策略类，如下所示：
- en: '[PRE39]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let’s also create a simple strategy class for the electronic counter, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也创建一个简单的电子计数器策略类，如下所示：
- en: '[PRE40]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we must define a tester function to test the strategy:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须定义一个测试函数来测试策略：
- en: '[PRE41]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s test the strategy for the vegetable counter by running the pipeline and
    providing `VegeCounter` as the strategy value:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行管道并提供`VegeCounter`作为策略值来测试蔬菜计数器的策略：
- en: '[PRE42]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output for the `VegeCounter` strategy is as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VegeCounter`策略的输出如下：'
- en: '[PRE43]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let’s test the strategy for the electronics counter by running the pipeline
    and providing `ElectronicsCounter` as the strategy value:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行管道并提供`ElectronicsCounter`作为策略值来测试电子计数器的策略：
- en: '[PRE44]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output for the `ElectronicsCounter` strategy is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ElectronicsCounter`策略的输出如下：'
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let’s connect the elements of this design pattern with its corresponding
    objects:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个设计模式的元素与其相应的对象连接起来：
- en: '![Figure 12.3 – Strategy pattern with classes ](img/Figure_12.3_B13426.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 使用类的策略模式](img/Figure_12.3_B13426.jpg)'
- en: Figure 12.3 – Strategy pattern with classes
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 使用类的策略模式
- en: With that, we have learned about the strategy design pattern. Now, let’s summarize
    this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经了解了策略设计模式。现在，让我们总结本章内容。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about behavioral design patterns by applying some
    of them in Python 3\. In particular, we implemented the chain of responsibility,
    command, and strategy patterns and understood each of their elements.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过在 Python 3 中应用其中一些模式，学习了行为设计模式。特别是，我们实现了责任链、命令和策略模式，并理解了它们各自的元素。
- en: Similar to the other chapters in this book, this chapter has been split into
    two parts – this chapter explained design patterns and focused on metaprogramming
    and its impact on Python code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他章节类似，本章也被分成了两部分——这一部分解释了设计模式，并专注于元编程及其对 Python 代码的影响。
- en: In the next chapter, we will continue looking at the concept of design patterns
    by covering examples of structural and creational design patterns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨设计模式的概念，通过涵盖结构性和创建性设计模式的例子来展开。
