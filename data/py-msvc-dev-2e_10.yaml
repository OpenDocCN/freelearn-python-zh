- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Deploying on AWS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上部署
- en: In the previous chapters, we ran our different microservices directly in the
    host operating system, as it is sometimes the quickest way to get started, while
    also being a useful approach in general—especially for smaller installations or
    development where everything can be contained in a virtual environment. However,
    if the application requires a database or a compiled extension, then things start
    to be tightly coupled to the operating system and version. Other developers with
    slightly different systems will start to run into problems, and the more differences
    between a development environment and a production one, the more trouble you will
    have when releasing your software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们直接在宿主操作系统上运行了我们的不同微服务，因为这是开始时最快的方法之一，同时也是一种通用的有用方法——特别是在可以包含在虚拟环境中的较小安装或开发中。然而，如果应用程序需要数据库或编译扩展，那么事情开始与操作系统和版本紧密耦合。其他使用略有不同系统的开发者可能会开始遇到问题，并且开发环境与生产环境之间的差异越大，发布软件时遇到的问题就越多。
- en: '**Virtual Machines** (**VMs**) can be a good solution, as they provide an isolated
    environment in which to run your code. A VM is essentially a piece of software
    pretending to be a real computer, in which there is a real operating system running
    in the pretend computer. If you''ve ever used an Amazon EC2 instance or a Google
    Compute Engine instance, then you have used a virtual machine. It''s possible
    to run them locally using tools such as VMware or VirtualBox.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机**（**VMs**）可以是一个很好的解决方案，因为它们提供了一个隔离的环境来运行你的代码。虚拟机本质上是一块软件，它假装成一台真正的计算机，其中在一个假计算机中运行着真实的操作系统。如果你曾经使用过亚马逊EC2实例或谷歌计算引擎实例，那么你已经使用过虚拟机了。你可以使用像VMware或VirtualBox这样的工具在本地运行它们。'
- en: However, VMs are heavyweights, precisely because they emulate a full computer.
    Using one from scratch involves installing an operating system or using a tool
    such as HashiCorp's Packer ([https://www.packer.io/](https://www.packer.io/))
    to build a disk image—the sort of thing that comes prebuilt for you when selecting
    an AWS or GCP instance.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虚拟机是重量级的，正是因为它们模拟了完整的计算机。从头开始使用它们需要安装操作系统或使用像HashiCorp的Packer（[https://www.packer.io/](https://www.packer.io/））这样的工具来构建磁盘镜像——这种东西在你选择AWS或GCP实例时是预先为你构建好的。
- en: The big revolution came with **Docker**, an open-source virtualization tool
    first released in 2013\. Docker allows the use of isolated environments called
    *containers* to run applications in a very portable way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的革命来自于**Docker**，这是一个开源的虚拟化工具，于2013年首次发布。Docker允许使用称为*容器*的隔离环境以非常便携的方式运行应用程序。
- en: Cloud computing providers, such as Amazon Web Services (AWS), Google Cloud,
    and Microsoft Azure, allow people to rent space on their computers and make creating
    virtual machines and containers much easier. Provisioning these cloud resources,
    along with attached storage and databases, can be done with a few mouse clicks,
    or a few commands typed in a terminal. They can also be configured using configuration
    files to describe resources, using Infrastructure-as-Code tools, such as HashiCorp's
    **Terraform**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算提供商，如亚马逊网络服务（AWS）、谷歌云和微软Azure，允许人们租用他们的计算机空间，并使创建虚拟机和容器变得更加容易。通过几个鼠标点击或输入终端中的几个命令，就可以配置这些云资源，包括附加的存储和数据库。它们也可以使用配置文件进行配置，以描述资源，使用基础设施即代码工具，例如HashiCorp的**Terraform**。
- en: In this chapter, we present Docker and explain how to run Quart-based microservices
    with it. We then cover deploying a container-based application using some common
    orchestration tools, such as Docker Compose, Docker Swarm, and, briefly, Kubernetes.
    Many of these topics could fill entire books by themselves, so this chapter will
    be an overview that relies on the installation instructions provided by the tools
    themselves to get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Docker，并解释了如何使用它运行基于Quart的微服务。然后，我们介绍了使用一些常见的编排工具部署基于容器的应用程序，例如Docker
    Compose、Docker Swarm，以及简要介绍Kubernetes。许多这些主题本身就可以填满整本书，因此本章将是一个概述，它依赖于工具本身提供的安装说明来开始。
- en: Most of the cloud computing providers will also have their own versions of these
    tools, modified to better integrate with the other services that they offer. If
    you are already using a particular company's services, it is worth investigating
    their tools. At the same time, it is also worth knowing the cloud-agnostic versions,
    as taking a more independent approach can make migrating from one provider to
    another much easier.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云计算提供商也将拥有这些工具的版本，经过修改以更好地与其他他们提供的服务集成。如果你已经在使用某个公司的服务，那么调查他们的工具是值得的。同时，了解云无关版本也是值得的，因为采取更独立的方法可以使从一个提供商迁移到另一个提供商变得更加容易。
- en: Note that some of the instructions in this chapter may result in incurring a
    charge from AWS. While we will keep those costs to a minimum, it is important
    to understand what costs may be incurred by checking with AWS and also to unsubscribe
    from any unused resources after trying things out.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的一些说明可能会导致AWS产生费用。虽然我们将尽量将成本降到最低，但了解可能产生的费用很重要，可以通过与AWS联系来确认，并在尝试过之后取消任何未使用的资源。
- en: What is Docker?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker是什么？
- en: The **Docker** ([https://www.docker.com/](https://www.docker.com/)) project
    is a *container* platform, which lets you run your applications in isolated environments.
    Using the Linux feature called `cgroups` ([https://en.wikipedia.org/wiki/Cgroups](https://en.wikipedia.org/wiki/Cgroups)),
    Docker creates isolated environments called containers that run on Linux without
    a VM. On macOS and Windows, installing Docker will create a lightweight VM for
    you to run containers in, although this is a seamless process. This means that
    macOS, Windows, and Linux users can all develop container-based applications without
    worrying about any interoperability trouble and deploy them to a Linux server
    where they will run natively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker** ([https://www.docker.com/](https://www.docker.com/))项目是一个**容器**平台，它允许你在隔离环境中运行应用程序。使用Linux的`cgroups`功能([https://en.wikipedia.org/wiki/Cgroups](https://en.wikipedia.org/wiki/Cgroups))，Docker创建了一个称为容器的隔离环境，在Linux上运行而不需要虚拟机。在macOS和Windows上，安装Docker会为你创建一个轻量级的虚拟机，以便在其中运行容器，尽管这是一个无缝的过程。这意味着macOS、Windows和Linux用户都可以开发基于容器的应用程序，而无需担心任何互操作性麻烦，并将它们部署到Linux服务器上，在那里它们将原生运行。'
- en: Today, Docker is almost synonymous with containers, but there are other container
    runtimes, such as **CRI-O** ([https://cri-o.io/](https://cri-o.io/)), and historical
    projects such as **rkt** and **CoreOS** that, together with Docker, helped shape
    the standardized ecosystem that we have today.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Docker几乎等同于容器，但还有其他容器运行时，例如**CRI-O** ([https://cri-o.io/](https://cri-o.io/))，以及历史项目如**rkt**和**CoreOS**，它们与Docker一起帮助塑造了我们今天所拥有的标准化生态系统。
- en: Because containers do not rely on emulation when running on Linux, there is
    little performance difference between running code inside a container and outside.
    As there is an emulation layer on macOS and Windows, while it is possible to run
    containers in production on these platforms, there is little benefit to doing
    so. It is possible to package up everything needed to run an application inside
    a container image and distribute it for use anywhere that can run a container.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器在Linux上运行时不需要仿真，容器内运行代码与外部运行之间的性能差异很小。由于macOS和Windows上存在仿真层，虽然在这些平台上运行容器在生产环境中是可能的，但这样做的好处很小。可以将运行应用程序所需的所有内容打包到容器镜像中，并在任何可以运行容器的位置分发它。
- en: As a Docker user, you just need to choose which image you want to run, and Docker
    does all the heavy lifting by interacting with the Linux kernel. An image in this
    context is the sum of all the instructions required to create a set of running
    processes on top of a Linux kernel, to run one container. An image includes all
    the resources necessary to run a Linux distribution. For instance, you can run
    whatever version of Ubuntu you want in a Docker container even if the host OS
    is of a different distribution.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Docker用户，你只需选择你想要运行的镜像，Docker将通过与Linux内核交互来完成所有繁重的工作。在这个上下文中，镜像是指创建一组在Linux内核上运行的进程所需的所有指令的总和，以运行一个容器。镜像包括运行Linux发行版所需的所有资源。例如，你可以在Docker容器中运行任何版本的Ubuntu，即使宿主操作系统是不同发行版。
- en: As containers operate best on a Linux-based system, the rest of this chapter
    assumes that everything is installed under a Linux distribution, such as Ubuntu.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器在基于Linux的系统上运行最佳，本章的其余部分假设所有内容都是在Linux发行版（如Ubuntu）下安装的。
- en: We used Docker in *Chapter 5*, *Splitting the Monolith*, when discussing metrics
    and monitoring, so you may already have Docker installed. With some older Linux
    distributions, you may have a very old version of Docker available. Installing
    a newer one directly from Docker itself is a good idea, to get the latest features
    and security patches. If you have a Docker installation, feel free to jump directly
    to the next section of this chapter, *Introduction to Docker*. If not, you can
    visit [https://www.docker.com/get-docker](https://www.docker.com/get-docker) to
    download it and find the installation instructions. The community edition is good
    enough for building, running, and installing containers. Installing Docker on
    Linux is straightforward—you can probably find a package for your Linux distribution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第五章*，*拆分单体*中使用了Docker，讨论了指标和监控，所以你可能已经安装了Docker。对于一些较老的Linux发行版，你可能有一个非常旧的Docker版本可用。直接从Docker本身安装一个新版本是个好主意，以获取最新的功能和安全补丁。如果你有Docker安装，可以直接跳到本章的下一节，*Docker简介*。如果没有，你可以访问[https://www.docker.com/get-docker](https://www.docker.com/get-docker)下载它并找到安装说明。社区版足以用于构建、运行和安装容器。在Linux上安装Docker很简单——你可能会找到适合你的Linux发行版的软件包。
- en: For macOS, if you have Homebrew ([https://brew.sh](https://brew.sh)) installed,
    then you can simply use `brew install docker`. Otherwise, follow the instructions
    on Docker's website. Under Windows, Docker can either use the **Windows Subsystem
    for Linux** (**WSL2**), or the built-in Hyper-V to run a virtual machine. We recommend
    WSL, as it is the most straightforward to get working.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS，如果你已经安装了Homebrew ([https://brew.sh](https://brew.sh))，那么你可以简单地使用`brew
    install docker`。否则，请遵循Docker网站上的说明。在Windows上，Docker可以使用**Windows子系统Linux**（**WSL2**）或内置的Hyper-V来运行虚拟机。我们推荐使用WSL，因为它是最容易工作的。
- en: 'If the installation was successful, you should be able to run the `docker`
    command in your shell. Try the `version` command to verify your installation,
    like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，你应该能在你的shell中运行`docker`命令。尝试运行`version`命令来验证你的安装，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A Docker installation is composed of a Docker Engine, which controls the running
    containers and a command-line interface. It also includes Docker Compose, which
    is a way of arranging multiple containers that will work together, as well as
    Kubernetes, an orchestration tool for deploying and managing container-based applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker安装由Docker Engine组成，它控制运行中的容器和一个命令行界面。它还包括Docker Compose，这是一种安排多个容器以便它们可以一起工作的方式，以及Kubernetes，这是一个用于部署和管理基于容器的应用程序的编排工具。
- en: The engine provides an HTTP API, which can be reached locally through a UNIX
    socket (usually, `/var/run/docker.sock`) or through the network. This means it
    is possible to control a Docker Engine that is running on a different computer
    to the Docker client, or orchestration tooling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎提供了一个HTTP API，可以通过本地UNIX套接字（通常是`/var/run/docker.sock`）或通过网络访问。这意味着可以控制运行在不同计算机上的Docker
    Engine，或者控制Docker客户端或编排工具。
- en: Now that Docker is installed on your system, let's discover how it works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Docker已经安装在你的系统上，让我们来探索它是如何工作的。
- en: Introduction to Docker
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: 'Let''s experiment with Docker containers. Running a container that you can
    enter commands in is as simple as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Docker容器进行实验。运行一个你可以输入命令的容器就像以下这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With this command, we are telling Docker to run the Ubuntu image, which will
    be fetched from Docker Hub, a central registry of public images. We are providing
    a tag of `20.04` after the image name so that we download the container image
    that represents the Ubuntu 20.04 operating system. This won't contain everything
    that a regular Ubuntu installation has, but anything that's missing is installable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我们告诉Docker运行Ubuntu镜像，该镜像将从Docker Hub获取，Docker Hub是一个公共镜像的中心注册库。我们在镜像名称后提供了一个`20.04`标签，以便我们下载代表Ubuntu
    20.04操作系统的容器镜像。这不会包含常规Ubuntu安装的所有内容，但任何缺失的内容都是可以安装的。
- en: We also tell Docker to run interactively—the `-i` argument—and to assign a `tty`
    with the `-t` argument, so that we can type commands inside the container. By
    default, Docker assumes that you want to start a container that runs in the background,
    serving requests. By using these two options and asking that the command `bash`
    is run inside the container, we can get a shell that we can use just like a Linux
    shell, outside the container.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还告诉Docker以交互式方式运行——使用`-i`参数——并使用`-t`参数分配一个`tty`，这样我们就可以在容器内输入命令。默认情况下，Docker假设你想启动一个在后台运行、处理请求的容器。通过使用这两个选项并要求在容器内运行`bash`命令，我们可以得到一个可以像Linux外壳一样使用的shell，而无需在容器外。
- en: 'Every existing Linux distribution out there provides a base image, not just
    Ubuntu. There are also pared-down base images for running Python, Ruby, or other
    environments, and base Linux images, such as Alpine, which aim to be even smaller.
    The size of the image is important because every time you want to update it or
    run it in a new place, it must be downloaded. Alpine is a little over 5MB in size,
    whereas the `ubuntu:20.04` image is nearly 73MB. You can compare sizes and manage
    the images your Docker Engine knows about with the following commands – the second
    command will remove any local copy of the `ubuntu:20.04` image, so if you run
    that, you will need to download that image again to use it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的每个Linux发行版都提供了一个基础镜像，不仅仅是Ubuntu。还有针对运行Python、Ruby或其他环境的精简基础镜像，以及像Alpine这样的基础Linux镜像，目标是更小。镜像的大小很重要，因为每次你想更新它或在新的地方运行它时，都必须下载。Alpine的大小略超过5MB，而`ubuntu:20.04`镜像的大小接近73MB。你可以使用以下命令比较大小并管理Docker引擎所知的镜像——第二个命令将删除任何本地的`ubuntu:20.04`镜像副本，所以如果你运行这个命令，你需要再次下载该镜像才能使用它：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might think that the size means the Ubuntu image is always a better choice
    than the Python base image, but the Ubuntu image doesn't contain Python, and so
    to use it we must build an image that contains everything we need and install
    our own software on top of that. Rather than do all of this set up by hand, we
    can use a **Dockerfile** ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为大小意味着Ubuntu镜像总是比Python基础镜像更好，但Ubuntu镜像不包含Python，因此为了使用它，我们必须构建一个包含我们所需一切内容的镜像，并在其上安装我们自己的软件。与其手动完成所有这些设置，我们可以使用**Dockerfile**
    ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/))。
- en: 'The standard name for these Docker configuration files is a Dockerfile, and
    the following is a basic example of one:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Docker配置文件的规范名称是Dockerfile，以下是一个基本示例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A Dockerfile is a text file with a set of instructions. Each line starts with
    the instruction in uppercase, followed by its arguments. In our example, there
    are these three instructions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是一个包含一系列指令的文本文件。每一行都以大写指令开头，后跟其参数。在我们的例子中，有三个这样的指令：
- en: '`FROM`: Points to the base image to use'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`：指向要使用的基础镜像'
- en: '`RUN`: Runs the commands in the container once the base image is installed'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：在基础镜像安装后，在容器中运行命令'
- en: '`CMD`: The command to run when the container is executed by Docker'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：当Docker执行容器时运行的命令'
- en: 'Now we should build our image and give it a useful name so that we can refer
    to it later on. Here we will run docker build and tag the new image with the name
    `ubuntu-with-python`, while using the current directory for a build environment
    – by default, this is also where `docker` `build` looks for a Dockerfile:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该构建我们的镜像，并给它一个有用的名字，这样我们以后就可以引用它。在这里，我们将运行`docker build`并使用`ubuntu-with-python`这个名字标记新的镜像，同时使用当前目录作为构建环境——默认情况下，这也是`docker
    build`查找Dockerfile的地方：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can run our new image in the same way we ran the Ubuntu image earlier:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以与之前运行Ubuntu镜像相同的方式运行我们的新镜像：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When Docker creates images, it creates a cache that has every instruction from
    the Dockerfile. If you run the `build` command a second time, without changing
    the file, it should be done within seconds. Permuting or changing instructions
    rebuilds the image, starting at the first change. For this reason, a good strategy
    when writing these files is to sort instructions so that the most stable ones
    (the ones you rarely change) are at the top.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker创建镜像时，它会创建一个包含Dockerfile中每个指令的缓存。如果你在不更改文件的情况下第二次运行`build`命令，它应该在几秒钟内完成。改变指令顺序或更改指令将重建镜像，从第一个更改开始。因此，在编写这些文件时，一个好的策略是将指令排序，使得最稳定的指令（你很少更改的指令）位于顶部。
- en: Another good piece of advice is to clean up each instruction. For example, when
    we run `apt-get update` and `apt-get install` above, this downloads a lot of package
    index files, and the `.deb` packages that, once installed, we no longer need.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条很好的建议是清理每条指令。例如，当我们运行`apt-get update`和`apt-get install`时，这会下载大量的软件包索引文件，以及一旦安装我们就不再需要的`.deb`软件包。
- en: 'We can make our resulting image smaller by cleaning up after ourselves, which
    must be done in the same `RUN` command so that the data we are removing is not
    written out as part of the container''s image:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过清理我们的操作来使我们的结果镜像更小，这必须在相同的`RUN`命令中完成，以确保我们正在删除的数据不会作为容器镜像的一部分被写入：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One great feature that Docker offers is the ability to share, publish, and reuse
    images with other developers. Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    is to Docker containers what PyPI is to Python packages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供的一个很棒的功能是能够与其他开发者共享、发布和重用镜像。Docker Hub ([https://hub.docker.com](https://hub.docker.com))对Docker容器的作用就像PyPI对Python包的作用一样。
- en: In the previous example, the Ubuntu base image was pulled from the Hub by Docker, and
    there are numerous pre-existing images you can use. For instance, if you want
    to launch a Linux distribution that is tweaked for Python, you can look at the
    Python page on the official Docker Hub website and pick one ([https://hub.docker.com/_/python/](https://hub.docker.com/_/python/)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，Docker从Hub拉取了Ubuntu基础镜像，并且有大量的预存镜像可供使用。例如，如果你想启动一个针对Python进行了优化的Linux发行版，你可以查看官方Docker
    Hub网站上的Python页面，并选择一个（[https://hub.docker.com/_/python/](https://hub.docker.com/_/python/))。
- en: The `python:version` images are Debian-based, and are an excellent starting
    point for any Python project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`python:version`镜像基于Debian，是任何Python项目的绝佳起点。'
- en: The Python images based on **Alpine Linux** are also quite popular, because
    they produce the smallest images to run Python. They are more than ten times smaller
    than other images, which means they are much faster to download and set up for
    people wanting to run your project in Docker (refer to [http://gliderlabs.viewdocs.io/docker-alpine/](http://gliderlabs.viewdocs.io/docker-alpine/)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基于**Alpine Linux**的Python镜像也非常受欢迎，因为它们可以生成运行Python所需的最小镜像。它们的体积比其他镜像小十倍以上，这意味着它们下载和设置的速度要快得多，对于那些想在Docker中运行你的项目的人来说（参考[http://gliderlabs.viewdocs.io/docker-alpine/](http://gliderlabs.viewdocs.io/docker-alpine/))。
- en: 'To use Python 3.9 from the Alpine base image, you can create a Dockerfile like
    this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Alpine基础镜像使用Python 3.9，你可以创建一个Dockerfile，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Building and running this Dockerfile places you in a Python 3.9 shell. The Alpine
    set is great if you run a Python application that does not require a lot of system-level
    dependencies nor any compilation. It is important to note, however, that Alpine
    has a specific set of compilation tools that are sometimes incompatible with some
    projects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行这个Dockerfile会将你置于一个Python 3.9 shell中。如果你运行的应用程序不需要大量的系统级依赖项或任何编译，Alpine集合是非常好的。然而，需要注意的是，Alpine有一组特定的编译工具，有时与某些项目不兼容。
- en: For a Quart-based microservice project, the slightly larger Debian-based Python
    images are probably a simpler choice, because of its standard compilation environment
    and stability. Moreover, once the base image is downloaded, it is cached and reused,
    so you do not need to download everything again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Quart的微服务项目，稍微大一点的基于Debian的Python镜像可能是一个更简单的选择，因为它具有标准的编译环境和稳定性。此外，一旦下载了基础镜像，它就会被缓存并重用，因此你不需要再次下载所有内容。
- en: Note that it is important to use images from trusted people and organizations
    on Docker Hub, since anyone can upload an image. Beyond the risk of running malicious
    code, there's also the problem of using a Linux image that is not up to date with
    the latest security patches. Docker also supports digitally signing images to
    help verify that an image is the one you expect, with no modifications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用Docker Hub上可信赖的人和组织提供的镜像非常重要，因为任何人都可以上传镜像。除了运行恶意代码的风险之外，还有使用未更新到最新安全补丁的Linux镜像的问题。Docker还支持对镜像进行数字签名，以帮助验证镜像是你期望的，且没有经过修改。
- en: Running Quart in Docker
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行Quart
- en: To run a Quart application in Docker, we can use the base Python image. From
    there, installing the app and its dependencies can be done via pip, which is already
    installed in the Python image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Docker中运行Quart应用程序，我们可以使用基础Python镜像。从那里，安装应用程序及其依赖项可以通过pip完成，pip已经包含在Python镜像中。
- en: Assuming your project has a `requirements.txt` file for its pinned dependencies,
    and a `setup.py` file that installs the project, creating an image for your project
    can be done by instructing Docker on how to use the `pip` command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的项目有一个 `requirements.txt` 文件用于其固定依赖项，以及一个 `setup.py` 文件用于安装项目，可以通过指示 Docker
    如何使用 `pip` 命令来为您的项目创建镜像。
- en: 'In the following example, we introduce the `COPY` command, which will recursively
    copy files and directories from outside the container into the image. We also
    add the `EXPOSE` directive to indicate to anyone running the container that this
    port should be exposed to the outside world. We still need to connect that exposed
    port when we run the container with the `-p` option. Any process inside the container
    can listen to any ports that it wants to, and communicate with itself using localhost,
    but anything outside the container won''t be able to reach the inside unless that
    port has been exposed. It''s also worth noting that localhost inside the container
    only refers to the container, not the computer that''s hosting the running containers;
    so, if you need to communicate with other services, you will need to use its real
    IP address:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们介绍了 `COPY` 命令，该命令将递归地从容器外部复制文件和目录到镜像中。我们还添加了 `EXPOSE` 指令，以告知任何运行容器的用户，该端口应公开给外部世界。当我们使用
    `-p` 选项运行容器时，我们仍然需要连接到那个公开的端口。容器内的任何进程都可以监听它想要的任何端口，并使用 localhost 与自身通信，但除非该端口已公开，否则容器外部的任何东西都无法到达容器内部。也值得注意，容器内部的
    localhost 仅指容器本身，而不是托管运行容器的计算机；因此，如果您需要与其他服务通信，您将需要使用其实际 IP 地址：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `3.9` tag here will get the latest Python 3.9 image that was uploaded to
    Docker Hub. Now we can run our new container, exposing the port it needs:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的 `3.9` 标签将获取上传到 Docker Hub 的最新 Python 3.9 镜像。现在我们可以运行我们的新容器，并公开它需要的端口：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Press Ctrl + C to stop the container, or from another terminal window, find
    the container and tell it to stop:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 Ctrl + C 停止容器，或者从另一个终端窗口中找到容器并告诉它停止：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `COPY` command automatically creates the top-level `app` directory in the
    container and copies everything from "`.`" in it. One important detail to remember
    with the `COPY` command is that any change to the local directory ("`.`") invalidates
    the Docker cache, and builds from that step. To tweak this mechanism, you can
    create a `.dockerignore` file where you can list files and directories that should
    be ignored by Docker, such as the `.git` directory that stores all the history
    and metadata about your version control.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 命令自动在容器中创建顶级 `app` 目录，并将 "`.`" 中的所有内容复制进去。关于 `COPY` 命令的一个重要细节是，对本地目录
    ("`.`") 的任何更改都会使 Docker 缓存失效，并从该步骤开始构建。为了调整这个机制，您可以在 `.dockerignore` 文件中列出 Docker
    应该忽略的文件和目录，例如存储所有版本控制历史和元数据的 `.git` 目录。'
- en: We are not using a virtual environment inside the container, as we are already
    in an isolated environment. We also run our Quart application using Hypercorn,
    a good practice for production use as we discussed in *Chapter 9*, *Packaging
    and Running Python*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在容器内没有使用虚拟环境，因为我们已经在一个隔离的环境中。我们还使用 Hypercorn 运行我们的 Quart 应用程序，这是我们在第 9 章 *打包和运行
    Python* 中讨论的生产使用的好做法。
- en: That is why the `CMD` instruction, which tells the container what command to
    run when it starts, uses **Hypercorn**. `CMD` can take a normal shell command
    as an argument, but this does get interpreted by the shell inside the container,
    meaning that it could go wrong if there are symbols the shell interprets differently,
    such as `*` and `?`. It's much safer to provide a list, in a format you may be
    familiar with, if you have ever used the Python subprocess module ([https://docs.python.org/3/library/subprocess.html](https://docs.python.org/3/library/subprocess.html))
    or used exec system calls.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，`CMD` 指令，它告诉容器启动时应该运行什么命令，使用了 **Hypercorn**。`CMD` 可以接受一个正常的 shell 命令作为参数，但这会被容器内部的
    shell 解释，这意味着如果存在 shell 不同的符号解释，如 `*` 和 `?`，可能会出错。如果您曾经使用过 Python 的 subprocess
    模块 ([https://docs.python.org/3/library/subprocess.html](https://docs.python.org/3/library/subprocess.html))
    或使用过 exec 系统调用，那么提供一个列表会更安全，格式可能与您熟悉。
- en: The next thing we need to do is orchestrate different containers so that they
    can work together. Let's see in the next section how we can do that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是编排不同的容器，以便它们可以协同工作。让我们在下一节中看看我们如何做到这一点。
- en: Docker-based deployments
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Docker 的部署
- en: Deploying a microservice at scale can be done by running several containers
    spread across either one or several instances. When we are developing our application
    locally, we are limited to what our one desktop or laptop computer can provide;
    but for a production service, it may run on dozens or hundreds of servers, with
    each one running a container that is providing different parts of the application.
    Each of the options for deploying your application in the cloud, or scaling it
    up to meet your needs, will involve running more instances, to run more containers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模部署微服务时，可以通过运行分布在单个或多个实例上的多个容器来实现。当我们本地开发应用程序时，我们受限于我们的一台桌面或笔记本电脑所能提供的资源；但对于生产服务来说，它可能运行在数十或数百台服务器上，每台服务器运行一个容器，提供应用程序的不同部分。您在云中部署应用程序或扩展以满足您需求的每个选项都将涉及运行更多实例，以运行更多容器。
- en: The first to examine is Docker Compose, which is aimed at smaller-scale deployments,
    mostly contained in a single instance, but running multiple containers. This is
    ideal for a development environment, a staging environment, or a prototype. Other
    options we will look at are Docker Swarm and Kubernetes, which provide different
    levels of complexity for someone deploying an application, but also increasing
    levels of flexibility and power. Both options will also need someone to run cloud
    instances or bare-metal servers on which to run the containers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要检查的是Docker Compose，它旨在针对较小规模的部署，通常包含在一个实例中，但运行多个容器。这对于开发环境、预发布环境或原型来说非常理想。我们将探讨的其他选项包括Docker
    Swarm和Kubernetes，它们为部署应用程序的人提供了不同级别的复杂性，但也增加了灵活性和功能。这两种选项还需要有人运行云实例或裸机服务器来运行容器。
- en: Once your Docker image is created, every host that runs a Docker daemon can
    be used to run as many containers as you want within the limits of the physical
    resources. We will examine several different options, to gain a broad overview
    of the features and complexity involved.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了Docker镜像，每个运行Docker守护进程的主机都可以用来在物理资源限制内运行尽可能多的容器。我们将探讨几个不同的选项，以获得有关功能和复杂性的广泛概述。
- en: There is no need to over-complicate your initial application. It might be tempting
    to go with a large Kubernetes cluster, but if your application does not need to
    scale that way, it's a wasted effort. Use the metrics collected about your application
    and the knowledge of upcoming business changes to adjust to plan for what you
    need, not what you might want.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要使您的初始应用程序过于复杂。可能会诱使您选择一个大的Kubernetes集群，但如果您的应用程序不需要以这种方式扩展，那将是一种浪费。使用关于您应用程序的指标和即将到来的业务变化的知识来调整计划，以满足您的需求，而不是您可能想要的需求。
- en: To experiment with the **Terraform**, **Docker Swarm**, and **Kubernetes** examples
    in this book and on [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample),
    you will need to create an account on AWS by visiting [https://aws.amazon.com/](https://aws.amazon.com/).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此书和[https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample)上的**Terraform**、**Docker
    Swarm**和**Kubernetes**示例进行实验，您需要通过访问[https://aws.amazon.com/](https://aws.amazon.com/)在AWS上创建一个账户。
- en: Once you have set up the account, visit the **Identity and Access Management**
    (**IAM**) page to create a service user that can create and change resources.
    You could use your root—or main—account to do all of the work, but it is better
    to create service accounts for this purpose, as it means that any leaked access
    keys or secrets can be easily revoked—and new ones created—without causing major
    trouble for accessing the account in general. We should follow the principle of
    least privilege, as we discussed in *Chapter 7*, *Securing Your Services*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您设置了账户，请访问**身份和访问管理**（**IAM**）页面以创建一个可以创建和更改资源的服务用户。您可以使用您的root或主要账户来完成所有工作，但最好为此目的创建服务账户，因为这意味着任何泄露的访问密钥或秘密都可以轻松撤销——并创建新的——而不会对访问账户造成重大麻烦。我们应该遵循最小权限原则，正如我们在*第7章*，*保护您的服务*中讨论的那样。
- en: Once on the IAM page, click **Add User** and request **Programmatic Access**
    so that you can obtain API keys to use this account in a program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入IAM页面，点击**添加用户**并请求**程序访问**，以便您可以使用API密钥在程序中使用此账户。
- en: '![](img/B17108_10_01.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17108_10_01.png)'
- en: 'Figure 10.1: IAM Add user page in AWS'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：AWS中的IAM添加用户页面
- en: Create a group to control the user's permissions more easily. Grant this new
    group the permissions to modify EC2 instances, since it covers most of what we
    will be changing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个组以更轻松地控制用户的权限。授予这个新组修改EC2实例的权限，因为它涵盖了我们将要更改的大部分内容。
- en: '![](img/B17108_10_02.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17108_10_02.png)'
- en: 'Figure 10.2: Naming the group and setting permissions'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：命名组和设置权限
- en: Once the group is created, you will get a chance to download the new **Access
    Key ID** and **Secret Access Key**. These will be used to grant access to any
    programs that we use to create instances and other cloud resources.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了组，您将有机会下载新的**访问密钥ID**和**秘密访问密钥**。这些将用于授权访问我们用来创建实例和其他云资源的任何程序。
- en: 'Most of these tools are Infrastructure-as-Code. That is to say, you will have
    a configuration file, or set of files, that describe what your running services
    will look like, and what resources they require. This configuration should also
    be kept in version control so that any changes can be managed. Whether it is in
    the same source control repository as your code will depend on how you need to
    deploy the software: If you are continuously deploying new versions, then it can
    be helpful to keep the configuration alongside the application, but in many cases,
    it is much clearer to keep it separate, especially if the CI pipelines will be
    difficult to coordinate between the deployments and the code''s own test and packaging
    tasks.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的大多数都是基础设施即代码。也就是说，您将有一个配置文件，或一组文件，描述您的运行服务将看起来是什么样子，以及它们需要哪些资源。此配置还应保留在版本控制中，以便任何更改都可以得到管理。它是否与您的代码存储在同一源代码控制仓库中将取决于您如何部署软件：如果您正在持续部署新版本，那么将配置与应用程序一起保留可能会有所帮助，但在许多情况下，将其分开会更清晰，特别是如果CI管道在部署和代码的测试与打包任务之间难以协调。
- en: Terraform
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we are defining a resource called `swarm_cluster`, in which will create
    three new instances, using an `Ubuntu Focal` base image. We set the instance size
    to `t3.micro` because we are trying things out and want to minimize the cost.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`swarm_cluster`的资源，我们将使用`Ubuntu Focal`基础镜像创建三个新实例。我们将实例大小设置为`t3.micro`，因为我们正在尝试新事物，并希望最小化成本。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Using Terraform, we can create and destroy our cloud resources in a CI/CD pipeline
    in a similar way that we test and deploy our application code. The following has
    in-depth tutorials and worked examples, and there are many community-provided
    modules to perform common tasks: [https://learn.hashicorp.com/terraform](https://learn.hashicorp.com/terraform).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Terraform，我们可以在CI/CD管道中以类似测试和部署我们的应用程序代码的方式创建和销毁我们的云资源。以下有深入的教程和示例，并且有许多社区提供的模块来执行常见任务：[https://learn.hashicorp.com/terraform](https://learn.hashicorp.com/terraform)。
- en: 'Terraform''s `plan` command will show you what changes will be made to your
    cloud infrastructure when you run `terraform apply`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform的`plan`命令将在您运行`terraform apply`时显示对您的云基础设施所做的更改：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you are done with any experiments, you can run `terraform destroy` to clear
    up any resources managed by Terraform—although this is a dangerous command for
    a production service!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成任何实验，您可以通过运行`terraform destroy`来清除Terraform管理的任何资源——尽管这是一个对于生产服务来说非常危险的命令！
- en: Service discovery
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务发现
- en: While Docker tries to provide all the tools to deal with clusters of containers,
    managing them can become quite complex. When done properly, it requires sharing
    some configuration across hosts, and to make sure that bringing containers up
    and down is partially automated.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker试图提供处理容器集群的所有工具，但管理它们可能会变得相当复杂。当正确执行时，它需要在主机之间共享一些配置，并确保启动和停止容器部分自动化。
- en: We very quickly come across scenarios that complicate a static configuration.
    If we need to move a microservice to a new AWS region, or a different cloud provider
    entirely, then how do we tell all the other microservices that use it? If we add
    a new feature that's controlled by a feature flag, how do we quickly turn it on
    and off? On a smaller scale, how does a load balancer know about all the containers
    that should receive traffic?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会遇到使静态配置复杂化的场景。如果我们需要将微服务迁移到新的AWS区域，或者完全迁移到不同的云服务提供商，那么我们如何通知使用它的所有其他微服务呢？如果我们添加了一个由功能标志控制的新功能，我们如何快速地打开和关闭它？在更小的范围内，负载均衡器如何知道应该接收流量的所有容器？
- en: Service discovery is an orchestration method that aims to solve these problems.
    Tools such as **Consul** ([https://www.consul.io/](https://www.consul.io/)) and
    **etcd** ([https://etcd.io/](https://etcd.io/)) allow values to be stored behind
    well-known keys and updated dynamically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现是一种旨在解决这些问题的编排方法。例如 **Consul** ([https://www.consul.io/](https://www.consul.io/))
    和 **etcd** ([https://etcd.io/](https://etcd.io/)) 这样的工具允许在知名键后存储值并动态更新。
- en: Instead of deploying your service with full knowledge of all the URLs it might
    connect to, you provide it with the address of a service discovery tool, and the
    list of keys it should look up for each element. When a microservice starts up,
    and at regular intervals, it can check where it should be sending traffic, or
    whether a feature should be turned on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必完全了解所有可能连接到的 URL 来部署你的服务，你可以提供服务发现工具的地址以及它应该查找的每个元素的键列表。当微服务启动时，以及定期，它可以检查它应该发送流量到何处，或者是否应该开启某个功能。
- en: 'We will use `etcd` as an example, with a basic Quart service, while also utilizing
    the `etcd3` Python library. Assuming you have `etcd` running with the default
    options after following the instructions on their website, we can add some configuration-updating
    code to our service, and have an endpoint that returns the URL we would contact,
    if the application was more complete:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 `etcd` 为例，使用基本的 Quart 服务，同时利用 `etcd3` Python 库。假设你按照他们网站上的说明在默认选项下运行了 `etcd`，我们可以在我们的服务中添加一些配置更新代码，并有一个返回我们如果应用程序更完整时会联系到的
    URL 的端点：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, we load the keys in the `settings_map` when the application
    starts, including `/services/dataservice/url`, which we can then validate and
    use. Any time that value changes in `etcd`, the `watch_callback` function will
    be run in its own thread, and the app''s configuration updated:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在应用程序启动时加载 `settings_map` 中的密钥，包括 `/services/dataservice/url`，然后我们可以对其进行验证和使用。任何在
    `etcd` 中值变化时，`watch_callback` 函数将在其自己的线程中运行，并更新应用程序的配置：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Updating the live configuration is a simple command!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更新实时配置只是一个简单的命令！
- en: If your application has configuration options that depend on each other, such
    as pairs of access tokens, it is best to encode them in a single option so that
    they are updated in a single operation. If something fails and only one of a co-dependent
    set of configuration settings is updated, your application will behave in unwanted
    and unexpected ways.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序有相互依赖的配置选项，例如访问令牌对，最好将它们编码在单个选项中，以便在单个操作中更新。如果出现问题并且只有一组相互依赖的配置设置中的一个被更新，你的应用程序将以不受欢迎和不期望的方式运行。
- en: Docker Compose
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose
- en: The commands required to run several containers on the same host can be quite
    long once you need to add names and networks and bind several sockets. Docker
    Compose ([https://docs.docker.com/compose/](https://docs.docker.com/compose/))
    simplifies the task by letting you define multiple containers' configuration in
    a single configuration file, as well as how those containers depend on each other.
    This utility is installed on macOS and Windows alongside Docker. For Linux distributions,
    there should be a system package available to install it, or you can obtain an
    installation script by following the instructions at [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一主机上运行多个容器所需的命令可能会相当长，一旦你需要添加名称和网络以及绑定多个套接字。Docker Compose ([https://docs.docker.com/compose/](https://docs.docker.com/compose/))
    通过允许你在单个配置文件中定义多个容器的配置以及这些容器如何相互依赖，简化了这项任务。此实用程序与 Docker 一起安装在 macOS 和 Windows
    上。对于 Linux 发行版，应该有一个系统包可供安装，或者你可以按照[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)中的说明获取安装脚本。
- en: Once the script is installed on your system, create a `yaml` file containing
    the information about services and networks that you want to run. The default
    filename is `docker-compose.yml`, and so we will use that name for our examples
    to make the commands simpler.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本安装到你的系统上，创建一个包含你想要运行的服务和网络信息的 `yaml` 文件。默认文件名是 `docker-compose.yml`，因此我们将使用该名称作为我们的示例以简化命令。
- en: 'The compose configuration file has many options that let you define every aspect
    of the deployment of several containers. It''s like a Makefile for a group of
    containers. This URL lists all options: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 配置文件有许多选项，允许你定义多个容器部署的各个方面。它就像一组容器的 Makefile。此 URL 列出了所有选项：[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)。
- en: 'In the following example, the `.yaml` file is placed one directory above two
    of our Jeeves microservices and defines three services: the `dataservice` and
    the `tokendealer`, which are built locally from their Dockerfile; the third is
    RabbitMQ, and we use an image published on Docker Hub to run that:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`.yaml`文件位于我们的Jeeves微服务目录之上，并定义了三个服务：`dataservice`和`tokendealer`，它们是从各自的Dockerfile本地构建的；第三个是RabbitMQ，我们使用Docker
    Hub上发布的镜像来运行它：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Compose` file also creates networks with its `networks` sections, allowing
    the containers to communicate with each other. They will get private DNS entries
    so they can be referred to with the image names, such as `dataservice`, `tokendealer`,
    and `rabbitmq` in the example above. To build and run those three containers,
    you can use the `up` command as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Compose`文件也通过其`networks`部分创建网络，允许容器之间进行通信。它们将获得私有DNS条目，因此可以使用图像名称来引用它们，例如上面示例中的`dataservice`、`tokendealer`和`rabbitmq`。要构建和运行这三个容器，您可以使用以下`up`命令：'
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first time that command is executed, the two local container images will
    be built. These will either be static, or you can assign volumes to them to mount
    in the source code and continue developing on them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行该命令时，将构建两个本地容器镜像。这些镜像可以是静态的，或者您可以分配卷给它们，将源代码挂载到上面并继续在上面开发。
- en: Using Docker Compose is great when you want to provide a full working stack
    for your microservices, which includes every piece of software needed to run it.
    For instance, if you are using a Postgres database, you can use the Postgres image
    ([https://hub.docker.com/_/postgres/](https://hub.docker.com/_/postgres/)) and
    link it to your service in a Docker Compose file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想为微服务提供一个完整的运行堆栈时，使用Docker Compose是非常好的，这个堆栈包括运行它所需的每一件软件。例如，如果您正在使用Postgres数据库，您可以使用Postgres镜像（[https://hub.docker.com/_/postgres/](https://hub.docker.com/_/postgres/)）并将其链接到Docker
    Compose文件中的服务。
- en: Containerizing everything, even the databases, is a great way to showcase your
    software, or simply a good option for development purposes. However, as we stated
    earlier, a Docker container should be seen as an ephemeral filesystem. So if you
    use a container for your database, make sure that the directory where the data
    is written is mounted on the host filesystem. In most cases, however, the database
    service is usually its dedicated server on a production deployment. Using a container
    does not make much sense and adds only a little bit of overhead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容，包括数据库，都进行容器化是一种展示您软件的绝佳方式，或者简单地说是开发目的的一个好选择。然而，正如我们之前所述，Docker容器应被视为一个短暂的文件系统。因此，如果您为数据库使用容器，请确保数据写入的目录已挂载在主机文件系统上。然而，在大多数情况下，数据库服务通常是生产部署中其专用的服务器。使用容器并没有太多意义，只会增加一点开销。
- en: Docker Swarm
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker has a built-in cluster functionality called **swarm** mode ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
    This mode has an impressive list of features, which lets you manage all your container
    clusters from a single utility. This makes it ideal for smaller deployments or
    ones that do not need to scale up and down as flexibly to meet changing demands.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有一个内置的集群功能，称为**swarm**模式（[https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/））。这种模式具有令人印象深刻的特性列表，让您可以从单个实用程序管理所有容器集群。这使得它非常适合较小的部署或不需要灵活地扩展和缩减以满足不断变化的需求。
- en: Once you have deployed a cluster, you need to set up a load balancer so that
    all the instances of your cluster are sharing the workload. The load balancer
    is commonly software such as nginx, OpenResty, or HAProxy, and is the entry point
    to distribute the incoming requests on clusters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦部署了集群，您需要设置一个负载均衡器，以便集群的所有实例都能共享工作负载。负载均衡器通常是nginx、OpenResty或HAProxy等软件，它是集群中分发传入请求的入口点。
- en: To set up a swarm, all we really need are three EC2 instances, provided we can
    connect to them using port `22` for SSH access to configure them, and port `2377`
    for Docker's own communication. We should also allow any ports that our application
    needs, such as port `443` for HTTPS connections.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个swarm，我们实际上只需要三个EC2实例，前提是我们可以通过端口`22`使用SSH访问来配置它们，以及端口`2377`用于Docker自身的通信。我们还应该允许我们的应用程序需要的任何端口，例如端口`443`用于HTTPS连接。
- en: 'To create a swarm, we must create a manager node that will organize the rest.
    Using one of the nodes you have just created, connect to it using SSH, and convert
    it to a Docker Swarm manager:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个swarm，我们必须创建一个管理节点来组织其余部分。使用您刚刚创建的一个节点，使用SSH连接到它，并将其转换为Docker Swarm管理器：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To add a worker to this swarm, run the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要向这个集群添加一个工作节点，请运行以下命令：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To add a manager to this swarm, run `docker swarm join-token manager` and follow
    the instructions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要向这个集群添加一个管理节点，请运行 `docker swarm join-token manager` 并遵循指示。
- en: 'Copy the `docker` `swarm` command provided, and paste it into an SSH session
    on the other instances you have created. You may need to run `sudo` to gain root
    access before the commands will work. On the manager node, we can now see all
    our workers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 复制提供的 `docker` `swarm` 命令，并将其粘贴到你在其他创建的实例上的 SSH 会话中。在命令生效之前，你可能需要运行 `sudo` 以获得
    root 权限。在管理节点上，我们现在可以看到所有我们的工作节点：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now all we need to do is create our services:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是创建我们的服务：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From here, we can scale our service up and down as we need to. To create five
    copies of our dataservice, we would issue a scale command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以根据需要调整我们的服务规模。要创建我们数据服务的五个副本，我们需要发出一个缩放命令：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As long as our manager node remains available, and some of the worker nodes
    are up, then our container service will remain active. We can terminate one of
    the cloud instances and watch things rebalance to the remaining instances with
    `docker service ps`. Adding more nodes is as easy as adjusting a variable in the
    Terraform configuration and re-running `terraform` `apply`, before then joining
    them to the swarm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的管理节点保持可用，并且一些工作节点处于运行状态，我们的容器服务就会保持活跃。我们可以终止一个云实例，并通过 `docker service ps`
    观察事情如何重新平衡到剩余的实例。添加更多节点就像在 Terraform 配置中调整一个变量并重新运行 `terraform apply` 一样简单，然后再将它们加入集群。
- en: Looking after the suite of cloud instances is still work, but this environment
    provides a neat way of providing a resilient container deployment, especially
    early on in an application's life.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 照顾这一套云实例仍然是一项工作，但这个环境提供了一种提供弹性容器部署的整洁方式，尤其是在应用程序生命周期的早期。
- en: Kubernetes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Originally designed by Google, but now maintained by an independent foundation,
    **Kubernetes** ([https://kubernetes.io/](https://kubernetes.io/), also known as
    k8s) provides a platform-independent way of automating work with containerized
    systems, allowing you to describe the system in terms of different components,
    and issuing commands to a controller to adjust settings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 原本由谷歌设计，但现在由一个独立基金会维护的**Kubernetes** ([https://kubernetes.io/](https://kubernetes.io/),
    也称为 k8s) 提供了一种平台无关的方式来自动化容器化系统的操作，允许你用不同组件的术语来描述系统，并向控制器发出命令以调整设置。
- en: Like Docker Swarm, Kubernetes also runs on a cluster of servers. It's possible
    to run this cluster yourself, although some cloud providers do have a service
    that makes managing the fleet of instances much easier. A good example of this
    is the **eksctl** utility for AWS ([https://eksctl.io/](https://eksctl.io/)).
    While not created by Amazon, it is an officially supported client for creating
    clusters in Amazon's Elastic Kubernetes Service.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Docker Swarm 一样，Kubernetes 也运行在一组服务器上。虽然你可以自己运行这个集群，但一些云提供商确实提供了一种服务，使得管理实例群组变得更加容易。一个很好的例子是
    AWS 的 **eksctl** 工具 ([https://eksctl.io/](https://eksctl.io/))。虽然它不是由亚马逊创建的，但它是一个官方支持的客户端，用于在亚马逊的弹性
    Kubernetes 服务中创建集群。
- en: 'Rather than create all the AWS resources yourself, or create Terraform configuration
    to do so, `eksctl` performs all the work for you, with sensible defaults for experimenting
    with Kubernetes. To get started, it is best to use the AWS credentials we created
    for earlier examples and to install both `eksctl` and `kubectl`—the Kubernetes
    command line. The AWS credentials will be used by `eksctl` to create the cluster
    and other necessary resources, and once done, `kubectl` can be used to deploy
    services and software. Unlike Docker Swarm, kubectl''s administrative commands
    are designed to be run from your own computer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是自己创建所有 AWS 资源，或者创建 Terraform 配置来这样做，`eksctl` 会为你完成所有工作，并提供合理的默认值来实验 Kubernetes。要开始，最好使用我们为早期示例创建的
    AWS 凭据，并安装 `eksctl` 和 `kubectl`——Kubernetes 命令行工具。AWS 凭据将由 `eksctl` 用于创建集群和其他必要资源，一旦完成，就可以使用
    `kubectl` 来部署服务和软件。与 Docker Swarm 不同，kubectl 的管理命令旨在从你的计算机上运行：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It will take a few minutes to create the cluster, but once done, it will write
    the credentials `kubectl` needs to the correct file, so no further setup should
    be needed. We told `eksctl` to create four nodes, and that''s exactly what it
    has done:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集群可能需要几分钟，但一旦完成，它就会将 `kubectl` 需要的凭据写入正确的文件，因此不需要进一步的设置。我们告诉 `eksctl` 创建四个节点，这正是它所做的事情：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the moment, we have nothing running on our `k8s` cluster, so we shall create
    some work for it to do. The fundamental unit of work for `k8s` is a `pod`, which
    describes a set of running containers on the cluster. We have not created any
    of our own yet, but there are some running in a different namespace to help k8s
    do its own work of managing the rest of the tasks we set it. Namespaces like this
    can be useful for grouping sets of tasks together, making it easier to understand
    what is important when looking at the cluster:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在`k8s`集群上没有运行任何东西，所以我们将为它创建一些工作要做。`k8s`的基本工作单元是`pod`，它描述了集群上运行的一组容器。我们还没有创建自己的，但有一些在不同的命名空间中运行，以帮助k8s完成我们设定的其他任务的管理。这样的命名空间可以用于将任务集分组在一起，使在查看集群时更容易理解哪些是重要的：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A Pod is a low-level description of some work for the cluster, and to help make
    life easier, there are higher-level abstractions for different types of work,
    such as a `Deployment` for a stateless application, such as a web interface or
    proxy, a `StatefulSet` for when your workload needs storage attached rather than
    keeping its data in a different service, as well as Jobs and CronJobs for one-off
    tasks and scheduled repeating tasks, respectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是对集群中某些工作的低级描述，为了使生活更轻松，还有针对不同类型工作的更高级抽象，例如用于无状态应用（如Web界面或代理）的`Deployment`，当你的工作负载需要附加存储而不是将数据保存在不同的服务中时，使用`StatefulSet`，以及用于一次性任务和计划重复任务的`Jobs`和`CronJobs`。
- en: 'Kubernetes accepts manifests of instructions that it should apply. A good starting
    point is to set up nginx, with a manifest such as this one:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes接受它应该应用的指令的清单。一个好的起点是设置nginx，使用如下清单：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We include some metadata about the type of resource we are requesting—a `Deployment`—and
    its name, and then dive into the specification for the service. Down at the bottom
    of the file, we can see that we've asked for a container based on the `nginx:1.21.0
    image`, and that it should have port `80` open. One layer up, we describe this
    container specification as a template that we use to create three different copies
    and run them on our cluster.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在请求的资源类型（`Deployment`）及其名称中包含一些元数据，然后深入到服务的规范中。在文件的底部，我们可以看到我们请求了一个基于`nginx:1.21.0
    image`的容器，并且它应该打开端口`80`。再往上一层，我们把这个容器规范描述为一个模板，我们用它来创建三个不同的副本并在我们的集群上运行。
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using kubectl''s `describe` subcommand, we get even more information about
    what was created for us:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl的`describe`子命令，我们可以获取更多关于为我们创建的内容的信息：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we decide we need more nginx containers, we can update the manifest. Change
    the number of replicas in our `yaml` file from three to eight, and re-apply the
    manifest:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定需要更多的nginx容器，我们可以更新清单。将我们的`yaml`文件中的副本数量从三个更改为八个，并重新应用清单：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A similar change could be performed to upgrade the version of nginx, and Kubernetes
    has several strategies to perform updates of a service so that end users are unlikely
    to notice it happening. For example, it is possible to create an entirely new
    Pod of containers and redirect traffic to it, but it's also possible to do rolling
    updates inside a Pod, where a container is only destroyed when its replacement
    has successfully started. How can you tell the container was successfully started?
    Kubernetes allows you to describe what it should look for to check whether a container
    can do its work, and how long it should wait for a container to start, with its
    liveness and readiness checks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以进行类似的更改来升级nginx的版本，Kubernetes有几种策略来执行服务的更新，以便最终用户不太可能注意到它的发生。例如，可以创建一个全新的容器Pod并将其流量重定向到它，但也可以在Pod内部进行滚动更新，其中容器只有在它的替代品成功启动后才会被销毁。如何判断容器已成功启动？Kubernetes允许你描述它应该查找的内容以检查容器是否可以执行其工作，以及它应该等待容器启动多长时间，使用其存活性和就绪性检查。
- en: If you have been following along with the examples, remember to delete the cloud
    resources when you are done, as they cost. To remove just the nginx-deeployment
    we created, use `kubectl`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随示例，记得当你完成时删除云资源，因为它们会产生费用。要删除我们创建的nginx-deployment，请使用`kubectl`。
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But to destroy the entire cluster, return to using `eksctl`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但要销毁整个集群，请返回使用`eksctl`：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a very brief overview of an enormously powerful tool, as the topic could
    cover an entire book by itself. For those who need it, the time spent learning
    Kubernetes is well spent, but as ever, you must assess the needs of your own application,
    and whether something simpler will get the job done.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于一个极其强大工具的简要概述，因为这个主题本身可能需要一本书来详细阐述。对于那些需要它的人来说，花时间学习Kubernetes是值得的，但正如以往一样，你必须评估你自己的应用需求，以及是否有一些更简单的方法可以完成任务。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked at how microservices can be containerized with containers,
    and how you can create a deployment entirely based on Docker images. Containers
    are a well-established technology that is widely used to run internet services.
    The most important thing to keep in mind is that a containerized application is
    ephemeral: it is designed to be destroyed and recreated on demand, and any data
    that is not externalized using a mount point is lost.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用容器将微服务容器化，以及如何完全基于Docker镜像创建部署。容器是一种成熟的技术，广泛用于运行互联网服务。需要牢记的最重要的一点是，容器化应用是短暂的：它被设计成按需销毁和重建，并且任何未通过挂载点外部化的数据都会丢失。
- en: For provisioning and clustering your services, there is no generic solution,
    as the tools you use will depend on your needs. From a simple Docker Compose setup
    to a full Kubernetes cluster, each option provides different complexity and benefits.
    The best choice often depends on where you are to deploy your services, how your
    teams work, and how large your application needs to be in the present—there is
    no sense in planning for an unknowable future.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务配置和集群，没有通用的解决方案，因为使用的工具将取决于你的需求。从简单的Docker Compose设置到完整的Kubernetes集群，每个选项都提供了不同的复杂性和好处。最佳选择通常取决于你打算在哪里部署你的服务，你的团队如何工作，以及你的应用当前需要多大——为不可知的未来规划是没有意义的。
- en: The best way to tackle this problem is to take baby steps by first deploying
    everything manually, then automating where it makes sense. Automation is great,
    but can rapidly become difficult if you use a toolset you do not fully understand,
    or that is too complex for your needs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方式是先通过手动部署一切来迈出小步，然后在合理的地方进行自动化。自动化很棒，但如果使用你不完全理解的工具集，或者工具过于复杂，它很快就会变得困难。
- en: 'As a guide, consider:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指导，请考虑：
- en: Docker Compose when you need to deploy multiple containers in a small environment,
    and do not need to manage a large infrastructure.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要在小型环境中部署多个容器，且不需要管理大型基础设施时，使用Docker Compose。
- en: Docker Swarm when you need flexibility in how many containers are deployed,
    to respond to a changing situation, and are happy to manage a larger cloud infrastructure.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要灵活性来部署多少个容器以应对不断变化的情况，并且愿意管理更大的云基础设施时，使用Docker Swarm。
- en: Kubernetes when automation and flexibility are paramount, and you have people
    and time available to manage the infrastructure and handle the complexity.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当自动化和灵活性至关重要，且你有人员和时间来管理基础设施和处理复杂性时，使用Kubernetes。
- en: You will not be locked into one orchestration tool once you choose it, as the
    containers you build can be used in any of them, but moving to a different orchestration
    tool can be hard work, depending on how complex your configuration is.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了某个编排工具，你不会局限于它，因为构建的容器可以在任何工具中使用，但根据你的配置复杂程度，迁移到不同的编排工具可能会是一项艰巨的工作。
- en: In that vein, to make their services easier to use and more appealing, cloud
    providers have built-in features to handle deployments. The three largest cloud
    providers are currently AWS, Google Cloud, and Microsoft Azure, although many
    other good options exist.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方向上，为了使他们的服务更容易使用和更具吸引力，云服务提供商内置了处理部署的功能。目前最大的三个云服务提供商是AWS、Google Cloud和Microsoft
    Azure，尽管存在许多其他不错的选择。
