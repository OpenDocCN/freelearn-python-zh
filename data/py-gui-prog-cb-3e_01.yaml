- en: Creating the GUI Form and Adding Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 GUI 表单并添加控件
- en: In this chapter, we will develop our first GUI in Python. We will start with
    the minimum code required to build a running GUI application. Each recipe then
    adds different widgets to the GUI form.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 开发我们的第一个 GUI。我们将从构建运行 GUI 应用程序所需的最少代码开始。然后，每个菜谱都会向 GUI 表单添加不同的控件。
- en: We will start by using the `tkinter` GUI toolkit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `tkinter` 图形用户界面工具包。
- en: '`tkinter` ships with Python. There is no need to install it once you have installed
    Python version 3.7 or later. The `tkinter` GUI toolkit enables us to write GUIs
    with Python.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter` 随 Python 一起提供。一旦安装了 Python 3.7 或更高版本，就无需安装它。`tkinter` 图形用户界面工具包使我们能够使用
    Python 编写 GUI。'
- en: The old world of the DOS Command Prompt has long been outdated. Some developers
    still like it for development work. The end user of your program expects a more
    modern, good-looking GUI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 旧世界的 DOS 命令提示符已经过时。一些开发者仍然喜欢用它进行开发工作。你的程序最终用户期望一个更现代、更美观的 GUI。
- en: In this book, you will learn how to develop GUIs using the Python programming
    language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习如何使用 Python 编程语言开发 GUI。
- en: By starting with the minimum amount of code, we can see the **pattern** every
    GUI written with `tkinter` and Python follows. First come the `import` statements,
    followed by the creation of a `tkinter` class. We then can call methods and change
    attributes. At the end, we always call the Windows event loop. Now we can run
    the code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从最少的代码开始，我们可以看到每个使用 `tkinter` 和 Python 编写的 GUI 都遵循的 **模式**。首先是 `import` 语句，然后是创建一个
    `tkinter` 类。然后我们可以调用方法并更改属性。最后，我们总是调用窗口事件循环。现在我们可以运行代码了。
- en: We progress from the most simple code, adding more and more functionality with
    each following recipe, introducing different widget controls and how to change
    and retrieve attributes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最简单的代码开始，在每个后续菜谱中添加更多功能，引入不同的控件控制以及如何更改和检索属性。
- en: In the first two recipes, we will show the entire code, consisting of only a
    few lines of code. In the following recipes, we will only show the code to be
    added to the previous recipes because, otherwise, the book would get too long,
    and seeing the same code over and over again is rather boring.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个菜谱中，我们将展示整个代码，它只包含几行代码。在随后的菜谱中，我们只展示要添加到先前菜谱中的代码，因为否则这本书会变得太长，反复看到相同的代码会相当无聊。
- en: If you don't have the time to type the code yourself, you can download all of
    the code for the entire book from [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有时间自己输入代码，你可以从 [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)
    下载整本书的代码。
- en: At the beginning of each chapter, I will show the Python modules that belong
    to each chapter. I will then reference the different modules that belong to the
    code shown, studied, and run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每章开始时，我将展示属于每个章节的 Python 模块。然后我将引用属于展示、研究和运行的代码的不同模块。
- en: By the end of this chapter, we will have created a working GUI application that
    consists of labels, buttons, textboxes, comboboxes, check buttons in various states,
    and radio buttons that change the background color of the GUI.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将创建一个包含标签、按钮、文本框、组合框、各种状态下的复选按钮和改变 GUI 背景颜色的单选按钮的工作 GUI 应用程序。
- en: 'Here is an overview of the Python modules (ending in a `.``py` extension) for
    this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章中以 `.py` 扩展名结尾的 Python 模块概述：
- en: '![](img/d997f179-53b2-4bbc-b875-810e9f20d52d.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d997f179-53b2-4bbc-b875-810e9f20d52d.png)'
- en: 'In this chapter, we start creating amazing GUIs using Python 3.7 or later.
    We will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从使用 Python 3.7 或更高版本开始创建令人惊叹的 GUI。我们将涵盖以下主题：
- en: Creating our first Python GUI
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Python GUI
- en: Preventing the GUI from being resized
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止 GUI 被调整大小
- en: Adding a label to the GUI form
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 GUI 表单添加标签
- en: Creating buttons and changing their text attributes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮并更改它们的文本属性
- en: Creating textbox widgets
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文本框小部件
- en: Setting the focus to a widget and disabling widgets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将焦点设置到控件上并禁用控件
- en: Creating combobox widgets
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组合框控件
- en: Creating a check button with different initial states
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有不同初始状态的复选按钮
- en: Using radio button widgets
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单选按钮控件
- en: Using scrolled text widgets
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滚动文本控件
- en: Adding several widgets in a loop
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中添加多个控件
- en: Creating our first Python GUI
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Python GUI
- en: Python is a very powerful programming language. It ships with the built-in `tkinter`
    module. In only a few lines of code (four, to be precise) we can build our first
    Python GUI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常强大的编程语言。它自带内置的`tkinter`模块。仅用几行代码（确切地说，是四行）我们就可以构建我们的第一个Python GUI。
- en: '`tkinter` is a Python **interface** to `tk`. `tk` is a GUI toolkit and related
    to `Tcl`, which is a tool command language. You can learn more about `tk` at [https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter`是Python到`tk`的**接口**。`tk`是一个GUI工具包，与`Tcl`相关，`Tcl`是一种工具命令语言。您可以在[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)了解更多关于`tk`的信息。'
- en: Another website related to `tcl` and `tk` is [https://www.tcl.tk/](https://www.tcl.tk/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与`tcl`和`tk`相关的网站是[https://www.tcl.tk/](https://www.tcl.tk/)。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe, a working Python development environment is a prerequisite.
    The IDLE GUI, which ships with Python, is enough to start. IDLE was built using
    `tkinter`!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个食谱，一个有效的Python开发环境是先决条件。Python附带的IDLE GUI足以开始。IDLE是使用`tkinter`构建的！
- en: How to do it…
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s take a look at how to create our first Python GUI:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建我们的第一个Python GUI：
- en: Create a new Python module and name it `First_GUI.py`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块并将其命名为`First_GUI.py`。
- en: 'At the top of the `First_GUI.py` module, import `tkinter`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`First_GUI.py`模块的顶部导入`tkinter`：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an instance of the `Tk` class:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Tk`类的实例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the instance variable to set a title:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用实例变量设置标题：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start the window''s main event loop:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动窗口的主事件循环：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the four lines of `First_GUI.py` required to
    create the resulting GUI:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建结果的GUI所需的`First_GUI.py`的四个代码行：
- en: '![](img/7806e7de-8ff9-4871-b8ad-d4c0f74b6b1e.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7806e7de-8ff9-4871-b8ad-d4c0f74b6b1e.png)'
- en: 'Run the GUI module. On executing the preceding code, the following output is
    obtained:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行GUI模块。在执行前面的代码后，得到以下输出：
- en: '![](img/abb1665f-46b1-4ced-b517-e57213a64560.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abb1665f-46b1-4ced-b517-e57213a64560.png)'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *line 9*, we import the built-in `tkinter` module and alias it as `tk` to
    simplify our Python code. In *line 12*, we create an instance of the `Tk` class
    by calling its constructor (the parentheses appended to `Tk` turns the class into
    an instance). We are using the `tk` alias so we don't have to use the longer word
    `tkinter`. We are assigning the class instance to a variable named `win` (short
    for a window) so that we can access the class attributes via this variable. As
    Python is a dynamically typed language, we did not have to declare this variable
    before assigning to it, and we did not have to give it a specific type. Python
    *infers* the type from the assignment of this statement. Python is a strongly
    typed language, so every variable always has a type. We just don't have to specify
    its type beforehand like in other languages. This makes Python a very powerful
    and productive language to program in.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第9行*，我们导入内置的`tkinter`模块并将其别名为`tk`以简化我们的Python代码。在*第12行*，我们通过调用其构造函数（`Tk`后附加的括号将类转换为实例）创建`Tk`类的实例。我们使用`tk`别名，这样我们就不必使用较长的单词`tkinter`。我们将类实例分配给一个名为`win`（代表窗口）的变量，这样我们就可以通过这个变量访问类属性。由于Python是一种动态类型语言，我们不必在分配之前声明这个变量，也不必给它指定一个特定的类型。Python
    *推断*这个语句的赋值类型。Python是一种强类型语言，所以每个变量始终有一个类型。我们只是不必像在其他语言中那样事先指定它的类型。这使得Python成为编程中非常强大和高效的编程语言。
- en: 'A little note about classes and types: In Python, every variable always has
    a type. We cannot create a variable that does not have a type. Yet, in Python,
    we do not have to declare the type beforehand, as we have to do in the C programming
    language.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类和类型的一点点说明：在Python中，每个变量始终有一个类型。我们无法创建一个没有类型的变量。然而，在Python中，我们不必事先声明类型，就像在C编程语言中那样。
- en: Python is smart enough to infer the type. C#, at the time of writing this book,
    also has this capability.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python足够智能，可以推断类型。在撰写本书时，C#也有这种能力。
- en: Using Python, we can create our own classes using the `class` keyword instead
    of the `def` keyword.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python，我们可以使用`class`关键字而不是`def`关键字来创建我们自己的类。
- en: 'In order to assign the class to a variable, we first have to create an instance
    of our class. We create the instance and assign this instance to our variable,
    for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将类分配给一个变量，我们首先必须创建我们类的实例。我们创建实例并将此实例分配给我们的变量，例如：
- en: '`class AClass(object):` `print(''Hello from AClass'')` `class_instance = AClass()`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`class AClass(object):` `print(''Hello from AClass'')` `class_instance = AClass()`'
- en: Now, the `class_instance` variable is of the `AClass` type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`class_instance`变量是`AClass`类型。
- en: If this sounds confusing, do not worry. We will cover **object-oriented programming**
    (**OOP**) in the coming chapters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，不要担心。我们将在接下来的章节中介绍**面向对象编程**（**OOP**）。
- en: In line 15, we use the instance variable (`win`) of the class to give our window
    a title by calling the `title()` method, passing in a string.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15行，我们使用类的实例变量（`win`）通过调用`title()`方法并传入一个字符串来给我们的窗口设置标题。
- en: You might have to enlarge the running GUI to see the entire title.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要放大正在运行的GUI才能看到整个标题。
- en: In line 20, we start the window's event loop by calling the `mainloop` method
    on the class instance, `win`. Up to this point in our code, we have created an
    instance and set one attribute (the window title), but the GUI will not be displayed
    until we start the main event loop.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第20行，我们通过在类实例`win`上调用`mainloop`方法来开始窗口的事件循环。到目前为止，在我们的代码中，我们已经创建了一个实例并设置了一个属性（窗口标题），但GUI将不会显示，直到我们开始主事件循环。
- en: An event loop is a mechanism that makes our GUI work. We can think of it as
    an endless loop where our GUI is waiting for events to be sent to it. A button
    click creates an event within our GUI, or our GUI being resized also creates an
    event.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是一种使我们的GUI工作的机制。我们可以将其视为一个无限循环，其中我们的GUI正在等待事件发送给它。按钮点击在我们的GUI中创建一个事件，或者我们的GUI被调整大小也会创建一个事件。
- en: We can write all of our GUI code in advance and nothing will be displayed on
    the user's screen until we call this endless loop (`win.mainloop()` in the preceding
    code). The event loop ends when the user clicks the red X button or a widget that
    we have programmed to end our GUI. When the event loop ends, our GUI also ends.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提前编写所有的GUI代码，直到我们调用这个无限循环（前述代码中的`win.mainloop()`），用户屏幕上都不会显示任何内容。当事件循环结束时，用户点击红色X按钮或我们编程来结束GUI的小部件时，事件循环结束。当事件循环结束时，我们的GUI也结束了。
- en: This recipe used the minimum amount of Python code to create our first GUI program.
    However, throughout this book we will use OOP when it makes sense.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用了最少的Python代码来创建我们的第一个GUI程序。然而，在这本书中，当有需要时，我们会使用面向对象编程（OOP）。
- en: We've successfully learned how to create our first Python GUI. Now, let's move
    on to the next recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何创建我们的第一个Python GUI。现在，让我们继续下一个菜谱。
- en: Preventing the GUI from being resized
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止GUI被调整大小
- en: By default, a GUI created using `tkinter` can be resized. This is not always
    ideal. The widgets we place onto our GUI forms might end up being resized in an
    improper way, so in this recipe, we will learn how to prevent our GUI from being
    resized by the user of our GUI application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用`tkinter`创建的GUI可以被调整大小。这并不总是理想的。我们放置到GUI表单中的小部件可能会以不适当的方式调整大小，因此在这个菜谱中，我们将学习如何防止我们的GUI被GUI应用程序的用户调整大小。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous one, *Creating our first Python GUI*, so one
    requirement is to have typed the first recipe yourself into a project of your
    own. Alternatively, you can download the code from [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)[/](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Second-Edition/)[.](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Second-Edition/)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱，*创建我们的第一个Python GUI*，因此一个要求是你必须自己在一个项目中将第一个菜谱输入进去。或者，你可以从[https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)[/](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Second-Edition/)[.](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Second-Edition/)
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Here are the steps to prevent the GUI from being resized:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是防止GUI被调整大小的步骤：
- en: Start with the module from the previous recipe and save it as `Gui_not_resizable.py`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个菜谱的模块开始，将其保存为`Gui_not_resizable.py`。
- en: 'Use the `Tk` instance variable, `win`, to call the `resizable` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Tk`实例变量`win`来调用`resizable`方法：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the code to prevent the GUI from being resized (`GUI_not_resizable.py`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是防止GUI被调整大小的代码（`GUI_not_resizable.py`）：
- en: '![](img/09c82c3d-90d2-4798-b065-0424030d8fb8.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09c82c3d-90d2-4798-b065-0424030d8fb8.png)'
- en: 'Run the code. Running the code creates this GUI:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。运行代码创建了这个GUI：
- en: '![](img/34fbdde8-3e1d-4dda-9b23-4eb16a69cf8e.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34fbdde8-3e1d-4dda-9b23-4eb16a69cf8e.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入幕后，更好地理解代码。
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Line 18 prevents the Python GUI from being resized.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第18行防止Python GUI被调整大小。
- en: The `resizable()` method is of the `Tk()` class and, by passing in `(False,
    False)`, we prevent the GUI from being resized. We can disable both the *x* and
    *y* dimensions of the GUI from being resized, or we can enable one or both dimensions
    by passing in `True` or any number other than zero. `(True, False)` would enable
    the *x* dimension but prevent the *y* dimension from being resized.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`resizable()` 方法属于 `Tk()` 类，通过传入 `(False, False)`，我们防止GUI被调整大小。我们可以禁用GUI的 *x*
    和 *y* 维度以防止调整大小，或者通过传入 `True` 或任何非零数字来启用一个或两个维度。`(True, False)` 将启用 *x* 维度但防止
    *y* 维度被调整大小。'
- en: Running this code will result in a GUI similar to the one we created in the
    first recipe. However, the user can no longer resize it. Also, note how the maximize
    button in the toolbar of the window is grayed out.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将生成一个类似于我们在第一个食谱中创建的GUI。然而，用户不能再调整它的大小。此外，请注意窗口工具栏中的最大化按钮已变灰。
- en: Why is this important? Because once we add widgets to our form, resizing our
    GUI can make it not look the way we want it to look. We will add widgets to our
    GUI in the next recipes, starting with *Adding a label to the GUI form.*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？因为一旦我们向表单添加小部件，调整GUI的大小可能会让它看起来不是我们想要的样子。我们将在下一个食谱中添加小部件到GUI，从*将标签添加到GUI表单*开始。
- en: We also added comments to our code in preparation for the recipes contained
    in this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在代码中添加了注释，为这本书中包含的食谱做准备。
- en: In visual programming IDEs such as Visual Studio .NET, C# programmers often
    do not think of preventing the user from resizing the GUI they developed in this
    language. This creates inferior GUIs. Adding this one line of Python code can
    make our users appreciate our GUI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio .NET等可视化编程IDE中，C#程序员通常不会考虑防止用户调整他们用这种语言开发的GUI的大小。这会创建出低质量的GUI。添加这一行Python代码可以让我们的用户欣赏我们的GUI。
- en: We've successfully learned how to prevent the GUI from being resized. Now, let's
    move on to the next recipe.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何防止GUI被调整大小。现在，让我们继续下一个食谱。
- en: Adding a label to the GUI form
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标签添加到GUI表单
- en: A label is a very simple widget that adds value to our GUI. It explains the
    purpose of the other widgets, providing additional information. This can guide
    the user to the meaning of an `Entry` widget, and it can also explain the data
    displayed by widgets without the user having to enter data into it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是一个非常简单的小部件，为我们的GUI增加了价值。它解释了其他小部件的目的，提供了额外的信息。这可以指导用户理解 `Entry` 小部件的含义，也可以解释小部件显示的数据，而无需用户输入数据。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are extending the first recipe, *Creating our first Python GUI*. We will
    leave the GUI resizable, so don't use the code from the second recipe (or comment
    the `win.resizable` line out).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在扩展第一个食谱，*创建我们的第一个Python GUI*。我们将保持GUI可调整大小，因此不要使用第二个食谱中的代码（或注释掉 `win.resizable`
    行）。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to add a label to the GUI from:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将标签添加到GUI中：
- en: Start with the `First_GUI.py` module and save it as `GUI_add_label.py`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `First_GUI.py` 模块开始，将其保存为 `GUI_add_label.py`。
- en: 'Import `ttk`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `ttk`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use `ttk` to add a label:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ttk` 添加标签：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the grid layout manager to position the label:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网格布局管理器定位标签：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In order to add a `Label` widget to our GUI, we will import the `ttk` module
    from `tkinter`. Please note the two `import` statements on lines 9 and 10.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `Label` 小部件添加到我们的GUI中，我们将从 `tkinter` 中导入 `ttk` 模块。请注意第9行和第10行的两个 `import`
    语句。
- en: 'The following code is added just above `win.mainloop()`, which is located at
    the bottom of the first and second recipes (`GUI_add_label.py`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码添加在 `win.mainloop()` 之上，位于第一个和第二个食谱的底部（`GUI_add_label.py`）：
- en: '![](img/02e8ac89-0b41-440f-a7b5-1cc9b4f9c43d.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02e8ac89-0b41-440f-a7b5-1cc9b4f9c43d.png)'
- en: 'Run the code and observe how a label is added to our GUI:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察标签是如何添加到我们的GUI中的：
- en: '![](img/5fe213c4-bea8-4e5a-b89b-abd08765ca97.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fe213c4-bea8-4e5a-b89b-abd08765ca97.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In line 10 of the preceding code, we import a separate module from the `tkinter`
    package. The `ttk` module has some advanced widgets such as a notebook, progress
    bar, labels, and buttons that look different. These help to make our GUI look
    better. In a sense, `ttk` is an extension within the `tkinter` package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码的第10行，我们从一个单独的模块中导入 `tkinter` 包。`ttk` 模块包含一些高级小部件，如笔记本、进度条、标签和按钮，它们看起来不同。这些有助于使我们的GUI看起来更好。在某种程度上，`ttk`
    是 `tkinter` 包中的一个扩展。
- en: We still need to import the `tkinter` package, but we need to specify that we
    now want to also use `ttk` from the `tkinter` package.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要导入`tkinter`包，但我们需要指定我们现在还想要使用`tkinter`包中的`ttk`。
- en: '`ttk` stands for *themed* `tk`. It improves our GUI''s look and feel. You can
    find more information at [https://docs.python.org/3/library/tkinter.ttk.html](https://docs.python.org/3/library/tkinter.ttk.html).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk`代表*主题化*的`tk`。它改善了我们的GUI的外观和感觉。您可以在[https://docs.python.org/3/library/tkinter.ttk.html](https://docs.python.org/3/library/tkinter.ttk.html)找到更多信息。'
- en: Line 19 adds the label to the GUI, just before we call `mainloop`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第19行在调用`mainloop`之前将标签添加到GUI中。
- en: We pass our window instance into the `ttk.Label` constructor and set the `text`
    attribute. This becomes the text our `Label` will display. We also make use of
    the grid layout manager, which we'll explore in much more depth in [Chapter 2](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml),
    *Layout Management*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将窗口实例传递给`ttk.Label`构造函数并设置`text`属性。这将成为`Label`将显示的文本。我们还使用了网格布局管理器，我们将在第2章[7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml]中更深入地探讨，*布局管理*。
- en: Observe how our GUI suddenly got much smaller than in the previous recipes.
    The reason why it became so small is that we added a widget to our form. Without
    a widget, the `tkinter` package uses a default size. Adding a widget causes optimization,
    which generally means using as little space as necessary to display the widget(s).
    If we make the text of the label longer, the GUI will expand automatically. We
    will cover this automatic form size adjustment in a later recipe in [Chapter 2](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml),
    *Layout Management*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到我们的GUI突然比之前的配方小得多。它变得如此之小的原因是我们在表单中添加了一个小部件。如果没有小部件，`tkinter`包将使用默认大小。添加小部件会导致优化，这通常意味着使用尽可能少的空间来显示小部件（s）。如果我们使标签的文本更长，GUI将自动扩展。我们将在第2章[7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml]的后续配方中介绍这种自动表单大小调整，*布局管理*。
- en: Try resizing and maximizing this GUI with a label and watch what happens. We've
    successfully learned how to add a label to the GUI form.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整大小并最大化带有标签的此GUI，看看会发生什么。我们已经成功地学习了如何向GUI表单添加标签。
- en: Now, let's move on to the next recipe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一个配方。
- en: Creating buttons and changing their text attributes
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按钮并更改它们的文本属性
- en: In this recipe, we will add a button widget, and we will use this button to
    change an attribute of another widget that is a part of our GUI. This introduces
    us to callback functions and event handling in a Python GUI environment.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将添加一个按钮小部件，并使用这个按钮来改变我们GUI中另一个小部件的属性。这使我们了解了Python GUI环境中的回调函数和事件处理。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous one, *Adding a label to the GUI form*. You
    can download the entire code from [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)/.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方扩展了之前的配方，*向GUI表单添加标签*。您可以从[https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)下载整个代码。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will update the label we added in the previous recipe as
    well as the `text` attribute of the button. The steps to add a button that performs
    an action when clicked are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将更新我们在上一个配方中添加的标签以及按钮的`text`属性。添加一个在点击时执行操作的按钮的步骤如下：
- en: Start with the `GUI_add_label.py` module and save it as `GUI_create_button_change_property.py`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_add_label.py`模块开始，并将其保存为`GUI_create_button_change_property.py`。
- en: 'Define a function and name it `click_me()`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数并命名为`click_me()`：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use `ttk` to create a button and give it a `text` attribute:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ttk`创建一个按钮并给它一个`text`属性：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Bind the function to the button:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数绑定到按钮：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the grid layout to position the button:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网格布局定位按钮：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding instructions produce the following code (`GUI_create_button_change_property.py`):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的说明产生了以下代码（`GUI_create_button_change_property.py`）：
- en: '![](img/cf3f5a4e-3178-42ec-81f6-5e0f913f5c98.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf3f5a4e-3178-42ec-81f6-5e0f913f5c98.png)'
- en: Run the code and observe the output.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出。
- en: 'The following screenshot shows how our GUI looks before clicking the button:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了点击按钮之前我们的GUI看起来是什么样子：
- en: '![](img/d40e857b-03ef-48a5-95fe-4becc9dbdc7a.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d40e857b-03ef-48a5-95fe-4becc9dbdc7a.png)'
- en: 'After clicking the button, the color of the label changed and so did the text
    of the button, which can be seen in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，标签的颜色发生了变化，按钮的文本也发生了变化，这可以从下面的屏幕截图中看到：
- en: '![](img/add723ee-646c-4bdd-98a8-3605aa240cf5.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/add723ee-646c-4bdd-98a8-3605aa240cf5.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入幕后，更好地理解代码。
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In line 19, we assign the label to a variable, `a_label`, and in line 20, we
    use this variable to position the label within the form. We need this variable
    in order to change its attributes in the `click_me()` function. By default, this
    is a module-level variable, so as long as we declare the variable above the function
    that calls it, we can access it inside the function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第19行，我们将标签分配给变量`a_label`，在第20行，我们使用这个变量在表单中定位标签。我们需要这个变量以便在`click_me()`函数中更改其属性。默认情况下，这是一个模块级变量，因此只要我们在调用它的函数上方声明变量，我们就可以在函数内部访问它。
- en: Line 23 is the event handler that is invoked once the button gets clicked.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第23行是当按钮被点击时调用的事件处理程序。
- en: In line 29, we create the button and bind the command to the `click_me()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第29行，我们创建了按钮并将命令绑定到`click_me()`函数。
- en: GUIs are event-driven. Clicking the button creates an event. We bind what happens
    when this event occurs in the callback function using the `command` attribute
    of the `ttk.Button` widget. Notice how we do not use parentheses, only the name
    `click_me`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GUI是事件驱动的。点击按钮会创建一个事件。我们使用`ttk.Button`小部件的`command`属性将此事件发生的回调函数绑定。注意我们是如何不使用括号，只使用名称`click_me`的。
- en: Lines 20 and 30 both use the grid layout manager, which will be discussed in
    [Chapter 2](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml), *Layout Management*,
    in the *Using the grid layout manager* recipe. This aligns both the label and
    the button. We also change the text of the label to include the word `red` to
    make it more obvious that the color has been changed. We will continue to add
    more and more widgets to our GUI, and we will make use of many built-in attributes
    in the other recipes of this book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第20行和第30行都使用了网格布局管理器，这将在[第2章](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml)的*布局管理*菜谱*使用网格布局管理器*中讨论。这使标签和按钮对齐。我们还更改了标签的文本，以包含单词`red`，使其更明显地表明颜色已更改。我们将继续在我们的GUI中添加更多和更多的小部件，并将在本书的其他菜谱中使用许多内置属性。
- en: We've successfully learned how to create buttons and change their text attributes.
    Now, let's move on to the next recipe.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何创建按钮并更改它们的文本属性。现在，让我们继续到下一个菜谱。
- en: Creating textbox widgets
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文本框小部件
- en: In `tkinter`, a typical one-line textbox widget is called `Entry`. In this recipe,
    we will add such an `Entry` widget to our GUI. We will make our label more useful
    by describing what the `Entry` widget is doing for the user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tkinter`中，典型的单行文本框小部件称为`Entry`。在这个菜谱中，我们将向我们的GUI添加这样的`Entry`小部件。我们将通过描述`Entry`小部件为用户做了什么来使我们的标签更有用。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the *Creating buttons and changing their text attributes*
    recipe, so download it from the repository and start working on it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱基于*创建按钮并更改它们的文本属性*菜谱，所以从存储库中下载它并开始工作。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to create textbox widgets:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建文本框小部件：
- en: Start with the `GUI_create_button_change_property.py` module and save it as
    `GUI_textbox_widget.py`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_create_button_change_property.py`模块开始，并将其保存为`GUI_textbox_widget.py`。
- en: 'Use the `tk` alias of `tkinter` to create a `StringVar` variable:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`tkinter`的`tk`别名创建一个`StringVar`变量：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `ttk.Entry` widget and assign it to another variable:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ttk.Entry`小部件并将其分配给另一个变量：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use this variable to position the `Entry` widget:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个变量定位`Entry`小部件：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding instructions produce the following code (`GUI_textbox_widget.py`):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述指令生成了以下代码（`GUI_textbox_widget.py`）：
- en: '![](img/e7c9f082-4bb2-45f4-9ae5-81b15d7136ac.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7c9f082-4bb2-45f4-9ae5-81b15d7136ac.png)'
- en: 'Run the code and observe the output; our GUI looks like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出；我们的GUI看起来像这样：
- en: '![](img/4aea7110-db84-4832-ac27-8c5c87f1582c.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4aea7110-db84-4832-ac27-8c5c87f1582c.png)'
- en: 'Enter some text and click the button; we will see that there is a change in
    the GUI, which is as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一些文本并点击按钮；我们会看到GUI发生了变化，如下所示：
- en: '![](img/1feb1baa-d29d-4f2e-9d52-b1dd0239eb21.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1feb1baa-d29d-4f2e-9d52-b1dd0239eb21.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入幕后，更好地理解代码。
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* we are creating a new Python module, and in *step 2* we are adding
    a `StringVar` type of `tkinter` and saving it in the `name` variable. We use this
    variable when we are creating an `Entry` widget and assigning it to the `textvariable`
    attribute of the `Entry` widget. Whenever we type some text into the `Entry` widget,
    this text will be saved in the `name` variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们创建一个新的 Python 模块，而在*步骤 2*中，我们添加了一个`StringVar`类型的`tkinter`，并将其保存在`name`变量中。当我们创建一个`Entry`小部件并将其分配给`Entry`小部件的`textvariable`属性时，我们使用这个变量。每次我们向`Entry`小部件中输入一些文本时，这些文本都会保存在`name`变量中。
- en: In *step 4*, we position the `Entry` widget and the preceding screenshot shows
    the entire code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，我们定位了`Entry`小部件，前一个截图显示了整个代码。
- en: In line 24, as shown in the screenshot, we get the value of the `Entry` widget
    using `name.get()`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 24 行，如图表所示，我们使用`name.get()`获取`Entry`小部件的值。
- en: When we created our button, we saved a reference to it in the `action` variable.
    We use the `action` variable to call the `configure` method of the button, which
    then updates the text of our button.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的按钮时，我们将其引用保存在`action`变量中。我们使用`action`变量来调用按钮的`configure`方法，然后更新按钮的文本。
- en: We have not used OOP yet, so how come we can access the value of a variable
    that was not even declared yet? Without using OOP classes, in Python procedural
    coding, we have to physically place a name above a statement that tries to use
    that name. So, how does this work (it does)? The answer to this is that the button
    click event is a callback function, and by the time the button is clicked by a
    user, the variables referenced in this function are known and do exist.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用 OOP，那么我们是如何访问一个甚至尚未声明的变量的值的呢？在不使用 OOP 类的情况下，在 Python 过程式编码中，我们必须在尝试使用该名称的语句上方实际放置一个名称。那么这是怎么工作的（它确实是这样工作的）？这个答案就是按钮点击事件是一个回调函数，并且当用户点击按钮时，这个函数中引用的变量是已知的并且确实存在。
- en: Line 27 gives our label a more meaningful name; for now, it describes the textbox
    below it. We moved the button down next to the label to visually associate the
    two. We are still using the grid layout manager, which will be explained in more
    detail in [Chapter 2](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml), *Layout Management*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第 27 行给我们的标签赋予了一个更有意义的名称；目前，它描述了其下方的文本框。我们将按钮向下移动到标签旁边，以便在视觉上关联这两个元素。我们仍在使用网格布局管理器，这将在[第
    2 章](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml)的*布局管理*中更详细地解释。
- en: Line 30 creates a variable, `name`. This variable is bound to the Entry widget
    and, in our `click_me()` function, we are able to retrieve the value of the Entry
    widget by calling `get()` on this variable. This works like a charm.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第 30 行创建了一个变量`name`。这个变量绑定到`Entry`小部件上，在我们的`click_me()`函数中，我们能够通过调用这个变量的`get()`来检索`Entry`小部件的值。这工作得很好。
- en: Now we observe that while the button displays the entire text we entered (and
    more), the textbox Entry widget did not expand. The reason for this is that we
    hardcoded it to a width of `12` in *line 31*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们注意到，虽然按钮显示了我们所输入的整个文本（以及更多），但文本框`Entry`小部件并没有扩展。这是因为我们在*第 31 行*将其硬编码为宽度为`12`。
- en: Python is a dynamically typed language and infers the type from the assignment.
    What this means is that if we assign a string to the `name` variable, it will
    be of the `string` type, and if we assign an integer to `name`, its type will
    be an integer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种动态类型语言，并从赋值中推断类型。这意味着如果我们将一个字符串分配给`name`变量，它将是`string`类型，如果我们将一个整数分配给`name`，它的类型将是整数。
- en: Using `tkinter`, we have to declare the `name` variable as the `tk.StringVar()`
    type before we can use it successfully. The reason is that `tkinter` is not Python.
    We can use it with Python, but it is not the same language. See [https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)
    for more information.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tkinter`，我们必须在成功使用之前将`name`变量声明为`tk.StringVar()`类型。原因是`tkinter`不是 Python。我们可以用
    Python 使用它，但它不是同一种语言。更多信息请参见[https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)。
- en: We've successfully learned how to create textbox widgets. Now, let's move on
    to the next recipe.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何创建文本框小部件。现在，让我们继续学习下一个菜谱。
- en: Setting the focus to a widget and disabling widgets
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置小部件的焦点和禁用小部件
- en: While our GUI is nicely improving, it would be more convenient and useful to
    have the cursor appear in the Entry widget as soon as the GUI appears.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 GUI 逐渐改进时，如果光标在 GUI 出现时立即出现在`Entry`小部件中，将会更加方便和有用。
- en: In this recipe, we learn how to make the cursor appear in the Entry box for
    immediate text Entry rather than the need for the user to *click* into the Entry
    widget to give it the `focus` method before typing into the entry widget.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习如何使光标出现在Entry框中，以便立即进行文本输入，而不是需要用户在输入到entry小部件之前先*点击*进入小部件以给它设置`focus`方法。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipe, *Creating textbox widgets*. Python
    is truly great. All we have to do to set the focus to a specific control when
    the GUI appears is call the `focus()` method on an instance of a `tkinter` widget
    we previously created. In our current GUI example, we assigned the `ttk.Entry`
    class instance to a variable named `name_entered`. Now, we can give it the focus.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱，*创建文本框小部件*。Python确实很棒。我们只需要在GUI出现时将焦点设置到特定的控件上，只需在之前创建的`tkinter`小部件实例上调用`focus()`方法即可。在我们的当前GUI示例中，我们将`ttk.Entry`类实例分配给名为`name_entered`的变量。现在，我们可以给它设置焦点。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Place the following code just above the previous code, which is located at
    the bottom of the module, and which starts the main window''s event loop, like
    we did in the previous recipes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放置在模块底部之前的代码上方，该代码启动主窗口的事件循环，就像我们在之前的菜谱中所做的那样：
- en: Start with the `GUI_textbox_widget.py` module and save it as `GUI_set_focus.py`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_textbox_widget.py`模块开始，并将其保存为`GUI_set_focus.py`。
- en: 'Use the `name_entered` variable we assigned the `ttk` `Entry` widget instance
    to and call the `focus()` method on this variable:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们分配给`ttk.Entry`小部件实例的`name_entered`变量，并在这个变量上调用`focus()`方法：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding instructions produce the following code (`GUI_set_focus.py`):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述说明生成了以下代码（`GUI_set_focus.py`）：
- en: '![](img/b0c81903-5a17-4b6e-b234-bf354af87554.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0c81903-5a17-4b6e-b234-bf354af87554.png)'
- en: Run the code and observe the output.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出。
- en: If you get some errors, make sure you are placing calls to variables below the
    code where they are declared. We are not using OOP as of now, so this is still
    necessary. Later, it will no longer be necessary to do this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一些错误，请确保你将变量调用放置在它们声明的代码下方。目前我们不是使用面向对象编程，所以这仍然是必要的。稍后，将不再需要这样做。
- en: On a Mac, you might have to set the focus to the GUI window first before being
    able to set the focus to the Entry widget in this window.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，你可能需要首先将焦点设置到GUI窗口，然后才能设置此窗口中的Entry小部件的焦点。
- en: 'Adding line 38 of the Python code places the cursor in our text Entry widget,
    giving the text Entry widget the focus. As soon as the GUI appears, we can type
    into this textbox without having to click it first. The resulting GUI now looks
    like this, with the cursor inside the Entry widget:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Python代码的第38行将光标放置在我们的文本Entry小部件中，给文本Entry小部件设置焦点。一旦GUI出现，我们就可以直接输入到这个文本框中，而无需先点击它。结果GUI现在看起来像这样，光标位于Entry小部件内：
- en: '![](img/cf18d512-a511-4ecf-b128-1a14218d78cb.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf18d512-a511-4ecf-b128-1a14218d78cb.png)'
- en: Note how the cursor now defaults to residing inside the text entry box.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在光标默认位于文本输入框内。
- en: We can also disable widgets. Here, we are disabling the button to show the principle.
    In larger GUI applications, the ability to disable widgets gives you control when
    you want to make things read only. Most likely, those would be combobox widgets
    and Entry widgets, but as we have not yet gotten to those widgets yet, we will
    use our button.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以禁用小部件。在这里，我们禁用按钮以展示原理。在更大的GUI应用程序中，禁用小部件的能力允许你在需要使某些内容只读时进行控制。最可能的是组合框小部件和Entry小部件，但因为我们还没有到达那些小部件，我们将使用我们的按钮。
- en: 'To disable widgets, we will set an attribute on the widget. We can make the
    button disabled by adding the following code below line 37 of the Python code
    to create the button:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用小部件，我们将在小部件上设置一个属性。我们可以通过在创建按钮的Python代码的第37行下方添加以下代码来使按钮不可用：
- en: Use the `GUI_set_focus.py` module and save it as `GUI_disable_button_widget.py`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GUI_set_focus.py`模块并将其保存为`GUI_disable_button_widget.py`。
- en: 'Use the `action` button variable to call the `configure` method and set the
    `state` attribute to `disabled`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`action`按钮变量来调用`configure`方法并将`state`属性设置为`disabled`：
- en: '[PRE16]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Call the `focus()` method on the `name_entered` variable:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`name_entered`变量上调用`focus()`方法：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding instructions produce the following code (`GUI_disable_button_widget.py`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 上述说明生成了以下代码（`GUI_disable_button_widget.py`）：
- en: '![](img/1b16ca24-16b2-4476-b5f6-ac28868c1886.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b16ca24-16b2-4476-b5f6-ac28868c1886.png)'
- en: 'Run the code. After adding the preceding line of Python code, clicking the
    button no longer creates an action:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。在添加上述Python代码行之后，点击按钮将不再创建动作：
- en: '![](img/1128d990-1d86-4dda-a6c5-a0ba54b76bd7.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1128d990-1d86-4dda-a6c5-a0ba54b76bd7.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This code is self-explanatory. In line 39, we set the focus to one control,
    and in line 37, we disable another widget. Good naming in programming languages
    helps to eliminate lengthy explanations. Later in this book, there will be some
    advanced tips on how to do this while programming at work or practicing our programming
    skills at home.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是自我解释的。在第39行，我们设置了一个控件的焦点，在第37行，我们禁用了另一个控件。在编程语言中使用良好的命名有助于消除冗长的解释。本书后面将有一些关于如何在工作中编程或在家中练习编程技能时如何做到这一点的先进技巧。
- en: We've successfully learned how to set the focus to a widget and disable widgets.
    Now, let's move on to the next recipe.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何设置控件焦点并禁用控件。现在，让我们继续到下一个菜谱。
- en: Creating combobox widgets
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组合框小部件
- en: In this recipe, we will improve our GUI by adding drop-down comboboxes that
    can have initial default values. While we can restrict the user to only certain
    choices, we can also allow the user to type in whatever they wish.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过添加具有初始默认值的下拉组合框来改进我们的GUI。虽然我们可以限制用户只能选择某些选项，但我们也可以允许用户输入他们想要的任何内容。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipe, *Setting the focus to a widget and
    disabling widgets*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱，*设置控件焦点和禁用控件*。
- en: How to do it…
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We insert another column between the Entry widget and the `Button` widget using
    the grid layout manager. Here is the Python code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用网格布局管理器在`Entry`控件和`Button`控件之间插入另一列。以下是Python代码：
- en: Start with the `GUI_set_focus.py` module and save it as `GUI_combobox_widget.py`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_set_focus.py`模块开始，并将其保存为`GUI_combobox_widget.py`。
- en: 'Change the button column to `2`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮列更改为`2`：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a new `ttk.Label` widget:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ttk.Label`小部件：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new `ttk.Combobox` widget:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ttk.Combobox`小部件：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Assign values to the `Combobox` widget:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Combobox`小部件分配值：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Place the `Combobox` widget into `column 1`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Combobox`小部件放置在`列1`：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding steps produce the following code (`GUI_combobox_widget.py`):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤生成了以下代码（`GUI_combobox_widget.py`）：
- en: '![](img/b33f24d0-d54b-4ef2-8cf8-1992cbc6bf84.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b33f24d0-d54b-4ef2-8cf8-1992cbc6bf84.png)'
- en: Run the code.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。
- en: 'The code, when added to the previous recipes, creates the following GUI. Note
    how, in line 43 in the preceding code, we assigned a tuple with default values
    to the combobox. These values then appear in the drop-down box. We can also change
    them if we like (by typing in different values when the application is running):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此代码添加到之前的菜谱中时，会创建以下GUI。注意，在前面的代码的第43行中，我们给组合框分配了一个具有默认值的元组。这些值随后出现在下拉框中。我们也可以根据需要更改它们（在应用程序运行时输入不同的值）：
- en: '![](img/038cd900-efd9-478f-8f7f-2e8ee110faf1.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/038cd900-efd9-478f-8f7f-2e8ee110faf1.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Line 40 adds a second label to match the newly created combobox (created in
    line 42). Line 41 assigns the value of the box to a variable of a special `tkinter`
    type `StringVar`, as we did in a previous recipe.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第40行添加了一个第二个标签以匹配新创建的组合框（在第42行创建）。第41行将框的值分配给一个特殊的`tkinter`类型的`StringVar`变量，就像我们在之前的菜谱中所做的那样。
- en: Line 44 aligns the two new controls (label and combobox) within our previous
    GUI layout, and line 45 assigns a default value to be displayed when the GUI first
    becomes visible. This is the first value of the `number_chosen['values']` tuple,
    the string `"1"`. We did not place quotes around our tuple of integers in line
    43, but they were cast into strings because, in line 41, we declared the values
    to be of the `tk.StringVar` type.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第44行将两个新的控件（标签和组合框）在我们的前一个GUI布局中对齐，第45行将默认值分配给当GUI首次可见时显示。这是`number_chosen['values']`元组的第一个值，字符串`"1"`。我们在第43行没有给整数的元组加上引号，但它们被转换成了字符串，因为在第41行中，我们声明了值应该是`tk.StringVar`类型。
- en: The preceding screenshot shows the selection made by the user is `42`. This
    value gets assigned to the `number` variable.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了用户所做的选择是`42`。此值被分配给`number`变量。
- en: If `100` is selected in the combobox, the value of the `number` variable becomes
    `100`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在组合框中选择`100`，则`number`变量的值变为`100`。
- en: '*Line 42* binds the value selected in the combobox to the `number` variable
    via the `textvariable` attribute.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*第42行*通过`textvariable`属性将组合框中选择的值绑定到`number`变量。'
- en: There's more…
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we want to restrict the user to only being able to select the values we
    have programmed into the `Combobox` widget, we can do it by passing the *`state`*
    attribute into the constructor. Modify *line 42* as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想限制用户只能选择我们编程到 `Combobox` 小部件中的值，我们可以通过将 *`state`* 属性传递给构造函数来实现。将 *第 42
    行* 修改如下：
- en: Start with the `GUI_combobox_widget.py` module and save it as `GUI_combobox_widget_readonly.py`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `GUI_combobox_widget.py` 模块开始，并将其保存为 `GUI_combobox_widget_readonly.py`。
- en: 'Set the `state` attribute when creating the `Combobox` widget:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 `Combobox` 小部件时设置 `state` 属性：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding steps produce the following code (`GUI_combobox_widget_readonly.py`):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤生成以下代码（`GUI_combobox_widget_readonly.py`）：
- en: '![](img/156fe288-a835-47cc-9712-b33946ee6d5f.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/156fe288-a835-47cc-9712-b33946ee6d5f.png)'
- en: Run the code.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。
- en: Now, users can no longer type values into the `Combobox` widget.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户不能再向 `Combobox` 小部件中输入值。
- en: 'We can display the value chosen by the user by adding the following line of
    code to our button click event callback function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在按钮点击事件回调函数中添加以下代码行来显示用户选择的价值：
- en: Start with the `GUI_combobox_widget_readonly.py` module and save it as `GUI_combobox_widget_readonly_plus_display_number.py`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `GUI_combobox_widget_readonly.py` 模块开始，并将其保存为 `GUI_combobox_widget_readonly_plus_display_number.py`。
- en: 'Extend the button click event handler by using the `get()` method on the `name`
    variable, use concatenation (`+ '' '' +`), and also get the number from the `number_chosen`
    variable (also calling the `get()` method on it):'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 `name` 变量上使用 `get()` 方法扩展按钮点击事件处理程序，使用连接（`+ ' ' +`），并从 `number_chosen` 变量（也调用它的
    `get()` 方法）获取数字：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the code.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。
- en: 'After choosing a number, entering a name, and then clicking the button, we
    get the following GUI result, which now also displays the number selected next
    to the name entered (`GUI_combobox_widget_readonly_plus_display_number.py`):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个数字，输入一个名称，然后点击按钮，我们得到以下 GUI 结果，现在它还显示了输入名称旁边的所选数字（`GUI_combobox_widget_readonly_plus_display_number.py`）：
- en: '![](img/0f56e0e9-7bde-47b3-b75a-d8f4df194b0e.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f56e0e9-7bde-47b3-b75a-d8f4df194b0e.png)'
- en: We've successfully learned how to add combobox widgets. Now, let's move on to
    the next recipe.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何添加组合框小部件。现在，让我们继续下一个配方。
- en: Creating a check button with different initial states
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有不同初始状态的复选框
- en: 'In this recipe, we will add three check button widgets, each with a different
    initial state:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将添加三个复选框小部件，每个小部件都有一个不同的初始状态：
- en: The first is disabled and has a checkmark in it. The user cannot remove this
    checkmark as the widget is disabled.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是禁用的，里面有一个勾选标记。由于小部件是禁用的，用户不能移除这个勾选标记。
- en: The second check button is enabled, and by default has no checkmark in it, but
    the user can click it to add a checkmark.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个复选框是启用的，默认情况下没有勾选标记，但用户可以点击它来添加勾选标记。
- en: The third check button is both enabled and checked by default. The users can
    uncheck and recheck the widget as often as they like.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个复选框默认既启用又选中。用户可以随时取消选中并重新选中小部件。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipe, *Creating combobox widgets*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方扩展了之前的配方，*创建组合框小部件*。
- en: How to do it…
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Here is the code for creating three check button widgets that differ in their
    states:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建三个状态不同的复选框小部件的代码：
- en: Start with the `GUI_combobox_widget_readonly_plus_display_number.py` module
    and save it as `GUI_checkbutton_widget.py`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `GUI_combobox_widget_readonly_plus_display_number.py` 模块开始，并将其保存为 `GUI_checkbutton_widget.py`。
- en: 'Create three `tk.IntVar` instances and save them in local variables:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个 `tk.IntVar` 实例并将它们保存在局部变量中：
- en: '[PRE25]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Set the `text` attributes for each of the `Combobox` widgets we are creating:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们创建的每个 `Combobox` 小部件设置 `text` 属性：
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Set their `state` to `deselect`/`select`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们的 `state` 设置为 `deselect`/`select`：
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use `grid` to lay them out:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `grid` 来布局：
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding steps will finally produce the following code (`GUI_checkbutton_widget.py`):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤最终生成以下代码（`GUI_checkbutton_widget.py`）：
- en: '![](img/093457a9-b94a-4024-b1cc-73422972bf4f.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/093457a9-b94a-4024-b1cc-73422972bf4f.png)'
- en: 'Run the module. Running the new code results in the following GUI:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行模块。运行新代码的结果如下 GUI：
- en: '![](img/8f88587a-6585-4063-a074-4e10e784ecdf.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f88587a-6585-4063-a074-4e10e784ecdf.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '*Steps 1* to *4* show the details and the screenshot in *step 5* displays the
    important aspects of the code.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 到 *4* 展示了详细信息和截图，*步骤 5* 显示了代码的重要方面。'
- en: In *lines 47*, *52*, and *57* ,we create three variables of the `IntVar` type.
    In the line following each of these variables, we create a `Checkbutton` widget,
    passing in these variables. They will hold the state of the `Checkbutton` widget
    (unchecked or checked). By default, that is either `0` (unchecked) or `1` (checked),
    so the type of the variable is a `tkinter` integer.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第47行*、*第52行*和*第57行*，我们创建了三个`IntVar`类型的变量。在每个这些变量之后的行中，我们创建了一个`Checkbutton`小部件，传递这些变量。它们将保存`Checkbutton`小部件的状态（未选中或选中）。默认情况下，这将是`0`（未选中）或`1`（选中），因此变量的类型是`tkinter`整数。
- en: We place these `Checkbutton` widgets in our main window, so the first argument
    passed into the constructor is the parent of the widget, in our case, `win`. We
    give each `Checkbutton` widget a different label via its `text` attribute.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些`Checkbutton`小部件放置在我们的主窗口中，因此构造函数传入的第一个参数是小部件的父级，在我们的情况下是`win`。我们通过其`text`属性给每个`Checkbutton`小部件一个不同的标签。
- en: Setting the sticky property of the grid to `tk.W` means that the widget will
    be aligned to the west of the grid. This is very similar to Java syntax, and it
    means that it will be aligned to the left. When we resize our GUI, the widget
    will remain on the left side and not be moved toward the center of the GUI.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格的`sticky`属性设置为`tk.W`意味着小部件将被对齐到网格的西边。这非常类似于Java语法，意味着它将被对齐到左边。当我们调整我们的GUI大小时，小部件将保持在左侧，而不会移动到GUI的中心。
- en: Lines 49 and 59 place a checkmark into the `Checkbutton` widget by calling the
    `select()` method on these two `Checkbutton` class instances.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第49行和第59行通过在这两个`Checkbutton`类实例上调用`select()`方法，将勾选标记放入`Checkbutton`小部件中。
- en: We continue to arrange our widgets using the grid layout manager, which will
    be explained in more detail in [Chapter 2](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml),
    *Layout Management*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用网格布局管理器来排列我们的小部件，这将在[第2章](7b1f337c-b9fe-4dc2-8c86-5827e7256831.xhtml)，*布局管理*中更详细地解释。
- en: We've successfully learned how to create a check button with different initial
    states. Now, let's move on to the next recipe.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何创建具有不同初始状态的复选框。现在，让我们继续下一个菜谱。
- en: Using radio button widgets
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单选按钮小部件
- en: In this recipe, we will create three radio button widgets. We will also add
    some code that changes the color of the main form, depending upon which radio
    button is selected.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建三个单选按钮小部件。我们还将添加一些代码，根据选中的哪个单选按钮改变主表单的颜色。
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipe, *Creating a check button with different
    initial states*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱，*创建具有不同初始状态的复选框*。
- en: How to do it…
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We add the following code to the previous recipe:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下代码添加到之前的菜谱中：
- en: Start with the `GUI_checkbutton_widget.py` module and save it as `GUI_radiobutton_widget.py`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_checkbutton_widget.py`模块开始，将其保存为`GUI_radiobutton_widget.py`。
- en: 'Create three module-level global variables for the color names:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为颜色名称创建三个模块级别的全局变量：
- en: '[PRE29]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a callback function for the radio buttons:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为单选按钮创建一个回调函数：
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create three `tk` radio buttons:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三个`tk`单选按钮：
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the grid layout to position them:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网格布局来定位它们：
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding steps will finally produce the following code (`GUI_radiobutton_widget.py`):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤最终将生成以下代码（`GUI_radiobutton_widget.py`）：
- en: '![](img/1a97f958-dd66-472f-a79f-8a3434bf8239.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a97f958-dd66-472f-a79f-8a3434bf8239.png)'
- en: 'Run the code. Running this code and selecting the radio button named Gold creates
    the following window:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。运行此代码并选择名为Gold的单选按钮将创建以下窗口：
- en: '![](img/038c201f-26b7-4559-8919-62f107f9997f.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/038c201f-26b7-4559-8919-62f107f9997f.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解。
- en: How it works…
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In lines 75-77, we create some module-level global variables that we will use
    in the creation of each radio button, as well as in the callback function that
    creates the action of changing the background color of the main form (using the
    `win` instance variable).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在第75-77行，我们创建了一些模块级别的全局变量，我们将在创建每个单选按钮以及创建改变主表单背景颜色的回调函数（使用`win`实例变量）时使用。
- en: We are using global variables to make it easier to change the code. By assigning
    the name of the color to a variable and using this variable in several places,
    we can easily experiment with different colors. Instead of doing a global search
    and replace of the hardcoded string (which is prone to errors), we just need to
    change one line of code and everything else will work. This is known as the **DRY
    principle**, which stands for **Don't Repeat Yourself**. This is an OOP concept
    that we will use in the later recipes of the book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用全局变量来简化代码的更改。通过将颜色名称分配给变量并在多个地方使用这个变量，我们可以轻松地尝试不同的颜色。我们不需要进行全局搜索和替换硬编码的字符串（这容易出错），只需更改一行代码，其他所有内容都会正常工作。这被称为**DRY原则**，代表**不要重复自己**。这是我们在本书后面的菜谱中将要使用的一个面向对象的概念。
- en: The names of the colors we are assigning to the variables (`COLOR1`, `COLOR2`,
    `...`) are `tkinter` keywords (technically, they are *symbolic names*). If we
    use names that are not `tkinter` color keywords, then the code will not work.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给变量的颜色名称（`COLOR1`、`COLOR2`、...）是`tkinter`关键字（技术上，它们是*符号名称*）。如果我们使用不是`tkinter`颜色关键字的名称，则代码将无法工作。
- en: Line 80 is the *callback function* that changes the background of our main form
    (`win`) depending upon the user's selection.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第80行是*回调函数*，根据用户的选中改变我们主表单（`win`）的背景。
- en: In line 87, we create a `tk.IntVar` variable. What is important about this is
    that we create only one variable to be used by all three radio buttons. As can
    be seen from the screenshot, no matter which radio buttons we select, all the
    others will automatically be unselected for us.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在第87行，我们创建了一个`tk.IntVar`变量。重要的是，我们只创建了一个变量，供所有三个单选按钮使用。从截图可以看出，无论我们选择哪个单选按钮，其他所有单选按钮都会自动为我们取消选中。
- en: Lines 89 to 96 create the three radio buttons, assigning them to the main form,
    passing in the variable to be used in the callback function that creates the action
    of changing the background of our main window.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第89行到第96行创建了三个单选按钮，并将它们分配给主表单，传递变量给回调函数，该函数用于改变我们主窗口的背景。
- en: While this is the first recipe that changes the color of a widget, quite honestly,
    it looks a bit ugly. A large portion of the following recipes in this book explain
    how to make our GUI look truly amazing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是第一个改变小部件颜色的菜谱，但坦白地说，它看起来有点丑。本书接下来的许多菜谱将解释如何使我们的GUI看起来真正令人惊叹。
- en: There's more…
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Here is a small sample of the available symbolic color names that you can look
    up in the official TCL documentation at [http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可用的符号颜色名称的小样本，您可以在官方TCL文档[http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm)中查找：
- en: '| **Name** | **Red** | **Green** | **Blue** |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **红色** | **绿色** | **蓝色** |'
- en: '| `alice blue` | 240 | 248 | 255 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `alice blue` | 240 | 248 | 255 |'
- en: '| `AliceBlue` | 240 | 248 | 255 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `AliceBlue` | 240 | 248 | 255 |'
- en: '| `Blue` | 0 | 0 | 255 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `蓝色` | 0 | 0 | 255 |'
- en: '| `Gold` | 255 | 215 | 0 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `金色` | 255 | 215 | 0 |'
- en: '| `Red` | 255 | 0 | 0 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `红色` | 255 | 0 | 0 |'
- en: Some of the names create the same color, so `alice blue` creates the same color
    as `AliceBlue`. In this recipe, we used the symbolic names `Blue`, `Gold`, and
    `Red`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一些名称创建相同的颜色，所以`alice blue`与`AliceBlue`创建相同的颜色。在这个菜谱中，我们使用了符号名称`Blue`、`Gold`和`Red`。
- en: We've successfully learned how to use radio button widgets. Now, let's move
    on to the next recipe.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用单选按钮小部件。现在，让我们继续学习下一个菜谱。
- en: Using scrolled text widgets
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滚动文本小部件
- en: '`ScrolledText` widgets are much larger than simple `Entry` widgets and span
    multiple lines. They are widgets like Notepad and wrap lines, automatically enabling
    vertical scroll bars when the text gets larger than the height of the `ScrolledText`
    widget.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrolledText`小部件比简单的`Entry`小部件大得多，并且跨越多行。它们像记事本一样，自动换行，并在文本超过`ScrolledText`小部件高度时自动启用垂直滚动条。'
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe extends the previous recipe, *Using radio button widgets*. You can
    download the code for each chapter of this book from [https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition/](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱扩展了之前的菜谱，*使用单选按钮小部件*。您可以从这个书的每个章节下载代码：[https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition/](https://github.com/PacktPublishing/Python-GUI-Programming-Cookbook-Third-Edition)。
- en: How to do it…
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'By adding the following lines of code, we create a `ScrolledText` widget:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码行，我们创建了一个`ScrolledText`小部件：
- en: Start with the `GUI_radiobutton_widget.py` module and save it as `GUI_scrolledtext_widget.py`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_radiobutton_widget.py`模块开始，并将其保存为`GUI_scrolledtext_widget.py`。
- en: 'Import `scrolledtext`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`scrolledtext`：
- en: '[PRE33]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define variables for the width and height:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义宽度和高度的变量：
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a `ScrolledText` widget:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ScrolledText`小部件：
- en: '[PRE35]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Position the widget:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位小部件：
- en: '[PRE36]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding steps will finally produce the following code (`GUI_scrolledtext_widget.py`):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤最终将产生以下代码（`GUI_scrolledtext_widget.py`）：
- en: '![](img/a749a82b-9bb7-4425-921c-f0a75b5fdff9.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a749a82b-9bb7-4425-921c-f0a75b5fdff9.png)'
- en: 'Run the code. We can actually type into our widget, and if we type enough words,
    the lines will automatically wraparound:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。我们实际上可以在小部件中输入文本，如果我们输入足够的单词，行将自动换行：
- en: '![](img/e1cd66e3-22fc-4d9c-9a28-82f112624c5b.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1cd66e3-22fc-4d9c-9a28-82f112624c5b.png)'
- en: 'Once we type in more words than the height of the widget can display, the vertical
    scroll bar becomes enabled. This all works out of the box without us needing to
    write any more code to achieve this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入的单词数量超过了小部件的高度，垂直滚动条就会启用。这一切都是默认的，我们不需要编写任何额外的代码来实现这一点：
- en: '![](img/b52a7776-6fd5-4d27-b719-8ec5e6fad17b.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b52a7776-6fd5-4d27-b719-8ec5e6fad17b.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In line 11, we import the module that contains the `ScrolledText` widget class.
    Add this to the top of the module, just below the other two `import` statements.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11行，我们导入了包含`ScrolledText`小部件类的模块。将其添加到模块的顶部，位于其他两个`import`语句之下。
- en: Lines 100 and 101 define the width and height of the `ScrolledText` widget we
    are about to create. These are hardcoded values we are passing into the `ScrolledText`
    widget constructor in line 102.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 第100行和第101行定义了我们即将创建的`ScrolledText`小部件的宽度和高度。这些是通过实验找到的*魔法数字*，它们在`ScrolledText`小部件构造函数的第102行中被传递进去。
- en: These values are *magic numbers* found by experimentation to work well. You
    might experiment by changing `scol_w` from 30 to 50 and observe the effect!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是通过实验找到的，效果很好。你可以通过将`scol_w`从30改为50来实验，并观察效果！
- en: In line 102, we are also setting a property on the widget by passing in `wrap=tk.WORD`.
    By setting the `wrap` property to `tk.WORD`, we are telling the `ScrolledText`
    widget to break lines by words so that we do not wraparound within a word. The
    default option is `tk.CHAR`, which wraps any character regardless of whether we
    are in the middle of a word.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在第102行，我们通过传递`wrap=tk.WORD`来设置小部件的一个属性。通过将`wrap`属性设置为`tk.WORD`，我们告诉`ScrolledText`小部件通过单词来断行，这样我们就不需要在单词中间换行。默认选项是`tk.CHAR`，它会将任何字符都换行，无论我们是否在单词中间。
- en: The second screenshot shows that the vertical scroll bar moved down because
    we are reading a longer text that does not entirely fit into the *x, y* dimensions
    of the `ScrolledText` control we created.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张截图显示，垂直滚动条向下移动，因为我们正在读取一个较长的文本，它不完全适合我们创建的`ScrolledText`控制器的*x, y*维度。
- en: Setting the `columnspan` attribute of the grid layout to `3` for the `ScrolledText`
    widget makes this widget span all of the three columns. If we do not set this
    attribute, our `ScrolledText` widget would only reside in column one, which is
    not what we want.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格布局的`columnspan`属性设置为`3`以适用于`ScrolledText`小部件，这使得该小部件跨越所有三个列。如果我们不设置此属性，我们的`ScrolledText`小部件将只位于第一列，这并不是我们想要的。
- en: We've successfully learned how to use scrolled text widgets. Now, let's move
    on to the next recipe.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何使用滚动文本小部件。现在，让我们继续下一个食谱。
- en: Adding several widgets in a loop
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在循环中添加多个小部件
- en: So far, we have created several widgets of the same type (for example, a radio
    button) by basically copying and pasting the same code and then modifying the
    variations (for example, the column number). In this recipe, we start refactoring
    our code to make it less redundant.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过基本上复制粘贴相同的代码并修改变体（例如，列数）来创建了多个相同类型的控件（例如，单选按钮）。在这个食谱中，我们开始重构代码，以使其更少冗余。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are refactoring some parts of the previous recipe's code, *Using scrolled
    text widgets*, so you need that code for this recipe.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重构之前食谱代码的一些部分，*使用滚动文本小部件*，因此你需要这段代码来完成这个食谱。
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Here''s how we refactor our code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的代码重构方式：
- en: Start with the `GUI_scrolledtext_widget.py` module and save it as `GUI_adding_widgets_in_loop.py`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GUI_scrolledtext_widget.py`模块开始，并将其保存为`GUI_adding_widgets_in_loop.py`。
- en: 'Delete the global name variables and create a Python list instead:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除全局名称变量，并创建一个Python列表代替：
- en: '[PRE37]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `get()` function on the radio button variable:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单选按钮变量的`get()`函数：
- en: '[PRE38]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create logic with an `if ... elif` structure:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if ... elif`结构创建逻辑：
- en: '[PRE39]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use a loop to create and position the radio buttons:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环创建和定位单选按钮：
- en: '[PRE40]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the code (`GUI_adding_widgets_in_loop.py`):'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码（`GUI_adding_widgets_in_loop.py`）：
- en: '![](img/918594c9-d943-49ce-b9a6-056ea4db08a9.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/918594c9-d943-49ce-b9a6-056ea4db08a9.png）'
- en: Running this code will create the same window as before, but our code is much
    cleaner and easier to maintain. This will help us when we expand our GUI in the
    coming recipes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将创建与之前相同的窗口，但我们的代码更加整洁且易于维护。这将在我们接下来的菜谱中扩展GUI时帮助我们。
- en: How it works…
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In *line 77*, we have turned our global variables into a list. In line 89, we
    set a default value to the `tk.IntVar` variable that we named `radVar`. This is
    important because, while in the previous recipe we had set the value for radio
    button widgets to start at `1`, in our new loop it is much more convenient to
    use Python's zero-based indexing. If we did not set the default value to a value
    outside the range of our radio button widgets, one of the radio buttons would
    be selected when the GUI appears. While this in itself might not be so bad, *it
    would not trigger the callback* and we would end up with a radio button selected
    that does not do its job (that is, change the color of the main win form).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第77行*，我们将全局变量转换成了一个列表。在第89行，我们为名为`radVar`的`tk.IntVar`变量设置了一个默认值。这很重要，因为在之前的菜谱中，我们为单选按钮小部件设置了从`1`开始的值，而在我们新的循环中，使用Python的基于零的索引要方便得多。如果我们没有将默认值设置在单选按钮小部件的范围之外，当GUI出现时，其中一个单选按钮会被选中。虽然这本身可能不是那么糟糕，*但它不会触发回调函数*，我们最终会选中一个不执行其工作（即改变主窗口颜色）的单选按钮。
- en: In *line 95*, we replace the three previously hardcoded creations of the radio
    button widgets with a loop that does the same. It is just more concise (fewer
    lines of code) and much more maintainable. For example, if we want to create 100
    instead of just `3` radio button widgets, all we have to change is the number
    inside Python's range operator. We would not have to type or copy and paste 97
    sections of duplicate code, just 1 number.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第95行*，我们用循环替换了之前硬编码创建的单选按钮小部件的三个实例。这更加简洁（代码行数更少）且易于维护。例如，如果我们想创建100个而不是仅仅`3`个单选按钮小部件，我们只需更改Python范围运算符内的数字即可。我们不需要输入或复制粘贴97段重复的代码，只需一个数字。
- en: Line 82 shows the modified callback function.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 第82行显示了修改后的回调函数。
- en: This recipe concludes the first chapter of this book. All the following recipes
    in all of the next chapters will build upon the GUIs we have constructed so far,
    greatly enhancing it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱标志着本书第一章节的结束。接下来所有章节的所有菜谱都将基于我们迄今为止构建的GUI进行构建，极大地增强了它。
