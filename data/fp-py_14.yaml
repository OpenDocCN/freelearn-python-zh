- en: Chapter 14. The PyMonad Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。PyMonad库
- en: A monad allows us to impose an order on expression evaluation in an otherwise
    lenient language. We can use a monad to insist that an expression such as *a +
    b + c* is evaluated in left-to-right order. Generally, there seems to be no point
    to a monad. When we want files to have their content read or written in a specific
    order, however, a monad is a handy way to assure that the `read()` and `write()`
    functions are evaluated in a particular order.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 单子允许我们在一个否则宽松的语言中对表达式的评估施加顺序。我们可以使用单子来坚持要求像*a + b + c*这样的表达式按从左到右的顺序进行评估。一般来说，单子似乎没有什么意义。然而，当我们希望文件按特定顺序读取或写入其内容时，单子是一种确保`read()`和`write()`函数按特定顺序进行评估的便捷方式。
- en: Languages that are lenient and have optimizing compilers benefit from monads
    to impose order on evaluation of expressions. Python, for the most part, is strict
    and does not optimize. We have little practical use for monads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 宽松且具有优化编译器的语言受益于单子，以对表达式的评估施加顺序。Python在大多数情况下是严格的，不进行优化。我们对单子几乎没有实际用途。
- en: However, the PyMonad module is more than just monads. There are a number of
    functional programming features that have a distinctive implementation. In some
    cases, the PyMonad module can lead to programs which are more succinct and expressive
    than those written using only the standard library modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PyMonad模块不仅仅是单子。它具有许多具有独特实现的函数式编程特性。在某些情况下，PyMonad模块可以导致比仅使用标准库模块编写的程序更简洁和表达力更强。
- en: Downloading and installing
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和安装
- en: 'The PyMonad module is available on **Python Package Index** (**PyPi**). In
    order to add PyMonad to your environment, you''ll need to use pip or Easy Install.
    Here are some typical situations:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad模块可在**Python Package Index**（**PyPi**）上找到。为了将PyMonad添加到您的环境中，您需要使用pip或Easy
    Install。以下是一些典型情况：
- en: If you have Python 3.4 or higher, you have both of these installation package
    tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 3.4或更高版本，您将拥有这两个安装包工具
- en: If you have Python 3.x, you may already have either one of the necessary installers
    because you've added packages already
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 3.x，可能已经有了其中一个必要的安装程序，因为您已经添加了包
- en: If you have Python 2.x, you should consider an upgrade to Python 3.4
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是Python 2.x，你应该考虑升级到Python 3.4
- en: If you don't have pip or Easy Install, you'll need to install them first; consider
    upgrading to Python 3.4 to get these installation tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有pip或Easy Install，你需要先安装它们；考虑升级到Python 3.4以获取这些安装工具
- en: Visit [https://pypi.python.org/pypi/PyMonad/](https://pypi.python.org/pypi/PyMonad/)
    for more information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://pypi.python.org/pypi/PyMonad/](https://pypi.python.org/pypi/PyMonad/)获取更多信息。
- en: For Mac OS and Linux developers, the command `pip install PyMonad` or `easy_install-3.3
    pymonad` must be run using the `sudo` command. When running a command such as
    `sudo easy_install-3.3 pymonad`, you'll be prompted for your password to assure
    that you have the administrative permissions necessary to do the installation.
    For Windows developers, the `sudo` command is not relevant, but you do need to
    have administrative rights.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mac OS和Linux开发人员，必须使用`sudo`命令运行命令`pip install PyMonad`或`easy_install-3.3 pymonad`。当运行诸如`sudo
    easy_install-3.3 pymonad`的命令时，系统会提示您输入密码，以确保您具有进行安装所需的管理权限。对于Windows开发人员，`sudo`命令不相关，但您需要具有管理权限。
- en: 'Once the `pymonad` package is installed, you can confirm it using the following
    commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`pymonad`包后，可以使用以下命令进行确认：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will display the `docstring` module and confirm that things really are
    properly installed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示`docstring`模块，并确认事情确实安装正确。
- en: Functional composition and currying
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合和柯里化
- en: Some functional languages work by transforming a multiargument function syntax
    into a collection of single argument functions. This process is called **currying**—it's
    named after logician Haskell Curry, who developed the theory from earlier concepts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式语言通过将多参数函数语法转换为一组单参数函数来工作。这个过程称为**柯里化**——它是以逻辑学家Haskell Curry的名字命名的，他从早期概念中发展出了这个理论。
- en: 'Currying is a technique for transforming a multiargument function into higher
    order single argument functions. In the simple case, we have a function ![Functional
    composition and currying](graphics/B03652_14_01.jpg); given two arguments *x*
    and *y*, this will return some resulting value, *z*. We can curry this into two
    functions: ![Functional composition and currying](graphics/B03652_14_02.jpg) and
    ![Functional composition and currying](graphics/B03652_14_03.jpg). Given the first
    argument value, *x*, the function returns a new one-argument function, ![Functional
    composition and currying](graphics/B03652_14_04.jpg) returns a new one-argument
    function, ![Functional composition and currying](graphics/B03652_14_09.jpg). This
    second function can be given an argument, *y*, and will return the resulting value,
    *z*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是一种将多参数函数转换为高阶单参数函数的技术。在简单情况下，我们有一个函数![函数组合和柯里化](graphics/B03652_14_01.jpg)；给定两个参数*x*和*y*，这将返回一些结果值*z*。我们可以将其柯里化为两个函数：![函数组合和柯里化](graphics/B03652_14_02.jpg)和![函数组合和柯里化](graphics/B03652_14_03.jpg)。给定第一个参数值*x*，函数返回一个新的单参数函数，![函数组合和柯里化](graphics/B03652_14_04.jpg)返回一个新的单参数函数，![函数组合和柯里化](graphics/B03652_14_09.jpg)。第二个函数可以给定一个参数*y*，并返回结果值*z*。
- en: 'We can evaluate a curried function in Python as follows: `f_c(2)(3)`. We apply
    the curried function to the first argument value of `2`, creating a new function.
    Then, we apply that new function to the second argument value of `3`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中评估柯里化函数，如下所示：`f_c(2)(3)`。我们将柯里化函数应用于第一个参数值`2`，创建一个新函数。然后，我们将该新函数应用于第二个参数值`3`。
- en: This applies recursively to functions of any complexity. If we start with a
    function ![Functional composition and currying](graphics/B03652_14_10.jpg), we
    curry this into a function ![Functional composition and currying](graphics/B03652_14_11.jpg).
    This is done recursively. First, the ![Functional composition and currying](graphics/B03652_14_12.jpg)
    function returns a new function with the b and c arguments, ![Functional composition
    and currying](graphics/B03652_14_13.jpg). Then we can curry the returned two-argument
    function to create ![Functional composition and currying](graphics/B03652_14_14.jpg).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何复杂度的函数。如果我们从一个函数开始![Functional composition and currying](graphics/B03652_14_10.jpg)，我们将其柯里化为一个函数![Functional
    composition and currying](graphics/B03652_14_11.jpg)。这是递归完成的。首先，![Functional composition
    and currying](graphics/B03652_14_12.jpg)函数返回一个带有b和c参数的新函数，![Functional composition
    and currying](graphics/B03652_14_13.jpg)。然后，我们可以对返回的两参数函数进行柯里化，创建![Functional
    composition and currying](graphics/B03652_14_14.jpg)。
- en: We can evaluate this curried function with `g_c(1)(2)(3)`. When we apply ![Functional
    composition and currying](graphics/B03652_14_15.jpg) to an argument of 1, we get
    a function; when we apply this returned function to 2, we get another function.
    When we apply the final function to 3, we get the expected result. Clearly, formal
    syntax is bulky, so we use some syntactic sugar to reduce `g_c(1)(2)(3)` to something
    more palatable like `g(1,2,3)`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`g_c(1)(2)(3)`来评估这个柯里化函数。当我们将![Functional composition and currying](graphics/B03652_14_15.jpg)应用于参数1时，我们得到一个函数；当我们将返回的函数应用于2时，我们得到另一个函数。当我们将最终函数应用于3时，我们得到预期的结果。显然，正式的语法很臃肿，因此我们使用一些语法糖将`g_c(1)(2)(3)`减少到更容易接受的形式，如`g(1,2,3)`。
- en: 'Let''s look at a concrete example in Python, for example, we have a function
    like the following one:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Python中的一个具体例子为例，例如，我们有一个如下所示的函数：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple, multiple-regression-based model for systolic blood pressure.
    This predicts blood pressure from **body mass index** (**BMI**), age, gender (1
    means male), and history of previous treatment (1 means previously treated). For
    more information on the model and how it's derived, visit [http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html](http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于多元回归的简单模型，用于预测收缩压。这从**体重指数**（**BMI**）、年龄、性别（1表示男性）和先前治疗历史（1表示先前治疗）预测血压。有关模型及其推导方式的更多信息，请访问[http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html](http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html)。
- en: 'We can use the `systolic_bp()` function with all four arguments, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有所有四个参数的`systolic_bp()`函数，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A male person with a BMI of 25, age 50, and no previous treatment will likely
    have a blood pressure of 116\. The second example shows a similar woman with a
    history of treatment who will likely have a blood pressure of 121.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个BMI为25、年龄为50、没有先前治疗历史的男性可能会有116的血压。第二个例子展示了一个类似的女性，她有治疗史，可能会有121的血压。
- en: 'Because we''ve used the `@curry` decorator, we can create intermediate results
    that are similar to partially applied functions. Take a look at the following
    command snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`@curry`装饰器，我们可以创建类似于部分应用函数的中间结果。看一下以下命令片段：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding case, we evaluated the `systolic_bp(25, 50, 0)` method to create
    a curried function and assigned this to the variable `treatment`. The BMI, age,
    and gender values don't typically change for a given patient. We can now apply
    the new function, `treatment`, to the remaining argument to get different blood
    pressure expectations based on patient history.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们评估了`systolic_bp(25, 50, 0)`方法来创建一个柯里化函数，并将其分配给变量`treatment`。BMI、年龄和性别值通常不会改变。我们现在可以将新函数`treatment`应用于剩余的参数，根据患者的历史得到不同的血压期望。
- en: This is similar in some respects to the `functools.partial()` function. The
    important difference is that currying creates a function that can work in a variety
    of ways. The `functools.partial()` function creates a more specialized function
    that can only be used with the given set of bound values.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这与`functools.partial()`函数类似。重要的区别在于柯里化创建了一个可以以多种方式工作的函数。`functools.partial()`函数创建了一个更专门的函数，只能与给定的一组绑定值一起使用。
- en: 'Here''s an example of creating some additional curried functions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建一些额外柯里化函数的示例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a gender-based treatment function based on our initial model. We must
    provide gender and treatment values to get a final value from the model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于我们初始模型的基于性别的治疗函数。我们必须提供性别和治疗值才能从模型中得到最终值。
- en: Using curried higher-order functions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用柯里化的高阶函数
- en: 'While currying is simple to visualize using ordinary functions, the real value
    shows up when we apply currying to higher-order functions. In the ideal situation,
    the `functools.reduce()` function would be "curryable" so that we can do this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然柯里化在使用普通函数时很容易进行可视化，但当我们将柯里化应用于高阶函数时，其真正价值就显现出来了。在理想情况下，`functools.reduce()`函数将是“可柯里化的”，这样我们就可以这样做：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `reduce()` function, however, isn''t curryable by the `pymonad` library,
    so this doesn''t actually work. If we define our own `reduce()` function, however,
    we can then curry it as shown previously. Here''s an example of a home-brewed
    `reduce()` function that can be used as shown earlier:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`pymonad`库无法对`reduce()`函数进行柯里化，因此这实际上不起作用。然而，如果我们定义自己的`reduce()`函数，我们可以像之前展示的那样对其进行柯里化。以下是一个可以像之前展示的那样使用的自制`reduce()`函数的示例：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `myreduce()` function will behave like the built-in `reduce()` function.
    The `myreduce()` function works with an iterable or a sequence object. Given a
    sequence, we'll create an iterator; given an iterable object, we'll simply use
    it. We initialize the result with the first item in the iterator. We apply the
    function to the ongoing sum (or product) and each subsequent item.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`myreduce()`函数将表现得像内置的`reduce()`函数。`myreduce()`函数适用于可迭代对象或序列对象。给定一个序列，我们将创建一个迭代器；给定一个可迭代对象，我们将简单地使用它。我们将结果初始化为迭代器中的第一项。我们将函数应用于正在进行的总和（或乘积）和每个后续项。'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's also possible to wrap the built-in `reduce()` function to create a curryable
    version. That's only two lines of code; an exercise left for you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以包装内置的`reduce()`函数以创建一个可柯里化的版本。这只需要两行代码；这是留给你的一个练习。
- en: 'Since the `myreduce()` function is a curried function, we can now use it to
    create functions based on our higher-order function, `myreduce()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`myreduce()`函数是一个柯里化函数，我们现在可以使用它来基于我们的高阶函数`myreduce()`创建函数：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We defined our own version of the `sum()` function using the curried reduce
    applied to the `add` operator. We also defined our own version of the default
    `max()` function using a `lambda` object that picks the larger of two values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用柯里化的reduce应用于`add`运算符定义了我们自己版本的`sum()`函数。我们还使用`lambda`对象定义了我们自己版本的默认`max()`函数，它选择两个值中较大的一个。
- en: We can't easily create the more general form of the `max()` function this way,
    because currying is focused on positional parameters. Trying to use the `key=`
    keyword parameter adds too much complexity to make the technique work toward our
    overall goals of succinct and expressive functional programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式不能轻松地创建`max()`函数的更一般形式，因为柯里化侧重于位置参数。尝试使用`key=`关键字参数会增加太多复杂性，使得这种技术无法朝着我们简洁和表达式丰富的函数程序的总体目标发展。
- en: To create a more generalized version of the `max()` function, we need to step
    outside the `key=` keyword parameter paradigm that functions such as `max()`,
    `min()`, and `sorted()` rely on. We would have to accept the higher-order function
    as the first argument in the same way as `filter()`, `map()`, and `reduce()` functions
    do. We could also create our own library of more consistent higher-order curried
    functions. These functions would rely exclusively on positional parameters. The
    higher-order function would be provided first so that our own curried `max(function,
    iterable)` method would follow the pattern set by the `map()`, `filter()`, and
    `functools.reduce()` functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`max()`函数的更一般化版本，我们需要跳出`key=`关键字参数范例，这些函数如`max()`、`min()`和`sorted()`依赖于。我们必须接受高阶函数作为第一个参数，就像`filter()`、`map()`和`reduce()`函数一样。我们还可以创建我们自己的更一致的高阶柯里化函数库。这些函数将完全依赖于位置参数。高阶函数将首先提供，以便我们自己的柯里化`max(function,
    iterable)`方法遵循`map()`、`filter()`和`functools.reduce()`函数设定的模式。
- en: Currying the hard way
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 艰难的柯里化
- en: 'We can create curried functions manually, without using the decorator from
    the `pymonad` library; one way of doing this is to execute the following commands:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动创建柯里化函数，而不使用`pymonad`库中的装饰器；其中一种方法是执行以下命令：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This curries a function, ![Currying the hard way](graphics/B03652_14_05.jpg),
    into a function, `f(x)`, which returns a function. Conceptually, ![Currying the
    hard way](graphics/B03652_14_06.jpg). We then curried the intermediate function
    to create the `f1(y)` and `f2(z)` function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个函数柯里化成一个函数`f(x)`，它返回一个函数。在概念上，我们然后对中间函数进行柯里化，创建`f1(y)`和`f2(z)`函数。
- en: When we evaluate the `f(x)` function, we'll get a new function, `f1`, as a result.
    If additional arguments are provided, those arguments are passed to the `f1` function
    for evaluation, either resulting in a final value or another function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`f(x)`函数时，我们将得到一个新的函数`f1`作为结果。如果提供了额外的参数，这些参数将传递给`f1`函数进行评估，要么产生最终值，要么产生另一个函数。
- en: Clearly, this is potentially error-prone. It does, however, serve to define
    what currying really means and how it's implemented in Python.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这可能会出现错误。然而，它确实有助于定义柯里化的真正含义以及它在Python中的实现方式。
- en: Functional composition and the PyMonad multiplication operator
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合和PyMonad乘法运算符
- en: One of the significant values of curried functions is the ability to combine
    them via functional composition. We looked at functional composition in [Chapter
    5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions*, and
    [Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techniques*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数的一个重要价值在于能够通过函数组合来结合它们。我们在[第5章](ch05.html "第5章. 高阶函数")和[第11章](ch11.html
    "第11章. 装饰器设计技术")中讨论了函数组合，*高阶函数*和*装饰器设计技术*。
- en: When we've created a curried function, we can easily perform function composition
    to create a new, more complex curried function. In this case, the PyMonad package
    defines the `*` operator for composing two functions. To show how this works,
    we'll define two curried functions that we can compose. First, we'll define a
    function that computes the product, and then we'll define a function that computes
    a specialized range of values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个柯里化函数，我们可以轻松地执行函数组合，创建一个新的、更复杂的柯里化函数。在这种情况下，PyMonad包为组合两个函数定义了`*`运算符。为了展示这是如何工作的，我们将定义两个可以组合的柯里化函数。首先，我们将定义一个计算乘积的函数，然后我们将定义一个计算特定值范围的函数。
- en: 'Here''s our first function that computes the product:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们计算乘积的第一个函数：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is based on our curried `myreduce()` function that was defined previously.
    It uses the `operator.mul()` function to compute a "times-reduction" of an iterable:
    we can call a product a times-reduce of a sequence.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于我们之前定义的柯里化`myreduce()`函数。它使用`operator.mul()`函数来计算可迭代对象的“乘法减少”：我们可以称一个乘积为序列的a次减少。
- en: 'Here''s our second curried function that will produce a range of values:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第二个柯里化函数，它将产生一系列值：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The result of the `alt_range()` function will be even values or odd values.
    It will have only values up to (and including) `n`, if `n` is odd. If `n` is even,
    it will have only even values up to `n`. The sequences are important for implementing
    the semifactorial or double factorial function, ![Functional composition and the
    PyMonad multiplication operator](graphics/B03652_14_07.jpg).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`alt_range()`函数的结果将是偶数值或奇数值。如果`n`是奇数，它将只有值直到（包括）`n`。如果`n`是偶数，它将只有偶数值直到`n`。这些序列对于实现半阶乘或双阶乘函数很重要。'
- en: 'Here''s how we can combine the `prod()` and `alt_range()` functions into a
    new curried function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将 `prod()` 和 `alt_range()` 函数组合成一个新的柯里化函数：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The PyMonad `*` operator here combines two functions into a composite function,
    named `semi_fact`. The `alt_range()` function is applied to the arguments. Then,
    the `prod()` function is applied to the results of the `alt_range` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 PyMonad `*` 运算符将两个函数组合成一个名为 `semi_fact` 的复合函数。`alt_range()` 函数被应用到参数上。然后，`prod()`
    函数被应用到 `alt_range` 函数的结果上。
- en: 'By doing this manually in Python, we''re effectively creating a new `lambda`
    object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Python 中手动执行这些操作，实际上是在创建一个新的 `lambda` 对象：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The composition of curried functions involves somewhat less syntax than creating
    a new `lambda` object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数的组合涉及的语法比创建一个新的 `lambda` 对象要少一些。
- en: 'Ideally, we would like to use functional composition and curried functions
    like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望像这样使用函数组合和柯里化函数：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will define a version of the `sum()` function that works with infinite
    sequences, stopping the generation of values when the threshold had been met.
    This doesn't seem to work because the `pymonad` library doesn't seem to handle
    infinite iterables as well as it handles the internal `List` objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义一个可以处理无限序列的 `sum()` 函数版本，在达到阈值时停止生成值。这似乎行不通，因为 `pymonad` 库似乎无法像处理内部的 `List`
    对象一样处理无限可迭代对象。
- en: Functors and applicative functors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子和应用函子
- en: 'The idea of a functor is a functional representation of a piece of simple data.
    A functor version of the number 3.14 is a function of zero arguments that returns
    this value. Consider the following example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函子的概念是简单数据的函数表示。数字 3.14 的函子版本是一个零参数函数，返回这个值。考虑以下示例：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a zero-argument `lambda` object that has a simple value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有简单值的零参数 `lambda` 对象。
- en: When we apply a curried function to a functor, we're creating a new curried
    functor. This generalizes the idea of "apply a function to an argument to get
    value" by using functions to represent the arguments, the values, and the functions
    themselves.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将柯里化函数应用于函子时，我们正在创建一个新的柯里化函子。这通过使用函数来表示参数、值和函数本身来概括了“应用函数到参数以获得值”的概念。
- en: Once everything in our program is a function, then all processing is simply
    a variation on the theme of functional composition. The arguments and results
    of curried functions can be functors. At some point, we'll apply a `getValue()`
    method to a `functor` object to get a Python-friendly, simple type that we can
    use in uncurried code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的程序中的所有内容都是函数，那么所有处理都只是函数组合的变体。柯里化函数的参数和结果可以是函子。在某个时候，我们将对一个 `functor` 对象应用
    `getValue()` 方法，以获得一个可以在非柯里化代码中使用的 Python 友好的简单类型。
- en: Since all we've done is functional composition, no calculation needs to be done
    until we actually demand a value using the `getValue()` method. Instead of performing
    a lot of calculations, our program defines a complex object that can produce a
    value when requested. In principle, this composition can be optimized by a clever
    compiler or runtime system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所做的只是函数组合，直到我们使用 `getValue()` 方法要求值时才需要进行计算。我们的程序不是执行大量计算，而是定义了一个复杂的对象，可以在需要时产生值。原则上，这种组合可以通过聪明的编译器或运行时系统进行优化。
- en: When we apply a function to a `functor` object, we're going to use a method
    similar to `map()` that is implemented as the `*` operator. We can think of the
    `function * functor` or `map(function, functor)` methods as a way to understand
    the role a functor plays in an expression.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个函数应用到一个 `functor` 对象时，我们将使用类似于 `map()` 的方法，该方法实现为 `*` 运算符。我们可以将 `function
    * functor` 或 `map(function, functor)` 方法看作是理解函子在表达式中扮演的角色的一种方式。
- en: In order to work politely with functions that have multiple arguments, we'll
    use the `&` operator to build composite functors. We'll often see `functor & functor`
    method to build a `functor` object from a pair of functors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了礼貌地处理具有多个参数的函数，我们将使用 `&` 运算符构建复合函子。我们经常会看到 `functor & functor` 方法来构建一个 `functor`
    对象。
- en: We can wrap Python simple types with a subclass of the `Maybe` functor. The
    `Maybe` functor is interesting, because it gives us a way to deal gracefully with
    missing data. The approach we used in [Chapter 11](ch11.html "Chapter 11. Decorator
    Design Techniques"), *Decorator Design Techniques*, was to decorate built-in functions
    to make them `None` aware. The approach taken by the PyMonad library is to decorate
    the data so that it gracefully declines being operated on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `Maybe` 函子的子类来包装 Python 的简单类型。`Maybe` 函子很有趣，因为它为我们提供了一种优雅地处理缺失数据的方法。我们在[第11章](ch11.html
    "第11章。装饰器设计技术")中使用的方法是装饰内置函数，使其具有 `None` 意识。PyMonad 库采用的方法是装饰数据，使其能够优雅地拒绝被操作。
- en: 'There are two subclasses of the `Maybe` functor:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe` 函子有两个子类：'
- en: '`Nothing`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nothing`'
- en: '`Just(some simple value)`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Just(some simple value)`'
- en: We use `Nothing` as a stand-in for the simple Python value of `None`. This is
    how we represent missing data. We use `Just(some simple value)` to wrap all other
    Python objects. These functors are function-like representations of constant values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Nothing` 作为简单 Python 值 `None` 的替代。这是我们表示缺失数据的方式。我们使用 `Just(some simple
    value)` 来包装所有其他 Python 对象。这些函子是常量值的函数式表示。
- en: 'We can use a curried function with these `Maybe` objects to tolerate missing
    data gracefully. Here''s a short example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些 `Maybe` 对象的柯里化函数来优雅地处理缺失的数据。以下是一个简短的示例：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `*` operator is functional composition: we''re composing the `systolic_bp()`
    function with an argument composite. The `&` operator builds a composite functor
    that can be passed as an argument to a curried function of multiple arguments.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 运算符是函数组合：我们正在将 `systolic_bp()` 函数与一个参数复合。`&` 运算符构建一个复合函子，可以作为多参数柯里化函数的参数传递。'
- en: This shows us that we get an answer instead of a `TypeError` exception. This
    can be very handy when working with large, complex datasets in which data could
    be missing or invalid. It's much nicer than having to decorate all of our functions
    to make them `None` aware.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明，我们得到了一个答案，而不是`TypeError`异常。在处理大型复杂数据集时，数据可能缺失或无效，这非常方便。这比不得不装饰所有函数以使它们具有`None`感知性要好得多。
- en: This works nicely for curried functions. We can't operate on the `Maybe` functors
    in uncurried Python code as functors have very few methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于柯里化函数非常有效。我们不能在未柯里化的Python代码中操作`Maybe`函子，因为函子的方法非常少。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must use the `getValue()` method to extract the simple Python value for uncurried
    Python code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`getValue()`方法来提取未柯里化的Python代码的简单Python值。
- en: Using the lazy List() functor
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用惰性List()函子
- en: The `List()` functor can be confusing at first. It's extremely lazy, unlike
    Python's built-in `list` type. When we evaluate the built-in `list(range(10))`
    method, the `list()` function will evaluate the `range()` object to create a list
    with 10 items. The PyMonad `List()` functor, however, is too lazy to even do this
    evaluation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`List()`函子一开始可能会让人困惑。它非常懒惰，不像Python的内置`list`类型。当我们评估内置`list(range(10))`方法时，`list()`函数将评估`range()`对象以创建一个包含10个项目的列表。然而，PyMonad的`List()`函子太懒惰了，甚至不会进行这种评估。'
- en: 'Here''s the comparison:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比较：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `List()` functor did not evaluate the `range()` object, it just preserved
    it without being evaluated. The `PyMonad.List()` function is useful to collect
    functions without evaluating them. We can evaluate them later as required:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`List()`函子没有评估`range()`对象，它只是保留了它而没有被评估。`PyMonad.List()`函数用于收集函数而不对其进行评估。我们可以根据需要稍后对其进行评估：'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We created a lazy `List` object with a `range()` object. Then we extracted and
    evaluated a `range()` object at position `0` in that list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个带有`range()`对象的惰性`List`对象。然后我们提取并评估了该列表中位置`0`处的`range()`对象。
- en: A `List` object won't evaluate a generator function or `range()` object; it
    treats any iterable argument as a single iterator object. We can, however, use
    the `*` operator to expand the values of a generator or the `range()` object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`对象不会评估生成器函数或`range()`对象；它将任何可迭代参数视为单个迭代器对象。但是，我们可以使用`*`运算符来展开生成器或`range()`对象的值。'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that there are several meanings for `*` operator: it is the built-in mathematical
    times operator, the function composition operator defined by PyMonad, and the
    built-in modifier used when calling a function to bind a single sequence object
    as all of the positional parameters of a function. We''re going to use the third
    meaning of the `*` operator to assign a sequence to multiple positional parameters.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`*`运算符有几种含义：它是内置的数学乘法运算符，是由PyMonad定义的函数组合运算符，以及在调用函数时用于将单个序列对象绑定为函数的所有位置参数的内置修饰符。我们将使用`*`运算符的第三个含义来将一个序列分配给多个位置参数。
- en: Here's a curried version of the `range()` function. This has a lower bound of
    1 instead of 0\. It's handy for some mathematical work because it allows us to
    avoid the complexity of the positional arguments in the built-in `range()` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`range()`函数的柯里化版本。它的下限是1而不是0。对于某些数学工作很方便，因为它允许我们避免内置`range()`函数中的位置参数的复杂性。
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We simply wrapped the built-in `range()` function to make it curryable by the
    PyMonad package.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地包装了内置的`range()`函数，使其可以由PyMonad包进行柯里化。
- en: 'Since a `List` object is a functor, we can map functions to the `List` object.
    The function is applied to each item in the `List` object. Here''s an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`List`对象是一个函子，我们可以将函数映射到`List`对象。该函数应用于`List`对象中的每个项目。这是一个例子：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We defined a composite function, `fact()`, which was built from the `prod()`
    and `range1n()` functions shown previously. This is the factorial function, ![Using
    the lazy List() functor](graphics/B03652_14_16.jpg). We created a `List()` functor,
    `seq1`, which is a sequence of 20 values. We mapped the `fact()` function to the
    `seq1` functor, which created a sequence of factorial values, `f1`. We showed
    the first 10 of these values earlier.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个复合函数`fact()`，它是从先前显示的`prod()`和`range1n()`函数构建的。这是阶乘函数，![Using the lazy
    List() functor](graphics/B03652_14_16.jpg)。我们创建了一个`List()`函子`seq1`，它是一个包含20个值的序列。我们将`fact()`函数映射到`seq1`函子，从而创建了一个阶乘值的序列`f1`。我们之前展示了其中的前10个值。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is a similarity between the composition of functions and the composition
    of a function and a functor. Both `prod*range1n` and `fact*seq1` use functional
    composition: one combines things that are obviously functions, and the other combines
    a function and a functor.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的组合和函数与函子的组合之间存在相似之处。`prod*range1n`和`fact*seq1`都使用函数组合：一个组合明显是函数的东西，另一个组合是函数和函子。
- en: 'Here''s another little function that we''ll use to extend this example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个我们将用来扩展此示例的小函数：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This little `n21()` function does a simple computation. It''s curried, however,
    so we can apply it to a functor like a `List()` function. Here''s the next part
    of the preceding example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的`n21()`函数执行简单的计算。但是，它是柯里化的，因此我们可以将其应用于像`List()`函数这样的函子。这是前面示例的下一部分：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've defined a composite function from the `prod()` and `alt_range()` functions
    shown previously. The function `f2` is semifactorial or double factorial, ![Using
    the lazy List() functor](graphics/B03652_14_07.jpg). The value of the function
    `f2` is built by mapping our small `n21()` function applied to the `seq1` sequence.
    This creates a new sequence. We then applied the `semi_fact` function to this
    new sequence to create a sequence of ![Using the lazy List() functor](graphics/B03652_14_17.jpg)
    values that parallels the sequence of ![Using the lazy List() functor](graphics/B03652_14_16.jpg)
    values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从先前显示的`prod()`和`alt_range()`函数定义了一个复合函数。函数`f2`是半阶乘或双阶乘，![Using the lazy List()
    functor](graphics/B03652_14_07.jpg)。函数`f2`的值是通过将我们的小`n21()`函数应用于`seq1`序列来构建的。这创建了一个新序列。然后我们将`semi_fact`函数应用于这个新序列，以创建一个![Using
    the lazy List() functor](graphics/B03652_14_17.jpg)值的序列，与![Using the lazy List()
    functor](graphics/B03652_14_16.jpg)值的序列相对应。
- en: 'We can now map the `/` operator to the `map()` and `operator.truediv` parallel
    functors:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`/`运算符映射到`map()`和`operator.truediv`并行函子：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `map()` function will apply the given operator to both functors, yielding
    a sequence of fractions that we can add.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数将给定的运算符应用于两个函子，产生一系列分数，我们可以将它们相加。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `f1 & f2` method will create all combinations of values from the two `List`
    objects. This is an important feature of `List` objects: they readily enumerate
    all combinations allowing a simple algorithm to compute all alternatives and filter
    the alternatives for the proper subset. This is something we don''t want; that''s
    why we used the `map()` function instead of the `operator.truediv * f1 & f2` method.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1 & f2`方法将创建两个`List`对象的所有值的组合。这是`List`对象的一个重要特性：它们可以很容易地枚举所有的组合，允许一个简单的算法计算所有的替代方案，并过滤适当的子集。这是我们不想要的；这就是为什么我们使用`map()`函数而不是`operator.truediv
    * f1 & f2`方法。'
- en: 'We defined a fairly complex calculation using a few functional composition
    techniques and a functor class definition. Here''s the full definition for this
    calculation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些函数组合技术和一个函子类定义来定义了一个相当复杂的计算。这是这个计算的完整定义：
- en: '![Using the lazy List() functor](graphics/B03652_14_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![使用惰性List()函子](graphics/B03652_14_08.jpg)'
- en: Ideally, we prefer not to use a fixed sized `List` object. We'd prefer to have
    a lazy and potentially infinite sequence of integer values. We could then use
    a curried version of `sum()` and `takewhile()` functions to find the sum of values
    in the sequence until the values are too small to contribute to the result. This
    would require an even lazier version of the `List()` object that could work with
    the `itertools.counter()` function. We don't have this potentially infinite list
    in PyMonad 1.3; we're limited to a fixed sized `List()` object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们不希望使用固定大小的`List`对象。我们更希望有一个惰性的、潜在无限的整数值序列。然后我们可以使用`sum()`和`takewhile()`函数的柯里化版本来找到序列中值的和，直到这些值对结果没有贡献。这将需要一个更懒惰的`List()`对象的版本，它可以与`itertools.counter()`函数一起使用。在PyMonad
    1.3中，我们没有这个潜在无限的列表；我们只能使用固定大小的`List()`对象。
- en: Monad concepts, the bind() function and the Binary Right Shift operator
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子概念、bind()函数和二进制右移运算符
- en: 'The name of the PyMonad library comes from the functional programming concept
    of a **monad**, a function that has a strict order. The underlying assumption
    behind much functional programming is that functional evaluation is liberal: it
    can be optimized or rearranged as necessary. A monad provides an exception that
    imposes a strict left-to-right ordering.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad库的名称来自函数式编程概念中的**单子**，即具有严格顺序的函数。函数式编程的基本假设是函数求值是自由的：它可以根据需要进行优化或重新排列。单子提供了一个例外，强加了严格的从左到右的顺序。
- en: Python, as we have seen, is strict. It doesn't require monads. We can, however,
    still apply the concept in places where it can help clarify a complex algorithm.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python是严格的。它不需要单子。然而，在可以帮助澄清复杂算法的地方，我们仍然可以应用这个概念。
- en: 'The technology for imposing strict evaluation is a binding between a monad
    and a function that will return a monad. A *flat* expression will become nested
    bindings that can''t be reordered by an optimizing compiler. The `bind()` function
    is mapped to the `>>` operator, allowing us to write expressions like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 强制求值的技术是单子和将返回一个单子的函数之间的绑定。一个*扁平*表达式将变成嵌套的绑定，不能被优化编译器重新排序。`bind()`函数映射到`>>`运算符，允许我们编写这样的表达式：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding expression would be converted to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式将转换为以下形式：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `bind()` functions assure that a strict left-to-right evaluation is imposed
    on this expression when it's evaluated. Also, note that the preceding expression
    is an example of functional composition. When we create a monad with the `>>`
    operator, we're creating a complex object that will be evaluated when we finally
    use the `getValue()` method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`函数确保在对这个表达式进行求值时施加了严格的从左到右的顺序。另外，注意前面的表达式是函数组合的一个例子。当我们使用`>>`运算符创建一个单子时，我们正在创建一个复杂的对象，当我们最终使用`getValue()`方法时，它将被求值。'
- en: The `Just()` subclass is required to create a simple monad compatible object
    that wraps a simple Python object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Just()`子类用于创建一个简单的单子兼容对象，它包装了一个简单的Python对象。'
- en: The monad concept is central to expressing a strict evaluation order—in a language
    that's heavily optimized and lenient. Python doesn't require a monad because it
    uses left-to-right strict evaluation. This makes the monad difficult to demonstrate
    because it doesn't really do something completely novel in a Python context. Indeed,
    the monad redundantly states the typical strict rules that Python follows.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 单子概念对于表达严格的求值顺序是至关重要的——在一个经过高度优化和宽松的语言中。Python不需要单子，因为它使用从左到右的严格求值。这使得单子很难展示，因为在Python环境中它并没有真正做一些全新的事情。事实上，单子多余地陈述了Python遵循的典型严格规则。
- en: In other languages, such as Haskell, a monad is crucial for file input and output
    where strict ordering is required. Python's imperative mode is much like a Haskell
    `do` block, which has an implicit Haskell `>>=` operator to force the statements
    to be evaluated in order. (PyMonad uses the `bind()` function and the `>>` operator
    for Haskell's `>>=` operation.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，比如Haskell，单子对于需要严格顺序的文件输入和输出至关重要。Python的命令式模式很像Haskell的`do`块，它有一个隐式的Haskell
    `>>=`运算符来强制语句按顺序求值。（PyMonad使用`bind()`函数和Haskell的`>>`运算符来执行Haskell的`>>=`操作。）
- en: Implementing simulation with monads
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单子实现模拟
- en: 'Monads are expected to pass through a kind of "pipeline": a monad will be passed
    as an argument to a function and a similar monad will be returned as the value
    of the function. The functions must be designed to accept and return similar structures.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 单子被期望通过一种“管道”传递：一个单子将作为参数传递给一个函数，类似的单子将作为函数的值返回。这些函数必须设计为接受和返回类似的结构。
- en: We'll look at a simple pipeline that can be used for simulation of a process.
    This kind of simulation may be a formal part of some Monte Carlo simulation. We'll
    take the Monte Carlo simulation literally and simulate a casino dice game, Craps.
    This involves what might be thought of as stateful rules for a fairly complex
    simulation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下一个简单的流水线，用于模拟一个过程。这种模拟可能是蒙特卡洛模拟的一个正式部分。我们将直接进行蒙特卡洛模拟，并模拟一个赌场骰子游戏——Craps。这涉及到对相当复杂的模拟进行状态规则的模拟。
- en: There's a lot of very strange gambling terminology involved. We can't provide
    much background about the various buzzwords involved. In some cases, the origins
    are lost in history.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及了很多非常奇怪的赌博术语。我们无法提供有关各种术语的背景信息。在某些情况下，这些术语的起源已经迷失在历史中。
- en: 'Craps involves someone rolling the dice (a shooter) and additional bettors.
    The game works like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Craps涉及有人掷骰子（射击者）和额外的赌徒。游戏的进行方式如下：
- en: 'The first roll is called a *come out* roll. There are three conditions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次投掷被称为“come out”投掷。有三种情况：
- en: If the dice total is 7 or 11, the shooter wins. Anyone betting on the *pass*
    line will be paid off as a winner, and all other bets lose. The game is over,
    and the shooter can play again.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果骰子总数为7或11，则射击者获胜。任何在“pass”线上下注的人都将被支付为赢家，而所有其他赌注都将输掉。游戏结束，射击者可以再玩一次。
- en: If the dice total is 2, 3, or 12, the shooter loses. Anyone betting on the *don't
    pass* line will win, and all other bets lose. The game is over, and the shooter
    must pass the dice to another shooter.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果骰子总数为2、3或12，射击者输掉。任何在“don't pass”线上下注的人都会赢，而所有其他赌注都会输掉。游戏结束，射击者必须将骰子传递给另一个射击者。
- en: Any other total (that is, 4, 5, 6, 8, 9, or 10) establishes a *point*. The game
    changes state from the *come out* roll to the *point* roll. The game continues.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何其他总数（即4、5、6、8、9或10）都会建立一个“point”。游戏从“come out”投掷状态转变为“point”投掷状态。游戏继续进行。
- en: 'If a point was established, each *point* roll is evaluated with three conditions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经建立了一个点，每个“point”投掷都会根据三个条件进行评估：
- en: If the dice total is 7, the shooter loses. Indeed, almost all bets are losers
    except for don't pass bets and a special proposition bet. Since the shooter lost,
    the dice are passed to another shooter.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果骰子总数为7，射击者输掉。实际上，几乎所有的赌注都是输家，除了“don't pass”赌注和一个特殊的提议赌注。由于射击者输了，骰子被传递给另一个射击者。
- en: If the dice totals the original point, the shooter wins. Anyone betting on the
    pass line will be paid off as a winner, and all other bets lose. The game is over,
    and the shooter can play again.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果骰子总数等于最初的点数，射击者获胜。任何在pass线上下注的人都将被支付为赢家，而所有其他赌注都将输掉。游戏结束，射击者可以再玩一次。
- en: Any other total continues the game with no resolution.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他总数都会使游戏继续进行，没有解决。
- en: The rules involve a kind of state change. We can look at this as a sequence
    of operations rather than a state change. There's one function that must be used
    first. Another recursive function is used after that. In this way, it fits the
    monad design pattern nicely.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 规则涉及一种状态变化。我们可以将其视为一系列操作，而不是状态变化。有一个必须首先使用的函数。之后使用另一个递归函数。这样，它很好地符合单子设计模式。
- en: As a practical matter, a casino allows numerous fairly complex side bets during
    the game. We can evaluate those separately from the essential rules of the game.
    Many of those bets (the propositions, field bets, and buying a number) are bets
    a player simply makes during the *point roll* phase of the game. There's an additional
    *come* and *don't come* pair of bets that establishes a point-within-a-point nested
    game. We'll stick the the basic outline of the game for the following example.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，赌场在游戏过程中允许进行许多相当复杂的副注。我们可以将这些与游戏的基本规则分开进行评估。其中许多赌注（提议、场地赌注和购买数字）是玩家在游戏的“point
    roll”阶段简单下注的赌注。还有一个额外的“come”和“don't come”一对赌注，建立了一个嵌套游戏中的点。我们将在以下示例中坚持游戏的基本轮廓。
- en: 'We''ll need a source of random numbers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个随机数源：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding function will generate a pair of dice for us.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将为我们生成一对骰子。
- en: 'Here''s our expectation from the overall game:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们对整个游戏的期望：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We create an initial monad, `Just(("",0, []))`, to define the essential type
    we're going to work with. A game will produce a three tuple with an outcome, a
    point, and a sequence of rolls. Initially, it's a default three tuple to define
    the type we're working with.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个初始单子，“Just(("",0, []))”，来定义我们要处理的基本类型。游戏将产生一个三元组，其中包含结果、点数和一系列投掷。最初，它是一个默认的三元组，用于定义我们要处理的类型。
- en: We pass this monad to two other functions. This will create a resulting monad,
    `outcome`, with the results of the game. We used the `>>` operator to connect
    the functions in the specific order they must be executed. In an optimizing language,
    this will prevent the expression from being rearranged.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个单子传递给另外两个函数。这将创建一个结果单子，“outcome”，其中包含游戏的结果。我们使用“>>”运算符按特定顺序连接函数，以便它们按顺序执行。在优化语言中，这将防止表达式被重新排列。
- en: We get the value of the monad at the end using the `getValue()` method. Since
    the monad objects are lazy, this request is what triggers the evaluation of the
    various monads to create the required output.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“getValue()”方法在最后获取单子的值。由于单子对象是惰性的，这个请求会触发对各种单子的评估，以创建所需的输出。
- en: The `come_out_roll()` function has the `rng()` function curried as the first
    argument. The monad will become the second argument to this function. The `come_out_roll()`
    function can roll the dice and apply the come out rules to determine if we have
    a win, a loss, or a point.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “come_out_roll()”函数将“rng()”函数作为第一个参数柯里化。单子将成为这个函数的第二个参数。“come_out_roll()”函数可以掷骰子，并应用开局规则来确定我们是赢了、输了还是建立了一个点。
- en: The `point_roll()` function also has the `rng()` function curried as the first
    argument. The monad will become the second argument. The `point_roll()` function
    can then roll the dice to see if the bet is resolved. If the bet is unresolved,
    this function will operate recursively to continue looking for resolution.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`point_roll()`函数也将`rng()`函数作为第一个参数柯里化。单子将成为第二个参数。然后`point_roll()`函数可以掷骰子来查看赌注是否解决。如果赌注没有解决，这个函数将递归操作继续寻找解决方案。'
- en: 'The `come_out_roll()` function looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`come_out_roll()`函数看起来像这样：'
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We rolled the dice once to determine if we have a first-roll win, loss, or point.
    We return an appropriate monad value that includes the outcome, a point value,
    and the roll of the dice. The point values for an immediate win and immediate
    loss aren't really meaningful. We could sensibly return a `0` here, since no point
    was really established.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们掷骰子一次，以确定我们是首次投掷赢，输，还是点数。我们返回一个适当的单子值，其中包括结果，点数值和骰子的投掷。立即赢得和立即输掉的点数值并不真正有意义。我们可以合理地在这里返回`0`，因为实际上并没有建立点数。
- en: 'The `point_roll()` function looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`point_roll()`函数看起来像这样：'
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We decomposed the `status` monad into the three individual values of the tuple.
    We could have used small `lambda` objects to extract the first, second, and third
    values. We could also have used the `operator.itemgetter()` function to extract
    the tuples' items. Instead, we used multiple assignment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`status`单子分解为元组的三个单独值。我们可以使用小的`lambda`对象来提取第一个，第二个和第三个值。我们也可以使用`operator.itemgetter()`函数来提取元组的项目。相反，我们使用了多重赋值。
- en: If a point was not established, the previous state will be "win" or "lose".
    The game was resolved in a single throw, and this function simply returns the
    `status` monad.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有建立点数，先前的状态将是“赢”或“输”。游戏在一次投掷中解决，这个函数只是返回`status`单子。
- en: If a point was established, the dice are rolled and rules applied to the new
    roll. If roll is 7, the game is a loser and a final monad is returned. If the
    roll is the point, the game is a winner and the appropriate monad is returned.
    Otherwise, a slightly revised monad is passed to the `point_roll()` function.
    The revised `status` monad includes this roll in the history of rolls.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果建立了一个点数，就会掷骰子并应用规则到新的投掷。如果投掷是7，游戏就输了，并返回最终的单子。如果投掷是点数，游戏就赢了，并返回适当的单子。否则，一个稍微修改的单子被传递给`point_roll()`函数。修改后的`status`单子包括这次投掷在投掷历史中。
- en: 'A typical output looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的输出看起来像这样：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The final monad has a string that shows the outcome. It has the point that was
    established and the sequence of dice rolls. Each outcome has a specific payout
    that we can use to determine the overall fluctuation in the bettor's stake.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的单子有一个显示结果的字符串。它有建立的点数和骰子投掷的顺序。每个结果都有一个特定的赔付，我们可以用来确定投注者赌注的总波动。
- en: We can use simulation to examine different betting strategies. We might be searching
    for a way to defeat any house edge built into the game.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模拟来检查不同的投注策略。我们可能正在寻找一种方法来击败游戏内置的庄家优势。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附注
- en: There's a small asymmetry in the basic rules of the game. Having 11 as an immediate
    winner is balanced by having 3 as an immediate loser. The fact that 2 and 12 are
    also losers is the basis of the house's edge of 5.5 percent (*1/18 = 5.5*) in
    this game. The idea is to determine which of the additional betting opportunities
    will dilute this edge.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏基本规则存在一些小的不对称性。11作为立即赢家与3作为立即输家平衡。2和12也是输家的事实是这个游戏中庄家优势的基础，为5.5%（*1/18 = 5.5*）。想法是确定哪些额外的投注机会会削弱这个优势。
- en: A great deal of clever Monte Carlo simulation can be built with a few simple,
    functional programming design techniques. The monad, in particular, can help structure
    these kinds of calculations when there are complex orders or internal states.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的、功能性的设计技术可以构建出许多巧妙的蒙特卡洛模拟。特别是单子可以帮助结构化这些类型的计算，当存在复杂的订单或内部状态时。
- en: Additional PyMonad features
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加的PyMonad功能
- en: One of the other features of PyMonad is the confusingly named **monoid**. This
    comes directly from mathematics and it refers to a group of data elements that
    have an operator, an identity element, and the group is closed with respect to
    that operator. When we think of natural numbers, the `add` operator, and an identity
    element `0`, this is a proper monoid. For positive integers, with an operator
    `*`, and an identity value of `1`, we also have a monoid; strings using `|` as
    an operator and an empty string as an identity element also qualifies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad的另一个特性是令人困惑地命名为**monoid**。这直接来自数学，它指的是一组具有运算符、单位元素，并且对于该运算符是封闭的数据元素。当我们考虑自然数、`add`运算符和单位元素`0`时，这是一个合适的单子。对于正整数，使用运算符`*`和单位值`1`，我们也有一个单子；使用`|`作为运算符和空字符串作为单位元素的字符串也符合条件。
- en: PyMonad includes a number of predefined monoid classes. We can extend this to
    add our own `monoid` class. The intent is to limit a compiler to certain kinds
    of optimizations. We can also use the monoid class to create data structures which
    accumulate a complex value, perhaps including a history of previous operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad包括许多预定义的单子类。我们可以扩展这个来添加我们自己的`monoid`类。目的是限制编译器对某些类型的优化。我们还可以使用单子类来创建累积复杂值的数据结构，可能包括以前操作的历史。
- en: Much of this provides insight into functional programming. To paraphrase the
    documentation, this is an easy way to learn about functional programming in, perhaps,
    a slightly more forgiving environment. Rather than learning an entire language
    and toolset to compile and run functional programs, we can just experiment with
    interactive Python.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其中许多内容提供了对函数式编程的见解。总结文档，这是一个学习函数式编程的简单方法，在可能稍微宽容的环境中。与其学习整个语言和工具集来编译和运行函数式程序，我们可以只是用交互式Python进行实验。
- en: Pragmatically, we don't need too many of these features because Python is already
    stateful and offers strict evaluation of expressions. There's no practical reason
    to introduce stateful objects in Python, or strictly-ordered evaluation. We can
    write useful programs in Python by mixing functional concepts with Python's imperative
    implementation. For that reason, we won't delve any more deeply into PyMonad.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从实用的角度来看，我们不需要太多这些功能，因为Python已经是有状态的，并且提供了表达式的严格评估。在Python中引入有状态的对象或严格排序的评估没有实际理由。我们可以通过将函数式概念与Python的命令式实现相结合来编写有用的程序。因此，我们不会深入研究PyMonad。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how we can use the PyMonad library to express
    some functional programming concepts directly in Python. The module shows many
    important functional programming techniques.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何使用PyMonad库直接在Python中表达一些函数式编程概念。该模块展示了许多重要的函数式编程技术。
- en: We looked at the idea of currying, a function that allows combinations of arguments
    to be applied to create new functions. Currying a function also allows us to use
    functional composition to create more complex functions from simpler pieces. We
    looked at functors that wrap simple data objects to make them into functions which
    can also be used with functional composition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了柯里化的概念，这是一种允许组合参数的函数，以创建新函数的方法。柯里化函数还允许我们使用函数组合，从简单的部分创建更复杂的函数。我们看了一下函子，它们包装简单的数据对象，使它们成为可以与函数组合一起使用的函数。
- en: Monads are a way to impose a strict evaluation order when working with an optimizing
    compiler and lazy evaluation rules. In Python, we don't have a good use case for
    monads, because Python is an imperative programming language under the hood. In
    some cases, imperative Python may be more expressive and succinct than a monad
    construction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一种在使用优化编译器和惰性评估规则时强加严格评估顺序的方法。在Python中，我们没有单子的一个很好的用例，因为Python在底层是一种命令式编程语言。在某些情况下，命令式Python可能比单子构造更具表现力和简洁。
- en: In the next chapter, we'll look at how we can apply functional programming techniques
    to build web services applications. The idea of HTTP could be summarized as `response
    = httpd(request)`. Ideally, HTTP is stateless, making it a perfect match for functional
    design. However, most web sites will maintain state, using cookies to track session
    state.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何应用函数式编程技术来构建Web服务应用程序。HTTP的概念可以总结为`response = httpd(request)`。理想情况下，HTTP是无状态的，这使其与函数式设计完美匹配。然而，大多数网站将保持状态，使用cookie来跟踪会话状态。
